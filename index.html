<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=">


  <link rel="mask-icon" href="/images/logo.svg?v=" color="#222">














<meta property="og:type" content="website">
<meta property="og:title" content="Jason‘s Blog">
<meta property="og:url" content="https://jasonxqh.github.io/index.html">
<meta property="og:site_name" content="Jason‘s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '',
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    fancybox: false,
    tabs: ,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: 'undefined',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>







  <title>Jason‘s Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', '[object Object]', 'auto');
  ga('send', 'pageview');
</script>





<meta name="generator" content="Hexo 4.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">
  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
<a href="https://github.com/JasonXQH/JasonXQH.github.io" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jason‘s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/%20" rel="section">
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2025/04/10/JavaToKotlin%E9%87%8D%E6%9E%84%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/10/JavaToKotlin%E9%87%8D%E6%9E%84%E6%96%B9%E6%A1%88/" itemprop="url">JavaToKotlin重构方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2025-04-10T13:31:48+08:00">
                2025-04-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2025-04-10T13:38:25+08:00">
                2025-04-10
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="11-从方法到属性"><a href="#11-从方法到属性" class="headerlink" title="11-从方法到属性"></a>11-从方法到属性</h2>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2025/04/09/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%BF%83%E5%BE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/04/09/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%BF%83%E5%BE%97/" itemprop="url">项目开发心得</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2025-04-09T22:30:13+08:00">
                2025-04-09
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2025-04-10T18:48:45+08:00">
                2025-04-10
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="项目开发心得"><a href="#项目开发心得" class="headerlink" title="项目开发心得"></a>项目开发心得</h1><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><ul>
<li><a href="obsidian://open?vault=QihangXu&#39;s%20Repo&amp;file=think%2Fgit">查看该文档</a></li>
<li>每天早上上班的时候，需要跟master保持一致。否则很可能会conflict, SOP 如下<ul>
<li>git checkout master</li>
<li>git pull</li>
<li>git checkout xxx</li>
<li>git merge master</li>
<li>git push -u origin xxx</li>
</ul>
</li>
</ul>
<h2 id="数据库篇"><a href="#数据库篇" class="headerlink" title="数据库篇"></a>数据库篇</h2><ul>
<li>postgres一般使用TEXT而不是用VARCHAR</li>
<li>Primary Key就不需要NOT NULL 了</li>
<li>对于一些字段，我们要求他可以为空，但是不能为空字符串。此时null 表示“没有提供数据”，而空字符串则被认为是无效或错误的输入。比如一些枚举类，它们一旦有值，通常需要用于后续业务逻辑或者系统校验，如果保存了空字符串，可能引发逻辑错误或数据不一致。<ul>
<li><code>access_token TEXT CHECK (access_token IS NULL OR access_token &lt;&gt; &#39;&#39;)</code></li>
</ul>
</li>
<li>对于其他一些字段，我们会要求它不能为空，但是可以为字符串。比如默认配置项、必要文本输入等 <code>seller_id BIGINT NOT NULL</code></li>
<li>对于一些Unique的值 ，我们要在创建数据表格的时候，就将其约束起来，不要等到后续再去维护。<strong>要向上推</strong><ul>
<li>比如<code>CREATE UNIQUE INDEX sellers_seller_id_store_id_idx ON public.sellers (seller_id);</code></li>
<li>要知道数据库是最后一层保障，很多判断应该在应用层做判断，如果数据库报错一定是代码写错了。</li>
</ul>
</li>
<li>时间格式：<code>expires_at TIMESTAMP WITH TIME ZONE = TIMESTAMPTZ</code><h2 id="OpenAPI"><a href="#OpenAPI" class="headerlink" title="OpenAPI"></a>OpenAPI</h2><h3 id="OpenAPI-与数据库表类型匹配"><a href="#OpenAPI-与数据库表类型匹配" class="headerlink" title="OpenAPI 与数据库表类型匹配"></a>OpenAPI 与数据库表类型匹配</h3><a href="obsidian://open?vault=obsidian&amp;file=%E9%A1%B9%E7%9B%AEsop%2F04-mig25codegen">mig25-codegen的下载和基本操作</a><br>我们要编写符合mig25的<code>openapi.yaml</code> , 最好是要将openapi中定义的component中的字段和数据库表中的字段匹配起来。</li>
<li>比如数据库表中字段类型为long，在openapi中可以这样设置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">type:</span> <span class="string">integer</span>  </span><br><span class="line"><span class="attr">format:</span> <span class="string">int64</span>  </span><br><span class="line"><span class="attr">example:</span> <span class="number">1052101482</span></span><br></pre></td></tr></table></figure></li>
<li>比如数据库表中的字段类型是UUID，在openapi中可以这样设置<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">leyan_seller_id:</span>  </span><br><span class="line">  <span class="attr">type:</span> <span class="string">string</span>  </span><br><span class="line">  <span class="attr">format:</span> <span class="string">uuid</span>  </span><br><span class="line">  <span class="attr">example:</span> <span class="string">'44cfdf24-6a22-4ba8-dedc-55e62aeadd85'</span></span><br></pre></td></tr></table></figure>
<h3 id="OpenAPI-component-设置-DTO-TO-VO"><a href="#OpenAPI-component-设置-DTO-TO-VO" class="headerlink" title="OpenAPI component 设置 DTO TO VO"></a>OpenAPI component 设置 DTO TO VO</h3>由于我们使用了<code>mig25-codegen</code> 这个插件，因此他可以根据OpenAPI的定义生成出相关VO和DTO的转换逻辑。这样就方便了对请求格式和返回格式的处理。<br>假设我们的 Model 名称为<code>Seller</code>，可以通过它对数据库进行增删改查的工作。<h4 id="request"><a href="#request" class="headerlink" title="request"></a>request</h4>那么当<code>requestBody</code>  中传入了json格式的seller，如何将其直接转换为可以操控数据库的类型Seller？<br>首先需要在OpenAPI的component中找到定义的seller,然后添加<code>x-request</code> 属性<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">SubsystemSeller:</span>  </span><br><span class="line">  <span class="attr">type:</span> <span class="string">object</span>  </span><br><span class="line">  <span class="attr">x-response:</span> <span class="string">Seller</span>  </span><br><span class="line">  <span class="attr">x-request:</span> <span class="string">Seller</span></span><br></pre></td></tr></table></figure>
然后在方法中：<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> seller = Seller.newRecord(requestBody)</span><br></pre></td></tr></table></figure>
如果说OpenAPI中定义的某些component和Seller Model不完全对应，只有其中某些字段，那么也可以用这种方法：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">SubsystemToken:</span>  </span><br><span class="line">  <span class="attr">type:</span> <span class="string">object</span>  </span><br><span class="line">  <span class="attr">x-request:</span> <span class="string">Seller</span>  </span><br><span class="line">  <span class="attr">required:</span> <span class="string">[</span> <span class="string">access_token,</span> <span class="string">app_name</span> <span class="string">]</span></span><br></pre></td></tr></table></figure>
此时，假设传入的requestBody中包含了这个SubsystemToken，可以用<code>update</code> 来更新Seller Model实现更新操作。<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seller.update(requestBody.SubsystemToken)</span><br></pre></td></tr></table></figure>
当然，不管是那种方式，最后都需要 <code>seller.store()</code> 将其应用到数据库中。<h4 id="response"><a href="#response" class="headerlink" title="response"></a>response</h4>同样的，当我从数据库中拿到了一些记录，但他们是Model类型，如何将其以OpenAPI规定的格式传出？<br>此时我们可以定义<code>x-response</code> ，正如上面所说的那样。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val responses &#x3D; loadedSellerOrders.map &#123; it.includes(fields).toResponse(OpenApiSellerOrder) &#125;</span><br></pre></td></tr></table></figure>
对于数据库中处理得到的loadedSellerOrders,对其执行toResponse操作转换成OpenAPI所定义的格式<h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2>我们的目标是</li>
<li>[!] 尽量不去手动的做VO和DTO之间的转换，而是交给codegen去完成。</li>
<li>[!] 尽量使用codegen生成的api进行操作，如<code>find</code>,<code>findBy</code>,<code>update</code>,<code>store</code>,<code>delete</code>等。代码要包含两方面：1. 要做什么 2.怎么去做。好的代码只体现1，2对developer是透明的，尽量交给框架去完成。<h3 id="Exception-Mapper"><a href="#Exception-Mapper" class="headerlink" title="Exception Mapper"></a>Exception Mapper</h3>对于很多方法，可能都会抛出同一类错误，比如说<code>NOT FOUND</code> ，那么我们有没有什么合适的方法去同意管理起来，而不是在每个方法中写一模一样的错误处理方法？<br>这时我们就需要用到<code>@ServerExceptionMapper</code> 注解，我们在Controller类中配置，统一处理特定类型的错误，比如说：<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Path(<span class="meta-string">"/superbook/subsystem"</span>)</span>  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperbookController</span> </span>&#123;  </span><br><span class="line">  <span class="meta">@ServerExceptionMapper</span>  </span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">handle</span><span class="params">(e: <span class="type">NoDataFoundException</span>)</span></span>: Response &#123;  </span><br><span class="line">    <span class="comment">// 返回 JSON 格式的错误信息  </span></span><br><span class="line">    <span class="keyword">val</span> body =  </span><br><span class="line">      mapOf(  </span><br><span class="line">        <span class="string">"code"</span> to <span class="number">404</span>,  </span><br><span class="line">        <span class="string">"error"</span> to <span class="string">"NOT_FOUND"</span>,  </span><br><span class="line">        <span class="string">"message"</span> to (e.message ?: <span class="string">"Resource not found"</span>),  </span><br><span class="line">      )  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> Response  </span><br><span class="line">      .status(Response.Status.NOT_FOUND)  </span><br><span class="line">      .type(MediaType.APPLICATION_JSON)  </span><br><span class="line">      .entity(body)  </span><br><span class="line">      .build()  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="mig25-codegen-find和findBy"><a href="#mig25-codegen-find和findBy" class="headerlink" title="mig25-codegen : find和findBy"></a>mig25-codegen : find和findBy</h3>当我们使用mig25生成的models的时候，可以使用它提供的API和数据库进行交互。那么<code>find</code>和<code>findBy</code> 有什么区别？<br>简单来说，<code>find</code> 只能根据主键进行查询，所以直接传入主键值即可。<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Seller.find(updatedFields.leyanSellerId)</span><br></pre></td></tr></table></figure>
但是<code>findBy</code> 的参数是一个条件，可以查询任意字段值<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Seller.findBy(  Seller.SELLERS.LEYAN_SELLER_ID.eq(installSystem.subsystemSeller.leyanSellerId),  </span><br><span class="line">)</span><br></pre></td></tr></table></figure>
此外，还有一个差别,我们看一下二者的底层实现：<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findBy</span><span class="params">(<span class="keyword">vararg</span> conditions: <span class="type">Condition</span>)</span></span> = <span class="keyword">where</span>(*conditions).fetchOne()  </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">find</span><span class="params">(value: <span class="type">T</span>)</span></span> = <span class="keyword">where</span>(pk.eq(value)).fetchSingle()</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><strong>fetchOne()</strong>：<ul>
<li>如果<strong>查询结果没有记录</strong>，返回 <strong>null</strong>。</li>
<li>如果查询结果返回多于一条记录，则抛出异常（例如 <code>NonUniqueResultException</code>）。    </li>
<li>适用于“可选”结果场景，即允许结果为空。</li>
</ul>
</li>
<li><strong>fetchSingle()</strong>：<ul>
<li>要求查询必须返回<strong>恰好一条记录</strong>。</li>
<li>如果查询<strong>结果为空，则抛出异常</strong>（例如 <code>NoDataFoundException</code> 或者其他与“没有数据”相关的异常）；如果结果超过一条，也会抛出异常。</li>
<li>用于预期必须存在一个记录的场景，并且希望在不存在时立即获得错误提示。<h3 id="Delete软删除"><a href="#Delete软删除" class="headerlink" title="Delete软删除"></a>Delete软删除</h3>在写delete方法的时候，通常使用软删除，将一些重要信息置空，而不是用<code>delete</code>将整行record删除。<h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><h3 id="用Assert包住错误"><a href="#用Assert包住错误" class="headerlink" title="用Assert包住错误"></a>用Assert包住错误</h3></li>
</ul>
</li>
</ul>
<p>对于更新、插入等方法的测试，在测试插入之后，需要绕过接口直接查数据库并Assert状态是否已经更新。而且<strong>需要Assert所有字段</strong>。这样比较容易发现bug，当我们发现bug的时候，需要写一个尽可能详细的test去把这个bug的边界给囊括住，这样可以更好的帮助修复。<br>如：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test enableSubsystem updates existing seller <span class="keyword">if</span> already exists`<span class="params">()</span></span> &#123;  </span><br><span class="line">  <span class="keyword">val</span> subsystemName = ... </span><br><span class="line">  <span class="comment">// 使用 fixture 中已存在的 sellerOne  val existingId = sellerOne.leyanSellerId!!  </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 构造示例请求体 InstallSystem  </span></span><br><span class="line">  <span class="keyword">val</span> subsystemInstallSystem =  ...</span><br><span class="line">  </span><br><span class="line">  Given &#123;  </span><br><span class="line">    ...</span><br><span class="line">  &#125; When &#123;  </span><br><span class="line">    ...</span><br><span class="line">  &#125; Then &#123;  </span><br><span class="line">    ...</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">//需要从数据库fetch出来注意比较</span></span><br><span class="line">  <span class="keyword">val</span> seller = Seller.find(existingId)  </span><br><span class="line">  </span><br><span class="line">  assertNotNull(seller, <span class="string">"Seller 应该存在"</span>)  </span><br><span class="line">  assertEquals(existingId, seller.leyanSellerId, <span class="string">"leyan_seller_id 应该匹配"</span>)  </span><br><span class="line">  assertEquals(<span class="number">1052101482</span>, seller.sellerId, <span class="string">"seller_id 应该匹配"</span>)  </span><br><span class="line">  assertEquals(<span class="number">425920014</span>, seller.storeId, <span class="string">"store_id 应该匹配"</span>)  </span><br><span class="line">  assertEquals(<span class="string">"updated_seller_nick"</span>, seller.sellerNick, <span class="string">"seller_nick 应该匹配"</span>)  </span><br><span class="line">  assertEquals(<span class="string">"更新后的店铺标题"</span>, seller.storeTitle, <span class="string">"store_title 应该匹配"</span>)  </span><br><span class="line">  assertEquals(<span class="string">"taobao"</span>, seller.platform, <span class="string">"platform 应该匹配"</span>)  </span><br><span class="line">  assertEquals(<span class="string">"5c4f37e8-2447-4dd6-b31e-9d678904b051"</span>, seller.organizationId.toString(), <span class="string">"organization_id 应该匹配"</span>)  </span><br><span class="line">  assertEquals(<span class="string">"淘宝"</span>, seller.sellerType, <span class="string">"seller_type 应该匹配"</span>)  </span><br><span class="line">  <span class="comment">// bugfix: 这里是框架性错误，第二次update失效，expected accessToken:"updated_access_token"  </span></span><br><span class="line">  assertEquals(<span class="string">"updated_access_token"</span>, seller.accessToken, <span class="string">"access_token 应该匹配"</span>)  </span><br><span class="line">  <span class="comment">// bugfix: 这里是框架性错误，第二次update失效，expected appName:"tb_lyzr"  </span></span><br><span class="line">  assertEquals(<span class="string">"tb_lyzr"</span>, seller.appName, <span class="string">"app_name 应该匹配"</span>)  </span><br><span class="line">  <span class="comment">// bugfix: 这里是框架性错误，第二次update失效，expected:"Instant.parse("2030-01-01T00:00:00Z") "  </span></span><br><span class="line">  assertEquals(Instant.parse(<span class="string">"2030-01-01T00:00:00Z"</span>), seller.expiresAt?.toInstant(), <span class="string">"expiresAt 应该匹配"</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="处理错误：Status-Message"><a href="#处理错误：Status-Message" class="headerlink" title="处理错误：Status + Message"></a>处理错误：Status + Message</h3><p>在Controller中，端口出错需要统一处理，比如需要请求的资源不存在，请求格式不对等。都可以使用quarkus提供的<code>ServerExceptionMapper</code> 注解,这里给出一些常用的</p>
<ul>
<li>如果接口是内部接口，那么返回信息可以简单一点，文字即可</li>
<li>如果接口是外部接口，有很多人需要用，那么返回信息需要更复杂，内容更细致</li>
<li>对于返回message，需要说明我要什么，但你给的是什么。可读性更强</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">请求资源不存在，用NoDataFoundException接收</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@ServerExceptionMapper</span>  </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">handle</span><span class="params">(e: <span class="type">NoDataFoundException</span>)</span></span>: Response &#123;  </span><br><span class="line">  <span class="comment">// 返回 JSON 格式的错误信息  </span></span><br><span class="line">  <span class="keyword">val</span> body =  </span><br><span class="line">    mapOf(  </span><br><span class="line">      <span class="string">"code"</span> to <span class="number">404</span>,  </span><br><span class="line">      <span class="string">"error"</span> to <span class="string">"NOT_FOUND"</span>,  </span><br><span class="line">      <span class="string">"message"</span> to (<span class="string">"The target leyan_seller_id does not exist in the database"</span>),  </span><br><span class="line">    )  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> Response  </span><br><span class="line">    .status(Response.Status.NOT_FOUND)  </span><br><span class="line">    .type(MediaType.APPLICATION_JSON)  </span><br><span class="line">    .entity(body)  </span><br><span class="line">    .build()  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">请求体json格式不对，用JsonMappingException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@ServerExceptionMapper</span>  </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">handle</span><span class="params">(e: <span class="type">JsonMappingException</span>)</span></span>: Response &#123;  </span><br><span class="line">  <span class="keyword">val</span> body =  </span><br><span class="line">    mapOf(  </span><br><span class="line">      <span class="string">"code"</span> to <span class="number">400</span>,  </span><br><span class="line">      <span class="string">"error"</span> to <span class="string">"BAD_REQUEST"</span>,  </span><br><span class="line">      <span class="string">"message"</span> to <span class="string">"Json Mapping Exception"</span>,  </span><br><span class="line">    )  </span><br><span class="line">  <span class="keyword">return</span> Response.status(Response.Status.BAD_REQUEST)  </span><br><span class="line">    .type(MediaType.APPLICATION_JSON)  </span><br><span class="line">    .entity(body)  </span><br><span class="line">    .build()  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">请求参数不符合限制条件，用ConstraintViolationException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">@ServerExceptionMapper</span>  </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">handle</span><span class="params">(e: <span class="type">ConstraintViolationException</span>)</span></span>: Response &#123;  </span><br><span class="line">  <span class="comment">// 构造自定义错误信息，你可以遍历 e.constraintViolations 获取详细信息  </span></span><br><span class="line">  <span class="keyword">val</span> errors =  </span><br><span class="line">    e.constraintViolations.map &#123; violation -&gt;  </span><br><span class="line">      mapOf(  </span><br><span class="line">        <span class="string">"field"</span> to violation.propertyPath.toString(),  </span><br><span class="line">      )  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">val</span> body =  </span><br><span class="line">    mapOf(  </span><br><span class="line">      <span class="string">"code"</span> to <span class="number">400</span>,  </span><br><span class="line">      <span class="string">"error"</span> to <span class="string">"BAD_REQUEST"</span>,  </span><br><span class="line">      <span class="string">"message"</span> to <span class="string">"Invalid Query Parameter"</span>,  </span><br><span class="line">      <span class="string">"violations"</span> to errors,  </span><br><span class="line">    )  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> Response.status(Response.Status.BAD_REQUEST)  </span><br><span class="line">    .type(MediaType.APPLICATION_JSON)  </span><br><span class="line">    .entity(body)  </span><br><span class="line">    .build()  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后比如我们进行了一个测试，返回404/400,我们不仅要判断这个状态码，还需要对返回值进行判断。比如说：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="function"><span class="keyword">fun</span> `test disableSubsystem returns 400 <span class="keyword">when</span> leyan_seller_id <span class="keyword">is</span> blank`<span class="params">()</span></span> &#123;  </span><br><span class="line"></span><br><span class="line">  When &#123;  </span><br><span class="line">    ..</span><br><span class="line">  &#125; Then &#123;  </span><br><span class="line">	<span class="comment">//判断状态</span></span><br><span class="line">    statusCode(<span class="number">400</span>)  </span><br><span class="line">    <span class="comment">//判断message</span></span><br><span class="line">    body(<span class="string">"message"</span>, equalTo(<span class="string">"Invalid Query Parameter"</span>))  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="bugfix"><a href="#bugfix" class="headerlink" title="bugfix"></a>bugfix</h2><p>此外，当发现bug的时候，我们如何上报，也是需要标准的处理方式<br>比如这里我发现了一个框架性的错误，无法解决。</p>
<ul>
<li>先在原来的分支编写 <strong>错误的、但是可以通过的测试</strong></li>
<li>再checkout一条 <code>bugfix</code> 分支，编写 <strong>正确的、但是无法通过的测试</strong></li>
<li>这样leader修改完之后，直接测试bugfix分支，通过以后，将bugfix分支merge到原先分支，就会得到<strong>正确的、且可以通过的测试</strong></li>
</ul>
<h3 id="对于时间的判断"><a href="#对于时间的判断" class="headerlink" title="对于时间的判断"></a>对于时间的判断</h3><p>对于时间戳，本地数据库和ci可能存在某些配置上的问题，导致存储的时间戳格式不一致。此时不要简单得用字符串判断是否相等。<br>可以用这样的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(Instant.parse(&quot;2030-01-01T00:00:00Z&quot;),</span><br><span class="line">seller.expiresAt?.toInstant(), &quot;expiresAt 应该匹配&quot;)</span><br></pre></td></tr></table></figure><br>来parse一下</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2025/03/07/%E5%9B%9E%E6%BA%AF%E5%89%AA%E6%9E%9D%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/03/07/%E5%9B%9E%E6%BA%AF%E5%89%AA%E6%9E%9D%E6%95%B4%E7%90%86/" itemprop="url">回溯剪枝整理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2025-03-07T09:36:31+08:00">
                2025-03-07
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2025-03-11T12:59:41+08:00">
                2025-03-11
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="回溯剪枝整理"><a href="#回溯剪枝整理" class="headerlink" title="回溯剪枝整理"></a>回溯剪枝整理</h1><p>参考文献：<a href="https://labuladong.online/algo/practice-in-action/partition-to-k-equal-sum-subsets/#%E4%BB%A5%E6%A1%B6%E7%9A%84%E8%A7%86%E8%A7%92" target="_blank" rel="noopener">https://labuladong.online/algo/practice-in-action/partition-to-k-equal-sum-subsets/#%E4%BB%A5%E6%A1%B6%E7%9A%84%E8%A7%86%E8%A7%92</a></p>
<p>这几天做了不少回溯的题目，虽然是暴力解法，但是其中涉及到球盒模型思维，如何高效剪枝的思维，都是很值得我们学习的。一些高效的剪枝操作，可以让代码的运行效率提高数十倍。因此所以我想整理一些常见的剪枝操作。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><a href="https://leetcode.cn/problems/find-minimum-time-to-finish-all-jobs/" target="_blank" rel="noopener">1723. 完成所有工作的最短时间</a></p>
<p>这一道是困难题，第一思路是用二分搜索来求最小的最大，最大的最小这种。然后我将数组排序去用二分搜索的框架带入。但是这样是做不出来的。因为之前如这种<a href="https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/" target="_blank" rel="noopener">1011. 在 D 天内送达包裹的能力</a> 题目中，都是必须按照给定的顺序来放到一个个桶中的，但在1723中并没有这个约束。</p>
<p>因此我还是选择暴力回溯。用球盒模型，每一个工人看做是一个桶，然后对于每一项工作，遍历桶，判断是否存放。</p>
<p>这里就遇到了第一个优化的点，就是排序，而且要逆序排列。为什么？这样较大的工作时间被先分配，可以更快地使得某个工人的工作时间达到较高值，从而更早地发现当前分配方案的最大工作时间是否已经超过当前最优解，从而提前剪枝，减少不必要的递归分支。</p>
<p>如果任务按照升序排列，那么在早期分支中，工人的工作时间累积得比较慢，可能需要更多任务才能超过最优解。这会导致<strong>必须深入递归后才能发现该分支无解</strong>，从而浪费了时间。而降序排序则能让无效分支在较浅层次就被剪除。</p>
<h2 id="等效状态判断"><a href="#等效状态判断" class="headerlink" title="等效状态判断"></a>等效状态判断</h2><h3 id="1723"><a href="#1723" class="headerlink" title="1723"></a>1723</h3><p>还是1723这道题，仅仅排序也是不够的还需要进一步剪枝。这也是对这道题提升最大的地方。也就是等效状态判断。在这道题目中，工人没有顺序，因此先给哪位工人安排工作都是无所谓的。也就是说，选择第一个空桶后就可以直接跳出循环，不必再尝试其它空桶。</p>
<p>因此，我们在循环中，可以这样写<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;everyBodyTime.length;i++)&#123;</span><br><span class="line">    <span class="comment">//如何剪枝？</span></span><br><span class="line">    <span class="keyword">if</span> (everyBodyTime[i] + jobs[index] &gt;= minTime) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 剪枝：空桶剪枝。若该工人还未分配工作（空桶），那么只分配给第一个空桶即可</span></span><br><span class="line">    <span class="keyword">if</span>(everyBodyTime[i] == <span class="number">0</span>) &#123;</span><br><span class="line">        everyBodyTime[i] += jobs[index];</span><br><span class="line">        traverse(jobs, everyBodyTime, index+<span class="number">1</span>);</span><br><span class="line">        everyBodyTime[i] -= jobs[index];</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 直接 break，因为其他空桶产生的状态是对称的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    everyBodyTime[i] += jobs[index];</span><br><span class="line">    traverse(jobs,everyBodyTime,index+<span class="number">1</span>);</span><br><span class="line">    everyBodyTime[i] -= jobs[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于等效状态判断，还有一题非常经典<a href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/" target="_blank" rel="noopener">698. 划分为k个相等的子集</a> 这题是说给定一个整数数组 <code>nums</code> 和一个正整数 <code>k</code>，找出是否有可能把这个数组分成 <code>k</code> 个非空子集，其总和都相等。我们套入球盒模型，k个盒子，nums个球，从球的角度出发，遍历k个盒子，判断是否要放入。在这里，k个盒子没有先后顺序之分，因此也需要用等效状态来剪枝。具体来说，当我们对每个数字尝试放入不同的桶时，会出现这样的情况：如果两个桶当前的和是相同的，那么把当前数字放入这两个桶其实会产生“对称”的状态，也就是说，它们得到的结果是等价的。</p>
<p>例如，假设 bucket[0] 和 bucket[1] 当前都为 5，并且目标值是 10，当我们尝试将当前数字 3 放入这两个桶时：</p>
<ul>
<li>如果放入 bucket[0]，则 bucket[0] 变为 8，bucket[1] 仍然为 5；</li>
<li>如果放入 bucket[1]，则 bucket[1] 变为 8，bucket[0] 仍然为 5。</li>
</ul>
<p>这两种状态在后续递归中所探索的可能性是等价的，只不过桶的顺序不同，但对于问题本身没有影响。</p>
<p>因此，我们可以这样写回溯函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span>[] bucket,<span class="keyword">int</span> index,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index == nums.length)&#123;</span><br><span class="line">        <span class="keyword">boolean</span> current = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> b:bucket)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b!=target) current = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(current) flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;bucket.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> num = nums[index];</span><br><span class="line">      <span class="comment">//重点：剪枝等效状态</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; bucket[i] == bucket[i-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(bucket[i] + num &gt; target) <span class="keyword">continue</span>;</span><br><span class="line">        bucket[i] += num;</span><br><span class="line">        traverse(nums,bucket,index+<span class="number">1</span>,target);</span><br><span class="line">        bucket[i] -= num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两种剪枝是可以互换的，效率不会差太多。第二种减去的情况多一些，效率会略好一些。</p>
<p><a href="https://leetcode.cn/problems/fair-distribution-of-cookies/" target="_blank" rel="noopener">2305. 公平分发饼干</a> 这题也可以用这种剪枝来快速提高效率，本质上都是一道题目</p>
<h2 id="状态存储"><a href="#状态存储" class="headerlink" title="状态存储"></a>状态存储</h2><p>还是<a href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/" target="_blank" rel="noopener">698. 划分为k个相等的子集</a> 这题，我们不妨从盒的角度出发，用每一个盒去装球，如果装满了，那么就装下一个盒子，一直到所有盒子都装满。</p>
<p><strong>但是效率很低，我们可以思考一下是否还有优化的空间</strong>。</p>
<p>首先，在这个解法中每个桶都可以认为是没有差异的，但是我们的回溯算法却会对它们区别对待，这里就会出现重复计算的情况。</p>
<p>什么意思呢？我们的回溯算法，说到底就是穷举所有可能的组合，然后看是否能找出和为 <code>target</code> 的 <code>k</code> 个桶（子集）。</p>
<p>那么，比如下面这种情况，<code>target = 5</code>，算法会在第一个桶里面装 <code>1, 4</code>：</p>
<p><img src="/2025/03/07/%E5%9B%9E%E6%BA%AF%E5%89%AA%E6%9E%9D%E6%95%B4%E7%90%86/1.jpeg" alt="img" style="zoom:67%;"></p>
<p>现在第一个桶装满了，就开始装第二个桶，算法会装入 <code>2, 3</code>：</p>
<p><img src="/2025/03/07/%E5%9B%9E%E6%BA%AF%E5%89%AA%E6%9E%9D%E6%95%B4%E7%90%86/2.jpeg" alt="img" style="zoom:67%;"></p>
<p>然后以此类推，对后面的元素进行穷举，凑出若干个和为 5 的桶（子集）。</p>
<p>但问题是，如果最后发现无法凑出和为 <code>target</code> 的 <code>k</code> 个子集，算法会怎么做？</p>
<p>回溯算法会回溯到第一个桶，重新开始穷举，现在它知道第一个桶里装 <code>1, 4</code> 是不可行的，它会尝试把 <code>2, 3</code> 装到第一个桶里：</p>
<p><img src="/2025/03/07/%E5%9B%9E%E6%BA%AF%E5%89%AA%E6%9E%9D%E6%95%B4%E7%90%86/3.jpeg" alt="img" style="zoom:67%;"></p>
<p><img src="/2025/03/07/%E5%9B%9E%E6%BA%AF%E5%89%AA%E6%9E%9D%E6%95%B4%E7%90%86/4.jpeg" alt="img" style="zoom:67%;"></p>
<p>好，到这里你应该看出来问题了，这种情况其实和之前的那种情况是一样的。也就是说，到这里你其实已经知道不需要再穷举了，必然凑不出来和为 <code>target</code> 的 <code>k</code> 个子集。</p>
<p>但我们的算法还是会傻乎乎地继续穷举，因为在她看来，第一个桶和第二个桶里面装的元素不一样，那这就是两种不一样的情况呀。</p>
<p>那么我们怎么让算法的智商提高，识别出这种情况，避免冗余计算呢？</p>
<p>你注意这两种情况的 <code>used</code> 数组肯定长得一样，所以 <code>used</code> 数组可以认为是回溯过程中的「状态」。</p>
<p><strong>所以，我们可以用一个 <code>memo</code> 备忘录，在装满一个桶时记录当前 <code>used</code> 的状态，如果当前 <code>used</code> 的状态是曾经出现过的，那就不用再继续穷举，从而起到剪枝避免冗余计算的作用</strong>。</p>
<p>有读者肯定会问，<code>used</code> 是一个布尔数组，怎么作为键进行存储呢？这其实是小问题，比如我们可以把数组转化成字符串，这样就可以作为哈希表的键进行存储了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 备忘录，存储 used 数组的状态</span></span><br><span class="line">    HashMap&lt;String, Boolean&gt; memo = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 见上文</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> bucket, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">boolean</span>[] used, <span class="keyword">int</span> target)</span> </span>&#123;        </span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 used 的状态转化成形如 [true, false, ...] 的字符串</span></span><br><span class="line">        <span class="comment">// 便于存入 HashMap</span></span><br><span class="line">        String state = Arrays.toString(used);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bucket == target) &#123;</span><br><span class="line">            <span class="comment">// 装满了当前桶，递归穷举下一个桶的选择</span></span><br><span class="line">            <span class="keyword">boolean</span> res = backtrack(k - <span class="number">1</span>, <span class="number">0</span>, nums, <span class="number">0</span>, used, target);</span><br><span class="line">            <span class="comment">// 将当前状态和结果存入备忘录</span></span><br><span class="line">            memo.put(state, res);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (memo.containsKey(state)) &#123;</span><br><span class="line">            <span class="comment">// 如果当前状态曾今计算过，就直接返回，不要再递归穷举了</span></span><br><span class="line">            <span class="keyword">return</span> memo.get(state);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他逻辑不变...</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = start;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bucket+nums[i]&gt;target)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 递归穷举下一个数字是否装入当前桶</span></span><br><span class="line">            <span class="keyword">if</span> (backTrack(k, bucket+nums[i], nums, i + <span class="number">1</span>, used, target)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实我认为，状态存储和上一届判断状态是否一致，是等价的，都是减去不必要的重复状态的计算。</p>
<h3 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139 单词拆分"></a>139 <a href="https://leetcode.cn/problems/word-break/" target="_blank" rel="noopener">单词拆分</a></h3>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2025/02/13/HoneyBadgerBFT%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/02/13/HoneyBadgerBFT%E5%AD%A6%E4%B9%A0/" itemprop="url">HoneyBadgerBFT学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2025-02-13T15:54:03+08:00">
                2025-02-13
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2025-04-11T10:19:47+08:00">
                2025-04-11
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HoneyBadger-BFT-学习"><a href="#HoneyBadger-BFT-学习" class="headerlink" title="HoneyBadger-BFT 学习"></a>HoneyBadger-BFT 学习</h1><h2 id="半同步共识-vs-异步共识"><a href="#半同步共识-vs-异步共识" class="headerlink" title="半同步共识 vs 异步共识"></a>半同步共识 vs 异步共识</h2><p>半同步共识协议就是基于第一种方法加强网络假设而设计的。这种方法可以让协议的设计相对简单，协议的关注点可以更多的放在安全性（safety），活性由 failure detector 来保证。比如在 PBFT 中，每个 replica 都要维护一个 timer，一旦 timeout 就会触发 view change 协议选举新的 leader。这里的 timer 就起到了一个 failure detector 的作用。由于半同步网络的假设存在，当网络恢复到同步之后，总能选出一个诚实的 leader，进而保证协议的活性。然而在异步环境下，failure detector 就会失去作用，可能<strong>导致无休止的 view change</strong>。除此之外，在工程实践中，即使底层网络能满足半同步假设的要求，但如何调节 timer 对协议的实际性能有非常大的影响。如果 timer 时间过短，那么可能导致 view change 频繁发生；如果时间过长，则可能导致网络从 partition 之后恢复较慢。</p>
<p>异步共识协议则完全不需要考虑 timer 的设置。为了保证协议的活性，异步协议需要引入随机源，简单来说就是当协议无法达成共识的时候，借助上帝抛骰子的方式随机选择一个结果作为最终结果。所以，异步共识的核心就是这颗<strong>common coin</strong></p>
<h2 id="HoneyBadger-BFT"><a href="#HoneyBadger-BFT" class="headerlink" title="HoneyBadger BFT"></a>HoneyBadger BFT</h2><p>以 HB-BFT 为例，讨论一下异步拜占庭共识所涉及的核心技术。异步拜占庭共识由于协议设计比较复杂、通信复杂度比较高，很长一段时间都只停留在论文中，直到 2016 年 Andrew Miller 在 CCS 上发表 HB-BFT 才意味着异步拜占庭容错正式迈入可实用领域。HB-BFT 通过非常巧妙的设计将整体的通信复杂度降低到了接近于最优的 O(|B|)，前提是区块所占带宽 |B| 足够大。</p>
<p>HB-BFT 通过模块化的方式解决了拜占庭环境下的原子广播（Atomic Broadcast，ABC）问题，即如何保证在异步和拜占庭环境下，各个节点按<strong>相同顺序</strong>收到相同的消息。HB-BFT 首先将 ABC 分解成一个核心模块，异步共同子集（Asynchronous Common Subset，ACS）。并提出了<br> <code>ACS = RBC(Reliable Broadcast) + ABA(Asynchronous Binary Agreement)</code><br>这两个子模块，并且分别针对这两个子模块找到了两个比较优化的实现，如下图所示。接下来我们讨论每个模块是如何实现的。</p>
<p><img src="/2025/02/13/HoneyBadgerBFT%E5%AD%A6%E4%B9%A0/1.png" style="zoom:67%;"></p>
<h3 id="HB-BFT-Overview"><a href="#HB-BFT-Overview" class="headerlink" title="HB-BFT Overview"></a>HB-BFT Overview</h3><p>首先，我们看 HB-BFT 是如何利用 ACS 实现 ABC 的。简单来说，每个节点都参与贡献一个区块的<strong>一部分</strong>,<strong>是一个多对多的发送交易，任何对等节点在收到了交易之后都会转发交易</strong>，而 ACS 的作用就是决定哪些节点贡献的这<strong>一部分</strong>最终达成了共识。假如网络中一共有 10 个节点，每个节点维护了一个交易池作为接收来自客户端交易的缓冲池，每个区块包含 B = 100 个交易。</p>
<ol>
<li>每个节点首先从本地的交易池中选取前 100 个合法的交易，之后再从这 100 个交易中随机选择 100/10=10 笔交易作为自己的 proposal。这里之所以每个节点只选择 B/N 笔交易是为了降低通信复杂度，而之所以采用随机选取的方式，是为了降低每个节点选择重复交易的概率。</li>
<li>通过一个共享公钥（阈值签名）将 proposal 加密，交易的内容直到共识结束后（收到了来自 f+1 个 share）才能被解密，从而防止了审查攻击（censorship attacks）。</li>
<li>每个节点将加密后的 proposal 作为 ACS 模块的输入，输出就得到了一个“名单”，记录了有哪些节点提交的 proposal 成功得到共识。</li>
<li>之后通过一系列的解密操作就得到了最终确认的区块。</li>
</ol>
<p><img src="/2025/02/13/HoneyBadgerBFT%E5%AD%A6%E4%B9%A0/2.png" style="zoom:67%;"></p>
<h3 id="ACS（Asynchronous-Common-Subset）"><a href="#ACS（Asynchronous-Common-Subset）" class="headerlink" title="ACS（Asynchronous Common Subset）"></a>ACS（Asynchronous Common Subset）</h3><p>接下来我们讨论 HB-BFT 的核心——ACS 模块是如何实现的。ACS 可以被分解成 RBC(Reliable Broadcast) 和 ABA(Asynchronous Binary Agreement) 两个子模块。每个节点首先将本地的 proposal 通过 RBC 发送到其它节点，之后每个节点针对每个 RBC 的实例成功与否（0 或 1）执行一次 ABA。也就是说，每个节点都要并行运行 N 个 ABA 的示例（每个节点的 proposal 一个），每个 ABA 的输出 0 或 1 表示是否所有正确节点都认为这个 proposal 最终应该成为区块的一部分。</p>
<p>ACS 的运行流程如下图所示。假如一共有 N=10 个节点（最多容忍 f=3 个拜占庭节点），以节点 P1<em>P</em>1为例。如果P1<em>P</em>1 收到来自P2<em>P</em>2的 proposal（即 RBC2 成功），则 P1<em>P</em>1将 ABA2 的输入置为 1。当P1<em>P</em>1收到 N−f 节点的 proposal 时，将其它所有的 ABA 的输入都置为 0。直到所有 ABA 运行结束，将所有输出为 1 的 ABA 的汇聚成一个集合作为 ACS 的最终输出。例如，针对节点P1,P3,P4,P6,P7,P9,P10发布的 proposal 对应的 ABA 的结果如果是 1 的话，ACS 的最终输出可以是（1，3，4，5，6，7，9，10）。ACS 保证所有正确节点都得到相同的输出。</p>
<p><img src="/2025/02/13/HoneyBadgerBFT%E5%AD%A6%E4%B9%A0/3.png" style="zoom:67%;"></p>
<p>下图展示了 ACS 在执行过程中的三种情况。</p>
<ul>
<li>在正常情况下，RBC1 结束比较早，相对应的 ABA1 的输入为 1（yes），其输出也是 1。</li>
<li>第二种情况，RBC2 结束的比较慢，在相对应的 ABA2 开始的时候（其它 N-f 个 RBC 成功之后）RBC2 还未结束，该节点对ABA2 的输入为 0（No），但由于其它 N-f 个节点已经收到RBC2，对于 ABA2 的输入为 1，最终 ABA2 的输出也是 1。<strong>简单来说就是：虽然我比较慢，但别人已经帮我决定好了</strong>。同时保证节点能够最终收到 RBC2 的 proposal。</li>
<li>第三种情况，RBC3 失败，当其它 N−f 个 RBC 成功之后，节点对 ABA3 的输入为 0，最终 ABA3 的输出也是 0。</li>
</ul>
<p><img src="/2025/02/13/HoneyBadgerBFT%E5%AD%A6%E4%B9%A0/4.png" style="zoom:67%;"></p>
<h3 id="RBC-Reliable-Broadcast"><a href="#RBC-Reliable-Broadcast" class="headerlink" title="RBC(Reliable Broadcast)"></a>RBC(Reliable Broadcast)</h3><p>可靠广播 RBC 可以确保源节点能够可靠地将消息发送到网络中的所有节点。具体来说，RBC 主要有以下三个性质：</p>
<ul>
<li><strong>一致性（Agreement）</strong>。任意两个正确节点都收到来自源节点的相同的消息。</li>
<li><strong>全局性（Totality）</strong>。只要有一个节点收到了来自源节点的消息，那么所有正确的节点最终都能收到这个消息。</li>
<li><strong>可信性（Validity）</strong>。如果源节点是正确的，那么所有正确的节点收到的消息一定与源节点发送的消息一致。</li>
</ul>
<p>抗拜占庭的 RBC 最早由 Bracha 于1987年首次提出，并得到了广泛应用，其消息传递的示意图如下。RBC 主要分成 <code>Initiate</code>、<code>Echo</code>、<code>Ready</code> 三个阶段，其中后两个阶段各经历一次 all-to-all 的广播，因此 Bracha 的 RBC 协议的通信复杂度是$O(N2∣v∣)$ 。</p>
<p>在这之后，Cachin 等人在 2005 年提出了基于纠删码的 RBC 实现，将通信复杂度降低到了$O(N∣v∣+λN2log⁡N)$。<strong>HB-BFT 就是采用了这种优化的 RBC</strong>。当$∣v∣ $远大于$λNlog⁡N$  的时候，其通信复杂度可以近似表示为$O(N∣v∣) $ 。由于$∣v∣=∣B∣/N$ ，则 HB-BFT 整体的通信复杂度可以表示为$O(∣B∣) $（|B|为整个区块的大小），也就是渐进于理论最优。</p>
<p><img src="/2025/02/13/HoneyBadgerBFT%E5%AD%A6%E4%B9%A0/5.jpg" style="zoom:67%;"></p>
<p>HB-BFT 中采用了基于(N-2f，N)的纠删码模式，即将一个数据块进行编码后，可以将其分成 N 份，其中只要任意 N-2f 份组合可以恢复整个数据块。消息传递的模式仍然跟传统的 RBC 类似。</p>
<h3 id="ABA-Asynchronous-Binary-Agreement"><a href="#ABA-Asynchronous-Binary-Agreement" class="headerlink" title="ABA (Asynchronous Binary Agreement)"></a>ABA (Asynchronous Binary Agreement)</h3><p>异步二元共识就是要在异步环境下让所有节点对于 0 或 1 达成共识。在 HB-BFT 中，每个节点都会针对其他所有节点的 RBC 是否成功进行一次二元共识，也就是说，在系统中<strong>每轮Epoch都要并行地执行 N 个 ABA 的实例</strong>。</p>
<p>ABA 主要满足下面几个性质：</p>
<ul>
<li><strong>一致性（Aggreement）</strong>。所有节点的输出相同（要么都是 0，要么都是 1）。</li>
<li><strong>最终性（Termination）</strong>。如果所有正确节点都收到了输入，那么所有正确节点最终都会得到输出。</li>
<li><strong>可信性（Validity）</strong>。如果任意正确节点的输出是 b（0 或 1），那么至少有一个正确节点的输入是 b。</li>
</ul>
<p>ABA 的实现原理就是当节点无法达成一致的时候借助一个外部的随机源做决定。这个随机源就是 ABA 的核心组件（Common Coin，CC），我们也可以将 CC 理解成上帝掷骰子，只不过这个骰子只有 0 和 1 两个值。虽然只掷一次骰子可能还是无法达成共识，那么就不停掷，最终会出现所有人都达成一致的结果，<strong>所以common coin是最大的瓶颈，因为common coin是概率性的，而且common coin的多方安全计算，要求每个节点参与，在异步环境下太慢了</strong>。Common Coin 有很多实现方案，HB-BFT 针对其模块化的设计，采用了基于阈值签名的 CC 方案。每个节点对一个共同的字符串进行签名并广播给其它节点，当节点收到来自其它 f+1 个节点的签名时，就可以将这些签名聚合成一个签名，并将这个签名作为随机源。</p>
<h3 id="HB-BFT-vs-PBFT"><a href="#HB-BFT-vs-PBFT" class="headerlink" title="HB-BFT vs PBFT"></a>HB-BFT vs PBFT</h3><p>PBFT是部分同步版的RBC, 如果都在同步场景下，二者性能应该差不多，因为ABA一轮就结束了，大家的结果是一样的。但是，在异步场景下，HB-BFT的性能会碾压PBFT，因为在异步情况下PBFT会一直换主，始终无法推进共识，但是HB-BFT运用Common Coin,利用概率，最后收敛。</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2025/01/02/%E9%99%90%E6%B5%81%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2025/01/02/%E9%99%90%E6%B5%81%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AD%A6%E4%B9%A0/" itemprop="url">限流组件开发与学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2025-01-02T10:11:44+08:00">
                2025-01-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2025-01-02T16:49:11+08:00">
                2025-01-02
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="限流组件开发与学习"><a href="#限流组件开发与学习" class="headerlink" title="限流组件开发与学习"></a>限流组件开发与学习</h1><p>为了让羊毛党利用脚本等工具快速多次抽奖印象活动体验，我们可以写一个限流的组件，来阻止短时间内大量请求。</p>
<p>首先来定义这个注解：<code>RateLimiterAccessInterceptor</code></p>
<h2 id="注解-RateLimiterAccessInterceptor"><a href="#注解-RateLimiterAccessInterceptor" class="headerlink" title="注解 RateLimiterAccessInterceptor"></a>注解 <code>RateLimiterAccessInterceptor</code></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RateLimiterAccessInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 用哪个字段作为拦截标识，未配置则默认走全部 */</span></span><br><span class="line">    <span class="function">String <span class="title">key</span><span class="params">()</span> <span class="keyword">default</span> "all"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 限制频次（每秒请求次数） */</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">permitsPerSecond</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 黑名单拦截（多少次限制后加入黑名单）0 不限制 */</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">blacklistCount</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 拦截后的执行方法 */</span></span><br><span class="line">    <span class="function">String <span class="title">fallbackMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个注解用于标识需要进行限流的方法。该注解包含以下属性：</p>
<ul>
<li><strong>key</strong>: 用于指定哪个字段作为限流的标识符，默认值为 <code>&quot;all&quot;</code>，表示对所有请求统一限流。</li>
<li><strong>permitsPerSecond</strong>: 每秒允许的请求次数，用于配置限流的频率。</li>
<li><strong>blacklistCount</strong>: 黑名单拦截的阈值，当某个标识符的请求次数超过该值后，将其加入黑名单。默认值为 <code>0</code>，表示不启用黑名单功能。</li>
<li><strong>fallbackMethod</strong>: 当请求被限流或拦截后，执行的回调方法名称。</li>
</ul>
<h2 id="切面类-RateLimiterAOP"><a href="#切面类-RateLimiterAOP" class="headerlink" title="切面类  RateLimiterAOP"></a>切面类  RateLimiterAOP</h2><p><code>RateLimiterAOP</code> 是一个切面类，负责拦截标注了 <code>RateLimiterAccessInterceptor</code> 注解的方法，并实现具体的限流逻辑。</p>
<h3 id="主要成员变量："><a href="#主要成员变量：" class="headerlink" title="主要成员变量："></a>主要成员变量：</h3><ul>
<li><strong>rateLimiterSwitch</strong>: 通过 <code>@DCCValue</code> 注解从配置中心获取的限流开关，用于控制限流功能的开启和关闭。</li>
<li><strong>loginRecord</strong>: 使用 Guava 的 <code>Cache</code> 实现，每个 <code>key</code> 对应一个 <code>RateLimiter</code>，用于控制请求频率。记录的有效期为 1 分钟。</li>
<li><strong>blacklist</strong>: 使用 Guava 的 <code>Cache</code> 实现，用于记录被加入黑名单的标识符，记录的有效期为 24 小时。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiterAOP</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DCCValue</span>(<span class="string">"rateLimiterSwitch:close"</span>)</span><br><span class="line">    <span class="keyword">private</span> String rateLimiterSwitch;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 个人限频记录1分钟</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Cache&lt;String, RateLimiter&gt; loginRecord = CacheBuilder.newBuilder()</span><br><span class="line">            .expireAfterWrite(<span class="number">1</span>, TimeUnit.MINUTES)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 个人限频黑名单24h - 分布式业务场景，可以记录到 Redis 中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Cache&lt;String, Long&gt; blacklist = CacheBuilder.newBuilder()</span><br><span class="line">            .expireAfterWrite(<span class="number">24</span>, TimeUnit.HOURS)</span><br><span class="line">            .build();</span><br><span class="line">  <span class="comment">/**/</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="切点定义："><a href="#切点定义：" class="headerlink" title="切点定义："></a>切点定义：</h3><p>定义了一个切点 <code>aopPoint</code>，匹配所有标注了 <code>RateLimiterAccessInterceptor</code> 注解的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiterAOP</span> </span>&#123;</span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line"><span class="comment">    <span class="doctag">@Pointcut</span>("<span class="doctag">@annotation</span>(io.github.jasonxqh.types.annotations.RateLimiterAccessInterceptor)")</span></span><br><span class="line"><span class="comment">    public void aopPoint()&#123;&#125;</span></span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="环绕通知-doRouter："><a href="#环绕通知-doRouter：" class="headerlink" title="环绕通知 doRouter："></a>环绕通知 <code>doRouter</code>：</h3><h4 id="RateLimiter是什么类？"><a href="#RateLimiter是什么类？" class="headerlink" title="RateLimiter是什么类？"></a>RateLimiter是什么类？</h4><p><strong><code>RateLimiter</code> 类介绍：</strong></p>
<ul>
<li><strong>来源</strong>：<code>RateLimiter</code> 是 Google Guava 库中的一个类，位于 <code>com.google.common.util.concurrent</code> 包中。</li>
<li><strong>功能</strong>：实现了基于令牌桶算法的限流器，用于控制代码执行的速率，防止系统被过多请求压垮。</li>
</ul>
<p><strong>主要特性：</strong></p>
<ol>
<li><strong>令牌桶算法</strong>：<ul>
<li><code>RateLimiter</code> 采用令牌桶算法，通过以固定速率生成令牌，控制请求的速率。</li>
<li>每个请求在执行前需要从桶中获取一个令牌，如果令牌可用，则允许请求执行；否则，拒绝请求。</li>
</ul>
</li>
<li><strong>两种获取令牌的方式</strong>：<ul>
<li><strong>阻塞获取</strong>：<code>acquire()</code> 方法会阻塞，直到获取到令牌。</li>
<li><strong>非阻塞获取</strong>：<code>tryAcquire()</code> 方法会立即返回，表示是否成功获取到令牌。</li>
</ul>
</li>
<li><strong>速率控制</strong>：<ul>
<li>可以动态调整令牌生成速率，适应不同的限流需求。</li>
</ul>
</li>
</ol>
<p><strong>主要方法：</strong></p>
<ul>
<li><strong><code>RateLimiter.create(double permitsPerSecond)</code></strong>：<ul>
<li>创建一个以指定速率（每秒发放的令牌数）生成令牌的 <code>RateLimiter</code> 实例。因此，我们在用<code>@RateLimiterAccessInterceptor</code> 注解一个方法的时候，需要定义这个<code>permitsPerSecond</code>字段，他决定了隔多少秒可以抽一次奖。</li>
</ul>
</li>
<li><strong><code>boolean tryAcquire()</code></strong>：<ul>
<li>尝试立即获取一个令牌，如果成功返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li>非阻塞方式，适用于需要快速判断是否允许请求的场景。</li>
</ul>
</li>
<li><strong><code>void acquire()</code></strong>：<ul>
<li>阻塞直到获取到一个令牌，适用于需要严格限制执行速率的场景。</li>
</ul>
</li>
</ul>
<h4 id="核心逻辑"><a href="#核心逻辑" class="headerlink" title="核心逻辑"></a>核心逻辑</h4><p>这是核心的限流逻辑实现。以下是详细流程：</p>
<ol>
<li><strong>限流开关检查</strong>：<ul>
<li>如果 <code>rateLimiterSwitch</code> 未配置或值为 <code>&quot;close&quot;</code>，则不进行限流，直接执行目标方法 <code>pjp.proceed()</code>。</li>
</ul>
</li>
<li><strong>获取限流标识符</strong>：<ul>
<li>从注解中获取 <code>key</code> 属性值。</li>
<li>通过 <code>getAttrValue</code> 方法，从目标方法的参数中提取出 <code>key</code> 对应的值 <code>keyAttr</code>。</li>
<li>如果 <code>keyAttr</code> 为 <code>&quot;all&quot;</code>，则表示对所有请求统一限流；否则，对特定标识符（如 <code>userId</code>）进行限流。</li>
</ul>
</li>
<li><strong>黑名单检查</strong>：<ul>
<li>如果 <code>blacklistCount</code> 不为 <code>0</code>，并且 <code>keyAttr</code> 已经在黑名单中且超过了 <code>blacklistCount</code>，则直接调用回调方法 <code>fallbackMethod</code>，拒绝此次请求。</li>
</ul>
</li>
<li><strong>限流检查</strong>：<ul>
<li>从 <code>loginRecord</code> 中获取对应 <code>key</code> 的 <code>RateLimiter</code> 实例，如果不存在则创建一个新的 <code>RateLimiter</code>，并放入缓存中。<code>loginRecord</code> 中的 <code>RateLimiter</code> 会在 1 分钟后过期，若该用户在此期间没有新的请求，其 <code>RateLimiter</code> 会被移除。</li>
<li>调用 <code>rateLimiter.tryAcquire()</code>尝试获取一个许可。如果获取失败，表示当前请求超出限流频率：<ul>
<li>如果 <code>blacklistCount</code> 不为 <code>0</code>，即配置的黑名单阈值不为 <code>0</code>。则记录此次超频行为，更新黑名单计数。</li>
<li>调用回调方法 <code>fallbackMethod</code>，拒绝此次请求。</li>
</ul>
</li>
</ul>
</li>
<li><strong>允许请求</strong>：<ul>
<li>如果成功获取到许可，则执行目标方法 <code>pjp.proceed()</code>，允许此次请求通过。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiterAOP</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"aopPoint() &amp;&amp; @annotation(rateLimiterAccessInterceptor)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doRouter</span><span class="params">(ProceedingJoinPoint pjp, RateLimiterAccessInterceptor rateLimiterAccessInterceptor)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//限流开关[open 开启 ，close 关闭] 关闭后不走限流策略</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(rateLimiterSwitch)||<span class="string">"close"</span>.equals(rateLimiterSwitch))&#123;</span><br><span class="line">            <span class="keyword">return</span> pjp.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">        String key = rateLimiterAccessInterceptor.key();</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(key))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"uId is null or empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String keyAttr = getAttrValue(key, pjp.getArgs());</span><br><span class="line">        log.info(<span class="string">"aop attr &#123;&#125;"</span>,keyAttr);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="string">"all"</span>.equals(keyAttr)</span><br><span class="line">                &amp;&amp; rateLimiterAccessInterceptor.blacklistCount() != <span class="number">0</span></span><br><span class="line">                &amp;&amp; <span class="keyword">null</span> != blacklist.getIfPresent(keyAttr)</span><br><span class="line">                &amp;&amp; blacklist.getIfPresent(keyAttr) &gt; rateLimiterAccessInterceptor.blacklistCount()) &#123;</span><br><span class="line">            log.info(<span class="string">"限流-黑名单拦截(24h)：&#123;&#125;"</span>, keyAttr);</span><br><span class="line">            <span class="keyword">return</span> fallbackMethodResult(pjp, rateLimiterAccessInterceptor.fallbackMethod());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RateLimiter rateLimiter = loginRecord.getIfPresent(key);</span><br><span class="line">        <span class="keyword">if</span>(rateLimiter == <span class="keyword">null</span>)&#123;</span><br><span class="line">            rateLimiter = RateLimiter.create(rateLimiterAccessInterceptor.permitsPerSecond());</span><br><span class="line">            loginRecord.put(key, rateLimiter);</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//未获取到令牌，超出了限制频率，视为违约1次，那么此时就需要在黑名单中加入1次</span></span><br><span class="line">        <span class="keyword">if</span>(!rateLimiter.tryAcquire())&#123;</span><br><span class="line">            <span class="keyword">if</span>(rateLimiterAccessInterceptor.blacklistCount() != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span> == blacklist.getIfPresent(keyAttr))&#123;</span><br><span class="line">                    blacklist.put(keyAttr, <span class="number">1L</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    blacklist.put(keyAttr, blacklist.getIfPresent(keyAttr) + <span class="number">1L</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">"限流-超频次拦截:&#123;&#125; "</span>,keyAttr);</span><br><span class="line">            <span class="keyword">return</span> fallbackMethodResult(pjp, rateLimiterAccessInterceptor.fallbackMethod());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pjp.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">/**/</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="辅助方法："><a href="#辅助方法：" class="headerlink" title="辅助方法："></a>辅助方法：</h3><ul>
<li><strong>fallbackMethodResult</strong>：通过反射调用用户配置的回调方法。当请求被限流或拦截后，执行此方法以返回预定义的响应。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用用户配置的回调方法，当拦截后，返回回调结果。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">fallbackMethodResult</span><span class="params">(JoinPoint jp, String fallbackMethod)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">    Signature sig = jp.getSignature();</span><br><span class="line">    MethodSignature methodSignature = (MethodSignature) sig;</span><br><span class="line">    Method method = jp.getTarget().getClass().getMethod(fallbackMethod, methodSignature.getParameterTypes());</span><br><span class="line">    <span class="keyword">return</span> method.invoke(jp.getThis(), jp.getArgs());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**/</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>getAttrValue</strong>：根据 <code>key</code> 从目标方法的参数中提取对应的值。支持通过反射获取对象属性值，适应不同参数类型。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实际根据自身业务调整，主要是为了获取通过某个值做拦截</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAttrValue</span><span class="params">(String attr, Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args[<span class="number">0</span>] <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> args[<span class="number">0</span>].toString();</span><br><span class="line">    &#125;</span><br><span class="line">    String filedValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Object arg : args) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotBlank(filedValue)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// filedValue = BeanUtils.getProperty(arg, attr);</span></span><br><span class="line">            <span class="comment">// fix: 使用lombok时，uId这种字段的get方法与idea生成的get方法不同，会导致获取不到属性值，改成反射获取解决</span></span><br><span class="line">            filedValue = String.valueOf(<span class="keyword">this</span>.getValueByName(arg, attr));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"获取路由属性值失败 attr：&#123;&#125;"</span>, attr, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> filedValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>getValueByName</strong> 和 <strong>getFieldByName</strong>：通过反射获取对象的指定属性值，支持获取父类属性。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取对象的特定属性值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 属性名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 属性值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> tang</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">getValueByName</span><span class="params">(Object item, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field field = getFieldByName(item, name);</span><br><span class="line">            <span class="keyword">if</span> (field == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Object o = field.get(item);</span><br><span class="line">            field.setAccessible(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据名称获取方法，该方法同时兼顾继承类获取父类的属性</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> item 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 属性名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 该属性对应方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> tang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Field <span class="title">getFieldByName</span><span class="params">(Object item, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Field field;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            field = item.getClass().getDeclaredField(name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            field = item.getClass().getSuperclass().getDeclaredField(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> field;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RateLimiterAccessInterceptor</span>(key = <span class="string">"userId"</span>,fallbackMethod = <span class="string">"drawRateLimiterError"</span>,permitsPerSecond = <span class="number">1.0</span>d,blacklistCount = <span class="number">1</span>)</span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"draw"</span>, method = RequestMethod.POST)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response&lt;ActivityDrawResponseDTO&gt; <span class="title">draw</span><span class="params">(@RequestBody ActivityDrawRequestDTO requestDTO)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.info(<span class="string">"活动抽奖开始 userId:&#123;&#125; activityId:&#123;&#125;"</span>, requestDTO.getUserId(), requestDTO.getActivityId());</span><br><span class="line">        <span class="comment">// 0.降级开关 [open为开启，close为关闭]</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(degradeSwitch) &amp;&amp; <span class="string">"open"</span>.equals(degradeSwitch)) &#123;</span><br><span class="line">            log.info(<span class="string">"当前degradeSwitch配置降级: &#123;&#125;"</span>,degradeSwitch);</span><br><span class="line">            <span class="keyword">return</span> Response.&lt;ActivityDrawResponseDTO&gt;builder()</span><br><span class="line">                    .code(ResponseCode.DEGRADE_SWITCH.getCode())</span><br><span class="line">                    .info(ResponseCode.DEGRADE_SWITCH.getInfo())</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Long activityId = requestDTO.getActivityId();</span><br><span class="line">        String userId = requestDTO.getUserId();</span><br><span class="line">        <span class="keyword">if</span>(activityId == <span class="keyword">null</span> || userId == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AppException(ResponseCode.ILLEGAL_PARAMETER.getCode(),ResponseCode.ILLEGAL_PARAMETER.getInfo());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1. 构建抽奖单,此时已经执行抽奖次数扣减了</span></span><br><span class="line">        UserRaffleOrderEntity orderEntity = activityPartakeService.createOrder(activityId, userId);</span><br><span class="line">        log.info(<span class="string">"活动抽奖，创建订单 userId:&#123;&#125; activityId:&#123;&#125; orderId:&#123;&#125;"</span>,userId,activityId, orderEntity.getOrderId());</span><br><span class="line">        <span class="comment">//2. 执行抽奖,消费抽奖单</span></span><br><span class="line">        RaffleAwardEntity raffleAwardEntity = strategyService.performRaffle(RaffleFactorEntity.builder()</span><br><span class="line">                .strategyId(orderEntity.getStrategyId())</span><br><span class="line">                .userId(userId)</span><br><span class="line">                .endDateTime(orderEntity.getEndDateTime())</span><br><span class="line">                .build());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.构造发奖记录，存储记录和Task，并更新抽奖单状态为已使用</span></span><br><span class="line">        UserAwardRecordEntity userAwardRecord = UserAwardRecordEntity.builder()</span><br><span class="line">                .userId(orderEntity.getUserId())</span><br><span class="line">                .activityId(orderEntity.getActivityId())</span><br><span class="line">                .strategyId(orderEntity.getStrategyId())</span><br><span class="line">                .orderId(orderEntity.getOrderId())</span><br><span class="line">                .awardId(raffleAwardEntity.getAwardId())</span><br><span class="line">                .awardTitle(raffleAwardEntity.getAwardTitle())</span><br><span class="line">                .awardConfig(raffleAwardEntity.getAwardConfig())</span><br><span class="line">                .awardTime(<span class="keyword">new</span> Date())</span><br><span class="line">                .awardState(AwardStateVO.create)</span><br><span class="line">                .build();</span><br><span class="line">        awardService.saveUserAwardRecord(userAwardRecord);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.返回结果</span></span><br><span class="line">        Response&lt;ActivityDrawResponseDTO&gt; response = Response.&lt;ActivityDrawResponseDTO&gt;builder()</span><br><span class="line">                .code(ResponseCode.SUCCESS.getCode())</span><br><span class="line">                .info(ResponseCode.SUCCESS.getInfo())</span><br><span class="line">                .data(ActivityDrawResponseDTO.builder()</span><br><span class="line">                        .awardIndex(raffleAwardEntity.getSort())</span><br><span class="line">                        .awardTitle(raffleAwardEntity.getAwardTitle())</span><br><span class="line">                        .awardId(raffleAwardEntity.getAwardId())</span><br><span class="line">                        .build())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (AppException e) &#123;</span><br><span class="line">        log.error(<span class="string">"活动抽奖失败 userId:&#123;&#125; activityId:&#123;&#125;"</span>, requestDTO.getUserId(), requestDTO.getActivityId(), e);</span><br><span class="line">        <span class="keyword">return</span> Response.&lt;ActivityDrawResponseDTO&gt;builder()</span><br><span class="line">                .code(e.getCode())</span><br><span class="line">                .info(e.getInfo())</span><br><span class="line">                .build();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">"活动抽奖失败 userId:&#123;&#125; activityId:&#123;&#125;"</span>, requestDTO.getUserId(), requestDTO.getActivityId(), e);</span><br><span class="line">        <span class="keyword">return</span> Response.&lt;ActivityDrawResponseDTO&gt;builder()</span><br><span class="line">                .code(ResponseCode.UN_ERROR.getCode())</span><br><span class="line">                .info(ResponseCode.UN_ERROR.getInfo())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response&lt;ActivityDrawResponseDTO&gt; <span class="title">drawRateLimiterError</span><span class="params">(@RequestBody ActivityDrawRequestDTO requestDTO)</span> </span>&#123;</span><br><span class="line">    log.error(<span class="string">"抽奖活动限流 userId:&#123;&#125; activityId:&#123;&#125;"</span>, requestDTO.getUserId(), requestDTO.getActivityId());</span><br><span class="line">    <span class="keyword">return</span> Response.&lt;ActivityDrawResponseDTO&gt;builder()</span><br><span class="line">            .code(ResponseCode.RATE_LIMITER.getCode())</span><br><span class="line">            .info(ResponseCode.RATE_LIMITER.getInfo())</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Redis版本"><a href="#Redis版本" class="headerlink" title="Redis版本"></a>Redis版本</h2><p>我们可以将缓存在Guava中的BlackList和loginRecord缓存在redis中，并模拟出RateLimiter的令牌桶策略：</p>
<p>使用Redis实现类似RateLimiter的令牌桶逻辑如下：</p>
<p><strong>令牌桶的构建和更新</strong></p>
<ul>
<li>获取限流速率 <code>permitsPerSecond</code>。</li>
<li>构建令牌桶的 Redis 键 <code>bucketKey</code>。</li>
<li>从 Redis 获取对应的令牌桶状态 <code>bucketMap</code>，包含 <code>tokens</code> 和 <code>last_refill_time</code>。</li>
<li>如果 <code>bucketMap</code> 为 <code>null</code> 或为空，初始化令牌数为 <code>1</code>，设置 <code>last_refill_time</code> 为当前时间，并设置过期时间为 <code>1 小时</code>。</li>
<li>否则，从 <code>bucketMap</code> 中获取当前的 <code>storedTokens</code> 和 <code>last_refill_time</code>。</li>
<li>计算自上次补充令牌以来经过的毫秒数 <code>elapsedMs</code>。</li>
<li>根据限流速率计算新产生的令牌数 <code>newTokens</code>。</li>
<li>将新令牌数添加到 <code>storedTokens</code>，并限制令牌数不超过 <code>1</code>（令牌桶容量），这样不管中间间隔了多少时间，都不会令令牌累计。</li>
<li>更新 <code>last_refill_time</code> 为当前时间。</li>
</ul>
<p><strong>判断令牌是否足够</strong></p>
<ul>
<li>如果 <code>storedTokens</code> 不足（即 <code>&lt;= 0</code>），表示请求超过了限流频率。</li>
<li>如果配置了黑名单阈值且 <code>keyAttr</code> 不是 <code>&quot;all&quot;</code>，则将 <code>keyAttr</code> 的黑名单计数器递增 <code>1</code>。</li>
<li>如果是第一次违反限流（<code>newVal == 1</code>），设置黑名单键的过期时间为 <code>24 小时</code>。</li>
<li>更新令牌桶的状态（虽然 <code>storedTokens</code> 已经不够，但依然更新是为了保持数据一致性）。</li>
<li>记录日志并调用回调方法 <code>fallbackMethod</code>，拦截请求。</li>
</ul>
<p><strong>扣减令牌并允许请求</strong></p>
<ul>
<li>如果有足够的令牌（<code>storedTokens &gt; 0</code>），则扣减 <code>1</code> 个令牌。说明这次是允许访问的</li>
<li>更新令牌桶的状态。</li>
<li>允许请求继续执行目标方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"aopPoint() &amp;&amp; @annotation(rateLimiterAccessInterceptor)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doRouter</span><span class="params">(ProceedingJoinPoint pjp, RateLimiterAccessInterceptor rateLimiterAccessInterceptor)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 检查总开关</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(rateLimiterSwitch)</span><br><span class="line">            || <span class="string">"close"</span>.equalsIgnoreCase(rateLimiterSwitch)) &#123;</span><br><span class="line">        <span class="keyword">return</span> pjp.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 从注解取到 key，即uid</span></span><br><span class="line">    String key = rateLimiterAccessInterceptor.key();</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(key))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"uId is null or empty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取调用方法时传入的真正值，比如 userId</span></span><br><span class="line">    String keyAttr = getAttrValue(key, pjp.getArgs());</span><br><span class="line">    log.info(<span class="string">"[RateLimiterAOP] keyAttr=&#123;&#125;"</span>, keyAttr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------------------------------------</span></span><br><span class="line">    <span class="comment">// 黑名单逻辑：如果某 keyAttr 超频几次，就记到这里</span></span><br><span class="line">    <span class="comment">// key:  BLACKLIST_PREFIX + keyAttr</span></span><br><span class="line">    <span class="comment">// val:  超过次数</span></span><br><span class="line">    <span class="comment">// TTL:  24 小时</span></span><br><span class="line">    <span class="comment">// -------------------------------------</span></span><br><span class="line">    <span class="comment">// 3. 如果设置了黑名单次数，就先检查黑名单</span></span><br><span class="line">    <span class="keyword">double</span> blackCountThreshold = rateLimiterAccessInterceptor.blacklistCount();</span><br><span class="line">    <span class="comment">// 非 "all" 且设定了黑名单阈值时，先检查是否已经在黑名单</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="string">"all"</span>.equals(keyAttr) &amp;&amp; blackCountThreshold &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        String blackKey = Constants.RedisKey.BLACKLIST_PREFIX + keyAttr;</span><br><span class="line">        Integer blackVal = redisService.getValue(blackKey);</span><br><span class="line">        <span class="keyword">if</span> (blackVal != <span class="keyword">null</span> &amp;&amp; (<span class="keyword">double</span>) blackVal &gt; blackCountThreshold) &#123;</span><br><span class="line">            <span class="comment">// 已达黑名单阈值</span></span><br><span class="line">            log.info(<span class="string">"限流-黑名单拦截(24h)：&#123;&#125;"</span>, keyAttr);</span><br><span class="line">            <span class="keyword">return</span> fallbackMethodResult(pjp, rateLimiterAccessInterceptor.fallbackMethod());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 令牌桶逻辑：TOKEN_BUCKET_PREFIX + userId =&gt; RMap&lt;String, String&gt;</span></span><br><span class="line">    <span class="keyword">double</span> permitsPerSecond = rateLimiterAccessInterceptor.permitsPerSecond();</span><br><span class="line">    String bucketKey = Constants.RedisKey.TOKEN_BUCKET_PREFIX + keyAttr;</span><br><span class="line">    <span class="comment">// 3.1) 获取 map 中的 tokens / lastRefillTime</span></span><br><span class="line">    RMap&lt;String, String&gt; bucketMap = redisService.getMap(bucketKey);</span><br><span class="line">    <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">  	<span class="comment">//初始必须为1，否则会直接触发黑名单</span></span><br><span class="line">    <span class="keyword">long</span> storedTokens = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">long</span> lastRefillTime = currentTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bucketMap == <span class="keyword">null</span> || bucketMap.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 第一次初始化</span></span><br><span class="line">        bucketMap = redisService.getMap(bucketKey);</span><br><span class="line">        bucketMap.put(<span class="string">"tokens"</span>, String.valueOf(storedTokens));</span><br><span class="line">        bucketMap.put(<span class="string">"last_refill_time"</span>, String.valueOf(lastRefillTime));</span><br><span class="line">        <span class="comment">// 如果需要令牌桶也自动过期，可调用</span></span><br><span class="line">        bucketMap.expire(<span class="number">1</span>, TimeUnit.HOURS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String tokenStr = bucketMap.get(<span class="string">"tokens"</span>);</span><br><span class="line">        String timeStr  = bucketMap.get(<span class="string">"last_refill_time"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tokenStr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            storedTokens = Long.parseLong(tokenStr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timeStr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            lastRefillTime = Long.parseLong(timeStr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.2) 计算需要补充的新令牌</span></span><br><span class="line">    <span class="keyword">long</span> elapsedMs = currentTime - lastRefillTime;</span><br><span class="line">    <span class="keyword">if</span> (elapsedMs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">double</span> permitsPerMs = permitsPerSecond / <span class="number">1000.0</span>;</span><br><span class="line">        <span class="keyword">long</span> newTokens = (<span class="keyword">long</span>) (elapsedMs * permitsPerMs);</span><br><span class="line">        <span class="keyword">if</span> (newTokens &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            storedTokens += newTokens;</span><br><span class="line">            <span class="comment">// 上限限制为1，也就是每隔permitsPerSecond最多只能产出1个令牌，无法堆积</span></span><br><span class="line">            storedTokens = Math.min(storedTokens, <span class="number">1</span>);</span><br><span class="line">            lastRefillTime = currentTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.3) 判断令牌是否足够</span></span><br><span class="line">    <span class="keyword">if</span> (storedTokens &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 不足 =&gt; 违约一次 =&gt; 进入黑名单统计</span></span><br><span class="line">        <span class="keyword">if</span> (blackCountThreshold &gt; <span class="number">0</span> &amp;&amp; !<span class="string">"all"</span>.equals(keyAttr)) &#123;</span><br><span class="line">            String blackKey = Constants.RedisKey.BLACKLIST_PREFIX + keyAttr;</span><br><span class="line">            <span class="keyword">long</span> newVal = redisService.incrBy(blackKey, <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 如果是第一次违约 =&gt; 设置 24h 过期</span></span><br><span class="line">            <span class="keyword">if</span> (newVal == <span class="number">1</span>) &#123;</span><br><span class="line">                redisService.expire(blackKey, <span class="number">24</span>, TimeUnit.HOURS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新令牌桶信息（可能 lastRefillTime 已刷新）</span></span><br><span class="line">        bucketMap.put(<span class="string">"tokens"</span>, String.valueOf(storedTokens));</span><br><span class="line">        bucketMap.put(<span class="string">"last_refill_time"</span>, String.valueOf(lastRefillTime));</span><br><span class="line">        log.info(<span class="string">"限流-超频次拦截(keyAttr=&#123;&#125;) =&gt; fallback"</span>, keyAttr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fallbackMethodResult(pjp, rateLimiterAccessInterceptor.fallbackMethod());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.4) 如果有令牌 =&gt; 扣减一个</span></span><br><span class="line">    storedTokens -= <span class="number">1</span>;</span><br><span class="line">    bucketMap.put(<span class="string">"tokens"</span>, String.valueOf(storedTokens));</span><br><span class="line">    bucketMap.put(<span class="string">"last_refill_time"</span>, String.valueOf(lastRefillTime));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4) 正常执行被拦截方法</span></span><br><span class="line">    <span class="keyword">return</span> pjp.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2024/12/23/zookeeper%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/12/23/zookeeper%E5%AD%A6%E4%B9%A0/" itemprop="url">zookeeper学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-12-23T14:22:39+08:00">
                2024-12-23
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2024-12-24T11:05:34+08:00">
                2024-12-24
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="zookeeper学习"><a href="#zookeeper学习" class="headerlink" title="zookeeper学习"></a>zookeeper学习</h1><h2 id="ZooKeeper-概述"><a href="#ZooKeeper-概述" class="headerlink" title="ZooKeeper 概述"></a><strong>ZooKeeper 概述</strong></h2><h3 id="a-Znode（节点）"><a href="#a-Znode（节点）" class="headerlink" title="a. Znode（节点）"></a>a. Znode（节点）</h3><ul>
<li><strong>Znode</strong> 是 ZooKeeper 中的数据单元，类似于文件系统中的文件或目录。</li>
<li><strong>层级结构</strong>：ZooKeeper 使用类似于 UNIX 文件系统的层级结构来组织 Znode。每个 Znode 都有一个唯一的路径，例如 <code>/app/config/database</code>。</li>
<li>节点类型：<ul>
<li><strong>PERSISTENT（持久节点）</strong>：永久存在，除非被手动删除。</li>
<li><strong>EPHEMERAL（临时节点）</strong>：与客户端会话绑定，客户端断开连接后自动删除。</li>
<li><strong>PERSISTENT_SEQUENTIAL（持久有序节点）</strong>：持久节点，Znode 名称后自动添加递增序号。</li>
<li><strong>EPHEMERAL_SEQUENTIAL（临时有序节点）</strong>：临时节点，Znode 名称后自动添加递增序号。</li>
</ul>
</li>
</ul>
<p><strong>数据存储</strong>：</p>
<ul>
<li><strong>单一数据块</strong>：每个 <strong>Znode</strong> 可以存储一块数据，数据的大小在 <strong>Zookeeper</strong> 中有限制（默认最大为 <strong>1 MB</strong>，可以通过配置调整，但不建议存储大量数据）。</li>
<li><strong>元数据</strong>：每个 <strong>Znode</strong> 除了存储数据外，还包含一些元数据，如版本号、ACL（访问控制列表）、创建时间等。</li>
</ul>
<h3 id="b-Watcher（观察者）"><a href="#b-Watcher（观察者）" class="headerlink" title="b. Watcher（观察者）"></a><strong>b. Watcher（观察者）</strong></h3><ul>
<li><strong>功能</strong>：允许客户端为特定 <strong>Znode</strong> 注册 <strong>Watcher</strong>，当 <strong>Znode</strong> 的数据或子节点发生变化时，<strong>Watcher</strong> 会被触发，客户端可以即时感知到这些变化。</li>
<li><strong>一次性</strong>：<strong>Watcher</strong> 是一次性的，触发后需要重新注册以持续监听。</li>
</ul>
<h3 id="c-会话与节点生命周期"><a href="#c-会话与节点生命周期" class="headerlink" title="c. 会话与节点生命周期"></a><strong>c. 会话与节点生命周期</strong></h3><ul>
<li><strong>会话</strong>：客户端与 <strong>Zookeeper</strong> 之间的连接会话，有超时机制。如果客户端在会话超时时间内未能与 <strong>Zookeeper</strong> 通信，<strong>Zookeeper</strong> 会认为客户端失效，删除其所有 <strong>EPHEMERAL</strong> 节点。</li>
<li><strong>节点生命周期</strong>：<strong>PERSISTENT</strong> 节点在创建后一直存在，除非被删除；<strong>EPHEMERAL</strong> 节点与会话绑定，随会话结束而自动删除。</li>
</ul>
<h3 id="d-ACL权限控制"><a href="#d-ACL权限控制" class="headerlink" title="d. ACL权限控制"></a>d. ACL权限控制</h3><p>Zookeeper 采⽤ ACL（Access Control Lists）策略来进⾏权限控制。定义了 五种权限：</p>
<ul>
<li>CREATE : 创建子节点的权限。</li>
<li>READ : 获取节点数据和子节点列表的权限</li>
<li>WRITE : 更新节点数据的权限</li>
<li>DELETE : 删除子节点的权限</li>
<li>ADMIN : 设置节点的 ACL 权限</li>
</ul>
<h2 id="Zookeeper-树形结构的设计原因"><a href="#Zookeeper-树形结构的设计原因" class="headerlink" title="Zookeeper 树形结构的设计原因"></a>Zookeeper 树形结构的设计原因</h2><h3 id="a-组织与管理"><a href="#a-组织与管理" class="headerlink" title="a. 组织与管理"></a><strong>a. 组织与管理</strong></h3><ul>
<li><strong>层级化管理</strong>：树形结构使得数据能够以逻辑和有序的方式组织。例如，可以将所有配置相关的 Znode 放在 <code>/app/config</code> 下，将所有服务注册信息放在 <code>/app/services</code> 下。</li>
<li><strong>模块化</strong>：不同模块或功能可以有各自的子树，便于模块化管理和维护。</li>
<li><strong>命名空间隔离</strong>：通过层级路径，可以轻松实现不同应用或模块之间的数据隔离，避免命名冲突。</li>
</ul>
<h3 id="b-简化访问与导航"><a href="#b-简化访问与导航" class="headerlink" title="b. 简化访问与导航"></a><strong>b. 简化访问与导航</strong></h3><ul>
<li><strong>路径导航</strong>：类似于文件系统，使用路径可以快速定位到特定的 Znode，简化了数据的访问和操作。</li>
<li><strong>递归操作</strong>：树形结构支持递归创建、删除和遍历操作，使得批量操作更加方便。例如，<code>creatingParentsIfNeeded()</code> 方法可以自动创建所有必要的父节点。</li>
</ul>
<h3 id="c-支持-Watcher-机制"><a href="#c-支持-Watcher-机制" class="headerlink" title="c. 支持 Watcher 机制"></a><strong>c. 支持 Watcher 机制</strong></h3><ul>
<li><strong>灵活的监听</strong>：客户端可以选择监听特定节点或整个子树的变化，提供了灵活的事件监听机制</li>
<li><strong>事件传播</strong>：树形结构使得事件的传播和管理更加高效。例如，当父节点发生变化时，子节点的 Watcher 也可以相应地接收到通知，便于实现动态配置和服务发现。</li>
<li><strong>事件隔离</strong>：通过层级路径，可以隔离不同模块或功能的事件，避免不必要的事件触发。</li>
</ul>
<h3 id="d-继承与权限管理"><a href="#d-继承与权限管理" class="headerlink" title="d. 继承与权限管理"></a><strong>d. 继承与权限管理</strong></h3><ul>
<li><strong>继承机制</strong>：在树形结构中，子节点可以继承父节点的属性，如访问控制列表（ACL），简化了权限管理。</li>
<li><strong>权限分层</strong>：通过层级路径，可以对不同层级的节点设置不同的权限，实现细粒度的访问控制。</li>
</ul>
<h2 id="实际应用中的树形结构优势"><a href="#实际应用中的树形结构优势" class="headerlink" title="实际应用中的树形结构优势"></a>实际应用中的树形结构优势</h2><h3 id="a-分布式配置管理"><a href="#a-分布式配置管理" class="headerlink" title="a. 分布式配置管理"></a><strong>a. 分布式配置管理</strong></h3><p>在微服务架构中，每个服务可能有不同的配置需求。通过树形路径，可以为每个服务或模块创建独立的配置节点。</p>
<p><strong>示例路径</strong>：</p>
<ul>
<li><code>/config/serviceA/database</code>：服务 A 的数据库配置。</li>
<li><code>/config/serviceB/cache</code>：服务 B 的缓存配置。</li>
</ul>
<h3 id="b-服务发现与注册"><a href="#b-服务发现与注册" class="headerlink" title="b. 服务发现与注册"></a><strong>b. 服务发现与注册</strong></h3><p>将每个服务实例注册到特定的路径下，便于服务的发现和负载均衡。</p>
<p><strong>示例路径</strong>：</p>
<ul>
<li><code>/services/serviceA/instance1</code>：服务 A 的第一个实例。</li>
<li><code>/services/serviceA/instance2</code>：服务 A 的第二个实例。</li>
</ul>
<h3 id="c-分布式锁"><a href="#c-分布式锁" class="headerlink" title="c. 分布式锁"></a><strong>c. 分布式锁</strong></h3><p>通过创建有序临时节点，实现公平的分布式锁机制。</p>
<p><strong>示例路径</strong>：</p>
<ul>
<li><code>/locks/resource1</code>：资源 1 的锁节点。</li>
</ul>
<h3 id="d-Leader-选举"><a href="#d-Leader-选举" class="headerlink" title="d. Leader 选举"></a><strong>d. Leader 选举</strong></h3><p>在多实例应用中，通过有序临时节点选出一个 Leader 实例，负责协调任务或管理全局状态。</p>
<p><strong>示例路径</strong>：</p>
<ul>
<li><code>/leader-election/serviceA</code>：服务 A 的 Leader 选举路径。</li>
</ul>
<h2 id="Zookeeper选主过程"><a href="#Zookeeper选主过程" class="headerlink" title="Zookeeper选主过程"></a>Zookeeper选主过程</h2><h3 id="1-1-选主的必要性"><a href="#1-1-选主的必要性" class="headerlink" title="1.1 选主的必要性"></a>1.1 选主的必要性</h3><p>在 Zookeeper 集群中，<strong>Leader</strong> 节点负责处理所有的写请求（如数据变更），并负责将这些变更同步到所有的 <strong>Follower</strong> 节点。为了确保系统的一致性和高可用性，当 Leader 节点出现故障或宕机时，集群需要迅速选举出新的 Leader，以维持服务的连续性。</p>
<h3 id="1-2-选主的算法"><a href="#1-2-选主的算法" class="headerlink" title="1.2 选主的算法"></a>1.2 选主的算法</h3><p>Zookeeper 使用 <strong>ZAB（Zookeeper Atomic Broadcast）</strong> 协议来实现 Leader 选举和消息广播。ZAB 主要分为两个阶段：</p>
<ol>
<li><strong>选举阶段（Leader Election Phase）</strong></li>
<li><strong>广播阶段（Broadcast Phase）</strong></li>
</ol>
<h4 id="1-2-1-选举阶段"><a href="#1-2-1-选举阶段" class="headerlink" title="1.2.1 选举阶段"></a>1.2.1 选举阶段</h4><p>选举过程遵循以下步骤：</p>
<ol>
<li><strong>初始化</strong>：<ul>
<li>当 Zookeeper 集群启动时，所有节点都会尝试通过投票来选举 Leader。</li>
<li>每个节点都会生成一个唯一的投票编号（zxid），用于区分不同的提议。</li>
</ul>
</li>
<li><strong>投票流程</strong>：<ul>
<li>每个节点首先向集群中的所有节点发送其自己的提议（包括自己的投票编号和当前状态）。</li>
<li>每个节点接收到提议后，会根据以下规则决定是否接受该提议：<ul>
<li><strong>如果提议的 zxid 大于当前已接受的 zxid</strong>，则接受该提议，并向提议者发送赞成票。</li>
<li><strong>如果提议的 zxid 小于当前已接受的 zxid</strong>，则拒绝该提议。</li>
<li><strong>如果提议的 zxid 等于当前已接受的 zxid</strong>，则根据节点的唯一标识符（如 IP 地址或端口号）决定接受或拒绝。</li>
</ul>
</li>
</ul>
</li>
<li><strong>达成共识</strong>：<ul>
<li>一旦某个提议获得了超过半数节点的赞成票（即多数同意），该提议就被接受，并成为新的 Leader。</li>
</ul>
</li>
<li><strong>故障恢复</strong>：<ul>
<li>如果在一定时间内没有节点达成共识（例如网络分区或节点故障），集群会重新启动选举过程，直到新的 Leader 被选出。</li>
</ul>
</li>
</ol>
<h4 id="1-2-2-广播阶段"><a href="#1-2-2-广播阶段" class="headerlink" title="1.2.2 广播阶段"></a>1.2.2 广播阶段</h4><p>一旦 Leader 被选出，ZAB 进入广播阶段，负责在 Leader 和 Followers 之间同步数据变更。</p>
<ol>
<li><strong>数据同步</strong>：<ul>
<li>Leader 负责将所有的写请求（如数据更新）广播给所有 Followers。</li>
<li>Followers 接收到数据变更后，依次确认并应用这些变更。</li>
</ul>
</li>
<li><strong>故障处理</strong>：<ul>
<li>如果 Leader 在广播过程中发生故障，集群会重新进入选举阶段，选举出新的 Leader。</li>
</ul>
</li>
</ol>
<h3 id="1-3-选主过程中的一致性保证"><a href="#1-3-选主过程中的一致性保证" class="headerlink" title="1.3 选主过程中的一致性保证"></a>1.3 选主过程中的一致性保证</h3><p>Zookeeper 通过以下机制保证选主过程中的一致性：</p>
<ul>
<li><strong>顺序性</strong>：所有的投票和提议都是按顺序进行的，确保不会出现冲突。</li>
<li><strong>多数原则</strong>：只有当提议获得了超过半数节点的赞成票时，才能被接受，防止脑裂（split-brain）问题。</li>
<li><strong>Zxid（Zookeeper Transaction Id）</strong>：每个提议和数据变更都有唯一的 zxid，用于保证操作的顺序性和一致性。</li>
</ul>
<h2 id="一致性协议对比-ZAB-Raft-PBFT"><a href="#一致性协议对比-ZAB-Raft-PBFT" class="headerlink" title="一致性协议对比(ZAB,Raft,PBFT)"></a><strong>一致性协议</strong>对比(ZAB,Raft,PBFT)</h2><div class="table-container">
<table>
<thead>
<tr>
<th>特性</th>
<th>ZAB</th>
<th>Raft</th>
<th>PBFT</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>应用场景</strong></td>
<td>专为 Zookeeper 设计</td>
<td>通用分布式系统</td>
<td>需要拜占庭容错的系统</td>
</tr>
<tr>
<td><strong>选主机制</strong></td>
<td>基于 ZAB，多数原则快速选举</td>
<td>基于任期和投票，多轮投票过程</td>
<td>基于轮询，多轮消息交换</td>
</tr>
<tr>
<td><strong>一致性模型</strong></td>
<td>原子广播，强一致性</td>
<td>强一致性，线性一致性</td>
<td>强一致性，拜占庭容错一致性</td>
</tr>
<tr>
<td><strong>容错能力</strong></td>
<td>Crash Fault Tolerance</td>
<td>Crash Fault Tolerance</td>
<td>Byzantine Fault Tolerance</td>
</tr>
<tr>
<td><strong>通信复杂度</strong></td>
<td>较低，针对性优化</td>
<td>中等，日志复制需要</td>
<td>高，通信复杂度 O(n²)</td>
</tr>
<tr>
<td><strong>可理解性</strong></td>
<td>中等，针对 Zookeeper 的专用设计</td>
<td>高，设计理念清晰易懂</td>
<td>低，协议复杂性高</td>
</tr>
<tr>
<td><strong>性能与扩展性</strong></td>
<td>优化小规模集群，高效同步</td>
<td>可扩展至中等规模，Leader 瓶颈存在</td>
<td>低，难以扩展到大规模集群</td>
</tr>
<tr>
<td><strong>实现复杂性</strong></td>
<td>中等，专用实现</td>
<td>高，通用实现</td>
<td>高，复杂实现</td>
</tr>
<tr>
<td><strong>适用性</strong></td>
<td>仅适用于 Zookeeper (读多写少、低延迟需求)</td>
<td>适用于多种通用分布式系统</td>
<td>适用于需要高安全性和容错性的场景(区块链等)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Zookeeper-Leader的职责"><a href="#Zookeeper-Leader的职责" class="headerlink" title="Zookeeper Leader的职责"></a>Zookeeper Leader的职责</h2><p>Leader 节点在 Zookeeper 集群中承担以下主要职责：</p>
<ol>
<li><strong>处理所有的写请求</strong>：<ul>
<li>所有客户端的写请求（如创建节点、删除节点、更新数据）都由 Leader 处理。</li>
<li>Leader 接收到写请求后，会将这些请求转化为事务（Transaction），并通过<strong>ZAB 协议将事务日志</strong>同步到所有 Followers。</li>
</ul>
</li>
<li><strong>事务日志管理</strong>：<ul>
<li>Leader 维护事务日志（Transaction Log），记录所有的数据变更操作。</li>
<li>事务日志用于在节点重启或故障恢复时，确保数据的一致性和持久性。</li>
</ul>
</li>
<li><strong>数据同步</strong>：<ul>
<li>Leader 负责将数据变更同步到所有 Followers，确保集群内的数据一致性。</li>
<li>Leader 通过心跳机制（Heartbeat）定期向 Followers 发送心跳包，维持与 Followers 的连接。</li>
</ul>
</li>
<li><strong>监控集群状态</strong>：<ul>
<li>Leader 监控整个集群的健康状态，检测节点故障或网络问题。</li>
<li>Leader 在检测到故障时，会触发相应的故障恢复机制，如重新选举 Leader 或调整数据同步策略。</li>
</ul>
</li>
</ol>
<h2 id="Zookeeper-的负载均衡机制"><a href="#Zookeeper-的负载均衡机制" class="headerlink" title="Zookeeper 的负载均衡机制"></a>Zookeeper 的负载均衡机制</h2><p>Zookeeper 集群的负载均衡主要体现在以下几个方面：</p>
<h3 id="3-1-客户端连接的均衡"><a href="#3-1-客户端连接的均衡" class="headerlink" title="3.1 客户端连接的均衡"></a>3.1 客户端连接的均衡</h3><p>每个 Zookeeper 客户端（如应用服务器上的 Zookeeper 客户端库）会连接到集群中的一个特定 Zookeeper 节点。为了实现负载均衡，通常采取以下策略：</p>
<ol>
<li><strong>多节点连接配置</strong>：<ul>
<li>在客户端配置中指定多个 Zookeeper 节点的地址（如 <code>zk1.example.com:2181, zk2.example.com:2181, zk3.example.com:2181</code>）。</li>
<li>客户端库会自动选择一个可用的 Zookeeper 节点进行连接，通常是按顺序尝试，或者根据负载情况动态选择。</li>
</ul>
</li>
<li><strong>随机连接策略</strong>：<ul>
<li>客户端可以随机选择一个 Zookeeper 节点进行连接，避免所有客户端集中连接到同一个节点，均衡负载分布。</li>
</ul>
</li>
<li><strong>智能连接管理</strong>：<ul>
<li>客户端库会监控连接的节点状态，当当前连接的节点不可用时，自动切换到其他可用节点，确保高可用性和负载均衡。</li>
</ul>
</li>
</ol>
<h3 id="3-2-读写负载的分离"><a href="#3-2-读写负载的分离" class="headerlink" title="3.2 读写负载的分离"></a>3.2 读写负载的分离</h3><p>Zookeeper 的架构设计旨在将读操作和写操作分离，从而实现有效的负载均衡：</p>
<ol>
<li><strong>读操作由 Followers 处理</strong>：<ul>
<li>大多数读请求（如获取节点数据、列出子节点等）可以由 Followers 直接处理，减少 Leader 的负载。</li>
<li>Followers 可以独立处理读请求，不需要通过 Leader 转发，提高系统的整体吞吐量。</li>
</ul>
</li>
<li><strong>写操作由 Leader 处理</strong>：<ul>
<li>所有写请求必须由 Leader 处理，以保证数据的一致性和顺序性。</li>
<li>虽然 Leader 负责写操作，但由于 Zookeeper 的高效设计，Leader 的负载通常不会成为瓶颈。</li>
</ul>
</li>
</ol>
<h3 id="3-3-数据同步和压缩优化"><a href="#3-3-数据同步和压缩优化" class="headerlink" title="3.3 数据同步和压缩优化"></a>3.3 数据同步和压缩优化</h3><p>为了优化负载和性能，Zookeeper 采用了一些数据同步和压缩的策略：</p>
<ol>
<li><strong>数据压缩（Data Compression）</strong>：<ul>
<li>Zookeeper 支持对事务日志进行压缩，减少存储空间和网络传输负载。</li>
<li>压缩后的事务日志可以更高效地同步到 Followers，减轻网络负担。</li>
</ul>
</li>
<li><strong>快照机制（Snapshotting）</strong>：<ul>
<li>定期对整个数据树进行快照（Snapshot），减少事务日志的数量和大小。</li>
<li>在集群恢复或新节点加入时，可以通过快照快速恢复数据，提升系统的整体性能。</li>
</ul>
</li>
</ol>
<h3 id="3-4-集群规模和节点数量的优化"><a href="#3-4-集群规模和节点数量的优化" class="headerlink" title="3.4 集群规模和节点数量的优化"></a>3.4 集群规模和节点数量的优化</h3><p>为了实现负载均衡和高可用性，Zookeeper 集群的规模和节点数量需要合理配置：</p>
<ol>
<li><strong>奇数节点数</strong>：<ul>
<li>集群通常配置为奇数个节点（如 3、5、7 个），以确保在部分节点故障时，仍能维持多数节点，保证 Leader 的选举和集群的可用性。</li>
</ul>
</li>
<li><strong>合理的节点分布</strong>：<ul>
<li>将 Zookeeper 节点分布在不同的物理或虚拟机上，避免单点故障和资源竞争。</li>
<li>确保网络连接稳定，减少节点之间的通信延迟，提升数据同步效率。</li>
</ul>
</li>
<li><strong>监控和调整</strong>：<ul>
<li>通过监控工具（如 Prometheus、Grafana）实时监控集群的负载情况和性能指标。</li>
<li>根据实际负载情况，动态调整集群规模，添加或移除节点，以优化负载均衡和性能。</li>
</ul>
</li>
</ol>
<h3 id="2-2-Leader-的高可用性"><a href="#2-2-Leader-的高可用性" class="headerlink" title="2.2 Leader 的高可用性"></a>2.2 Leader 的高可用性</h3><p>为了保证系统的高可用性，Zookeeper 集群通常部署为奇数个节点（如 3、5、7 个），以确保在半数以上节点正常工作时，Leader 能够被选举出来。这样，即使部分节点发生故障，集群仍能维持多数节点的可用性，继续提供服务。</p>
<h3 id="2-3-Leader-的负载"><a href="#2-3-Leader-的负载" class="headerlink" title="2.3 Leader 的负载"></a>2.3 Leader 的负载</h3><p>尽管 Leader 主要负责写请求和数据同步，但它在正常运行时的负载相对可控。Zookeeper 的设计旨在使 Leader 节点不成为性能瓶颈：</p>
<ul>
<li><strong>高效的通信协议</strong>：ZAB 协议和 Zookeeper 的内部优化使得数据同步和事务处理高效快速。</li>
<li><strong>轻量级操作</strong>：大多数读操作由 Followers 处理，Leader 只负责写操作和数据同步，减少了负载压力。</li>
<li><strong>集群扩展</strong>：通过增加 Followers 节点，可以分担读请求的压力，间接减轻 Leader 的负载。</li>
</ul>
<h2 id><a href="#" class="headerlink" title=" "></a> </h2><h2 id="ZooKeeper-部署方案"><a href="#ZooKeeper-部署方案" class="headerlink" title="ZooKeeper 部署方案"></a>ZooKeeper 部署方案</h2><h3 id="部署一个集中式的-Zookeeper-集群"><a href="#部署一个集中式的-Zookeeper-集群" class="headerlink" title="部署一个集中式的 Zookeeper 集群"></a><strong>部署一个集中式的 Zookeeper 集群</strong></h3><p><strong>步骤如下：</strong></p>
<ol>
<li><p><strong>部署 Zookeeper 集群</strong>：</p>
<ul>
<li><strong>节点数量</strong>：建议使用 3 个或 5 个 Zookeeper 服务器节点，具体数量根据系统规模和高可用性需求决定。</li>
<li><strong>独立服务器</strong>：将 Zookeeper 集群<strong>部署在专门的服务器或节点</strong>上，而不是应用服务器上，以避免资源竞争。</li>
<li><strong>网络配置</strong>：确保所有 Zookeeper 节点之间以及应用服务器与 Zookeeper 集群之间的网络连接稳定且低延迟。</li>
</ul>
</li>
<li><p><strong>配置应用服务器连接到 Zookeeper 集群</strong>：</p>
<ul>
<li><p><strong>客户端配置</strong>：在每台应用服务器上配置 Zookeeper 客户端，使其连接到整个 Zookeeper 集群，而不是单个节点。通常在配置中指定所有 Zookeeper 节点的地址，客户端会自动选择一个可用的节点进行连接。</p>
</li>
<li><p><strong>连接字符串示例</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zookeeper.connect&#x3D;zk1.example.com:2181,zk2.example.com:2181,zk3.example.com:2181</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>故障切换</strong>：如果一个 Zookeeper 节点不可用，客户端会自动连接到其他可用节点，确保高可用性。</p>
</li>
</ul>
</li>
</ol>
<h3 id="Zookeeper-集群中的配置变化通知机制"><a href="#Zookeeper-集群中的配置变化通知机制" class="headerlink" title="Zookeeper 集群中的配置变化通知机制"></a>Zookeeper 集群中的配置变化通知机制</h3><p>在实际部署中，所有应用实例将通过 Zookeeper 客户端连接到同一个 Zookeeper 集群。当某个配置节点发生变化时，Zookeeper 会通过其集群机制确保所有客户端（即所有应用实例）都能及时接收到配置变化的通知。这就是Zookeeper的Watcher机制，用于监听节点的变化。</p>
<p>具体流程如下：</p>
<ol>
<li><strong>配置节点变化</strong>：<ul>
<li>当某个配置节点（如 <code>/big-market-dcc/config/degradeSwitch</code>）在 Zookeeper 集群中发生变化时，所有连接到集群的客户端会收到相应的通知。</li>
</ul>
</li>
<li><strong>通知分发</strong>：<ul>
<li>Zookeeper 集群内部通过一致性协议确保所有节点上的数据一致，并通过网络将变化通知给所有订阅了该节点的客户端。</li>
<li>每个应用服务器上其 连接到集群的 Zookeeper 客户端接收到通知，并根据监听器逻辑更新相应属性。</li>
</ul>
</li>
</ol>
<p><strong>示意图</strong></p>
<p><img src="/2024/12/23/zookeeper%E5%AD%A6%E4%B9%A0/2.png" style="zoom:80%;"></p>
<ul>
<li><strong>Zookeeper 集群</strong>：3 个 Zookeeper 节点组成一个集群，确保高可用性和数据一致性。</li>
<li><strong>应用服务器</strong>：多个应用服务器通过 Zookeeper 客户端连接到 Zookeeper 集群，监听配置节点的变化。</li>
</ul>
<h3 id="实现步骤总结"><a href="#实现步骤总结" class="headerlink" title="实现步骤总结"></a>实现步骤总结</h3><ol>
<li><strong>部署 Zookeeper 集群</strong>：<ul>
<li>在独立的服务器上部署多个 Zookeeper 实例，形成一个集群（ensemble）。</li>
<li>配置 <code>zoo.cfg</code> 文件，确保集群中各节点的正确通信和选举。</li>
</ul>
</li>
<li><strong>配置应用服务器连接</strong>：<ul>
<li>在每台应用服务器上，配置 Zookeeper 客户端连接到整个 Zookeeper 集群。</li>
<li>确保应用服务器能够访问所有 Zookeeper 节点的地址和端口。</li>
</ul>
</li>
<li><strong>实现动态配置监听</strong>：<ul>
<li>您现有的 <code>DCCValueBeanFactory</code> 类通过 Zookeeper 客户端监听配置节点的变化。</li>
<li>当配置节点变化时，所有应用服务器上的监听器都会收到通知，并相应地更新 Bean 的属性值。</li>
</ul>
</li>
<li><strong>确保配置同步</strong>：<ul>
<li>使用集中式 Zookeeper 集群，确保所有应用服务器共享相同的配置数据源，保证配置的一致性和同步性。</li>
</ul>
</li>
</ol>
<h2 id="在项目中使用Zookeeper"><a href="#在项目中使用Zookeeper" class="headerlink" title="在项目中使用Zookeeper"></a>在项目中使用Zookeeper</h2><h3 id="引入zookeeper"><a href="#引入zookeeper" class="headerlink" title="引入zookeeper"></a>引入zookeeper</h3><p>根pom文件，引入zookeeper包</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zookeeper-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="单实例部署"><a href="#单实例部署" class="headerlink" title="单实例部署"></a>单实例部署</h3><ol>
<li><code>docker-compose</code>文件，拉取zookeeper镜像</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zookeeper:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">zookeeper:3.9.0</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">zookeeper</span></span><br><span class="line">  <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">  <span class="attr">hostname:</span> <span class="string">zoo1</span> </span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">2181</span><span class="string">:2181</span> <span class="comment"># 客户端连接端口</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="attr">ZOO_MY_ID:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">ZOO_SERVERS:</span> <span class="string">server.1=zookeeper:2888:3888;2181</span></span><br><span class="line">  <span class="attr">networks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">my-network</span></span><br></pre></td></tr></table></figure>
<ol>
<li><code>application-dev.yml</code>中引入zookeeper配置</li>
</ol>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zookeeper:</span></span><br><span class="line">  <span class="attr">sdk:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">connect-string:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.108</span><span class="string">:2181</span></span><br><span class="line">      <span class="attr">base-sleep-time-ms:</span> <span class="number">1000</span></span><br><span class="line">      <span class="attr">max-retries:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">session-timeout-ms:</span> <span class="number">18000</span></span><br><span class="line">      <span class="attr">connection-timeout-ms:</span> <span class="number">30000</span></span><br></pre></td></tr></table></figure>
<h3 id="多实例部署"><a href="#多实例部署" class="headerlink" title="多实例部署"></a>多实例部署</h3><p><code>Docker-compose.yml</code></p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多实例</span></span><br><span class="line">  <span class="attr">zookeeper1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.9.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zookeeper1</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zoo1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2181</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="comment"># 当前容器在集群中的 ID</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">1</span></span><br><span class="line">      <span class="comment"># 配置集群内所有 Zookeeper 实例的地址</span></span><br><span class="line">      <span class="comment"># 格式：server.id=hostname:2888:3888;&lt;clientPort&gt;</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">&gt;</span></span><br><span class="line">        <span class="string">server.1=zoo1:2888:3888;2181</span></span><br><span class="line">        <span class="string">server.2=zoo2:2888:3888;2181</span></span><br><span class="line">        <span class="string">server.3=zoo3:2888:3888;2181</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my-network</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zookeeper2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.9.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zookeeper2</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zoo2</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2182</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">&gt;</span></span><br><span class="line">        <span class="string">server.1=zoo1:2888:3888;2181</span></span><br><span class="line">        <span class="string">server.2=zoo2:2888:3888;2181</span></span><br><span class="line">        <span class="string">server.3=zoo3:2888:3888;2181</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my-network</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zookeeper3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zookeeper:3.9.0</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zookeeper3</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">zoo3</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">2183</span><span class="string">:2181</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">ZOO_SERVERS:</span> <span class="string">&gt;</span></span><br><span class="line">        <span class="string">server.1=zoo1:2888:3888;2181</span></span><br><span class="line">        <span class="string">server.2=zoo2:2888:3888;2181</span></span><br><span class="line">        <span class="string">server.3=zoo3:2888:3888;2181</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my-network</span></span><br><span class="line">      </span><br><span class="line"><span class="comment"># 多实例</span></span><br><span class="line">  <span class="attr">zoonavigator:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">elkozmon/zoonavigator:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">zoonavigator</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9020</span><span class="string">:9000</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">my-network</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper3</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="comment"># 这里指定 ZooNavigator 默认连接的 Zookeeper 地址（可用逗号分隔多个）</span></span><br><span class="line">      <span class="attr">ZK_HOSTS:</span> <span class="string">"zoo1:2181,zoo2:2181,zoo3:2181"</span></span><br></pre></td></tr></table></figure>
<p><code>application-dev.yml</code>中引入zookeeper配置</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zookeeper:</span></span><br><span class="line">  <span class="attr">sdk:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">connect-string:</span> <span class="string">"localhost:2181,localhost:2182,localhost:2183"</span> </span><br><span class="line">      <span class="attr">base-sleep-time-ms:</span> <span class="number">1000</span></span><br><span class="line">      <span class="attr">max-retries:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">session-timeout-ms:</span> <span class="number">60000</span></span><br><span class="line">      <span class="attr">connection-timeout-ms:</span> <span class="number">15000</span></span><br></pre></td></tr></table></figure>
<p>启动之后，通过<code>echo srvr | nc localhost 2182</code> 命令，可以查看zoo2的信息：<br><img src="/2024/12/23/zookeeper%E5%AD%A6%E4%B9%A0/3.png" style="zoom:80%;"></p>
<h3 id="ZookeeperClientConfigProperties-类"><a href="#ZookeeperClientConfigProperties-类" class="headerlink" title="ZookeeperClientConfigProperties 类"></a><strong><code>ZookeeperClientConfigProperties</code> 类</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.jasonxqh.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"zookeeper.sdk.config"</span>, ignoreInvalidFields = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperClientConfigProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String connectString;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> baseSleepTimeMs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxRetries;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sessionTimeoutMs;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> connectionTimeoutMs;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong><code>@ConfigurationProperties(prefix = &quot;zookeeper.sdk.config&quot;, ignoreInvalidFields = true)</code></strong>：</p>
<ul>
<li>这是 <strong>Spring Boot</strong> 的注解，用于将配置文件中的属性映射到这个类的字段。</li>
<li><strong><code>prefix</code></strong>：指定前缀为 <code>zookeeper.sdk.config</code>，意味着配置文件中所有以这个前缀开头的属性都会映射到这个类中。</li>
<li><strong><code>ignoreInvalidFields = true</code></strong>：如果配置文件中有无法映射的字段，Spring 会忽略它们，不会抛出异常。</li>
</ul>
</li>
<li><p><strong><code>connectString</code></strong>：</p>
<ul>
<li><strong>描述</strong>：Zookeeper 集群的连接字符串，格式通常为 <code>host1:port1,host2:port2,host3:port3</code>。</li>
<li><strong>示例</strong>：<code>localhost:2181</code> 或 <code>192.168.1.100:2181,192.168.1.101:2181</code></li>
</ul>
</li>
<li><strong><code>baseSleepTimeMs</code></strong>：<ul>
<li><strong>描述</strong>：重试连接时初始的等待时间，单位为毫秒。</li>
<li><strong>作用</strong>：在连接失败后，Curator 会按照指数退避算法重试连接，<code>baseSleepTimeMs</code> 是初始等待时间。</li>
</ul>
</li>
<li><strong><code>maxRetries</code></strong>：<ul>
<li><strong>描述</strong>：最大重试次数。</li>
<li><strong>作用</strong>：在连接失败后，Curator 会尝试重试，<code>maxRetries</code> 限制了重试的次数。</li>
</ul>
</li>
<li><strong><code>sessionTimeoutMs</code></strong>：<ul>
<li><strong>描述</strong>：Zookeeper 会话超时时间，单位为毫秒。</li>
<li><strong>作用</strong>：如果客户端在这个时间内没有与 Zookeeper 服务器通信，服务器会认为客户端失效，并关闭会话。</li>
</ul>
</li>
<li><strong><code>connectionTimeoutMs</code></strong>：<ul>
<li><strong>描述</strong>：连接超时时间，单位为毫秒。</li>
<li><strong>作用</strong>：客户端在建立与 Zookeeper 服务器的连接时，如果超过这个时间还未连接成功，则会抛出异常。</li>
</ul>
</li>
</ul>
<h3 id="ZooKeeperClientConfig-类"><a href="#ZooKeeperClientConfig-类" class="headerlink" title="ZooKeeperClientConfig 类"></a><strong><code>ZooKeeperClientConfig</code> 类</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io.github.jasonxqh.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(ZookeeperClientConfigProperties<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ZooKeeperClientConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多参数构建ZooKeeper客户端连接</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"zookeeperClient"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CuratorFramework <span class="title">createWithOptions</span><span class="params">(ZookeeperClientConfigProperties properties)</span> </span>&#123;</span><br><span class="line">        ExponentialBackoffRetry backoffRetry = <span class="keyword">new</span> ExponentialBackoffRetry(properties.getBaseSleepTimeMs(), properties.getMaxRetries());</span><br><span class="line">        CuratorFramework client = CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(properties.getConnectString())</span><br><span class="line">                .retryPolicy(backoffRetry)</span><br><span class="line">                .sessionTimeoutMs(properties.getSessionTimeoutMs())</span><br><span class="line">                .connectionTimeoutMs(properties.getConnectionTimeoutMs())</span><br><span class="line">                .build();</span><br><span class="line">        client.start();</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="功能与作用"><a href="#功能与作用" class="headerlink" title="功能与作用"></a><strong>功能与作用</strong></h4><ul>
<li><strong><code>@EnableConfigurationProperties(ZookeeperClientConfigProperties.class)</code></strong>：<ul>
<li>启用 <strong><code>ZookeeperClientConfigProperties</code></strong> 类的配置属性绑定，确保 <strong>Spring</strong> 能够将配置文件中的属性正确映射到这个类中。</li>
</ul>
</li>
<li><strong><code>@Bean(name = &quot;zookeeperClient&quot;)</code></strong>：<ul>
<li>定义一个 <strong>Spring Bean</strong>，名字为 <code>zookeeperClient</code>。标识<code>createWithOptions</code>方法，告诉 <strong>Spring</strong> 该方法会返回一个对象，这个对象需要被注册为 <strong>Spring</strong> 容器中的 Bean。</li>
<li><strong>返回类型</strong>：<code>CuratorFramework</code>，是 <strong>Zookeeper</strong> 的一个高级客户端框架，提供了比原生 Zookeeper 客户端更丰富、更易用的 API，简化了 Zookeeper 的操作，如服务发现、分布式锁等。</li>
</ul>
</li>
</ul>
<h4 id="方法详解"><a href="#方法详解" class="headerlink" title="方法详解"></a><strong>方法详解</strong></h4><ul>
<li><code>createWithOptions</code>：<ul>
<li><strong>参数</strong>：<code>ZookeeperClientConfigProperties properties</code>，自动注入配置属性。</li>
<li><strong>步骤</strong>：<ol>
<li>创建重试策略：<ul>
<li>使用 <strong>ExponentialBackoffRetry</strong>，基于指数退避算法的重试策略，在每次重试失败后，等待时间逐渐增加，避免频繁重试导致的资源浪费。。</li>
<li>参数为 <code>baseSleepTimeMs</code>（初始等待时间）和 <code>maxRetries</code>（最大重试次数）。</li>
</ul>
</li>
<li>构建 CuratorFramework 客户端：<ul>
<li><strong><code>connectString</code></strong>：Zookeeper 连接字符串。</li>
<li><strong><code>retryPolicy</code></strong>：前面定义的重试策略。</li>
<li><strong><code>sessionTimeoutMs</code></strong>：会话超时时间。</li>
<li><strong><code>connectionTimeoutMs</code></strong>：连接超时时间。</li>
</ul>
</li>
<li>启动客户端：<ul>
<li>调用 <code>client.start()</code> 启动 CuratorFramework 客户端。</li>
</ul>
</li>
<li>返回客户端：<ul>
<li>将启动的 <code>CuratorFramework</code> 实例作为 Bean 返回，供其他组件使用。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> CuratorFramework curatorFramework;</span><br></pre></td></tr></table></figure>
<p>先引入<code>CuratorFramework</code> ,也就是刚才注册为Bean的那个对象</p>
<h4 id="1-test-all-方法"><a href="#1-test-all-方法" class="headerlink" title="1.test_all 方法"></a>1.<strong><code>test_all</code> 方法</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_all</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String path = <span class="string">"/big-market-dcc/config/downgradeSwitch"</span>;</span><br><span class="line">    String data = <span class="string">"0"</span>;</span><br><span class="line">    curatorFramework.create().withMode(CreateMode.EPHEMERAL).forPath(path, data.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        curatorFramework.setData().forPath(path, String.valueOf(i).getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>功能</strong>：</p>
<ul>
<li>创建一个 <strong>临时节点</strong>（<code>EPHEMERAL</code>），路径为 <code>/big-market-dcc/config/downgradeSwitch</code>，初始数据为 <code>&quot;0&quot;</code>。</li>
<li>修改该节点的数据两次，分别设置为 <code>&quot;0&quot;</code> 和 <code>&quot;1&quot;</code>。</li>
</ul>
<p><strong>背后原理</strong>：</p>
<ul>
<li><strong>临时节点</strong>在客户端与 <strong>Zookeeper</strong> 的连接断开时自动删除。这对于需要自动清理的节点非常有用，如<strong>会话信息、临时锁</strong>等。</li>
<li><strong>数据修改</strong>：通过 <code>setData</code> 方法更新节点的数据，操作顺序展示了 <strong>Zookeeper</strong> 对节点数据的顺序一致性。</li>
</ul>
<h4 id="2-createNode-方法"><a href="#2-createNode-方法" class="headerlink" title="2.createNode 方法"></a>2.<strong><code>createNode</code> 方法</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createNode</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String path = <span class="string">"/big-market-dcc/config/downgradeSwitch/test/a"</span>;</span><br><span class="line">    String data = <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == curatorFramework.checkExists().forPath(path)) &#123;</span><br><span class="line">        curatorFramework.create().creatingParentsIfNeeded().forPath(path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>功能</strong>：</p>
<ul>
<li>创建一个 <strong>永久节点</strong>（默认模式，<code>PERSISTENT</code>），路径为 <code>/big-market-dcc/config/downgradeSwitch/test/a</code>，数据为 <code>&quot;0&quot;</code>（尽管未设置数据）。</li>
<li>如果该路径不存在，则创建，包括必要的父节点。</li>
</ul>
<p><strong>背后原理</strong>：</p>
<ul>
<li><strong>永久节点</strong>在客户端与 <strong>Zookeeper</strong> 的连接断开后仍然存在，适用于需要长期存在的数据，如<strong>配置信息、服务注册</strong>等。</li>
<li><strong><code>creatingParentsIfNeeded()</code></strong>：确保在创建目标节点之前，所有必要的父节点都已存在。如果父节点不存在，则自动创建。</li>
</ul>
<h4 id="3-createEphemeralNode-方法"><a href="#3-createEphemeralNode-方法" class="headerlink" title="3.createEphemeralNode 方法"></a>3.<strong><code>createEphemeralNode</code> 方法</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createEphemeralNode</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String path = <span class="string">"/big-market-dcc/config/epnode"</span>;</span><br><span class="line">    String data = <span class="string">"0"</span>;</span><br><span class="line">    curatorFramework.create().withMode(CreateMode.EPHEMERAL).forPath(path, data.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>功能</strong>：</p>
<ul>
<li>创建一个 <strong>临时节点</strong>，路径为 <code>/big-market-dcc/config/epnode</code>，数据为 <code>&quot;0&quot;</code>。</li>
</ul>
<p><strong>背后原理</strong>：</p>
<ul>
<li><strong>临时节点</strong>在客户端会话结束时自动删除，适用于需要临时存在的数据，如临时锁、会话信息等。</li>
</ul>
<h4 id="4-crateEphemeralSequentialNode-方法"><a href="#4-crateEphemeralSequentialNode-方法" class="headerlink" title="4.crateEphemeralSequentialNode 方法"></a>4.<strong><code>crateEphemeralSequentialNode</code> 方法</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crateEphemeralSequentialNode</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String path = <span class="string">"/big-market-dcc/config/epsnode"</span>;</span><br><span class="line">    String data = <span class="string">"0"</span>;</span><br><span class="line">    curatorFramework.create()</span><br><span class="line">            .withMode(CreateMode.EPHEMERAL_SEQUENTIAL)</span><br><span class="line">            .forPath(path, data.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>功能</strong>：</p>
<ul>
<li>创建一个 <strong>临时有序节点</strong>，路径为 <code>/big-market-dcc/config/epsnode</code>，数据为 <code>&quot;0&quot;</code>。</li>
<li>节点名将被自动加上一个递增的序号，如 <code>/big-market-dcc/config/epsnode0000000001</code>。</li>
</ul>
<p><strong>背后原理</strong>：</p>
<ul>
<li><strong>临时有序节点</strong>结合了 <strong>临时节点</strong>和 <strong>有序节点</strong>的特性，适用于需要按顺序创建临时节点的场景，如<strong>任务队列、排名系统</strong>等。</li>
</ul>
<h4 id="5-setData-方法"><a href="#5-setData-方法" class="headerlink" title="5.setData 方法"></a>5.<strong><code>setData</code> 方法</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    curatorFramework.setData().forPath(<span class="string">"/big-market-dcc/config/downgradeSwitch"</span>, <span class="string">"111"</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    curatorFramework.setData().forPath(<span class="string">"/big-market-dcc/config/userWhiteList"</span>, <span class="string">"222"</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>功能</strong>：</p>
<ul>
<li>更新两个节点的数据：<ul>
<li><code>/big-market-dcc/config/downgradeSwitch</code> 设置为 <code>&quot;111&quot;</code>。</li>
<li><code>/big-market-dcc/config/userWhiteList</code> 设置为 <code>&quot;222&quot;</code>。</li>
</ul>
</li>
</ul>
<p><strong>背后原理</strong>：</p>
<ul>
<li><strong>数据更新</strong>：通过 <code>setData</code> 方法修改节点的数据，<strong>Zookeeper</strong> 确保数据的一致性和顺序性。</li>
</ul>
<h4 id="6-getData-方法"><a href="#6-getData-方法" class="headerlink" title="6.getData 方法"></a>6.<strong><code>getData</code> 方法</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String downgradeSwitch = <span class="keyword">new</span> String(curatorFramework.getData().forPath(<span class="string">"/big-market-dcc/config/downgradeSwitch"</span>), StandardCharsets.UTF_8);</span><br><span class="line">    log.info(<span class="string">"测试结果: &#123;&#125;"</span>, downgradeSwitch);</span><br><span class="line">    String userWhiteList = <span class="keyword">new</span> String(curatorFramework.getData().forPath(<span class="string">"/big-market-dcc/config/userWhiteList"</span>), StandardCharsets.UTF_8);</span><br><span class="line">    log.info(<span class="string">"测试结果: &#123;&#125;"</span>, userWhiteList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>功能</strong>：</p>
<ul>
<li>获取两个节点的数据：<ul>
<li><code>/big-market-dcc/config/downgradeSwitch</code>。</li>
<li><code>/big-market-dcc/config/userWhiteList</code>。</li>
</ul>
</li>
<li>记录日志输出获取的数据。</li>
</ul>
<p><strong>背后原理</strong>：</p>
<ul>
<li><strong>数据读取</strong>：通过 <code>getData</code> 方法获取节点的数据，<strong>Zookeeper</strong> 保证数据的线性一致性，即所有客户端看到的操作都是按照顺序执行的。</li>
</ul>
<h4 id="7-setDataAsync-方法"><a href="#7-setDataAsync-方法" class="headerlink" title="7.setDataAsync 方法"></a>7.<strong><code>setDataAsync</code> 方法</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataAsync</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String path = <span class="string">"/big-market-dcc/config/downgradeSwitch"</span>;</span><br><span class="line">    String data = <span class="string">"0"</span>;</span><br><span class="line">    CuratorListener listener = (client, event) -&gt; &#123;</span><br><span class="line">        Stat stat = event.getStat();</span><br><span class="line">        log.info(<span class="string">"stat="</span> + JSON.toJSONString(stat));</span><br><span class="line">        CuratorEventType eventType = event.getType();</span><br><span class="line">        log.info(<span class="string">"eventType="</span> + eventType.name());</span><br><span class="line">    &#125;;</span><br><span class="line">    curatorFramework.getCuratorListenable().addListener(listener);</span><br><span class="line">    curatorFramework.setData().inBackground().forPath(path, data.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>功能</strong>：</p>
<ul>
<li><strong>异步设置数据</strong>：在后台线程中更新 <code>/big-market-dcc/config/downgradeSwitch</code> 节点的数据为 <code>&quot;0&quot;</code>。</li>
<li><strong>监听器</strong>：注册一个 <code>CuratorListener</code>，监听数据更新事件，记录相关信息。</li>
</ul>
<p><strong>背后原理</strong>：</p>
<ul>
<li><strong>异步操作</strong>：通过 <code>inBackground()</code> 方法，数据设置操作在后台执行，主线程不会阻塞。</li>
<li><strong>事件监听</strong>：<code>CuratorListener</code> 用于监听 <strong>CuratorFramework</strong> 事件，捕捉并处理各种 <strong>Zookeeper</strong> 事件，如数据更改、节点创建等。</li>
</ul>
<h4 id="8-deleteData-方法"><a href="#8-deleteData-方法" class="headerlink" title="8.deleteData 方法"></a>8.<strong><code>deleteData</code> 方法</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteData</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String path = <span class="string">"/big-market-dcc/config/downgradeSwitch"</span>;</span><br><span class="line">    curatorFramework.delete().deletingChildrenIfNeeded().forPath(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>功能</strong>：</p>
<ul>
<li>删除 <code>/big-market-dcc/config/downgradeSwitch</code> 节点及其所有子节点。</li>
</ul>
<p><strong>背后原理</strong>：</p>
<ul>
<li><strong>节点删除</strong>：通过 <code>delete</code> 方法删除指定路径的节点。</li>
<li><strong><code>deletingChildrenIfNeeded()</code></strong>：如果目标节点有子节点，则递归删除所有子节点。这对于删除非叶子节点非常有用。</li>
</ul>
<h4 id="9-guaranteedDeleteData-方法"><a href="#9-guaranteedDeleteData-方法" class="headerlink" title="9.guaranteedDeleteData 方法"></a>9.<strong><code>guaranteedDeleteData</code> 方法</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">guaranteedDeleteData</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String path = <span class="string">"/big-market-dcc/config/downgradeSwitch"</span>;</span><br><span class="line">    curatorFramework.delete().guaranteed().forPath(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>功能</strong>：</p>
<ul>
<li><strong>安全删除</strong>：删除 <code>/big-market-dcc/config/downgradeSwitch</code> 节点，即使第一次删除失败，也会在后台继续尝试删除，直到成功为止。</li>
</ul>
<p><strong>背后原理</strong>：</p>
<ul>
<li><strong><code>guaranteed()</code></strong>：确保删除操作最终成功，即使发生中间失败，Curator 会在后台持续重试，直到节点被成功删除。</li>
</ul>
<h4 id="10-watchedGetChildren-方法"><a href="#10-watchedGetChildren-方法" class="headerlink" title="10.watchedGetChildren 方法"></a>10.<strong><code>watchedGetChildren</code> 方法</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watchedGetChildren</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String path = <span class="string">"/big-market-dcc"</span>;</span><br><span class="line">    List&lt;String&gt; children = curatorFramework.getChildren().watched().forPath(path);</span><br><span class="line">    log.info(<span class="string">"测试结果：&#123;&#125;"</span>, JSON.toJSONString(children));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>功能</strong>：</p>
<ul>
<li>获取 <code>/big-market-dcc</code> 节点的所有子节点，并为该路径注册一个 <strong>Watcher</strong>。</li>
</ul>
<p><strong>背后原理</strong>：</p>
<ul>
<li><strong><code>watched()</code></strong>：在读取子节点列表的同时，为该路径注册一个 <strong>Watcher</strong>，当子节点发生变化时（如新增、删除），<strong>Watcher</strong> 会被触发。</li>
<li><strong>数据变化监听</strong>：通过 <strong>Watcher</strong> 机制，客户端可以实时感知 <strong>Zookeeper</strong> 节点的变化，适用于动态配置、服务发现等场景。</li>
</ul>
<h4 id="11-getDataByPath-方法"><a href="#11-getDataByPath-方法" class="headerlink" title="11. getDataByPath 方法"></a><strong>11. <code>getDataByPath</code> 方法</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDataByPath</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String path = <span class="string">"/big-market-dcc/config/downgradeSwitch"</span>;</span><br><span class="line">    String fullClassName = <span class="string">""</span>;</span><br><span class="line">    String jsonStr = <span class="keyword">new</span> String(curatorFramework.getData().forPath(path), StandardCharsets.UTF_8);</span><br><span class="line">    Class clazz = Class.forName(fullClassName);</span><br><span class="line">    log.info(<span class="string">"测试结果：&#123;&#125;"</span>, JSON.parseObject(jsonStr, clazz));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>功能</strong>：</p>
<ul>
<li>从指定路径 <code>/big-market-dcc/config/downgradeSwitch</code> 获取数据，并将其反序列化为指定的类实例。</li>
</ul>
<p><strong>背后原理</strong>：</p>
<ul>
<li><strong>数据读取与反序列化</strong>：通过 <code>getData</code> 方法获取节点数据后，使用 <strong>FastJSON</strong> 将 JSON 字符串转换为相应的类对象。</li>
<li><strong>动态类型加载</strong>：使用 <code>Class.forName(fullClassName)</code> 动态加载类，这里 <code>fullClassName</code> 需要替换为实际的类名。</li>
</ul>
<h3 id="可视化页面"><a href="#可视化页面" class="headerlink" title="可视化页面"></a>可视化页面</h3><p>我们可以在docker-compose中配置<code>zoonavigator</code>来管理zookeeper</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zoonavigator:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">elkozmon/zoonavigator:latest</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">zoonavigator</span></span><br><span class="line">  <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">9020</span><span class="string">:9000</span></span><br><span class="line">  <span class="attr">networks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">my-network</span></span><br><span class="line">  <span class="attr">depends_on:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">zookeeper</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/12/23/zookeeper%E5%AD%A6%E4%B9%A0/1.png" style="zoom:67%;"></p>
<ol>
<li><p><strong>访问界面</strong>： 打开浏览器，访问 <code>http://localhost:9000</code>。</p>
</li>
<li><p><strong>连接 ZooKeeper</strong>： 在界面中输入 ZooKeeper 的服务地址（如 <code>zookeeper:2181</code>），即可查看和管理节点数据。</p>
</li>
</ol>
<h2 id="基于注解的动态配置管理机制"><a href="#基于注解的动态配置管理机制" class="headerlink" title="基于注解的动态配置管理机制"></a>基于注解的动态配置管理机制</h2><p><code>DCCValueBeanFactory</code> 和 <code>DCCValue</code> 构成了一个基于注解的动态配置管理机制，主要用于将 Zookeeper（通过 Apache Curator 客户端）中的配置<strong>动态注入</strong>到 Spring 管理的 Bean 中，并在配置变化时<strong>实时更新</strong>这些 Bean 的属性值。以下是对这两个类的详细解析及其实现效果的说明：</p>
<h3 id="DCCValue注解"><a href="#DCCValue注解" class="headerlink" title="@DCCValue注解"></a><code>@DCCValue</code>注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DCCValue &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>@Retention(RetentionPolicy.RUNTIME)</code></strong>: 该注解在运行时保留，允许反射访问。</li>
<li><strong><code>@Target(ElementType.FIELD)</code></strong>: 该注解只能应用于类的字段（成员变量）。</li>
<li><strong><code>@Documented</code></strong>: 该注解包含在 Javadoc 中</li>
</ul>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p><code>@DCCValue</code> 注解用于标注需要从配置中心（Zookeeper）中动态注入值的 Bean 字段。注解的 <code>value</code> 属性用于指定配置的键值，格式为 <code>&quot;key:defaultValue&quot;</code>，其中 <code>key</code> 是在 Zookeeper 中的配置路径，<code>defaultValue</code> 是当 Zookeeper 中没有对应配置时的默认值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@DCCValue</span>(<span class="string">"isSwitch:1"</span>)</span><br><span class="line">    <span class="keyword">private</span> String isSwitch;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他业务逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，<code>isSwitch</code> 字段将从 Zookeeper 的路径 <code>/big-market-dcc/conig/isSwitch</code> 中获取配置值。如果该路径下没有配置值，则 <code>isSwitch</code> 将被赋予默认值 <code>&quot;1&quot;</code>。</p>
<h3 id="DCCValueBeanFactory-类"><a href="#DCCValueBeanFactory-类" class="headerlink" title="DCCValueBeanFactory 类"></a><code>DCCValueBeanFactory</code> 类</h3><h4 id="DCCValueBeanFactory-函数"><a href="#DCCValueBeanFactory-函数" class="headerlink" title="DCCValueBeanFactory 函数"></a>DCCValueBeanFactory 函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DCCValueBeanFactory</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BASE_CONFIG_PATH = <span class="string">"/big-market-dcc"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BASE_CONFIG_PATH_CONIG = BASE_CONFIG_PATH + <span class="string">"/conig"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CuratorFramework client;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String,Object&gt; dccObjGroup = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DCCValueBeanFactory</span><span class="params">(CuratorFramework client)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == client.checkExists().forPath(BASE_CONFIG_PATH_CONIG)) &#123;</span><br><span class="line">            client.create().creatingParentsIfNeeded().forPath(BASE_CONFIG_PATH_CONIG);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CuratorCache curatorCache = CuratorCache.build(client, BASE_CONFIG_PATH_CONIG);</span><br><span class="line">      <span class="comment">//通过 CuratorCache 启动对 BASE_CONFIG_PATH_CONIG 路径的监听。</span></span><br><span class="line">        curatorCache.start();</span><br><span class="line"></span><br><span class="line">        curatorCache.listenable().addListener(((type, oldData, data) -&gt; &#123;</span><br><span class="line">            <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">                <span class="keyword">case</span> NODE_CHANGED:</span><br><span class="line">                    String dccValuePath = data.getPath();</span><br><span class="line">                    Object objBean = dccObjGroup.get(dccValuePath);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == objBean) <span class="keyword">return</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 1. getDeclaredField 方法用于获取指定类中声明的所有字段</span></span><br><span class="line">												<span class="comment">//    包括私有字段、受保护字段和公共字段。</span></span><br><span class="line">                        <span class="comment">// 2. getField 方法用于获取指定类中的公共字段</span></span><br><span class="line">                      	<span class="comment">//		即只能获取到公共访问修饰符（public）的字段。</span></span><br><span class="line">                        Field field = objBean.getClass().getDeclaredField(dccValuePath.substring(dccValuePath.lastIndexOf(<span class="string">"/"</span>) + <span class="number">1</span>));</span><br><span class="line">                        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        field.set(objBean, <span class="keyword">new</span> String(data.getData()));</span><br><span class="line">                        field.setAccessible(<span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">       <span class="comment">/**/</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<ol>
<li><strong>初始化 Zookeeper 配置路径</strong>:<ul>
<li>确保 Zookeeper 中的基础配置路径 <code>/big-market-dcc/conig</code> 存在，如果不存在则创建。</li>
</ul>
</li>
<li><strong>监听配置变化（<code>NODE_CHANGED</code>）时</strong>:<ul>
<li>使用 <code>CuratorCache</code> 监听 <code>/big-market-dcc/conig</code> 路径下的节点变化。</li>
<li>当监听到节点变化（如 <code>NODE_CHANGED</code>）时，找到对应的 Bean 和字段，动态更新字段的值。</li>
</ul>
</li>
</ol>
<h4 id="postProcessAfterInitialization函数"><a href="#postProcessAfterInitialization函数" class="headerlink" title="postProcessAfterInitialization函数"></a>postProcessAfterInitialization函数</h4><h5 id="为什么要重写-postProcessAfterInitialization？"><a href="#为什么要重写-postProcessAfterInitialization？" class="headerlink" title="为什么要重写 postProcessAfterInitialization？"></a><strong>为什么要重写 <code>postProcessAfterInitialization</code>？</strong></h5><p><code>postProcessAfterInitialization</code> 是 Spring <code>BeanPostProcessor</code> 接口的方法之一，允许我们在 Spring 容器初始化 Bean 后<strong>对其进行额外的处理</strong>。通过重写该方法，可以实现对所有 Bean 的统一扫描和处理。</p>
<p>在这里，重写 <code>postProcessAfterInitialization</code> 的目的是 <strong>对 Spring 容器中所有 Bean 的字段进行扫描和注入动态配置</strong>，实现与 ZooKeeper 配置中心的集成。</p>
<h5 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h5><p>这个函数的核心作用是 <strong>扫描 Spring Bean 中标注了 <code>@DCCValue</code> 注解的字段</strong>，将其与 ZooKeeper 中的节点绑定，完成以下功能：</p>
<ol>
<li><strong>根据注解配置值从 ZooKeeper 中获取数据，并注入到字段中。</strong></li>
<li><strong>如果 ZooKeeper 节点不存在，则自动创建，并设置默认值（如果有默认值）。</strong></li>
<li><strong>将字段与 ZooKeeper 节点动态绑定，当节点数据发生变化时能够更新字段的值</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DCCValueBeanFactory</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BASE_CONFIG_PATH = <span class="string">"/big-market-dcc"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BASE_CONFIG_PATH_CONIG = BASE_CONFIG_PATH + <span class="string">"/conig"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CuratorFramework client;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String,Object&gt; dccObjGroup = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DCCValueBeanFactory</span><span class="params">(CuratorFramework client)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">/**/</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    <span class="doctag">@Override</span></span></span><br><span class="line"><span class="comment">    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span></span><br><span class="line"><span class="comment">      /*</span></span><br><span class="line"><span class="comment">      扫描 Bean 的字段</span></span><br><span class="line"><span class="comment">        获取当前 Bean 的所有字段。</span></span><br><span class="line"><span class="comment">        准备遍历这些字段，检查是否包含 <span class="doctag">@DCCValue</span> 注解。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">        Class&lt;?&gt; beanClass = bean.getClass();</span><br><span class="line">        Field[] declaredFields = beanClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          处理包含 @DCCValue 注解的字段</span></span><br><span class="line"><span class="comment">            条件判断：如果字段没有标注 @DCCValue，跳过处理。</span></span><br><span class="line"><span class="comment">            获取注解信息：提取 @DCCValue 注解的内容。</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">            <span class="keyword">if</span>(!declaredField.isAnnotationPresent(DCCValue<span class="class">.<span class="keyword">class</span>)) <span class="title">continue</span></span>;</span><br><span class="line">            DCCValue dccValue = declaredField.getAnnotation(DCCValue<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          解析注解值</span></span><br><span class="line"><span class="comment">            注解的 value 定义了与 ZooKeeper 节点的映射关系，</span></span><br><span class="line"><span class="comment">						格式为 "key:defaultValue"。</span></span><br><span class="line"><span class="comment">            key 是 ZooKeeper 节点的名称。</span></span><br><span class="line"><span class="comment">            defaultValue 是默认值（如果未指定默认值，则为 null）。</span></span><br><span class="line"><span class="comment">            通过 split 将注解值拆分成节点路径和默认值</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">            String value = dccValue.value();</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(value)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(declaredField.getName() + <span class="string">" @DCCValue is not config value config case 「isSwitch/isSwitch:1」"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            String[] split = value.split(<span class="string">":"</span>);</span><br><span class="line">            String key = split[<span class="number">0</span>];</span><br><span class="line">            String defaultValue = split.length == <span class="number">2</span> ? split[<span class="number">1</span>] : <span class="keyword">null</span>;</span><br><span class="line">						</span><br><span class="line">          	<span class="comment">/*</span></span><br><span class="line"><span class="comment">          	检查并创建 ZooKeeper 节点</span></span><br><span class="line"><span class="comment">              节点存在检查：通过 client.checkExists() </span></span><br><span class="line"><span class="comment">              判断 ZooKeeper 中是否存在对应的节点。</span></span><br><span class="line"><span class="comment">              1. 如果节点不存在，则自动创建节点，并设置默认值（如果有）。</span></span><br><span class="line"><span class="comment">              2. 如果节点已经存在，从 ZooKeeper 中读取节点数据，将节点数据设置到字段中</span></span><br><span class="line"><span class="comment">          	*/</span></span><br><span class="line">            String keyPath = BASE_CONFIG_PATH.concat(<span class="string">"/"</span>).concat(key);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span> == client.checkExists().forPath(keyPath)) &#123;</span><br><span class="line">                    client.create().creatingParentsIfNeeded().forPath(keyPath);</span><br><span class="line">                    <span class="keyword">if</span>(StringUtils.isBlank(defaultValue)) &#123;</span><br><span class="line">                        declaredField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        declaredField.set(bean,defaultValue);</span><br><span class="line">                        declaredField.setAccessible(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    log.info(<span class="string">"DCC 节点监听 创建节点 &#123;&#125;"</span>, keyPath);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    String configValue = <span class="keyword">new</span> String(client.getData().forPath(keyPath));</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isNotBlank(configValue)) &#123;</span><br><span class="line">                        declaredField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        declaredField.set(bean,configValue);</span><br><span class="line">                        declaredField.setAccessible(<span class="keyword">false</span>);</span><br><span class="line">                        log.info(<span class="string">"DCC 节点监听 设置配置 &#123;&#125; &#123;&#125; &#123;&#125;"</span>, keyPath, declaredField.getName(), configValue);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//注册字段与 Bean 的映射,将字段所在的 Bean 和节点路径绑定</span></span><br><span class="line">          <span class="comment">//便于后续监听时能够快速找到对应的 Bean 和字段。</span></span><br><span class="line">            dccObjGroup.put(keyPath,bean);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><ul>
<li><strong>动态配置注入</strong>:<ul>
<li>通过在 Bean 的字段上使用 <code>@DCCValue</code> 注解，开发者可以轻松地将 Zookeeper 中的配置值注入到 Spring Bean 中，无需手动编写配置加载逻辑。</li>
</ul>
</li>
<li><strong>实时配置更新</strong>:<ul>
<li>由于 <code>DCCValueBeanFactory</code> 使用 <code>CuratorCache</code> 监听配置路径下的节点变化，当 Zookeeper 中的配置发生变化时，相关 Bean 的字段值会被实时更新，保证应用程序始终使用最新的配置。</li>
</ul>
</li>
<li><strong>默认值支持</strong>:<ul>
<li>如果 Zookeeper 中没有对应的配置值，可以在注解中指定默认值，确保应用程序在缺失配置时仍能正常运行。</li>
</ul>
</li>
</ul>
<h3 id="示例流程"><a href="#示例流程" class="headerlink" title="示例流程"></a>示例流程</h3><ol>
<li><strong>启动时</strong>:<ul>
<li>Spring 容器初始化 <code>DCCValueBeanFactory</code>。</li>
<li><code>DCCValueBeanFactory</code> 检查并创建基础配置路径 <code>/big-market-dcc/conig</code>。</li>
<li>遍历所有 Bean，查找被 <code>@DCCValue</code> 注解标注的字段，加载对应的配置值到字段中。如果配置不存在，则使用默认值。</li>
</ul>
</li>
<li><strong>运行时</strong>:<ul>
<li>当 Zookeeper 中某个配置节点（如 <code>/big-market-dcc/conig/isSwitch</code>）的值发生变化时，<code>CuratorCache</code> 监听到 <code>NODE_CHANGED</code> 事件。</li>
<li><code>DCCValueBeanFactory</code> 根据变化的节点路径找到对应的 Bean 和字段，动态更新字段的值。</li>
</ul>
</li>
</ol>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><strong>动态配置管理</strong>:<ul>
<li>在分布式系统中，配置管理往往需要集中化和动态化。通过这种方式，可以在不重启应用的情况下，实时更新配置，提高系统的灵活性和可维护性。</li>
</ul>
</li>
<li><strong>特性开关（Feature Toggle）</strong>:<ul>
<li>可以通过动态配置来控制应用程序的特性开关，快速启用或禁用某些功能，便于灰度发布和 A/B 测试。</li>
</ul>
</li>
<li><strong>环境配置隔离</strong>:<ul>
<li>在不同的运行环境（如开发、测试、生产）中，通过 Zookeeper 管理不同的配置，简化配置管理和部署流程。</li>
</ul>
</li>
</ul>
<h3 id="答疑1"><a href="#答疑1" class="headerlink" title="答疑1"></a>答疑1</h3><p><strong>修改zookeeper的节点值时，是否必须连接到Leader节点？</strong></p>
<p><strong>应用节点无需直接连接到 Leader 节点</strong>，可以连接到 Zookeeper 集群中的任意一个节点（Leader 或 Followers）。当应用节点连接到 Followers 并尝试执行写操作时，Zookeeper 的客户端库（如 Curator）会自动将写请求重定向到当前的 Leader。具体过程如下：</p>
<ol>
<li><strong>连接到任意节点</strong>：应用程序通过 CuratorFramework 客户端连接到 Zookeeper 集群中的任意一个节点。</li>
<li><strong>执行写操作</strong>：<ul>
<li>如果客户端连接的是 Leader 节点，写请求将直接由 Leader 处理。Leader会更新事务日志，并通过 ZAB 协议将变更同步到 Followers。</li>
<li>如果客户端连接的是 Followers 节点，Followers 会将写请求转发给 Leader 节点。</li>
</ul>
</li>
<li><strong>自动重定向</strong>：CuratorFramework 客户端会自动处理重定向，无需应用程序显式管理。这确保了写操作总是由 Leader 处理，保持数据一致性。</li>
</ol>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a><strong>优势</strong></h4><ul>
<li><strong>透明性</strong>：应用程序无需关心当前 Leader 是哪个节点，简化了客户端实现。</li>
<li><strong>高可用性</strong>：即使 Leader 发生故障，客户端可以自动切换到新的 Leader，保持写操作的连续性。</li>
<li><strong>负载均衡</strong>：读请求可以由任意节点处理，分散了负载压力。</li>
</ul>
<h3 id="大营销项目中使用动态配置管理"><a href="#大营销项目中使用动态配置管理" class="headerlink" title="大营销项目中使用动态配置管理"></a>大营销项目中使用动态配置管理</h3><p>在这里，我们用DCCValue注解标识了degradSwitch，并将其默认值设置成了open</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RaffleActivityController</span> <span class="keyword">implements</span> <span class="title">IRaffleActivityService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@DCCValue</span>(<span class="string">"degradeSwitch:open"</span>)</span><br><span class="line">    <span class="keyword">private</span> String degradeSwitch;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*省略*/</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"draw"</span>, method = RequestMethod.POST)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response&lt;ActivityDrawResponseDTO&gt; <span class="title">draw</span><span class="params">(@RequestBody ActivityDrawRequestDTO requestDTO)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">"活动抽奖开始 userId:&#123;&#125; activityId:&#123;&#125;"</span>, requestDTO.getUserId(), requestDTO.getActivityId());</span><br><span class="line">            <span class="keyword">if</span> (!<span class="string">"open"</span>.equals(degradeSwitch)) &#123;</span><br><span class="line">                log.info(<span class="string">"当前degradeSwitch配置降级: &#123;&#125;"</span>,degradeSwitch);</span><br><span class="line">                <span class="keyword">return</span> Response.&lt;ActivityDrawResponseDTO&gt;builder()</span><br><span class="line">                        .code(ResponseCode.DEGRADE_SWITCH.getCode())</span><br><span class="line">                        .info(ResponseCode.DEGRADE_SWITCH.getInfo())</span><br><span class="line">                        .build();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(<span class="string">"当前degradeSwitch配置: &#123;&#125;"</span>,degradeSwitch);</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">/*省略*/</span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>项目运行启动之后，会自动扫描带有@DCCValue注解的Bean，并在zookeeper中注册一个节点，存储其默认的值。如下所示：<br><img src="/2024/12/23/zookeeper%E5%AD%A6%E4%B9%A0/4.png" style="zoom:67%;"></p>
<p>而且，我们发现切换zookeeper实例的时候，发现每个实例中都有这个degradeSwitch节点，并且节点的值都是open。</p>
<p>如果我们通过一些方法改变zookeeper上的degradeSwitch节点值，那么这个变化就会被监听到，从而对应的Bean对象的值就会被修改。</p>
<p>如果活动降级、熔断了，那么就会进入这个if判断，返回一个null值。</p>
<h4 id="结合-Zookeeper-与-Redis-的最佳实践"><a href="#结合-Zookeeper-与-Redis-的最佳实践" class="headerlink" title="结合 Zookeeper 与 Redis 的最佳实践"></a><strong>结合 Zookeeper 与 Redis 的最佳实践</strong></h4><p>鉴于 Zookeeper 和 Redis 各自的优势和局限性，在某些场景下，结合使用这两者可以更好地满足分布式系统的需求。以下是一些最佳实践：</p>
<ul>
<li><strong>配置管理</strong>：继续使用 Zookeeper 进行集中式配置管理，确保强一致性。使用 Redis 作为配置的缓存层，提高读取性能。</li>
<li><strong>分布式锁</strong>：在需要高性能和快速锁定的场景下，使用 Redis 实现分布式锁；在需要强一致性和复杂锁定机制的场景下，使用 Zookeeper。</li>
<li><strong>服务发现</strong>：使用 Zookeeper/Nacos 进行服务发现和注册，确保服务实例的动态变化能够被客户端实时感知。</li>
<li><strong>消息传递和通知</strong>：使用 Redis 的 Pub/Sub 或 Keyspace Notifications 进行实时消息传递和事件通知。</li>
</ul>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2024/12/23/dubbo%E5%92%8Cnacos%E5%9C%A8%E5%A4%A7%E8%90%A5%E9%94%80%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/12/23/dubbo%E5%92%8Cnacos%E5%9C%A8%E5%A4%A7%E8%90%A5%E9%94%80%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/" itemprop="url">dubbo和nacos在大营销项目中的应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-12-23T13:08:11+08:00">
                2024-12-23
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2024-12-24T12:36:31+08:00">
                2024-12-24
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="dubbo和nacos在大营销项目中的应用"><a href="#dubbo和nacos在大营销项目中的应用" class="headerlink" title="dubbo和nacos在大营销项目中的应用"></a>dubbo和nacos在大营销项目中的应用</h1><h2 id="Dubbo配置流程以及踩坑情况"><a href="#Dubbo配置流程以及踩坑情况" class="headerlink" title="Dubbo配置流程以及踩坑情况"></a>Dubbo配置流程以及踩坑情况</h2><h3 id="引入dubbo和nacos"><a href="#引入dubbo和nacos" class="headerlink" title="引入dubbo和nacos"></a>引入dubbo和nacos</h3><ol>
<li>在项目根pom文件中引入nacos：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.nacos<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>配置<code>application-dev.xml</code></li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dubbo:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">big-market</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">1.0</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">id:</span> <span class="string">nacos-registry</span></span><br><span class="line">    <span class="attr">address:</span> <span class="string">nacos://127.0.0.1:8848</span></span><br><span class="line">  <span class="attr">protocol:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dubbo</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">-1</span></span><br><span class="line">  <span class="attr">scan:</span></span><br><span class="line">    <span class="attr">base-packages:</span> <span class="string">io.github.jasonxqh.api</span></span><br></pre></td></tr></table></figure>
<h4 id="dubbo-application"><a href="#dubbo-application" class="headerlink" title="dubbo.application"></a>dubbo.application</h4><p><strong><code>name</code></strong>:</p>
<ul>
<li><strong>作用</strong>：定义 Dubbo 应用的名称。这个名称在服务注册中心（如 Nacos）中用于标识该应用。</li>
<li><strong>意义</strong>：便于在注册中心中区分不同的 Dubbo 应用，尤其在微服务架构中有多个应用时。</li>
</ul>
<p><strong><code>version</code></strong>:</p>
<ul>
<li><strong>作用</strong>：指定应用的版本号。</li>
<li><strong>意义</strong>：用于服务版本管理，可以在同一个接口的不同版本之间进行区分和兼容。例如，不同版本的服务可以同时存在，消费者可以选择调用特定版本的服务。</li>
</ul>
<h4 id="dubbo-registry"><a href="#dubbo-registry" class="headerlink" title="dubbo.registry"></a>dubbo.registry</h4><p><strong><code>id</code></strong>:</p>
<ul>
<li><strong>作用</strong>：给注册中心实例指定一个唯一标识符。</li>
<li><strong>意义</strong>：在配置多个注册中心时，通过 <code>id</code> 区分不同的注册中心实例。</li>
</ul>
<p><strong><code>address</code></strong>:</p>
<ul>
<li><strong>作用</strong>：指定注册中心的地址和协议。</li>
<li><strong>值</strong>： <code>nacos://127.0.0.1:8848</code><ul>
<li><strong><code>nacos</code></strong>：表示使用 <strong>Nacos</strong> 作为注册中心。</li>
<li><strong><code>127.0.0.1:8848</code></strong>：Nacos 注册中心的地址和端口。</li>
</ul>
</li>
<li><strong>意义</strong>：Dubbo 服务提供者和消费者通过这个地址与 Nacos 进行通信，实现服务的注册与发现。</li>
</ul>
<h4 id="dubbo-protocol"><a href="#dubbo-protocol" class="headerlink" title="dubbo.protocol"></a>dubbo.protocol</h4><ul>
<li><strong><code>name</code></strong>:<ul>
<li><strong>作用</strong>：指定使用的通信协议。</li>
<li><strong>值</strong>：<code>dubbo</code>，表示使用 <strong>Dubbo</strong> 协议。</li>
<li><strong>意义</strong>：Dubbo 支持多种协议（如 <code>dubbo</code>、<code>rmi</code>、<code>http</code> 等），选择合适的协议以满足不同的性能和兼容性需求。</li>
</ul>
</li>
<li><strong><code>port</code></strong>:<ul>
<li><strong>作用</strong>：指定服务提供者监听的端口号。</li>
<li><strong>值</strong>：<code>-1</code> 表示自动分配端口。</li>
<li><strong>意义</strong>：<ul>
<li><strong>自动分配</strong>：在开发或测试环境中，使用自动分配端口可以避免端口冲突，简化配置。</li>
<li><strong>固定端口</strong>：在生产环境中，建议指定固定端口，便于服务的管理和监控。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="dubbo-scan"><a href="#dubbo-scan" class="headerlink" title="dubbo.scan"></a>dubbo.scan</h4><p><strong><code>base-packages</code></strong>:</p>
<ul>
<li><strong>作用</strong>：指定 Dubbo 扫描注解的基础包路径。</li>
<li><strong>值</strong>：<code>io.github.jasonxqh.api</code></li>
<li><strong>意义</strong>：<ul>
<li><strong>自动扫描</strong>：Dubbo 会自动扫描指定包及其子包下的类，查找并注册带有 Dubbo 注解（如 <code>@DubboService</code>、<code>@DubboReference</code>）的服务提供者和消费者。</li>
<li><strong>简化配置</strong>：无需在每个类上单独配置注册信息，提升开发效率。</li>
</ul>
</li>
</ul>
<h3 id="启动nacos"><a href="#启动nacos" class="headerlink" title="启动nacos"></a>启动nacos</h3><p>首先，要在</p>
<p>在<code>docker-compose-environment</code>中配置nacos信息，运行后 拉取镜像，即可启动</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># http://127.0.0.1:8848/nacos 【账号：nacos 密码：nacos】</span></span><br><span class="line"><span class="attr">nacos:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">nacos/nacos-server:v2.2.3-slim</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">nacos</span></span><br><span class="line">  <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"8848:8848"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"9848:9848"</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">PREFER_HOST_MODE=hostname</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">MODE=standalone</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_PLATFORM=mysql</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_HOST=mysql</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_DB_NAME=nacos_config</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_PORT=3306</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_USER=root</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_PASSWORD=123456</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_DB_PARAM=characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useSSL=false&amp;allowPublicKeyRetrieval=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">NACOS_AUTH_IDENTITY_KEY=2222</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">NACOS_AUTH_IDENTITY_VALUE=2xxx</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">NACOS_AUTH_TOKEN=SecretKey012345678901234567890123456789012345678901234567890123456789</span></span><br><span class="line">  <span class="attr">networks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">my-network</span></span><br><span class="line">  <span class="attr">depends_on:</span></span><br><span class="line">    <span class="attr">mysql:</span></span><br><span class="line">      <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br></pre></td></tr></table></figure>
<p><strong><code>MYSQL_SERVICE_HOST=mysql</code></strong>：</p>
<ul>
<li><strong>含义</strong>：指定 MySQL 服务的主机名为 <code>mysql</code>。在 Docker Compose 中，服务之间可以通过服务名互相通信。因此，<code>mysql</code> 指的是同一 Docker Compose 文件中定义的名为 <code>mysql</code> 的服务。</li>
</ul>
<p><strong><code>networks: - my-network</code></strong>：</p>
<ul>
<li><strong>含义</strong>：将 Nacos 容器加入到名为 <code>my-network</code> 的 Docker 网络中。</li>
</ul>
<p><strong><code>depends_on: mysql</code></strong>：</p>
<ul>
<li><strong>含义</strong>：Nacos 服务依赖于名为 <code>mysql</code> 的服务，并且在 MySQL 服务健康（<code>service_healthy</code>）后才启动。</li>
</ul>
<p><strong><code>MYSQL_SERVICE_PORT=3306</code></strong>：</p>
<ul>
<li><strong>含义</strong>：指定 MySQL 服务的端口为 <code>3306</code>，这是 MySQL 的默认端口。</li>
</ul>
<h3 id="Dubbo-服务提供者-DubboService"><a href="#Dubbo-服务提供者-DubboService" class="headerlink" title="Dubbo 服务提供者(@DubboService)"></a>Dubbo 服务提供者(<code>@DubboService</code>)</h3><p>  <code>@DubboService</code> 是 <strong>Dubbo</strong> 提供的注解，用于标识一个类为 <strong>Dubbo 服务提供者</strong>。它相当于 <strong>Spring</strong> 中的 <code>@Service</code> 注解，但专门用于 <strong>Dubbo 服务的发布和注册</strong>。</p>
<h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a><strong>主要功能</strong></h4><ul>
<li><strong>服务发布</strong>：将标注的类作为 Dubbo 服务提供者，自动将其注册到注册中心（如 Nacos、Zookeeper）。</li>
<li><strong>配置服务属性</strong>：通过注解属性配置服务的版本、分组、超时、重试次数等参数。</li>
<li><strong>支持多协议和多注册中心</strong>：允许在不同的协议和注册中心下发布服务实例。</li>
</ul>
<h4 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a><strong>常用属性</strong></h4><ul>
<li><strong><code>version</code></strong>：指定服务的版本号，用于区分不同版本的服务。</li>
<li><strong><code>group</code></strong>：指定服务的分组，便于在同一个注册中心中管理不同组的服务。</li>
<li><strong><code>interfaceName</code></strong>：指定服务接口的全限定名（不常用，通常通过接口类自动推断）。</li>
<li><strong><code>timeout</code></strong>：调用超时时间，单位毫秒。</li>
<li><strong><code>retries</code></strong>：失败重试次数。</li>
<li><strong><code>protocol</code></strong>：指定服务使用的协议</li>
</ul>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RestController</span>()</span><br><span class="line"><span class="meta">@CrossOrigin</span>(<span class="string">"*"</span>)</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/api/v1/raffle/activity"</span>)</span><br><span class="line"><span class="meta">@DubboService</span>(</span><br><span class="line">    version = <span class="string">"1.0"</span>,</span><br><span class="line">    group = <span class="string">"user-group"</span>,</span><br><span class="line">    timeout = <span class="number">5000</span>,</span><br><span class="line">    retries = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RaffleActivityController</span> <span class="keyword">implements</span> <span class="title">IRaffleActivityService</span> </span>&#123;</span><br><span class="line"> 		 <span class="comment">/**/</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>自动注册</strong>：<code>@DubboService</code> 注解会自动将 <code>RaffleActivityController</code> 类注册为 Dubbo 服务，Dubbo 会根据配置将其信息发布到注册中心。</li>
<li><strong>版本与分组</strong>：通过 <code>version</code> 和 <code>group</code> 属性，可以在同一注册中心中管理不同版本和不同组的服务，避免冲突和提高灵活性。</li>
<li><strong>超时与重试</strong>：通过 <code>timeout</code> 和 <code>retries</code> 属性，控制服务调用的容错行为，提升系统的鲁棒性。</li>
</ul>
<h4 id="bug1"><a href="#bug1" class="headerlink" title="bug1"></a>bug1</h4><p>在我正确在<code>application-dev.yml</code> 中配置dubbo时，一开始出现了这个问题，spring无法扫描到我的配置信息。</p>
<p><img src="/2024/12/23/dubbo%E5%92%8Cnacos%E5%9C%A8%E5%A4%A7%E8%90%A5%E9%94%80%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/Samsung_T5/JasonXQH.github.io/source/_posts/大营销项目中遇到的bug与心得/5.jpg" style="zoom:67%;"></p>
<p>解决：这种问题很坑，一般不是我们的代码问题，单纯是idea没有刷新配置文件。我们清理缓存并重启即可。</p>
<h3 id="Dubbo-服务消费者-DubboReference"><a href="#Dubbo-服务消费者-DubboReference" class="headerlink" title="Dubbo 服务消费者(@DubboReference)"></a>Dubbo 服务消费者(<code>@DubboReference</code>)</h3><p><code>@DubboReference</code> 是 <strong>Dubbo</strong> 提供的注解，用于注入 <strong>Dubbo 服务消费者</strong>，即引用远程的 Dubbo 服务。它相当于 <strong>Spring</strong> 中的 <code>@Autowired</code> 注解，但专门用于引用远程服务。</p>
<ol>
<li>在 测试项目中，引入注册到nacos中的包,然后编写测试类：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ApiTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DubboReference</span>(interfaceClass = IRaffleActivityService<span class="class">.<span class="keyword">class</span>, <span class="title">version</span> </span>= <span class="string">"1.0"</span>)</span><br><span class="line">    <span class="keyword">private</span> IRaffleActivityService raffleActivityService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_rpc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ActivityDrawRequestDTO request = <span class="keyword">new</span> ActivityDrawRequestDTO();</span><br><span class="line">        request.setActivityId(<span class="number">100301L</span>);</span><br><span class="line">        request.setUserId(<span class="string">"xiaofuge"</span>);</span><br><span class="line">        Response&lt;ActivityDrawResponseDTO&gt; response = raffleActivityService.draw(request);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"请求参数：&#123;&#125;"</span>, JSON.toJSONString(request));</span><br><span class="line">        log.info(<span class="string">"测试结果：&#123;&#125;"</span>, JSON.toJSONString(response));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>@DubboReference</code>：<ul>
<li><strong>作用</strong>：这是 <strong>Dubbo</strong> 提供的注解，用于注入远程服务的引用（即消费者）。</li>
<li>属性说明：<ul>
<li><strong><code>interfaceClass</code></strong>：指定要引用的远程服务接口类。</li>
<li><strong><code>version</code></strong>：指定服务的版本，用于区分不同版本的服务实例。</li>
</ul>
</li>
<li>优势：<ul>
<li><strong>简化配置</strong>：通过注解方式注入远程服务，无需手动配置服务地址。</li>
<li><strong>动态代理</strong>：Dubbo 自动生成代理对象，简化服务调用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>注意</strong>：确保 <strong>Dubbo</strong> 已正确配置，且 <code>IRaffleActivityService</code> 接口在服务提供者和消费者中版本一致，且接口类在两端保持同步。</p>
</blockquote>
<h4 id="bug2"><a href="#bug2" class="headerlink" title="bug2"></a>bug2</h4><p>在大营销项目中，需要先 <code>mvn clean install</code>重新构建项目所有的包，这样测试项目中才能引入最新版本的包。否则会出现引用到过去没有serialize的DTO的报错<img src="/2024/12/23/dubbo%E5%92%8Cnacos%E5%9C%A8%E5%A4%A7%E8%90%A5%E9%94%80%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/Samsung_T5/JasonXQH.github.io/source/_posts/大营销项目中遇到的bug与心得/5.jpg" style="zoom:67%;"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2024/12/16/%E5%A4%A7%E8%90%A5%E9%94%80-%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/12/16/%E5%A4%A7%E8%90%A5%E9%94%80-%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/" itemprop="url">大营销-更新日志</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-12-16T13:44:50+08:00">
                2024-12-16
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2025-04-11T10:15:52+08:00">
                2025-04-11
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="大营销-更新日志"><a href="#大营销-更新日志" class="headerlink" title="大营销-更新日志"></a>大营销-更新日志</h1><h2 id="12-06"><a href="#12-06" class="headerlink" title="12.06"></a>12.06</h2><ul>
<li>2.0版本部署成功<ul>
<li>增加分库分表，支持分布式部署</li>
<li>完善用户抽奖功能</li>
</ul>
</li>
</ul>
<h2 id="12-16"><a href="#12-16" class="headerlink" title="12.16"></a>12.16</h2><ul>
<li><p>3.0版本部署成功，网址<a href="http://117.72.108.9:3000/?userId=xxx&amp;activityId=100301" target="_blank" rel="noopener">http://117.72.108.9:3000/?userId=xxx&amp;activityId=100301</a></p>
<ul>
<li>实现积分功能<ul>
<li>积分兑换抽奖次数</li>
<li>积分查询</li>
<li>sku产品列表</li>
</ul>
</li>
</ul>
</li>
<li><p>TODOLIST</p>
<ol>
<li>分布式架构的引入</li>
<li>抽奖10次接口</li>
<li>滚动播放排：xxx抽中了xxx</li>
</ol>
</li>
</ul>
<h2 id="12-23"><a href="#12-23" class="headerlink" title="12.23"></a>12.23</h2><ul>
<li>引入dubbo+nacos配置</li>
</ul>
<h2 id="12-30"><a href="#12-30" class="headerlink" title="12.30"></a>12.30</h2><ul>
<li>引入降级策略和限流策略</li>
</ul>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><h3 id="达到权重值之后，可选择消耗幸运值阶梯次数，来实现保底抽奖"><a href="#达到权重值之后，可选择消耗幸运值阶梯次数，来实现保底抽奖" class="headerlink" title="达到权重值之后，可选择消耗幸运值阶梯次数，来实现保底抽奖"></a>达到权重值之后，可选择消耗幸运值阶梯次数，来实现保底抽奖</h3><p><img src="/2024/12/16/%E5%A4%A7%E8%90%A5%E9%94%80-%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/1.png"></p>
<p>思路：</p>
<ul>
<li>首先，在数据库中添加两个字段，我想着是把他添加到<code>raffle_activity_account</code>表格中，</li>
</ul>
<p>之前查询抽奖次数使用的是这个函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 查询用户抽奖总次数</span></span><br><span class="line">Integer userActivityAccountTotalUseCount  = raffleActivityAccountQuotaService.queryActivityAccountPartakeCount(userId,activityId);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">queryActivityAccountPartakeCount</span><span class="params">(String userId, Long activityId)</span> </span>&#123;</span><br><span class="line">        RaffleActivityAccount raffleActivityAccount = accountDao.queryActivityAccountByUserIdAndActivityId(RaffleActivityAccount.builder()</span><br><span class="line">                .activityId(activityId)</span><br><span class="line">                .userId(userId)</span><br><span class="line">                .build());</span><br><span class="line">        <span class="keyword">return</span> raffleActivityAccount.getTotalCount()-raffleActivityAccount.getTotalCountSurplus();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>是将总Count减去getTotalCountSurplus得到的。</p>
<ol>
<li>步骤1：添加字段</li>
</ol>
<ul>
<li>现在我想加入两个字段，1个是<code>total_raffled_count</code>,代表该用户已经抽过多少次的奖了，1个是<code>available_raffled_count</code>,代表用户当前可使用在保底抽奖上的抽奖次数。</li>
<li>在用户抽奖,更新<code>raffle_activity_account</code>的时候，可以同步更新<code>total_raffled_count</code>为<code>raffleActivityAccount.getTotalCount()-raffleActivityAccount.getTotalCountSurplus();</code></li>
<li>同时更新<code>available_raffled_count = available_raffled_count + 1</code>(这个1即抽奖次数，但是未来可能会开发10连抽功能，因此这个1需要修改的，参考<code>raffle_activity_sku</code>的做法)</li>
</ul>
<ol>
<li>步骤2：改变查询方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">queryActivityAccountPartakeCount</span><span class="params">(String userId, Long activityId)</span> </span>&#123;</span><br><span class="line">    RaffleActivityAccount raffleActivityAccount = accountDao.queryActivityAccountByUserIdAndActivityId(RaffleActivityAccount.builder()</span><br><span class="line">            .activityId(activityId)</span><br><span class="line">            .userId(userId)</span><br><span class="line">            .build());</span><br><span class="line">    <span class="keyword">return</span> raffleActivityAccount.getAvailableRaffledCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，在责任链节点中，由于也需要查询抽奖次数，因此也要做相应的修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">queryActivityAccountTotalUseCount</span><span class="params">(String userId, Long strategyId)</span> </span>&#123;</span><br><span class="line">    Long activityId = raffleActivityDao.queryActivityIdByStrategyId(strategyId);</span><br><span class="line">    RaffleActivityAccount raffleActivityAccount = raffleActivityAccountDao.queryActivityAccountByUserIdAndActivityId(RaffleActivityAccount.builder()</span><br><span class="line">            .activityId(activityId)</span><br><span class="line">            .userId(userId)</span><br><span class="line">            .build());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> raffleActivityAccount.getAvailableRaffledCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>消耗已抽奖的次数，兑换保底抽奖机会</li>
</ol>
<p>当用户消耗抽奖次数兑换保底的时候，会扣减<code>available_raffled_count</code>的值，同时走规则树策略，抽保底。</p>
<ul>
<li>需要喜修改draw 这个 api，传入参数是：抽奖阶梯的id，用户id，是否需要开启保底抽奖的判断flag</li>
<li>api的功能：根据抽奖阶梯id，从<code>raffle_activity_account</code>中，扣去available_raffled_count次数，再保底抽奖，走责任链rule weight节点。如果不点击保底抽奖，那么就不需要走责任链rule weight节点。</li>
</ul>
<h3 id="使用异步线程增加10连抽的功能"><a href="#使用异步线程增加10连抽的功能" class="headerlink" title="使用异步线程增加10连抽的功能"></a>使用异步线程增加10连抽的功能</h3><ol>
<li>系统配置一套活动、规则，发奖部分增加再来一次的奖品发放</li>
<li></li>
<li>监控系统</li>
<li>订单ID，引用了hutool包的雪花算法加redis自增Id作为wokerId同时把用户分库分表放在后缀，这样可以通过订单直接查询，就是太长25位(弃用了)</li>
</ol>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2024/11/21/%E4%B8%80%E4%BA%9B%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/11/21/%E4%B8%80%E4%BA%9B%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/" itemprop="url">一些提高效率的开发技巧</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-11-21T10:45:43+08:00">
                2024-11-21
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2024-12-04T16:41:33+08:00">
                2024-12-04
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="好用插件："><a href="#好用插件：" class="headerlink" title="好用插件："></a>好用插件：</h2><ul>
<li>vo2dto 对象转换</li>
<li>Easy Javadoc 一键生成注释 </li>
<li>MyBatisCodeHelper,自动生成dao,mapper.xml和po对象</li>
</ul>
<p><img src="/2024/11/21/%E4%B8%80%E4%BA%9B%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/2.png" style="zoom:67%;"></p>
<ul>
<li>SequenceDiagram,生成调用图</li>
</ul>
<h2 id="C-Clion"><a href="#C-Clion" class="headerlink" title="C++/Clion"></a>C++/Clion</h2><p>对于一个项目，我们在没有编译的时候，无法代码跳转，这时候怎么办？</p>
<p><img src="/2024/11/21/%E4%B8%80%E4%BA%9B%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/1.png" style="zoom:67%;"></p>
<p>可以直接对文件夹右键标记为Project Sources and Headers</p>
<h2 id="统计行数"><a href="#统计行数" class="headerlink" title="统计行数"></a>统计行数</h2><p>使用<code>cloc</code>，可以更方便的统计文件夹下的代码数量。安装方式：<code>brew install cloc</code></p>
<p><img src="/2024/11/21/%E4%B8%80%E4%BA%9B%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/3.png" style="zoom:67%;"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2024/11/20/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/11/20/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%AD%A6%E4%B9%A0/" itemprop="url">分库分表学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-11-20T11:14:40+08:00">
                2024-11-20
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2025-04-11T10:18:15+08:00">
                2025-04-11
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="分库分表学习"><a href="#分库分表学习" class="headerlink" title="分库分表学习"></a>分库分表学习</h1><p><a href="https://articles.zsxq.com/id_xq8o4sj295df.html" target="_blank" rel="noopener">https://articles.zsxq.com/id_xq8o4sj295df.html</a></p>
<p><img src="/2024/11/20/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%AD%A6%E4%B9%A0/1.png"></p>
<h3 id="AOP核心概念"><a href="#AOP核心概念" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h3><p><a href="https://javaguide.cn/system-design/framework/spring/ioc-and-aop.html#%E4%BB%80%E4%B9%88%E6%98%AF-aop" target="_blank" rel="noopener">可参考 JavaGuide的博客</a> ,具体的不在这里介绍了。</p>
<h2 id="分库分表哪里体现了AOP"><a href="#分库分表哪里体现了AOP" class="headerlink" title="分库分表哪里体现了AOP?"></a>分库分表哪里体现了AOP?</h2><p>数据库分库分表组件在这篇文章中已经介绍得很详细了，我们要学习的是这个组件中哪里体现出来了AOP，以及说当我们进行分库分表查询的时候，源码的调用逻辑是怎么样的。</p>
<p>我们要思考，在这个分库分表组件中，AOP的关键核心，在哪里体现出来了？</p>
<h3 id="横切关注点（cross-cutting-concerns）"><a href="#横切关注点（cross-cutting-concerns）" class="headerlink" title="横切关注点（cross-cutting concerns）"></a>横切关注点（cross-cutting concerns）</h3><p>横切关注点指的是多个类或对象中的公共行为（如日志记录、事务管理、权限控制、接口限流、接口幂等等）。</p>
<p><strong>数据库路由逻辑</strong>是这个组件的横切关注点，包括：</p>
<ul>
<li>从方法参数中解析路由字段（<code>getAttrValue</code>）。</li>
<li>根据路由字段计算目标库和表的索引（<code>dbRouterStrategy.doRouter</code>）。</li>
<li>在 SQL 执行时动态修改表名（MyBatis 拦截器）。</li>
<li>清理 <code>ThreadLocal</code> 中的路由信息（<code>dbRouterStrategy.clear</code>）。</li>
</ul>
<h3 id="切面（Aspect）"><a href="#切面（Aspect）" class="headerlink" title="切面（Aspect）"></a>切面（Aspect）</h3><p>切面是对横切关注点进行封装的类，一个切面是一个类。切面可以定义多个通知，用来实现具体的功能。</p>
<p>逻辑分为两部分：</p>
<ol>
<li>方法级别的路由逻辑：<ul>
<li>使用 <code>@Around</code> 注解的 <code>doRouter</code> 方法，将路由逻辑应用到带有 <code>@DBRouter</code> 注解的方法。</li>
<li>实现动态路由的核心逻辑。</li>
</ul>
</li>
<li>SQL 级别的表名替换<ul>
<li>MyBatis 拦截器中的 <code>intercept</code> 方法，用于拦截并修改 SQL，完成分表逻辑。</li>
</ul>
</li>
</ol>
<p>切面贯穿了方法调用和 SQL 执行两个层面。</p>
<h3 id="连接点（JoinPoint）"><a href="#连接点（JoinPoint）" class="headerlink" title="连接点（JoinPoint）"></a>连接点（JoinPoint）</h3><p>连接点是方法调用或者方法执行时的某个特定时刻（如方法调用、异常抛出等）。</p>
<ol>
<li>方法调用：<ul>
<li>带有 <code>@DBRouter</code> 注解的方法是连接点，例如 <code>service.insertUser()</code> 方法。</li>
</ul>
</li>
<li>SQL 执行：<ul>
<li>MyBatis 拦截器中的 <code>BoundSql</code> 是另一个连接点，表示每次执行的 SQL 语句。</li>
</ul>
</li>
</ol>
<p>连接点提供了拦截点，切面通过切点筛选具体的连接点。</p>
<h3 id="通知（Advice）："><a href="#通知（Advice）：" class="headerlink" title="通知（Advice）："></a><strong>通知（Advice）</strong>：</h3><p>通知就是切面在某个连接点要执行的操作。通知有五种类型，分别是前置通知（Before）、后置通知（After）、返回通知（AfterReturning）、异常通知（AfterThrowing）和环绕通知（Around）。前四种通知都是在目标方法的前后执行，而环绕通知可以控制目标方法的执行过程。 </p>
<h4 id="在组件中的体现："><a href="#在组件中的体现：" class="headerlink" title="在组件中的体现："></a>在组件中的体现：</h4><ol>
<li><strong>方法级通知</strong>：<ul>
<li>在 <code>doRouter</code> 方法中：<ul>
<li><strong>前置逻辑</strong>：解析路由字段，计算库表索引（<code>dbRouterStrategy.doRouter</code>）。</li>
<li><strong>环绕逻辑</strong>：通过 <code>jp.proceed()</code> 执行业务方法。</li>
<li><strong>后置逻辑</strong>：清理路由信息（<code>dbRouterStrategy.clear</code>）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>SQL 级通知</strong>：<ul>
<li>在 MyBatis 拦截器中的 <code>intercept</code> 方法：<ul>
<li><strong>前置逻辑</strong>：提取 SQL 表名。</li>
<li><strong>环绕逻辑</strong>：通过动态修改 <code>BoundSql</code> 替换表名。</li>
<li><strong>后置逻辑</strong>：恢复原始状态（如果有需要）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="切点（Pointcut）："><a href="#切点（Pointcut）：" class="headerlink" title="切点（Pointcut）："></a><strong>切点（Pointcut）</strong>：</h3><p>一个切点是一个表达式，它用来匹配哪些连接点需要被切面所增强。切点可以通过注解、正则表达式、逻辑运算等方式来定义。比如 <code>execution(* com.xyz.service..*(..))</code>匹配 <code>com.xyz.service</code> 包及其子包下的类或接口。 </p>
<h4 id="在组件中的体现：-1"><a href="#在组件中的体现：-1" class="headerlink" title="在组件中的体现："></a>在组件中的体现：</h4><p>切点通过以下方式定义：</p>
<ol>
<li><p><strong>方法级切点</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"aopPoint() &amp;&amp; @annotation(dbRouter)"</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>aopPoint()</code> 是一个通用的切点定义（可能是包或类范围）。</li>
<li><code>@annotation(dbRouter)</code> 限定只拦截带有 <code>@DBRouter</code> 注解的方法。</li>
</ul>
</li>
<li><p><strong>SQL 级切点</strong>：</p>
<ul>
<li>MyBatis 插件拦截了 <code>StatementHandler</code> 接口的 <code>prepare</code> 方法，用于动态修改 SQL。</li>
</ul>
</li>
</ol>
<p>切点将通知与具体的连接点绑定，决定哪些方法或 SQL 会被拦截。</p>
<h3 id="织入（Weaving）："><a href="#织入（Weaving）：" class="headerlink" title="织入（Weaving）："></a><strong>织入（Weaving）</strong>：</h3><p>织入是将切面和目标对象连接起来的过程，也就是将通知应用到切点匹配的连接点上。常见的织入时机有两种，分别是编译期织入（Compile-Time Weaving 如：AspectJ）和运行期织入（Runtime Weaving 如：AspectJ、Spring AOP）。</p>
<h4 id="在组件中的体现：-2"><a href="#在组件中的体现：-2" class="headerlink" title="在组件中的体现："></a>在组件中的体现：</h4><ol>
<li><strong>方法级织入</strong>：<ul>
<li>Spring AOP 在运行时使用动态代理，将 <code>doRouter</code> 的切面逻辑织入到带有 <code>@DBRouter</code> 注解的方法中。</li>
<li>例如，当调用 <code>service.insertUser()</code> 时，Spring AOP 代理会触发 <code>doRouter</code> 方法。</li>
</ul>
</li>
<li><strong>SQL 级织入</strong>：<ul>
<li>MyBatis 拦截器在运行时动态修改 SQL 执行流程，通过反射直接修改 SQL 表名。</li>
<li>每次执行 SQL 时，<code>intercept</code> 方法会被调用，动态替换表名。</li>
</ul>
</li>
</ol>
<p>织入过程确保切面逻辑能够在正确的连接点上执行。</p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="简单技术问题："><a href="#简单技术问题：" class="headerlink" title="简单技术问题："></a>简单技术问题：</h3><ol>
<li><p>什么是 AOP？在 DB-Router 中如何应用 AOP？</p>
</li>
<li><p>AbstractRoutingDatasource 是什么？它的作用是什么？</p>
</li>
<li><p>ThreadLocal是什么？在 DB-Router 中是如何使用的？</p>
</li>
<li><p>什么是哈希散列？在 DB-Router 中为什么选择了哈希散列算法？</p>
</li>
<li><p>SAC 测试是什么？在 DB-Router 中如何应用 SAC测试？</p>
</li>
</ol>
<h3 id="中等技术问题："><a href="#中等技术问题：" class="headerlink" title="中等技术问题："></a>中等技术问题：</h3><ol>
<li><p>什么是 MyBatis Plugin？ 在 DB-Router 中如何应用 MyBatis Plugin 实现动态变更表信息？<br> 2.分库分表的散列算法有哪些，各自的优缺点是什么？</p>
</li>
<li><p>在 DB-Router 中如何支持个性化的分库分表控制？请结合具体实例说明。</p>
</li>
<li><p>在 DB-Router 中如何实现扩展监控、扫描、策略等规则？</p>
</li>
<li><p>什么是雪崩测试？在 DB-Router 中如何进行雪崩测试？</p>
</li>
</ol>
<h3 id="难度技术问题："><a href="#难度技术问题：" class="headerlink" title="难度技术问题："></a>难度技术问题：</h3><ol>
<li><p>在 DB-Router 的架构模型中，如何实现扩展性和灵活性的平衡？</p>
</li>
<li><p>在 DB-Router 中如何保证数据路由的高效性和准确性？</p>
</li>
<li><p>在 DB-Router 中，如何避免分库分表后产生的性能问题？</p>
</li>
<li><p>在 DB-Router 中如何应对高并发的场景？请结合具体实例说明。</p>
</li>
<li><p>在 DB-Router 的设计过程中，遇到了哪些技术难点？是如何解决的？<br>  可合</p>
</li>
</ol>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/%5Bobject%20Object%5D"
                alt="Jason" />
            
              <p class="site-author-name" itemprop="name">Jason</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20fa%20fa-archive">
              
                  <span class="site-state-item-count">435</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">61</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="true"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
 <!--
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>







-->
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>




















  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v="></script>

  <script type="text/javascript" src="/js/src/motion.js?v="></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v="></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
