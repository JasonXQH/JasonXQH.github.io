<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="y0-26jFM_8wn6Slpy1ahkB8ndR7w0OOGyAU6IaXjLUI" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="JavaScript,web期末," />










<meta name="description" content="OOP-in-JavaScript这篇博客我们来谈谈JavaScript 面向对象编程 这是为了给期末大作业打下基础，因为我打算用react来实现前端框架。而react是OOP的典形应用之一 学习资料： Mosh老师的OOP in JavaScript B站搬运视频 ObjectsObject Literals首先来看看声明一个类，可以用的关键词 var let const  var定义的变量，作">
<meta property="og:type" content="article">
<meta property="og:title" content="OOP-in-JavaScript">
<meta property="og:url" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/index.html">
<meta property="og:site_name" content="Jason‘s Blog">
<meta property="og:description" content="OOP-in-JavaScript这篇博客我们来谈谈JavaScript 面向对象编程 这是为了给期末大作业打下基础，因为我打算用react来实现前端框架。而react是OOP的典形应用之一 学习资料： Mosh老师的OOP in JavaScript B站搬运视频 ObjectsObject Literals首先来看看声明一个类，可以用的关键词 var let const  var定义的变量，作">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/1.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/2.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/3.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/4.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/5.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/8.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/6.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/7.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/9.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/11.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/12.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/14.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/16.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/17.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/18.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/19.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/20.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/21.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/22.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/23.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/25.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/26.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/27.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/28.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/29.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/30.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/31.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/32.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/33.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/40.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/42.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/43.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/35.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/36.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/37.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/38.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/39.png">
<meta property="article:published_time" content="2020-05-25T16:06:10.000Z">
<meta property="article:modified_time" content="2020-07-07T14:27:04.000Z">
<meta property="article:author" content="Jason">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="web期末">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/"/>





  <title>OOP-in-JavaScript | Jason‘s Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-170027658-1', 'auto');
  ga('send', 'pageview');
</script>





<meta name="generator" content="Hexo 4.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">
  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
<a href="https://github.com/JasonXQH/JasonXQH.github.io" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jason‘s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">OOP-in-JavaScript</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-26T00:06:10+08:00">
                2020-05-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  10.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  42
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="OOP-in-JavaScript"><a href="#OOP-in-JavaScript" class="headerlink" title="OOP-in-JavaScript"></a>OOP-in-JavaScript</h1><p>这篇博客我们来谈谈JavaScript 面向对象编程</p>
<p>这是为了给期末大作业打下基础，因为我打算用react来实现前端框架。而react是OOP的典形应用之一</p>
<p>学习资料：</p>
<p><a href="https://codewithmosh.com/p/object-oriented-programming-in-javascript" target="_blank" rel="noopener">Mosh老师的OOP in JavaScript</a></p>
<p><a href="https://www.bilibili.com/video/BV1gb411w7eW?p=1" target="_blank" rel="noopener">B站搬运视频</a></p>
<h2 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h2><h3 id="Object-Literals"><a href="#Object-Literals" class="headerlink" title="Object Literals"></a>Object Literals</h3><p>首先来看看声明一个类，可以用的关键词 var let const</p>
<ul>
<li><p><strong>var</strong>定义的变量，作用域是整个封闭函数，是全域的；<strong>let</strong>定义的变量，作用域是在块级或者字块中；</p>
</li>
<li><p>变量提升：不论通过var声明的变量处于当前作用于的第几行，都会提升到作用域的最顶部。 而let声明的变量不会在顶部初始化，凡是在let声明之前使用该变量都会报错（引用错误ReferenceError）；</p>
</li>
<li><p>只要块级作用域内存在let，它所声明的变量就会绑定在这个区域；</p>
</li>
<li><p>let不允许在相同作用域内重复声明（报错同时使用var和let，两个let）。</p>
</li>
<li><p><strong>const</strong>用来专门声明一个常量，它跟let一样作用于块级作用域，没有变量提升，重复声明会报错，不同的是<strong>const声明的常量不可改变，声明时必须初始化（赋值）</strong></p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> circle = &#123;</span><br><span class="line">    radius:<span class="number">1</span>,</span><br><span class="line">    location:&#123;</span><br><span class="line">        x: <span class="number">1</span>,</span><br><span class="line">        y: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    draw:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'draw'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//输出 draw</span></span><br></pre></td></tr></table></figure>
<h3 id="Factories-工厂模式"><a href="#Factories-工厂模式" class="headerlink" title="Factories 工厂模式"></a>Factories 工厂模式</h3><p>但是像上面那样生成一个对象的话，如果要声明很多对象（具有相同的性质），每个对象中又有很多方法的话。实在是太麻烦了，所以我们要用工厂模式创建。</p>
<p>对象定义规则：</p>
<p>冒号和属性值之间要用空格</p>
<p>我们把方法也当作一个对象的属性，所以定义方法的时候为 名字: function(){}</p>
<p>比如draw: function(){} 其实相当于function draw(){}，就是在对象直接量中定义的函数的时候要用到这个写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCircle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        radius,	<span class="comment">// es6 的新语法，如果属性名和传入变量名称一致，不需要再做赋值，直接等于即可</span></span><br><span class="line">        location: &#123;</span><br><span class="line">            x:<span class="number">1</span>,</span><br><span class="line">            y:<span class="number">1</span></span><br><span class="line">        &#125;,	<span class="comment">//属性和属性之间要用逗号断开</span></span><br><span class="line">        draw: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'draw'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> circle = createCircle(<span class="number">1</span>);</span><br><span class="line">circle.draw();</span><br></pre></td></tr></table></figure>
<h3 id="Constructors-构造函数"><a href="#Constructors-构造函数" class="headerlink" title="Constructors 构造函数"></a>Constructors 构造函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this'</span>,<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    <span class="keyword">this</span>.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'draw'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> another = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果 const another = Circle(1);</span></span><br><span class="line"><span class="comment">控制台输出：这显然变成了一个Window 对象</span></span><br><span class="line"><span class="comment">this Window &#123;parent: Window, opener: null, top: Window, length: 0, frames: Window, …&#125;</span></span><br><span class="line"><span class="comment">如果 const another = new Circle(1);</span></span><br><span class="line"><span class="comment">他就是一个Object对象</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>我们既可以用工厂模式创建对象，也可以用构造函数来创建对象，我们对两者都需要熟悉</p>
<p>对于构造函数创建对象这种方法，我们一定需要 new + 构造函数</p>
<p>对于工厂模式创建方法，直接调用创建函数即可</p>
<h3 id="Constructor-Property"><a href="#Constructor-Property" class="headerlink" title="Constructor Property"></a>Constructor Property</h3><p><img src="/2020/05/26/OOP-in-JavaScript/1.png" style="zoom:100%;"></p>
<p>我们看到由两种不同函数构造出来的两个对象的constructor也是不一样的，由构造函数构造出来的another对象是利用自己的构造函数Circle()</p>
<p>由工厂模式构造出来的circle函数，构造函数时 Object() 也就是说createCircle函数会调用new Object()并返回</p>
<h3 id="Functions-are-Objects"><a href="#Functions-are-Objects" class="headerlink" title="Functions are Objects"></a>Functions are Objects</h3><p>比较难理解的就是JavaScript中的类是通过函数的形式存在的，可以说函数即对象。</p>
<p><img src="/2020/05/26/OOP-in-JavaScript/2.png" style="zoom:100%;"></p>
<p>对上面Circle的构造函数来说 ，我们显示了他几个属性，我们同样看出来了，Circle函数是通过Function()这个构造函数构造出来的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this'</span>,<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    <span class="keyword">this</span>.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'draw'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AND</span></span><br><span class="line">    <span class="keyword">const</span> Circle1 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'radius'</span>,<span class="string">`</span></span><br><span class="line"><span class="string">       this.radius = radius;</span></span><br><span class="line"><span class="string">    this.draw = function () &#123;</span></span><br><span class="line"><span class="string">        console.log('draw')</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    `</span>);</span><br><span class="line"><span class="comment">//这两个函数表达的意思是一样的，只不过Circle自己调用了Function(),而Circle1则手动调用了Function()</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/26/OOP-in-JavaScript/3.png" style="zoom:200%;"></p>
<p>函数（类）的一些方法</p>
<h4 id="call-和-apply"><a href="#call-和-apply" class="headerlink" title="call 和 apply"></a>call 和 apply</h4><ul>
<li>call()和apply()的第一个实参都为this的值，即使传入的实参是原始值或者null或者undefined</li>
<li>call()，第一个参数之后的所有实参是要传入待调用函数的值；</li>
<li>apply()实参都放到一个数组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this'</span>,<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    <span class="keyword">this</span>.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'draw'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Circle.call(&#123;&#125;,<span class="number">1</span>)			 	<span class="comment">//把1传给一个空对象</span></span><br><span class="line"><span class="keyword">const</span> another =<span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Value-vs-Reference-Types"><a href="#Value-vs-Reference-Types" class="headerlink" title="Value vs Reference Types"></a>Value vs Reference Types</h3><p><img src="/2020/05/26/OOP-in-JavaScript/4.png" style="zoom: 50%;"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> y = x;</span><br><span class="line">x=<span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/26/OOP-in-JavaScript/5.png" style="zoom:100%;"></p>
<p>显示如上图，我们可以看到这和python是不一样的。当我们声明两个变量x,y的时候。x和y是相互独立的</p>
<p>但是当我们这样写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = &#123;<span class="attr">value</span>: <span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> y =  x;</span><br><span class="line">x.value = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/26/OOP-in-JavaScript/8.png" style="zoom:100%;"></p>
<p>就会这样显示，这是因为什么呢？如下图</p>
<p><img src="/2020/05/26/OOP-in-JavaScript/6.png" style="zoom: 50%;"></p>
<p><img src="/2020/05/26/OOP-in-JavaScript/7.png" style="zoom: 50%;"></p>
<p>这是因为当我们声明一个对象的时候，value:10 并没有存储在这个变量x里，而是存储在一段内存当中，而变量x存储的只是那段内存的地址。所以当令y = x的时候，事实上赋值给y的是一段地址，而非值。所以导致x,y都指向了同一段内存。自然，当value的值改变的时候，x，y都跟着改变了</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>就是：Primitives(基本类型) are copied by their Value，Objects(对象) are copied by their reference</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increase</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">    number++;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br><span class="line">increase(number);</span><br><span class="line"><span class="built_in">console</span>.log(number);			<span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(increase(number));	<span class="comment">// 11</span></span><br></pre></td></tr></table></figure>
<p>从这里我们可以很清楚的看见，当调用increase(number)的时候，传入的number只是把value值赋给了函数中的number的值，但是在外面的number还是10.</p>
<p>如果把返回值输出的话，可以得到11，但这任然没有改变number = 10</p>
<p>如果我们把number换成一个对象，又会有什么变化呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> number = &#123;<span class="attr">value</span> :<span class="number">10</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increase</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    obj.value++;</span><br><span class="line">&#125;</span><br><span class="line">increase(number);</span><br><span class="line"><span class="built_in">console</span>.log(number.value)<span class="comment">// 11</span></span><br></pre></td></tr></table></figure>
<p>我们得到这样的结果，原理如下，我们传进去一个number对象，然后再这个increase函数里把这个对象的地址付给了obj，随后让obj的value属性+1，因为obj和number指向的是同一块内存，所以在外面number.value 也会相应的变化</p>
<h3 id="Adding-or-Removing-Properties"><a href="#Adding-or-Removing-Properties" class="headerlink" title="Adding or Removing Properties"></a>Adding or Removing Properties</h3><p>由构造或者工厂模式创建的对象，都是动态对象，我们可以在这个对象中添加或者删除属性。</p>
<h3 id="运用-的方法"><a href="#运用-的方法" class="headerlink" title="运用 . 的方法"></a>运用 . 的方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this'</span>,<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    <span class="keyword">this</span>.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'draw'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle = <span class="keyword">new</span> Circle(<span class="number">10</span>);		</span><br><span class="line">circle.location = &#123; <span class="attr">x</span>:<span class="number">1</span> &#125;; 		<span class="comment">//利用点的方式添加属性</span></span><br><span class="line"><span class="keyword">delete</span> circle.location;			<span class="comment">//delete+ . 来删除属性</span></span><br></pre></td></tr></table></figure>
<h3 id="运用方括号"><a href="#运用方括号" class="headerlink" title="运用方括号"></a>运用方括号</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> propertyName = <span class="string">'location'</span></span><br><span class="line">circle[propertyName] = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>方括号的操作比点要麻烦一点，但是可以动态访问</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> propertyName = <span class="string">'center location'</span></span><br><span class="line">circle.center location</span><br></pre></td></tr></table></figure>
<p>而且当遇到属性名称中间有特殊符号或者空格的时候，不能用点来访问，这时候需要用方括号来访问</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> circle[location];</span><br></pre></td></tr></table></figure>
<p>删除的时候也只需要在方括号中写上属性名称即可</p>
<h3 id="Enumerating-Properties"><a href="#Enumerating-Properties" class="headerlink" title="Enumerating Properties"></a>Enumerating Properties</h3><p>使用  for…in..遍历，可以打印出所有对象中的 属性，方法 的索引<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this'</span>,<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    <span class="keyword">this</span>.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'draw'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle = <span class="keyword">new</span> Circle(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> circle)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印 radius和draw</span></span><br></pre></td></tr></table></figure><br>如果希望直接输出索引存储的值，或者调用方法的话，可以这样写console.log(key,circle[key] );<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> circle)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key,circle[key] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/2020/05/26/OOP-in-JavaScript/9.png" style="zoom: 90%;"></p>
<p>如果只想打印属性，需要在前面利用typeof做一个判断<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> circle)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> circle[key]!== <span class="string">'function'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(key,circle[key] );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//只打印属性，不打印方法</span></span><br></pre></td></tr></table></figure><br>如果只想输出索引，以数组的形式呈现，那么利用Object对象的key方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(circle);</span><br><span class="line"><span class="built_in">console</span>.log(keys)</span><br><span class="line"><span class="comment">// 输出["radius","draw"],无法区分是属性还是方法</span></span><br></pre></td></tr></table></figure><br>可以利用 in 操作符判断一个对象中是否有该属性或方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">'radius'</span> <span class="keyword">in</span> circle)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Circle has a radius'</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="Abstraction"><a href="#Abstraction" class="headerlink" title="Abstraction"></a>Abstraction</h3><p><strong>Hide the details, Show the essentials</strong></p>
<p>我们应该隐藏我们不想让外界访问到的比较复杂的和细节的部分，我们只要显示我们认为必要的部分。就比如说DVD，dvd含有非常复杂的线路板，但是他只给我们几个按钮（公共接口)来操作，这就是我们要对对象做的事情</p>
<p>如果不这样做，外部一直调用我们对象中的方法，那么对象中的一个小小的改变，外面很多的代码都要相应的修改，这是很麻烦的事情</p>
<h3 id="Private-Properties-and-Methods"><a href="#Private-Properties-and-Methods" class="headerlink" title="Private Properties and Methods"></a>Private Properties and Methods</h3><p>如何实现上面的目标，我们需要用私有属性和私有方法。</p>
<p>那么和C++中的直接放在private:中不同，和python中两根下划线或者@property也不一样，因为JavaScript当中函数和对象是一个定义，所以我们只要把 这个方法或者属性从对象中移走，把它变成函数当中的属性或者方法就可以了。</p>
<p>也就是说，我们只要简单的把 this.属性/方法 替换成 let 属性/方法，就能实现隐藏</p>
<p>在这里我们一定要用let，因为上文说过，let声明的变量或者方法只在这个语句块中实现。但是var声明的是全局变量。所以当我们使用let声明变量和方法的时候，出了这个函数，两者就失效了。这达到了我们Abstraction的目的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    <span class="keyword">let</span> computeOptimumlocation = <span class="function"><span class="keyword">function</span> (<span class="params">factor</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> defaultLocation= &#123;<span class="attr">x</span>:<span class="number">0</span>,<span class="attr">y</span>:<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">this</span>.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> x,y;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'draw'</span>)</span><br><span class="line">        computeOptimumlocation(<span class="number">0.1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不要把闭包和作用域混淆。作用域只是临时的，但是闭包是永恒的。 </p>
<p>就像上面在draw方法中的x,y，每次调用draw方法的时候，x,y都会重新被创建，然后当draw结束以后，两个x,y就死掉了。</p>
<p>但是闭包不一样，在调用好computeOptimumlocation之后，computeOptimumlocation任然存在在函数当中 。而且他们会保持自己的状态，因为他们是draw方法的闭包</p>
<p>现在，在外面，是没有办法访问defaultLocation和computeOptimumlocation这两个属性和方法的！</p>
<p>像上面的写法也有缺陷，因为严格意义上let声明的属性和方法并不是Circle对象的成员，他们只是Circle函数内部的局部变量而已。如果从面向对象的角度，我们仍然可以称他们为Circle对象的私有成员。因为我们没有办法去修改或者读取它</p>
<h3 id="Getters-and-Setters"><a href="#Getters-and-Setters" class="headerlink" title="Getters and Setters"></a>Getters and Setters</h3><p>那么我们怎么样能够在外面读取对象中的私有属性呢？(只读不写)</p>
<p>一般的，我们可以定义一个方法，然后方法中返回这个私有属性，但是这样在外面调用的时候，显得很麻烦，因为要调用一个方法，再返回一个属性。</p>
<p>所以我们可以用 Object.defineProperties()或者Object.defineProperty()这个方法（一个和多个属性的区别）这个方法的用处有三个参数，第一个参数是this，第二个参数是添加属性的名称，第三个参数就是一个对象，里面存放键值对， get:function(){} 和 set:function(){}</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    <span class="keyword">let</span> computeOptimumlocation = <span class="function"><span class="keyword">function</span> (<span class="params">factor</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> defaultLocation= &#123;<span class="attr">x</span>:<span class="number">0</span>,<span class="attr">y</span>:<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">this</span>.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'draw'</span>)</span><br><span class="line">        computeOptimumlocation(<span class="number">0.1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>,<span class="string">'defaultLocation'</span>,&#123;</span><br><span class="line">       <span class="keyword">get</span>: function () &#123;</span><br><span class="line">            <span class="keyword">return</span> defaultLocation;</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="keyword">set</span>: function (value) &#123;</span><br><span class="line">           <span class="keyword">if</span>(!value.x||!value.y)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Invalid location.'</span>)</span><br><span class="line">           defaultLocation = value;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle = <span class="keyword">new</span> Circle(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(circle.defaultLocation);</span><br><span class="line">circle.defaultLocation = &#123;<span class="attr">x</span>:<span class="number">2</span>,<span class="attr">y</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(circle.defaultLocation);</span><br></pre></td></tr></table></figure>
<p>get就是我们读取信息的方法，那么set就是我们设置这个私有属性的方法（我们如果不希望外界修改，就不要写set了）</p>
<p>当我们想要显示这个信息的时候呢console.log(circle.defaultLocation)</p>
<p><img src="/2020/05/26/OOP-in-JavaScript/11.png" style="zoom: 90%;"></p>
<p>如果我们输出的value是不合法的（比如说只输入了一个）那么就会报错。</p>
<h3 id="Exercise-Stopwatch"><a href="#Exercise-Stopwatch" class="headerlink" title="Exercise- Stopwatch"></a>Exercise- Stopwatch</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StopWatch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> startTime,stopTime,running,duration = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.start = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(running)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Stopwatch has already started!'</span>);</span><br><span class="line">        running= <span class="literal">true</span>;</span><br><span class="line">        startTime =<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.stop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!running)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Stopwatch has already stopped!'</span>);</span><br><span class="line">        running = <span class="literal">false</span>;</span><br><span class="line">        stopTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="keyword">const</span> seconds = (stopTime.getTime()-startTime.getTime())/<span class="number">1000</span>;</span><br><span class="line">        <span class="comment">//得到的是毫秒数，所以要除以1000</span></span><br><span class="line">        duration +=seconds;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.reset = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        startTime = <span class="literal">null</span>;</span><br><span class="line">        stopTime = <span class="literal">null</span>;</span><br><span class="line">        running = <span class="literal">false</span>;</span><br><span class="line">        duration = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>,<span class="string">'duration'</span>,&#123;</span><br><span class="line">        <span class="keyword">get</span>: function () &#123;</span><br><span class="line">            <span class="keyword">return</span> duration;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Prototypes"><a href="#Prototypes" class="headerlink" title="Prototypes"></a>Prototypes</h2><h3 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h3><p><img src="/2020/05/26/OOP-in-JavaScript/12.png" style="zoom: 67%;"></p>
<p>有两种继承方式：Classical （类继承）和prototype（原型继承）</p>
<h3 id="Prototypes-and-Prototypical-Inheritance"><a href="#Prototypes-and-Prototypical-Inheritance" class="headerlink" title="Prototypes and Prototypical Inheritance"></a>Prototypes and Prototypical Inheritance</h3><p>在JavaScript中，没有类，只有对象。那么只有对象的话如何引入继承呢？</p>
<p>我们就把原来的shape看作是原型(prototype)，然后把属性和方法都放到这个原型中去。注意，原型其实就是一个一般的对象。每个对象(除了元对象)都会有原型</p>
<p>在Javascript中创建的对象直接或间接地继承自元对象（Object） ，元对象在JavaScript中是所有对象的根对象。Object对象没有原对象 </p>
<p><img src="/2020/05/26/OOP-in-JavaScript/14.png" style="zoom: 33%;"></p>
<p>在内存中，只有一个元对象</p>
<p><img src="/2020/05/26/OOP-in-JavaScript/16.png" style="zoom: 67%;"></p>
<p>当寻找一个方法的时候，JavaScript引擎会在这个对象里找，如果找不到，就到这个对象的原型对象去找，如果还是找不到，就继续沿着原型链往上找，一直找到元对象位置。这就是原型继承的工作原理</p>
<p>可以看到__proto__属性都是由一个对象指向一个对象，即指向它们的原型对象（也可以理解为父对象），那么这个属性的作用是什么呢？它的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的__proto__属性所指向的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找…直到原型链顶端null（可以理解为原始人。。。），再往上找就相当于在null上取值，会报错（可以理解为，再往上就已经不是“人”的范畴了，找不到了，到此结束，null为原型链的终点），由以上这种通过__proto__属性来连接对象直到null的一条链即为我们所谓的原型链。</p>
<p> 其实我们平时调用的字符串方法、数组方法、对象方法、函数方法等都是靠__proto__继承而来的。</p>
<h3 id="Multilevel-Inheritance"><a href="#Multilevel-Inheritance" class="headerlink" title="Multilevel Inheritance"></a>Multilevel Inheritance</h3><p>比如我们声明一个数组对象myArray。数组对象myArray是继承自arrayBase（数组元对象）的</p>
<p><img src="/2020/05/26/OOP-in-JavaScript/17.png" style="zoom: 67%;"></p>
<p>我们看都在最后一行，这个数组元对象的原型对象是 ObjectBase（元对象）示意图如下：</p>
<p><img src="/2020/05/26/OOP-in-JavaScript/18.png" style="zoom: 33%;"></p>
<p>我们如果自己写一个构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    <span class="keyword">this</span>.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> x,y;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'draw'</span>)</span><br><span class="line">        computeOptimumlocation(<span class="number">0.1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> circle = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>那么所有这个构造函数构造出来的对象，都具有同一个原型。比如这里的circle对象的原型对象就是CircleBase，CircleBase也有一个元对象，就是ObjectBase</p>
<p><img src="/2020/05/26/OOP-in-JavaScript/19.png" style="zoom: 33%;"></p>
<h3 id="Property-Descriptors"><a href="#Property-Descriptors" class="headerlink" title="Property Descriptors"></a>Property Descriptors</h3><p>我们虽然可以在一个对象中调用它原型对象的方法或者属性，但是我们却无法通过Objec.keys()或者 for…in…这种方法遍历 <strong>元对象</strong> 的属性。但毕竟元对象是所有对象的根对象，为什么没有办法迭代遍历呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>:<span class="string">'Jason'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> objectBase = <span class="built_in">Object</span>.getPrototypeOf(person);</span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(objectBase,<span class="string">'toString'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor);</span><br></pre></td></tr></table></figure>
<p>在console中</p>
<p><img src="/2020/05/26/OOP-in-JavaScript/20.png" style="zoom: 100%;"></p>
<p>我们发现他的enumerable属性是false，也就是说这个toString方法，是不可以被枚举的。writable说明这个方法可以被重写</p>
<p>我们可以对自己创造的对象的属性进行属性的定义</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>:<span class="string">'Jason'</span>&#125;;</span><br><span class="line"> <span class="built_in">Object</span>.defineProperty(person,<span class="string">'name'</span>,&#123;</span><br><span class="line">     writable: <span class="literal">false</span></span><br><span class="line">     enumerable: <span class="literal">true</span></span><br><span class="line">     configurable:<span class="literal">false</span></span><br><span class="line"> &#125;);</span><br><span class="line"> person.name = <span class="string">'John '</span>;</span><br><span class="line"> <span class="built_in">console</span>.log(person.name)</span><br><span class="line"><span class="comment">//我们发现名字并没有发生改变</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(person));</span><br><span class="line"><span class="comment">// ["name"],因为我们设置了这个name属性是可迭代，可枚举的</span></span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(person));</span><br><span class="line"><span class="comment">// ["name"],因为configurable 为false，是不可以被删除的</span></span><br></pre></td></tr></table></figure>
<p>在默认情况下，所有属性都是可写可枚举可配置的</p>
<h3 id="Constructor-Prototypes"><a href="#Constructor-Prototypes" class="headerlink" title="Constructor Prototypes"></a>Constructor Prototypes</h3><p><a href="https://blog.csdn.net/cc18868876837/article/details/81211729?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">在这篇博客讲的很清楚</a></p>
<p><img src="/2020/05/26/OOP-in-JavaScript/21.png" style="zoom: 60%;"></p>
<p><strong>constructor 属性</strong>的含义就是<strong>指向该对象的构造函数</strong>，所有函数（此时看成对象了）最终的构造函数都指向<strong>Function</strong>。从上图中可以看出<strong>Function</strong>这个对象比较特殊，它的构造函数就是它自己（因为Function可以看成是一个函数，也可以是一个对象）</p>
<p><strong>prototype属性</strong>，别忘了一点 , 它是函数所独有的，它是从一个<strong>函数</strong>指向一个<strong>对象</strong>。它的含义是<strong>函数的原型对象</strong>，也就是这个函数（其实所有函数都可以作为构造函数）所创建的<strong>实例的原型对象</strong>，由此可知：f1.__proto__ === Foo.prototype，它们两个完全一样。</p>
<p>获得对象原型的方法是调用Object对象的getPrototypeOf() 方法</p>
<p>Object.prototype()是所有对象的爸爸</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Circle.prototype === circle.__proto__</span><br><span class="line"><span class="built_in">Array</span>.prototype === arr.__proto__</span><br><span class="line"><span class="keyword">let</span> x = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.prototype === x.__proto__</span><br></pre></td></tr></table></figure>
<h3 id="Prototype-vs-Instance-Members"><a href="#Prototype-vs-Instance-Members" class="headerlink" title="Prototype vs Instance Members"></a>Prototype vs Instance Members</h3><p><strong>js中可以说函数就是类，类就是函数。</strong></p>
<p>①<code>__proto__</code>和<code>constructor</code>属性是<strong>对象</strong>所独有的；② <code>prototype</code>属性是<strong>函数</strong>所独有的。但是由于JS中函数也是一种对象，所以函数也拥有<code>__proto__</code>和<code>constructor</code>属性，这点是致使我们产生困惑的很大原因之一。</p>
<p>从上面我们已经知道要给MyClss类的本身增加方法，需要讲方法定义在MyClass这个函数内部，这样的话，每声明一个新的实例，就会将MyClass本身复制一遍，这显然不是最优的做法。</p>
<p>既然不能将一个类（函数）所包含的方法都定义在函数的内部，那么，如何来给一个类添加方法呢？这就需要用到函数的prototype属性了。 </p>
<p>那prototype属性的作用又是什么呢？它的作用就是<strong>包含可以由特定类型的所有实例共享的属性和方法</strong>，也就是<strong>让该函数所实例化的对象们都可以找到公用的属性和方法</strong>。<strong>任何</strong>函数在创建的时候，其实会<strong>默认同时创建该函数的prototype对象。</strong></p>
<p>所以根据prototype的属性我们知道了，虽然新创建的对象可以使用它的构造函数所指向的prototype对象的属性和方法，但不能像构造函数那样直接调用prototype对象。</p>
<p>简而言之，就是如果我们使用函数的prototype对象来给函数添加方法，那么在创建一个新的对象的时候，并不会复制这个函数的所有方法，而是指向了这函数的所有方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line">Circle.prototype.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'draw'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> c1 = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> c2 = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//如下图，我们发现 c1,c2中并没有发现draw属性，但是c1,c2却可以调用draw属性</span></span><br><span class="line"><span class="comment">//因为draw已经在他们的原型对象里了</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/26/OOP-in-JavaScript/22.png" style="zoom: 60%;"></p>
<h3 id="Iterating-Instance-and-Prototype-Members"><a href="#Iterating-Instance-and-Prototype-Members" class="headerlink" title="Iterating Instance and Prototype Members"></a>Iterating Instance and Prototype Members</h3><p>Object.keys()只返回实例对象的成员</p>
<p>for…in .. () 返回所有可迭代可枚举的成员（在原型链上的）</p>
<p>hasOwnProperty(‘成员名字’)，判断该成员是继承而来的还是实例本省就有的</p>
<h3 id="Avoid-Extending-the-Built-in-Objects"><a href="#Avoid-Extending-the-Built-in-Objects" class="headerlink" title="Avoid Extending the Built-in Objects"></a>Avoid Extending the Built-in Objects</h3><p>我们不应该修改JavaScript中的 Built-in Objects，比如说在Array.prototype 或者 Object.prototype中加入新的方法或者修改原有的方法。因为以后引入的外部库可能也有相同名称的方法但是实现起来却完全不同</p>
<p>Don‘t modify objects you don’t OWN!</p>
<h3 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StopWatch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> startTime,stopTime,running,duration = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//把这些都设置成只读属性</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>,<span class="string">'duration'</span>,&#123;</span><br><span class="line">        <span class="keyword">get</span>: function () &#123;</span><br><span class="line">            <span class="keyword">return</span> duration;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>,<span class="string">'startTime'</span>,&#123;</span><br><span class="line">        <span class="keyword">get</span>: function () &#123;</span><br><span class="line">            <span class="keyword">return</span> startTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>,<span class="string">'stopTime'</span>,&#123;</span><br><span class="line">        <span class="keyword">get</span>: function () &#123;</span><br><span class="line">            <span class="keyword">return</span> stopTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>,<span class="string">'running'</span>,&#123;</span><br><span class="line">        <span class="keyword">get</span>: function () &#123;</span><br><span class="line">            <span class="keyword">return</span> running;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StopWatch.prototype.start = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.running)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Stopwatch has already started!'</span>);</span><br><span class="line">    running = <span class="literal">true</span>;</span><br><span class="line">    startTime =<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">&#125;;</span><br><span class="line">StopWatch.prototype.stop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.running)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Stopwatch has already stopped!'</span>);</span><br><span class="line">    running = <span class="literal">false</span>;</span><br><span class="line">    stopTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">const</span> seconds = (stopTime.getTime()-startTime.getTime())/<span class="number">1000</span>;</span><br><span class="line">    <span class="comment">//得到的是毫秒数，所以要除以1000</span></span><br><span class="line">    duration +=seconds;</span><br><span class="line">&#125;;</span><br><span class="line">StopWatch.prototype.reset = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.startTime = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.stopTime = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.running = <span class="literal">false</span>;</span><br><span class="line">    duration = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//这里要注意，duration前面不要加this,因为这duration作为对象来说是可读属性</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Prototypical-Inheritance"><a href="#Prototypical-Inheritance" class="headerlink" title="Prototypical Inheritance"></a>Prototypical Inheritance</h2><h3 id="1-Creating-Your-Own-Prototypical-Inheritance"><a href="#1-Creating-Your-Own-Prototypical-Inheritance" class="headerlink" title="1- Creating Your Own Prototypical Inheritance"></a>1- Creating Your Own Prototypical Inheritance</h3><p>现在比如说我们有一个圆的构造函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line">Circle.prototype.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Draw'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Circle.prototype.duplicate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Duplicate'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么如果我又想要一个Square 构造函数。又想保留这两个方法，我们是不是要重写？</p>
<p>其实不是，我们可以新建一个Shape 构造函数，再Shape.prototype 中添加这两个属性，然后再让Circle和Square继承Shape即可</p>
<p><img src="/2020/05/26/OOP-in-JavaScript/23.png" style="zoom: 33%;"></p>
<p>所以在这里，我们需要用到这个函数Object.create(proto)</p>
<p>返回值：一个新对象，带着指定的原型对象和属性。</p>
<p>也就是说命令一个Circle的原型对象，让他去等于一个新的，指向ShapeBase的对象，达到了继承的功能</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Circle.prototype = <span class="built_in">Object</span>.create(Shape.prototype)</span><br></pre></td></tr></table></figure>
<p>这里，我们令Shape.prototype作为Circle的原型对象，否则</p>
<p>Circle.prototype = Object.create(Object.prototype)，直接从元对象继承过来</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Shape.prototype.duplicate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Duplicate'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Circle.prototype = <span class="built_in">Object</span>.create(Shape.prototype);<span class="comment">//让Circle继承自Shape</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是在Circle的原型对象中添加方法</span></span><br><span class="line">Circle.prototype.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Draw'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/26/OOP-in-JavaScript/25.png" style="zoom: 100%;"></p>
<p>c是一个实例，这个实例中有一个radius =1 的属性。这个实例的原型是CircleBase对象</p>
<p>CircleBase对象中，我们有一个draw方法。</p>
<p>CircleBase也是继承来的，继承自ShapeBase对象，在ShapeBase对象中有duplicate和constructor这两个方法</p>
<p>CircleBase也是继承来的，继承自Object对象，也就是元对象。</p>
<h3 id="2-Resetting-the-Constructor"><a href="#2-Resetting-the-Constructor" class="headerlink" title="2- Resetting the Constructor"></a>2- Resetting the Constructor</h3><p>但是向上面那样的写法，我们发现Circle.prototype 没有了 constructor方法了 我们就没有办法通过new Circle(1)来创建一个Circle对象了</p>
<p>这时候如果我们这样写 new Circle.prototype.constructor(1);的话，我们发现是这样一个情况</p>
<p><img src="/2020/05/26/OOP-in-JavaScript/26.png" style="zoom: 150%;"></p>
<p>我们看到其实是创建出了一个Shape对象来，这是因为CircleBase并没有constructor,所以他按照原型链向上去找，在ShapeBase中找到了这个constructor方法，但这个方法是Shape的构造函数。所以构造了一个Shape对象出来。</p>
<p>所以，在继承的时候，我们除了需要Object.create()之外，我们还需要Circle.prototype.constructor = Circle;</p>
<p><img src="/2020/05/26/OOP-in-JavaScript/27.png" style="zoom: 150%;"></p>
<p>那么加上这句话，我们可以看到我们利用new Circle.prototype.constructor()或者直接new Circle()构造出来的，就是一个Circle对象了</p>
<h3 id="3-Calling-the-Super-Constructor"><a href="#3-Calling-the-Super-Constructor" class="headerlink" title="3- Calling the Super Constructor"></a>3- Calling the Super Constructor</h3><p>那么我如果在Shape中传入一个color，在Circle中传入一个radius，这样的话我可以直接在Circle构造函数中调用Shape() 方法吗？</p>
<p>这是不行的，因为我们直接调用Shape()而不写new的话，传入的color参数会直接放到window对象（全局对象）当中去，那么如果我们写 new Shape()这就是新建了一个对象，不是我们要的目的。</p>
<p>所以我们的要做的就是把Shape中的color值赋给this对象</p>
<p>利用 Shape.call(this, color) ，就可以对this对象调用Shape方法，并且把color赋值给this对象</p>
<p><img src="/2020/05/26/OOP-in-JavaScript/28.png" style="zoom: 100%;"></p>
<h3 id="4-Intermediate-Function-Inheritance"><a href="#4-Intermediate-Function-Inheritance" class="headerlink" title="4- Intermediate Function Inheritance"></a>4- Intermediate Function Inheritance</h3><p>如果我们要写多级继承或者一个原型对象产生多个子对象的时候，我们会产生很多这样的代码，既不美观又容易犯错，落下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Square.prototype = <span class="built_in">Object</span>.create(Shape.prototype);</span><br><span class="line">Square.prototype.constructor = Square;</span><br></pre></td></tr></table></figure>
<p>所以我们写一个函数来封装这个继承方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">Child,Parent</span>) </span>&#123;</span><br><span class="line">    Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype);</span><br><span class="line">    Child.prototype.constructor = Child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来用这个函数代替刚才的继承代码就好了！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extend(Circle,Shape);</span><br><span class="line">extend(Square,Shape);</span><br></pre></td></tr></table></figure>
<h3 id="5-Method-Overriding"><a href="#5-Method-Overriding" class="headerlink" title="5- Method Overriding"></a>5- Method Overriding</h3><p>在子类中重写基类的方法，重写一定要放在继承代码之后</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extend(Circle,Shape);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius,color</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line">Circle.prototype.duplicate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Duplicate Circle'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果我们想重写基类中的方法的同时也想调用基类中的方法 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Circle.prototype.duplicate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//调用call，传入this</span></span><br><span class="line">    Shape.prototype.duplicate.call(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Duplicate Circle'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/26/OOP-in-JavaScript/29.png" style="zoom: 100%;"></p>
<h3 id="6-Polymorphism多态"><a href="#6-Polymorphism多态" class="headerlink" title="6- Polymorphism多态"></a>6- Polymorphism多态</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Shape.prototype.duplicate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Duplicate'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">extend(Circle,Shape);<span class="comment">//继承函数，上文已提及</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius,color</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line">Circle.prototype.duplicate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Duplicate Circle'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">extend(Square,Shape);</span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Square</span>(<span class="params">size</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line">&#125;</span><br><span class="line">Square.prototype.duplicate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Duplicate Square'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shapes = [</span><br><span class="line">    <span class="keyword">new</span> Circle(),</span><br><span class="line">    <span class="keyword">new</span> Square()</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> shape <span class="keyword">of</span> shapes)&#123;</span><br><span class="line">    shape.duplicate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/26/OOP-in-JavaScript/30.png" style="zoom: 100%;"></p>
<p>这就是多态的作用了</p>
<h3 id="7-When-to-Use-Inheritance"><a href="#7-When-to-Use-Inheritance" class="headerlink" title="7- When to Use Inheritance"></a>7- When to Use Inheritance</h3><p>不是所有的地方都需要用继承，之后还会提到Composition方法</p>
<p><img src="/2020/05/26/OOP-in-JavaScript/31.png" style="zoom: 50%;"></p>
<p>比如这样，就发生了逻辑错误。</p>
<p><img src="/2020/05/26/OOP-in-JavaScript/32.png" style="zoom: 50%;"></p>
<p>正确的层级应该是这样的，但是如果有很多动物，这样的写法会让代码变得脆弱</p>
<p>如果要用继承，做好保存在同一级，不要多层级</p>
<p>记住 Favor Composition over Inheritance</p>
<p>我们通过组合的方式，也就是定义几个基本对象，然后拿来一个对象，我们把适用于这个对象的基本对象放加给它。</p>
<p>听起来有点像面向函数的编程思维。</p>
<h3 id="8-Mixins"><a href="#8-Mixins" class="headerlink" title="8- Mixins"></a>8- Mixins</h3><p>我们创建了三个基本对象：canEat, can Swim, can Walk;</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canEat = &#123;</span><br><span class="line">    eat : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hunger--;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'eating'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> canWalk = &#123;</span><br><span class="line">    walk: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'walking'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> canSwim = &#123;</span><br><span class="line">    swim: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'swim'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(Person.prototype,canEat,canWalk);</span><br><span class="line"><span class="keyword">const</span>  person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Goldfish</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(Goldfish.prototype,canEat,canSwim);</span><br><span class="line"><span class="keyword">const</span> goldfish = <span class="keyword">new</span> Goldfish();</span><br><span class="line"><span class="built_in">console</span>.log(goldfish);</span><br></pre></td></tr></table></figure>
<p>但是这样我们还是不精简，我们可以定义一个mixin函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params">target,...sources</span>)</span>&#123;<span class="comment">//...sources就是说可以传入多个参数</span></span><br><span class="line">    <span class="built_in">Object</span>.assign(target,...sources);</span><br><span class="line">&#125;</span><br><span class="line">mixin(Person.prototype,canSwim,canEat);</span><br><span class="line">mixin(GoldFish.prototype,canSwim,canEat);</span><br></pre></td></tr></table></figure>
<h3 id="9-Exercise-Prototypical-Inheritance"><a href="#9-Exercise-Prototypical-Inheritance" class="headerlink" title="9- Exercise- Prototypical Inheritance"></a>9- Exercise- Prototypical Inheritance</h3><h3 id="10-Solution-Prototypical-Inheritance"><a href="#10-Solution-Prototypical-Inheritance" class="headerlink" title="10- Solution- Prototypical Inheritance"></a>10- Solution- Prototypical Inheritance</h3><h3 id="11-Exercise-Polymorphism"><a href="#11-Exercise-Polymorphism" class="headerlink" title="11- Exercise- Polymorphism"></a>11- Exercise- Polymorphism</h3><h3 id="12-Solution-Polymorphism"><a href="#12-Solution-Polymorphism" class="headerlink" title="12- Solution- Polymorphism"></a>12- Solution- Polymorphism</h3><h2 id="ES6-Classes"><a href="#ES6-Classes" class="headerlink" title="ES6 Classes"></a>ES6 Classes</h2><p><code>注:</code> 5-10小结来自React系列教程，因为是ES6的新语法，和对象也有点关系，所以我把它记录到这里，但是没有用到class</p>
<p><a href="https://www.bilibili.com/video/BV1Sb411P79t?p=17" target="_blank" rel="noopener">React教程</a></p>
<h3 id="1-ES6-Classes"><a href="#1-ES6-Classes" class="headerlink" title="1- ES6 Classes"></a>1- ES6 Classes</h3><p>在ES6中，有一种创建对象和继承关系的新方法-类</p>
<p> 但是类本质上还是函数，只是给函数披上了一层外衣</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(radius) &#123;</span><br><span class="line">        <span class="comment">//这里是在构造函数中定义的属性和方法，实例化的对象中会进行拷贝</span></span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">        <span class="keyword">this</span>.move = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里是在 Circle.prototype 中定义属性和方法</span></span><br><span class="line">    draw()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'draw'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typeof</span> Circle; <span class="comment">// function</span></span><br></pre></td></tr></table></figure>
<p>现在如果我新建一个对象，如果不写new，就会报错</p>
<h3 id="2-Hoisting置顶"><a href="#2-Hoisting置顶" class="headerlink" title="2- Hoisting置顶"></a>2- Hoisting置顶</h3><p>在JavaScript中函数的声明有两种形式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">直接函数声明，可以不写分号</span></span><br><span class="line"><span class="comment">这种声明方式，函数会自动被抬升到代码最上面</span></span><br><span class="line"><span class="comment">所以可以声明之前调用sayHello函数，因为JavaScript引擎会自动置顶</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> sayGoodbye = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数表达式声明，需要以分号结束</span></span><br><span class="line"><span class="comment">函数表达式并不会提前，它的本质是常量或者变量，我们如果在前面调用，实际上是调用了未声明的量</span></span><br><span class="line"><span class="comment">所以是非法的。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>对于类来说，我们也有两种形式，类声明和类表达式，但是和函数不同的是，类声明和类表达式都不会置顶</p>
<p>所以不可以再类声明前实例化类</p>
<p>个人建议，用类声明来创建类</p>
<h3 id="3-Static-Methods"><a href="#3-Static-Methods" class="headerlink" title="3- Static Methods"></a>3- Static Methods</h3><p>我们有两种方法，实例方法和静态方法</p>
<p>实例方法只会在实例中生效</p>
<p>实例方法实在类当中起作用的，而不是在类的实例当中</p>
<p>现成的例子，就是Math对象中的函数，就是静态函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(radius) &#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">        <span class="keyword">this</span>.move = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里的draw()就是一个实例方法</span></span><br><span class="line">    draw()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'draw'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//static method</span></span><br><span class="line">    <span class="comment">//这样之后，这个方法就不会再属于类的实例对象了，无法在示例化的对象中通过点来访问</span></span><br><span class="line">    <span class="comment">//但是可以同过类+点的方法来讨论，之作用在class本身</span></span><br><span class="line">  	<span class="keyword">static</span> parse(string)&#123;</span><br><span class="line">		<span class="keyword">const</span> radius = <span class="built_in">JSON</span>.parse(str).radius;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Circle(radius);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> circle = Circle.parse(<span class="string">'&#123;"radius" : 1&#125;'</span>);<span class="comment">//调用了类的静态方法，</span></span><br></pre></td></tr></table></figure>
<h3 id="4-The-This-Keyword"><a href="#4-The-This-Keyword" class="headerlink" title="4- The This Keyword"></a>4- The This Keyword</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Circle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle();</span><br><span class="line">c.draw();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> draw = c.draw;</span><br><span class="line">draw();</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/26/OOP-in-JavaScript/33.png" style="zoom: 80%;"></p>
<p>同样是调用，为什么一个是Circle对象，一个就是Window对象了呢？</p>
<p>因为我们从一个对象c上调用方法draw()，draw()中的this是指向对象本身的。</p>
<p>然而通过函数调用，也就是const draw = c.draw; draw();这种方法调用的draw()的时候</p>
<p>我们以一种独立的方式调用函数， 这种调用，draw()中的this指向一个默认的全局变量，也就是Window对象（或者node 中的Global)</p>
<h4 id="strict模式对this的影响"><a href="#strict模式对this的影响" class="headerlink" title="strict模式对this的影响"></a>strict模式对this的影响</h4><p>在JavaScript中有一个strict 模式，当我们开启这个模式的时候，JavaScript会做很多更严格的错误检查。</p>
<p>通过 use strict 启用</p>
<p>然后我们会发现，原来的Window对象变成了undefined对象。也就是说当独立调用draw()的时候，this将不再指向全局对象。他会被设置成undefined，这样会防止我们修改Window对象中的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">	draw()&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle();</span><br><span class="line">c.draw();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> draw = c.draw;</span><br><span class="line">draw();</span><br></pre></td></tr></table></figure>
<p>这时候我们会发现调用draw()还是出现undefined</p>
<p>因为在类的作用下，严格模式会自动启用。</p>
<h3 id="5-Binding-this"><a href="#5-Binding-this" class="headerlink" title="5- Binding this"></a>5- Binding this</h3><p>我们知道如果独立调用类中的函数，那么this会指向Window或者undefined</p>
<p>接下来我们让this无论何时都指向对象本身</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">	name: <span class="string">"Mosh"</span>,</span><br><span class="line">	walk()&#123;</span><br><span class="line">		console.<span class="built_in">log</span>(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> walk = person.walk.bind(person);</span><br><span class="line">walk();</span><br><span class="line"><span class="comment">//我们发现这时候 walk()中的this就指向了Person类</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/26/OOP-in-JavaScript/40.png" style="zoom: 80%;"></p>
<h3 id="6-Arrow-Functions"><a href="#6-Arrow-Functions" class="headerlink" title="6- Arrow Functions"></a>6- Arrow Functions</h3><p>箭头函数非常有用</p>
<p>原来我们这么写一个函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="keyword">function</span>(<span class="params">number</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> number*number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们可以这么写</p>
<p>如果没有 参数，那么直接 ()=&gt;{} 即可</p>
<p>如果有多可参数，那么需要用括号括起来；如果只有一个参数如下图，可以省略括号</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">number</span> =&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> number*number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>甚至我们如果写的是单行代码，只返回一个值，我们可以这么写，（类似于python中的lambda函数）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">number</span> =&gt;</span> number*number;<span class="comment">//理解为 number goes to  number*number</span></span><br></pre></td></tr></table></figure>
<p>再比如：利用fileter函数的时候，简直比python都要简洁。。。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jobs =[</span><br><span class="line">	&#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">isActive</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">	&#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">isActive</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">	&#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">isActive</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> activeJobs = jobs.filter(<span class="function"><span class="params">job</span>=&gt;</span> job.isActive  );</span><br></pre></td></tr></table></figure>
<h3 id="7-Arrow-Functions-and-this"><a href="#7-Arrow-Functions-and-this" class="headerlink" title="7- Arrow Functions and this"></a>7- Arrow Functions and this</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">	talk()&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"this"</span>,<span class="keyword">this</span>);</span><br><span class="line">        &#125;，<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.talk();</span><br></pre></td></tr></table></figure>
<p>我们按照上面这种写法吗，发现this指向了Window对象</p>
<p>这是因为传入的匿名回调函数，是不属于任何对象的。他和person.talk()函数没关系,是一个独立的函数，所以默认this指向了全局对象WIndow</p>
<p>那么我们怎么让回调函数中的this指向对象person呢？</p>
<p>我们可以 然后在回调函数中利用箭头符号的特性，不需要在回调函数外面声明self再让回调函数指向self</p>
<p>直接像下面这样修改即可。箭头函数中的this，是从上面定义this的地方继承下来的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">	talk()&#123;</span><br><span class="line">        setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">            console.log(&quot;this&quot;,this);</span><br><span class="line">        &#125;，1000);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.talk();</span><br></pre></td></tr></table></figure>
<h3 id="8-Array-map-Method"><a href="#8-Array-map-Method" class="headerlink" title="8- Array.map Method"></a>8- Array.map Method</h3><p>ES6中新引入了Array.map </p>
<p>当我想渲染一个列表的时候，经常要使用到map()方法</p>
<p>map()方法遍历列表中的每一个项，传入到某个函数当中，然后再返回每一个项（和python的map方法差不多）,得到一个新的列表</p>
<p>利用模板格式语法，我们可以美化代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> colors = [<span class="string">'red'</span>,<span class="string">'green'</span>,<span class="string">'blue'</span>];</span><br><span class="line"><span class="keyword">const</span> items = color.map( <span class="function"><span class="params">color</span> =&gt;</span><span class="string">`&lt;li&gt;<span class="subst">$&#123;color&#125;</span>&lt;/li&gt;`</span>);</span><br><span class="line"><span class="comment">//上面的就等于 color.map(color =&gt; "&lt;li&gt;+ color + &lt;/li&gt;")</span></span><br><span class="line"><span class="built_in">console</span>.log(items);</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/26/OOP-in-JavaScript/42.png" style="zoom: 80%;"></p>
<h3 id="9-Object-Destructuring-解构赋值"><a href="#9-Object-Destructuring-解构赋值" class="headerlink" title="9- Object Destructuring 解构赋值"></a>9- Object Destructuring 解构赋值</h3><p>解构赋值允许你使用类似数组或对象字面量的语法将数组和对象的属性赋给各种变量。这种赋值语法极度简洁，同时还比传统的属性访问方法更为清晰。</p>
<p>通常来说，你很可能这样访问数组中的前三个元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> first = someArray[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> second = someArray[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> third = someArray[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<p>如果使用解构赋值的特性，将会使等效的代码变得更加简洁并且可读性更高：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [first, second, third] = someArray;</span><br></pre></td></tr></table></figure>
<p>想要几个写几个</p>
<h3 id="10-Spread-Operator"><a href="#10-Spread-Operator" class="headerlink" title="10- Spread Operator"></a>10- Spread Operator</h3><p>就是三个点  ...</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> first = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> second = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> combined = [...first,...second];</span><br><span class="line"><span class="comment">//利用这种语法，那么我们可以随心所欲地在数组中加些别的内容比如</span></span><br><span class="line"><span class="keyword">const</span> combined = [...first,<span class="string">'a'</span>,...second,<span class="string">'b'</span>];</span><br></pre></td></tr></table></figure>
<p>有了这种语法，我们可以很容易的复制一个数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> clone = [...first];</span><br></pre></td></tr></table></figure>
<p>我们也可以对对象使用这种语法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> first = &#123;<span class="attr">name</span> : <span class="string">"Mosh"</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> second = &#123;<span class="attr">job</span>: <span class="string">"Instructor"</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> combined = &#123;...first,...second,<span class="attr">location</span>:<span class="string">"Australia"</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(combined);</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/26/OOP-in-JavaScript/43.png" style="zoom: 80%;"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> clone = &#123;...first&#125;;</span><br><span class="line"><span class="comment">//同时也可以对对象进行赋值操作</span></span><br></pre></td></tr></table></figure>
<h3 id="11-1-Private-Members-Using-Symbols"><a href="#11-1-Private-Members-Using-Symbols" class="headerlink" title="11-1 Private Members Using Symbols"></a>11-1 Private Members Using Symbols</h3><p>如果我们直接在constructor中定义方法或者属性，那么这个属性可以在实例中被访问</p>
<p>但是利用Symbol()函数来达成 私有属性这个功能(实现了一部分私有属性的功能)</p>
<p>Symbol 值可以由程序创建，并可以作为属性名，而且不用担心属性名冲突。调用 Symbol() 方法将创建一个新的 Symbol 类型的值，并且该值不与其它任何值相等。 Symbol() === Symbol() //False</p>
<p>Symbol  一旦创建后就不可更改，不能对它们设置属性（如果在严格模式下尝试这样做，你将得到一个 TypeError）。它们可以作为属性名，这时它们和字符串的属性名没有什么区别。所以我们现在就要把这个Symbol作为属性的名称</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _radius = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> _draw = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(radius) &#123;</span><br><span class="line">        <span class="comment">//因为下划线加上变量名是常见的私有属性的表达方式，但是直接通过点是没有办法访问的</span></span><br><span class="line">        <span class="comment">//所以通过中括号来访问</span></span><br><span class="line">        <span class="keyword">this</span>[_radius] = radius;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据ES6 的新特性，就是可以计算生成属性的名称</span></span><br><span class="line">    <span class="comment">//_draw 这个独立的值就会被当作这个方法的名称</span></span><br><span class="line">    [_draw]()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line">c.radius;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/26/OOP-in-JavaScript/35.png" style="zoom: 80%;"></p>
<p>这样我们就把原来的属性名称隐藏起来了（虽然外面还是显示了symbol）但是如果我们按照这种方式定义了多个变量的话，那么他们都显示为Symbol()但是在内部他们是不相同的</p>
<h3 id="11-2-Private-Members-Using-WeakMaps"><a href="#11-2-Private-Members-Using-WeakMaps" class="headerlink" title="11- 2 Private Members Using WeakMaps"></a>11- 2 Private Members Using WeakMaps</h3><p><a href="https://blog.csdn.net/weixin_33971205/article/details/87946796" target="_blank" rel="noopener">weakmap博客</a></p>
<p>利用ES6的新特性WeakMap（弱映射）,WeakMap 的键只能是对象，值可以为任意的类型</p>
<p>之所以被称为弱映射，是因为键很弱，如果键没有被引用的话，那么这个键值对就会被垃圾回收机制删除，避免了内存泄漏</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _radius = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>(radius) &#123;</span><br><span class="line">            _radius.set(<span class="keyword">this</span><span class="comment">/*对象，即键值*/</span>,radius);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/26/OOP-in-JavaScript/36.png" style="zoom: 100%;"></p>
<p>我们看到这样 radius就被隐藏起来了；如果我们想要读取这个radius的值，那么我们需要再写一个方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _radius = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>(radius) &#123;</span><br><span class="line">            _radius.set(<span class="keyword">this</span><span class="comment">/*对象，即键值*/</span>,radius);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        draw()&#123;</span><br><span class="line">		    	<span class="built_in">console</span>.log(_radius.get(<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line">c.draw();<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>那么我们怎么定义一个方法呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _radius = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> _move = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>(radius) &#123;</span><br><span class="line">            _radius.set(<span class="keyword">this</span><span class="comment">/*对象，即键值*/</span>,radius);</span><br><span class="line">       <span class="comment">//上面是把变量属性radius映射到this(Circle)对象中，下面的则是把一个方法映射进去</span></span><br><span class="line">            _move.set(<span class="keyword">this</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            	<span class="built_in">console</span>.log(<span class="string">'move'</span>,<span class="keyword">this</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        draw()&#123;</span><br><span class="line">		    _move.get(<span class="keyword">this</span>)();<span class="comment">//调用私有方法</span></span><br><span class="line">            <span class="built_in">console</span>.log(_radius.get(<span class="keyword">this</span>));<span class="comment">//读取私有属性</span></span><br><span class="line">            _console.log(<span class="string">'draw'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line">c.draw(); <span class="comment">// 显示:move undefined</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为什么console.log('move',this)中的this指向了undefined(严格模式下)</span></span><br><span class="line"><span class="comment">原因还没搞懂。。。</span></span><br><span class="line"><span class="comment">那么如果我们要调用Circle对象中的某些成员该怎么办？要解决这个问题我们需要运用箭头函数</span></span><br><span class="line"><span class="comment">英文箭头函数会将this设置为包含它的函数，这时候console.log('move',this)中的this</span></span><br><span class="line"><span class="comment">将从调用它的构造函数中继承过来，也就是说，显示Circle</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">_move.set(<span class="keyword">this</span>, () =&gt; &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'move'</span>,<span class="keyword">this</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们最好对每一个属性或者方法都建立一个WeakMap</p>
<p>因为如果都放在一起，代码会变得不干净</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> privateProps = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(radius)&#123;</span><br><span class="line">		privateProps.set(<span class="keyword">this</span>,&#123;</span><br><span class="line">			radius: radius,</span><br><span class="line">			move: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	privateProps.get(<span class="keyword">this</span>).radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-Getters-and-Setters"><a href="#12-Getters-and-Setters" class="headerlink" title="12- Getters and Setters"></a>12- Getters and Setters</h3><p>如果我们想要把radius设置成只读属性，一种方法就是向上面那样写一个在prototype里的方法getRadius()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _radius = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">     <span class="keyword">constructor</span>(radius) &#123;</span><br><span class="line">         _radius.set(<span class="keyword">this</span><span class="comment">/*对象，即键值*/</span>,radius);</span><br><span class="line">     &#125; </span><br><span class="line">     getRadius()&#123;</span><br><span class="line">         <span class="keyword">return</span> _radius.get(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以用上文提到的Object.definProperty() 这样更容易操作和访问</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _radius = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">     <span class="keyword">constructor</span>(radius) &#123;</span><br><span class="line">         _radius.set(<span class="keyword">this</span><span class="comment">/*对象，即键值*/</span>,radius);</span><br><span class="line">         <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>,<span class="string">'radius'</span>,&#123;</span><br><span class="line">         	<span class="keyword">get</span>: function()&#123;</span><br><span class="line">         		<span class="keyword">return</span> _radius.get(<span class="keyword">this</span>)</span><br><span class="line">         	&#125;</span><br><span class="line">         &#125;)</span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但显然Object.definProperty() 也太麻烦了，ES6中的类有着更好的实现办法,直接把get 属性(){}加到prototype当中 ,这看起来像个方法，但实际上可以直接c.radius 来进行访问。</p>
<p>类似的，我们也可以设置set 属性(){} ;可以对radius进行赋值</p>
<p>ES6 中，getter和setter 变得简单多了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _radius = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(radius) &#123;</span><br><span class="line">        _radius.set(<span class="keyword">this</span><span class="comment">/*对象，即键值*/</span>,radius);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> radius()&#123;</span><br><span class="line">        <span class="keyword">return</span> _radius.get(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> radius(value)&#123;</span><br><span class="line">        <span class="keyword">if</span>(value&lt;=<span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Invalid radius'</span>);</span><br><span class="line">        _radius.set(<span class="keyword">this</span>,value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-Inheritance"><a href="#13-Inheritance" class="headerlink" title="13- Inheritance"></a>13- Inheritance</h3><p>在ES6中实现继承，我们只需要简简单单的extends关键词即可</p>
<p>下面的move和draw都是放在原型对象中的，而不是在constructor中的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	move()&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'move'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">	draw()&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'draw'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle();</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/26/OOP-in-JavaScript/37.png" style="zoom: 100%;"></p>
<p>我们可以在Shape中加一个constructor构造函数，让每个Shape实例都有一个color属性，但是如果在Circle中加一个constructor的话，子类的构造器中必须先调用父类的构造函数，以创建一个父类的实例。我们可以用<strong>super</strong>关键字，super()中传入父类构造函数中的属性名称</p>
<p>如果想把自己的属性也加到构造函数中去，那么直接写就行,super <strong>只管</strong>父类构造函数中的属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(color)&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">	move()&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'move'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(color,radius)&#123;</span><br><span class="line">        <span class="keyword">super</span>(color);</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">	draw()&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'draw'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle(<span class="string">'red'</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/26/OOP-in-JavaScript/38.png" style="zoom: 100%;"></p>
<h3 id="14-Method-Overriding"><a href="#14-Method-Overriding" class="headerlink" title="14- Method Overriding"></a>14- Method Overriding</h3><p>在原型继承里提过重写函数，那么在类中呢？也是直接写就行了，JavaScript编译器会从下至上寻找这个move函数</p>
<p>如果我想要在自类中调用父类的move函数，又想要有自己的改变，利用super.move()即可；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	move()&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'move'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">	move()&#123;</span><br><span class="line">        <span class="keyword">super</span>.move();</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'circle move'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle(<span class="string">'red'</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h3 id="15-Exercise"><a href="#15-Exercise" class="headerlink" title="15- Exercise"></a>15- Exercise</h3><h3 id="16-Solution"><a href="#16-Solution" class="headerlink" title="16- Solution"></a>16- Solution</h3><h2 id="ES6-Tooling"><a href="#ES6-Tooling" class="headerlink" title="ES6 Tooling"></a>ES6 Tooling</h2><h3 id="1-Modules"><a href="#1-Modules" class="headerlink" title="1- Modules"></a>1- Modules</h3><p>现实生活中我们不可能在一个文件中写成百上千行的脚本文件。所以我们把代码划分成很多独立的小文件，这些文件就是所谓的模块。</p>
<p>模块带来了很多好处。、</p>
<p><strong>Maintainability</strong></p>
<p>我们通过模块化增加了程序的可维护性，更加容易管理程序。</p>
<p><strong>Resuse</strong></p>
<p>我们通过模块化，可以在更多的程序中重用我们已经写好了的模块</p>
<p><strong>Abstract</strong></p>
<p>我们通过模块化, 可以隐藏模块中的细节，之向外提供必要的接口即可</p>
<h3 id="2-CommonJS-Modules"><a href="#2-CommonJS-Modules" class="headerlink" title="2- CommonJS Modules"></a>2- CommonJS Modules</h3><p><strong>Circle.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Implementation Detail </span></span><br><span class="line"><span class="keyword">const</span> _radius = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Public Interface</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(radius) &#123;</span><br><span class="line">    _radius.set(<span class="keyword">this</span>, radius);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  draw() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Circle with radius '</span> + _radius.get(<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Circle;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果我们想导入多个类，也想把它们公开，我们可以这么写</span></span><br><span class="line"><span class="comment">module.exports.Circle = Circle;</span></span><br><span class="line"><span class="comment">module.exports.Shape = Shape;</span></span><br><span class="line"><span class="comment">module.exports.Square = Square;</span></span><br><span class="line"><span class="comment">这里我只想导入一个类，我们可以直接简化成</span></span><br><span class="line"><span class="comment">module.exports = Circle;</span></span><br><span class="line"><span class="comment">这样我们引入Circle模块的时候，我们其实就得到了Circle类</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>index.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Circle = <span class="built_in">require</span>(<span class="string">'./circle'</span>);</span><br><span class="line"><span class="comment">// 	引用circle，其实等于引用了Circle对象,那么我们把这个返回值存放在一个常量Circle当中</span></span><br><span class="line"><span class="comment">//	就可以用Cirle来创建对象了</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle(<span class="number">10</span>);</span><br><span class="line">c.draw();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	在这个模块中，我们只公开了Circle类</span></span><br><span class="line"><span class="comment">	所以这里的radius弱映射_radius是没有办法访问到的</span></span><br><span class="line"><span class="comment">	所以说，Circle是公共接口,而_radius 是实现细节</span></span><br><span class="line"><span class="comment">	这种方法不会破坏其他程序，因为没有任何其他模块可以访问到_radius属性。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>运行index.js, 得到了Circle with radius 10</p>
<h3 id="3-ES6-Modules"><a href="#3-ES6-Modules" class="headerlink" title="3- ES6 Modules"></a>3- ES6 Modules</h3><p><strong>Circle.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _radius = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在ES6当中，我们直接在class之前加上export即可，这样我们也可以访问Circle类但是不能访问radius</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(radius) &#123;</span><br><span class="line">    _radius.set(<span class="keyword">this</span>, radius);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  draw() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Circle with radius '</span> + _radius.get(<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>index.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Circle&#125; <span class="keyword">from</span> <span class="string">'./circle.js'</span>;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">引入的使用大括号围住Circle，Circle就是export出来的Circle，这时候一定要写上.js</span></span><br><span class="line"><span class="comment">同时在html引入的时候注type = 'module' 才不会报错</span></span><br><span class="line"><span class="comment"> &lt;script type="module" src="index.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">语法和python类似。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle(<span class="number">10</span>);</span><br><span class="line">c.draw();</span><br></pre></td></tr></table></figure>
<h3 id="4-ES6-Tooling"><a href="#4-ES6-Tooling" class="headerlink" title="4- ES6 Tooling"></a>4- ES6 Tooling</h3><p>前端工作者，需要了解</p>
<p>JavaScript中我们有两类工具，分别是 Transpiler 和 Bundler</p>
<p><strong>Transpiler</strong> 是 Translator+Compiler 的结合，基本上就是将我们写的JavaScript代码翻译成所有浏览器都能读懂的代码，Babel就是现代JS代码中一种非常流行的转译器</p>
<p><strong>Bundler</strong> 就是把很多的js文件合并成一个js文件，也就是我们说的打包。最受欢迎的就是WebPack。他会去掉所有的空行，注释，并且会简化一切名称。这样有助于优化客户请求文件的过程</p>
<h3 id="5-Babel"><a href="#5-Babel" class="headerlink" title="5- Babel"></a>5- Babel</h3><p>在terminal中安装 babel</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install babel-cli@6.26.0 babel-core@6.26.0 babel-preset-env@1.6.1 --save-dev</span><br></pre></td></tr></table></figure>
<p>我们在index.js中写 const x = 1;</p>
<p><img src="/2020/05/26/OOP-in-JavaScript/39.png" style="zoom: 100%;"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置好以后,需要创建一个build文件夹</span></span><br><span class="line">npm run babel;</span><br></pre></td></tr></table></figure>
<p>会出现以下结果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> x= <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="6-Webpack"><a href="#6-Webpack" class="headerlink" title="6- Webpack"></a>6- Webpack</h3><p>webpack会把所有的js文件合并</p>

      
    </div>
    
    
    
    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束，感谢您的阅读-------------</div>
    
</div>

      
    </div>
    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:</strong>
    Jason
  </li>
  <li class="post-copyright-link">
    <strong>Post link:</strong>
    <a href="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/" title="OOP-in-JavaScript">https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice: </strong>
    All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> unless stating additionally.
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag"><i class="fa fa-tag"></i> JavaScript</a>
          
            <a href="/tags/web%E6%9C%9F%E6%9C%AB/" rel="tag"><i class="fa fa-tag"></i> web期末</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/05/25/%E5%AE%A2%E6%88%B7%E7%AB%AFJS%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/" rel="next" title="客户端JS第一部分">
                <i class="fa fa-chevron-left"></i> 客户端JS第一部分
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/" rel="prev" title="常数项级数的审敛法">
                常数项级数的审敛法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC80OTgyMC8yNjMxMQ=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Jason</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives%7C%7C%20archive">
              
                  <span class="site-state-item-count">438</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">67</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/JasonXQH" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:10195501423@stu.ecnu.edu.cn" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://yanghong.tech/" title="友链:杨弘的博客" target="_blank">友链:杨弘的博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://ankate.github.io/" title="友链:赵奕轲的博客" target="_blank">友链:赵奕轲的博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://github.com/JasonXQH/JasonXQH.github.io" title="Like it, STAR ME" target="_blank">Like it, STAR ME</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#OOP-in-JavaScript"><span class="nav-number">1.</span> <span class="nav-text">OOP-in-JavaScript</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Objects"><span class="nav-number">1.1.</span> <span class="nav-text">Objects</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-Literals"><span class="nav-number">1.1.1.</span> <span class="nav-text">Object Literals</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Factories-工厂模式"><span class="nav-number">1.1.2.</span> <span class="nav-text">Factories 工厂模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Constructors-构造函数"><span class="nav-number">1.1.3.</span> <span class="nav-text">Constructors 构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Constructor-Property"><span class="nav-number">1.1.4.</span> <span class="nav-text">Constructor Property</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Functions-are-Objects"><span class="nav-number">1.1.5.</span> <span class="nav-text">Functions are Objects</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#call-和-apply"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">call 和 apply</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Value-vs-Reference-Types"><span class="nav-number">1.1.6.</span> <span class="nav-text">Value vs Reference Types</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#例子"><span class="nav-number">1.1.6.2.</span> <span class="nav-text">例子</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Adding-or-Removing-Properties"><span class="nav-number">1.1.7.</span> <span class="nav-text">Adding or Removing Properties</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运用-的方法"><span class="nav-number">1.1.8.</span> <span class="nav-text">运用 . 的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运用方括号"><span class="nav-number">1.1.9.</span> <span class="nav-text">运用方括号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Enumerating-Properties"><span class="nav-number">1.1.10.</span> <span class="nav-text">Enumerating Properties</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Abstraction"><span class="nav-number">1.1.11.</span> <span class="nav-text">Abstraction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Private-Properties-and-Methods"><span class="nav-number">1.1.12.</span> <span class="nav-text">Private Properties and Methods</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Getters-and-Setters"><span class="nav-number">1.1.13.</span> <span class="nav-text">Getters and Setters</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise-Stopwatch"><span class="nav-number">1.1.14.</span> <span class="nav-text">Exercise- Stopwatch</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Prototypes"><span class="nav-number">1.2.</span> <span class="nav-text">Prototypes</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Inheritance"><span class="nav-number">1.2.1.</span> <span class="nav-text">Inheritance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Prototypes-and-Prototypical-Inheritance"><span class="nav-number">1.2.2.</span> <span class="nav-text">Prototypes and Prototypical Inheritance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Multilevel-Inheritance"><span class="nav-number">1.2.3.</span> <span class="nav-text">Multilevel Inheritance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Property-Descriptors"><span class="nav-number">1.2.4.</span> <span class="nav-text">Property Descriptors</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Constructor-Prototypes"><span class="nav-number">1.2.5.</span> <span class="nav-text">Constructor Prototypes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Prototype-vs-Instance-Members"><span class="nav-number">1.2.6.</span> <span class="nav-text">Prototype vs Instance Members</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Iterating-Instance-and-Prototype-Members"><span class="nav-number">1.2.7.</span> <span class="nav-text">Iterating Instance and Prototype Members</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Avoid-Extending-the-Built-in-Objects"><span class="nav-number">1.2.8.</span> <span class="nav-text">Avoid Extending the Built-in Objects</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercise"><span class="nav-number">1.2.9.</span> <span class="nav-text">Exercise</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Prototypical-Inheritance"><span class="nav-number">1.3.</span> <span class="nav-text">Prototypical Inheritance</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Creating-Your-Own-Prototypical-Inheritance"><span class="nav-number">1.3.1.</span> <span class="nav-text">1- Creating Your Own Prototypical Inheritance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Resetting-the-Constructor"><span class="nav-number">1.3.2.</span> <span class="nav-text">2- Resetting the Constructor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Calling-the-Super-Constructor"><span class="nav-number">1.3.3.</span> <span class="nav-text">3- Calling the Super Constructor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Intermediate-Function-Inheritance"><span class="nav-number">1.3.4.</span> <span class="nav-text">4- Intermediate Function Inheritance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Method-Overriding"><span class="nav-number">1.3.5.</span> <span class="nav-text">5- Method Overriding</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Polymorphism多态"><span class="nav-number">1.3.6.</span> <span class="nav-text">6- Polymorphism多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-When-to-Use-Inheritance"><span class="nav-number">1.3.7.</span> <span class="nav-text">7- When to Use Inheritance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-Mixins"><span class="nav-number">1.3.8.</span> <span class="nav-text">8- Mixins</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-Exercise-Prototypical-Inheritance"><span class="nav-number">1.3.9.</span> <span class="nav-text">9- Exercise- Prototypical Inheritance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-Solution-Prototypical-Inheritance"><span class="nav-number">1.3.10.</span> <span class="nav-text">10- Solution- Prototypical Inheritance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-Exercise-Polymorphism"><span class="nav-number">1.3.11.</span> <span class="nav-text">11- Exercise- Polymorphism</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-Solution-Polymorphism"><span class="nav-number">1.3.12.</span> <span class="nav-text">12- Solution- Polymorphism</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ES6-Classes"><span class="nav-number">1.4.</span> <span class="nav-text">ES6 Classes</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-ES6-Classes"><span class="nav-number">1.4.1.</span> <span class="nav-text">1- ES6 Classes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Hoisting置顶"><span class="nav-number">1.4.2.</span> <span class="nav-text">2- Hoisting置顶</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Static-Methods"><span class="nav-number">1.4.3.</span> <span class="nav-text">3- Static Methods</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-The-This-Keyword"><span class="nav-number">1.4.4.</span> <span class="nav-text">4- The This Keyword</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#strict模式对this的影响"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">strict模式对this的影响</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Binding-this"><span class="nav-number">1.4.5.</span> <span class="nav-text">5- Binding this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Arrow-Functions"><span class="nav-number">1.4.6.</span> <span class="nav-text">6- Arrow Functions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-Arrow-Functions-and-this"><span class="nav-number">1.4.7.</span> <span class="nav-text">7- Arrow Functions and this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-Array-map-Method"><span class="nav-number">1.4.8.</span> <span class="nav-text">8- Array.map Method</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-Object-Destructuring-解构赋值"><span class="nav-number">1.4.9.</span> <span class="nav-text">9- Object Destructuring 解构赋值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-Spread-Operator"><span class="nav-number">1.4.10.</span> <span class="nav-text">10- Spread Operator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-1-Private-Members-Using-Symbols"><span class="nav-number">1.4.11.</span> <span class="nav-text">11-1 Private Members Using Symbols</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-Private-Members-Using-WeakMaps"><span class="nav-number">1.4.12.</span> <span class="nav-text">11- 2 Private Members Using WeakMaps</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-Getters-and-Setters"><span class="nav-number">1.4.13.</span> <span class="nav-text">12- Getters and Setters</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-Inheritance"><span class="nav-number">1.4.14.</span> <span class="nav-text">13- Inheritance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-Method-Overriding"><span class="nav-number">1.4.15.</span> <span class="nav-text">14- Method Overriding</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-Exercise"><span class="nav-number">1.4.16.</span> <span class="nav-text">15- Exercise</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-Solution"><span class="nav-number">1.4.17.</span> <span class="nav-text">16- Solution</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ES6-Tooling"><span class="nav-number">1.5.</span> <span class="nav-text">ES6 Tooling</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Modules"><span class="nav-number">1.5.1.</span> <span class="nav-text">1- Modules</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-CommonJS-Modules"><span class="nav-number">1.5.2.</span> <span class="nav-text">2- CommonJS Modules</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-ES6-Modules"><span class="nav-number">1.5.3.</span> <span class="nav-text">3- ES6 Modules</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-ES6-Tooling"><span class="nav-number">1.5.4.</span> <span class="nav-text">4- ES6 Tooling</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Babel"><span class="nav-number">1.5.5.</span> <span class="nav-text">5- Babel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Webpack"><span class="nav-number">1.5.6.</span> <span class="nav-text">6- Webpack</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="true"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
 <!--
  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">1288.5k</span>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>



-->
        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('-1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->


  
  

  
  


  

  

</body>
</html>
