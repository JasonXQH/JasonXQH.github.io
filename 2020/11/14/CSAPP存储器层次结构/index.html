<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="y0-26jFM_8wn6Slpy1ahkB8ndR7w0OOGyAU6IaXjLUI" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="CSAPP," />










<meta name="description" content="存储器层次结构(The memory hierarchy)存储技术 磁盘  这是一个硬盘的内部结构，圆形的部分是磁片，Arm是磁头臂，其尖端就是一个磁头。 我们将磁盘模型抽象出来：   磁盘中有很多磁片，每一张磁片有2面 磁片的每一面又有若干的同心圆，叫做磁道(track) 磁道之间并不是连续的，中间有gap将其分成一小段一小段，每一小段叫做一个sector  磁盘容量现在的磁盘都是以TB为单位来">
<meta property="og:type" content="article">
<meta property="og:title" content="CSAPP存储器层次结构">
<meta property="og:url" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="Jason‘s Blog">
<meta property="og:description" content="存储器层次结构(The memory hierarchy)存储技术 磁盘  这是一个硬盘的内部结构，圆形的部分是磁片，Arm是磁头臂，其尖端就是一个磁头。 我们将磁盘模型抽象出来：   磁盘中有很多磁片，每一张磁片有2面 磁片的每一面又有若干的同心圆，叫做磁道(track) 磁道之间并不是连续的，中间有gap将其分成一小段一小段，每一小段叫做一个sector  磁盘容量现在的磁盘都是以TB为单位来">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/1.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/9.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/10.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/11.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/12.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/13.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/14.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/48.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/49.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/15.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/16.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/17.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/18.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/2.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/3.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/4.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/8.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/5.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/7.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/6.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/19.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/20.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/21.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/22.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/23.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/24.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/25.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/26.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/27.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/29.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/34.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/36.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/35.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/3.jpg">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/32.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/31.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/33.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/38.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/37.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/39.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/43.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/42.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/41.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/40.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/44.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/45.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/46.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/47.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/2.jpg">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/4.jpg">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/5.jpg">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/50.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/51.png">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/7.jpg">
<meta property="og:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/52.png">
<meta property="article:published_time" content="2020-11-14T01:40:28.000Z">
<meta property="article:modified_time" content="2022-06-25T07:24:20.000Z">
<meta property="article:author" content="Jason">
<meta property="article:tag" content="CSAPP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://jasonxqh.github.io/2020/11/14/CSAPP存储器层次结构/"/>





  <title>CSAPP存储器层次结构 | Jason‘s Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-170027658-1', 'auto');
  ga('send', 'pageview');
</script>





<meta name="generator" content="Hexo 4.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">
  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
<a href="https://github.com/JasonXQH/JasonXQH.github.io" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jason‘s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">CSAPP存储器层次结构</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-14T09:40:28+08:00">
                2020-11-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  10.9k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  43
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="存储器层次结构-The-memory-hierarchy"><a href="#存储器层次结构-The-memory-hierarchy" class="headerlink" title="存储器层次结构(The memory hierarchy)"></a>存储器层次结构(The memory hierarchy)</h1><h2 id="存储技术"><a href="#存储技术" class="headerlink" title="存储技术"></a>存储技术</h2><p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/1.png" style="zoom:80%;"></p>
<h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/9.png" style="zoom:80%;"></p>
<p> 这是一个硬盘的内部结构，圆形的部分是磁片，Arm是磁头臂，其尖端就是一个磁头。</p>
<p>我们将磁盘模型抽象出来：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/10.png" style="zoom:80%;"></p>
<ul>
<li>磁盘中有很多磁片，每一张磁片有2面</li>
<li>磁片的每一面又有若干的同心圆，叫做磁道(track)</li>
<li>磁道之间并不是连续的，中间有gap将其分成一小段一小段，每一小段叫做一个sector</li>
</ul>
<h4 id="磁盘容量"><a href="#磁盘容量" class="headerlink" title="磁盘容量"></a>磁盘容量</h4><p>现在的磁盘都是以TB为单位来计算的</p>
<p>一张磁盘的容量和下面几个参数有关：</p>
<ul>
<li>Recording density</li>
</ul>
<p>number of bits that can be squeezed into a 1 inch segment of a track.每英寸的sector可以放多少数据</p>
<ul>
<li>Track density</li>
</ul>
<p>number of tracks that can be squeezed into a 1 inch radial segment.一张磁片上可以放多少磁道</p>
<ul>
<li>Areal density</li>
</ul>
<p>product of recording and track density. 每平方英寸上可以放多少bity</p>
<h4 id="磁盘操作"><a href="#磁盘操作" class="headerlink" title="磁盘操作"></a>磁盘操作</h4><p>磁盘和磁头都可以运动。磁盘是转动，而磁头接近于径向移动。通过磁头径向移动，其可以扫到所有的磁道。在读取或者写入数据的时候，我们只要将磁头移动到特定的track上并旋转磁片，就可以通过电磁感应来讲数据写道特定的sector当中去。</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/11.png" style="zoom:80%;"></p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/12.png" style="zoom:80%;"></p>
<h4 id="磁盘访问："><a href="#磁盘访问：" class="headerlink" title="磁盘访问："></a>磁盘访问：</h4><p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/13.png" style="zoom:80%;"></p>
<p>现在我们在访问蓝色的数据，访问完之后，如果我们要访问红色的数据，需要进行上述几个步骤。</p>
<p>首先，我们要将磁头移动到红色区域所位于的磁道上方，(抬起来移动过去)，这个过程叫做 seek(寻道)、</p>
<p>接下来，我们要将磁片旋转，让红色区域转到磁头的下方，这个过程叫 Rotational latency</p>
<p>最后，我们的磁头要碰到红色区域进行电磁感应并传输数据</p>
<p>这些过程，都是机械运动，所以相对于内存来说，磁盘访问是非常非常慢的。</p>
<h4 id="访问时间"><a href="#访问时间" class="headerlink" title="访问时间"></a>访问时间</h4><p>我们来计算一下磁盘访问时间。 简单来说 就是上面几个过程的所消耗时间之和，也就是寻道时间+旋转时间+传送时间</p>
<p>$T<em>{access} = T</em>{avg~seek}+T<em>{avg~rotation}+T</em>{avg~transfer}$ </p>
<p>寻道时间通常为3~9ms,一次寻道的最大时间 $T_{maxseek}$可以高达20ms。</p>
<p>旋转时间是的计算公式为 $T_{avg~rotation}= \frac{1}{2}\times\frac{1}{RPM}\times\frac{60s}{1min}$ RPM即为每分钟的转速</p>
<p>传送时间一般依赖于旋转速度和每条磁道的扇区数目。因此我们可以这样来计算</p>
<p>$T_{avg~transfer} = \frac{1}{RPM}\times\frac{1}{(平均扇区数/磁道)}\times \frac{60s}{1min}$ </p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/14.png" style="zoom:80%;"></p>
<p>估计访问下面这个磁盘上一个扇区的访问时间（以ms 为单位）：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/48.png" style="zoom:120%;"></p>
<p>$T<em>{avg~rotation} =\frac{1}{2}\times T</em>{max~rotation}=\frac{1}{2}\times\frac{60s}{15000RPM}\times\frac{1000ms}{1s}= 2ms$</p>
<p>$T_{avg~transfer}=(60s/15000RMP)\times\frac{1}{500扇区/磁道}\times\frac{1000ms}{s}= 0.008ms$ </p>
<p>所以预计总的访问时间为 $8+2+0.008 \approx10ms$ </p>
<p>硬盘两个参数很重要：随机访问速度和连续访问速度。硬盘的随机访问速度是很慢的，但是连续访问速度是很快的。当我们写的随机算法将内存中的空间占满之后，数据便要随机存储到硬盘当中去，这时候磁盘的随机访问速度如果很慢那么这个算法肯定是会垮掉的。</p>
<p>比如说这一题：假设1MB 的文件由512 个字节的逻辑块组成，存储在具有如下特性的磁盘驱动器上：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/49.png" style="zoom:120%;"></p>
<p>对于下面的情况，假设程序顺序地读文件的逻辑块，一个接一个，将读/写头定位道第一块上的时间是 $T<em>{avg~seek}+T</em>{avg~rotations}$</p>
<p>A. 最好的情况: 给定逻辑块道磁盘扇区地最好的可能的映射(顺序的)，估计读取这个文件所需要的最优时间</p>
<p>B. 随机的情况：如果块是随机映射到磁盘扇区的，估计读这个文件所需要的时间,以毫秒为单位</p>
<p>首先我们计算 $T<em>{access}=T</em>{seek}+T<em>{avg~rotation}+T</em>{avg~transfer}=5ms+\frac{1}{2}\times\frac{60}{10000}\times\frac{1000ms}{1s}+\frac{60s}{10000RPM}\times\frac{1}{1000扇区/磁道}\times\frac{1000ms}{1s}\approx 8ms$</p>
<p>如果是最好的情况，块被映射到连续的扇区，在同一柱面上，那样就可以一块接一块地读取，不用寻道和移动读写头。一旦读/写头定位到了第一个扇区，我们只需要旋转磁盘2整圈(每圈1000个扇区，每个扇区512字节)来读取2000个块。所以读取这个文件地总时间只要 $T<em>{seek}+T</em>{avg~rotation}+2\times T_{max~rotation}=5+3+12=20ms$ </p>
<p>随机的情况下，块被随机地映射到扇区上，读2000块中的每一块都需要 $T<em>{avg~seek}+T</em>{avg~rotations}$ms = 8*2000=16000ms=16秒</p>
<p>所以，我们看得到，清理磁盘碎片是一件很重要的事情！</p>
<h4 id="I-O-Bus"><a href="#I-O-Bus" class="headerlink" title="I/O Bus"></a>I/O Bus</h4><p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/15.png" style="zoom:80%;"></p>
<p>磁盘是挂在磁盘控制器上的，而磁盘控制器是挂在I/O Bus，与I/O bridge相连的。那么我们要读取disk中的sector的话，首先要告诉磁盘控制器，然后从磁盘中取出数据后，直接放入内存而不经过CPU的。这种模式叫做 DMA(Direct Memory Access) 直接内存访问。</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/16.png" style="zoom:80%;"></p>
<p>那么为什么不用CPU去取数据呢？因为CPU是一个很贵的”劳动力“，而取数据是一个相对比较低端的”杂活”，我们要让CPU去干更加复杂的计算。</p>
<h3 id="Nonvolatile-Memories"><a href="#Nonvolatile-Memories" class="headerlink" title="Nonvolatile Memories"></a>Nonvolatile Memories</h3><ul>
<li><p>DRAM和SRAM都是易于丢失的内存，停电之后，里面的数据都没了</p>
</li>
<li><p>非易失的内存，在停电之后，数据并不会丢失</p>
<ul>
<li>Read-only memory (ROM): programmed during production</li>
<li>Electrically eraseable PROM (EEPROM): electronic erase capability</li>
<li>Flash memory: EEPROMs, with partial (block-level) erase capability (U盘)</li>
<li>3D XPoint (Intel Optane) &amp; emerging NVMs</li>
</ul>
</li>
</ul>
<p>非易失的数据，有这些应用：</p>
<ul>
<li>Firmware(固件) programs stored in a ROM(比如Bios，磁盘控制器，网卡，显卡加速器等)</li>
<li>固态硬盘(ssd)</li>
<li>Disk caches</li>
</ul>
<h3 id="SSD-固态硬盘"><a href="#SSD-固态硬盘" class="headerlink" title="SSD(固态硬盘)"></a>SSD(固态硬盘)</h3><p>固态硬盘的结构如下：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/17.png" style="zoom:80%;"></p>
<p>SSD中，有很多Block，每个Block之间又有很多Page</p>
<ul>
<li>每一个Page的大小从4k-512k不等，每一个Blocks又有32-128个page</li>
<li>读和写都是以page为单位进行的</li>
<li>不能只写1个page，需要把整个block擦除之后再写</li>
<li>每一个block的寿命大概是写入十万次</li>
</ul>
<h4 id="ssd的性能"><a href="#ssd的性能" class="headerlink" title="ssd的性能"></a>ssd的性能</h4><p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/18.png" style="zoom:80%;"></p>
<p>顺序的读取：2G出头，顺序的写入：2G不到一点。但是随机读和随机写入相对于顺序的读取和写入慢很多很多。随机的写入特别慢，因为我们先要擦除block，再写入。</p>
<p>我们这里还要了解一Buffer和Cache的区别</p>
<p>Cache是缓存，一般认为Cache中有的，比它第一级的存储区域也要有。cache是其下一级的一个子集</p>
<p>Buffer是缓冲，我们将一些数据暂时放到Buffer中，但Buffer中的数据可能并不会在低一级的存储器中。相当于一个蓄水池。</p>
<p>SSD中的DRAM是个Buffer，因为我一下子要将东西写入page中是不方便的，所以我们暂时把数据放到蓄水池Buffer当中。</p>
<p>还有一个作用，Buffer是将随机的数据，变成连续的数据，这样可以提升写入速度，同时也付出了昂贵的DRAM造价</p>
<h2 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h2><p>局部性对硬件和软件系统的设计和性能都有着极大的影响，有良好局部性的程序比局部性差的程序<br>运行得更快。因此一个编写良好的计算机程序常常具有良好的局部性。也就是说它们倾向于 <strong>引用</strong> 邻近于 <strong>最近引用过的数据项</strong> 的数据项，或者是最近引用过的数据项本身。</p>
<p>局部性常常有两种不同的形式：时间局部性和空间局部性。</p>
<p>时间局部性良好是说，被引用过一次的内存位置很可能再<strong>不远的将来</strong>再次被多次引用</p>
<p>空间局部性良好是说，如果一个内存的位置被引用了一次，那么程序很可能在不远的将来引用<strong>附近的</strong>一个内存位置。</p>
<p>对于一个同一个算法来说，调换两行遍历代码并不会影响算法的复杂度，但是其局部性可能相差会非常非常大。比如说一个二维数组元素求和的算法.正常来说我们写双重循环，内层循环会读一行数据，外层循环则负责换行。因此这个 <code>sumarrayrows</code> 算法具有良好的空间局部性，因为他按照数组被存储的优先顺序来访问这个数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_array_rows</span><span class="params">(<span class="keyword">int</span> a[M][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">    	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">    		sum += a[i][j];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法得到了一个很好的<strong>步长为1</strong> 的引用模式，具有良好的空间局部性：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/2.png" style="zoom:120%;"></p>
<p>但是我们只要做一个很小的改动，就会对其局部性有很大的影响。比如说我们把循环中的i、j和M、N调换</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_array_cols</span><span class="params">(<span class="keyword">int</span> a[M][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">    	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">    		sum += a[i][j];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这样的交换就会导致这个算法的空间局部性很差，因为他按照列顺序来扫描数组，而不是按照行顺序，因为在C数组再内存中是按照行顺序存放的。</p>
<p>我们得到了一个步长为N的引用模式，如图所示：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/3.png" style="zoom:120%;"></p>
<p>我们再来举一个例子：</p>
<p>一个对三维数组求和的算法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_array_3d</span><span class="params">(<span class="keyword">int</span> a[M][N][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">    		<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; M; k++)</span><br><span class="line">    			sum += a[k][i][j];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到，三层循环是按照i、j、k来执行的的，但是 我们最后访问的却是<code>a[k][i][j]</code>这显然是一个局部性很差的算法，因为其步长是<code>N*N*sizeof(int)</code> ,我们需要调整一下循环的顺序来将这个算法的步长改为1——将第二层关于j的循环放在最内层即可。</p>
<p>最后，让我们讲一些评价程序中局部性的一些简单原则：</p>
<ul>
<li>重复引用相同变量的程序有良好的时间局部性</li>
<li>对于步长为k的引用模式的程序，<strong>步长越小，空间局部性越好</strong>。在内存中以大步长跳来跳去的程序空间局部性会很差。</li>
<li>对于取指令来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好。</li>
</ul>
<h2 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h2><p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/4.png" style="zoom:120%;"></p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/8.png" style="zoom:120%;"></p>
<p>我们的存储器大致可以画成一个金字塔形，越上面的造价越贵、读取方式越快、容量越小；相反的，底层的存储设备变得更慢</p>
<ul>
<li><p>在最高层(L0) 是少量快速的CPU<strong>寄存器</strong>，CPU 可以在一个时钟周期内访问它们。</p>
</li>
<li><p>接下来是一个或多个小型到中型的<strong>基于SRAM 的高速缓存存储器</strong>，可以在几个CPU 时钟周期内访问它<br>们。这些元器件发热量高耗电大，因此没有办法造的很大。这里我们设计了3层Cache</p>
</li>
<li><p>然后是一个大的<strong>基于DRAM 的主存</strong>，可以在几十到几百个时钟周期内访问它们,</p>
</li>
<li><p>接下来是慢速但是容量很大的<strong>本地磁盘</strong>。</p>
</li>
<li><p>最后，有些系统甚至包括了一层附加的远程服务器上的磁盘，要通过网络来访问它们</p>
</li>
</ul>
<p>对于Cache，我们是一行一行读入的，每一行是64个字节</p>
<p>对于磁盘，我们会读取相当大的一块区域，而且磁盘跳读是非常慢的。</p>
<p>我们知道，现在的CPU读取和磁盘读取的速度相差地越来越大，我们希望用便宜的价格买到大容量存储的设备，又希望在读取时能达到一个较高的速度，怎么办？这时候Cache就应运而生了， 在运行程序的时候，我们希望将我们需要的数据放在靠近金字塔顶端的Cache中，把我们不要的数据放在底层磁盘当中。这样，只有在进行数据交换的时候，才会到磁盘当中去取，时间才会变慢。</p>
<p>这就好像一个贪心算法，根据局部性原理，当我们访问过一个数据之后，我们就可以将其放在上层cache中，因为将来很可能再会用到。也就是说，上层是下层的缓存。</p>
<h3 id="存储器层次结构中的缓存"><a href="#存储器层次结构中的缓存" class="headerlink" title="存储器层次结构中的缓存"></a>存储器层次结构中的缓存</h3><p>一般而言，高速缓存(cache)是一个小而快速的存储设备，它作为存储在更大、也更慢的设备中的数据对象的缓冲区域。使用高速缓存的过程称为缓存(caching)</p>
<p>存储器层次结构的中心思想是，对于每个k，位于為层的更快更小的存储设备作为位于k+1层的更大更慢的存储设备的缓存。换句话说，层次结构中的每一层都缓存来自较低一层的数据对象。</p>
<p>比如说这个例子，第k层更小更快也更贵，其只有4个块，缓存着第k+1层块的一个子集。k+1层存储器被划分为16个大小固定的块，编号为 0~15</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/5.png" style="zoom:120%;"></p>
<h4 id="Hit"><a href="#Hit" class="headerlink" title="Hit"></a>Hit</h4><p>接下来我们来介绍一个概念： Hit 命中.简单来说，就是上一级想要的数据，下一级刚好有。比如下面这个例子，顶层的想要数据14，然后发现Cache里面刚好有数据14，那么这就是命中了。</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/7.png" style="zoom:120%;"></p>
<h4 id="Miss"><a href="#Miss" class="headerlink" title="Miss"></a>Miss</h4><p>Miss和Hit相反，也就是说没有命中。比如下面这个例子，上面的数据想要12，而第二层Cache中原来的数据为8、9、14、3并没有12，所以这就是一个Miss。于是Cache又要向下一层Memory里去找数据12，Memory里有12，然后将其提到Cache中去。</p>
<p>那么这就出现了一个问题：我们怎么来决定什么元素应该被替换(上面这个例子中，9被替换)？ 也就是说找到一个Victim。这是在操作系统中要学习的内容，也就是 Replacement policy,也是我们规定的一套标准。</p>
<p> <img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/6.png" style="zoom:120%;"></p>
<h3 id="3-Types-of-Cache-Misses"><a href="#3-Types-of-Cache-Misses" class="headerlink" title="3 Types of Cache Misses"></a>3 Types of Cache Misses</h3><p>我们要知道 ，程序出现了Miss的话，要再向下级去寻找，这就导致运行时间长了很多，是一种严重拉低效率的情况。</p>
<h4 id="Code-compulsory-miss"><a href="#Code-compulsory-miss" class="headerlink" title="Code (compulsory) miss"></a>Code (compulsory) miss</h4><p>顾名思义，就是冷启动。因为我们电脑启动的时候，Cache里面是没有数据的，因此第一次肯定会miss。</p>
<p>所以也说这是 compulsory miss</p>
<h4 id="Capacity-miss"><a href="#Capacity-miss" class="headerlink" title="Capacity miss"></a>Capacity miss</h4><p>Capacity是容量之意，比如说，我每一次循环里面要读取的数据时4个kb，但是一个cache里面的容量只有3k，那么不管怎么访问和优化，都会出现miss的情况。有点捉襟见肘的意思。</p>
<p>容量不够的话，我们可以停止一些程序的运行，以确保急需cache的程序来访问内存。</p>
<h4 id="Conflict-miss"><a href="#Conflict-miss" class="headerlink" title="Conflict miss"></a>Conflict miss</h4><p>举一个例子，假设我们规定，在k+1层的编码为i的block 必须被放到k层编码为(i mod 4) 的block当中，而我们又必须反复去读取0,8,0,8这一串数据，那么虽然说我k层的blocks还没有用完，capacity也是够的，但是每次访问还是会出现miss，因为0，8 mod4都是0，被映射到了同一个对应的block，造成了conflict miss。因此，这种情况是我们需要规避的，我们需要设计良好的机制来减少甚至避免这种情况的发生。</p>
<h2 id="Cache-Memories-高速缓存存储器"><a href="#Cache-Memories-高速缓存存储器" class="headerlink" title="Cache Memories(高速缓存存储器)"></a>Cache Memories(高速缓存存储器)</h2><p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/19.png" style="zoom:120%;"></p>
<p>这就是Cache在CPU中的模拟结构。CPU会首先在cache memory中去找。</p>
<p>下面这幅图是Instruction Cache在CPU中的一些具体的功能</p>
<p><code>Fetch Control</code> 是决定取哪一条指令的，然后再到Cache中去取。</p>
<p><code>Instruction Decode</code> 是将从Cache中取回来的指令变成二进制编码的</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/20.png" style="zoom:120%;"></p>
<h3 id="General-Cache-Organization"><a href="#General-Cache-Organization" class="headerlink" title="General Cache Organization"></a>General Cache Organization</h3><p>cache memory是这样来组织的：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/21.png" style="zoom:120%;"></p>
<p>一个cache里面有若干个set，每个set里面又有若干的cache line。 一个cache里面，有$2^s$个sets，每一个sets里面又有 $2^e$个cache line。这样做的目的是为了编码比较方便。</p>
<p> 每一个cache line内部又分成三个部分，分别是 v,tag和B。</p>
<ul>
<li><p>B就是Cache line里面的存储空间,大小为 $2^b$个 bytes</p>
</li>
<li><p>v只有一位，全称为 valid bit，来标志这个cache line 是否有用。</p>
</li>
<li>tag则是这个cache line的标签。</li>
</ul>
<p>现在我们来做一个小练习：</p>
<p>我们得到了表格中的一部分信息，我们现在要讲表格补齐，因此这里我们需要对地址的划分非常清楚</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">高速缓存</th>
<th>m(位数)</th>
<th>C(cache大小)</th>
<th>B(块大小)</th>
<th>E(cache line总数)</th>
<th>S(Set总数)</th>
<th>t(tag位数)</th>
<th>s(set位数)</th>
<th>b(block位数)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td>32</td>
<td>1024</td>
<td>4</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td>32</td>
<td>1024</td>
<td>8</td>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td>32</td>
<td>1024</td>
<td>32</td>
<td>32</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>C代表了Cache Size 也就是 $S\times E\times B = 1024$  这里我们已经知道了B和E，于是我们可以先填写S。</p>
<ol>
<li>第一个cache 的$S = 1024/4 = 256$，也就是说这个Cache 有256个set</li>
<li>同理，第二个Cache的$S = 1024/(8\times 4) = 32$ ,也就是说这个Cache 有32个set</li>
<li>第三个Cache的$S = 1024/(32\times 32) = 1$,也就是说这是一个全相连的Cache,只有一个Set</li>
<li>知道了 S之后，我们可以根据 $S = 2^s$ 求出小s的值，小s的值即地址空间关于定位Set的位数</li>
<li>知道了B之后，我们可以根据 $B = 2^b$ 求出小b的值，小b的值即地址空间关于定位block偏移量的位数</li>
<li>知道了 s和 b之后，我们就可以知道 t的值，因为$t= m-s-b$ 其中m为地址的总位数，因为地址的总位数只由三个部分 t,s,b组成。</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">高速缓存</th>
<th>m(位数)</th>
<th>C(cache大小)</th>
<th>B(块大小)</th>
<th>E(cache line总数)</th>
<th>S(Set总数)</th>
<th>t(tag位数)</th>
<th>s(set位数)</th>
<th>b(block位数)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td>32</td>
<td>1024</td>
<td>4</td>
<td>1</td>
<td>256</td>
<td>22</td>
<td>8</td>
<td>2</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td>32</td>
<td>1024</td>
<td>8</td>
<td>4</td>
<td>32</td>
<td>24</td>
<td>5</td>
<td>3</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td>32</td>
<td>1024</td>
<td>32</td>
<td>32</td>
<td>1</td>
<td>27</td>
<td>0</td>
<td>5</td>
</tr>
</tbody>
</table>
</div>
<h3 id="读取Cache"><a href="#读取Cache" class="headerlink" title="读取Cache"></a>读取Cache</h3><p>示意图如下：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/22.png" style="zoom:120%;"></p>
<p>现在拿到了一个地址，机器不会直接去内存里去找地址，而是先会在Cache里面寻找，寻找流程如下：</p>
<p>一串地址可以分成三个部分：tag + set index + block offset(偏移量)</p>
<ol>
<li>首先利用set index位来定位这串地址在cache中位于哪一个sets，因为一共有$2^s$ 个sets，所以我们需要用 s位来当我们的索引</li>
<li>在定位到的set中，遍历所有的cache line,查找是否有和我们地址中 tag段相匹配的 cache line</li>
<li>如果找到了这个cache line，并且这个cache line是valid ，那么就说命中cache了</li>
<li>最后通过我们的offset定位到特定的数据</li>
</ol>
<p>定位 set $\Rightarrow $ 匹配tag $\Rightarrow$ 找到byte</p>
<h3 id="Direct-Mapped-Cache-E-1"><a href="#Direct-Mapped-Cache-E-1" class="headerlink" title="Direct Mapped Cache(E=1)"></a>Direct Mapped Cache(E=1)</h3><p>当E等于1的时候，每一个set只有1条cache line，这时这种cache也被称为是 Direct Mapped Cache。假设每个cache line 中的block size B 为8 bytes.那么这个cache的模型就如下图所示：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/23.png" style="zoom:100%;"></p>
<p>这种Cache的查找模式如下：</p>
<p>我们定位到set之后，我们去看tag是否与cache line中的tag相匹配，还要看这个cache line是否valid。同时满足两个条件才能说命中了。如果一开始tag就不匹配，那么这个cache line就是victim，我们要删除它并替换掉。</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/24.png" style="zoom:100%;"></p>
<p>下面是一个模拟的查找情景。我们有一个4位的地址，cache中有4个sets，每一个sets中有一个cache line，每个cache line的Block 空间为 2 bytes 。block里面存放的数据，就是<strong>查找地址指向的数据 </strong>。</p>
<p>查找地址左边一列是地址所代表的十进制数，查找不成功的时候，我们会将这个地址指向的数(前/后两个)放到blocks当中去。</p>
<p>那么我们查找的第一行是 $[0000_2]$ ,所以应该映射到第0个set，这时候cache是空的，所以是cold  miss，然后将这个数据0存储到第一行cache line当中，因为一个cache line可以存储两个bytes，所以我们在将0输入的时候同时也要将0后面的数字1也一并输入</p>
<p>第二行是$[0001_2]$ ，映射到第0个set，这时候cache line是有数据的，然后我们看tag也适合cache line相匹配的，于是这一个地址是 Hit</p>
<p>第三行是$[0111_2]$ ,定位到set3，显然这时候cache line是空的，那么就是 cold miss</p>
<p>第四行是$[1000_2]$, 定位到set0，tag不匹配，所以miss，并且将set0作为victim，将其替换成 $v=1,Tag=1,M[8-9]$</p>
<p>第五行是$[0000_2]$ ,定位到set0，tag又不匹配，所以miss,并且将set0作为 victim,将其替换成$v=1,Tag =0,M[0-1]$ </p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/25.png" style="zoom:100%;"></p>
<h3 id="E-Way-Set-Associative-Cache-组相连的cache"><a href="#E-Way-Set-Associative-Cache-组相连的cache" class="headerlink" title="E-Way Set Associative Cache 组相连的cache"></a>E-Way Set Associative Cache 组相连的cache</h3><p>顾名思义就是说一个set当中有多个cache line,这里取 E=2，每个cacheline当中有8个bytes</p>
<p>那么查找的过程如下：</p>
<p>首先还是找到对应的set</p>
<p>其次同时比较两个cache line 的tag，匹配到哪个进入那个cache，如果两个都不匹配，就是miss，这时候要在两个cache line里面选择一个杀掉</p>
<p>选择哪个cache line有多种方法，可以是随机的，也可以是least recent used(LRU)，即<strong>最近最少使用的cache line</strong>。但是最近最少使用实现起来没有那么简单，如何高效实现是一件比较复杂的事情。</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/26.png" style="zoom:100%;"></p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/27.png" style="zoom:100%;"></p>
<p>我们用一个例子来模拟E=2时，cache的查找情况:</p>
<ol>
<li>第一个 $[0000_2]$ 肯定是miss的，因为这时候cache里面还没有东西。因此，我们把set0中的cache line1存放 $[0000_2]$ 指向的数据$ M[0-1]$</li>
<li>第二行 $[0001_2]$ ，先匹配set0，然后匹配tag 00，匹配成功，于是 hit</li>
<li>第三行 $[0111_2]$ ，先匹配set1，然后匹配tag 01，发现cache line是空的，所以miss</li>
<li>第四行 $[1000_2]$ ，先匹配 set0，然后匹配tag10，发现cache line 是空的，所以miss</li>
<li>第五行 $[0000_2]$ ，先匹配 set0， 然后匹配set0，发现cache line 非空，所以hit</li>
</ol>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/29.png" style="zoom:100%;"></p>
<p>我们看到，读取同样的数据，因为我们的分配方式不同。两路的组相连cache 比 直接写入内存(E=1)少了一次 miss，多了一次hit，因此更加灵活。 </p>
<h4 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h4><p>一个地址，为什么要把tag设为前面几位，而把set设置在中间几位呢？</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/34.png" style="zoom:100%;"></p>
<p>如果把 前面几位设置成set的话，会导致以下这种结果。</p>
<p>set0会在最前面，set1第二……,每一个set中间又是连续的。这样我在一段地址里面进行读写循环，会导致conflict miss的几率大大提高，严重降低机器的运行效率</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/36.png" style="zoom:100%;"></p>
<p>而将Tag放在前面，将set放在中间，那么在一块连续的内存当中，相同set的地址不会挤在一起，从而降低了conflict miss，并提高了机器的运行效率</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/35.png" style="zoom:100%;"></p>
<p>现在我们来做一个小练习：假想一个高速缓存，用地址的高s 位做组索引，那么内存块连续的片(chunk)会被映射到同一个高速缓存组。</p>
<p>A. 每个这样的连续的数组片中有多少个块</p>
<p>B. 考虑下面的代码，它运行在一个高速缓存形式为$(S,E,B,m) = (512,1,32,32)$ 的系统上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">40960</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">4096</span>;i++)</span><br><span class="line">	sum+=<span class="built_in">array</span>[i];</span><br></pre></td></tr></table></figure>
<p>我们首先要知道如果用地址的高s位作为组索引，整个地址的三部分结构如下：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/3.jpg" style="zoom:100%;"></p>
<p>那么随着地址的渐渐增加，我们址答每个连续的数组片(chunk) 是由$2^t$个块组成的，这里t是标记位数。因此，数组头$2^t$ 个块都会映射到组0，而接下来$2^t$ 个块 会被映射到组1，以此类推</p>
<p>对于B小题来说，我们可以轻易地计算出s = 9,b = 5,因此t=32-14=18位，也就是说数组中头 $2^{18}$ 个块会被映射到组0。现在我们来计算数组需要占用多少块。我们的数组只由$(4096*4)/32 =512$ 个块组成，所以数组中所有的块都会被映射到组0。因此在任何时刻高速缓存至多只能保存一个数组块。很明显用高位做索引不能充分利用cache</p>
<h3 id="Cache-Write"><a href="#Cache-Write" class="headerlink" title="Cache Write"></a>Cache Write</h3><p>刚才我们讨论了 cache 的读取，现在我们来讨论一下cache的写入。</p>
<h4 id="Write-Hit"><a href="#Write-Hit" class="headerlink" title="Write-Hit"></a>Write-Hit</h4><p>如果我们要写入的数据在cache line中，这时候叫做cache hit 当我们这时候我们要做一个选择：</p>
<ol>
<li>通写 write-through(write immediately to memory)</li>
</ol>
<p>数据被立即写入磁盘，另外也会在缓存保存一份（用来提升读性能）。</p>
<ol>
<li>回写 write-back(defer write to memory until replacement of line)</li>
</ol>
<p>先写到cache line里, 用回写这种机制的时候，需要在cache line 中添加一个dirty bit(脏位)，这个dirty就代表这行cache line暂时还没有写到磁盘当中去，所以我们在找victim的时候，当我们发现这个cache line 是干净的，那么就直接将其替换即可，如果这行cache line是脏的， 在这时候就要将cache line中的数据存到内存中去。</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/32.png" style="zoom: 120%;"></p>
<p>这两者的差别也可以用图表示出来：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/31.png" style="zoom: 120%;"></p>
<p>回写的优点：</p>
<p>write-back：磁盘写性能高，每次只要写一行cache line 即可</p>
<p>回写的缺点：</p>
<p>wirite-back：系统崩溃或突然断电时，cache中的数据会丢失。有时候另外一个线程在读取数据的时候，可能会导致读取的和写入的不一致。</p>
<p>通写的优点：</p>
<p>读取和写入永远是一致的</p>
<p>通写的缺点:</p>
<p>开销很大</p>
<h4 id="Write-miss"><a href="#Write-miss" class="headerlink" title="Write-miss"></a>Write-miss</h4><p>如果我们要写入的数据没有存放在 cache line当中，那么这时候就是 Write-miss</p>
<p>比如说我在键盘中输入的数据，肯定是cache line中没有的，根据计算机硬件架构体系，这些数据首先会被存入到内存当中。</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/33.png" style="zoom: 120%;"></p>
<ol>
<li>写分配 Write-allocate (将要写入的数据从内存中取出放到cache当中并更新cache line)</li>
<li>非写分配 No-write-allocate (直接写到memory当中，不更新cache)</li>
</ol>
<p>目前的系统常用的机制是 ：write-back + write-allocate </p>
<h2 id="Cache-Performance-Metrics"><a href="#Cache-Performance-Metrics" class="headerlink" title="Cache Performance Metrics"></a>Cache Performance Metrics</h2><h4 id="Miss-rate"><a href="#Miss-rate" class="headerlink" title="Miss rate"></a>Miss rate</h4><p>Miss rate = 1- Hit rate ，因为一次访问存取要么miss 要么 hit</p>
<p>一般情况下， L1 cache 的miss rate是 3%-10%</p>
<p>L2 cache 的miss rate 一般在 1% 以下。</p>
<h4 id="Hit-Time"><a href="#Hit-Time" class="headerlink" title="Hit Time"></a>Hit Time</h4><p>Hit Time即当我命中cache 和从cache 中取到数所花费的时间，包括了查找set，匹配tag的时间</p>
<p>比较典型的例子：</p>
<p>对于L1 cache 来说，是4个运行周期</p>
<p>对于L2 cache 来说，是10个运行周期</p>
<h4 id="Miss-Penalty"><a href="#Miss-Penalty" class="headerlink" title="Miss Penalty"></a>Miss Penalty</h4><p>当我们出现 miss的情况，需要大概50-200个运行周期去从内存中取得我们的数据。</p>
<p>问题：为什么不用hit rate 而用 miss rate？</p>
<p>因为用户更关心的是平均访问的时间，对于hit rate来说，其值一般在90%以上，那么当hit rate 相差 1% 的时候，比如从97%提升到99%，看上去这两个数相差了2%，以为提升的幅度很小；而事实上miss rate却从3%降到了1%，机器的性能提升了不止一倍。假设一共有100次cache 读取，之前是3*200+97*4 而现在变成了 1*200+99*4，相差接近3倍，这是hit rate反映不出来的，而miss rate从3%降至1%则能体现出这种倍数差距。</p>
<p>miss rate在0%-10%所反映的和电脑实际性能之间基本上是呈线性关系的，但是显然 hit rate 并不是线性关系。</p>
<h3 id="The-memory-mountain-内存山"><a href="#The-memory-mountain-内存山" class="headerlink" title="The memory mountain 内存山"></a>The memory mountain 内存山</h3><p>内存山是整本书最有代表性的</p>
<ul>
<li>Read throughput 读的带宽<ul>
<li>也就是从内存中每秒能读取多少数据</li>
</ul>
</li>
<li>Memory mountain：我们运行一个能反应空间局部性和时间局部性对读取吞吐量变化的函数，然后将其可视化出来</li>
</ul>
<p>测试原理如下：</p>
<p>stride是步长，此外，我们还定义了2倍步长，3倍步长和4倍步长. 每一次我们加上1、2、3、4倍步长</p>
<p>data数组总的长度是elems，因为要保证加上4倍步长不能冲出数组，所以循环到 length-sx4这个长度为止</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> data[MAXELEMS]; <span class="comment">/* Global array to traverse */</span></span><br><span class="line"><span class="comment">/* test - Iterate over first "elems" elements of</span></span><br><span class="line"><span class="comment">* 			array "data" with stride of "stride“,</span></span><br><span class="line"><span class="comment">* 			using 4x4 loop unrolling.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> elems, <span class="keyword">int</span> stride)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> i, sx2=stride*<span class="number">2</span>, sx3=stride*<span class="number">3</span>, sx4=stride*<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">long</span> acc0 = <span class="number">0</span>, acc1 = <span class="number">0</span>, acc2 = <span class="number">0</span>, acc3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> length = elems, limit = length - sx4;</span><br><span class="line">    <span class="comment">/* Combine 4 elements at a time */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i += sx4) &#123;</span><br><span class="line">        acc0 = acc0 + data[i];</span><br><span class="line">        acc1 = acc1 + data[i+stride];</span><br><span class="line">        acc2 = acc2 + data[i+sx2];</span><br><span class="line">        acc3 = acc3 + data[i+sx3];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Finish any remaining elements */</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">  		acc0 = acc0 + data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((acc0 + acc1) + (acc2 + acc3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跑之前先要测试一遍，来把cache 填满，因为cache 之前是空的</p>
<p>acc1，2，3，4每次循环都会被调用，所以他们几乎不会出寄存器，data数组在内存当中，每次访问的是 data[i+xstride]，因为data数组是在内存中连续存储的，因此 stride越大，说明空间局部性越弱；stride越小，代表空间局部性越强</p>
<p> <img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/38.png" style="zoom: 120%;"></p>
<p>下面是根据吞吐量画出来的内存山：吞吐率越高，性能越好，吞吐率越低，性能越差。</p>
<p>当步长较小的时候，即使是好几倍的步长，也跳不出 L1 cache，因此吞吐量始终维持在一个很高的水平。(黄色部分)</p>
<p>但随着步长的增加，读取的时候会跳出L1 cache，进入L2 cache 或者 L3 cache，这时候吞吐量就下了一个很大的台阶。表现为橙色和紫色部分。</p>
<p>当步长达到一定程度的时候，我们发现吞吐率不会下降了，这是因为每次读取都是cache miss，必须回到内存中去读取，所以速度最慢。表现为深蓝色部分</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/37.png" style="zoom: 120%;">,</p>
<h3 id="Rearrangeing-loops-to-improve-spatial-locality-提升空间复杂度"><a href="#Rearrangeing-loops-to-improve-spatial-locality-提升空间复杂度" class="headerlink" title="Rearrangeing loops to improve spatial locality(提升空间复杂度)"></a>Rearrangeing loops to improve spatial locality(提升空间复杂度)</h3><p>我们用矩阵乘法来举例子，最基本的矩阵乘法的写法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ijk */</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">        sum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (k=<span class="number">0</span>; k&lt;n; k++)</span><br><span class="line">        sum += a[i][k] * b[k][j];</span><br><span class="line">        c[i][j] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据类型都是long ,也就是8个bytes，算法的复杂度为 $O(N^3)$ </p>
<p>现在我们来分析一下 矩阵乘法的miss rate</p>
<p>我们对矩阵和cache提出这些假设：</p>
<ul>
<li>Block size = 32B</li>
<li>矩阵的边长(N)非常大，1/N 接近于0 (如高分辨率的图片)</li>
<li>矩阵大到连cache都放不下一行数据</li>
</ul>
<p><strong>分析方法</strong></p>
<p>我们对最内层循环进行分析：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/39.png" style="zoom: 100%;"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">	sum += a[<span class="number">0</span>][i];</span><br></pre></td></tr></table></figure>
<p>我们知道，C语言中的数组是按照行存放的。每次循环访问的都是同一行的数字，因此这个循环对于a矩阵的局部性是非常好的。但是因为这个数组的边非常大，cache都放不下，因此还是存在一定的 miss rate。这个miss rate 可以由 $\frac{sizeof(a<em>{ij})}{B}$ 来计算(B指Block的大小)，也就是说每访问$ B/ sizeof(a</em>{ij})$ 个数据后，会出现 一次miss。</p>
<p>但是如果稍微改一下算法，虽然不改变最终结果和算法的复杂度，但是也会让局部性变得很差</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	sum += a[i][<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>比如改成上面这样子，每次跳一行来读取一个数字，因为cache 放不下一行，所以必然每次都会出现miss，因此这个算法的miss rate = 1，局部性非常差</p>
<h4 id="三种不同的矩阵乘法的写法"><a href="#三种不同的矩阵乘法的写法" class="headerlink" title="三种不同的矩阵乘法的写法"></a>三种不同的矩阵乘法的写法</h4><p><strong>Matrix Multiplication (ijk)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ijk */</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">        sum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (k=<span class="number">0</span>; k&lt;n; k++)</span><br><span class="line">            sum += a[i][k] * b[k][j];</span><br><span class="line">        c[i][j] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/43.png" style="zoom: 100%;"></p>
<p>Block = 32B, 数据类型为long  </p>
<p>这个miss rate可以这样来计算：</p>
<p>对于A矩阵：每次访问四个数据出现一次miss ，miss rate = 0.25</p>
<p>对于B矩阵：每次都是跳了一行，因此 miss rate = 1</p>
<p>对于C矩阵：只要求在指定位置写入即可，miss rate = 0</p>
<p>avg misses/iter = 1.25</p>
<p><strong>Matrix Multiplication (kij)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (k=<span class="number">0</span>; k&lt;n; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    r = a[i][k];</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">    	c[i][j] += r * b[k][j];	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/42.png" style="zoom: 100%;"></p>
<p>这个矩阵乘法比较奇怪</p>
<p>在最里面的循环，a矩阵并不要进行操作，因此其miss rate = 0</p>
<p>对于B矩阵和C矩阵移动的是j，因此他们的miss rate  = 0.25</p>
<p>avg misses/iter = 0.5</p>
<p><strong>Matrix Multiplication (jki)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* jki */</span></span><br><span class="line"><span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (k=<span class="number">0</span>; k&lt;n; k++) &#123;</span><br><span class="line">    r = b[k][j];</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    	c[i][j] += a[i][k] * r;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/41.png" style="zoom: 100%;"></p>
<p>这种算法的局部性最差，A矩阵和C矩阵都是跳行访问的，miss rate = 1.0,而B是固定的，miss rate =0</p>
<p>avg misses/iter = 2.0</p>
<p>从实验数据上也可以看到这个差别：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/40.png" style="zoom: 100%;"></p>
<h4 id="Using-Blocking-to-improve-temporal-locality-时间复杂度"><a href="#Using-Blocking-to-improve-temporal-locality-时间复杂度" class="headerlink" title="Using Blocking to improve temporal locality(时间复杂度)"></a>Using Blocking to improve temporal locality(时间复杂度)</h4><p>我们还是拿矩阵乘法来举例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c = (<span class="keyword">double</span> *) <span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">double</span>), n*n);</span><br><span class="line"><span class="comment">/* Multiply n x n matrices a and b */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmm</span><span class="params">(<span class="keyword">double</span> *a, <span class="keyword">double</span> *b, <span class="keyword">double</span> *c, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">            	c[i*n + j] += a[i*n + k] * b[k*n + j];	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/44.png" style="zoom: 100%;"></p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/45.png" style="zoom: 100%;"></p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/46.png" style="zoom: 100%;"></p>
<p><strong>Blocking Summary</strong></p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/47.png" style="zoom: 100%;"></p>
<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>下列三个函数，以不同的空间局部性成都，执行相同的操作，请对这些空间函数就空间局部性进行排序。并解释如何得到排序结果</p>
<p>a) structs 数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> N 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> vel[<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">int</span> acc[<span class="number">3</span>];</span><br><span class="line">&#125;<span class="built_in">point</span>;</span><br><span class="line"><span class="built_in">point</span> p[N];</span><br></pre></td></tr></table></figure>
<p>b) clear1 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear1</span><span class="params">(<span class="built_in">point</span> *p,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i ,j ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">        	p[i].vel[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>；j &lt; <span class="number">3</span>j j++)</span><br><span class="line">        	p[i].acc[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c) clear2 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear2</span><span class="params">(<span class="built_in">point</span> *p, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i ,j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">        p[i].vel[j] = <span class="number">0</span>;</span><br><span class="line">        p[i].acc[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>d) clear 3数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    	p[i].vel[j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">   		p[i].acc[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道判断空间局部性的好坏，就要看步长、扫描顺序。首先我们画出struct的结构如下：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/2.jpg" style="zoom: 100%;"></p>
<p>我们先来看看clear1，它以步长为1的引用模式访问vel数组和acc数组，因此明显地具有最好的空间局部性。</p>
<p>clear2和clear1一样，是依次扫描N个结构中的一个，但是在每个结构当中步长并不为1，比如当j = 0的时候，vel[j] 偏移量为0，而acc[j] 的偏移量为12。所以说clear2的空间局部性比clear1要更差一些。</p>
<p>函数clear3不仅在每个结构当中跳来跳去，而且还要从结构跳到结构，所以clear3的空间局部性比clear2和clear1都要差</p>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>在信号处理和科学计算的应用中，转置矩阵的行和列是一个很重要的问题。从局部性的角度来看，它也很有趣，因为它的引用模式既是以行为主 (wise)的，也是以列为主(column-wise)的。例如，考虑下面的转置函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transpose1</span><span class="params">(<span class="built_in">array</span> dst, <span class="built_in">array</span> src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">        	dst[j][i] = src[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设在一台具有如下属性的机器上运行这段代码</p>
<ul>
<li>sizeof(int) =4</li>
<li>src数组从地址0开始，dst数组从地址16(十进制)开始</li>
<li>只有一个L1告诉数据缓存，他是直接映射的、直写的和写分配的。块的大小为8个字节</li>
<li>这个高速缓存总的大小为16个数据字节(16 data bytes)，一开始是空的</li>
<li>对 src和dst数组的访问分别是读和写不命中的唯一来源</li>
</ul>
<p>A.对每个row和col,指明对$src[row][col]$和 $dst[row][col]$ 的访问时命中还是不命中。例如，读$src[0][0]$ 会不命中，写$dst[0][0]$ 也不会命中</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/4.jpg" style="zoom: 100%;"></p>
<p>首先我们要画出src和dst的图像，如上图所示。这里注意，每个高速缓存行只包含数组的一个行，杠苏缓存正好只能够保存一个数组。而且对于所有的i，src和dst的行i是映射到同一个高速缓存行的。但是我们发现Cache是肯定不够大的，所以对一个数组的引用总是要驱逐另一个数组的有用的行。</p>
<p>比如说对 $dst[0][0]$ 写会驱逐当我们读 $src[0][0]$ 时加载进来的那一行。所以当我们接下来读取$src[0][1]$ 时，会有一个不命中。</p>
<p>B. 对于一个大小为32数据字节的Cache重复这个练习</p>
<p>当高速缓存为32字节的时候，它足够大，并能容纳这两个数组。因此，所有的不命中都是开始时的冷不命中。</p>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>最近一个很成功的游戏SimAquarium 的核心就是一个紧密循环（tight loop), 它计算256 个海藻(algae)的平均位置。在一台具有块大小为16 字节(B=16) .整个大小为1024 字节的直接映射数据缓存的机器上测量它的高速缓存性能。定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct algae_position &#123;</span><br><span class="line">	int x;</span><br><span class="line">	int y;</span><br><span class="line">&#125;</span><br><span class="line">struct algae.position grid[16][16];</span><br><span class="line">int total_x &#x3D; 0, totally &#x3D; 0;</span><br><span class="line">int i, j;</span><br></pre></td></tr></table></figure>
<p>还有如下假设：</p>
<ul>
<li>sizeof(int) = 4</li>
<li>grid 从内存地址0开始</li>
<li>这个高速缓存开始时是空的</li>
<li>唯一的内存访问时对数组grid的元素的访问。变量 i，j,total_x和total_y 存放在寄存器当中</li>
</ul>
<p>确定下面代码的高速缓存性能：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">31</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">    	total_x += grid[i][j].x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">31</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">    	total_y += grid[i][j].y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们要画出这struct的结构和整一个struct数组的样子</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/5.jpg" style="zoom: 100%;"></p>
<p>每个16字节的高速缓存包含着两个连续的algae_position 结构。每个循环按照内存的访问顺序访问这些结构，每次读一个整数元素。所以每个循环的模式就是不命中、命中、不命中、命中，依次类推。这里我们不必实际列举出读和不命中的总数就能预测出不命中率为50%</p>
<p>A. 读总数是多少？</p>
<p>读的总数为 16*16 = 256</p>
<p>B. 缓存不命中的读总数是多少？</p>
<p>缓存不命中的总数是256</p>
<p>C. 不命中率是多少？ 50%</p>
<h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>给定上面的四条假设</p>
<ul>
<li>sizeof(int) = 4</li>
<li>grid 从内存地址0开始</li>
<li>这个高速缓存开始时是空的</li>
<li>唯一的内存访问时对数组grid的元素的访问。变量 i，j,total_x和total_y 存放在寄存器当中</li>
</ul>
<p>确定下列代码的高速缓存性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line">        total_x += grid[j][i].x;</span><br><span class="line">        total_y += grid[j][i].y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A. 读总数是多少？512<br>B. 高速缓存不命中的读总数是多少？ 256</p>
<p>如图所示：</p>
<p>C. 不命中率是多少？50%<br>D. 如果高速缓存有两倍大，那么不命中率会是多少呢？如果高速缓存有现在的两倍大，那么它能保存整个grid数组。所有的不命中都会是开始时的冷不命中，而不命中的概率会降低到25%</p>
<p>确定下面代码的高速缓存性能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line">        total_x += grid[i][j].x;</span><br><span class="line">        total_y += grid[i][j].y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个循环有很好的步长为1的引用模式，因此所有的不命中都是最开始时的冷不命中。</p>
<p>A. 读总数是多少？512<br>B. 高速缓存不命中的读总数是多少？ 128</p>
<p>C. 不命中率是多少？ 25%<br>D.如果高速缓存有两倍大，那么不命中率会是多少呢？无论高速缓存的大小增加多少，还是会冷命中，因此不会改变不命中率，因为冷不命中时不可能避免的。</p>
<h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>假设我们再下列条件下执行代码中的三个求和函数</p>
<ul>
<li>sizeof(int) = 4</li>
<li>机器有4KB直接映射的高速缓存，块大小为16字节</li>
<li>在两个循环中，代码只对数据进行内存访问。循环索引和值sum都存放在寄存器当中</li>
<li>数组a从内存地址 0x8000000处开始存储 </li>
</ul>
<p>对于N=64和N=60 这两种情况，在表中填写他们大概的高速缓存不命中率</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/50.png" style="zoom: 100%;"></p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/51.png" style="zoom: 100%;"></p>
<p>当N=64的时候首先我们要画出cache的草图和数组的草图</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/7.jpg" style="zoom: 100%;"></p>
<p> 因为数组的大小为cache的4倍，而cache又是直接映射的缓存，所以每次存储255个block就要从头开始，一共四次。所以对于前1/4个数组，出现的是cold miss，而且miss一次会hit3次。后面3/4个数组出现的是conflict miss，但也是miss一次hit3次。因此 miss rate = 25%</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/52.png" style="zoom: 100%;"></p>
<p>对于 sumB，它的局部性是比较差的，read cache order如下：</p>
<p>我们是按照 $a[0][0],a[1][0],a[2][0]$这样的顺序访问的，每次跳一行，一行64*4=256个字节，也就是会跳16个block，因此一开始的时候我们是读取第 $0,16,32…240$ 个cache的，但是这样还只到$a[15][0]$ 当读取$a[16][0]$ 的时候又会返回到第0个cache</p>
<p>0,16,32…240(4times);1,17,33,…241,(4 times)…;15,31,47,…255 (4 times)</p>
<p>对于 sumC</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i+=<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j+=<span class="number">2</span>)</span><br><span class="line">    sum += (a[j][i] + a[j][i+<span class="number">1</span>] + a[j+<span class="number">1</span>][i] + a[j+<span class="number">1</span>][i+<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<p>如果读取了$a[j][i],a[j+1][i]$ 那么 $a[j][i+1],a[j+1][i+1]$肯定是hit的</p>
<p>因此我们可以简化成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i+=<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j+=<span class="number">2</span>)</span><br><span class="line">    sum += (a[j][i] + a[j+<span class="number">1</span>][i]);</span><br></pre></td></tr></table></figure>
<p>上面这个函数和下面这个函数是等价的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i+=<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">    sum += a[j][i];</span><br></pre></td></tr></table></figure>
<p>这和sumB类似，但是因为$i+=2$,所以read cache order只做了2次循环</p>
<p>因此对于这个函数，missrate = 50%，但同时，对于原函数miss count = $64/2<em>64</em>50\% $ = 64*64/4</p>
<p>所以missrate仍然是25%</p>
<p>如果 N=60 的话，那么 对于 sumA和sumC都和 N=64是一样的，为25%</p>
<p>let’s see first inner loop $a[0][0] -&gt; a[59][0]$</p>
<p>read memory address order:</p>
<p>0, 60*4, 60*4*2, …. 60*4*59</p>
<p>read cache order:</p>
<p>0, 15, 30, …., 225, (17 numbers) 255, 14, 29, ….., 224, (17 numbers) 254, 13, 28, ….., 223, (17 numbers) 253, 12, 27, 42, 57, 72, 87, 102, 117 (9 numbers)</p>
<p>all read miss and store into different blocks</p>
<p>next 3 loops: $a[0][1] -&gt; a[59][1], a[0][2] -&gt; a[59][2], a[0][3] -&gt; a[59][3]$</p>
<p>all hit</p>
<p>althrough N is smaller and not power of 2, miss rate is still 25%</p>

      
    </div>
    
    
    
    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束，感谢您的阅读-------------</div>
    
</div>

      
    </div>
    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:</strong>
    Jason
  </li>
  <li class="post-copyright-link">
    <strong>Post link:</strong>
    <a href="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/" title="CSAPP存储器层次结构">https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice: </strong>
    All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> unless stating additionally.
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/CSAPP/" rel="tag"><i class="fa fa-tag"></i> CSAPP</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" rel="next" title="人工神经网络">
                <i class="fa fa-chevron-left"></i> 人工神经网络
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/11/17/%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%E6%B3%95/" rel="prev" title="矩阵链乘法">
                矩阵链乘法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC80OTgyMC8yNjMxMQ=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Jason</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives%7C%7C%20archive">
              
                  <span class="site-state-item-count">438</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">67</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/JasonXQH" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:10195501423@stu.ecnu.edu.cn" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://yanghong.tech/" title="友链:杨弘的博客" target="_blank">友链:杨弘的博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://ankate.github.io/" title="友链:赵奕轲的博客" target="_blank">友链:赵奕轲的博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://github.com/JasonXQH/JasonXQH.github.io" title="Like it, STAR ME" target="_blank">Like it, STAR ME</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#存储器层次结构-The-memory-hierarchy"><span class="nav-number">1.</span> <span class="nav-text">存储器层次结构(The memory hierarchy)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#存储技术"><span class="nav-number">1.1.</span> <span class="nav-text">存储技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#磁盘"><span class="nav-number">1.1.1.</span> <span class="nav-text">磁盘</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#磁盘容量"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">磁盘容量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#磁盘操作"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">磁盘操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#磁盘访问："><span class="nav-number">1.1.1.3.</span> <span class="nav-text">磁盘访问：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#访问时间"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">访问时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O-Bus"><span class="nav-number">1.1.1.5.</span> <span class="nav-text">I&#x2F;O Bus</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nonvolatile-Memories"><span class="nav-number">1.1.2.</span> <span class="nav-text">Nonvolatile Memories</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SSD-固态硬盘"><span class="nav-number">1.1.3.</span> <span class="nav-text">SSD(固态硬盘)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ssd的性能"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">ssd的性能</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#局部性"><span class="nav-number">1.2.</span> <span class="nav-text">局部性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#存储器层次结构"><span class="nav-number">1.3.</span> <span class="nav-text">存储器层次结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#存储器层次结构中的缓存"><span class="nav-number">1.3.1.</span> <span class="nav-text">存储器层次结构中的缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Hit"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">Hit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Miss"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">Miss</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Types-of-Cache-Misses"><span class="nav-number">1.3.2.</span> <span class="nav-text">3 Types of Cache Misses</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Code-compulsory-miss"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">Code (compulsory) miss</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Capacity-miss"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">Capacity miss</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Conflict-miss"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">Conflict miss</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cache-Memories-高速缓存存储器"><span class="nav-number">1.4.</span> <span class="nav-text">Cache Memories(高速缓存存储器)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#General-Cache-Organization"><span class="nav-number">1.4.1.</span> <span class="nav-text">General Cache Organization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读取Cache"><span class="nav-number">1.4.2.</span> <span class="nav-text">读取Cache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Direct-Mapped-Cache-E-1"><span class="nav-number">1.4.3.</span> <span class="nav-text">Direct Mapped Cache(E&#x3D;1)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#E-Way-Set-Associative-Cache-组相连的cache"><span class="nav-number">1.4.4.</span> <span class="nav-text">E-Way Set Associative Cache 组相连的cache</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#小问题"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">小问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cache-Write"><span class="nav-number">1.4.5.</span> <span class="nav-text">Cache Write</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Write-Hit"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">Write-Hit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Write-miss"><span class="nav-number">1.4.5.2.</span> <span class="nav-text">Write-miss</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cache-Performance-Metrics"><span class="nav-number">1.5.</span> <span class="nav-text">Cache Performance Metrics</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Miss-rate"><span class="nav-number">1.5.0.1.</span> <span class="nav-text">Miss rate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hit-Time"><span class="nav-number">1.5.0.2.</span> <span class="nav-text">Hit Time</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Miss-Penalty"><span class="nav-number">1.5.0.3.</span> <span class="nav-text">Miss Penalty</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-memory-mountain-内存山"><span class="nav-number">1.5.1.</span> <span class="nav-text">The memory mountain 内存山</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rearrangeing-loops-to-improve-spatial-locality-提升空间复杂度"><span class="nav-number">1.5.2.</span> <span class="nav-text">Rearrangeing loops to improve spatial locality(提升空间复杂度)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#三种不同的矩阵乘法的写法"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">三种不同的矩阵乘法的写法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Using-Blocking-to-improve-temporal-locality-时间复杂度"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">Using Blocking to improve temporal locality(时间复杂度)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#练习题"><span class="nav-number">1.6.</span> <span class="nav-text">练习题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1"><span class="nav-number">1.6.1.</span> <span class="nav-text">1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2"><span class="nav-number">1.6.2.</span> <span class="nav-text">2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3"><span class="nav-number">1.6.3.</span> <span class="nav-text">3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4"><span class="nav-number">1.6.4.</span> <span class="nav-text">4</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5"><span class="nav-number">1.6.5.</span> <span class="nav-text">5</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="true"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
 <!--
  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">1288.5k</span>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>



-->
        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('-1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
