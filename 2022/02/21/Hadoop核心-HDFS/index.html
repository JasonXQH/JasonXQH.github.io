<!DOCTYPE html>
<html lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jasonxqh.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Hadoop核心-HDFS现在我们来详细学习一下HDFS和MR的原理 HDFS的设计思想HDFS的全称是 The Hadoop Distributed File System, 即Hadoop分布式文件系统。那么作为分布式数据管理系统，HDFS最主要要解决这几个问题：  如何存储上百GB&#x2F;TB级别大文件？ 如何保证文件系统的容错？ 如何进行大文件的并发读写控制？  首先，它最大的特点就是，可以处理">
<meta property="og:type" content="article">
<meta property="og:title" content="Hadoop核心-HDFS">
<meta property="og:url" content="https://jasonxqh.github.io/2022/02/21/Hadoop%E6%A0%B8%E5%BF%83-HDFS/index.html">
<meta property="og:site_name" content="Jason‘s Blog">
<meta property="og:description" content="Hadoop核心-HDFS现在我们来详细学习一下HDFS和MR的原理 HDFS的设计思想HDFS的全称是 The Hadoop Distributed File System, 即Hadoop分布式文件系统。那么作为分布式数据管理系统，HDFS最主要要解决这几个问题：  如何存储上百GB&#x2F;TB级别大文件？ 如何保证文件系统的容错？ 如何进行大文件的并发读写控制？  首先，它最大的特点就是，可以处理">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://jasonxqh.github.io/2022/02/21/Hadoop%E6%A0%B8%E5%BF%83-HDFS/1.png">
<meta property="og:image" content="https://jasonxqh.github.io/2022/02/21/Hadoop%E6%A0%B8%E5%BF%83-HDFS/5.png">
<meta property="og:image" content="https://jasonxqh.github.io/2022/02/21/Hadoop%E6%A0%B8%E5%BF%83-HDFS/2.png">
<meta property="og:image" content="https://jasonxqh.github.io/2022/02/21/Hadoop%E6%A0%B8%E5%BF%83-HDFS/6.png">
<meta property="og:image" content="https://jasonxqh.github.io/2022/02/21/Hadoop%E6%A0%B8%E5%BF%83-HDFS/7.png">
<meta property="og:image" content="https://jasonxqh.github.io/2022/02/21/Hadoop%E6%A0%B8%E5%BF%83-HDFS/8.jpeg">
<meta property="og:image" content="https://jasonxqh.github.io/2022/02/21/Hadoop%E6%A0%B8%E5%BF%83-HDFS/4.png">
<meta property="og:image" content="https://jasonxqh.github.io/2022/02/21/Hadoop%E6%A0%B8%E5%BF%83-HDFS/8.png">
<meta property="article:published_time" content="2022-02-21T14:31:03.000Z">
<meta property="article:modified_time" content="2022-03-14T07:01:58.000Z">
<meta property="article:author" content="Jason">
<meta property="article:tag" content="bigdata">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jasonxqh.github.io/2022/02/21/Hadoop%E6%A0%B8%E5%BF%83-HDFS/1.png">

<link rel="canonical" href="https://jasonxqh.github.io/2022/02/21/Hadoop%E6%A0%B8%E5%BF%83-HDFS/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Hadoop核心-HDFS | Jason‘s Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jason‘s Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/02/21/Hadoop%E6%A0%B8%E5%BF%83-HDFS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Hadoop核心-HDFS
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-21 22:31:03" itemprop="dateCreated datePublished" datetime="2022-02-21T22:31:03+08:00">2022-02-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-14 15:01:58" itemprop="dateModified" datetime="2022-03-14T15:01:58+08:00">2022-03-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Hadoop核心-HDFS"><a href="#Hadoop核心-HDFS" class="headerlink" title="Hadoop核心-HDFS"></a>Hadoop核心-HDFS</h1><p>现在我们来详细学习一下HDFS和MR的原理</p>
<h3 id="HDFS的设计思想"><a href="#HDFS的设计思想" class="headerlink" title="HDFS的设计思想"></a>HDFS的设计思想</h3><p>HDFS的全称是 The Hadoop Distributed File System, 即Hadoop分布式文件系统。那么作为分布式数据管理系统，HDFS最主要要解决这几个问题：</p>
<ul>
<li><strong>如何存储上百GB/TB级别大文件？</strong></li>
<li><strong>如何保证文件系统的容错？</strong></li>
<li><strong>如何进行大文件的并发读写控制？</strong></li>
</ul>
<p>首先，它最大的特点就是，可以处理大数据文件。</p>
<p>那么具体是怎么处理的呢？HDFS会将大文件分割成一个一个block，每个block的大小为128MB(或者是64MB)，然后将其存放到不同的机器(节点)上面，如下图所示：</p>
<p><img src="/2022/02/21/Hadoop%E6%A0%B8%E5%BF%83-HDFS/1.png" style="zoom:67%;"></p>
<p>其次，我们可以通过<strong>分块冗余存储</strong>来保证文件系统的容错性。也就是说，将大文件分割成的小块也可以做冗余备份。这些备份会被放在不同的节点上，因此处分存放某一文件块的所有节点都发生故障，否则HDFS在部分节点故障的情况下依然可以访问到该文件块。如下图：绿色块存放在DataNode1、2、5，黑色块存放在DataNode1、3、5</p>
<p><img src="/2022/02/21/Hadoop%E6%A0%B8%E5%BF%83-HDFS/5.png"></p>
<p>最后，为了让HDFS可以进行大文件的并发读写，我们对文件的读写做了简化——采用<strong>一次写入，多次读取</strong>的方式，即可避免读写冲突。在HDFS中，只支持顺序写入，不支持随机写入。而且不允许修改上传后的文件，如果需要修改，需要先删除，再上传修改完后的文件。</p>
<p>一个很自然的问题是，HDFS把大文件切成块之后，这些块和操作系统中的块有什么区别？</p>
<ul>
<li>显然，在HDFS将大文件切成128MB的块之后，会让一些机器去存储，对于这些机器来说，128MB的块就相当于一个文件。机器会将块继续拆分成32KB的块存放在磁盘里面。因此我们可以说HDFS切成的块在上层，操作系统分块在底层。</li>
</ul>
<h3 id="HDFS的架构"><a href="#HDFS的架构" class="headerlink" title="HDFS的架构"></a>HDFS的架构</h3><p>HDFS采用master/slave架构。一个HDFS集群是由一个NameNode、一个Secondary NameNode和一定数目的DataNode组成。NameNode是一个中心服务器，负责<strong>管理文件系统的名字空间</strong>(namespace)以及<strong>客户端对文件的访问</strong>；Sencondary NameNode 所在节点是主节点的备份节点；集群中的DataNode一般是一个节点一个，负责<strong>管理它所在节点上的存储</strong>。</p>
<p><img src="/2022/02/21/Hadoop%E6%A0%B8%E5%BF%83-HDFS/2.png" style="zoom:67%;"></p>
<p>接下来，我们来详细介绍每个节点的作用。</p>
<h4 id="NameNode内部结构"><a href="#NameNode内部结构" class="headerlink" title="NameNode内部结构"></a>NameNode内部结构</h4><p>NameNode执行文件系统的名字空间操作，比如打开、关闭、重命名文件或目录。它也负责确定数据块到具体DataNode节点的映射。</p>
<p><img src="/2022/02/21/Hadoop%E6%A0%B8%E5%BF%83-HDFS/6.png" style="zoom:67%;"></p>
<p>如上图，NameNode在内存中维护了HDFS的树形结构的目录。这和Linux文件系统的目录结构时分类似。但这个目录只指示了文件块存储的位置，而不实际存储文件。HDFS将目录结构存放在磁盘上的FsImage文件中，可以看做是HDFS目录结构的一个本地快照。</p>
<p>此外，Editlog文件主要记录了对目录以及HDFS文件块的创建、删除、重命名等操作。</p>
<h4 id="Sencondary-NameNode与NameNode的交互"><a href="#Sencondary-NameNode与NameNode的交互" class="headerlink" title="Sencondary NameNode与NameNode的交互"></a>Sencondary NameNode与NameNode的交互</h4><p>Sencondary NameNode ：充当NameNode的备份，一般在另外一台物理机上运行。一旦NameNode出现故障的时候，就利用Secondary NameNode进行恢复</p>
<p><img src="/2022/02/21/Hadoop%E6%A0%B8%E5%BF%83-HDFS/7.png"></p>
<p>其中，Secondary NameNode和NameNode之间同步的过程如上图所示：</p>
<ol>
<li>当Sec NameNode 开始请求备份数据的时候，NameNode暂时将新到达的修改操作追加到新的EditLog.new 当中</li>
<li>Sec NameNode拉取NameNode中的FsImage和EditLog两个文件</li>
<li>Sec NameNode将这两个文件进行合并形成最新的文件目录结构，形成检查点文件FsImage.ckpt</li>
<li>Sec NameNode将检查点文件返回给NameNode</li>
<li>NameNode使用FsImage.ckpt 替换旧的FsImage文件，并使用EditLog.new替换旧的EditLog文件。</li>
</ol>
<ul>
<li>DataNode处理文件系统客户端的读写请求。在NameNode的统一调度下进行数据块的创建、删除和复制。</li>
</ul>
<p>NameNode和DataNode 被设计成可以在普通的商用机器上运行。这些机器一般运行着GNU/Linux操作系统(OS)。HDFS采用Java语言开发，因此任何支持Java的机器都可以部署NameNode或DataNode。由于采用了可移植性极强的Java语言，使得HDFS可以部署到多种类型的机器上。一个典型的部署场景是一台机器上只运行一个NameNode实例，而集群中的其它机器分别运行一个DataNode实例。这种架构并不排斥在一台机器上运行多个DataNode，只不过这样的情况比较少见。</p>
<h3 id="节点之间的读与写"><a href="#节点之间的读与写" class="headerlink" title="节点之间的读与写"></a>节点之间的读与写</h3><h4 id="文件的分块与备份"><a href="#文件的分块与备份" class="headerlink" title="文件的分块与备份"></a>文件的分块与备份</h4><p>一般来说，HDFS中每个文件块<strong>都有三个副本</strong>，在写入文件块时，NameNode使用以下<strong>启发式策略</strong>来决定副本放置，并不是严格最优的</p>
<ul>
<li><p>第一个副本:  如果客户端和某一DataNode位于同一个物理节点，那么HDFS将第一个副本放置在该DataNode。如果客户端不与任何DataNode放在同一物理节点，那么HDFS随机挑选一台磁盘不太满、CPU不太忙的节点。这种副本放置策略的好处就是<strong>支持快速写入</strong></p>
</li>
<li><p>第二个副本：NameNode将第二个副本放置在与第一个副本不同的机架的某一节点上。例如下图的结构：某一文件块的第一个副本在机架1，那么第二个副本就需要放在机架2上。这样一来，如果机架2上某一个节点要读取这个文件块，就可以直接读取第二个副本了。</p>
<p>因此可以有效地减少跨机架的网络流量。</p>
</li>
<li><p>第三个副本：NameNode将第三个副本放在第一个副本所在机架的不同节点上。这样，如果第一个副本所在的节点宕机了，那么该节点可以读取第三个副本。而且即便机架与交换机之间存在故障也不影响。</p>
<p>因此这种副本放置策略有利于应对故障发生时的文件块读取。</p>
</li>
<li><p>如果还有更多的副本，NameNode将随机选择节点来放置</p>
</li>
</ul>
<p><img src="/2022/02/21/Hadoop%E6%A0%B8%E5%BF%83-HDFS/8.jpeg" style="zoom: 67%;"></p>
<h4 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h4><p><img src="/2022/02/21/Hadoop%E6%A0%B8%E5%BF%83-HDFS/4.png" style="zoom:150%;"></p>
<p>首先我要将一个200M文件存到HDFS集群中。</p>
<ol>
<li>客户端通过RPC（远程服务）访问NameNode，请求写入一个文件。</li>
<li>NameNode检查客户端是否有权限写入，如果有权限返回一个响应。如果没有客户端就会抛出一个异常。</li>
<li>客户端会将文件按BlckSize大小（默认128M）将文件切分成一个一个Block块，然后请求写入第一个Block块。</li>
<li>NameNode会根据它的负载均衡机制，给客户端返回满足其副本数量（默认是3）的列表（BlockId：主机，端口号，存放的目录）。</li>
<li>客户端根据返回的列表，开始建立管道（pipeline）。客户端-&gt;第一个节点-&gt;第二个节点-&gt;第三个节点。</li>
<li>开始传输数据，Block按照Packet一次传输，当一个Packet成功传输到第一个DataNode上以后，第一个DodaNode就把这个Packet开始进行复制，并将这个Packet通过管道传输到下一个DataNode上，下一个DataNode接收到Packet后，继续进行复制，再传输到下一个DataNode上。这就是<strong>单个文件块传输的流水线方式</strong></li>
<li>当一个Block块成功传输完以后，从最后一个DataNode开始，依次从管道返回ACK队列，到客户端。最后，DataNode1会向客户端发送确认信息，表示该文件已成功写入。</li>
<li>客户端会在自己内部维护着一个ACK队列，跟返回来的ACK队列进行匹配，只要有一台DataNode写成功，就认为这次写操作是完成的。</li>
<li>开始进行下一个Block块的写入。重复3-8。 </li>
</ol>
<p>这样一来，集群中单一NameNode的结构大大简化了系统的架构。NameNode是所有HDFS元数据的仲裁者和管理者。用户数据永远不会流过NameNode。</p>
<p>如果在传输的时候，有的DataNode宕机了，这个DataNode就会从这个管道中退出。剩下的DataNode继续传输。然后，等传输完成以后，NameNode会再分发出一个节点，去写成功的DataNode上复制出一份Block块，写到新的DataNode上。</p>
<h5 id="流水线复制"><a href="#流水线复制" class="headerlink" title="流水线复制"></a>流水线复制</h5><p>当客户端向HDFS文件写入数据的时候，一开始是写到本地临时文件中。假设该文件的副本系数设置为3，当本地临时文件累积到一个数据块的大小时，客户端会从NameNode获取一个DataNode列表用于存放副本。然后客户端开始向第一个DataNode传输数据，第一个DataNode一小部分一小部分(4 KB)地接收数据，将每一部分写入本地仓库，并同时传输该部分到列表中第二个DataNode节点。第二个DataNode也是这样，一小部分一小部分地接收数据，写入本地仓库，并同时传给第三个DataNode。最后，第三个DataNode接收数据并存储在本地。因此，DataNode能流水线式地从前一个节点接收数据，并在同时转发给下一个节点，数据以流水线的方式从前一个DataNode复制到下一个。</p>
<h4 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h4><p>现在我们来学习，在这种架构下，当客户端需要读取数据的时候，系统是如何操作的。</p>
<ol>
<li>客户端回合NameNode通信，请求读取一个文件</li>
<li>NameNode会根据文件的路径等信息，判断读取请求是否合法。如果合法则向客户端返回文件所有数据块的存放地址</li>
<li>对于第一个数据块，客户端从最近的存放该数据块的DataNode读取数据</li>
<li>当第一个数据块读取完毕后，客户端从最近的存放第二个数据块的DataNode读取数据</li>
<li>以此类推，客户端读取下一个数据块，直到读取完所有数据块。</li>
</ol>
<p><img src="/2022/02/21/Hadoop%E6%A0%B8%E5%BF%83-HDFS/8.png"></p>
<p>读取和写入的不同在于，当我写入文件的时候，客户端在每次写入一个文件块的时候，都需要询问NameNode该文件块存放的位置，并不是NameNode一次性告诉客户端所有的文件块应该存放的位置；而读取的时候，客户端则可以一下子知道所有文件块应该存放的位置。这很好理解，在写入的时候节点状态时刻在发生变化。</p>
<h4 id="文件读写与一致性"><a href="#文件读写与一致性" class="headerlink" title="文件读写与一致性"></a>文件读写与一致性</h4><p>如果在HDFS上对同一个文件进行并发读写访问，那么就需要加锁来保证互斥访问。这会增加编程的复杂度。因此我们可以约定：只会有一个写文件的请求发生，文件写入之后就不会更改了，文件写入后的读取操作可以并发。</p>
<p>基于这种思想，HDFS采用了<strong>一次写入、多次读取</strong>和简化一致性模型：</p>
<ul>
<li>一个文件经过创建、写入和关闭后，就不能改变文件中已有的内容</li>
<li>已经写入到HDFS的文件，仅允许在文件末尾追加数据，即append</li>
<li>当对一个文件进行写入操作或者追加操作的时候，NameNode将拒绝其他针对该文件的读、写请求</li>
<li>当对一个文件进行读取操作时，NameNode允许其他针对该文件的读请求。</li>
</ul>
<p><strong>提问</strong>： 读取的时候可以并行读取吗？</p>
<p>如果以还原文件为目的的话，是不可以并行的，因为文件的块与块之间需要做一个拼接，如果并行读取的话，会导致文件数据混乱无法还原。</p>
<h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><p>Namespace的中文名是：文件系统的名字空间 </p>
<p>HDFS支持传统的层次型文件组织结构。用户或者应用程序可以创建目录，然后将文件保存在这些目录里。文件系统名字空间的层次结构和大多数现有的文件系统类似：用户可以创建、删除、移动或重命名文件。当前，HDFS不支持用户磁盘配额和访问权限控制，也不支持硬链接和软链接。但是HDFS架构并不妨碍实现这些特性。</p>
<p>NameNode负责<strong>维护文件系统的名字空间</strong>，任何对文件系统名字空间或属性的修改都将被NameNode记录下来。应用程序可以设置HDFS保存的文件的副本数目。文件副本的数目称为文件的副本系数，这个信息也是由NameNode保存的。</p>
<h4 id="Back-up-Metadata"><a href="#Back-up-Metadata" class="headerlink" title="Back up Metadata"></a>Back up Metadata</h4><p>HDFS被设计成能够在一个大集群中跨机器可靠地存储超大文件。它将每个文件存储成一系列的数据块，除了最后一个，所有的数据块都是同样大小的。<strong>为了容错，文件的所有数据块都会有副本。</strong>每个文件的数据块大小和副本系数都是可配置的。应用程序可以指定某个文件的副本数目。副本系数可以在文件创建的时候指定，也可以在之后改变。HDFS中的文件都是一次性写入的，并且严格要求在任何时候只能有一个写入者。</p>
<p>NameNode全权管理数据块的复制，它周期性地从集群中的每个DataNode接收心跳信号和块状态报告(Blockreport)。接收到心跳信号意味着该DataNode节点工作正常。块状态报告包含了一个该DataNode上所有数据块的列表。</p>
<p>就比如说</p>
<h4 id="副本存放-最最开始的一步"><a href="#副本存放-最最开始的一步" class="headerlink" title="副本存放: 最最开始的一步"></a>副本存放: 最最开始的一步</h4><p>副本的存放是HDFS可靠性和性能的关键。优化的副本存放策略是HDFS区分于其他大部分分布式文件系统的重要特性。这种特性需要做大量的调优，并需要经验的积累。HDFS采用一种称为机架感知(rack-aware)的策略来改进数据的可靠性、可用性和网络带宽的利用率。目前实现的副本存放策略只是在这个方向上的第一步。实现这个策略的短期目标是验证它在生产环境下的有效性，观察它的行为，为实现更先进的策略打下测试和研究的基础。</p>
<p>大型HDFS实例一般运行在跨越多个机架的计算机组成的集群上，不同机架上的两台机器之间的通讯需要经过交换机。在大多数情况下，同一个机架内的两台机器间的带宽会比不同机架的两台机器间的带宽大。</p>
<p>通过一个<a href="https://hadoop.apache.org/docs/r1.0.4/cn/cluster_setup.html#Hadoop的机架感知" target="_blank" rel="noopener">机架感知</a>的过程，NameNode可以确定每个DataNode所属的机架id。一个简单但没有优化的策略就是将副本存放在不同的机架上。这样可以有效防止当整个机架失效时数据的丢失，并且允许读数据的时候充分利用多个机架的带宽。这种策略设置可以将副本均匀分布在集群中，有利于当组件失效情况下的负载均衡。但是，因为这种策略的一个写操作需要传输数据块到多个机架，这增加了写的代价。</p>
<p>在大多数情况下，副本系数是3，HDFS的存放策略是将一个副本存放在本地机架的节点上，一个副本放在同一机架的另一个节点上，最后一个副本放在不同机架的节点上。这种策略减少了机架间的数据传输，这就提高了写操作的效率。机架的错误远远比节点的错误少，所以这个策略不会影响到数据的可靠性和可用性。于此同时，因为数据块只放在两个（不是三个）不同的机架上，所以此策略减少了读取数据时需要的网络传输总带宽。在这种策略下，副本并不是均匀分布在不同的机架上。三分之一的副本在一个节点上，三分之二的副本在一个机架上，其他副本均匀分布在剩下的机架中，<strong>这一策略在不损害数据可靠性和读取性能的情况下改进了写的性能</strong>。 </p>
<h4 id="副本选择"><a href="#副本选择" class="headerlink" title="副本选择"></a>副本选择</h4><p>为了降低整体的带宽消耗和读取延时，<strong>HDFS会尽量让读取程序读取离它最近的副本</strong>。如果在读取程序的同一个机架上有一个副本，那么就读取该副本。如果一个HDFS集群跨越多个数据中心，那么客户端也将首先读本地数据中心的副本。</p>
<h4 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h4><p>NameNode启动后会进入一个称为安全模式的特殊状态。处于安全模式的NameNode是不会进行数据块的复制的。NameNode从所有的 DataNode接收心跳信号和块状态报告。块状态报告包括了某个DataNode所有的数据块列表。每个数据块都有一个指定的最小副本数。当NameNode检测确认某个数据块的副本数目达到这个最小值，那么该数据块就会被认为是副本安全(safely replicated)的；在一定百分比（这个参数可配置）的数据块被NameNode检测确认是安全之后（加上一个额外的30秒等待时间），NameNode将退出安全模式状态。接下来它会确定还有哪些数据块的副本没有达到指定数目，并将这些数据块复制到其他DataNode上。</p>
<h3 id="文件系统元数据的持久化"><a href="#文件系统元数据的持久化" class="headerlink" title="文件系统元数据的持久化"></a>文件系统元数据的持久化</h3><p>NameNode上保存着HDFS的名字空间。对于任何对文件系统元数据产生修改的操作，NameNode都会使用一种称为EditLog的事务日志记录下来。例如，在HDFS中创建一个文件，NameNode就会在Editlog中插入一条记录来表示；同样地，修改文件的副本系数也将往Editlog插入一条记录。NameNode在本地操作系统的文件系统中存储这个Editlog。整个文件系统的名字空间，包括数据块到文件的映射、文件的属性等，都存储在一个称为FsImage的文件中，这个文件也是放在NameNode所在的本地文件系统上。</p>
<p>NameNode在内存中保存着整个文件系统的名字空间和文件数据块映射(Blockmap)的映像。这个关键的元数据结构设计得很紧凑，因而一个有4G内存的NameNode足够支撑大量的文件和目录。当NameNode启动时，它从硬盘中读取Editlog和FsImage，将所有Editlog中的事务作用在内存中的FsImage上，并将这个新版本的FsImage从内存中保存到本地磁盘上，然后删除旧的Editlog，因为这个旧的Editlog的事务都已经作用在FsImage上了。这个过程称为一个检查点(checkpoint)。在当前实现中，检查点只发生在NameNode启动时，在不久的将来将实现支持周期性的检查点。</p>
<p>DataNode将HDFS数据以文件的形式存储在本地的文件系统中，它并不知道有关HDFS文件的信息。它把每个HDFS数据块存储在本地文件系统的一个单独的文件中。DataNode并不在同一个目录创建所有的文件，实际上，它用试探的方法来确定每个目录的最佳文件数目，并且在适当的时候创建子目录。在同一个目录中创建所有的本地文件并不是最优的选择，这是因为本地文件系统可能无法高效地在单个目录中支持大量的文件。当一个DataNode启动时，它会扫描本地文件系统，产生一个这些本地文件对应的所有HDFS数据块的列表，然后作为报告发送到NameNode，这个报告就是块状态报告。</p>
<h3 id="通讯协议"><a href="#通讯协议" class="headerlink" title="通讯协议"></a>通讯协议</h3><p>所有的HDFS通讯协议都是建立在TCP/IP协议之上。客户端通过一个可配置的TCP端口连接到NameNode，通过ClientProtocol协议与NameNode交互。而DataNode使用DataNodeProtocol协议与NameNode交互。一个远程过程调用(RPC)模型被抽象出来封装ClientProtocol和DataNodeprotocol协议。在设计上，NameNode不会主动发起RPC，而是响应来自客户端或 DataNode 的RPC请求。</p>
<h3 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h3><p>HDFS的主要目标就是即使在出错的情况下也要保证数据存储的可靠性。常见的三种出错情况是：NameNode出错, DataNode出错和网络割裂(network partitions)。</p>
<h4 id="磁盘数据错误，心跳检测和重新复制"><a href="#磁盘数据错误，心跳检测和重新复制" class="headerlink" title="磁盘数据错误，心跳检测和重新复制"></a>磁盘数据错误，心跳检测和重新复制</h4><p>每个DataNode节点周期性地向NameNode发送心跳信号。网络割裂可能导致一部分DataNode跟NameNode失去联系。NameNode通过心跳信号的缺失来检测这一情况，并将这些近期不再发送心跳信号DataNode标记为宕机，不会再将新的IO请求发给它们。任何存储在宕机DataNode上的数据将不再有效。DataNode的宕机可能会引起一些数据块的副本系数低于指定值，NameNode不断地检测这些需要复制的数据块，一旦发现就启动复制操作。在下列情况下，可能需要重新复制：某个DataNode节点失效，某个副本遭到损坏，DataNode上的硬盘错误，或者文件的副本系数增大。</p>
<h4 id="集群均衡"><a href="#集群均衡" class="headerlink" title="集群均衡"></a>集群均衡</h4><p>HDFS的架构支持数据均衡策略。如果某个DataNode节点上的空闲空间低于特定的临界点，按照均衡策略系统就会自动地将数据从这个DataNode移动到其他空闲的DataNode。当对某个文件的请求突然增加，那么也可能启动一个计划创建该文件新的副本，并且同时重新平衡集群中的其他数据。这些均衡策略目前还没有实现。</p>
<h4 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h4><p>从某个DataNode获取的数据块有可能是损坏的，损坏可能是由DataNode的存储设备错误、网络错误或者软件bug造成的。HDFS客户端软件实现了对HDFS文件内容的校验和(checksum)检查。当客户端创建一个新的HDFS文件，会计算这个文件每个数据块的校验和，并将校验和作为一个单独的隐藏文件保存在同一个HDFS名字空间下。当客户端获取文件内容后，它会检验从DataNode获取的数据跟相应的校验和文件中的校验和是否匹配，如果不匹配，客户端可以选择从其他DataNode获取该数据块的副本。</p>
<h4 id="元数据磁盘错误"><a href="#元数据磁盘错误" class="headerlink" title="元数据磁盘错误"></a>元数据磁盘错误</h4><p>FsImage和Editlog是HDFS的核心数据结构。如果这些文件损坏了，整个HDFS实例都将失效。因而，NameNode可以配置成支持维护多个FsImage和Editlog的副本。任何对FsImage或者Editlog的修改，都将同步到它们的副本上。这种多副本的同步操作可能会降低NameNode每秒处理的名字空间事务数量。然而这个代价是可以接受的，因为即使HDFS的应用是数据密集的，它们也非元数据密集的。当NameNode重启的时候，它会选取最近的完整的FsImage和Editlog来使用。</p>
<p>NameNode是HDFS集群中的单点故障(single point of failure)所在。如果NameNode机器故障，是需要手工干预的。目前，自动重启或在另一台机器上做NameNode故障转移的功能还没实现。</p>
<h4 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h4><p>快照支持某一特定时刻的数据的复制备份。利用快照，可以让HDFS在数据损坏时恢复到过去一个已知正确的时间点。HDFS目前还不支持快照功能，但计划在将来的版本进行支持。</p>
<h3 id="数据组织"><a href="#数据组织" class="headerlink" title="数据组织"></a>数据组织</h3><h4 id="数据块"><a href="#数据块" class="headerlink" title="数据块"></a>数据块</h4><p>HDFS被设计成支持大文件，适用HDFS的是那些需要处理大规模的数据集的应用。这些应用都是只写入数据一次，但却读取一次或多次，并且读取速度应能满足流式读取的需要。HDFS支持文件的“一次写入多次读取”语义。一个典型的数据块大小是64MB(或128MB)。因而，HDFS中的文件总是按照64M被切分成不同的块，每个块尽可能地存储于不同的DataNode中。</p>
<h4 id="Staging"><a href="#Staging" class="headerlink" title="Staging"></a>Staging</h4><p>客户端创建文件的请求其实并没有立即发送给NameNode，事实上，在刚开始阶段HDFS客户端会先将文件数据缓存到本地的一个临时文件。应用程序的写操作被透明地重定向到这个临时文件。当这个临时文件累积的数据量超过一个数据块的大小，客户端才会联系NameNode。NameNode将文件名插入文件系统的层次结构中，并且分配一个数据块给它。然后返回DataNode的标识符和目标数据块给客户端。接着客户端将这块数据从本地临时文件上传到指定的DataNode上。当文件关闭时，在临时文件中剩余的没有上传的数据也会传输到指定的DataNode上。然后客户端告诉NameNode文件已经关闭。此时NameNode才将文件创建操作提交到日志里进行存储。如果NameNode在文件关闭前宕机了，则该文件将丢失。</p>
<p>上述方法是对在HDFS上运行的目标应用进行认真考虑后得到的结果。这些应用需要进行文件的流式写入。如果不采用客户端缓存，由于网络速度和网络堵塞会对吞估量造成比较大的影响。这种方法并不是没有先例的，早期的文件系统，比如AFS，就用客户端缓存来提高性能。为了达到更高的数据上传效率，已经放松了POSIX标准的要求。</p>
<h3 id="可访问性"><a href="#可访问性" class="headerlink" title="可访问性"></a>可访问性</h3><p>HDFS给应用提供了多种访问方式。用户可以通过<a href="https://hadoop.apache.org/docs/current/api/index.html" target="_blank" rel="noopener">Java API</a>接口访问，通过命令行访问，通过Ambari可视化界面访问，也可以通过<a href="https://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-hdfs/LibHdfs.html" target="_blank" rel="noopener">C语言的封装API</a>访问，还可以通过浏览器的方式访问HDFS中的文件。 </p>
<h4 id="DFS-Shell"><a href="#DFS-Shell" class="headerlink" title="DFS Shell"></a>DFS Shell</h4><p>HDFS以文件和目录的形式组织用户数据。它提供了一个命令行的接口(DFSShell)让用户与HDFS中的数据进行交互。命令的语法和用户熟悉的其他shell(例如 bash, csh)工具类似。下面是一些动作/命令的示例：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">动作</th>
<th style="text-align:center">命令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">创建一个名为 <code>/foodir</code>的目录</td>
<td style="text-align:center"><code>bin/hadoop dfs -mkdir /foodir</code></td>
</tr>
<tr>
<td style="text-align:center">创建一个名为 <code>/foodir</code> 的目录</td>
<td style="text-align:center"><code>bin/hadoop dfs -mkdir /foodir</code></td>
</tr>
<tr>
<td style="text-align:center">查看名为<code>/foodir/myfile.txt</code>的文件内容</td>
<td style="text-align:center"><code>bin/hadoop dfs -cat /foodir/myfile.txt</code></td>
</tr>
</tbody>
</table>
</div>
<p>DFSShell 可以用在那些通过脚本语言和文件系统进行交互的应用程序上。</p>
<h4 id="DFS-Admin"><a href="#DFS-Admin" class="headerlink" title="DFS Admin"></a>DFS Admin</h4><p>DFSAdmin 命令用来管理HDFS集群。这些命令只有HDSF的管理员才能使用。下面是一些动作/命令的示例：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">动作</th>
<th style="text-align:center">命令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">将集群置于安全模式</td>
<td style="text-align:center">bin/hadoop dfsadmin -safemode enter</td>
</tr>
<tr>
<td style="text-align:center">显示DataNode列表</td>
<td style="text-align:center">bin/hadoop dfsadmin -report</td>
</tr>
<tr>
<td style="text-align:center">使DataNode节点 DataNodename退役</td>
<td style="text-align:center">bin/hadoop dfsadmin -decommission DataNodename</td>
</tr>
</tbody>
</table>
</div>
<h4 id="浏览器接口"><a href="#浏览器接口" class="headerlink" title="浏览器接口"></a>浏览器接口</h4><p>一个典型的HDFS安装会在一个可配置的TCP端口开启一个Web服务器用于暴露HDFS的名字空间。用户可以用浏览器来浏览HDFS的名字空间和查看文件的内容。</p>
<h3 id="存储空间回收"><a href="#存储空间回收" class="headerlink" title="存储空间回收"></a>存储空间回收</h3><h4 id="文件的删除和恢复"><a href="#文件的删除和恢复" class="headerlink" title="文件的删除和恢复"></a>文件的删除和恢复</h4><p>当用户或应用程序删除某个文件时，这个文件并没有立刻从HDFS中删除。实际上，HDFS会将这个文件重命名转移到<code>/trash</code>目录。只要文件还在<code>/trash</code>目录中，该文件就可以被迅速地恢复。文件在<code>/trash</code>中保存的时间是可配置的，当超过这个时间时，NameNode就会将该文件从名字空间中删除。删除文件会使得该文件相关的数据块被释放。注意，从用户删除文件到HDFS空闲空间的增加之间会有一定时间的延迟。</p>
<p>只要被删除的文件还在<code>/trash</code>目录中，用户就可以恢复这个文件。如果用户想恢复被删除的文件，可以浏览<code>/trash</code>目录找回该文件。<code>/trash</code>目录仅仅保存被删除文件的最后副本。<code>/trash</code>目录与其他的目录没有什么区别，除了一点：在该目录上HDFS会应用一个特殊策略来自动删除文件。目前的默认策略是删除<code>/trash</code>中保留时间超过6小时的文件。将来，这个策略可以通过一个被良好定义的接口配置。</p>
<h4 id="减少副本系数"><a href="#减少副本系数" class="headerlink" title="减少副本系数"></a>减少副本系数</h4><p>当一个文件的副本系数被减小后，NameNode会选择过剩的副本删除。下次心跳检测时会将该信息传递给DataNode。DataNode遂即移除相应的数据块，集群中的空闲空间加大。同样，在调用setReplication API结束和集群中空闲空间增加间会有一定的延迟。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/bigdata/" rel="tag"># bigdata</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/02/20/%E4%BA%86%E8%A7%A3Hadoop/" rel="prev" title="了解Hadoop">
      <i class="fa fa-chevron-left"></i> 了解Hadoop
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/02/22/AI-agents-and-environments/" rel="next" title="AI-agents_and_environments">
      AI-agents_and_environments <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Hadoop核心-HDFS"><span class="nav-number">1.</span> <span class="nav-text">Hadoop核心-HDFS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HDFS的设计思想"><span class="nav-number">1.0.1.</span> <span class="nav-text">HDFS的设计思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HDFS的架构"><span class="nav-number">1.0.2.</span> <span class="nav-text">HDFS的架构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#NameNode内部结构"><span class="nav-number">1.0.2.1.</span> <span class="nav-text">NameNode内部结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sencondary-NameNode与NameNode的交互"><span class="nav-number">1.0.2.2.</span> <span class="nav-text">Sencondary NameNode与NameNode的交互</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#节点之间的读与写"><span class="nav-number">1.0.3.</span> <span class="nav-text">节点之间的读与写</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件的分块与备份"><span class="nav-number">1.0.3.1.</span> <span class="nav-text">文件的分块与备份</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件写入"><span class="nav-number">1.0.3.2.</span> <span class="nav-text">文件写入</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#流水线复制"><span class="nav-number">1.0.3.2.1.</span> <span class="nav-text">流水线复制</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件读取"><span class="nav-number">1.0.3.3.</span> <span class="nav-text">文件读取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件读写与一致性"><span class="nav-number">1.0.3.4.</span> <span class="nav-text">文件读写与一致性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Namespace"><span class="nav-number">1.0.4.</span> <span class="nav-text">Namespace</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Back-up-Metadata"><span class="nav-number">1.0.4.1.</span> <span class="nav-text">Back up Metadata</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#副本存放-最最开始的一步"><span class="nav-number">1.0.4.2.</span> <span class="nav-text">副本存放: 最最开始的一步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#副本选择"><span class="nav-number">1.0.4.3.</span> <span class="nav-text">副本选择</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#安全模式"><span class="nav-number">1.0.4.4.</span> <span class="nav-text">安全模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件系统元数据的持久化"><span class="nav-number">1.0.5.</span> <span class="nav-text">文件系统元数据的持久化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通讯协议"><span class="nav-number">1.0.6.</span> <span class="nav-text">通讯协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容错机制"><span class="nav-number">1.0.7.</span> <span class="nav-text">容错机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#磁盘数据错误，心跳检测和重新复制"><span class="nav-number">1.0.7.1.</span> <span class="nav-text">磁盘数据错误，心跳检测和重新复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#集群均衡"><span class="nav-number">1.0.7.2.</span> <span class="nav-text">集群均衡</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据完整性"><span class="nav-number">1.0.7.3.</span> <span class="nav-text">数据完整性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#元数据磁盘错误"><span class="nav-number">1.0.7.4.</span> <span class="nav-text">元数据磁盘错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快照"><span class="nav-number">1.0.7.5.</span> <span class="nav-text">快照</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据组织"><span class="nav-number">1.0.8.</span> <span class="nav-text">数据组织</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据块"><span class="nav-number">1.0.8.1.</span> <span class="nav-text">数据块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Staging"><span class="nav-number">1.0.8.2.</span> <span class="nav-text">Staging</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可访问性"><span class="nav-number">1.0.9.</span> <span class="nav-text">可访问性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DFS-Shell"><span class="nav-number">1.0.9.1.</span> <span class="nav-text">DFS Shell</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DFS-Admin"><span class="nav-number">1.0.9.2.</span> <span class="nav-text">DFS Admin</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#浏览器接口"><span class="nav-number">1.0.9.3.</span> <span class="nav-text">浏览器接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存储空间回收"><span class="nav-number">1.0.10.</span> <span class="nav-text">存储空间回收</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件的删除和恢复"><span class="nav-number">1.0.10.1.</span> <span class="nav-text">文件的删除和恢复</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#减少副本系数"><span class="nav-number">1.0.10.2.</span> <span class="nav-text">减少副本系数</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jason</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">439</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->




  















  

  

  

</body>
</html>
