<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="y0-26jFM_8wn6Slpy1ahkB8ndR7w0OOGyAU6IaXjLUI" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="scala," />










<meta name="description" content="Scala初识The Absolute Scala BasicsValues, Variables and Types学习一门新的语言，自然要先从数值类型入手。在scala中，常量用val定义，变量用var定义。  定义常量Int  一个量有两种定义方式，一种是显式的定义x. 指明其为类型；另外一种则是隐式的声明，让编译器来判断的类型。推荐使用显式的定义，可读性更强一些。 12val x : In">
<meta property="og:type" content="article">
<meta property="og:title" content="scala初识">
<meta property="og:url" content="https://jasonxqh.github.io/2022/04/28/scala%E5%88%9D%E8%AF%86/index.html">
<meta property="og:site_name" content="Jason‘s Blog">
<meta property="og:description" content="Scala初识The Absolute Scala BasicsValues, Variables and Types学习一门新的语言，自然要先从数值类型入手。在scala中，常量用val定义，变量用var定义。  定义常量Int  一个量有两种定义方式，一种是显式的定义x. 指明其为类型；另外一种则是隐式的声明，让编译器来判断的类型。推荐使用显式的定义，可读性更强一些。 12val x : In">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://jasonxqh.github.io/2022/04/28/scala%E5%88%9D%E8%AF%86/1.png">
<meta property="og:image" content="https://jasonxqh.github.io/2022/04/28/scala%E5%88%9D%E8%AF%86/2.jpeg">
<meta property="og:image" content="https://jasonxqh.github.io/2022/04/28/scala%E5%88%9D%E8%AF%86/3.png">
<meta property="og:image" content="https://jasonxqh.github.io/2022/04/28/scala%E5%88%9D%E8%AF%86/5.png">
<meta property="og:image" content="https://jasonxqh.github.io/2022/04/28/scala%E5%88%9D%E8%AF%86/7.svg">
<meta property="og:image" content="https://jasonxqh.github.io/2022/04/28/scala%E5%88%9D%E8%AF%86/6.svg">
<meta property="article:published_time" content="2022-04-28T02:29:01.000Z">
<meta property="article:modified_time" content="2022-05-09T06:59:58.000Z">
<meta property="article:author" content="Jason">
<meta property="article:tag" content="scala">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jasonxqh.github.io/2022/04/28/scala%E5%88%9D%E8%AF%86/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://jasonxqh.github.io/2022/04/28/scala初识/"/>





  <title>scala初识 | Jason‘s Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-170027658-1', 'auto');
  ga('send', 'pageview');
</script>





<meta name="generator" content="Hexo 4.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">
  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
<a href="https://github.com/JasonXQH/JasonXQH.github.io" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jason‘s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/04/28/scala%E5%88%9D%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">scala初识</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-04-28T10:29:01+08:00">
                2022-04-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Words count in article&#58;</span>
                
                <span title="Words count in article">
                  20.5k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Reading time &asymp;</span>
                
                <span title="Reading time">
                  90
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Scala初识"><a href="#Scala初识" class="headerlink" title="Scala初识"></a>Scala初识</h1><h2 id="The-Absolute-Scala-Basics"><a href="#The-Absolute-Scala-Basics" class="headerlink" title="The Absolute Scala Basics"></a>The Absolute Scala Basics</h2><h3 id="Values-Variables-and-Types"><a href="#Values-Variables-and-Types" class="headerlink" title="Values, Variables and Types"></a>Values, Variables and Types</h3><p>学习一门新的语言，自然要先从数值类型入手。在scala中，常量用val定义，变量用var定义。</p>
<ul>
<li>定义常量Int</li>
</ul>
<p>一个量有两种定义方式，一种是显式的定义x. 指明其为类型；另外一种则是隐式的声明，让编译器来判断的类型。推荐使用显式的定义，可读性更强一些。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x : <span class="type">Int</span> = <span class="number">62</span></span><br><span class="line"><span class="keyword">val</span> x = <span class="number">62</span></span><br></pre></td></tr></table></figure>
<ul>
<li>定义常量String，同样分显式和隐式两种。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aString : <span class="type">String</span> = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">val</span> bString = <span class="string">"goodbye"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>定义布尔值Boolean</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aBoolean: <span class="type">Boolean</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>定义字符类型 Char</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aChar: <span class="type">Char</span> = 'a'</span><br><span class="line"><span class="keyword">val</span> bChar = 'b'</span><br></pre></td></tr></table></figure>
<ul>
<li>定义Short类型整数</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aShort : <span class="type">Short</span> = <span class="number">3456</span></span><br></pre></td></tr></table></figure>
<ul>
<li>定义Long 整数, 需要在数值尾部加上L</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aLong : <span class="type">Long</span> =<span class="number">5273985273895237</span>L</span><br><span class="line"><span class="keyword">val</span> bLong = <span class="number">5273985273895237</span>L</span><br></pre></td></tr></table></figure>
<ul>
<li>定义浮点数Float, 需要在尾部加上f</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aFloat: <span class="type">Float</span> = <span class="number">2.0</span>f</span><br><span class="line"><span class="keyword">val</span> bFloat = <span class="number">2.0</span>f</span><br></pre></td></tr></table></figure>
<ul>
<li>定义双精度浮点数Double</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aDouble: <span class="type">Double</span> = <span class="number">3.14</span></span><br><span class="line"><span class="keyword">val</span> bDouble = <span class="number">2.0</span></span><br></pre></td></tr></table></figure>
<p>scala中还有一个特殊的类型：Unit类型，它表示无值，和其他语言中的void等同。用作不返回任何结果的方法的结果类型。Unit只有一个实例值，写成 <code>()</code></p>
<p>比如说：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aWeirdValue = (aVariable = <span class="number">3</span>)<span class="comment">// Unit == void</span></span><br><span class="line">println(aWeirdValue)</span><br></pre></td></tr></table></figure>
<h3 id="Expressions"><a href="#Expressions" class="headerlink" title="Expressions"></a>Expressions</h3><ul>
<li>操作符</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="number">3</span>+<span class="number">5</span></span><br><span class="line"><span class="keyword">val</span> xIsEven = x%<span class="number">2</span> == <span class="number">0</span></span><br><span class="line"><span class="keyword">val</span> xIsOdd = !xIsEven</span><br></pre></td></tr></table></figure>
<p>scala中的操作符和Java中的操作符是一样的，包括||, &amp;&amp; ， &gt;&gt;,&lt;&lt;, ^ ,+= , 但是注意，没有++，—</p>
<ul>
<li>if 表达式，if在scala中是以表达式的形式存在，而不是以指令的形式存在的，如下</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> cond: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">val</span> i = <span class="keyword">if</span>(cond) <span class="number">42</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>当然也可以写正常的 If-else  指令</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(aVariable==<span class="number">4</span>)&#123;</span><br><span class="line">  println(<span class="string">"12dsdawd"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  println(<span class="number">2112</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>while表达式，在Scala中请不要写while表达式，因为scala有更方便的方法进行遍历。 while表达式也是可以返回值的，只不过返回一个unit。</li>
</ul>
<p>在scala中,所有的代码都是以表达式的形式呈现的，因此我们在写scala的时候要尽量减少如 <code>println()</code>、 <code>while</code>、以及变量再赋值这类的命令式语言的代码。虽然他们有效，但本质上还是表达式，返回的值是Unit，且会干扰我们代码的工整</p>
<ul>
<li>code block, 此外scala还有一种特殊的表达式 ： CodeBlocks .这种表达式返回的值是代码块的最后一行得到的值，在这里 <code>aCodeBlock = &quot;goodbye&quot;</code>. 此外要记住，在CodeBlocks中定义的val定量，在块外是无法被访问到的</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aCodeBlock = &#123;</span><br><span class="line">  <span class="keyword">val</span> y = <span class="number">2</span></span><br><span class="line">  <span class="keyword">val</span> z = y+<span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span>(z &gt; <span class="number">2</span>) <span class="string">"hello"</span> <span class="keyword">else</span> <span class="string">"goodbye"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> somValue = &#123;</span><br><span class="line">	<span class="number">2</span>&lt;<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> someOtherValue = &#123;</span><br><span class="line">	<span class="keyword">if</span>(someValue) <span class="number">239</span> <span class="keyword">else</span> <span class="number">2120</span></span><br><span class="line">	<span class="number">42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请问someOtherValue的结果是什么? 因为CodeBlock的值等于最后一行代码的值，在这里someOtherValue = 42</p>
<h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><p>在Scala中，一个函数的定义如下：</p>
<p><code>aFunction</code>是函数的名字，a和b是函数的两个需要被输入的参数，String是该函数的返回值类型</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aFunction</span> </span>(a: <span class="type">String</span>,b: <span class="type">Int</span>) <span class="type">String</span> = &#123;</span><br><span class="line">	a + <span class="string">" "</span> + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果函数只有一行，那么可以不需要用<code>{}</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如这个函数只需要返回42</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aParameterlessFunction</span></span>(): <span class="type">Int</span> = <span class="number">42</span></span><br><span class="line"><span class="comment">// 这个函数负责打印,不需要返回值，因此返回一个Unit对象</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aFunctionWithSideEffects</span></span>(aString: <span class="type">String</span>): <span class="type">Unit</span> = println(aString)</span><br></pre></td></tr></table></figure>
<p>我们可以写一个递归函数：会连续打印n遍 aString。 在scala中，当我们需要写一个for/while循环的时候，我们需要写一个等价的递归函数。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aRepeatedFunction</span></span>(aString: <span class="type">String</span>, n: <span class="type">Int</span>): <span class="type">String</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) aString</span><br><span class="line">  <span class="keyword">else</span> aString + aRepeatedFunction(aString, n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(aRepeatedFunction(<span class="string">"hello"</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>我们也可以在一个函数里面写另外一个函数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aBigFunction</span></span>(n: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">aSmallerFunction</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Int</span> = a + b</span><br><span class="line">  aSmallerFunction(n, n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(aBigFunction(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise"></a>Exercise</h4><p>写一个函数，用来判断一个数是否为素数？</p>
<p>在其他语言中，我们可能会用一个for循环，每次循环都让n除以一个不大于其自身$\frac{1}{2}$ 的数(1除外)，如果都不能整除，就说明这个数是素数。</p>
<p>在Scala中，由于我们要用递归去代替循环，那么就只能这么写：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span></span>(n: <span class="type">Int</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isPrimeUntil</span></span>(t: <span class="type">Int</span>): <span class="type">Boolean</span> =</span><br><span class="line">    <span class="keyword">if</span> (t &lt;= <span class="number">1</span>) <span class="literal">true</span></span><br><span class="line">    <span class="keyword">else</span> n % t != <span class="number">0</span> &amp;&amp; isPrimeUntil(t<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">  isPrimeUntil(n / <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Type-Inference"><a href="#Type-Inference" class="headerlink" title="Type Inference"></a>Type Inference</h3><p>Scala有隐式的类型转换，比如说：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="number">2</span></span><br><span class="line"><span class="keyword">val</span> y = x + <span class="string">"items"</span></span><br></pre></td></tr></table></figure>
<p>此时，编译器认为一个Int+一个String还是String，因此y的类型就是一个String类型的常量。</p>
<p>但是，也存在编译器推测失灵的情况，主要发生在递归函数里面。我们看到，如果n&lt;=0，会返回1，此时编译器会认为函数的返回类型为诶Int，但是第二行，返回的值类型是Int乘以一个函数调用，这就把便一起搞混了，到底是不是返回Int呢？</p>
<p>因此，在创建函数的时候最好点名函数的返回类型，如果返回类型为空，那么就将类型置为Unit</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span></span>(n: <span class="type">Int</span>): <span class="type">Int</span> =</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span> n * factorial(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">println(factorial(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<h3 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h3><p>使用递归函数的时候，很容易出现一种情况：<strong>栈溢出</strong>。就拿连乘函数来说，<code>factorial(10)</code> 还可以跑，但是<code>factorial(5000)</code> 就会报错。</p>
<p>那么怎么避免这个问题？</p>
<p>要解决问题就需要找到问题为什么会发生,<code>if (n &lt;= 0) 1 else n * factorial(n-1)</code> 这句代码中，每调用一次factorial，就会占用一行栈空间。</p>
<p>如果n=5，那么这个递归的调用过程大致如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">factorial(<span class="number">5</span>)</span><br><span class="line"><span class="number">5</span> * factorial(<span class="number">4</span>)</span><br><span class="line"><span class="number">5</span> * (<span class="number">4</span> * factorial(<span class="number">3</span>))</span><br><span class="line"><span class="number">5</span> * (<span class="number">4</span> * (<span class="number">3</span> * factorial(<span class="number">2</span>)))</span><br><span class="line"><span class="number">5</span> * (<span class="number">4</span> * (<span class="number">3</span> * (<span class="number">2</span> * factorial(<span class="number">1</span>))))</span><br><span class="line"><span class="number">5</span> * (<span class="number">4</span> * (<span class="number">3</span> * (<span class="number">2</span> * <span class="number">1</span>)))</span><br></pre></td></tr></table></figure>
<p>为了解决这个问题，需要学习“尾递归”的概念。什么是尾递归？尾递归是指递归调用是函数的最后一个语句，而且其结果被直接返回，这是一类特殊的递归调用。 由于递归结果总是直接返回，尾递归比较方便转换为循环，因此编译器容易对它进行优化。</p>
<p>以上阶乘函数不是尾递归，因为递归调用的结果有一次额外的乘法计算，这导致每一次递归调用留在堆栈中的数据都必须保留。我们可以将它修改为尾递归的方式。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">anotherFactorial</span></span>(n: <span class="type">Int</span>): <span class="type">BigInt</span> = &#123;</span><br><span class="line">  <span class="meta">@tailrec</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">factHelper</span></span>(x: <span class="type">Int</span>, accumulator: <span class="type">BigInt</span>): <span class="type">BigInt</span> =</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) accumulator</span><br><span class="line">    <span class="keyword">else</span> factHelper(x - <span class="number">1</span>, x * accumulator) </span><br><span class="line">  <span class="comment">// TAIL RECURSION = use recursive call as the LAST expression</span></span><br><span class="line">  factHelper(n, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的调用，由于调用结果都是直接返回，所以之前的递归调用留在堆栈中的数据可以丢弃，只需要保留最后一次的数据，这就是尾递归容易优化的原因所在， 而它的秘密武器就是上面的acc，它是一个累加器（accumulator，习惯上翻译为累加器，其实不一定非是“加”，任何形式的积聚都可以），用来积累之前调用的结果，这样之前调用的数据就可以被丢弃了。</p>
<p>因此，当我们需要用循环的时候，就可以用到 Tail Recursion</p>
<p>比如说我要用tail recursion来写一个判断是否为素数的函数，在这里我们的accumulator是一个布尔值的变量，用来记录在当前情况下，n是否还为素数。如果布尔值为否，那么就返回false，如果t&lt;=1了，说除到2还是素数，说明n是真的素数，因此返回true。如果t还没到1，那么就递归调用IsPrimeUntil函数，将布尔值设定为 <code>n%t != 0</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">IsPrime</span></span>(n: <span class="type">Int</span>): <span class="type">Boolean</span> =&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@tailrec</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">IsPrimeUntil</span></span>( isPrimeNow:<span class="type">Boolean</span>, t:<span class="type">Int</span>):<span class="type">Boolean</span> =&#123;</span><br><span class="line">    <span class="keyword">if</span>(!isPrimeNow) <span class="literal">false</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t&lt;=<span class="number">1</span>) <span class="literal">true</span></span><br><span class="line">    <span class="keyword">else</span> <span class="type">IsPrimeUntil</span>(n%t!=<span class="number">0</span>,t<span class="number">-1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">IsPrimeUntil</span>( <span class="literal">true</span>,n/<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如我要写一个Fibonacci的递归函数，这个比较难一些。和一般的Fibonacci思维不同，如果使用tail recursion，是从底部想上去加，而且要有两个accumulator来记录$f(n-1),f(n-2)$的值</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span></span>(n: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">   <span class="meta">@tailrec</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">fiboTailrec</span></span>(i: <span class="type">Int</span>, last: <span class="type">Int</span>, nextToLast: <span class="type">Int</span>): <span class="type">Int</span> =</span><br><span class="line">     <span class="keyword">if</span>(i &gt;= n) last</span><br><span class="line">     <span class="keyword">else</span> fiboTailrec(i + <span class="number">1</span>, last + nextToLast, last)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="number">1</span></span><br><span class="line">   <span class="keyword">else</span> fiboTailrec(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> println(fibonacci(<span class="number">8</span>)) <span class="comment">// 1 1 2 3 5 8 13, 21</span></span><br></pre></td></tr></table></figure>
<h3 id="Call-by-Name-and-Call-by-Value"><a href="#Call-by-Name-and-Call-by-Value" class="headerlink" title="Call-by-Name and Call-by-Value"></a>Call-by-Name and Call-by-Value</h3><p>scala的call by name 和call by value最大的区别就是：</p>
<p><strong>call-by-name在调用的时候会重新根据name做计算，而call-by-value预先计算，然后保留计算值后一直使用这个value。</strong></p>
<p>比如说：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calledByValue</span></span>(x: <span class="type">Long</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  println(<span class="string">"by value: "</span> + x)</span><br><span class="line">  println(<span class="string">"by value: "</span> + x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意，call by name的话，需要用到的语法不同，还要加上 =&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calledByName</span></span>(x: =&gt; <span class="type">Long</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  println(<span class="string">"by name: "</span> + x)</span><br><span class="line">  println(<span class="string">"by name: "</span> + x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">calledByValue(<span class="type">System</span>.nanoTime())</span><br><span class="line">calledByName(<span class="type">System</span>.nanoTime())</span><br></pre></td></tr></table></figure>
<p>结果如下图所示，我们看到，call by name的话，每次都会计算x的值；而call by value的话，会预计算x的值</p>
<p><img src="/2022/04/28/scala%E5%88%9D%E8%AF%86/1.png"></p>
<p>同时call by name传入的表达式是<strong>lazy</strong> 的，也就是说，只有要用到这个参数的时候，才回去计算这个参数的值。</p>
<p>比如说：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">infinite</span></span>(): <span class="type">Int</span> = <span class="number">1</span> + infinite()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printFirst</span></span>(x: <span class="type">Int</span>, y: =&gt; <span class="type">Int</span>) = println(x)</span><br><span class="line"></span><br><span class="line">printFirst(infinite(), <span class="number">34</span>) <span class="comment">// stack overflow</span></span><br><span class="line">printFirst(<span class="number">34</span>, infinite())</span><br></pre></td></tr></table></figure>
<p>如上面这几行代码，我们定义了一个无限递归的函数infinite，如果调用infinite()必会导致stackoverflow</p>
<p>然后我们有定义了一个printFirst函数，第一个参数是call by value的，第二个是call by name的。</p>
<p>如果我们调用<code>printFirst(infinite(), 34)</code>，会报错，因为x是call by value的，需要预计算，那么丢会调用<code>infinite()</code>.导致栈溢出</p>
<p>但是如果我们调用<code>printFirst(34,infinite())</code>,就不会报错，因为y是call by name的，是<strong>lazy</strong> 的，若函数体内没有关于y的调用，就不会去计算y的值。因此不会报错。</p>
<p>当然，如果输入的都是数字的话，那么call by name和call by value就是一样的了</p>
<h3 id="Default-and-Named-Arguments"><a href="#Default-and-Named-Arguments" class="headerlink" title="Default and Named Arguments"></a>Default and Named Arguments</h3><p>在写下尾递归的时候，我们常常会选择两个函数嵌套的写法，这是因为我们不想让用户手动输入accumulator的值，函数嵌套可以实现对用户的透明机制。</p>
<p>那么可不可以既实现透明，又只写一层函数的方法呢？显然，我们可以用默认参数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trFact</span></span>(n: <span class="type">Int</span>, acc: <span class="type">Int</span> = <span class="number">1</span>): <span class="type">Int</span> =</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) acc</span><br><span class="line">  <span class="keyword">else</span> trFact(n<span class="number">-1</span>, n*acc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> fact10 = trFact(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>如果一个函数有多个默认参数的话，编译器会默认输入的第一个参数对应函数中第一个place holder，因此如果我们想让第一个参数默认，其他两个参数自己设置的话，就需要我们显式得设置参数的名字。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">savePicture</span></span>(format: <span class="type">String</span> = <span class="string">"jpg"</span>, width: <span class="type">Int</span> = <span class="number">1920</span>, height: <span class="type">Int</span> = <span class="number">1080</span>): <span class="type">Unit</span> = println(<span class="string">"saving picture"</span>)</span><br><span class="line"> savePicture(<span class="string">"jpg"</span>,<span class="number">800</span>,<span class="number">600</span>)<span class="comment">// 这是可以的</span></span><br><span class="line"> savePicture(height = <span class="number">600</span>, width = <span class="number">800</span>)<span class="comment">//这也是可以的</span></span><br><span class="line">savePicture(<span class="number">800</span>,<span class="number">600</span>)<span class="comment">//这就会报错</span></span><br></pre></td></tr></table></figure>
<h3 id="Smart-Operations-on-Strings"><a href="#Smart-Operations-on-Strings" class="headerlink" title="Smart Operations on Strings"></a>Smart Operations on Strings</h3><p>现在我们来介绍一些对于字符串的操作</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> str: <span class="type">String</span> = <span class="string">"Hello, I am learning Scala"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>输出指定位置的字符</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(str.charAt(<span class="number">2</span>)) <span class="comment">// l</span></span><br></pre></td></tr></table></figure>
<ul>
<li>节选字符串</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(str.substring(<span class="number">7</span>,<span class="number">11</span>))	<span class="comment">//I am</span></span><br><span class="line">println(str.take(<span class="number">2</span>)) <span class="comment">//He</span></span><br></pre></td></tr></table></figure>
<ul>
<li>切分字符串</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(str.split(<span class="string">" "</span>).toList) <span class="comment">//List(Hello,, I, am, learning, Scala)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>判断字符串是否从某字符串开始</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(str.startsWith(<span class="string">"Hello"</span>)) <span class="comment">//True</span></span><br></pre></td></tr></table></figure>
<ul>
<li>字符串替换</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(str.replace(<span class="string">" "</span>, <span class="string">"-"</span>)) <span class="comment">//Hello,-I-am-learning-Scala</span></span><br></pre></td></tr></table></figure>
<ul>
<li>小写化</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(str.toLowerCase()) <span class="comment">//hello, i am learning scala</span></span><br></pre></td></tr></table></figure>
<ul>
<li>字符串长度</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(str.length) <span class="comment">// 26</span></span><br></pre></td></tr></table></figure>
<ul>
<li>字符串反转</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(str.reverse) <span class="comment">// alacS gninrael ma I ,olleH</span></span><br></pre></td></tr></table></figure>
<ul>
<li>字符串转为数字</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aNumberString = <span class="string">"2"</span></span><br><span class="line"><span class="keyword">val</span> aNumber = aNumberString.toInt</span><br></pre></td></tr></table></figure>
<ul>
<li><p>字符串和数字拼接，需要用到特殊的拼接符号。</p>
<ul>
<li>+: 用于在list的头部添加元素</li>
<li>:+ 用于在list尾部追加元素; </li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println('a' +: aNumberString :+ 'z')</span><br></pre></td></tr></table></figure>
</li>
<li><p>S-插值器</p>
</li>
</ul>
<p>S-插值器的语法有点类似于CSS、PHP中的变量。也就是说，利用S-插值器可以往字符串中插入变量，比如说”</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name = <span class="string">"David"</span></span><br><span class="line"><span class="keyword">val</span> age = <span class="number">12</span></span><br><span class="line"><span class="keyword">val</span> greeting = <span class="string">s"Hello, my name is <span class="subst">$name</span> and I am <span class="subst">$age</span> years old"</span></span><br><span class="line"><span class="keyword">val</span> anotherGreeting = <span class="string">s"Hello, my name is <span class="subst">$name</span> and I will be turning <span class="subst">$&#123;age + 1&#125;</span> years old."</span></span><br><span class="line">println(anotherGreeting) <span class="comment">//Hello, my name is David and I will be turning 13 years old.</span></span><br></pre></td></tr></table></figure>
<ul>
<li>F-插值器</li>
</ul>
<p>F-插值器的作用是用来格式化的</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> speed = <span class="number">1.2</span>f</span><br><span class="line"><span class="keyword">val</span> myth = <span class="string">f"<span class="subst">$name</span> can eat <span class="subst">$speed</span>%2.2f burgers per minute"</span></span><br><span class="line">println(myth) <span class="comment">// David can eat 1.20 burgers per minute</span></span><br></pre></td></tr></table></figure>
<ul>
<li>raw-插值器</li>
</ul>
<p>raw插值器则是让字符串中的转义符失效 。 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> str2 = <span class="string">"a\nb"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> str3 = <span class="string">raw"a\nb"</span></span><br><span class="line"></span><br><span class="line">println(str2) <span class="comment">// \n 生效，a和b之间换行</span></span><br><span class="line"></span><br><span class="line">println(str3)	<span class="comment">// a\nb , \n失效</span></span><br></pre></td></tr></table></figure>
<p>但是我如果把string当做一个插入的参数打印，那么转义符就不会失效，比如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> escaped = <span class="string">"This is a \n newline"</span></span><br><span class="line">println(<span class="string">raw"<span class="subst">$escaped</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">This is a </span></span><br><span class="line"><span class="comment"> newline</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="Object-Oriented-Programming-in-Scala"><a href="#Object-Oriented-Programming-in-Scala" class="headerlink" title="Object Oriented Programming in Scala"></a>Object Oriented Programming in Scala</h2><h3 id="Object-Oriented-Basics"><a href="#Object-Oriented-Basics" class="headerlink" title="Object-Oriented Basics"></a>Object-Oriented Basics</h3><p>现在我们来创建一个最简单的类</p>
<p>我们首先从构造类的参数说起。这个Person类需要两个构造参数：name和age，其中，age用val来修饰，说明age变成了类中的一个成员，我们可以用<code>person.age</code>来访问；但是name只是一个参数，我们无法用<code>person.name</code> 来获取这个参数。</p>
<p>然后我们来看类中的body部分，这一部分类似于CodeBlock，一些逻辑会直接运行。如果在里面定义了常量或者定量，他们都会变成<strong>fields</strong>我们都可以通过点运算符对其进行访问</p>
<p>接着我们来看两个函数，函数名都是greet，因此会发生函数重载。第一个greet函数接收一个String类型的参数，并打印字符串，这个字符串里面如果需要引用这个传参，需要用<code>${this.name}</code> ，而不能单纯的用<code>$name</code></p>
<p>第二个函数没有任何输入参数，直接打印字符串，这里调用的参数是 <code>$name</code> ,是类里面的成员变量</p>
<p>和C++一样，scala也支持在类里面写多个构造函数，可以是没有参数的构造函数，也可以是有参数的</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, val age: <span class="type">Int</span> = 0</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body</span></span><br><span class="line">  <span class="keyword">val</span> x = <span class="number">2</span></span><br><span class="line">  println(<span class="number">1</span> + <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// method</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">greet</span></span>(name: <span class="type">String</span>): <span class="type">Unit</span> = println(<span class="string">s"<span class="subst">$&#123;this.name&#125;</span> says: Hi, <span class="subst">$name</span>"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// overloading</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">greet</span></span>(): <span class="type">Unit</span> = println(<span class="string">s"Hi, I am <span class="subst">$name</span>"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// multiple constructors</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(name: <span class="type">String</span>) = <span class="keyword">this</span>(name, <span class="number">0</span>) <span class="comment">//如果只有一个string参数的构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>() = <span class="keyword">this</span>(<span class="string">"John Doe"</span>)		<span class="comment">//如果没有参数，其构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> person = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"John"</span>, <span class="number">26</span>) <span class="comment">//在创建对象时就会打印 4</span></span><br><span class="line">  println(person.x)			 <span class="comment">// 2</span></span><br><span class="line">  person.greet(<span class="string">"Daniel"</span>) <span class="comment">//John says: Hi, Daniel</span></span><br><span class="line">  person.greet() 				 <span class="comment">//Hi, I am John</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">val</span> person2 = <span class="keyword">new</span> <span class="type">Person</span>()</span><br><span class="line">  person2.greet()					<span class="comment">//Hi, I am John Doe</span></span><br></pre></td></tr></table></figure>
<h4 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise"></a>Exercise</h4><ol>
<li><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Novel and a Writer</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Writer: first name, surname, year(出生年)</span></span><br><span class="line"><span class="comment">    - method fullname 返回全名</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Novel: name, year of release, author</span></span><br><span class="line"><span class="comment">  - authorAge 返回作者的年龄</span></span><br><span class="line"><span class="comment">  - isWrittenBy(author) 返回作者对象</span></span><br><span class="line"><span class="comment">  - copy (new year of release) = new instance of Novel 返回一个新实例</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Writer</span>(<span class="params">firstName: <span class="type">String</span>, surname: <span class="type">String</span>, val year: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fullName</span></span>: <span class="type">String</span> = firstName + <span class="string">" "</span> + surname</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Novel</span>(<span class="params">name: <span class="type">String</span>, year: <span class="type">Int</span>, author: <span class="type">Writer</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">authorAge</span> </span>= year - author.year</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isWrittenBy</span></span>(author: <span class="type">Writer</span>) = author == <span class="keyword">this</span>.author</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">copy</span></span>(newYear: <span class="type">Int</span>): <span class="type">Novel</span> = <span class="keyword">new</span> <span class="type">Novel</span>(name, newYear, author)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Counter class</span></span><br><span class="line"><span class="comment">    - receives an int value</span></span><br><span class="line"><span class="comment">    - method current count </span></span><br><span class="line"><span class="comment">    // 需要实现两个方法，一个增1，一个减1</span></span><br><span class="line"><span class="comment">    - method to increment/decrement =&gt; new Counter</span></span><br><span class="line"><span class="comment">    // 还要实现函数重载，输入一个n，要增加n次</span></span><br><span class="line"><span class="comment">    - overload inc/dec to receive an amount</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span>(<span class="params">val count: <span class="type">Int</span> = 0</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inc</span> </span>= &#123;</span><br><span class="line">    println(<span class="string">"incrementing"</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Counter</span>(count + <span class="number">1</span>)  <span class="comment">// immutability</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//	def dec():Counter =&#123;&#125;</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dec</span> </span>= &#123;</span><br><span class="line">    println(<span class="string">"decrementing"</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Counter</span>(count - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 这是一个递归函数，但是不是下尾递归</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inc</span></span>(n: <span class="type">Int</span>): <span class="type">Counter</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">else</span> inc.inc(n<span class="number">-1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dec</span></span>(n: <span class="type">Int</span>): <span class="type">Counter</span> =</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">else</span> dec.dec(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">print</span> </span>= println(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于函数返回一个Counter，所以可以在调用inc之后继续调用inc，如果调用了三次，那么会让count+3 = 3</p>
<p>但是如果重新调用inc，那么之前的inc并不会累加，对于counter来说，其count值始终为零。 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">调用: counter.inc.print</span><br><span class="line">incrementing</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line">调用: counter.inc.inc.inc.print</span><br><span class="line">incrementing</span><br><span class="line">incrementing</span><br><span class="line">incrementing</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">调用: counter.inc(<span class="number">10</span>).print</span><br><span class="line">incrementing</span><br><span class="line">incrementing</span><br><span class="line">incrementing</span><br><span class="line">incrementing</span><br><span class="line">incrementing</span><br><span class="line">incrementing</span><br><span class="line">incrementing</span><br><span class="line">incrementing</span><br><span class="line">incrementing</span><br><span class="line">incrementing</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<h3 id="Syntactic-Sugar-Method-Notations"><a href="#Syntactic-Sugar-Method-Notations" class="headerlink" title="Syntactic Sugar: Method Notations"></a>Syntactic Sugar: Method Notations</h3><p>现在来介绍一些语法糖。scala是一个很”自然语言化”的语言，里面有很多特殊的语法，我觉得很像是C++中的运算符重载。</p>
<ul>
<li>infix notation/ operator notation ，这种语法只适用于<strong>只有一个参数的函数</strong>中 。 在scala中，我们要理解一个概念：所有的操作符，同时也是一个函数。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val name: <span class="type">String</span>, favoriteMovie: <span class="type">String</span>,val age: <span class="type">Int</span> = 0</span>)</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">likes</span></span>(movie:<span class="type">String</span>): <span class="type">Boolean</span> = movie == favourite</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hangOutWith</span></span>(person: <span class="type">Person</span>): <span class="type">String</span> = <span class="string">s"<span class="subst">$&#123;this.name&#125;</span> is hanging out with <span class="subst">$&#123;person.name&#125;</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> mary = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"Mary"</span>,<span class="string">"Inception"</span>)</span><br><span class="line"><span class="keyword">val</span> tom - <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"Tom"</span>,<span class="string">"Fight Club"</span>)</span><br></pre></td></tr></table></figure>
<p>我们要调用Person中的likes函数,正常的写法如下：<code>mary.likes(&quot;Inception&quot;)</code></p>
<p>但我们可以直接这样写： <code>mary likes &quot;Inception&quot;</code>， 也就是将其他特殊符号全部略去，只留下最重要的三个部分。又比如说，可以直接写  <code>mary hangOutWith tom</code></p>
<p>甚至我可以重命名hangOutWith函数为 <code>def +(person: Person): String = s&quot;${this.name} is hanging out with ${person.name}&quot;</code>， 那么就可以这么写： <code>mary + tom</code></p>
<p>而<code>+</code> 和<code>.+</code> 是相等的，所以我们还可以这么写： <code>mary.+(tom)</code></p>
<ul>
<li>prefix notation，主要是 <code>unary_</code> 前缀，它只<strong>适用于单目运算符</strong><code>-,+,~,!</code> </li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="number">-1</span>  <span class="comment">// equivalent with 1.unary_-</span></span><br><span class="line"><span class="keyword">val</span> y = <span class="number">1.</span>unary_- <span class="comment">// x和y是相等的</span></span><br></pre></td></tr></table></figure>
<p>同样的，我们也可以在Person类中定义 名为<code>unary_!</code>的函数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val name: <span class="type">String</span>, favoriteMovie: <span class="type">String</span>,val age: <span class="type">Int</span> = 0</span>)</span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">unary_!</span> </span>: <span class="type">String</span> = <span class="string">s"<span class="subst">$name</span>, what the heck?!"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unary_+</span> </span>: <span class="type">Person</span> = <span class="keyword">new</span> <span class="type">Person</span>(name, favoriteMovie, age + <span class="number">1</span>)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面两个表达式是等价的 打印值： Hi, my name is Mary and I like Inception</span></span><br><span class="line">println(!mary)				</span><br><span class="line">println(mary.unary_!)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面两个表达式也是等价的，打印值： 1</span></span><br><span class="line">println(+mary.age)</span><br><span class="line">println(mary.unary_+.age)</span><br></pre></td></tr></table></figure>
<ul>
<li>Postfix notation 适用于<strong>没有任何参数的函数</strong></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val name: <span class="type">String</span>, favoriteMovie: <span class="type">String</span>, val age: <span class="type">Int</span> = 0</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isAlive</span></span>: <span class="type">Boolean</span> = <span class="literal">true</span> <span class="comment">//直接返回true</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(): <span class="type">String</span> = <span class="string">s"Hi, my name is <span class="subst">$name</span> and I like <span class="subst">$favoriteMovie</span>"</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(n: <span class="type">Int</span>): <span class="type">String</span> = <span class="string">s"<span class="subst">$name</span> watched <span class="subst">$favoriteMovie</span> <span class="subst">$n</span> times"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.language.postfixOps</span><br><span class="line"></span><br><span class="line">println(mary.isAlive)</span><br><span class="line"><span class="comment">//用这种写法也可以，只不过需要导入一个包，不建议使用</span></span><br><span class="line">println(mary isAlive)</span><br></pre></td></tr></table></figure>
<ul>
<li>apply () 函数</li>
</ul>
<p>当我们直接在一个对象后面加上<code>()</code>,编译器就会自动调用该类中的apply函数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val name: <span class="type">String</span>, favoriteMovie: <span class="type">String</span>, val age: <span class="type">Int</span> = 0</span>) </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(): <span class="type">String</span> = <span class="string">s"Hi, my name is <span class="subst">$name</span> and I like <span class="subst">$favoriteMovie</span>"</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(n: <span class="type">Int</span>): <span class="type">String</span> = <span class="string">s"<span class="subst">$name</span> watched <span class="subst">$favoriteMovie</span> <span class="subst">$n</span> times"</span></span><br><span class="line">&#125;</span><br><span class="line">println(mary.apply())</span><br><span class="line">println(mary()) <span class="comment">// equivalent</span></span><br></pre></td></tr></table></figure>
<h4 id="Method-Notations-Exercises"><a href="#Method-Notations-Exercises" class="headerlink" title="Method Notations (Exercises)"></a>Method Notations (Exercises)</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  1.  Overload the + operator</span></span><br><span class="line"><span class="comment">      mary + "the rockstar" =&gt; new person "Mary (the rockstar)"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">+</span></span>(nickname:<span class="type">String</span>) = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">s"name(<span class="subst">$nickname</span>)"</span>,favoriteMovie)</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  2.  Add an age to the Person class</span></span><br><span class="line"><span class="comment">      Add a unary + operator =&gt; new person with the age + 1</span></span><br><span class="line"><span class="comment">      +mary =&gt; mary with the age incrementer</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unary_+</span> </span>: <span class="type">Person</span> = <span class="keyword">new</span> <span class="type">Person</span>(name,favoriteMovie,age+<span class="number">1</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  3.  Add a "learns" method in the Person class =&gt; "Mary learns Scala"</span></span><br><span class="line"><span class="comment">      Add a learnsScala method, calls learns method with "Scala".</span></span><br><span class="line"><span class="comment">      Use it in postfix notation.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">learns</span></span>(lessons:<span class="type">String</span>) = <span class="string">s"<span class="subst">$name</span> learns <span class="subst">$lessons</span>"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">learnScala</span> </span>= <span class="keyword">this</span> learns <span class="string">"Scala"</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  4.  Overload the apply method</span></span><br><span class="line"><span class="comment">      mary.apply(2) =&gt; "Mary watched Inception 2 times"</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(n: <span class="type">Int</span>): <span class="type">String</span> = <span class="string">s"<span class="subst">$name</span> watched <span class="subst">$favoriteMovie</span> <span class="subst">$n</span> times"</span></span><br></pre></td></tr></table></figure>
<h3 id="Scala-Objects"><a href="#Scala-Objects" class="headerlink" title="Scala Objects"></a>Scala Objects</h3><p>Scala既然可以当做面向对象的语言来写，那么就必须具备面向对象语言的特征。那么其中一个特征就是：类内静态方法、静态成员变量。静态方法我们在Java中学过，就是只能被类调用，而不能被实例调用。比如说：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    public static <span class="keyword">final</span> int <span class="type">N_EYES</span> = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么在scala中，如何实现类内静态成员呢？ 答案就是Object</p>
<p>比如我创建一个名为Person的Object，里面的所有成员都是静态的，如果要调用，只能这样来写<code>Person.N_EYES</code>,<code>Person.canFlay</code>, <code>Person.apply</code> </p>
<p>此外，Object只有唯一一个实例，就是他自己，如果我令 <code>mary = Person(&quot;Mary&quot;)</code> ，又令 <code>john = Person(&quot;John&quot;)</code> 。那么事实上，mary和john是相等的，它们都是同一个实例。 专业一点叫做singleton instance</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123; <span class="comment">// type + its only instance</span></span><br><span class="line">  <span class="comment">// "static"/"class" - level functionality</span></span><br><span class="line">  <span class="keyword">val</span> <span class="type">N_EYES</span> = <span class="number">2</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">canFly</span></span>: <span class="type">Boolean</span> = <span class="literal">false</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> mary = <span class="type">Person</span></span><br><span class="line">    <span class="keyword">val</span> john = <span class="type">Person</span></span><br><span class="line">    println(mary == john) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>那么如果要创建一个实例的的话，就需要另外创建一个<code>class Person</code>, 这里object 和 class后面的名字必须相同。可以这么说，<strong>Scala中的Object和Class共同构成了Java中的类</strong>。</p>
<p>如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123; <span class="comment">// type + its only instance</span></span><br><span class="line">  <span class="comment">// "static"/"class" - level functionality</span></span><br><span class="line">  <span class="keyword">val</span> <span class="type">N_EYES</span> = <span class="number">2</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">canFly</span></span>: <span class="type">Boolean</span> = <span class="literal">false</span></span><br><span class="line">	<span class="comment">// 静态方法，只能通过Person.apply调用</span></span><br><span class="line">  <span class="comment">// factory method</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(mother: <span class="type">Person</span>, father: <span class="type">Person</span>): <span class="type">Person</span> = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"Bobbie"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val name: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// instance-level functionality</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意，如果既写了 object，又写了 class. 那么如果我们用new的话，一定是新建一个实例。</span></span><br><span class="line"><span class="keyword">val</span> mary = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"Mary"</span>) <span class="comment">// 新实例 mary</span></span><br><span class="line"><span class="keyword">val</span> john = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"John"</span>) <span class="comment">// 新实例 John</span></span><br><span class="line">println(mary == john)					<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如果我想调用类内静态方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> bobbie = <span class="type">Person</span>(mary,john)</span><br></pre></td></tr></table></figure>
<p>最后，我们来说为什么我们现在都用<code>object xxx extends App</code> 来运行scala文件：</p>
<p>在Java中，要使程序能够运行，需要有一个main函数，如下所示：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; </span><br><span class="line">    public static void main(<span class="type">String</span>[] args) &#123; </span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于scala到最后也是需要放到JVM上去运行的，因此也需要有一个main函数。scala中的main函数如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span></span><br></pre></td></tr></table></figure>
<p>但是如果我们用 <code>object xxx extends App</code> ，那么就会继承 App中的main函数，我们就不用每次都写了。</p>
<h3 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h3><p>既然上面提到了 继承，现在我们就来说说scala中的继承是怎么回事。</p>
<p>scala的继承以及一些关键字基本和Java中的类似。</p>
<h4 id="单类继承"><a href="#单类继承" class="headerlink" title="单类继承"></a>单类继承</h4><p>一个基本的单类继承如下：我创建了一个Animal类，然后有创建了一个Cat类去继承Animal，此时在Cat类中就可以继承Animal中的成员了。</p>
<p>成员默认是<strong>public</strong>,子类和外部都可以调用</p>
<p>如果成员被<strong>private</strong>修饰，那么其子类就无法调用和外部就无法调用</p>
<p>如果成员被<strong>protected</strong>修饰，那么其子类内部可以调用，但外部无法调用(实例调用)</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> creatureType = <span class="string">"wild"</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eat</span> </span>= println(<span class="string">"nomnom"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">crunch</span> </span>= &#123;</span><br><span class="line">    eat</span><br><span class="line">    println(<span class="string">"crunch crunch"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> cat = <span class="keyword">new</span> <span class="type">Cat</span></span><br><span class="line">cat.crunch</span><br></pre></td></tr></table></figure>
<p>那么如果父类和子类的参数不同，该如何写继承语法？</p>
<p>比如说，Person有两个参数，Adult有三个参数，如果我们还是直接 <code>extends Person</code> ,编译器会报错。因此这样如果新建一个Adult实例的话，Adult事实上会调用Person中的构造函数，而Person中的构造函数只接受两个参数。因此，对于子类和父类参数不同的情况下，在继承时就要调用父类的构造函数，如下</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(name: <span class="type">String</span>) = <span class="keyword">this</span>(name, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adult</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span>, idCard: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Person</span>(<span class="params">name</span>)<span class="title">//Person</span>(<span class="params">name,age</span>) <span class="title">这里父类有两个构造函数，因此传入一个或者两个都可</span></span></span><br><span class="line"><span class="class"><span class="title">/*</span></span></span><br><span class="line"><span class="class"><span class="title">当然，如果父类中有这样的</span>  <span class="title">def</span> <span class="title">this</span>(<span class="params"></span>) </span>= <span class="keyword">this</span>(<span class="string">"112"</span>,<span class="number">0</span>)构造函数</span><br><span class="line">那么子类也可以直接 <span class="keyword">extends</span> <span class="type">Person</span></span><br><span class="line"></span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h4 id="函数重写"><a href="#函数重写" class="headerlink" title="函数重写"></a>函数重写</h4><p>在子类 可以重写父类中的函数和成员变量，需要使用override关键词。</p>
<p>当然，如果重写的是父类中的成员变量，可以放在子类的构造函数中，比如：<code>Dog(override val creatureType: String)</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">override val creatureType: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//override val creatureType = "domestic" // can override in the body or directly in the constructor arguments</span></span><br><span class="line">  	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">eat</span> </span>= &#123; </span><br><span class="line">    println(<span class="string">"crunch, crunch"</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>如果想要在重写的函数中仍然运行父类中的代码，可以使用<code>super</code>，super就代表父类，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Dog(override val creatureType: String) extends Animal &#123;</span><br><span class="line">  	override def eat &#x3D; &#123; </span><br><span class="line">  	super.eat</span><br><span class="line">    println(&quot;crunch, crunch&quot;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>事实上我们要尽量避免函数继承，因为会很乱。这里提供了一些办法来避免函数的重载：</p>
<ul>
<li>对成员变量、成员函数使用 final 关键词修饰，就可以避免被重写</li>
<li>对类用final关键词修饰，就可以避免该类被继承</li>
<li>新语法：使用seal关键词，如果用seal来修饰类，那么<strong>仅在此文件中可以继承该类</strong>，但是其他文件中无法继承该类</li>
</ul>
<h3 id="Inheritance-Continued-Abstract-Classes-and-Traits"><a href="#Inheritance-Continued-Abstract-Classes-and-Traits" class="headerlink" title="Inheritance, Continued:  Abstract Classes and Traits"></a>Inheritance, Continued:  Abstract Classes and Traits</h3><h4 id="Abstract-class"><a href="#Abstract-class" class="headerlink" title="Abstract  class"></a>Abstract  class</h4><ul>
<li>抽象类的一个或者多个方法没有完整的定义</li>
<li>声明抽象方法不需要加abstract关键字，<strong>只需要不写方法体</strong>，如<code>def eat: Unit</code></li>
<li>子类重写父类的抽象方法时<strong>不需要</strong>加override</li>
<li>父类可以声明抽象字段（没有初始值的字段）</li>
<li>子类重写父类的抽象字段时不需要加override</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> creatureType: <span class="type">String</span> = <span class="string">"wild"</span> <span class="comment">// 非抽象字段</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>: <span class="type">Unit</span> <span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> creatureType: <span class="type">String</span> = <span class="string">"Canine"</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>: <span class="type">Unit</span> = println(<span class="string">"crunch crunch"</span>) <span class="comment">//重写父类抽象方法时不需要加override </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Traits"><a href="#Traits" class="headerlink" title="Traits"></a>Traits</h4><p>类似于Java中的接口，trait被用于通过所支持的方法特例化来定义对象。如Java 8中一样，<a href="https://so.csdn.net/so/search?q=Scala&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">Scala</a>允许trait被部分实现。其有以下特征：</p>
<ul>
<li>Abstract class和Traits 可以<strong>同时有抽象成员和非抽象成员</strong> </li>
<li>但是和class相比，trait 没有构造函数. </li>
<li>一个类只能继承一个抽象类，但可以混合多个traits。 比如说下面的Crocodile，继承了Animal，同时继承了两个traits: Carnivore和ColdBlooded</li>
<li>一般 抽象类是描述一种物体的，而一个traits 是用来描述该物体的行为的</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Carnivore</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>(animal: <span class="type">Animal</span>): <span class="type">Unit</span></span><br><span class="line">  <span class="keyword">val</span> preferredMeal: <span class="type">String</span> = <span class="string">"fresh meat"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ColdBlooded</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Crocodile</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">with</span> <span class="title">Carnivore</span> <span class="keyword">with</span> <span class="title">ColdBlooded</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> creatureType: <span class="type">String</span> = <span class="string">"croc"</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>: <span class="type">Unit</span> = println(<span class="string">"nomnomnom"</span>) <span class="comment">//重写抽象类中的抽象方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>(animal: <span class="type">Animal</span>): <span class="type">Unit</span> = println(<span class="string">s"I'm a croc and I'm eating <span class="subst">$&#123;animal.creatureType&#125;</span>"</span>)<span class="comment">//重写traits中的抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Type-Hierarchy"><a href="#Type-Hierarchy" class="headerlink" title="Type Hierarchy"></a>Type Hierarchy</h4><p>最后提一嘴Scala中的类型结构，首先，所有类型都是继承自 <code>scala.Any</code> , 这就类似于JavaScript中的Object类， Any是整个Scala类型系统的<strong>超类</strong>。 </p>
<p><code>scala.Any</code>下面分为两个类： <code>scala.AnyVal</code>  和 <code>scala.AnyRef</code> 。</p>
<ul>
<li><code>scala.AnyVal</code>类中，主要是Int，Unit，Boolean，Float这几个数值类</li>
<li><code>scala.AnyRef</code>类中，主要是String，List, Set 这几个引用类型</li>
<li><code>scala.Noting</code>类是一切类的<strong>子类</strong>，包括我们自己创建的类</li>
</ul>
<p><img src="/2022/04/28/scala%E5%88%9D%E8%AF%86/2.jpeg"></p>
<h3 id="Inheritance-Exercises-Implementing-Our-Own-Collection"><a href="#Inheritance-Exercises-Implementing-Our-Own-Collection" class="headerlink" title="Inheritance Exercises Implementing Our Own Collection"></a>Inheritance Exercises Implementing Our Own Collection</h3><p>现在我们要实现一个Int类型的链表，链表要实现这样几个功能：</p>
<ul>
<li><code>head</code>：返回链表头部</li>
<li><code>def tail</code>: 返回除了链表头部以外的剩余部分</li>
<li><code>def isEmpty</code>: 返回链表是否为空</li>
<li><code>def add(int)</code>: 往链表中添加元素</li>
<li><code>def toString</code>: 可以打印链表中的元素</li>
</ul>
<p>根据上述要求我们写一个抽象类如下：我们要用函数式编程的思路去设计这个列表。所以添加一各元素，需要返回一个新的对象。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyList</span> </span>&#123;  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">head</span></span>: <span class="type">Int</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tail</span></span>: <span class="type">MyList</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>: <span class="type">Boolean</span></span><br><span class="line"> 	<span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(element:<span class="type">Int</span>): <span class="type">MyList</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printElements</span></span>: <span class="type">String</span></span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>: <span class="type">String</span> = <span class="string">"["</span>+printElements+<span class="string">"]"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们要实现这个列表：由于一开始新建链表的时候，肯定需要一个空链表，因此我们要创建一个Empty的对象。这里Object没必要用class, 因为我们没有创建一个Empty实例然后去调用其内部方法的需求和必要。</p>
<p>然后创建 一个Cons类，同样继承MyList，这个类需要传入两个参数，链表的头部和其他部分。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Empty</span> <span class="keyword">extends</span> <span class="title">MyList</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">head</span></span>: <span class="type">Int</span> = <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchElementException</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tail</span></span>: <span class="type">MyList</span> = <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchElementException</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(element : <span class="type">Int</span>): <span class="type">MyList</span> = <span class="keyword">new</span> <span class="type">Cons</span>(element,<span class="type">Empty</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printElements</span></span>: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cons</span>(<span class="params">head:<span class="type">Int</span>,tail:<span class="type">MyList</span></span>) <span class="keyword">extends</span> <span class="title">MyList</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">head</span></span>: <span class="type">Int</span> = head;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tail</span></span>: <span class="type">MyList</span> = tail;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>: <span class="type">Boolean</span> = <span class="literal">false</span>; </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(element:<span class="type">Int</span>):<span class="type">MyList</span> = <span class="keyword">new</span> <span class="type">Cons</span>(element,<span class="keyword">this</span>)</span><br><span class="line">  <span class="comment">//这是一个递归，每次只打印一个节点的头部</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printElements</span></span>: <span class="type">String</span> = </span><br><span class="line">  	<span class="keyword">if</span> (t.isEmpty)<span class="string">""</span>+h</span><br><span class="line">  	<span class="keyword">else</span> h+<span class="string">" "</span>+t.printElements </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">1</span>,<span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">3</span>,<span class="type">Empty</span>))) <span class="comment">// 1,2,3</span></span><br><span class="line">println(list.tail.head)			<span class="comment">// 2</span></span><br><span class="line">println(list.add(<span class="number">4</span>).head)   <span class="comment">// 4</span></span><br><span class="line">println(list.isEmpty)       <span class="comment">// false</span></span><br><span class="line">println(list.toString) 			<span class="comment">// [1 2 3]</span></span><br></pre></td></tr></table></figure>
<h3 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h3><p>现在来谈谈scala中的泛型类，这一块比较难</p>
<p>泛型类使用中括号 <code>[]</code> 接收类型参数，虽然类型参数可以是任何名字，但是一个惯例是使用字母 <code>A</code> 作为类型参数标识符。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如说我定义一个MyList的泛型类：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">	<span class="comment">// use the type A</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型类不一定只有一个参数,比如说我创建一个映射类，Key可以使一个数据类型，Value则可是另一种数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMap</span>[<span class="type">Key</span>,<span class="type">Value</span>]</span></span><br></pre></td></tr></table></figure>
<p>这个MyList泛型类使用A作为类型参数。这意味着这个 MyList[A] 只能存储类型为A的元素。因此，我可以创建一个字符串类型的列表，一个整数类型的列表：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listOfIntegers = <span class="keyword">new</span> <span class="type">MyList</span>[<span class="type">Int</span>]</span><br><span class="line"><span class="keyword">val</span> listOfStrings = <span class="keyword">new</span> <span class="type">MyList</span>[<span class="type">String</span>]</span><br></pre></td></tr></table></figure></p>
<p> 然后我们来说说泛型方法：泛型方法就是接收了泛型参数的方法，如下</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generic methods</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyList</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">empty</span></span>[<span class="type">A</span>]: <span class="type">MyList</span>[<span class="type">A</span>] = ??? <span class="comment">//这是一个静态方法，返回MyList[A]</span></span><br><span class="line">  <span class="comment">// ??? 是TODO的意思，这里只讲语法，因此不表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//比如我要创建一个空的存放整数类型的list，可以这样写：</span></span><br><span class="line"><span class="keyword">val</span> emptyListOfIntegers = <span class="type">MyList</span>.empty[<span class="type">Int</span>]</span><br></pre></td></tr></table></figure>
<h4 id="variance-problem"><a href="#variance-problem" class="headerlink" title="variance problem"></a>variance problem</h4><p>现在我们来讨论一下泛型中多样化的问题</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span></span><br></pre></td></tr></table></figure>
<p>我们来看，Cat是Animal的子类，Dog也是Animal的子类，那么，<code>MyList[Cat]</code>是不是<code>MyList[Animal]</code>的子类</p>
<p>我们有三种推测</p>
<ul>
<li><code>MyList[Cat]</code>是 <code>MyList[Animal]</code>的子类, 即  <code>List[Cat] extends List[Animal]</code>，二者 Covariance(协变)</li>
<li><code>MyList[Cat]</code>不是<code>MyList[Animal]</code>的子类，即 二者 Invariance(不可变)</li>
<li><code>MyList[Cat]</code>反而要比<code>MyList[Animal]</code>更高一级，是<code>MyList[Animal]</code>的父类，即二者 Contravariance(逆变)</li>
</ul>
<p>在scala中，这三种方法其实都可以实现，但是需要不同的符号：用加号表示为协变，减号表示逆变，如: </p>
<ul>
<li><p>Convariance : 参数类型前面需要有一个<code>+</code> 。如果是类型是协变的，那么我们可以用一个<code>ConvarianceList[Cat]</code> 去替换<code>ConvariantList[Animal]</code> ，说明Cat是Animal的子集</p>
<p><strong>那么这时候其实出了一个大问题</strong>：我们能不能加其他类型的动物进去？<code>animalList.add(new Dog)</code>合法吗？按照道理来说，Dog属于Animal，添加到animalList中是没有逻辑上的问题的，但是显然会污染一个cat类型的animallist。 如果我们要创建一个convariant的类，就必须解决这个问题——我们学完bounded types就知道了。</p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConvarianceList</span>[+<span class="type">A</span>]</span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">animal</span> </span>: <span class="type">Animal</span> = <span class="keyword">new</span> <span class="type">Cat</span></span><br><span class="line"><span class="keyword">val</span> animalList: <span class="type">ConvariantList</span>[<span class="type">Animal</span>] = <span class="keyword">new</span> <span class="type">ConvarianceList</span>[<span class="type">Cat</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>Invariance ：在scala中，什么符号都不加就是Invariance。在这种情况下，<code>InvariantList[Animal]</code> 只能对应 Animal类型</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invariant</span>[<span class="type">A</span>]</span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">invariantAnimalList</span></span>: <span class="type">InvariantList</span>[<span class="type">Animal</span>] = <span class="keyword">new</span> <span class="type">InvariantList</span>[<span class="type">Animal</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Contravariance: 参数类型前面需要有一个<code>-</code>， 这是最难以理解的，特别是如果我们还以列表为例的话——那么只能写成<code>InvariantList[cat] = new InvariantList[Animal]</code>，我们用Animal可以去替换Cat，说明Animal是Cat的一个子类<strong>，语法上没问题但是逻辑上有问题</strong>。为了方便理解，我们可以重新设计一个类Trainer</p>
<p>这样的话，<strong>一个动物训练师当然可以替换一个猫咪训练师，因为动物训练师可以训练所有动物</strong>，也包括猫。从这个角度上来看 逆变关系比较好理解。<strong>但是从动物训练师是猫咪训练师的一个子类来理解，就比较奇怪了。</strong></p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">contravariantTrainer</span>[-<span class="type">A</span>]</span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">contravariantTrainer</span>[cat] </span>= <span class="keyword">new</span> contravariantTrainer[<span class="type">Animal</span>]</span><br></pre></td></tr></table></figure>
<h4 id="bounded-types"><a href="#bounded-types" class="headerlink" title="bounded types"></a>bounded types</h4><p>在Scala中，类型界限是对类型参数或类型变量的限制。 通过使用类型边界，我们可以定义类型变量的限制。</p>
<ul>
<li>上界：这里<strong>T是类型参数</strong>，而<strong>S是类型</strong>。 通过将“上界”声明为“ <strong>[T &lt;：S]</strong> ”，表示此类型<strong>参数T必须与S相同或S的子类型</strong>。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里，我们要求Cage中的输入参数必须是Animal的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cage</span>[<span class="type">A</span> &lt;: <span class="type">Animal</span>](<span class="params">animal: <span class="type">A</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">因此，我们将Dog作为参数是合法的</span></span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">cage</span> </span>= <span class="keyword">new</span> <span class="type">Cage</span>(<span class="keyword">new</span> <span class="type">Dog</span>)</span><br></pre></td></tr></table></figure>
<p>我们看到，如果是另外一个不是animal的子类，我们就没有办法将其放到Cage里面，因为Cage有类型限制</p>
<p><img src="/2022/04/28/scala%E5%88%9D%E8%AF%86/3.png"></p>
<ul>
<li>下界：这里<strong>T是类型参数，而S是类型</strong>。 通过将“下界”声明为“ <strong>[T&gt;：S]</strong> ”，表示此类型<strong>参数T必须与S相同或为S的超类型</strong>。</li>
</ul>
<p>现在我们可以解决上面那个可不可以把Dog插入 <code>List[Cat]</code>的难题了,解决方法就是，如果我往一个List[Cat]里面插入Dog，就会返回一个 <code>List[Animal]</code> ，也就是说把类型更泛化一个级别</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>[+<span class="type">A</span>] </span>&#123; </span><br><span class="line">  <span class="comment">//要实现以上功能，我们可以用到下界符号，当与A同类型或者超类要加入到MyList[A]中，就会返回MyList[B]</span></span><br><span class="line">  <span class="comment">//那么如果添加一个Dog，就会返回一个MyList[Animal]</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(<span class="type">B</span> &gt;:<span class="type">A</span>)(element:<span class="type">B</span>): <span class="type">MyList</span>[<span class="type">B</span>] = ???</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们对之前写的MyList进行修改：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyList</span>[+<span class="type">A</span>] </span>&#123; <span class="comment">//将MyList改为泛型抽象类</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">head</span></span>: <span class="type">A</span>								<span class="comment">//返回的参数从Int改为A</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tail</span></span>: <span class="type">MyList</span>[<span class="type">A</span>]				<span class="comment">//同理，返回类型为A的MyList</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>: <span class="type">Boolean</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>[<span class="type">B</span> &gt;: <span class="type">A</span>](element: <span class="type">B</span>): <span class="type">MyList</span>[<span class="type">B</span>] <span class="comment">//在add设置下界</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printElements</span></span>: <span class="type">String</span></span><br><span class="line">  <span class="comment">// polymorphic call</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>: <span class="type">String</span> = <span class="string">"["</span> + printElements + <span class="string">"]"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//由于这里返回的是一个Exception,而Empty里面没有任何类型的数据，因此将Empty对象继承自MyList[Nothing]</span></span><br><span class="line"><span class="comment">//因为Nothing是任何类的子类，因此可以用Nothing来替换之前的Int</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Empty</span> <span class="keyword">extends</span> <span class="title">MyList</span>[<span class="type">Nothing</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">head</span></span>: <span class="type">Nothing</span> = <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchElementException</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tail</span></span>: <span class="type">MyList</span>[<span class="type">Nothing</span>] = <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchElementException</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line">  <span class="comment">//这里也要将函数改为下界，B &gt;: Nothing，返回一个MyList[B]</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>[<span class="type">B</span> &gt;: <span class="type">Nothing</span>](element: <span class="type">B</span>): <span class="type">MyList</span>[<span class="type">B</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(element, <span class="type">Empty</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printElements</span></span>: <span class="type">String</span> = <span class="string">""</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cons</span>[+<span class="type">A</span>](<span class="params">head: <span class="type">A</span>, tail: <span class="type">MyList</span>[<span class="type">A</span>]</span>) <span class="keyword">extends</span> <span class="title">MyList</span>[<span class="type">A</span>] <span class="title">/*注意这里只能是</span>[<span class="type">A</span>],<span class="title">不能是</span>[+<span class="type">A</span>]<span class="title">*/</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">head</span></span>: <span class="type">A</span> = h</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tail</span></span>: <span class="type">MyList</span>[<span class="type">A</span>] = t</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>: <span class="type">Boolean</span> = <span class="literal">false</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>[<span class="type">B</span> &gt;: <span class="type">A</span>](element: <span class="type">B</span>): <span class="type">MyList</span>[<span class="type">B</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(element, <span class="keyword">this</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printElements</span></span>: <span class="type">String</span> =</span><br><span class="line">    <span class="keyword">if</span>(t.isEmpty) <span class="string">""</span> + h</span><br><span class="line">    <span class="keyword">else</span> <span class="string">s"<span class="subst">$h</span> <span class="subst">$&#123;t.printElements&#125;</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试如下：</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ListTest</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> listOfIntegers: <span class="type">MyList</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">1</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">3</span>, <span class="type">Empty</span>)))</span><br><span class="line">  <span class="keyword">val</span> listOfStrings: <span class="type">MyList</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="string">"Hello"</span>,<span class="keyword">new</span> <span class="type">Cons</span>(<span class="string">"scala"</span>,<span class="type">Empty</span>)) </span><br><span class="line">  println(listOfStrings.toString) <span class="comment">//[Hello scala]</span></span><br><span class="line">  println(listOfIntegers.toString)<span class="comment">//[1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Anonymous-Classes"><a href="#Anonymous-Classes" class="headerlink" title="Anonymous Classes"></a>Anonymous Classes</h3><p> <strong>匿名类：</strong>也就是没有命名的类. 对于一个类的子类，如果我们只需要实现其一次(创建一个实例), 我们就可以使用匿名类</p>
<p>首先我们来看不使用匿名类的写法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先创建一个抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>: <span class="type">Unit</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//然后创建抽象类的一个子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnonymousClasses$$anon$1</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>: <span class="type">Unit</span> = println(<span class="string">"ahahahahahaah"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最后为这个子类创建一个实例</span></span><br><span class="line"><span class="keyword">val</span> funnyAnimal: <span class="type">Animal</span> = <span class="keyword">new</span> <span class="type">AnonymousClasses</span>$$anon$<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>那么如果这个类的实例只会被创建一次，我们就没必要搞这么复杂，直接使用匿名类就可以：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>: <span class="type">Unit</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">val</span> funnyAnimal: <span class="type">Animal</span> = <span class="keyword">new</span> <span class="type">Animal</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>: <span class="type">Unit</span> = println(<span class="string">"ahahahahahaah"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匿名类不只有抽象类能使用，正常的类中也可以使用, 但是需要显式得写 override</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sayHi</span></span>: <span class="type">Unit</span> = println(<span class="string">s"Hi, my name is <span class="subst">$name</span>, how can I help?"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> jim = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"Jim"</span>) &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">sayHi</span></span>: <span class="type">Unit</span> = println(<span class="string">s"Hi, my name is Jim, how can I be of service?"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Object-Oriented-Exercises-Expanding-Our-Collection"><a href="#Object-Oriented-Exercises-Expanding-Our-Collection" class="headerlink" title="Object-Oriented Exercises : Expanding Our Collection"></a>Object-Oriented Exercises : Expanding Our Collection</h3><p>现在我们在来扩展一下之前写的MyLIst，往里面添加三个函数： map，filter 和flatmap，示例和要求如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Exercises:</span></span><br><span class="line"><span class="comment">  首先创建两个接口</span></span><br><span class="line"><span class="comment">  1.  Generic trait MyPredicate[-T] with a little method test(T) =&gt; Boolean</span></span><br><span class="line"><span class="comment">  2.  Generic trait MyTransformer[-A, B] with a method transform(A) =&gt; B</span></span><br><span class="line"><span class="comment">  然后创建三个函数</span></span><br><span class="line"><span class="comment">  3.  MyList:</span></span><br><span class="line"><span class="comment">      - map(transformer) =&gt; MyList</span></span><br><span class="line"><span class="comment">      - filter(predicate) =&gt; MyList</span></span><br><span class="line"><span class="comment">      - flatMap(transformer from A to MyList[B]) =&gt; MyList[B]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      class EvenPredicate extends MyPredicate[Int]</span></span><br><span class="line"><span class="comment">      class StringToIntTransformer extends MyTransformer[String, Int]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      [1,2,3].map(n * 2) = [2,4,6]</span></span><br><span class="line"><span class="comment">      [1,2,3,4].filter(n % 2) = [2,4]</span></span><br><span class="line"><span class="comment">      [1,2,3].flatMap(n =&gt; [n, n+1]) =&gt; [1,2,2,3,3,4]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//一个Predicate接口，用来判断是否符合条件</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">MyPredicate</span>[-<span class="type">T</span>] </span>&#123;</span><br><span class="line">  	<span class="function"><span class="keyword">def</span> <span class="title">test</span></span>(elem: <span class="type">T</span>) : <span class="type">Boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个MyTransfomer结构，用来进行类型转换</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">MyTransformer</span>[-<span class="type">A</span>,<span class="type">B</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">transform</span></span>(elem : <span class="type">A</span>): <span class="type">B</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyList</span>[+<span class="type">A</span>] </span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	...</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">  <span class="comment">//  higher-order functions</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](transformer: <span class="type">MyTransformer</span>[<span class="type">A</span>,<span class="type">B</span>]): <span class="type">MyList</span>[<span class="type">B</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(predicate: <span class="type">MyPredicate</span>[<span class="type">A</span>]): <span class="type">MyList</span>[<span class="type">A</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](transformer: <span class="type">MyTransformer</span>[<span class="type">A</span>,<span class="type">MyList</span>[<span class="type">B</span>]]): <span class="type">MyList</span>[<span class="type">B</span>]</span><br><span class="line">&#125;</span><br><span class="line">                                            </span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Empty</span> <span class="keyword">extends</span> <span class="title">MyList</span>[<span class="type">Noting</span>] </span>&#123;</span><br><span class="line">  <span class="comment">// 对一个Empty对象试行Map和filter操作，得到的肯定都是Empty本身</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](transformer: <span class="type">MyTransformer</span>[<span class="type">Nothing</span>,<span class="type">B</span>]):<span class="type">MyList</span>[<span class="type">B</span>] = <span class="type">Empty</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](tranformer:<span class="type">MyTransformer</span>[<span class="type">Nothing</span>,<span class="type">MyList</span>[<span class="type">B</span>]]):<span class="type">MyList</span>[<span class="type">B</span>] = <span class="type">Empty</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(predicate: <span class="type">MyPredicate</span>[<span class="type">Nothing</span>]): <span class="type">MyList</span>[<span class="type">Nothing</span>] =  <span class="type">Empty</span></span><br><span class="line">&#125;</span><br><span class="line">                                            </span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Cons</span>[+<span class="type">A</span>](<span class="params">h: <span class="type">A</span>, t: <span class="type">MyList</span>[<span class="type">A</span>]</span>) <span class="keyword">extends</span> <span class="title">MyList</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="comment">/* 对于List中的每一个元素，都进行predicate判定</span></span><br><span class="line"><span class="comment">  		+ 如果符合判定条件，就留下</span></span><br><span class="line"><span class="comment">		  + 否则就递归判定tail</span></span><br><span class="line"><span class="comment">		  </span></span><br><span class="line"><span class="comment">		 比如说 [1,2,3].filter(n%2 == 0)</span></span><br><span class="line"><span class="comment">		 = [2,3].filter(n%2 == 0)</span></span><br><span class="line"><span class="comment">		 = new Cons(2,[3].filter(n%2 == 0))</span></span><br><span class="line"><span class="comment">		 = new Cons(2,Empty.filter(n%2 == 0))</span></span><br><span class="line"><span class="comment">		 = new Cons(2,Empty)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(predicate: <span class="type">MyPredicate</span>[<span class="type">A</span>]) : <span class="type">MyList</span>[<span class="type">A</span>] = </span><br><span class="line">  		<span class="keyword">if</span> (predicate.test(h)) <span class="keyword">new</span> <span class="type">Cons</span>(h,t.filter(predicate))</span><br><span class="line">  		<span class="keyword">else</span> t.filter(predict)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 对于map来说，原先的列表有多长，新的列表就有多长，只不过对每个元素做了一个映射</span></span><br><span class="line"><span class="comment">  	 比如说[1,2,3].map(n*2)</span></span><br><span class="line"><span class="comment">  	  =  new Cons(2,[2,3].map(n*2))</span></span><br><span class="line"><span class="comment">  	  =  new Cons(2,new Cons(4,[3].map(n*2)))</span></span><br><span class="line"><span class="comment">  	  =  new Cons(2,new Cons(4,new Cons(6,Empty)))</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](transformer: <span class="type">MyTransformer</span>[<span class="type">A</span>,<span class="type">B</span>]):<span class="type">MyList</span>[<span class="type">B</span>] = </span><br><span class="line">  		<span class="keyword">new</span> <span class="type">Cons</span>(transformer(h),t.map(transformer))</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// flatmap比较难一些，因为列表中每个元素可能会被映射为多个元素</span></span><br><span class="line">  <span class="comment">// 因此需要我们设计一个concatenation function</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//这里用到了下界，只有相等类型或超类的列表才能连接起来，比如:</span></span><br><span class="line">  <span class="comment">/* [1,2] ++ [3,4,5]</span></span><br><span class="line"><span class="comment">  =  new Cons(1,[2]++[3,4,5])</span></span><br><span class="line"><span class="comment">  =	 new Cons(1,new Cons(2,Empty++[3,4,5]))</span></span><br><span class="line"><span class="comment">  =  new Cons(1,new Cons(2, new Cons(3,new Cons(4, new Cons(5)))))</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">++</span></span>[<span class="type">B</span> &gt;: <span class="type">A</span>](list: <span class="type">MyList</span>[<span class="type">B</span>]): <span class="type">MyList</span>[<span class="type">B</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(h, t ++ list)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*然后我们就可以写flatmap函数了</span></span><br><span class="line"><span class="comment">  比如说：[1,2].flatmap(n =&gt; [3n,4n])</span></span><br><span class="line"><span class="comment">  = [3,4] ++ [2].flatMap(n =&gt; [3n,4n])</span></span><br><span class="line"><span class="comment">  = [3,4] ++ [6,8] ++ Empty.flatmap(n =&gt; [n,n+1])</span></span><br><span class="line"><span class="comment">  = [3,4,6,8]</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](transformer: <span class="type">MyTransformer</span>[<span class="type">A</span>,<span class="type">MyList</span>[<span class="type">B</span>]]): <span class="type">MyList</span>[<span class="type">B</span>] = </span><br><span class="line">      transformer.transform(h)++t.flatMap(transformer)</span><br><span class="line">&#125;</span><br><span class="line">                                            </span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ListTest</span> <span class="keyword">extends</span> <span class="title">App</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> listOfIntegers: <span class="type">MyList</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">1</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">3</span>, <span class="type">Empty</span>)))</span><br><span class="line">  <span class="keyword">val</span> anatherListOfIntegers: <span class="type">MyList</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">4</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">5</span>, <span class="type">Empty</span>))</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//[2]</span></span><br><span class="line">  println(listOfIntegers.filter(<span class="keyword">new</span> <span class="type">MyPredicate</span>[<span class="type">Int</span>]&#123;</span><br><span class="line">    	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">test</span></span>(elem : <span class="type">Int</span>): <span class="type">Boolean</span> = elem % <span class="number">2</span> == <span class="number">0</span><span class="comment">// elem % 2==0 是一个表达式</span></span><br><span class="line">  &#125;))</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//[2,4,6]</span></span><br><span class="line">  println(listOfIntegers.map(<span class="keyword">new</span> <span class="type">MyTransformer</span>[<span class="type">Int</span>,<span class="type">Int</span>]&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">transform</span></span>(elem: <span class="type">Int</span>): <span class="type">Int</span> = elem*<span class="number">2</span></span><br><span class="line">  &#125;))</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//[1,2,3,4,5]</span></span><br><span class="line">  println((listOfIntegers ++ anotherListOfIntegers).toString)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//[1,2,2,3,3,4]</span></span><br><span class="line">  println(listOfIntegers.flatMap(<span class="keyword">new</span> <span class="type">MyTransformer</span>[<span class="type">Int</span>,<span class="type">MyList</span>[<span class="type">Int</span>]]&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">transform</span></span>(elem: <span class="type">Int</span>): <span class="type">MyList</span>[<span class="type">Int</span>] = </span><br><span class="line">    				 <span class="keyword">new</span> <span class="type">Cons</span>(elem,<span class="keyword">new</span> <span class="type">Cons</span>(elem+<span class="number">1</span>,<span class="type">Empty</span>)).toString <span class="comment">//返回一个新的MyList</span></span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Case-Classes"><a href="#Case-Classes" class="headerlink" title="Case Classes"></a>Case Classes</h3><p>case class是scala中的一种更强大的创建类的方式。它不仅拥有普通class的功能，又有很多内建方法，不用我们自己去实现。</p>
<p>比如说我创建一个case class如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>,age: <span class="type">Int</span></span>)</span></span><br></pre></td></tr></table></figure>
<p>现在来一一介绍case class的一些特性</p>
<ul>
<li>类的构造参数默认是类内成员</li>
<li>初始化的时候可以不用new，也可以加上，但是普通类必须加new</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> jim = <span class="type">Person</span>(<span class="string">"Jim"</span>,<span class="number">34</span>)<span class="comment">//初始化的时候可以不用new</span></span><br><span class="line">println(jim.name)<span class="comment">//这对于case class是合法的，因为name是类内成员；而对于普通class则无法编译</span></span><br></pre></td></tr></table></figure>
<ul>
<li>toString的实现更漂亮</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">println(jim)<span class="comment">//Person(Jim,34) 我们看到直接打印case class的实例很直观的显示Person的参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果不加case的class，直接打印实例则是返回哈希字符串*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">noCasePerson</span>(<span class="params">name: <span class="type">String</span>,age:<span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">nocaseJim</span> </span>= <span class="keyword">new</span> noCasePerson(<span class="string">"Jim"</span>,<span class="number">34</span>)<span class="comment">//初始化必然要 new</span></span><br><span class="line">println(nocaseJim)<span class="comment">//lectures.part2oop.CaseClasses$noCasePerson@7a0ac6e3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>默认实现了equals 和hashCode；</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*在case class中，如果两个类参数相等，那么会默认判定这两个类是相等的(内置了equals方法)*/</span></span><br><span class="line"><span class="keyword">val</span> jim2 = <span class="type">Person</span>(<span class="string">"Jim"</span>,<span class="number">34</span>)</span><br><span class="line">println(jim = jim2)<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*但是在class中，则会返回false，因为这是两个实例*/</span></span><br><span class="line"><span class="keyword">val</span> nocaseJim2 = <span class="keyword">new</span> noCasePerson(<span class="string">"Jim"</span>,<span class="number">34</span>)</span><br><span class="line">println(nocaseJim = nocaseJim2) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>case class 实现了 copy方法</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> jim3 = jim.copy()<span class="comment">//创建一个和jim一模一样的实例</span></span><br><span class="line"><span class="keyword">val</span> jim4 = jim.copy(age = <span class="number">45</span>)<span class="comment">//创建一个除了age不同，其余都和jim一模一样的实例</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Case class 在创建时同时创建了companion object(伴生对象)，同时在里面给我们实现子apply方法，使得我们在使用的时候可以不直接显示地new对象；</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> thePerson = <span class="type">Person</span><span class="comment">//合法，这里的Person是case class Person的伴生对象</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>Case Class 可以序列化(Serializable)</p>
</li>
<li><p>Case Class  可以用于模式匹配，这是case class最重要的特性关于模式识别是什么，我们最后一章会学</p>
</li>
<li>除了Case Class之外，还有Case Object，其主要特性和Case Class相同，但不会创建伴生对象——因为他们自己就是自己的伴生对象</li>
</ul>
<h3 id="Scala-3-Enums"><a href="#Scala-3-Enums" class="headerlink" title="Scala 3: Enums"></a>Scala 3: Enums</h3><p>现在我们来说说Scala中的枚举类，枚举类是Scala3中的新语法</p>
<h4 id="基础定义"><a href="#基础定义" class="headerlink" title="基础定义"></a>基础定义</h4><p>首先我们可以给出一个最基本的枚举类的定义，我们可以将scala中的enum理解为一中数据类型，case后面的是该类型可选的值</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="type">Permissions</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">READ</span>,<span class="type">WRITE</span>,<span class="type">EXECUTE</span>,<span class="type">NONE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> somePermissions : <span class="type">Permissions</span> = <span class="type">Permissions</span>.<span class="type">READ</span></span><br></pre></td></tr></table></figure>
<h4 id="Enum中也可以有函数"><a href="#Enum中也可以有函数" class="headerlink" title="Enum中也可以有函数"></a>Enum中也可以有函数</h4><p>在Enum中也可以定义函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="type">Permissions</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">READ</span>,<span class="type">WRITE</span>,<span class="type">EXECUTE</span>,<span class="type">NONE</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">openDocument</span></span>():<span class="type">Unit</span> =</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == <span class="type">READ</span> || <span class="keyword">this</span> == <span class="type">WRITE</span>) println(<span class="string">"opening document"</span>)</span><br><span class="line">    <span class="keyword">else</span> println(<span class="string">"reading not allowed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> somePermissions: <span class="type">Permissions</span> = <span class="type">Permissions</span>.<span class="type">READ</span></span><br><span class="line">  somePermissions.openDocument()<span class="comment">// opening document</span></span><br></pre></td></tr></table></figure>
<h4 id="constructor-args"><a href="#constructor-args" class="headerlink" title="constructor args"></a>constructor args</h4><p>Enum也可以接收参数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="type">Color</span>(<span class="keyword">val</span> rgb: <span class="type">Int</span>)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Red</span>   <span class="keyword">extends</span> <span class="type">Color</span>(<span class="number">0xFF0000</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Green</span> <span class="keyword">extends</span> <span class="type">Color</span>(<span class="number">0x00FF00</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Blue</span>  <span class="keyword">extends</span> <span class="type">Color</span>(<span class="number">0x0000FF</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="type">Color</span>.<span class="type">Red</span>.rgb) <span class="comment">// 255 (即0xFF0000)</span></span><br></pre></td></tr></table></figure>
<h4 id="companion-objects"><a href="#companion-objects" class="headerlink" title="companion objects"></a>companion objects</h4><p>我们可以为Enum创建伴生对象：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Color</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">fromRGB</span></span>(<span class="keyword">val</span> rgb : <span class="type">Int</span>) :  <span class="type">Color</span> = ??? <span class="comment">//写从RGB到Color的逻辑(if-else)，这里略去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Enum的一些标准接口"><a href="#Enum的一些标准接口" class="headerlink" title="Enum的一些标准接口"></a>Enum的一些标准接口</h4><ul>
<li><code>Enum.ordinal</code>, 通过ordinal可以返回某个枚举值在类中的index，比如：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">al somePermissions: <span class="type">Permissions</span> = <span class="type">Permissions</span>.<span class="type">READ</span> </span><br><span class="line"><span class="comment">// Read在Perssions中的index 是 0 ，因此 somePermissions.ordinal = 0</span></span><br><span class="line"><span class="keyword">val</span> somPermissionsOrdinal = somePermissions.ordinal</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Enum.values</code> 可以以数组的方式返回Enums中的所有值</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">Permissions</span>.values.mkString(<span class="string">"Array("</span>, <span class="string">", "</span>, <span class="string">")"</span>))</span><br><span class="line"><span class="comment">//Array(READ, WRITE, EXECUTE, NONE)</span></span><br><span class="line">println(<span class="type">Color</span>.values.mkString(<span class="string">"Array("</span>, <span class="string">", "</span>, <span class="string">")"</span>) )</span><br><span class="line"><span class="comment">//Array(Red, Green, Blue)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>Enum.valueOf</code> 这个方法感觉有点鸡肋..</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">Color</span>.valueOf(<span class="string">"Blue"</span>)) <span class="comment">// Color.Blue </span></span><br><span class="line">println(<span class="type">Permissions</span>.valueOf(<span class="string">"READ"</span>)) <span class="comment">// Permissions.READ</span></span><br></pre></td></tr></table></figure>
<p>有了case class，我们可以让MyList的功能变得更加强大。</p>
<ul>
<li>首先有了equals方法，可以方便的比较两个List的元素是否相等</li>
<li>能序列化，使得在分布式系统中更加方便操作</li>
</ul>
<h3 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h3><p>现在来学习scala中的异常处理。首先来分辨一下Error和Exception的区别：</p>
<ul>
<li><p>Error 是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。既然是非正常情况，<strong>所以不便于也不需要捕获</strong>，常见的比如 OutOfMemoryError , StackOverFlowError, 都是 Error 的子类。</p>
</li>
<li><p>Exception 是程序正常运行中，可以预料的意外情况，<strong>可能并且应该被捕获</strong>，进行相应处理。Exception 又分为可检查（checked）异常和不检查（unchecked）异常【即运行时异常】，可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。</p>
<ul>
<li>检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li>
<li>运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常<strong>可以在编译时被忽略</strong>，类似 NullPointerException、ArrayIndexOutOfBoundsException 之类，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。</li>
</ul>
</li>
</ul>
<p>在JVM中，Exception和Error都继承了Throwable类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。</p>
<h4 id="throw-catch"><a href="#throw-catch" class="headerlink" title="throw-catch"></a>throw-catch</h4><ul>
<li>首先来说怎么抛出一个异常：</li>
</ul>
<p>要知道  <code>throw new NullPointerException</code> 也是一个表达式，返回一个Nothing, 所以我们可以用String类型接收它，因为Nothing是任何类的子类</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aWeirdValue: <span class="type">String</span> = <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NullPointerException</span> <span class="comment">// also crashes</span></span><br></pre></td></tr></table></figure>
<ul>
<li>然后我们来说怎么catch一个异常</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getInt</span></span>(withExceptions: <span class="type">Boolean</span>): <span class="type">Int</span> =</span><br><span class="line">  <span class="keyword">if</span> (withExceptions) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">"No int for you!"</span>)</span><br><span class="line">  <span class="keyword">else</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> potentialFail = <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 调用getInt函数，导致其抛出一个异常</span></span><br><span class="line">  getInt(<span class="literal">true</span>) </span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="comment">// catch一个RuntimeException的异常的话，就打印</span></span><br><span class="line">  <span class="comment">// 如果getInt抛出的是一个NullPointerException的话，虽然有try-catch，还是会报错</span></span><br><span class="line">  <span class="keyword">case</span> e: <span class="type">RuntimeException</span> =&gt;  println(<span class="string">"caught a runtime exception"</span>)</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// finally和java中一样，无论怎么样都会执行，可写可不写</span></span><br><span class="line">  <span class="comment">// finally不会影响代码块的返回值类型</span></span><br><span class="line">  <span class="comment">// use finally only for side effects</span></span><br><span class="line">  println(<span class="string">"finally"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(potentialFail)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/28/scala%E5%88%9D%E8%AF%86/5.png"></p>
<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>scala中自定义异常也非常容易，只需要让其继承某一异常类即可</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  1.  Crash your program with an OutOfMemoryError</span></span><br><span class="line"><span class="comment">  2.  Crash with SOError</span></span><br><span class="line"><span class="comment">  3.  PocketCalculator</span></span><br><span class="line"><span class="comment">      - add(x,y)</span></span><br><span class="line"><span class="comment">      - subtract(x,y)</span></span><br><span class="line"><span class="comment">      - multiply(x,y)</span></span><br><span class="line"><span class="comment">      - divide(x,y)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Throw</span></span><br><span class="line"><span class="comment">        - OverflowException if add(x,y) exceeds Int.MAX_VALUE</span></span><br><span class="line"><span class="comment">        - UnderflowException if subtract(x,y) exceeds Int.MIN_VALUE</span></span><br><span class="line"><span class="comment">        - MathCalculationException for division by 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先我们要创建一些自定义异常类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OverflowException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span>(<span class="params">"<span class="type">Overflow</span>"</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">UnderflowException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span>(<span class="params">"<span class="type">Underflow</span>"</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">MathCalculationException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span>(<span class="params">"<span class="type">Division</span> by 0"</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">然后我们构造简易的计算器</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">object</span> <span class="title">PocketCalculator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x: <span class="type">Int</span>,y:<span class="type">Int</span>) = &#123;</span><br><span class="line">    <span class="keyword">val</span> result = x + y</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span> &amp;&amp; x+y &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">OverFlowException</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span> &amp;&amp; x+y &gt; <span class="number">0</span> ) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UnderFlowException</span></span><br><span class="line">    <span class="keyword">else</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">substract</span></span>(x: <span class="type">Int</span>,y:<span class="type">Int</span>) = &#123;</span><br><span class="line">      <span class="keyword">val</span> result = x - y</span><br><span class="line">      <span class="keyword">if</span>(x &gt; <span class="number">0</span> &amp;&amp; y&lt;<span class="number">0</span> &amp;&amp; x-y &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">OverFlowException</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span> &amp;&amp; x-y &gt; <span class="number">0</span> ) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UnderFlowException</span></span><br><span class="line">      <span class="keyword">else</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">multiply</span></span>(x: <span class="type">Int</span>,y:<span class="type">Int</span>) = &#123;</span><br><span class="line">      <span class="keyword">val</span> result = x * y</span><br><span class="line">      <span class="keyword">if</span>(x &gt; <span class="number">0</span> &amp;&amp; y&gt; <span class="number">0</span> &amp;&amp; x*y &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">OverFlowException</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(x &gt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span> &amp;&amp; x*y &gt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UnderFlowException</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span> &amp;&amp; x*y &lt; <span class="number">0</span> ) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">OverFlowException</span></span><br><span class="line">     	<span class="keyword">else</span> <span class="keyword">if</span>(x &lt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span> &amp;&amp; x*y &gt; <span class="number">0</span> ) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UnderFlowException</span></span><br><span class="line">      <span class="keyword">else</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">divide</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) = &#123;</span><br><span class="line">      <span class="keyword">if</span> (y == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">MathCalculationException</span></span><br><span class="line">      <span class="keyword">else</span> x / y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后我们测试</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> calculatorFail = <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="type">PocketCalculator</span>.add(<span class="type">Int</span>.<span class="type">MaxValue</span>, <span class="number">10</span>)</span><br><span class="line">  &#125;<span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> e: <span class="type">OverflowException</span> =&gt; println(<span class="string">"OverflowException"</span>)</span><br><span class="line">    <span class="keyword">case</span> e: <span class="type">UnderflowException</span> =&gt; println(<span class="string">"UnderflowException"</span>)</span><br><span class="line">    <span class="keyword">case</span> e: <span class="type">MathCalculationException</span> =&gt; println(<span class="string">"MathCalculationException"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// OverflowException</span></span><br></pre></td></tr></table></figure>
<h3 id="Packaging-and-Imports"><a href="#Packaging-and-Imports" class="headerlink" title="Packaging and Imports"></a>Packaging and Imports</h3><h2 id="Functional-Programming-in-Scala"><a href="#Functional-Programming-in-Scala" class="headerlink" title="Functional Programming in Scala"></a>Functional Programming in Scala</h2><h3 id="What’s-a-Function-Really"><a href="#What’s-a-Function-Really" class="headerlink" title="What’s a Function, Really"></a>What’s a Function, Really</h3><p>我们要学习scala中的函数式编程特性，就先要弄明白函数式编程是什么。</p>
<p>函数式编程中的函数指的并不是编程语言中的函数（或方法），它指的是数学意义上的函数，即映射关系（如：y = f(x)），就是 y 和 x 的对应关系。</p>
<h4 id="函数式编程的特性"><a href="#函数式编程的特性" class="headerlink" title="函数式编程的特性"></a>函数式编程的特性</h4><ol>
<li><p>函数是一等公民，它的意思就是函数与其他数据类型一样，可以把它们存在数组里，当做参数传递，赋值给变量，可以在任何地方定义，在函数内或函数外，可以作为函数的参数和返回值，也可以对函数进行组合。</p>
</li>
<li><p>高阶函数(Higher Order Function, HOF)，在函数式编程中， 高阶函数的定义是把其它函数当做参数，或者返回一个函数作为结果的函数。</p>
</li>
<li><p><strong>柯里化</strong>，就是把一个多参数的函数 f，转换为单参数函数 g，并且这个函数的返回值也是一个函数。</p>
</li>
<li><p>Side Effects，所谓“副作用”，指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。<br>   在像 C++ 这样的命令式语言中，函数的意义与数学函数完全不同。例如，假设我们有一个 C++ 函数，它接受一个浮点参数并返回一个浮点结果。从表面上看它可能看起来有点像数学函数意义上的映射实数成实数，但是 C++ 函数可以做的不仅仅是返回一个取决于其参数的数字，它还可以读写其他的全局变量，也可将将输出写入屏幕并接收来自用户的输入。但是，在纯函数式语言中，函数只能读取其参数提供给它的内容，并且它对世界产生影响的唯一方式就是通过它返回的值。</p>
</li>
<li><p>纯函数，纯函数编程和函数编程的区别在于：是否允许在函数内部执行一些非函数式的操作，同时这些操作是否会暴露给系统中的其他地方？也就是是否存在副作用。如果不存在副作用，或者说可以不用在意这些副作用，那么就将其称为纯粹的函数式编程。</p>
</li>
<li><p>引用透明性，函数无论在何处、何时调用，如果使用相同的输入总能持续地得到相同的结果，就具备了函数式的特征。这种不依赖外部变量或“状态”，只依赖输入的参数的特性就被称为引用透明性（referential transparency）。“没有可感知的副作用”（比如不改变对调用者可见的变量，进行I/O，不抛出异常等）的这些限制都隐含着引用透明性</p>
</li>
<li>递归和迭代，对于函数式而言，循环体有一个无法避免的副作用，就是它会修改某些对象的状态，通常这些对象又是和其他部分共享的。而且也因为变量值是不可变的，纯函数编程语言也无法实现循环。所以纯函数编程语言通常不包含像 while 和 for 这样的迭代构造器，而是采用的无需修改的递归。 </li>
</ol>
<h4 id="function-value"><a href="#function-value" class="headerlink" title="function value"></a>function value</h4><p>Scala编译后是要放到JVM上运行的，其实本质上是一个面向对象的编程语言。但是为了让他可以实现函数式编程，就需要对其方法(method)做一定的包装(变为函数)。因此，我们要理解——在scala里面，函数和方法是两个不同的概念。</p>
<ul>
<li>函数接口是 FunctionN(N可以是1,2,3…代表接收的参数个数) ，将其理解为一个<strong>实体</strong>，在实体中包装了一个<strong>行为方式</strong>，写在了其apply方法里</li>
<li>方法是 Method(在实体中用def定义)，将其理解为一种行为方式，这个行为方式可以通过转换来包装成一个FunctionN实体</li>
</ul>
<p>比如说，我想创建一个函数，它可以将字符串转移成数字，那么显然它接受1个参数，并返回一个Int类型的值。那么此时我需要用到Function1接口:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stringToIntConverter 接收String类型的参数，返回 Int类型的值</span></span><br><span class="line"><span class="keyword">val</span> stringToIntConverter = <span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">String</span>, <span class="type">Int</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(string: <span class="type">String</span>): <span class="type">Int</span> = string.toInt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(stringToIntConverter(<span class="string">"3"</span>) + <span class="number">4</span>) <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<p>Function1接口的源码如下：我们看到，其内部只有一个apply函数，之前我们学过，在一个对象后面加上<code>()</code>,编译器就会自动调用该类中的apply函数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@annotation</span>.implicitNotFound(msg = <span class="string">"No implicit view available from $&#123;T1&#125; =&gt; $&#123;R&#125;."</span>)</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Function1</span>[@specialized(<span class="type">Specializable</span>.<span class="type">Arg</span>) -<span class="type">T1</span>, @specialized(<span class="type">Specializable</span>.<span class="type">Return</span>) +<span class="type">R</span>] <span class="keyword">extends</span> <span class="title">AnyRef</span> </span>&#123; self =&gt;</span><br><span class="line">  <span class="comment">/** Apply the body of this function to the argument.</span></span><br><span class="line"><span class="comment">   *  @return   the result of function application.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(v1: <span class="type">T1</span>): <span class="type">R</span></span><br></pre></td></tr></table></figure>
<p>再比如说，我想创建一个函数，它可以实现两个Int值相加，那么此时我需要用Function2接口</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">val</span> adder = <span class="keyword">new</span> <span class="type">Function2</span>[<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>] &#123;</span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Int</span> = a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h4><p>事实上，我们在创建函数的时候，  <code>Function2[A,B,R]</code> 与 <code>(A,B) =&gt; R</code>是等价的，因此为了简介，我们也可以直接这样写：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> adder: ((<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span>) = <span class="keyword">new</span> <span class="type">Function2</span>[<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Int</span> = a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是感觉比原来更复杂了，我们接下来学习匿名函数的时候会对其做一个简化</p>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><ul>
<li>write  a function which takes 2 strings and concatenates them</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> concatenator:((<span class="type">String</span>,<span class="type">String</span>) =&gt; <span class="type">String</span> ) = <span class="keyword">new</span> <span class="type">Function2</span>[<span class="type">Int</span>,<span class="type">Int</span>,<span class="type">Int</span>]&#123;</span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span> </span>(a:<span class="type">String</span>, b:<span class="type">String</span>): <span class="type">String</span> = a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>transform the MyPredicate and MyTransformer into function types</li>
</ul>
<p>要对MyList中的MyPredicate和MyTransformer做一个改造，使其成为function types. 事实上，我们可以直接删去这两个接口</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> exercises</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyList</span>[+<span class="type">A</span>] </span>&#123; </span><br><span class="line">  <span class="comment">//主要改这三个函数</span></span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">   我们要把圈来的 Mytransformer接口和MyPredicate接口改成函数式接口，可以是 Function1[A,B]</span></span><br><span class="line"><span class="comment">   但是为了更加直观，我们可以将其直接写为 A =&gt; B</span></span><br><span class="line"><span class="comment">   higher-order functions</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](transformer: <span class="type">Function1</span>[<span class="type">A</span>,<span class="type">B</span>]): <span class="type">MyList</span>[<span class="type">B</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](transformer: <span class="type">A</span> =&gt; <span class="type">MyList</span>[<span class="type">B</span>]): <span class="type">MyList</span>[<span class="type">B</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(predicate: <span class="type">A</span> =&gt; <span class="type">Boolean</span>): <span class="type">MyList</span>[<span class="type">A</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Empty</span> <span class="keyword">extends</span> <span class="title">MyList</span>[<span class="type">Nothing</span>] </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](transformer: <span class="type">Nothing</span> =&gt; <span class="type">B</span>): <span class="type">MyList</span>[<span class="type">B</span>] = <span class="type">Empty</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](transformer: <span class="type">Nothing</span> =&gt; <span class="type">MyList</span>[<span class="type">B</span>]): <span class="type">MyList</span>[<span class="type">B</span>] = <span class="type">Empty</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(predicate: <span class="type">Nothing</span> =&gt; <span class="type">Boolean</span>): <span class="type">MyList</span>[<span class="type">Nothing</span>] = <span class="type">Empty</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Cons</span>[+<span class="type">A</span>](<span class="params">h: <span class="type">A</span>, t: <span class="type">MyList</span>[<span class="type">A</span>]</span>) <span class="keyword">extends</span> <span class="title">MyList</span>[<span class="type">A</span>] </span>&#123; </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(predicate: <span class="type">A</span> =&gt; <span class="type">Boolean</span>): <span class="type">MyList</span>[<span class="type">A</span>] =</span><br><span class="line">    <span class="keyword">if</span> (predicate(h)) <span class="keyword">new</span> <span class="type">Cons</span>(h, t.filter(predicate))</span><br><span class="line">    <span class="keyword">else</span> t.filter(predicate)</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](transformer: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">MyList</span>[<span class="type">B</span>] =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Cons</span>(transformer(h), t.map(transformer))</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">++</span></span>[<span class="type">B</span> &gt;: <span class="type">A</span>](list: <span class="type">MyList</span>[<span class="type">B</span>]): <span class="type">MyList</span>[<span class="type">B</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(h, t ++ list)</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](transformer: <span class="type">A</span> =&gt; <span class="type">MyList</span>[<span class="type">B</span>]): <span class="type">MyList</span>[<span class="type">B</span>] =</span><br><span class="line">    transformer(h) ++ t.flatMap(transformer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ListTest</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> listOfIntegers: <span class="type">MyList</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">1</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">3</span>, <span class="type">Empty</span>)))</span><br><span class="line">  <span class="keyword">val</span> cloneListOfIntegers: <span class="type">MyList</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">1</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">3</span>, <span class="type">Empty</span>)))</span><br><span class="line">  <span class="keyword">val</span> anotherListOfIntegers: <span class="type">MyList</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">4</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">5</span>, <span class="type">Empty</span>))</span><br><span class="line"> </span><br><span class="line">  println(listOfIntegers.filter(<span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>,<span class="type">Boolean</span>]&#123;</span><br><span class="line">    	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(elem : <span class="type">Int</span>): <span class="type">Boolean</span> = elem % <span class="number">2</span> == <span class="number">0</span> </span><br><span class="line">  &#125;))</span><br><span class="line">   </span><br><span class="line">  println(listOfIntegers.map(<span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>,<span class="type">Int</span>]&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(elem: <span class="type">Int</span>): <span class="type">Int</span> = elem*<span class="number">2</span></span><br><span class="line">  &#125;))</span><br><span class="line">   </span><br><span class="line">  println((listOfIntegers ++ anotherListOfIntegers).toString)</span><br><span class="line">   </span><br><span class="line">  println(listOfIntegers.flatMap(<span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>,<span class="type">MyList</span>[<span class="type">Int</span>]]&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(elem: <span class="type">Int</span>): <span class="type">MyList</span>[<span class="type">Int</span>] = </span><br><span class="line">    				 <span class="keyword">new</span> <span class="type">Cons</span>(elem,<span class="keyword">new</span> <span class="type">Cons</span>(elem+<span class="number">1</span>,<span class="type">Empty</span>)).toString <span class="comment">//返回一个新的MyList</span></span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>define a function which takes an int and returns another function which takes an int and returns an int</li>
</ul>
<p>对于这个问题我们要从两个方面来思考：</p>
<ol>
<li>这个函数是什么类型的？接收一个Int，返回一个function，因此是Function1类型的</li>
<li>怎么实现？如下  </li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> superAdder: <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>]] = <span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>]] &#123;</span><br><span class="line">  <span class="comment">// 在这里实现apply函数，接收一个Int，返回一个Function type</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">Int</span>): <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>] &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(y: <span class="type">Int</span>): <span class="type">Int</span> = x + y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">val</span> adder3 = superAdder(<span class="number">3</span>)<span class="comment">// 此时adder3是外层的apply函数，仍然接收一个Int</span></span><br><span class="line">  println(adder3(<span class="number">4</span>))				<span class="comment">// 	adder3(4)其实调用的是内部的apply函数，返回值是int，结果是7</span></span><br><span class="line">  println(superAdder(<span class="number">3</span>)(<span class="number">4</span>)) <span class="comment">// curried function 7</span></span><br><span class="line"> 	<span class="comment">//superAdder就是一个Curried function，他将原来多参数的函数变为单参数的函数，</span></span><br></pre></td></tr></table></figure>
<h3 id="Anonymous-Functions"><a href="#Anonymous-Functions" class="headerlink" title="Anonymous Functions"></a>Anonymous Functions</h3><p>不知道你们有没有发现，我们利用Function  type来实现函数接口，从语法上还是遵循了 定义类、重载函数的思想，实际上还没有摆脱面向对象的编程思维。</p>
<p>因此我们可以使用 匿名函数，也就是 JavaScript中的 Lambda函数。 Scala 中定义匿名函数的语法很简单，箭头左边是参数列表，右边是函数体。</p>
<p>使用匿名函数后，我们的代码变得更简洁了。比如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> doubler = (x:<span class="type">Int</span>) =&gt; x*<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>同样我们可以在匿名函数中定义多个参数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> adder = (x: <span class="type">Int</span>, y: <span class="type">Int</span>) =&gt; x+y</span><br></pre></td></tr></table></figure>
<p>也可以不给匿名函数传入参数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> justDoSth = () =&gt; <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>需要注意，<code>println(justDoSth)</code> 和 <code>println(justDoSth())</code> 是不同的，前者是打印函数本身，后者是打印调用函数后返回的结果</p>
<h4 id="语法糖-1"><a href="#语法糖-1" class="headerlink" title="语法糖"></a>语法糖</h4><p>我们再来介绍一个匿名类中的语法糖：可以用下划线来代替传入的参数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> niceIncrementer: <span class="type">Int</span> =&gt; <span class="type">Int</span> = _ + <span class="number">1</span> <span class="comment">// equivalant to x =&gt; x+1</span></span><br><span class="line"><span class="keyword">val</span> niceAdder: (<span class="type">Int</span>,<span class="type">Int</span>) =&gt; <span class="type">Int</span> = _+_ <span class="comment">// equivalent to (a,b) =&gt; a+b</span></span><br></pre></td></tr></table></figure>
<h4 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise"></a>Exercise</h4><p>现在我们将MyList中的FunctionN接口都改为匿名函数</p>
<p>改之前：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ListTest</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> listOfIntegers: <span class="type">MyList</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">1</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">3</span>, <span class="type">Empty</span>))) </span><br><span class="line"> </span><br><span class="line">  println(listOfIntegers.filter(<span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>,<span class="type">Boolean</span>]&#123;</span><br><span class="line">    	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(elem : <span class="type">Int</span>): <span class="type">Boolean</span> = elem % <span class="number">2</span> == <span class="number">0</span> </span><br><span class="line">  &#125;)) </span><br><span class="line">  println(listOfIntegers.map(<span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>,<span class="type">Int</span>]&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(elem: <span class="type">Int</span>): <span class="type">Int</span> = elem*<span class="number">2</span></span><br><span class="line">  &#125;)) </span><br><span class="line">  println(listOfIntegers.flatMap(<span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>,<span class="type">MyList</span>[<span class="type">Int</span>]]&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(elem: <span class="type">Int</span>): <span class="type">MyList</span>[<span class="type">Int</span>] = </span><br><span class="line">    				 <span class="keyword">new</span> <span class="type">Cons</span>(elem,<span class="keyword">new</span> <span class="type">Cons</span>(elem+<span class="number">1</span>,<span class="type">Empty</span>)).toString <span class="comment">//返回一个新的MyList</span></span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改之后：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ListTest</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> listOfIntegers: <span class="type">MyList</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">1</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">3</span>, <span class="type">Empty</span>))) </span><br><span class="line"> </span><br><span class="line">  	println(listOfIntegers.filter(_%<span class="number">2</span> == <span class="number">0</span>).toString)</span><br><span class="line">  	println(listOfIntegers.map(_ * <span class="number">2</span>))</span><br><span class="line">  	println(listOfIntegers.flatmap(elem =&gt; <span class="type">Cons</span>(elem, <span class="type">Cons</span>(elem+<span class="number">1</span>,<span class="type">Empty</span>)).toString)</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们将之前的 super adder改成匿名函数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改之前</span></span><br><span class="line"><span class="keyword">val</span> superAdder: <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>]] = <span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>]] &#123; </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">Int</span>): <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>] &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(y: <span class="type">Int</span>): <span class="type">Int</span> = x + y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//改之后,接收了x参数，返回一个需要接受y的函数，然后再返回x+y</span></span><br><span class="line"><span class="keyword">val</span> superAdd = (x: <span class="type">Int</span>) =&gt; (y: <span class="type">Int</span>) =&gt; x + y</span><br></pre></td></tr></table></figure>
<h3 id="Higher-Order-Functions-and-Curries"><a href="#Higher-Order-Functions-and-Curries" class="headerlink" title="Higher-Order-Functions and Curries"></a>Higher-Order-Functions and Curries</h3><p>我们之前说过scala中的高阶函数要么接收一个函数为参数，要么返回一个函数。</p>
<p>比如说，我想设计一个可以重复将某一函数执行n次的函数，那么就需要传入一个函数f、参数n、初始值x</p>
<p>如 <code>nTimes(f,3,x) = nTimes(f,2,f(x)) = nTimes(f,1,f(f(x)))=nTimes(f,0,f(f(f(x))))</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nTimes</span></span>(f:<span class="type">Int</span> =&gt; <span class="type">Int</span>, n: <span class="type">Int</span>, x:<span class="type">Int</span>) : <span class="type">Int</span> = </span><br><span class="line">		<span class="keyword">if</span>(n &lt;= <span class="number">0</span>) x</span><br><span class="line">		<span class="keyword">else</span> nTimes(f,n<span class="number">-1</span>,f(x))</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"></span><br><span class="line">print(nTimes(plusOne,<span class="number">100000</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>但我们有没有感到一丝奇怪，就是我们说的函数式编程，是希望像数学里的那样，实现一个映射关系。每次只对一个参数x进行操作，而不是像上面的调用那样，一次要输入3个参数</p>
<p>因此我们可以对nTimes函数做一个改进：改进后的nTimes，每次返回的不再是Int，而是一个<code>(Int =&gt; Int)</code>的函数, 因此，我们可以调用返回的函数去计算</p>
<p>但是这种方法也有弊端，就是会出现栈溢出的问题，不是下尾递归</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nTimesBetter</span></span>(f: <span class="type">Int</span> =&gt; <span class="type">Int</span>, n: <span class="type">Int</span>): (<span class="type">Int</span> =&gt; <span class="type">Int</span>) = </span><br><span class="line">		<span class="keyword">if</span> (n &lt;= <span class="number">0</span>)(x: <span class="type">Int</span>) =&gt; x</span><br><span class="line">		<span class="keyword">else</span> (x: <span class="type">Int</span>) =&gt; nTimesBetter(f,n<span class="number">-1</span>)(f(x))</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用，此时，plus10变成了一个 Int=&gt;Int的函数</span></span><br><span class="line"><span class="keyword">val</span> plus10 = nTimesBetter(plusOne,<span class="number">100</span>)</span><br><span class="line">println(plus10(<span class="number">1</span>)) <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>
<h4 id="多个参数列表"><a href="#多个参数列表" class="headerlink" title="多个参数列表"></a>多个参数列表</h4><p>多个参数列表(multiple parameter lists)常常和柯里化常常一起用,比如说，我想创建一个函数，它可以将double类型的浮点数格式化成想要的样子。正常来说，需要输入两个参数，一个是需要被格式化的浮点数，另一个是String类型的格式本身。但是若要对其进行柯里化，就只能让函数每次只接收一个参数。</p>
<p>因此，我们可以使用多个参数列表的语法。也就是使用多个<code>()</code>, 注意，括号的顺序和参数输入的顺序是有关的。比如说下面这个<code>curriedFormatter</code>,需要先输入String, 然后在去处理Double，最后返回String</p>
<p>其本质上是一个<code>String =&gt; Double =&gt; String</code> 的函数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">curriedFormatter</span></span>(c: <span class="type">String</span>)(x: <span class="type">Double</span>) : <span class="type">String</span> = c.format(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试：</span></span><br><span class="line">	<span class="comment">//curriedFormatter返回一个Double=&gt;String的函数</span></span><br><span class="line">  <span class="keyword">val</span> standardFormat: (<span class="type">Double</span> =&gt; <span class="type">String</span>) = curriedFormatter(<span class="string">"%4.2f"</span>)</span><br><span class="line">  <span class="keyword">val</span> preciseFormat: (<span class="type">Double</span> =&gt; <span class="type">String</span>) = curriedFormatter(<span class="string">"%10.8f"</span>)   			   </span><br><span class="line">	</span><br><span class="line">  println(standardFormat(<span class="type">Math</span>.<span class="type">PI</span>)) <span class="comment">// 3.14</span></span><br><span class="line">  println(preciseFormat(<span class="type">Math</span>.<span class="type">PI</span>))	 <span class="comment">// 3.1415926</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果使用 多个参数列表的话，我们在定义子函数的时候(如上面的standardFormat和preciseFormat)，需要显式得注明函数接受的参数及其返回类型。</p>
<p>为了把多个参数列表讲清楚，我们在来举一个三个参数列表的例子：</p>
<ul>
<li>首先，我定义了triplefunc，它是一个<code>String =&gt; Double =&gt; Int =&gt;String</code>的函数</li>
<li>然后，我有定义了一个doubleFormatter， 它是triplefunc接收了一个参数后的返回值，类型为<code>Double =&gt; Int =&gt; String</code></li>
<li>接着，我又定义了一个IntAdder，它是doubleFormatter接收了一个参数后的返回值，类型为<code>Int=&gt;String</code></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">triplefunc</span></span>(c:<span class="type">String</span>)(x:<span class="type">Double</span>)(y:<span class="type">Int</span>):<span class="type">String</span> = c.format(x+y)</span><br><span class="line"><span class="keyword">val</span> doubleFormatter: <span class="type">Double</span> =&gt; <span class="type">Int</span> =&gt; <span class="type">String</span> = triplefunc(<span class="string">"%4.2f"</span>)</span><br><span class="line"><span class="keyword">val</span> <span class="type">IntAdder</span>: <span class="type">Int</span> =&gt; <span class="type">String</span> = doubleFormatter(<span class="number">2.33</span>)</span><br><span class="line"><span class="comment">//最后我们将三个函数全部调用，得到的结果是一样的 6.33</span></span><br><span class="line">println(triplefunc(<span class="string">"%4.2f"</span>)(<span class="number">2.33</span>)(<span class="number">4</span>))</span><br><span class="line">println(doubleFormatter(<span class="number">2.33</span>)(<span class="number">4</span>))</span><br><span class="line">println(<span class="type">IntAdder</span>(<span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<h4 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  1.  Expand MyList</span></span><br><span class="line"><span class="comment">      - foreach method A =&gt; Unit</span></span><br><span class="line"><span class="comment">        [1,2,3].foreach(x =&gt; println(x))</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      - sort function ((A, A) =&gt; Int) =&gt; MyList</span></span><br><span class="line"><span class="comment">        [1,2,3].sort((x, y) =&gt; y - x) =&gt; [3,2,1]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      - zipWith (list, (A, B) =&gt; C) =&gt; MyList[C]</span></span><br><span class="line"><span class="comment">        [1,2,3].zipWith([4,5,6], x * y) =&gt; [1 * 4, 2 * 5, 3 * 6] = [4,10,18]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      - fold(start)(function) =&gt; a value</span></span><br><span class="line"><span class="comment">        [1,2,3].fold(0)(x + y) = 6</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  2.  toCurry(f: (Int, Int) =&gt; Int) =&gt; (Int =&gt; Int =&gt; Int)</span></span><br><span class="line"><span class="comment">      fromCurry(f: (Int =&gt; Int =&gt; Int)) =&gt; (Int, Int) =&gt; Int</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  3.  compose(f,g) =&gt; x =&gt; f(g(x))</span></span><br><span class="line"><span class="comment">      andThen(f,g) =&gt; x =&gt; g(f(x))</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p><strong>Exercise1</strong></p>
<p>首先对MyList进行改进，新加入了四个高阶函数</p>
<ul>
<li>abstract class</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyList</span>[+<span class="type">A</span>]</span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">foreach</span></span>(f: <span class="type">A</span> =&gt; <span class="type">Unit</span>) : <span class="type">Unit</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">sort</span></span>(compare:(<span class="type">A</span>,<span class="type">A</span>)=&gt;<span class="type">Int</span>) =&gt; <span class="type">MyList</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">zipWith</span></span>[<span class="type">B</span>,<span class="type">C</span>](list:<span class="type">MyList</span>[<span class="type">B</span>],zip:(<span class="type">A</span>,<span class="type">B</span>)=&gt;<span class="type">C</span>):<span class="type">MyList</span>[<span class="type">C</span>]</span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">fold</span></span>[<span class="type">B</span>](start:<span class="type">B</span>)(operator:(<span class="type">B</span>,<span class="type">A</span>)=&gt;<span class="type">B</span>):<span class="type">B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>object Empty </li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Empty</span> <span class="keyword">extends</span> <span class="title">MyList</span>[<span class="type">Nothing</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foreach</span></span>(f: <span class="type">Nothing</span> =&gt; <span class="type">Unit</span>):<span class="type">Unit</span> = ()</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sort</span></span>(compare:(<span class="type">Nothing</span>,<span class="type">Nothing</span>)=&gt;<span class="type">Int</span>):<span class="type">MyList</span> = <span class="type">Empty</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">zipWith</span></span>[<span class="type">B</span>,<span class="type">C</span>](list:<span class="type">MyList</span>[<span class="type">B</span>],zip:(<span class="type">Nothing</span>,<span class="type">B</span>)=&gt;<span class="type">C</span>):<span class="type">MyList</span>[<span class="type">C</span>]=</span><br><span class="line">  	<span class="keyword">if</span>(!list.isEmpty)  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">"Lists do not have the same length"</span>)</span><br><span class="line">    <span class="keyword">else</span> <span class="type">Empty</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fold</span></span>[<span class="type">B</span>](start:<span class="type">B</span>)(operator:(<span class="type">B</span>:<span class="type">Nothing</span>)=&gt; <span class="type">B</span>):<span class="type">B</span> = start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>class Cons</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Cons</span>[+<span class="type">A</span>](<span class="params">h: <span class="type">A</span>, t: <span class="type">MyList</span>[<span class="type">A</span>]</span>) <span class="keyword">extends</span> <span class="title">MyList</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foreach</span></span>(f: <span class="type">A</span> =&gt; <span class="type">Unit</span>):<span class="type">Unit</span> = &#123;</span><br><span class="line">			f(h)</span><br><span class="line">			t.foreach(f)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">sort</span></span>(compare:(<span class="type">A</span>,<span class="type">A</span>)=&gt;<span class="type">Int</span>):<span class="type">MyList</span> = &#123;</span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">insert</span></span>(x: <span class="type">A</span>, sortedList: <span class="type">MyList</span>[<span class="type">A</span>]): <span class="type">MyList</span>[<span class="type">A</span>] =</span><br><span class="line">      <span class="keyword">if</span> (sortedList.isEmpty) <span class="keyword">new</span> <span class="type">Cons</span>(x, <span class="type">Empty</span>)</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (compare(x, sortedList.head) &lt;= <span class="number">0</span>) <span class="keyword">new</span> <span class="type">Cons</span>(x, sortedList)</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">new</span> <span class="type">Cons</span>(sortedList.head, insert(x, sortedList.tail))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sortedTail = t.sort(compare)</span><br><span class="line">    insert(h, sortedTail)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">zipWith</span></span>[<span class="type">B</span>,<span class="type">C</span>](list:<span class="type">MyList</span>[<span class="type">B</span>],zip:(<span class="type">A</span>,<span class="type">B</span>)=&gt;<span class="type">C</span>):<span class="type">MyList</span>[<span class="type">C</span>] =  </span><br><span class="line">    <span class="keyword">if</span> (list.isEmpty) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">"Lists do not have the same length"</span>)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">new</span> <span class="type">Cons</span>(zip(h,list.head),t.zipWith(list.tail,zip))</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fold</span></span>[<span class="type">B</span>](start:<span class="type">B</span>)(operator:(<span class="type">B</span>,<span class="type">A</span>)=&gt;<span class="type">B</span>):<span class="type">B</span> = </span><br><span class="line">  	t.fold(operator(start,h))(operator)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="map-flatMap-filter-and-for-comprehensions"><a href="#map-flatMap-filter-and-for-comprehensions" class="headerlink" title="map, flatMap, filter and for-comprehensions"></a>map, flatMap, filter and for-comprehensions</h3><p>我们之前实现了自己的List，并在其中实现了map，flatmap和filter的相关功能，现在来介绍Scala中的内置方法。</p>
<p>首先来创建一个List：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">println(list.head)<span class="comment">// 打印头部，即1</span></span><br><span class="line">println(list.tail)<span class="comment">// 打印除了头之外的部分，List(2, 3)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>map</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(list.map(_ + <span class="number">1</span>))							<span class="comment">//List(2, 3, 4)</span></span><br><span class="line">println(list.map(_ + <span class="string">" is a number"</span>))	<span class="comment">//List(1 is a number, 2 is a number, 3 is a number)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>filter</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(list.filter(_ % <span class="number">2</span> == <span class="number">0</span>)) 	<span class="comment">//List(2)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>flatMap</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> toPair = (x: <span class="type">Int</span>) =&gt; <span class="type">List</span>(x, x+<span class="number">1</span>)</span><br><span class="line">println(list.flatMap(toPair))		<span class="comment">//List(1, 2, 2, 3, 3, 4)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>foreach </li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.foreach(println)<span class="comment">// 1,2,3</span></span><br></pre></td></tr></table></figure>
<p>我们看到这些函数和我们之前自己实现的功能是一样的。</p>
<h4 id="多重循环"><a href="#多重循环" class="headerlink" title="多重循环"></a>多重循环</h4><p>现在如果我想输出两个甚至更多个list的笛卡尔积，该如何操作？在面向对象的语言中，我们会使用双重循环for-loops，但是在scala中，我们需要用flatmap和map的组合来实现</p>
<ul>
<li>如果是双重循环，外循环中的每个值，都会产生一个list，是一对多的映射，因此使用flatMap；内循环每个值只生成一个对应的值，是一对一映射，因此使用map</li>
<li>如果是三重循环，除了最内层循环使用map，外层循环都会产生一个list，因此使用flatMap</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">val</span> numbers = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">  <span class="keyword">val</span> chars = <span class="type">List</span>('a','b','c','d')</span><br><span class="line">  <span class="keyword">val</span> colors = <span class="type">List</span>(<span class="string">"black"</span>, <span class="string">"white"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果我想做a1,a2,...d3,d4</span></span><br><span class="line">println(numbers.flatMap(n =&gt; chars.map(c =&gt; <span class="string">""</span>+c+n)))</span><br><span class="line"><span class="comment">//List(a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3, a4, b4, c4, d4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果我想对三个list做笛卡尔积：</span></span><br><span class="line">println(numbers.flatMap(n =&gt; chars.flatmap(c =&gt; colors.map(color=&gt;<span class="string">""</span>+c+n+<span class="string">"-"</span>+color))))</span><br><span class="line"><span class="comment">//List(a2-black, a2-white, b2-black, b2-white, c2-black, c2-white, d2-black, d2-white, a4-black, a4-white, b4-black, b4-white, c4-black, c4-white, d4-black, d4-white)=</span></span><br></pre></td></tr></table></figure>
<p>事实上，这种代码的可读性是比较差的，因此，scala提供了多重循环的简化版本。也就是 for循环，如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> forCombinations = <span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="comment">// guards, 也就是for循环中的if条件判断，编译器会将其翻译为filter</span></span><br><span class="line">  n &lt;- numbers <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">  c &lt;- chars</span><br><span class="line">  color &lt;- colors</span><br><span class="line">&#125; <span class="keyword">yield</span> <span class="string">""</span> + c + n + <span class="string">"-"</span> + color</span><br><span class="line">println(forCombinations)</span><br></pre></td></tr></table></figure>
<p>for 循环中的 yield 会把当前的元素记下来，保存在集合中，循环结束后将返回该集合。Scala中 for 循环是有返回值的。如果被循环的是 Map，返回的就是  Map，被循环的是 List，返回的就是 List，以此类推。</p>
<p>上面这句话的意思就是，对于numbers中的偶数、chars中的字符，colors中的颜色，都将其组合并保存在集合中</p>
<p>但是这只是一种语法糖，在编译器内部，还是将for语句转换成map和flatmap来执行的。</p>
<ul>
<li>注意，以下两种写法都是可以的，属于语法重载。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list.map &#123; x =&gt;</span><br><span class="line">  x * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list.map(_*<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h4 id="发散"><a href="#发散" class="headerlink" title="发散"></a>发散</h4><p>试问，我们之前创建的MyList对象，是不是也可以使用for语句进行循环呢？可以的，只要我们在函数内定义了逻辑正确的map、flatMap、filter函数，就可以应用for</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">val</span> listOfIntegers: <span class="type">MyList</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">1</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">3</span>, <span class="type">Empty</span>))) </span><br><span class="line">  <span class="keyword">val</span> listOfStrings: <span class="type">MyList</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="string">"Hello"</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="string">"Scala"</span>, <span class="type">Empty</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> combinations = <span class="keyword">for</span> &#123;</span><br><span class="line">  n &lt;- listOfIntegers</span><br><span class="line">  string &lt;- listOfStrings</span><br><span class="line">&#125; <span class="keyword">yield</span> n + <span class="string">"-"</span> + string</span><br><span class="line">println(combinations)<span class="comment">//[1-Hello 1-Scala 2-Hello 2-Scala 3-Hello 3-Scala]</span></span><br></pre></td></tr></table></figure>
<h3 id="A-Collections-Overview"><a href="#A-Collections-Overview" class="headerlink" title="A Collections Overview"></a>A Collections Overview</h3><p>这一节我们来学习scala中的 集合类,这是一个比较大的类，包含了很多子类.</p>
<p>首先，我们要了解scala中的集合分为 mutable(可变) collection 和immutable(不可变) collection。</p>
<ul>
<li>可变集合可以在适当的地方被更新或扩展。这意味着你可以修改，添加，移除一个集合的元素。</li>
<li>不可变集合类，相比之下，永远不会改变。不过，你仍然可以模拟添加，移除或更新操作。但是这些操作将在每一种情况下都返回一个新的集合，同时使原来的集合不发生改变。</li>
</ul>
<p>之前我们自己写的MyList，List都属于immutable collection之列。</p>
<h4 id="mutable-collection架构图"><a href="#mutable-collection架构图" class="headerlink" title="mutable collection架构图"></a>mutable collection架构图</h4><p><img src="/2022/04/28/scala%E5%88%9D%E8%AF%86/7.svg"></p>
<p>在本篇文章中不会介绍mutable collection的相关内容</p>
<h4 id="immutable-collection-架构图"><a href="#immutable-collection-架构图" class="headerlink" title="immutable collection 架构图"></a>immutable collection 架构图</h4><p><img src="/2022/04/28/scala%E5%88%9D%E8%AF%86/6.svg"></p>
<p>Traversable是所有collection的母类，然后在Iterable下面主要分三大类：Set，Map, 和Seq。 Set是不包含重复数据的集合, Maps是键值对集合，Seq是适合存有序重复数据的列表集合。</p>
<p>Seq下面还是有 IndexSeq 和 LinearSeq两种， 前者可以通过 索引来快速定位元素。后者的元素则是线性的，按照某种顺序排列的。</p>
<h3 id="Sequences-List-Array-Vector"><a href="#Sequences-List-Array-Vector" class="headerlink" title="Sequences:  List, Array, Vector"></a>Sequences:  List, Array, Vector</h3><p>首先我们来看看 Seq接口提供了哪些操作：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Seq</span>[+<span class="type">A</span>] </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">head</span></span>: <span class="type">A</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">tail</span> </span>: <span class="type">Seq</span>[<span class="type">A</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Seq接口是一个很general(不知道怎么翻译了)的接口，其中的元素是按照清晰地顺序进行排列的。而且可以通过下标index进行访问。</p>
<p>Seq接口提供很多操作：</p>
<ul>
<li><p>在索引和迭代方面</p>
<ul>
<li><code>apply</code>: 可以直接通过<code>Seq(1,3,2,4)</code> 这样的方法构造Seq</li>
<li>iterator: 详细用法可以参考文档</li>
<li>length:返回seq长度</li>
<li>reverse: 倒转seq</li>
</ul>
</li>
<li><p>创建新的Seq方面</p>
<ul>
<li>concatenation: 两个seq连接</li>
<li>appending: seq之后连一个元素</li>
<li>prepending: seq之前连一个元素</li>
</ul>
</li>
<li>其他<ul>
<li>grouping</li>
<li>sorting</li>
<li>zipping</li>
<li>searching</li>
<li>slicing</li>
</ul>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aSequence = <span class="type">Seq</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">println(aSequence)		<span class="comment">// List(1, 3, 2, 4)</span></span><br><span class="line">println(aSequence.reverse)<span class="comment">// List(4, 2, 3, 1)</span></span><br><span class="line">println(aSequence(<span class="number">2</span>))	<span class="comment">// 2</span></span><br><span class="line">println(aSequence ++ <span class="type">Seq</span>(<span class="number">7</span>,<span class="number">5</span>,<span class="number">6</span>))<span class="comment">// List(1, 3, 2, 4, 7, 5, 6)</span></span><br><span class="line">println(aSequence.sorted)		<span class="comment">// List(1, 2, 3, 4)</span></span><br></pre></td></tr></table></figure>
<h4 id="Ranges"><a href="#Ranges" class="headerlink" title="Ranges"></a>Ranges</h4><p>scala中的Range也是一种类型，其本质上是一种特殊的 Array</p>
<p>range有两种定义方式：</p>
<ul>
<li>利用until / to 定义 . to代表前闭后闭区间；until代表前闭后开区间</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aRange: <span class="type">Seq</span>[<span class="type">Int</span>] = <span class="number">1</span> until <span class="number">10</span> </span><br><span class="line">aRange.foreach(println)<span class="comment">//1 2 3 4 5 6 7 8 9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> bRange: <span class="type">Seq</span>[<span class="type">Int</span>] = <span class="number">1</span> to <span class="number">10</span> </span><br><span class="line">bRange.foreach(println)<span class="comment">//1 2 3 4 5 6 7 8 9 10</span></span><br></pre></td></tr></table></figure>
<ul>
<li>利用Range(A,B) by C 定义。Range(A,B)代表A和B的前闭后开区间 ，C代表自定义步长</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//范围需要在最大值和最小值范围内即 2 &lt;= 元素 &lt;= 19</span></span><br><span class="line"><span class="keyword">val</span> res: <span class="type">Range</span> = <span class="type">Range</span>(<span class="number">2</span>, <span class="number">20</span>) by <span class="number">3</span></span><br><span class="line">println(res.foreach(println))</span><br></pre></td></tr></table></figure>
<p>利用 Ranges我们可以实现类似循环的效果：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span> to <span class="number">10</span>).foreach(x =&gt; println(<span class="string">"Hello"</span>)) <span class="comment">// 打印10遍 Hello</span></span><br></pre></td></tr></table></figure>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>List列表：不可变</p>
<p>LIst支持在头部快速添加和移除条目,意味着模式匹配很顺畅, head、tail、isEmpty操作只需要 $O(1)$的复杂度。</p>
<p>大多数List操作还是需要遍历整个列表的，需要O(n)的复杂度，如length，reverse。</p>
<p>List不支持索引直接定位，如 <code>list(2)=10</code> (非法)； 但是可以使用updated方法，但此方法也不是索引定位，而是线性复杂度的。</p>
<p>List列表跟其他语言中的数组非常像，二者都是同构的，同一个列表的所有元素必须是相同类型。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aList = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">// +: 是prepend, :+ 是 append，我们只要记住 : 都是靠近List一边的即可</span></span><br><span class="line"><span class="keyword">val</span> prepended = <span class="number">42</span> +: aList :+ <span class="number">89</span></span><br><span class="line">println(prepended) <span class="comment">// List(42, 1, 2, 3, 89)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fill函数是创建一个长度为5的数组，数组中每个元素都是 字符串 apple</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">val</span> apples5 = <span class="type">List</span>.fill(<span class="number">5</span>)(<span class="string">"apple"</span>)</span><br><span class="line">println(apples5)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将list中的元素按一定格式排列，mkString中的参数就是每个元素之间的分割符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">println(aList.mkString(<span class="string">"-|-"</span>))</span><br></pre></td></tr></table></figure>
<h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><p>Array和List不一样，它和Java中的arrays是等价的</p>
<ul>
<li>在创建的时候，可以预先其分配内存，而不对其进行赋值</li>
<li>在适当的位置可以被修改(更新)，所以是部分可变的</li>
<li>可以和 Java的 T[] arrays互相操作</li>
<li>可以通过索引访问，速度很快</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是创建一个长度为4的Array，同时赋值</span></span><br><span class="line"><span class="keyword">val</span> numbers = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">//创建一个String类型、长度为3的Array，但不赋值</span></span><br><span class="line"><span class="keyword">val</span> threeElements = <span class="type">Array</span>.ofDim[<span class="type">String</span>](<span class="number">3</span>)</span><br><span class="line">threeElements.foreach(println)<span class="comment">// 打印会得到null</span></span><br><span class="line"><span class="comment">//如果是数值类型的数组，不赋值，打印会得到0或者false(bool)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// array是部分可变的，比如我们可以将某一位置上的值更新。</span></span><br><span class="line">numbers(<span class="number">2</span>) = <span class="number">0</span>  <span class="comment">// 这种写法比较直白，其实是numbers.update(2, 0)的语法糖</span></span><br><span class="line">println(numbers.mkString(<span class="string">" "</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>seq和array之间的转化</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays and seq</span></span><br><span class="line"><span class="keyword">val</span> numbersSeq: <span class="type">Seq</span>[<span class="type">Int</span>] = numbers  <span class="comment">// 隐式转化，将array转换为ArraySeq</span></span><br><span class="line">println(numbersSeq) <span class="comment">//ArraySeq(1 2 0 4)</span></span><br></pre></td></tr></table></figure>
<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>vector是另外一个独立的体系，也是 Imuutable的</p>
<ul>
<li>vector可以利用索引来进行读写，复杂度为$O(\log_{32}(n))$,因此vector的索引操作是非常快的</li>
<li>可以使用append和prepend</li>
<li>底层数据结构是fixed-branched Trie树(字典树)，</li>
<li>当vector中数据很大时，表现很好</li>
<li>可以使用prepend和append方法，也可以调用 updated 进行更新</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> vector: <span class="type">Vector</span>[<span class="type">Int</span>] = <span class="type">Vector</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">println(vector)</span><br></pre></td></tr></table></figure>
<ul>
<li>vectors和lists性能对比</li>
</ul>
<p>在数据量很大的情况下，vectors的表现要远远优于list：</p>
<p>首先我们写一个函数，对一个长度为1,000,000的Seq(vector和list都继承自seq)，随机替换seq中的某一个值，重复1,000遍。最终返回平均每次updated操作的运算时间。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> maxRuns = <span class="number">1000</span></span><br><span class="line"><span class="keyword">val</span> maxCapacity = <span class="number">1000000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getWriteTime</span></span>(collection: <span class="type">Seq</span>[<span class="type">Int</span>]): <span class="type">Double</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> r = <span class="keyword">new</span> <span class="type">Random</span></span><br><span class="line">  <span class="keyword">val</span> times = <span class="keyword">for</span> &#123;</span><br><span class="line">    it &lt;- <span class="number">1</span> to maxRuns</span><br><span class="line">  &#125; <span class="keyword">yield</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> currentTime = <span class="type">System</span>.nanoTime()</span><br><span class="line">    collection.updated(r.nextInt(maxCapacity), r.nextInt())</span><br><span class="line">    <span class="type">System</span>.nanoTime() - currentTime</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  times.sum * <span class="number">1.0</span> / maxRuns</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> numbersList = (<span class="number">1</span> to maxCapacity).toList</span><br><span class="line"><span class="keyword">val</span> numbersVector = (<span class="number">1</span> to maxCapacity).toVector</span><br><span class="line"></span><br><span class="line"><span class="comment">// keeps reference to tail</span></span><br><span class="line"><span class="comment">// updating an element in the middle takes long</span></span><br><span class="line">println(getWriteTime(numbersList)) <span class="comment">//耗费 2673515.435 纳秒</span></span><br><span class="line"><span class="comment">// depth of the tree is small</span></span><br><span class="line"><span class="comment">// needs to replace an entire 32-element chunk</span></span><br><span class="line">println(getWriteTime(numbersVector))<span class="comment">//耗费 8457.379 纳秒</span></span><br></pre></td></tr></table></figure>
<p>我们看到，list和vector在updated 操作上，有着近三百多倍的差距，而且差距会随着规模的增大而继续拉大</p>
<h3 id="Tuples-and-Maps"><a href="#Tuples-and-Maps" class="headerlink" title="Tuples and Maps"></a>Tuples and Maps</h3><p>和List一样，Tuple也是不可变的，但是和list也有不同之处：<strong>元组可以包含不同类型的元素</strong>，但是list为元素为统一中类型</p>
<h4 id="Tuples"><a href="#Tuples" class="headerlink" title="Tuples"></a>Tuples</h4><p>声明元组的语法如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aTuple = <span class="keyword">new</span> <span class="type">Tuple2</span>(<span class="number">2</span>,<span class="string">"hello scala"</span>)<span class="comment">//最正规也最复杂的定义</span></span><br><span class="line"><span class="keyword">val</span> aTuple = <span class="type">Tuple2</span>(<span class="number">2</span>,<span class="string">"hello scala"</span>)		<span class="comment">//可以把new去掉，因为Tuple2中有apple方法</span></span><br><span class="line"><span class="keyword">val</span> aTuple = (<span class="number">2</span>, <span class="string">"hello, Scala"</span>)  			<span class="comment">// 这是一种语法糖，等价于用Tuple2来定义</span></span><br></pre></td></tr></table></figure>
<p>事实上，scala会自动根据元组里面的元素类型以及个数去创建 TuplesN[]，N最大为22(因为是根据FunctionN来的)，所以说元组的最大容量只有22</p>
<ul>
<li>tuple 访问元素的方法</li>
</ul>
<p>tuple访问里面的第一个元素用<code>._1</code>; 第二个元素用<code>._2</code> ，以此类推</p>
<p>如果想要修改tuple中的元素，需要使用copy方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(aTuple._1)  <span class="comment">// 2</span></span><br><span class="line">println(aTuple.copy(_2 = <span class="string">"goodbye Java"</span>)) <span class="comment">//(2,goodbye Java)</span></span><br><span class="line">println(aTuple.swap)  <span class="comment">// ("hello, Scala", 2) 只有Tuple2有这个swap方法，其他都没有</span></span><br></pre></td></tr></table></figure>
<h4 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h4><ul>
<li>Maps是键值对集合，可以由如下定义：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string 是key， Int 是value</span></span><br><span class="line"><span class="keyword">val</span> aMap: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>] = <span class="type">Map</span>()</span><br><span class="line"><span class="comment">// 键值对可以使一个Tuple2，也可以是 key -&gt; value形式的(语法糖)</span></span><br><span class="line"><span class="comment">// withDefaultValue(-1)的意思是，如果查到Map中没有的键，就返回-1;若不设置，遇到的时候会报错</span></span><br><span class="line"><span class="keyword">val</span> phonebook = <span class="type">Map</span>((<span class="string">"Jim"</span>, <span class="number">555</span>), <span class="string">"Daniel"</span> -&gt; <span class="number">789</span>, (<span class="string">"JIM"</span>, <span class="number">9000</span>)).withDefaultValue(<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>判断map是否包含某个键</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(phonebook.contains(<span class="string">"Jim"</span>))<span class="comment">// true</span></span><br><span class="line">print(phonebook(<span class="string">"Mary"</span>))<span class="comment">//-1,因为 Mary这个键不存在</span></span><br></pre></td></tr></table></figure>
<ul>
<li>由于map是immutable的，因此如果要往原来的map里插入新键值对，</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> newPairing = <span class="string">"Mary"</span> -&gt; <span class="number">678</span></span><br><span class="line"><span class="keyword">val</span> newPhonebook = phonebook + newPairing</span><br><span class="line">println(newPhonebook)</span><br></pre></td></tr></table></figure>
<ul>
<li>让tuples打印得更漂亮</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(tuple.toString)</span><br></pre></td></tr></table></figure>
<h5 id="functionals-on-maps"><a href="#functionals-on-maps" class="headerlink" title="functionals on maps"></a>functionals on maps</h5><ul>
<li>map 函数</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(phonebook.map(pair =&gt; pair._1.toLowerCase -&gt; pair._2))</span><br></pre></td></tr></table></figure>
<ul>
<li>filter函数</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(phonebook.view.filterKeys(x =&gt; x.startsWith(<span class="string">"J"</span>)).toMap)</span><br></pre></td></tr></table></figure>
<ul>
<li>mapValues</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(phonebook.view.mapValues(number =&gt; <span class="string">"0245-"</span> + number).toMap)</span><br></pre></td></tr></table></figure>
<h5 id="map与其结构之间的转换"><a href="#map与其结构之间的转换" class="headerlink" title="map与其结构之间的转换"></a>map与其结构之间的转换</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// conversions to other collections</span></span><br><span class="line"><span class="comment">// map转换为List</span></span><br><span class="line">println(phonebook.toList) </span><br><span class="line"><span class="comment">// List转换为Map</span></span><br><span class="line">println(<span class="type">List</span>((<span class="string">"Daniel"</span>, <span class="number">555</span>)).toMap)</span><br></pre></td></tr></table></figure>
<h5 id="groupBy函数"><a href="#groupBy函数" class="headerlink" title="groupBy函数"></a>groupBy函数</h5><p>groupBy函数比较有用，可以将List中的元素分成组。比如说</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> names = <span class="type">List</span>(<span class="string">"Bob"</span>, <span class="string">"James"</span>, <span class="string">"Angela"</span>, <span class="string">"Mary"</span>, <span class="string">"Daniel"</span>, <span class="string">"Jim"</span>)</span><br><span class="line">println(names.groupBy(name =&gt; name.charAt(<span class="number">0</span>)))</span><br><span class="line"><span class="comment">//HashMap(J -&gt; List(James, Jim), A -&gt; List(Angela), M -&gt; List(Mary), B -&gt; List(Bob), D -&gt; List(Daniel))</span></span><br><span class="line">println(names.groupBy(name =&gt; name.charAt(<span class="number">0</span>) == '<span class="type">J</span>'))</span><br><span class="line"><span class="comment">//HashMap(false -&gt; List(Bob, Angela, Mary, Daniel), true -&gt; List(James, Jim))</span></span><br></pre></td></tr></table></figure>
<h4 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise"></a>Exercise</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  1.  What would happen if I had two original entries "Jim" -&gt; 555 and "JIM" -&gt; 900</span></span><br><span class="line"><span class="comment">      !!! careful with mapping keys.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  2.  Overly simplified social network based on maps</span></span><br><span class="line"><span class="comment">      Person = String</span></span><br><span class="line"><span class="comment">      - add a person to the network</span></span><br><span class="line"><span class="comment">      - remove</span></span><br><span class="line"><span class="comment">      - friend (mutual)</span></span><br><span class="line"><span class="comment">      - unfriend</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      - number of friends of a person</span></span><br><span class="line"><span class="comment">      - person with most friends</span></span><br><span class="line"><span class="comment">      - how many people have NO friends</span></span><br><span class="line"><span class="comment">      - if there is a social connection between two people (direct or not)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h3><p>现在来介绍一下Scala中一种特殊的类: Option</p>
<p>Option 可以看做一个容器要么有东西(Some),要么什么东西都没有。<strong>我们可将其看成一个长度为0或1的List。当Option里面有东西的时候，这个List的长度是1（也就是 Some），而当你的Option里没有东西的时候，它的长度是0（也就是 None）。</strong></p>
<p>那么Option可以应用在哪里？我们设想一个情况：打印一个还未分配内存的字符串，显然，这会导致 Null Pointer Error并使得程序崩溃。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> string: <span class="type">String</span> = <span class="literal">null</span></span><br><span class="line">println(string.length)</span><br></pre></td></tr></table></figure>
<p>为了解决这个问题，正常方法可以这样写,但是如果通篇都是这样的处理，就会显得很杂乱</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> string : <span class="type">String</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">if</span> (string != <span class="literal">null</span>) &#123;</span><br><span class="line">		println(string.length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，Option就发挥其作用了。Option可以作为一个wrapper，被它包含的值可以使存在的，也可以是Nothing。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unsafeMethod</span></span>(): <span class="type">String</span> = <span class="literal">null</span></span><br><span class="line"><span class="comment">//  val result = Some(null) // WRONG</span></span><br><span class="line"><span class="keyword">val</span> result = <span class="type">Option</span>(unsafeMethod()) <span class="comment">// Some or None</span></span><br><span class="line">println(result)	<span class="comment">//None</span></span><br></pre></td></tr></table></figure>
<p>此外，在 map 中，我们可以用Option来包裹 <code>map.get(&quot;key&quot;)</code> 如果key不存在，那么值就是 None</p>
<p>又比如，在访问一个空列表的头部的时候，也可以用Option。</p>
<p>我的理解是，option有点像植物大战僵尸中的南瓜，南瓜里面可以有植物，也可以什么都没有，但南瓜放在那边就会起一个保护作用。</p>
<h4 id="使用-getOrElse-方法"><a href="#使用-getOrElse-方法" class="headerlink" title="使用 getOrElse() 方法"></a>使用 getOrElse() 方法</h4><p>以下是示例程序，显示了如何使用<strong>getOrElse()</strong>方法访问值或不存在值时的默认值。</p>
<p>比如说：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backupMethod</span></span>(): <span class="type">String</span> = <span class="string">"A valid result"</span></span><br><span class="line"><span class="comment">// 如果前面函数的调用值是None，那么就会调用后面的函数</span></span><br><span class="line"><span class="keyword">val</span> chainedResult = <span class="type">Option</span>(unsafeMethod()).orElse(<span class="type">Option</span>(backupMethod()))</span><br></pre></td></tr></table></figure>
<p>事实上，我们可以在进行优化，在定义函数的时候，就将返回值定为 Option, 这样可读性更强，而且对用户更友好(api中已经设定了option，用户不用自己再套一层option)</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">betterUnsafeMethod</span></span>(): <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">betterBackupMethod</span></span>(): <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">Some</span>(<span class="string">"A valid result"</span>)</span><br><span class="line"><span class="keyword">val</span> betterChainedResult = betterUnsafeMethod() orElse betterBackupMethod()</span><br></pre></td></tr></table></figure>
<h4 id="functions-on-Options"><a href="#functions-on-Options" class="headerlink" title="functions on Options"></a>functions on Options</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(myFirstOption.isEmpty) <span class="comment">// 判断是否为空</span></span><br><span class="line">println(myFirstOption.get)   	<span class="comment">// 获得Option中的值，由于可能是空值，因此不安全</span></span><br></pre></td></tr></table></figure>
<p>Option也可以使用map、filter和flatMap函数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myFirstOption: <span class="type">Option</span>[<span class="type">Int</span>] = <span class="type">Some</span>(<span class="number">4</span>)</span><br><span class="line">println(myFirstOption.map(_ * <span class="number">2</span>)) 	<span class="comment">// Some(8)</span></span><br><span class="line">println(myFirstOption.filter(x =&gt; x &gt; <span class="number">10</span>))<span class="comment">// None </span></span><br><span class="line">println(myFirstOption.flatMap(x =&gt; <span class="type">Option</span>(x * <span class="number">10</span>)))<span class="comment">// Some(40)</span></span><br></pre></td></tr></table></figure>
<h4 id="for-comprehensions"><a href="#for-comprehensions" class="headerlink" title="for-comprehensions"></a>for-comprehensions</h4><p>在设计api的时候，如果返回值可能是None，我们需要在前面套一层Option使得api更加安全。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Connection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span> </span>= <span class="string">"Connected"</span> <span class="comment">// connect to some server</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">object</span> <span class="title">Connection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> random = <span class="keyword">new</span> <span class="type">Random</span>(<span class="type">System</span>.nanoTime())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(host: <span class="type">String</span>, port: <span class="type">String</span>): <span class="type">Option</span>[<span class="type">Connection</span>] =</span><br><span class="line">      <span class="keyword">if</span> (random.nextBoolean()) <span class="type">Some</span>(<span class="keyword">new</span> <span class="type">Connection</span>)</span><br><span class="line">      <span class="keyword">else</span> <span class="type">None</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> forConnectionStatus = <span class="keyword">for</span> &#123;</span><br><span class="line">  host &lt;- config.get(<span class="string">"host"</span>)</span><br><span class="line">  port &lt;- config.get(<span class="string">"port"</span>)</span><br><span class="line">  connection &lt;- <span class="type">Connection</span>(host, port)</span><br><span class="line">&#125; <span class="keyword">yield</span> connection.connect</span><br><span class="line"></span><br><span class="line">forConnectionStatus.foreach(println)</span><br></pre></td></tr></table></figure>
<h3 id="Handling-Failure"><a href="#Handling-Failure" class="headerlink" title="Handling Failure"></a>Handling Failure</h3><h2 id="Pattern-Matching"><a href="#Pattern-Matching" class="headerlink" title="Pattern Matching"></a>Pattern Matching</h2><h3 id="Pattern-Matching-1"><a href="#Pattern-Matching-1" class="headerlink" title="Pattern Matching"></a>Pattern Matching</h3><p>pattern matching是scala中很重要的一部分，它类似于switch case，可以对一个值进行条件判断，然后针对不同的条件进行不同的处理。</p>
<p>但是Scala的模式匹配的功能比Java的swich case语法的功能要强大的多，Java的swich case语法<strong>只能对值</strong>进行匹配。但是Scala的模式匹配除了可以对值进行匹配之外，还可以<strong>对类型进行匹配、对Array和List的元素情况进行匹配、对case class进行匹配、甚至对有值或没值（Option）进行匹配</strong>。 </p>
<p>一个常见的pattern match的语法如下：很容易理解，就是swich case</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> random = <span class="keyword">new</span> <span class="type">Random</span></span><br><span class="line"><span class="keyword">val</span> x = random.nextInt(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> description = x <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">"the ONE"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span> =&gt; <span class="string">"double or nothing"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span> =&gt; <span class="string">"third time is the charm"</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="string">"something else"</span>  <span class="comment">// _ = WILDCARD</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用pattern matching的时候我们要注意几点：</p>
<ul>
<li>case 要按照一定的顺序来组织，增强可读性</li>
<li>为了防止出现 MatchError的情况，一定要设置 Wildcard，也就是默认不匹配情况下的返回值。(用 <code>_</code>符号)</li>
</ul>
<p>pattern matching还有其他好用的特性</p>
<h4 id="解耦合"><a href="#解耦合" class="headerlink" title="解耦合"></a>解耦合</h4><p>模式匹配不单匹配值，甚至可以匹配类中的某个成员变量来进行条件筛选</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">bob</span> </span>= <span class="type">Person</span>(<span class="string">"Bob"</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> greeting = bob <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Person</span>(n, a) <span class="keyword">if</span> a &lt; <span class="number">21</span> =&gt; <span class="string">s"Hi, my name is <span class="subst">$n</span> and I can't drink in the US"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Person</span>(n, a) =&gt; <span class="string">s"Hi, my name is <span class="subst">$n</span> and I am <span class="subst">$a</span> years old"</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="string">"I don't know who I am"</span></span><br><span class="line">&#125;</span><br><span class="line">println(greeting)</span><br></pre></td></tr></table></figure>
<h4 id="PM在继承类中的应用"><a href="#PM在继承类中的应用" class="headerlink" title="PM在继承类中的应用"></a>PM在继承类中的应用</h4><p>Pattern Matching 甚至可以匹配子类类型。如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">  <span class="title">case</span> <span class="title">class</span> <span class="title">Dog</span>(<span class="params">breed: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">  <span class="title">case</span> <span class="title">class</span> <span class="title">Parrot</span>(<span class="params">greeting: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">  <span class="title">case</span> <span class="title">class</span> <span class="title">Cat</span>(<span class="params">meow: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">animal</span></span>: <span class="type">Animal</span> = <span class="type">Dog</span>(<span class="string">"Terra Nova"</span>)</span><br><span class="line"><span class="keyword">val</span> animal2: <span class="type">Animal</span> = <span class="type">Parrot</span>(<span class="string">"Terra Nova"</span>)</span><br><span class="line"><span class="keyword">val</span> animal3: <span class="type">Animal</span> = <span class="type">Cat</span>(<span class="string">"Meow Meow"</span>)</span><br><span class="line"></span><br><span class="line">animal3 <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Dog</span>(someBreed) =&gt; println(<span class="string">s"Matched a dog of the <span class="subst">$someBreed</span> breed"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Parrot</span>(someGreetings) =&gt; println(<span class="string">s"Match a parrot of <span class="subst">$someGreetings</span> greeting"</span>)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; println(<span class="string">"Something else"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise"></a>Exercise</h4><p>给出如下要求：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Exercise</span></span><br><span class="line"><span class="comment">  simple function uses PM</span></span><br><span class="line"><span class="comment">   takes an Expr =&gt; human readable form</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Sum(Number(2), Number(3)) =&gt; 2 + 3</span></span><br><span class="line"><span class="comment">   Sum(Number(2), Number(3), Number(4)) =&gt; 2 + 3 + 4</span></span><br><span class="line"><span class="comment">   Prod(Sum(Number(2), Number(1)), Number(3)) = (2 + 1) * 3</span></span><br><span class="line"><span class="comment">   Sum(Prod(Number(2), Number(1)), Number(3)) = 2 * 1 + 3</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>要我们用PM实现代码到数学公式的转换。这里最难想到的就是乘法的处理：</p>
<ul>
<li><code>Prod(Number(2), Number(1))</code> , 对2和1不需要改，直接变成 <code>2*1</code></li>
<li><code>Prod(Sum(Number(2),Number(1)),Number3)</code>,那么前面的<code>Sum(Number(2),Number(1))</code> 就需要额外加个括号，符合预算规则</li>
<li><code>Prod(Prod(Number(2),Number(1)),Number(3))</code> ，那么不需要括号，计算出<code>2*1</code>之后在和3计算得到<code>2*1*3</code></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Expr</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Number</span>(<span class="params">n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Sum</span>(<span class="params">e1: <span class="type">Expr</span>, e2: <span class="type">Expr</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Prod</span>(<span class="params">e1: <span class="type">Expr</span>, e2: <span class="type">Expr</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">show</span>(<span class="params">e: <span class="type">Expr</span></span>)</span>: <span class="type">String</span> = e <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Number</span>(n) =&gt;	<span class="string">s"<span class="subst">$n</span>"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Sum</span>(e1,e2) =&gt; show(e1)+<span class="string">" + "</span>+show(e2)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Prod</span>(e1,e2) =&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">matchInProdExp</span></span>(e: <span class="type">Expr</span>): <span class="type">String</span> = e <span class="keyword">match</span> &#123;</span><br><span class="line">      	<span class="keyword">case</span> <span class="type">Number</span>(n) =&gt; show(e)</span><br><span class="line">      	<span class="keyword">case</span> <span class="type">Prod</span>(e1,e2) =&gt; show(e)</span><br><span class="line">      	<span class="keyword">case</span> _ =&gt; <span class="string">"("</span>+ show(e)+<span class="string">")"</span></span><br><span class="line">    &#125;</span><br><span class="line">    matchInProdExp(e1)+<span class="string">" * "</span>+matchInProdExp(e2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">println(show(<span class="type">Sum</span>(<span class="type">Number</span>(<span class="number">2</span>), <span class="type">Number</span>(<span class="number">3</span>))))</span><br><span class="line">println(show(<span class="type">Sum</span>(<span class="type">Sum</span>(<span class="type">Number</span>(<span class="number">2</span>), <span class="type">Number</span>(<span class="number">3</span>)), <span class="type">Number</span>(<span class="number">4</span>))))</span><br><span class="line">println(show(<span class="type">Prod</span>(<span class="type">Sum</span>(<span class="type">Number</span>(<span class="number">2</span>), <span class="type">Number</span>(<span class="number">1</span>)), <span class="type">Number</span>(<span class="number">3</span>))))</span><br><span class="line">println(show(<span class="type">Prod</span>(<span class="type">Sum</span>(<span class="type">Number</span>(<span class="number">2</span>), <span class="type">Number</span>(<span class="number">1</span>)), <span class="type">Sum</span>(<span class="type">Number</span>(<span class="number">3</span>), <span class="type">Number</span>(<span class="number">4</span>)))))</span><br><span class="line">println(show(<span class="type">Sum</span>(<span class="type">Prod</span>(<span class="type">Number</span>(<span class="number">2</span>), <span class="type">Number</span>(<span class="number">1</span>)), <span class="type">Number</span>(<span class="number">3</span>))))</span><br></pre></td></tr></table></figure>
<h3 id="ALL-the-Patterns"><a href="#ALL-the-Patterns" class="headerlink" title="ALL the Patterns"></a>ALL the Patterns</h3><p>这一节我们来系统总结一下总共有多少Patterns可以供我们去匹配</p>
<h4 id="constants"><a href="#constants" class="headerlink" title="constants"></a>constants</h4><p>case里面可以是很多类型，数字、字符串、布尔值、对象等</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x: <span class="type">Any</span> = <span class="string">"Scala"</span></span><br><span class="line"><span class="keyword">val</span> constants = x <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">"a number"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">"Scala"</span> =&gt; <span class="string">"THE Scala"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="literal">true</span> =&gt; <span class="string">"The Truth"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">AllThePatterns</span> =&gt; <span class="string">"A singleton object"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="variables"><a href="#variables" class="headerlink" title="variables"></a>variables</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> matchAVariable = x <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> something =&gt; <span class="string">s"I've found <span class="subst">$something</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="wildcard"><a href="#wildcard" class="headerlink" title="wildcard"></a>wildcard</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> matchAnything = x <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> _ =&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="tuples"><a href="#tuples" class="headerlink" title="tuples"></a>tuples</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aTuple = (<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> matchATuple = aTuple <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> (<span class="number">1</span>, <span class="number">1</span>) =&gt;</span><br><span class="line">  <span class="keyword">case</span> (something, <span class="number">2</span>) =&gt; <span class="string">s"I've found <span class="subst">$something</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>甚至可以匹配 嵌套元组：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> nestedTuple = (<span class="number">1</span>, (<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="keyword">val</span> matchANestedTuple = nestedTuple <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> (_, (<span class="number">2</span>, variable)) =&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="case-classes"><a href="#case-classes" class="headerlink" title="case classes"></a>case classes</h4><p>constructor pattern可以匹配我们自己创建的case class。比如说我创建了一个MyList[Int]类型的列表。case类型可以类似于case class的构造器，用来解构类中的成员</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aList: <span class="type">MyList</span>[<span class="type">Int</span>] = <span class="type">Cons</span>(<span class="number">1</span>, <span class="type">Cons</span>(<span class="number">2</span>, <span class="type">Empty</span>))</span><br><span class="line">  </span><br><span class="line"><span class="keyword">val</span> matchAList = aList <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Empty</span> =&gt; <span class="string">"Empty"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Cons</span>(head, <span class="type">Cons</span>(subhead, subtail)) =&gt; <span class="string">s"head is <span class="subst">$head</span>, subhead is <span class="subst">$subhead</span>, subtail is <span class="subst">$subtail</span>"</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">println(matchAList)<span class="comment">//head is 1, subhead is 2, subtail is []</span></span><br></pre></td></tr></table></figure>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>List  patterns非常有用,它可以有很多种形式的case</p>
<ul>
<li><code>case List(1, _, _, _)</code>  匹配开头为1，长度为4的List</li>
<li><code>case List(1, _*)</code> 匹配开头为1，长度不限的List</li>
<li><code>case 1 :: List(_)</code> 匹配开头为1的List</li>
<li><code>case List(1,2,_) :+ 42</code> 匹配以42结束的List</li>
<li><code>case h :: t =&gt; h + &quot;&quot; + processList(t)</code> 提取list的头元素和尾元素</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aStandardList = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">42</span>)</span><br><span class="line"><span class="keyword">val</span> standardListMatching = aStandardList <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">List</span>(<span class="number">1</span>, _, _, _) =&gt; <span class="comment">// extractor - advanced</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">List</span>(<span class="number">1</span>, _*) =&gt; <span class="comment">// list of arbitrary length - advanced</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span> :: <span class="type">List</span>(_) =&gt; <span class="comment">// infix pattern</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,_) :+ <span class="number">42</span> =&gt; <span class="string">"lala"</span><span class="comment">// infix pattern</span></span><br><span class="line">  <span class="keyword">case</span> h :: t =&gt; h + <span class="string">""</span> + processList(t) <span class="comment">//haskell-like prepending</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>scala还可以匹配输入对象的类型，如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> unknown: <span class="type">Any</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">val</span> unknownMatch = unknown <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> list: <span class="type">List</span>[<span class="type">Int</span>] =&gt; <span class="comment">// explicit type specifier</span></span><br><span class="line">  <span class="keyword">case</span> _:<span class="type">String</span> =&gt; <span class="string">"this method returns String"</span></span><br><span class="line">  <span class="keyword">case</span> _:<span class="type">Int</span> =&gt; <span class="string">"this method returns Int"</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="string">"this method returns something else"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="name-binding"><a href="#name-binding" class="headerlink" title="name binding"></a>name binding</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> nameBindingMatch = aList <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> nonEmptyList @ <span class="type">Cons</span>(_, _) =&gt; <span class="comment">// name binding =&gt; use the name later(here)</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Cons</span>(<span class="number">1</span>, rest @ <span class="type">Cons</span>(<span class="number">2</span>, _)) =&gt; <span class="comment">// name binding inside nested patterns</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="multi-patterns"><a href="#multi-patterns" class="headerlink" title="multi-patterns"></a>multi-patterns</h4><p>multiple patterns就是将两个模式用 Pipe符号连接起来——只要符合其中一个模式，就匹配成功，如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 8 - multi-patterns</span></span><br><span class="line"><span class="keyword">val</span> multipattern = aList <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Empty</span> | <span class="type">Cons</span>(<span class="number">0</span>, _) =&gt; <span class="comment">// compound pattern (multi-pattern)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="if-guards"><a href="#if-guards" class="headerlink" title="if guards"></a>if guards</h4><p>可在模式后添加 if 语句</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> secondElementSpecial = aList <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Cons</span>(_, <span class="type">Cons</span>(specialElement, _)) <span class="keyword">if</span> specialElement % <span class="number">2</span> == <span class="number">0</span> =&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注明"><a href="#注明" class="headerlink" title="注明"></a>注明</h4><p>JVM中会存在type erase的情况，如下：</p>
<p>此时打印 numbersMath，会得到 a list of strings，这是因为在 Java刚开始被创建时，是没有泛型这一概念的，泛型直到Java5才被加入。因此，JVM在做类型判断的时候，为了能让Java1的程序也能运行，在判断的时候，将泛型全部抹去了</p>
<p>因此，在java内部，事实上不会对List究竟是哪一种类型的做匹配，而是只匹配是否为List</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numbers: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"> <span class="keyword">val</span> numbersMatch = numbers <span class="keyword">match</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> listOfStrings: <span class="type">List</span>[<span class="type">String</span>] =&gt; <span class="string">"a list of strings"</span></span><br><span class="line">   <span class="keyword">case</span> listOfNumbers: <span class="type">List</span>[<span class="type">Int</span>] =&gt; <span class="string">"a list of numbers"</span></span><br><span class="line">   <span class="keyword">case</span> _ =&gt; <span class="string">""</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> println(numbersMatch)</span><br></pre></td></tr></table></figure>
<h3 id="Patterns-Everywhere"><a href="#Patterns-Everywhere" class="headerlink" title="Patterns Everywhere"></a>Patterns Everywhere</h3><p>事实上，模式匹配的思想在 scala中随处可见：</p>
<h4 id="在try-catch中"><a href="#在try-catch中" class="headerlink" title="在try-catch中"></a>在try-catch中</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> e: <span class="type">RuntimeException</span> =&gt; <span class="string">"runtime"</span></span><br><span class="line">  <span class="keyword">case</span> npe: <span class="type">NullPointerException</span> =&gt; <span class="string">"npe"</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="string">"something else"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在try-catch中的case 其实是简写的形式，事实上在catch里面也有一个match，如下</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  e <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> e: <span class="type">RuntimeException</span> =&gt; <span class="string">"runtime"</span></span><br><span class="line">    <span class="keyword">case</span> npe: <span class="type">NullPointerException</span> =&gt; <span class="string">"npe"</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="string">"something else"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在-for-中"><a href="#在-for-中" class="headerlink" title="在 for 中"></a>在 for 中</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="keyword">val</span> evenOnes = <span class="keyword">for</span> &#123;</span><br><span class="line">  x &lt;- list <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="comment">//也是一种模式匹配</span></span><br><span class="line">&#125; <span class="keyword">yield</span> <span class="number">10</span> * x</span><br><span class="line"></span><br><span class="line"><span class="comment">// generators are also based on PATTERN MATCHING</span></span><br><span class="line"><span class="keyword">val</span> tuples = <span class="type">List</span>((<span class="number">1</span>,<span class="number">2</span>), (<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="keyword">val</span> filterTuples = <span class="keyword">for</span> &#123;</span><br><span class="line">  (first, second) &lt;- tuples</span><br><span class="line">&#125; <span class="keyword">yield</span> first * second</span><br></pre></td></tr></table></figure>
<h4 id="Tuple-List"><a href="#Tuple-List" class="headerlink" title="Tuple, List"></a>Tuple, List</h4><p>可以直接提取出tuple、list中的元素，这也包含了PM的思想。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> tuple = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> (a, b, c) = tuple</span><br><span class="line">println(b) </span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> head :: tail = list</span><br><span class="line">println(head)</span><br><span class="line">println(tail)</span><br></pre></td></tr></table></figure>
<h4 id="partial-function"><a href="#partial-function" class="headerlink" title="partial function"></a>partial function</h4><p>有时我们会遇到这样子的函数，可能会被搞得不知道是什么意思，其实这也是PM的简化形式</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="keyword">val</span> mappedList = list.map &#123;</span><br><span class="line">  <span class="keyword">case</span> v <span class="keyword">if</span> v % <span class="number">2</span> == <span class="number">0</span> =&gt; v + <span class="string">" is even"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">"the one"</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="string">"something else"</span></span><br><span class="line">&#125; <span class="comment">// partial function literal</span></span><br></pre></td></tr></table></figure>
<p>省去了对每一个list中的元素x做match的过程</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mappedList2 = list.map &#123; x =&gt; x <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> v <span class="keyword">if</span> v % <span class="number">2</span> == <span class="number">0</span> =&gt; v + <span class="string">" is even"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">"the one"</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="string">"something else"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    
    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束，感谢您的阅读-------------</div>
    
</div>

      
    </div>
    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:</strong>
    Jason
  </li>
  <li class="post-copyright-link">
    <strong>Post link:</strong>
    <a href="https://jasonxqh.github.io/2022/04/28/scala%E5%88%9D%E8%AF%86/" title="scala初识">https://jasonxqh.github.io/2022/04/28/scala%E5%88%9D%E8%AF%86/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice: </strong>
    All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> unless stating additionally.
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/scala/" rel="tag"><i class="fa fa-tag"></i> scala</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/" rel="next" title="Solidity初识">
                <i class="fa fa-chevron-left"></i> Solidity初识
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2022/05/08/advanced-Scala%E5%AD%A6%E4%B9%A0/" rel="prev" title="advanced-Scala学习">
                advanced-Scala学习 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC80OTgyMC8yNjMxMQ=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Jason</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives%7C%7C%20archive">
              
                  <span class="site-state-item-count">440</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">68</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/JasonXQH" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:10195501423@stu.ecnu.edu.cn" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://yanghong.tech/" title="友链:杨弘的博客" target="_blank">友链:杨弘的博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://ankate.github.io/" title="友链:赵奕轲的博客" target="_blank">友链:赵奕轲的博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://github.com/JasonXQH/JasonXQH.github.io" title="Like it, STAR ME" target="_blank">Like it, STAR ME</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Scala初识"><span class="nav-number">1.</span> <span class="nav-text">Scala初识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Absolute-Scala-Basics"><span class="nav-number">1.1.</span> <span class="nav-text">The Absolute Scala Basics</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Values-Variables-and-Types"><span class="nav-number">1.1.1.</span> <span class="nav-text">Values, Variables and Types</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Expressions"><span class="nav-number">1.1.2.</span> <span class="nav-text">Expressions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">Exercise</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Functions"><span class="nav-number">1.1.3.</span> <span class="nav-text">Functions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise-1"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">Exercise</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Type-Inference"><span class="nav-number">1.1.4.</span> <span class="nav-text">Type Inference</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Recursion"><span class="nav-number">1.1.5.</span> <span class="nav-text">Recursion</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Call-by-Name-and-Call-by-Value"><span class="nav-number">1.1.6.</span> <span class="nav-text">Call-by-Name and Call-by-Value</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Default-and-Named-Arguments"><span class="nav-number">1.1.7.</span> <span class="nav-text">Default and Named Arguments</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Smart-Operations-on-Strings"><span class="nav-number">1.1.8.</span> <span class="nav-text">Smart Operations on Strings</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-Oriented-Programming-in-Scala"><span class="nav-number">1.2.</span> <span class="nav-text">Object Oriented Programming in Scala</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-Oriented-Basics"><span class="nav-number">1.2.1.</span> <span class="nav-text">Object-Oriented Basics</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise-2"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">Exercise</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Syntactic-Sugar-Method-Notations"><span class="nav-number">1.2.2.</span> <span class="nav-text">Syntactic Sugar: Method Notations</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Method-Notations-Exercises"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">Method Notations (Exercises)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Scala-Objects"><span class="nav-number">1.2.3.</span> <span class="nav-text">Scala Objects</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Inheritance"><span class="nav-number">1.2.4.</span> <span class="nav-text">Inheritance</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单类继承"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">单类继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数重写"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">函数重写</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#super"><span class="nav-number">1.2.5.</span> <span class="nav-text">super</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Inheritance-Continued-Abstract-Classes-and-Traits"><span class="nav-number">1.2.6.</span> <span class="nav-text">Inheritance, Continued:  Abstract Classes and Traits</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Abstract-class"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">Abstract  class</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Traits"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">Traits</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Type-Hierarchy"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">Type Hierarchy</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Inheritance-Exercises-Implementing-Our-Own-Collection"><span class="nav-number">1.2.7.</span> <span class="nav-text">Inheritance Exercises Implementing Our Own Collection</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Generics"><span class="nav-number">1.2.8.</span> <span class="nav-text">Generics</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#variance-problem"><span class="nav-number">1.2.8.1.</span> <span class="nav-text">variance problem</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bounded-types"><span class="nav-number">1.2.8.2.</span> <span class="nav-text">bounded types</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Anonymous-Classes"><span class="nav-number">1.2.9.</span> <span class="nav-text">Anonymous Classes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-Oriented-Exercises-Expanding-Our-Collection"><span class="nav-number">1.2.10.</span> <span class="nav-text">Object-Oriented Exercises : Expanding Our Collection</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Case-Classes"><span class="nav-number">1.2.11.</span> <span class="nav-text">Case Classes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Scala-3-Enums"><span class="nav-number">1.2.12.</span> <span class="nav-text">Scala 3: Enums</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基础定义"><span class="nav-number">1.2.12.1.</span> <span class="nav-text">基础定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Enum中也可以有函数"><span class="nav-number">1.2.12.2.</span> <span class="nav-text">Enum中也可以有函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#constructor-args"><span class="nav-number">1.2.12.3.</span> <span class="nav-text">constructor args</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#companion-objects"><span class="nav-number">1.2.12.4.</span> <span class="nav-text">companion objects</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Enum的一些标准接口"><span class="nav-number">1.2.12.5.</span> <span class="nav-text">Enum的一些标准接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exceptions"><span class="nav-number">1.2.13.</span> <span class="nav-text">Exceptions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#throw-catch"><span class="nav-number">1.2.13.1.</span> <span class="nav-text">throw-catch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义异常"><span class="nav-number">1.2.13.2.</span> <span class="nav-text">自定义异常</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Packaging-and-Imports"><span class="nav-number">1.2.14.</span> <span class="nav-text">Packaging and Imports</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Functional-Programming-in-Scala"><span class="nav-number">1.3.</span> <span class="nav-text">Functional Programming in Scala</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#What’s-a-Function-Really"><span class="nav-number">1.3.1.</span> <span class="nav-text">What’s a Function, Really</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数式编程的特性"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">函数式编程的特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#function-value"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">function value</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#语法糖"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">语法糖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#练习"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">练习</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Anonymous-Functions"><span class="nav-number">1.3.2.</span> <span class="nav-text">Anonymous Functions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#语法糖-1"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">语法糖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise-3"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">Exercise</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Higher-Order-Functions-and-Curries"><span class="nav-number">1.3.3.</span> <span class="nav-text">Higher-Order-Functions and Curries</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#多个参数列表"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">多个参数列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercises"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">Exercises</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-flatMap-filter-and-for-comprehensions"><span class="nav-number">1.3.4.</span> <span class="nav-text">map, flatMap, filter and for-comprehensions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#多重循环"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">多重循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#发散"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">发散</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#A-Collections-Overview"><span class="nav-number">1.3.5.</span> <span class="nav-text">A Collections Overview</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#mutable-collection架构图"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">mutable collection架构图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#immutable-collection-架构图"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">immutable collection 架构图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sequences-List-Array-Vector"><span class="nav-number">1.3.6.</span> <span class="nav-text">Sequences:  List, Array, Vector</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Ranges"><span class="nav-number">1.3.6.1.</span> <span class="nav-text">Ranges</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#List"><span class="nav-number">1.3.6.2.</span> <span class="nav-text">List</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Array"><span class="nav-number">1.3.6.3.</span> <span class="nav-text">Array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Vector"><span class="nav-number">1.3.6.4.</span> <span class="nav-text">Vector</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tuples-and-Maps"><span class="nav-number">1.3.7.</span> <span class="nav-text">Tuples and Maps</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Tuples"><span class="nav-number">1.3.7.1.</span> <span class="nav-text">Tuples</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Maps"><span class="nav-number">1.3.7.2.</span> <span class="nav-text">Maps</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#functionals-on-maps"><span class="nav-number">1.3.7.2.1.</span> <span class="nav-text">functionals on maps</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#map与其结构之间的转换"><span class="nav-number">1.3.7.2.2.</span> <span class="nav-text">map与其结构之间的转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#groupBy函数"><span class="nav-number">1.3.7.2.3.</span> <span class="nav-text">groupBy函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise-4"><span class="nav-number">1.3.7.3.</span> <span class="nav-text">Exercise</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Options"><span class="nav-number">1.3.8.</span> <span class="nav-text">Options</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用-getOrElse-方法"><span class="nav-number">1.3.8.1.</span> <span class="nav-text">使用 getOrElse() 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#functions-on-Options"><span class="nav-number">1.3.8.2.</span> <span class="nav-text">functions on Options</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#for-comprehensions"><span class="nav-number">1.3.8.3.</span> <span class="nav-text">for-comprehensions</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Handling-Failure"><span class="nav-number">1.3.9.</span> <span class="nav-text">Handling Failure</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pattern-Matching"><span class="nav-number">1.4.</span> <span class="nav-text">Pattern Matching</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Pattern-Matching-1"><span class="nav-number">1.4.1.</span> <span class="nav-text">Pattern Matching</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解耦合"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">解耦合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PM在继承类中的应用"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">PM在继承类中的应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise-5"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">Exercise</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ALL-the-Patterns"><span class="nav-number">1.4.2.</span> <span class="nav-text">ALL the Patterns</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#constants"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">constants</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#variables"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">variables</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#wildcard"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">wildcard</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tuples"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">tuples</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#case-classes"><span class="nav-number">1.4.2.5.</span> <span class="nav-text">case classes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#list"><span class="nav-number">1.4.2.6.</span> <span class="nav-text">list</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#type"><span class="nav-number">1.4.2.7.</span> <span class="nav-text">type</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#name-binding"><span class="nav-number">1.4.2.8.</span> <span class="nav-text">name binding</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#multi-patterns"><span class="nav-number">1.4.2.9.</span> <span class="nav-text">multi-patterns</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#if-guards"><span class="nav-number">1.4.2.10.</span> <span class="nav-text">if guards</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注明"><span class="nav-number">1.4.2.11.</span> <span class="nav-text">注明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Patterns-Everywhere"><span class="nav-number">1.4.3.</span> <span class="nav-text">Patterns Everywhere</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#在try-catch中"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">在try-catch中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在-for-中"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">在 for 中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Tuple-List"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">Tuple, List</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#partial-function"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">partial function</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="true"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
 <!--
  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">1290.9k</span>
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>



-->
        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('-1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->


  
  

  
  


  

  

</body>
</html>
