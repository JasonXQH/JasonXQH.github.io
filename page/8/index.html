<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=">


  <link rel="mask-icon" href="/images/logo.svg?v=" color="#222">














<meta property="og:type" content="website">
<meta property="og:title" content="Jason‘s Blog">
<meta property="og:url" content="https://jasonxqh.github.io/page/8/index.html">
<meta property="og:site_name" content="Jason‘s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '',
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    fancybox: false,
    tabs: ,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: 'undefined',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>







  <title>Jason‘s Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', '[object Object]', 'auto');
  ga('send', 'pageview');
</script>





<meta name="generator" content="Hexo 4.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">
  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
<a href="https://github.com/JasonXQH/JasonXQH.github.io" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jason‘s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/%20" rel="section">
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/12/06/Django%E5%AD%A6%E4%B9%A02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/" itemprop="url">Django学习2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-12-06T18:39:25+08:00">
                2021-12-06
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-01-17T21:20:18+08:00">
                2022-01-17
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Django学习2"><a href="#Django学习2" class="headerlink" title="Django学习2"></a>Django学习2</h1><h3 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h3><p>我们为了保留第一部分代码，因此新开一个文件夹，叫storefront2, 并在里面创建虚拟环境。</p>
<p>创建好以后，VSCode可能不会把该虚拟环境当做默认虚拟环境，因此我们需要设置一下：</p>
<p>command+p 并在搜索栏敲&gt; 呼出命令面板. 选择 python: select Interpreter选项，点击输入解释器路径，并输入当前文件夹下的虚拟环境的路径(通过pipenv shell可查看)，就设置完成了，如下图所示</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/1.png" style="zoom:67%;"></p>
<h2 id="Building-RESTful-APIs-with-Django-REST-Framework"><a href="#Building-RESTful-APIs-with-Django-REST-Framework" class="headerlink" title="Building. RESTful APIs with Django REST Framework"></a>Building. RESTful APIs with Django REST Framework</h2><h3 id="What-are-RESTful-APIs"><a href="#What-are-RESTful-APIs" class="headerlink" title="What are RESTful APIs"></a>What are RESTful APIs</h3><p>之前我们看到的数据只有Admin才有权限查看。现在我们要写一些接口，能让我们以非Admin的角色来获取数据库中的信息。这些接口就是API。打一个不恰当的比方，API就好像是电视遥控板中的一个按键。</p>
<p>RESTful API则是对API提出了一下几点要求</p>
<ul>
<li>Fast</li>
<li>Scalable</li>
<li>Reliable</li>
<li>Easy to understand</li>
<li>Easy to change</li>
</ul>
<p>首先，我们要了解一些基本概念：</p>
<h3 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h3><p>RESTful API 中的 Resources 概念就好像是我们在application中创建的对象一样。浏览器能通过 URL(Uniform Resource Locator) 访问到 Resources，URL就好像是这些资源的地址。</p>
<p>比如说，我想访问 products 数据，那么，我们的URL可以是这样的：<code>localhost:9000/products</code></p>
<p>或者，products中的具体数据,比如<code>localhost:9000/products/1</code></p>
<p>再者，Resources中也可能有Resources，比如说一个特定的产品有很多评测，那么url可以是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">localhost:9000&#x2F;products&#x2F;1&#x2F;reviews</span><br><span class="line">localhost:9000&#x2F;products&#x2F;1&#x2F;reviews&#x2F;1</span><br></pre></td></tr></table></figure>
<h3 id="Resource-Representations"><a href="#Resource-Representations" class="headerlink" title="Resource Representations"></a>Resource Representations</h3><p>当client用URL访问Resources的时候，后端就需要向客户回传这些Resources</p>
<p>一般，Resources 传给前端的格式是：HTML, XML, JSON。这些我们都比较熟悉了。</p>
<h3 id="HTTP-Methods"><a href="#HTTP-Methods" class="headerlink" title="HTTP Methods"></a>HTTP Methods</h3><p>HTTP主要有几种请求方法：</p>
<ul>
<li>GET: 用来获取数据</li>
<li>POST: 创建数据，比如<code>/products</code></li>
<li>PUT: 更新数据，如果要修改所有的对象，就要使用PUT, <code>/products</code></li>
<li>PATCH: 更新一部分数据, 比如只修改第一个对象，那么就要使用PATCH，<code>/products/1</code></li>
<li>DELETE：删除数据, 比如<code>/products/1</code></li>
</ul>
<h3 id="Installing-Django-REST-Framework"><a href="#Installing-Django-REST-Framework" class="headerlink" title="Installing Django REST Framework"></a>Installing Django REST Framework</h3><p>我们需要用这行代码下载Django REST Framework, 这样写起API就方便很多,</p>
<p><code>pipenv install djangorestframework</code> </p>
<p>下载完成后，我们要在APP中注册：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">'rest_framework'</span>,</span><br><span class="line">		<span class="comment">#...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="Creating-API-Views"><a href="#Creating-API-Views" class="headerlink" title="Creating API Views"></a>Creating API Views</h3><p>现在我们来创建 <code>127.0.0.1:9000/store/products</code> 对应的API</p>
<p>首先要明白，Django有自己的HttpRequest和HttpResponse模块，同时，Django Rest Framework也有自己的Request和Response模块。在这个项目中我们主要使用后两者，因为更方便，实现的功能也更强</p>
<p>其次，我们要把Django框架理解成层级访问，最高层就是我们创建的storefront，然后是storefront下面的各个注册的app，最后是app中的各种Object(Resources)。我们通过URL访问的时候，也是要”层级访问“</p>
<p><code>127.0.0.1:9000/</code> 访问的就是最顶层 storefront ，如果我们要访问storefront中的store，需要在storefront里面的<code>urls.py</code>注册<code>store/</code> ,如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">'playground/'</span>, include(<span class="string">'playground.urls'</span>)),</span><br><span class="line">    path(<span class="string">'store/'</span>, include(<span class="string">'store.urls'</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>再者，我们如果要访问store中的products对象，我们就需要在store里面的<code>urls.py</code> 中注册<code>products/</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line"><span class="comment"># URLConf</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'products/'</span>, views.product_list)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>最后，我们在view中编写api，来处理client通过URL这个“地址”发送来的请求：在这里，我使用了<em>rest_framework</em>中的<code>api_view</code>  这个修饰器，当api被<code>@api_view</code>修饰后，里面的request就会自动替换成<em>rest_framework</em> 中更简介、强大的request对象。</p>
<p>然后，我们用 <em>rest_framework</em> 中的 <code>Response</code> 来替换 <em>django.http</em> 中的<code>HttpResponse</code>,这样，返回的就是一个 <strong>Brosable API</strong>对象，非常简洁美观，一目了然：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> rest_framework.decorators <span class="keyword">import</span> api_view</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@api_view()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product_list</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Response(<span class="string">'OK'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/2.gif"></p>
<p>如果使用Django的HttpResponse，那么返回的仅仅是一个”OK”,但如果用的是<em>rest_framework</em> 的Response，就会显示我们的Http method， URL，以及Response的报文。同时，也可以以切换为json格式，查看浏览器真正会显示的画面，也就是”OK”</p>
<h4 id="product-details"><a href="#product-details" class="headerlink" title="product details"></a>product details</h4><p>接下来，我们再来创建一个API：product detail,用来访问每个Product特定的信息</p>
<p>首先我们编写 view: 功能很简单，从client发来的URL中找到参数id，然后返回这个id的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@api_view()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product_detail</span><span class="params">(request,id)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Response(id)</span><br></pre></td></tr></table></figure>
<p>然后，我们在urls.py中注册路由：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">  	<span class="comment">#...</span></span><br><span class="line">    path(<span class="string">'products/&lt;int:id&gt;/'</span>, views.product_detail)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>注意，因为我们访问的是每个product的编号，因此只能是整数类型，为了防止出现类似于<code>/store/products/1/</code>的非法请求出现，我们在注册路由的时候，要给参数id添加一个限制条件：<code>&lt;int:id&gt;</code></p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/3.gif"></p>
<h3 id="Creating-Serializers"><a href="#Creating-Serializers" class="headerlink" title="Creating Serializers"></a>Creating Serializers</h3><p>我们要将Object转换为浏览器可以处理的JSON格式的信息，首先我们需要 Serializer(序列化工具) 将这些对象信息 转换成字典，然后使用 REST Framework中的JSONRenderer模块将字典转换成JSON。</p>
<p>现在，我们就来学习如何创建一个Serializer，它的样子和models很像，只不过model负责的是和数据库<strong>对接</strong>，而serializer负责的是和client<strong>对接</strong>。然而，数据库中的某些信息我们是不希望用户去了解的，因此在<code>serializer</code>中一般不会提供产品的所有信息</p>
<p>首先我们要在store中创建<code>serializers.py</code> ,需要用到<em>rest_framework</em> 中的 <code>serializers</code> 模块.在下面这个网站中，有<code>serializers</code>提供的数据类型：</p>
<p><a href="https://www.django-rest-framework.org/api-guide/fields/" target="_blank" rel="noopener">https://www.django-rest-framework.org/api-guide/fields/</a></p>
<p>这里，我们只想用户开放了三个字段信息：产品id，产品名称以及产品单价。因此可以这么写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductSerializers</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    id = serializers.IntegerField()</span><br><span class="line">    title = serializers.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    unit_price = serializers.DecimalField(max_digits=<span class="number">6</span>, decimal_places=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Serializing-Objects"><a href="#Serializing-Objects" class="headerlink" title="Serializing Objects"></a>Serializing Objects</h3><p>在这个view中，我们要根据url中的id，从数据库中取出对象；然后，把这个对象交给<code>ProductSerializers</code> 去序列化，最后，把序列化后的数据传给Response，它会将其转换为JSON格式的文档回传给client</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Product</span><br><span class="line"><span class="keyword">from</span> .serializers <span class="keyword">import</span> ProductSerializers</span><br><span class="line"></span><br><span class="line"><span class="meta">@api_view()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product_detail</span><span class="params">(request, id)</span>:</span></span><br><span class="line">    product = Product.objects.get(pk=id)</span><br><span class="line">    serializers = ProductSerializers(product)</span><br><span class="line">    <span class="keyword">return</span> Response(serializers.data)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/4.png"></p>
<p>我们看到<code>unit_price</code> 是字符串类型的，我们需要设置一下将其变为数字类型：在setting.py中加入如下设置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'COERCE_DECIMAL_TO_STRING'</span>: <span class="literal">False</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，参数如果正确的话，是能从数据库中获取信息的，但是，如果参数是0呢？Django会报错，而不是返回一个显示错误信息的JSON文档。对此，我们有两种解决方法：</p>
<ul>
<li>用<em>rest_framework</em>中的 <code>status</code> 模块</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@api_view()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product_detail</span><span class="params">(request, id)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        product = Product.objects.get(pk=id)</span><br><span class="line">        serializers = ProductSerializers(product)</span><br><span class="line">        <span class="keyword">return</span> Response(serializers.data)</span><br><span class="line">    <span class="keyword">except</span> Product.DoesNotExist:</span><br><span class="line">        <span class="keyword">return</span> Response(status=status.HTTP_404_NOT_FOUND)</span><br></pre></td></tr></table></figure>
<ul>
<li>用<code>Django.shortcut</code> 中的 <code>get_object_or_404</code> 方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@api_view()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product_detail</span><span class="params">(request, id)</span>:</span></span><br><span class="line"></span><br><span class="line">    product = get_object_or_404(Product, pk=id)</span><br><span class="line">    serializer = ProductSerializer(product)</span><br><span class="line">    <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/5.png"></p>
<p>然后，我们再注册一个<code>store/products/</code> 路由，显示所有products信息。因此，我们可以用<code>get_list_or_404</code>,它是用来获取数据库中所有对象的方法，注意，当queryset中有很多元素的时候，需要设置 <code>many=True</code>,这样，serializer就会遍历queryset来执行操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@api_view()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product_list</span><span class="params">(request)</span>:</span></span><br><span class="line">    queryset = get_list_or_404(Product)</span><br><span class="line">    serializer = ProductSerializer(queryset, many=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure>
<h3 id="Creating-Custom-Serializer-Fields"><a href="#Creating-Custom-Serializer-Fields" class="headerlink" title="Creating Custom Serializer Fields"></a>Creating Custom Serializer Fields</h3><p>首先，我们要明白API Model是不等于Data Model的，后者是应用实现的一个部分，而前者是要给外界展示的一个部分。因此，展示的部分可以在model本身的基础上做一个计算，比如说，我们可以再Serializer里给product增加一个税后的价钱：</p>
<p>我们这里创建了一个计算税后价格的函数<code>calculate_tax</code>, 即把原价乘以1.1后返回(这里，由于1.1是浮点数，需要用<code>Decimal(1.1)</code>包裹一下)。然后， 再用<code>SerializerMethodField</code> 客制化，将<code>method_name</code>参数设定为我们自己写的函数的名称：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    id = serializers.IntegerField()</span><br><span class="line">    title = serializers.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    price = serializers.DecimalField(</span><br><span class="line">        max_digits=<span class="number">6</span>, decimal_places=<span class="number">2</span>, source=<span class="string">'unit_price'</span>)</span><br><span class="line">    price_with_tax = serializers.SerializerMethodField(</span><br><span class="line">        method_name=<span class="string">'calculate_tax'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate_tax</span><span class="params">(self, product: models.Product)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> product.unit_price * Decimal(<span class="number">1.1</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意了，这里我将<code>unit_price</code>改成了<code>price</code>,但是model中并没有这个字段，因此直接查询会报错。我们需要设定<code>source</code>参数为原来的字段</p>
</blockquote>
<h3 id="Serializing-Relationships"><a href="#Serializing-Relationships" class="headerlink" title="Serializing Relationships"></a>Serializing Relationships</h3><h4 id="使用serializers内置方法"><a href="#使用serializers内置方法" class="headerlink" title="使用serializers内置方法"></a>使用serializers内置方法</h4><p>如果我想在Serilizer中显示一对一关系、一对多关系。比如，我想在ProductSerializer中显示产品属于的集合类型,我可以使用 <code>PrimaryKeyRelatedField</code>这个方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> store.models <span class="keyword">import</span> Product, Collection</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">   	<span class="comment"># ...</span></span><br><span class="line">    collection = serializers.PrimaryKeyRelatedField(</span><br><span class="line">        queryset=Collection.objects.all()</span><br><span class="line">    )</span><br><span class="line">		<span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>有时候，系统会发生报错，这是因为检查机制出了点问题，可以通过重启解决</p>
</blockquote>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/6.png"></p>
<p>但是，显示数字显然是不够的，我们想要显示collection的名称信息,因此我们可以用<code>StringRelatedField</code>方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    collection = serializers.StringRelatedField()</span><br></pre></td></tr></table></figure>
<p>但这样虽然能显示collection字符串，但是对每个product都会额外多出一个关于Collection的查询，导致性能异常低下。为了解决这个bug，我们需要在view中修改一下：将原来个<code>get_list_or_404</code>改为<code>Product.objects.select_related(&#39;collection&#39;).all()</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@api_view()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product_list</span><span class="params">(request)</span>:</span></span><br><span class="line">    queryset = Product.objects.select_related(<span class="string">'collection'</span>).all()</span><br><span class="line">		<span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/7.png"></p>
<h4 id="使用嵌套的Serializer对象："><a href="#使用嵌套的Serializer对象：" class="headerlink" title="使用嵌套的Serializer对象："></a>使用嵌套的Serializer对象：</h4><p>除了上面这种方法，我们还可以使用嵌套对象的方法，能展示的数据更多：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    id = serializers.IntegerField()</span><br><span class="line">    title = serializers.CharField(max_length=<span class="number">255</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">		<span class="comment"># ...</span></span><br><span class="line">    collection = CollectionSerializer()</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/8.png"></p>
<h3 id="Model-Serializers"><a href="#Model-Serializers" class="headerlink" title="Model Serializers"></a>Model Serializers</h3><p>我们发现，现在创建的Serializers和Models是非常相似的。为了节省代码，增加代码的可维护性，我们可以使用<code>ModelSerializer</code>这个类：</p>
<p>使用了这个类之后，我们需要在里面创建Meta class，在 Meta中，我们要确定model的类型，并确定要放到ModelSerializer的字段, 即设置fields数组</p>
<p>如果我们想覆盖的话，我们可以自己写要呈现的内容。比如说<code>collection</code>，如果我不采用嵌套对象的方法，ModelSerializer会默认使用外键的值。</p>
<p>此外还可以自己加入model中没有的值，比如<code>price_with_tax</code>,这是我们自己写的一个字段，也可以加到fields中去</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Collection</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'title'</span>  ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Product</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'title'</span>, <span class="string">'unit_price'</span>, <span class="string">'price_with_tax'</span>, <span class="string">'collection'</span>]</span><br><span class="line">    price_with_tax = serializers.SerializerMethodField(</span><br><span class="line">        method_name=<span class="string">'calculate_tax'</span>)</span><br><span class="line">    collection = CollectionSerializer()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate_tax</span><span class="params">(self, product: Product)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> product.unit_price * Decimal(<span class="number">1.1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Deserializing-Objects"><a href="#Deserializing-Objects" class="headerlink" title="Deserializing Objects"></a>Deserializing Objects</h3><p>有了从server到client的对对象的序列化，那么就有对应从client到server的反序列化。比如说我想创建一个新的product，就要求sever反序列化得到client传入的关于新产品的信息，将它们变成一个对象。</p>
<p>我们知道，GET 方法是用来请求数据的，POST方法是用来更新数据的，我们现在在<code>product_list</code> 中实现一下两种方式的不同逻辑。</p>
<p>首先，在<code>@api_view</code>中要列出这个api能处理的HTTP METHOD的类型.这里是<code>[&#39;GET&#39;,&#39;POST&#39;]</code>.</p>
<p>然后，我们要设计<code>if-else</code> 来处理不同的请求。这里，如果是GET，就返回product列表，如果是POST我们要验证数据，并将合法的数据插入数据库，这里我们先不做验证，并直接返回OK作为测试</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@api_view(['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product_list</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        queryset = Product.objects.select_related(<span class="string">'collection'</span>).all()</span><br><span class="line">        serializer = ProductSerializer(</span><br><span class="line">            queryset, many=<span class="literal">True</span>, context=&#123;<span class="string">'request'</span>: request&#125;)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        serializer = ProductSerializer(data=request.data)</span><br><span class="line">        <span class="comment"># serializer.validated_data</span></span><br><span class="line">        <span class="keyword">return</span> Response(<span class="string">'OK'</span>)</span><br></pre></td></tr></table></figure>
<p>最后，我们把 <code>http://127.0.0.1:9000/store/products/</code> 拉到最后，然后随便输入一个JSON格式的文件，提交后我们就会看到 RESPONSE报文，其HTTP method为POST。</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/10.png"></p>
<h3 id="Data-Validation"><a href="#Data-Validation" class="headerlink" title="Data Validation"></a>Data Validation</h3><p>现在我们来学习数据验证相关的问题。</p>
<h4 id="if-else-block"><a href="#if-else-block" class="headerlink" title="if-else block"></a>if-else block</h4><p>这个逻辑是这样的，首先，serializer需要调用<code>is_valid()</code>函数，如果通过，那么对就可以对validated_data进行保存等操作；如果不通过，我们这里就返回<code>serializer.errors</code> ,并附上状态码400</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        serializer = ProductSerializer(data=request.data)</span><br><span class="line">        <span class="keyword">if</span> serializer.is_valid():</span><br><span class="line">            serializer.validated_data</span><br><span class="line">            <span class="keyword">return</span> Response(<span class="string">'OK'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)</span><br></pre></td></tr></table></figure>
<p>测试结果如下图所示：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/11.png"></p>
<h4 id="raise-exception-True"><a href="#raise-exception-True" class="headerlink" title="raise_exception=True"></a>raise_exception=True</h4><p>我们可以用一种更简单的方法来取代if-else逻辑：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">  serializer = ProductSerializer(data=request.data)</span><br><span class="line">  serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">  serializer.validated_data</span><br><span class="line">  <span class="keyword">return</span> Response(<span class="string">"OK"</span>)</span><br></pre></td></tr></table></figure>
<p>效果是一样的</p>
<p>现在，如果输入正确的信息，我们想将其在终端打印出来:（注意，这里要考虑好collection的类型，如果是对象的话，collection的值应该是一个字典。这里我使用的是默认的 <code>PrimaryKeyRelatedField</code>，因此只输入了一个INT值</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"title"</span>:<span class="string">"a"</span>,</span><br><span class="line">  <span class="attr">"unit_price"</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="attr">"collection"</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/12.png"></p>
<p>我们发现，在终端打印出来的<code>serializer.validated_data</code> 是一个OrderedDict</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OrderedDict([(&#39;title&#39;, &#39;a&#39;), (&#39;unit_price&#39;, Decimal(&#39;1.00&#39;)), (&#39;collection&#39;, &lt;Collection: collection1&gt;)])</span><br><span class="line">[08&#x2F;Dec&#x2F;2021 09:58:32] &quot;POST &#x2F;store&#x2F;products&#x2F; HTTP&#x2F;1.1&quot; 200 16875</span><br></pre></td></tr></table></figure>
<p><em>rest_framework</em> 只提供给我们数据类型、是否为空这类简单的数据验证，如果我们要设计更加复杂的验证方法，需要在serializer.py中自己实现函数如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, data)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> data[<span class="string">'password'</span>] != data[<span class="string">'confirm_password'</span>]:</span><br><span class="line">        <span class="keyword">return</span> serializers.ValidationError(<span class="string">'passwords do not match'</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>
<h3 id="Saving-Objects"><a href="#Saving-Objects" class="headerlink" title="Saving Objects"></a>Saving Objects</h3><p>我们可以用 <code>ModelSerializer</code>中的<code>save</code>方法将浏览器发送过来的数据存入数据库</p>
<p>由于我们在创建的时候，inventory字段设置了最小值为1的验证器，因此我们需要把这些必填的值也加入到serializer中去：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Product</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'title'</span>, <span class="string">'description'</span>, <span class="string">'slug'</span>, <span class="string">'inventory'</span>,</span><br><span class="line">                  <span class="string">'unit_price'</span>, <span class="string">'price_with_tax'</span>, <span class="string">'collection'</span>]</span><br><span class="line">    price_with_tax = serializers.SerializerMethodField(</span><br><span class="line">        method_name=<span class="string">'calculate_tax'</span>)</span><br></pre></td></tr></table></figure>
<p>我们创建的产品如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"title"</span>:<span class="string">"a"</span>,</span><br><span class="line">  <span class="attr">"slug"</span>:<span class="string">"a"</span>,</span><br><span class="line">  <span class="attr">"unit_price"</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="attr">"collection"</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="attr">"inventory"</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提交后，Django就会保存了，非常方便</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/13.png"></p>
<h3 id="Updating-Objects"><a href="#Updating-Objects" class="headerlink" title="Updating Objects"></a>Updating Objects</h3><p>想要更新数据库中的信息，需要使用 PUT 或者PATCH 方法, 且需要对一个特定的product进行修改。因此，我们把这个逻辑封装在<code>product_detail</code> 这个api当中。</p>
<p>首先，我们还是要确定这个API负责的HTTP Method类型，这里，为了方便我们就只用PUT类型来更新数据</p>
<p>然后做一个方法判断，在PUT方法中，由于我们要对一个特定的数据进行修改，因此我们往<code>ProductSerializer</code>中传入的，不只是client递交过来的更新信息，还要这个目标对象的一个实例。因此，我们在if-else block之前就把product提取出来，然后传给<code>ProductSerializer</code>,返回一个更新后的product</p>
<p>接着就是对product进行数据验证，返回一个保存后的信息并保存</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@api_view(['GET', 'PUT'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product_detail</span><span class="params">(request, id)</span>:</span></span><br><span class="line">    product = get_object_or_404(Product, pk=id)</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        serializer = ProductSerializer(product)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">'PUT'</span>:</span><br><span class="line">        serializer = ProductSerializer(product, data=request.data)</span><br><span class="line">        serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        serializer.save()</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data,status=status.HTTP_201_CREATED)</span><br></pre></td></tr></table></figure>
<ul>
<li>递交前：</li>
</ul>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/14.png"></p>
<ul>
<li>递交后</li>
</ul>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/15.png"></p>
<p>我们发现，id=2的产品已经更新了。title前面多了个’+’ </p>
<h3 id="Deleting-Objects"><a href="#Deleting-Objects" class="headerlink" title="Deleting Objects"></a>Deleting Objects</h3><p>如果我们在<code>product_detail</code>中添加DELETE Method: <code>@api_view([&#39;GET&#39;, &#39;PUT&#39;,&#39;DELETE&#39;])</code></p>
<p>这时候，回到client，就会发现这里多出来一个DELETE按钮。这就是Brosable API带来的好处——方便简洁</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/16.png"></p>
<p>如果我们只写删除的逻辑，是会报错的，因为product是orderItem的外键，是保护关系。也就是说，如果不删除orderitem，就不能删除它引用的product。</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/18.png"></p>
<p>因此我们要这么处理逻辑，如果引用该产品的orderitem数量(用<code>product.orderitem_set</code>表示)大于0，我们就不能删除，并返回状态码 405，代表该方法对此情况不适用。如果等于0，那么放心删除，返回状态码204</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">elif request.method &#x3D;&#x3D; &#39;DELETE&#39;:</span><br><span class="line">        if product.orderitem_set.count() &gt; 0:</span><br><span class="line">            return Response(&#123;&#39;error&#39;: &#39;Product cannot be deleted because it is associated with orderitem&#39;&#125;,</span><br><span class="line">                            status&#x3D;status.HTTP_405_METHOD_NOT_ALLOWED)</span><br><span class="line">        product.delete()</span><br><span class="line">        return Response(status&#x3D;status.HTTP_204_NO_CONTENT)</span><br></pre></td></tr></table></figure>
<p>这样，如果起了冲突的话，就会收到这样的返回报文：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/19.png"></p>
<p>如果该product没有被引用过，就可以安全删除：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/17.png"></p>
<p>注意点：</p>
<p>在代码中，反向引用计算该产品的orderitem 可以用<code>product.orderitem_set</code> 来表示，但是这种表示不容易记住。我们可以通过修改<code>Orderitem</code>模型,在product字段中添加<code>related_name</code>属性来提高代码的可读性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderItem</span><span class="params">(models.Model)</span>:</span></span><br><span class="line"><span class="comment">#...</span></span><br><span class="line">    product = models.ForeignKey(</span><br><span class="line">        Product, on_delete=models.PROTECT, related_name=<span class="string">'orderitems'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> request.method == <span class="string">'DELETE'</span>:</span><br><span class="line">    <span class="keyword">if</span> product.orderitems.count() &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<h3 id="Exercise-Building-the-Collections-API"><a href="#Exercise-Building-the-Collections-API" class="headerlink" title="Exercise Building the Collections API"></a>Exercise Building the Collections API</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@api_view(['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">collection_list</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        queryset = Collection.objects.all()</span><br><span class="line">        serializer = CollectionSerializer(</span><br><span class="line">            queryset, many=<span class="literal">True</span>, context=&#123;<span class="string">'request'</span>: request&#125;)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        serializer = CollectionSerializer(data=request.data)</span><br><span class="line">        serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        serializer.save()</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data, status=status.HTTP_201_CREATED)</span><br><span class="line"></span><br><span class="line"><span class="meta">@api_view(['GET', 'PUT', 'DELETE'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">collection_detail</span><span class="params">(request, id)</span>:</span></span><br><span class="line">    collection = get_object_or_404(Product, pk=id)</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        serializer = CollectionSerializer(collection)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">'PUT'</span>:</span><br><span class="line">        serializer = CollectionSerializer(collection, data=request.data)</span><br><span class="line">        serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        serializer.save()</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data, status=status.HTTP_201_CREATED)</span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">'DELETE'</span>:</span><br><span class="line">        <span class="keyword">if</span> collection.products.count() &gt; <span class="number">0</span>:<span class="comment">#注意修改Product Model</span></span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'error'</span>: <span class="string">'Collection cannot be deleted because it is associated with products'</span>&#125;,</span><br><span class="line">                            status=status.HTTP_405_METHOD_NOT_ALLOWED)</span><br><span class="line">        collection.delete()</span><br><span class="line">        <span class="keyword">return</span> Response(status=status.HTTP_204_NO_CONTENT)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'products/'</span>, views.product_list),</span><br><span class="line">    path(<span class="string">'products/&lt;int:id&gt;/'</span>, views.product_detail),</span><br><span class="line">    path(<span class="string">'collections/'</span>, views.collection_list),</span><br><span class="line">    path(<span class="string">'collections/&lt;int:id&gt;/'</span>, views.collection_detail),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="Advanced-API-Concepts"><a href="#Advanced-API-Concepts" class="headerlink" title="Advanced API Concepts"></a>Advanced API Concepts</h2><p>在这一章我们将学习更多技术，帮助我们更快的编写API</p>
<h3 id="Class-based-Views"><a href="#Class-based-Views" class="headerlink" title="Class-based Views"></a>Class-based Views</h3><p>之前我们是单独创建View，即一个函数为单位进行对模型的操作。但是，如果是要处理很多HTTP Method的话，就会用到很多<code>if-else blocks</code> 这会让代码看起来非常杂乱。因此我们现在来学习 class-basesd Views</p>
<p>首先，要引入<code>APIView</code>, 然后，在这个类里面，我们可以定义各种方法的逻辑，每个方法写一个单独的函数。比如<code>def get</code>,<code>def post</code>. 函数内部的逻辑和之前if-else代码块内的逻辑是一致的。这样一来，我们就可以规避掉if-else的这种判断逻辑，让代码看起来更加整洁。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductList</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        queryset = Product.objects.select_related(<span class="string">'collection'</span>).all()</span><br><span class="line">        serializer = ProductSerializer(</span><br><span class="line">            queryset, many=<span class="literal">True</span>, context=&#123;<span class="string">'request'</span>: request&#125;)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        serializer = ProductSerializer(data=request.data)</span><br><span class="line">        serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        serializer.save()</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data, status=status.HTTP_201_CREATED)</span><br></pre></td></tr></table></figure>
<p>同理，我们也可以重写ProductDetail，但是注意了，因为要获取特定的product，所以需要在函数中再加一个参数：id</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductDetail</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, id)</span>:</span></span><br><span class="line">        product = get_object_or_404(Product, pk=id)</span><br><span class="line"></span><br><span class="line">        serializer = ProductSerializer(product)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, request, id)</span>:</span></span><br><span class="line">        product = get_object_or_404(Product, pk=id)</span><br><span class="line">        serializer = ProductSerializer(product, data=request.data)</span><br><span class="line">        serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        serializer.save()</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data, status=status.HTTP_201_CREATED)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, request, id)</span>:</span></span><br><span class="line">        product = get_object_or_404(Product, pk=id)</span><br><span class="line">        <span class="keyword">if</span> product.orderitems.count() &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'error'</span>: <span class="string">'Product cannot be deleted because it is associated with orderitem'</span>&#125;,</span><br><span class="line">                            status=status.HTTP_405_METHOD_NOT_ALLOWED)</span><br><span class="line">        product.delete()</span><br><span class="line">        <span class="keyword">return</span> Response(status=status.HTTP_204_NO_CONTENT)</span><br></pre></td></tr></table></figure>
<p>写完<code>class</code> 在url中还需要作相应修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URLConf</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'products/'</span>, views.ProductList.as_view()),</span><br><span class="line">    path(<span class="string">'products/&lt;int:id&gt;/'</span>, views.ProductDetail.as_view()),</span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h3><p>我们发现，对于Collection和Product，它们的view方法基本上是一模一样的。比如 product_list 和 collection_list的功能基本一样，就是从数据库中获取所有对象并返回；又比如 product_detail 和 collection_detail，都是访问特定的对象的具体信息。那么如此相同的逻辑，是否有一种方法可以将它们封装起来，我们就可以减少很多不必要的代码了。由此，我们来学习 Mixins(混合类)的概念。所谓混合类，顾名思义就是将很多操作都封装在一个类里面</p>
<p>首先，我们从 mixins的源码开始看起：混合类都放在<code>rest_framework.mixins</code>中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.mixins <span class="keyword">import</span> ListModelMixin,CreateModelMixin</span><br></pre></td></tr></table></figure>
<p>比如说，这个ListModelMixin，其源码如下所示，我们看到这个类中只有一个list函数。函数的逻辑和我们自己写的逻辑非常相似：首先，从数据库中创建一个queryset, 然后进行分页等操作，再送到Serializer中去序列化，并返回序列化后的数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListModelMixin</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    List a queryset.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">list</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        queryset = self.filter_queryset(self.get_queryset())</span><br><span class="line"></span><br><span class="line">        page = self.paginate_queryset(queryset)</span><br><span class="line">        <span class="keyword">if</span> page <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            serializer = self.get_serializer(page, many=<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">return</span> self.get_paginated_response(serializer.data)</span><br><span class="line"></span><br><span class="line">        serializer = self.get_serializer(queryset, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure>
<p>又比如说 CreateModelMixin: 里面的create函数逻辑和我们def put的逻辑一样。<br>首先把数据传入serializer创建序列化对象，然后进行数据验证，再进行保存操作，如果成功，最后返回HTTP 201</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateModelMixin</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Create a model instance.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        serializer = self.get_serializer(data=request.data)</span><br><span class="line">        serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        self.perform_create(serializer)</span><br><span class="line">        headers = self.get_success_headers(serializer.data)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perform_create</span><span class="params">(self, serializer)</span>:</span></span><br><span class="line">        serializer.save()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_success_headers</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">'Location'</span>: str(data[api_settings.URL_FIELD_NAME])&#125;</span><br><span class="line">        <span class="keyword">except</span> (TypeError, KeyError):</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>此外，还有几种 mixin：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>mixins</th>
<th>作用</th>
<th>对应http的请求方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mixins.ListModelMixin</td>
<td>定义list方法，返回一个queryset列表</td>
<td>GET</td>
</tr>
<tr>
<td>Mixins.CreateModelMixin</td>
<td>定义create方法，创建一个实例</td>
<td>POST</td>
</tr>
<tr>
<td>Mixins.RetrieveModelMixin</td>
<td>定义retrieve方法，返回一个具体的实例</td>
<td>GET</td>
</tr>
<tr>
<td>Mixins.UpdateModelMixin</td>
<td>定义update方法，对某个实例进行更新</td>
<td>PUT/PATCH</td>
</tr>
<tr>
<td>Mixins.DestroyModelMixin</td>
<td>定义delete方法，删除某个实例</td>
<td>DELETE</td>
</tr>
</tbody>
</table>
</div>
<p>在<a href="https://www.django-rest-framework.org/api-guide/generic-views/#mixins" target="_blank" rel="noopener">官网</a>上我们能找到更多信息</p>
<h3 id="Generic-Views"><a href="#Generic-Views" class="headerlink" title="Generic Views"></a>Generic Views</h3><p>在了解了mixins之后，我们需要再上一层，去了解Generic Views，也就是封装了Mixins的视图类。放在<code>rest_framework.generics</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from rest_framework.generics import ListCreateAPIView</span><br></pre></td></tr></table></figure>
<p>比如说，我们来看<code>ListCreateAPIView</code> 这个类。它里面封装了<code>ListModelMixin</code>和<code>CreateModelMixin</code> 这两个混合类，由此，我们可以用它来获取一个model中的所有对象信息，还可以创建新的对象。</p>
<p>此外，在这个类里面有 两个句柄函数(handler method)：get和post，get函数调用了从<code>ListModelMixin</code>继承下来的list方法；而post函数调用了从<code>CreateModelMixin</code>继承下来的<code>create</code>方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListCreateAPIView</span><span class="params">(mixins.ListModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                        mixins.CreateModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                        GenericAPIView)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Concrete view for listing a queryset or creating a model instance.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.list(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.create(request, *args, **kwargs)</span><br></pre></td></tr></table></figure>
<p>此外，在 <a href="https://www.django-rest-framework.org/api-guide/generic-views/" target="_blank" rel="noopener">官网</a> 上还有更多的Generic Views，比如<code>ListAPIView</code>,就仅仅提供get方法，而且是只读的；<code>RetrieveUpdateDestroyAPIView</code> 就提供 get,put,patch和delete四种方法。</p>
<p>那么，对于我们刚刚创建的 Class-based View ,我们就可以让它继承<code>ListCreateAPIView</code>类：由于里面已经封装了get和post函数。于是，我们只需要调用<code>get_queryset</code>和<code>get_serializer_class</code>这两个方法来获取queryset和serializer这两个对象就可以了。此外，为了让serializer获取到request的报文(这样就可以用其 去序列化、创建新对象)，我们需要使用<code>get_serializer_context</code> 方法，传入一个字典<code>{&#39;request&#39;: self.request}</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductList</span><span class="params">(ListCreateAPIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Product.objects.select_related(<span class="string">'collection'</span>).all()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_serializer_class</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> ProductSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_serializer_context</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'request'</span>: self.request&#125;</span><br></pre></td></tr></table></figure>
<p>我们甚至还能让这个类变得更简单。直接设置<code>queryset</code>和<code>serializer_class</code>这两个类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductList</span><span class="params">(ListCreateAPIView)</span>:</span></span><br><span class="line">    queryset = Product.objects.select_related(<span class="string">'collection'</span>).all()</span><br><span class="line">    serializer_class = ProductSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_serializer_context</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'request'</span>: self.request&#125;</span><br></pre></td></tr></table></figure>
<p>使用Generic View，不仅在保持原功能的情况下简化自己的代码，还会自己创建一张表单，方便我们创建新的product，我们再也不用苦逼的手写JSON了</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/21.png"></p>
<p>同样的，我们可以为Collection 创建  Generic Views. 如下所示：</p>
<p>这里，我们新加了一个字段<code>products_count</code>,用来统计有多少products属于该collection</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionList</span><span class="params">(ListCreateAPIView)</span>:</span></span><br><span class="line">    queryset = Collection.objects.annotate(</span><br><span class="line">        products_count=Count(<span class="string">'products'</span>)).all()</span><br><span class="line">    serializer_class = CollectionSerializer</span><br></pre></td></tr></table></figure>
<p>但是，当创建新的collection的时候，我希望products_count是一个只读的值，否则就乱了套了。因此，我们在<code>CollectionSerializer</code>里面，需要把products_count`设置为已读</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Collection</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'title'</span>, <span class="string">'products_count'</span>]</span><br><span class="line"></span><br><span class="line">    products_count = serializers.IntegerField(read_only=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>结果如下所示，我们可以看到collection中的<code>products_count</code>字段，但是要新建collection的话我们只能填写一个title字段：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/22.png"></p>
<h3 id="Customizing-Generic-Views"><a href="#Customizing-Generic-Views" class="headerlink" title="Customizing Generic Views"></a>Customizing Generic Views</h3><p>事实上我们可以客制化Generic Views。</p>
<p>对于ProductDetail这个View，我们需要用到 PUT、GET、DELETE这三个函数。其中，PUT和GET都是可以交给封装好的函数去执行的。但对于DELETE方法，我们写了自己的逻辑进去，就是要先做一个判断。</p>
<p>因此，我们不能用Generic View提供给我们的DELETE方法，需要自己重写DELETE，方法也很简单，就保留<code>def delete</code>即可。</p>
<p>修改完以后还没结束，运行会报错：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/23.png"></p>
<p>为了解决这个bug，我们可以修改url,把参数从id改为pk: <code>path(&#39;products/&lt;int:pk&gt;/&#39;, views.ProductDetail.as_view())</code>；或者在 <code>ProductDetail</code> 里面设置 <code>lookup_field</code>属性为id：<code>lookup_field=id</code>,这里我们选择前者</p>
<p>如果选择前者，那么在<code>delete</code>方法中，需要把参数id也改成pk，否则会导致参数不识别。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductDetail</span><span class="params">(RetrieveUpdateDestroyAPIView)</span>:</span></span><br><span class="line">    queryset = Product.objects.all()</span><br><span class="line">    serializer_class = ProductSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, request, pk)</span>:</span></span><br><span class="line">        product = get_object_or_404(Product, pk=pk)</span><br><span class="line">        <span class="keyword">if</span> product.orderitems.count() &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'error'</span>: <span class="string">'Product cannot be deleted because it is associated with orderitem'</span>&#125;,</span><br><span class="line">                            status=status.HTTP_405_METHOD_NOT_ALLOWED)</span><br><span class="line">        product.delete()</span><br><span class="line">        <span class="keyword">return</span> Response(status=status.HTTP_204_NO_CONTENT)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/24.gif"></p>
<p>现在，我们把CollectionDetail也修改一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionDetail</span><span class="params">(RetrieveUpdateDestroyAPIView)</span>:</span></span><br><span class="line"></span><br><span class="line">    queryset = Collection.objects.all()</span><br><span class="line">    serializer_class = CollectionSerializer</span><br><span class="line">		<span class="comment"># 记得修改url.py</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, request, pk)</span>:</span></span><br><span class="line">        collection = get_object_or_404(Collection, pk=pk)</span><br><span class="line">        <span class="keyword">if</span> collection.products.count() &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'error'</span>: <span class="string">'Collection cannot be deleted because it is associated with products'</span>&#125;,</span><br><span class="line">                            status=status.HTTP_405_METHOD_NOT_ALLOWED)</span><br><span class="line">        collection.delete()</span><br><span class="line">        <span class="keyword">return</span> Response(status=status.HTTP_204_NO_CONTENT)</span><br></pre></td></tr></table></figure>
<h3 id="ViewSets"><a href="#ViewSets" class="headerlink" title="ViewSets"></a>ViewSets</h3><p>我们来关注Product和Collection，这两个model都有两个Generic View——一个List用来取得所有信息，一个Detail来获得单独信息。在每个View里面，都需要定义queryset和serializer_class这两个属性，比较重复。因此，我们可以引入ViewSets(视图集)，顾名思义，他将很多view放在一个集合类里面，这个类提供了很多内置Minixs。这样，只需要确定一套queryset和serializer_class就能完成多个view的任务了。</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/25.png"></p>
<p>我们导入</p>
<p>然后来看看ModelViewSet的源码：<code>from rest_framework.viewsets import ModelViewSet</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelViewSet</span><span class="params">(mixins.CreateModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                   mixins.RetrieveModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                   mixins.UpdateModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                   mixins.DestroyModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                   mixins.ListModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                   GenericViewSet)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A viewset that provides default `create()`, `retrieve()`, `update()`,</span></span><br><span class="line"><span class="string">    `partial_update()`, `destroy()` and `list()` actions.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>我们看到，<code>ModelViewSet</code>里面继承了很多Mixins，提供了很多http 方法，是一个<strong>集大成者</strong></p>
<p>由此，我们可以让<code>ProductViewSet</code>和<code>CollectionViewSet</code>  继承 <code>ModelViewSet</code>,如下所示。这样就把两个View集合为一个ViewSet了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    queryset = Product.objects.all()</span><br><span class="line">    serializer_class = ProductSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_serializer_context</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'request'</span>: self.request&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, request, pk)</span>:</span></span><br><span class="line">        product = get_object_or_404(Product, pk=pk)</span><br><span class="line">        <span class="keyword">if</span> product.orderitems.count() &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'error'</span>: <span class="string">'Product cannot be deleted because it is associated with orderitem'</span>&#125;,</span><br><span class="line">                            status=status.HTTP_405_METHOD_NOT_ALLOWED)</span><br><span class="line">        product.delete()</span><br><span class="line">        <span class="keyword">return</span> Response(status=status.HTTP_204_NO_CONTENT)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果希望ViewSet中的信息是只读的，我们可以使用ReadOnlyModelViewSet类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    queryset = Collection.objects.annotate(</span><br><span class="line">        products_count=Count(<span class="string">'products'</span>)).all()</span><br><span class="line">    serializer_class = CollectionSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, request, pk)</span>:</span></span><br><span class="line">        collection = get_object_or_404(Collection, pk=pk)</span><br><span class="line">        <span class="keyword">if</span> collection.products.count() &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'error'</span>: <span class="string">'Collection cannot be deleted because it is associated with products'</span>&#125;,</span><br><span class="line">                            status=status.HTTP_405_METHOD_NOT_ALLOWED)</span><br><span class="line">        collection.delete()</span><br><span class="line">        <span class="keyword">return</span> Response(status=status.HTTP_204_NO_CONTENT)</span><br></pre></td></tr></table></figure>
<p>我们还要注意，对于ProductList，CollectionList这些View，是不能提供DELETE函数的，否则会出现删库跑路的情况。我们想要的是，给每一个特定的对象(ProductDetail)提供删除服务。</p>
<p>因此，我们不应该重写delete方法(这是对Products全适用的删除函数)，而要重写destroy方法，它是用来删除一个单独的实例的。</p>
<p>在修改过程中，我们需要修改如下逻辑，因为在destroy方法中，已经有获取实例的逻辑了，我们不需要再访问一次数据库去获取product，因此，我们可以反向思考：查找OrderItem中的实例是否与该product相关联。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> product.orderitems.count() &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'error'</span>: <span class="string">'Product cannot be deleted because it is associated with orderitem'</span>&#125;,</span><br></pre></td></tr></table></figure>
<p>最终修改后如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    queryset = Product.objects.all()</span><br><span class="line">    serializer_class = ProductSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_serializer_context</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'request'</span>: self.request&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">destroy</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> OrderItem.objects.filter(product_id=kwargs[<span class="string">'pk'</span>]).count() &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'error'</span>: <span class="string">'Product cannot be deleted because it is associated with orderitem'</span>&#125;,</span><br><span class="line">                            status=status.HTTP_405_METHOD_NOT_ALLOWED)</span><br><span class="line">        <span class="keyword">return</span> super().destroy(request, *args, **kwargs)</span><br></pre></td></tr></table></figure>
<p>修改完成后，程序是无法运行的，因为url并没有修改。那么，怎么让url定位到我们编写的ViewSet呢？我们接下来学习Routers路由的写法</p>
<h3 id="Routers"><a href="#Routers" class="headerlink" title="Routers"></a>Routers</h3><p>当我们使用ViewSet来集成View，就不用显式使用urlpatterns来注册url了。</p>
<h4 id="SimpleRouter"><a href="#SimpleRouter" class="headerlink" title="SimpleRouter"></a>SimpleRouter</h4><p>首先，我们导入DRF中的 routers 中的SimpleRouter类</p>
<p>然后，我们创建一个SimpleRouter实例，并将两个ViewSet注册进去</p>
<p>打印一下注册后router.urls支持的格式：发现router已经帮我们自动注册了四条 URLPattern</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ &lt;URLPattern &#39;^products&#x2F;$&#39; [name&#x3D;&#39;product-list&#39;]&gt;,</span><br><span class="line"> &lt;URLPattern &#39;^products&#x2F;(?P&lt;pk&gt;[^&#x2F;.]+)&#x2F;$&#39; [name&#x3D;&#39;product-detail&#39;]&gt;,</span><br><span class="line"> &lt;URLPattern &#39;^collections&#x2F;$&#39; [name&#x3D;&#39;collection-list&#39;]&gt;,</span><br><span class="line"> &lt;URLPattern &#39;^collections&#x2F;(?P&lt;pk&gt;[^&#x2F;.]+)&#x2F;$&#39; [name&#x3D;&#39;collection-detail&#39;]&gt;]</span><br></pre></td></tr></table></figure>
<p>最后，我们让 urlpatterns 等于 <code>router.urls</code> 也就是上面个数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.routers <span class="keyword">import</span> SimpleRouter,DefaultRouter</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line">router = SimpleRouter()</span><br><span class="line">router.register(<span class="string">'products'</span>, views.ProductViewSet)</span><br><span class="line">router.register(<span class="string">'collections'</span>, views.CollectionViewSet)</span><br><span class="line"></span><br><span class="line">urlpatterns = router.urls</span><br></pre></td></tr></table></figure>
<h4 id="DefaultRouter"><a href="#DefaultRouter" class="headerlink" title="DefaultRouter"></a>DefaultRouter</h4><p>如果我们使用的是 DefaultRouter 类，那么相比SimpleRouter会多出两个功能：</p>
<p>首先，如果我们访问 <code>http://127.0.0.1:9000/store/</code> 就会出现一个<strong>根目录</strong>，也就会展示出这个app下开放的api，如下图所示</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/26.png"></p>
<p>其次，如果我们访问<code>http://127.0.0.1:9000/store/products.json</code>,就会展示出所有products的JSON格式的文档信息：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/27.png"></p>
<h3 id="Building-the-Reviews-API"><a href="#Building-the-Reviews-API" class="headerlink" title="Building the Reviews API"></a>Building the Reviews API</h3><p>现在，我们要对product创建一个Review内容，即用户反馈。</p>
<p>首先，创建Review model</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Review</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    product = models.ForeignKey(</span><br><span class="line">        Product, on_delete=models.CASCADE, related_name=<span class="string">'reviews'</span>)</span><br><span class="line">    name = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    description = models.TextField()</span><br><span class="line">    date = models.DateField(auto_now_add=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>然后，创建相应的Serializer：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReviewSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Review</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'date'</span>, <span class="string">'name'</span>, <span class="string">'description'</span>, <span class="string">'product'</span>]</span><br></pre></td></tr></table></figure>
<p>接着，创建ViewSet</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReviewViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    queryset = Review.objects.all()</span><br><span class="line">    serializer_class = ReviewSerializer</span><br></pre></td></tr></table></figure>
<p>最后，注册路由，但是我们发现，Product和Review是一对多的关系，因此我们需要在检索单个product的url  <code>http://localhost:9000/store/products/1/</code> 后面，再加上对Review的检索。这就是我们接下来要学习的嵌套路由</p>
<h3 id="Nested-Routers"><a href="#Nested-Routers" class="headerlink" title="Nested Routers"></a>Nested Routers</h3><p>首先，我们需要下载实现嵌套路由的包： <code>pipenv install drf-nested-routers</code></p>
<p>具体教程在<a href="https://github.com/alanjds/drf-nested-routers" target="_blank" rel="noopener">https://github.com/alanjds/drf-nested-routers</a> 可以找到：</p>
<p>我们要实现的功能如下，前两行是通过domain pk找到单独的domain</p>
<p>第三行是找到关于此domain的所有nameservers</p>
<p>第四行是通过nameserver pk来找到关于此domain的特定的nameserver</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;domain&#x2F; &lt;- Domains list</span><br><span class="line">&#x2F;domain&#x2F;&#123;pk&#125;&#x2F; &lt;- One domain, from &#123;pk&#125;</span><br><span class="line">&#x2F;domain&#x2F;&#123;domain_pk&#125;&#x2F;nameservers&#x2F; &lt;- Nameservers of domain from &#123;domain_pk&#125;</span><br><span class="line">&#x2F;domain&#x2F;&#123;domain_pk&#125;&#x2F;nameservers&#x2F;&#123;pk&#125; &lt;- Specific nameserver from &#123;pk&#125;, of domain from &#123;domain_pk&#125;</span><br></pre></td></tr></table></figure>
<p>实现逻辑如下，首先，创建一个SimpleRouter实例，并注册domain，这都是前置操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># urls.py</span></span><br><span class="line"><span class="keyword">from</span> rest_framework_nested <span class="keyword">import</span> routers</span><br><span class="line"><span class="keyword">from</span> views <span class="keyword">import</span> DomainViewSet, NameserverViewSet</span><br><span class="line">(...)</span><br><span class="line"></span><br><span class="line">router = routers.SimpleRouter()</span><br><span class="line">router.register(<span class="string">'domains'</span>, DomainViewSet)</span><br></pre></td></tr></table></figure>
<p>接下来，我们要使用到上面导入的routers模块中的<code>NestedSimpleRouter</code>类，我们要传入三个参数：</p>
<ul>
<li>第一个参数是parent router,也就是之前注册的关于domain的路由；</li>
<li>第二个参数是子路由的前缀,也就是<code>http://localhost:9000/store/products/1/reviews/1/</code>中的<code>products</code></li>
<li>第三个参数是lookup查询参数，这个嵌套路由要先查询domain</li>
</ul>
<p>也就是说，这三个参数我们就可以理解为 父路由、”父类名+s”、loopup=”父类名”</p>
<p>然后，我们在这个<code>NestedSimpleRouter</code>中注册nameservers，和<code>NameserverViewSet</code>相对应。<br>basename 参数是一种名字模式,它是可选的，设置了这个参数以后，可以为我们提供命名View的选项。这里我们选择<code>domain-nameservers</code>, 那么就会自动生成两个name:<code>domain-nameservers-list</code>,<code>domain-nameservers-detail</code>。</p>
<p>最后，我们创建两个urlpattern</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">domains_router = routers.NestedSimpleRouter(router,  <span class="string">'domains'</span>, lookup=<span class="string">'domain'</span>)</span><br><span class="line">domains_router.register(<span class="string">'nameservers'</span>, NameserverViewSet, basename=<span class="string">'domain-nameservers'</span>)</span><br><span class="line"><span class="comment"># 'basename' is optional. Needed only if the same viewset is registered more than once</span></span><br><span class="line"><span class="comment"># Official DRF docs on this option: http://www.django-rest-framework.org/api-guide/routers/</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">''</span>, include(router.urls)),</span><br><span class="line">    path(<span class="string">''</span>, include(domains_router.urls)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>在我们这个项目中，可以这么写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">router = routers.DefaultRouter()</span><br><span class="line">router.register(<span class="string">'products'</span>, views.ProductViewSet)</span><br><span class="line">router.register(<span class="string">'collections'</span>, views.CollectionViewSet)</span><br><span class="line"></span><br><span class="line">products_router = routers.NestedDefaultRouter(</span><br><span class="line">    router, <span class="string">'products'</span>, lookup=<span class="string">'products'</span>)</span><br><span class="line">products_router.register(<span class="string">'reviews'</span>, views.ReviewViewSet,</span><br><span class="line">                         basename=<span class="string">'product-reviews'</span>)</span><br><span class="line"><span class="comment"># 我们可以不用显式注册url，直接+就可以</span></span><br><span class="line">urlpatterns = router.urls + products_router.urls</span><br></pre></td></tr></table></figure>
<p>这里，我们设置的<code>basename=&#39;product-reviews&#39;</code>, 能提供的url模板如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[&lt;URLPattern <span class="string">'^products/(?P&lt;products_pk&gt;[^/.]+)/reviews/$'</span> [name=<span class="string">'product-reviews-list'</span>]&gt;,</span><br><span class="line"> &lt;URLPattern <span class="string">'^products/(?P&lt;products_pk&gt;[^/.]+)/reviews\.(?P&lt;format&gt;[a-z0-9]+)/?$'</span> [name=<span class="string">'product-reviews-list'</span>]&gt;,</span><br><span class="line"> &lt;URLPattern <span class="string">'^products/(?P&lt;products_pk&gt;[^/.]+)/reviews/(?P&lt;pk&gt;[^/.]+)/$'</span> [name=<span class="string">'product-reviews-detail'</span>]&gt;,</span><br><span class="line"> &lt;URLPattern <span class="string">'^products/(?P&lt;products_pk&gt;[^/.]+)/reviews/(?P&lt;pk&gt;[^/.]+)\.(?P&lt;format&gt;[a-z0-9]+)/?$'</span> [name=<span class="string">'product-reviews-detail'</span>]&gt;,</span><br><span class="line"> <span class="comment"># 下面两个是上层路由，不用管</span></span><br><span class="line"> &lt;URLPattern <span class="string">'^$'</span> [name=<span class="string">'api-root'</span>]&gt;,</span><br><span class="line"> &lt;URLPattern <span class="string">'^\.(?P&lt;format&gt;[a-z0-9]+)/?$'</span> [name=<span class="string">'api-root'</span>]&gt;]</span><br></pre></td></tr></table></figure>
<p>结果如下，我们可以在<code>http://localhost:9000/store/products/&lt;id:pk&gt;/reviews/</code>中看到reviews信息，并且能创建新的review</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/28.png"></p>
<p>但这个程序存在bug，因为url中，是先检索product，再在这个product里面创建review，所以我们在创建的时候根本不需要填写product字段，这个字段的值应该有url中的参数来决定。但是，如果在serializer里面直接把product给去掉，是不可以的，因为product_id 这个字段名是必须的。对此，我们可以这样修改：</p>
<p>我们可以在 View中，利用<code>get_serializer_context</code>函数将需要的参数(这里是product_pk) 传递给serializer：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReviewViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    queryset = Review.objects.all()</span><br><span class="line">    serializer_class = ReviewSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_serializer_context</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'product_id'</span>: self.kwargs[<span class="string">'products_id'</span>]&#125;</span><br></pre></td></tr></table></figure>
<p>然后，在ReviewSerializer中，我们要重写create函数。我们从view那里传过来的context中获得了product_id，并获得了表单提交上来的validated_data，那么现在就集齐了创建一个新Review实例的所有信息。</p>
<p>我们可以调用<code>objects.create</code>方法，将这些信息传入，如下所示</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReviewSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Review</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'date'</span>, <span class="string">'name'</span>, <span class="string">'description'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self,validated_data)</span>:</span></span><br><span class="line">        product_id = self.context[<span class="string">'product_id'</span>]</span><br><span class="line">        Review.objects.create(product_id=product_id,**validated_data)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/29.gif"></p>
<p>但是，还是有一个bug，就是现在不管是哪个product，在<code>products/&lt;product_id&gt;/reviews/</code>界面都可以获取所有的review信息:比如上面这个gif，我在访问<code>product/3/</code>的时候能看到对product1的评论。<br>因此，我们要对其做一个筛选，只选择该products的Review信息</p>
<h3 id="Filtering"><a href="#Filtering" class="headerlink" title="Filtering"></a>Filtering</h3><p>接下来，我们就来学习如何根据url中的参数来筛选信息：</p>
<p>比如说，我想筛选collection4中所有的product，可以这样来写<code>http://localhost:9000/store/products/?collection_id=4</code></p>
<p>现在我们来实现这个功能。我们不能直接在queryset中调用<code>.filter()</code>,因为这时候参数没办法获取。因此我们要调用<code>get_queryset</code>来返回客制化的 queryset</p>
<p>首先，我们要确认默认queryset仍然是<code>Product.objects.all()</code>,因为当没有<code>/?collection_id=&lt;id&gt;</code>这个参数的时候，仍然需要返回所有的product。</p>
<p>然后，我们要从url的参数中获取<code>collection_id</code>的值。url中的参数都在<code>quert_params</code>中，也就是<code>self.request.query_params.get(&#39;collection_id&#39;)</code>。注意了这里我们需要用get函数，而不能直接写<code>query_params[&#39;collection_id&#39;]</code> 后者是默认参数一定存在的，如果不存在就会报错；而前者当参数不存在的时候，collection_id的值就为空(None)</p>
<p>如果collection_id非空，那么我们就在默认的<code>queryset</code>上调用<code>filter</code> 筛选出目标对象，最后返回queryset</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#views.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    serializer_class = ProductSerializer</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">        queryset = Product.objects.all()</span><br><span class="line">        collection_id = self.request.query_params.get(<span class="string">'collection_id'</span>)</span><br><span class="line">        <span class="keyword">if</span> collection_id <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            queryset = queryset.filter(collection_id=collection_id)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> queryset</span><br><span class="line">   <span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p>但仅仅修改View是不够的，系统会报错。原因是在<code>ProductViewSet</code>中我们删去了queryset属性，变成了<code>get_queryset</code>函数，而router是根据这个属性默认生成basename的。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AssertionError: `basename` argument not specified, and could not automatically determine the name from the viewset, as it does not have a `.queryset` attribute.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>因此，我们对url.py也要做一定的修改，即给ProductViewSet注册的路由组一个basename参数(可以使products也可以是product)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#urls.py</span></span><br><span class="line">router = routers.DefaultRouter()</span><br><span class="line">router.register(<span class="string">'products'</span>, views.ProductViewSet, basename=<span class="string">'products'</span>)</span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p>效果如下图所示：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/30.gif"></p>
<h3 id="Generic-Filtering"><a href="#Generic-Filtering" class="headerlink" title="Generic Filtering"></a>Generic Filtering</h3><p>上面我们只筛选了一个collection字段，那么如果我们想筛选另外一个字段，是不是得改很多代码呢？这也太hard code了，因此我们现在来学习 Generic Filter</p>
<p>我们需要用到Django Filter 来帮助我们完成这个功能：<code>pipenv install django-filter</code>; 下载完后，记得在setting中注册：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">'django_filters'</span>,</span><br><span class="line">   <span class="comment">#...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>然后，我们在view中使用这个包，我们就不需要再调用<code>get_queryset</code>函数了，直接使用<code>queryset = Product.objects.all()</code>即可。</p>
<p>接着，我们引入<code>filter_backends = [DjangoFilterBackend]</code> ,并设置可供筛选的参数。这里除了collection_id还有unit_price可以选</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django_filters.rest_framework <span class="keyword">import</span> DjangoFilterBackend</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    queryset = Product.objects.all()</span><br><span class="line">    serializer_class = ProductSerializer</span><br><span class="line">    filter_backends = [DjangoFilterBackend]</span><br><span class="line">    filterset_fields = [<span class="string">'collection_id'</span>, <span class="string">'unit_price'</span>]</span><br></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/31.gif"></p>
<p>但这样筛选是不符合常理的，对于unit_price的筛选应该是一个区间而不是一个特定的值。因此，我们需要对其进行改进。在 <a href="https://django-filter.readthedocs.io/en/stable/" target="_blank" rel="noopener">django-filter文档</a>中我们可以获得答案</p>
<p>我们新建一个<code>filter.py</code>的文件，里面用来写自定义的筛选器：</p>
<ul>
<li>首先我们导入 FilterSet类，然后新建一个ProductFilter来继承这个类，</li>
<li>在这个类中，我们需要确定一些元数据: 确定该筛选器应用于哪个model，以及可供筛选的字段<ul>
<li>collection_id 这个字段不用改，因此我们就写<code>[&#39;exact&#39;]</code></li>
<li>unit_price 这个字段需要填写区间范围，因此可以这么写：<code>[&#39;gt&#39;, &#39;lt&#39;]</code> ,代表价格高于某个值或者低于某个值</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django_filters.rest_framework <span class="keyword">import</span> FilterSet</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Product</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductFilter</span><span class="params">(FilterSet)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Product</span><br><span class="line">        fields = &#123;</span><br><span class="line">            <span class="string">'collection_id'</span>: [<span class="string">'exact'</span>],</span><br><span class="line">            <span class="string">'unit_price'</span>: [<span class="string">'gt'</span>, <span class="string">'lt'</span>]</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>结果如下，非常方便，调试起来很快：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/32.gif"></p>
<h3 id="Searching"><a href="#Searching" class="headerlink" title="Searching"></a>Searching</h3><p>那么，对于title，description这样的字符串字段，我们就没有办法做一个筛选了，需要做查找。方法也很简单：</p>
<p>首先，我们可以使用<code>rest_framework.filters</code>中的SearchFilter模块</p>
<p>然后，在<code>filter_backends</code>中添加SearchFilter</p>
<p>最后，确定search_field属性即可，除了model本身的字段之外，还可以查找外键model的字段。查找不区分大小写，支持模糊查找，中间用逗号隔开即可，简直太方便了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.filters <span class="keyword">import</span> SearchFilter</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    queryset = Product.objects.all()</span><br><span class="line">    serializer_class = ProductSerializer</span><br><span class="line">    filter_backends = [DjangoFilterBackend, SearchFilter]</span><br><span class="line">    filterset_class = ProductFilter</span><br><span class="line">    search_fields = [<span class="string">'title'</span>, <span class="string">'description'</span>, <span class="string">'collection__title'</span>]</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/33.gif"></p>
<h3 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a>Sorting</h3><p>现在，我们还可以用filters中的OrderingFilter类帮助我们对 model进行筛选：</p>
<p>首先，我们导入<code>OrderingFilter</code></p>
<p>然后，把OrderingFilter 加到 filter_backends中去</p>
<p>最后，确定能排序的字段，即<code>ordering_fields</code> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.filters <span class="keyword">import</span> SearchFilter,OrderingFilter</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    queryset = Product.objects.all()</span><br><span class="line">    serializer_class = ProductSerializer</span><br><span class="line">    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]</span><br><span class="line">    filterset_class = ProductFilter</span><br><span class="line">    search_fields = [<span class="string">'title'</span>, <span class="string">'description'</span>, <span class="string">'collection__title'</span>]</span><br><span class="line">    ordering_fields = [<span class="string">'unit_price'</span>, <span class="string">'last_update'</span>]</span><br></pre></td></tr></table></figure>
<p>结果如下所示。我们发现，当对unit_price升序排列的时候，url为<code>/products/?ordering=unit_price</code> 而降序排列的时候，url为<code>/products/?ordering=-unit_price</code></p>
<p>而且，对于serializer没有提供的字段 <code>last_update</code>，也可以进行排序</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/34.gif"></p>
<h3 id="Pagination"><a href="#Pagination" class="headerlink" title="Pagination"></a>Pagination</h3><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><p>现在我们来讲分页，首先，引入pagination模块</p>
<p>然后设置<code>pagination_class</code>属性为<code>PageNumberPagination</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.pagination <span class="keyword">import</span> PageNumberPagination</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">    pagination_class = PageNumberPagination</span><br><span class="line">    <span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p>接着，我们在setting中确认每一页的数量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'COERCE_DECIMAL_TO_STRING'</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">'PAGE_SIZE'</span>: <span class="number">10</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下图所示，现在已经可以实现分页了，每一页中还会告诉你总数、下一页的url和前一页的url，分页结果放在 results 数组当中：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/35.png"></p>
<p>如果我们想设置全部使用 Django Restful Framework的model都采用分页的方式呈现，可以这样设置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'COERCE_DECIMAL_TO_STRING'</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">'DEFAULT_PAGINATION_CLASS'</span>: <span class="string">'rest_framework.pagination.PageNumberPagination'</span>,</span><br><span class="line">    <span class="string">'PAGE_SIZE'</span>: <span class="number">10</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，我甚至不需要在view中规定<code>pagination_class = PageNumberPagination</code>也可以进行分页</p>
<h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><p>但是如果我们不想对所有model进行分页，但是在settings中规定了<code>PAGE_SIZE</code>属性的话，系统会给一个warning，意思是如果规定了<code>PAGE_SIZE</code>,你最好规定一下<code>DEFAULT_PAGE_CLASS</code>。</p>
<p>为了规避这个warning，我们可以自己实现：创建一个 pagination.py 文件:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pagination.py </span></span><br><span class="line"><span class="keyword">from</span> rest_framework.pagination <span class="keyword">import</span> PageNumberPagination</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultPagination</span><span class="params">(PageNumberPagination)</span>:</span></span><br><span class="line">    page_size = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>然后，在view中，将原本的<code>PageNumberPagination</code>改为<code>DefaultPagination</code> 即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">		<span class="comment">#...</span></span><br><span class="line">    pagination_class = DefaultPagination</span><br><span class="line">    <span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<h2 id="Designing-and-Implementing-a-Shopping-Cart-API"><a href="#Designing-and-Implementing-a-Shopping-Cart-API" class="headerlink" title="Designing and Implementing a Shopping Cart API"></a>Designing and Implementing a Shopping Cart API</h2><h3 id="Designing-the-API"><a href="#Designing-the-API" class="headerlink" title="Designing the API"></a>Designing the API</h3><p>现在我们来设计一个购物车的API，主要包含以下几个功能：创建购物车、访问购物车的内容、删除购物车、往购物车中添加物品，往购物车更新物品的数量，往购物车删除物品</p>
<ul>
<li>Create a Cart 对于路人，不一定要登录，也可以创建一个购物车</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>METHOD</th>
<th>url</th>
<th>request</th>
<th>Response</th>
</tr>
</thead>
<tbody>
<tr>
<td>POST</td>
<td>/carts/</td>
<td>{}</td>
<td>cart</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Getting a Cart</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>METHOD</th>
<th>url</th>
<th>request</th>
<th>Response</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>/carts/:id</td>
<td>{}</td>
<td>cart</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Deleting a Cart</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>METHOD</th>
<th>url</th>
<th>request</th>
<th>Response</th>
</tr>
</thead>
<tbody>
<tr>
<td>DELETE</td>
<td>/carts/:id</td>
<td>{}</td>
<td>{}</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Adding an Item </li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>METHOD</th>
<th>url</th>
<th>request</th>
<th>Response</th>
</tr>
</thead>
<tbody>
<tr>
<td>POST</td>
<td>/carts/:id/items</td>
<td>{prodId,qty}</td>
<td>item</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Updating an Item 这里，我们要更新的话，只需要修改购物车内物品的数量，因此，我们使用PATCH方法</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>METHOD</th>
<th>url</th>
<th>request</th>
<th>Response</th>
</tr>
</thead>
<tbody>
<tr>
<td>PATCH</td>
<td>/carts/:id/items/:id</td>
<td>{qty}</td>
<td>{qty}</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Deleting an item</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>METHOD</th>
<th>url</th>
<th>request</th>
<th>Response</th>
</tr>
</thead>
<tbody>
<tr>
<td>DELETE</td>
<td>/carts/:id/items/:id</td>
<td>{}</td>
<td>{}</td>
</tr>
</tbody>
</table>
</div>
<p>我们创建两个类，一个来负责购物车的API，称为<code>CartViewSet</code>，一个来负责购物车中物品的API,称为<code>CartItemViewSet</code></p>
<h3 id="Revisiting-the-Data-Model"><a href="#Revisiting-the-Data-Model" class="headerlink" title="Revisiting the Data Model"></a>Revisiting the Data Model</h3><p>首先，我们要知道，购物车是一个对用户比较较敏感的信息，不能轻易地被其他人获取到这个信息，因此我们需要使用到GUID，即Globally Unique Identifier。是一种由算法生成的二进制长度为128位的数字标识符</p>
<p>首先我们引入uuid4，然后重写Cart Model的 id为UUIDField，默认值为uuid的引用。注意，这里不能使用<code>default = uuid64()</code> 因为这样会导致在创建migration的时候就生成了一个UUID的值 ，进而导致所有的cart都会使用同一个UUID。</p>
<p>对于CartItem，我们也需要进行修改，首先，可以给ForeignKey添加一个<code>related_name</code>属性<br>其次，我们需要给数据库增加一个限制：我们不允许在同一个cart中，有多个products。如果用户往购物车中添加相同的product，只改变 quantity的值。要在数据库里添加这个数据，我们可以设置元数据中的<code>unique_together</code>属性</p>
<blockquote>
<p> 这个元数据是非常重要的一个！它等同于数据库的联合约束！</p>
<p>举个例子，假设有一张用户表，保存有用户的姓名、出生日期、性别和籍贯等等信息。要求是所有的用户唯一不重复，可现在有好几个叫“张伟”的，如何区别它们呢？（不要和我说主键唯一，这里讨论的不是这个问题）</p>
<p>我们可以设置不能有两个用户在同一个地方同一时刻出生并且都叫“张伟”，使用这种联合约束，保证数据库能不能重复添加用户（也不要和我谈小概率问题）。在模型中用<code>unique_together</code>，也就是联合唯一！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_together &#x3D; [[&#39;name&#39;, &#39;birth_day&#39;, &#39;address&#39;]]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在这里，我们只要设置两个值即可：<code>unique_together = [[&#39;cart&#39;, &#39;product&#39;]]</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cart</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    id = models.UUIDField(primary_key=<span class="literal">True</span>, default=uuid4)</span><br><span class="line">    created_at = models.DateTimeField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartItem</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    cart = models.ForeignKey(</span><br><span class="line">        Cart, on_delete=models.CASCADE, related_name=<span class="string">'items'</span>)  <span class="comment"># cartitem_set</span></span><br><span class="line">    product = models.ForeignKey(Product, on_delete=models.CASCADE)</span><br><span class="line">    quantity = models.PositiveSmallIntegerField()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        unique_together = [[<span class="string">'cart'</span>, <span class="string">'product'</span>]]</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/20.png"></p>
<p>migrate后，两个数据表如上图所示，我们看到了cart id从原来的bigint变成了char(32); 并且cart_id和product_id之间加上了一个约束</p>
<h3 id="Creating-a-Cart"><a href="#Creating-a-Cart" class="headerlink" title="Creating a Cart"></a>Creating a Cart</h3><p>创建一个API的流程如下：</p>
<h4 id="Serializer"><a href="#Serializer" class="headerlink" title="Serializer"></a>Serializer</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Cart</span><br><span class="line">        fields = [<span class="string">'id'</span>]</span><br></pre></td></tr></table></figure>
<h4 id="View"><a href="#View" class="headerlink" title="View"></a>View</h4><p>在这里我们并不希望CartViewSet去继承<code>ModelViewSet</code>这个类，因为对于cart来说，我只希望创建一个购物车，获得一个购物车，删除一个购物车。 我并不想用GET方法请求<code>/carts/</code>来获得所有的购物车信息。否则，其他人的购物车我们也看得到。</p>
<p>基于此，我们要客制化 ViewSets。在这一part，我先使用CreateModelMixin：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartViewSet</span><span class="params">(CreateModelMixin, GenericViewSet)</span>:</span></span><br><span class="line">    queryset = Cart.objects.all()</span><br><span class="line">    serializer_class = CartSerializer</span><br></pre></td></tr></table></figure>
<h4 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h4><p>注册Router</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.register(<span class="string">'collections'</span>, views.CollectionViewSet)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/37.png"></p>
<p>我们发现，id仍然是可以由client设置的，这和我们将其设为默认自动填充的UUID不符，由此，我们可以在serializer中将id设为只读：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    id = serializers.UUIDField(read_only=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Cart</span><br><span class="line">        fields = [<span class="string">'id'</span>]</span><br></pre></td></tr></table></figure>
<p>这样就可以直接创建了，我们看到在这个<code>/carts/</code>下，是没有办法通过GET来获取cart信息的，但是可以通过POST创建一个cart：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/38.gif"></p>
<h3 id="Getting-a-Cart"><a href="#Getting-a-Cart" class="headerlink" title="Getting a Cart"></a>Getting a Cart</h3><p>在这个购物车里，我希望列出购物车的id，购物车中物品信息，以及整个购物车的商品总价值。首先，为了能获取到特定一个购物车的信息，我们需要使用<code>RetrieveModelMixin</code> </p>
<h4 id="CartItem"><a href="#CartItem" class="headerlink" title="CartItem"></a>CartItem</h4><p>为此，我们需要创建一个<code>CartItemSerializer</code> 来显示商品的详细信息，在这个Serializer中，我想展示的信息有：这个Item的id，这个商品的信息，购买数量，以及这件商品的总价值</p>
<p>但我们又不想展示这个商品的所有信息，因此我们还需要创建一个<code>SimpleProductSerializer</code>专门为cartitem展示信息。我们想展示在购物车中的商品信息时：商品id，商品名称，商品单价</p>
<p>然后，我们要计算这件cartitem的总金额，计算公式是：这件商品的数量乘以这件商品的价格。需要用到<code>serializers.SerializerMethodField()</code>这个方法。比如字段名是total_price，那么就需要创建一个<code>get_total_price</code>来计算这个字段</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleProductSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Product</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'title'</span>, <span class="string">'unit_price'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartItemSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    product = SimpleProductSerializer()</span><br><span class="line">    total_price = serializers.SerializerMethodField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_total_price</span><span class="params">(self, cart_item: CartItem)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> CartItem.quantity*CartItem.product.unit_price</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = CartItem</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'product'</span>, <span class="string">'quantity'</span>, <span class="string">'total_price'</span>]</span><br></pre></td></tr></table></figure>
<p>最后，我们要计算购物车的总金额，同样需要用到<code>serializers.SerializerMethodField()</code>方法。不过因为在这里items是个数组，因此我们需要用一些技巧来计算整个金额：</p>
<p>下面这行代码就是说，对于每个购物车里面的商品，我都计算出商品的数量和商品的价格，然后用<code>sum()</code>函数对其求和</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum([item.quantity*item.product.unit_price <span class="keyword">for</span> item <span class="keyword">in</span> cart.items.all()])</span><br></pre></td></tr></table></figure>
<p>整体效果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    id = serializers.UUIDField(read_only=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 我们希望items的信息在这里仅仅是呈现，之后会学怎么往里面添加商品</span></span><br><span class="line">    items = CartItemSerializer(many=<span class="literal">True</span>,read_only=<span class="literal">True</span>)</span><br><span class="line">    total_price = serializers.SerializerMethodField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_total_price</span><span class="params">(self, cart)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> sum([item.quantity*item.product.unit_price <span class="keyword">for</span> item <span class="keyword">in</span> cart.items.all()])</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Cart</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'items'</span>,<span class="string">'total_price'</span>]</span><br></pre></td></tr></table></figure>
<p>最后，为了避免找到cart，再去一个一个找cartitem，增加数据库负担，我们可以用<code>prefetch_related</code>方法在查找Cart的时候就将里面的item都检索出来。注意了，<code>prefetch_related</code>是找反向关系的(父找子)，<code>select_related</code>方法是查找正向关系的(子找父)，不要用错！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartViewSet</span><span class="params">(CreateModelMixin, RetrieveModelMixin, GenericViewSet)</span>:</span></span><br><span class="line">    queryset = Cart.objects.prefetch_related(<span class="string">'items'</span>).all()</span><br><span class="line">    serializer_class = CartSerializer</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/39.png"></p>
<h3 id="Deleting-a-Cart"><a href="#Deleting-a-Cart" class="headerlink" title="Deleting a Cart"></a>Deleting a Cart</h3><p>要删除很简单，我们加一个<code>RetrieveModelMixin</code>就可以了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartViewSet</span><span class="params">(CreateModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                  RetrieveModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                  DestroyModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                  GenericViewSet)</span>:</span></span><br><span class="line">    queryset = Cart.objects.prefetch_related(<span class="string">'items'</span>).all()</span><br><span class="line">    serializer_class = CartSerializer</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/40.gif"></p>
<h3 id="Getting-Cart-Items"><a href="#Getting-Cart-Items" class="headerlink" title="Getting Cart Items"></a>Getting Cart Items</h3><p>现在，我们要把之前学的嵌套路由用上了，我们希望在输入<code>/carts/&lt;cart_id&gt;/items</code> 的时候，可以显示这个购物车里面所有的商品信息; 在输入<code>/carts/&lt;cart_id&gt;/items/&lt;item_id&gt;</code> 的时候可以显示购物车中某商品特定的信息</p>
<p>首先，我们要创建一个CartItemViewSet，因为对Cart Item,我们可以有获取list，获取detail，增加和删除的功能，因此，这里我们直接让其继承自ModelViewSet即可。注意，由于我们要用嵌套循环，父类cart的id是从request来的，因此我们要重写<code>get_query</code>函数，筛选出id为<code>cart_pk</code>的所有商品。</p>
<p>此外，由于我们想获取该item的商品信息，我们需要用<code>selected_related</code>将商品一并找出。否则会增加很多重复查询。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartItemViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    serializer_class = CartItemSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> CartItem.objects\</span><br><span class="line">            .filter(cart_id=self.kwargs[<span class="string">'cart_pk'</span>])\</span><br><span class="line">            .select_related(<span class="string">'product'</span>)</span><br></pre></td></tr></table></figure>
<p>然后，我们注册嵌套路由，模式和之前的 Product-Review是一样的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">carts_router = routers.NestedDefaultRouter(router, <span class="string">'carts'</span>, lookup=<span class="string">'cart'</span>)</span><br><span class="line">carts_router.register(<span class="string">'items'</span>, views.CartItemViewSet, basename=<span class="string">'cart-items'</span>)</span><br><span class="line"></span><br><span class="line">urlpatterns = router.urls + products_router.urls+carts_router.urls</span><br></pre></td></tr></table></figure>
<p>结果如下图所示：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/41.gif"></p>
<h3 id="Adding-a-Cart-Item"><a href="#Adding-a-Cart-Item" class="headerlink" title="Adding a Cart Item"></a>Adding a Cart Item</h3><p>现在，我们要实现给购物车添加商品的功能,现在的表单，我们不是不能添加，但是超级麻烦，如下所示：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/42.png"></p>
<p>事实上，我们往一个购物车里添加信息，只需要两个字段就行了：product_id 和 quantity</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartItemViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_serializer_class</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.request.method == <span class="string">'POST'</span>:</span><br><span class="line">            <span class="keyword">return</span> AddCartItemSerializer</span><br><span class="line">        <span class="keyword">return</span> CartItemSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_serializer_context</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'cart_id'</span>: self.kwargs[<span class="string">'cart_pk'</span>]&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> CartItem.objects\</span><br><span class="line">            .filter(cart_id=self.kwargs[<span class="string">'cart_pk'</span>])\</span><br><span class="line">            .select_related(<span class="string">'product'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddCartItemSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    product_id = serializers.IntegerField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate_product_id</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> Product.objects.filter(pk=value).exists():</span><br><span class="line">            <span class="keyword">raise</span> serializers.ValidationError(<span class="string">'No Product with the given ID'</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        cart_id = self.context[<span class="string">'cart_id'</span>]</span><br><span class="line">        product_id = self.validated_data[<span class="string">'product_id'</span>]</span><br><span class="line">        quantity = self.validated_data[<span class="string">'quantity'</span>]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cart_item = CartItem.objects.get(</span><br><span class="line">                cart_id=cart_id, product_id=product_id)</span><br><span class="line">            cart_item.quantity += quantity</span><br><span class="line">            cart_item.save()</span><br><span class="line">        <span class="keyword">except</span> CartItem.DoesNotExist:</span><br><span class="line">            CartItem.objects.create(cart_id=cart_id, **self.validated_data)</span><br><span class="line">        <span class="keyword">return</span> self.instance</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = CartItem</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'product_id'</span>, <span class="string">'quantity'</span>]</span><br></pre></td></tr></table></figure>
<p>效果如下,如果product_id相同，那么数量就会在原来的基础上增加，并不会创建一个新的item</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/44.gif"></p>
<p>此外，我对quantity在model中加上了一个validator：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">quantity = models.PositiveSmallIntegerField(</span><br><span class="line">        validators=[MinValueValidator(<span class="number">1</span>)])</span><br></pre></td></tr></table></figure>
<p>这样，如果新增的product的数量为0，会报错：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/43.png"></p>
<h3 id="Updating-a-Cart-Item"><a href="#Updating-a-Cart-Item" class="headerlink" title="Updating a Cart Item"></a>Updating a Cart Item</h3><p>现在，我们想更新 Cart Item的数量，即quantity：</p>
<p>我们首先定位到一个特定cart中的特定item，发现这个item里面字段太多了，我们只想让顾客修改quantity字段即可：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/45.png"></p>
<p>方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#serializer.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpdateCartItemSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = CartItem</span><br><span class="line">        fields = [<span class="string">'quantity'</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#view.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartItemViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    http_method_names = [<span class="string">'get'</span>,<span class="string">'post'</span>,<span class="string">'patch'</span>,<span class="string">'delete'</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_serializer_class</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.request.method == <span class="string">'POST'</span>:</span><br><span class="line">            <span class="keyword">return</span> AddCartItemSerializer</span><br><span class="line">        <span class="keyword">if</span> self.request.method == <span class="string">'PATCH'</span>:</span><br><span class="line">            <span class="keyword">return</span> UpdateCartItemSerializer</span><br><span class="line">        <span class="keyword">return</span> CartItemSerializer</span><br></pre></td></tr></table></figure>
<p>效果如下，我利用PATCH方法，成功地完成了修改quantity的值</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/46.gif"></p>
<h3 id="Deleting-a-Cart-Item"><a href="#Deleting-a-Cart-Item" class="headerlink" title="Deleting a Cart Item"></a>Deleting a Cart Item</h3><p>由于在上面我们已经确定了，CartItemViewSet中可行的请求方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_method_names = [<span class="string">'get'</span>, <span class="string">'post'</span>, <span class="string">'patch'</span>, <span class="string">'delete'</span>]</span><br></pre></td></tr></table></figure>
<p>我们可以直接删除特定的item，效果如下：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/47.gif"></p>
<h2 id="Django-Authentication-System"><a href="#Django-Authentication-System" class="headerlink" title="Django Authentication System"></a>Django Authentication System</h2><h3 id="Django-Authentication-System-1"><a href="#Django-Authentication-System-1" class="headerlink" title="Django Authentication System"></a>Django Authentication System</h3><p>在这一章我们来学习Django的内置认证系统。并将学习如何客制化User model，让其为我们的 项目服务</p>
<p>在INSTALLED_APPS中默认就有<code>django.contrib.auth</code> 应用，在这个app中有很多模型：User，Group,Permission等</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">    <span class="string">'django.contrib.auth'</span>,</span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>
<p>在数据库中的<code>auth_user</code>表格里，我们也可以看到Django项目中的用户信息。里面有很多字段：密码、上次登录时间，是否是超级管理员，名字，邮箱，注册时间等。之后我们将介绍怎么客制化这张表格。</p>
<p>此外，我们还要了解Middleware, 下面是在这个项目中默认的中间件。在Django中，每当我们收到一个client发来的request的时候，request在经过view的时候，同时也在按照顺序将request一一经过下列中间件。每个中间件都可以往request中添加额外的信息或者直接返回一个Response(可能是发生错误了)。在这些中间件中我们看到有一个是用来处理用户信息的: <code>django.contrib.auth.middleware.AuthenticationMiddleware</code>, 这个中间件的功能，是用来读取request中用户的信息、并设置其属性的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="string">'debug_toolbar.middleware.DebugToolbarMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.security.SecurityMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions.middleware.SessionMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.common.CommonMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.csrf.CsrfViewMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.auth.middleware.AuthenticationMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages.middleware.MessageMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.clickjacking.XFrameOptionsMiddleware'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="Customizing-the-User-Model"><a href="#Customizing-the-User-Model" class="headerlink" title="Customizing the User Model"></a>Customizing the User Model</h3><p>现在我们来介绍两种客制化User Model的方法：</p>
<h4 id="Extend-User"><a href="#Extend-User" class="headerlink" title="Extend User"></a>Extend User</h4><p>第一种方法，是我新创建一个类(不妨叫做AppUser),让其继承自 User类. 使用这种方法，我们新加入的列就会显示在auth_user这张表格中。因此，如果要存储与身份验证(Authentication)相关的属性，建议使用这种方法</p>
<h4 id="Create-Profile"><a href="#Create-Profile" class="headerlink" title="Create  Profile"></a>Create  Profile</h4><p>第二种方法，是我创建一个Profile类，并让其建立和User的一对一联系。使用这种方法，将会有另一张表格，通过外键和auth_user相连接。因此，如果要存储与身份验证无关的属性(用户个人信息，比如用户生日、地址等)，建议使用这种方法。</p>
<p>此外，在不同的app中，我们也可以设计不同的Profile Model——在sales app中，我们可以用Customer来表示Profile，在hr app中，我们可以用Employee来表示Profile，在training app中，我们可以使用Student来表示Profile</p>
<p>由于第二种方法使用的场景更多，我们常常使用第二种方法作为客制化 User model的方法</p>
<h3 id="Extending-the-User-Model"><a href="#Extending-the-User-Model" class="headerlink" title="Extending the User Model"></a>Extending the User Model</h3><p>我们观察到，在auth_user这张表格中，对于email并没有严格的限制，但是呢，事实上不会存在多个用户共同使用一个email的情况，因此，我们需要新建一张自己的user表格，在里面加上对email的唯一性限制</p>
<p>首先，我们应该把我们的 User 创建在那里，肯定不能是store，因为这时对整个项目来说的，不能是特定的app</p>
<p>因此我们可以新创建一个名为 core的app。然后，将其在 INSTALLED_APP中注册。</p>
<p>接着我们在 core&gt;models.py中创建 User, 这个User需要继承自<code>django.contrib.auth.models</code>中的抽象类<code>AbstractUser</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> AbstractUser</span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(AbstractUser)</span>:</span></span><br><span class="line">    email = models.EmailField(unique=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>然后，我们需要在setting中确定<code>AUTH_USER_MODEL</code>属性，让其等于 core中的User</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AUTH_USER_MODEL &#x3D; &#39;core.User&#39;</span><br></pre></td></tr></table></figure>
<p>但这样一来，程序会起一个冲突：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/48.png"></p>
<p>原来，我们在第一部分写的Like app中，用到了<code>django.contrib.auth.models</code>中的User类，但是现在，我们将<code>AUTH_USER_MODEL</code>设置成了我们自己写的类，由此引发了冲突。为了修改这个冲突，我们可以对LikedItem Model进行修改：这里，根据系统的提示，我们隐式的确定USER_MODEL</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="comment">#...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LikedItem</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure>
<p>现在，冲突又出现了：由于我们的core还没有migrate，因此系统无法启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">raise ValueError(&quot;Dependency on app with no migrations: %s&quot; % key[0])</span><br><span class="line">ValueError: Dependency on app with no migrations: core</span><br></pre></td></tr></table></figure>
<p>在makemigration之后，要进行migrate操作的时候，又发生了如下错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">raise InconsistentMigrationHistory(</span><br><span class="line">django.db.migrations.exceptions.InconsistentMigrationHistory: Migration admin.0001_initial is applied before its dependency core.0001_initial on database 'default'.</span><br></pre></td></tr></table></figure>
<p>这个意思是说，我们在项目中期却打算修改原本的User模型，这一般是不被允许的，这涉及到数据库的底层设计。因此，我们需要重启数据库，将原有的库删除.然后重新migrate</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE  storefront2;</span><br><span class="line">CREATE DATABASE storefront2;</span><br></pre></td></tr></table></figure>
<p>所以，在今后我们最好在一个项目的一开始就创建自己的User类，可以这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> AbstractUser</span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(AbstractUser)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>现在，让我们重新创建一个superuser：<code>python manage.py createsuperuser</code></p>
<p>进入admin页面后，我们发现，admin界面中，只有Groups page，没有Users page:</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/49.png"></p>
<p>我们可以再 core&gt;admin.py中作如下修改</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.admin <span class="keyword">import</span> UserAdmin <span class="keyword">as</span> BaseUserAdmin</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> User</span><br><span class="line"><span class="comment">#...</span></span><br><span class="line"><span class="meta">@admin.register(User)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAdmin</span><span class="params">(BaseUserAdmin)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>可以看到，现在有了用户界面，可以看到已经注册的用户(现在就我一个)</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/50.png"></p>
<p>我们来到新建用户画面，发现必填字段只有下面这些</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/51.png"></p>
<p>这是因为，我们继承的BaseUserAdmin类中，有一个属性是add_fieldsets, 里面规定的字段不包含email等，我们需要拿出来重写：在这里，我在原来的基础上加上了email、first_name,last_name</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@admin.register(User)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAdmin</span><span class="params">(BaseUserAdmin)</span>:</span></span><br><span class="line">    <span class="comment"># pass</span></span><br><span class="line">    add_fieldsets = (</span><br><span class="line">        (<span class="literal">None</span>, &#123;</span><br><span class="line">            <span class="string">'classes'</span>: (<span class="string">'wide'</span>,),</span><br><span class="line">            <span class="string">'fields'</span>: (<span class="string">'username'</span>, <span class="string">'password1'</span>, <span class="string">'password2'</span>, <span class="string">'email'</span>, <span class="string">'first_name'</span>, <span class="string">'last_name'</span>),</span><br><span class="line">        &#125;), <span class="comment">#这个逗号一定要加，否则会出bug</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>刷新后结果如下，我们发现，email现在已经成了必填项，而且有唯一性，First name和Last name是选填项</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/52.png"></p>
<p>我们可以看到创建新用户后的样子如下：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/53.png"></p>
<p>与此同时，我们发现数据库中存放用户的表格从<code>auth_user</code>变成了<code>core_user</code>,里面保存了相关信息：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/54.png"></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>现在我们来小结一下这种方法的基本步骤：</p>
<ol>
<li>创建一个专门存放核心信息的app(最好叫core之类的)</li>
<li>在这个app中创建继承自AbstractUser的 User Model，里面确定要修改的字段</li>
<li>在settings.py 设置AUTH_USER_MODEL 属性</li>
<li>将之前引用<code>Django.contrib.auth.models.User</code> 的app修改为 <code>settings.AUTH_USER_MODEL</code></li>
</ol>
<h3 id="Creating-user-Profiles"><a href="#Creating-user-Profiles" class="headerlink" title="Creating user Profiles"></a>Creating user Profiles</h3><p>现在我们来学习第二种方法，之前，在store&gt;model.py中，我们写了一个Customer Model,里面有名字、手机号、生日、会员等级等信息。我们要做的就是在此基础上增加一个和core.User的一对一联系.此外，模型中的first_name,last_name,email 都已经在 core.User中实现了，我们现在将这些冗余信息删除</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    MEMBERSHIP_BRONZE = <span class="string">'B'</span></span><br><span class="line">    MEMBERSHIP_SILVER = <span class="string">'S'</span></span><br><span class="line">    MEMBERSHIP_GOLD = <span class="string">'G'</span></span><br><span class="line"></span><br><span class="line">    MEMBERSHIP_CHOICES = [</span><br><span class="line">        (MEMBERSHIP_BRONZE, <span class="string">'Bronze'</span>),</span><br><span class="line">        (MEMBERSHIP_SILVER, <span class="string">'Silver'</span>),</span><br><span class="line">        (MEMBERSHIP_GOLD, <span class="string">'Gold'</span>),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    phone = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    birth_date = models.DateField(null=<span class="literal">True</span>, blank=<span class="literal">True</span>)</span><br><span class="line">    membership = models.CharField(</span><br><span class="line">        max_length=<span class="number">1</span>, choices=MEMBERSHIP_CHOICES, default=MEMBERSHIP_BRONZE)</span><br><span class="line">    user = models.OneToOneField(</span><br><span class="line">        settings.AUTH_USER_MODEL, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure>
<p>接着，由于我们在<code>__str__</code> 中返回的是<code>f&#39;{self.first_name} {self.last_name}&#39;</code> 这个字符串，在class Meta也规定按照<code>[&#39;first_name&#39;,&#39;last_name&#39;]</code>来排序，由此，我们需要对其进行修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f'<span class="subst">&#123;self.user.first_name&#125;</span> <span class="subst">&#123;self.user.last_name&#125;</span>'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        ordering = [<span class="string">'user__first_name'</span>, <span class="string">'user__last_name'</span>]</span><br></pre></td></tr></table></figure>
<p>接下来系统给我们报错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">store</span>.<span class="title">admin</span>.<span class="title">CustomerAdmin</span>'&gt;:</span> (admin.E033) The value of <span class="string">'ordering[0]'</span> refers to <span class="string">'first_name'</span>, which <span class="keyword">is</span> <span class="keyword">not</span> a field of <span class="string">'store.Customer'</span>.</span><br></pre></td></tr></table></figure>
<p>原来，在第一章的admin模块中，我们在 store&gt;admin中创建了 CustomerAdmin类，里面引用了 first_name.last_name,现在这些属性已经不属于 Customer了，我们要对其进行修改：</p>
<p>对于 ordering 属性，我们可以直接用<code>user__first_name</code>和<code>user__last_name</code> 但是对于list_display属性，这种语法并不适用，所以我们保持原样，转向去 Customer Model去创建两个同名函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#store&gt;models.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">   <span class="comment">#...</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f'<span class="subst">&#123;self.user.first_name&#125;</span> <span class="subst">&#123;self.user.last_name&#125;</span>'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.user.first_name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">last_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.user.last_name</span><br><span class="line"><span class="comment">#store&gt;admin.py </span></span><br><span class="line"><span class="meta">@admin.register(models.Customer)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">	<span class="comment">#...</span></span><br><span class="line">    list_display = [<span class="string">'first_name'</span>, <span class="string">'last_name'</span>,  <span class="string">'membership'</span>, <span class="string">'orders'</span>] </span><br><span class="line">    ordering = [<span class="string">'user__first_name'</span>, <span class="string">'user__last_name'</span>]</span><br></pre></td></tr></table></figure>
<p>这样bug就完美解除了，现在我们来更新数据库。在 Customer界面，我们可以为已经存在的用户创建Profile：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/55.png"></p>
<p>我们为admin和JohnSmith分别创建一个profile，结果如下：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/56.png"></p>
<p>我们还可以给User添加排序：需要用<code>@admin.display()</code>修饰：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># store&gt;model.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span><span class="params">(models.Model)</span>:</span>    </span><br><span class="line"><span class="meta">    @admin.display(ordering='user__first_name')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.user.first_name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @admin.display(ordering='user__last_name')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">last_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.user.last_name</span><br></pre></td></tr></table></figure>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>要是用第二种方法，我们小结一下步骤：</p>
<ol>
<li>创建Profile model(叫什么随意)</li>
<li>在这个model中，创建和 AUTH_USER_MODEL 的一对一联系</li>
</ol>
<h3 id="Groups-and-Permissions"><a href="#Groups-and-Permissions" class="headerlink" title="Groups and Permissions"></a>Groups and Permissions</h3><p>Groups就是一些权限的集合，为了不给每一个用户都单独分配权限，我们可以将拥有相同权限的集合放到一个group中，这样就方便很多.</p>
<p>我们以superadmin登陆后，在 AUTHENTICATION AND  AUTHORIZATION中点击 Groups可以新建一个组：在这里，我希望这个组内的成员拥有对customer (Profile)、Order和OrderItem的CRUD权利：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/59.png"></p>
<p>然后，我们可以在User界面，挑选一个用户，将它加到Customer Service组中，记得勾选 Staff status，这样他就可以登录到admin 后台了</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/57.png"></p>
<p>我们退出admin，登录JasonBall后，可以看到，他只能对Customer和Order这两个Model进行修改了(OrderItem在Order中修改)。</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/58.png"></p>
<h3 id="Creating-Custom-Permissions"><a href="#Creating-Custom-Permissions" class="headerlink" title="Creating Custom Permissions"></a>Creating Custom Permissions</h3><p>我们发现，有些权限是系统不能提供的，比如说我要取消订单，这是一种订单状态的修改，而不是删除订单。</p>
<p>要实现客制化，我们需要在Meta类中设置元数据 permission属性。这个属性是一个元组列表，每个元组代表特定的权限。元组中第一个元素是code name(需具备唯一性)，第二个元素是对这个权限的描述</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        permissions = [</span><br><span class="line">            (<span class="string">'cancel_order'</span>,<span class="string">'can_cancel_order'</span>)</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/60.png"></p>
<p>那么关于这个权限是如何实现的，我们放在下面一节里细说</p>
<h2 id="Securing-APIs"><a href="#Securing-APIs" class="headerlink" title="Securing APIs"></a>Securing APIs</h2><p>在这一章，我们要对api进行安全认证</p>
<h3 id="Token-based-Authentication"><a href="#Token-based-Authentication" class="headerlink" title="Token-based Authentication"></a>Token-based Authentication</h3><p>对RESTful API，使用Token-base Authentication是一种基本操作. 基本流程如下：</p>
<ol>
<li>新用户要使用我们的服务，需要发送request请求，里面有创建用户的信息</li>
<li>server收到以后，为其创建一个账号</li>
<li>用户用刚注册的账号来访问接下来的api<ol>
<li>如果后台认证成功(密码正确)，那么就发送一个token</li>
<li>账号密码错误，返回一个error</li>
</ol>
</li>
</ol>
<p>token是什么我们就不用多说了。</p>
<h3 id="Adding-the-Authentication-Endpoints"><a href="#Adding-the-Authentication-Endpoints" class="headerlink" title="Adding the Authentication Endpoints"></a>Adding the Authentication Endpoints</h3><p>虽然Django提供了用户认证系统，但是我们并没有为其注册url。现在我们要注册一系列url，以便让用户实现注册、登录等操作。</p>
<p>为了实现这层api，我们可以使用<code>djoser</code> 这个包。他提供给我们一系列Views：比如注册、登录、等等。在其<a href="https://djoser.readthedocs.io/en/latest/" target="_blank" rel="noopener">官网</a>中，我们可以找到一些教程</p>
<p>首先，我们<code>pipenv install djoser</code> 下载这个包，然后将其注册到 INSTALLED_APP中去</p>
<p>然后，我们将auth注册到urlpattern中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">		<span class="comment">#...</span></span><br><span class="line">    path(<span class="string">'auth/'</span>,include(<span class="string">'djoser.urls'</span>))</span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>djoser 要依赖与一个 Authentication Backend才能够实现，因为djoser只是一层api和view函数，我们需要确定项目的Auth engine,才能让djoser发挥其作用。</p>
<p>在Django中我们主要有两个 Auth Engines：</p>
<ul>
<li>Token-based Authentication, 这是DRF中的认知引擎</li>
<li>JSON Web Token Authentication，这是一个独立的包，需要下载</li>
</ul>
<p>那么两者有什么区别呢？</p>
<p>前者会使用一张独立的Token表格，来存放tokens,每次server收到一个请求后，都会去数据库中做验证，判断token是否合法。也就是每次请求，都需要访问数据库</p>
<p>后者则不需要依赖数据库，因为Token的架构不同，我们在server层就可以完成对用户的验证</p>
<p>在这里我们选择后者，因此，我们需要再下载一个包：<code>pipenv install djangorestframework_simplejwt</code></p>
<p>然后，在settings.py中，我们要将项目的Auth Engine设为JWTAuthentication：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'COERCE_DECIMAL_TO_STRING'</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">'DEFAULT_AUTHENTICATION_CLASSES'</span>: (</span><br><span class="line">        <span class="string">'rest_framework_simplejwt.authentication.JWTAuthentication'</span>,</span><br><span class="line">    ),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们要设置SIMPLE_JWT, 这项设置要求用户在请求头中需要加上JWT前缀</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SIMPLE_JWT = &#123;</span><br><span class="line">   <span class="string">'AUTH_HEADER_TYPES'</span>: (<span class="string">'JWT'</span>,),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照教程，我们还需要在 storefront&gt;urls.py中注册一个新的urlpattern：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">  <span class="comment">#...</span></span><br><span class="line">    path(<span class="string">'auth/'</span>, include(<span class="string">'djoser.urls'</span>)),</span><br><span class="line">    path(<span class="string">'auth/'</span>, include(<span class="string">'djoser.urls.jwt'</span>)),</span><br><span class="line">  <span class="comment">#...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>现在，djoser提供的endpoints就可以正常使用了：</p>
<ul>
<li><code>/users/</code></li>
<li><code>/users/me/</code></li>
<li><code>/users/confirm/</code></li>
<li><code>/users/resend_activation/</code></li>
<li><code>/users/set_password/</code></li>
<li><code>/users/reset_password/</code></li>
<li><code>/users/reset_password_confirm/</code></li>
<li><code>/users/set_username/</code></li>
<li><code>/users/reset_username/</code></li>
<li><code>/users/reset_username_confirm/</code></li>
<li><code>/token/login/</code> (Token Based Authentication)</li>
<li><code>/token/logout/</code> (Token Based Authentication)</li>
<li><code>/jwt/create/</code> (JSON Web Token Authentication)</li>
<li><code>/jwt/refresh/</code> (JSON Web Token Authentication)</li>
<li><code>/jwt/verify/</code> (JSON Web Token Authentication)</li>
</ul>
<p>比如说，我访问 <code>http://localhost:9000/auth/users/</code>：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/61.png"></p>
<p>因为这些urls是不允许匿名用户访问的，我们必须有token才可以访问到信息。因此这里返回的状态码是401 Unauthorized。</p>
<h3 id="Registering-Users"><a href="#Registering-Users" class="headerlink" title="Registering Users"></a>Registering Users</h3><p>接下来我们就来学怎么注册一个新用户,在这个endpoint，我们不仅有GET还有POST方法。因此是可以新建User的</p>
<p>如果我们的注册信息很简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;email&quot;: &quot;user1@icloud.com&quot;,</span><br><span class="line">    &quot;username&quot;: &quot;user1&quot;,</span><br><span class="line">    &quot;password&quot;: &quot;1234&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到是不能注册成功的</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/62.png"></p>
<p>这是因为在settings.py中我们设置了一系列Validator： 有最短长度验证、简单密码验证、全数值密码验证等</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AUTH_PASSWORD_VALIDATORS = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'django.contrib.auth.password_validation.UserAttributeSimilarityValidator'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'django.contrib.auth.password_validation.MinimumLengthValidator'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'django.contrib.auth.password_validation.CommonPasswordValidator'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'django.contrib.auth.password_validation.NumericPasswordValidator'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>当我们改进password后，就可以正常注册了</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/63.png"></p>
<p>但我们有没有发现，这个POST函数并没有要求我们输入firstname和lastname(可以不填，但必须有)，这是因为djoser默认提供的字段只有这些，因此我们需要客制化serializer</p>
<p>在 <a href="https://djoser.readthedocs.io/en/latest/settings.html?highlight=serializer#serializers" target="_blank" rel="noopener">https://djoser.readthedocs.io/en/latest/settings.html?highlight=serializer#serializers</a> 中，我们可以看到djoser提供的所有serializer，其中我们要重写的是<code>user_create</code> </p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/64.png"></p>
<p>我们将这个serializer写在core app中,首先，我们要导入<code>djoser.serializers</code>中的<code>UserCreateSerializer</code>类<br>然后，我们要创建一个客制化类，让其继承自<code>UserCreateSerializer</code><br>接着，我们要重写Meta 类中的fields属性，又不想重写Meta中所有的属性，所以我们让Meta也继承自原来类中的Meta类。<br>最后，我们确认fields属性中的字段，把first_name,last_name加上：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># core&gt;serializers.py</span></span><br><span class="line"><span class="keyword">from</span> djoser.serializers <span class="keyword">import</span> UserCreateSerializer <span class="keyword">as</span> BaseUserCreateSerializer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserCreateSerializer</span><span class="params">(BaseUserCreateSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span><span class="params">(BaseUserCreateSerializer.Meta)</span>:</span></span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'username'</span>, <span class="string">'password'</span>,</span><br><span class="line">                  <span class="string">'email'</span>, <span class="string">'first_name'</span>, <span class="string">'last_name'</span>]</span><br></pre></td></tr></table></figure>
<p>此外，由于我们想用自己写的<code>UserCreateSerializer</code>,我们需要在settings中注明这一点：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># settings.py</span></span><br><span class="line">DJOSER = &#123;</span><br><span class="line">    <span class="string">'SERIALIZERS'</span>: &#123;</span><br><span class="line">        <span class="string">'user_create'</span>: <span class="string">'core.serializers.UserCreateSerializer'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后结果如下所示，注意，first_name和last_name是选填的</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/64.gif"></p>
<h3 id="Building-the-Profile-API"><a href="#Building-the-Profile-API" class="headerlink" title="Building the Profile API"></a>Building the Profile API</h3><p>但是，现在我们输入的都是core.user的字段，我们想在注册的时候添加birthday这种在profile中的字段，该怎么办？</p>
<p>我们当然可以在UserCreateSerializer中添加这个字段，但是这会让代码的耦合度变得很高。我们的程序设计理念是模块化。理想的状态是这样的：在前端，用户填了一系列表单，表单中的有些字段是属于core.user的，而有些字段则是属于store.customer的，为了将这些信息都保存下来，我们需要用户在提交时先访问 create user API,然后再发送一个Update Profile 请求访问Profile API，这样能让整个系统结构更加稳定。</p>
<p>由于Djoser并不提供<code>/user/profile</code>类似的api，我们需要自己实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># store&gt;serializers.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    user_id = serializers.IntegerField()</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Customer</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'user_id'</span>, <span class="string">'phone'</span>, <span class="string">'birth_date'</span>, <span class="string">'membership'</span>]</span><br><span class="line"><span class="comment"># store&gt;urls.py</span></span><br><span class="line">router.register(<span class="string">'customers'</span>,views.CustomerViewSet)</span><br></pre></td></tr></table></figure>
<p>然后，在<code>http://localhost:9000/store/customers/</code>界面，我们就可以为特定的 User创建profile了：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/65.gif"></p>
<h3 id="Logging-In"><a href="#Logging-In" class="headerlink" title="Logging In"></a>Logging In</h3><p>现在我们来讲用户认证。在Djoser中，下面两个endpoints是给 auth engine为DRF自带的Token Based Authentication使用的</p>
<ul>
<li><code>/token/login/</code> (Token Based Authentication)</li>
<li><code>/token/logout/</code> (Token Based Authentication)</li>
</ul>
<p>下面三个endpoints则是给 JSON Web Token Authentication使用的：</p>
<ul>
<li><code>/jwt/create/</code> (JSON Web Token Authentication)</li>
<li><code>/jwt/refresh/</code> (JSON Web Token Authentication)</li>
<li><code>/jwt/verify/</code> (JSON Web Token Authentication)</li>
</ul>
<p>其中<code>/jwt/create/</code> 这个endpoint就是用来给用户登录的：如果我们输入的用户名和密码错误，如下所示</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/66.png"></p>
<p>如果我们输入正确的用户名和密码，那么DJango会返回两个个Token ：access token和refresh token。access token是short-lived(短暂的)token，用来访问需要安全认证的API的；当access token过期的时候，需要用到refresh token来获得一个新的access token</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/67.png"></p>
<p>在 <a href="https://django-rest-framework-simplejwt.readthedocs.io/en/latest/settings.html" target="_blank" rel="noopener">simplejwt的官网</a>中，我们可以看到一系列设置，其中包括<code>&#39;ACCESS_TOKEN_LIFETIME&#39;,&#39;REFRESH_TOKEN_LIFETIME&#39;</code>也就是说，我们可以自己修改access token的寿命：</p>
<p>为了方便，我们这里就讲access token的有效时间也设为1天</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#settings.py</span></span><br><span class="line">SIMPLE_JWT = &#123;</span><br><span class="line">    <span class="string">'AUTH_HEADER_TYPES'</span>: (<span class="string">'JWT'</span>,),</span><br><span class="line">    <span class="string">'ACCESS_TOKEN_LIFETIME'</span>: timedelta(days=<span class="number">1</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一个前后端分离的系统中，当前段获得了一对token后，需要将它们存在浏览器里面。这里我们只能存放在一个文件里面，用来模拟前端的小型数据库，这样就算登录账户了。</p>
<p>那么怎么登出账户呢？很简单，就是将token从前端的小型数据库中移除即可。所以，在这个项目中，没有登出用户一说，因为这是前端干的事，和后端、数据库没有关系</p>
<h3 id="Inspecting-a-JSON-Web-Token"><a href="#Inspecting-a-JSON-Web-Token" class="headerlink" title="Inspecting a JSON Web Token"></a>Inspecting a JSON Web Token</h3><p>现在，我们来学习解构JWT，需要用到这个网站： <a href="https://jwt.io/" target="_blank" rel="noopener">https://jwt.io/</a></p>
<p>我们在这个网站里，将我们刚才保存的token输进去，如下图所示，右图是这个token解构后的信息：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/68.png"></p>
<p>第一部分是header，里面有typ键，这里是JWT，因为我们采用了这种认证机制</p>
<p>第二部分是payload, 第一个键是token_type，这里是access token；第二个键是过期时间；第三个键是这个token的唯一认证机制。最后一个键是user_id</p>
<p>第三部分是Verify Signature,是根据前两部分生成的，<code>your-256-bit-secret</code> 会存在server里面。如果我们对Payload进行修改，那么Signature也会做相应的修改。因此，就算黑客获取了你的token，打算修改你的user_id，这时候signature也会改变，也就不是原来的那个token了。如果拿这个去访问后端，是会被拒绝的，因为后端也认出这个<code>your-256-bit-secret</code> 不是自己生成的。</p>
<h3 id="Refreshing-Tokens"><a href="#Refreshing-Tokens" class="headerlink" title="Refreshing Tokens"></a>Refreshing Tokens</h3><p>那么如果Access token 过期了，没法访问Protected API, 而Refresh token 没有过期，会怎么样呢？我们需要用refresh_token向后端重新申请一个access token.</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/69.png"></p>
<p>Djoser 为我们提供的这个api，是可以通过一个refresh token去获得一个新的access token的：</p>
<ul>
<li><code>/jwt/refresh/</code> (JSON Web Token Authentication)</li>
</ul>
<p>效果如下：</p>
<p> <img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/70.gif"></p>
<h3 id="Getting-the-Current-User"><a href="#Getting-the-Current-User" class="headerlink" title="Getting the Current User"></a>Getting the Current User</h3><p>我们可以通过 <code>users/me/</code> 这个endpoint 来获得当前的用户。</p>
<p>但是我们发现，如果直接访问<code>http://localhost:9000/auth/users/me/</code>，Django是不会给我们提供任何信息的，因为我们并没有在请求头里存放token信息。</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/73.png"></p>
<p>因此，我们需要用到这个浏览器插件：<a href="https://chrome.google.com/webstore/detail/modheader/idgpnmonknjnojddfkpgkljpfnnfcklj?hl=en" target="_blank" rel="noopener">Modheader</a>， 利用这个插件，我们可以往请求头中添加信息。这里，我要添加一个Authorization的信息，信息内容是 <code>JWT (Access Token)</code> 。之所以这么写，是因为之前我们在settings中规定了认证的类型为JWT:  <code>&#39;AUTH_HEADER_TYPES&#39;: (&#39;JWT&#39;,)</code></p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/71.png"></p>
<p>设置好后，我们刷新页面，就可以得到个人信息了。</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/72.png"></p>
<p>但是现在，我们发现只能获得默认的三个字段：email，id，username，如果我想获得其他信息如first_name,last_name 应该怎么办？</p>
<p>还是老方法，修改默认的Serializer：我们找到 <code>&#39;current_user&#39;: &#39;djoser.serializers.UserSerializer&#39;,</code> 发现这个UserSerializer 是负责当前用户信息的。因此我们来重写他</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># core&gt;serializers.py</span></span><br><span class="line"><span class="keyword">from</span> djoser.serializers <span class="keyword">import</span> UserSerializer <span class="keyword">as</span>  BaseUserSerializer,\</span><br><span class="line">															 UserCreateSerializer <span class="keyword">as</span> BaseUserCreateSerializer</span><br><span class="line"> 		<span class="comment">#...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSerializer</span><span class="params">(BaseUserSerializer)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span><span class="params">(BaseUserSerializer.Meta)</span>:</span></span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'username'</span>, <span class="string">'password'</span>,</span><br><span class="line">                  <span class="string">'email'</span>, <span class="string">'first_name'</span>, <span class="string">'last_name'</span>]</span><br></pre></td></tr></table></figure>
<p>别忘了在 settings.py&gt;Djoser中增加修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DJOSER = &#123;</span><br><span class="line">    <span class="string">'SERIALIZERS'</span>: &#123;</span><br><span class="line">        <span class="string">'user_create'</span>: <span class="string">'core.serializers.UserCreateSerializer'</span>,</span><br><span class="line">        <span class="string">'current_user'</span>: <span class="string">'core.serializers.UserSerializer'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/74.png" style="zoom:67%;"></p>
<blockquote>
<p>注意了，Modheader会向所有的browser发送这个Authorization，因此可能会扰乱其它网站的登录(如果他们也用JWT的话)，因此最好用完就删掉。</p>
</blockquote>
<h3 id="Getting-Current-Users-Profile"><a href="#Getting-Current-Users-Profile" class="headerlink" title="Getting Current Users Profile"></a>Getting Current Users Profile</h3><p>上面我们获得了User的核心信息，现在如果我想获得User  Profile，该怎么办？</p>
<p>我们希望，访问<code>/store/customers/me</code> 的时候，可以获取到用户的电话号码、出生日期，会员等级等信息。</p>
<p>首先，我们要导入 action decorator，用它来修饰/me 这个动作，这里，我们要设置detail的值，如果为False，那么说明这个action作用于list view，通过<code>/store/customers/me</code>即可访问；如果为True，说明这个action作用于detail view，需要通过<code>/store/customers/&lt;id&gt;/me</code> 来访问。在这里，由于只会筛选到一个customer的信息，因此我们设置为False即可</p>
<p>然后，由于token的Payload中有userid这个键，因此我们可以用<code>request.user.id</code> 找到特定的customer的profile信息</p>
<p>最后，我们将object传入Serializer并将<code>serializer.data</code>传回</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> rest_framework.decorators <span class="keyword">import</span> action</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerViewSet</span><span class="params">(CreateModelMixin, RetrieveModelMixin, UpdateModelMixin, GenericViewSet)</span>:</span></span><br><span class="line">    queryset = Customer.objects.all()</span><br><span class="line">    serializer_class = CustomerSerializer</span><br><span class="line">	</span><br><span class="line"><span class="meta">    @action(detail=False)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">me</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        customer = Customer.objects.get(user_id = request.user.id)</span><br><span class="line">        serializer = CustomerSerializer(customer)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/75.png" style="zoom:67%;"></p>
<p>但是，现在我作为用户本人，只能查看个人的信息，并不能创建、修改更新个人信息。因为我们看到这边只允许GET方法，因此我们需要对CustomerView进行修改。</p>
<p>现在我们来捋一捋逻辑，我现在作为用户本人，已经登录了，现在在访问<code>/store/customers/me/</code> 这个endpoint</p>
<ul>
<li>如果我有customer信息<ul>
<li>我可以GET来获取</li>
<li>我可以PUT来更新</li>
</ul>
</li>
<li>如果我没有customer信息<ul>
<li>那么我可以创建相关信息<ul>
<li>GET</li>
<li>PUT</li>
</ul>
</li>
</ul>
</li>
<li>在使用PUT的时候，我不希望修改这个user的id，否则就乱了套了</li>
</ul>
<p>根据这个逻辑，我们可以这样修改：</p>
<ul>
<li>首先规定action中的methods参数为GET和PUT</li>
<li>然后，根据token中的id去数据库中获取customer对象，如果有则返回对象，如果没有，就创建一个实例<ul>
<li>如果方法是GET，那么就返回serializer.data</li>
<li>如果方法是PUT，说明要更新，因此我们需要将customer实例和request.data传给<code>CustomerSerializer</code>,让它去验证信息准确性，如果没问题，就保存</li>
</ul>
</li>
<li>在CustomerSerializer中将user_id改为<code>read_only=True</code>， 这样一来，用户只有在访问<code>/store/customers/me/</code> 的时候，才能创建或修改个人信息。在<code>/store/customers/</code> 的时候，不能创建个人信息，因为此时是获取不到user_id的</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># store&gt;views.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerViewSet</span><span class="params">(CreateModelMixin, RetrieveModelMixin, UpdateModelMixin, GenericViewSet)</span>:</span></span><br><span class="line">    queryset = Customer.objects.all()</span><br><span class="line">    serializer_class = CustomerSerializer</span><br><span class="line"></span><br><span class="line"><span class="meta">    @action(detail=False, methods=['GET', 'PUT'])</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">me</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        (customer,created) = Customer.objects.get_or_create(user_id=request.user.id)</span><br><span class="line">        <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">            serializer = CustomerSerializer(customer)</span><br><span class="line">            <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line">        <span class="keyword">elif</span> request.method == <span class="string">'PUT'</span>:</span><br><span class="line">            serializer = CustomerSerializer(customer, data=request.data)</span><br><span class="line">            serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">            serializer.save()</span><br><span class="line">            <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line">          </span><br><span class="line"><span class="comment"># stores&gt;serialize.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    user_id = serializers.IntegerField(read_only=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Customer</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'user_id'</span>, <span class="string">'phone'</span>, <span class="string">'birth_date'</span>, <span class="string">'membership'</span>]</span><br></pre></td></tr></table></figure>
<p>注意，这里使用<code>get_or_create</code> 方法的时候，返回值是一个对象元组，我们需要用一个元组来接收，如果只赋值给customer会报如下错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Got AttributeError when attempting to get a value for field `user_id` on serializer `CustomerSerializer`.</span><br><span class="line">The serializer field might be named incorrectly and not match any attribute or key on the `tuple` instance.</span><br><span class="line">Original exception text was: 'tuple' object has no attribute 'user_id'.</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/76.gif" style="zoom:67%;"></p>
<h3 id="Applying-Permissions"><a href="#Applying-Permissions" class="headerlink" title="Applying Permissions"></a>Applying Permissions</h3><p>在 <a href="https://www.django-rest-framework.org/api-guide/permissions/" target="_blank" rel="noopener">https://www.django-rest-framework.org/api-guide/permissions/</a> 中，我们可以看到各式各样的 Permission</p>
<p>比如 AllowAny，是对所有人都可以开放的权限，isAuthentication 是已经登陆的人的权限。我们也可以自己创建权限。</p>
<p>如果我们想给所有的viewset都加上 isAuthentication权限.可以直接修改settings.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># settings.py</span></span><br><span class="line"></span><br><span class="line">DJOSER = &#123;</span><br><span class="line">    <span class="string">'SERIALIZERS'</span>: &#123;</span><br><span class="line">        <span class="string">'user_create'</span>: <span class="string">'core.serializers.UserCreateSerializer'</span>,</span><br><span class="line">        <span class="string">'current_user'</span>: <span class="string">'core.serializers.UserSerializer'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'DEFAULT_PERMISSION_CLASSES'</span>:[</span><br><span class="line">        <span class="string">'rest_framework.permissions.IsAuthenticated'</span></span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/77.png" style="zoom:67%;"></p>
<p>如果我们希望有些 api可以由匿名用户访问，我们就不能采用这种一劳永逸的方法。可以在viewset里面设置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerViewSet</span><span class="params">(CreateModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                      RetrieveModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                      UpdateModelMixin, </span></span></span><br><span class="line"><span class="class"><span class="params">                      GenericViewSet)</span>:</span></span><br><span class="line">    queryset = Customer.objects.all()</span><br><span class="line">    serializer_class = CustomerSerializer</span><br><span class="line">    permission_classes = [IsAuthenticated]</span><br></pre></td></tr></table></figure>
<p>但是对于Generic View，好像用不了这个方法。我们需要在class上面加上一个decorator：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@permission_classes([IsAuthenticated])</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SearchBookView</span><span class="params">(ListAPIView)</span>:</span></span><br><span class="line">  <span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p>我们希望，在CustomerViewSet中，如果是未认证的用户，也可以查看他人的用户信息，但是只用认证后的用户才有权限更新Profile：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># store &gt;views</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerViewSet</span><span class="params">(CreateModelMixin, RetrieveModelMixin, UpdateModelMixin, GenericViewSet)</span>:</span></span><br><span class="line">    queryset = Customer.objects.all()</span><br><span class="line">    serializer_class = CustomerSerializer</span><br><span class="line">    permission_classes = [IsAuthenticated]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_permissions</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.request.method == <span class="string">'GET'</span>:</span><br><span class="line">            <span class="keyword">return</span> [AllowAny]</span><br></pre></td></tr></table></figure>
<p>如果我们不登录，那么只有GET方法</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/78.png" style="zoom:67%;"></p>
<p>如果我们登陆了，那么可以调用PUT方法</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/79.png" style="zoom:67%;"></p>
<h3 id="Applying-Custom-Permissions"><a href="#Applying-Custom-Permissions" class="headerlink" title="Applying Custom Permissions"></a>Applying Custom Permissions</h3><p>现在我们来自己创建Permissions类：</p>
<p>对于Products，我们希望只有admin可以修改有关product的信息，但是其他用户(不管有没有登录)，都不能修改。但是DRF中写好的permission类只有IsAuthenticatedOrReadOnly,没有 IsAdminOrReadOnly,.因此我们要客制化一个Permission 类。</p>
<p>我们首先来看<code>IsAuthenticated</code>,其内部逻辑就是找到是否token里有user，并且这个user是否是认证的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsAuthenticated</span><span class="params">(BasePermission)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Allows access only to authenticated users.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_permission</span><span class="params">(self, request, view)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(request.user <span class="keyword">and</span> request.user.is_authenticated)</span><br></pre></td></tr></table></figure>
<p>然后我们再来看看<code>IsAdminUser</code>的内部逻辑，就是找到是否有user，并且user是否是admin</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsAdminUser</span><span class="params">(BasePermission)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Allows access only to admin users.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_permission</span><span class="params">(self, request, view)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(request.user <span class="keyword">and</span> request.user.is_staff)</span><br></pre></td></tr></table></figure>
<p>接着我们就可以自己写permission了。逻辑如下：</p>
<ul>
<li>如果使用安全方法(GET,OPTION,HEAD)访问，那么就给这个权限</li>
<li>如果用PUT,DELETE,POST方法来访问的话，那么就需要判断是否为admin了</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> permissions</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsAdminOrReadOnly</span><span class="params">(permissions.BasePermission)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_permission</span><span class="params">(self, request, view)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> request.method <span class="keyword">in</span> permissions.SAFE_METHODS:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> bool(request.user <span class="keyword">and</span> request.user.is_staff)</span><br></pre></td></tr></table></figure>
<p>我们看到，如果我是staff(admin)我就可以新创建一个Product，除此之外只能是已读 的</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/80.png" style="zoom:67%;"></p>
<h3 id="Applying-Model-Permissions"><a href="#Applying-Model-Permissions" class="headerlink" title="Applying Model Permissions"></a>Applying Model Permissions</h3><p>现在我们只给admin操作Customer的权限。在之前我们创建的一个Group 叫做 Customer Service，如果我们想让拥有这个权限的用户进行操作，该怎么办？</p>
<p>我们可以使用DjangoModelPermissions</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerViewSet</span><span class="params">(CreateModelMixin, </span></span></span><br><span class="line"><span class="class"><span class="params">											RetrieveModelMixin, </span></span></span><br><span class="line"><span class="class"><span class="params">											UpdateModelMixin, </span></span></span><br><span class="line"><span class="class"><span class="params">											GenericViewSet)</span>:</span></span><br><span class="line">    queryset = Customer.objects.all()</span><br><span class="line">    serializer_class = CustomerSerializer</span><br><span class="line">    permission_classes = [DjangoModelPermissions]</span><br><span class="line">    <span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p>当使用这种权限方式，只有Groups中的用户才有权限对这个endpoint 进行操作.</p>
<p>比如说对于 JasonBall用户，他被加入到 customer service组了，那么现在他就拥有对customer的增删改查的权限：<code>http://localhost:9000/store/customers/5/</code></p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/83.png" style="zoom:67%;"></p>
<p>当我们把他从这个组删除，那么我们看到，除了GET方法，它不能对customer进行PUT，POST和DELETE操作了</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/81.png" style="zoom:67%;"></p>
<p>那么如果我甚至不想给他查看用户信息的权限，我们该怎么办？</p>
<p>看到DjangoObjectPermissions的源码，我们发现，在 <code>perms_map</code>这个列表中,只有POST、PUT、PATCH和DELETE是受保护的方法，而对GET方法没有权限方面的限制</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">perms_map = &#123;</span><br><span class="line">    <span class="string">'GET'</span>: [],</span><br><span class="line">    <span class="string">'OPTIONS'</span>: [],</span><br><span class="line">    <span class="string">'HEAD'</span>: [],</span><br><span class="line">    <span class="string">'POST'</span>: [<span class="string">'%(app_label)s.add_%(model_name)s'</span>],</span><br><span class="line">    <span class="string">'PUT'</span>: [<span class="string">'%(app_label)s.change_%(model_name)s'</span>],</span><br><span class="line">    <span class="string">'PATCH'</span>: [<span class="string">'%(app_label)s.change_%(model_name)s'</span>],</span><br><span class="line">    <span class="string">'DELETE'</span>: [<span class="string">'%(app_label)s.delete_%(model_name)s'</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，我们可以重写DjangoModelPermissions，在里面为GET方法加上权限设置。然后，将VIewSet中的permission_classes 修改成 我们自己写的 FullDjangoModelPermissions</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># store&gt;permissions</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FullDjangoModelPermissions</span><span class="params">(permissions.DjangoModelPermissions)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.perms_map[<span class="string">'GET'</span>] = [<span class="string">'%(app_label)s.add_%(model_name)s'</span>] </span><br><span class="line">        </span><br><span class="line"><span class="comment"># store&gt;views</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerViewSet</span><span class="params">(CreateModelMixin, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin,  GenericViewSet)</span>:</span></span><br><span class="line">    queryset = Customer.objects.all()</span><br><span class="line">    serializer_class = CustomerSerializer</span><br><span class="line">    permission_classes = [FullDjangoModelPermissions]</span><br><span class="line">    <span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p>结果如下，JasonBall现在连信息都看不了了 </p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/82.png" style="zoom:67%;"></p>
<h3 id="Applying-Custom-Model-Permissions"><a href="#Applying-Custom-Model-Permissions" class="headerlink" title="Applying Custom Model Permissions"></a>Applying Custom Model Permissions</h3><p>现在我们客制化一个Model Permission，我们想实现的功能是，当用户拥有这个权限，那么他可以访问历史订单，否则看不见。因为我们还没有开始写订单API，所以我们先(意思意思)</p>
<p>首先，我们在customer下面定义 permission元组列表。migration后，我们就可以在/admin界面给用户添加这个权限了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        ordering = [<span class="string">'user__first_name'</span>, <span class="string">'user__last_name'</span>]</span><br><span class="line">        permissions = [</span><br><span class="line">            (<span class="string">'view_history'</span>,<span class="string">'Can view history'</span>)</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure>
<p>接着，我们要为这个自定义的permission创建一个类，注意，这种自定义的类都需要继承自 <code>BasePermission</code>.在这个类中，我们要重写<code>has_permission</code>函数，里面返回的是一个判断用户是否拥有特定权限的布尔值。</p>
<p>这里，权限的命名方式是：app名字 . 自定义的权限名字</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewCustomerHistoryPermission</span><span class="params">(permissions.BasePermission)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_permission</span><span class="params">(self, request, view)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> request.user.has_perm(<span class="string">'store.view_history'</span>)</span><br></pre></td></tr></table></figure>
<p>最后，我们把这个permission class加到我们想要的action里面去，注意，这里自定义的action需要self,request和pk三个参数。因为这个 action是为特定的customer服务的，因此需要用到pk参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lass CustomerViewSet(	CreateModelMixin, </span><br><span class="line">											RetrieveModelMixin,</span><br><span class="line">                      UpdateModelMixin, </span><br><span class="line">                      DestroyModelMixin,</span><br><span class="line">                      GenericViewSet): 		</span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line"><span class="meta"> 		@action(detail=True, permission_classes=ViewCustomerHistoryPermission)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">history</span><span class="params">(self, request, pk)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'OK'</span>: <span class="string">"History"</span>&#125;)</span><br><span class="line">		<span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p>如果没有这个权限：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/84.png"></p>
<p>如果我们把这个权限加给JasonBall</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/85.png"></p>
<blockquote>
<p>注意点：</p>
<p>我们在给权限的时候永远不要一个一个加，就算只给一个权限，我们也要先创建一个Group，然后在把用户加到组里，这样不仅方便管理，而且能够轻易地通过组来筛选组内的用户。</p>
<p>如果一个一个加，项目大的话会非常难以管理</p>
</blockquote>
<h2 id="Designing-and-Building-the-Orders-API"><a href="#Designing-and-Building-the-Orders-API" class="headerlink" title="Designing and Building the Orders API"></a>Designing and Building the Orders API</h2><h3 id="Designing-the-API-1"><a href="#Designing-the-API-1" class="headerlink" title="Designing the API"></a>Designing the API</h3><p>我们现在来创建一个下单的API：首先给个设计</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>METHOD</th>
<th>url</th>
<th>request</th>
<th>Response</th>
</tr>
</thead>
<tbody>
<tr>
<td>POST</td>
<td>/orders/</td>
<td>{cartId}</td>
<td>order</td>
</tr>
<tr>
<td>GET</td>
<td>/orders/</td>
<td>{}</td>
<td>order[]</td>
</tr>
<tr>
<td>GET</td>
<td>/orders/1</td>
<td>{}</td>
<td>order</td>
</tr>
<tr>
<td>PATCH</td>
<td>/orders/1</td>
<td>——</td>
<td>——</td>
</tr>
<tr>
<td>DELETE</td>
<td>/orders/1</td>
<td>——</td>
<td>——</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Getting-the-Orders"><a href="#Getting-the-Orders" class="headerlink" title="Getting the Orders"></a>Getting the Orders</h3><p>首先我们在数据库里生成一些订单(因为创建订单的api我们还没写)</p>
<p>还是老套路，首先创建 serializer.我们最终想返回的是一个嵌套列表，形式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"id"</span>: <span class="number">2</span>,																	<span class="comment"># 订单号		</span></span><br><span class="line">        <span class="string">"customer"</span>: <span class="number">4</span>,														<span class="comment"># 顾客id</span></span><br><span class="line">        <span class="string">"placed_at"</span>: <span class="string">"2021-12-14T16:07:53Z"</span>,			<span class="comment"># 创建时间</span></span><br><span class="line">        <span class="string">"payment_status"</span>: <span class="string">"P"</span>,										<span class="comment"># 订单状态</span></span><br><span class="line">        <span class="string">"items"</span>: [																<span class="comment"># 订单物件</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"id"</span>: <span class="number">2</span>,</span><br><span class="line">                <span class="string">"product"</span>: &#123;											<span class="comment"># 物件信息</span></span><br><span class="line">                    <span class="string">"id"</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="string">"title"</span>: <span class="string">"Bread Ww Cluster"</span>,</span><br><span class="line">                    <span class="string">"unit_price"</span>: <span class="number">4.0</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"unit_price"</span>: <span class="number">10.0</span>,								<span class="comment">#单价</span></span><br><span class="line">                <span class="string">"quantity"</span>: <span class="number">10</span>									</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"id"</span>: <span class="number">3</span>,</span><br><span class="line">                <span class="string">"product"</span>: &#123;</span><br><span class="line">                    <span class="string">"id"</span>: <span class="number">2</span>,</span><br><span class="line">                    <span class="string">"title"</span>: <span class="string">"Island Oasis"</span>,</span><br><span class="line">                    <span class="string">"unit_price"</span>: <span class="number">84.64</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"unit_price"</span>: <span class="number">20.0</span>,</span><br><span class="line">                <span class="string">"quantity"</span>: <span class="number">20</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>我们看到这个嵌套对象还是蛮复杂的，最外层是order，第二层是orderitems，第三层是product</p>
<p>为了实现这个嵌套数组，我们可以这样来写serializer</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># serializer.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderItemSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    product = SimpleProductSerializer()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = OrderItem</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'product'</span>, <span class="string">'unit_price'</span>, <span class="string">'quantity'</span>]</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line"></span><br><span class="line">    items = OrderItemSerializer(many=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Order</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'customer'</span>, <span class="string">'placed_at'</span>, <span class="string">'payment_status'</span>, <span class="string">'items'</span>]</span><br><span class="line"><span class="comment"># 注意，如果items = OrderItemSerializer(many=True)，会报错，因为没有在model里面写related_name</span></span><br><span class="line"><span class="comment"># model.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderItem</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    order = models.ForeignKey(</span><br><span class="line">        Order, on_delete=models.PROTECT, related_name=<span class="string">'items'</span>)</span><br><span class="line">    <span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p>最后，我们注册routers:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># urls.py</span></span><br><span class="line">router.register(<span class="string">'orders'</span>, views.OrderViewSet)</span><br></pre></td></tr></table></figure>
<h3 id="Applying-Permissions-1"><a href="#Applying-Permissions-1" class="headerlink" title="Applying Permissions"></a>Applying Permissions</h3><p>现在我们给 orders 添加权限，否则匿名用户也能对订单进行查看。而且每个人只能查看自己下的订单。因此，我们要对queryset进行一个重写：</p>
<p>如果用户是staff，那么就可以返回所有的订单</p>
<p>如果用户不是staff，那么，就筛选出该用户下的订单并返回</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># views.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    serializer_class = OrderSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.request.user.is_staff:</span><br><span class="line">            <span class="keyword">return</span> Order.objects.all()</span><br><span class="line"></span><br><span class="line">        (customer_id, created) = Customer.objects.only(</span><br><span class="line">            <span class="string">'id'</span>,).get_or_create(user_id=self.request.user.id)</span><br><span class="line">        Order.objects.filter(customer_id=customer_id)</span><br><span class="line"><span class="comment"># urls.py</span></span><br><span class="line">router.register(<span class="string">'orders'</span>, views.OrderViewSet, basename=<span class="string">'orders'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Creating-an-Order"><a href="#Creating-an-Order" class="headerlink" title="Creating an Order"></a>Creating an Order</h3><p>现在我们来理一下创建Order的逻辑。</p>
<p>首先，我们可以从 Token中获得user_id, 我们将其取出放入 context。然后，如果是POST方法，说明需要创建一个Order，因为创建Order需要同时创建item(这一部分暂未实现)，内部实现逻辑更复杂，因此我们这里需要新建一个CreateOrderSerializer。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    permission_classes = [IsAuthenticated]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_serializer_context</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'user_id'</span>: self.request.user.id, &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_serializer_class</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.request.method == <span class="string">'POST'</span>:</span><br><span class="line">            <span class="keyword">return</span> CreateOrderSerializer</span><br><span class="line">        <span class="keyword">return</span> OrderSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.request.user.is_staff:</span><br><span class="line">            <span class="keyword">return</span> Order.objects.all()</span><br><span class="line"></span><br><span class="line">        (customer_id, created) = Customer.objects.only(</span><br><span class="line">            <span class="string">'id'</span>,).get_or_create(user_id=self.request.user.id)</span><br><span class="line">        Order.objects.filter(customer_id=customer_id)</span><br></pre></td></tr></table></figure>
<p>因为这个Serializer是要收入一个嵌套数组的(cart+cartItem)，这不属于Model之一 ,因此我们这里使用<code>Serializer</code>，需要自己定义save函数。创建一个Order最基本的两个条件是购物车号码以及用户的id(当item为空的时候)，因此这边我们根据id去找到customer，并用这个customer去创建Order</p>
<p>需要注意的是，cart_id 存放在 <code>**validated_data</code>里面，属于request.data中的内容；而user_id是view通过context(可以理解为小窗)传给Serializer的内容，不包含在validated_data里面 </p>
<p>在调用save函数的时候，validated_data会自动传入，而context不会，因此我们要手动传入customer字段。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateOrderSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    cart_id = serializers.UUIDField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self,  **kwargs)</span>:</span></span><br><span class="line">        (customer, created) = Customer.objects.get_or_create(</span><br><span class="line">            user=self.context[<span class="string">'user_id'</span>],)</span><br><span class="line">        Order.objects.create(customer=customer)</span><br></pre></td></tr></table></figure>
<h3 id="Creating-Order-Items"><a href="#Creating-Order-Items" class="headerlink" title="Creating Order Items"></a>Creating Order Items</h3><p>上面所说的，只是创建一个Order对象，但是并没有创建订单中的物品信息。为此，我们需要在订单之后，再创建订单中的OrderItems对象</p>
<p>第一步，我们获取<code>validated_data</code> 中的<code>cart_id</code>信息。</p>
<p>第二步, 我们根据card_id找到隶属于这个购物车中的所有物品 cart_items</p>
<p>第三步，对于每个cart_item，我们都创建一个 order_item ；然后，作为数组成员放到 order_items 中去</p>
<p>第四步，调用 <code>objects.bulk_create</code> 方法，传入一个数组，这个方法就会为每一个数组中的成员创建一个对象，所以叫做 bulk，意思是大量创建</p>
<p>第五步，在创建订单后，购物车就没有用了，所以我们要删掉它</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateOrderSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> transaction.atomic():</span><br><span class="line">        cart_id = serializers.UUIDField()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self,  **kwargs)</span>:</span></span><br><span class="line">            (customer, created) = Customer.objects.get_or_create(</span><br><span class="line">                user=self.context[<span class="string">'user_id'</span>],)</span><br><span class="line">            order = Order.objects.create(customer=customer)</span><br><span class="line">            cart_id = self.validated_data[<span class="string">'cart_id'</span>]</span><br><span class="line">            cart_items = CartItem.objects\</span><br><span class="line">                .select_related(<span class="string">'product'</span>)\</span><br><span class="line">                .filter(cart_id=cart_id)\</span><br><span class="line"></span><br><span class="line">            order_items = [</span><br><span class="line">                OrderItem(</span><br><span class="line">                    order=order,</span><br><span class="line">                    product=item.product,</span><br><span class="line">                    unit_price=item.product.unit_price,</span><br><span class="line">                    quantity=item.quantity,</span><br><span class="line">                ) <span class="keyword">for</span> item <span class="keyword">in</span> cart_items</span><br><span class="line">            ]</span><br><span class="line"></span><br><span class="line">            OrderItem.objects.bulk_create(order_items)</span><br><span class="line"></span><br><span class="line">            Cart.objects.filter(pk=cart_id).delete()</span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果在订单创建一半的时候服务器崩掉了，怎么办？我们肯定需要回滚，因此我们可以将其视作一个数据库事务。为了实现事务功能，我们在代码前面加上 <code>with transaction.atomic()</code> 即可</p>
<p>结果如下，我们首先创建一个购物车。</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/86.png"></p>
<p>然后，我们把购物车编号输入，用POST方法创建一个订单</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/87.png"></p>
<p>然后，用GET方法就可以获得当前用户的所有订单。</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/88.png"></p>
<h3 id="Returning-the-Created-Order"><a href="#Returning-the-Created-Order" class="headerlink" title="Returning the Created Order"></a>Returning the Created Order</h3><p>我们现在发现，当我们用一个购物车号码去创建一个订单的时候，返回的结果只是它的订单号，而我们希望的是直接返回这个创建好后的订单：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/89.png"></p>
<p>这是因为，在<code>OrderViewSet</code> 中，我们让其继承自 ModelViewSet，我们查看其源代码中的 <code>CreateModelMixin</code>类如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateModelMixin</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Create a model instance.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        serializer = self.get_serializer(data=request.data)</span><br><span class="line">        serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        self.perform_create(serializer)</span><br><span class="line">        headers = self.get_success_headers(serializer.data)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)</span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p>我们发现，首先它会获取到ViewSet中定义的serializer，然后创建一个对象。在Response中, 同样用这个serializer来构造返回信息。因此，在这个例子中，当使用 POST请求方法的时候，用到的是<code>CreateOrderSerializer</code> ，这个serializer只接收一个字段——购物车的号码，因此返回体中也只有这个购物车号这一个字段</p>
<p>为了修改这个bug，我们可以重写create函数，让其覆盖掉返回时候的那个serializer，从而返回刚刚创建的订单对象。 需要注意的是，由于<code>CreateOrderSerializer</code> 需要接受到user_id和请求体中的cart_id，所以我们要传入两组数据。</p>
<p><code>get_serializer_context</code> 的作用就是给serializer带去“额外”(不在请求体之内的) 信息的，现在我们在重写create函数的时候直接传入了context，因此这个函数可以删去。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    permission_classes = [IsAuthenticated]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        serializer = CreateOrderSerializer(data=request.data,</span><br><span class="line">                                           context=&#123;</span><br><span class="line">                                               <span class="string">'user_id'</span>: self.request.user.id, &#125;</span><br><span class="line">                                           )</span><br><span class="line">        serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        order = serializer.save()</span><br><span class="line">        serializer = OrderSerializer(order)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_serializer_class</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.request.method == <span class="string">'POST'</span>:</span><br><span class="line">            <span class="keyword">return</span> CreateOrderSerializer</span><br><span class="line">        <span class="keyword">return</span> OrderSerializer</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># def get_serializer_context(self):</span></span><br><span class="line">    <span class="comment">#     return context=&#123;'user_id': self.request.user.id, &#125;)</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.request.user.is_staff:</span><br><span class="line">            <span class="keyword">return</span> Order.objects.all()</span><br><span class="line"></span><br><span class="line">        (customer_id, created) = Customer.objects.only(</span><br><span class="line">            <span class="string">'id'</span>,).get_or_create(user_id=self.request.user.id)</span><br><span class="line">        Order.objects.filter(customer_id=customer_id)</span><br></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/90.png"></p>
<h3 id="Data-Validation-1"><a href="#Data-Validation-1" class="headerlink" title="Data Validation"></a>Data Validation</h3><p> 现在我们虽然已经实现了创建订单，返回订单，但是如果我们用一个cart_id重复创建订单的话，系统并不会给我们报错，而这是不被允许的——因为当订单创建后，购物车会被删除，此时cart_id 就不存在了。</p>
<p>我们需要排除的情况是：</p>
<ul>
<li>当前的UUID并不存在(购物车ID非法)</li>
<li>当前的购物车中并没有任何物品</li>
</ul>
<p>我们可以再Serializer Class中对特定的字段进行验证，格式为：函数 <code>validate_{字段名}</code> ,比如说我们对cart_id进行验证。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateOrderSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> transaction.atomic():</span><br><span class="line">        cart_id = serializers.UUIDField()<span class="comment"># 必须是在Serializer中的字段才可以被验证</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">validate_cart_id</span><span class="params">(self, cart_id)</span>:</span></span><br><span class="line">          <span class="comment"># 如果购物车号不存在，那么就会报错</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> Cart.objects.filter(pk=cart_id).exists():</span><br><span class="line">                <span class="keyword">raise</span> serializers.ValidationError(</span><br><span class="line">                    <span class="string">"No cart with id %s exists"</span> % cart_id)</span><br><span class="line">          <span class="comment"># 如果购物车中没有一件商品，也会报错</span></span><br><span class="line">            <span class="keyword">if</span> CartItem.objects.filter(cart_id=cart_id).count() == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">raise</span> serializers.ValidationError(</span><br><span class="line">                  	<span class="string">"The cart with id % s is EMPTY!"</span> % cart_id)</span><br><span class="line">            <span class="keyword">return</span> cart_id</span><br></pre></td></tr></table></figure>
<p>结果如下</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/91.png"></p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/92.png"></p>
<h3 id="Revisiting-the-Permissions"><a href="#Revisiting-the-Permissions" class="headerlink" title="Revisiting the  Permissions"></a>Revisiting the  Permissions</h3><p>如果我们想给不同的人不同的权限怎么办？在ViewSets里面怎么修改？</p>
<p>比如说，对于订单删除功能，我只想开放给Admin，对于一般的用户，是不能删除创建的订单的的，为此，我们可以重写<code>get_permissions</code>函数 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    http_method_names = [<span class="string">'get'</span>, <span class="string">'patch'</span>,<span class="string">'post'</span> ,<span class="string">'delete'</span>, <span class="string">'head'</span>, <span class="string">'options'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_permissions</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.request.method <span class="keyword">in</span> [<span class="string">'PATCH'</span>, <span class="string">'DELETE'</span>]:</span><br><span class="line">            <span class="keyword">return</span> [IsAdminUser()]</span><br><span class="line">        <span class="keyword">return</span> [IsAuthenticated()]</span><br></pre></td></tr></table></figure>
<h3 id="Updating-an-Order"><a href="#Updating-an-Order" class="headerlink" title="Updating an Order"></a>Updating an Order</h3><p>修改完权限后，就必须是管理员才能修改订单了，但是，在修改订单的时候，我们只希望修改订单的状态，其他字段我们希望它是只读的。但是，如果我们直接修改OrderSerializer的话，需要给除了<code>payment_status</code> 以外的字段都加上read_only，这是比较繁琐的，而且如果以后有新的字段进来，还是要修改OrderSerializer的。</p>
<p>因此，我们可以另外创建一个UpdateOrderSerializer，专门来更新Order</p>
<ul>
<li>serializer.py</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpdateOrderSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Order</span><br><span class="line">        fields = [<span class="string">'payment_status'</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>views.py&gt; class OrderViewSet</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_serializer_class</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.request.method == <span class="string">'POST'</span>:</span><br><span class="line">        <span class="keyword">return</span> CreateOrderSerializer</span><br><span class="line">    <span class="keyword">elif</span> self.request.method == <span class="string">'PATCH'</span>:</span><br><span class="line">        <span class="keyword">return</span> UpdateCartItemSerializer</span><br><span class="line">    <span class="keyword">return</span> OrderSerializer</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/93.gif"></p>
<h3 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h3><p>之前，我们在<code>OrderViewSet</code>的<code>get_queryset</code> 函数中，我们使用了 <code>get_or_create</code> 方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">    (customer_id, created) = Customer.objects.only(</span><br><span class="line">        <span class="string">'id'</span>,).get_or_create(user_id=self.request.user.id)</span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p>因为在我们这个app中，先要创建一个User对象，然后， 再需要手动创建Customer，让其和User建立一对一的关系。因此存在忘记创建Customer的情况，使用了<code>get_or_create</code>之后，当检测到对应User的Customer未创建，就会自动创建一个Customer对象。</p>
<p>但这种方法毕竟是权宜之计，我们想要的理想状态是：当创建了User之后，会自动生成对应的Customer对象(默认)，然后，用户可以去自行修改其Customer对象的信息。</p>
<p>由此，我们就需要用到Signal了。 顾名思义，信号允许应用程序在发生特定事件时得到通知 。比如说，我想在有人发表评论或对文章做出React时通知文章作者，我们就可以使用信号。只要指定的Model被保存下来(修改、更新)，就会发送signal，接收器收到以后，会执行相应的动作</p>
<ul>
<li><p>信号系统包含以下三要素：</p>
<ul>
<li>发送者－信号的发出方</li>
<li>信号－信号本身</li>
<li>接收者－信号的接受者</li>
</ul>
</li>
</ul>
<p>Django内置了一整套信号，下面是一些比较常用的：</p>
<ul>
<li><code>django.db.models.signals.pre_save</code> &amp; <code>django.db.models.signals.post_save</code></li>
</ul>
<p>在ORM模型的save()方法调用之前或之后发送信号</p>
<ul>
<li><code>django.db.models.signals.pre_delete</code>&amp; <code>django.db.models.signals.post_delete</code></li>
</ul>
<p>在ORM模型或查询集的delete()方法调用之前或之后发送信号。</p>
<ul>
<li><code>django.db.models.signals.m2m_changed</code></li>
</ul>
<p><code>m2m_changed</code>当多对多字段被修改时发送信号。</p>
<ul>
<li><code>django.core.signals.request_started</code> &amp;<code>django.core.signals.request_finished</code></li>
</ul>
<p>当接收和关闭HTTP请求时发送信号。</p>
<h4 id="监听信号"><a href="#监听信号" class="headerlink" title="监听信号"></a>监听信号</h4><ul>
<li>接收器</li>
</ul>
<p>首先我们要用到 <code>@receiver</code>这个修饰器，被它修饰的函数把这三者都集成到了一起。</p>
<p>在这个例子中，<code>signal</code>是<code>post_save</code>, 发送者是<code>core.User</code> , 如果是成功创建了的话，Customer就会创建出对应的对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models.signals <span class="keyword">import</span> post_save</span><br><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> receiver</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Customer</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@receiver(post_save, sender=settings.AUTH_USER_MODEL)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_customer_for_new_user</span><span class="params">(sender, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> kwargs[<span class="string">'created'</span>]:</span><br><span class="line">        Customer.objects.create(user=kwargs[<span class="string">'instance'</span>])</span><br></pre></td></tr></table></figure>
<ul>
<li>随后在apps/store/app.py的config类下重写ready方法,用来激活signals，因为这个app对core.User发出来的signal比较感兴趣。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoreConfig</span><span class="params">(AppConfig)</span>:</span></span><br><span class="line">    default_auto_field = <span class="string">'django.db.models.BigAutoField'</span></span><br><span class="line">    name = <span class="string">'store'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ready</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">import</span> store.signals</span><br></pre></td></tr></table></figure>
<p>结果如下，我们看到，当创建了一个新用户的时候，对应的Customer也被创建了</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/94.png"></p>
<h3 id="Creating-Custom-Signals"><a href="#Creating-Custom-Signals" class="headerlink" title="Creating Custom Signals"></a>Creating Custom Signals</h3><p>此外，我们也可以自定义signals，比如说，当我创建了一个订单之后，我可以发送一个Signal。对这个signal感兴趣的app 就可以捕获它，实现提示用户等功能</p>
<p>由于情况变得复杂(这个app中既有系统信号又有自定义信号)，我们把逻辑都移动到signals文件夹当中。其中，文件夹中的 <code>handlers.py</code> 用来存放 receiver的逻辑。<code>__init__.py</code> 用来存放新建的自定义信号。比如说，我想创建一个<code>order_created</code>信号，在订单创建时候发送</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> Signal</span><br><span class="line">order_created = Signal()</span><br></pre></td></tr></table></figure>
<p>然后，我们需要设计发送逻辑,我们希望在订单创建时候发送这个信号，就需要修改Serializer中的save函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateOrderSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> transaction.atomic():</span><br><span class="line">				<span class="comment">#...</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self,  **kwargs)</span>:</span></span><br><span class="line">          <span class="comment">#...</span></span><br><span class="line">         	<span class="comment"># 用 signal.send</span></span><br><span class="line">					order_created.send_robust(self.__class__,order = order) </span><br><span class="line">          <span class="keyword">return</span> order</span><br></pre></td></tr></table></figure>
<blockquote>
<p>信息发送有两个函数：send和send_robust</p>
<p>顾名思义，后者比较鲁棒，稳定性较强。</p>
<p>因为<code>send</code>函数，当其中一个receiver在接收信号的时候发生了错误，是不会影响其他receiver的，但<code>send_robust</code> 函数会捕获receiver发生的异常，并添加到返回的 responses数组中。</p>
</blockquote>
<p>当store发出了这个signal之后，我们希望core app可以收到这个消息并做出一定的动作。那么，我们需要在core中也创建一个receiver。同样的，我们创建signals文件夹，里面再新建一个handlers.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> store.signals <span class="keyword">import</span> order_created</span><br><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> receiver</span><br><span class="line"><span class="comment"># 在这里我们没有指定sender，默认只要收到信号就执行</span></span><br><span class="line"><span class="meta">@receiver(order_created)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_order_created</span><span class="params">(sender, **kwargs)</span>:</span></span><br><span class="line">    print(kwargs[<span class="string">'order'</span>])</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/" itemprop="url">神经网络和反向传播</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-12-02T22:44:42+08:00">
                2021-12-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2021-12-27T12:30:46+08:00">
                2021-12-27
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="神经网络和反向传播"><a href="#神经网络和反向传播" class="headerlink" title="神经网络和反向传播"></a>神经网络和反向传播</h1><h2 id="损失函数和优化"><a href="#损失函数和优化" class="headerlink" title="损失函数和优化"></a>损失函数和优化</h2><p>在大多数机器学习模型中，都会有一个<strong>损失函数(lost function)</strong>。比如常见的MSE：</p>
<script type="math/tex; mode=display">
L(w,b) = \frac{1}{N}\sum_{i=1}^n(y_i-f(wx_i+b))^2</script><p>损失函数用来衡量机器学习模型的精确度。一般来说，损失函数的值越小，模型的精确度就越高。如果要提高机器学习模型的精确度，就需要尽可能降低损失函数的值。而降低损失函数的值，我们一般采用梯度下降这个方法。所以，<strong>梯度下降的目的，就是为了最小化损失函数。</strong></p>
<h3 id="梯度下降的原理"><a href="#梯度下降的原理" class="headerlink" title="梯度下降的原理"></a>梯度下降的原理</h3><p>寻找损失函数的最低点，就像我们在山谷里行走，希望找到山谷里最低的地方。那么如何寻找损失函数的最低点呢？在这里，我们使用了微积分里导数，通过求出函数导数的值，从而找到函数下降的方向或者是最低点（极值点）。</p>
<p>损失函数里一般有两种参数，一种是控制输入信号量的权重(Weight, 简称 $w$ ），另一种是调整函数与真实值距离的偏差（Bias，简称 $b$ ）。我们所要做的工作，就是通过梯度下降方法，不断地调整权重$w$和偏差$b$，使得损失函数的值变得越来越小。</p>
<p>假设某个损失函数里，模型损失值 $L$与权重 $w$ 下图这样的关系。实际模型里，可能会有多个权重$w$，这里为了简单起见，举只有一个权重$w$的例子。权重$w$目前的位置是在A点。此时如果求出A点的梯度 $\frac{dL}{dw}$ ，便可以知道如果我们向右移动，可以使损失函数的值变得更小。</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/1.png" style="zoom:150%;"></p>
<p>用数学语言来解释一下：假设只有一个参数w</p>
<ul>
<li>那么导数$\frac{dL(w)}{dw}=\lim\limits_{h\rightarrow0}\frac{L(w+h)-L(w)}{h}$ 就代表L在w的切线斜率，即$L(w)$在该店的变化速率和方向。那么，只要导数不为0，我们往反方向微调就可以减小$L(w)$</li>
</ul>
<p>当有多维情况下，会有多个权重，此时$\boldsymbol W$ 为向量</p>
<ul>
<li>那么偏导数$[\frac{\partial L(\boldsymbol W)}{\partial w<em>1},\frac{\partial L(\boldsymbol W)}{\partial w_2},\cdots,\frac{\partial L(\boldsymbol W)}{\partial w_n}]$ 代表L在$\boldsymbol W$ 处沿每个维度的变化速率和方向，称为梯度和(gradient)，记为$\nabla</em>{\boldsymbol W}L$ 或$grad(L(\boldsymbol W))$ 。这个时候，我们需要把各个样本数据的权重梯度加起来，并求出它们的平均值，用这个平均值来作为样本整体的权重梯度。</li>
<li>$\nabla<em>{\boldsymbol W}L$ 和方向向量$\boldsymbol v$ 的点积即为该方向的斜率(方向导数)，公式为$\nabla</em>{\boldsymbol W}L\cdot v=|\nabla<em>{\boldsymbol W}L||v|\cos\theta$。当$cos(\theta)=1$ 的时候达到最大值。因此，负梯度 $-\nabla</em>{\boldsymbol W}L$ 的方向即为 L 在$\boldsymbol W$处下降最快的方向， 沿$-\nabla_{\boldsymbol W}L$方向微调就可以快速减小$L(\boldsymbol W)$(即梯度下降)</li>
<li>梯度下降的公式为： $W<em>{\text{new}} = W-\lambda\nabla</em>{\boldsymbol W}L$  ，其中$\lambda$是超参数，其含义就是<strong>学习率(Learning Rate)</strong>或者<strong>步长(Step size)</strong></li>
</ul>
<p>如果学习率$\lambda$设置得过大，有可能我们会错过损失函数的最小值；如果设置得过小，可能我们要迭代式子(2)非常多次才能找到最小值，会耗费较多的时间。因此，在实际应用中，我们需要为学习率设$\lambda$置一个合适的值。</p>
<h3 id="梯度下降的过程"><a href="#梯度下降的过程" class="headerlink" title="梯度下降的过程"></a>梯度下降的过程</h3><p>我们把上面的内容稍微整理一下，可以得到梯度下降的整体过程：</p>
<ol>
<li>for i = 0 to 训练数据的个数：</li>
</ol>
<p>(1) 计算第 i 个训练数据的权重 $w$ 和偏差 $b$ 相对于损失函数的梯度。于是我们最终会得到每一个训练数据的权重和偏差的梯度值。</p>
<p>(2) 计算所有训练数据权重  $w$ 的梯度的总和。</p>
<p>(3) 计算所有训练数据偏差 $b$ 的梯度的总和。</p>
<ol>
<li>做完上面的计算之后，我们开始执行下面的计算：</li>
</ol>
<p>(1) 使用上面第(2)、(3)步所得到的结果，计算所有样本的权重和偏差的梯度的平均值。</p>
<p>(2) 使用下面的式子，更新每个样本的权重值和偏差值。</p>
<script type="math/tex; mode=display">
w_{i+1} = w_i-\lambda\cdot\frac{dL}{d_{w_i}}\\
b_{i+1} = b_i-\lambda\cdot\frac{dL}{d_{w_i}}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def train(X, y, W, B, alpha, max_iters):</span><br><span class="line">    &#39;‘’</span><br><span class="line">    选取所有的数据作为训练样本来执行梯度下降</span><br><span class="line">    X : 训练数据集</span><br><span class="line">    y : 训练数据集所对应的目标值</span><br><span class="line">    W : 权重向量</span><br><span class="line">    B ： 偏差变量</span><br><span class="line">    alpha ： 学习速率</span><br><span class="line">    max_iters : 梯度下降过程最大的迭代次数</span><br><span class="line">   &#39;&#39;&#39;</span><br><span class="line">   dW &#x3D; 0 # 初始化权重向量的梯度累加器</span><br><span class="line">   dB &#x3D; 0 # 初始化偏差向量的梯度累加器</span><br><span class="line">   m &#x3D; X.shape[0] # 训练数据的数量</span><br><span class="line">   </span><br><span class="line">   # 开始梯度下降的迭代</span><br><span class="line">   for i in range(max_iters): </span><br><span class="line">       dW &#x3D; 0 # 重新设置权重向量的梯度累加器</span><br><span class="line">       dB &#x3D; 0 # 重新设置偏差向量的梯度累加器</span><br><span class="line">       </span><br><span class="line">       # 对所有的训练数据进行遍历</span><br><span class="line">       for j in range(m):</span><br><span class="line">           # 1. 遍历所有的训练数据</span><br><span class="line">           # 2. 计算每个训练数据的权重向量梯度w_grad和偏差向量梯度b_grad</span><br><span class="line">           # 3. 把w_grad和b_grad的值分别累加到dW和dB两个累加器里</span><br><span class="line">       </span><br><span class="line">       W &#x3D; W - alpha * (dW &#x2F; m) # 更新权重的值</span><br><span class="line">       B &#x3D; B - alpha * (dB &#x2F; m) # 更新偏差的值</span><br><span class="line"></span><br><span class="line">    return W, B # 返回更新后的权重和偏差。</span><br></pre></td></tr></table></figure>
<h3 id="其他常见的梯度下降算法"><a href="#其他常见的梯度下降算法" class="headerlink" title="其他常见的梯度下降算法"></a>其他常见的梯度下降算法</h3><p>上面介绍的梯度下降算法里，在迭代每一次梯度下降的过程中，都对所有样本数据的梯度进行计算。虽然最终得到的梯度下降的方向较为准确，但是运算会耗费过长的时间。于是人们在上面这个算法的基础上对样本梯度的运算过程进行了改进，得到了下面这两种也较为常见的算法：</p>
<h4 id="小批量样本梯度下降（Mini-Batch-GD"><a href="#小批量样本梯度下降（Mini-Batch-GD" class="headerlink" title="小批量样本梯度下降（Mini Batch GD)"></a>小批量样本梯度下降（Mini Batch GD)</h4><p>这个算法在每次梯度下降的过程中，只选取一部分的样本数据进行计算梯度，比如整体样本1/100的数据。在数据量较大的项目中，可以明显地减少梯度计算的时间。</p>
<h4 id="随机梯度下降（Stochastic-GD"><a href="#随机梯度下降（Stochastic-GD" class="headerlink" title="随机梯度下降（Stochastic GD)"></a>随机梯度下降（Stochastic GD)</h4><p>随机梯度下降算法只随机抽取<strong>一个</strong>样本进行梯度计算，由于每次梯度下降迭代只计算一个样本的梯度，因此运算时间比小批量样本梯度下降算法还要少很多，但由于训练的数据量太小（只有一个），因此下降路径很容易受到训练数据自身噪音的影响，看起来就像醉汉走路一样，变得歪歪斜斜的。</p>
<blockquote>
<p>GD的优势：每次迭代loss下降快</p>
<p>GD的劣势：一次迭代需要遍历所有数据，并且容易陷入local minima(局部极小值)</p>
<p>SGD的优势：迭代更新速度快，并且往往因为minibatch含有噪声而避开local minima</p>
<p>SGD的劣势：每次迭代，loss下降较慢</p>
</blockquote>
<p>由于数据量较大，训练深度神经网络基本使用SGD，以及其他性能更加的优化方法</p>
<h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>我们在<a href="https://jasonxqh.github.io/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/">人工神经网络</a> 这篇博客里面感性的认识了一下神经网络的架构，现在我们回顾并从数学角度重新学习一遍。</p>
<p>我们学过很多线性分类器，但是有很多非线性的分类情况我们是很难用线性分类器来解决的：</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/2.png" style="zoom: 67%;"></p>
<p>比如这种分类，我们只能够通过增加高阶多项事项来让分类器可行。那么当输入变量有n个的时候，最多会导致$O(n^n)$级别的参数，显然是不可行的。</p>
<h3 id="单层神经网络"><a href="#单层神经网络" class="headerlink" title="单层神经网络"></a>单层神经网络</h3><p>因此我们需要用到神经网络.我们从最简单的神经网络看起：</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/3.png"></p>
<p>在上面这个神经网络中，每条边都有一个权重，即$w_i$, 然后让权重和输入值相乘，就得到了$f(W,x)$ .这里$\boldsymbol W =[-30,20,20]$，对应一个偏置项(神经网络都需要的一个常数)和两个输入变量。我们用一层神经网络搭配Sigmoid激活函数可以模拟出 $y=x_1 \&amp;~x_2$的情况。</p>
<p>到这一步，神经网络还是线性的，那么就需要一个非线性的激活函数来打破这个线性。这里我们选择的是Sigmoid激活函数</p>
<p>我们可以给输入值和输出值做一个表格：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>x1</th>
<th>x2</th>
<th>$\sigma(f(W,x))$</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>$\sigma(-30)\approx0$</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>$\sigma(-10)\approx 0$</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>$\sigma(-10)\approx 0$</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>$\sigma(10)\approx 1$</td>
</tr>
</tbody>
</table>
</div>
<p>同理，我们可以通过修改权重，使得这个神经网络可以模拟$y=x_1|x_2$ 的情况，如下图所示：</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/4.png"></p>
<p>最早使用的激活函数就是 Sigmoid, 但是后来发现Sigmoid函数存在一些缺点，因此后来的神经网络大多使用tanh或者ReLU，我们在神经网络的训练那节会细讲。</p>
<p>进而我们可以设立多层的神经网络，将输出值当做下一层的输入值，再激活，再输入。以此来实现一个复杂的高维空间的模型。当神经网络的层数变多的时候，中间的几层就像是被“隐藏”起来了一样，因此我们称其为<strong>hidden layer(隐藏层)</strong></p>
<h3 id="hidden-layer"><a href="#hidden-layer" class="headerlink" title="hidden layer"></a>hidden layer</h3><p>在正常情况下，hidden layer肯定不止一个神经元，因为需要不同的神经元来捕捉不同的特征</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/5.png"></p>
<p>比如说上面这个两层的神经网络：输入层有三个变量，一个偏置项；隐藏层有四个神经元和一个偏置项。</p>
<p>那么我们可以得到hidden layer的计算公式：</p>
<script type="math/tex; mode=display">
a_1 = \sigma(w_{11}^1x_1+w_{12}^1x_2+w_{13}^1x_3+b_1^1)\\
a_2 = \sigma(w_{21}^1x_1+w_{22}^1x_2+w_{23}^1x_3+b_2^1)\\
a_3 = \sigma(w_{31}^1x_1+w_{32}^1x_2+w_{33}^1x_3+b_3^1)\\
a_4 = \sigma(w_{41}^1x_1+w_{42}^1x_2+w_{43}^1x_3+b_4^1)\\</script><p>用矩阵的思路来说，就是 </p>
<script type="math/tex; mode=display">
\boldsymbol a = \sigma(\boldsymbol {W^1x}+\boldsymbol b)\\</script><p>现在，hidden layer的输出结果变成了output layer 的输入结果，此时output layer一共有3个神经元，计算公式如下：(注意，这里的上标不代表平方而代表该权重位于第二层)</p>
<script type="math/tex; mode=display">
h_1 = \sigma(w_{11}^2a_1+w_{12}^2a_2+w_{13}^2a_3+w_{14}^2a_4+b_1^2)\\
h_2 = \sigma(w_{21}^2a_1+w_{22}^2a_2+w_{23}^2a_3+w_{24}^2a_4+b_2^2)\\
h_3 = \sigma(w_{31}^2a_1+w_{32}^2a_2+w_{33}^2a_3+w_{34}^2a_4+b_3^2)\\</script><h4 id="矩阵思路"><a href="#矩阵思路" class="headerlink" title="矩阵思路"></a>矩阵思路</h4><p>如果我们先不考虑偏置项，但考虑输入和输出，我们从矩阵的思路来理解一下每个层数的计算。</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/6.png"></p>
<p>那么，对于hidden layer来说，其权重矩阵的大小就是$H$行$D$列：</p>
<script type="math/tex; mode=display">
\boldsymbol{W^1} \in \mathbb R^{H\times D}</script><p>对于output layer来说，其权重矩阵的大小就是$C$行$H$列：</p>
<script type="math/tex; mode=display">
\boldsymbol W^2\in\mathbb R^{C\times H}</script><p>那么，如果是三层神经网络呢？</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/7.png"></p>
<p>此时，对于第一层隐藏层，$\boldsymbol{W^1} \in \mathbb R^{H_1\times D}$</p>
<p>对于第二层隐藏层，$\boldsymbol{W^2} \in \mathbb R^{H_2\times H_1}$</p>
<p>对于第三层输出层，$\boldsymbol W^3\in \mathbb R^{C\times H^2}$</p>
<p>用代码来表示，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f &#x3D; lambda x: 1.0&#x2F;(1.0+np.exp(-x)) # activation function(use sigmoid)</span><br><span class="line">x &#x3D; np.random.randn(3,1) # random input vector of three numbers(3x1)</span><br><span class="line">h1 &#x3D; f(np.dot(W1,x)+b1)	 # calculate first hidden layer activations(4x1)</span><br><span class="line">h2 &#x3D; f(np.dot(W2,h1)+b2) # calculate second hidden layer activations(4x1)</span><br><span class="line">out &#x3D; np.dot(W3,h2)+b3	 # output neuron(1x1)</span><br></pre></td></tr></table></figure>
<h4 id="随机连接的神经网络"><a href="#随机连接的神经网络" class="headerlink" title="随机连接的神经网络"></a>随机连接的神经网络</h4><p>事实上，神经网络之间是可以随机连接的，并不需要像我们上面介绍的那样全连接，如下图所示：</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/9.png"></p>
<h3 id="两层神经网络"><a href="#两层神经网络" class="headerlink" title="两层神经网络"></a>两层神经网络</h3><p>上面引入了多层神经网络的概念，那么用简单的两层神经网络可以解决什么问题呢？表示 异或 关系，如下图所示：</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/10.png"></p>
<p>同样用Sigmoid做激活函数，可以得到如下表格：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>x1</th>
<th>x2</th>
<th>a1</th>
<th>a2</th>
<th>h</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>$\sigma(-30)\approx0$</td>
<td>$\sigma(10)\approx1$</td>
<td>$\sigma(10)\approx1$</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>$\sigma(-10)\approx0$</td>
<td>$\sigma(-10)\approx0$</td>
<td>$\sigma(-10)\approx0$</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>$\sigma(-10)\approx0$</td>
<td>$\sigma(-10)\approx0$</td>
<td>$\sigma(-10)\approx0$</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>$\sigma(10)\approx1$</td>
<td>$\sigma(-30)\approx0$</td>
<td>$\sigma(10)\approx1$</td>
</tr>
</tbody>
</table>
</div>
<h2 id="神经网络的计算"><a href="#神经网络的计算" class="headerlink" title="神经网络的计算"></a>神经网络的计算</h2><p>现在我们来看看一个神经网络是如何被计算的</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/11.png"></p>
<p>对于这个神经网络，我们训练集是：$(x<em>i,y_i)</em>{i=1}^N$ ,其中$x_i$是向量，$y_i$是标签。激活函数式ReLU</p>
<ol>
<li>第一步，我们计算 $f(x;\boldsymbol W^1)$  ,然后输入到ReLU中去激活得到 $\boldsymbol a$</li>
<li>接着我们把$\boldsymbol a$ 和 $\boldsymbol W^2$ 计算得到 $\boldsymbol s = f(\boldsymbol a,\boldsymbol W^2)$ </li>
<li>用Softmax 来计算 $h<em>k = \frac{e^{s_k}}{\sum</em>{j}e^{s_j}}$  得到输出值</li>
<li>计算损失函数，其组成为softmax的损失函数加上第一层、第二层权重的正则项 $L = \frac{1}{N} \sum_{i=1}^Nl(\boldsymbol h_i,y_i)+\lambda R(\boldsymbol W^1)+\lambda R(\boldsymbol W^2)$</li>
<li>优化损失函数：计算解析梯度 $\frac{\partial L}{\partial \boldsymbol W^1},\frac{\partial L}{\partial \boldsymbol W^2}$ ，可以通过数值梯度去计算，得到$\nabla<em>{\boldsymbol W}L = \nabla</em>{\boldsymbol W}[\frac{1}{N}\sum_{i=1}^N(l(\boldsymbol h_i,y_i)+\lambda R(\boldsymbol W^1)+\lambda R(\boldsymbol W^2))]$</li>
</ol>
<p>这边只有两层，我们就发现解析梯度是如此的难求，那么如果神经网络的梯度再往上加的话，对计算机来说计算梯度是很复杂的一件事，因此，我们就需要<strong>反向传播</strong>这个技巧了</p>
<h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><p>我们在高数里面，已经学会了链式法则。那么，在计算梯度的时候，我们也可以用这套法则来较为方便得计算出权重的梯度。</p>
<p>比如说，我们得到了损失函数 $L$, 根据公式: $\frac{\partial L}{\partial \boldsymbol W^2} = \frac{\partial L}{\partial\boldsymbol h}\frac{\partial \boldsymbol h}{\partial \boldsymbol W^2}$， 我们可以先求出L关于$\boldsymbol h$的导数，然后再去求$h$关于$\boldsymbol W^2$的导数。</p>
<p>如果我们想计算$\frac{\partial L}{\partial \boldsymbol W^1}$ ，那么我们就在再向前推一层，根据公式：$\frac{\partial L}{\partial \boldsymbol W^1} = \frac{\partial L}{\partial\boldsymbol h}\frac{\partial  \boldsymbol h}{\partial \boldsymbol a}\frac{\partial \boldsymbol a}{\partial\boldsymbol W^1}$ 。</p>
<p>可以看到，反向传播的原理就是每一层的输出对这一层的输入求一个梯度，也就是按照从右往左的顺序来求梯度。</p>
<h4 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h4><p>我们把某个神经网络的计算图画出来。计算图可以看做是一个可视化的神经网络，把每一步的计算都用一个结构来表示，有了计算图就可以以很清晰的思路来编写代码了</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/12.png"></p>
<h5 id="前向传播1"><a href="#前向传播1" class="headerlink" title="前向传播1"></a>前向传播1</h5><p>上面是$x_1,w_1,x_2,w_2,b$ 的初始值，根据这些初始值，我们可以前向计算来得到每个节点的输出值：</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/13.png"></p>
<h5 id="反向传播1"><a href="#反向传播1" class="headerlink" title="反向传播1"></a>反向传播1</h5><p>接下来，我们要反向传播，从最后一步向前计算，首先我们假设这已经到了最后一层，因此最后一层的梯度就定为$\frac{\partial h}{\partial \sigma}=1$。然后我们从最后一层开始计算倒数第二层的梯度</p>
<p>对于倒数第二层，我们要知道链式法则：$\frac{\partial h}{\partial x} = \frac{\partial h}{\partial \sigma}\frac{\partial \sigma}{\partial x}$ </p>
<p>现在已知上游梯度 $\frac{\partial h}{\partial \sigma}=1$, 只要计算这层<strong>局部梯度</strong>，再把这层的输入值带入即可求得。因为$f(x) = \frac{1}{x}$ 所以 $\frac{df}{dx} = -\frac{1}{x^2}$ ,再把这层的输入值1.37带入，得到：$\frac{\partial h}{\partial x} = 1\times(-1/1.37^2)=-0.53$</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/14.png"></p>
<h5 id="反向传播2"><a href="#反向传播2" class="headerlink" title="反向传播2"></a>反向传播2</h5><p>现在，我们已经计算得到了两层梯度，继续向前推进。现在，$f(x) = x+1$,因此局部梯度 $\frac{df}{dx} = 1$, 输入值为0.37。但是这层得到的梯度和输入值无关，因此这层反向传播得到的值为$-0.53\times 1 = -0.53$</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/15.png"></p>
<h5 id="反向传播3"><a href="#反向传播3" class="headerlink" title="反向传播3"></a>反向传播3</h5><p>再向前推， 现在$f(x) = e^x$, 上游梯度为-0.53, 局部梯度为 $\frac{df}{dx} =e^x$, 输入值为-1。这层反向传播得到的值为 $-0.53\times e^{-1}=-0.2$</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/16.png"></p>
<h5 id="反向传播4"><a href="#反向传播4" class="headerlink" title="反向传播4"></a>反向传播4</h5><p>现在$f(x) = x-1$ ，局部梯度为 $-1$ ，和输入值无关，上游梯度为-0.2。 这层反向传播得到的值为：$-0.2\times -1=0.2$</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/17.png"></p>
<h5 id="反向传播5"><a href="#反向传播5" class="headerlink" title="反向传播5"></a>反向传播5</h5><p>到这一部分，神经网络开始分叉了，在这里 $f(x)$ 为两个输入值的和。我们分别把每个输入值都当做主元，那么对于b，上游梯度为0.2, 局部梯度为$\frac{df}{dx} = 1$ ，与输入值无关，因此反向传播得到的值为0.2</p>
<p>对于另外一个神经元，同理，与输入值无关，反向传播得到的值为0.2</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/18.png"></p>
<h5 id="反向传播6"><a href="#反向传播6" class="headerlink" title="反向传播6"></a>反向传播6</h5><p>在这一层神经网络又分叉了，但这层还是两个输入值相加, 和上一层是一样的，因此都是0.2</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/19.png"></p>
<h5 id="反向传播7"><a href="#反向传播7" class="headerlink" title="反向传播7"></a>反向传播7</h5><p>在这一层，我们先来看上面的分叉。$f(x)$为两个输入值的乘积，当我们把$x_1$当做主元的时候，$f(x) = -x$, 因此 $\frac{df}{dx_1}=-1$, 与输入值无关，上游梯度为0.2,因此反向传播得到的值为$0.2\times -1 =-0.2$</p>
<p>当把 $w_1$看做主元的时候，$f(x)= 2x,\frac{df}{dw_1} = 2$,与输入值无关，上游梯度的值为0.2. 因此反向传播得到的值为 $0.2\times 2 = 0.4$</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/20.png"></p>
<h5 id="反向传播8"><a href="#反向传播8" class="headerlink" title="反向传播8"></a>反向传播8</h5><p>现在来看下层的分叉。同样是输入值的乘积。</p>
<p>当我们把$x_2$当做主元的时候，$f(x) = -2x$, 因此 $\frac{df}{dx_2}=-2$, 与输入值无关，上游梯度为0.2,因此反向传播得到的值为$0.2\times -2=-0.4$</p>
<p>当把 $w_2$看做主元的时候，$f(x)= -3x,\frac{df}{dw_2} = 3$,与输入值无关，上游梯度的值为0.2. 因此反向传播得到的值为 $0.2\times -3 = -0.6$</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/21.png"></p>
<h4 id="分块计算图"><a href="#分块计算图" class="headerlink" title="分块计算图"></a>分块计算图</h4><p>细心地同学可能已经发现了，在正向传播的时候， 导数第1、2、3、4步合起来刚好是一个 $\frac{1}{1+e^{-x}}$ 的函数，也就是我们选择的Sigmoid激活函数。事实上，Sigmoid有自己的梯度形式，因此可以把计算图简单化。</p>
<p>这样，只要求 Sigmoid的本地梯度就可以了，相当于多步并一步：</p>
<script type="math/tex; mode=display">
\frac{d\sigma(x)}{dx} = \frac{e^{-x}}{(1+e^{-x})^2} = (\frac{1+e^{-x}-1}{1+e^{-x}})(\frac{1}{1+e^{-x}}) = (1-\sigma(x))\sigma(x)</script><p>这样一来，上游梯度就是1，输入值$x=1$, $\sigma(x)=0.73$,  局部梯度如上所示，反向传播得到的结果是：</p>
<script type="math/tex; mode=display">
1\times[(1-0.73)\times0.73]=0.2</script><p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/22.png"></p>
<p>同样的，我们可以把前面的神经元也合并成一块，用线性函数$ y=w_1x_1+w_2x_2+b$ 来表示</p>
<p>这样，对于 $w_i,x_i$的导数，我们可以用链式法则来求得：</p>
<script type="math/tex; mode=display">
\frac{\partial \sigma}{\partial w_i} = \frac{\partial \sigma}{\partial y}\frac{\partial y}{\partial w_i}\\
\frac{\partial \sigma}{\partial x_i} = \frac{\partial \sigma}{\partial y}\frac{\partial y}{\partial x_i}\\</script><p>比如，对于$y=-x_1-2x_2-3$ ,上游梯度为0.2</p>
<script type="math/tex; mode=display">
\begin{align}
&\frac{\partial \sigma}{\partial w_1} = \frac{\partial \sigma}{\partial y}\frac{\partial y}{\partial w_1}=0.2\times2=0.4\\
&\frac{\partial \sigma}{\partial x_1} = \frac{\partial \sigma}{\partial y}\frac{\partial y}{\partial x_1}=0.2\times-1=-0.2\\
&\frac{\partial \sigma}{\partial w_2} = \frac{\partial \sigma}{\partial y}\frac{\partial y}{\partial w_2}=0.2\times-3=-0.6\\
&\frac{\partial \sigma}{\partial x_2} = \frac{\partial \sigma}{\partial y}\frac{\partial y}{\partial x_2}=0.2\times2=-0.4\\
&\frac{\partial \sigma}{\partial b} = \frac{\partial \sigma}{\partial y}\frac{\partial y}{\partial b}=0.2\times1=0.2\\
\end{align}</script><p>如下图所示：</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/23.png"></p>
<p>根据这个计算图，我们可以很有条理地写出代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(w1,w2,w3,w4)</span>:</span></span><br><span class="line">	s1 = w1*x1</span><br><span class="line">	s2 = w2*x2</span><br><span class="line">	s3 = s1+s2</span><br><span class="line">	s4 = s3+b</span><br><span class="line">	L = sigmoid(s4)</span><br><span class="line">	</span><br><span class="line">	grad_L = <span class="number">1.0</span></span><br><span class="line">	grad_s4 = grad_L*(<span class="number">1</span>-L)*(L)</span><br><span class="line">	grad_b = grad_s4</span><br><span class="line">	grad_s3 = grad_s4</span><br><span class="line">	grad_s1 = grad_s3</span><br><span class="line">	grad_s2 = grad_s3</span><br><span class="line">	grad_w1 = grad_s1*x1</span><br><span class="line">	grad_x1 = grad_s1*w1</span><br><span class="line">	grad_w2 = grad_s2*x2</span><br><span class="line">	grad_x2 = grad_s2*w2</span><br></pre></td></tr></table></figure>
<h4 id="梯度流的常见模式"><a href="#梯度流的常见模式" class="headerlink" title="梯度流的常见模式"></a>梯度流的常见模式</h4><p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/24.png"></p>
<h3 id="反向传播的矩阵运算"><a href="#反向传播的矩阵运算" class="headerlink" title="反向传播的矩阵运算"></a>反向传播的矩阵运算</h3><p>前面我们都是计算标量，但事实上每一层都有很多神经元，因此，在真正运算的时候，都是矩阵运算。</p>
<h4 id="前向运算"><a href="#前向运算" class="headerlink" title="前向运算"></a>前向运算</h4><p>我们假设输入的<strong>x是D维的横向向量</strong>，<strong>隐藏层有H个</strong>，因此权重矩阵 $W\in\mathbb R^{D\times H}$ </p>
<p>输入乘以权重矩阵后，矩阵的形状为 $(1,H)$ , 如下图所示</p>
<p>然后对每个元素进行Sigmoid激活，得到$\boldsymbol\sigma$</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/25.png"></p>
<h4 id="反向运算-输入向量"><a href="#反向运算-输入向量" class="headerlink" title="反向运算-输入向量"></a>反向运算-输入向量</h4><p>每一层计算得到的梯度矩阵的形状和这一层的输入的矩阵形状是一样的。我们首先假设在sigmoid这层反向计算得到的梯度为：$\frac{\partial h}{\partial \sigma} = [4,1,2,-1]$</p>
<h5 id="反向传播1-1"><a href="#反向传播1-1" class="headerlink" title="反向传播1"></a>反向传播1</h5><p>现在，我们来计算y这层的局部梯度： $\frac{\partial\sigma}{\partial y}$</p>
<p>我们知道，矩阵对矩阵求导，需要$\sigma$矩阵中的每一个元素对$y$矩阵中的每一个元素求导，也就是Jacobian Matrix：</p>
<script type="math/tex; mode=display">
\boldsymbol J = [\frac{\partial \boldsymbol f}{\partial x_1},\cdots,\frac{\partial \boldsymbol f}{\partial x_n}] = \begin{bmatrix}\frac{\partial f_1}{\partial x_1}&\cdots&\frac{\partial f_1}{\partial x_n}\\\vdots&\ddots&\vdots\\\frac{\partial f_m}{\partial x_1}&\cdots&\frac{\partial f_m}{\partial x_n} \end{bmatrix}</script><p>也就是说，当隐藏层矩阵的形状为$(1,H)$的时候，$\frac{\partial \sigma}{\partial y}\in \mathbb R^{H\times H}$,  显然这是很复杂的计算，当$H=4096$的时候，我们甚至需要16M的内存来储存这个Jacobian矩阵</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/26.png"></p>
<p>事实上，我们根本不需要实现 Jacobian Matirx。 因为我们发现</p>
<script type="math/tex; mode=display">
(\frac{\partial \sigma}{\partial y})_{1,1}= (1-0.007)\times0.007=0.007\\
(\frac{\partial \sigma}{\partial y})_{1,2}=(\frac{\partial \sigma}{\partial y})_{1,3}=(\frac{\partial \sigma}{\partial y})_{1,4}=0</script><p>说明$y_i$只影响$\sigma_i$, 因此只需要保留对角线上的元素即可，如下图所示：</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/27.png"></p>
<p>因此，我们可以求出这一层的梯度，也就是两个梯度对应元素相乘后累加：</p>
<script type="math/tex; mode=display">
\frac{\partial h}{\partial y} = \frac{\partial h}{\partial \sigma}\frac{\partial \sigma}{\partial y} = \begin{bmatrix}4&1&2&-1\end{bmatrix}
\begin{bmatrix}0.007&0&0&0\\0&0.01&0&0\\0&0&0.11&0\\0&0&0&0\end{bmatrix}
=\begin{bmatrix}0.028&0.01&0.22&0\end{bmatrix}</script><p>因此，我们只要固定i，然后求一个pairwise的梯度计算，得到局部梯度；再乘以上游梯度，就可以得到这一层的梯度</p>
<h5 id="反向传播2-1"><a href="#反向传播2-1" class="headerlink" title="反向传播2"></a>反向传播2</h5><p>现在，我们要把y这层的梯度往前传，求出$(\frac{\partial y}{\partial x})_{n,m}=(\frac{\partial y_n}{\partial x_m})\Rightarrow\frac{\partial y}{\partial x}\in\mathbb R^{H\times D}$</p>
<p>我们发现，$R^{H\times D}$其实和 $\boldsymbol W^T$ 的形状是一样的. 为什么呢？我们看一下 $y^T$是如何被计算得到的就豁然明了了</p>
<script type="math/tex; mode=display">
y^T = \begin{bmatrix}x_1w_{11}+x_2w_{21}+x_3w_{31}\\x_1w_{12}+x_2w_{22}+x_3w_{32}\\x_1w_{13}+x_2w_{23}+x_3w_{33}\\x_1w_{14}+x_2w_{24}+x_3w_{34} \end{bmatrix}</script><p>那么，如果y对x求偏导的话，得到的雅克比矩阵就是：</p>
<script type="math/tex; mode=display">
\frac{\partial y}{\partial x} =\begin{bmatrix}w_{11} &w_{21}&w_{31}\\w_{12}&w_{22}&w_{32}\\w_{13}&w_{23}&w_{33}\\w_{14}&w_{24}&w_{34} \end{bmatrix} = W^T</script><p>也就是说：</p>
<script type="math/tex; mode=display">
\frac{\partial h}{\partial x} = \frac{\partial h}{\partial y}\frac{\partial y}{\partial x} = \frac{\partial h}{\partial y}W^T\\
shape=(1,H)(H\times D) = (1,D)</script><p>$\frac{\partial h}{\partial x}$ 的形状和$\boldsymbol x$ 的形状是一样的</p>
<h5 id="反向传播3-1"><a href="#反向传播3-1" class="headerlink" title="反向传播3"></a>反向传播3</h5><p>现在来看$\boldsymbol W$这层的梯度，我们首先列出公式</p>
<script type="math/tex; mode=display">
\frac{\partial h}{\partial W} =\frac{\partial h}{\partial W_{ij}}</script><p>虽然$\boldsymbol W$是矩阵，按照雅克比行列式来计算的话，需要每个$y<em>j$对这行中每一个元素$w</em>{ij}$求偏导，这太麻烦了。我们还是一对一对求就好，因为$w_{ij}$只影响 $y_j$ ,因此，上式可以简化为：</p>
<script type="math/tex; mode=display">
\frac{\partial h}{\partial W}=\frac{\partial h}{\partial y_j}\frac{\partial y_j}{\partial w_{ij}} = \frac{\partial h}{\partial y_j}x_i=x_i\frac{\partial h}{\partial y_j}\\</script><p>那么，因为 $\boldsymbol W$ 有三行，对每一行进行如上计算，就会得到一个  $3\times 4$  的矩阵，即</p>
<script type="math/tex; mode=display">
\frac{\partial h}{\partial W}=x^T\frac{\partial h}{\partial y}
=\begin{bmatrix}2\\1\\3\end{bmatrix}\begin{bmatrix}0.028&0.01&0.22&0\end{bmatrix}</script><p>发现这和$\boldsymbol W$的形状也是一样的 </p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/28.png"></p>
<h5 id="反向传播4-1"><a href="#反向传播4-1" class="headerlink" title="反向传播4"></a>反向传播4</h5><p>上面因为简化，我们没有加入偏置项b，现在我们加上试试：</p>
<script type="math/tex; mode=display">
y^T = \begin{bmatrix}x_1w_{11}+x_2w_{21}+x_3w_{31}+b\\x_1w_{12}+x_2w_{22}+x_3w_{32}+b\\x_1w_{13}+x_2w_{23}+x_3w_{33}+b\\x_1w_{14}+x_2w_{24}+x_3w_{34}+b \end{bmatrix}</script><p>此时，要求偏置项的梯度，我们可以列出公示：</p>
<script type="math/tex; mode=display">
\frac{\partial h}{\partial b} = \frac{\partial h}{\partial y}\frac{\partial y}{\partial b} = \frac{\partial h}{\partial y}\begin{bmatrix}1\\\vdots\\1\end{bmatrix}_H = \sum_{j}\frac{\partial h}{\partial y_j}</script><p>因为这里y关于b的导数始终是1，最后得到的关于b的梯度也是一个数</p>
<h4 id="反向运算-minibatch"><a href="#反向运算-minibatch" class="headerlink" title="反向运算-minibatch"></a>反向运算-minibatch</h4><p>上面，我们输入的只是个向量，即输入一个样本，因此计算起来还是效率不够高。因此我们可以采用minibatch的方法，输入一个矩阵来计算</p>
<h5 id="反向传播1-2"><a href="#反向传播1-2" class="headerlink" title="反向传播1"></a>反向传播1</h5><p>当输入变成一个矩阵的时候，发现$y<em>{ij}$仍然只会影响$\sigma</em>{ij}$,因此我们可以一对一计算，如下</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/29.png"></p>
<h5 id="反向传播2-2"><a href="#反向传播2-2" class="headerlink" title="反向传播2"></a>反向传播2</h5><p>和只输入向量一样，$x_{ij}$只会影响y的<strong>第i行</strong>，因此</p>
<script type="math/tex; mode=display">
\frac{\partial h}{\partial x_{ij}} = \sum_{k}\frac{\partial h}{\partial y_{ik}}\frac{\partial y_{ik}}{\partial x_{ij}} = \sum_{k}\frac{\partial h}{\partial y_{ik}}w_{jk}\Rightarrow\frac{\partial h}{\partial x} = \frac{\partial h}{\partial y}W^T</script><p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/30.png"></p>
<h5 id="反向传播3-2"><a href="#反向传播3-2" class="headerlink" title="反向传播3"></a>反向传播3</h5><p>$w_{ij}$只会影响y的<strong>第j列</strong>，因此：</p>
<script type="math/tex; mode=display">
\frac{\partial h}{\partial W}=\sum_{k}\frac{\partial h}{\partial y_{kj}}\frac{\partial y_{kj}}{\partial w_{ij}} =\sum_k \frac{\partial h}{\partial y_{kj}}x_{ki}=\sum_kx_{ki}\frac{\partial h}{\partial y_{kj}}\Longrightarrow\frac{\partial h}{\partial W} = X^T\frac{\partial h}{\partial y}</script><p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/31.png"></p>
<h5 id="反向传播4-2"><a href="#反向传播4-2" class="headerlink" title="反向传播4"></a>反向传播4</h5><p>在输入为向量的情况下，b只是个数，但当输入为一个矩阵的时候，偏置项b就变成了N维的向量。$b\in\mathbb R^N$</p>
<p>此时，要求偏置项的梯度，就是</p>
<script type="math/tex; mode=display">
\frac{\partial h}{\partial b} = \sum_j \frac{\partial h}{\partial y_{ij}}</script><p>令b原式的形状是 $(M,)$  上游梯度的形状为$(N\times M)$ ，那么相当于是对上游梯度每一列求和，最后得到形状为$(M,)$的梯度</p>
<h4 id="多层神经网络反向传播"><a href="#多层神经网络反向传播" class="headerlink" title="多层神经网络反向传播"></a>多层神经网络反向传播</h4><p>从上面的神经网络，我们可以推广到当神经网络有很多层的时候，可以这样来求各层的权重：</p>
<script type="math/tex; mode=display">
\begin{align}
&\frac{\partial L}{\partial \boldsymbol W^l} = \frac{\partial L}{\partial \boldsymbol h}\frac{\partial\boldsymbol h}{\boldsymbol W^l}\\
&\frac{\partial L}{\partial \boldsymbol W^{l-1}} = \frac{\partial L}{\partial \boldsymbol h}\frac{\partial\boldsymbol h}{\partial\boldsymbol  a^l}\frac{\partial\boldsymbol a^l}{\boldsymbol W^{l-1}}\\
&\frac{\partial L}{\partial \boldsymbol W^{l-2}} = \frac{\partial L}{\partial \boldsymbol h}\frac{\partial\boldsymbol h}{\partial\boldsymbol  a^l}\frac{\partial\boldsymbol a^l}{\partial\boldsymbol a^{l-1}}\frac{\partial\boldsymbol a^{l-1}}{\boldsymbol W^{l-2}}\\
\vdots\\\vdots\\
&\frac{\partial L}{\partial \boldsymbol W^{l-2}} = \frac{\partial L}{\partial \boldsymbol h}\frac{\partial\boldsymbol h}{\partial\boldsymbol  a^l}\frac{\partial\boldsymbol a^l}{\partial\boldsymbol a^{l-1}}\frac{\partial\boldsymbol a^{l-1}}{\partial\boldsymbol a^{l-2}}\cdots\frac{\partial \boldsymbol a^2}{\boldsymbol W^{l-2}}
\end{align}</script><p>注意，不要忘记每一层的偏执权重b，以及正则项</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/" itemprop="url">计算机视觉-神经网络的训练</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-12-02T12:57:44+08:00">
                2021-12-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-06-26T16:06:12+08:00">
                2022-06-26
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="计算机视觉-神经网络的训练"><a href="#计算机视觉-神经网络的训练" class="headerlink" title="计算机视觉-神经网络的训练"></a>计算机视觉-神经网络的训练</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>我们在 <a href="https://jasonxqh.github.io/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/">卷积神经网络理论</a> 这篇博客中粗略学习了卷积神经网络的相关知识。</p>
<p>在那篇博客里，我们用举了很多例子，比如说手写识别，图像分类。但其实CNN还有其他作用，比如：</p>
<ul>
<li>风格迁移</li>
</ul>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/1.png" style="zoom:67%;"></p>
<p>我们输入一张内容图片，再输入一张风格图片，通过最小化内容的损失和风格的损失来获取一张既保留前一张图片内容与后一张图片风格的图片。</p>
<script type="math/tex; mode=display">
x=\arg\min_{x}l_{(x,countent)}+l_{(x,style)}</script><p>在<a href="https://dreamscopeapp.com/" target="_blank" rel="noopener">https://dreamscopeapp.com/</a> 中，就是利用CNN这项技术来实现风格迁移的。</p>
<ul>
<li>Alpha Go</li>
</ul>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/2.png" style="zoom:67%;"></p>
<p>Alpha Go的原理就是提取出棋盘上的概率特征,然后去判断落子的位置</p>
<ul>
<li>看图说话</li>
</ul>
<p>如果图片和文本联系起来，可以实现看图说话的功能：每个词出来以后，预测下一个词是什么</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/3.png"></p>
<h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><p>现在我们来讲一些神经网络训练中的技巧。首先就是如何选择激活函数：</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/4.png"></p>
<p>我们知道比较有代表性的激活函数有Sigmoid，Relu，tanh，那么它们各自的优缺点是什么呢？</p>
<h3 id="Sigmoid"><a href="#Sigmoid" class="headerlink" title="Sigmoid"></a>Sigmoid</h3><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/5.png"></p>
<script type="math/tex; mode=display">
\sigma(x) = \frac{1}{1+e^{-x}}</script><p>我们观察到Sigmoid函数，y在x的绝对值大于4的时候，就非常非常接近于1了，而且基本维持不变。</p>
<p>因此，Sigmoid的优点是：</p>
<blockquote>
<ul>
<li>可以把数据压缩到0和1之间，每层数据的变化不是很大，如果变化太大会导致训练的不稳定，从而参数的梯度会很大，训练的代价高。</li>
<li>Sigmoid在任意位置均可导</li>
</ul>
</blockquote>
<p>Sigmoid的缺点是</p>
<blockquote>
<ul>
<li>饱和输出</li>
<li>非零均值，均值为0.5</li>
<li>属于幂函数计算代价高</li>
</ul>
</blockquote>
<p>我们主要来关注前两个缺点：</p>
<h4 id="饱和输出"><a href="#饱和输出" class="headerlink" title="饱和输出"></a>饱和输出</h4><p>饱和输出的意思是，当x稍微大一点或小一点的时候，$\sigma(x)$ 就会无限接近1或者0了。从而导致sigmoid的局部梯度接近于0，造成回传梯度消失，参数无法更新</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/6.png"></p>
<h4 id="非零均值"><a href="#非零均值" class="headerlink" title="非零均值"></a>非零均值</h4><p>首先，对于Sigmoid函数，$\sigma_i$都是正数。那么对于回传来的梯度，我们有公式：</p>
<script type="math/tex; mode=display">
\frac{\partial h}{\partial w_i} = \frac{\partial h}{\partial y} \frac{\partial y}{\partial w_i} = \frac{\partial h}{\partial y}\sigma_i</script><p>上游传回来的梯度如果是正的，那么每个$w_i$的梯度都是正的；上游传回来的梯度如果是负的，那么每个$w_i$的梯度都是负的。这就造成每一层的weight要么全部变小，要么全部变大，梯度呈“之字形”更新，虽然最后也能收敛到最优解，但收敛很慢  </p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/8.png"></p>
<p>用<code>minibatch</code>可以减轻这种效应</p>
<h3 id="tanh"><a href="#tanh" class="headerlink" title="tanh"></a>tanh</h3><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/9.png"></p>
<script type="math/tex; mode=display">
\tanh x = \frac{\sinh x}{\cosh x} = \frac{e^x-e^{-x}}{e^x+e^{-x}} = \frac{e^{2x}-1}{e^{2x}+1}</script><p>优点：</p>
<blockquote>
<ul>
<li>将数值压缩到(-1,1)之间</li>
<li>零均值</li>
<li>曲线平滑，便于求导</li>
</ul>
</blockquote>
<p>缺点：</p>
<blockquote>
<ul>
<li>容易饱和输出</li>
<li>exp() 幂函数计算复杂度很高</li>
</ul>
</blockquote>
<p>所以说 $\tanh$ 和  $\text{sigmoid}$ 的缺点是相同的</p>
<h3 id="Relu"><a href="#Relu" class="headerlink" title="Relu"></a>Relu</h3><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/10.png"></p>
<script type="math/tex; mode=display">
f(x) = \max(0,x)</script><p>其优点有很多：</p>
<blockquote>
<ol>
<li>在正区间是不会饱和的</li>
<li>计算复杂度极低</li>
<li>由前两条可以得到<strong>收敛速度比Sigmoid和tanh快</strong></li>
</ol>
</blockquote>
<p>当然，也存在一些缺点</p>
<blockquote>
<ol>
<li>不是零均值，也会存在一些 Zig-Zag的问题</li>
<li>不会压缩数据，因此数据幅度会随着网络加深不断增大</li>
<li>神经元坏死</li>
</ol>
</blockquote>
<h4 id="神经元坏死"><a href="#神经元坏死" class="headerlink" title="神经元坏死"></a>神经元坏死</h4><p>由于参数初始化或者学习率设置不当，会导致某些神经元的输入永远是负数，那么经过Relu，梯度为0，导致相应的参数永远不会更新。这就是Dead ReLU</p>
<p>采用合适的参数初始化和调整学习率可以缓解这种现象</p>
<h3 id="Leaky-ReLU"><a href="#Leaky-ReLU" class="headerlink" title="Leaky ReLU"></a>Leaky ReLU</h3><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/11.png"></p>
<script type="math/tex; mode=display">
f(x)= \max(ax,x)</script><p>Leaky ReLU和Relu很像，只不过在小于0的时候也有一个很小的斜率(取决于超参数的大小)。这样可以继承ReLU的优点，又规避了ReLU神经元坏死的缺陷</p>
<p>优点：</p>
<blockquote>
<ul>
<li>不会造成饱和 计算复杂率低</li>
<li>收敛速度比Sigmoid和tanh快</li>
<li>近似零均值</li>
<li>解决ReLU的神经元坏死问题</li>
</ul>
</blockquote>
<p>缺点：</p>
<blockquote>
<ul>
<li>数值幅度不断增大</li>
<li>实际表现不一定会比ReLU好</li>
</ul>
</blockquote>
<p>最后一点在科学研究中很常见，就是提出了能规避缺点的好方法，但却并不能得到更好的效果</p>
<h3 id="ELU-Exponential-Linear-Units"><a href="#ELU-Exponential-Linear-Units" class="headerlink" title="ELU(Exponential Linear Units)"></a>ELU(Exponential Linear Units)</h3><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/12.png"></p>
<script type="math/tex; mode=display">
f(x) = \begin{cases}x&x>0\\\alpha(\exp(x)-1)&x\leq 0 \end{cases}</script><p>我们看到ELU和Leaky ReLU很像，只是一个是线性函数，一个是幂函数</p>
<p>优点：</p>
<blockquote>
<ul>
<li>不容易造成饱和</li>
<li>收敛速度比Sigmoid和tanh快</li>
<li>近似零均值</li>
<li>解决了ReLU的神经元坏死问题</li>
</ul>
</blockquote>
<p>缺点：</p>
<blockquote>
<ul>
<li>存在幂函数，exp()计算复杂度高</li>
<li>表现不一定比ReLU好</li>
</ul>
</blockquote>
<h3 id="Maxout"><a href="#Maxout" class="headerlink" title="Maxout"></a>Maxout</h3><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/13.png"></p>
<script type="math/tex; mode=display">
f(x) = \max(w_1^Tx+b_1,w_2^Tx+b_2)\\
x\in\mathbb R^m,f(x)\in\mathbb R^n,w_1,w_2\in \mathbb R^{m\times n},w\in \mathbb R&{m\times n\times 2}</script><p>上面的输入层有8个神经元，maxout以后只有四个输出神经元，因为两两组合选出最大的那个值作为输出</p>
<p>推广得到：</p>
<script type="math/tex; mode=display">
f(x) = \max(w_1^Tx+b_1,\cdots,w_k^Tx+b_k)\\
w\in \mathbb R^{m\times n\times k}</script><p>maxout讲的不是很多，其原理就是每一个输出神经元的输出都会和上一层的输入神经元做计算，最后取最大值作为输出。</p>
<p> 实际搭建模型的时候：</p>
<ul>
<li>首选ReLU，但是要注意初始化和学习率的设置</li>
<li>不要使用Sigmoid</li>
<li>可以使用tanh，不过效果来讲一般</li>
<li>可以多尝试一点其他激活函数</li>
</ul>
<h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><h3 id="调整图片大小"><a href="#调整图片大小" class="headerlink" title="调整图片大小"></a>调整图片大小</h3><p>一般来说，将图像裁剪为大小一致的正方形。可以通过downscale和upscale来调整大小。</p>
<p>可以使用Pillow的<code>crop()</code>和<code>resize()</code>方法</p>
<h3 id="图像序列化"><a href="#图像序列化" class="headerlink" title="图像序列化"></a>图像序列化</h3><p>可以使用pickle模块将图片转化为像素值数组，并附上相应标签</p>
<h3 id="零均值化"><a href="#零均值化" class="headerlink" title="零均值化"></a>零均值化</h3><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/14.png"></p>
<p>目标：将原始像素值从[0,255]调整为$[-128,127]$ . </p>
<p>方法：</p>
<ul>
<li><p>计算所有图像的平均，得到mean image，mean image和原始图像的大小应保持一致</p>
</li>
<li><p>然后将每个图像都减去mean image</p>
</li>
</ul>
<p>如果输入数据不是零均值的话，会产生什么影响？造成这一层参数的梯度，要么都是正的，要么都是负的，导致Zig-Zag效应</p>
<p>此外，还有一些零均值化的方法，比如：</p>
<ul>
<li>每个channel 减去各自的平均。 比如 VCGNet</li>
<li>每个channel 减去各自的平均，然后除以std(标准化). 比如 ResNet</li>
</ul>
<h3 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h3><p>目标：将数值压缩到一个较小的区间</p>
<p>好处：</p>
<ul>
<li>减小损失函数对权重参数变化的敏感度</li>
<li>方便优化参数</li>
</ul>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/15.png"></p>
<p>在实际搭建模型的时候，必做的三个步骤是：</p>
<ol>
<li>调整图像大小</li>
<li>图像序列化</li>
<li>零均质化</li>
</ol>
<p>等每一层卷积之后，再去做<strong>标准化</strong>，一般先不做。</p>
<h3 id="权重参数的初始化"><a href="#权重参数的初始化" class="headerlink" title="权重参数的初始化"></a>权重参数的初始化</h3><p>初始化参数的好坏对网络的训练有着非常重要的意义。</p>
<p>由链式规则可知：</p>
<script type="math/tex; mode=display">
\frac{\partial L}{\partial \boldsymbol W^1} = \frac{\partial L}{\partial \boldsymbol h}\frac{\partial \boldsymbol h}{\partial \boldsymbol a^l}\frac{\partial \boldsymbol a^{l-1}}{\partial \boldsymbol a^{l-2}}\cdots\cdots\frac{\partial \boldsymbol a^2}{\partial \boldsymbol W^1}</script><p>那么当参数初始化过小的话,每一层回传值都$\approx 0$</p>
<ul>
<li>会导致回传梯度快速接近0，梯度消失。靠近输入层的梯度无法更新</li>
</ul>
<p>如果参数初始化过大(&gt;1)</p>
<ul>
<li>每一层都会乘以一个大于1的数字，会导致回传梯度快速增大，梯度爆炸。靠近输入的梯度会更新太快. 不知道什么时候才能找到最优解</li>
</ul>
<p>下面这张图中，纵轴代表更新速度，越上面代表更新越快。layer4是靠近输出层的，layer1是靠近输入层的。我们看到靠近输入层的layer1更新速度非常小。</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/16.png"></p>
<p>下面接好一些参数初始化方法</p>
<h4 id="全部初始化为0"><a href="#全部初始化为0" class="headerlink" title="全部初始化为0"></a>全部初始化为0</h4><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/17.png"></p>
<p>如果全部初始化为0，会导致：</p>
<ol>
<li>每一层的<strong>神经元输出完全一样</strong></li>
<li>每一层的<strong>参数梯度完全一样</strong>(参数的梯度和输入有关)</li>
<li>每一层的<strong>参数永远相同</strong></li>
<li>学习很缓慢，无法学习数据特征</li>
</ol>
<h4 id="完全随机初始化"><a href="#完全随机初始化" class="headerlink" title="完全随机初始化"></a>完全随机初始化</h4><p>若把参数设定为<strong>零均值、方差较小</strong>的正态分布随机数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dims &#x3D; [4096]*7</span><br><span class="line">hs &#x3D; []</span><br><span class="line">x &#x3D; np.random.randn(16,dims[0])</span><br><span class="line">for Din,Dout in zip(dims[:-1],dims[1:]):</span><br><span class="line">	W &#x3D; 0.01*np.random.randn(Din,Dout)</span><br><span class="line">	x &#x3D; np.tanh(x.dot(W))</span><br><span class="line">	hs.append(x)</span><br></pre></td></tr></table></figure>
<p>在这里我们用 tanh当做激活函数，初始化的数据也比较小。主要集中在0附近，因此，会导致下面这种情况，就是随着网络的一层层加深，经过激活函数 tanh 的时候会越来越塌陷，所有参数越来越靠近0，被激活的越来越少。</p>
<p>从而导致，越靠近输出层，梯度 $\frac{\partial L}{\partial w}$ 接近于0，靠近输出层的w的无法更新</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/18.png"></p>
<p>若把参数设定为<strong>零均值，方差较大</strong>的正态分布随机数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dims &#x3D; [4096]*7</span><br><span class="line">hs &#x3D; []</span><br><span class="line">x &#x3D; np.random.randn(16,dims[0])</span><br><span class="line">for Din,Dout in zip(dims[:-1],dims[1:]):</span><br><span class="line">	W &#x3D; 0.1*np.random.randn(Din,Dout)</span><br><span class="line">	x &#x3D; np.tanh(x.dot(W))</span><br><span class="line">	hs.append(x)</span><br></pre></td></tr></table></figure>
<p>那么这时候，经过tanh激活函数后，随着网络越深，输入值矩阵会越来越大，和权重相乘之后会无限接近于-1或者无限接近于1。从而导致激活越来越饱和。</p>
<p>这样一来，激活门的局部梯度就接近于0,根据tanh的导数图像可知，由于激活后的tanh都集中在-1和1，导致回传的梯度会消失</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/54.png" style="zoom: 67%;"></p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/19.png"></p>
<p>所以不管怎么样，都会塌陷或饱和。</p>
<h4 id="Xavier-初始化"><a href="#Xavier-初始化" class="headerlink" title="Xavier 初始化"></a>Xavier 初始化</h4><p>最理想的状态是，梯度既不会消失，也不会饱和，尽可能保持y和x的分布保持一致。现在来介绍Xavier初始化：</p>
<p>其方法就是在正态分布的随机数基础上除以$\sqrt n$ ： $std = 1/\sqrt{\text{Din}}$</p>
<p>卷积层Din的大小怎么算？$\text{Din} = F^2\times k$ ，其中 F为filter大小，输入K为信道数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dims = [<span class="number">4096</span>]*<span class="number">7</span></span><br><span class="line">hs = []</span><br><span class="line">x = np.random.randn(<span class="number">16</span>,dims[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> Din,Dout <span class="keyword">in</span> zip(dims[:<span class="number">-1</span>],dims[<span class="number">1</span>:]):</span><br><span class="line">	W = np.random.randn(Din,Dout) / np.sqrt(Din)</span><br><span class="line">	x = np.tanh(x.dot(W))</span><br><span class="line">	hs.append(x)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/20.png"></p>
<p>会有一定的塌陷，但是塌陷的速度明显减慢了</p>
<p>如果将激活函数替换为ReLU的话：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dims = [<span class="number">4096</span>]*<span class="number">7</span></span><br><span class="line">hs = []</span><br><span class="line">x = np.random.randn(<span class="number">16</span>,dims[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> Din,Dout <span class="keyword">in</span> zip(dims[:<span class="number">-1</span>],dims[<span class="number">1</span>:]):</span><br><span class="line">	W = np.random.randn(Din,Dout) / np.sqrt(Din)</span><br><span class="line">	x = np.maximum(<span class="number">0</span>,x.dot(w))</span><br><span class="line">	hs.append(x)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/21.png"></p>
<h4 id="He初始化"><a href="#He初始化" class="headerlink" title="He初始化"></a>He初始化</h4><p>He初始化是在Xavier上的基础上做了一些微小的改动，他觉得Xavier的更新还是太快了，因此除了一个更小的值.结果效果非常好：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dims = [<span class="number">4096</span>]*<span class="number">7</span></span><br><span class="line">hs = []</span><br><span class="line">x = np.random.randn(<span class="number">16</span>,dims[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> Din,Dout <span class="keyword">in</span> zip(dims[:<span class="number">-1</span>],dims[<span class="number">1</span>:]):</span><br><span class="line">	W = np.random.randn(Din,Dout)/np.sqrt(Din/<span class="number">2</span>) <span class="comment"># 相当于 *np.sqrt(2/Din)</span></span><br><span class="line">	x = np.maximum(<span class="number">0</span>,x.dot(w))</span><br><span class="line">	hs.append(x)</span><br></pre></td></tr></table></figure>
<p>在实际搭建模型的时候，优先使用ReLU+He进行初始化</p>
<h2 id="Batch-Normaliziation"><a href="#Batch-Normaliziation" class="headerlink" title="Batch Normaliziation"></a>Batch Normaliziation</h2><p>最后一部分我们来聚焦标准化。之前我们说，在数据预处理的时候先不要做数据标准化，这是因为有人发明了在层与层之间做标准化的方法，效果更好。</p>
<p>其中一个效果较好的方法就是 Batch Normaliziation</p>
<p>提出这个方法的内驱力是：</p>
<ul>
<li>如果不做标准化，输入的变化很大，导致参数也不停地变化，进而导致内部输出的分布不停变化。损失函数很难收敛</li>
<li>不做标准化，会导致数很大或者很小，进而导致激活容易饱和，或者激活趋近于0</li>
<li>总的来说，不做标准化会导致神经网络<strong>难以收敛</strong></li>
</ul>
<p>因为这种方法是通过对Minibatch标准化，因此我们称其为 Batch Normalization.</p>
<p>其原理就是对特征的每一维单独做normalization：</p>
<script type="math/tex; mode=display">
\hat x^{(k)} = \frac{x^{(k)}-E[x^{(k)}]}{\sqrt{\text{Var}[x^{(k)}]}}</script><p>详解：</p>
<script type="math/tex; mode=display">
\text{求batch中每一维特征的平均:} \mu_j = \frac{1}{N}\sum_{i=1}^n x_{i,j}\\
\text{求batch中每一维特征的方差:}\sigma_j^2 = \frac{1}{N}\sum_{i=1}^N(x_{i,j}-\mu_j)^2\\
\text{对每个x做 normalization:}\hat x_{i,j} =\frac{x_{i,j}-\mu_j}{\sqrt{\sigma_j^2+\varepsilon}}~~~~~~\text{维度:}~~(N\times D)</script><p>然后，我们要引入参数$\gamma$和$\beta$ ，也就是引入一个标准化的程度，否则如果强行标准化到$N(0,1)$可能会导致某些特征发生改变</p>
<script type="math/tex; mode=display">
y_{i,j} = \gamma_j\hat x_{i,j}+\beta_j
~~~~~~\text{维度:}~~(N\times D)</script><p>在推理时，可能只有一个或者几个样本，因此无法计算稳定的、有效地计算$\mu$和$\sigma^2$ .我们希望使用固定的$\mu,\sigma^2$ ,否则，整个模型会一直变化。</p>
<p>关于$\mu$和$\sigma^2$ 怎么更新，Moving Average技巧，momentum是一个超参，一般设为0.99或者0.999,然后让mean和var每次都会更新，但是更新幅度较小。最后获得一个整体的均值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">running_mean &#x3D; momentum * running_mean + (1-momentum) * sample_mean</span><br><span class="line">running_var  &#x3D; momentum * running_var  + (1-momentum) * sample_var</span><br></pre></td></tr></table></figure>
<p>到最后我们会发现，变量只有x,其余的都是超参数，可以将以下两式融合成 线性结构：</p>
<script type="math/tex; mode=display">
\begin{align}
&\hat x_{i,j} =\frac{x_{i,j}-\mu_j}{\sqrt{\sigma_j^2+\varepsilon}} \\~\\
&y_{i,j}=\gamma_j\hat x_{i,j}+\beta_j
\end{align}</script><h3 id="矩阵运算视角"><a href="#矩阵运算视角" class="headerlink" title="矩阵运算视角"></a>矩阵运算视角</h3><h4 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h4><p>对于输入x , 是 $N\times D$ 的矩阵</p>
<p>Batch Normalization就是保留输入的维度(即D)，对每一维里面所有的元素进行标准化</p>
<script type="math/tex; mode=display">
{\mu,\sigma}:1\times D\\
{\gamma,\beta}:1\times D\\
y = \gamma(x-\mu)/\sigma+\beta</script><h4 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h4><p>对于卷积层，输入为 $\text{N}\times \text{C}\times \text{H}\times W$</p>
<p>Batch Normalization就是保留输入的信道，是对每个信道里面的所有元素进行标准化。最后保留C个均值、C个方差</p>
<script type="math/tex; mode=display">
{\mu,\sigma}:1\times C\times1\times1\\
{\gamma,\beta}:1\times C\times1\times1\\
y = \gamma(x-\mu)/\sigma+\beta</script><h3 id="BN放在那里呢？"><a href="#BN放在那里呢？" class="headerlink" title="BN放在那里呢？"></a>BN放在那里呢？</h3><p>BN是放在卷积/全连接层和激活函数之间的一层。</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/22.png"></p>
<p>BN的注意点 </p>
<ul>
<li>优化了梯度流，是深度网络训练起来更加容易</li>
<li>可以使用较大的Learning Rate，加速收敛</li>
<li>受权重参数初始化影响较小</li>
<li>在训练过程中起到正则化的作用</li>
<li>推理时和FC/Conv层融合，几乎不增加开销</li>
<li>注意训练和推理BN的具体实现是不同的</li>
</ul>
<h3 id="Normalization的变化"><a href="#Normalization的变化" class="headerlink" title="Normalization的变化"></a>Normalization的变化</h3><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/53.png"></p>
<p>有时候，Batch Norm  在神经网络中的作用不那么突出，因此提出了一些变形。其原理和思想都和Batch Norm一样，只是参与归一化的元素不同</p>
<ul>
<li><p>Batch Normalization：对信道中的所有元素进行Normalization</p>
</li>
<li><p>Layer Normalization ：C代表每个信道，N代表每张图片。Layer Normalization就是对Batch中的每一张图片进行Normalization</p>
</li>
<li><p>Instance Normalization:每一张图片中的每一个信道做Normalization，更细致一些</p>
</li>
<li>Group Normalization: 取一张 图片中的部分信道做Normalization，介于Layer和Instance之间</li>
</ul>
<h2 id="优化方法的演进"><a href="#优化方法的演进" class="headerlink" title="优化方法的演进"></a>优化方法的演进</h2><p>前面我们讲了，通过反向传播来得到不同层的梯度，得到了梯度怎么拿来更新模型中的参数呢？这边又涉及到了不同的技巧，我们来学习一些</p>
<h3 id="SGD"><a href="#SGD" class="headerlink" title="SGD"></a>SGD</h3><p>SGD的全称是 Stochastic Gradient Descent，即随机梯度下降。</p>
<p>标准的随机梯度下降不是一个batch一个batch来做的，而是每次使用一个数据(一张图片)来计算loss。得到了损失函数，我们马上来更新参数。</p>
<p>伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while True:</span><br><span class="line">	weights grad &#x3D; evaluate gradient(loss fun,data,weights) #根据当前图像计算梯度</span><br><span class="line">	weights +&#x3D; -step size * weights grad</span><br></pre></td></tr></table></figure>
<p>SGD的迭代次数多，更新速度快，但也有其不可规避的缺点，比如：</p>
<h4 id="zig-zag问题"><a href="#zig-zag问题" class="headerlink" title="zig-zag问题"></a>zig-zag问题</h4><p>假设在二维空间中，损失函数对参数$w_1$ 非常敏感，但是对$w_2$不太敏感。</p>
<p>那么当w1稍微改动一下，损失函数就变化很大；w2可能要改动很多损失函数才能变化。</p>
<p>下图每个圈代表相同的损失函数的值，我们发现由于损失函数对参数的敏感程度的不同，会导致Zig-Zag的问题</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/23.png"></p>
<p>当然，用非零均值的激活函数也会造成Zig-zag的问题。</p>
<h4 id="minibatch的噪声问题"><a href="#minibatch的噪声问题" class="headerlink" title="minibatch的噪声问题"></a>minibatch的噪声问题</h4><p>我们可以用 mini-batch 则来效缓解Zig-zag的问题。但同时也会引入一些噪声。</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/24.png"></p>
<h4 id="局部最优和鞍点"><a href="#局部最优和鞍点" class="headerlink" title="局部最优和鞍点"></a>局部最优和鞍点</h4><p>SGD是每次用当前的参数减掉计算得到的梯度来得到下一轮的参数的。因此，如果当损失函数陷入极小值点或者说进入鞍点的时候，参数会很难更新。如下图:</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/25.png"></p>
<p>当落入极小值点的时候，梯度是接近于0的，此时更新就很难移动了。稍微动一点点的话，梯度就变成反方向的了，就好像U形管中的小球一样。</p>
<p>在高位空间中，鞍点是更常见的，此时，某些方向loss会变大，某些方向loss会变小。 </p>
<h3 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h3><p>利用SGD+Momentum,我们可以解决SGD带来的缺点。其更新原理如下：</p>
<script type="math/tex; mode=display">
v_{t+1} = \rho v_t+\nabla f(x_t)\\
x_{t+1} = x_t-\alpha v_{t+1}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vx&#x3D;0</span><br><span class="line">while True:</span><br><span class="line">	dx &#x3D; compute_gradient(x)</span><br><span class="line">	vx &#x3D; rho*vx+dx</span><br><span class="line">	x -&#x3D; leaning_rate * vx</span><br></pre></td></tr></table></figure>
<p>在SGD中，我们把梯度看做是一个静态的量，每次求得以后用原参数减去即可。但是在SGD+Momentum中，就相当于给梯度加上一个”速度“——下一时刻的速度，等于当前时刻的速度乘以一个衰减率$\rho$, 再加上求得的梯度。然后，用当前的权重减掉速度来更新权重。</p>
<p>等于说，现在我改变的是速度的大小，速度是由梯度累加起来的一个量。梯度$\nabla f(x)d(x)$越大，增量也就越大, 这样就避免了一个速度为0的情况，因此权重是一直可以更新的。</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/26.png"></p>
<p>这种方法，在当前速度和梯度方向相同的时候，会让权重减小较多的值，相当于踩了一个刹车，来让我们不那么容易地错过最优点。如果当前处于极小值点/鞍点，仍然是有一个速度存在的(可能为负数)，借助于这个速度，可以跳过这个极小值旁边的坡。如上图所示</p>
<p>在可视化图中，我们发现 SGD+Momentum 在最后绕过了最优解，最后又绕回来了。这就是速度的直观表现，一开始遇到最优点但是刹不住车了，后来再一步一步减小自己的速度，回到最优点</p>
<h4 id="Nesterov-Momentum"><a href="#Nesterov-Momentum" class="headerlink" title="Nesterov Momentum"></a>Nesterov Momentum</h4><p>对于SGD+Momentum，Nesterov提出了一种改进方法，如下图所示：</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/27.png"></p>
<p>Nesterov 的依据是，下一层速度的更新，不要依据当前点的梯度，而要依靠下一个点的梯度。这样，如果下一个点的梯度非常陡峭，如果和速度同方向，说明正在下坡，$v<em>{t+1}$变小，因此可以慢一点；如果和速度反方向，说明在爬坡，$v</em>{t+1}$增大，需要加速。</p>
<p>计算公式：</p>
<script type="math/tex; mode=display">
\begin{align}
&v_{t+1} = pv_t-\alpha\nabla f(x_t+\rho v_t)\\
&x_{t+1}= x_t+v_{t+1}\\
&\text{令}\tilde x_t = x_t+\rho v_t,\text{可知：}\\
&v_{t+1} = \tilde x_t -\rho v_t+(1+\rho)v_{t+1}=\tilde x_t+v_{t+1}+\rho(v_{t+1}-v_t)
\end{align}</script><p>因此，我们只要计算$\tilde x$即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dx &#x3D; compute_gradient(x)</span><br><span class="line">old_v &#x3D; v</span><br><span class="line">v &#x3D; rho*v-leaning_rate*dx</span><br><span class="line">x +&#x3D; -rho*old_v+(1+rho)*v</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/28.png"></p>
<h3 id="AdaGrad"><a href="#AdaGrad" class="headerlink" title="AdaGrad"></a>AdaGrad</h3><p>对于SGD、以及Momentum，我们发现对某一层所有点的梯度更新都是一样的。但是实际情况下，某些方向对参数的更新是不明感的，而有些方向很敏感。因此我们要对敏感方向更新的快一些，而对不敏感的方向慢一点。</p>
<p>由此，我们来学习AdaGrad,这个优化策略的思想是：</p>
<p>对参数的每一维，都累计当前梯度的平方，这样，梯度越大，这个方向累计的数值就越大。</p>
<p>接下来，用这个累计梯度平方根去计算$\alpha$, 累计梯度越大，$\alpha_t$就越小；累计梯度小的，$\alpha_t$就越大</p>
<p>我们把$\alpha$ 作为参数更新的学习率，使得每个维度的$\alpha$ 不同. 这样，对于各个方向的参数更新都会平滑一些，不会导致某些方向参数更新快，某些方向参数更新慢的这种Zig-Zag情况 </p>
<script type="math/tex; mode=display">
\begin{align}
&r_t = r_{t-1}+\nabla f(x_t)\times \nabla f(x_t)\\
&\alpha_t = \frac{\alpha}{\sqrt{r_t}+\delta}\\
&x_{t+1} = x_t -\alpha_t\nabla f(x_t)
\end{align}</script><p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">grad_squared = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	dx = compute_gradient(x)</span><br><span class="line">	grad_squared += dx*dx</span><br><span class="line">	x -= learning_rate * dx /(np.sqrt(grad_quared)+<span class="number">1e-7</span>)</span><br><span class="line"> <span class="comment"># 1e-7是超参，用以防止除零</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/29.png"></p>
<p>同时，Adagrad也有其局限性，因为在一段时间之后，在梯度更新很快的方向，$\sqrt{r_t}$很大，这个方向学习率可能会趋近于0，有可能导致在鞍点附近的参数无法更新</p>
<h4 id="RMSProp-Leakey-AdaGrad"><a href="#RMSProp-Leakey-AdaGrad" class="headerlink" title="RMSProp(Leakey AdaGrad)"></a>RMSProp(Leakey AdaGrad)</h4><p>为了解决某些方向累计梯度过大，我们对AdaGrad进行更新：对梯度平方做了一个很细小的改变(momentum)：</p>
<script type="math/tex; mode=display">
\begin{align}
&r_t = \text{decay rate}*r_{t-1}+\text{(1-decay rate)}*\nabla f^2(x_t)\\
&\alpha_t = \frac{\alpha}{\sqrt{r_t}+\delta}\\
&x_{t+1} = x_t -\alpha_t\nabla f(x_t)
\end{align}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grad_squared = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	dx = compute_gradient(x)</span><br><span class="line">	grad_squared += decay_rate*grad_squared+(<span class="number">1</span>-decay_rate)*dx*dx</span><br><span class="line">	x -= learning_rate * dx /(np.sqrt(grad_quared)+<span class="number">1e-7</span>)</span><br></pre></td></tr></table></figure>
<p>这样给累加的梯度乘以一个衰减率(0.9或者0.99)， 当某一个方向梯度更新得快的时候，就不会导致累计梯度增加过快。</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/30.png"></p>
<p>从图中我们可以看出，RMSProp相对与Momentum方法，它不容易越过最优点，而是以一种缓慢接近的方式达到最优点</p>
<h3 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h3><p>Adam的全称是 Adaptive Moment estimation</p>
<p>这种方法就是将momentum和Adagrad的思路结合起来</p>
<p>首先，<code>first_moment = beta1 * first_moment + (1-beta1)*dx</code>, 也就是momentum的计算。给梯度加上一个moving average。</p>
<p>其次，<code>second_moment = beta2 * second_moment + (1-beta2)*dx*dx</code> 也就是<code>Leakey AdaGrad</code>的做法，</p>
<p>最后，将这两种方法结合起来，即：<code>x -= leaning_rate * first_unbias / (np.sqrt(second_unbias)+1e-7)</code></p>
<p>注意，如果我们直接把first_moment和second_moment引用到更新式子中去的话，可能会导致初期的学习率过大. 因此，我们需要用bias correction来防止初期学习训练率过大的情况——让它们除以一个小于1的值，用来修正过大的学习率。</p>
<p>常用的初始设置:</p>
<ul>
<li>beta1=0.9</li>
<li>beta2=0.999</li>
<li>Learning_rate = 1e-3 or 5e-4</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">first_moment &#x3D; 0</span><br><span class="line">second_moment &#x3D; 0</span><br><span class="line">for t in range(1,num_iterations):</span><br><span class="line">	dx &#x3D; compute_gradient(x)</span><br><span class="line">	first_moment &#x3D; beta1 * first_moment + (1-beta1)*dx</span><br><span class="line">	second_moment &#x3D; beta2 * second_moment + (1-beta2)*dx*dx</span><br><span class="line">	first_unbias &#x3D; first_moment &#x2F; (1-beta1**t)</span><br><span class="line">	second_unbias &#x3D; second_moment &#x2F;(1-beta2**t)</span><br><span class="line">	x -&#x3D; leaning_rate * first_unbias &#x2F; (np.sqrt(second_unbias)+1e-7)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/31.png"></p>
<p>adam的优点很明显——既不会越过很多(Momentum的缺点)，又可以在各个方向平滑更新(Adagrad优点)</p>
<p>一般做实验的时候，常用adam</p>
<h2 id="学习率的设置"><a href="#学习率的设置" class="headerlink" title="学习率的设置"></a>学习率的设置</h2><p>前面是通过梯度来更新学习率，但初始学习率是一个超参，我们需要来了解学习率如何设置。因为学习率过大，会很容易越过损失函数的最优点；学习率过小，则会导致损失函数更新很慢。如下图所示</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/32.png"></p>
<p>常用的设置是：使用逐渐衰减(decay) 的学习率, 即越来越小。这是因为越接近optimal，越容易越过这个最优解，因此我们要让参数更新没那么快，以找到最优点。</p>
<ul>
<li>step decay: 每训练N个 iteration/epoch ，就除以常数</li>
<li>exponention decay: $\alpha = \alpha_0e^{-kt}$</li>
<li>1/t decay :$\alpha = \frac{\alpha_0}{1+kt}$</li>
</ul>
<h3 id="Step"><a href="#Step" class="headerlink" title="Step"></a>Step</h3><p>这就是我们使用了学习率下降后的曲线图，比如在SGD+Momentum这个优化方法中，学习率并不会自适应更新，因此我们学一段时间后就让学习率变小一点，这样能使loss持续不断地减小。比如说一开始把学习率设置为0.1,然后每30代乘以一个0.1 </p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/33.png"></p>
<h3 id="Cosine"><a href="#Cosine" class="headerlink" title="Cosine"></a>Cosine</h3><p>使用Step LR Schedule会带来的一大问题是：我们不知道训练几代去下调一次学习率，也不知道下调到多少达到的效果最好，因此需要多次试错。因此我们可以用一个平滑的曲线代替阶段式的调优：这里选取的就是余弦函数</p>
<script type="math/tex; mode=display">
\alpha_t = \frac{1}{2}\alpha_0(1+\cos(t\pi/T))</script><p>这样，学习率也从阶段式下降变成了一条平滑下降的曲线，如下图所示：</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/35.png" style="zoom:120%;"></p>
<p>Loss 曲线如下所示：</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/36.png"></p>
<p>相比于 Step，采用Cosine策略，我们要调整的超参就少了很多——只有两个必要的，而不需要引入新的超参</p>
<p>一个是初始的Learning Rate，还有一个是大写的T，也就是我们要训练的epoch数量</p>
<h3 id="Linear"><a href="#Linear" class="headerlink" title="Linear"></a>Linear</h3><p>当然，我们还可以采用线性下降的策略.</p>
<script type="math/tex; mode=display">
\alpha_t  =\alpha_0 (1-t/T)</script><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/37.png"></p>
<p>我们要有一个观念，并不存在那种学习率策略是更好的，这取决与训练的模型。因此Cosine和Linear是无高下之分的。</p>
<h3 id="Inverse-sqrt"><a href="#Inverse-sqrt" class="headerlink" title="Inverse sqrt"></a>Inverse sqrt</h3><p>还有一种策略是让 出示学习率除以迭代次数的平方根，公式如下：</p>
<script type="math/tex; mode=display">
\alpha_t = \alpha_0/\sqrt t</script><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/38.png"></p>
<p>这种学习率变化策略是：只在高学习率停留很小一段时间。在低学习率停留较长时间。(和Cosine策略有点相反)</p>
<h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><p>我们知道过拟合的坏处是很大的，因此我们要阻止过拟合的发生。这时，就需要正则化</p>
<h3 id="Add-term-to-the-loss"><a href="#Add-term-to-the-loss" class="headerlink" title="Add term to the loss"></a>Add term to the loss</h3><p>我们在之前反向传播的时候就提醒过，在Loss function中需要 添加正则化项：</p>
<script type="math/tex; mode=display">
L = \frac{1}{N}\sum_{i=1}^N \sum_{j\neq y_i}\max(0,f(x_i;W)_j-f(x_i;W)_{y_j}+1)+\lambda R(W)</script><p>其中，$\lambda$是超参数，代表正则化的强度</p>
<p>常使用的$R(W)$如下：</p>
<ul>
<li>L2 regularization  $R(W) = \sum<em>k\sum_lW</em>{k,l}^2$(Weight decay)</li>
<li>L1 regularization  $R(W) = \sum<em>k\sum_l|W</em>{k,l}|$</li>
<li>Elastic net(L1+L2) $R(W) = \sum<em>k\sum_l\beta W</em>{k,l}^2+|W_{k,l}|$ </li>
</ul>
<h3 id="Drop-out-减小特征的捕获"><a href="#Drop-out-减小特征的捕获" class="headerlink" title="Drop out 减小特征的捕获"></a>Drop out 减小特征的捕获</h3><p>我们可以随机丢失一些output,来让模型简化，减小冗余，我们不希望很多神经元去学习同一个特征，我们希望神经网络中的神经元有自己的“特长”，各自负责各自的特征。这样就可以减少过拟合发生的概率：</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/45.png"></p>
<p>一般来说，随机drop的概率设为0.5。这就给神经网络的训练增加了很大的随机性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">H1 = np.maximum (<span class="number">0</span>,np.dot(W1,X)+b1)</span><br><span class="line">U1 = np.random.rand(*H1.shape)&lt;p 	<span class="comment"># first dropout mask</span></span><br><span class="line">H1 *= U1 <span class="comment"># drop</span></span><br><span class="line">H2 = np.maximum(<span class="number">0</span>,np.dot(W2,H1)+b2)</span><br><span class="line">U2 = np.random.read(*H2.shape)&lt;p</span><br><span class="line">H2 *= U2 <span class="comment"># drop</span></span><br><span class="line">out = np.dot(W3,H2)+b3</span><br></pre></td></tr></table></figure>
<p>此外，drop out还可以减小计算压力，如果每一层都要做全连接的话，这种计算量是无法想象的</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/46.png"></p>
<p>在上图中，我们可以看到两个经典的神经网络是在哪几层进行Drop out的。在之后的一些神经网络架构中，如GoogleNet，ResNet，它们使用全局平均池化层来代替全连接层，这样就不需要dropout调节了</p>
<h4 id="Drop-out-Training-and-Testing"><a href="#Drop-out-Training-and-Testing" class="headerlink" title="Drop out Training and Testing"></a>Drop out Training and Testing</h4><p>在训练集和测试集上，Drop out 层的功能是不一样的。</p>
<p>在训练时，Drop out给神经网络增加可随机性：</p>
<script type="math/tex; mode=display">
y = f_W(x;z)</script><ul>
<li>y代表 Output</li>
<li>x代表 Input</li>
<li>z代表 Random Mask</li>
</ul>
<p>这样，设p为每个神经元输出的概率，那么在训练集上，神经元有1-p的概率是不输出任何值的，但是在测试集中，Drop out再产生随机性就说不通了，要不然，神经网络今天把图片认成猫明天认成狗，就不好了。<br>因此，在测试集上，我们仍然保留每个神经经元的输出，但在每个输出的值上乘以概率p。这样一来，测试集和训练集上，每个神经元输出的值的期望是保持相同的: $(1-p)\times 0\times w+p<em>w=w</em>p$</p>
<p>因此，在测试集上，Drop out层的代码应该这么写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">H1 = np.maximum(<span class="number">0</span>,np.dot(W1,X)+b1)*p</span><br><span class="line">H2 = np.maximum(<span class="number">0</span>,np.dot(W2,H1)+b2)*p</span><br><span class="line">out = np.dot(W3,H2)+b3</span><br></pre></td></tr></table></figure>
<h4 id="Inverted-dropout"><a href="#Inverted-dropout" class="headerlink" title="Inverted dropout"></a>Inverted dropout</h4><p>普通dropout和Inverted dropout的思想是一样的，区别就在于什么时候做 rescaling. 前者是在测试推理时进行rescaling，而后者则是在推理时保持不变，在训练时做rescaling. </p>
<p>具体实现就是：在训练时让一部分神经元失活，让 另一部分神经元的输出值除以p，即变大。</p>
<p>但不管怎么样，两种dropout的输出值的数学期望是相等的，设计Inverted dropout的出发点是不想去动测试集</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">p =<span class="number">0.5</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_step</span><span class="params">(X)</span>:</span></span><br><span class="line">  H1 = np.maximum (<span class="number">0</span>,np.dot(W1,X)+b1)</span><br><span class="line">  U1 = np.random.rand(*H1.shape)&lt;p /p	 <span class="comment">#我们把 /p 写在这里</span></span><br><span class="line">  H1 *= U1 <span class="comment"># drop</span></span><br><span class="line">  H2 = np.maximum(<span class="number">0</span>,np.dot(W2,H1)+b2)</span><br><span class="line">  U2 = np.random.read(*H2.shape)&lt;p /p</span><br><span class="line">  H2 *= U2 <span class="comment"># drop</span></span><br><span class="line">  out = np.dot(W3,H2)+b3</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(X)</span>:</span></span><br><span class="line">  H1 = np.maximum(<span class="number">0</span>,np.dot(W1,X)+b1)</span><br><span class="line">  H2 = np.maximum(<span class="number">0</span>,np.dot(W2,H1)+b2)</span><br><span class="line">  out = np.dot(W3,H2)+b3</span><br></pre></td></tr></table></figure>
<h3 id="正则化一般模板"><a href="#正则化一般模板" class="headerlink" title="正则化一般模板"></a>正则化一般模板</h3><p>正则化在训练时和推理(测试)时的实现是不同的，我们可以用这样的公式去表示：</p>
<ul>
<li>Training : 增加一些随机性</li>
</ul>
<script type="math/tex; mode=display">
y = f_W(x,z)</script><ul>
<li>Testing：将这些随机性公摊到输出值上(有时候是近似的)<script type="math/tex; mode=display">
y = f(x) = E_z(f(x,z)) = \int p(z)f(x,z)dz</script></li>
</ul>
<p>像刚才，我们介绍的Dropout就是一个很好的例子。此外，比如Batch Normalization也是类似的，它在训练时选取随机的minibatch去做归一化；但是在测试的时候，就是用规定下来的数据$\mu,\sigma^2$ 去给输入值做归一化</p>
<h3 id="Data-augumentation-增加训练数据"><a href="#Data-augumentation-增加训练数据" class="headerlink" title="Data augumentation 增加训练数据"></a>Data augumentation 增加训练数据</h3><p>增加训练数据的好处主要有两个：</p>
<ol>
<li>在一些神经网络中，输入值的数据量可能没有很大。比如说要用神经网络来训练医学影像，但是患者是有限的，拍片数量也是有限的，因此我们需要想办法增加训练集的数据。</li>
<li>如果训练集过小，神经网络的训练效果是不如机器学习的，因为很容易发生过拟合的情况，由此，我们更需要增加训练数据，避免过拟合。从这个角度看 ，增加训练数据的目的和正则化的目的是一样的，所以放在一起讲</li>
</ol>
<p>下面来讲几种增加训练数据的方法</p>
<h4 id="Transform-image"><a href="#Transform-image" class="headerlink" title="Transform image"></a>Transform image</h4><p>反转图片，如下</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/48.png"></p>
<p>和反转图片相似的，我们还可以扭曲部分图片像素，来达到增加训练数据的效果</p>
<h4 id="Color-jitter"><a href="#Color-jitter" class="headerlink" title="Color jitter"></a>Color jitter</h4><p>我们可以随机调整图片的对比度、亮度，如下</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/47.png"></p>
<h4 id="Random-Crops-and-Scales"><a href="#Random-Crops-and-Scales" class="headerlink" title="Random Crops and Scales"></a>Random Crops and Scales</h4><p>我们可以对一张照片进行裁剪和缩放，用相等的框框从图中选取$l\times l$的图片</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/49.png"></p>
<p>在推理的时候，我们可以平均多个crops的预测结果，已达到正则化的目的</p>
<h4 id="随机池化大小"><a href="#随机池化大小" class="headerlink" title="随机池化大小"></a>随机池化大小</h4><p>随机池化大小可以简单理解为对图片实行不同程度的模糊。其实现原理就是将不同尺度的像素块(patch)合在一起</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/50.png"></p>
<h4 id="Cutout"><a href="#Cutout" class="headerlink" title="Cutout"></a>Cutout</h4><p>在小数据集上还常用Cutout方法，就是用一个方块挡住图片中不同的位置</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/51.png"></p>
<h4 id="Mixup"><a href="#Mixup" class="headerlink" title="Mixup"></a>Mixup</h4><p>还有一种方法就是Mixup，将两张图片按照不同的权重合并起来，以增加训练数据</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/52.png"></p>
<h3 id="早停法"><a href="#早停法" class="headerlink" title="早停法"></a>早停法</h3><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/34.png"></p>
<p>还有一个技巧，是在合适的时候停止训练神经网络，当我们看到验证集的正确率开始下降、或者已经训练很长时间的时候，我们就该停止训练。这被称为(早停法)，如上图所示</p>
<h3 id="在实际训练中"><a href="#在实际训练中" class="headerlink" title="在实际训练中"></a>在实际训练中</h3><ul>
<li>在大型的全连接网络中，我们需要使用Drop out</li>
<li>训练的时候使用Batch Normalization和各种常用的data augmentation</li>
<li>在小数据集上尝试随机池化，cutout,mixup等方法</li>
<li>使用early stopping 和 ensembles model</li>
</ul>
<h2 id="超参的选择"><a href="#超参的选择" class="headerlink" title="超参的选择"></a>超参的选择</h2><h3 id="Grid-Search"><a href="#Grid-Search" class="headerlink" title="Grid Search"></a>Grid Search</h3><p>在神经网络中非常重要的两个超参数就是Weight decay以及Learning rate，为了找到合适的超参，我们肯定需要大量循环。一个方法就是将两者的取值写成列表，然后穷举搭配。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">weight_decay_list &#x3D; [1*10^(-4),1*10^(-3),1*10^(-2),1*10^(-1)]</span><br><span class="line">learning_rate &#x3D; [1*10^(-4),1*10^(-3),1*10^(-2),1*10^(-1)]</span><br><span class="line"></span><br><span class="line">for weight in weight_decay_list:</span><br><span class="line">	for learning_rate in learing_rate_list:</span><br><span class="line">		#...</span><br></pre></td></tr></table></figure>
<h3 id="Random-Search"><a href="#Random-Search" class="headerlink" title="Random Search"></a>Random Search</h3><p>相比于确定多个值去做穷举，我们可以划定一个范围，然后在里面随机挑选超参搭配。运行多次后找到合适的超参方案：</p>
<p>比如说采用 loguniform函数，即连续对数均匀分布（在浮点数空间中的对数尺度上均匀分布）。然后每次训练的时候在这个函数中随机取值</p>
<p>Weight decay: log-uniform on $[1\times10^{-4},1\times10^{-1}]$;</p>
<p>Weight decay: log-uniform on $[1\times10^{-4},1\times10^{-1}]$;</p>
<p>在上面这个例子中，即在$[-4,-1]$中随机取值t，取$1\times 10^{-t}$作为参数</p>
<h3 id="两种搜索方法辨析"><a href="#两种搜索方法辨析" class="headerlink" title="两种搜索方法辨析"></a>两种搜索方法辨析</h3><p>在一个神经网络里面可能有很多超参数，有些超参数对神经网络的影响非常大，而有些超参对神经网络的影响几乎可以忽略不计。</p>
<p>此时，如果采用 Grid Search，如左下图所示，由于采用相等的间隔采样，我们很可能会略过最优值，而如果缩小采样间隔，会导致训练时间更长。</p>
<p>但是对于 Random Search，如右下图所示，更可能选择到好的重要参数，然后只要继续做微调即可</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/39.png"></p>
<h3 id="一般模式"><a href="#一般模式" class="headerlink" title="一般模式"></a>一般模式</h3><p>最后我们来讲如何选择超参数</p>
<p>综上，我们可以归结为如下步骤：</p>
<ol>
<li><p>验证loss计算的正确性</p>
<ul>
<li>是否加上正则项</li>
</ul>
</li>
<li><p>确保能够overfit一个小样本集</p>
<ul>
<li>我们可以从cifar10中选取10~50张图片作为模型</li>
<li>在不用正则项的情况下，初步调整学习率和初始化方法。<ul>
<li>如果loss始终不下降，说明学习率太小</li>
<li>如果loss突然暴增，说明学习率太大，已经跳过了最优点</li>
</ul>
</li>
</ul>
</li>
<li><p>使用全部数据集寻找合适的学习率</p>
<ul>
<li>加上很小的weight decay之后，在100个iteration以内搜索能使loss快速下降的学习率</li>
<li>一般可以尝试 0.1,0.01,0.001,0.0001</li>
</ul>
</li>
<li><p>粗粒度搜索学习率和weight decay，观察验证集结果</p>
<ul>
<li>在第3步确定的学习率范围内随机搜索，并随机搜索 weight decay</li>
<li>每个学习率和weight decay组合训练 ，一般取5个epoch</li>
</ul>
</li>
<li><p>细粒度搜索学习率和weight decay，观察验证集结果</p>
<ul>
<li>缩小第四步的搜索范围，训练更长时间 (大概20个epoch)</li>
</ul>
</li>
<li><p>根据learning curve 采取相应措施</p>
<ul>
<li><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/40.png"></p>
<p>如果出现上面这种情况，说明初始化有问题，我们应该调整参数初始化</p>
</li>
<li><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/41.png"></p>
<p>若出现上面这种情况，loss一直降不下来，我们可以尝试衰减学习率。(采用不同的策略)</p>
</li>
<li><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/42.png"></p>
<p>如果衰减学习率之后，loss出现一个断层，之后平滑、不再下降。说明我们衰减的太早了，还需要多训练几个epoch</p>
</li>
<li><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/43.png"></p>
<p>如果随着时间的推移，发现训练集的正确率持续上升而测试集正确率却逐渐走低。说明出现了过拟合的情况，此时需要增加正则，并使用更多数据</p>
</li>
<li><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/44.png"></p>
<p>如果训练集合测试集的准确率考的太近，说明我们选用的模型太小了，需要考虑使用更大的模型</p>
</li>
</ul>
</li>
<li><p>如果还是不理想，那么需要回到第五步再寻找</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/55.png"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/" itemprop="url">数据库-系统可用性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-12-01T18:55:07+08:00">
                2021-12-01
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-06-23T20:10:24+08:00">
                2022-06-23
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据库-系统可用性"><a href="#数据库-系统可用性" class="headerlink" title="数据库-系统可用性"></a>数据库-系统可用性</h1><p>系统的可用性是指：一个系统处在正常工作状态的时间比例</p>
<p> 比如说，一台机器的 MTTR(mean time to failure)是81.5年，MTTF(mean time to repair)是1h，那么：</p>
<ul>
<li>MTTF in hours = 81.5$\times$365$\times$24 = 713940</li>
<li>Inherent availability(Ai) = 713940/(713940+1) = 99.99986%</li>
</ul>
<p>怎么才能让服务器变得高可用呢?</p>
<p>我们可以使用 冗余节点(Redundancy) 和数据复制(Replication)的技术，当某节点发生故障时，切换到冗余节点。</p>
<h2 id="MongoDB的容错方案"><a href="#MongoDB的容错方案" class="headerlink" title="MongoDB的容错方案"></a>MongoDB的容错方案</h2><p>MongoDB诞生的时候，就决定部署在云上。那么在部署的时候我们就不能只放在一台机器上，需要做备份，如下图：</p>
<p><img src="/2021/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/1.png"></p>
<p>Primary是主机，有两个Secondary是主机的备份。系统要做的就是在主机更新时通知备份的及其来让这三个机器的数据保持一致。为了实现同步，我们需要了解<strong>心跳</strong>的含义，简单来说，心跳就是主机过一段时间(可能是几十毫秒).告诉对方我还在，还有心跳。一旦有Primary机器出故障了，就会影响心跳。这时候Secondary机器会感知到，其中一台机器变成了Primary, 如下图所示：</p>
<p><img src="/2021/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/2.png"></p>
<p>那么有一个问题：为什么是一主两备，而不是一主一备呢？第三台机器存在的意义是什么</p>
<p>其实，原来的高可用机制就是单机热备：</p>
<p>它的期望效果是：只要S1和S2 其中一个在线，系统即可用，如下图：</p>
<p><img src="/2021/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/3.png"></p>
<p>第一种情况，当S2出问题的时候，Primary S1还可以正常运行，等S2重启之后，再去做更新。</p>
<p>第二种情况，当Primary S1发生故障的时候，S2会宣布自己没有心跳了(Timeout)，然后S2转换身份变成Primary，当S1恢复之后，再把S2的信息同步给S1</p>
<p>这种设计，看起来只要两个主机不同时发生故障，就会一直运行下去，但事实上并非如此。如下图：</p>
<p><img src="/2021/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/4.png"></p>
<p>比如，最后一种情况，S1只是卡了一下，它并不认为自己是宕机了或者故障了，但此时S2已经收不到S1的心跳了，因此它决定变成Primary，但此时S1却回过神来了。这种情况下到底谁是Primary呢？这便出现了<strong>争议</strong>。有的用户会认为S1是Primary，而有的用户认为S2才是Primary。</p>
<p>解决办法只能是再增加一个S3，当两个人出现争议的时候，可以通过<strong>投票</strong>的方式选出新的Primary。</p>
<h2 id="Raft算法"><a href="#Raft算法" class="headerlink" title="Raft算法"></a>Raft算法</h2><p> raft是一个共识算法（consensus algorithm），所谓共识，就是多个节点对某个事情达成一致的看法，即使是在部分节点故障、网络延时、网络分割的情况下</p>
<p>而在分布式系统中，共识算法更多用于提高系统的容错性，比如分布式存储中的复制集（replication），在 带着问题学习分布式系统之中心化复制集 一文中介绍了中心化复制集的相关知识。raft协议就是一种leader-based的共识算法，与之相应的是leaderless的共识算法。</p>
<p>简单概括算法就是：raft会先选举出leader，leader完全负责replicated log的管理。leader负责接受所有客户端更新请求，然后复制到follower节点，并在“安全”的时候执行这些请求。如果leader故障，followes会重新选举出新的leader。</p>
<p>Raft算法可以分为几个子问题：Leader election , Log replication</p>
<h3 id="Leader-election"><a href="#Leader-election" class="headerlink" title="Leader election"></a>Leader election</h3><p>在raft协议中，一个节点任意时刻都处于以下三个状态之一：</p>
<ul>
<li>Leader</li>
<li>Follower</li>
<li>Candidate</li>
</ul>
<p>给出状态转移图能很直观的知道这三个状态的区别：</p>
<p><img src="/2021/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/5.png"></p>
<p>可以看出所有节点启动时都是follower状态；在一段时间内如果没有收到来自leader的心跳，从follower切换到candidate，发起选举；如果收到大多数节点的票（含自己的一票）则切换到leader状态；如果发现其他节点比自己更新，则主动切换到follower。</p>
<p> 总之，系统中最多只有一个leader，如果在一段时间里发现没有leader，则大家通过选举-投票选出leader。leader会不停的给follower发心跳消息，表明自己的存活状态。如果leader故障，那么follower会转换成candidate，重新选出leader。</p>
<h4 id="term"><a href="#term" class="headerlink" title="term"></a>term</h4><p>从上面可以看出，哪个节点做leader是大家投票选举出来的，每个leader工作一段时间，然后选出新的leader继续负责。这根民主社会的选举很像，每一届新的履职期称之为一届任期，在raft协议中，也是这样的，对应的术语叫<strong>term</strong>。</p>
<p><img src="/2021/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/6.png"></p>
<p>term（任期）以选举（election）开始，然后就是一段或长或短的稳定工作期（normal Operation）。从上图可以看到，任期是递增的，这就充当了逻辑时钟的作用；另外，term 3展示了一种情况，就是说没有选举出leader就结束了，然后会发起新的选举，后面会解释这种<em>split vote</em>的情况。</p>
<h4 id="选举过程"><a href="#选举过程" class="headerlink" title="选举过程"></a>选举过程</h4><p> 上面已经说过，如果follower在<em>election timeout</em>内没有收到来自leader的心跳，（也许此时还没有选出leader，大家都在等；也许leader挂了；也许只是leader与该follower之间网络故障），则会主动发起选举。步骤如下：</p>
<ul>
<li>增加节点本地的 <em>current term</em> ，切换到candidate状态</li>
<li>投自己一票</li>
<li>并行给其他节点发送 <em>RequestVote RPCs</em></li>
<li><p>等待其他节点的回复</p>
<p>在这个过程中，根据来自其他节点的消息，可能出现三种结果</p>
</li>
</ul>
<ol>
<li>收到majority的投票（含自己的一票），则赢得选举，成为leader</li>
</ol>
<blockquote>
<p> 第一种情况，赢得了选举之后，新的leader会立刻给所有节点发消息，广而告之，避免其余节点触发新的选举。在这里，先回到投票者的视角，投票者如何决定是否给一个选举请求投票呢，有以下约束：</p>
<ul>
<li>在任一任期内，单个节点最多只能投一票</li>
<li>候选人知道的信息不能比自己的少（这一部分，后面介绍log replication和safety的时候会详细介绍）</li>
<li>first-come-first-served 先来先得</li>
</ul>
</blockquote>
<ol>
<li>被告知别人已当选，那么自行切换到follower</li>
</ol>
<blockquote>
<p>第二种情况，比如有三个节点A B C。A B同时发起选举，而A的选举消息先到达C，C给A投了一票，当B的消息到达C时，已经不能满足上面提到的第一个约束，即C不会给B投票，而A和B显然都不会给对方投票。A胜出之后，会给B,C发心跳消息，节点B发现节点A的term不低于自己的term，知道有已经有Leader了，于是转换成follower。</p>
</blockquote>
<ol>
<li>一段时间内没有收到majority投票，则保持candidate状态，重新发出选举</li>
</ol>
<p><img src="/2021/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/7.png"></p>
<blockquote>
<p>第三种情况如上图所示，总共有四个节点，Node C、Node D同时成为了candidate，进入了term 4，但Node A投了NodeD一票，NodeB投了Node C一票，这就出现了平票 split vote的情况。这个时候大家都在等啊等，直到超时后重新发起选举。如果出现平票的情况，那么就延长了系统不可用的时间（没有leader是不能处理客户端写请求的），因此raft引入了randomized election timeouts来尽量避免平票情况。同时，leader-based 共识算法中，节点的数目都是奇数个，尽量保证majority的出现。</p>
</blockquote>
<h3 id="Log-replication"><a href="#Log-replication" class="headerlink" title="Log replication"></a>Log replication</h3><p>当有了leader，系统应该进入对外工作期了。客户端的一切请求来发送到leader，leader来调度这些并发请求的顺序，并且保证leader与followers状态的一致性。raft中的做法是，将这些请求以及执行顺序告知followers。leader和followers以相同的顺序来执行这些请求，保证状态一致。</p>
<h4 id="Replicated-state-machines"><a href="#Replicated-state-machines" class="headerlink" title="Replicated state machines"></a>Replicated state machines</h4><p>   共识算法的实现一般是基于复制状态机（Replicated state machines），何为复制状态机：</p>
<blockquote>
<p>If two identical, <strong>deterministic</strong> processes begin in the same state and get the same inputs in the same order, they will produce the same output and end in the same state.</p>
</blockquote>
<p>   简单来说：<strong>相同的初识状态 + 相同的输入 = 相同的结束状态</strong>。引文中有一个很重要的词<code>deterministic</code>，就是说不同节点要以相同且确定性的函数来处理输入，而不要引入一些不确定的值，比如本地时间等。如何保证所有节点 <code>get the same inputs in the same order</code>，使用replicated log是一个很不错的注意，log具有持久化、保序的特点，是大多数分布式系统的基石。</p>
<p>  因此，可以这么说，在raft中，leader将客户端请求（command）封装到一个个log entry，将这些log entries复制（replicate）到所有follower节点，然后大家按相同顺序应用log entry中的command，则状态肯定是一致的。</p>
<p><img src="/2021/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/8.png"></p>
<h4 id="请求完整流程"><a href="#请求完整流程" class="headerlink" title="请求完整流程"></a>请求完整流程</h4><p>当系统（leader）收到一个来自客户端的写请求，到返回给客户端，整个过程从leader的视角来看会经历以下步骤：</p>
<ul>
<li>leader append log entry</li>
<li>leader issue AppendEntries RPC in parallel</li>
<li>leader wait for majority response</li>
<li>leader apply entry to state machine</li>
<li>leader reply to client</li>
<li>leader notify follower apply log</li>
</ul>
<p>  可以看到日志的提交过程有点类似两阶段提交(2PC)，不过与2PC的区别在于，leader只需要大多数（majority）节点的回复即可，这样只要超过一半节点处于工作状态则系统就是可用的。</p>
<p>  那么日志在每个节点上是什么样子的呢</p>
<p><img src="/2021/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/9.png"></p>
<p> 不难看到，logs由顺序编号的log entry组成 ，每个log entry除了包含command，还包含产生该log entry时的leader term。从上图可以看到，五个节点的日志并不完全一致，raft算法为了保证高可用，并不是强一致性，而是最终一致性，leader会不断尝试给follower发log entries，直到所有节点的log entries都相同。</p>
<p>  在上面的流程中，leader只需要日志被复制到大多数节点即可向客户端返回，一旦向客户端返回成功消息，那么系统就必须保证log（其实是log所包含的command）<strong>在任何异常的情况下都不会发生回滚</strong>。这里有两个词：commit（committed），apply(applied)，前者是指日志被复制到了大多数节点后<strong>日志的状态</strong>；而后者则是节点将日志应用到状态机，真正影响到<strong>节点状态</strong>。</p>
<blockquote>
<p>The leader decides when it is safe to apply a log entry to the state machines; such an entry is called committed. Raft guarantees that committed entries are durable and will eventually be executed by all of the available state machines. A log entry is committed once the leader that created the entry has replicated it on a majority of the servers</p>
</blockquote>
<h3 id="Safety"><a href="#Safety" class="headerlink" title="Safety"></a>Safety</h3><p>在上面提到只要日志被复制到majority节点，就能保证不会被回滚，即使在各种异常情况下，这根leader election提到的选举约束有关。在这一部分，主要讨论raft协议在各种各样的异常情况下如何工作的。</p>
<p>  衡量一个分布式算法，有许多属性，如</p>
<ul>
<li>safety：nothing bad happens,</li>
<li>liveness： something good eventually happens.</li>
</ul>
<p>  在任何系统模型下，都需要满足safety属性，即在任何情况下，系统都不能出现不可逆的错误，也不能向客户端返回错误的内容。比如，raft保证被复制到大多数节点的日志不会被回滚，那么就是safety属性。而raft最终会让所有节点状态一致，这属于liveness属性。</p>
<p>  raft协议会保证以下属性</p>
<p><img src="/2021/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/10.png"></p>
<h4 id="Election-safety"><a href="#Election-safety" class="headerlink" title="Election safety"></a>Election safety</h4><p>  选举安全性，即任一任期内最多一个leader被选出。这一点非常重要，在一个复制集中任何时刻只能有一个leader。系统中同时有多余一个leader，被称之为脑裂（brain split），这是非常严重的问题，会导致数据的覆盖丢失。在raft中，两点保证了这个属性：</p>
<ul>
<li>一个节点某一任期内最多只能投一票；</li>
<li>只有获得majority投票的节点才会成为leader。</li>
</ul>
<p>  因此，<strong>某一任期内一定只有一个leader</strong>。</p>
<h4 id="log-matching"><a href="#log-matching" class="headerlink" title="log matching"></a>log matching</h4><p>很有意思，log匹配特性， 就是说如果两个节点上的某个<code>log entry</code>的<code>log index</code>相同且term相同，那么在该index之前的所有log entry应该都是相同的。如何做到的？依赖于以下两点</p>
<ul>
<li>If two entries in different logs have the same index and term, then they store the same command.如果不同日志中的两个条目具有相同的索引和term，那么它们存储的是同一个命令。</li>
<li>If two entries in different logs have the same index and term, then the logs are identical in all preceding entries.如果不同日志中的两个条目具有相同的索引和term，那么日志中的所有前面的条目都是相同的。</li>
</ul>
<p>首先，leader在某一term的任一位置只会创建一个log entry，且log entry是append-only。其次，consistency check。leader在AppendEntries中包含最新log entry之前的一个log 的term和index，如果follower在对应的term index找不到日志，那么就会告知leader不一致。</p>
<p>在没有异常的情况下，log matching是很容易满足的，但如果出现了node crash，情况就会变得复杂。比如下图</p>
<p><img src="/2021/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/11.png"></p>
<p><strong>注意</strong>：上图的a-f不是6个follower，而是某个follower可能存在的六个状态</p>
<p>leader、follower都可能crash，那么follower维护的日志与leader相比可能出现以下情况</p>
<ul>
<li>比leader日志少，如上图中的ab</li>
<li>比leader日志多，如上图中的cd</li>
<li>某些位置比leader多，某些日志比leader少，如ef（多少是针对某一任期而言）</li>
</ul>
<p>最终的结果是日志必须按照顺序记录的如下图：</p>
<p><img src="/2021/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/9.png" style="zoom:50%;"></p>
<p> 因此，当出现了leader与follower不一致的情况，leader强制follower复制自己的log</p>
<blockquote>
<p>To bring a follower’s log into consistency with its own, the leader must find the latest log entry where the two logs agree, delete any entries in the follower’s log after that point, and send the follower all of the leader’s entries after that point.</p>
</blockquote>
<p>leader会维护一个<code>nextIndex[]</code>数组，记录了leader可以发送每一个follower的log index，初始化为eader最后一个log index加1， 前面也提到，leader选举成功之后会立即给所有follower发送AppendEntries RPC（不包含任何log entry， 也充当心跳消息）,那么流程总结为：</p>
<blockquote>
<p>s1 leader 初始化nextIndex[x]为 leader最后一个 log index + 1<br>s2 AppendEntries里prevLogTerm prevLogIndex来自 logs[nextIndex[x] - 1]<br>s3 如果follower判断prevLogIndex位置的log term不等于prevLogTerm，那么返回 False，否则返回True<br>s4 leader收到follower的回复，如果返回值是False，则nextIndex[x] -= 1, 跳转到s2. 否则<br>s5 同步nextIndex[x]后的所有log entries</p>
</blockquote>
<h4 id="leader-completeness-vs-elcetion-restriction"><a href="#leader-completeness-vs-elcetion-restriction" class="headerlink" title="leader completeness vs elcetion restriction"></a>leader completeness vs elcetion restriction</h4><p>  leader完整性：如果一个log entry在某个任期被提交（committed），那么这条日志一定会出现在所有更高term的leader的日志里面。这个跟leader election、log replication都有关。</p>
<ul>
<li>一个日志被复制到majority节点才算committed</li>
<li>一个节点得到majority的投票才能成为leader，而节点A给节点B投票的其中一个前提是，B的日志不能比A的日志旧。下面的引文指处了如何判断日志的新旧</li>
</ul>
<blockquote>
<p>voter denies its vote if its own log is more up-to-date than that of the candidate.</p>
<p>If the logs have last entries with different terms, then the log with the later term is more up-to-date. If the logs end with the same term, then whichever log is longer is more up-to-date.</p>
</blockquote>
<p>  上面两点都提到了majority：commit majority and vote majority，根据Quorum，这两个majority一定是有重合的，因此被选举出的leader一定包含了最新的committed的日志。</p>
<p>  raft与其他协议（Viewstamped Replication、mongodb）不同，raft始终保证leade包含最新的已提交的日志，因此leader不会从follower catchup日志，这也大大简化了系统的复杂度。</p>
<p>我们可以在 Raft官网看到可视化的Raft，十分有趣 <a href="https://raft.github.io/" target="_blank" rel="noopener">https://raft.github.io/</a></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/11/29/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch12-%E5%AD%90%E6%A8%A1%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/11/29/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch12-%E5%AD%90%E6%A8%A1%E5%87%BD%E6%95%B0/" itemprop="url">数据科学算法ch12-子模函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-11-29T15:54:33+08:00">
                2021-11-29
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-01-06T23:38:10+08:00">
                2022-01-06
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据科学算法ch12-子模函数"><a href="#数据科学算法ch12-子模函数" class="headerlink" title="数据科学算法ch12-子模函数"></a>数据科学算法ch12-子模函数</h1><p>子模函数时边际效用递减规律的形式化表示。在机器学习和人工智能领域，子模函数有着广泛的应用，如文档摘要、信息扩散、传感器布置和图像采集描述等诸多问题</p>
<p>比如说：要在办公楼里面布置无线网络，由于在不同的位置安装无线路由器的效果是不同的，那么在那些地方安装无线路由器能满足上述条件且总花费越低？要知道，部署的无线路由器越多，对提升网络覆盖率的贡献就越低。</p>
<p>又比如说：在大数据时代，日常看到的信息可能是片面零散的，可以采用文本摘要技术来帮助人们解决碎片化阅读的问题。我们的目标是用尽量少的句子来覆盖用户感兴趣的关键词。当选择的句子越来越多，未被包含的关键词就越少，因此选择句子对文本中的关键词覆盖也符合边际效用递减的规律。</p>
<p>上面例子中都设计边际效用递减规律，在数学上这个规律可以被定义为子模函数</p>
<h2 id="子模函数"><a href="#子模函数" class="headerlink" title="子模函数"></a>子模函数</h2><p>在了解子模函数前，我们首先了解一下凸函数和凹函数：</p>
<p><img src="/2021/11/29/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch12-%E5%AD%90%E6%A8%A1%E5%87%BD%E6%95%B0/1.png" alt></p>
<p>现在我们从凹函数到子模：</p>
<p>对于集合函数$f:{0,1}^n\rightarrow \mathbb R,\forall i,\partial_if(x)=f(x+e_i)-f(x)$ <strong>是非增的</strong>，那么$f(x)$就是子模函数</p>
<p>也就是说，从集合中任意调出一个子集来，我们可以将其映射为一个实数，然后这个实数的变化趋势和凹函数是一致的。</p>
<p>但是对于集合函数来讲，单调性并不是说一个大小为5的子集对应的函数的值一定大于一个大小为4的子集。它只大于它自己的大于等于4的子集的函数值。</p>
<p>用集合的话来说：</p>
<p>集合函数： $f:{0,1}^n\rightarrow \mathbb R$ 是子模函数当且仅当对 $\forall A,B\subseteq V$, 以下不等式成立</p>
<script type="math/tex; mode=display">
f(A)+f(B)\geq f(A\cap B)+f(A\cup B)</script><p><img src="/2021/11/29/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch12-%E5%AD%90%E6%A8%A1%E5%87%BD%E6%95%B0/2.png"></p>
<h3 id="子模函数的等价定义"><a href="#子模函数的等价定义" class="headerlink" title="子模函数的等价定义"></a>子模函数的等价定义</h3><p>子模函数有两个等价定义：</p>
<p><strong>边际效用递减</strong>：</p>
<p>对任意的 $S\subseteq T\subseteq V$ 和 $v\in V \backslash T$ </p>
<script type="math/tex; mode=display">
f(S\cup \{v\})-f(S)\geq f(T\cup \{v\})-f(T)</script><p>这实际上就是边际效用递减规律的<strong>形式化表述</strong>。</p>
<ul>
<li>我们可以把边际效用看做是：$f(S\cup {v})-f(S)$ ，即在集合S中增加元素 $v$ 导致函数值变化。</li>
<li>进一步，随着集合$S$ 的不断增大，比如增加到集合<strong>T</strong> ,那么显然边际效用 $f(T\cup {v})-f(T)$ 是不断减少的。</li>
</ul>
<p>因此，我们说当 $S\subseteq T$ 的时候，$f(S\cup {v})-f(S)\geq f(T\cup {v})-f(T)$</p>
<p><strong>集合效用递减：</strong></p>
<p>对于任意的$S\subseteq T\subseteq V$ 以及 $C\subseteq V \backslash T$ </p>
<p>满足：</p>
<script type="math/tex; mode=display">
f(S\cup C)-f(S) \geq f(T\cup C)-f(T)</script><p>也很容易理解，上面是加一个元素，现在是加一个集合，归根到底就是边际效用递减</p>
<h3 id="子模函数的性质"><a href="#子模函数的性质" class="headerlink" title="子模函数的性质"></a>子模函数的性质</h3><p>假设 $f(A)$ 和 $g(A)$ 为任意两个子模函数，则：</p>
<ol>
<li>对 $\forall a&gt; 0$ ,$af(A)$ 也是一个子模函数</li>
<li>$f(A)+g(A)$ 也是一个子模函数</li>
<li>$\overline f(A)=f(A^c)$ 也是一个子模函数</li>
<li>对任意固定的 $S\subset U$,$f(A|S)=f(A\cap S)$ 也是一个子模函数</li>
<li>对任意固定的 $S\subset U$ ,$f(A|S^c) = f(A\cup S)-f(S)$  也是一个子模函数</li>
</ol>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h4><p>给定一个集合$ V$，当$A\subseteq V$ 的时候，有 $f(A)$ 是一个子模函数</p>
<p>a. 证明 $\overline f(A)= f(A^c)$ 是一个子模函数</p>
<p>b. 证明 当$S\subset V,~g(A) = f(A\cap S) $ 是一个子模函数</p>
<p>证明什么函数是一个子模函数，我们一定要从定义入手，也就是 $f(S)+f(T)\geq f(S\cup T)+f(S\cap T)$</p>
<p>比如说a, 我们令 $A = S^c,B=T^c$, 带入到 $f(A)$中，得到</p>
<script type="math/tex; mode=display">
f(A)+f(B) \geq f(A\cup B)+f(A\cap B)\\~\\
f(S^c)+f(T^c)\geq f(S^c\cup T^c)+f(S^c\cap T^c)</script><p>已知：</p>
<script type="math/tex; mode=display">
A\cup B = S^c\cup T^c = (S\cap T)^c\\
A\cap B = S^c\cap T^c = (S\cup T)^c\\

f(S\cap T)^c = \overline f(S\cap T)\\
f(S\cup T)^c = \overline f(S\cup T)</script><p>又：</p>
<script type="math/tex; mode=display">
f(S^c) = \overline f(S)\\
f(T^c) = \overline f(T)</script><p>因此，上式可以化为：</p>
<script type="math/tex; mode=display">
\overline f(S)+\overline f(T)\geq \overline f(S\cap T)+\overline f(S\cup T)</script><p>得证</p>
<hr>
<p>对于b，即：</p>
<script type="math/tex; mode=display">
\begin{align}
f(A\cap S)+f(B\cap S) &\geq f\bigg((A\cap S)\cup(B\cap S)\bigg)+f\bigg((A\cap S)\cap(B\cap S)\bigg)\\
&\geq f\bigg((A\cup B)\cap S \bigg)+f\bigg( (A\cap  B)\cap S \bigg)\\
\end{align}</script><p>我们令  $S = A\cap S, T = B\cap S$, 那么，根据上式，可知： $g(S)+g(T) \geq g(S\cap T)+g(S\cup T)$</p>
<h4 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h4><p>a. 证明<strong>边际效用递减</strong>的等价定义</p>
<p>需要分充分性和必要性证明，首先证明必要性</p>
<p>令 $S\subset T$ ，给定集合 $S\cup{V}$ 和 $T$， 如果 $v\notin T$, 根据定义，我们有：</p>
<script type="math/tex; mode=display">
f(S\cup\{v\})+f(T)\geq f(S\cup \{v\}\cup T)+f(S\cup\{v\}\cap T)</script><p>注意到： $f(S\cup{v}\cup T)=f(T\cup{v}),f((S\cup{v})\cap T)=f(S)$ </p>
<p>带入上式，有：</p>
<script type="math/tex; mode=display">
f(S\cup \{v\})-f(S)\geq f(T\cup\{v\})-f(T)</script><p>然后，我们来证明充分性</p>
<p>给定两个集合 $S$ 和 $T$ ,令 $T\backslash S = {v_1,v_2\cdots,v_k}$, $T_j = {v_1,\cdots,v_j}$ , 我们令：$A_j = (S\cap T)\cup T_j,B_j = S\cup T_j$ , 我们有：</p>
<script type="math/tex; mode=display">
f(A_j\cup{v_{j+1}})-f(A_j)\geq f(B_j\cup{v_{j+1}})-f(B_j),j = 0,\cdots,k-1</script><p>对上式的$k-1$ 个句子求和，可以得到：</p>
<script type="math/tex; mode=display">
f(S)+f(T)\geq f(S\cup T)+f(S\cap T)</script><p>b. 证明<strong>集合效用递减</strong>的等价定义</p>
<p>将上面的$v_i$ 换成集合$C$ 即可</p>
<h4 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h4><p>设 $w: N\rightarrow R$ 表示有限集 $N$ 中元素的权重，考虑一个线性函数为：</p>
<script type="math/tex; mode=display">
f(S) = \sum_{i\in S}w_i ,\forall S\subseteq N</script><p>证明这个线性函数是一个子模函数</p>
<script type="math/tex; mode=display">
f(S) = \sum_{i\in S} w_i\\
f(T) =\sum_{i\in T} w_i\\
f(S\cup T) = \sum_{i\in {S\cup T}} w_i\\
f(S\cap T) = \sum_{i\in {S\cap T}} w_i\\
f(S\cup T)+f(S\cap T) = \sum_{i\in S\cup T}w_i+\sum_{i\in S\cap T} w_i= \sum_{i\in S}w_i+\sum_{i\in T}w_i-\sum_{i\in S\cap T}+\sum_{i\in S\cap T}=f(S)+f(T)\\</script><p>满足 子模函数对 $f(S)+f(T)\geq f(S\cup T)+f(S\cap T)$ 的定义，因此这个函数是一个子模函数</p>
<h2 id="集合覆盖"><a href="#集合覆盖" class="headerlink" title="集合覆盖"></a>集合覆盖</h2><p>首先给出覆盖及其相关定义：</p>
<blockquote>
<p>集合覆盖</p>
</blockquote>
<p>设A是非空集，C是集合A的非空子集组成的集合，即$C={A<em>\alpha|A</em>\alpha\in A,A_\alpha\neq \empty}$ ，C是集合A的覆盖，若C满足：</p>
<script type="math/tex; mode=display">
\bigcup_{A_\alpha\in C}A_{\alpha} = A</script><blockquote>
<p>最小全覆盖问题</p>
</blockquote>
<p>令U为一有限集，$\mathcal S = {s_1,\cdots,s_n}$ 为 由U的n个子集构成的集族，全覆盖问题是找到$\mathcal S$最小的子集盖 集合U</p>
<p>简单来说，就是找到最小的 句子集合包含所有的单词</p>
<blockquote>
<p>k-最大覆盖问题</p>
</blockquote>
<p>令$U$为一有限集，$\mathcal S={s_1,s_2\cdots,s_n}$ 为由$U$的n个子集构成的集族，给定正整数k，最大子覆盖问题就是从$\mathcal S$ 中找到k个子集，使得这k个子集覆盖集合$U$中最多的元素</p>
<p>简单来说，找到k个句子使得其包含的单词数量最多</p>
<h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p>比如话务验业务技能全集$U={a,b,c,d,e,f,g,h,i,j,k,l}$，现在考虑有7名候选话务员的集合$S={A_1,A_2\cdots,A_7}$ ,其中，7位话务员的技能分别为：</p>
<script type="math/tex; mode=display">
A_1= \{a,b,c,d\},A_2= \{e,f,g,h\},A_3 = \{i,j,k,l\}\\
A_4 = \{a,e\},A_5 = \{i,b,f,g\},A_6 = \{c,e,h,j,k,l\},A_7 = \{l\}</script><p> 对于最小全覆盖问题：</p>
<p>话务员集合 $C_1 = {A_1,A_2,A_3,A_4}$和$C_2={A_1,A_5,A_6}$ 中的话务员都能满足客户所有类型的需求。但是集族$C_1$需要4位话务员，而集族$C_2$ 只需要3为话务员。因此$C_1$并不可能是$U$的最小全覆盖，而不存在两位话务员的集合就能实现全覆盖，因此$C_2$ 是全集U的一个最小全覆盖。</p>
<p>当然，$S={A_1,A_2,A_3}$ 也是一个大小为3 的全覆盖</p>
<p>对于最大覆盖问题：</p>
<p>假定只能制定两名话务员向客户提供服务，应该选择那两位话务员呢？</p>
<p>由于第6位话务员包含了6种技能，是所有话务员中技能最多的，为了使得应对的客户需求尽可能的多，可以把第6位作为候选之一。而且${A_1,A_2,A_3,A_5}$都有4种业务技能，且：</p>
<script type="math/tex; mode=display">
A_1\cap A_6 = \{c\},A_2\cap A_6 = \{e,h\}\\
A_3\cap A_6 = \{j,k,l\},A_5\cap A_6 = \{\empty\}</script><p>进一步：</p>
<script type="math/tex; mode=display">
\abs{A_1\cap A_6} = 9,\abs{A_2\cap A_6} = 8\\
\abs{A_3\cap A_6} =7,\abs{A_5\cap A_6} = 10</script><p>因此，集族$C={A_5,A_6}$ 能够覆盖客户10类不同的需求，因此集族$C={A_5,A_6}$ 构成$k=2$时的最大覆盖</p>
<p>对于这种小数据量问题，从中发现最大覆盖还是比较容易的。但是很多应用中数据规模都很大，比如在文本摘要中全集可以是一些关键词。给定的语料中可能包含成千上万的句子，此时要发现最大覆盖就不那么容易了</p>
<h3 id="抽取式文本摘要"><a href="#抽取式文本摘要" class="headerlink" title="抽取式文本摘要"></a>抽取式文本摘要</h3><p>给定用户定义的n个关键词组成的集合 $W={w_1,w_2\cdots,w_n}$ 和 m个候选句子集合$\mathcal S = {s_i|s_i\sub W,i=1,2\cdots,m}$ ，其中句子$s_i$ 表示该句子包含的关键词集合。抽取式文本摘要问题旨在选择k个句子，使得这k个句子能够包含最多数量的关键词</p>
<p>用整数规划的形式来表达，可以是：</p>
<p>令$\mathscr{C}$ 为找出的k个句子，那么设</p>
<script type="math/tex; mode=display">
x_i=\cases{1,S_i\in \mathscr C\\0,S_i\notin\mathscr C} 
\\~\\
y_i = \cases{1,w_j\in \bigcup_{S\in \mathscr T}S\\0,w_j\notin \bigcup_{S\in\mathscr T}S}</script><p>整数规划问题可写为：</p>
<script type="math/tex; mode=display">
\begin{align}
&\max \sum_j y_j\\
s.t.&\sum_i x_i\leq k\\
&\sum_{w_j\in S_i} x_i\geq y_j\\
&x_i\in\{0,1\},\forall i\in[m]\\
&y_j\in\{0,1\},\forall j\in [n]
\end{align}</script><h2 id="爬山算法"><a href="#爬山算法" class="headerlink" title="爬山算法"></a>爬山算法</h2><p>爬山算法是一个解决子模优化问题的局部搜索算法。下图是爬山算法的一个实例，它解决了最大子覆盖问题。该算法在每次迭代过程中选择使得集合覆盖函数$f(A)$<strong>边际增幅最大 </strong>的候选元素u，通过不停地迭代，从一个候选结果想另一个候选结果”移动”直到终止条件满足</p>
<p><img src="/2021/11/29/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch12-%E5%AD%90%E6%A8%A1%E5%87%BD%E6%95%B0/3.png"></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>假设给定的关键词集合为 $W={w_1,w_2\cdots,w_S}$ ，共有9个候选句子$D={s_1,s_2\cdots,s_9}$ ，用于文本摘要，其中这9个句子包含的关键词分别为：</p>
<script type="math/tex; mode=display">
\begin{align}
&s_1 = \{w_1,w_2,w_8\}~s_2=\{w_1,w_3,w_7\}~s_3 = \{w_1,w_6\}\\
&s_4 = \{w_1,w_3,w_7,w_8\}~s_5=\{w_1,w_5,w_6\}~s_6 = \{w_1,w_5,w_8\}\\
&s_7 = \{w_5\},s_8 = \{w_1,w_4,w_6\} ,s_9 = \{w_2,w_8\}
\end{align}</script><ul>
<li>第一轮迭代：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>子集</th>
<th>f(A)</th>
<th>$f(A\cup A_i)$</th>
<th>$\Delta$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$s_1$</td>
<td>0</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>$s_2$</td>
<td>0</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>$s_3$</td>
<td>0</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>$s_4$</td>
<td>0</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>$s_5$</td>
<td>0</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>$s_6$</td>
<td>0</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>$s_7$</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>$s_8$</td>
<td>0</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>$s_9$</td>
<td>0</td>
<td>2</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<p>我们看到，第一轮，一定是选择包含关键词最多的那个句子，也就是 $s_4$. 现在，$f(A) = {w_1,w_3,w_7,w_8}$ </p>
<ul>
<li>第二轮迭代：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>子集</th>
<th>f(A)</th>
<th>$f(A\cup A_i)$</th>
<th>$\Delta$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$s_1$</td>
<td>4</td>
<td>5</td>
<td>1</td>
</tr>
<tr>
<td>$s_2$</td>
<td>4</td>
<td>4</td>
<td>0</td>
</tr>
<tr>
<td>$s_3$</td>
<td>4</td>
<td>5</td>
<td>1</td>
</tr>
<tr>
<td>$s_5$</td>
<td>4</td>
<td>6</td>
<td>2</td>
</tr>
<tr>
<td>$s_6$</td>
<td>4</td>
<td>5</td>
<td>1</td>
</tr>
<tr>
<td>$s_7$</td>
<td>4</td>
<td>5</td>
<td>1</td>
</tr>
<tr>
<td>$s_8$</td>
<td>4</td>
<td>6</td>
<td>2</td>
</tr>
<tr>
<td>$s_9$</td>
<td>4</td>
<td>5</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>在第二轮迭代中，边际效益就少了很多了，我们看到 边际效益最大的是 $s_5,s_8$，这里选择靠前的，也就是$s_5$, 更新 $f(A) = {w_1,w_3,w_5,w_6,w_7,w_8}$</p>
<ul>
<li>第三轮迭代</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>子集</th>
<th>f(A)</th>
<th>$f(A\cup A_i)$</th>
<th>$\Delta$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$s_1$</td>
<td>6</td>
<td>7</td>
<td>1</td>
</tr>
<tr>
<td>$s_2$</td>
<td>6</td>
<td>6</td>
<td>0</td>
</tr>
<tr>
<td>$s_3$</td>
<td>6</td>
<td>6</td>
<td>0</td>
</tr>
<tr>
<td>$s_6$</td>
<td>6</td>
<td>6</td>
<td>0</td>
</tr>
<tr>
<td>$s_7$</td>
<td>6</td>
<td>6</td>
<td>0</td>
</tr>
<tr>
<td>$s_8$</td>
<td>6</td>
<td>7</td>
<td>1</td>
</tr>
<tr>
<td>$s_9$</td>
<td>6</td>
<td>7</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>第三轮迭代，大多数边际效益都为0了，这里选择 最靠前的边际效益最大的句子 $s_1$</p>
<p>因此，我们看见，爬山算法并不是只有一种结果，只要让$f(A)$ 到达终止条件即可</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/" itemprop="url">数据科学算法ch11-整数规划</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-11-23T22:27:16+08:00">
                2021-11-23
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-01-06T20:39:04+08:00">
                2022-01-06
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据科学算法ch11-整数规划"><a href="#数据科学算法ch11-整数规划" class="headerlink" title="数据科学算法ch11-整数规划"></a>数据科学算法ch11-整数规划</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>这章我们来学习<strong>离散变量的优化问题</strong>。这些问题的描述非常简单，但是由于”组合爆炸”的原因，导致求解此类问题的最优解变得非常困难。典型的问题有：旅行商问题(TSP),集合覆盖问题(SCP)等。这里给出几例</p>
<h3 id="旅行商问题"><a href="#旅行商问题" class="headerlink" title="旅行商问题"></a>旅行商问题</h3><p>给定一组城市以及每两个城市间的旅行成本(或距离)，旅行商问题(TSP)旨在：在经过每个城市一次的情况下最后回到出发的城市，应该如何选择行进路线以使总行程最短？ </p>
<p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/1.png" style="zoom:67%;"></p>
<p>即输入：包含n个点的几何，以及两两间的成本</p>
<p>输出：如果遍访所有顶点，对 对称TSP问题 的可行解决方案为$\frac{(n-1)!}2$ </p>
<p>目标函数：最小化旅行成本(或距离)的大小</p>
<p>那么TSP就可以定义在一个无向图上：$G=(V,E)$,其中$V$为顶点集合 $E$为边的集合，且每条边的成本为 $c_{jj}$</p>
<p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/18.png"></p>
<p>约束的第一个式子：保证从一个城市出发只能去一个城市</p>
<p>约束的第二个式子：保证每个城市只能被访问一次 </p>
<p>约束的第三个式子：保证只有n个顶点构成的一个环，从而回到出发的城市。如果地图上有两个环，就不是TSP问题的解</p>
<h3 id="集合覆盖问题-SCP"><a href="#集合覆盖问题-SCP" class="headerlink" title="集合覆盖问题(SCP)"></a>集合覆盖问题(SCP)</h3><p>输入：</p>
<ul>
<li>全集 $U = {u_1,u_2,\cdots,u_n}$</li>
<li>子集簇 $S = {S_i|S_i\subseteq U ,i\in [1,\cdots,m]}$​​</li>
<li>成本 $C = {c_1,\cdots,c_m}$</li>
</ul>
<p>目标：找到一个指标集 $I\in {1,\cdots,m}$ ，使得$\sum<em>{i\in I}c_i$ 最小且满足 $\bigcup</em>{i\in I}S_i = U$</p>
<p>集合覆盖问题具有广泛的应用：</p>
<ul>
<li>全覆盖和最大覆盖</li>
<li>顶点覆盖</li>
<li>信息传播</li>
<li>文本摘要</li>
</ul>
<h3 id="Fiver-游戏"><a href="#Fiver-游戏" class="headerlink" title="Fiver 游戏"></a>Fiver 游戏</h3><p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/2.png" style="zoom:67%;"></p>
<p>问题定义：我们注意到，同一个圆圈被点击两次，又恢复了原样，若一个圆圈为红色，这个圆圈及其周围4个圆圈总共被点击的次数一定为一个奇数。</p>
<p>因此我们可以定义：</p>
<script type="math/tex; mode=display">
x_{ij} = \cases{1,\text{circle}~(i,j) ~\text{is clicked}\\0,\text{otherwise}}</script><p>该问题可以建模为：</p>
<script type="math/tex; mode=display">
\begin{align}
&\min \sum_{i}^5\sum_i^5x_{ij}\\
&x_{ij}+x_{i(j-1)}+x_{i(j+1)}+x_{(i-1)j}+x_{(i+1)j} ~\text{is odd}\\
&x_{ij}\in\{0,1\},\forall i,j\in[1,5]\\
&x_{ij}=0,\text{otherwise}\\
\end{align}</script><p>然而，这并不是一个规划问题，因为其中的约束条件并不是线性的。我们知道最坏的条件就是一个圆圈被点击了五次变为红色(自己+左右上下)，那通过引入一个自由变量$y_{ij}$​, 令其取值为$[0,2]$,我们就可以将这个问题转化成一个整数规划的问题：</p>
<script type="math/tex; mode=display">
\begin{align}
&\min \sum_{i}^5\sum_i^5x_{ij}\\
&x_{ij}+x_{i(j-1)}+x_{i(j+1)}+x_{(i-1)j}+x_{(i+1)j} -2y_{ij} =1\\
&x_{ij}\in\{0,1\},\forall i,j\in[1,5]\\
&x_{ij}=0,\text{otherwise}\\
&0\leq y_{ij}\leq 2,y_{ij}\in N,1\leq i,j\leq 5
\end{align}</script><p>这里，$y<em>{ij}=0$，就是取1的情况；$y</em>{ij}=1$ 就是取3的情况；$y_{ij}=2$​ ,就是填5的情况。也就是覆盖了所有情境，将自然语言转换成了优化条件</p>
<p>以上举的三个例子，最后都转换成了线性整数规划，其要求就是输入和输出都是线性函数，可行解是所有满足这些线性等式(不等式)，且要满足完整性(即整数)，接下来详细来介绍一下：</p>
<h2 id="整数规划"><a href="#整数规划" class="headerlink" title="整数规划"></a>整数规划</h2><p>线性整数规划化在我们初中的时候就已经学过了，就是一类需要用画图解决的应用题。但是难点就在于如何建模，使得自然语言转换成约束条件。</p>
<p>线性整数规划类型可以分成下面三种：</p>
<p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/3.png" style="zoom:67%;"></p>
<p>第一种 混合线性整数规划。在这章中没有涉及，没有特别有效的方法来解决。</p>
<p>第二种 线性整数规划，即目标函数是线性的，约束是线性条件，<strong>解的类型是整数</strong></p>
<p>第三种 0-1线性规划，是线性整数规划的一种特殊类型，比如Fiver问题、TSP问题。其特点就是变量的类型都是布尔型。 </p>
<p>比如说这里有一个整数规划的问题：</p>
<script type="math/tex; mode=display">
\max z = 3x+4y\\
\text{约束条件}~ x+y\leq4\\
2x+3y\leq 9\\
0\leq x,y\in \boldsymbol Z</script><p>其可行域就是由空心点组成的集合：</p>
<p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/4.png" style="zoom:67%;"></p>
<h2 id="分支定界法"><a href="#分支定界法" class="headerlink" title="分支定界法"></a>分支定界法</h2><p>上面这个整数规划的例子，只有两个决策变量，即使每个可行解都试一遍，也很快就能得到该整数规划问题的解，那么如果有很多决策变量的情况该怎么办呢？</p>
<p>我们要学习：枚举树</p>
<p>比如下面这个例子</p>
<script type="math/tex; mode=display">
\max 24x_1+2x_2+20x_3+4x_4\\
\text{约束条件} ~~~8x_1+x_2+20x_3+4x_4\leq 9\\
x_i\in\{0,1\},1\leq i\leq 4</script><p>如果我们一一枚举，那么所有可能的取值有$2^4$种，但是在现实生活中，决策变量的数量可能为n，如果一个一个去，那么可行域的大小就可能是$2^n$ 。因此，如何有效地遍历整个可行域成为一个关键的问题。</p>
<p>通常，我们可以利用枚举树把整个可行域迭代地分割为越来越小的子集，每个子集称为一个<strong>分支</strong>。</p>
<p>在枚举树中，每个节点对应一个整数规划的问题，<strong>其中根节点是原始的整数规划问题</strong>，每个节点的孩子，是在父亲节点对应的整数规划问题上，通过<strong>固定某个决策变量</strong>的取值来得到一个新的整数规划问题。</p>
<p>以上面这个整数规划问题为例，那么$IP(1)$ 对应的整数规划问题是：</p>
<script type="math/tex; mode=display">
\begin{align}
&\text{IP(1)}\\
&\max 24x_1+2x_2+20x_3+4x_4\\
&\text{约束条件} ~~~8x_1+x_2+5x_3+4x_4\leq 9\\
&x_i\in\{0,1\},1\leq i\leq 4\\
\end{align}</script><p>那么根节点的两个孩子节点$IP(2)$和$IP(3)$ 分别为如下的整数规划问题：</p>
<script type="math/tex; mode=display">
\begin{align}
&\text{IP(2)}\\
&\max 24x_1+2x_2+5x_3+4x_4\\
&\text{约束条件} ~~~8x_1+x_2+20x_3+4x_4\leq 9\\
&x_1=0\\
&x_i\in\{0,1\},2\leq i\leq 4\\~\\
&\text{IP(3)}\\
&\max 24x_1+2x_2+20x_3+4x_4\\
&\text{约束条件} ~~~8x_1+x_2+5x_3+4x_4\leq 9\\
&x_1=1\\
&x_i\in\{0,1\},2\leq i\leq 4\\
\end{align}</script><p>以此类推，每个节点都有两个孩子节点，对于整数规划问题$IP(1)$ ,可以构建下图所示的枚举树</p>
<p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/5.png"></p>
<h3 id="松弛和定界"><a href="#松弛和定界" class="headerlink" title="松弛和定界"></a>松弛和定界</h3><p>但这样也并不能解决变量一多以后的运算问题，如果能够去掉一些明显不会称为最优解的分支，那么求解整数规划的问题会变得更为高效。</p>
<p>比如说对于上面这棵枚举树中的 $IP(4)$和$IP(7)$. </p>
<p>关于$IP(4)$ ，我们的整数规划的定义如下：</p>
<script type="math/tex; mode=display">
\begin{align}
&\text{IP(4)}\\
&\max 24x_1+2x_2+20x_3+4x_4\\
&\text{约束条件} ~~~8x_1+x_2+5x_3+4x_4\leq 9\\
&x_1=0,x_2=0\\
&x_i\in\{0,1\},3\leq i\leq 4\\
\end{align}</script><p>我们已经知道了它的最优解，那么$IP(4)$ 的所有子孙结点都不需要在进行计算，因为$IP(4)$的最优解一定是其子孙结点的一个上界。</p>
<p>我们需要把$IP(4)$中的整数约束去掉，问题就转化为如下的一个<strong>线性规划问题</strong>，这样的目的是，<strong>LP问题的最优解一定是IP问题的最优解的上界</strong>。</p>
<p>记作$LP(4)$:</p>
<script type="math/tex; mode=display">
\begin{align}
&\text{LP(4)}\\
&\max 24x_1+2x_2+20x_3+4x_4\\
&\text{约束条件} ~~~8x_1+x_2+5x_3+4x_4\leq 9\\
&x_1=0,x_2=0\\
&0\leq x\leq1,3\leq i\leq 4\\
\end{align}</script><p>我们很容易发现对于线性规划问题 $LP(4)$ ，很容易发现它的最优解是 $x_1=0,x_2=0,x_3=1,x_4=1,z=24$ .</p>
<p>关于$IP(7)$ ，我们将其转化为线性规划问题：</p>
<script type="math/tex; mode=display">
\begin{align}
&\text{LP(7)}\\
&\max 24x_1+2x_2+20x_3+4x_4\\
&\text{约束条件} ~~~8x_1+x_2+5x_3+4x_4\leq 9\\
&x_1=1,x_2=1\\
&0\leq x\leq1,3\leq i\leq 4\\
\end{align}</script><p>同样可以发现其最优解为：$x<em>1=1,x_2=1,x_3=0,x_4=0,z</em>{IP(7)}=26$ .</p>
<p>如果$IP(8)$的最优解不会超过$IP(7)$ ,那么包括节点$IP(8)$ 和它的自己孙节点也都不需要再进行计算了。</p>
<p><strong>重点：</strong></p>
<p>整数规划的松弛线性规划问题的解释整数规划问题解的上界。如果$IP(8)$ 对应的松弛线性规划问题$LP(8)$ 的解都不超过$IP(7)$,即：</p>
<script type="math/tex; mode=display">
Z_{IP}(8)\leq Z_{LP}(8)\leq Z_{IP}(7)</script><p>因此，通过整数规划问题的松弛找到了响应节点整数最优解的上界</p>
<h3 id="分支定界算法"><a href="#分支定界算法" class="headerlink" title="分支定界算法"></a>分支定界算法</h3><p>现在我们来对枚举树进行剪枝规则</p>
<ol>
<li><strong>已经找到了某个节点的最优解</strong>，该节点的所有子孙结点都不需要再解。因此其所有的子孙结点都可以从枚举树中删除</li>
<li>如果已知枚举树中某个节点的最优解，而当前节点的松弛线性规划问题的最优解都比已知的最优解要小，那么当前结点对应的整数规划问题不可能成为最优解，当前节点及其子孙结点都不用再解、因此当前节点及其子孙结点都可以直接从枚举树中删除</li>
<li>如果当前结点对应的松弛线性规划问题没有可行解，那么当前节点及其子孙结点都不可能存在可行解。因此可以直接从枚举树中删除。</li>
</ol>
<p>我们可以用一下伪代码概括</p>
<p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/6.png"></p>
<p>算法中的 active结点，意味着这些节点对应的整数规划问题可能是该整数规划的最优解。只要枚举树中还有active结点，分支定界算法就要继续执行，直到没有为止</p>
<p>算法记录当前位置所发现的最优解，记为$Z_I$ ，初始值为$-\infty$ 。算法基于线性规划问题$LP(j)$的最优解$x(j)$来判断：</p>
<ol>
<li>第一种情形：线性规划问题$LP(j)$无解，则枚举树中的节点$IP(j)$及其子孙结点会被剪枝</li>
<li>第二种情形：如果$Z_{LP}(j)\leq Z_I$ ，则枚举树中的节点$IP(j)$及其子孙结点会被剪枝</li>
<li><p>第三种情形：如果$Z<em>{LP}(j)&gt;Z_I$ ，且$x(j)$为整数解，即$x(j)$也是$IP(j)$ 的可行解，算法找到一个比当前最优解还要更优的一个可行整数解$x(j)$, 因此当前最优解$Z_I$ 更新为$Z</em>{LP}(j)=Z_{IP}(j)$，并将枚举树中的节点$IP(j)$ 及其子节点全部剪枝</p>
</li>
<li><p>第四种情形：如果$Z_{LP}(j)&gt;Z_I$，但是$x(j)$为<strong>非整数解</strong>，即 $x(j)$ 不是$IP(j)$ 的可行解，算法无法判断节点$IP(j)$的子孙结点中是否存在更优的解，因此将节点$IP(j)$的孩子标记为active结点</p>
</li>
</ol>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>我们还是用刚才的整数规划例子：</p>
<script type="math/tex; mode=display">
\max 24x_1+2x_2+20x_3+4x_4\\
\text{约束条件} ~~~8x_1+x_2+5x_3+4x_4\leq 9\\
x_i\in\{0,1\},1\leq i\leq 4</script><h4 id="迭代1"><a href="#迭代1" class="headerlink" title="迭代1"></a>迭代1</h4><p>初始状态$IP(1)$的松弛线性规划$LP(1)$作为枚举树根节点，标记为active，当前最优解$Z_I=-\infty$ </p>
<p>通过解决线性规划问题$LP(1)$，得到$LP(1)$的最优解为：</p>
<script type="math/tex; mode=display">
x_1=\frac{1}{2},x_2=0,x_3=1,x_4=0,z_{LP}(1)=32</script><p>（关于如何解决线性规划问题，可以通过python的pulp包来求解）</p>
<p>因为$Z_{LP}(1)&gt;Z_I$ ，且$x(1)$为非整数解，即$x(1)$不是$IP(1)$的可行解，属于第4种情形，那么将$IP(1)$标记为inactive，并将$IP(1)$的两个孩子结点$IP(2)$和$IP(3)$ 标记为active结点</p>
<h4 id="迭代2"><a href="#迭代2" class="headerlink" title="迭代2"></a>迭代2</h4><p>迭代2选择了结点$IP(2)$，如图所示</p>
<p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/7.png"></p>
<p>这里枚举树中的结点$IP(2)$ 的松弛线性规划问题为$LP(2)$。通过解决线性规划问题$LP(2)$可以得到最优解：</p>
<script type="math/tex; mode=display">
\begin{align}
LP(2):
&\max 24x_1+2x_2+20x_3+4x_4\\~\\
\text{s.t.}
&8x_1+x_2+5x_3+4x_4\leq 9\\
&x_1=0\\
&0\leq x_i\leq 1,2\leq i\leq 4\\
&\text{解得:}~x_1=0,x_2=1,x_3=1,x_4=\frac{3}{4},Z_{LP}(2)=25
\end{align}</script><p>由于$Z_{LP(2)}&gt;Z_I$ ，且$x(2)$ 为非整数解，即$x(2)$ 不是$IP(2)$ 的可行解，属于第4种情形。</p>
<p>分支定界算法将$IP(2)$标记为inactive，并将$IP(2)$ 的两个孩子节点$IP(4)$和$IP(5)$ 标记为active结点 </p>
<h4 id="迭代3"><a href="#迭代3" class="headerlink" title="迭代3"></a>迭代3</h4><p>第三次迭代选择$IP(3)$，如图所示：</p>
<p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/8.png"></p>
<p>这里枚举树中的结点$IP(3)$ 的松弛线性规划问题为$LP(3)$。通过解决线性规划问题$LP(3)$可以得到最优解：</p>
<script type="math/tex; mode=display">
\begin{align}
LP(3):
&\max 24x_1+2x_2+20x_3+4x_4\\~\\
\text{s.t.} &8x_1+x_2+5x_3+4x_4\leq 9\\
&x_1=1\\
&0\leq x_i\leq 1,2\leq i\leq 4\\
&\text{解得:}~~~x_1=1,x_2=0,x_3=\frac{1}{4},x_4=0,Z_{LP}(3)=28
\end{align}</script><p>由于$Z_{LP(3)}&gt;Z_I$ ，且$x(3)$ 为非整数解，即$x(3)$ 不是$IP(3)$ 的可行解，属于第4种情形。</p>
<p>分支定界算法将$IP(3)$标记为inactive，并将$IP(3)$ 的两个孩子节点$IP(6)$和$IP(7)$ 标记为active结点 </p>
<h4 id="迭代4"><a href="#迭代4" class="headerlink" title="迭代4"></a>迭代4</h4><p>第四次选择了$IP(4)$,如下图：</p>
<p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/9.png"></p>
<p>这里枚举树中的结点$IP(4)$ 的松弛线性规划问题为$LP(4)$。通过解决线性规划问题$LP(4)$可以得到最优解：</p>
<script type="math/tex; mode=display">
\begin{align}
LP(4):
&\max 24 x_1+2x_2+20x_3+4x_4\\~\\
\text{s.t.} &8x_1+x_2+5x_3+4x_4\leq 9\\
&x_1=0,x_2=0\\
&0\leq x_i\leq 1,3\leq i\leq 4\\
&\text{解得:}~~~x_1=0,x_2=0,x_3=1,x_4=1,Z_{LP}(4)= 24
\end{align}</script><p>由于$Z_{LP(4)}&gt;Z_I$ ，且$x(4)$ 是整数解，即$x(4)$  是$IP(4)$ 的可行解，属于第3种情形。</p>
<p> 因此，分支定界算法将当前的最优解更新为：$Z<em>I=Z</em>{LP(4)}=Z_{IP(4)}$，并进一步将$IP(4)$所有的孩子结点剪枝</p>
<h4 id="迭代5"><a href="#迭代5" class="headerlink" title="迭代5"></a>迭代5</h4><p>第5次迭代中，选择active结点$IP(5)$,如下图：</p>
<p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/10.png"></p>
<p>这里枚举树中的结点$IP(5)$ 的松弛线性规划问题为$LP(5)$。通过解决线性规划问题$LP(5)$可以得到最优解：</p>
<script type="math/tex; mode=display">
\begin{align}
&LP(5):
\max ~24 x_1+2x_2+20x_3+4x_4\\~\\
\text{s.t.} &8x_1+x_2+5x_3+4x_4\leq 9\\
&x_1=0,x_2=1\\
&0\leq x_i\leq 1,3\leq i\leq 4\\
&\text{解得:}~~~x_1=0,x_2=1,x_1=1,x_4=\frac{3}{4},Z_{LP}(5)= 25
\end{align}</script><p>由于$Z_{LP(5)}&gt;Z_I$ ，但$x(5)$ 为非整数解，即$x(5)$ 不是$IP(5)$ 的可行解，属于第4种情形。</p>
<p>分支定界算法将$IP(5)$标记为inactive，并将$IP(5)$ 的两个孩子节点$IP(8)$和$IP(9)$ 标记为active结点 </p>
<h4 id="迭代6"><a href="#迭代6" class="headerlink" title="迭代6"></a>迭代6</h4><p>选择active节点 $IP(6)$ ,如下图：</p>
<p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/12.png"></p>
<p>这里枚举树中的结点$IP(6)$ 的松弛线性规划问题为$LP(6)$。通过解决线性规划问题$LP(6)$可以得到最优解：</p>
<script type="math/tex; mode=display">
\begin{align}
LP(6):
&\max ~24 x_1+2x_2+20x_3+4x_4\\~\\
\text{s.t.} &8x_1+x_2+5x_3+4x_4\leq 9\\
&x_1=1,x_2=0\\
&0\leq x_i\leq 1,3\leq i\leq 4\\
&\text{解得:}~~~x_1=0,x_2=1,x_1=1,x_4=\frac{3}{4},Z_{LP}(6)= 25
\end{align}</script><p>由于$Z_{LP(6)}&gt;Z_I$ ，但$x(6)$ 为非整数解，即$x(6)$ 不是$IP(6)$ 的可行解，属于第4种情形。</p>
<p>分支定界算法将$IP(6)$标记为inactive，并将$IP(6)$ 的两个孩子节点$IP(10)$和$IP(11)$ 标记为active结点 </p>
<h4 id="迭代7"><a href="#迭代7" class="headerlink" title="迭代7"></a>迭代7</h4><p>选择active节点 $IP(7)$ ,如下图：</p>
<p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/13.png"></p>
<p>这里枚举树中的结点$IP(7)$ 的松弛线性规划问题为$LP(7)$。通过解决线性规划问题$LP(7)$可以得到最优解：</p>
<script type="math/tex; mode=display">
\begin{align}
LP(7):
&\max ~24 x_1+2x_2+20x_3+4x_4\\~\\
\text{s.t.} &8x_1+x_2+5x_3+4x_4\leq 9\\
&x_1=1,x_2=1\\
&0\leq x_i\leq 1,3\leq i\leq 4\\
&\text{解得:}~~~x_1=1,x_2=1,x_1=0,x_4=0,Z_{LP}(7)= 26
\end{align}</script><p>此时发现$Z<em>{LP}(7)&gt;Z_I$ 且$x(7)$为整数解，因此$x(7)$是$IP(7)$的可行解，属于第3种情形。因此，分支定界算法将当前的最优解更新为：$Z_I=Z</em>{LP}(7)=Z_{IP}(7)$,并进一步将$IP(7)$所有的孩子结点剪枝</p>
<h4 id="迭代8"><a href="#迭代8" class="headerlink" title="迭代8"></a>迭代8</h4><p>选择active节点 $IP(8)$ ,如下图：</p>
<p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/14.png"></p>
<p>这里枚举树中的结点$IP(8)$ 的松弛线性规划问题为$LP(8)$。通过解决线性规划问题$LP(8)$可以得到最优解：</p>
<script type="math/tex; mode=display">
\begin{align}
LP(8):
&\max ~24 x_1+2x_2+20x_3+4x_4\\~\\
\text{s.t.} &8x_1+x_2+5x_3+4x_4\leq 9\\
&x_1=0,x_2=1,x_3=0\\
&0\leq x_4\leq 1\\
&\text{解得:}~~~x_1=0,x_2=1,x_1=0,x_4=1,Z_{LP}(8)= 6
\end{align}</script><p>此时发现$Z_{LP}(8)&lt;Z_I$ ,属于第2种情形，分支定界算法将$IP(8)$标记为Inactive，并将IP(8)的两个孩子结点全部剪枝</p>
<h4 id="迭代9"><a href="#迭代9" class="headerlink" title="迭代9"></a>迭代9</h4><p>选择active节点 $IP(9)$ ,如下图：</p>
<p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/15.png"></p>
<p>这里枚举树中的结点$IP(9)$ 的松弛线性规划问题为$LP(9)$。通过解决线性规划问题$LP(9)$可以得到最优解：</p>
<script type="math/tex; mode=display">
\begin{align}
LP(9):
&\max ~24 x_1+2x_2+20x_3+4x_4\\~\\
\text{s.t.} &8x_1+x_2+5x_3+4x_4\leq 9\\
&x_1=0,x_2=1,x_3=1\\
&0\leq x_4\leq 1\\
&\text{解得:}~~~x_1=0,x_2=1,x_1=1,x_4=\frac{3}{4},Z_{LP}(9)= 25
\end{align}</script><p>由于$Z_{LP(9)}&lt;Z_I$ ， 属于第2种情形，分支定界算法将$IP(9)$标记为Inactive，并将$IP(9)$的两个孩子结点全部剪枝</p>
<h4 id="迭代10"><a href="#迭代10" class="headerlink" title="迭代10"></a>迭代10</h4><p>选择active节点 $IP(9)$ ,如下图：</p>
<p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/16.png"></p>
<p>这里枚举树中的结点$IP(10)$ 的松弛线性规划问题为$LP(10)$。通过解决线性规划问题$LP(10)$可以得到最优解：</p>
<script type="math/tex; mode=display">
\begin{align}
LP(10):
&\max ~24 x_1+2x_2+20x_3+4x_4\\~\\
\text{s.t.} &8x_1+x_2+5x_3+4x_4\leq 9\\
&x_1=0,x_2=1,x_3=1\\
&0\leq x_4\leq 1\\
&\text{解得:}~~~x_1=1,x_2=0,x_1=0,x_4=\frac{1}{4},Z_{LP}(10)= 25
\end{align}</script><p>由于$Z_{LP(9)}&lt;Z_I$ ， 属于第2种情形，分支定界算法将$IP(10)$标记为Inactive，并将$IP(10)$的两个孩子结点全部剪枝</p>
<h4 id="迭代11"><a href="#迭代11" class="headerlink" title="迭代11"></a>迭代11</h4><p>选择active节点 $IP(11)$ ,如下图：</p>
<p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/17.png"></p>
<p>这里枚举树中的结点$IP(11)$ 的松弛线性规划问题为$LP(11)$。通过解决线性规划问题$LP(11)$可以得到最优解：</p>
<script type="math/tex; mode=display">
\begin{align}
LP(11):
&\max ~24 x_1+2x_2+20x_3+4x_4\\~\\
\text{s.t.} &8x_1+x_2+5x_3+4x_4\leq 9\\
&x_1=1,x_2=0,x_3=1\\
&0\leq x_4\leq 1\\
&\text{无解}
\end{align}</script><p>因此，最终得到的结果是 $Z = 26$</p>
<h2 id="割平面法"><a href="#割平面法" class="headerlink" title="割平面法"></a>割平面法</h2><p>找到合适的约束可以大大减低整数规划问题的求解过程，为了找到合适的约束条件，这里先定义有效不等式的概念。</p>
<h3 id="有效不等式"><a href="#有效不等式" class="headerlink" title="有效不等式"></a>有效不等式</h3><p>给定一个整数规划问题，一个约束条件可以减小松弛线性规划问题的可行域，但却不减少任何整数的可行解，则称其为有效不等式，有事又被称为<strong>割平面</strong>或者<strong>割</strong></p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>将下列条件改成整数规划的约束，<strong>保证两个不等式中至少有一个成立</strong></p>
<script type="math/tex; mode=display">
x_1+x_2+x_3+x_4 \leq 4&&(1)\\
3x_1-x_2-x_3+x_4\leq 3&&(2)</script><p>其中 $x_j\geq 0,j=1,\cdots,4$, 并且每一个变量都是整数。</p>
<p>解：</p>
<p>我们可以把这个问题变成0-1整数规划问题，令：</p>
<script type="math/tex; mode=display">
w = \begin{cases}
1&x_1+x_2+x_3+x_4 \leq 4\\~\\
0&-3x_1+x_2+x_3-x_4\geq -3
\end{cases}</script><p>令 $M&gt;0$</p>
<p>则有：</p>
<script type="math/tex; mode=display">
\begin{cases}
x_1+x_2+x_3+x_4 \leq 4+M(1-w)\\~\\
-3x_1+x_2+x_3-x_4\geq -3-Mw
\end{cases}</script><p>其中 $w={0,1}$</p>
<p>这样， 不管 $w$ 的取值如何，$(1),(2)$ 至少有一个成立</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/11/15/%E6%95%B0%E6%8D%AE%E6%AD%A3%E7%A1%AE%E6%80%A7%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/11/15/%E6%95%B0%E6%8D%AE%E6%AD%A3%E7%A1%AE%E6%80%A7%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/" itemprop="url">数据正确性与事务处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-11-15T15:00:34+08:00">
                2021-11-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-06-23T20:07:20+08:00">
                2022-06-23
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据正确性与事务处理"><a href="#数据正确性与事务处理" class="headerlink" title="数据正确性与事务处理"></a>数据正确性与事务处理</h1><p>数据库除了提供数据的存储和查询功能，还提供<strong>事务处理</strong>功能。本章节就要来谈谈事务处理的相关细节。</p>
<h3 id="OLTP和OLAP"><a href="#OLTP和OLAP" class="headerlink" title="OLTP和OLAP"></a>OLTP和OLAP</h3><p>首先我们要了解应用的两种模式：OLTP和OLAP</p>
<p>OLTP 即事务处理，OLAP即分析处理，两者在数据库里存储的数据以及对数据库的操作都有不同。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>OLTP(事务型应用)</th>
<th>OLAP(分析型应用)</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据</td>
<td>状态型</td>
<td>历时型</td>
</tr>
<tr>
<td>例子</td>
<td>账户余额、购物车、课程表等</td>
<td>购物历史、记录等</td>
</tr>
<tr>
<td>对数据库的要求</td>
<td>稳定性、正确性</td>
<td>注重处理能力</td>
</tr>
<tr>
<td>对数据库的主要操作</td>
<td>更新</td>
<td>复杂SQL查询</td>
</tr>
</tbody>
</table>
</div>
<p>因此，对于事务型应用，我们要求数据库能保证<strong>数据正确性</strong>的同时提供<strong>事务处理</strong>功能。 </p>
<h3 id="数据的正确性问题"><a href="#数据的正确性问题" class="headerlink" title="数据的正确性问题"></a>数据的正确性问题</h3><p>导致数据出现错误的的原因主要有两个</p>
<p>一个是在数据并发的时候若不使用锁的时候，会发生LOST UPDATES，导致数据丢失</p>
<p>另一个是在处理事务的时候数据库突然发生故障导致数据丢失</p>
<p>我们举一个很简单的例子：</p>
<p><img src="/2021/11/15/%E6%95%B0%E6%8D%AE%E6%AD%A3%E7%A1%AE%E6%80%A7%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/1.jpeg" style="zoom:50%;"></p>
<p>在数据库中，A所在的一列是索引，因此当我们修改的A的值的时候需要修改表和索引两个地方，使其保持一致。假设甲和乙几乎同时提交修改请求，如果没有锁的存在，可能表中收到的指令是：先把A修改成2再把A修改成3；而索引收到的指令是：先把A修改成3再把A修改成2. 这样的后果就是索引和表中的值都无法保持一致</p>
<p>此外，数据库系统还可能在已经修改了表但还没有修改索引的时候突然奔溃，这也会使两个值不一样。</p>
<p>为了规避这些风险，我们需要一种机制去保证数据的正确性 </p>
<h3 id="数据库操作的原子性"><a href="#数据库操作的原子性" class="headerlink" title="数据库操作的原子性"></a>数据库操作的原子性</h3><p>理论上，只要我们对数据库的操作满足原子性，我们就能保证数据的正确性。那么什么是原子性？</p>
<p>我们可以把原子性理解为：不管多少事务是有重合的，我们要把他们实现成好像一瞬间完成的一样(具体实现方法之后再讲)，投影在一个数轴上，这样在数轴上这些点是不会重合的，每一个操作都有先后顺序，不会互相干扰</p>
<p><img src="/2021/11/15/%E6%95%B0%E6%8D%AE%E6%AD%A3%E7%A1%AE%E6%80%A7%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/2.jpeg" style="zoom:50%;"></p>
<p>那么，怎么样实现原子性呢？ 我们提出日志机制</p>
<h4 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h4><p><img src="/2021/11/15/%E6%95%B0%E6%8D%AE%E6%AD%A3%E7%A1%AE%E6%80%A7%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/3.jpeg" style="zoom:50%;"></p>
<p>现在有一个O1操作如上图所示，一共要执行6个步骤。为了保证数据的准确性，我们在硬盘上另外开了一片区域来记录日志</p>
<ul>
<li>在O1操作开始前，会记录日志<code>log(O1,start)</code> 代表O1操作已经开始</li>
<li>当我们发现要对硬盘上的数据进行修改的时候，也就是在第二步和第三步之间。则会记录A原始的值，即 <code>log(O1,A,3)</code> </li>
<li>同理在第五和第六步之间记录 <code>log(O1,B,3)</code></li>
<li>最后在O1操作全部完成之后，记录<code>log(O1,end)</code> 代表整个操作结束</li>
</ul>
<p>这样的当运行到第三句话，发生了故障导致机器重启。那么当数据库系统再次启动的时候会执行恢复程序，即扫描一遍日志，查看是否有异常。当扫描到O1操作的日志的时候，发现<code>log(O1,start)</code>却没有结束日志。因此判定O1操作没有执行完成，执行回滚操作。由于我们记录了A的原始数据，因此回滚起来也非常方便。</p>
<h4 id="redo日志"><a href="#redo日志" class="headerlink" title="redo日志"></a>redo日志</h4><p>上面的这种记录日志的方式叫做undo日志,其主要的功能就是在操作到一半的情况下能够回滚回去。</p>
<p>还有一种记录日志的方式叫做redo日志。其原理如下图所示</p>
<p><img src="/2021/11/15/%E6%95%B0%E6%8D%AE%E6%AD%A3%E7%A1%AE%E6%80%A7%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/4.jpeg" style="zoom:50%;"></p>
<p>运用这种形式操作的步骤也是不同的，是先把数据取出来再修改好，然后一并写回。不是像undo一样改一个写回一个。那么如果在3和4之间发生中断，此时还没有写回到数据表当中，在日志里只记录了两行，那么此时系统不需要做任何事情。数据表中A和B仍然为3</p>
<p>那么如果在5和6之间发生中断，这时候A的值已经被改成5，B的值仍然为3，而此时在日志里，<code>log(O1,A,5)</code>和<code>log(O1,B,5)</code>已经被记录下来，<code>log(O1,end)</code>也记录了下来。系统会判断操作已经结束，然后去检查数据表中的数据是否与日志匹配，结果发现B仍然是3，因此判定出现了异常现象，此时只要把数据表中的B修改成日志当中记录的5即可</p>
<p>所以undo是把数据表恢复成操作开始前的状态(回滚)，redo是把数据表恢复成操作结束后的状态</p>
<p>那么undo和redo有什么优缺点呢？</p>
<p>redo：</p>
<ul>
<li>优点： 效率比较高，性能比较好，对数据的修改可以推迟到所有操作结束之后，记录日志和回写硬盘分开进行</li>
<li>缺点：对内存消耗比较高，当内存满了以后再添加会导致数据丢失。</li>
</ul>
<p>undo:</p>
<ul>
<li>优点：对内存的消耗比较小，没修改一个值内存就会直接释放</li>
<li>缺点：需要同步记录日志和修改数据的值，导致记录日志和回写硬盘交错进行，是随机访问硬盘的情况，性能较差。</li>
</ul>
<p>在数据库中，我们会把这两种日志结合在一起，称为 undo/redo 日志。这种日志不但包含了每个元素修改之前的值，还包含了元素修改之后的值。这样就可以规避undo/redo日志各自的缺点。如下：</p>
<p><img src="/2021/11/15/%E6%95%B0%E6%8D%AE%E6%AD%A3%E7%A1%AE%E6%80%A7%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/5.jpeg" style="zoom:50%;"></p>
<p>一旦发生故障，就有两种选择，如果发现日志已经完整了，我们可执行redo操作；如果日志并不完整，可以执行undo操作。</p>
<p>运用undo/redo日志，我们看到每个操作都可以看做是时间轴上的某一个点，即使发生故障，故障也可以看做是时间轴上的一个点，只不过之后会做undo/redo罢了，也就是我们利用日志可以保证在发生系统故障的时候数据操作的原子性</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><img src="/2021/11/15/%E6%95%B0%E6%8D%AE%E6%AD%A3%E7%A1%AE%E6%80%A7%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/10.png" style="zoom:50%;"></p>
<p>这个是Undo日志，O2已经完成了但是O1还没有完成，因此undo会把A回滚成原来的样子，即3</p>
<p><img src="/2021/11/15/%E6%95%B0%E6%8D%AE%E6%AD%A3%E7%A1%AE%E6%80%A7%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/11.png" style="zoom:50%;"></p>
<p>对于B，在Undo日志下，我们要 先记录元素原本的值，然后再讲修改后的值写回硬盘</p>
<p><img src="/2021/11/15/%E6%95%B0%E6%8D%AE%E6%AD%A3%E7%A1%AE%E6%80%A7%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/12.png" style="zoom:50%;"></p>
<p>谁最后结束，磁盘上的值就是谁操作的值。</p>
<p>对于D， 操作o1 是最后结束的，因此最后应该<code>write(A=5)</code>而不是<code>write(A=6)</code></p>
<p><img src="/2021/11/15/%E6%95%B0%E6%8D%AE%E6%AD%A3%E7%A1%AE%E6%80%A7%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/13.png" style="zoom:50%;"></p>
<p>对于C，由于undo的存在，在执行到一般的时候，可能会发生回滚导致已经结束的CRUD操作撤销。不一定会顺利完成</p>
<p><img src="/2021/11/15/%E6%95%B0%E6%8D%AE%E6%AD%A3%E7%A1%AE%E6%80%A7%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/14.png" style="zoom:50%;"></p>
<h3 id="并发控制机制"><a href="#并发控制机制" class="headerlink" title="并发控制机制"></a>并发控制机制</h3><p>然而，我们还没有解决如何在并发时保持数据的原子性。因此当两个线程同时处理两个操作的时候，可能会出现数据错误的情况，如下：</p>
<p><img src="/2021/11/15/%E6%95%B0%E6%8D%AE%E6%AD%A3%E7%A1%AE%E6%80%A7%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/6.jpeg" style="zoom:50%;"></p>
<p>假设CPU一开始收到O2的前半部分，修改了A的值为5，这时候发生了中断，转而去执行操作O2的所有指令，这时A变成了10，B变成了6；执行完O2后回过来执行O1，最终B为8</p>
<p>我们发现本应该是相同的A和B，但是当线程之间发生调度的时候，会出现AB不相等的情况。为了解决这个问题，可以使用<strong>锁</strong>或者<strong>时间戳</strong>机制</p>
<p><img src="/2021/11/15/%E6%95%B0%E6%8D%AE%E6%AD%A3%E7%A1%AE%E6%80%A7%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/7.jpeg" style="zoom:50%;"></p>
<p>如上图，在操作1读取A之前，就要给A上锁，这样即使发生了线程调度，在运行了三句指令后去执行操作O2，CPU会发现A上的锁还没有解开，因此无法读取A的值。</p>
<p>这样一来，只有当操作O1完全结束，将锁完全释放之后，才能继续执行操作O2</p>
<p>上面所讲的日志和锁保证了数据库内单步操作的原子性，但是在事务型应用中，事务是由一系列的访问构成的，我们要保证整个事务的正确性，因此需要数据库提供事务处理接口。接下来我们我们就来学习这方面的知识。</p>
<h3 id="应用层面的数据正确性"><a href="#应用层面的数据正确性" class="headerlink" title="应用层面的数据正确性"></a>应用层面的数据正确性</h3><p>我们首先用一个例子来说明为什么应用中的事务逻辑会出现正确性问题：</p>
<p><img src="/2021/11/15/%E6%95%B0%E6%8D%AE%E6%AD%A3%E7%A1%AE%E6%80%A7%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/8.jpeg" style="zoom:50%;"></p>
<p>那么当我们要修改账户的名称为Bob的时候，编写的程序应该如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Update —&gt; User.ID &#x3D; &#39;3679&#39;</span><br><span class="line">Set name &#x3D; &#39;Bob&#39;;</span><br><span class="line">For(Doc.AuthorID &#x3D;&#39;3679&#39;)&#123;</span><br><span class="line">	set Doc.AuthorName &#x3D; &#39;Bob&#39;,&#125;</span><br><span class="line">END for</span><br></pre></td></tr></table></figure>
<p>这时候，如果在第二行和第三行之间计算机发生了故障，软件重启后，就发现仅仅修改了User文档中的名字，而没有吧博客文章文档里面的每个名字都进行修改。这就出现异常了，但是这和数据库本身并没有问题，因此我们要提出新的机制来解决应用层面的数据正确性问题。</p>
<h4 id="用标志位防止数据异常"><a href="#用标志位防止数据异常" class="headerlink" title="用标志位防止数据异常"></a>用标志位防止数据异常</h4><p>和记录日志类似，我们也有一种机制，能让程序记起来自己在哪里中断，已经执行了什么，还未执行什么。</p>
<p>因此我们可以在User文档中新增一个标志位namesync,当user名字被修改的时候，会将其设为ToDo，用于告诉系统还有工作没做完。当所有博客文章的作者名称都修改完之后，才会更新标志位为 Done，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Update —&gt; User.ID &#x3D; &#39;3679&#39;</span><br><span class="line">Set name &#x3D; &#39;Bob&#39;;</span><br><span class="line">Set namesync &#x3D; &#39;ToDo&#39;	&#x2F;&#x2F;设置标志位为To DO</span><br><span class="line">For(Doc.AuthorID &#x3D;&#39;3679&#39;)&#123;</span><br><span class="line">	set Doc.AuthorName &#x3D; &#39;Bob&#39;,&#125;</span><br><span class="line">END for</span><br><span class="line">Update -&gt;User.ID &#x3D; &#39;3679&#39; Set namesync &#x3D;&#39;Done&#39; &#x2F;&#x2F;重新更新标志位为Done</span><br></pre></td></tr></table></figure>
<p>这样，当故障发生，系统重启之后，会去检查namesync的值，如果是todo，那么就会重新执行一遍改名操作。最后再将namesync置为Done即可</p>
<h4 id="用消息队列防止数据异常"><a href="#用消息队列防止数据异常" class="headerlink" title="用消息队列防止数据异常"></a>用消息队列防止数据异常</h4><p>之前我们是在一个现有文档里面添加一个标志位来保证正确性。现在我们可以新建一个任务文档来存放将要做的任务，我们称之为消息队列。示意图如下：</p>
<p><img src="/2021/11/15/%E6%95%B0%E6%8D%AE%E6%AD%A3%E7%A1%AE%E6%80%A7%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/9.jpeg" style="zoom:50%;"></p>
<p>当我们要做这个互相加好友的操作的时候，消息队列中新插入一个任务，把status置为 Todo，意为还未完成。然后，当双方都完成更新操作，才将status置为Done </p>
<p>注意了，若要用消息队列来保证应用的数据正确性，首先要满足一个前提——操作的幂等性，也就是不管操作几次，最终的结果是一样的。</p>
<p>比如，向集合里插入一个元素、从集合里删除一个元素、对一个元素进行赋值，都属于幂等操作。但是对一个数据进行自增，这就不幂等了因为每次操作和原来的值都不一样</p>
<h3 id="事务处理的概念"><a href="#事务处理的概念" class="headerlink" title="事务处理的概念"></a>事务处理的概念</h3><p>上面两种操作是在APP层面保证应用的数据正确性，但是这给程序员增加了不少负担。</p>
<p>此外，可能有多个程序员编写多个程序在访问同一张表。一个程序员可能能让自己的程序保持数据的正确性，但是他不能要求别的程序员也这样。因此程序会变得非常复杂。</p>
<p>因此，我们想能不能把这些工作交给数据库去做呢? 这就叫做事务处理。</p>
<p>什么是事务(Transaction)？我在mysql博客中已经介绍过了，事务就是一段可以实现特定功能的SQL代码，在执行失误的时候，所有的语句都必须成功执行，否则事务就会失败。</p>
<p>Transaction有几个特性：</p>
<p>第一个是原子性(Atomicity)，也就是不可分割的，一个事务不管其包含多少语句都是一个完整的整体。除非事务中所有的语句都成功执行，Transaction才算执行成功，否则所有修改都会回滚。</p>
<p>第二个特性是一致性(Consistency)，也就是说我们使用了Transaction之后，我们的数据库永远保持一致。 </p>
<p>第三个特性是隔离性(Isolation)。也就是说 Transaction之间是相互隔离的，特别是他们要修改同一个数据的时候。他们之间不受影响。如果多个Transaction要修改同一个数据，这条记录就会被锁定，每次只能有一个Transaction有权修改。其他的Transaction需要等待这个Transaction执行完毕</p>
<p>最后一个是持久性(Durability), 意思是一但一个Transaction被提交，它的修改就是永久性的，无法撤销，其他任何崩溃的情况（停电、宕机),也不会影响数据的修改</p>
<p>我们称这四个属性为 ACID</p>
<p>使用了事务，就好像每个事务都只是数轴上的一个点，不会互相干扰。 </p>
<h3 id="合理使用事务"><a href="#合理使用事务" class="headerlink" title="合理使用事务"></a>合理使用事务</h3><p>现在我们举几个例子来说明事务的功能</p>
<p>首先是订电影票的流程:</p>
<ul>
<li>获取空闲座位</li>
<li>展示座位</li>
<li>用户选择座位</li>
<li>用户提交订票请求</li>
<li>将座位分配给用户</li>
</ul>
<p>一种朴素的思想是将这五步都包含在一个Transaction里面，虽然能保证事务的完整性，但是这就使得该订票平台每次只能有一个人订票。因为数据库在一开始就会把所有的位置上锁，当整个订票过程结束后才解锁。这样就无法满足高并发的情况</p>
<p>因此更好的方法是在第四步和第五步之间 Beigin Transaction。但当电影特别火的时候，还是有可能同时多个人抢一个座位的情况。因此我们不能简单的将座位直接分配给客户，而是在分配前做一个判断</p>
<blockquote>
<ul>
<li>获取空闲座位</li>
<li>展示座位</li>
<li>用户选择座位</li>
<li>用户提交订票请求</li>
</ul>
<p>Begin Transaction</p>
<ul>
<li>座位是否空闲<ul>
<li>IF空闲，分配给用户</li>
<li>ELSE不空闲，数据库abort，前端return SORRY</li>
</ul>
</li>
</ul>
<p>End Transaction¢</p>
</blockquote>
<p>因此，我们引出了一个创建事务的原则：事务应该是短小的。否则会导致整个程序的性能下降</p>
<hr>
<p>现在我们用另外一个例子：</p>
<p>购买商品的过程：</p>
<ul>
<li>IF 账户余额 &lt;= 商品价格，Then 取消</li>
<li>调用商品运输服务</li>
<li>账户余额  -= 商品价格 </li>
</ul>
<p>我们当然可以把这三步都放在一个Transaction里面，但是我们会发现，好像第二步和第一步、第三步的关系没有那么紧密，他并没有处理的用户账户相关的问题。因此更好的解决办法如下：</p>
<blockquote>
<p>Begin Transaction</p>
<ul>
<li>IF 账户余额 &lt;= 商品价格，Then 取消</li>
<li>账户余额  -= 商品价格 </li>
</ul>
<p>End Transaction</p>
<ul>
<li>调用商品运输服务</li>
</ul>
</blockquote>
<p>我们要根据不同的情境来设计不同的事务</p>
<h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p><img src="/2021/11/15/%E6%95%B0%E6%8D%AE%E6%AD%A3%E7%A1%AE%E6%80%A7%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/15.png" style="zoom:50%;"></p>
<p>我们要注意一句话：在拿到所有锁之前，不能释放任何一个锁。比如下面这个例子</p>
<p><img src="/2021/11/15/%E6%95%B0%E6%8D%AE%E6%AD%A3%E7%A1%AE%E6%80%A7%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/18.jpeg" style="zoom:50%;"></p>
<p>当O1运行到 <code>x-&gt;A</code>后，如果释放了锁，这时候如果发生了线程调度，调到O2，马上锁住并全部运行完成。这就会造成数据不同步。因此即使手上有1000把锁，如果事务中还有锁没拿到，那么就一把锁也无法释放。</p>
<p>因此，这也告诉我们事务要设计的短一些。</p>
<p><img src="/2021/11/15/%E6%95%B0%E6%8D%AE%E6%AD%A3%E7%A1%AE%E6%80%A7%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/16.png" style="zoom:50%;"></p>
<p>对于A，在读取A元素之前必须先给A上锁，因此错误</p>
<p>对于C，同理</p>
<p>对于D，我们要记住：先Start再锁，先End再释放。因为如果先锁再记录日志，这种逻辑很怪，因为在锁的时候我并不知道我的目标元素是什么</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2021/11/15/%E6%95%B0%E6%8D%AE%E6%AD%A3%E7%A1%AE%E6%80%A7%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/1.png"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/11/14/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/11/14/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/" itemprop="url">关系数据库设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-11-14T13:26:42+08:00">
                2021-11-14
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-11-23T14:19:34+08:00">
                2022-11-23
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="关系数据库设计"><a href="#关系数据库设计" class="headerlink" title="关系数据库设计"></a>关系数据库设计</h1><h3 id="关系数据库设计-1"><a href="#关系数据库设计-1" class="headerlink" title="关系数据库设计"></a>关系数据库设计</h3><p>怎么做好数据库的设计？</p>
<ol>
<li>需求分析, 解决存什么</li>
<li>概念设计，用何种模式</li>
<li>数据库结构设计，解决怎么存</li>
</ol>
<h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><p>下图是一个博客系统的4个界面</p>
<p><img src="/2021/11/14/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/1.png" style="zoom:67%;"></p>
<p>这个界面的功能如上图所示：</p>
<ul>
<li><p>第一个登录界面，用户能看见自己的个人信息以及关注的人写的文章</p>
</li>
<li><p>第二个界面，是用户点击特定一篇文章后显示的文章具体信息</p>
</li>
<li>第三个界面是用户点击新建按钮之后显式的，用于新创建一个界面</li>
<li>第四个界面是其他博主的主页，我们可以看到他写了那些文章，它关注的人之类的信息。</li>
</ul>
<h4 id="概念设计"><a href="#概念设计" class="headerlink" title="概念设计"></a>概念设计</h4><p>现在我们解决了需求分析，现在我们来做概念设计</p>
<p>对于这个 博客系统，我们需要创建三个对象：用户、文章、评论，其关系如下：</p>
<p><img src="/2021/11/14/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/2.jpeg" style="zoom:67%;"></p>
<h4 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h4><p>我们要用关系来表示这三个对象，用表格来呈现，每一列代表对象的一个属性，如下图所示：</p>
<p><img src="/2021/11/14/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/3.jpeg" style="zoom:67%;"></p>
<p>首先，黑色部分代表的是用表来展示对象的基本属性的部分。比如对于用户，有名字、信息等；比如对文档，有标题和内容等</p>
<p>但是怎么用表格来表示对象与对象之间的关系呢？</p>
<p>首先，对于文章和作者、评论和作者这类多对1关系，可以直接在后面加上一列。比如说，对于Doc表格，我们可以在后面加上一列Author，来记录UID，这样就能记录这篇文章的作者了</p>
<p>对于评论，我们可以在表后添加两列，分别记录代表作者的UID和代表文章的DID。用来表示这条评论所在的文章及其作者</p>
<p>但是对于用户和用户之间的关注关系，因为是多对多的，我们发现没有办法通过添加一列的方式来呈现，因此我们可以另外新建一张表，里面有Followee和Follower两列，分别记录被关注者和关注者的UID即可。</p>
<p>这是我们比较朴素的设计思路，接下来我们介绍一种更系统的设计方法——ER图</p>
<h3 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h3><p>ER图的表现形式有点类似于前面面向对象的模型的概念设计。但是在表达对象与对象之间的关系有一些更细致的方式。</p>
<p>ER图中的E 代表 Entity(实体)，R代表Relationship(联系)，ER图也就是用来刻画实体与实体之间关系的示意图 </p>
<p>比如说员工参与项目这个模型我们可以画出其ER图</p>
<p><img src="/2021/11/14/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/4.jpeg" style="zoom:67%;"></p>
<h4 id="形状的意义"><a href="#形状的意义" class="headerlink" title="形状的意义"></a>形状的意义</h4><p>其中，方块代表实体；圆圈代表实体中的属性；而菱型则代表连接对象之间的关系。</p>
<p>我们从这张ER图中可以很清楚的看到：员工实体有<strong>工号、名字、技能</strong>这三个属性；项目有<strong>项目号、经费</strong>；此外，参与这个关系也有一个<strong>工时</strong>属性，代表每个人需要花多少时间在这个项目上。</p>
<h4 id="箭头的意义"><a href="#箭头的意义" class="headerlink" title="箭头的意义"></a>箭头的意义</h4><p>现在，我们要了解不同类型的属性</p>
<ul>
<li><strong>唯一属性</strong>，就是可以唯一识别一个实体的属性。比如员工里的工号，项目中的项目号。通常我们可以把唯一属性看做是这个实体中的ID。</li>
<li><strong>单值属性</strong>，名字和经费这类属性可以被称为单值属性，因为一个员工只能对应一个名字，一个项目只能对应一笔经费</li>
<li><strong>多值属性</strong>，员工的技能并不是单值属性，一个员工可以由多个技能。</li>
</ul>
<p>不同的属性反映在不同的箭头上，唯一属性用双向箭头表示，单值属性用单箭头表示，双值属性用两个同一朝向的箭头表示 </p>
<h4 id="菱形两变m和1的意义"><a href="#菱形两变m和1的意义" class="headerlink" title="菱形两变m和1的意义"></a>菱形两变m和1的意义</h4><p>在上面这个ER图中，我们看到员工和项目之间的参与关系是一个多对多的关系，一个员工可以参加多个项目，同样一个项目也需要多个员工共同完成.因此参与关系的两变是m和m</p>
<p>还有两种关系：一对多/多对一，一对一</p>
<p>比如员工和部门之间就是多对一的关系，一个员工只能属于一个部门，而部门可以有多个员工</p>
<p>比如经理和部门之间的就是一对一关系，一个员工只能管理一个部门</p>
<h4 id="不同关系的表现形式"><a href="#不同关系的表现形式" class="headerlink" title="不同关系的表现形式"></a>不同关系的表现形式</h4><p>上面我们所介绍的都是两个实体之间的二元联系，其实联系可以有更多种不同的方式，比如：</p>
<p><img src="/2021/11/14/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/6.jpeg" style="zoom:67%;"></p>
<p>比如说，同样是员工，上级对下级是一个一对多的关系。我们可以用左边这张图来表示</p>
<p>对于用户、运营商、手机这样一个三边关系，很难说是一对多还是一对一的关系，我们直接用语言描述即可：一个用户可以有多台手机，一个手机只能属于一位用户，而且一个手机只能对应一个运营商</p>
<h4 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h4><p>ER图还有其他更细枝末节的刻画，比如说商品和食品、电子产品之间其实是父类和子类的关系。</p>
<p>还有弱实体的概念，比如说一个房间的存在依附于一座楼房的存在，一座城市依附于一个国家的存在</p>
<h3 id="从ER图到关系模型设计"><a href="#从ER图到关系模型设计" class="headerlink" title="从ER图到关系模型设计"></a>从ER图到关系模型设计</h3><p>我们之前设计出来了ER图，现在我们要介绍一种固定的方式来将设计出来的ER图转换成一张或者几张关系表。我们还是以上面员工和项目的ER图为例</p>
<ul>
<li>首先要将实体类中的唯一属性和单值属性选出来创建一张表</li>
</ul>
<p><img src="/2021/11/14/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/7.jpeg" style="zoom:67%;"></p>
<ul>
<li>对于多值属性，要单独拿出来刻画，比如说对于技能，要新建一张skills表来存放。</li>
</ul>
<p><img src="/2021/11/14/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/8.jpeg" style="zoom:67%;"></p>
<ul>
<li><p>最后我们来处理联系，对于一对一或者一对多联系，我们可以将其归并到一个实体当中。但是对于多对多联系，我们需要新建一张表来存放这个联系</p>
<ul>
<li>我们假设员工和项目是一对一的联系,我们可以任意选择一个实体关系表，在后面加上一列。比如：</li>
</ul>
<p><img src="/2021/11/14/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/9.jpeg" style="zoom:67%;"></p>
<ul>
<li>我们假设员工和项目是多对一的联系，我们在多的那一个实体关系表后加一列，即可，这里还是选择加在员工表后</li>
</ul>
<p><img src="/2021/11/14/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/9.jpeg" style="zoom:67%;"></p>
<ul>
<li>事实上，员工和项目是多对多的联系，因此我们要新建第四张表，这张表有三列，前两列分别存放员工的ID和项目的ID，第三列存放工时</li>
</ul>
<p><img src="/2021/11/14/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/10.jpeg" style="zoom:67%;"></p>
</li>
</ul>
<h3 id="ER图在博客系统中的应用"><a href="#ER图在博客系统中的应用" class="headerlink" title="ER图在博客系统中的应用"></a>ER图在博客系统中的应用</h3><p><img src="/2021/11/14/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/11.jpeg" style="zoom:67%;"></p>
<p>我们这里忽略了每一个实体的内部属性，把目光聚焦到关系上. 首先在这个类似于三角形的关系中，一共有三个一对多关系，因此在Doc表后加一列，在Comment表后加一列。此外，我们还要处理”关注”这个关系，新建一张表即可。</p>
<p><img src="/2021/11/14/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/12.jpeg" style="zoom: 50%;"></p>
<p>我们看到，从ER图到关系表，是一个机械化的过程。只要按部就班来即可</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><img src="/2021/11/14/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/16.png"></p>
<p><img src="/2021/11/14/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/17.png"></p>
<p>一般联系要么可以附着在一张现有的表上(1 to1,1 to m) ，如果单提取出来新建一张表，说明这是m to m的关系，那么这一行是由关系两边的实体的ID共同确定的，即A</p>
<h3 id="关系数据库中的冗余"><a href="#关系数据库中的冗余" class="headerlink" title="关系数据库中的冗余"></a>关系数据库中的冗余</h3><p>我们在数据库中随处可见冗余，如下表所示：</p>
<p>这里第二行和第三行出现了两个May，然后Price，P_name 也出现了重复的情况</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>UID</th>
<th>U_name</th>
<th>PID</th>
<th>P_name</th>
<th>Price</th>
<th>Quant</th>
<th>Date</th>
</tr>
</thead>
<tbody>
<tr>
<td>U001</td>
<td>Jason</td>
<td>P003</td>
<td>Pencil</td>
<td>10</td>
<td>1</td>
<td>3/10/2020</td>
</tr>
<tr>
<td>U002</td>
<td>May</td>
<td>P002</td>
<td>Soap</td>
<td>5</td>
<td>2</td>
<td>4/10/2020</td>
</tr>
<tr>
<td>U003</td>
<td>May</td>
<td>P003</td>
<td>Pencil</td>
<td>10</td>
<td>2</td>
<td>8/10/2020</td>
</tr>
<tr>
<td>U004</td>
<td>Bob</td>
<td>P002</td>
<td>Soap</td>
<td>5</td>
<td>1</td>
<td>10/10/2020</td>
</tr>
</tbody>
</table>
</div>
<p>这是因为这张表是由 UID和PID确定的，但是U_name是单独由UID确定的，P_name和Price则是有PID单独确定的。在这张表里主键是UID+PID，因此在一张表里面当UID或PID重复出现多次的话，会造成数据的冗余。</p>
<p>冗余的副作用很多，最直观也最易理解的就是当我们修改一个值的时候需要将整个表扫描一遍然后修改所有冗余值。如何规避掉这些冗余，需要在我们设计数据库的时候下功夫。</p>
<p>现在我介绍一下<strong>函数依赖</strong>的含义：</p>
<p>比如u_name 是依赖于UID的，p_name,price是依赖于PID的。在这张表中有这两个函数依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UID -&gt; u_name</span><br><span class="line">PID -&gt; p_name,price</span><br></pre></td></tr></table></figure>
<p>当函数依赖的两个决定属性(UID和PID)不等于这个表的主键的时候，就会出现冗余的情况</p>
<h3 id="数据库设计的规范化"><a href="#数据库设计的规范化" class="headerlink" title="数据库设计的规范化"></a>数据库设计的规范化</h3><p>为了规避冗余，我们需要把我们的数据库设计的规范化，只要我们按照ER图的设计理念，构造出来的数据表一般都是规范的。就像上面这张表，以规范化的方式我们要将其拆分为三张小表，如下：</p>
<p>User</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>UID</th>
<th>U_name</th>
</tr>
</thead>
<tbody>
<tr>
<td>U001</td>
<td>Jason</td>
</tr>
<tr>
<td>U002</td>
<td>May</td>
</tr>
<tr>
<td>U003</td>
<td>Bob</td>
</tr>
</tbody>
</table>
</div>
<p>Product </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>PID</th>
<th style="text-align:left">Pname</th>
<th>Price</th>
</tr>
</thead>
<tbody>
<tr>
<td>P002</td>
<td style="text-align:left">soap</td>
<td>5</td>
</tr>
<tr>
<td>P003</td>
<td style="text-align:left">pencil</td>
<td>10</td>
</tr>
</tbody>
</table>
</div>
<p>Order</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>UID</th>
<th>PID</th>
<th>Quant</th>
<th>Date</th>
</tr>
</thead>
<tbody>
<tr>
<td>U001</td>
<td>P003</td>
<td>1</td>
<td>3/10/2020</td>
</tr>
<tr>
<td>U002</td>
<td>P002</td>
<td>2</td>
<td>4/10/2020</td>
</tr>
<tr>
<td>U002</td>
<td>P003</td>
<td>2</td>
<td>8/10/2020</td>
</tr>
<tr>
<td>U003</td>
<td>P002</td>
<td>1</td>
<td>10/10/2020</td>
</tr>
</tbody>
</table>
</div>
<p>我们要记住宽表拆分的原则：</p>
<p>让同时被使用到的属性(即出现在同一个SQL中的属性)尽可能位于拆分后的一张表中。这样子就不用再做连接，增加开销了</p>
<h3 id="冗余带来的好处"><a href="#冗余带来的好处" class="headerlink" title="冗余带来的好处"></a>冗余带来的好处</h3><p>上面我们介绍了两种模式(大表和拆分后的三张表)现在我们来讨论哪一种模式更好。</p>
<p>比如说对于查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT u_name,p_name</span><br><span class="line">FROM XXX</span><br><span class="line">WHERE date &#x3D; ? AND price*quant &gt;1000</span><br></pre></td></tr></table></figure>
<p>虽然大表有冗余，但是能很高效的来处理这段查询。反观拆分的三张表格，我们需要对其做连接后才能完成查询，代价比较大。</p>
<p>那么在规范化和非规范化之间应该怎么选择呢？我们要看看那些冗余的属性被修改的几率是否很高。</p>
<p>如果修改的几率很大，那么对于大表来说每次修改的开销就很大，就不划算；反之则可以选择大表来存储数据</p>
<p>但是对于这张表来说，我们在商城注册了之后，一般就不回去更改名字；且商品一旦创建之后，也不太会修改它的名字。价格这列见仁见智了。因此总体来说对于这套数据库系统，非规范化导致的数据冗余带来的负面作用是比较小的，但正面效果是比较好的。</p>
<p>所以说，非规范化和规范化都有其使用场景。</p>
<h3 id="如何利用冗余"><a href="#如何利用冗余" class="headerlink" title="如何利用冗余"></a>如何利用冗余</h3><p>现在我们有两张表：<code>Product(PID,P_name,Price)</code> 和 <code>Order(BID,UID,PID,Quant,Date)</code></p>
<p>然后我们用这个查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Sum</span>(Quant)*Price </span><br><span class="line"><span class="keyword">FROM</span> Product,<span class="keyword">Order</span></span><br><span class="line"><span class="keyword">WHERE</span> Product.PID = Order.PID</span><br><span class="line"><span class="keyword">AND</span> Product.PID = ?</span><br></pre></td></tr></table></figure>
<p>这个查询非常普遍，就是要我们去计算某一件特定商品的总销售额。如果我们采用标准化的关系表，那么会非常慢，因为Product和Order会连接成一张大表，我们需要扫描这张表中所有的内容，然后再统计计算才能得到结果。因此这时候我们可以用冗余来帮助我们简化查询，方法也很简单就是给Product加一个TotalSales属性</p>
<p><code>Product(PID,P_name,Price,TotalSales)</code> </p>
<p>这样，我们就可以直接获得TotalSales了，而我们所需要付出的代价，仅仅是每次下订单的时候额外更新一下Product表格即可</p>
<p>最后我们对非规范化和冗余做一个延伸和总结。冗余经常会给我们的程序开发带来一些好处。最具有代表性的就是缓存机制。比如web server会专门开一片区域当缓存来存放数据库中经常被调用的那些值。 但是缓存是冗余的值，没了缓存还是可以正常运行，但是有缓存会大大提升程序的运行速度。</p>
<p>还有比如数据库内部的索引，这也是冗余的一种表现。</p>
<h3 id="网上购物场景实例"><a href="#网上购物场景实例" class="headerlink" title="网上购物场景实例"></a>网上购物场景实例</h3><ul>
<li>网站陈列了各种各样的商品，提供商品的详细信息，包括商品名称、种类、价格、仓储地址等。</li>
<li>用户可以登录到网站，浏览并选择商品。</li>
<li>用户提交购买请求，包括：购买商品的种类和数量、购买客户的姓名和地址等。</li>
<li>系统审核用户的购买请求，完成购买，整个过程包括调用外部系统实现付款和送货，以及记录用户的购买历史。</li>
</ul>
<h4 id="创建ER图"><a href="#创建ER图" class="headerlink" title="创建ER图"></a>创建ER图</h4><p>我们对于用户和商品之间的购买关系，有两种处理方式，第一种是用一个简单关系带描述(菱形)，第二种则是通过用户下订单、订单中包含商品的方式来呈现，如下图所示。</p>
<p><img src="/2021/11/14/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/13.jpeg" style="zoom: 50%;"></p>
<p>那么应该采用哪种方式呢？</p>
<p>选择标准就是这种关系能否由两个实体的ID去确定。比如UID和PID能唯一确定一个购买关系吗？答案是不能的，因为一个用户可以重复下单同一件商品，仅用UID和PID是反映出来的</p>
<p><img src="/2021/11/14/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/14.jpeg" style="zoom: 50%;"></p>
<h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><ol>
<li><p><img src="/2021/11/14/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/19.png"></p>
</li>
</ol>
<p>因为只有少量员工有两个电话号码，那么我们没有必要新开一张表去存储多值属性的关系，直接新建一列即可，这一列大多数都是空白的。不会让这张表变得非常宽</p>
<ol>
<li><p><img src="/2021/11/14/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/18.png"></p>
</li>
<li><p>某关系表R的外键是指：</p>
</li>
</ol>
<p>A. 其他关系表的键，可以是R的任意属性</p>
<p>B. 该关系表R除主键之外的另一个键</p>
<p>C. 其它关系表的键，同时必须作为R的主属性(即R的键包含的属性)</p>
<p>D. 其他关系表的键，同时必须作为R的非主属性(即不被R的键包含)</p>
<p>在了解这个问题之前，我们首先要学习 主码、候选码、主属性、非主属性 的定义</p>
<ol>
<li>候选码的定义：如果关系中的某一<strong>属性组</strong>的值能唯一地标识一个元组，则称该属性组为候选码；</li>
<li>主码的定义：如果一个关系有多个候选码，则选定其中一个为主码；</li>
<li>主属性定义：候选码的诸属性称为主属性；</li>
<li>非主属性定义：不包含在任何候选码中的属性称为非主属性；</li>
</ol>
<p>因为我们可以通过两张表的主键来定义一张表格，这两个主键都是这张表的外键。因此，外键在表中也是用来标识一个元组的，是主属性。所以选择C</p>
<ol>
<li><p>请针对以下需求设计ER图，并构建相应的关系模式：</p>
<p>一个关于电影、制作人员和演员的网站（类似一个简易的IMDB网站）。用户可以浏览每一部电影的简介和相关信息（出品年份、电影类型、时长、评级），以及其导演、编剧和演员的列表。用户还可以浏览每一位导演、编剧或演员的信息（姓名、性别、年龄、简介），以及他们参与过哪些电影作品。导演、编剧或演员只是职位，一个人可以身兼数职。</p>
<p>每一位演员在其参演的电影中都扮演一定的角色。用户在浏览电影时，除了能看到演员信息，还能看到每位演员扮演了什么角色。用户在浏览演员时，除了能看到他（或她）参演的电影，还能看到他（或她）在每一部电影中扮演的角色。（注意：一位演员可以在一部电影中扮演多个角色。同一个角色也可能由多名演员扮演，比如，年少时由一位演员扮演，年老时由另一位演员扮演。）</p>
<p>用户登录后还可以针对每一部电影、每一位导演、编剧或演员进行评价和打分，供别人参考。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/11/09/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch10-%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/11/09/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch10-%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/" itemprop="url">数据科学算法ch10-矩阵分解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-11-09T19:04:53+08:00">
                2021-11-09
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2021-12-02T14:37:04+08:00">
                2021-12-02
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/11/09/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch9-%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3%E4%B8%8E%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/11/09/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch9-%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3%E4%B8%8E%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/" itemprop="url">数据科学算法ch9-奇异值分解与主成分分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-11-09T19:04:26+08:00">
                2021-11-09
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-01-06T23:48:34+08:00">
                2022-01-06
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="奇异值分解与主成分分析"><a href="#奇异值分解与主成分分析" class="headerlink" title="奇异值分解与主成分分析"></a>奇异值分解与主成分分析</h1><p>在机器学习中，随着数据维度的升高，分类器的性能会先增加后降低。这可能是因为维度过高会导致过拟合问题。为了缓解过拟合，我们可以用数据降维。因此现在我们来学习两种常用的数据降维方法：<strong>奇异值分解</strong>(SVD) 和 <strong>主成分分析</strong>(PCA)</p>
<p>对于是方阵的数据，我们可以用特征值分解，但如果数据不是方阵，只是普通的方阵，那么就可以使用奇异值分解和主成分分析</p>
<h2 id="对角化与特征值分解"><a href="#对角化与特征值分解" class="headerlink" title="对角化与特征值分解"></a>对角化与特征值分解</h2><blockquote>
<p>相似矩阵</p>
</blockquote>
<p>对于矩阵 $\boldsymbol {A,B}\in\boldsymbol R^{n\times n}$ ，若存在$n\times n$ 的可逆矩阵$\boldsymbol P$，使得 $\boldsymbol A=\boldsymbol {PBP}^{-1}$,则称矩阵$\boldsymbol {A}$和$\boldsymbol B$ 是相似的</p>
<blockquote>
<p>正交矩阵</p>
</blockquote>
<p>对于矩阵$\boldsymbol P$ ,若$\boldsymbol P^{-1} = \boldsymbol P^T$ 则称$ \boldsymbol P$ 为正交矩阵。</p>
<p>由于$\boldsymbol {PP}^T = \boldsymbol I$​ ，因此正交矩阵是一类特殊的线性变换，它是保持原点不动，长度不变的旋转变换 </p>
<blockquote>
<p>对角化</p>
</blockquote>
<p>若方阵$\boldsymbol A$ 相似于一个对角阵，即存在一个可逆矩阵P和对角矩阵 $\Sigma$ ，使得 $\boldsymbol A=\boldsymbol {P\Sigma P}^{-1}$ ，则称$\boldsymbol  A$是可对角化的</p>
<p>矩阵对角化的重要性在于，若矩阵 $\boldsymbol A$ 是可对角化的，那么会满足以下两条性质：</p>
<script type="math/tex; mode=display">
\boldsymbol A^k = \boldsymbol {P\Sigma}^k\boldsymbol P^{-1}\\
\boldsymbol A^{-1} = \boldsymbol {P\Sigma}^{-1}\boldsymbol P^{-1}</script><p>接下来给出对角化的相关定理</p>
<ul>
<li><p>矩阵 $\boldsymbol A \in \boldsymbol {R}^{n\times n}$ 可对角化的充分必要条件是$\boldsymbol A$ 有 n 个线性无关的特征向量</p>
</li>
<li><p>矩阵 $\boldsymbol A \in \boldsymbol {R}^{n\times n}$ 可对角化的充分必要条件是，该矩阵每一个特征值的<strong>几何重数</strong> 等于其 <strong>代数重数</strong> </p>
</li>
</ul>
<blockquote>
<p>正交对角化</p>
</blockquote>
<p>若存在对角阵 $\boldsymbol \Sigma $ 、正交矩阵 $\boldsymbol P$ ，使得$\boldsymbol A = \boldsymbol P\boldsymbol \Sigma\boldsymbol P^{T}$​ 则称A是可正交对角化的</p>
<p>正交对角化也是一种矩阵分解方法，该方法又被称为特征值分解。若矩阵$\boldsymbol A$ 是可正交对角化的，意味着矩阵 $\boldsymbol A$ 对应的线性变换可以分解成三步：</p>
<ol>
<li>将空间向量经过正交矩阵$\boldsymbol P^T$ 进行旋转变换</li>
<li>通过对角矩阵$\boldsymbol \Sigma$​ 进行伸缩变换</li>
<li>经过正交矩阵$\boldsymbol P$ 进行旋转变换，其中 $\boldsymbol P$ 和 $\boldsymbol P^T$ 互为逆变换</li>
</ol>
<p>接下来给出对角化的相关定理：<strong>若$\boldsymbol A$是实对称矩阵</strong>，那么$\boldsymbol A$具有一下性质</p>
<ol>
<li>不同特征值对应的特征向量之间是正交的</li>
<li>$\boldsymbol A$ 有n个实特征值(如果包含重数)</li>
<li>对于任一特征值，其对应的特征向量的集合重数等于特征值的代数重数</li>
<li>特征空间是相互正交的</li>
<li>$\boldsymbol A$​是可正交对角化的</li>
</ol>
<h3 id="特征值分解"><a href="#特征值分解" class="headerlink" title="特征值分解"></a>特征值分解</h3><p>求解对称方程 $A\in \mathbb R^{n\times n}$ 的特征分解步骤</p>
<ul>
<li><p>计算矩阵A的特征值$\lambda_1\cdots,\lambda_n$ 即 求特征方程 $|A-\lambda I| = 0$  的n个根</p>
</li>
<li><p>求特征值对应的n个相互正交的特征向量 $q_1,\cdots,q_n$即求解方程组并单位化</p>
<script type="math/tex; mode=display">
Aq_i = \lambda_iq_i,i=1,\cdots,n</script></li>
<li><p>记矩阵 $Q=(q_1,\cdots,q_n)$ </p>
</li>
<li><p>最终得到矩阵A的特征分解为 </p>
<script type="math/tex; mode=display">
A = Q\begin{pmatrix} \lambda_1 &  &  \\  & \cdots &  \\ & & \lambda_n \end{pmatrix}Q^T</script></li>
</ul>
<p>例：求实对称矩阵的特征分解</p>
<script type="math/tex; mode=display">
A =\begin{bmatrix} 2& 1\\ 1 & 2 \end{bmatrix}</script><ol>
<li>首先我们计算特征向量</li>
</ol>
<script type="math/tex; mode=display">
|\lambda I-A| =\begin{bmatrix}\lambda-2& -1\\ -1 & \lambda-2 \end{bmatrix}=0\\</script><p>特征值：$\lambda_1=3,\lambda_2=1$</p>
<p>带入求解并单位化： $q_1 = (\frac{1}{\sqrt 2},\frac{1}{\sqrt 2})^T,q_2 = (-\frac{1}{\sqrt2},\frac{1}{\sqrt2})^T$ </p>
<ol>
<li>写出特征向量方阵Q和特征值方阵 $\Lambda$ </li>
</ol>
<script type="math/tex; mode=display">
Q =[q_1,q_2] =\begin{bmatrix} \frac{1}{\sqrt2}& -\frac{1}{\sqrt 2}\\ \frac{1}{\sqrt 2} & \frac{1}{\sqrt2} \end{bmatrix},\Lambda =\begin{bmatrix} \lambda_1 & \\  & \lambda_2 \end{bmatrix} = \begin{bmatrix} 3 &\\ & 1 \end{bmatrix}</script><ol>
<li>$p=(\alpha_1,\alpha_2,\alpha_3),(p^{-1})^T=(\beta_1,\beta_2,\beta_3)$ </li>
</ol>
<script type="math/tex; mode=display">
G_1 = \alpha_1\beta_1^T+\alpha_2\beta_2^T\\~\\
G_2 = \alpha_3\beta_3^T</script><p>A和$G_1,G_2$的关系就是特征分解</p>
<h2 id="奇异值分解"><a href="#奇异值分解" class="headerlink" title="奇异值分解"></a>奇异值分解</h2><p>给定矩阵 $\boldsymbol A\in \boldsymbol R^{m\times n}$ ,则矩阵 $\boldsymbol A$ 的奇异值分解为：</p>
<script type="math/tex; mode=display">
\boldsymbol A = \boldsymbol U\boldsymbol\Sigma\boldsymbol V^T</script><h3 id="分解过程"><a href="#分解过程" class="headerlink" title="分解过程"></a>分解过程</h3><ol>
<li>计算矩阵 $\boldsymbol {AA}^T$ 和 $\boldsymbol A^T\boldsymbol A$ </li>
<li>分别计算矩阵  $\boldsymbol {AA}^T$ 和 $\boldsymbol A^T\boldsymbol A$ 的特征值和对应的特征向量</li>
<li>用矩阵  $\boldsymbol {AA}^T$ 的特征向量组成矩阵 $\boldsymbol U$;用 $\boldsymbol A^T\boldsymbol A$  的特征向量组成$\boldsymbol V$</li>
<li>对矩阵 $\boldsymbol {AA}^T$ 和 $\boldsymbol A^T\boldsymbol A$ 的非零特征值求算术平方根，并对应特征向量的位置填入$\boldsymbol \Sigma$ 的<strong>对角元</strong></li>
</ol>
<h2 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h2>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/9/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/%5Bobject%20Object%5D"
                alt="Jason" />
            
              <p class="site-author-name" itemprop="name">Jason</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20fa%20fa-archive">
              
                  <span class="site-state-item-count">435</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">61</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="true"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
 <!--
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>







-->
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>




















  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v="></script>

  <script type="text/javascript" src="/js/src/motion.js?v="></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v="></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
