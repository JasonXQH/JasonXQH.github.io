<!DOCTYPE html>
<html lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jasonxqh.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jason‘s Blog">
<meta property="og:url" content="https://jasonxqh.github.io/page/8/index.html">
<meta property="og:site_name" content="Jason‘s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jasonxqh.github.io/page/8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jason‘s Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jason‘s Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/12/16/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/16/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">注意力机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-16 18:52:53" itemprop="dateCreated datePublished" datetime="2021-12-16T18:52:53+08:00">2021-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-12-27 20:24:42" itemprop="dateModified" datetime="2021-12-27T20:24:42+08:00">2021-12-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="注意力机制"><a href="#注意力机制" class="headerlink" title="注意力机制"></a>注意力机制</h1><h2 id="RNNs-attention"><a href="#RNNs-attention" class="headerlink" title="RNNs+attention"></a>RNNs+attention</h2><p>在写 <a href="https://jasonxqh.github.io/2021/12/16/循环神经网络/#其他例子">循环神经网络</a> 这篇博客的时候，我曾简单讲过注意力机制的原理及其作用。现在我们来详细学习一下注意力机制。</p>
<p>首先，我们要知道注意力机制在RNN中的作用有哪些？</p>
<ul>
<li>计算机视觉中的应用： 图片描述</li>
<li>自然语言处理中的应用：机器翻译</li>
</ul>
<h3 id="不使用注意力机制-图像识别"><a href="#不使用注意力机制-图像识别" class="headerlink" title="不使用注意力机制-图像识别"></a>不使用注意力机制-图像识别</h3><p><img src="/2021/12/16/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/1.png"></p>
<p>我们来讲不使用注意力机制的RNN是如何进行看图说话的。我们看到上图的左半侧是一个encoder，输入的是图片$I$,  右半侧是decoder，输出的是文本</p>
<p>首先，图像经过CNN卷积以后生成一张 feature map，也就是上面绿色的矩阵</p>
<p>然后，我们将feature map 经过 MLP (multi-layer perceptron,多层感知机)后，变成一个D维的$h_0$。 同时，利用 $h_0$ 转化出一个 context vector c(为了方便其实一般就是将$c$设置为整个$h_0$),使其保留了图片中的特征信息，可以用来辅助文本预测。</p>
<p>context vector 是可以作为选择性输入的，有没有都可以。如果将其作为一部分输入，那么神经元既有之前生成的文本信息，又有保留下来的图片信息，可以帮助RNN更好辅助生成单词。</p>
<p>但是这样做是有一个缺陷的，就是我们生成的context vector虽然拥有图片的全部特征，但对于每一个神经元的输入，都是相等的。因此，这并不利于在不同时刻捕捉差异化的图片信息，神经网络说话的时候就”抓不住重点“，导致看图说话效果不好。   </p>
<h3 id="使用注意力机制-图像识别"><a href="#使用注意力机制-图像识别" class="headerlink" title="使用注意力机制-图像识别"></a>使用注意力机制-图像识别</h3><p>因此，看图说话借鉴了机器翻译中的注意力机制来提升看图说话的准确性</p>
<p><img src="/2021/12/16/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/2.png"></p>
<ul>
<li><p>首先，还是图片通过CNN 生成一张feature map，然后通过MLP生成隐层向量$h_0$ </p>
</li>
<li><p>用隐向量和feature map 相乘，生成一张 $H\times W$ 的对齐分数矩阵 $\boldsymbol e$。对齐分数越大，代表应该关注这部分特征越多。</p>
</li>
<li><p>对于对齐分数中的元素，利用 softmax 进行归一化，得到注意力分数矩阵 $\boldsymbol a$ , 这就代表了每一个部分应该被关注的概率</p>
</li>
<li><p>利用注意力分数矩阵和feature map 做对位相乘(加权聚合)，得到加权之后的整张图片的特征向量context vector, 形状为 $D\times 1$</p>
<script type="math/tex; mode=display">
c_t = \sum_{i,j} a_{t,i,j}z_{i,j}</script></li>
<li><p>将 context vector 、输入值、以及上个隐层状态，共同作为下一个神经元的输入。接下来，每一步的$h_{i}$都会和feature map生成一个 context vector，告诉下一个神经元应该关注哪里。</p>
</li>
</ul>
<p>通过这种方法，每个时刻 t 的 context vector 都是不一样的，是随着$h_{t-1}$  变化而来的。因此，每个时刻都可以根据前一时刻的隐层状态去关注图片的不同区域</p>
<p><img src="/2021/12/16/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/3.png"></p>
<p>结果如下：</p>
<p><img src="/2021/12/16/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/4.png"></p>
<h4 id="图像描述注意力计算"><a href="#图像描述注意力计算" class="headerlink" title="图像描述注意力计算"></a>图像描述注意力计算</h4><p>现在我们来具体看一下注意力分数是如何被计算出来的，如下图：</p>
<p><img src="/2021/12/16/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/8.png"></p>
<h3 id="不使用注意力机制-机器翻译"><a href="#不使用注意力机制-机器翻译" class="headerlink" title="不使用注意力机制-机器翻译"></a>不使用注意力机制-机器翻译</h3><p>机器翻译和图片识别的原理大致相同，只不过原本的encoder 是用来处理图片信息的，而现在是用来处理文字流的。因此我们不能使用CNN，而要使用RNN：</p>
<p>在Encoder中，一个一个输入法语单词，生成一个隐向量，聚合后经过MLP得到decoder的初始隐向量$h_0$</p>
<p>还可以保留一个 context vector 包含了这句法语中的所有特征，作为辅助输入来帮助文本预测，</p>
<p><img src="/2021/12/16/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/5.png"></p>
<p>但是因为没有引入attention机制，导致decoder没有关注重点，翻译不准确</p>
<h3 id="使用注意力机制-机器翻译"><a href="#使用注意力机制-机器翻译" class="headerlink" title="使用注意力机制-机器翻译"></a>使用注意力机制-机器翻译</h3><p><img src="/2021/12/16/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/6.png"></p>
<p>在机器翻译中引入注意力机制后，对于每一个输入层的隐向量$z<em>i$ ,都和$h</em>{t-1}$相乘得到对齐分数$\boldsymbol e$ ;</p>
<ul>
<li>再经过 softmax 计算注意力分数$a_{t,i}$,t代表第t个时刻</li>
<li>用得到的$\boldsymbol a$和当前$z_i$ 聚合，得到context vector c， 作为下一层的输入。</li>
</ul>
<p>这样，在decoder中，每个时刻t 的context vector 都会随着$h_{t-1}$的变化而变化，即每个时刻都可以根据前一时刻的隐层状态关注输入文本的不同部分</p>
<p><img src="/2021/12/16/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/7.png"></p>
<h2 id="一般的注意力层结构"><a href="#一般的注意力层结构" class="headerlink" title="一般的注意力层结构"></a>一般的注意力层结构</h2><h3 id="一般注意力层"><a href="#一般注意力层" class="headerlink" title="一般注意力层"></a>一般注意力层</h3><p>之前我们介绍了如何在图像识别中进行注意力计算，现在我们来看看一般注意力层是如何计算的：</p>
<p>首先，因为一般注意力层的输入并不是feature map，而是单个的向量，因此原来的MLP变成了现在的点积，事实证明用点积计算可以在 Transformer 中取得很好的效果</p>
<p><img src="/2021/12/16/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/10.jpg"></p>
<p>然而得到了对齐分数$e_i$，但是在向量长度很长的情况下，会造成对齐分数的方差很大(大的分数很大，小的分数很小)。这样的数据经过softmax层以后(指数运算)，会使得注意力分数只集中在少数几个输入向量上。因此，单单点积还是不够的，我们需要除以$\sqrt D$ 以减轻这种效应，其中$D$为向量长度。</p>
<p><img src="/2021/12/16/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/11.png"></p>
<p>接着，对 对齐分数进行softmax以后，得到了注意力分数。在将注意力分数和输入值$x$做整合：</p>
<p><img src="/2021/12/16/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/9.png"></p>
<p>但是，这种一般注意力层是存在缺点的：输入向量既 作为对齐运算的输入，又 做为注意力运算的输入，有点缺乏输入特征上的变化。</p>
<h3 id="自注意力层"><a href="#自注意力层" class="headerlink" title="自注意力层"></a>自注意力层</h3><p>因此，我们可以通过在计算对齐分数和注意力分数的时候，分别用一个线性层对输入向量进行转化来解决这个问题。这样存在一定的变化之后，可以使得 $y_i$ 的大小和输入$x_i$的大小是不一样的。</p>
<p>如下所示：</p>
<p><img src="/2021/12/16/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/12.png"></p>
<p>对于输入向量，我们可以将其乘以一个 $\boldsymbol W_k$矩阵将其变为 Key 向量，将其和Querie向量相乘得到对齐分数</p>
<p>然后再将输入值 乘以 $\boldsymbol W_v$矩阵相乘，得到 Value 向量，将其和softmax过后的对齐分数聚得到注意力分数</p>
<p>而且从RNN中我们也看到了，Queries 向量也是由输入向量经线性层得到的。</p>
<p>用自己来生成query、key去做对齐分数的计算，再与由自己来生成的value聚合，这就是<strong>自注意力层</strong>命名由来</p>
<p>简单来说，就是对一组输入向量的自我注意力运算，将中间的计算隐藏后，我们可以得到如下结构：</p>
<p><img src="/2021/12/16/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/13.png"></p>
<h3 id="位置编码"><a href="#位置编码" class="headerlink" title="位置编码"></a>位置编码</h3><p>运用自注意力层，可以完全抛弃循环神经网络中的迭代结构。因为在RNN中，context vectors是按照顺序，一个一个生成的，需要借助每一次循环的$h_{t-1}$ 。但是自注意力层只需要自己计算就可以得到 context vectors了。</p>
<p>因此也会导致一个问题，就是生成的编码$y_i$很可能无法学到输入向量的排列顺序信息，这对于处理文本和图片都是不利的。因此，我们要想一个办法，在输入向量中加入其在序列中的位置信息。使其能够表示每个向量的绝对位置和相对位置。</p>
<p>这就是位置编码 (positional encoding)的作用</p>
<p><img src="/2021/12/16/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/14.png"></p>
<p>关于位置编码$p_t$, 需要满足以下特性：</p>
<ul>
<li>唯一性： 每个时刻的编码是唯一的 </li>
<li>一致性：对于所有输入长度，两个时刻之间的距离是一致的</li>
<li>泛化性：对于所有输入长度都可以使用这套编码</li>
</ul>
<p>因此，用三角函数来表示时刻、位置信息就是一个很好地选择。</p>
<script type="math/tex; mode=display">
p_t^i = \begin{cases}\sin(\omega_k\cdot t)&\text{if i=2k} \\~\\\cos(\omega_k\cdot t) & \text{if~i=2k+1} \end{cases}</script><p>其中， $t\geq 0$ 代表时刻；$0\leq i&lt;D$ 代表编码的<strong>第i个位置</strong>; $\omega_k = \frac{1}{10000^{2K/D}}$ </p>
<p>最终，对于在t时刻、长度为D的输入，会得到一个长度为D的位置编码：</p>
<p><img src="/2021/12/16/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/15.png"></p>
<p>因为我们对$\omega_k$ 取得值是很小的，t乘以10000之后，可能会开始循环，但 t 一般只取128、256、512、1024。因此 $p_t$ 所有sin、cos的值都是在一个周期之内的，满足唯一性。</p>
<p>泛化性也很好理解，因为这套编码对任何长度的句子, 都是适用的</p>
<p>对于一致性，两个时刻之间的距离是一致的吗？我们可以用一个简单的方式来证明：我们考虑位置编码中任意一对sin和cos，运算以下公式：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}\cos(\omega_k\cdot\Delta t)&\sin(\omega_k\cdot \Delta t)\\-\sin(\omega_k\cdot\Delta t)&\cos(\omega_k\cdot \Delta t) \end{bmatrix}\cdot\begin{bmatrix}\sin(\omega_k\cdot t)\\ \cos(\omega_k\cdot t) \end{bmatrix} = \begin{bmatrix}\sin(\omega_k\cdot(t+\Delta t))\\\cos(\omega_k\cdot(t+\Delta t)) \end{bmatrix}</script><p>我们发现，其距离只和两个时刻有关，和输入长度无关。因此一致性也会满足</p>
<h3 id="遮挡的自注意力层"><a href="#遮挡的自注意力层" class="headerlink" title="遮挡的自注意力层"></a>遮挡的自注意力层</h3><p>有了位置编码这个工具以后，输入向量就是由顺序性的。但现在又有一个问题，之前的注意力机制，输出结果的时候，后面的输入是看不到的。但现在有了位置编码之后，在输出$y_0$的时候却能看到后面的输入。</p>
<p>这是不可以的，每一个位置的输入编码是<strong>不应该提前看到后面的输入</strong>的，否则会导致过拟合的情况</p>
<p>因此，提出了<strong>遮挡的</strong>自注意力层。也就是说，在encode的时候，将当前向量后面的对齐分数设置为负无穷，在decode 的时候相应的注意力分数设置为0，如下图所示：</p>
<p><img src="/2021/12/16/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/16.png"></p>
<p>我们看到，对于第一个输入位置的$k_0$,我们把$k_1,k_2$的对齐分数置为$-\infty$；对于第二个位置输入的$k_1$,它可以看见$k_0$输入，但是$k_2$ 的对齐分数被设置为$-\infty$ </p>
<h3 id="多头自注意力层"><a href="#多头自注意力层" class="headerlink" title="多头自注意力层"></a>多头自注意力层</h3><p><img src="/2021/12/16/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/17.png"></p>
<p>用多组不同的 $k/q/v$ 来计算多组不同的注意力分数，每组注意力分数关注输入中的不同部分，以提高对子空间的特征捕捉能力。</p>
<p>比如说我可以设置$h=8$，即8个head，每个 head 生成一组输出，最后将8组输出拼接</p>
<h2 id="Transformers"><a href="#Transformers" class="headerlink" title="Transformers"></a>Transformers</h2><p>完全基于注意力机制的全新的神经网络结构</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/12/16/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/16/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">生成模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-16 18:52:41" itemprop="dateCreated datePublished" datetime="2021-12-16T18:52:41+08:00">2021-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-05 18:07:22" itemprop="dateModified" datetime="2022-03-05T18:07:22+08:00">2022-03-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="生成模型"><a href="#生成模型" class="headerlink" title="生成模型"></a>生成模型</h1><p>到现在为止，我们学习的所有模型都是<strong>有监督学习</strong>。</p>
<ul>
<li>给定数据x和标签y，学习$x\rightarrow y$ 的映射，并以此预测新的数据的标签</li>
<li>应用场景如：图像分类，图像描述，目标检测，语义/实例分割，图像复原，风格转换等等。</li>
</ul>
<p>那么，什么是无监督学习及其应用呢？</p>
<ul>
<li>对于海量数据来讲，是没有标签的(或者标签就是数据本身)，给数据打标签是一件费时费力的工作。</li>
<li>应用场景如：机器学习中的聚类，降维，EM算法，表征学习，生成模型等等</li>
</ul>
<p>这节课，我们主要来学习生成模型。简单来说，就是一个可以生成图像的模型——给定训练图像，生成行的随机图像，如下图所示：</p>
<p>左边是输入的数据，是真实世界里的照片；右边是模型随机生成的照片</p>
<p><img src="/2021/12/16/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/1.png" style="zoom:120%;"></p>
<p>现在给出正式定义：给定观测数据 $X$ 和 目标变量$Y$,模拟联合分布$p(X,Y)$ 或 条件概率分布 $p(X|Y)$ </p>
<p>给定观测数据和目标变量Y，模拟联合分布$p(X,Y)$ 或者条件概率分布$p(X|Y)$. 然后，由 $p(X,Y)$ 或者 $p(X|Y)$ 可以模拟概率密度函数$p(X)$</p>
<p>不管使用哪种方法，其底层逻辑都是<strong>极大似然函数</strong>。 在 <a href="https://jasonxqh.github.io/2021/06/10/概率论第六章/#最大似然估计与EM算法">极大似然估计与EM算法</a> 中，我们已经学过极大似然函数是用来估计参数的。同样的在这里我们可以用到这个方法</p>
<ul>
<li>构建参数模型表示图像的概率密度函数 $p<em>{model}(x|\theta)$，(一般使用神经网络来模拟$p</em>{model}(x|\theta)$ )</li>
<li>使用大量观测图像去估计参数$\theta$ , 使得 $\sum p_{model}(x|\theta)$ 去极大值 (优化目标)</li>
<li>使用估计(训练)好的 $p_{model}(x|\theta)$ 生成新的随机图像</li>
</ul>
<script type="math/tex; mode=display">
\theta ^* = \arg\max_\theta \mathbb E_{x\sim p_{data}}\log p_{\text{model}}(x|\theta)</script><p>现在我们给出常用的生成模型以及他们的分类</p>
<p><img src="/2021/12/16/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/2.png" style="zoom:100%;"></p>
<p>首先，生成模型分为两大类：显示的概率密度函数——即显式定义概率密度函数，然后用观测数据将其最大化；隐式的概率密度函数——预先没有定义，但是通过其他方式使得模型学习得到概率密度函数。</p>
<p>其中，显示概率密度函数又分为两种: 容易计算的概率密度函数和近似的概率密度函数。其中，前者最主要的技术是 完全可见信念网络 (Fully Visible Belif Nest, FVBN)，主要模型是PixelRNN/CNN； 后者主要技术为变分自编码器(Variational Auto Encoder)和马尔科夫链(玻尔兹曼机)</p>
<p>隐式概率密度函数中分为两种模型： GAN和GSN，GAN是我们今天要学习的模型，GSN中使用马尔科夫链，效率比较低。</p>
<h2 id="显式概率密度函数"><a href="#显式概率密度函数" class="headerlink" title="显式概率密度函数"></a>显式概率密度函数</h2><h3 id="FVBN"><a href="#FVBN" class="headerlink" title="FVBN"></a>FVBN</h3><p>首先我们来介绍显示概率密度函数类别下的完全可见信念网络的原理。然后来介绍一下这个网络下的PixelRNN模型</p>
<p>首先，我们令图片 $x ={x_1,x_2,\cdots,x_n}$为一组向量，$p(x)$ 是关于图片中所有像素值的联合概率分布。</p>
<p>其次，我们要计算$p(x)$ ，$p(x)$等于基于链式规则的条件概率乘积，即：</p>
<script type="math/tex; mode=display">
p(x) = \prod_{i=1}^nP(x_i|x_1,\cdots,x_{i-1})</script><ul>
<li>$p(x) $是代表图片x 的概率，我们可以使用神经网络来模拟高维数据的概率分布</li>
<li>$p(x<em>1,\cdots,x</em>{i-1})$ 代表给定前面所有像素的情况想，第i个像素的值$x_i$的概率</li>
</ul>
<p>最后，将联合概率学习转换为顺序预测：</p>
<ul>
<li>根据已生成的像素预测下一个像素值</li>
<li>优化目标：最大化$L = \sum_x\log p(x)$</li>
</ul>
<h3 id="Pixel-RNN-CNN"><a href="#Pixel-RNN-CNN" class="headerlink" title="Pixel RNN/CNN"></a>Pixel RNN/CNN</h3><h4 id="Pixcel-RNN"><a href="#Pixcel-RNN" class="headerlink" title="Pixcel RNN"></a>Pixcel RNN</h4><p>从上面对 FVBN 的介绍，我们发现对像素的预测是呈序列状的，因此很适合用循环网络来解决这个问题。因此我们要定义一个比较规则的序列</p>
<p>最朴素的想法是：从左上角开始每次生成一个像素点，当前点为 output, 左边一个点为 input。如下图所示：</p>
<p><img src="/2021/12/16/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/3.png" style="zoom:100%;"></p>
<p>但这样训练和生成的效率都很低，我们想象一下生成512x512的图像，会导致像素序列非常长，而这么长的序列对RNN来说是非常不利的。</p>
<p>所以，在<a href="http://proceedings.mlr.press/v48/oord16.pdf" target="_blank" rel="noopener">这篇文章</a>中，作者提出了用Row LSTM方法和Diagonal BiLSTM方法来解决Pixel RNN的问题。</p>
<h4 id="Row-LSTM"><a href="#Row-LSTM" class="headerlink" title="Row LSTM"></a>Row LSTM</h4><p>Row LSTM的想法是：从上往下逐行生成像素点，即把前一行的像素全部作为 input ，如下图所示</p>
<p><img src="/2021/12/16/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/4.png" style="zoom:100%;"></p>
<p>这种方法采用LSTM顺序去输出每一个像素点</p>
<script type="math/tex; mode=display">
[o_i, f_i, i_i, g_i] = (K^{ss} * h_{i-1} +K^{is} * x_i)</script><p>其中，$K^{is}*x_i$ 代表 $3\times 1$的卷积运算，训练时还可以让所有row 并行运算</p>
<p>不足之处：</p>
<ul>
<li>每个像素点的 context 知识上面几行组成的三角区域，这和理想状态不符合、</li>
<li>生成时依然是每次只生成一个像素点，会存在一定的效率上的问题</li>
</ul>
<h4 id="Diagonal-BiLSTM"><a href="#Diagonal-BiLSTM" class="headerlink" title="Diagonal BiLSTM"></a>Diagonal BiLSTM</h4><p>要了解对角双向LSTM方法，我们首先要对双向LSTM有一个了解。其结构如下图所示：</p>
<ul>
<li>两层LSTM结构，分别从正反两个方向顺序输入序列数据</li>
<li>同一个时间步的两个hidden state 拼接然后转化为输出</li>
</ul>
<p>通过这个方法，就可以同时捕获当前时间步前面和后面的context，而不像前面Row LSTM方法那样只能捕捉前面的context</p>
<p><img src="/2021/12/16/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/6.png" style="zoom:100%;"></p>
<p>将BiLSTM应用于生成模型中去，我们看到，这里有两层LSTM：第一层从左上到右下；第二层从右上到左下。像素生成的示意图如下所示：</p>
<p><img src="/2021/12/16/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/5.png" style="zoom:100%;"></p>
<p>运用这种方法</p>
<ul>
<li>输入为左边(右边)的像素点</li>
<li>hidden state为左边(右边)和上方像素点的hidden values，并对其做$2\times1$ 卷积</li>
</ul>
<p><img src="/2021/12/16/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/8.png" style="zoom:100%;"></p>
<p>正常来说，输入值是左方和上方的像素点做卷积，但是这样不太方便矩阵计算。因此，我们每一行平移一个pixel的位置，使得左方像素和上方像素对齐，方便卷积计算。</p>
<p>不足之处</p>
<ul>
<li><p>生成时依然每次生成一个像素点</p>
<p><img src="/2021/12/16/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/9.png" style="zoom:100%;"></p>
</li>
</ul>
<p>我们看到Pixel RNN 生成的图片都非常小，因为尺寸一旦大了会导致梯度爆炸、梯度消失等问题。</p>
<h4 id="Pixel-CNN"><a href="#Pixel-CNN" class="headerlink" title="Pixel CNN"></a>Pixel CNN</h4><p>使用CNN，可以用左边和上面的像素卷积后生成新像素点。在训练时可以高度并行来提高训练效率</p>
<p><img src="/2021/12/16/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/7.png" style="zoom:100%;"></p>
<p>使用门结构层来代替 ReLU 层</p>
<ul>
<li>$t = \tanh (\boldsymbol W<em>{k,f}*x)\odot\sigma(\boldsymbol W</em>{k,g}*x)$ </li>
<li>加强网络的 non-linearity</li>
</ul>
<p>不足之处：</p>
<p>生成的时候仍然每次生成一个像素点。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Pixel RNN和Pixel CNN的优点：</p>
<ul>
<li>显示计算图像生成概率，生成图像直接和原式图像比较，易于优化，训练稳定</li>
</ul>
<p>缺点：</p>
<ul>
<li>虽然训练时候可以利用并行增加效率，但是测试的时候只能一个一个生成咸水沽。</li>
</ul>
<p>改进：</p>
<ul>
<li>Sigmoid 代替 Softmax</li>
<li>将 RGB像素视为整体</li>
<li>Res connections</li>
<li>Dropout</li>
</ul>
<p>总的来说， FVBN就是定义了一个离散的、易处理的(tractable) 密度函数，利用训练集直接优化似然(直接寻找极大似然).</p>
<script type="math/tex; mode=display">
p(x) = \prod_{i=1}^n p(x_i|x_1,\cdots,x_{i-1})</script><h3 id="VAE"><a href="#VAE" class="headerlink" title="VAE"></a>VAE</h3><p>VAE的全称是(Variational Autoencoders) ，相比于FVBN，它定义了一个连续的、不易处理的密度函数，是通过优化似然的下界(lower bound)来逼近极大似然的方法.因此，这里要是用积分来定义公式</p>
<script type="math/tex; mode=display">
p(x) = \int p(z)p(x|z)dz</script><h4 id="自编码器"><a href="#自编码器" class="headerlink" title="自编码器"></a>自编码器</h4><p>那么要了解VAE，首先要对自编码器(Autoencoders ,AE) 有一定的了解。自编码器是一种通过无监督的方式去学习数据内在表征(降维)的神经网络，如下图所示：</p>
<p><img src="/2021/12/16/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/10.png" style="zoom:100%;"></p>
<p>左侧是PCA的方法进行一个降维，右侧是通过自编码器方法对图片进行一个降维。它们的区别是：</p>
<ul>
<li>PCA是将矩阵经过sigmoid激活后保留主成分达到降维的目的，然后通过和$W^T$ 相乘获得新的压缩后的图片</li>
<li>自编码器则是通过一系列神经网络(编码器)将图片变成一个向量，然后再通过一些列神经网络(解码器)将这个向量复原成一张图片</li>
</ul>
<p>他们的效果对比如下，我们看到自编码器相对于PCA有更多的参数，但复原后的图片也更加清晰</p>
<p><img src="/2021/12/16/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/11.png" style="zoom:100%;"></p>
<h5 id="使用自编码器进行预训练"><a href="#使用自编码器进行预训练" class="headerlink" title="使用自编码器进行预训练"></a>使用自编码器进行预训练</h5><p>自编码器有什么应用场景呢？</p>
<p>首先，训练一个能够用于重构输入的隐层向量表示：</p>
<p><img src="/2021/12/16/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/12.png" style="zoom:100%;"></p>
<p>然后，训练完毕后，隐层特征就可以用于其他有监督训练任务(例如有大量数据，却只有少量标签)</p>
<p><img src="/2021/12/16/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/13.png" style="zoom:100%;"></p>
<p>那么我们可不可以随机初始化一个隐层向量，然后通过decoder来生成图像呢？这是比较困难的。因为用固定的自编码器去生成图片的时候，虽然隐层向量空间是连续的，但是每张图片生成的向量是离散的。处于离散向量之外的其他向量，不一定能生成图片。</p>
<p>就如同下图，虽然自编码器可以压缩黑狗还原黑狗，压缩白狗还原白狗，但是处于黑狗和白狗之间的那部分向量，是不一定能生成斑点狗的</p>
<p><img src="/2021/12/16/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/14.png" style="zoom:100%;"></p>
<h4 id="VAE的原理"><a href="#VAE的原理" class="headerlink" title="VAE的原理"></a>VAE的原理</h4><p>由此，我们提出，在自编码器的隐层向量空间中加入一些噪音，使得自编码器也能够生成斑点狗的照片：</p>
<p><img src="/2021/12/16/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/15.png" style="zoom:100%;"></p>
<p>那么既然我们定义在连续空间上，因此VAE的概率密度函数也得是连续的，由此得到了公式</p>
<script type="math/tex; mode=display">
p(x) = \int p(z) p(x|z)dz</script><p>其中：$x$ 是图像，而$z$ 是可以是隐层向量空间里面的一个随机向量(连续变量)。所以对于每一个z可能会生成一张图片。</p>
<h5 id="用VAE模型生成图像"><a href="#用VAE模型生成图像" class="headerlink" title="用VAE模型生成图像"></a>用VAE模型生成图像</h5><p>VAE模型怎么去生成一张图像？</p>
<ul>
<li><p>首先，从高斯分布中生成一个随机变量z，使得 $z\sim N(0,I)~$</p>
</li>
<li><p>让每个$z$ 去生成令一个正态分布 $N(\mu(z),\sigma(z))$</p>
</li>
<li>让 $x|z$ 服从正态分布 $N(\mu(z),\sigma(z))$ </li>
<li>$\mu,\sigma$ 两个函数可以用神经网络表示</li>
<li>因为z可以一直生成，因此理论上$p(x)$ 可以表示成无穷多个正态分布的mixture(即 $p(x) = \int p(z)p(x|z)dz$ ）。但事实上训练的图片是有限的，因此,  训练目标为最大化$\prod_xp(x)$或$\sum_x\log(p(x))$</li>
</ul>
<p><img src="/2021/12/16/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/17.png" style="zoom:100%;"></p>
<p>但事实上z不可能随机生成的，而是要根据我们的输入图片学习而来的(巧妇难为无米之炊)。放在数学层面上解释，就是我们要去寻找后验概率$p(z|x)$</p>
<p>这部分，就是自编码器中 <strong>decoder</strong> 的部分</p>
<h5 id="后验概率"><a href="#后验概率" class="headerlink" title="后验概率"></a>后验概率</h5><p>后验概率其实就是上述步骤反过来，扮演一个 encoder的部分</p>
<p>我们引入近似概率$q(z|x)$,使得：</p>
<ul>
<li>每个x生成一个正态分布 $N(\mu(x),\sigma(x))$</li>
<li>$z|x$ 服从正态分布$N(\mu(x),\sigma(x))$</li>
<li>$\mu,\sigma$ 两个函数可以用神经网络表示，使得 $q(z|x)$尽可能逼近$p(z)$</li>
</ul>
<p>将两部分放在一起看，如下所示</p>
<p><img src="/2021/12/16/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/18.png" style="zoom:100%;"></p>
<p>所以说，VAE和AE的原理是一样的，都是由图片生成向量，再由向量去还原图片。区别在于AE里面中间的向量是固定的，而VAE中间的向量是根据分布随机生成的。</p>
<h5 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h5><p>因为我们的目标是最大化$L = \sum_x\log p(x)$, 对于概率密度函数$p(x) = \int p(z)p(x|z)dz$ ，直接计算是不易处理的，因此我们需要用近似的方法将其变得更容易处理一点</p>
<script type="math/tex; mode=display">
\begin{align}
\log p(x) &= \log p(x)\int q(z|x)dz\\
&= \int q(z|x)\log p(x)dz\\
&=\int q(z|x)\log (\frac{p(z,x)}{p(z|x)}) dz\\
&=\int q(z|x)\log(\frac{p(z,x)}{q(z|x)}\frac{q(z|x)}{p(z|x)}) dz\\
&=\int q(z|x)\log(\frac{p(z,x)}{q(z|x)})dz+\int q(z|x)\log (\frac{q(z|x)}{p(z|x)})dz
\end{align}</script><p>其中，最后一式的第二部分是$KL$散度， 肯定是大于等于0的，因此</p>
<script type="math/tex; mode=display">
\log p(x) \geq \int q(z|x)\log (\frac{p(x|z)p(z)}{q(z|x)})dz</script><p>这个就是$\log p(x)$ 的下界，我们令其为 $L_b$。 因此，目标函数可以转化为 $L= \sum _x L_b$</p>
<p>下一步，我们知道了$L<em>b$的公式如下，我们就要去寻找$p(x|z)$和$q(z|x)$ ，求得$L_b$的极大似然估计，使得$\sum</em>{x}L_b$最大化</p>
<script type="math/tex; mode=display">
L_b = \int q(z|x) \log(\frac{p(x|z)p(z)}{q(z|x)})dz\\</script><script type="math/tex; mode=display">
\begin{align}
L_b& = \int q(z|x)\log p(x|z) dz + \int q(z|x) \log (\frac{p(z)}{q(z|x)})dz\\
&=\int q(z|x)\log(x|z)dz-\int q(z|x)\log(\frac{q(z|x)}{p(z)})dz\\
& = \text{E}_{q(z|x)}\log p(x|z)-D_{KL}(q(z|x)||p(z))
\end{align}</script><p>我们的目标是最大化前半部分$\text{E}_{q(z|x)}\log p(x|z)$ 重构图像概率，以及最小化后半部分后延概率分布$q(z|x)$和高斯分布$p(z)$之间的差异</p>
<h5 id="VAE-的训练"><a href="#VAE-的训练" class="headerlink" title="VAE 的训练"></a>VAE 的训练</h5><p><img src="/2021/12/16/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/19.png" style="zoom:100%;"></p>
<ul>
<li>最小化 $D<em>{KL}(q</em>\phi(z|x)|| p(z))$ , 即 $\max L<em>{q</em>\phi} = \sum_j 1+\log(\sigma_j^2)-\mu_j^2-\sigma_j^2$</li>
<li>最大化$E<em>{q</em>\phi}\log p<em>\theta(x|z)$ , 即 $\max L</em>{p<em>\theta} = \sum_l\log p</em>\theta(x|z_l)$ </li>
</ul>
<p>我们的目标方程也变成了：$L = \sum_iL_i$, 其中：</p>
<ul>
<li>$L<em>i = \frac{1}{2}L</em>{q<em>\phi}^i+\frac{1}{L}L</em>{p_\theta}^i$</li>
</ul>
<p>我们可以用随机梯度上升的方式来最大化$L$</p>
<h5 id="VAE-图像生成"><a href="#VAE-图像生成" class="headerlink" title="VAE 图像生成"></a>VAE 图像生成</h5><p>训练完毕后，我们已经得到了$q(z|x)$ ，因此可以扔掉 encoder，只保留decoder.</p>
<p>因为我们加了noise，所以对于连续空间里面的每一个随机向量z，都保留了一定的特征，因此都可以生成一张随机的图片。</p>
<p>Input 为：随机向量$z\sim N(0,I)$</p>
<p>Output为：一张随机图像</p>
<p>VAE效果如下</p>
<p><img src="/2021/12/16/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/20.png" style="zoom:100%;"></p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>VAE 的优点：</p>
<ul>
<li>显示计算图像生成概率，生成图像直接和原始图像进行比较，易于优化，训练稳定</li>
<li>相对于Pixel RNN 训练较快</li>
</ul>
<p>缺点：</p>
<ul>
<li>计算的是极大似然的下界</li>
<li>使用MSE计算原图和生成图像的差异，不能保证复原真实图片，导致生成图像比较模糊 </li>
</ul>
<p>这是因为，VAE只是通过采样正态分布来尝试记住真实图片的样子，将特征重新组合，并不是真正意义上生成新的图片</p>
<p><img src="/2021/12/16/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/21.png" style="zoom:100%;"></p>
<h2 id="隐式的概率密度"><a href="#隐式的概率密度" class="headerlink" title="隐式的概率密度"></a>隐式的概率密度</h2><p>当我们定义了显示的密度函数的话，就永远是根据已经存在的图片去生成新的图片。因此，还有一种方法是不定义显示的概率密度函数了，这样生成器就相当于从未见过真实的图片，只是根据Discriminator(鉴频器) 的反馈去不断逼近真实的图片，所以GAN也被认为是真正意义上的生成模型。</p>
<p>其原理如下所示：</p>
<p>Generator 直接从任何一个先验概率分布中生成图片，然后用一个<em>专家</em> 去判断这个图像是否是真的。直到专家无法分辨图像的真假的时候，就相当于生成了一张新的图片</p>
<p><img src="/2021/12/16/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/22.png" style="zoom:100%;"></p>
<h3 id="GAN"><a href="#GAN" class="headerlink" title="GAN"></a>GAN</h3><h4 id="非正式解释"><a href="#非正式解释" class="headerlink" title="非正式解释"></a>非正式解释</h4><p>用非正式的语言来解释一下Gan的原理：</p>
<p>我们把每一张图片当一个点去看。黑色的点代表训练数据点的分布，而绿色代表GAN模型生成图片的分布。蓝色的县代表生成数据点为真的概率</p>
<p><img src="/2021/12/16/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/23.png" style="zoom:100%;"></p>
<p>因此，我们可以看到，在一开始，数据点为真的概率是不断波动的，前半部分为1，后半部分为0(图2)。我们可以根据这个标准，让绿色的线不断逼近黑色的线，最后让它们重合。此时，蓝色的线停留在0.5处，也就是说，我不能鉴别这个绿色的点是真的还是假的图片。</p>
<h4 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h4><p><img src="/2021/12/16/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/25.png" style="zoom:100%;"></p>
<p>首先，给定一个假的随机向量，交给Generator生成图片，然后将生成图片和真图片共同交给 Discriminator去判断，给出真假判断。最后的训练目标就是，这个Discriminator没有办法区别生成的图片是真的还是假的。</p>
<h4 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h4><p>目标函数由两部分,如下：</p>
<p><img src="/2021/12/16/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/26.png" style="zoom:100%;"></p>
<p>第一部分是$\max_D$,即对Discriminator的训练，让其可以尽可能区分真假图片的这个目标。因此他希望对于真的图片，对其的判断要尽量接近于1；而对于生成的图片，要尽量判断出他是假的。因此优化目标是$D(G(z))$尽量接近0</p>
<p><img src="/2021/12/16/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/27.png" style="zoom:100%;"></p>
<p>第二部分是$\min_G$ ，也就是对Generator的训练，让他生成的图片尽可能的逼近真图片，也就是让$D(G(z))$ 尽量接近1</p>
<p><img src="/2021/12/16/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/28.png" style="zoom:100%;"></p>
<p>因此这就是为什么叫做生成对抗网络(GAN)了，因为两者的优化目的是相反的，一个是让 $D(G(z))$尽量接近0；另一个是让$D(G(z))$尽量接近1</p>
<h4 id="GAN-训练方法"><a href="#GAN-训练方法" class="headerlink" title="GAN 训练方法"></a>GAN 训练方法</h4><p>对于GAN，我们要训练n次。在每一次训练中，需要：</p>
<ul>
<li><p>迭代k次 Discriminator：</p>
<ul>
<li>抽取 n 个随机向量${z^{(1)},\cdots,z^{(m)}}\in p(z)$  组成 minibatch</li>
<li>抽取 n 个图像${x^{(1)},\cdots,x^{(m)}}$ 组成minibatch</li>
<li>使用SGA梯度上升算法更新Discriminator的参数：</li>
</ul>
<script type="math/tex; mode=display">
\nabla_{\theta_d}\frac{1}{m} \sum_{i=1}^m[\log D_{\theta_d}(x^{(i)})+\log(1- D_{\theta_d}\Big(G_{\theta_g}\Big(z^{(i)}\Big) )\Big)]</script></li>
<li><p>迭代一次 Generator：</p>
<ul>
<li><p>抽取 n 个随机向量${z^{(1)},z^{(2)},\cdots,z^{(m)} }\in p(z)$ 组成 minibatch</p>
</li>
<li><p>使用SGA 更新Generator的参数：</p>
<script type="math/tex; mode=display">
\nabla_{\theta_g} \frac{1}{m}\sum_{i=1}^m\log(D_{\theta_d}\Big(G_{\theta_g}\Big(z^{(i)}) \Big)\Big)</script></li>
</ul>
</li>
</ul>
<p>我们看到利用GAN生成的图片，每一张都是不一样的，而VAE和原图会比较相似</p>
<p><img src="/2021/12/16/%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/24.png" style="zoom:100%;"></p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>GAN的优点：</p>
<ul>
<li>GAN可以完美模拟真是数据分布(只要有足够多的图片)</li>
<li>Generator 根据 Discriminator 的反馈进行更新(不是尝试去记忆真实的图片)</li>
<li>生成图片的质量高</li>
</ul>
<p>GAN的缺点</p>
<ul>
<li>没有显示的概率密度函数，生成图像的可解释性比较差</li>
<li>训练具有不稳定性，即Generator 和 Discriminator 较难同步</li>
<li>需要足够的图片和足够的算力，不然可能需要算很久</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/12/16/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/16/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">循环神经网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-16 18:52:13" itemprop="dateCreated datePublished" datetime="2021-12-16T18:52:13+08:00">2021-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-12-30 10:23:02" itemprop="dateModified" datetime="2021-12-30T10:23:02+08:00">2021-12-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h1><p>循环神经网络和卷积神经网络处理的数据类型是不一样的。卷积神经网络可是用来处理矩阵类型的数据，而生活中有很多数据是序列型的，且没有固定的长度、大小。因此CNN并不是非常适合用来处理这些数据。</p>
<p>因此我们提出了 RNN (Recurrent Neural Networks)，其想法就是，采用重复的结构单元，每次输入序列里的一个数据，后面的结构单元能够记忆前面的输入信息。</p>
<h2 id="RNN的结构"><a href="#RNN的结构" class="headerlink" title="RNN的结构"></a>RNN的结构</h2><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>现在我们来看看一个简单的循环神经网络，它由输入层、隐藏层和输出层组成</p>
<p><img src="/2021/12/16/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/1.jpeg" style="zoom: 67%;"></p>
<p>我们现在这样来理解，如果把上面有W的那个带箭头的圈去掉，它就变成了最普通的<strong>全连接神经网络</strong>。x是一个向量，它表示<strong>输入层</strong>的值（这里面没有画出来表示神经元节点的圆圈）；s是一个向量，它表示<strong>隐藏层</strong>的值（这里隐藏层面画了一个节点，你也可以想象这一层其实是多个节点，节点数与向量s的维度相同）；</p>
<p>U是输入层到隐藏层的<strong>权重矩阵</strong>，o也是一个向量，它表示<strong>输出层</strong>的值；V是隐藏层到输出层的<strong>权重矩阵</strong>。</p>
<p>那么，现在我们来看看W是什么。<strong>循环神经网络</strong>的<strong>隐藏层</strong>的值s不仅仅取决于当前这次的输入x，还取决于上一次<strong>隐藏层</strong>的值s。<strong>权重矩阵</strong> W就是<strong>隐藏层</strong>上一次的值作为这一次的输入的权重。</p>
<p>如果我们把上面的图展开，<strong>循环神经网络</strong>也可以画成下面这个样子：</p>
<p><img src="/2021/12/16/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/2.jpeg" style="zoom: 67%;"></p>
<p>现在看上去就比较清楚了，这个网络在t时刻接收到输入 $x<em>t$ 之后，隐藏层的值是 $s_t $，输出值是$o_t$。关键一点是，$s_t $的值不仅仅取决于$x_t$，还取决于$s</em>{t-1}$。我们可以用下面的公式来表示<strong>循环神经网络</strong>的计算方法：</p>
<script type="math/tex; mode=display">
O_t = g(\boldsymbol V\cdot S_t)\\
S_t = f(\boldsymbol U\cdot X_t+ \boldsymbol W\cdot S_{t-1})</script><p>如果我们把式2反复带入式1，可得到:</p>
<script type="math/tex; mode=display">
\begin{align}
O_t &= g(V\cdot S_t)\\
&=Vf(U\cdot x_t+W\cdot S_{t-1})\\
&=Vf(U\cdot x_t+Wf(Ux_{t-1}+W\cdot S_{t-2}))\\
&=Vf(U\cdot x_t+Wf(Ux_{t-1}+W(f(Ux_{t-3}+\cdots))))
\end{align}</script><p>其中，最简单的$f(x)$是线性变换加激活，比如说 $f(x) = \tanh(U\cdot X<em>t+W\cdot S</em>{t-1})$ </p>
<p>因此我们说，隐藏层包含了过去的历史信息，用来预测下一时刻的目标</p>
<h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>在进行文本改写等情况下，可能会用到</p>
<p><img src="/2021/12/16/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/5.png" style="zoom: 67%;"></p>
<h4 id="多对一"><a href="#多对一" class="headerlink" title="多对一"></a>多对一</h4><p>比如说，在情感分类的时候，输入可能是一个句子，输出代表这个情感的类型或者情感的等级。那么这就是多对一的情况</p>
<p>又比如说，在输入一连串文本的时候，通过神经网络生成一张图像的场景</p>
<p><img src="/2021/12/16/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/3.png" style="zoom: 67%;"></p>
<h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><p>在看图说话这个应用场景中，输入一张图片，可能会有多个单词的输出。</p>
<p><img src="/2021/12/16/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/4.png" style="zoom: 67%;"></p>
<h4 id="特殊多对多"><a href="#特殊多对多" class="headerlink" title="特殊多对多"></a>特殊多对多</h4><p><img src="/2021/12/16/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/6.png" style="zoom: 67%;"></p>
<p>还有一种特殊的多对多循环神经网络，常常用来做机器翻译。比如输入的是红色框框代表的英语，经过循环神经网络处理，输出一个向量$h_T$,里面包含了这句话中所有的语义信息。然后，$h_T$ 作为下面一个循环神经网络序列的输入，解码器将这个向量输出成一个德语序列</p>
<p>这样设计的原因是，因为不同语言之间的语法结构是不同的，因此如果采用一边输入、一边输出的方式，会造成翻译不准确、语义丢失等情况</p>
<h4 id="多层RNN"><a href="#多层RNN" class="headerlink" title="多层RNN"></a>多层RNN</h4><p>上面说的RNN例子，都属于一层神经网络，只是在不断堆叠时间步。那么，要训练深层神经网络的话，仅靠一层RNN是不够的，因此提出了多层RNN结构</p>
<p><img src="/2021/12/16/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/13.png" style="zoom: 67%;"></p>
<p>从第二层开始，隐藏层的生成是通过本层上一时刻的权重矩阵和上层本时刻的权重矩阵共同生成的。即：</p>
<script type="math/tex; mode=display">
S_t^l = \tanh W^l
\begin{pmatrix} s_{t}^{l-1} \\ s_{t-1}^l \end{pmatrix}\\
\text{l代表层数,t代表时刻}</script><h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><h4 id="BPTT"><a href="#BPTT" class="headerlink" title="BPTT"></a>BPTT</h4><p>学习博客：<a href="https://blog.csdn.net/lzw66666/article/details/113132149?utm_source=app&amp;app_version=4.20.0" target="_blank" rel="noopener">https://blog.csdn.net/lzw66666/article/details/113132149?utm_source=app&amp;app_version=4.20.0</a></p>
<p>BPTT（back-propagation through time）算法是常用的训练RNN的方法，其实本质还是BP算法，只不过RNN处理时间序列数据，所以要基于时间反向传播，故叫随时间反向传播。BPTT的中心思想和BP算法相同，沿着需要优化的参数的负梯度方向不断寻找更优的点直至收敛。综上所述，BPTT算法本质还是BP算法，BP算法本质还是梯度下降法，那么求各个参数的梯度便成了此算法的核心。</p>
<p>首先，我们还是要看这张图：</p>
<p><img src="/2021/12/16/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/2.jpeg" style="zoom: 67%;"></p>
<p>一共有三个权重矩阵： $\boldsymbol {U,V,W}$ 需要在反向传播中更新</p>
<script type="math/tex; mode=display">
O_t = g(\boldsymbol V\cdot S_t)\\
S_t = f(\boldsymbol U\cdot X_t+ \boldsymbol W\cdot S_{t-1})</script><p>反向传播的计算说到底分三部分：1. 定义损失函数 2. 求出损失函数对参数的偏导数 3. 更新参数</p>
<h5 id="定义损失函数"><a href="#定义损失函数" class="headerlink" title="定义损失函数"></a>定义损失函数</h5><p>假设在时刻 $t$ 的损失函数为：</p>
<script type="math/tex; mode=display">
L_t = \frac{1}{2}(Y_t - O_t)^2</script><p>损失函数可以用均方误差、Softmax，这里用的是前者</p>
<p>因为有多个时刻，所以总损失函数为所有时刻的损失函数之和：$L = \sum_{t=0}^T{L_t}$</p>
<h5 id="求损失函数对参数的偏导"><a href="#求损失函数对参数的偏导" class="headerlink" title="求损失函数对参数的偏导"></a>求损失函数对参数的偏导</h5><ol>
<li>我们来看最主要的权重(参数)矩阵：$\boldsymbol W$, 在RNN中的每一时刻都出现了，因此 $\boldsymbol W$ 在时刻t的梯度 等于<strong>时刻t的损失函数</strong>对所有时刻的 $\boldsymbol W$ 的<strong>梯度和</strong></li>
</ol>
<script type="math/tex; mode=display">
\frac{\partial L_t}{\partial \boldsymbol W} = \sum_{s=0}^T \frac{\partial L_t}{\partial \boldsymbol W_s}</script><ol>
<li><p>将 $\frac{\partial L_t}{\partial \boldsymbol W}$ 带入损失函数，可得$\boldsymbol W$ 的总梯度 $\frac{\partial L}{\partial \boldsymbol W}$ 等于$\boldsymbol W$ 在所有时刻的梯度和</p>
<script type="math/tex; mode=display">
\frac{\partial L}{\partial \boldsymbol W} = \sum_{t=0}^T\frac{\partial L_t}{\partial w} \\
=\sum_{t=0}^T\sum_{s=0}^T\frac{\partial L_t}{\partial w_s}</script></li>
<li><p>有了梯度，我们就可以用来更新参数了</p>
</li>
</ol>
<script type="math/tex; mode=display">
\boldsymbol W = \boldsymbol W-\alpha\frac{\partial L }{\partial \boldsymbol W}</script><p>以上三步就是针对参数$\boldsymbol W$ 的反向传播</p>
<h4 id="truncated-BPTT"><a href="#truncated-BPTT" class="headerlink" title="truncated BPTT"></a>truncated BPTT</h4><p>但是BPTT有个问题，当输入序列边长的时候，BPTT非常容易出现梯度爆炸和梯度消失的问题。因此，为了缓解这个问题，有人突出了 TBPTT，也就是前向传播 $k_1$ 步，然后反向传播$k_2$步，通过这个方式使得传播序列变短。通常$k_1=k_2 &lt; n$ </p>
<p><img src="/2021/12/16/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/31.png" style="zoom: 67%;"></p>
<h2 id="RNN的应用"><a href="#RNN的应用" class="headerlink" title="RNN的应用"></a>RNN的应用</h2><h3 id="训练语言模型"><a href="#训练语言模型" class="headerlink" title="训练语言模型"></a>训练语言模型</h3><p>RNN的一大应用就是来构建语言模型. 它捕捉了一些人类语言的语法结构和语义信息，能够进行生成文字、自动回复等功能。现在我们用最简单的例子(character-level )来看一下模型是怎么被训练的.</p>
<p>我们用的语料库就是一个单词： hello； 词汇表为 [h,e,l,o]；</p>
<p>我们用 独热编码来编写词汇，输入到循环神经网络中，通过权重计算、激活，得到隐藏层如下：</p>
<p><img src="/2021/12/16/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/7.png"></p>
<p>现在，隐藏层需要输出一个值，这个值就代表当前时刻输入值的下一个预测值。输出值和输入值的维度需要保持一致。在这个例子中，输出一个长度为4的向量，每个值代表词汇表中对应词出现的概率。</p>
<p>推理过程如下图所示：</p>
<p><img src="/2021/12/16/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/8.png" style="zoom:120%;"></p>
<p>如果我们使用莎士比亚的著作当做语料库，基于character-level 训练，那么只要给神经网络输入一个字母，他就会自己写一部莎士比亚风格的著作了</p>
<h3 id="其他例子"><a href="#其他例子" class="headerlink" title="其他例子"></a>其他例子</h3><ul>
<li>此外，RNN还可以用来写诗，比如说：</li>
</ul>
<p><img src="/2021/12/16/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/9.png" style="zoom:120%;"></p>
<ul>
<li>用来写代码，用整个 linux 内核来训练，虽然肯定有语法错误。更多的是像 tabline 一样给出代码提示，或者是代码的克隆检测、代码分类等。</li>
</ul>
<p><img src="/2021/12/16/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/10.png" style="zoom:100%;"></p>
<ul>
<li>使用多对多神经网络，也常常被IDE用来进行代码纠错：</li>
</ul>
<p><img src="/2021/12/16/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/11.png" style="zoom: 67%;"></p>
<p>前面讲的都是自然与语言处理相关的内容，其实RNN在cv里面的应用也十分广泛。比如说看图说话：</p>
<p><img src="/2021/12/16/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/12.png" style="zoom: 67%;"></p>
<p>其原理如下图所示，首先输入图像，由CNN处理后，提取特征，然后变成RNN的输入向量：</p>
<p><img src="/2021/12/16/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/14.png" style="zoom: 67%;"></p>
<p>但这个模型并不是百分百正确的，会出现很多识别错误的例子。</p>
<p>因此，我们可以引入注意力机制，提高RNN的识别率：</p>
<p>在没有引入注意力机制的时候，读入的是一个长度为D的特征 。那么现在，我们让CNN训练一张图片，得到一个 $L\times D$ 的矩阵(即feature map)，一共L行，每行代表图片里的L个区域，如下所示：</p>
<p><img src="/2021/12/16/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/15.png" style="zoom: 67%;"></p>
<ul>
<li><p>作为输入$h_0$，一般是一个向量，我们可以通过平均池化的方式获得。这样D列就会变成一个长度为D的向量，作为整个图片的特征向量</p>
</li>
<li><p>然后，通过 $L\times D$  和 $h_0$ (长度为D)相乘，可以得到一个长度为 $L$ 的向量。</p>
<ul>
<li>将$L$里面的元素进行一个softmax求出加权特征向量$Z_1$——里面的每一个元素就是对这一个区域的注意力分数。</li>
<li>将这个$Z_1$ 向量作为$h_1$ 的输入，为其指明观察的方向。</li>
</ul>
</li>
<li>在$h_1$ 输出了预测值straw以后，由 $h_1$和feature map相乘，softmax后得到$Z_2$。并将$Z_2$和$h_1$得到的输出值straw 共同输入到 $h_2$ 。 $h_2$ 预测值又将和$Z_3$ 共同输入给 $h_3$ 预测，以此类推</li>
</ul>
<p><img src="/2021/12/16/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/17.png" style="zoom: 67%;"></p>
<p>$a_i$ 代表  feature map 里面的第i行特征</p>
<p>$\alpha_{ti}$ 代表t时刻的这个注意力向量的第i个注意力分数</p>
<p>在没有引入注意力机制的时候，每次输入的特征是一样的；但是引入了注意力机制的话，相当于，每一个时间节点，都会要求RNN去观察图片中的一个重点的区域。如下图所示：</p>
<p><img src="/2021/12/16/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/16.png" style="zoom: 67%;"></p>
<p>此外，这里还提到了 soft attention 和 hard attention，前者是说，直接保留输出的注意力分数，而后者是确立一个阈值，将超过阈值的注意力分数置为1，否则设为0。</p>
<h2 id="RNN的缺点及解决办法"><a href="#RNN的缺点及解决办法" class="headerlink" title="RNN的缺点及解决办法"></a>RNN的缺点及解决办法</h2><p>RNN 是有一个非常明显的缺点的——训练长数据的时候容易出现梯度爆炸和梯度消失的问题。为了搞明白这个问题。在前面，我们已经学习了前向传播和BPTT，现在我们再来复习一下：</p>
<p>前向传播公式：</p>
<script type="math/tex; mode=display">
O_t = g(\boldsymbol V\cdot S_t)\\
S_t = f(\boldsymbol U\cdot X_t+ \boldsymbol W\cdot S_{t-1})</script><p>这里我们为了简化，就不添加偏置项了</p>
<p>我们用三次循环为例，示意图如下：</p>
<p><img src="/2021/12/16/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/30.jpeg"></p>
<p>现在来计算前向传播的 $s_1,s_2,s_3,o_1,o_2,o_3$</p>
<script type="math/tex; mode=display">
s_1 = f(\boldsymbol Ux_1+\boldsymbol W s_0)~~~~~o_1 = g(\boldsymbol Vs_1)\\
s_2 = f(\boldsymbol Ux_2+\boldsymbol W s_1)~~~~~o_2 = g(\boldsymbol Vs_2)\\
s_3 = f(\boldsymbol Ux_3+\boldsymbol W s_2)~~~~~o_2 = g(\boldsymbol Vs_3)\\</script><p>现在来计算 $t=3$ 时刻，损失函数$L_3$ 对 $\boldsymbol {U、V、W}$ 的偏导</p>
<script type="math/tex; mode=display">
\begin{align}
&\frac{\partial L_3}{\partial \boldsymbol V} = \frac{\partial L_3}{\partial S_3}\frac{\partial S_3}{\partial \boldsymbol V}\\
&\frac{\partial L_3}{\partial \boldsymbol U} = \frac{\partial L_3}{\partial O_3}\frac{\partial O_3}{\partial \boldsymbol U}+\frac{\partial L_3}{\partial O_3}\frac{\partial O_3}{\partial S_3}\frac{\partial S_3}{\partial S_2}\frac{\partial S_2}{\partial  \boldsymbol U}+\frac{\partial L_3}{\partial O_3}\frac{\partial O_3}{\partial S_3}\frac{\partial S_3}{\partial S_2}\frac{\partial S_2}{\partial S_1}\frac{\partial S_1}{ \boldsymbol U} \\
&\frac{\partial L_3}{\partial \boldsymbol W} = \frac{\partial L_3}{\partial O_3}\frac{\partial O_3}{\partial \boldsymbol W}+\frac{\partial L_3}{\partial O_3}\frac{\partial O_3}{\partial S_3}\frac{\partial S_3}{\partial S_2}\frac{\partial S_2}{\partial  \boldsymbol W}+\frac{\partial L_3}{\partial O_3}\frac{\partial O_3}{\partial S_3}\frac{\partial S_3}{\partial S_2}\frac{\partial S_2}{\partial S_1}\frac{\partial S_1}{ \boldsymbol W}
\end{align}</script><p>根据上述推导，我们可以得出在任意时刻 $t$, $L$ 对 $\boldsymbol {U,V,W}$ 的偏导公式，以$W$为例：</p>
<script type="math/tex; mode=display">
\frac{\partial L_t}{\partial W} = \sum_{k=0}^t \frac{\partial L_t}{\partial O_t}\frac{\partial O_t}{\partial S_t}(\prod_{j=k+1}^t\frac{\partial S_j}{\partial S_{j-1}})\frac{\partial S_j}{\partial \boldsymbol W}</script><p>我   $S<em>j = \tanh(\boldsymbol Ux_i+\boldsymbol WS</em>{j-1})$ ，那么 $\frac{\partial S<em>j}{\partial S</em>{j-1}} = \tanh’ \boldsymbol W$ ，而$\prod<em>{j=k+1}^t\frac{\partial S_j}{\partial S</em>{j-1}}=\boldsymbol W^t\cdot\prod_{j=k+1}^t \tanh’$ </p>
<p>从上式可知，在回传梯度的时候，我们需要连续不断地乘以 $\boldsymbol W$ </p>
<script type="math/tex; mode=display">
W= Q\Lambda Q^{-1}\rightarrow (W)^n = Q\Lambda^n Q^{-1}</script><p>因此，当特征值大于1的时候，只要循环次数过多，就会造成梯度爆炸</p>
<p>同理，当特征值小于1的时候，只要循环次数过多，会造成梯度消失</p>
<h3 id="梯度裁剪"><a href="#梯度裁剪" class="headerlink" title="梯度裁剪"></a>梯度裁剪</h3><p>为了解决这个问题，我们们可以用梯度裁剪的方法。当特征值&gt;1,造成梯度爆炸、或者梯度的L2范数过大的时候，我们需要对梯度进行缩小</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grad_norm = np.sum(grad*grad)</span><br><span class="line"><span class="keyword">if</span> grad_norm &gt; threshold:</span><br><span class="line">	grad *= (threshold / grad_norm)</span><br></pre></td></tr></table></figure>
<h3 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h3><p>学习博客： <a href="https://www.jianshu.com/p/9dc9f41f0b29" target="_blank" rel="noopener">https://www.jianshu.com/p/9dc9f41f0b29</a></p>
<p>但是梯度裁剪对于梯度消失的情况效果并不好，因此我们需要使用更高级的结构，也就是长短期记忆(Long short-Term Memory, LSTM) </p>
<p>因为在RNN中主要是 $h_i$会出现梯度爆炸和梯度消失，在LSTM中就主要做了一项中间步骤，使得回传以后$h$不再是永远为$W^T$，从而避免了梯度爆炸、和消失的问题</p>
<h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p>所有 RNN 都具有一种重复神经网络模块的链式的形式。在标准的 RNN 中，这个重复的模块只有一个非常简单的结构，例如一个 <code>tanh</code> 层。 LSTM 同样是这样的结构，但是重复的模块拥有一个不同的结构。不同于 单一神经网络层，这里是有四个，以一种非常特殊的方式进行交互。</p>
<p>LSTM 的关键就是<strong>细胞状态 $C_t$</strong>，水平线在图上方贯穿运行。</p>
<p>细胞状态类似于传送带。直接在整个链上运行，只有一些少量的线性交互。信息在上面流传保持不变会很容易。</p>
<p><img src="/2021/12/16/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/24.jpg"></p>
<p>LSTM 有通过精心设计的称作为“门”的结构来去除或者增加信息到细胞状态的能力。门是一种让信息选择式通过的方法。他们包含一个 <code>sigmoid</code> 神经网络层和一个按位的乘法操作。</p>
<p><img src="/2021/12/16/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/25.jpg"></p>
<p>Sigmoid 层输出0到1之间的数值，描述每个部分有多少量可以通过。 0代表“不许任何量通过”，1 就指“允许任意量通过”</p>
<p>LSTM 拥有三个门，来保护和控制细胞状态。</p>
<h4 id="逐步理解-LSTM"><a href="#逐步理解-LSTM" class="headerlink" title="逐步理解 LSTM"></a>逐步理解 LSTM</h4><p>LSTM一开始需要计算4个向量：</p>
<ul>
<li>i : input gate , 控制在 $c_t$ 中写入哪些信息</li>
<li>f : forget gate , 控制从$c_{t-1}$  中擦除哪些信息</li>
<li>o : output gate ，控制从$c_t$输出哪些信息</li>
<li>g：激活输入</li>
</ul>
<p><img src="/2021/12/16/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/21.png"></p>
<h5 id="决定丢弃信息"><a href="#决定丢弃信息" class="headerlink" title="决定丢弃信息"></a>决定丢弃信息</h5><p>在LSTM中的第一步是决定我们会从细胞状态中丢弃什么信息。这个决定通过上面所说的 forget gate 完成。该门会读取$h<em>{t-1}$ 和$x_t$ ，并输出一个在0到1之间的数值给每个在细胞状态$C</em>{t-1}$中的数字。1表示完全保留而0代表完全舍弃。</p>
<p>计算公式如下：</p>
<script type="math/tex; mode=display">
f_t = \sigma(W_f\cdot[h_{t-1},x_t]+b_f)</script><p><img src="/2021/12/16/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/26.png" style="zoom: 67%;"></p>
<h5 id="确定更新信息"><a href="#确定更新信息" class="headerlink" title="确定更新信息"></a>确定更新信息</h5><p>下一步，是确定什么样的新信息会被存放在细胞状态中。这里包含两个部分。第一，一个<code>sigmoid</code> 层(即input gate) 决定我们将要更新什么值。然后一个 <code>tanh</code>层(gate)创建一个新的候选值向量 $\widetilde C_t$. 这个向量将会被加入到细胞状态中。</p>
<p> 计算公式如下：</p>
<script type="math/tex; mode=display">
i_t = \sigma(W_i\cdot[h_{t-1},x_t]+b_i)\\
\widetilde C_t = \tanh (W_C\cdot[h_{t-1},x_t]+b_C)\\</script><p><img src="/2021/12/16/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/27.png" style="zoom: 67%;"></p>
<h5 id="更新细胞状态"><a href="#更新细胞状态" class="headerlink" title="更新细胞状态"></a>更新细胞状态</h5><p>现在是更新旧细胞状态的时间了，$C_{t-1}$ 更新为 $C_t$ 。</p>
<p>我们把旧状态 与 $f_t$ 相乘，来丢弃掉我们确定需要丢弃的信息。接着加上 $i_t*\widetilde C_t$,即新的候选值。</p>
<p>公式如下：</p>
<script type="math/tex; mode=display">
c_t = f_t\odot C_{t-1}+i_t\odot \widetilde C_t</script><p><img src="/2021/12/16/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/28.png" style="zoom: 67%;"></p>
<h5 id="输出信息"><a href="#输出信息" class="headerlink" title="输出信息"></a>输出信息</h5><p>最终，我们需要确定输出什么值。这个输出将会基于我们的细胞状态。</p>
<ul>
<li>首先，我们运行一个 <code>sigmoid</code> 来确定细胞状态的哪个部分将输出出去。得到输出门 output gate</li>
<li>接着，我们把细胞状态通过 <code>tanh</code>进行处理，得到一个 -1~1 之间的值，并将它和<code>sigmoid</code>的输出相乘。最终我们仅仅会输出我们确定输出的那部分。</li>
</ul>
<script type="math/tex; mode=display">
o_t = \sigma(W_o[h_{t-1},x_t]+b_o)\\
h_t = o_t * \tanh(C_t)</script><p><img src="/2021/12/16/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/29.png" style="zoom: 67%;"></p>
<h4 id="梯度回传"><a href="#梯度回传" class="headerlink" title="梯度回传"></a>梯度回传</h4><p> <strong>LSTM 中梯度的传播有很多条路径</strong>，$c<em>{t-1}\rightarrow c_t = f_t\odot c</em>{t-1}+i_t\odot \hat c_t$ 这条路径上只有<strong>逐元素相乘和相加</strong>的操作，梯度流最稳定；</p>
<p>但是在<strong>其他路径</strong>上，LSTM 的梯度流和普通 RNN 没有太大区别，照样会发生相同的权重矩阵反复连乘的情况，依然会爆炸或者消失。由于<strong>总的远距离梯度 = 各条路径的远距离梯度之和</strong>，即便其他远距离路径梯度消失了，只要保证有一条远距离路径（就是上面说的那条高速公路）梯度不消失，总的远距离梯度就不会消失（正常梯度 + 消失梯度= 正常梯度）。因此 LSTM 通过改善<strong>一条路径</strong>上的梯度问题拯救了<strong>总体的远距离梯度</strong> </p>
<p>同样，因为总的远距离梯度 = 各条路径的远距离梯度之和，高速公路上梯度流比较稳定，但其他路径上梯度有可能爆炸，此时总的远距离梯度 = 正常梯度 + 爆炸梯度 = 爆炸梯度，因此 <strong>LSTM 仍然有可能发生梯度爆炸</strong>。不过，由于 LSTM 的其他路径非常崎岖，和普通 RNN 相比多经过了很多次激活函数（导数都小于 1），因此 <strong>LSTM 发生梯度爆炸的频率要低得多</strong>。实践中仍然可以通过梯度裁剪来解决。</p>
<p><img src="/2021/12/16/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/22.png"></p>
<h3 id="GRU"><a href="#GRU" class="headerlink" title="GRU"></a>GRU</h3><p>GRU是对 LSTM的进一步简化</p>
<p><img src="/2021/12/16/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/23.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">计算机视觉-卷积神经网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-16 18:39:45" itemprop="dateCreated datePublished" datetime="2021-12-16T18:39:45+08:00">2021-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-25 22:51:20" itemprop="dateModified" datetime="2022-06-25T22:51:20+08:00">2022-06-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机视觉-卷积神经网络"><a href="#计算机视觉-卷积神经网络" class="headerlink" title="计算机视觉-卷积神经网络"></a>计算机视觉-卷积神经网络</h1><p>在<a href="https://jasonxqh.github.io/2020/11/24/卷积神经网路理论/">卷积神经网路理论</a>中，我们简单介绍了一下卷积神经网络的原理，现在我们来系统学习神经网络的相关知识。</p>
<h2 id="正向传播"><a href="#正向传播" class="headerlink" title="正向传播"></a>正向传播</h2><p>在 <a href="https://jasonxqh.github.io/2021/12/02/神经网络和反向传播/">神经网络和反向传播</a> 中，我们学习了全连接层，那么，全连接层有什么缺陷呢？</p>
<p>第一层假设是 $x\in \mathbb R^{100\times100\times 3}$ ，第二层假设有4096个神经元，那么这全连接一下，就需要第一层有$30000 \times 4096\approx 1.2\text{亿}$ 个参数，这是不能承受之重啊——因此我们需要用到新的方法。</p>
<p>其实我们也提出了解决的方法：</p>
<ul>
<li><p>局部pattern：每个神经元捕获局部pattern，以减少权重参数。相当于每个神经元<strong>各司其职</strong></p>
<p><img src="/2021/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/2.png" style="zoom:67%;"></p>
</li>
<li><p>相似pattern：功能相似的神经元可以共享权重参数，比如两个神经元都是处理鼻子特征的，那么可以使用一套参数</p>
<p><img src="/2021/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/1.png" style="zoom:67%;"></p>
</li>
<li><p>像素采样：可以通过压缩等方式，将像素下采样，以进一步减少参数数量</p>
</li>
</ul>
<p><img src="/2021/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/3.png" style="zoom:67%;"></p>
<h3 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h3><p>那么，把这三者结合起来，就是卷积神经网络的作用。首先，伸进网络最重要的就是理解卷积核(kernel/filter)的作用，卷积核就是一个权重矩阵(参数矩阵)，用来捕捉局部的特征，其深度和图像深度(信道数)是一样的。比如说 ,现在有一个 $32\times32\times3$ 的图像矩阵，卷积核一般很小，比如说$5\times 5$,那么其深度一定是3。</p>
<p>用这个卷积核和图像在$5\times 5\times3$的区域内做点积，这样就会得到一共75个值，然后<strong>将其求和</strong>，输出得到第一个神经元$a_1$ ，然后用ReLU函数激活——这整个过程就叫做一次卷积。这样一来，就避免了$32\times32\times3$的超大型权重矩阵，只需要一个小型权重矩阵即可。</p>
<p><img src="/2021/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/4.png" style="zoom:67%;"></p>
<p>此外，由于一张图片多次出现同一个特征，因此一个卷积核对图片做一次卷积是远远不够的，需要<strong>扫描</strong>整张图片。那么该隔远扫描一次呢？这个距离就叫做步长(stride)，一般这个长度不会超过3。横向扫描一遍，接着跳到下一行再扫描一遍。整张图扫描下来，像素就会<strong>缩水</strong>一点。</p>
<p>比如，对$32\times32\times3$的图片用$5\times 5\times3$的卷积核卷积一遍，就会得到一张$28\times28\times1$的图片：</p>
<p><img src="/2021/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/5.png" style="zoom:67%;"></p>
<p>但是，一张图片不仅仅只有这一个特征，因此我们需要多个卷积核共同作用，每一个卷积核捕获不同的特征(在训练神经网络的时候会自动学习到不同特征)最后得到k层activation map</p>
<p>因此我们要记住：卷积核的深度和输入图片的信道数有关，而activation maps的深度适合卷积核的个数有关的</p>
<p><img src="/2021/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/6.png" style="zoom:67%;"></p>
<h3 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h3><p>上面得到的activation maps其实就是一个卷积层，而对于这个卷积层，又会有其他卷积核对其进行卷积，最后达成对原始图片进行不断地降维的目标。</p>
<h4 id="FC层-vs-卷积层"><a href="#FC层-vs-卷积层" class="headerlink" title="FC层 vs 卷积层"></a>FC层 vs 卷积层</h4><p>现在我们来看看全连接层(仿射层/FC层)和卷积层的对比。为了方便，我们拿$5\times5\times1$的输入图像作为例子；全连接层拿9个神经元作为例子，卷积核以$3\times3\times1$为例</p>
<p>如果是全连接层，要得到一个神经元的输入值，需要每个位置的像素点和权重做乘积后求和，那么这一层就一共需要$5\times5\times9=225$个参数。但是对于卷积层来说，不是一行一行去做卷积的，而是一个区域一个区域去做卷积。因此对整张图扫描一遍后会得到$3\times3\times1$的卷积层，同样是九个神经元。但是，因为使用同一个卷积核，其参数是不会变的——9个，也就是卷积核的大小。要达到和仿射层一样的参数水平，我们需要用到25个卷积核，但一般来说并不需要那么多捕捉特征的卷积核。</p>
<p>因此通过权重共享和局部全连接两种方式，可以明显减少参数的数量。</p>
<p><img src="/2021/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/7.png" style="zoom:67%;"></p>
<p>那么，如果当stride取2的时候，对于上述例子，一共只需要输出4个神经元就可以了，为后续减少了更多负担(当然也不可避免的失去一些信息)</p>
<h4 id="Zero-Padding"><a href="#Zero-Padding" class="headerlink" title="Zero Padding"></a>Zero Padding</h4><p>细心的同学们可能发现，图像边缘的像素做的卷积次数要比图像中间像素做的要少很多。因此有可能导致边缘的pattern无法被卷积核有效捕捉。为了解决这个问题，我们可以用0对图像的边缘进行补充，使得整张图片都位于图像里面：</p>
<p><img src="/2021/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/8.png"></p>
<p>比如说，对于$N\times N$ 的图片，$F\times F$的卷积核，步长为1，padding为1，最终得到的activation map 的边长为：</p>
<script type="math/tex; mode=display">
(N+1\times2-F)/1+1</script><p>这是因为，padding会给图像的左右两边同时加上一列，因此我们要乘以2.</p>
<p>事实上，由于卷积核的大小不同，为了保持卷积后activation map的大小不变，一般我们会取不同的padding。</p>
<ul>
<li>当F=3, padding 大小可取1， $2\times1-3=-1$</li>
<li>当F=5, padding 大小可取2， $2\times2-5=-1$</li>
<li>当F=7, padding 大小可取3， $2\times3-7=-1$</li>
</ul>
<h4 id="Activation-Maps"><a href="#Activation-Maps" class="headerlink" title="Activation Maps"></a>Activation Maps</h4><p>现在我们来做一个小练习：考虑两层的卷积神经网络。输入层图像的大小为$32\times 32\times3$, 第一层一共有6个$7\times7 \times3$的卷积核，第二层是10个$5\times5\times6$的卷积核。第一层有大小为2的padding，两层的stride均为1。请给出每层的activation maps的大小、深度, 以及每一层参数的个数。</p>
<p>首先，我们计算第一个activation maps的边长：</p>
<script type="math/tex; mode=display">
(32+2\times2-7)/1+1=30</script><p>第一个activation maps的深度等于该层卷积核的个数，也就是6</p>
<p>因此，第一个activation map的大小为：$30\times30\times6$</p>
<p>参数个数为<strong>卷积核的个数</strong> 乘以 <strong>卷积核的大小加上偏置项(一般为1)</strong>，即 $6\times(7\times7\times3+1)=888$</p>
<p>然后计算第二层activation maps的边长：</p>
<script type="math/tex; mode=display">
(30-5)/1+1=26</script><p>第二层activation maps的深度等于该层卷积核的个数，也就是10</p>
<p>因此，第二个activation maps的大小为：$26\times26\times10$</p>
<p>参数个数为$10\times(5\times5\times 6+1)=1510$ </p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>现在我们对卷积层做一个小结，并总结出一套通用的计算公式</p>
<ul>
<li>设当前层的输入矩阵为： $W_1\times H_1\times D_1$</li>
<li>设置4个必要的超参数：<ul>
<li>filter的个数$K$, 大小(边长)为 $F$, 因此可以确定有 $K$ 个偏置项</li>
<li>stride的大小为$S$</li>
<li>Zero padding的数量为 $P$</li>
</ul>
</li>
</ul>
<p>那么由上述数据，我们可以计算得到下一层的 activation maps 的大小为:</p>
<ul>
<li>$W_2 = \frac{W_1-F+2P}{S}+1$</li>
<li>$H_2=\frac{H_1-F+2P}{S}+1$</li>
<li>$D_2=K$</li>
</ul>
<p>第 d 个activation map是第d个filter与输入层做卷积后的结果(每个卷积都加上第d个偏置量)</p>
<p>最后，我们给出常用的超参数设置：</p>
<ul>
<li>K=32,64,128,256 ……</li>
<li>F=3,S=1,P=1</li>
<li>F=5,S=1,P=1或2</li>
<li>F=5,S=2,P=满足整除的数</li>
<li>F=1,S=1,P=0 (这个就相当于全连接，但是参数都是一样的)</li>
</ul>
<h3 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h3><p>池化（Pooling）：也称为欠采样或下采样。主要用于<strong>特征降维</strong>，压缩数据和参数的数量，减小过拟合，同时提高模型的容错性。因为卷积过后 activation map可能还是具有较强的线性，使用池化可以有效降低这种线性</p>
<p>一般来说，每隔几个 Conv+ReLU 层后，会又一层 Pooling，以有效减小参数(像素采样)</p>
<p><img src="/2021/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/9.png"></p>
<p>那么池化层该怎么做呢？</p>
<p>Pooling就相当于一个<strong>没有参数的卷积核</strong>，它对activation map中的一部分区域做mean、sum或者max操作，得到新的map。比如说，Max Pooling就是取一个部分中的最大值：(实际意义就是保留最突出的特征)</p>
<p><img src="/2021/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/10.png"></p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>假设 Conv+ReLU层的输出为 $W_1\times H_1\times D_1$</p>
<ul>
<li><p>我们设置两个超参数</p>
<ul>
<li>filter的大小(边长)为 $F$ ，只需要一个没有参数的 filter</li>
<li>Stride 大小为 $S$ </li>
<li>一般不做padding</li>
</ul>
</li>
<li><p>一般，我们常用的设置为： </p>
<ul>
<li>$F=2,S=2$</li>
<li>$F=3,S=2$</li>
</ul>
</li>
<li><p>最后生成大小为 $W_2\times H_2\times D_2$的 feature maps</p>
<ul>
<li>$W_2 = \frac{W_1-F}{S}+1$</li>
<li>$H_2=\frac{H_1-F}{S}+1$</li>
<li>$D_2=D_1$</li>
</ul>
</li>
</ul>
<h3 id="FC层"><a href="#FC层" class="headerlink" title="FC层"></a>FC层</h3><p>当缩小到一定程度之后，我们对图像进行扁平化，将其压平成一列，并进行全连接，最后得到图像分类的结果</p>
<p><img src="/2021/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/11.png"></p>
<p>完整的CNN如下：</p>
<p><img src="/2021/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/12.png"></p>
<h2 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h2><p>反向传播我们倒过来看, 首先是池化层，然后是激活函数层(ReLU),最后看卷积层</p>
<h3 id="Max-Pooling"><a href="#Max-Pooling" class="headerlink" title="Max Pooling"></a>Max Pooling</h3><p>首先，最大池化的操作就是把一部分区域的最大值传给下一层。那么这就相当于<a href="https://jasonxqh.github.io/2021/12/02/神经网络和反向传播/#梯度流的常见模式">梯度流的常见模式</a>中的max gate。那么，在反向传播时，上游梯度就会回传到input最大的位置：</p>
<p><img src="/2021/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/13.png"></p>
<h3 id="ReLU"><a href="#ReLU" class="headerlink" title="ReLU"></a>ReLU</h3><p>ReLU的反向传播也很简单，如果输入层的像素大于0，那么就回传梯度，否则就回传0</p>
<p><img src="/2021/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/14.png"></p>
<h3 id="Conv"><a href="#Conv" class="headerlink" title="Conv"></a>Conv</h3><p>比较复杂的反向传播就是卷积层的反向传播，其实卷积层的反向传播也需要做一次卷积。</p>
<p>我们既要算权重的梯度，也要算输入的梯度</p>
<p>参考博客： <a href="https://www.cnblogs.com/pinard/p/6494810.html" target="_blank" rel="noopener">https://www.cnblogs.com/pinard/p/6494810.html</a></p>
<p>我们用一个例子来推导，然后再一般化得到公式：</p>
<p>假设我们 $l-1$ 层的输出值 $a^{l-1}$是一个$3\times 3$的矩阵，第$l$ 层的卷积核 $W^{l}$ 是一个$2\times2$的矩阵，步长为1，那么输出的矩阵边长大小为$(3-2)/1+1=2$ 。我们不考虑偏置项，则有：</p>
<script type="math/tex; mode=display">
a^{l-1}\times W^l = z^l</script><p>我们列出 $a,W,z$的矩阵表达式如下：</p>
<script type="math/tex; mode=display">
\begin{pmatrix} a_{11} & a_{12} & a_{13} \\ a_{21} & a_{22} & a_{23}\\a_{31}&a_{23}&a_{33} \end{pmatrix}*\begin{pmatrix}w_{11}&w_{12}\\w_{21}&w_{22} \end{pmatrix} = \begin{pmatrix}z_{11}&z_{12}\\z_{21}&z_{22} \end{pmatrix}</script><p>根据卷积的定义，我们很容易得出：</p>
<script type="math/tex; mode=display">
z_{11} = a_{11}w_{11}+a_{12}w_{12}+a_{21}w_{21}+a_{22}w_{22}\\
z_{12}= a_{12}w_{11}+a_{13}w_{12}+a_{22}w_{21}+a_{23}w_{22}\\
z_{21} = a_{21}w_{11}+a_{22}w_{12}+a_{31}w_{21}+a_{32}w_{22}\\
z_{22} = a_{22}w_{11}+a_{23}w_{12}+a_{32}w_{21}+a_{33}w_{22}</script><p>接着，我们模拟反向求导：</p>
<script type="math/tex; mode=display">
\nabla a^{l-1} = \frac{\partial J(\boldsymbol W,b)}{\partial a^{l-1}} = (\frac{\partial z^l}{\partial a^{l-1}})^T\frac{\partial J(\boldsymbol W,b)}{\partial z} = (\frac{\partial z^l}{\partial a^{l-1}})^T\delta^l</script><p>从上式可以看出，对于 $a^{l-1}$ 的梯度误差 $\nabla a^{l-1}$ ,等于第l层的梯度误差乘以 $\frac{\partial z^l}{\partial a^{l-1}}$ , 而 $\frac{\partial z^l}{\partial a^{l-1}}$ 对应上面的例子中相关联的 w 的值。假设我们的z矩阵对应的反向传播误差是 $\delta<em>{11},\delta</em>{12},\delta<em>{21},\delta</em>{22}$组成的$2\times 2$矩阵，则利用上面梯度的式子和4个等式，我们可以分别写出 $\nabla a^{l-1}$ 的9个标量梯度。</p>
<p>比如对于 $a<em>{11}$ 的梯度，由于在4个等始终，$a</em>{11}$只和$z_{11}$有关，从而我们有：</p>
<script type="math/tex; mode=display">
\nabla a_{11} = \delta_{11}w_{11}</script><p>以此类推，我们可以得到：</p>
<script type="math/tex; mode=display">
\begin{align}
&\nabla a_{12} = \delta_{11}w_{12}+\delta_{12}w_{11}\\
&\nabla a_{13} = \delta_{12}w_{12}\\
&\nabla a_{21} = \delta_{11}w_{21}+\delta_{21}w_{11} \\
&\nabla a_{22} = \delta_{11}w_{22}+\delta_{12}w_{21}+\delta_{21}w_{12}+\delta_{22}w_{11} \\
&\nabla a_{23} = \delta_{12}w_{22}+\delta_{22}w_{12}\\
&\nabla a_{31} = \delta_{21}w_{21}\\
&\nabla a_{32} = \delta_{21}w_{22}+\delta_{22}w_{21} \\
&\nabla a_{33} = \delta_{22}w_{22}\\
\end{align}</script><p>　这上面9个式子其实可以用一个矩阵卷积的形式表示，即：</p>
<script type="math/tex; mode=display">
\begin{pmatrix}0&0&0&0\\ 0&\delta_{11} & \delta_{12} & 0 \\ 0 & \delta_{21} & \delta_{22}&0\\0&0&0&0 \end{pmatrix}*\begin{pmatrix}w_{22}&w_{21}\\w_{12}&w_{11} \end{pmatrix} =\begin{pmatrix} \nabla a_{11} & \nabla a_{12} & \nabla a_{13} \\ \nabla a_{21} & \nabla a_{22} & \nabla a_{23}\\\nabla a_{31}&\nabla a_{23}&\nabla a_{33} \end{pmatrix}</script><p>为了符合梯度计算，我们在误差矩阵周围填充了一圈0，此时我们将<strong>卷积核翻转后</strong>和<strong>反向传播的梯度误差</strong>进行卷积，就得到了前一次的梯度误差。 </p>
<p>因此，我们可以将其一般化：</p>
<p>首先，在DNN中，我们知道$\delta^{l-1}$和 $\delta^{l}$(由后向前推)的递推关系为：</p>
<script type="math/tex; mode=display">
\delta^{l-1} = \frac{\partial J(\boldsymbol W,b)}{\partial z^{l-1}} = (\frac{\partial z^{l}}{\partial z^{l-1}})^T\frac{\partial J(\boldsymbol W,b)}{\partial z^{l-1}} = (\frac{\partial z^{l}}{\partial z^{l-1}})^T\delta^{l}</script><p>因此，要推得到 $\delta^{l-1}$ ，必须要先计算 $\frac{\partial z^l}{\partial z^{l-1}}$ </p>
<p>因为 $z^{l-1}$ 和$z^{l}$是前向传播得到的，其关系为：</p>
<script type="math/tex; mode=display">
z^l = a^{l-1}*\boldsymbol W^l +b^l = \sigma(z^{l-1})*\boldsymbol W^l+b^l</script><p>因此：</p>
<script type="math/tex; mode=display">
\frac{\partial z^l}{\partial z^{l-1}} = rot180(\boldsymbol W')\odot \sigma'(z^{l-1})</script><script type="math/tex; mode=display">
\delta^{l-1}=(\frac{\partial z^l}{\partial z^{l-1}})\delta^l =\delta^l*rot180(\boldsymbol W')\odot \sigma'(z^{l-1})</script><p>这里的式子其实和DNN的类似，区别在于对于含有卷积的式子求导时，卷积核被旋转了180度。即式子中的$rot180$，翻转180度的意思是上下翻转一次，接着左右翻转一次。在DNN中这里只是矩阵的转置。那么为什么呢？由于这里都是张量，直接推演参数太多了。我们以一个简单的例子说明为啥这里求导后卷积核要翻转。</p>
<h4 id="已知卷积层的-delta-l-，推导该层的W-b的梯度"><a href="#已知卷积层的-delta-l-，推导该层的W-b的梯度" class="headerlink" title="已知卷积层的$\delta^l$，推导该层的W,b的梯度"></a>已知卷积层的$\delta^l$，推导该层的W,b的梯度</h4><p>好了，我们现在已经可以递推出每一层的梯度误差$\delta^l$ 了，对于全连接层，可以按DNN的反向传播算法求该层W,b的梯度，而卷积层的W,b需要求出。</p>
<p>在第l层，某个卷积核矩阵 $\boldsymbol W$ 的导数可以表示如下：</p>
<script type="math/tex; mode=display">
\frac{\partial J(\boldsymbol W,b)}{\partial W_{pq}^l} = \sum_{i}\sum_j(\delta_{i,j}^la^{l-1}_{i+p-1,j+q-1})</script><p>假设输入的a是$4\times 4$矩阵，卷积核 $\boldsymbol W$是$3\times3$的矩阵，输出z是$2\times2$的矩阵，那么反向传播的z的梯度误差$\delta$ 也是$2\times 2$的矩阵。</p>
<p>那么根据上面的例子，我们有：</p>
<script type="math/tex; mode=display">
\frac{\partial J(\boldsymbol W,b)}{\partial \boldsymbol W_{11}^l} = a_{11}\delta_{11}+a_{12}\delta_{12}+a_{21}\delta_{21}+a_{22}\delta_{22}\\
\frac{\partial J(\boldsymbol W,b)}{\partial \boldsymbol W_{12}^l} = a_{12}\delta_{11}+a_{13}\delta_{12}+a_{22}\delta_{21}+a_{23}\delta_{22}\\

\frac{\partial J(\boldsymbol W,b)}{\partial \boldsymbol W_{13}^l} = a_{13}\delta_{11}+a_{14}\delta_{12}+a_{23}\delta_{21}+a_{24}\delta_{22}\\
(...)</script><p>最终一共得到9个式子，整理后可得：</p>
<script type="math/tex; mode=display">
\frac{\partial J(\boldsymbol W,b)}{\partial \boldsymbol W^l} =\begin{pmatrix}a_{11}&a_{12}&a_{13}&a_{14}\\ a_{21}&a_{22} & a_{23} & a_{24} \\ a_{31} & a_{32} & a_{33}&a_{34}\\a_{41}&a_{42}&a_{43}&a_{44} \end{pmatrix}*\begin{pmatrix}\delta_{11}&\delta_{12}\\\delta_{21}&\delta_{22} \end{pmatrix}</script><p>从而可以清楚的看到这次我们为什么没有反转的原因。</p>
<p>而对于b,则稍微有些特殊，因为$\delta^l$是高维张量，而$b$只是一个向量，不能像DNN那样直接和$\delta^l$相等。通常的做法是将$\delta^l$的各个子矩阵的项分别求和，得到一个误差向量，即为$b$的梯度</p>
<script type="math/tex; mode=display">
\frac{\partial J(\boldsymbol W,b)}{\partial b^l} =\sum_{u,v}(\delta^l)_{u,v}</script><h4 id="总结CNN"><a href="#总结CNN" class="headerlink" title="总结CNN"></a>总结CNN</h4><p>现在我们总结下CNN的反向传播算法，以最基本的批量梯度下降法为例来描述反向传播算法。</p>
<p>输入：m个图片样本，CNN模型的层数L和所有隐藏层的类型，对于卷积层，要定义卷积核的大小K，卷积核子矩阵的维度F，填充大小P，步幅S。对于池化层，要定义池化区域大小k和池化标准（MAX或Average），对于全连接层，要定义全连接层的激活函数（输出层除外）和各层的神经元个数。梯度迭代参数迭代步长$\alpha$,最大迭代次数MAX与停止迭代阈值$\epsilon$</p>
<p>输出：CNN模型各隐藏层与输出层的𝑊,𝑏</p>
<p><img src="/2021/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/15.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/12/06/Django%E5%AD%A6%E4%B9%A02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/" class="post-title-link" itemprop="url">Django学习2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-06 18:39:25" itemprop="dateCreated datePublished" datetime="2021-12-06T18:39:25+08:00">2021-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-17 21:20:18" itemprop="dateModified" datetime="2022-01-17T21:20:18+08:00">2022-01-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Django学习2"><a href="#Django学习2" class="headerlink" title="Django学习2"></a>Django学习2</h1><h3 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h3><p>我们为了保留第一部分代码，因此新开一个文件夹，叫storefront2, 并在里面创建虚拟环境。</p>
<p>创建好以后，VSCode可能不会把该虚拟环境当做默认虚拟环境，因此我们需要设置一下：</p>
<p>command+p 并在搜索栏敲&gt; 呼出命令面板. 选择 python: select Interpreter选项，点击输入解释器路径，并输入当前文件夹下的虚拟环境的路径(通过pipenv shell可查看)，就设置完成了，如下图所示</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/1.png" style="zoom:67%;"></p>
<h2 id="Building-RESTful-APIs-with-Django-REST-Framework"><a href="#Building-RESTful-APIs-with-Django-REST-Framework" class="headerlink" title="Building. RESTful APIs with Django REST Framework"></a>Building. RESTful APIs with Django REST Framework</h2><h3 id="What-are-RESTful-APIs"><a href="#What-are-RESTful-APIs" class="headerlink" title="What are RESTful APIs"></a>What are RESTful APIs</h3><p>之前我们看到的数据只有Admin才有权限查看。现在我们要写一些接口，能让我们以非Admin的角色来获取数据库中的信息。这些接口就是API。打一个不恰当的比方，API就好像是电视遥控板中的一个按键。</p>
<p>RESTful API则是对API提出了一下几点要求</p>
<ul>
<li>Fast</li>
<li>Scalable</li>
<li>Reliable</li>
<li>Easy to understand</li>
<li>Easy to change</li>
</ul>
<p>首先，我们要了解一些基本概念：</p>
<h3 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h3><p>RESTful API 中的 Resources 概念就好像是我们在application中创建的对象一样。浏览器能通过 URL(Uniform Resource Locator) 访问到 Resources，URL就好像是这些资源的地址。</p>
<p>比如说，我想访问 products 数据，那么，我们的URL可以是这样的：<code>localhost:9000/products</code></p>
<p>或者，products中的具体数据,比如<code>localhost:9000/products/1</code></p>
<p>再者，Resources中也可能有Resources，比如说一个特定的产品有很多评测，那么url可以是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">localhost:9000&#x2F;products&#x2F;1&#x2F;reviews</span><br><span class="line">localhost:9000&#x2F;products&#x2F;1&#x2F;reviews&#x2F;1</span><br></pre></td></tr></table></figure>
<h3 id="Resource-Representations"><a href="#Resource-Representations" class="headerlink" title="Resource Representations"></a>Resource Representations</h3><p>当client用URL访问Resources的时候，后端就需要向客户回传这些Resources</p>
<p>一般，Resources 传给前端的格式是：HTML, XML, JSON。这些我们都比较熟悉了。</p>
<h3 id="HTTP-Methods"><a href="#HTTP-Methods" class="headerlink" title="HTTP Methods"></a>HTTP Methods</h3><p>HTTP主要有几种请求方法：</p>
<ul>
<li>GET: 用来获取数据</li>
<li>POST: 创建数据，比如<code>/products</code></li>
<li>PUT: 更新数据，如果要修改所有的对象，就要使用PUT, <code>/products</code></li>
<li>PATCH: 更新一部分数据, 比如只修改第一个对象，那么就要使用PATCH，<code>/products/1</code></li>
<li>DELETE：删除数据, 比如<code>/products/1</code></li>
</ul>
<h3 id="Installing-Django-REST-Framework"><a href="#Installing-Django-REST-Framework" class="headerlink" title="Installing Django REST Framework"></a>Installing Django REST Framework</h3><p>我们需要用这行代码下载Django REST Framework, 这样写起API就方便很多,</p>
<p><code>pipenv install djangorestframework</code> </p>
<p>下载完成后，我们要在APP中注册：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">'rest_framework'</span>,</span><br><span class="line">		<span class="comment">#...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="Creating-API-Views"><a href="#Creating-API-Views" class="headerlink" title="Creating API Views"></a>Creating API Views</h3><p>现在我们来创建 <code>127.0.0.1:9000/store/products</code> 对应的API</p>
<p>首先要明白，Django有自己的HttpRequest和HttpResponse模块，同时，Django Rest Framework也有自己的Request和Response模块。在这个项目中我们主要使用后两者，因为更方便，实现的功能也更强</p>
<p>其次，我们要把Django框架理解成层级访问，最高层就是我们创建的storefront，然后是storefront下面的各个注册的app，最后是app中的各种Object(Resources)。我们通过URL访问的时候，也是要”层级访问“</p>
<p><code>127.0.0.1:9000/</code> 访问的就是最顶层 storefront ，如果我们要访问storefront中的store，需要在storefront里面的<code>urls.py</code>注册<code>store/</code> ,如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">'playground/'</span>, include(<span class="string">'playground.urls'</span>)),</span><br><span class="line">    path(<span class="string">'store/'</span>, include(<span class="string">'store.urls'</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>再者，我们如果要访问store中的products对象，我们就需要在store里面的<code>urls.py</code> 中注册<code>products/</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line"><span class="comment"># URLConf</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'products/'</span>, views.product_list)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>最后，我们在view中编写api，来处理client通过URL这个“地址”发送来的请求：在这里，我使用了<em>rest_framework</em>中的<code>api_view</code>  这个修饰器，当api被<code>@api_view</code>修饰后，里面的request就会自动替换成<em>rest_framework</em> 中更简介、强大的request对象。</p>
<p>然后，我们用 <em>rest_framework</em> 中的 <code>Response</code> 来替换 <em>django.http</em> 中的<code>HttpResponse</code>,这样，返回的就是一个 <strong>Brosable API</strong>对象，非常简洁美观，一目了然：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> rest_framework.decorators <span class="keyword">import</span> api_view</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@api_view()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product_list</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Response(<span class="string">'OK'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/2.gif"></p>
<p>如果使用Django的HttpResponse，那么返回的仅仅是一个”OK”,但如果用的是<em>rest_framework</em> 的Response，就会显示我们的Http method， URL，以及Response的报文。同时，也可以以切换为json格式，查看浏览器真正会显示的画面，也就是”OK”</p>
<h4 id="product-details"><a href="#product-details" class="headerlink" title="product details"></a>product details</h4><p>接下来，我们再来创建一个API：product detail,用来访问每个Product特定的信息</p>
<p>首先我们编写 view: 功能很简单，从client发来的URL中找到参数id，然后返回这个id的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@api_view()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product_detail</span><span class="params">(request,id)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Response(id)</span><br></pre></td></tr></table></figure>
<p>然后，我们在urls.py中注册路由：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">  	<span class="comment">#...</span></span><br><span class="line">    path(<span class="string">'products/&lt;int:id&gt;/'</span>, views.product_detail)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>注意，因为我们访问的是每个product的编号，因此只能是整数类型，为了防止出现类似于<code>/store/products/1/</code>的非法请求出现，我们在注册路由的时候，要给参数id添加一个限制条件：<code>&lt;int:id&gt;</code></p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/3.gif"></p>
<h3 id="Creating-Serializers"><a href="#Creating-Serializers" class="headerlink" title="Creating Serializers"></a>Creating Serializers</h3><p>我们要将Object转换为浏览器可以处理的JSON格式的信息，首先我们需要 Serializer(序列化工具) 将这些对象信息 转换成字典，然后使用 REST Framework中的JSONRenderer模块将字典转换成JSON。</p>
<p>现在，我们就来学习如何创建一个Serializer，它的样子和models很像，只不过model负责的是和数据库<strong>对接</strong>，而serializer负责的是和client<strong>对接</strong>。然而，数据库中的某些信息我们是不希望用户去了解的，因此在<code>serializer</code>中一般不会提供产品的所有信息</p>
<p>首先我们要在store中创建<code>serializers.py</code> ,需要用到<em>rest_framework</em> 中的 <code>serializers</code> 模块.在下面这个网站中，有<code>serializers</code>提供的数据类型：</p>
<p><a href="https://www.django-rest-framework.org/api-guide/fields/" target="_blank" rel="noopener">https://www.django-rest-framework.org/api-guide/fields/</a></p>
<p>这里，我们只想用户开放了三个字段信息：产品id，产品名称以及产品单价。因此可以这么写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductSerializers</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    id = serializers.IntegerField()</span><br><span class="line">    title = serializers.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    unit_price = serializers.DecimalField(max_digits=<span class="number">6</span>, decimal_places=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Serializing-Objects"><a href="#Serializing-Objects" class="headerlink" title="Serializing Objects"></a>Serializing Objects</h3><p>在这个view中，我们要根据url中的id，从数据库中取出对象；然后，把这个对象交给<code>ProductSerializers</code> 去序列化，最后，把序列化后的数据传给Response，它会将其转换为JSON格式的文档回传给client</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Product</span><br><span class="line"><span class="keyword">from</span> .serializers <span class="keyword">import</span> ProductSerializers</span><br><span class="line"></span><br><span class="line"><span class="meta">@api_view()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product_detail</span><span class="params">(request, id)</span>:</span></span><br><span class="line">    product = Product.objects.get(pk=id)</span><br><span class="line">    serializers = ProductSerializers(product)</span><br><span class="line">    <span class="keyword">return</span> Response(serializers.data)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/4.png"></p>
<p>我们看到<code>unit_price</code> 是字符串类型的，我们需要设置一下将其变为数字类型：在setting.py中加入如下设置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'COERCE_DECIMAL_TO_STRING'</span>: <span class="literal">False</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，参数如果正确的话，是能从数据库中获取信息的，但是，如果参数是0呢？Django会报错，而不是返回一个显示错误信息的JSON文档。对此，我们有两种解决方法：</p>
<ul>
<li>用<em>rest_framework</em>中的 <code>status</code> 模块</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@api_view()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product_detail</span><span class="params">(request, id)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        product = Product.objects.get(pk=id)</span><br><span class="line">        serializers = ProductSerializers(product)</span><br><span class="line">        <span class="keyword">return</span> Response(serializers.data)</span><br><span class="line">    <span class="keyword">except</span> Product.DoesNotExist:</span><br><span class="line">        <span class="keyword">return</span> Response(status=status.HTTP_404_NOT_FOUND)</span><br></pre></td></tr></table></figure>
<ul>
<li>用<code>Django.shortcut</code> 中的 <code>get_object_or_404</code> 方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@api_view()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product_detail</span><span class="params">(request, id)</span>:</span></span><br><span class="line"></span><br><span class="line">    product = get_object_or_404(Product, pk=id)</span><br><span class="line">    serializer = ProductSerializer(product)</span><br><span class="line">    <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/5.png"></p>
<p>然后，我们再注册一个<code>store/products/</code> 路由，显示所有products信息。因此，我们可以用<code>get_list_or_404</code>,它是用来获取数据库中所有对象的方法，注意，当queryset中有很多元素的时候，需要设置 <code>many=True</code>,这样，serializer就会遍历queryset来执行操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@api_view()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product_list</span><span class="params">(request)</span>:</span></span><br><span class="line">    queryset = get_list_or_404(Product)</span><br><span class="line">    serializer = ProductSerializer(queryset, many=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure>
<h3 id="Creating-Custom-Serializer-Fields"><a href="#Creating-Custom-Serializer-Fields" class="headerlink" title="Creating Custom Serializer Fields"></a>Creating Custom Serializer Fields</h3><p>首先，我们要明白API Model是不等于Data Model的，后者是应用实现的一个部分，而前者是要给外界展示的一个部分。因此，展示的部分可以在model本身的基础上做一个计算，比如说，我们可以再Serializer里给product增加一个税后的价钱：</p>
<p>我们这里创建了一个计算税后价格的函数<code>calculate_tax</code>, 即把原价乘以1.1后返回(这里，由于1.1是浮点数，需要用<code>Decimal(1.1)</code>包裹一下)。然后， 再用<code>SerializerMethodField</code> 客制化，将<code>method_name</code>参数设定为我们自己写的函数的名称：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    id = serializers.IntegerField()</span><br><span class="line">    title = serializers.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    price = serializers.DecimalField(</span><br><span class="line">        max_digits=<span class="number">6</span>, decimal_places=<span class="number">2</span>, source=<span class="string">'unit_price'</span>)</span><br><span class="line">    price_with_tax = serializers.SerializerMethodField(</span><br><span class="line">        method_name=<span class="string">'calculate_tax'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate_tax</span><span class="params">(self, product: models.Product)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> product.unit_price * Decimal(<span class="number">1.1</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意了，这里我将<code>unit_price</code>改成了<code>price</code>,但是model中并没有这个字段，因此直接查询会报错。我们需要设定<code>source</code>参数为原来的字段</p>
</blockquote>
<h3 id="Serializing-Relationships"><a href="#Serializing-Relationships" class="headerlink" title="Serializing Relationships"></a>Serializing Relationships</h3><h4 id="使用serializers内置方法"><a href="#使用serializers内置方法" class="headerlink" title="使用serializers内置方法"></a>使用serializers内置方法</h4><p>如果我想在Serilizer中显示一对一关系、一对多关系。比如，我想在ProductSerializer中显示产品属于的集合类型,我可以使用 <code>PrimaryKeyRelatedField</code>这个方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> store.models <span class="keyword">import</span> Product, Collection</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">   	<span class="comment"># ...</span></span><br><span class="line">    collection = serializers.PrimaryKeyRelatedField(</span><br><span class="line">        queryset=Collection.objects.all()</span><br><span class="line">    )</span><br><span class="line">		<span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>有时候，系统会发生报错，这是因为检查机制出了点问题，可以通过重启解决</p>
</blockquote>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/6.png"></p>
<p>但是，显示数字显然是不够的，我们想要显示collection的名称信息,因此我们可以用<code>StringRelatedField</code>方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    collection = serializers.StringRelatedField()</span><br></pre></td></tr></table></figure>
<p>但这样虽然能显示collection字符串，但是对每个product都会额外多出一个关于Collection的查询，导致性能异常低下。为了解决这个bug，我们需要在view中修改一下：将原来个<code>get_list_or_404</code>改为<code>Product.objects.select_related(&#39;collection&#39;).all()</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@api_view()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product_list</span><span class="params">(request)</span>:</span></span><br><span class="line">    queryset = Product.objects.select_related(<span class="string">'collection'</span>).all()</span><br><span class="line">		<span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/7.png"></p>
<h4 id="使用嵌套的Serializer对象："><a href="#使用嵌套的Serializer对象：" class="headerlink" title="使用嵌套的Serializer对象："></a>使用嵌套的Serializer对象：</h4><p>除了上面这种方法，我们还可以使用嵌套对象的方法，能展示的数据更多：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    id = serializers.IntegerField()</span><br><span class="line">    title = serializers.CharField(max_length=<span class="number">255</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">		<span class="comment"># ...</span></span><br><span class="line">    collection = CollectionSerializer()</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/8.png"></p>
<h3 id="Model-Serializers"><a href="#Model-Serializers" class="headerlink" title="Model Serializers"></a>Model Serializers</h3><p>我们发现，现在创建的Serializers和Models是非常相似的。为了节省代码，增加代码的可维护性，我们可以使用<code>ModelSerializer</code>这个类：</p>
<p>使用了这个类之后，我们需要在里面创建Meta class，在 Meta中，我们要确定model的类型，并确定要放到ModelSerializer的字段, 即设置fields数组</p>
<p>如果我们想覆盖的话，我们可以自己写要呈现的内容。比如说<code>collection</code>，如果我不采用嵌套对象的方法，ModelSerializer会默认使用外键的值。</p>
<p>此外还可以自己加入model中没有的值，比如<code>price_with_tax</code>,这是我们自己写的一个字段，也可以加到fields中去</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Collection</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'title'</span>  ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Product</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'title'</span>, <span class="string">'unit_price'</span>, <span class="string">'price_with_tax'</span>, <span class="string">'collection'</span>]</span><br><span class="line">    price_with_tax = serializers.SerializerMethodField(</span><br><span class="line">        method_name=<span class="string">'calculate_tax'</span>)</span><br><span class="line">    collection = CollectionSerializer()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate_tax</span><span class="params">(self, product: Product)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> product.unit_price * Decimal(<span class="number">1.1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Deserializing-Objects"><a href="#Deserializing-Objects" class="headerlink" title="Deserializing Objects"></a>Deserializing Objects</h3><p>有了从server到client的对对象的序列化，那么就有对应从client到server的反序列化。比如说我想创建一个新的product，就要求sever反序列化得到client传入的关于新产品的信息，将它们变成一个对象。</p>
<p>我们知道，GET 方法是用来请求数据的，POST方法是用来更新数据的，我们现在在<code>product_list</code> 中实现一下两种方式的不同逻辑。</p>
<p>首先，在<code>@api_view</code>中要列出这个api能处理的HTTP METHOD的类型.这里是<code>[&#39;GET&#39;,&#39;POST&#39;]</code>.</p>
<p>然后，我们要设计<code>if-else</code> 来处理不同的请求。这里，如果是GET，就返回product列表，如果是POST我们要验证数据，并将合法的数据插入数据库，这里我们先不做验证，并直接返回OK作为测试</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@api_view(['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product_list</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        queryset = Product.objects.select_related(<span class="string">'collection'</span>).all()</span><br><span class="line">        serializer = ProductSerializer(</span><br><span class="line">            queryset, many=<span class="literal">True</span>, context=&#123;<span class="string">'request'</span>: request&#125;)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        serializer = ProductSerializer(data=request.data)</span><br><span class="line">        <span class="comment"># serializer.validated_data</span></span><br><span class="line">        <span class="keyword">return</span> Response(<span class="string">'OK'</span>)</span><br></pre></td></tr></table></figure>
<p>最后，我们把 <code>http://127.0.0.1:9000/store/products/</code> 拉到最后，然后随便输入一个JSON格式的文件，提交后我们就会看到 RESPONSE报文，其HTTP method为POST。</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/10.png"></p>
<h3 id="Data-Validation"><a href="#Data-Validation" class="headerlink" title="Data Validation"></a>Data Validation</h3><p>现在我们来学习数据验证相关的问题。</p>
<h4 id="if-else-block"><a href="#if-else-block" class="headerlink" title="if-else block"></a>if-else block</h4><p>这个逻辑是这样的，首先，serializer需要调用<code>is_valid()</code>函数，如果通过，那么对就可以对validated_data进行保存等操作；如果不通过，我们这里就返回<code>serializer.errors</code> ,并附上状态码400</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        serializer = ProductSerializer(data=request.data)</span><br><span class="line">        <span class="keyword">if</span> serializer.is_valid():</span><br><span class="line">            serializer.validated_data</span><br><span class="line">            <span class="keyword">return</span> Response(<span class="string">'OK'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)</span><br></pre></td></tr></table></figure>
<p>测试结果如下图所示：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/11.png"></p>
<h4 id="raise-exception-True"><a href="#raise-exception-True" class="headerlink" title="raise_exception=True"></a>raise_exception=True</h4><p>我们可以用一种更简单的方法来取代if-else逻辑：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">  serializer = ProductSerializer(data=request.data)</span><br><span class="line">  serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">  serializer.validated_data</span><br><span class="line">  <span class="keyword">return</span> Response(<span class="string">"OK"</span>)</span><br></pre></td></tr></table></figure>
<p>效果是一样的</p>
<p>现在，如果输入正确的信息，我们想将其在终端打印出来:（注意，这里要考虑好collection的类型，如果是对象的话，collection的值应该是一个字典。这里我使用的是默认的 <code>PrimaryKeyRelatedField</code>，因此只输入了一个INT值</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"title"</span>:<span class="string">"a"</span>,</span><br><span class="line">  <span class="attr">"unit_price"</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="attr">"collection"</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/12.png"></p>
<p>我们发现，在终端打印出来的<code>serializer.validated_data</code> 是一个OrderedDict</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OrderedDict([(&#39;title&#39;, &#39;a&#39;), (&#39;unit_price&#39;, Decimal(&#39;1.00&#39;)), (&#39;collection&#39;, &lt;Collection: collection1&gt;)])</span><br><span class="line">[08&#x2F;Dec&#x2F;2021 09:58:32] &quot;POST &#x2F;store&#x2F;products&#x2F; HTTP&#x2F;1.1&quot; 200 16875</span><br></pre></td></tr></table></figure>
<p><em>rest_framework</em> 只提供给我们数据类型、是否为空这类简单的数据验证，如果我们要设计更加复杂的验证方法，需要在serializer.py中自己实现函数如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, data)</span>:</span>  </span><br><span class="line">    <span class="keyword">if</span> data[<span class="string">'password'</span>] != data[<span class="string">'confirm_password'</span>]:</span><br><span class="line">        <span class="keyword">return</span> serializers.ValidationError(<span class="string">'passwords do not match'</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>
<h3 id="Saving-Objects"><a href="#Saving-Objects" class="headerlink" title="Saving Objects"></a>Saving Objects</h3><p>我们可以用 <code>ModelSerializer</code>中的<code>save</code>方法将浏览器发送过来的数据存入数据库</p>
<p>由于我们在创建的时候，inventory字段设置了最小值为1的验证器，因此我们需要把这些必填的值也加入到serializer中去：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Product</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'title'</span>, <span class="string">'description'</span>, <span class="string">'slug'</span>, <span class="string">'inventory'</span>,</span><br><span class="line">                  <span class="string">'unit_price'</span>, <span class="string">'price_with_tax'</span>, <span class="string">'collection'</span>]</span><br><span class="line">    price_with_tax = serializers.SerializerMethodField(</span><br><span class="line">        method_name=<span class="string">'calculate_tax'</span>)</span><br></pre></td></tr></table></figure>
<p>我们创建的产品如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"title"</span>:<span class="string">"a"</span>,</span><br><span class="line">  <span class="attr">"slug"</span>:<span class="string">"a"</span>,</span><br><span class="line">  <span class="attr">"unit_price"</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="attr">"collection"</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="attr">"inventory"</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提交后，Django就会保存了，非常方便</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/13.png"></p>
<h3 id="Updating-Objects"><a href="#Updating-Objects" class="headerlink" title="Updating Objects"></a>Updating Objects</h3><p>想要更新数据库中的信息，需要使用 PUT 或者PATCH 方法, 且需要对一个特定的product进行修改。因此，我们把这个逻辑封装在<code>product_detail</code> 这个api当中。</p>
<p>首先，我们还是要确定这个API负责的HTTP Method类型，这里，为了方便我们就只用PUT类型来更新数据</p>
<p>然后做一个方法判断，在PUT方法中，由于我们要对一个特定的数据进行修改，因此我们往<code>ProductSerializer</code>中传入的，不只是client递交过来的更新信息，还要这个目标对象的一个实例。因此，我们在if-else block之前就把product提取出来，然后传给<code>ProductSerializer</code>,返回一个更新后的product</p>
<p>接着就是对product进行数据验证，返回一个保存后的信息并保存</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@api_view(['GET', 'PUT'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product_detail</span><span class="params">(request, id)</span>:</span></span><br><span class="line">    product = get_object_or_404(Product, pk=id)</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        serializer = ProductSerializer(product)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">'PUT'</span>:</span><br><span class="line">        serializer = ProductSerializer(product, data=request.data)</span><br><span class="line">        serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        serializer.save()</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data,status=status.HTTP_201_CREATED)</span><br></pre></td></tr></table></figure>
<ul>
<li>递交前：</li>
</ul>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/14.png"></p>
<ul>
<li>递交后</li>
</ul>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/15.png"></p>
<p>我们发现，id=2的产品已经更新了。title前面多了个’+’ </p>
<h3 id="Deleting-Objects"><a href="#Deleting-Objects" class="headerlink" title="Deleting Objects"></a>Deleting Objects</h3><p>如果我们在<code>product_detail</code>中添加DELETE Method: <code>@api_view([&#39;GET&#39;, &#39;PUT&#39;,&#39;DELETE&#39;])</code></p>
<p>这时候，回到client，就会发现这里多出来一个DELETE按钮。这就是Brosable API带来的好处——方便简洁</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/16.png"></p>
<p>如果我们只写删除的逻辑，是会报错的，因为product是orderItem的外键，是保护关系。也就是说，如果不删除orderitem，就不能删除它引用的product。</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/18.png"></p>
<p>因此我们要这么处理逻辑，如果引用该产品的orderitem数量(用<code>product.orderitem_set</code>表示)大于0，我们就不能删除，并返回状态码 405，代表该方法对此情况不适用。如果等于0，那么放心删除，返回状态码204</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">elif request.method &#x3D;&#x3D; &#39;DELETE&#39;:</span><br><span class="line">        if product.orderitem_set.count() &gt; 0:</span><br><span class="line">            return Response(&#123;&#39;error&#39;: &#39;Product cannot be deleted because it is associated with orderitem&#39;&#125;,</span><br><span class="line">                            status&#x3D;status.HTTP_405_METHOD_NOT_ALLOWED)</span><br><span class="line">        product.delete()</span><br><span class="line">        return Response(status&#x3D;status.HTTP_204_NO_CONTENT)</span><br></pre></td></tr></table></figure>
<p>这样，如果起了冲突的话，就会收到这样的返回报文：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/19.png"></p>
<p>如果该product没有被引用过，就可以安全删除：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/17.png"></p>
<p>注意点：</p>
<p>在代码中，反向引用计算该产品的orderitem 可以用<code>product.orderitem_set</code> 来表示，但是这种表示不容易记住。我们可以通过修改<code>Orderitem</code>模型,在product字段中添加<code>related_name</code>属性来提高代码的可读性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderItem</span><span class="params">(models.Model)</span>:</span></span><br><span class="line"><span class="comment">#...</span></span><br><span class="line">    product = models.ForeignKey(</span><br><span class="line">        Product, on_delete=models.PROTECT, related_name=<span class="string">'orderitems'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> request.method == <span class="string">'DELETE'</span>:</span><br><span class="line">    <span class="keyword">if</span> product.orderitems.count() &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<h3 id="Exercise-Building-the-Collections-API"><a href="#Exercise-Building-the-Collections-API" class="headerlink" title="Exercise Building the Collections API"></a>Exercise Building the Collections API</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@api_view(['GET', 'POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">collection_list</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        queryset = Collection.objects.all()</span><br><span class="line">        serializer = CollectionSerializer(</span><br><span class="line">            queryset, many=<span class="literal">True</span>, context=&#123;<span class="string">'request'</span>: request&#125;)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        serializer = CollectionSerializer(data=request.data)</span><br><span class="line">        serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        serializer.save()</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data, status=status.HTTP_201_CREATED)</span><br><span class="line"></span><br><span class="line"><span class="meta">@api_view(['GET', 'PUT', 'DELETE'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">collection_detail</span><span class="params">(request, id)</span>:</span></span><br><span class="line">    collection = get_object_or_404(Product, pk=id)</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        serializer = CollectionSerializer(collection)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">'PUT'</span>:</span><br><span class="line">        serializer = CollectionSerializer(collection, data=request.data)</span><br><span class="line">        serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        serializer.save()</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data, status=status.HTTP_201_CREATED)</span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">'DELETE'</span>:</span><br><span class="line">        <span class="keyword">if</span> collection.products.count() &gt; <span class="number">0</span>:<span class="comment">#注意修改Product Model</span></span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'error'</span>: <span class="string">'Collection cannot be deleted because it is associated with products'</span>&#125;,</span><br><span class="line">                            status=status.HTTP_405_METHOD_NOT_ALLOWED)</span><br><span class="line">        collection.delete()</span><br><span class="line">        <span class="keyword">return</span> Response(status=status.HTTP_204_NO_CONTENT)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'products/'</span>, views.product_list),</span><br><span class="line">    path(<span class="string">'products/&lt;int:id&gt;/'</span>, views.product_detail),</span><br><span class="line">    path(<span class="string">'collections/'</span>, views.collection_list),</span><br><span class="line">    path(<span class="string">'collections/&lt;int:id&gt;/'</span>, views.collection_detail),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="Advanced-API-Concepts"><a href="#Advanced-API-Concepts" class="headerlink" title="Advanced API Concepts"></a>Advanced API Concepts</h2><p>在这一章我们将学习更多技术，帮助我们更快的编写API</p>
<h3 id="Class-based-Views"><a href="#Class-based-Views" class="headerlink" title="Class-based Views"></a>Class-based Views</h3><p>之前我们是单独创建View，即一个函数为单位进行对模型的操作。但是，如果是要处理很多HTTP Method的话，就会用到很多<code>if-else blocks</code> 这会让代码看起来非常杂乱。因此我们现在来学习 class-basesd Views</p>
<p>首先，要引入<code>APIView</code>, 然后，在这个类里面，我们可以定义各种方法的逻辑，每个方法写一个单独的函数。比如<code>def get</code>,<code>def post</code>. 函数内部的逻辑和之前if-else代码块内的逻辑是一致的。这样一来，我们就可以规避掉if-else的这种判断逻辑，让代码看起来更加整洁。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductList</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        queryset = Product.objects.select_related(<span class="string">'collection'</span>).all()</span><br><span class="line">        serializer = ProductSerializer(</span><br><span class="line">            queryset, many=<span class="literal">True</span>, context=&#123;<span class="string">'request'</span>: request&#125;)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        serializer = ProductSerializer(data=request.data)</span><br><span class="line">        serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        serializer.save()</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data, status=status.HTTP_201_CREATED)</span><br></pre></td></tr></table></figure>
<p>同理，我们也可以重写ProductDetail，但是注意了，因为要获取特定的product，所以需要在函数中再加一个参数：id</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductDetail</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, id)</span>:</span></span><br><span class="line">        product = get_object_or_404(Product, pk=id)</span><br><span class="line"></span><br><span class="line">        serializer = ProductSerializer(product)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, request, id)</span>:</span></span><br><span class="line">        product = get_object_or_404(Product, pk=id)</span><br><span class="line">        serializer = ProductSerializer(product, data=request.data)</span><br><span class="line">        serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        serializer.save()</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data, status=status.HTTP_201_CREATED)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, request, id)</span>:</span></span><br><span class="line">        product = get_object_or_404(Product, pk=id)</span><br><span class="line">        <span class="keyword">if</span> product.orderitems.count() &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'error'</span>: <span class="string">'Product cannot be deleted because it is associated with orderitem'</span>&#125;,</span><br><span class="line">                            status=status.HTTP_405_METHOD_NOT_ALLOWED)</span><br><span class="line">        product.delete()</span><br><span class="line">        <span class="keyword">return</span> Response(status=status.HTTP_204_NO_CONTENT)</span><br></pre></td></tr></table></figure>
<p>写完<code>class</code> 在url中还需要作相应修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URLConf</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'products/'</span>, views.ProductList.as_view()),</span><br><span class="line">    path(<span class="string">'products/&lt;int:id&gt;/'</span>, views.ProductDetail.as_view()),</span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h3><p>我们发现，对于Collection和Product，它们的view方法基本上是一模一样的。比如 product_list 和 collection_list的功能基本一样，就是从数据库中获取所有对象并返回；又比如 product_detail 和 collection_detail，都是访问特定的对象的具体信息。那么如此相同的逻辑，是否有一种方法可以将它们封装起来，我们就可以减少很多不必要的代码了。由此，我们来学习 Mixins(混合类)的概念。所谓混合类，顾名思义就是将很多操作都封装在一个类里面</p>
<p>首先，我们从 mixins的源码开始看起：混合类都放在<code>rest_framework.mixins</code>中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.mixins <span class="keyword">import</span> ListModelMixin,CreateModelMixin</span><br></pre></td></tr></table></figure>
<p>比如说，这个ListModelMixin，其源码如下所示，我们看到这个类中只有一个list函数。函数的逻辑和我们自己写的逻辑非常相似：首先，从数据库中创建一个queryset, 然后进行分页等操作，再送到Serializer中去序列化，并返回序列化后的数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListModelMixin</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    List a queryset.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">list</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        queryset = self.filter_queryset(self.get_queryset())</span><br><span class="line"></span><br><span class="line">        page = self.paginate_queryset(queryset)</span><br><span class="line">        <span class="keyword">if</span> page <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            serializer = self.get_serializer(page, many=<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">return</span> self.get_paginated_response(serializer.data)</span><br><span class="line"></span><br><span class="line">        serializer = self.get_serializer(queryset, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure>
<p>又比如说 CreateModelMixin: 里面的create函数逻辑和我们def put的逻辑一样。<br>首先把数据传入serializer创建序列化对象，然后进行数据验证，再进行保存操作，如果成功，最后返回HTTP 201</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateModelMixin</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Create a model instance.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        serializer = self.get_serializer(data=request.data)</span><br><span class="line">        serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        self.perform_create(serializer)</span><br><span class="line">        headers = self.get_success_headers(serializer.data)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perform_create</span><span class="params">(self, serializer)</span>:</span></span><br><span class="line">        serializer.save()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_success_headers</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">'Location'</span>: str(data[api_settings.URL_FIELD_NAME])&#125;</span><br><span class="line">        <span class="keyword">except</span> (TypeError, KeyError):</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>此外，还有几种 mixin：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>mixins</th>
<th>作用</th>
<th>对应http的请求方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mixins.ListModelMixin</td>
<td>定义list方法，返回一个queryset列表</td>
<td>GET</td>
</tr>
<tr>
<td>Mixins.CreateModelMixin</td>
<td>定义create方法，创建一个实例</td>
<td>POST</td>
</tr>
<tr>
<td>Mixins.RetrieveModelMixin</td>
<td>定义retrieve方法，返回一个具体的实例</td>
<td>GET</td>
</tr>
<tr>
<td>Mixins.UpdateModelMixin</td>
<td>定义update方法，对某个实例进行更新</td>
<td>PUT/PATCH</td>
</tr>
<tr>
<td>Mixins.DestroyModelMixin</td>
<td>定义delete方法，删除某个实例</td>
<td>DELETE</td>
</tr>
</tbody>
</table>
</div>
<p>在<a href="https://www.django-rest-framework.org/api-guide/generic-views/#mixins" target="_blank" rel="noopener">官网</a>上我们能找到更多信息</p>
<h3 id="Generic-Views"><a href="#Generic-Views" class="headerlink" title="Generic Views"></a>Generic Views</h3><p>在了解了mixins之后，我们需要再上一层，去了解Generic Views，也就是封装了Mixins的视图类。放在<code>rest_framework.generics</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from rest_framework.generics import ListCreateAPIView</span><br></pre></td></tr></table></figure>
<p>比如说，我们来看<code>ListCreateAPIView</code> 这个类。它里面封装了<code>ListModelMixin</code>和<code>CreateModelMixin</code> 这两个混合类，由此，我们可以用它来获取一个model中的所有对象信息，还可以创建新的对象。</p>
<p>此外，在这个类里面有 两个句柄函数(handler method)：get和post，get函数调用了从<code>ListModelMixin</code>继承下来的list方法；而post函数调用了从<code>CreateModelMixin</code>继承下来的<code>create</code>方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListCreateAPIView</span><span class="params">(mixins.ListModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                        mixins.CreateModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                        GenericAPIView)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Concrete view for listing a queryset or creating a model instance.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.list(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.create(request, *args, **kwargs)</span><br></pre></td></tr></table></figure>
<p>此外，在 <a href="https://www.django-rest-framework.org/api-guide/generic-views/" target="_blank" rel="noopener">官网</a> 上还有更多的Generic Views，比如<code>ListAPIView</code>,就仅仅提供get方法，而且是只读的；<code>RetrieveUpdateDestroyAPIView</code> 就提供 get,put,patch和delete四种方法。</p>
<p>那么，对于我们刚刚创建的 Class-based View ,我们就可以让它继承<code>ListCreateAPIView</code>类：由于里面已经封装了get和post函数。于是，我们只需要调用<code>get_queryset</code>和<code>get_serializer_class</code>这两个方法来获取queryset和serializer这两个对象就可以了。此外，为了让serializer获取到request的报文(这样就可以用其 去序列化、创建新对象)，我们需要使用<code>get_serializer_context</code> 方法，传入一个字典<code>{&#39;request&#39;: self.request}</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductList</span><span class="params">(ListCreateAPIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Product.objects.select_related(<span class="string">'collection'</span>).all()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_serializer_class</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> ProductSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_serializer_context</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'request'</span>: self.request&#125;</span><br></pre></td></tr></table></figure>
<p>我们甚至还能让这个类变得更简单。直接设置<code>queryset</code>和<code>serializer_class</code>这两个类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductList</span><span class="params">(ListCreateAPIView)</span>:</span></span><br><span class="line">    queryset = Product.objects.select_related(<span class="string">'collection'</span>).all()</span><br><span class="line">    serializer_class = ProductSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_serializer_context</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'request'</span>: self.request&#125;</span><br></pre></td></tr></table></figure>
<p>使用Generic View，不仅在保持原功能的情况下简化自己的代码，还会自己创建一张表单，方便我们创建新的product，我们再也不用苦逼的手写JSON了</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/21.png"></p>
<p>同样的，我们可以为Collection 创建  Generic Views. 如下所示：</p>
<p>这里，我们新加了一个字段<code>products_count</code>,用来统计有多少products属于该collection</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionList</span><span class="params">(ListCreateAPIView)</span>:</span></span><br><span class="line">    queryset = Collection.objects.annotate(</span><br><span class="line">        products_count=Count(<span class="string">'products'</span>)).all()</span><br><span class="line">    serializer_class = CollectionSerializer</span><br></pre></td></tr></table></figure>
<p>但是，当创建新的collection的时候，我希望products_count是一个只读的值，否则就乱了套了。因此，我们在<code>CollectionSerializer</code>里面，需要把products_count`设置为已读</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Collection</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'title'</span>, <span class="string">'products_count'</span>]</span><br><span class="line"></span><br><span class="line">    products_count = serializers.IntegerField(read_only=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>结果如下所示，我们可以看到collection中的<code>products_count</code>字段，但是要新建collection的话我们只能填写一个title字段：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/22.png"></p>
<h3 id="Customizing-Generic-Views"><a href="#Customizing-Generic-Views" class="headerlink" title="Customizing Generic Views"></a>Customizing Generic Views</h3><p>事实上我们可以客制化Generic Views。</p>
<p>对于ProductDetail这个View，我们需要用到 PUT、GET、DELETE这三个函数。其中，PUT和GET都是可以交给封装好的函数去执行的。但对于DELETE方法，我们写了自己的逻辑进去，就是要先做一个判断。</p>
<p>因此，我们不能用Generic View提供给我们的DELETE方法，需要自己重写DELETE，方法也很简单，就保留<code>def delete</code>即可。</p>
<p>修改完以后还没结束，运行会报错：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/23.png"></p>
<p>为了解决这个bug，我们可以修改url,把参数从id改为pk: <code>path(&#39;products/&lt;int:pk&gt;/&#39;, views.ProductDetail.as_view())</code>；或者在 <code>ProductDetail</code> 里面设置 <code>lookup_field</code>属性为id：<code>lookup_field=id</code>,这里我们选择前者</p>
<p>如果选择前者，那么在<code>delete</code>方法中，需要把参数id也改成pk，否则会导致参数不识别。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductDetail</span><span class="params">(RetrieveUpdateDestroyAPIView)</span>:</span></span><br><span class="line">    queryset = Product.objects.all()</span><br><span class="line">    serializer_class = ProductSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, request, pk)</span>:</span></span><br><span class="line">        product = get_object_or_404(Product, pk=pk)</span><br><span class="line">        <span class="keyword">if</span> product.orderitems.count() &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'error'</span>: <span class="string">'Product cannot be deleted because it is associated with orderitem'</span>&#125;,</span><br><span class="line">                            status=status.HTTP_405_METHOD_NOT_ALLOWED)</span><br><span class="line">        product.delete()</span><br><span class="line">        <span class="keyword">return</span> Response(status=status.HTTP_204_NO_CONTENT)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/24.gif"></p>
<p>现在，我们把CollectionDetail也修改一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionDetail</span><span class="params">(RetrieveUpdateDestroyAPIView)</span>:</span></span><br><span class="line"></span><br><span class="line">    queryset = Collection.objects.all()</span><br><span class="line">    serializer_class = CollectionSerializer</span><br><span class="line">		<span class="comment"># 记得修改url.py</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, request, pk)</span>:</span></span><br><span class="line">        collection = get_object_or_404(Collection, pk=pk)</span><br><span class="line">        <span class="keyword">if</span> collection.products.count() &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'error'</span>: <span class="string">'Collection cannot be deleted because it is associated with products'</span>&#125;,</span><br><span class="line">                            status=status.HTTP_405_METHOD_NOT_ALLOWED)</span><br><span class="line">        collection.delete()</span><br><span class="line">        <span class="keyword">return</span> Response(status=status.HTTP_204_NO_CONTENT)</span><br></pre></td></tr></table></figure>
<h3 id="ViewSets"><a href="#ViewSets" class="headerlink" title="ViewSets"></a>ViewSets</h3><p>我们来关注Product和Collection，这两个model都有两个Generic View——一个List用来取得所有信息，一个Detail来获得单独信息。在每个View里面，都需要定义queryset和serializer_class这两个属性，比较重复。因此，我们可以引入ViewSets(视图集)，顾名思义，他将很多view放在一个集合类里面，这个类提供了很多内置Minixs。这样，只需要确定一套queryset和serializer_class就能完成多个view的任务了。</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/25.png"></p>
<p>我们导入</p>
<p>然后来看看ModelViewSet的源码：<code>from rest_framework.viewsets import ModelViewSet</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelViewSet</span><span class="params">(mixins.CreateModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                   mixins.RetrieveModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                   mixins.UpdateModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                   mixins.DestroyModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                   mixins.ListModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                   GenericViewSet)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    A viewset that provides default `create()`, `retrieve()`, `update()`,</span></span><br><span class="line"><span class="string">    `partial_update()`, `destroy()` and `list()` actions.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>我们看到，<code>ModelViewSet</code>里面继承了很多Mixins，提供了很多http 方法，是一个<strong>集大成者</strong></p>
<p>由此，我们可以让<code>ProductViewSet</code>和<code>CollectionViewSet</code>  继承 <code>ModelViewSet</code>,如下所示。这样就把两个View集合为一个ViewSet了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    queryset = Product.objects.all()</span><br><span class="line">    serializer_class = ProductSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_serializer_context</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'request'</span>: self.request&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, request, pk)</span>:</span></span><br><span class="line">        product = get_object_or_404(Product, pk=pk)</span><br><span class="line">        <span class="keyword">if</span> product.orderitems.count() &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'error'</span>: <span class="string">'Product cannot be deleted because it is associated with orderitem'</span>&#125;,</span><br><span class="line">                            status=status.HTTP_405_METHOD_NOT_ALLOWED)</span><br><span class="line">        product.delete()</span><br><span class="line">        <span class="keyword">return</span> Response(status=status.HTTP_204_NO_CONTENT)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果希望ViewSet中的信息是只读的，我们可以使用ReadOnlyModelViewSet类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    queryset = Collection.objects.annotate(</span><br><span class="line">        products_count=Count(<span class="string">'products'</span>)).all()</span><br><span class="line">    serializer_class = CollectionSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, request, pk)</span>:</span></span><br><span class="line">        collection = get_object_or_404(Collection, pk=pk)</span><br><span class="line">        <span class="keyword">if</span> collection.products.count() &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'error'</span>: <span class="string">'Collection cannot be deleted because it is associated with products'</span>&#125;,</span><br><span class="line">                            status=status.HTTP_405_METHOD_NOT_ALLOWED)</span><br><span class="line">        collection.delete()</span><br><span class="line">        <span class="keyword">return</span> Response(status=status.HTTP_204_NO_CONTENT)</span><br></pre></td></tr></table></figure>
<p>我们还要注意，对于ProductList，CollectionList这些View，是不能提供DELETE函数的，否则会出现删库跑路的情况。我们想要的是，给每一个特定的对象(ProductDetail)提供删除服务。</p>
<p>因此，我们不应该重写delete方法(这是对Products全适用的删除函数)，而要重写destroy方法，它是用来删除一个单独的实例的。</p>
<p>在修改过程中，我们需要修改如下逻辑，因为在destroy方法中，已经有获取实例的逻辑了，我们不需要再访问一次数据库去获取product，因此，我们可以反向思考：查找OrderItem中的实例是否与该product相关联。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> product.orderitems.count() &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'error'</span>: <span class="string">'Product cannot be deleted because it is associated with orderitem'</span>&#125;,</span><br></pre></td></tr></table></figure>
<p>最终修改后如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    queryset = Product.objects.all()</span><br><span class="line">    serializer_class = ProductSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_serializer_context</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'request'</span>: self.request&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">destroy</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> OrderItem.objects.filter(product_id=kwargs[<span class="string">'pk'</span>]).count() &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">'error'</span>: <span class="string">'Product cannot be deleted because it is associated with orderitem'</span>&#125;,</span><br><span class="line">                            status=status.HTTP_405_METHOD_NOT_ALLOWED)</span><br><span class="line">        <span class="keyword">return</span> super().destroy(request, *args, **kwargs)</span><br></pre></td></tr></table></figure>
<p>修改完成后，程序是无法运行的，因为url并没有修改。那么，怎么让url定位到我们编写的ViewSet呢？我们接下来学习Routers路由的写法</p>
<h3 id="Routers"><a href="#Routers" class="headerlink" title="Routers"></a>Routers</h3><p>当我们使用ViewSet来集成View，就不用显式使用urlpatterns来注册url了。</p>
<h4 id="SimpleRouter"><a href="#SimpleRouter" class="headerlink" title="SimpleRouter"></a>SimpleRouter</h4><p>首先，我们导入DRF中的 routers 中的SimpleRouter类</p>
<p>然后，我们创建一个SimpleRouter实例，并将两个ViewSet注册进去</p>
<p>打印一下注册后router.urls支持的格式：发现router已经帮我们自动注册了四条 URLPattern</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ &lt;URLPattern &#39;^products&#x2F;$&#39; [name&#x3D;&#39;product-list&#39;]&gt;,</span><br><span class="line"> &lt;URLPattern &#39;^products&#x2F;(?P&lt;pk&gt;[^&#x2F;.]+)&#x2F;$&#39; [name&#x3D;&#39;product-detail&#39;]&gt;,</span><br><span class="line"> &lt;URLPattern &#39;^collections&#x2F;$&#39; [name&#x3D;&#39;collection-list&#39;]&gt;,</span><br><span class="line"> &lt;URLPattern &#39;^collections&#x2F;(?P&lt;pk&gt;[^&#x2F;.]+)&#x2F;$&#39; [name&#x3D;&#39;collection-detail&#39;]&gt;]</span><br></pre></td></tr></table></figure>
<p>最后，我们让 urlpatterns 等于 <code>router.urls</code> 也就是上面个数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.routers <span class="keyword">import</span> SimpleRouter,DefaultRouter</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line">router = SimpleRouter()</span><br><span class="line">router.register(<span class="string">'products'</span>, views.ProductViewSet)</span><br><span class="line">router.register(<span class="string">'collections'</span>, views.CollectionViewSet)</span><br><span class="line"></span><br><span class="line">urlpatterns = router.urls</span><br></pre></td></tr></table></figure>
<h4 id="DefaultRouter"><a href="#DefaultRouter" class="headerlink" title="DefaultRouter"></a>DefaultRouter</h4><p>如果我们使用的是 DefaultRouter 类，那么相比SimpleRouter会多出两个功能：</p>
<p>首先，如果我们访问 <code>http://127.0.0.1:9000/store/</code> 就会出现一个<strong>根目录</strong>，也就会展示出这个app下开放的api，如下图所示</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/26.png"></p>
<p>其次，如果我们访问<code>http://127.0.0.1:9000/store/products.json</code>,就会展示出所有products的JSON格式的文档信息：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/27.png"></p>
<h3 id="Building-the-Reviews-API"><a href="#Building-the-Reviews-API" class="headerlink" title="Building the Reviews API"></a>Building the Reviews API</h3><p>现在，我们要对product创建一个Review内容，即用户反馈。</p>
<p>首先，创建Review model</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Review</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    product = models.ForeignKey(</span><br><span class="line">        Product, on_delete=models.CASCADE, related_name=<span class="string">'reviews'</span>)</span><br><span class="line">    name = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    description = models.TextField()</span><br><span class="line">    date = models.DateField(auto_now_add=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>然后，创建相应的Serializer：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReviewSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Review</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'date'</span>, <span class="string">'name'</span>, <span class="string">'description'</span>, <span class="string">'product'</span>]</span><br></pre></td></tr></table></figure>
<p>接着，创建ViewSet</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReviewViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    queryset = Review.objects.all()</span><br><span class="line">    serializer_class = ReviewSerializer</span><br></pre></td></tr></table></figure>
<p>最后，注册路由，但是我们发现，Product和Review是一对多的关系，因此我们需要在检索单个product的url  <code>http://localhost:9000/store/products/1/</code> 后面，再加上对Review的检索。这就是我们接下来要学习的嵌套路由</p>
<h3 id="Nested-Routers"><a href="#Nested-Routers" class="headerlink" title="Nested Routers"></a>Nested Routers</h3><p>首先，我们需要下载实现嵌套路由的包： <code>pipenv install drf-nested-routers</code></p>
<p>具体教程在<a href="https://github.com/alanjds/drf-nested-routers" target="_blank" rel="noopener">https://github.com/alanjds/drf-nested-routers</a> 可以找到：</p>
<p>我们要实现的功能如下，前两行是通过domain pk找到单独的domain</p>
<p>第三行是找到关于此domain的所有nameservers</p>
<p>第四行是通过nameserver pk来找到关于此domain的特定的nameserver</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;domain&#x2F; &lt;- Domains list</span><br><span class="line">&#x2F;domain&#x2F;&#123;pk&#125;&#x2F; &lt;- One domain, from &#123;pk&#125;</span><br><span class="line">&#x2F;domain&#x2F;&#123;domain_pk&#125;&#x2F;nameservers&#x2F; &lt;- Nameservers of domain from &#123;domain_pk&#125;</span><br><span class="line">&#x2F;domain&#x2F;&#123;domain_pk&#125;&#x2F;nameservers&#x2F;&#123;pk&#125; &lt;- Specific nameserver from &#123;pk&#125;, of domain from &#123;domain_pk&#125;</span><br></pre></td></tr></table></figure>
<p>实现逻辑如下，首先，创建一个SimpleRouter实例，并注册domain，这都是前置操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># urls.py</span></span><br><span class="line"><span class="keyword">from</span> rest_framework_nested <span class="keyword">import</span> routers</span><br><span class="line"><span class="keyword">from</span> views <span class="keyword">import</span> DomainViewSet, NameserverViewSet</span><br><span class="line">(...)</span><br><span class="line"></span><br><span class="line">router = routers.SimpleRouter()</span><br><span class="line">router.register(<span class="string">'domains'</span>, DomainViewSet)</span><br></pre></td></tr></table></figure>
<p>接下来，我们要使用到上面导入的routers模块中的<code>NestedSimpleRouter</code>类，我们要传入三个参数：</p>
<ul>
<li>第一个参数是parent router,也就是之前注册的关于domain的路由；</li>
<li>第二个参数是子路由的前缀,也就是<code>http://localhost:9000/store/products/1/reviews/1/</code>中的<code>products</code></li>
<li>第三个参数是lookup查询参数，这个嵌套路由要先查询domain</li>
</ul>
<p>也就是说，这三个参数我们就可以理解为 父路由、”父类名+s”、loopup=”父类名”</p>
<p>然后，我们在这个<code>NestedSimpleRouter</code>中注册nameservers，和<code>NameserverViewSet</code>相对应。<br>basename 参数是一种名字模式,它是可选的，设置了这个参数以后，可以为我们提供命名View的选项。这里我们选择<code>domain-nameservers</code>, 那么就会自动生成两个name:<code>domain-nameservers-list</code>,<code>domain-nameservers-detail</code>。</p>
<p>最后，我们创建两个urlpattern</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">domains_router = routers.NestedSimpleRouter(router,  <span class="string">'domains'</span>, lookup=<span class="string">'domain'</span>)</span><br><span class="line">domains_router.register(<span class="string">'nameservers'</span>, NameserverViewSet, basename=<span class="string">'domain-nameservers'</span>)</span><br><span class="line"><span class="comment"># 'basename' is optional. Needed only if the same viewset is registered more than once</span></span><br><span class="line"><span class="comment"># Official DRF docs on this option: http://www.django-rest-framework.org/api-guide/routers/</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">''</span>, include(router.urls)),</span><br><span class="line">    path(<span class="string">''</span>, include(domains_router.urls)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>在我们这个项目中，可以这么写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">router = routers.DefaultRouter()</span><br><span class="line">router.register(<span class="string">'products'</span>, views.ProductViewSet)</span><br><span class="line">router.register(<span class="string">'collections'</span>, views.CollectionViewSet)</span><br><span class="line"></span><br><span class="line">products_router = routers.NestedDefaultRouter(</span><br><span class="line">    router, <span class="string">'products'</span>, lookup=<span class="string">'products'</span>)</span><br><span class="line">products_router.register(<span class="string">'reviews'</span>, views.ReviewViewSet,</span><br><span class="line">                         basename=<span class="string">'product-reviews'</span>)</span><br><span class="line"><span class="comment"># 我们可以不用显式注册url，直接+就可以</span></span><br><span class="line">urlpatterns = router.urls + products_router.urls</span><br></pre></td></tr></table></figure>
<p>这里，我们设置的<code>basename=&#39;product-reviews&#39;</code>, 能提供的url模板如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[&lt;URLPattern <span class="string">'^products/(?P&lt;products_pk&gt;[^/.]+)/reviews/$'</span> [name=<span class="string">'product-reviews-list'</span>]&gt;,</span><br><span class="line"> &lt;URLPattern <span class="string">'^products/(?P&lt;products_pk&gt;[^/.]+)/reviews\.(?P&lt;format&gt;[a-z0-9]+)/?$'</span> [name=<span class="string">'product-reviews-list'</span>]&gt;,</span><br><span class="line"> &lt;URLPattern <span class="string">'^products/(?P&lt;products_pk&gt;[^/.]+)/reviews/(?P&lt;pk&gt;[^/.]+)/$'</span> [name=<span class="string">'product-reviews-detail'</span>]&gt;,</span><br><span class="line"> &lt;URLPattern <span class="string">'^products/(?P&lt;products_pk&gt;[^/.]+)/reviews/(?P&lt;pk&gt;[^/.]+)\.(?P&lt;format&gt;[a-z0-9]+)/?$'</span> [name=<span class="string">'product-reviews-detail'</span>]&gt;,</span><br><span class="line"> <span class="comment"># 下面两个是上层路由，不用管</span></span><br><span class="line"> &lt;URLPattern <span class="string">'^$'</span> [name=<span class="string">'api-root'</span>]&gt;,</span><br><span class="line"> &lt;URLPattern <span class="string">'^\.(?P&lt;format&gt;[a-z0-9]+)/?$'</span> [name=<span class="string">'api-root'</span>]&gt;]</span><br></pre></td></tr></table></figure>
<p>结果如下，我们可以在<code>http://localhost:9000/store/products/&lt;id:pk&gt;/reviews/</code>中看到reviews信息，并且能创建新的review</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/28.png"></p>
<p>但这个程序存在bug，因为url中，是先检索product，再在这个product里面创建review，所以我们在创建的时候根本不需要填写product字段，这个字段的值应该有url中的参数来决定。但是，如果在serializer里面直接把product给去掉，是不可以的，因为product_id 这个字段名是必须的。对此，我们可以这样修改：</p>
<p>我们可以在 View中，利用<code>get_serializer_context</code>函数将需要的参数(这里是product_pk) 传递给serializer：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReviewViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    queryset = Review.objects.all()</span><br><span class="line">    serializer_class = ReviewSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_serializer_context</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'product_id'</span>: self.kwargs[<span class="string">'products_id'</span>]&#125;</span><br></pre></td></tr></table></figure>
<p>然后，在ReviewSerializer中，我们要重写create函数。我们从view那里传过来的context中获得了product_id，并获得了表单提交上来的validated_data，那么现在就集齐了创建一个新Review实例的所有信息。</p>
<p>我们可以调用<code>objects.create</code>方法，将这些信息传入，如下所示</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReviewSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Review</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'date'</span>, <span class="string">'name'</span>, <span class="string">'description'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self,validated_data)</span>:</span></span><br><span class="line">        product_id = self.context[<span class="string">'product_id'</span>]</span><br><span class="line">        Review.objects.create(product_id=product_id,**validated_data)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/29.gif"></p>
<p>但是，还是有一个bug，就是现在不管是哪个product，在<code>products/&lt;product_id&gt;/reviews/</code>界面都可以获取所有的review信息:比如上面这个gif，我在访问<code>product/3/</code>的时候能看到对product1的评论。<br>因此，我们要对其做一个筛选，只选择该products的Review信息</p>
<h3 id="Filtering"><a href="#Filtering" class="headerlink" title="Filtering"></a>Filtering</h3><p>接下来，我们就来学习如何根据url中的参数来筛选信息：</p>
<p>比如说，我想筛选collection4中所有的product，可以这样来写<code>http://localhost:9000/store/products/?collection_id=4</code></p>
<p>现在我们来实现这个功能。我们不能直接在queryset中调用<code>.filter()</code>,因为这时候参数没办法获取。因此我们要调用<code>get_queryset</code>来返回客制化的 queryset</p>
<p>首先，我们要确认默认queryset仍然是<code>Product.objects.all()</code>,因为当没有<code>/?collection_id=&lt;id&gt;</code>这个参数的时候，仍然需要返回所有的product。</p>
<p>然后，我们要从url的参数中获取<code>collection_id</code>的值。url中的参数都在<code>quert_params</code>中，也就是<code>self.request.query_params.get(&#39;collection_id&#39;)</code>。注意了这里我们需要用get函数，而不能直接写<code>query_params[&#39;collection_id&#39;]</code> 后者是默认参数一定存在的，如果不存在就会报错；而前者当参数不存在的时候，collection_id的值就为空(None)</p>
<p>如果collection_id非空，那么我们就在默认的<code>queryset</code>上调用<code>filter</code> 筛选出目标对象，最后返回queryset</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#views.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    serializer_class = ProductSerializer</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">        queryset = Product.objects.all()</span><br><span class="line">        collection_id = self.request.query_params.get(<span class="string">'collection_id'</span>)</span><br><span class="line">        <span class="keyword">if</span> collection_id <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            queryset = queryset.filter(collection_id=collection_id)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> queryset</span><br><span class="line">   <span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p>但仅仅修改View是不够的，系统会报错。原因是在<code>ProductViewSet</code>中我们删去了queryset属性，变成了<code>get_queryset</code>函数，而router是根据这个属性默认生成basename的。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AssertionError: `basename` argument not specified, and could not automatically determine the name from the viewset, as it does not have a `.queryset` attribute.</span><br></pre></td></tr></table></figure>
</blockquote>
<p>因此，我们对url.py也要做一定的修改，即给ProductViewSet注册的路由组一个basename参数(可以使products也可以是product)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#urls.py</span></span><br><span class="line">router = routers.DefaultRouter()</span><br><span class="line">router.register(<span class="string">'products'</span>, views.ProductViewSet, basename=<span class="string">'products'</span>)</span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p>效果如下图所示：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/30.gif"></p>
<h3 id="Generic-Filtering"><a href="#Generic-Filtering" class="headerlink" title="Generic Filtering"></a>Generic Filtering</h3><p>上面我们只筛选了一个collection字段，那么如果我们想筛选另外一个字段，是不是得改很多代码呢？这也太hard code了，因此我们现在来学习 Generic Filter</p>
<p>我们需要用到Django Filter 来帮助我们完成这个功能：<code>pipenv install django-filter</code>; 下载完后，记得在setting中注册：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">'django_filters'</span>,</span><br><span class="line">   <span class="comment">#...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>然后，我们在view中使用这个包，我们就不需要再调用<code>get_queryset</code>函数了，直接使用<code>queryset = Product.objects.all()</code>即可。</p>
<p>接着，我们引入<code>filter_backends = [DjangoFilterBackend]</code> ,并设置可供筛选的参数。这里除了collection_id还有unit_price可以选</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django_filters.rest_framework <span class="keyword">import</span> DjangoFilterBackend</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    queryset = Product.objects.all()</span><br><span class="line">    serializer_class = ProductSerializer</span><br><span class="line">    filter_backends = [DjangoFilterBackend]</span><br><span class="line">    filterset_fields = [<span class="string">'collection_id'</span>, <span class="string">'unit_price'</span>]</span><br></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/31.gif"></p>
<p>但这样筛选是不符合常理的，对于unit_price的筛选应该是一个区间而不是一个特定的值。因此，我们需要对其进行改进。在 <a href="https://django-filter.readthedocs.io/en/stable/" target="_blank" rel="noopener">django-filter文档</a>中我们可以获得答案</p>
<p>我们新建一个<code>filter.py</code>的文件，里面用来写自定义的筛选器：</p>
<ul>
<li>首先我们导入 FilterSet类，然后新建一个ProductFilter来继承这个类，</li>
<li>在这个类中，我们需要确定一些元数据: 确定该筛选器应用于哪个model，以及可供筛选的字段<ul>
<li>collection_id 这个字段不用改，因此我们就写<code>[&#39;exact&#39;]</code></li>
<li>unit_price 这个字段需要填写区间范围，因此可以这么写：<code>[&#39;gt&#39;, &#39;lt&#39;]</code> ,代表价格高于某个值或者低于某个值</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django_filters.rest_framework <span class="keyword">import</span> FilterSet</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Product</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductFilter</span><span class="params">(FilterSet)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Product</span><br><span class="line">        fields = &#123;</span><br><span class="line">            <span class="string">'collection_id'</span>: [<span class="string">'exact'</span>],</span><br><span class="line">            <span class="string">'unit_price'</span>: [<span class="string">'gt'</span>, <span class="string">'lt'</span>]</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>结果如下，非常方便，调试起来很快：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/32.gif"></p>
<h3 id="Searching"><a href="#Searching" class="headerlink" title="Searching"></a>Searching</h3><p>那么，对于title，description这样的字符串字段，我们就没有办法做一个筛选了，需要做查找。方法也很简单：</p>
<p>首先，我们可以使用<code>rest_framework.filters</code>中的SearchFilter模块</p>
<p>然后，在<code>filter_backends</code>中添加SearchFilter</p>
<p>最后，确定search_field属性即可，除了model本身的字段之外，还可以查找外键model的字段。查找不区分大小写，支持模糊查找，中间用逗号隔开即可，简直太方便了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.filters <span class="keyword">import</span> SearchFilter</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    queryset = Product.objects.all()</span><br><span class="line">    serializer_class = ProductSerializer</span><br><span class="line">    filter_backends = [DjangoFilterBackend, SearchFilter]</span><br><span class="line">    filterset_class = ProductFilter</span><br><span class="line">    search_fields = [<span class="string">'title'</span>, <span class="string">'description'</span>, <span class="string">'collection__title'</span>]</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/33.gif"></p>
<h3 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a>Sorting</h3><p>现在，我们还可以用filters中的OrderingFilter类帮助我们对 model进行筛选：</p>
<p>首先，我们导入<code>OrderingFilter</code></p>
<p>然后，把OrderingFilter 加到 filter_backends中去</p>
<p>最后，确定能排序的字段，即<code>ordering_fields</code> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.filters <span class="keyword">import</span> SearchFilter,OrderingFilter</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    queryset = Product.objects.all()</span><br><span class="line">    serializer_class = ProductSerializer</span><br><span class="line">    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]</span><br><span class="line">    filterset_class = ProductFilter</span><br><span class="line">    search_fields = [<span class="string">'title'</span>, <span class="string">'description'</span>, <span class="string">'collection__title'</span>]</span><br><span class="line">    ordering_fields = [<span class="string">'unit_price'</span>, <span class="string">'last_update'</span>]</span><br></pre></td></tr></table></figure>
<p>结果如下所示。我们发现，当对unit_price升序排列的时候，url为<code>/products/?ordering=unit_price</code> 而降序排列的时候，url为<code>/products/?ordering=-unit_price</code></p>
<p>而且，对于serializer没有提供的字段 <code>last_update</code>，也可以进行排序</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/34.gif"></p>
<h3 id="Pagination"><a href="#Pagination" class="headerlink" title="Pagination"></a>Pagination</h3><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><p>现在我们来讲分页，首先，引入pagination模块</p>
<p>然后设置<code>pagination_class</code>属性为<code>PageNumberPagination</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.pagination <span class="keyword">import</span> PageNumberPagination</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">    pagination_class = PageNumberPagination</span><br><span class="line">    <span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p>接着，我们在setting中确认每一页的数量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'COERCE_DECIMAL_TO_STRING'</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">'PAGE_SIZE'</span>: <span class="number">10</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如下图所示，现在已经可以实现分页了，每一页中还会告诉你总数、下一页的url和前一页的url，分页结果放在 results 数组当中：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/35.png"></p>
<p>如果我们想设置全部使用 Django Restful Framework的model都采用分页的方式呈现，可以这样设置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'COERCE_DECIMAL_TO_STRING'</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">'DEFAULT_PAGINATION_CLASS'</span>: <span class="string">'rest_framework.pagination.PageNumberPagination'</span>,</span><br><span class="line">    <span class="string">'PAGE_SIZE'</span>: <span class="number">10</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，我甚至不需要在view中规定<code>pagination_class = PageNumberPagination</code>也可以进行分页</p>
<h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><p>但是如果我们不想对所有model进行分页，但是在settings中规定了<code>PAGE_SIZE</code>属性的话，系统会给一个warning，意思是如果规定了<code>PAGE_SIZE</code>,你最好规定一下<code>DEFAULT_PAGE_CLASS</code>。</p>
<p>为了规避这个warning，我们可以自己实现：创建一个 pagination.py 文件:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pagination.py </span></span><br><span class="line"><span class="keyword">from</span> rest_framework.pagination <span class="keyword">import</span> PageNumberPagination</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefaultPagination</span><span class="params">(PageNumberPagination)</span>:</span></span><br><span class="line">    page_size = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>然后，在view中，将原本的<code>PageNumberPagination</code>改为<code>DefaultPagination</code> 即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">		<span class="comment">#...</span></span><br><span class="line">    pagination_class = DefaultPagination</span><br><span class="line">    <span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<h2 id="Designing-and-Implementing-a-Shopping-Cart-API"><a href="#Designing-and-Implementing-a-Shopping-Cart-API" class="headerlink" title="Designing and Implementing a Shopping Cart API"></a>Designing and Implementing a Shopping Cart API</h2><h3 id="Designing-the-API"><a href="#Designing-the-API" class="headerlink" title="Designing the API"></a>Designing the API</h3><p>现在我们来设计一个购物车的API，主要包含以下几个功能：创建购物车、访问购物车的内容、删除购物车、往购物车中添加物品，往购物车更新物品的数量，往购物车删除物品</p>
<ul>
<li>Create a Cart 对于路人，不一定要登录，也可以创建一个购物车</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>METHOD</th>
<th>url</th>
<th>request</th>
<th>Response</th>
</tr>
</thead>
<tbody>
<tr>
<td>POST</td>
<td>/carts/</td>
<td>{}</td>
<td>cart</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Getting a Cart</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>METHOD</th>
<th>url</th>
<th>request</th>
<th>Response</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>/carts/:id</td>
<td>{}</td>
<td>cart</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Deleting a Cart</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>METHOD</th>
<th>url</th>
<th>request</th>
<th>Response</th>
</tr>
</thead>
<tbody>
<tr>
<td>DELETE</td>
<td>/carts/:id</td>
<td>{}</td>
<td>{}</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Adding an Item </li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>METHOD</th>
<th>url</th>
<th>request</th>
<th>Response</th>
</tr>
</thead>
<tbody>
<tr>
<td>POST</td>
<td>/carts/:id/items</td>
<td>{prodId,qty}</td>
<td>item</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Updating an Item 这里，我们要更新的话，只需要修改购物车内物品的数量，因此，我们使用PATCH方法</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>METHOD</th>
<th>url</th>
<th>request</th>
<th>Response</th>
</tr>
</thead>
<tbody>
<tr>
<td>PATCH</td>
<td>/carts/:id/items/:id</td>
<td>{qty}</td>
<td>{qty}</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Deleting an item</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>METHOD</th>
<th>url</th>
<th>request</th>
<th>Response</th>
</tr>
</thead>
<tbody>
<tr>
<td>DELETE</td>
<td>/carts/:id/items/:id</td>
<td>{}</td>
<td>{}</td>
</tr>
</tbody>
</table>
</div>
<p>我们创建两个类，一个来负责购物车的API，称为<code>CartViewSet</code>，一个来负责购物车中物品的API,称为<code>CartItemViewSet</code></p>
<h3 id="Revisiting-the-Data-Model"><a href="#Revisiting-the-Data-Model" class="headerlink" title="Revisiting the Data Model"></a>Revisiting the Data Model</h3><p>首先，我们要知道，购物车是一个对用户比较较敏感的信息，不能轻易地被其他人获取到这个信息，因此我们需要使用到GUID，即Globally Unique Identifier。是一种由算法生成的二进制长度为128位的数字标识符</p>
<p>首先我们引入uuid4，然后重写Cart Model的 id为UUIDField，默认值为uuid的引用。注意，这里不能使用<code>default = uuid64()</code> 因为这样会导致在创建migration的时候就生成了一个UUID的值 ，进而导致所有的cart都会使用同一个UUID。</p>
<p>对于CartItem，我们也需要进行修改，首先，可以给ForeignKey添加一个<code>related_name</code>属性<br>其次，我们需要给数据库增加一个限制：我们不允许在同一个cart中，有多个products。如果用户往购物车中添加相同的product，只改变 quantity的值。要在数据库里添加这个数据，我们可以设置元数据中的<code>unique_together</code>属性</p>
<blockquote>
<p> 这个元数据是非常重要的一个！它等同于数据库的联合约束！</p>
<p>举个例子，假设有一张用户表，保存有用户的姓名、出生日期、性别和籍贯等等信息。要求是所有的用户唯一不重复，可现在有好几个叫“张伟”的，如何区别它们呢？（不要和我说主键唯一，这里讨论的不是这个问题）</p>
<p>我们可以设置不能有两个用户在同一个地方同一时刻出生并且都叫“张伟”，使用这种联合约束，保证数据库能不能重复添加用户（也不要和我谈小概率问题）。在模型中用<code>unique_together</code>，也就是联合唯一！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique_together &#x3D; [[&#39;name&#39;, &#39;birth_day&#39;, &#39;address&#39;]]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>在这里，我们只要设置两个值即可：<code>unique_together = [[&#39;cart&#39;, &#39;product&#39;]]</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cart</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    id = models.UUIDField(primary_key=<span class="literal">True</span>, default=uuid4)</span><br><span class="line">    created_at = models.DateTimeField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartItem</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    cart = models.ForeignKey(</span><br><span class="line">        Cart, on_delete=models.CASCADE, related_name=<span class="string">'items'</span>)  <span class="comment"># cartitem_set</span></span><br><span class="line">    product = models.ForeignKey(Product, on_delete=models.CASCADE)</span><br><span class="line">    quantity = models.PositiveSmallIntegerField()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        unique_together = [[<span class="string">'cart'</span>, <span class="string">'product'</span>]]</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/20.png"></p>
<p>migrate后，两个数据表如上图所示，我们看到了cart id从原来的bigint变成了char(32); 并且cart_id和product_id之间加上了一个约束</p>
<h3 id="Creating-a-Cart"><a href="#Creating-a-Cart" class="headerlink" title="Creating a Cart"></a>Creating a Cart</h3><p>创建一个API的流程如下：</p>
<h4 id="Serializer"><a href="#Serializer" class="headerlink" title="Serializer"></a>Serializer</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Cart</span><br><span class="line">        fields = [<span class="string">'id'</span>]</span><br></pre></td></tr></table></figure>
<h4 id="View"><a href="#View" class="headerlink" title="View"></a>View</h4><p>在这里我们并不希望CartViewSet去继承<code>ModelViewSet</code>这个类，因为对于cart来说，我只希望创建一个购物车，获得一个购物车，删除一个购物车。 我并不想用GET方法请求<code>/carts/</code>来获得所有的购物车信息。否则，其他人的购物车我们也看得到。</p>
<p>基于此，我们要客制化 ViewSets。在这一part，我先使用CreateModelMixin：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartViewSet</span><span class="params">(CreateModelMixin, GenericViewSet)</span>:</span></span><br><span class="line">    queryset = Cart.objects.all()</span><br><span class="line">    serializer_class = CartSerializer</span><br></pre></td></tr></table></figure>
<h4 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h4><p>注册Router</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.register(<span class="string">'collections'</span>, views.CollectionViewSet)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/37.png"></p>
<p>我们发现，id仍然是可以由client设置的，这和我们将其设为默认自动填充的UUID不符，由此，我们可以在serializer中将id设为只读：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    id = serializers.UUIDField(read_only=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Cart</span><br><span class="line">        fields = [<span class="string">'id'</span>]</span><br></pre></td></tr></table></figure>
<p>这样就可以直接创建了，我们看到在这个<code>/carts/</code>下，是没有办法通过GET来获取cart信息的，但是可以通过POST创建一个cart：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/38.gif"></p>
<h3 id="Getting-a-Cart"><a href="#Getting-a-Cart" class="headerlink" title="Getting a Cart"></a>Getting a Cart</h3><p>在这个购物车里，我希望列出购物车的id，购物车中物品信息，以及整个购物车的商品总价值。首先，为了能获取到特定一个购物车的信息，我们需要使用<code>RetrieveModelMixin</code> </p>
<h4 id="CartItem"><a href="#CartItem" class="headerlink" title="CartItem"></a>CartItem</h4><p>为此，我们需要创建一个<code>CartItemSerializer</code> 来显示商品的详细信息，在这个Serializer中，我想展示的信息有：这个Item的id，这个商品的信息，购买数量，以及这件商品的总价值</p>
<p>但我们又不想展示这个商品的所有信息，因此我们还需要创建一个<code>SimpleProductSerializer</code>专门为cartitem展示信息。我们想展示在购物车中的商品信息时：商品id，商品名称，商品单价</p>
<p>然后，我们要计算这件cartitem的总金额，计算公式是：这件商品的数量乘以这件商品的价格。需要用到<code>serializers.SerializerMethodField()</code>这个方法。比如字段名是total_price，那么就需要创建一个<code>get_total_price</code>来计算这个字段</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleProductSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Product</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'title'</span>, <span class="string">'unit_price'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartItemSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    product = SimpleProductSerializer()</span><br><span class="line">    total_price = serializers.SerializerMethodField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_total_price</span><span class="params">(self, cart_item: CartItem)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> CartItem.quantity*CartItem.product.unit_price</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = CartItem</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'product'</span>, <span class="string">'quantity'</span>, <span class="string">'total_price'</span>]</span><br></pre></td></tr></table></figure>
<p>最后，我们要计算购物车的总金额，同样需要用到<code>serializers.SerializerMethodField()</code>方法。不过因为在这里items是个数组，因此我们需要用一些技巧来计算整个金额：</p>
<p>下面这行代码就是说，对于每个购物车里面的商品，我都计算出商品的数量和商品的价格，然后用<code>sum()</code>函数对其求和</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum([item.quantity*item.product.unit_price <span class="keyword">for</span> item <span class="keyword">in</span> cart.items.all()])</span><br></pre></td></tr></table></figure>
<p>整体效果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    id = serializers.UUIDField(read_only=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 我们希望items的信息在这里仅仅是呈现，之后会学怎么往里面添加商品</span></span><br><span class="line">    items = CartItemSerializer(many=<span class="literal">True</span>,read_only=<span class="literal">True</span>)</span><br><span class="line">    total_price = serializers.SerializerMethodField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_total_price</span><span class="params">(self, cart)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> sum([item.quantity*item.product.unit_price <span class="keyword">for</span> item <span class="keyword">in</span> cart.items.all()])</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Cart</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'items'</span>,<span class="string">'total_price'</span>]</span><br></pre></td></tr></table></figure>
<p>最后，为了避免找到cart，再去一个一个找cartitem，增加数据库负担，我们可以用<code>prefetch_related</code>方法在查找Cart的时候就将里面的item都检索出来。注意了，<code>prefetch_related</code>是找反向关系的(父找子)，<code>select_related</code>方法是查找正向关系的(子找父)，不要用错！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartViewSet</span><span class="params">(CreateModelMixin, RetrieveModelMixin, GenericViewSet)</span>:</span></span><br><span class="line">    queryset = Cart.objects.prefetch_related(<span class="string">'items'</span>).all()</span><br><span class="line">    serializer_class = CartSerializer</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/39.png"></p>
<h3 id="Deleting-a-Cart"><a href="#Deleting-a-Cart" class="headerlink" title="Deleting a Cart"></a>Deleting a Cart</h3><p>要删除很简单，我们加一个<code>RetrieveModelMixin</code>就可以了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartViewSet</span><span class="params">(CreateModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                  RetrieveModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                  DestroyModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                  GenericViewSet)</span>:</span></span><br><span class="line">    queryset = Cart.objects.prefetch_related(<span class="string">'items'</span>).all()</span><br><span class="line">    serializer_class = CartSerializer</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/40.gif"></p>
<h3 id="Getting-Cart-Items"><a href="#Getting-Cart-Items" class="headerlink" title="Getting Cart Items"></a>Getting Cart Items</h3><p>现在，我们要把之前学的嵌套路由用上了，我们希望在输入<code>/carts/&lt;cart_id&gt;/items</code> 的时候，可以显示这个购物车里面所有的商品信息; 在输入<code>/carts/&lt;cart_id&gt;/items/&lt;item_id&gt;</code> 的时候可以显示购物车中某商品特定的信息</p>
<p>首先，我们要创建一个CartItemViewSet，因为对Cart Item,我们可以有获取list，获取detail，增加和删除的功能，因此，这里我们直接让其继承自ModelViewSet即可。注意，由于我们要用嵌套循环，父类cart的id是从request来的，因此我们要重写<code>get_query</code>函数，筛选出id为<code>cart_pk</code>的所有商品。</p>
<p>此外，由于我们想获取该item的商品信息，我们需要用<code>selected_related</code>将商品一并找出。否则会增加很多重复查询。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartItemViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    serializer_class = CartItemSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> CartItem.objects\</span><br><span class="line">            .filter(cart_id=self.kwargs[<span class="string">'cart_pk'</span>])\</span><br><span class="line">            .select_related(<span class="string">'product'</span>)</span><br></pre></td></tr></table></figure>
<p>然后，我们注册嵌套路由，模式和之前的 Product-Review是一样的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">carts_router = routers.NestedDefaultRouter(router, <span class="string">'carts'</span>, lookup=<span class="string">'cart'</span>)</span><br><span class="line">carts_router.register(<span class="string">'items'</span>, views.CartItemViewSet, basename=<span class="string">'cart-items'</span>)</span><br><span class="line"></span><br><span class="line">urlpatterns = router.urls + products_router.urls+carts_router.urls</span><br></pre></td></tr></table></figure>
<p>结果如下图所示：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/41.gif"></p>
<h3 id="Adding-a-Cart-Item"><a href="#Adding-a-Cart-Item" class="headerlink" title="Adding a Cart Item"></a>Adding a Cart Item</h3><p>现在，我们要实现给购物车添加商品的功能,现在的表单，我们不是不能添加，但是超级麻烦，如下所示：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/42.png"></p>
<p>事实上，我们往一个购物车里添加信息，只需要两个字段就行了：product_id 和 quantity</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartItemViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_serializer_class</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.request.method == <span class="string">'POST'</span>:</span><br><span class="line">            <span class="keyword">return</span> AddCartItemSerializer</span><br><span class="line">        <span class="keyword">return</span> CartItemSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_serializer_context</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'cart_id'</span>: self.kwargs[<span class="string">'cart_pk'</span>]&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> CartItem.objects\</span><br><span class="line">            .filter(cart_id=self.kwargs[<span class="string">'cart_pk'</span>])\</span><br><span class="line">            .select_related(<span class="string">'product'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddCartItemSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    product_id = serializers.IntegerField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate_product_id</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> Product.objects.filter(pk=value).exists():</span><br><span class="line">            <span class="keyword">raise</span> serializers.ValidationError(<span class="string">'No Product with the given ID'</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        cart_id = self.context[<span class="string">'cart_id'</span>]</span><br><span class="line">        product_id = self.validated_data[<span class="string">'product_id'</span>]</span><br><span class="line">        quantity = self.validated_data[<span class="string">'quantity'</span>]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cart_item = CartItem.objects.get(</span><br><span class="line">                cart_id=cart_id, product_id=product_id)</span><br><span class="line">            cart_item.quantity += quantity</span><br><span class="line">            cart_item.save()</span><br><span class="line">        <span class="keyword">except</span> CartItem.DoesNotExist:</span><br><span class="line">            CartItem.objects.create(cart_id=cart_id, **self.validated_data)</span><br><span class="line">        <span class="keyword">return</span> self.instance</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = CartItem</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'product_id'</span>, <span class="string">'quantity'</span>]</span><br></pre></td></tr></table></figure>
<p>效果如下,如果product_id相同，那么数量就会在原来的基础上增加，并不会创建一个新的item</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/44.gif"></p>
<p>此外，我对quantity在model中加上了一个validator：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">quantity = models.PositiveSmallIntegerField(</span><br><span class="line">        validators=[MinValueValidator(<span class="number">1</span>)])</span><br></pre></td></tr></table></figure>
<p>这样，如果新增的product的数量为0，会报错：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/43.png"></p>
<h3 id="Updating-a-Cart-Item"><a href="#Updating-a-Cart-Item" class="headerlink" title="Updating a Cart Item"></a>Updating a Cart Item</h3><p>现在，我们想更新 Cart Item的数量，即quantity：</p>
<p>我们首先定位到一个特定cart中的特定item，发现这个item里面字段太多了，我们只想让顾客修改quantity字段即可：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/45.png"></p>
<p>方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#serializer.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpdateCartItemSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = CartItem</span><br><span class="line">        fields = [<span class="string">'quantity'</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#view.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartItemViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    http_method_names = [<span class="string">'get'</span>,<span class="string">'post'</span>,<span class="string">'patch'</span>,<span class="string">'delete'</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_serializer_class</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.request.method == <span class="string">'POST'</span>:</span><br><span class="line">            <span class="keyword">return</span> AddCartItemSerializer</span><br><span class="line">        <span class="keyword">if</span> self.request.method == <span class="string">'PATCH'</span>:</span><br><span class="line">            <span class="keyword">return</span> UpdateCartItemSerializer</span><br><span class="line">        <span class="keyword">return</span> CartItemSerializer</span><br></pre></td></tr></table></figure>
<p>效果如下，我利用PATCH方法，成功地完成了修改quantity的值</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/46.gif"></p>
<h3 id="Deleting-a-Cart-Item"><a href="#Deleting-a-Cart-Item" class="headerlink" title="Deleting a Cart Item"></a>Deleting a Cart Item</h3><p>由于在上面我们已经确定了，CartItemViewSet中可行的请求方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_method_names = [<span class="string">'get'</span>, <span class="string">'post'</span>, <span class="string">'patch'</span>, <span class="string">'delete'</span>]</span><br></pre></td></tr></table></figure>
<p>我们可以直接删除特定的item，效果如下：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/47.gif"></p>
<h2 id="Django-Authentication-System"><a href="#Django-Authentication-System" class="headerlink" title="Django Authentication System"></a>Django Authentication System</h2><h3 id="Django-Authentication-System-1"><a href="#Django-Authentication-System-1" class="headerlink" title="Django Authentication System"></a>Django Authentication System</h3><p>在这一章我们来学习Django的内置认证系统。并将学习如何客制化User model，让其为我们的 项目服务</p>
<p>在INSTALLED_APPS中默认就有<code>django.contrib.auth</code> 应用，在这个app中有很多模型：User，Group,Permission等</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">    <span class="string">'django.contrib.auth'</span>,</span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">  ]</span><br></pre></td></tr></table></figure>
<p>在数据库中的<code>auth_user</code>表格里，我们也可以看到Django项目中的用户信息。里面有很多字段：密码、上次登录时间，是否是超级管理员，名字，邮箱，注册时间等。之后我们将介绍怎么客制化这张表格。</p>
<p>此外，我们还要了解Middleware, 下面是在这个项目中默认的中间件。在Django中，每当我们收到一个client发来的request的时候，request在经过view的时候，同时也在按照顺序将request一一经过下列中间件。每个中间件都可以往request中添加额外的信息或者直接返回一个Response(可能是发生错误了)。在这些中间件中我们看到有一个是用来处理用户信息的: <code>django.contrib.auth.middleware.AuthenticationMiddleware</code>, 这个中间件的功能，是用来读取request中用户的信息、并设置其属性的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="string">'debug_toolbar.middleware.DebugToolbarMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.security.SecurityMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions.middleware.SessionMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.common.CommonMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.csrf.CsrfViewMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.auth.middleware.AuthenticationMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages.middleware.MessageMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.clickjacking.XFrameOptionsMiddleware'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="Customizing-the-User-Model"><a href="#Customizing-the-User-Model" class="headerlink" title="Customizing the User Model"></a>Customizing the User Model</h3><p>现在我们来介绍两种客制化User Model的方法：</p>
<h4 id="Extend-User"><a href="#Extend-User" class="headerlink" title="Extend User"></a>Extend User</h4><p>第一种方法，是我新创建一个类(不妨叫做AppUser),让其继承自 User类. 使用这种方法，我们新加入的列就会显示在auth_user这张表格中。因此，如果要存储与身份验证(Authentication)相关的属性，建议使用这种方法</p>
<h4 id="Create-Profile"><a href="#Create-Profile" class="headerlink" title="Create  Profile"></a>Create  Profile</h4><p>第二种方法，是我创建一个Profile类，并让其建立和User的一对一联系。使用这种方法，将会有另一张表格，通过外键和auth_user相连接。因此，如果要存储与身份验证无关的属性(用户个人信息，比如用户生日、地址等)，建议使用这种方法。</p>
<p>此外，在不同的app中，我们也可以设计不同的Profile Model——在sales app中，我们可以用Customer来表示Profile，在hr app中，我们可以用Employee来表示Profile，在training app中，我们可以使用Student来表示Profile</p>
<p>由于第二种方法使用的场景更多，我们常常使用第二种方法作为客制化 User model的方法</p>
<h3 id="Extending-the-User-Model"><a href="#Extending-the-User-Model" class="headerlink" title="Extending the User Model"></a>Extending the User Model</h3><p>我们观察到，在auth_user这张表格中，对于email并没有严格的限制，但是呢，事实上不会存在多个用户共同使用一个email的情况，因此，我们需要新建一张自己的user表格，在里面加上对email的唯一性限制</p>
<p>首先，我们应该把我们的 User 创建在那里，肯定不能是store，因为这时对整个项目来说的，不能是特定的app</p>
<p>因此我们可以新创建一个名为 core的app。然后，将其在 INSTALLED_APP中注册。</p>
<p>接着我们在 core&gt;models.py中创建 User, 这个User需要继承自<code>django.contrib.auth.models</code>中的抽象类<code>AbstractUser</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> AbstractUser</span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(AbstractUser)</span>:</span></span><br><span class="line">    email = models.EmailField(unique=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>然后，我们需要在setting中确定<code>AUTH_USER_MODEL</code>属性，让其等于 core中的User</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AUTH_USER_MODEL &#x3D; &#39;core.User&#39;</span><br></pre></td></tr></table></figure>
<p>但这样一来，程序会起一个冲突：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/48.png"></p>
<p>原来，我们在第一部分写的Like app中，用到了<code>django.contrib.auth.models</code>中的User类，但是现在，我们将<code>AUTH_USER_MODEL</code>设置成了我们自己写的类，由此引发了冲突。为了修改这个冲突，我们可以对LikedItem Model进行修改：这里，根据系统的提示，我们隐式的确定USER_MODEL</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="comment">#...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LikedItem</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure>
<p>现在，冲突又出现了：由于我们的core还没有migrate，因此系统无法启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">raise ValueError(&quot;Dependency on app with no migrations: %s&quot; % key[0])</span><br><span class="line">ValueError: Dependency on app with no migrations: core</span><br></pre></td></tr></table></figure>
<p>在makemigration之后，要进行migrate操作的时候，又发生了如下错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">raise InconsistentMigrationHistory(</span><br><span class="line">django.db.migrations.exceptions.InconsistentMigrationHistory: Migration admin.0001_initial is applied before its dependency core.0001_initial on database 'default'.</span><br></pre></td></tr></table></figure>
<p>这个意思是说，我们在项目中期却打算修改原本的User模型，这一般是不被允许的，这涉及到数据库的底层设计。因此，我们需要重启数据库，将原有的库删除.然后重新migrate</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE  storefront2;</span><br><span class="line">CREATE DATABASE storefront2;</span><br></pre></td></tr></table></figure>
<p>所以，在今后我们最好在一个项目的一开始就创建自己的User类，可以这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> AbstractUser</span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(AbstractUser)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>现在，让我们重新创建一个superuser：<code>python manage.py createsuperuser</code></p>
<p>进入admin页面后，我们发现，admin界面中，只有Groups page，没有Users page:</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/49.png"></p>
<p>我们可以再 core&gt;admin.py中作如下修改</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.auth.admin <span class="keyword">import</span> UserAdmin <span class="keyword">as</span> BaseUserAdmin</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> User</span><br><span class="line"><span class="comment">#...</span></span><br><span class="line"><span class="meta">@admin.register(User)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAdmin</span><span class="params">(BaseUserAdmin)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>可以看到，现在有了用户界面，可以看到已经注册的用户(现在就我一个)</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/50.png"></p>
<p>我们来到新建用户画面，发现必填字段只有下面这些</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/51.png"></p>
<p>这是因为，我们继承的BaseUserAdmin类中，有一个属性是add_fieldsets, 里面规定的字段不包含email等，我们需要拿出来重写：在这里，我在原来的基础上加上了email、first_name,last_name</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@admin.register(User)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserAdmin</span><span class="params">(BaseUserAdmin)</span>:</span></span><br><span class="line">    <span class="comment"># pass</span></span><br><span class="line">    add_fieldsets = (</span><br><span class="line">        (<span class="literal">None</span>, &#123;</span><br><span class="line">            <span class="string">'classes'</span>: (<span class="string">'wide'</span>,),</span><br><span class="line">            <span class="string">'fields'</span>: (<span class="string">'username'</span>, <span class="string">'password1'</span>, <span class="string">'password2'</span>, <span class="string">'email'</span>, <span class="string">'first_name'</span>, <span class="string">'last_name'</span>),</span><br><span class="line">        &#125;), <span class="comment">#这个逗号一定要加，否则会出bug</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>刷新后结果如下，我们发现，email现在已经成了必填项，而且有唯一性，First name和Last name是选填项</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/52.png"></p>
<p>我们可以看到创建新用户后的样子如下：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/53.png"></p>
<p>与此同时，我们发现数据库中存放用户的表格从<code>auth_user</code>变成了<code>core_user</code>,里面保存了相关信息：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/54.png"></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>现在我们来小结一下这种方法的基本步骤：</p>
<ol>
<li>创建一个专门存放核心信息的app(最好叫core之类的)</li>
<li>在这个app中创建继承自AbstractUser的 User Model，里面确定要修改的字段</li>
<li>在settings.py 设置AUTH_USER_MODEL 属性</li>
<li>将之前引用<code>Django.contrib.auth.models.User</code> 的app修改为 <code>settings.AUTH_USER_MODEL</code></li>
</ol>
<h3 id="Creating-user-Profiles"><a href="#Creating-user-Profiles" class="headerlink" title="Creating user Profiles"></a>Creating user Profiles</h3><p>现在我们来学习第二种方法，之前，在store&gt;model.py中，我们写了一个Customer Model,里面有名字、手机号、生日、会员等级等信息。我们要做的就是在此基础上增加一个和core.User的一对一联系.此外，模型中的first_name,last_name,email 都已经在 core.User中实现了，我们现在将这些冗余信息删除</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    MEMBERSHIP_BRONZE = <span class="string">'B'</span></span><br><span class="line">    MEMBERSHIP_SILVER = <span class="string">'S'</span></span><br><span class="line">    MEMBERSHIP_GOLD = <span class="string">'G'</span></span><br><span class="line"></span><br><span class="line">    MEMBERSHIP_CHOICES = [</span><br><span class="line">        (MEMBERSHIP_BRONZE, <span class="string">'Bronze'</span>),</span><br><span class="line">        (MEMBERSHIP_SILVER, <span class="string">'Silver'</span>),</span><br><span class="line">        (MEMBERSHIP_GOLD, <span class="string">'Gold'</span>),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    phone = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    birth_date = models.DateField(null=<span class="literal">True</span>, blank=<span class="literal">True</span>)</span><br><span class="line">    membership = models.CharField(</span><br><span class="line">        max_length=<span class="number">1</span>, choices=MEMBERSHIP_CHOICES, default=MEMBERSHIP_BRONZE)</span><br><span class="line">    user = models.OneToOneField(</span><br><span class="line">        settings.AUTH_USER_MODEL, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure>
<p>接着，由于我们在<code>__str__</code> 中返回的是<code>f&#39;{self.first_name} {self.last_name}&#39;</code> 这个字符串，在class Meta也规定按照<code>[&#39;first_name&#39;,&#39;last_name&#39;]</code>来排序，由此，我们需要对其进行修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f'<span class="subst">&#123;self.user.first_name&#125;</span> <span class="subst">&#123;self.user.last_name&#125;</span>'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        ordering = [<span class="string">'user__first_name'</span>, <span class="string">'user__last_name'</span>]</span><br></pre></td></tr></table></figure>
<p>接下来系统给我们报错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">store</span>.<span class="title">admin</span>.<span class="title">CustomerAdmin</span>'&gt;:</span> (admin.E033) The value of <span class="string">'ordering[0]'</span> refers to <span class="string">'first_name'</span>, which <span class="keyword">is</span> <span class="keyword">not</span> a field of <span class="string">'store.Customer'</span>.</span><br></pre></td></tr></table></figure>
<p>原来，在第一章的admin模块中，我们在 store&gt;admin中创建了 CustomerAdmin类，里面引用了 first_name.last_name,现在这些属性已经不属于 Customer了，我们要对其进行修改：</p>
<p>对于 ordering 属性，我们可以直接用<code>user__first_name</code>和<code>user__last_name</code> 但是对于list_display属性，这种语法并不适用，所以我们保持原样，转向去 Customer Model去创建两个同名函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#store&gt;models.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">   <span class="comment">#...</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f'<span class="subst">&#123;self.user.first_name&#125;</span> <span class="subst">&#123;self.user.last_name&#125;</span>'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.user.first_name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">last_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.user.last_name</span><br><span class="line"><span class="comment">#store&gt;admin.py </span></span><br><span class="line"><span class="meta">@admin.register(models.Customer)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">	<span class="comment">#...</span></span><br><span class="line">    list_display = [<span class="string">'first_name'</span>, <span class="string">'last_name'</span>,  <span class="string">'membership'</span>, <span class="string">'orders'</span>] </span><br><span class="line">    ordering = [<span class="string">'user__first_name'</span>, <span class="string">'user__last_name'</span>]</span><br></pre></td></tr></table></figure>
<p>这样bug就完美解除了，现在我们来更新数据库。在 Customer界面，我们可以为已经存在的用户创建Profile：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/55.png"></p>
<p>我们为admin和JohnSmith分别创建一个profile，结果如下：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/56.png"></p>
<p>我们还可以给User添加排序：需要用<code>@admin.display()</code>修饰：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># store&gt;model.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span><span class="params">(models.Model)</span>:</span>    </span><br><span class="line"><span class="meta">    @admin.display(ordering='user__first_name')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.user.first_name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @admin.display(ordering='user__last_name')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">last_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.user.last_name</span><br></pre></td></tr></table></figure>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>要是用第二种方法，我们小结一下步骤：</p>
<ol>
<li>创建Profile model(叫什么随意)</li>
<li>在这个model中，创建和 AUTH_USER_MODEL 的一对一联系</li>
</ol>
<h3 id="Groups-and-Permissions"><a href="#Groups-and-Permissions" class="headerlink" title="Groups and Permissions"></a>Groups and Permissions</h3><p>Groups就是一些权限的集合，为了不给每一个用户都单独分配权限，我们可以将拥有相同权限的集合放到一个group中，这样就方便很多.</p>
<p>我们以superadmin登陆后，在 AUTHENTICATION AND  AUTHORIZATION中点击 Groups可以新建一个组：在这里，我希望这个组内的成员拥有对customer (Profile)、Order和OrderItem的CRUD权利：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/59.png"></p>
<p>然后，我们可以在User界面，挑选一个用户，将它加到Customer Service组中，记得勾选 Staff status，这样他就可以登录到admin 后台了</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/57.png"></p>
<p>我们退出admin，登录JasonBall后，可以看到，他只能对Customer和Order这两个Model进行修改了(OrderItem在Order中修改)。</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/58.png"></p>
<h3 id="Creating-Custom-Permissions"><a href="#Creating-Custom-Permissions" class="headerlink" title="Creating Custom Permissions"></a>Creating Custom Permissions</h3><p>我们发现，有些权限是系统不能提供的，比如说我要取消订单，这是一种订单状态的修改，而不是删除订单。</p>
<p>要实现客制化，我们需要在Meta类中设置元数据 permission属性。这个属性是一个元组列表，每个元组代表特定的权限。元组中第一个元素是code name(需具备唯一性)，第二个元素是对这个权限的描述</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        permissions = [</span><br><span class="line">            (<span class="string">'cancel_order'</span>,<span class="string">'can_cancel_order'</span>)</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/60.png"></p>
<p>那么关于这个权限是如何实现的，我们放在下面一节里细说</p>
<h2 id="Securing-APIs"><a href="#Securing-APIs" class="headerlink" title="Securing APIs"></a>Securing APIs</h2><p>在这一章，我们要对api进行安全认证</p>
<h3 id="Token-based-Authentication"><a href="#Token-based-Authentication" class="headerlink" title="Token-based Authentication"></a>Token-based Authentication</h3><p>对RESTful API，使用Token-base Authentication是一种基本操作. 基本流程如下：</p>
<ol>
<li>新用户要使用我们的服务，需要发送request请求，里面有创建用户的信息</li>
<li>server收到以后，为其创建一个账号</li>
<li>用户用刚注册的账号来访问接下来的api<ol>
<li>如果后台认证成功(密码正确)，那么就发送一个token</li>
<li>账号密码错误，返回一个error</li>
</ol>
</li>
</ol>
<p>token是什么我们就不用多说了。</p>
<h3 id="Adding-the-Authentication-Endpoints"><a href="#Adding-the-Authentication-Endpoints" class="headerlink" title="Adding the Authentication Endpoints"></a>Adding the Authentication Endpoints</h3><p>虽然Django提供了用户认证系统，但是我们并没有为其注册url。现在我们要注册一系列url，以便让用户实现注册、登录等操作。</p>
<p>为了实现这层api，我们可以使用<code>djoser</code> 这个包。他提供给我们一系列Views：比如注册、登录、等等。在其<a href="https://djoser.readthedocs.io/en/latest/" target="_blank" rel="noopener">官网</a>中，我们可以找到一些教程</p>
<p>首先，我们<code>pipenv install djoser</code> 下载这个包，然后将其注册到 INSTALLED_APP中去</p>
<p>然后，我们将auth注册到urlpattern中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">		<span class="comment">#...</span></span><br><span class="line">    path(<span class="string">'auth/'</span>,include(<span class="string">'djoser.urls'</span>))</span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>djoser 要依赖与一个 Authentication Backend才能够实现，因为djoser只是一层api和view函数，我们需要确定项目的Auth engine,才能让djoser发挥其作用。</p>
<p>在Django中我们主要有两个 Auth Engines：</p>
<ul>
<li>Token-based Authentication, 这是DRF中的认知引擎</li>
<li>JSON Web Token Authentication，这是一个独立的包，需要下载</li>
</ul>
<p>那么两者有什么区别呢？</p>
<p>前者会使用一张独立的Token表格，来存放tokens,每次server收到一个请求后，都会去数据库中做验证，判断token是否合法。也就是每次请求，都需要访问数据库</p>
<p>后者则不需要依赖数据库，因为Token的架构不同，我们在server层就可以完成对用户的验证</p>
<p>在这里我们选择后者，因此，我们需要再下载一个包：<code>pipenv install djangorestframework_simplejwt</code></p>
<p>然后，在settings.py中，我们要将项目的Auth Engine设为JWTAuthentication：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'COERCE_DECIMAL_TO_STRING'</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">'DEFAULT_AUTHENTICATION_CLASSES'</span>: (</span><br><span class="line">        <span class="string">'rest_framework_simplejwt.authentication.JWTAuthentication'</span>,</span><br><span class="line">    ),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们要设置SIMPLE_JWT, 这项设置要求用户在请求头中需要加上JWT前缀</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SIMPLE_JWT = &#123;</span><br><span class="line">   <span class="string">'AUTH_HEADER_TYPES'</span>: (<span class="string">'JWT'</span>,),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照教程，我们还需要在 storefront&gt;urls.py中注册一个新的urlpattern：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">  <span class="comment">#...</span></span><br><span class="line">    path(<span class="string">'auth/'</span>, include(<span class="string">'djoser.urls'</span>)),</span><br><span class="line">    path(<span class="string">'auth/'</span>, include(<span class="string">'djoser.urls.jwt'</span>)),</span><br><span class="line">  <span class="comment">#...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>现在，djoser提供的endpoints就可以正常使用了：</p>
<ul>
<li><code>/users/</code></li>
<li><code>/users/me/</code></li>
<li><code>/users/confirm/</code></li>
<li><code>/users/resend_activation/</code></li>
<li><code>/users/set_password/</code></li>
<li><code>/users/reset_password/</code></li>
<li><code>/users/reset_password_confirm/</code></li>
<li><code>/users/set_username/</code></li>
<li><code>/users/reset_username/</code></li>
<li><code>/users/reset_username_confirm/</code></li>
<li><code>/token/login/</code> (Token Based Authentication)</li>
<li><code>/token/logout/</code> (Token Based Authentication)</li>
<li><code>/jwt/create/</code> (JSON Web Token Authentication)</li>
<li><code>/jwt/refresh/</code> (JSON Web Token Authentication)</li>
<li><code>/jwt/verify/</code> (JSON Web Token Authentication)</li>
</ul>
<p>比如说，我访问 <code>http://localhost:9000/auth/users/</code>：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/61.png"></p>
<p>因为这些urls是不允许匿名用户访问的，我们必须有token才可以访问到信息。因此这里返回的状态码是401 Unauthorized。</p>
<h3 id="Registering-Users"><a href="#Registering-Users" class="headerlink" title="Registering Users"></a>Registering Users</h3><p>接下来我们就来学怎么注册一个新用户,在这个endpoint，我们不仅有GET还有POST方法。因此是可以新建User的</p>
<p>如果我们的注册信息很简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;email&quot;: &quot;user1@icloud.com&quot;,</span><br><span class="line">    &quot;username&quot;: &quot;user1&quot;,</span><br><span class="line">    &quot;password&quot;: &quot;1234&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到是不能注册成功的</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/62.png"></p>
<p>这是因为在settings.py中我们设置了一系列Validator： 有最短长度验证、简单密码验证、全数值密码验证等</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AUTH_PASSWORD_VALIDATORS = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'django.contrib.auth.password_validation.UserAttributeSimilarityValidator'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'django.contrib.auth.password_validation.MinimumLengthValidator'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'django.contrib.auth.password_validation.CommonPasswordValidator'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'django.contrib.auth.password_validation.NumericPasswordValidator'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>当我们改进password后，就可以正常注册了</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/63.png"></p>
<p>但我们有没有发现，这个POST函数并没有要求我们输入firstname和lastname(可以不填，但必须有)，这是因为djoser默认提供的字段只有这些，因此我们需要客制化serializer</p>
<p>在 <a href="https://djoser.readthedocs.io/en/latest/settings.html?highlight=serializer#serializers" target="_blank" rel="noopener">https://djoser.readthedocs.io/en/latest/settings.html?highlight=serializer#serializers</a> 中，我们可以看到djoser提供的所有serializer，其中我们要重写的是<code>user_create</code> </p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/64.png"></p>
<p>我们将这个serializer写在core app中,首先，我们要导入<code>djoser.serializers</code>中的<code>UserCreateSerializer</code>类<br>然后，我们要创建一个客制化类，让其继承自<code>UserCreateSerializer</code><br>接着，我们要重写Meta 类中的fields属性，又不想重写Meta中所有的属性，所以我们让Meta也继承自原来类中的Meta类。<br>最后，我们确认fields属性中的字段，把first_name,last_name加上：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># core&gt;serializers.py</span></span><br><span class="line"><span class="keyword">from</span> djoser.serializers <span class="keyword">import</span> UserCreateSerializer <span class="keyword">as</span> BaseUserCreateSerializer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserCreateSerializer</span><span class="params">(BaseUserCreateSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span><span class="params">(BaseUserCreateSerializer.Meta)</span>:</span></span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'username'</span>, <span class="string">'password'</span>,</span><br><span class="line">                  <span class="string">'email'</span>, <span class="string">'first_name'</span>, <span class="string">'last_name'</span>]</span><br></pre></td></tr></table></figure>
<p>此外，由于我们想用自己写的<code>UserCreateSerializer</code>,我们需要在settings中注明这一点：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># settings.py</span></span><br><span class="line">DJOSER = &#123;</span><br><span class="line">    <span class="string">'SERIALIZERS'</span>: &#123;</span><br><span class="line">        <span class="string">'user_create'</span>: <span class="string">'core.serializers.UserCreateSerializer'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后结果如下所示，注意，first_name和last_name是选填的</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/64.gif"></p>
<h3 id="Building-the-Profile-API"><a href="#Building-the-Profile-API" class="headerlink" title="Building the Profile API"></a>Building the Profile API</h3><p>但是，现在我们输入的都是core.user的字段，我们想在注册的时候添加birthday这种在profile中的字段，该怎么办？</p>
<p>我们当然可以在UserCreateSerializer中添加这个字段，但是这会让代码的耦合度变得很高。我们的程序设计理念是模块化。理想的状态是这样的：在前端，用户填了一系列表单，表单中的有些字段是属于core.user的，而有些字段则是属于store.customer的，为了将这些信息都保存下来，我们需要用户在提交时先访问 create user API,然后再发送一个Update Profile 请求访问Profile API，这样能让整个系统结构更加稳定。</p>
<p>由于Djoser并不提供<code>/user/profile</code>类似的api，我们需要自己实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># store&gt;serializers.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    user_id = serializers.IntegerField()</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Customer</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'user_id'</span>, <span class="string">'phone'</span>, <span class="string">'birth_date'</span>, <span class="string">'membership'</span>]</span><br><span class="line"><span class="comment"># store&gt;urls.py</span></span><br><span class="line">router.register(<span class="string">'customers'</span>,views.CustomerViewSet)</span><br></pre></td></tr></table></figure>
<p>然后，在<code>http://localhost:9000/store/customers/</code>界面，我们就可以为特定的 User创建profile了：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/65.gif"></p>
<h3 id="Logging-In"><a href="#Logging-In" class="headerlink" title="Logging In"></a>Logging In</h3><p>现在我们来讲用户认证。在Djoser中，下面两个endpoints是给 auth engine为DRF自带的Token Based Authentication使用的</p>
<ul>
<li><code>/token/login/</code> (Token Based Authentication)</li>
<li><code>/token/logout/</code> (Token Based Authentication)</li>
</ul>
<p>下面三个endpoints则是给 JSON Web Token Authentication使用的：</p>
<ul>
<li><code>/jwt/create/</code> (JSON Web Token Authentication)</li>
<li><code>/jwt/refresh/</code> (JSON Web Token Authentication)</li>
<li><code>/jwt/verify/</code> (JSON Web Token Authentication)</li>
</ul>
<p>其中<code>/jwt/create/</code> 这个endpoint就是用来给用户登录的：如果我们输入的用户名和密码错误，如下所示</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/66.png"></p>
<p>如果我们输入正确的用户名和密码，那么DJango会返回两个个Token ：access token和refresh token。access token是short-lived(短暂的)token，用来访问需要安全认证的API的；当access token过期的时候，需要用到refresh token来获得一个新的access token</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/67.png"></p>
<p>在 <a href="https://django-rest-framework-simplejwt.readthedocs.io/en/latest/settings.html" target="_blank" rel="noopener">simplejwt的官网</a>中，我们可以看到一系列设置，其中包括<code>&#39;ACCESS_TOKEN_LIFETIME&#39;,&#39;REFRESH_TOKEN_LIFETIME&#39;</code>也就是说，我们可以自己修改access token的寿命：</p>
<p>为了方便，我们这里就讲access token的有效时间也设为1天</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#settings.py</span></span><br><span class="line">SIMPLE_JWT = &#123;</span><br><span class="line">    <span class="string">'AUTH_HEADER_TYPES'</span>: (<span class="string">'JWT'</span>,),</span><br><span class="line">    <span class="string">'ACCESS_TOKEN_LIFETIME'</span>: timedelta(days=<span class="number">1</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一个前后端分离的系统中，当前段获得了一对token后，需要将它们存在浏览器里面。这里我们只能存放在一个文件里面，用来模拟前端的小型数据库，这样就算登录账户了。</p>
<p>那么怎么登出账户呢？很简单，就是将token从前端的小型数据库中移除即可。所以，在这个项目中，没有登出用户一说，因为这是前端干的事，和后端、数据库没有关系</p>
<h3 id="Inspecting-a-JSON-Web-Token"><a href="#Inspecting-a-JSON-Web-Token" class="headerlink" title="Inspecting a JSON Web Token"></a>Inspecting a JSON Web Token</h3><p>现在，我们来学习解构JWT，需要用到这个网站： <a href="https://jwt.io/" target="_blank" rel="noopener">https://jwt.io/</a></p>
<p>我们在这个网站里，将我们刚才保存的token输进去，如下图所示，右图是这个token解构后的信息：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/68.png"></p>
<p>第一部分是header，里面有typ键，这里是JWT，因为我们采用了这种认证机制</p>
<p>第二部分是payload, 第一个键是token_type，这里是access token；第二个键是过期时间；第三个键是这个token的唯一认证机制。最后一个键是user_id</p>
<p>第三部分是Verify Signature,是根据前两部分生成的，<code>your-256-bit-secret</code> 会存在server里面。如果我们对Payload进行修改，那么Signature也会做相应的修改。因此，就算黑客获取了你的token，打算修改你的user_id，这时候signature也会改变，也就不是原来的那个token了。如果拿这个去访问后端，是会被拒绝的，因为后端也认出这个<code>your-256-bit-secret</code> 不是自己生成的。</p>
<h3 id="Refreshing-Tokens"><a href="#Refreshing-Tokens" class="headerlink" title="Refreshing Tokens"></a>Refreshing Tokens</h3><p>那么如果Access token 过期了，没法访问Protected API, 而Refresh token 没有过期，会怎么样呢？我们需要用refresh_token向后端重新申请一个access token.</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/69.png"></p>
<p>Djoser 为我们提供的这个api，是可以通过一个refresh token去获得一个新的access token的：</p>
<ul>
<li><code>/jwt/refresh/</code> (JSON Web Token Authentication)</li>
</ul>
<p>效果如下：</p>
<p> <img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/70.gif"></p>
<h3 id="Getting-the-Current-User"><a href="#Getting-the-Current-User" class="headerlink" title="Getting the Current User"></a>Getting the Current User</h3><p>我们可以通过 <code>users/me/</code> 这个endpoint 来获得当前的用户。</p>
<p>但是我们发现，如果直接访问<code>http://localhost:9000/auth/users/me/</code>，Django是不会给我们提供任何信息的，因为我们并没有在请求头里存放token信息。</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/73.png"></p>
<p>因此，我们需要用到这个浏览器插件：<a href="https://chrome.google.com/webstore/detail/modheader/idgpnmonknjnojddfkpgkljpfnnfcklj?hl=en" target="_blank" rel="noopener">Modheader</a>， 利用这个插件，我们可以往请求头中添加信息。这里，我要添加一个Authorization的信息，信息内容是 <code>JWT (Access Token)</code> 。之所以这么写，是因为之前我们在settings中规定了认证的类型为JWT:  <code>&#39;AUTH_HEADER_TYPES&#39;: (&#39;JWT&#39;,)</code></p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/71.png"></p>
<p>设置好后，我们刷新页面，就可以得到个人信息了。</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/72.png"></p>
<p>但是现在，我们发现只能获得默认的三个字段：email，id，username，如果我想获得其他信息如first_name,last_name 应该怎么办？</p>
<p>还是老方法，修改默认的Serializer：我们找到 <code>&#39;current_user&#39;: &#39;djoser.serializers.UserSerializer&#39;,</code> 发现这个UserSerializer 是负责当前用户信息的。因此我们来重写他</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># core&gt;serializers.py</span></span><br><span class="line"><span class="keyword">from</span> djoser.serializers <span class="keyword">import</span> UserSerializer <span class="keyword">as</span>  BaseUserSerializer,\</span><br><span class="line">															 UserCreateSerializer <span class="keyword">as</span> BaseUserCreateSerializer</span><br><span class="line"> 		<span class="comment">#...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSerializer</span><span class="params">(BaseUserSerializer)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span><span class="params">(BaseUserSerializer.Meta)</span>:</span></span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'username'</span>, <span class="string">'password'</span>,</span><br><span class="line">                  <span class="string">'email'</span>, <span class="string">'first_name'</span>, <span class="string">'last_name'</span>]</span><br></pre></td></tr></table></figure>
<p>别忘了在 settings.py&gt;Djoser中增加修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DJOSER = &#123;</span><br><span class="line">    <span class="string">'SERIALIZERS'</span>: &#123;</span><br><span class="line">        <span class="string">'user_create'</span>: <span class="string">'core.serializers.UserCreateSerializer'</span>,</span><br><span class="line">        <span class="string">'current_user'</span>: <span class="string">'core.serializers.UserSerializer'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/74.png" style="zoom:67%;"></p>
<blockquote>
<p>注意了，Modheader会向所有的browser发送这个Authorization，因此可能会扰乱其它网站的登录(如果他们也用JWT的话)，因此最好用完就删掉。</p>
</blockquote>
<h3 id="Getting-Current-Users-Profile"><a href="#Getting-Current-Users-Profile" class="headerlink" title="Getting Current Users Profile"></a>Getting Current Users Profile</h3><p>上面我们获得了User的核心信息，现在如果我想获得User  Profile，该怎么办？</p>
<p>我们希望，访问<code>/store/customers/me</code> 的时候，可以获取到用户的电话号码、出生日期，会员等级等信息。</p>
<p>首先，我们要导入 action decorator，用它来修饰/me 这个动作，这里，我们要设置detail的值，如果为False，那么说明这个action作用于list view，通过<code>/store/customers/me</code>即可访问；如果为True，说明这个action作用于detail view，需要通过<code>/store/customers/&lt;id&gt;/me</code> 来访问。在这里，由于只会筛选到一个customer的信息，因此我们设置为False即可</p>
<p>然后，由于token的Payload中有userid这个键，因此我们可以用<code>request.user.id</code> 找到特定的customer的profile信息</p>
<p>最后，我们将object传入Serializer并将<code>serializer.data</code>传回</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> rest_framework.decorators <span class="keyword">import</span> action</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerViewSet</span><span class="params">(CreateModelMixin, RetrieveModelMixin, UpdateModelMixin, GenericViewSet)</span>:</span></span><br><span class="line">    queryset = Customer.objects.all()</span><br><span class="line">    serializer_class = CustomerSerializer</span><br><span class="line">	</span><br><span class="line"><span class="meta">    @action(detail=False)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">me</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        customer = Customer.objects.get(user_id = request.user.id)</span><br><span class="line">        serializer = CustomerSerializer(customer)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/75.png" style="zoom:67%;"></p>
<p>但是，现在我作为用户本人，只能查看个人的信息，并不能创建、修改更新个人信息。因为我们看到这边只允许GET方法，因此我们需要对CustomerView进行修改。</p>
<p>现在我们来捋一捋逻辑，我现在作为用户本人，已经登录了，现在在访问<code>/store/customers/me/</code> 这个endpoint</p>
<ul>
<li>如果我有customer信息<ul>
<li>我可以GET来获取</li>
<li>我可以PUT来更新</li>
</ul>
</li>
<li>如果我没有customer信息<ul>
<li>那么我可以创建相关信息<ul>
<li>GET</li>
<li>PUT</li>
</ul>
</li>
</ul>
</li>
<li>在使用PUT的时候，我不希望修改这个user的id，否则就乱了套了</li>
</ul>
<p>根据这个逻辑，我们可以这样修改：</p>
<ul>
<li>首先规定action中的methods参数为GET和PUT</li>
<li>然后，根据token中的id去数据库中获取customer对象，如果有则返回对象，如果没有，就创建一个实例<ul>
<li>如果方法是GET，那么就返回serializer.data</li>
<li>如果方法是PUT，说明要更新，因此我们需要将customer实例和request.data传给<code>CustomerSerializer</code>,让它去验证信息准确性，如果没问题，就保存</li>
</ul>
</li>
<li>在CustomerSerializer中将user_id改为<code>read_only=True</code>， 这样一来，用户只有在访问<code>/store/customers/me/</code> 的时候，才能创建或修改个人信息。在<code>/store/customers/</code> 的时候，不能创建个人信息，因为此时是获取不到user_id的</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># store&gt;views.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerViewSet</span><span class="params">(CreateModelMixin, RetrieveModelMixin, UpdateModelMixin, GenericViewSet)</span>:</span></span><br><span class="line">    queryset = Customer.objects.all()</span><br><span class="line">    serializer_class = CustomerSerializer</span><br><span class="line"></span><br><span class="line"><span class="meta">    @action(detail=False, methods=['GET', 'PUT'])</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">me</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        (customer,created) = Customer.objects.get_or_create(user_id=request.user.id)</span><br><span class="line">        <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">            serializer = CustomerSerializer(customer)</span><br><span class="line">            <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line">        <span class="keyword">elif</span> request.method == <span class="string">'PUT'</span>:</span><br><span class="line">            serializer = CustomerSerializer(customer, data=request.data)</span><br><span class="line">            serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">            serializer.save()</span><br><span class="line">            <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line">          </span><br><span class="line"><span class="comment"># stores&gt;serialize.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    user_id = serializers.IntegerField(read_only=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Customer</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'user_id'</span>, <span class="string">'phone'</span>, <span class="string">'birth_date'</span>, <span class="string">'membership'</span>]</span><br></pre></td></tr></table></figure>
<p>注意，这里使用<code>get_or_create</code> 方法的时候，返回值是一个对象元组，我们需要用一个元组来接收，如果只赋值给customer会报如下错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Got AttributeError when attempting to get a value for field `user_id` on serializer `CustomerSerializer`.</span><br><span class="line">The serializer field might be named incorrectly and not match any attribute or key on the `tuple` instance.</span><br><span class="line">Original exception text was: 'tuple' object has no attribute 'user_id'.</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/76.gif" style="zoom:67%;"></p>
<h3 id="Applying-Permissions"><a href="#Applying-Permissions" class="headerlink" title="Applying Permissions"></a>Applying Permissions</h3><p>在 <a href="https://www.django-rest-framework.org/api-guide/permissions/" target="_blank" rel="noopener">https://www.django-rest-framework.org/api-guide/permissions/</a> 中，我们可以看到各式各样的 Permission</p>
<p>比如 AllowAny，是对所有人都可以开放的权限，isAuthentication 是已经登陆的人的权限。我们也可以自己创建权限。</p>
<p>如果我们想给所有的viewset都加上 isAuthentication权限.可以直接修改settings.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># settings.py</span></span><br><span class="line"></span><br><span class="line">DJOSER = &#123;</span><br><span class="line">    <span class="string">'SERIALIZERS'</span>: &#123;</span><br><span class="line">        <span class="string">'user_create'</span>: <span class="string">'core.serializers.UserCreateSerializer'</span>,</span><br><span class="line">        <span class="string">'current_user'</span>: <span class="string">'core.serializers.UserSerializer'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'DEFAULT_PERMISSION_CLASSES'</span>:[</span><br><span class="line">        <span class="string">'rest_framework.permissions.IsAuthenticated'</span></span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/77.png" style="zoom:67%;"></p>
<p>如果我们希望有些 api可以由匿名用户访问，我们就不能采用这种一劳永逸的方法。可以在viewset里面设置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerViewSet</span><span class="params">(CreateModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                      RetrieveModelMixin,</span></span></span><br><span class="line"><span class="class"><span class="params">                      UpdateModelMixin, </span></span></span><br><span class="line"><span class="class"><span class="params">                      GenericViewSet)</span>:</span></span><br><span class="line">    queryset = Customer.objects.all()</span><br><span class="line">    serializer_class = CustomerSerializer</span><br><span class="line">    permission_classes = [IsAuthenticated]</span><br></pre></td></tr></table></figure>
<p>但是对于Generic View，好像用不了这个方法。我们需要在class上面加上一个decorator：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@permission_classes([IsAuthenticated])</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SearchBookView</span><span class="params">(ListAPIView)</span>:</span></span><br><span class="line">  <span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p>我们希望，在CustomerViewSet中，如果是未认证的用户，也可以查看他人的用户信息，但是只用认证后的用户才有权限更新Profile：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># store &gt;views</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerViewSet</span><span class="params">(CreateModelMixin, RetrieveModelMixin, UpdateModelMixin, GenericViewSet)</span>:</span></span><br><span class="line">    queryset = Customer.objects.all()</span><br><span class="line">    serializer_class = CustomerSerializer</span><br><span class="line">    permission_classes = [IsAuthenticated]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_permissions</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.request.method == <span class="string">'GET'</span>:</span><br><span class="line">            <span class="keyword">return</span> [AllowAny]</span><br></pre></td></tr></table></figure>
<p>如果我们不登录，那么只有GET方法</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/78.png" style="zoom:67%;"></p>
<p>如果我们登陆了，那么可以调用PUT方法</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/79.png" style="zoom:67%;"></p>
<h3 id="Applying-Custom-Permissions"><a href="#Applying-Custom-Permissions" class="headerlink" title="Applying Custom Permissions"></a>Applying Custom Permissions</h3><p>现在我们来自己创建Permissions类：</p>
<p>对于Products，我们希望只有admin可以修改有关product的信息，但是其他用户(不管有没有登录)，都不能修改。但是DRF中写好的permission类只有IsAuthenticatedOrReadOnly,没有 IsAdminOrReadOnly,.因此我们要客制化一个Permission 类。</p>
<p>我们首先来看<code>IsAuthenticated</code>,其内部逻辑就是找到是否token里有user，并且这个user是否是认证的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsAuthenticated</span><span class="params">(BasePermission)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Allows access only to authenticated users.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_permission</span><span class="params">(self, request, view)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(request.user <span class="keyword">and</span> request.user.is_authenticated)</span><br></pre></td></tr></table></figure>
<p>然后我们再来看看<code>IsAdminUser</code>的内部逻辑，就是找到是否有user，并且user是否是admin</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsAdminUser</span><span class="params">(BasePermission)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Allows access only to admin users.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_permission</span><span class="params">(self, request, view)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(request.user <span class="keyword">and</span> request.user.is_staff)</span><br></pre></td></tr></table></figure>
<p>接着我们就可以自己写permission了。逻辑如下：</p>
<ul>
<li>如果使用安全方法(GET,OPTION,HEAD)访问，那么就给这个权限</li>
<li>如果用PUT,DELETE,POST方法来访问的话，那么就需要判断是否为admin了</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> permissions</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsAdminOrReadOnly</span><span class="params">(permissions.BasePermission)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_permission</span><span class="params">(self, request, view)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> request.method <span class="keyword">in</span> permissions.SAFE_METHODS:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> bool(request.user <span class="keyword">and</span> request.user.is_staff)</span><br></pre></td></tr></table></figure>
<p>我们看到，如果我是staff(admin)我就可以新创建一个Product，除此之外只能是已读 的</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/80.png" style="zoom:67%;"></p>
<h3 id="Applying-Model-Permissions"><a href="#Applying-Model-Permissions" class="headerlink" title="Applying Model Permissions"></a>Applying Model Permissions</h3><p>现在我们只给admin操作Customer的权限。在之前我们创建的一个Group 叫做 Customer Service，如果我们想让拥有这个权限的用户进行操作，该怎么办？</p>
<p>我们可以使用DjangoModelPermissions</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerViewSet</span><span class="params">(CreateModelMixin, </span></span></span><br><span class="line"><span class="class"><span class="params">											RetrieveModelMixin, </span></span></span><br><span class="line"><span class="class"><span class="params">											UpdateModelMixin, </span></span></span><br><span class="line"><span class="class"><span class="params">											GenericViewSet)</span>:</span></span><br><span class="line">    queryset = Customer.objects.all()</span><br><span class="line">    serializer_class = CustomerSerializer</span><br><span class="line">    permission_classes = [DjangoModelPermissions]</span><br><span class="line">    <span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p>当使用这种权限方式，只有Groups中的用户才有权限对这个endpoint 进行操作.</p>
<p>比如说对于 JasonBall用户，他被加入到 customer service组了，那么现在他就拥有对customer的增删改查的权限：<code>http://localhost:9000/store/customers/5/</code></p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/83.png" style="zoom:67%;"></p>
<p>当我们把他从这个组删除，那么我们看到，除了GET方法，它不能对customer进行PUT，POST和DELETE操作了</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/81.png" style="zoom:67%;"></p>
<p>那么如果我甚至不想给他查看用户信息的权限，我们该怎么办？</p>
<p>看到DjangoObjectPermissions的源码，我们发现，在 <code>perms_map</code>这个列表中,只有POST、PUT、PATCH和DELETE是受保护的方法，而对GET方法没有权限方面的限制</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">perms_map = &#123;</span><br><span class="line">    <span class="string">'GET'</span>: [],</span><br><span class="line">    <span class="string">'OPTIONS'</span>: [],</span><br><span class="line">    <span class="string">'HEAD'</span>: [],</span><br><span class="line">    <span class="string">'POST'</span>: [<span class="string">'%(app_label)s.add_%(model_name)s'</span>],</span><br><span class="line">    <span class="string">'PUT'</span>: [<span class="string">'%(app_label)s.change_%(model_name)s'</span>],</span><br><span class="line">    <span class="string">'PATCH'</span>: [<span class="string">'%(app_label)s.change_%(model_name)s'</span>],</span><br><span class="line">    <span class="string">'DELETE'</span>: [<span class="string">'%(app_label)s.delete_%(model_name)s'</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，我们可以重写DjangoModelPermissions，在里面为GET方法加上权限设置。然后，将VIewSet中的permission_classes 修改成 我们自己写的 FullDjangoModelPermissions</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># store&gt;permissions</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FullDjangoModelPermissions</span><span class="params">(permissions.DjangoModelPermissions)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.perms_map[<span class="string">'GET'</span>] = [<span class="string">'%(app_label)s.add_%(model_name)s'</span>] </span><br><span class="line">        </span><br><span class="line"><span class="comment"># store&gt;views</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerViewSet</span><span class="params">(CreateModelMixin, RetrieveModelMixin, UpdateModelMixin, DestroyModelMixin,  GenericViewSet)</span>:</span></span><br><span class="line">    queryset = Customer.objects.all()</span><br><span class="line">    serializer_class = CustomerSerializer</span><br><span class="line">    permission_classes = [FullDjangoModelPermissions]</span><br><span class="line">    <span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p>结果如下，JasonBall现在连信息都看不了了 </p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/82.png" style="zoom:67%;"></p>
<h3 id="Applying-Custom-Model-Permissions"><a href="#Applying-Custom-Model-Permissions" class="headerlink" title="Applying Custom Model Permissions"></a>Applying Custom Model Permissions</h3><p>现在我们客制化一个Model Permission，我们想实现的功能是，当用户拥有这个权限，那么他可以访问历史订单，否则看不见。因为我们还没有开始写订单API，所以我们先(意思意思)</p>
<p>首先，我们在customer下面定义 permission元组列表。migration后，我们就可以在/admin界面给用户添加这个权限了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        ordering = [<span class="string">'user__first_name'</span>, <span class="string">'user__last_name'</span>]</span><br><span class="line">        permissions = [</span><br><span class="line">            (<span class="string">'view_history'</span>,<span class="string">'Can view history'</span>)</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure>
<p>接着，我们要为这个自定义的permission创建一个类，注意，这种自定义的类都需要继承自 <code>BasePermission</code>.在这个类中，我们要重写<code>has_permission</code>函数，里面返回的是一个判断用户是否拥有特定权限的布尔值。</p>
<p>这里，权限的命名方式是：app名字 . 自定义的权限名字</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewCustomerHistoryPermission</span><span class="params">(permissions.BasePermission)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_permission</span><span class="params">(self, request, view)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> request.user.has_perm(<span class="string">'store.view_history'</span>)</span><br></pre></td></tr></table></figure>
<p>最后，我们把这个permission class加到我们想要的action里面去，注意，这里自定义的action需要self,request和pk三个参数。因为这个 action是为特定的customer服务的，因此需要用到pk参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lass CustomerViewSet(	CreateModelMixin, </span><br><span class="line">											RetrieveModelMixin,</span><br><span class="line">                      UpdateModelMixin, </span><br><span class="line">                      DestroyModelMixin,</span><br><span class="line">                      GenericViewSet): 		</span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line"><span class="meta"> 		@action(detail=True, permission_classes=ViewCustomerHistoryPermission)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">history</span><span class="params">(self, request, pk)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'OK'</span>: <span class="string">"History"</span>&#125;)</span><br><span class="line">		<span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p>如果没有这个权限：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/84.png"></p>
<p>如果我们把这个权限加给JasonBall</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/85.png"></p>
<blockquote>
<p>注意点：</p>
<p>我们在给权限的时候永远不要一个一个加，就算只给一个权限，我们也要先创建一个Group，然后在把用户加到组里，这样不仅方便管理，而且能够轻易地通过组来筛选组内的用户。</p>
<p>如果一个一个加，项目大的话会非常难以管理</p>
</blockquote>
<h2 id="Designing-and-Building-the-Orders-API"><a href="#Designing-and-Building-the-Orders-API" class="headerlink" title="Designing and Building the Orders API"></a>Designing and Building the Orders API</h2><h3 id="Designing-the-API-1"><a href="#Designing-the-API-1" class="headerlink" title="Designing the API"></a>Designing the API</h3><p>我们现在来创建一个下单的API：首先给个设计</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>METHOD</th>
<th>url</th>
<th>request</th>
<th>Response</th>
</tr>
</thead>
<tbody>
<tr>
<td>POST</td>
<td>/orders/</td>
<td>{cartId}</td>
<td>order</td>
</tr>
<tr>
<td>GET</td>
<td>/orders/</td>
<td>{}</td>
<td>order[]</td>
</tr>
<tr>
<td>GET</td>
<td>/orders/1</td>
<td>{}</td>
<td>order</td>
</tr>
<tr>
<td>PATCH</td>
<td>/orders/1</td>
<td>——</td>
<td>——</td>
</tr>
<tr>
<td>DELETE</td>
<td>/orders/1</td>
<td>——</td>
<td>——</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Getting-the-Orders"><a href="#Getting-the-Orders" class="headerlink" title="Getting the Orders"></a>Getting the Orders</h3><p>首先我们在数据库里生成一些订单(因为创建订单的api我们还没写)</p>
<p>还是老套路，首先创建 serializer.我们最终想返回的是一个嵌套列表，形式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"id"</span>: <span class="number">2</span>,																	<span class="comment"># 订单号		</span></span><br><span class="line">        <span class="string">"customer"</span>: <span class="number">4</span>,														<span class="comment"># 顾客id</span></span><br><span class="line">        <span class="string">"placed_at"</span>: <span class="string">"2021-12-14T16:07:53Z"</span>,			<span class="comment"># 创建时间</span></span><br><span class="line">        <span class="string">"payment_status"</span>: <span class="string">"P"</span>,										<span class="comment"># 订单状态</span></span><br><span class="line">        <span class="string">"items"</span>: [																<span class="comment"># 订单物件</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"id"</span>: <span class="number">2</span>,</span><br><span class="line">                <span class="string">"product"</span>: &#123;											<span class="comment"># 物件信息</span></span><br><span class="line">                    <span class="string">"id"</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="string">"title"</span>: <span class="string">"Bread Ww Cluster"</span>,</span><br><span class="line">                    <span class="string">"unit_price"</span>: <span class="number">4.0</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"unit_price"</span>: <span class="number">10.0</span>,								<span class="comment">#单价</span></span><br><span class="line">                <span class="string">"quantity"</span>: <span class="number">10</span>									</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"id"</span>: <span class="number">3</span>,</span><br><span class="line">                <span class="string">"product"</span>: &#123;</span><br><span class="line">                    <span class="string">"id"</span>: <span class="number">2</span>,</span><br><span class="line">                    <span class="string">"title"</span>: <span class="string">"Island Oasis"</span>,</span><br><span class="line">                    <span class="string">"unit_price"</span>: <span class="number">84.64</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"unit_price"</span>: <span class="number">20.0</span>,</span><br><span class="line">                <span class="string">"quantity"</span>: <span class="number">20</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>我们看到这个嵌套对象还是蛮复杂的，最外层是order，第二层是orderitems，第三层是product</p>
<p>为了实现这个嵌套数组，我们可以这样来写serializer</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># serializer.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderItemSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    product = SimpleProductSerializer()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = OrderItem</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'product'</span>, <span class="string">'unit_price'</span>, <span class="string">'quantity'</span>]</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line"></span><br><span class="line">    items = OrderItemSerializer(many=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Order</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'customer'</span>, <span class="string">'placed_at'</span>, <span class="string">'payment_status'</span>, <span class="string">'items'</span>]</span><br><span class="line"><span class="comment"># 注意，如果items = OrderItemSerializer(many=True)，会报错，因为没有在model里面写related_name</span></span><br><span class="line"><span class="comment"># model.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderItem</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    order = models.ForeignKey(</span><br><span class="line">        Order, on_delete=models.PROTECT, related_name=<span class="string">'items'</span>)</span><br><span class="line">    <span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p>最后，我们注册routers:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># urls.py</span></span><br><span class="line">router.register(<span class="string">'orders'</span>, views.OrderViewSet)</span><br></pre></td></tr></table></figure>
<h3 id="Applying-Permissions-1"><a href="#Applying-Permissions-1" class="headerlink" title="Applying Permissions"></a>Applying Permissions</h3><p>现在我们给 orders 添加权限，否则匿名用户也能对订单进行查看。而且每个人只能查看自己下的订单。因此，我们要对queryset进行一个重写：</p>
<p>如果用户是staff，那么就可以返回所有的订单</p>
<p>如果用户不是staff，那么，就筛选出该用户下的订单并返回</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># views.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    serializer_class = OrderSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.request.user.is_staff:</span><br><span class="line">            <span class="keyword">return</span> Order.objects.all()</span><br><span class="line"></span><br><span class="line">        (customer_id, created) = Customer.objects.only(</span><br><span class="line">            <span class="string">'id'</span>,).get_or_create(user_id=self.request.user.id)</span><br><span class="line">        Order.objects.filter(customer_id=customer_id)</span><br><span class="line"><span class="comment"># urls.py</span></span><br><span class="line">router.register(<span class="string">'orders'</span>, views.OrderViewSet, basename=<span class="string">'orders'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Creating-an-Order"><a href="#Creating-an-Order" class="headerlink" title="Creating an Order"></a>Creating an Order</h3><p>现在我们来理一下创建Order的逻辑。</p>
<p>首先，我们可以从 Token中获得user_id, 我们将其取出放入 context。然后，如果是POST方法，说明需要创建一个Order，因为创建Order需要同时创建item(这一部分暂未实现)，内部实现逻辑更复杂，因此我们这里需要新建一个CreateOrderSerializer。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    permission_classes = [IsAuthenticated]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_serializer_context</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'user_id'</span>: self.request.user.id, &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_serializer_class</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.request.method == <span class="string">'POST'</span>:</span><br><span class="line">            <span class="keyword">return</span> CreateOrderSerializer</span><br><span class="line">        <span class="keyword">return</span> OrderSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.request.user.is_staff:</span><br><span class="line">            <span class="keyword">return</span> Order.objects.all()</span><br><span class="line"></span><br><span class="line">        (customer_id, created) = Customer.objects.only(</span><br><span class="line">            <span class="string">'id'</span>,).get_or_create(user_id=self.request.user.id)</span><br><span class="line">        Order.objects.filter(customer_id=customer_id)</span><br></pre></td></tr></table></figure>
<p>因为这个Serializer是要收入一个嵌套数组的(cart+cartItem)，这不属于Model之一 ,因此我们这里使用<code>Serializer</code>，需要自己定义save函数。创建一个Order最基本的两个条件是购物车号码以及用户的id(当item为空的时候)，因此这边我们根据id去找到customer，并用这个customer去创建Order</p>
<p>需要注意的是，cart_id 存放在 <code>**validated_data</code>里面，属于request.data中的内容；而user_id是view通过context(可以理解为小窗)传给Serializer的内容，不包含在validated_data里面 </p>
<p>在调用save函数的时候，validated_data会自动传入，而context不会，因此我们要手动传入customer字段。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateOrderSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    cart_id = serializers.UUIDField()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self,  **kwargs)</span>:</span></span><br><span class="line">        (customer, created) = Customer.objects.get_or_create(</span><br><span class="line">            user=self.context[<span class="string">'user_id'</span>],)</span><br><span class="line">        Order.objects.create(customer=customer)</span><br></pre></td></tr></table></figure>
<h3 id="Creating-Order-Items"><a href="#Creating-Order-Items" class="headerlink" title="Creating Order Items"></a>Creating Order Items</h3><p>上面所说的，只是创建一个Order对象，但是并没有创建订单中的物品信息。为此，我们需要在订单之后，再创建订单中的OrderItems对象</p>
<p>第一步，我们获取<code>validated_data</code> 中的<code>cart_id</code>信息。</p>
<p>第二步, 我们根据card_id找到隶属于这个购物车中的所有物品 cart_items</p>
<p>第三步，对于每个cart_item，我们都创建一个 order_item ；然后，作为数组成员放到 order_items 中去</p>
<p>第四步，调用 <code>objects.bulk_create</code> 方法，传入一个数组，这个方法就会为每一个数组中的成员创建一个对象，所以叫做 bulk，意思是大量创建</p>
<p>第五步，在创建订单后，购物车就没有用了，所以我们要删掉它</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateOrderSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> transaction.atomic():</span><br><span class="line">        cart_id = serializers.UUIDField()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self,  **kwargs)</span>:</span></span><br><span class="line">            (customer, created) = Customer.objects.get_or_create(</span><br><span class="line">                user=self.context[<span class="string">'user_id'</span>],)</span><br><span class="line">            order = Order.objects.create(customer=customer)</span><br><span class="line">            cart_id = self.validated_data[<span class="string">'cart_id'</span>]</span><br><span class="line">            cart_items = CartItem.objects\</span><br><span class="line">                .select_related(<span class="string">'product'</span>)\</span><br><span class="line">                .filter(cart_id=cart_id)\</span><br><span class="line"></span><br><span class="line">            order_items = [</span><br><span class="line">                OrderItem(</span><br><span class="line">                    order=order,</span><br><span class="line">                    product=item.product,</span><br><span class="line">                    unit_price=item.product.unit_price,</span><br><span class="line">                    quantity=item.quantity,</span><br><span class="line">                ) <span class="keyword">for</span> item <span class="keyword">in</span> cart_items</span><br><span class="line">            ]</span><br><span class="line"></span><br><span class="line">            OrderItem.objects.bulk_create(order_items)</span><br><span class="line"></span><br><span class="line">            Cart.objects.filter(pk=cart_id).delete()</span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果在订单创建一半的时候服务器崩掉了，怎么办？我们肯定需要回滚，因此我们可以将其视作一个数据库事务。为了实现事务功能，我们在代码前面加上 <code>with transaction.atomic()</code> 即可</p>
<p>结果如下，我们首先创建一个购物车。</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/86.png"></p>
<p>然后，我们把购物车编号输入，用POST方法创建一个订单</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/87.png"></p>
<p>然后，用GET方法就可以获得当前用户的所有订单。</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/88.png"></p>
<h3 id="Returning-the-Created-Order"><a href="#Returning-the-Created-Order" class="headerlink" title="Returning the Created Order"></a>Returning the Created Order</h3><p>我们现在发现，当我们用一个购物车号码去创建一个订单的时候，返回的结果只是它的订单号，而我们希望的是直接返回这个创建好后的订单：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/89.png"></p>
<p>这是因为，在<code>OrderViewSet</code> 中，我们让其继承自 ModelViewSet，我们查看其源代码中的 <code>CreateModelMixin</code>类如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateModelMixin</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Create a model instance.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        serializer = self.get_serializer(data=request.data)</span><br><span class="line">        serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        self.perform_create(serializer)</span><br><span class="line">        headers = self.get_success_headers(serializer.data)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)</span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p>我们发现，首先它会获取到ViewSet中定义的serializer，然后创建一个对象。在Response中, 同样用这个serializer来构造返回信息。因此，在这个例子中，当使用 POST请求方法的时候，用到的是<code>CreateOrderSerializer</code> ，这个serializer只接收一个字段——购物车的号码，因此返回体中也只有这个购物车号这一个字段</p>
<p>为了修改这个bug，我们可以重写create函数，让其覆盖掉返回时候的那个serializer，从而返回刚刚创建的订单对象。 需要注意的是，由于<code>CreateOrderSerializer</code> 需要接受到user_id和请求体中的cart_id，所以我们要传入两组数据。</p>
<p><code>get_serializer_context</code> 的作用就是给serializer带去“额外”(不在请求体之内的) 信息的，现在我们在重写create函数的时候直接传入了context，因此这个函数可以删去。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    permission_classes = [IsAuthenticated]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        serializer = CreateOrderSerializer(data=request.data,</span><br><span class="line">                                           context=&#123;</span><br><span class="line">                                               <span class="string">'user_id'</span>: self.request.user.id, &#125;</span><br><span class="line">                                           )</span><br><span class="line">        serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        order = serializer.save()</span><br><span class="line">        serializer = OrderSerializer(order)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_serializer_class</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.request.method == <span class="string">'POST'</span>:</span><br><span class="line">            <span class="keyword">return</span> CreateOrderSerializer</span><br><span class="line">        <span class="keyword">return</span> OrderSerializer</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># def get_serializer_context(self):</span></span><br><span class="line">    <span class="comment">#     return context=&#123;'user_id': self.request.user.id, &#125;)</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.request.user.is_staff:</span><br><span class="line">            <span class="keyword">return</span> Order.objects.all()</span><br><span class="line"></span><br><span class="line">        (customer_id, created) = Customer.objects.only(</span><br><span class="line">            <span class="string">'id'</span>,).get_or_create(user_id=self.request.user.id)</span><br><span class="line">        Order.objects.filter(customer_id=customer_id)</span><br></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/90.png"></p>
<h3 id="Data-Validation-1"><a href="#Data-Validation-1" class="headerlink" title="Data Validation"></a>Data Validation</h3><p> 现在我们虽然已经实现了创建订单，返回订单，但是如果我们用一个cart_id重复创建订单的话，系统并不会给我们报错，而这是不被允许的——因为当订单创建后，购物车会被删除，此时cart_id 就不存在了。</p>
<p>我们需要排除的情况是：</p>
<ul>
<li>当前的UUID并不存在(购物车ID非法)</li>
<li>当前的购物车中并没有任何物品</li>
</ul>
<p>我们可以再Serializer Class中对特定的字段进行验证，格式为：函数 <code>validate_{字段名}</code> ,比如说我们对cart_id进行验证。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateOrderSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> transaction.atomic():</span><br><span class="line">        cart_id = serializers.UUIDField()<span class="comment"># 必须是在Serializer中的字段才可以被验证</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">validate_cart_id</span><span class="params">(self, cart_id)</span>:</span></span><br><span class="line">          <span class="comment"># 如果购物车号不存在，那么就会报错</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> Cart.objects.filter(pk=cart_id).exists():</span><br><span class="line">                <span class="keyword">raise</span> serializers.ValidationError(</span><br><span class="line">                    <span class="string">"No cart with id %s exists"</span> % cart_id)</span><br><span class="line">          <span class="comment"># 如果购物车中没有一件商品，也会报错</span></span><br><span class="line">            <span class="keyword">if</span> CartItem.objects.filter(cart_id=cart_id).count() == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">raise</span> serializers.ValidationError(</span><br><span class="line">                  	<span class="string">"The cart with id % s is EMPTY!"</span> % cart_id)</span><br><span class="line">            <span class="keyword">return</span> cart_id</span><br></pre></td></tr></table></figure>
<p>结果如下</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/91.png"></p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/92.png"></p>
<h3 id="Revisiting-the-Permissions"><a href="#Revisiting-the-Permissions" class="headerlink" title="Revisiting the  Permissions"></a>Revisiting the  Permissions</h3><p>如果我们想给不同的人不同的权限怎么办？在ViewSets里面怎么修改？</p>
<p>比如说，对于订单删除功能，我只想开放给Admin，对于一般的用户，是不能删除创建的订单的的，为此，我们可以重写<code>get_permissions</code>函数 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    http_method_names = [<span class="string">'get'</span>, <span class="string">'patch'</span>,<span class="string">'post'</span> ,<span class="string">'delete'</span>, <span class="string">'head'</span>, <span class="string">'options'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_permissions</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.request.method <span class="keyword">in</span> [<span class="string">'PATCH'</span>, <span class="string">'DELETE'</span>]:</span><br><span class="line">            <span class="keyword">return</span> [IsAdminUser()]</span><br><span class="line">        <span class="keyword">return</span> [IsAuthenticated()]</span><br></pre></td></tr></table></figure>
<h3 id="Updating-an-Order"><a href="#Updating-an-Order" class="headerlink" title="Updating an Order"></a>Updating an Order</h3><p>修改完权限后，就必须是管理员才能修改订单了，但是，在修改订单的时候，我们只希望修改订单的状态，其他字段我们希望它是只读的。但是，如果我们直接修改OrderSerializer的话，需要给除了<code>payment_status</code> 以外的字段都加上read_only，这是比较繁琐的，而且如果以后有新的字段进来，还是要修改OrderSerializer的。</p>
<p>因此，我们可以另外创建一个UpdateOrderSerializer，专门来更新Order</p>
<ul>
<li>serializer.py</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpdateOrderSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Order</span><br><span class="line">        fields = [<span class="string">'payment_status'</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>views.py&gt; class OrderViewSet</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_serializer_class</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.request.method == <span class="string">'POST'</span>:</span><br><span class="line">        <span class="keyword">return</span> CreateOrderSerializer</span><br><span class="line">    <span class="keyword">elif</span> self.request.method == <span class="string">'PATCH'</span>:</span><br><span class="line">        <span class="keyword">return</span> UpdateCartItemSerializer</span><br><span class="line">    <span class="keyword">return</span> OrderSerializer</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/93.gif"></p>
<h3 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h3><p>之前，我们在<code>OrderViewSet</code>的<code>get_queryset</code> 函数中，我们使用了 <code>get_or_create</code> 方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">    (customer_id, created) = Customer.objects.only(</span><br><span class="line">        <span class="string">'id'</span>,).get_or_create(user_id=self.request.user.id)</span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p>因为在我们这个app中，先要创建一个User对象，然后， 再需要手动创建Customer，让其和User建立一对一的关系。因此存在忘记创建Customer的情况，使用了<code>get_or_create</code>之后，当检测到对应User的Customer未创建，就会自动创建一个Customer对象。</p>
<p>但这种方法毕竟是权宜之计，我们想要的理想状态是：当创建了User之后，会自动生成对应的Customer对象(默认)，然后，用户可以去自行修改其Customer对象的信息。</p>
<p>由此，我们就需要用到Signal了。 顾名思义，信号允许应用程序在发生特定事件时得到通知 。比如说，我想在有人发表评论或对文章做出React时通知文章作者，我们就可以使用信号。只要指定的Model被保存下来(修改、更新)，就会发送signal，接收器收到以后，会执行相应的动作</p>
<ul>
<li><p>信号系统包含以下三要素：</p>
<ul>
<li>发送者－信号的发出方</li>
<li>信号－信号本身</li>
<li>接收者－信号的接受者</li>
</ul>
</li>
</ul>
<p>Django内置了一整套信号，下面是一些比较常用的：</p>
<ul>
<li><code>django.db.models.signals.pre_save</code> &amp; <code>django.db.models.signals.post_save</code></li>
</ul>
<p>在ORM模型的save()方法调用之前或之后发送信号</p>
<ul>
<li><code>django.db.models.signals.pre_delete</code>&amp; <code>django.db.models.signals.post_delete</code></li>
</ul>
<p>在ORM模型或查询集的delete()方法调用之前或之后发送信号。</p>
<ul>
<li><code>django.db.models.signals.m2m_changed</code></li>
</ul>
<p><code>m2m_changed</code>当多对多字段被修改时发送信号。</p>
<ul>
<li><code>django.core.signals.request_started</code> &amp;<code>django.core.signals.request_finished</code></li>
</ul>
<p>当接收和关闭HTTP请求时发送信号。</p>
<h4 id="监听信号"><a href="#监听信号" class="headerlink" title="监听信号"></a>监听信号</h4><ul>
<li>接收器</li>
</ul>
<p>首先我们要用到 <code>@receiver</code>这个修饰器，被它修饰的函数把这三者都集成到了一起。</p>
<p>在这个例子中，<code>signal</code>是<code>post_save</code>, 发送者是<code>core.User</code> , 如果是成功创建了的话，Customer就会创建出对应的对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models.signals <span class="keyword">import</span> post_save</span><br><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> receiver</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Customer</span><br><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@receiver(post_save, sender=settings.AUTH_USER_MODEL)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_customer_for_new_user</span><span class="params">(sender, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> kwargs[<span class="string">'created'</span>]:</span><br><span class="line">        Customer.objects.create(user=kwargs[<span class="string">'instance'</span>])</span><br></pre></td></tr></table></figure>
<ul>
<li>随后在apps/store/app.py的config类下重写ready方法,用来激活signals，因为这个app对core.User发出来的signal比较感兴趣。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoreConfig</span><span class="params">(AppConfig)</span>:</span></span><br><span class="line">    default_auto_field = <span class="string">'django.db.models.BigAutoField'</span></span><br><span class="line">    name = <span class="string">'store'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ready</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">import</span> store.signals</span><br></pre></td></tr></table></figure>
<p>结果如下，我们看到，当创建了一个新用户的时候，对应的Customer也被创建了</p>
<p><img src="/2021/12/06/Django%E5%AD%A6%E4%B9%A02/94.png"></p>
<h3 id="Creating-Custom-Signals"><a href="#Creating-Custom-Signals" class="headerlink" title="Creating Custom Signals"></a>Creating Custom Signals</h3><p>此外，我们也可以自定义signals，比如说，当我创建了一个订单之后，我可以发送一个Signal。对这个signal感兴趣的app 就可以捕获它，实现提示用户等功能</p>
<p>由于情况变得复杂(这个app中既有系统信号又有自定义信号)，我们把逻辑都移动到signals文件夹当中。其中，文件夹中的 <code>handlers.py</code> 用来存放 receiver的逻辑。<code>__init__.py</code> 用来存放新建的自定义信号。比如说，我想创建一个<code>order_created</code>信号，在订单创建时候发送</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> Signal</span><br><span class="line">order_created = Signal()</span><br></pre></td></tr></table></figure>
<p>然后，我们需要设计发送逻辑,我们希望在订单创建时候发送这个信号，就需要修改Serializer中的save函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateOrderSerializer</span><span class="params">(serializers.Serializer)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> transaction.atomic():</span><br><span class="line">				<span class="comment">#...</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self,  **kwargs)</span>:</span></span><br><span class="line">          <span class="comment">#...</span></span><br><span class="line">         	<span class="comment"># 用 signal.send</span></span><br><span class="line">					order_created.send_robust(self.__class__,order = order) </span><br><span class="line">          <span class="keyword">return</span> order</span><br></pre></td></tr></table></figure>
<blockquote>
<p>信息发送有两个函数：send和send_robust</p>
<p>顾名思义，后者比较鲁棒，稳定性较强。</p>
<p>因为<code>send</code>函数，当其中一个receiver在接收信号的时候发生了错误，是不会影响其他receiver的，但<code>send_robust</code> 函数会捕获receiver发生的异常，并添加到返回的 responses数组中。</p>
</blockquote>
<p>当store发出了这个signal之后，我们希望core app可以收到这个消息并做出一定的动作。那么，我们需要在core中也创建一个receiver。同样的，我们创建signals文件夹，里面再新建一个handlers.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> store.signals <span class="keyword">import</span> order_created</span><br><span class="line"><span class="keyword">from</span> django.dispatch <span class="keyword">import</span> receiver</span><br><span class="line"><span class="comment"># 在这里我们没有指定sender，默认只要收到信号就执行</span></span><br><span class="line"><span class="meta">@receiver(order_created)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_order_created</span><span class="params">(sender, **kwargs)</span>:</span></span><br><span class="line">    print(kwargs[<span class="string">'order'</span>])</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/" class="post-title-link" itemprop="url">神经网络和反向传播</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-02 22:44:42" itemprop="dateCreated datePublished" datetime="2021-12-02T22:44:42+08:00">2021-12-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-12-27 12:30:46" itemprop="dateModified" datetime="2021-12-27T12:30:46+08:00">2021-12-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="神经网络和反向传播"><a href="#神经网络和反向传播" class="headerlink" title="神经网络和反向传播"></a>神经网络和反向传播</h1><h2 id="损失函数和优化"><a href="#损失函数和优化" class="headerlink" title="损失函数和优化"></a>损失函数和优化</h2><p>在大多数机器学习模型中，都会有一个<strong>损失函数(lost function)</strong>。比如常见的MSE：</p>
<script type="math/tex; mode=display">
L(w,b) = \frac{1}{N}\sum_{i=1}^n(y_i-f(wx_i+b))^2</script><p>损失函数用来衡量机器学习模型的精确度。一般来说，损失函数的值越小，模型的精确度就越高。如果要提高机器学习模型的精确度，就需要尽可能降低损失函数的值。而降低损失函数的值，我们一般采用梯度下降这个方法。所以，<strong>梯度下降的目的，就是为了最小化损失函数。</strong></p>
<h3 id="梯度下降的原理"><a href="#梯度下降的原理" class="headerlink" title="梯度下降的原理"></a>梯度下降的原理</h3><p>寻找损失函数的最低点，就像我们在山谷里行走，希望找到山谷里最低的地方。那么如何寻找损失函数的最低点呢？在这里，我们使用了微积分里导数，通过求出函数导数的值，从而找到函数下降的方向或者是最低点（极值点）。</p>
<p>损失函数里一般有两种参数，一种是控制输入信号量的权重(Weight, 简称 $w$ ），另一种是调整函数与真实值距离的偏差（Bias，简称 $b$ ）。我们所要做的工作，就是通过梯度下降方法，不断地调整权重$w$和偏差$b$，使得损失函数的值变得越来越小。</p>
<p>假设某个损失函数里，模型损失值 $L$与权重 $w$ 下图这样的关系。实际模型里，可能会有多个权重$w$，这里为了简单起见，举只有一个权重$w$的例子。权重$w$目前的位置是在A点。此时如果求出A点的梯度 $\frac{dL}{dw}$ ，便可以知道如果我们向右移动，可以使损失函数的值变得更小。</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/1.png" style="zoom:150%;"></p>
<p>用数学语言来解释一下：假设只有一个参数w</p>
<ul>
<li>那么导数$\frac{dL(w)}{dw}=\lim\limits_{h\rightarrow0}\frac{L(w+h)-L(w)}{h}$ 就代表L在w的切线斜率，即$L(w)$在该店的变化速率和方向。那么，只要导数不为0，我们往反方向微调就可以减小$L(w)$</li>
</ul>
<p>当有多维情况下，会有多个权重，此时$\boldsymbol W$ 为向量</p>
<ul>
<li>那么偏导数$[\frac{\partial L(\boldsymbol W)}{\partial w<em>1},\frac{\partial L(\boldsymbol W)}{\partial w_2},\cdots,\frac{\partial L(\boldsymbol W)}{\partial w_n}]$ 代表L在$\boldsymbol W$ 处沿每个维度的变化速率和方向，称为梯度和(gradient)，记为$\nabla</em>{\boldsymbol W}L$ 或$grad(L(\boldsymbol W))$ 。这个时候，我们需要把各个样本数据的权重梯度加起来，并求出它们的平均值，用这个平均值来作为样本整体的权重梯度。</li>
<li>$\nabla<em>{\boldsymbol W}L$ 和方向向量$\boldsymbol v$ 的点积即为该方向的斜率(方向导数)，公式为$\nabla</em>{\boldsymbol W}L\cdot v=|\nabla<em>{\boldsymbol W}L||v|\cos\theta$。当$cos(\theta)=1$ 的时候达到最大值。因此，负梯度 $-\nabla</em>{\boldsymbol W}L$ 的方向即为 L 在$\boldsymbol W$处下降最快的方向， 沿$-\nabla_{\boldsymbol W}L$方向微调就可以快速减小$L(\boldsymbol W)$(即梯度下降)</li>
<li>梯度下降的公式为： $W<em>{\text{new}} = W-\lambda\nabla</em>{\boldsymbol W}L$  ，其中$\lambda$是超参数，其含义就是<strong>学习率(Learning Rate)</strong>或者<strong>步长(Step size)</strong></li>
</ul>
<p>如果学习率$\lambda$设置得过大，有可能我们会错过损失函数的最小值；如果设置得过小，可能我们要迭代式子(2)非常多次才能找到最小值，会耗费较多的时间。因此，在实际应用中，我们需要为学习率设$\lambda$置一个合适的值。</p>
<h3 id="梯度下降的过程"><a href="#梯度下降的过程" class="headerlink" title="梯度下降的过程"></a>梯度下降的过程</h3><p>我们把上面的内容稍微整理一下，可以得到梯度下降的整体过程：</p>
<ol>
<li>for i = 0 to 训练数据的个数：</li>
</ol>
<p>(1) 计算第 i 个训练数据的权重 $w$ 和偏差 $b$ 相对于损失函数的梯度。于是我们最终会得到每一个训练数据的权重和偏差的梯度值。</p>
<p>(2) 计算所有训练数据权重  $w$ 的梯度的总和。</p>
<p>(3) 计算所有训练数据偏差 $b$ 的梯度的总和。</p>
<ol>
<li>做完上面的计算之后，我们开始执行下面的计算：</li>
</ol>
<p>(1) 使用上面第(2)、(3)步所得到的结果，计算所有样本的权重和偏差的梯度的平均值。</p>
<p>(2) 使用下面的式子，更新每个样本的权重值和偏差值。</p>
<script type="math/tex; mode=display">
w_{i+1} = w_i-\lambda\cdot\frac{dL}{d_{w_i}}\\
b_{i+1} = b_i-\lambda\cdot\frac{dL}{d_{w_i}}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def train(X, y, W, B, alpha, max_iters):</span><br><span class="line">    &#39;‘’</span><br><span class="line">    选取所有的数据作为训练样本来执行梯度下降</span><br><span class="line">    X : 训练数据集</span><br><span class="line">    y : 训练数据集所对应的目标值</span><br><span class="line">    W : 权重向量</span><br><span class="line">    B ： 偏差变量</span><br><span class="line">    alpha ： 学习速率</span><br><span class="line">    max_iters : 梯度下降过程最大的迭代次数</span><br><span class="line">   &#39;&#39;&#39;</span><br><span class="line">   dW &#x3D; 0 # 初始化权重向量的梯度累加器</span><br><span class="line">   dB &#x3D; 0 # 初始化偏差向量的梯度累加器</span><br><span class="line">   m &#x3D; X.shape[0] # 训练数据的数量</span><br><span class="line">   </span><br><span class="line">   # 开始梯度下降的迭代</span><br><span class="line">   for i in range(max_iters): </span><br><span class="line">       dW &#x3D; 0 # 重新设置权重向量的梯度累加器</span><br><span class="line">       dB &#x3D; 0 # 重新设置偏差向量的梯度累加器</span><br><span class="line">       </span><br><span class="line">       # 对所有的训练数据进行遍历</span><br><span class="line">       for j in range(m):</span><br><span class="line">           # 1. 遍历所有的训练数据</span><br><span class="line">           # 2. 计算每个训练数据的权重向量梯度w_grad和偏差向量梯度b_grad</span><br><span class="line">           # 3. 把w_grad和b_grad的值分别累加到dW和dB两个累加器里</span><br><span class="line">       </span><br><span class="line">       W &#x3D; W - alpha * (dW &#x2F; m) # 更新权重的值</span><br><span class="line">       B &#x3D; B - alpha * (dB &#x2F; m) # 更新偏差的值</span><br><span class="line"></span><br><span class="line">    return W, B # 返回更新后的权重和偏差。</span><br></pre></td></tr></table></figure>
<h3 id="其他常见的梯度下降算法"><a href="#其他常见的梯度下降算法" class="headerlink" title="其他常见的梯度下降算法"></a>其他常见的梯度下降算法</h3><p>上面介绍的梯度下降算法里，在迭代每一次梯度下降的过程中，都对所有样本数据的梯度进行计算。虽然最终得到的梯度下降的方向较为准确，但是运算会耗费过长的时间。于是人们在上面这个算法的基础上对样本梯度的运算过程进行了改进，得到了下面这两种也较为常见的算法：</p>
<h4 id="小批量样本梯度下降（Mini-Batch-GD"><a href="#小批量样本梯度下降（Mini-Batch-GD" class="headerlink" title="小批量样本梯度下降（Mini Batch GD)"></a>小批量样本梯度下降（Mini Batch GD)</h4><p>这个算法在每次梯度下降的过程中，只选取一部分的样本数据进行计算梯度，比如整体样本1/100的数据。在数据量较大的项目中，可以明显地减少梯度计算的时间。</p>
<h4 id="随机梯度下降（Stochastic-GD"><a href="#随机梯度下降（Stochastic-GD" class="headerlink" title="随机梯度下降（Stochastic GD)"></a>随机梯度下降（Stochastic GD)</h4><p>随机梯度下降算法只随机抽取<strong>一个</strong>样本进行梯度计算，由于每次梯度下降迭代只计算一个样本的梯度，因此运算时间比小批量样本梯度下降算法还要少很多，但由于训练的数据量太小（只有一个），因此下降路径很容易受到训练数据自身噪音的影响，看起来就像醉汉走路一样，变得歪歪斜斜的。</p>
<blockquote>
<p>GD的优势：每次迭代loss下降快</p>
<p>GD的劣势：一次迭代需要遍历所有数据，并且容易陷入local minima(局部极小值)</p>
<p>SGD的优势：迭代更新速度快，并且往往因为minibatch含有噪声而避开local minima</p>
<p>SGD的劣势：每次迭代，loss下降较慢</p>
</blockquote>
<p>由于数据量较大，训练深度神经网络基本使用SGD，以及其他性能更加的优化方法</p>
<h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>我们在<a href="https://jasonxqh.github.io/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/">人工神经网络</a> 这篇博客里面感性的认识了一下神经网络的架构，现在我们回顾并从数学角度重新学习一遍。</p>
<p>我们学过很多线性分类器，但是有很多非线性的分类情况我们是很难用线性分类器来解决的：</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/2.png" style="zoom: 67%;"></p>
<p>比如这种分类，我们只能够通过增加高阶多项事项来让分类器可行。那么当输入变量有n个的时候，最多会导致$O(n^n)$级别的参数，显然是不可行的。</p>
<h3 id="单层神经网络"><a href="#单层神经网络" class="headerlink" title="单层神经网络"></a>单层神经网络</h3><p>因此我们需要用到神经网络.我们从最简单的神经网络看起：</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/3.png"></p>
<p>在上面这个神经网络中，每条边都有一个权重，即$w_i$, 然后让权重和输入值相乘，就得到了$f(W,x)$ .这里$\boldsymbol W =[-30,20,20]$，对应一个偏置项(神经网络都需要的一个常数)和两个输入变量。我们用一层神经网络搭配Sigmoid激活函数可以模拟出 $y=x_1 \&amp;~x_2$的情况。</p>
<p>到这一步，神经网络还是线性的，那么就需要一个非线性的激活函数来打破这个线性。这里我们选择的是Sigmoid激活函数</p>
<p>我们可以给输入值和输出值做一个表格：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>x1</th>
<th>x2</th>
<th>$\sigma(f(W,x))$</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>$\sigma(-30)\approx0$</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>$\sigma(-10)\approx 0$</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>$\sigma(-10)\approx 0$</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>$\sigma(10)\approx 1$</td>
</tr>
</tbody>
</table>
</div>
<p>同理，我们可以通过修改权重，使得这个神经网络可以模拟$y=x_1|x_2$ 的情况，如下图所示：</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/4.png"></p>
<p>最早使用的激活函数就是 Sigmoid, 但是后来发现Sigmoid函数存在一些缺点，因此后来的神经网络大多使用tanh或者ReLU，我们在神经网络的训练那节会细讲。</p>
<p>进而我们可以设立多层的神经网络，将输出值当做下一层的输入值，再激活，再输入。以此来实现一个复杂的高维空间的模型。当神经网络的层数变多的时候，中间的几层就像是被“隐藏”起来了一样，因此我们称其为<strong>hidden layer(隐藏层)</strong></p>
<h3 id="hidden-layer"><a href="#hidden-layer" class="headerlink" title="hidden layer"></a>hidden layer</h3><p>在正常情况下，hidden layer肯定不止一个神经元，因为需要不同的神经元来捕捉不同的特征</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/5.png"></p>
<p>比如说上面这个两层的神经网络：输入层有三个变量，一个偏置项；隐藏层有四个神经元和一个偏置项。</p>
<p>那么我们可以得到hidden layer的计算公式：</p>
<script type="math/tex; mode=display">
a_1 = \sigma(w_{11}^1x_1+w_{12}^1x_2+w_{13}^1x_3+b_1^1)\\
a_2 = \sigma(w_{21}^1x_1+w_{22}^1x_2+w_{23}^1x_3+b_2^1)\\
a_3 = \sigma(w_{31}^1x_1+w_{32}^1x_2+w_{33}^1x_3+b_3^1)\\
a_4 = \sigma(w_{41}^1x_1+w_{42}^1x_2+w_{43}^1x_3+b_4^1)\\</script><p>用矩阵的思路来说，就是 </p>
<script type="math/tex; mode=display">
\boldsymbol a = \sigma(\boldsymbol {W^1x}+\boldsymbol b)\\</script><p>现在，hidden layer的输出结果变成了output layer 的输入结果，此时output layer一共有3个神经元，计算公式如下：(注意，这里的上标不代表平方而代表该权重位于第二层)</p>
<script type="math/tex; mode=display">
h_1 = \sigma(w_{11}^2a_1+w_{12}^2a_2+w_{13}^2a_3+w_{14}^2a_4+b_1^2)\\
h_2 = \sigma(w_{21}^2a_1+w_{22}^2a_2+w_{23}^2a_3+w_{24}^2a_4+b_2^2)\\
h_3 = \sigma(w_{31}^2a_1+w_{32}^2a_2+w_{33}^2a_3+w_{34}^2a_4+b_3^2)\\</script><h4 id="矩阵思路"><a href="#矩阵思路" class="headerlink" title="矩阵思路"></a>矩阵思路</h4><p>如果我们先不考虑偏置项，但考虑输入和输出，我们从矩阵的思路来理解一下每个层数的计算。</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/6.png"></p>
<p>那么，对于hidden layer来说，其权重矩阵的大小就是$H$行$D$列：</p>
<script type="math/tex; mode=display">
\boldsymbol{W^1} \in \mathbb R^{H\times D}</script><p>对于output layer来说，其权重矩阵的大小就是$C$行$H$列：</p>
<script type="math/tex; mode=display">
\boldsymbol W^2\in\mathbb R^{C\times H}</script><p>那么，如果是三层神经网络呢？</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/7.png"></p>
<p>此时，对于第一层隐藏层，$\boldsymbol{W^1} \in \mathbb R^{H_1\times D}$</p>
<p>对于第二层隐藏层，$\boldsymbol{W^2} \in \mathbb R^{H_2\times H_1}$</p>
<p>对于第三层输出层，$\boldsymbol W^3\in \mathbb R^{C\times H^2}$</p>
<p>用代码来表示，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f &#x3D; lambda x: 1.0&#x2F;(1.0+np.exp(-x)) # activation function(use sigmoid)</span><br><span class="line">x &#x3D; np.random.randn(3,1) # random input vector of three numbers(3x1)</span><br><span class="line">h1 &#x3D; f(np.dot(W1,x)+b1)	 # calculate first hidden layer activations(4x1)</span><br><span class="line">h2 &#x3D; f(np.dot(W2,h1)+b2) # calculate second hidden layer activations(4x1)</span><br><span class="line">out &#x3D; np.dot(W3,h2)+b3	 # output neuron(1x1)</span><br></pre></td></tr></table></figure>
<h4 id="随机连接的神经网络"><a href="#随机连接的神经网络" class="headerlink" title="随机连接的神经网络"></a>随机连接的神经网络</h4><p>事实上，神经网络之间是可以随机连接的，并不需要像我们上面介绍的那样全连接，如下图所示：</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/9.png"></p>
<h3 id="两层神经网络"><a href="#两层神经网络" class="headerlink" title="两层神经网络"></a>两层神经网络</h3><p>上面引入了多层神经网络的概念，那么用简单的两层神经网络可以解决什么问题呢？表示 异或 关系，如下图所示：</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/10.png"></p>
<p>同样用Sigmoid做激活函数，可以得到如下表格：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>x1</th>
<th>x2</th>
<th>a1</th>
<th>a2</th>
<th>h</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>$\sigma(-30)\approx0$</td>
<td>$\sigma(10)\approx1$</td>
<td>$\sigma(10)\approx1$</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>$\sigma(-10)\approx0$</td>
<td>$\sigma(-10)\approx0$</td>
<td>$\sigma(-10)\approx0$</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>$\sigma(-10)\approx0$</td>
<td>$\sigma(-10)\approx0$</td>
<td>$\sigma(-10)\approx0$</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>$\sigma(10)\approx1$</td>
<td>$\sigma(-30)\approx0$</td>
<td>$\sigma(10)\approx1$</td>
</tr>
</tbody>
</table>
</div>
<h2 id="神经网络的计算"><a href="#神经网络的计算" class="headerlink" title="神经网络的计算"></a>神经网络的计算</h2><p>现在我们来看看一个神经网络是如何被计算的</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/11.png"></p>
<p>对于这个神经网络，我们训练集是：$(x<em>i,y_i)</em>{i=1}^N$ ,其中$x_i$是向量，$y_i$是标签。激活函数式ReLU</p>
<ol>
<li>第一步，我们计算 $f(x;\boldsymbol W^1)$  ,然后输入到ReLU中去激活得到 $\boldsymbol a$</li>
<li>接着我们把$\boldsymbol a$ 和 $\boldsymbol W^2$ 计算得到 $\boldsymbol s = f(\boldsymbol a,\boldsymbol W^2)$ </li>
<li>用Softmax 来计算 $h<em>k = \frac{e^{s_k}}{\sum</em>{j}e^{s_j}}$  得到输出值</li>
<li>计算损失函数，其组成为softmax的损失函数加上第一层、第二层权重的正则项 $L = \frac{1}{N} \sum_{i=1}^Nl(\boldsymbol h_i,y_i)+\lambda R(\boldsymbol W^1)+\lambda R(\boldsymbol W^2)$</li>
<li>优化损失函数：计算解析梯度 $\frac{\partial L}{\partial \boldsymbol W^1},\frac{\partial L}{\partial \boldsymbol W^2}$ ，可以通过数值梯度去计算，得到$\nabla<em>{\boldsymbol W}L = \nabla</em>{\boldsymbol W}[\frac{1}{N}\sum_{i=1}^N(l(\boldsymbol h_i,y_i)+\lambda R(\boldsymbol W^1)+\lambda R(\boldsymbol W^2))]$</li>
</ol>
<p>这边只有两层，我们就发现解析梯度是如此的难求，那么如果神经网络的梯度再往上加的话，对计算机来说计算梯度是很复杂的一件事，因此，我们就需要<strong>反向传播</strong>这个技巧了</p>
<h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><p>我们在高数里面，已经学会了链式法则。那么，在计算梯度的时候，我们也可以用这套法则来较为方便得计算出权重的梯度。</p>
<p>比如说，我们得到了损失函数 $L$, 根据公式: $\frac{\partial L}{\partial \boldsymbol W^2} = \frac{\partial L}{\partial\boldsymbol h}\frac{\partial \boldsymbol h}{\partial \boldsymbol W^2}$， 我们可以先求出L关于$\boldsymbol h$的导数，然后再去求$h$关于$\boldsymbol W^2$的导数。</p>
<p>如果我们想计算$\frac{\partial L}{\partial \boldsymbol W^1}$ ，那么我们就在再向前推一层，根据公式：$\frac{\partial L}{\partial \boldsymbol W^1} = \frac{\partial L}{\partial\boldsymbol h}\frac{\partial  \boldsymbol h}{\partial \boldsymbol a}\frac{\partial \boldsymbol a}{\partial\boldsymbol W^1}$ 。</p>
<p>可以看到，反向传播的原理就是每一层的输出对这一层的输入求一个梯度，也就是按照从右往左的顺序来求梯度。</p>
<h4 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h4><p>我们把某个神经网络的计算图画出来。计算图可以看做是一个可视化的神经网络，把每一步的计算都用一个结构来表示，有了计算图就可以以很清晰的思路来编写代码了</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/12.png"></p>
<h5 id="前向传播1"><a href="#前向传播1" class="headerlink" title="前向传播1"></a>前向传播1</h5><p>上面是$x_1,w_1,x_2,w_2,b$ 的初始值，根据这些初始值，我们可以前向计算来得到每个节点的输出值：</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/13.png"></p>
<h5 id="反向传播1"><a href="#反向传播1" class="headerlink" title="反向传播1"></a>反向传播1</h5><p>接下来，我们要反向传播，从最后一步向前计算，首先我们假设这已经到了最后一层，因此最后一层的梯度就定为$\frac{\partial h}{\partial \sigma}=1$。然后我们从最后一层开始计算倒数第二层的梯度</p>
<p>对于倒数第二层，我们要知道链式法则：$\frac{\partial h}{\partial x} = \frac{\partial h}{\partial \sigma}\frac{\partial \sigma}{\partial x}$ </p>
<p>现在已知上游梯度 $\frac{\partial h}{\partial \sigma}=1$, 只要计算这层<strong>局部梯度</strong>，再把这层的输入值带入即可求得。因为$f(x) = \frac{1}{x}$ 所以 $\frac{df}{dx} = -\frac{1}{x^2}$ ,再把这层的输入值1.37带入，得到：$\frac{\partial h}{\partial x} = 1\times(-1/1.37^2)=-0.53$</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/14.png"></p>
<h5 id="反向传播2"><a href="#反向传播2" class="headerlink" title="反向传播2"></a>反向传播2</h5><p>现在，我们已经计算得到了两层梯度，继续向前推进。现在，$f(x) = x+1$,因此局部梯度 $\frac{df}{dx} = 1$, 输入值为0.37。但是这层得到的梯度和输入值无关，因此这层反向传播得到的值为$-0.53\times 1 = -0.53$</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/15.png"></p>
<h5 id="反向传播3"><a href="#反向传播3" class="headerlink" title="反向传播3"></a>反向传播3</h5><p>再向前推， 现在$f(x) = e^x$, 上游梯度为-0.53, 局部梯度为 $\frac{df}{dx} =e^x$, 输入值为-1。这层反向传播得到的值为 $-0.53\times e^{-1}=-0.2$</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/16.png"></p>
<h5 id="反向传播4"><a href="#反向传播4" class="headerlink" title="反向传播4"></a>反向传播4</h5><p>现在$f(x) = x-1$ ，局部梯度为 $-1$ ，和输入值无关，上游梯度为-0.2。 这层反向传播得到的值为：$-0.2\times -1=0.2$</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/17.png"></p>
<h5 id="反向传播5"><a href="#反向传播5" class="headerlink" title="反向传播5"></a>反向传播5</h5><p>到这一部分，神经网络开始分叉了，在这里 $f(x)$ 为两个输入值的和。我们分别把每个输入值都当做主元，那么对于b，上游梯度为0.2, 局部梯度为$\frac{df}{dx} = 1$ ，与输入值无关，因此反向传播得到的值为0.2</p>
<p>对于另外一个神经元，同理，与输入值无关，反向传播得到的值为0.2</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/18.png"></p>
<h5 id="反向传播6"><a href="#反向传播6" class="headerlink" title="反向传播6"></a>反向传播6</h5><p>在这一层神经网络又分叉了，但这层还是两个输入值相加, 和上一层是一样的，因此都是0.2</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/19.png"></p>
<h5 id="反向传播7"><a href="#反向传播7" class="headerlink" title="反向传播7"></a>反向传播7</h5><p>在这一层，我们先来看上面的分叉。$f(x)$为两个输入值的乘积，当我们把$x_1$当做主元的时候，$f(x) = -x$, 因此 $\frac{df}{dx_1}=-1$, 与输入值无关，上游梯度为0.2,因此反向传播得到的值为$0.2\times -1 =-0.2$</p>
<p>当把 $w_1$看做主元的时候，$f(x)= 2x,\frac{df}{dw_1} = 2$,与输入值无关，上游梯度的值为0.2. 因此反向传播得到的值为 $0.2\times 2 = 0.4$</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/20.png"></p>
<h5 id="反向传播8"><a href="#反向传播8" class="headerlink" title="反向传播8"></a>反向传播8</h5><p>现在来看下层的分叉。同样是输入值的乘积。</p>
<p>当我们把$x_2$当做主元的时候，$f(x) = -2x$, 因此 $\frac{df}{dx_2}=-2$, 与输入值无关，上游梯度为0.2,因此反向传播得到的值为$0.2\times -2=-0.4$</p>
<p>当把 $w_2$看做主元的时候，$f(x)= -3x,\frac{df}{dw_2} = 3$,与输入值无关，上游梯度的值为0.2. 因此反向传播得到的值为 $0.2\times -3 = -0.6$</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/21.png"></p>
<h4 id="分块计算图"><a href="#分块计算图" class="headerlink" title="分块计算图"></a>分块计算图</h4><p>细心地同学可能已经发现了，在正向传播的时候， 导数第1、2、3、4步合起来刚好是一个 $\frac{1}{1+e^{-x}}$ 的函数，也就是我们选择的Sigmoid激活函数。事实上，Sigmoid有自己的梯度形式，因此可以把计算图简单化。</p>
<p>这样，只要求 Sigmoid的本地梯度就可以了，相当于多步并一步：</p>
<script type="math/tex; mode=display">
\frac{d\sigma(x)}{dx} = \frac{e^{-x}}{(1+e^{-x})^2} = (\frac{1+e^{-x}-1}{1+e^{-x}})(\frac{1}{1+e^{-x}}) = (1-\sigma(x))\sigma(x)</script><p>这样一来，上游梯度就是1，输入值$x=1$, $\sigma(x)=0.73$,  局部梯度如上所示，反向传播得到的结果是：</p>
<script type="math/tex; mode=display">
1\times[(1-0.73)\times0.73]=0.2</script><p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/22.png"></p>
<p>同样的，我们可以把前面的神经元也合并成一块，用线性函数$ y=w_1x_1+w_2x_2+b$ 来表示</p>
<p>这样，对于 $w_i,x_i$的导数，我们可以用链式法则来求得：</p>
<script type="math/tex; mode=display">
\frac{\partial \sigma}{\partial w_i} = \frac{\partial \sigma}{\partial y}\frac{\partial y}{\partial w_i}\\
\frac{\partial \sigma}{\partial x_i} = \frac{\partial \sigma}{\partial y}\frac{\partial y}{\partial x_i}\\</script><p>比如，对于$y=-x_1-2x_2-3$ ,上游梯度为0.2</p>
<script type="math/tex; mode=display">
\begin{align}
&\frac{\partial \sigma}{\partial w_1} = \frac{\partial \sigma}{\partial y}\frac{\partial y}{\partial w_1}=0.2\times2=0.4\\
&\frac{\partial \sigma}{\partial x_1} = \frac{\partial \sigma}{\partial y}\frac{\partial y}{\partial x_1}=0.2\times-1=-0.2\\
&\frac{\partial \sigma}{\partial w_2} = \frac{\partial \sigma}{\partial y}\frac{\partial y}{\partial w_2}=0.2\times-3=-0.6\\
&\frac{\partial \sigma}{\partial x_2} = \frac{\partial \sigma}{\partial y}\frac{\partial y}{\partial x_2}=0.2\times2=-0.4\\
&\frac{\partial \sigma}{\partial b} = \frac{\partial \sigma}{\partial y}\frac{\partial y}{\partial b}=0.2\times1=0.2\\
\end{align}</script><p>如下图所示：</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/23.png"></p>
<p>根据这个计算图，我们可以很有条理地写出代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(w1,w2,w3,w4)</span>:</span></span><br><span class="line">	s1 = w1*x1</span><br><span class="line">	s2 = w2*x2</span><br><span class="line">	s3 = s1+s2</span><br><span class="line">	s4 = s3+b</span><br><span class="line">	L = sigmoid(s4)</span><br><span class="line">	</span><br><span class="line">	grad_L = <span class="number">1.0</span></span><br><span class="line">	grad_s4 = grad_L*(<span class="number">1</span>-L)*(L)</span><br><span class="line">	grad_b = grad_s4</span><br><span class="line">	grad_s3 = grad_s4</span><br><span class="line">	grad_s1 = grad_s3</span><br><span class="line">	grad_s2 = grad_s3</span><br><span class="line">	grad_w1 = grad_s1*x1</span><br><span class="line">	grad_x1 = grad_s1*w1</span><br><span class="line">	grad_w2 = grad_s2*x2</span><br><span class="line">	grad_x2 = grad_s2*w2</span><br></pre></td></tr></table></figure>
<h4 id="梯度流的常见模式"><a href="#梯度流的常见模式" class="headerlink" title="梯度流的常见模式"></a>梯度流的常见模式</h4><p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/24.png"></p>
<h3 id="反向传播的矩阵运算"><a href="#反向传播的矩阵运算" class="headerlink" title="反向传播的矩阵运算"></a>反向传播的矩阵运算</h3><p>前面我们都是计算标量，但事实上每一层都有很多神经元，因此，在真正运算的时候，都是矩阵运算。</p>
<h4 id="前向运算"><a href="#前向运算" class="headerlink" title="前向运算"></a>前向运算</h4><p>我们假设输入的<strong>x是D维的横向向量</strong>，<strong>隐藏层有H个</strong>，因此权重矩阵 $W\in\mathbb R^{D\times H}$ </p>
<p>输入乘以权重矩阵后，矩阵的形状为 $(1,H)$ , 如下图所示</p>
<p>然后对每个元素进行Sigmoid激活，得到$\boldsymbol\sigma$</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/25.png"></p>
<h4 id="反向运算-输入向量"><a href="#反向运算-输入向量" class="headerlink" title="反向运算-输入向量"></a>反向运算-输入向量</h4><p>每一层计算得到的梯度矩阵的形状和这一层的输入的矩阵形状是一样的。我们首先假设在sigmoid这层反向计算得到的梯度为：$\frac{\partial h}{\partial \sigma} = [4,1,2,-1]$</p>
<h5 id="反向传播1-1"><a href="#反向传播1-1" class="headerlink" title="反向传播1"></a>反向传播1</h5><p>现在，我们来计算y这层的局部梯度： $\frac{\partial\sigma}{\partial y}$</p>
<p>我们知道，矩阵对矩阵求导，需要$\sigma$矩阵中的每一个元素对$y$矩阵中的每一个元素求导，也就是Jacobian Matrix：</p>
<script type="math/tex; mode=display">
\boldsymbol J = [\frac{\partial \boldsymbol f}{\partial x_1},\cdots,\frac{\partial \boldsymbol f}{\partial x_n}] = \begin{bmatrix}\frac{\partial f_1}{\partial x_1}&\cdots&\frac{\partial f_1}{\partial x_n}\\\vdots&\ddots&\vdots\\\frac{\partial f_m}{\partial x_1}&\cdots&\frac{\partial f_m}{\partial x_n} \end{bmatrix}</script><p>也就是说，当隐藏层矩阵的形状为$(1,H)$的时候，$\frac{\partial \sigma}{\partial y}\in \mathbb R^{H\times H}$,  显然这是很复杂的计算，当$H=4096$的时候，我们甚至需要16M的内存来储存这个Jacobian矩阵</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/26.png"></p>
<p>事实上，我们根本不需要实现 Jacobian Matirx。 因为我们发现</p>
<script type="math/tex; mode=display">
(\frac{\partial \sigma}{\partial y})_{1,1}= (1-0.007)\times0.007=0.007\\
(\frac{\partial \sigma}{\partial y})_{1,2}=(\frac{\partial \sigma}{\partial y})_{1,3}=(\frac{\partial \sigma}{\partial y})_{1,4}=0</script><p>说明$y_i$只影响$\sigma_i$, 因此只需要保留对角线上的元素即可，如下图所示：</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/27.png"></p>
<p>因此，我们可以求出这一层的梯度，也就是两个梯度对应元素相乘后累加：</p>
<script type="math/tex; mode=display">
\frac{\partial h}{\partial y} = \frac{\partial h}{\partial \sigma}\frac{\partial \sigma}{\partial y} = \begin{bmatrix}4&1&2&-1\end{bmatrix}
\begin{bmatrix}0.007&0&0&0\\0&0.01&0&0\\0&0&0.11&0\\0&0&0&0\end{bmatrix}
=\begin{bmatrix}0.028&0.01&0.22&0\end{bmatrix}</script><p>因此，我们只要固定i，然后求一个pairwise的梯度计算，得到局部梯度；再乘以上游梯度，就可以得到这一层的梯度</p>
<h5 id="反向传播2-1"><a href="#反向传播2-1" class="headerlink" title="反向传播2"></a>反向传播2</h5><p>现在，我们要把y这层的梯度往前传，求出$(\frac{\partial y}{\partial x})_{n,m}=(\frac{\partial y_n}{\partial x_m})\Rightarrow\frac{\partial y}{\partial x}\in\mathbb R^{H\times D}$</p>
<p>我们发现，$R^{H\times D}$其实和 $\boldsymbol W^T$ 的形状是一样的. 为什么呢？我们看一下 $y^T$是如何被计算得到的就豁然明了了</p>
<script type="math/tex; mode=display">
y^T = \begin{bmatrix}x_1w_{11}+x_2w_{21}+x_3w_{31}\\x_1w_{12}+x_2w_{22}+x_3w_{32}\\x_1w_{13}+x_2w_{23}+x_3w_{33}\\x_1w_{14}+x_2w_{24}+x_3w_{34} \end{bmatrix}</script><p>那么，如果y对x求偏导的话，得到的雅克比矩阵就是：</p>
<script type="math/tex; mode=display">
\frac{\partial y}{\partial x} =\begin{bmatrix}w_{11} &w_{21}&w_{31}\\w_{12}&w_{22}&w_{32}\\w_{13}&w_{23}&w_{33}\\w_{14}&w_{24}&w_{34} \end{bmatrix} = W^T</script><p>也就是说：</p>
<script type="math/tex; mode=display">
\frac{\partial h}{\partial x} = \frac{\partial h}{\partial y}\frac{\partial y}{\partial x} = \frac{\partial h}{\partial y}W^T\\
shape=(1,H)(H\times D) = (1,D)</script><p>$\frac{\partial h}{\partial x}$ 的形状和$\boldsymbol x$ 的形状是一样的</p>
<h5 id="反向传播3-1"><a href="#反向传播3-1" class="headerlink" title="反向传播3"></a>反向传播3</h5><p>现在来看$\boldsymbol W$这层的梯度，我们首先列出公式</p>
<script type="math/tex; mode=display">
\frac{\partial h}{\partial W} =\frac{\partial h}{\partial W_{ij}}</script><p>虽然$\boldsymbol W$是矩阵，按照雅克比行列式来计算的话，需要每个$y<em>j$对这行中每一个元素$w</em>{ij}$求偏导，这太麻烦了。我们还是一对一对求就好，因为$w_{ij}$只影响 $y_j$ ,因此，上式可以简化为：</p>
<script type="math/tex; mode=display">
\frac{\partial h}{\partial W}=\frac{\partial h}{\partial y_j}\frac{\partial y_j}{\partial w_{ij}} = \frac{\partial h}{\partial y_j}x_i=x_i\frac{\partial h}{\partial y_j}\\</script><p>那么，因为 $\boldsymbol W$ 有三行，对每一行进行如上计算，就会得到一个  $3\times 4$  的矩阵，即</p>
<script type="math/tex; mode=display">
\frac{\partial h}{\partial W}=x^T\frac{\partial h}{\partial y}
=\begin{bmatrix}2\\1\\3\end{bmatrix}\begin{bmatrix}0.028&0.01&0.22&0\end{bmatrix}</script><p>发现这和$\boldsymbol W$的形状也是一样的 </p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/28.png"></p>
<h5 id="反向传播4-1"><a href="#反向传播4-1" class="headerlink" title="反向传播4"></a>反向传播4</h5><p>上面因为简化，我们没有加入偏置项b，现在我们加上试试：</p>
<script type="math/tex; mode=display">
y^T = \begin{bmatrix}x_1w_{11}+x_2w_{21}+x_3w_{31}+b\\x_1w_{12}+x_2w_{22}+x_3w_{32}+b\\x_1w_{13}+x_2w_{23}+x_3w_{33}+b\\x_1w_{14}+x_2w_{24}+x_3w_{34}+b \end{bmatrix}</script><p>此时，要求偏置项的梯度，我们可以列出公示：</p>
<script type="math/tex; mode=display">
\frac{\partial h}{\partial b} = \frac{\partial h}{\partial y}\frac{\partial y}{\partial b} = \frac{\partial h}{\partial y}\begin{bmatrix}1\\\vdots\\1\end{bmatrix}_H = \sum_{j}\frac{\partial h}{\partial y_j}</script><p>因为这里y关于b的导数始终是1，最后得到的关于b的梯度也是一个数</p>
<h4 id="反向运算-minibatch"><a href="#反向运算-minibatch" class="headerlink" title="反向运算-minibatch"></a>反向运算-minibatch</h4><p>上面，我们输入的只是个向量，即输入一个样本，因此计算起来还是效率不够高。因此我们可以采用minibatch的方法，输入一个矩阵来计算</p>
<h5 id="反向传播1-2"><a href="#反向传播1-2" class="headerlink" title="反向传播1"></a>反向传播1</h5><p>当输入变成一个矩阵的时候，发现$y<em>{ij}$仍然只会影响$\sigma</em>{ij}$,因此我们可以一对一计算，如下</p>
<p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/29.png"></p>
<h5 id="反向传播2-2"><a href="#反向传播2-2" class="headerlink" title="反向传播2"></a>反向传播2</h5><p>和只输入向量一样，$x_{ij}$只会影响y的<strong>第i行</strong>，因此</p>
<script type="math/tex; mode=display">
\frac{\partial h}{\partial x_{ij}} = \sum_{k}\frac{\partial h}{\partial y_{ik}}\frac{\partial y_{ik}}{\partial x_{ij}} = \sum_{k}\frac{\partial h}{\partial y_{ik}}w_{jk}\Rightarrow\frac{\partial h}{\partial x} = \frac{\partial h}{\partial y}W^T</script><p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/30.png"></p>
<h5 id="反向传播3-2"><a href="#反向传播3-2" class="headerlink" title="反向传播3"></a>反向传播3</h5><p>$w_{ij}$只会影响y的<strong>第j列</strong>，因此：</p>
<script type="math/tex; mode=display">
\frac{\partial h}{\partial W}=\sum_{k}\frac{\partial h}{\partial y_{kj}}\frac{\partial y_{kj}}{\partial w_{ij}} =\sum_k \frac{\partial h}{\partial y_{kj}}x_{ki}=\sum_kx_{ki}\frac{\partial h}{\partial y_{kj}}\Longrightarrow\frac{\partial h}{\partial W} = X^T\frac{\partial h}{\partial y}</script><p><img src="/2021/12/02/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%92%8C%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/31.png"></p>
<h5 id="反向传播4-2"><a href="#反向传播4-2" class="headerlink" title="反向传播4"></a>反向传播4</h5><p>在输入为向量的情况下，b只是个数，但当输入为一个矩阵的时候，偏置项b就变成了N维的向量。$b\in\mathbb R^N$</p>
<p>此时，要求偏置项的梯度，就是</p>
<script type="math/tex; mode=display">
\frac{\partial h}{\partial b} = \sum_j \frac{\partial h}{\partial y_{ij}}</script><p>令b原式的形状是 $(M,)$  上游梯度的形状为$(N\times M)$ ，那么相当于是对上游梯度每一列求和，最后得到形状为$(M,)$的梯度</p>
<h4 id="多层神经网络反向传播"><a href="#多层神经网络反向传播" class="headerlink" title="多层神经网络反向传播"></a>多层神经网络反向传播</h4><p>从上面的神经网络，我们可以推广到当神经网络有很多层的时候，可以这样来求各层的权重：</p>
<script type="math/tex; mode=display">
\begin{align}
&\frac{\partial L}{\partial \boldsymbol W^l} = \frac{\partial L}{\partial \boldsymbol h}\frac{\partial\boldsymbol h}{\boldsymbol W^l}\\
&\frac{\partial L}{\partial \boldsymbol W^{l-1}} = \frac{\partial L}{\partial \boldsymbol h}\frac{\partial\boldsymbol h}{\partial\boldsymbol  a^l}\frac{\partial\boldsymbol a^l}{\boldsymbol W^{l-1}}\\
&\frac{\partial L}{\partial \boldsymbol W^{l-2}} = \frac{\partial L}{\partial \boldsymbol h}\frac{\partial\boldsymbol h}{\partial\boldsymbol  a^l}\frac{\partial\boldsymbol a^l}{\partial\boldsymbol a^{l-1}}\frac{\partial\boldsymbol a^{l-1}}{\boldsymbol W^{l-2}}\\
\vdots\\\vdots\\
&\frac{\partial L}{\partial \boldsymbol W^{l-2}} = \frac{\partial L}{\partial \boldsymbol h}\frac{\partial\boldsymbol h}{\partial\boldsymbol  a^l}\frac{\partial\boldsymbol a^l}{\partial\boldsymbol a^{l-1}}\frac{\partial\boldsymbol a^{l-1}}{\partial\boldsymbol a^{l-2}}\cdots\frac{\partial \boldsymbol a^2}{\boldsymbol W^{l-2}}
\end{align}</script><p>注意，不要忘记每一层的偏执权重b，以及正则项</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/" class="post-title-link" itemprop="url">计算机视觉-神经网络的训练</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-02 12:57:44" itemprop="dateCreated datePublished" datetime="2021-12-02T12:57:44+08:00">2021-12-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-26 16:06:12" itemprop="dateModified" datetime="2022-06-26T16:06:12+08:00">2022-06-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机视觉-神经网络的训练"><a href="#计算机视觉-神经网络的训练" class="headerlink" title="计算机视觉-神经网络的训练"></a>计算机视觉-神经网络的训练</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>我们在 <a href="https://jasonxqh.github.io/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/">卷积神经网络理论</a> 这篇博客中粗略学习了卷积神经网络的相关知识。</p>
<p>在那篇博客里，我们用举了很多例子，比如说手写识别，图像分类。但其实CNN还有其他作用，比如：</p>
<ul>
<li>风格迁移</li>
</ul>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/1.png" style="zoom:67%;"></p>
<p>我们输入一张内容图片，再输入一张风格图片，通过最小化内容的损失和风格的损失来获取一张既保留前一张图片内容与后一张图片风格的图片。</p>
<script type="math/tex; mode=display">
x=\arg\min_{x}l_{(x,countent)}+l_{(x,style)}</script><p>在<a href="https://dreamscopeapp.com/" target="_blank" rel="noopener">https://dreamscopeapp.com/</a> 中，就是利用CNN这项技术来实现风格迁移的。</p>
<ul>
<li>Alpha Go</li>
</ul>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/2.png" style="zoom:67%;"></p>
<p>Alpha Go的原理就是提取出棋盘上的概率特征,然后去判断落子的位置</p>
<ul>
<li>看图说话</li>
</ul>
<p>如果图片和文本联系起来，可以实现看图说话的功能：每个词出来以后，预测下一个词是什么</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/3.png"></p>
<h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><p>现在我们来讲一些神经网络训练中的技巧。首先就是如何选择激活函数：</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/4.png"></p>
<p>我们知道比较有代表性的激活函数有Sigmoid，Relu，tanh，那么它们各自的优缺点是什么呢？</p>
<h3 id="Sigmoid"><a href="#Sigmoid" class="headerlink" title="Sigmoid"></a>Sigmoid</h3><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/5.png"></p>
<script type="math/tex; mode=display">
\sigma(x) = \frac{1}{1+e^{-x}}</script><p>我们观察到Sigmoid函数，y在x的绝对值大于4的时候，就非常非常接近于1了，而且基本维持不变。</p>
<p>因此，Sigmoid的优点是：</p>
<blockquote>
<ul>
<li>可以把数据压缩到0和1之间，每层数据的变化不是很大，如果变化太大会导致训练的不稳定，从而参数的梯度会很大，训练的代价高。</li>
<li>Sigmoid在任意位置均可导</li>
</ul>
</blockquote>
<p>Sigmoid的缺点是</p>
<blockquote>
<ul>
<li>饱和输出</li>
<li>非零均值，均值为0.5</li>
<li>属于幂函数计算代价高</li>
</ul>
</blockquote>
<p>我们主要来关注前两个缺点：</p>
<h4 id="饱和输出"><a href="#饱和输出" class="headerlink" title="饱和输出"></a>饱和输出</h4><p>饱和输出的意思是，当x稍微大一点或小一点的时候，$\sigma(x)$ 就会无限接近1或者0了。从而导致sigmoid的局部梯度接近于0，造成回传梯度消失，参数无法更新</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/6.png"></p>
<h4 id="非零均值"><a href="#非零均值" class="headerlink" title="非零均值"></a>非零均值</h4><p>首先，对于Sigmoid函数，$\sigma_i$都是正数。那么对于回传来的梯度，我们有公式：</p>
<script type="math/tex; mode=display">
\frac{\partial h}{\partial w_i} = \frac{\partial h}{\partial y} \frac{\partial y}{\partial w_i} = \frac{\partial h}{\partial y}\sigma_i</script><p>上游传回来的梯度如果是正的，那么每个$w_i$的梯度都是正的；上游传回来的梯度如果是负的，那么每个$w_i$的梯度都是负的。这就造成每一层的weight要么全部变小，要么全部变大，梯度呈“之字形”更新，虽然最后也能收敛到最优解，但收敛很慢  </p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/8.png"></p>
<p>用<code>minibatch</code>可以减轻这种效应</p>
<h3 id="tanh"><a href="#tanh" class="headerlink" title="tanh"></a>tanh</h3><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/9.png"></p>
<script type="math/tex; mode=display">
\tanh x = \frac{\sinh x}{\cosh x} = \frac{e^x-e^{-x}}{e^x+e^{-x}} = \frac{e^{2x}-1}{e^{2x}+1}</script><p>优点：</p>
<blockquote>
<ul>
<li>将数值压缩到(-1,1)之间</li>
<li>零均值</li>
<li>曲线平滑，便于求导</li>
</ul>
</blockquote>
<p>缺点：</p>
<blockquote>
<ul>
<li>容易饱和输出</li>
<li>exp() 幂函数计算复杂度很高</li>
</ul>
</blockquote>
<p>所以说 $\tanh$ 和  $\text{sigmoid}$ 的缺点是相同的</p>
<h3 id="Relu"><a href="#Relu" class="headerlink" title="Relu"></a>Relu</h3><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/10.png"></p>
<script type="math/tex; mode=display">
f(x) = \max(0,x)</script><p>其优点有很多：</p>
<blockquote>
<ol>
<li>在正区间是不会饱和的</li>
<li>计算复杂度极低</li>
<li>由前两条可以得到<strong>收敛速度比Sigmoid和tanh快</strong></li>
</ol>
</blockquote>
<p>当然，也存在一些缺点</p>
<blockquote>
<ol>
<li>不是零均值，也会存在一些 Zig-Zag的问题</li>
<li>不会压缩数据，因此数据幅度会随着网络加深不断增大</li>
<li>神经元坏死</li>
</ol>
</blockquote>
<h4 id="神经元坏死"><a href="#神经元坏死" class="headerlink" title="神经元坏死"></a>神经元坏死</h4><p>由于参数初始化或者学习率设置不当，会导致某些神经元的输入永远是负数，那么经过Relu，梯度为0，导致相应的参数永远不会更新。这就是Dead ReLU</p>
<p>采用合适的参数初始化和调整学习率可以缓解这种现象</p>
<h3 id="Leaky-ReLU"><a href="#Leaky-ReLU" class="headerlink" title="Leaky ReLU"></a>Leaky ReLU</h3><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/11.png"></p>
<script type="math/tex; mode=display">
f(x)= \max(ax,x)</script><p>Leaky ReLU和Relu很像，只不过在小于0的时候也有一个很小的斜率(取决于超参数的大小)。这样可以继承ReLU的优点，又规避了ReLU神经元坏死的缺陷</p>
<p>优点：</p>
<blockquote>
<ul>
<li>不会造成饱和 计算复杂率低</li>
<li>收敛速度比Sigmoid和tanh快</li>
<li>近似零均值</li>
<li>解决ReLU的神经元坏死问题</li>
</ul>
</blockquote>
<p>缺点：</p>
<blockquote>
<ul>
<li>数值幅度不断增大</li>
<li>实际表现不一定会比ReLU好</li>
</ul>
</blockquote>
<p>最后一点在科学研究中很常见，就是提出了能规避缺点的好方法，但却并不能得到更好的效果</p>
<h3 id="ELU-Exponential-Linear-Units"><a href="#ELU-Exponential-Linear-Units" class="headerlink" title="ELU(Exponential Linear Units)"></a>ELU(Exponential Linear Units)</h3><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/12.png"></p>
<script type="math/tex; mode=display">
f(x) = \begin{cases}x&x>0\\\alpha(\exp(x)-1)&x\leq 0 \end{cases}</script><p>我们看到ELU和Leaky ReLU很像，只是一个是线性函数，一个是幂函数</p>
<p>优点：</p>
<blockquote>
<ul>
<li>不容易造成饱和</li>
<li>收敛速度比Sigmoid和tanh快</li>
<li>近似零均值</li>
<li>解决了ReLU的神经元坏死问题</li>
</ul>
</blockquote>
<p>缺点：</p>
<blockquote>
<ul>
<li>存在幂函数，exp()计算复杂度高</li>
<li>表现不一定比ReLU好</li>
</ul>
</blockquote>
<h3 id="Maxout"><a href="#Maxout" class="headerlink" title="Maxout"></a>Maxout</h3><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/13.png"></p>
<script type="math/tex; mode=display">
f(x) = \max(w_1^Tx+b_1,w_2^Tx+b_2)\\
x\in\mathbb R^m,f(x)\in\mathbb R^n,w_1,w_2\in \mathbb R^{m\times n},w\in \mathbb R&{m\times n\times 2}</script><p>上面的输入层有8个神经元，maxout以后只有四个输出神经元，因为两两组合选出最大的那个值作为输出</p>
<p>推广得到：</p>
<script type="math/tex; mode=display">
f(x) = \max(w_1^Tx+b_1,\cdots,w_k^Tx+b_k)\\
w\in \mathbb R^{m\times n\times k}</script><p>maxout讲的不是很多，其原理就是每一个输出神经元的输出都会和上一层的输入神经元做计算，最后取最大值作为输出。</p>
<p> 实际搭建模型的时候：</p>
<ul>
<li>首选ReLU，但是要注意初始化和学习率的设置</li>
<li>不要使用Sigmoid</li>
<li>可以使用tanh，不过效果来讲一般</li>
<li>可以多尝试一点其他激活函数</li>
</ul>
<h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><h3 id="调整图片大小"><a href="#调整图片大小" class="headerlink" title="调整图片大小"></a>调整图片大小</h3><p>一般来说，将图像裁剪为大小一致的正方形。可以通过downscale和upscale来调整大小。</p>
<p>可以使用Pillow的<code>crop()</code>和<code>resize()</code>方法</p>
<h3 id="图像序列化"><a href="#图像序列化" class="headerlink" title="图像序列化"></a>图像序列化</h3><p>可以使用pickle模块将图片转化为像素值数组，并附上相应标签</p>
<h3 id="零均值化"><a href="#零均值化" class="headerlink" title="零均值化"></a>零均值化</h3><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/14.png"></p>
<p>目标：将原始像素值从[0,255]调整为$[-128,127]$ . </p>
<p>方法：</p>
<ul>
<li><p>计算所有图像的平均，得到mean image，mean image和原始图像的大小应保持一致</p>
</li>
<li><p>然后将每个图像都减去mean image</p>
</li>
</ul>
<p>如果输入数据不是零均值的话，会产生什么影响？造成这一层参数的梯度，要么都是正的，要么都是负的，导致Zig-Zag效应</p>
<p>此外，还有一些零均值化的方法，比如：</p>
<ul>
<li>每个channel 减去各自的平均。 比如 VCGNet</li>
<li>每个channel 减去各自的平均，然后除以std(标准化). 比如 ResNet</li>
</ul>
<h3 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h3><p>目标：将数值压缩到一个较小的区间</p>
<p>好处：</p>
<ul>
<li>减小损失函数对权重参数变化的敏感度</li>
<li>方便优化参数</li>
</ul>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/15.png"></p>
<p>在实际搭建模型的时候，必做的三个步骤是：</p>
<ol>
<li>调整图像大小</li>
<li>图像序列化</li>
<li>零均质化</li>
</ol>
<p>等每一层卷积之后，再去做<strong>标准化</strong>，一般先不做。</p>
<h3 id="权重参数的初始化"><a href="#权重参数的初始化" class="headerlink" title="权重参数的初始化"></a>权重参数的初始化</h3><p>初始化参数的好坏对网络的训练有着非常重要的意义。</p>
<p>由链式规则可知：</p>
<script type="math/tex; mode=display">
\frac{\partial L}{\partial \boldsymbol W^1} = \frac{\partial L}{\partial \boldsymbol h}\frac{\partial \boldsymbol h}{\partial \boldsymbol a^l}\frac{\partial \boldsymbol a^{l-1}}{\partial \boldsymbol a^{l-2}}\cdots\cdots\frac{\partial \boldsymbol a^2}{\partial \boldsymbol W^1}</script><p>那么当参数初始化过小的话,每一层回传值都$\approx 0$</p>
<ul>
<li>会导致回传梯度快速接近0，梯度消失。靠近输入层的梯度无法更新</li>
</ul>
<p>如果参数初始化过大(&gt;1)</p>
<ul>
<li>每一层都会乘以一个大于1的数字，会导致回传梯度快速增大，梯度爆炸。靠近输入的梯度会更新太快. 不知道什么时候才能找到最优解</li>
</ul>
<p>下面这张图中，纵轴代表更新速度，越上面代表更新越快。layer4是靠近输出层的，layer1是靠近输入层的。我们看到靠近输入层的layer1更新速度非常小。</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/16.png"></p>
<p>下面接好一些参数初始化方法</p>
<h4 id="全部初始化为0"><a href="#全部初始化为0" class="headerlink" title="全部初始化为0"></a>全部初始化为0</h4><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/17.png"></p>
<p>如果全部初始化为0，会导致：</p>
<ol>
<li>每一层的<strong>神经元输出完全一样</strong></li>
<li>每一层的<strong>参数梯度完全一样</strong>(参数的梯度和输入有关)</li>
<li>每一层的<strong>参数永远相同</strong></li>
<li>学习很缓慢，无法学习数据特征</li>
</ol>
<h4 id="完全随机初始化"><a href="#完全随机初始化" class="headerlink" title="完全随机初始化"></a>完全随机初始化</h4><p>若把参数设定为<strong>零均值、方差较小</strong>的正态分布随机数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dims &#x3D; [4096]*7</span><br><span class="line">hs &#x3D; []</span><br><span class="line">x &#x3D; np.random.randn(16,dims[0])</span><br><span class="line">for Din,Dout in zip(dims[:-1],dims[1:]):</span><br><span class="line">	W &#x3D; 0.01*np.random.randn(Din,Dout)</span><br><span class="line">	x &#x3D; np.tanh(x.dot(W))</span><br><span class="line">	hs.append(x)</span><br></pre></td></tr></table></figure>
<p>在这里我们用 tanh当做激活函数，初始化的数据也比较小。主要集中在0附近，因此，会导致下面这种情况，就是随着网络的一层层加深，经过激活函数 tanh 的时候会越来越塌陷，所有参数越来越靠近0，被激活的越来越少。</p>
<p>从而导致，越靠近输出层，梯度 $\frac{\partial L}{\partial w}$ 接近于0，靠近输出层的w的无法更新</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/18.png"></p>
<p>若把参数设定为<strong>零均值，方差较大</strong>的正态分布随机数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dims &#x3D; [4096]*7</span><br><span class="line">hs &#x3D; []</span><br><span class="line">x &#x3D; np.random.randn(16,dims[0])</span><br><span class="line">for Din,Dout in zip(dims[:-1],dims[1:]):</span><br><span class="line">	W &#x3D; 0.1*np.random.randn(Din,Dout)</span><br><span class="line">	x &#x3D; np.tanh(x.dot(W))</span><br><span class="line">	hs.append(x)</span><br></pre></td></tr></table></figure>
<p>那么这时候，经过tanh激活函数后，随着网络越深，输入值矩阵会越来越大，和权重相乘之后会无限接近于-1或者无限接近于1。从而导致激活越来越饱和。</p>
<p>这样一来，激活门的局部梯度就接近于0,根据tanh的导数图像可知，由于激活后的tanh都集中在-1和1，导致回传的梯度会消失</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/54.png" style="zoom: 67%;"></p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/19.png"></p>
<p>所以不管怎么样，都会塌陷或饱和。</p>
<h4 id="Xavier-初始化"><a href="#Xavier-初始化" class="headerlink" title="Xavier 初始化"></a>Xavier 初始化</h4><p>最理想的状态是，梯度既不会消失，也不会饱和，尽可能保持y和x的分布保持一致。现在来介绍Xavier初始化：</p>
<p>其方法就是在正态分布的随机数基础上除以$\sqrt n$ ： $std = 1/\sqrt{\text{Din}}$</p>
<p>卷积层Din的大小怎么算？$\text{Din} = F^2\times k$ ，其中 F为filter大小，输入K为信道数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dims = [<span class="number">4096</span>]*<span class="number">7</span></span><br><span class="line">hs = []</span><br><span class="line">x = np.random.randn(<span class="number">16</span>,dims[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> Din,Dout <span class="keyword">in</span> zip(dims[:<span class="number">-1</span>],dims[<span class="number">1</span>:]):</span><br><span class="line">	W = np.random.randn(Din,Dout) / np.sqrt(Din)</span><br><span class="line">	x = np.tanh(x.dot(W))</span><br><span class="line">	hs.append(x)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/20.png"></p>
<p>会有一定的塌陷，但是塌陷的速度明显减慢了</p>
<p>如果将激活函数替换为ReLU的话：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dims = [<span class="number">4096</span>]*<span class="number">7</span></span><br><span class="line">hs = []</span><br><span class="line">x = np.random.randn(<span class="number">16</span>,dims[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> Din,Dout <span class="keyword">in</span> zip(dims[:<span class="number">-1</span>],dims[<span class="number">1</span>:]):</span><br><span class="line">	W = np.random.randn(Din,Dout) / np.sqrt(Din)</span><br><span class="line">	x = np.maximum(<span class="number">0</span>,x.dot(w))</span><br><span class="line">	hs.append(x)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/21.png"></p>
<h4 id="He初始化"><a href="#He初始化" class="headerlink" title="He初始化"></a>He初始化</h4><p>He初始化是在Xavier上的基础上做了一些微小的改动，他觉得Xavier的更新还是太快了，因此除了一个更小的值.结果效果非常好：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dims = [<span class="number">4096</span>]*<span class="number">7</span></span><br><span class="line">hs = []</span><br><span class="line">x = np.random.randn(<span class="number">16</span>,dims[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> Din,Dout <span class="keyword">in</span> zip(dims[:<span class="number">-1</span>],dims[<span class="number">1</span>:]):</span><br><span class="line">	W = np.random.randn(Din,Dout)/np.sqrt(Din/<span class="number">2</span>) <span class="comment"># 相当于 *np.sqrt(2/Din)</span></span><br><span class="line">	x = np.maximum(<span class="number">0</span>,x.dot(w))</span><br><span class="line">	hs.append(x)</span><br></pre></td></tr></table></figure>
<p>在实际搭建模型的时候，优先使用ReLU+He进行初始化</p>
<h2 id="Batch-Normaliziation"><a href="#Batch-Normaliziation" class="headerlink" title="Batch Normaliziation"></a>Batch Normaliziation</h2><p>最后一部分我们来聚焦标准化。之前我们说，在数据预处理的时候先不要做数据标准化，这是因为有人发明了在层与层之间做标准化的方法，效果更好。</p>
<p>其中一个效果较好的方法就是 Batch Normaliziation</p>
<p>提出这个方法的内驱力是：</p>
<ul>
<li>如果不做标准化，输入的变化很大，导致参数也不停地变化，进而导致内部输出的分布不停变化。损失函数很难收敛</li>
<li>不做标准化，会导致数很大或者很小，进而导致激活容易饱和，或者激活趋近于0</li>
<li>总的来说，不做标准化会导致神经网络<strong>难以收敛</strong></li>
</ul>
<p>因为这种方法是通过对Minibatch标准化，因此我们称其为 Batch Normalization.</p>
<p>其原理就是对特征的每一维单独做normalization：</p>
<script type="math/tex; mode=display">
\hat x^{(k)} = \frac{x^{(k)}-E[x^{(k)}]}{\sqrt{\text{Var}[x^{(k)}]}}</script><p>详解：</p>
<script type="math/tex; mode=display">
\text{求batch中每一维特征的平均:} \mu_j = \frac{1}{N}\sum_{i=1}^n x_{i,j}\\
\text{求batch中每一维特征的方差:}\sigma_j^2 = \frac{1}{N}\sum_{i=1}^N(x_{i,j}-\mu_j)^2\\
\text{对每个x做 normalization:}\hat x_{i,j} =\frac{x_{i,j}-\mu_j}{\sqrt{\sigma_j^2+\varepsilon}}~~~~~~\text{维度:}~~(N\times D)</script><p>然后，我们要引入参数$\gamma$和$\beta$ ，也就是引入一个标准化的程度，否则如果强行标准化到$N(0,1)$可能会导致某些特征发生改变</p>
<script type="math/tex; mode=display">
y_{i,j} = \gamma_j\hat x_{i,j}+\beta_j
~~~~~~\text{维度:}~~(N\times D)</script><p>在推理时，可能只有一个或者几个样本，因此无法计算稳定的、有效地计算$\mu$和$\sigma^2$ .我们希望使用固定的$\mu,\sigma^2$ ,否则，整个模型会一直变化。</p>
<p>关于$\mu$和$\sigma^2$ 怎么更新，Moving Average技巧，momentum是一个超参，一般设为0.99或者0.999,然后让mean和var每次都会更新，但是更新幅度较小。最后获得一个整体的均值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">running_mean &#x3D; momentum * running_mean + (1-momentum) * sample_mean</span><br><span class="line">running_var  &#x3D; momentum * running_var  + (1-momentum) * sample_var</span><br></pre></td></tr></table></figure>
<p>到最后我们会发现，变量只有x,其余的都是超参数，可以将以下两式融合成 线性结构：</p>
<script type="math/tex; mode=display">
\begin{align}
&\hat x_{i,j} =\frac{x_{i,j}-\mu_j}{\sqrt{\sigma_j^2+\varepsilon}} \\~\\
&y_{i,j}=\gamma_j\hat x_{i,j}+\beta_j
\end{align}</script><h3 id="矩阵运算视角"><a href="#矩阵运算视角" class="headerlink" title="矩阵运算视角"></a>矩阵运算视角</h3><h4 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h4><p>对于输入x , 是 $N\times D$ 的矩阵</p>
<p>Batch Normalization就是保留输入的维度(即D)，对每一维里面所有的元素进行标准化</p>
<script type="math/tex; mode=display">
{\mu,\sigma}:1\times D\\
{\gamma,\beta}:1\times D\\
y = \gamma(x-\mu)/\sigma+\beta</script><h4 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h4><p>对于卷积层，输入为 $\text{N}\times \text{C}\times \text{H}\times W$</p>
<p>Batch Normalization就是保留输入的信道，是对每个信道里面的所有元素进行标准化。最后保留C个均值、C个方差</p>
<script type="math/tex; mode=display">
{\mu,\sigma}:1\times C\times1\times1\\
{\gamma,\beta}:1\times C\times1\times1\\
y = \gamma(x-\mu)/\sigma+\beta</script><h3 id="BN放在那里呢？"><a href="#BN放在那里呢？" class="headerlink" title="BN放在那里呢？"></a>BN放在那里呢？</h3><p>BN是放在卷积/全连接层和激活函数之间的一层。</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/22.png"></p>
<p>BN的注意点 </p>
<ul>
<li>优化了梯度流，是深度网络训练起来更加容易</li>
<li>可以使用较大的Learning Rate，加速收敛</li>
<li>受权重参数初始化影响较小</li>
<li>在训练过程中起到正则化的作用</li>
<li>推理时和FC/Conv层融合，几乎不增加开销</li>
<li>注意训练和推理BN的具体实现是不同的</li>
</ul>
<h3 id="Normalization的变化"><a href="#Normalization的变化" class="headerlink" title="Normalization的变化"></a>Normalization的变化</h3><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/53.png"></p>
<p>有时候，Batch Norm  在神经网络中的作用不那么突出，因此提出了一些变形。其原理和思想都和Batch Norm一样，只是参与归一化的元素不同</p>
<ul>
<li><p>Batch Normalization：对信道中的所有元素进行Normalization</p>
</li>
<li><p>Layer Normalization ：C代表每个信道，N代表每张图片。Layer Normalization就是对Batch中的每一张图片进行Normalization</p>
</li>
<li><p>Instance Normalization:每一张图片中的每一个信道做Normalization，更细致一些</p>
</li>
<li>Group Normalization: 取一张 图片中的部分信道做Normalization，介于Layer和Instance之间</li>
</ul>
<h2 id="优化方法的演进"><a href="#优化方法的演进" class="headerlink" title="优化方法的演进"></a>优化方法的演进</h2><p>前面我们讲了，通过反向传播来得到不同层的梯度，得到了梯度怎么拿来更新模型中的参数呢？这边又涉及到了不同的技巧，我们来学习一些</p>
<h3 id="SGD"><a href="#SGD" class="headerlink" title="SGD"></a>SGD</h3><p>SGD的全称是 Stochastic Gradient Descent，即随机梯度下降。</p>
<p>标准的随机梯度下降不是一个batch一个batch来做的，而是每次使用一个数据(一张图片)来计算loss。得到了损失函数，我们马上来更新参数。</p>
<p>伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while True:</span><br><span class="line">	weights grad &#x3D; evaluate gradient(loss fun,data,weights) #根据当前图像计算梯度</span><br><span class="line">	weights +&#x3D; -step size * weights grad</span><br></pre></td></tr></table></figure>
<p>SGD的迭代次数多，更新速度快，但也有其不可规避的缺点，比如：</p>
<h4 id="zig-zag问题"><a href="#zig-zag问题" class="headerlink" title="zig-zag问题"></a>zig-zag问题</h4><p>假设在二维空间中，损失函数对参数$w_1$ 非常敏感，但是对$w_2$不太敏感。</p>
<p>那么当w1稍微改动一下，损失函数就变化很大；w2可能要改动很多损失函数才能变化。</p>
<p>下图每个圈代表相同的损失函数的值，我们发现由于损失函数对参数的敏感程度的不同，会导致Zig-Zag的问题</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/23.png"></p>
<p>当然，用非零均值的激活函数也会造成Zig-zag的问题。</p>
<h4 id="minibatch的噪声问题"><a href="#minibatch的噪声问题" class="headerlink" title="minibatch的噪声问题"></a>minibatch的噪声问题</h4><p>我们可以用 mini-batch 则来效缓解Zig-zag的问题。但同时也会引入一些噪声。</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/24.png"></p>
<h4 id="局部最优和鞍点"><a href="#局部最优和鞍点" class="headerlink" title="局部最优和鞍点"></a>局部最优和鞍点</h4><p>SGD是每次用当前的参数减掉计算得到的梯度来得到下一轮的参数的。因此，如果当损失函数陷入极小值点或者说进入鞍点的时候，参数会很难更新。如下图:</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/25.png"></p>
<p>当落入极小值点的时候，梯度是接近于0的，此时更新就很难移动了。稍微动一点点的话，梯度就变成反方向的了，就好像U形管中的小球一样。</p>
<p>在高位空间中，鞍点是更常见的，此时，某些方向loss会变大，某些方向loss会变小。 </p>
<h3 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h3><p>利用SGD+Momentum,我们可以解决SGD带来的缺点。其更新原理如下：</p>
<script type="math/tex; mode=display">
v_{t+1} = \rho v_t+\nabla f(x_t)\\
x_{t+1} = x_t-\alpha v_{t+1}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vx&#x3D;0</span><br><span class="line">while True:</span><br><span class="line">	dx &#x3D; compute_gradient(x)</span><br><span class="line">	vx &#x3D; rho*vx+dx</span><br><span class="line">	x -&#x3D; leaning_rate * vx</span><br></pre></td></tr></table></figure>
<p>在SGD中，我们把梯度看做是一个静态的量，每次求得以后用原参数减去即可。但是在SGD+Momentum中，就相当于给梯度加上一个”速度“——下一时刻的速度，等于当前时刻的速度乘以一个衰减率$\rho$, 再加上求得的梯度。然后，用当前的权重减掉速度来更新权重。</p>
<p>等于说，现在我改变的是速度的大小，速度是由梯度累加起来的一个量。梯度$\nabla f(x)d(x)$越大，增量也就越大, 这样就避免了一个速度为0的情况，因此权重是一直可以更新的。</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/26.png"></p>
<p>这种方法，在当前速度和梯度方向相同的时候，会让权重减小较多的值，相当于踩了一个刹车，来让我们不那么容易地错过最优点。如果当前处于极小值点/鞍点，仍然是有一个速度存在的(可能为负数)，借助于这个速度，可以跳过这个极小值旁边的坡。如上图所示</p>
<p>在可视化图中，我们发现 SGD+Momentum 在最后绕过了最优解，最后又绕回来了。这就是速度的直观表现，一开始遇到最优点但是刹不住车了，后来再一步一步减小自己的速度，回到最优点</p>
<h4 id="Nesterov-Momentum"><a href="#Nesterov-Momentum" class="headerlink" title="Nesterov Momentum"></a>Nesterov Momentum</h4><p>对于SGD+Momentum，Nesterov提出了一种改进方法，如下图所示：</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/27.png"></p>
<p>Nesterov 的依据是，下一层速度的更新，不要依据当前点的梯度，而要依靠下一个点的梯度。这样，如果下一个点的梯度非常陡峭，如果和速度同方向，说明正在下坡，$v<em>{t+1}$变小，因此可以慢一点；如果和速度反方向，说明在爬坡，$v</em>{t+1}$增大，需要加速。</p>
<p>计算公式：</p>
<script type="math/tex; mode=display">
\begin{align}
&v_{t+1} = pv_t-\alpha\nabla f(x_t+\rho v_t)\\
&x_{t+1}= x_t+v_{t+1}\\
&\text{令}\tilde x_t = x_t+\rho v_t,\text{可知：}\\
&v_{t+1} = \tilde x_t -\rho v_t+(1+\rho)v_{t+1}=\tilde x_t+v_{t+1}+\rho(v_{t+1}-v_t)
\end{align}</script><p>因此，我们只要计算$\tilde x$即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dx &#x3D; compute_gradient(x)</span><br><span class="line">old_v &#x3D; v</span><br><span class="line">v &#x3D; rho*v-leaning_rate*dx</span><br><span class="line">x +&#x3D; -rho*old_v+(1+rho)*v</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/28.png"></p>
<h3 id="AdaGrad"><a href="#AdaGrad" class="headerlink" title="AdaGrad"></a>AdaGrad</h3><p>对于SGD、以及Momentum，我们发现对某一层所有点的梯度更新都是一样的。但是实际情况下，某些方向对参数的更新是不明感的，而有些方向很敏感。因此我们要对敏感方向更新的快一些，而对不敏感的方向慢一点。</p>
<p>由此，我们来学习AdaGrad,这个优化策略的思想是：</p>
<p>对参数的每一维，都累计当前梯度的平方，这样，梯度越大，这个方向累计的数值就越大。</p>
<p>接下来，用这个累计梯度平方根去计算$\alpha$, 累计梯度越大，$\alpha_t$就越小；累计梯度小的，$\alpha_t$就越大</p>
<p>我们把$\alpha$ 作为参数更新的学习率，使得每个维度的$\alpha$ 不同. 这样，对于各个方向的参数更新都会平滑一些，不会导致某些方向参数更新快，某些方向参数更新慢的这种Zig-Zag情况 </p>
<script type="math/tex; mode=display">
\begin{align}
&r_t = r_{t-1}+\nabla f(x_t)\times \nabla f(x_t)\\
&\alpha_t = \frac{\alpha}{\sqrt{r_t}+\delta}\\
&x_{t+1} = x_t -\alpha_t\nabla f(x_t)
\end{align}</script><p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">grad_squared = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	dx = compute_gradient(x)</span><br><span class="line">	grad_squared += dx*dx</span><br><span class="line">	x -= learning_rate * dx /(np.sqrt(grad_quared)+<span class="number">1e-7</span>)</span><br><span class="line"> <span class="comment"># 1e-7是超参，用以防止除零</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/29.png"></p>
<p>同时，Adagrad也有其局限性，因为在一段时间之后，在梯度更新很快的方向，$\sqrt{r_t}$很大，这个方向学习率可能会趋近于0，有可能导致在鞍点附近的参数无法更新</p>
<h4 id="RMSProp-Leakey-AdaGrad"><a href="#RMSProp-Leakey-AdaGrad" class="headerlink" title="RMSProp(Leakey AdaGrad)"></a>RMSProp(Leakey AdaGrad)</h4><p>为了解决某些方向累计梯度过大，我们对AdaGrad进行更新：对梯度平方做了一个很细小的改变(momentum)：</p>
<script type="math/tex; mode=display">
\begin{align}
&r_t = \text{decay rate}*r_{t-1}+\text{(1-decay rate)}*\nabla f^2(x_t)\\
&\alpha_t = \frac{\alpha}{\sqrt{r_t}+\delta}\\
&x_{t+1} = x_t -\alpha_t\nabla f(x_t)
\end{align}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grad_squared = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	dx = compute_gradient(x)</span><br><span class="line">	grad_squared += decay_rate*grad_squared+(<span class="number">1</span>-decay_rate)*dx*dx</span><br><span class="line">	x -= learning_rate * dx /(np.sqrt(grad_quared)+<span class="number">1e-7</span>)</span><br></pre></td></tr></table></figure>
<p>这样给累加的梯度乘以一个衰减率(0.9或者0.99)， 当某一个方向梯度更新得快的时候，就不会导致累计梯度增加过快。</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/30.png"></p>
<p>从图中我们可以看出，RMSProp相对与Momentum方法，它不容易越过最优点，而是以一种缓慢接近的方式达到最优点</p>
<h3 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h3><p>Adam的全称是 Adaptive Moment estimation</p>
<p>这种方法就是将momentum和Adagrad的思路结合起来</p>
<p>首先，<code>first_moment = beta1 * first_moment + (1-beta1)*dx</code>, 也就是momentum的计算。给梯度加上一个moving average。</p>
<p>其次，<code>second_moment = beta2 * second_moment + (1-beta2)*dx*dx</code> 也就是<code>Leakey AdaGrad</code>的做法，</p>
<p>最后，将这两种方法结合起来，即：<code>x -= leaning_rate * first_unbias / (np.sqrt(second_unbias)+1e-7)</code></p>
<p>注意，如果我们直接把first_moment和second_moment引用到更新式子中去的话，可能会导致初期的学习率过大. 因此，我们需要用bias correction来防止初期学习训练率过大的情况——让它们除以一个小于1的值，用来修正过大的学习率。</p>
<p>常用的初始设置:</p>
<ul>
<li>beta1=0.9</li>
<li>beta2=0.999</li>
<li>Learning_rate = 1e-3 or 5e-4</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">first_moment &#x3D; 0</span><br><span class="line">second_moment &#x3D; 0</span><br><span class="line">for t in range(1,num_iterations):</span><br><span class="line">	dx &#x3D; compute_gradient(x)</span><br><span class="line">	first_moment &#x3D; beta1 * first_moment + (1-beta1)*dx</span><br><span class="line">	second_moment &#x3D; beta2 * second_moment + (1-beta2)*dx*dx</span><br><span class="line">	first_unbias &#x3D; first_moment &#x2F; (1-beta1**t)</span><br><span class="line">	second_unbias &#x3D; second_moment &#x2F;(1-beta2**t)</span><br><span class="line">	x -&#x3D; leaning_rate * first_unbias &#x2F; (np.sqrt(second_unbias)+1e-7)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/31.png"></p>
<p>adam的优点很明显——既不会越过很多(Momentum的缺点)，又可以在各个方向平滑更新(Adagrad优点)</p>
<p>一般做实验的时候，常用adam</p>
<h2 id="学习率的设置"><a href="#学习率的设置" class="headerlink" title="学习率的设置"></a>学习率的设置</h2><p>前面是通过梯度来更新学习率，但初始学习率是一个超参，我们需要来了解学习率如何设置。因为学习率过大，会很容易越过损失函数的最优点；学习率过小，则会导致损失函数更新很慢。如下图所示</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/32.png"></p>
<p>常用的设置是：使用逐渐衰减(decay) 的学习率, 即越来越小。这是因为越接近optimal，越容易越过这个最优解，因此我们要让参数更新没那么快，以找到最优点。</p>
<ul>
<li>step decay: 每训练N个 iteration/epoch ，就除以常数</li>
<li>exponention decay: $\alpha = \alpha_0e^{-kt}$</li>
<li>1/t decay :$\alpha = \frac{\alpha_0}{1+kt}$</li>
</ul>
<h3 id="Step"><a href="#Step" class="headerlink" title="Step"></a>Step</h3><p>这就是我们使用了学习率下降后的曲线图，比如在SGD+Momentum这个优化方法中，学习率并不会自适应更新，因此我们学一段时间后就让学习率变小一点，这样能使loss持续不断地减小。比如说一开始把学习率设置为0.1,然后每30代乘以一个0.1 </p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/33.png"></p>
<h3 id="Cosine"><a href="#Cosine" class="headerlink" title="Cosine"></a>Cosine</h3><p>使用Step LR Schedule会带来的一大问题是：我们不知道训练几代去下调一次学习率，也不知道下调到多少达到的效果最好，因此需要多次试错。因此我们可以用一个平滑的曲线代替阶段式的调优：这里选取的就是余弦函数</p>
<script type="math/tex; mode=display">
\alpha_t = \frac{1}{2}\alpha_0(1+\cos(t\pi/T))</script><p>这样，学习率也从阶段式下降变成了一条平滑下降的曲线，如下图所示：</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/35.png" style="zoom:120%;"></p>
<p>Loss 曲线如下所示：</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/36.png"></p>
<p>相比于 Step，采用Cosine策略，我们要调整的超参就少了很多——只有两个必要的，而不需要引入新的超参</p>
<p>一个是初始的Learning Rate，还有一个是大写的T，也就是我们要训练的epoch数量</p>
<h3 id="Linear"><a href="#Linear" class="headerlink" title="Linear"></a>Linear</h3><p>当然，我们还可以采用线性下降的策略.</p>
<script type="math/tex; mode=display">
\alpha_t  =\alpha_0 (1-t/T)</script><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/37.png"></p>
<p>我们要有一个观念，并不存在那种学习率策略是更好的，这取决与训练的模型。因此Cosine和Linear是无高下之分的。</p>
<h3 id="Inverse-sqrt"><a href="#Inverse-sqrt" class="headerlink" title="Inverse sqrt"></a>Inverse sqrt</h3><p>还有一种策略是让 出示学习率除以迭代次数的平方根，公式如下：</p>
<script type="math/tex; mode=display">
\alpha_t = \alpha_0/\sqrt t</script><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/38.png"></p>
<p>这种学习率变化策略是：只在高学习率停留很小一段时间。在低学习率停留较长时间。(和Cosine策略有点相反)</p>
<h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><p>我们知道过拟合的坏处是很大的，因此我们要阻止过拟合的发生。这时，就需要正则化</p>
<h3 id="Add-term-to-the-loss"><a href="#Add-term-to-the-loss" class="headerlink" title="Add term to the loss"></a>Add term to the loss</h3><p>我们在之前反向传播的时候就提醒过，在Loss function中需要 添加正则化项：</p>
<script type="math/tex; mode=display">
L = \frac{1}{N}\sum_{i=1}^N \sum_{j\neq y_i}\max(0,f(x_i;W)_j-f(x_i;W)_{y_j}+1)+\lambda R(W)</script><p>其中，$\lambda$是超参数，代表正则化的强度</p>
<p>常使用的$R(W)$如下：</p>
<ul>
<li>L2 regularization  $R(W) = \sum<em>k\sum_lW</em>{k,l}^2$(Weight decay)</li>
<li>L1 regularization  $R(W) = \sum<em>k\sum_l|W</em>{k,l}|$</li>
<li>Elastic net(L1+L2) $R(W) = \sum<em>k\sum_l\beta W</em>{k,l}^2+|W_{k,l}|$ </li>
</ul>
<h3 id="Drop-out-减小特征的捕获"><a href="#Drop-out-减小特征的捕获" class="headerlink" title="Drop out 减小特征的捕获"></a>Drop out 减小特征的捕获</h3><p>我们可以随机丢失一些output,来让模型简化，减小冗余，我们不希望很多神经元去学习同一个特征，我们希望神经网络中的神经元有自己的“特长”，各自负责各自的特征。这样就可以减少过拟合发生的概率：</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/45.png"></p>
<p>一般来说，随机drop的概率设为0.5。这就给神经网络的训练增加了很大的随机性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">H1 = np.maximum (<span class="number">0</span>,np.dot(W1,X)+b1)</span><br><span class="line">U1 = np.random.rand(*H1.shape)&lt;p 	<span class="comment"># first dropout mask</span></span><br><span class="line">H1 *= U1 <span class="comment"># drop</span></span><br><span class="line">H2 = np.maximum(<span class="number">0</span>,np.dot(W2,H1)+b2)</span><br><span class="line">U2 = np.random.read(*H2.shape)&lt;p</span><br><span class="line">H2 *= U2 <span class="comment"># drop</span></span><br><span class="line">out = np.dot(W3,H2)+b3</span><br></pre></td></tr></table></figure>
<p>此外，drop out还可以减小计算压力，如果每一层都要做全连接的话，这种计算量是无法想象的</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/46.png"></p>
<p>在上图中，我们可以看到两个经典的神经网络是在哪几层进行Drop out的。在之后的一些神经网络架构中，如GoogleNet，ResNet，它们使用全局平均池化层来代替全连接层，这样就不需要dropout调节了</p>
<h4 id="Drop-out-Training-and-Testing"><a href="#Drop-out-Training-and-Testing" class="headerlink" title="Drop out Training and Testing"></a>Drop out Training and Testing</h4><p>在训练集和测试集上，Drop out 层的功能是不一样的。</p>
<p>在训练时，Drop out给神经网络增加可随机性：</p>
<script type="math/tex; mode=display">
y = f_W(x;z)</script><ul>
<li>y代表 Output</li>
<li>x代表 Input</li>
<li>z代表 Random Mask</li>
</ul>
<p>这样，设p为每个神经元输出的概率，那么在训练集上，神经元有1-p的概率是不输出任何值的，但是在测试集中，Drop out再产生随机性就说不通了，要不然，神经网络今天把图片认成猫明天认成狗，就不好了。<br>因此，在测试集上，我们仍然保留每个神经经元的输出，但在每个输出的值上乘以概率p。这样一来，测试集和训练集上，每个神经元输出的值的期望是保持相同的: $(1-p)\times 0\times w+p<em>w=w</em>p$</p>
<p>因此，在测试集上，Drop out层的代码应该这么写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">H1 = np.maximum(<span class="number">0</span>,np.dot(W1,X)+b1)*p</span><br><span class="line">H2 = np.maximum(<span class="number">0</span>,np.dot(W2,H1)+b2)*p</span><br><span class="line">out = np.dot(W3,H2)+b3</span><br></pre></td></tr></table></figure>
<h4 id="Inverted-dropout"><a href="#Inverted-dropout" class="headerlink" title="Inverted dropout"></a>Inverted dropout</h4><p>普通dropout和Inverted dropout的思想是一样的，区别就在于什么时候做 rescaling. 前者是在测试推理时进行rescaling，而后者则是在推理时保持不变，在训练时做rescaling. </p>
<p>具体实现就是：在训练时让一部分神经元失活，让 另一部分神经元的输出值除以p，即变大。</p>
<p>但不管怎么样，两种dropout的输出值的数学期望是相等的，设计Inverted dropout的出发点是不想去动测试集</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">p =<span class="number">0.5</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_step</span><span class="params">(X)</span>:</span></span><br><span class="line">  H1 = np.maximum (<span class="number">0</span>,np.dot(W1,X)+b1)</span><br><span class="line">  U1 = np.random.rand(*H1.shape)&lt;p /p	 <span class="comment">#我们把 /p 写在这里</span></span><br><span class="line">  H1 *= U1 <span class="comment"># drop</span></span><br><span class="line">  H2 = np.maximum(<span class="number">0</span>,np.dot(W2,H1)+b2)</span><br><span class="line">  U2 = np.random.read(*H2.shape)&lt;p /p</span><br><span class="line">  H2 *= U2 <span class="comment"># drop</span></span><br><span class="line">  out = np.dot(W3,H2)+b3</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(X)</span>:</span></span><br><span class="line">  H1 = np.maximum(<span class="number">0</span>,np.dot(W1,X)+b1)</span><br><span class="line">  H2 = np.maximum(<span class="number">0</span>,np.dot(W2,H1)+b2)</span><br><span class="line">  out = np.dot(W3,H2)+b3</span><br></pre></td></tr></table></figure>
<h3 id="正则化一般模板"><a href="#正则化一般模板" class="headerlink" title="正则化一般模板"></a>正则化一般模板</h3><p>正则化在训练时和推理(测试)时的实现是不同的，我们可以用这样的公式去表示：</p>
<ul>
<li>Training : 增加一些随机性</li>
</ul>
<script type="math/tex; mode=display">
y = f_W(x,z)</script><ul>
<li>Testing：将这些随机性公摊到输出值上(有时候是近似的)<script type="math/tex; mode=display">
y = f(x) = E_z(f(x,z)) = \int p(z)f(x,z)dz</script></li>
</ul>
<p>像刚才，我们介绍的Dropout就是一个很好的例子。此外，比如Batch Normalization也是类似的，它在训练时选取随机的minibatch去做归一化；但是在测试的时候，就是用规定下来的数据$\mu,\sigma^2$ 去给输入值做归一化</p>
<h3 id="Data-augumentation-增加训练数据"><a href="#Data-augumentation-增加训练数据" class="headerlink" title="Data augumentation 增加训练数据"></a>Data augumentation 增加训练数据</h3><p>增加训练数据的好处主要有两个：</p>
<ol>
<li>在一些神经网络中，输入值的数据量可能没有很大。比如说要用神经网络来训练医学影像，但是患者是有限的，拍片数量也是有限的，因此我们需要想办法增加训练集的数据。</li>
<li>如果训练集过小，神经网络的训练效果是不如机器学习的，因为很容易发生过拟合的情况，由此，我们更需要增加训练数据，避免过拟合。从这个角度看 ，增加训练数据的目的和正则化的目的是一样的，所以放在一起讲</li>
</ol>
<p>下面来讲几种增加训练数据的方法</p>
<h4 id="Transform-image"><a href="#Transform-image" class="headerlink" title="Transform image"></a>Transform image</h4><p>反转图片，如下</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/48.png"></p>
<p>和反转图片相似的，我们还可以扭曲部分图片像素，来达到增加训练数据的效果</p>
<h4 id="Color-jitter"><a href="#Color-jitter" class="headerlink" title="Color jitter"></a>Color jitter</h4><p>我们可以随机调整图片的对比度、亮度，如下</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/47.png"></p>
<h4 id="Random-Crops-and-Scales"><a href="#Random-Crops-and-Scales" class="headerlink" title="Random Crops and Scales"></a>Random Crops and Scales</h4><p>我们可以对一张照片进行裁剪和缩放，用相等的框框从图中选取$l\times l$的图片</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/49.png"></p>
<p>在推理的时候，我们可以平均多个crops的预测结果，已达到正则化的目的</p>
<h4 id="随机池化大小"><a href="#随机池化大小" class="headerlink" title="随机池化大小"></a>随机池化大小</h4><p>随机池化大小可以简单理解为对图片实行不同程度的模糊。其实现原理就是将不同尺度的像素块(patch)合在一起</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/50.png"></p>
<h4 id="Cutout"><a href="#Cutout" class="headerlink" title="Cutout"></a>Cutout</h4><p>在小数据集上还常用Cutout方法，就是用一个方块挡住图片中不同的位置</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/51.png"></p>
<h4 id="Mixup"><a href="#Mixup" class="headerlink" title="Mixup"></a>Mixup</h4><p>还有一种方法就是Mixup，将两张图片按照不同的权重合并起来，以增加训练数据</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/52.png"></p>
<h3 id="早停法"><a href="#早停法" class="headerlink" title="早停法"></a>早停法</h3><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/34.png"></p>
<p>还有一个技巧，是在合适的时候停止训练神经网络，当我们看到验证集的正确率开始下降、或者已经训练很长时间的时候，我们就该停止训练。这被称为(早停法)，如上图所示</p>
<h3 id="在实际训练中"><a href="#在实际训练中" class="headerlink" title="在实际训练中"></a>在实际训练中</h3><ul>
<li>在大型的全连接网络中，我们需要使用Drop out</li>
<li>训练的时候使用Batch Normalization和各种常用的data augmentation</li>
<li>在小数据集上尝试随机池化，cutout,mixup等方法</li>
<li>使用early stopping 和 ensembles model</li>
</ul>
<h2 id="超参的选择"><a href="#超参的选择" class="headerlink" title="超参的选择"></a>超参的选择</h2><h3 id="Grid-Search"><a href="#Grid-Search" class="headerlink" title="Grid Search"></a>Grid Search</h3><p>在神经网络中非常重要的两个超参数就是Weight decay以及Learning rate，为了找到合适的超参，我们肯定需要大量循环。一个方法就是将两者的取值写成列表，然后穷举搭配。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">weight_decay_list &#x3D; [1*10^(-4),1*10^(-3),1*10^(-2),1*10^(-1)]</span><br><span class="line">learning_rate &#x3D; [1*10^(-4),1*10^(-3),1*10^(-2),1*10^(-1)]</span><br><span class="line"></span><br><span class="line">for weight in weight_decay_list:</span><br><span class="line">	for learning_rate in learing_rate_list:</span><br><span class="line">		#...</span><br></pre></td></tr></table></figure>
<h3 id="Random-Search"><a href="#Random-Search" class="headerlink" title="Random Search"></a>Random Search</h3><p>相比于确定多个值去做穷举，我们可以划定一个范围，然后在里面随机挑选超参搭配。运行多次后找到合适的超参方案：</p>
<p>比如说采用 loguniform函数，即连续对数均匀分布（在浮点数空间中的对数尺度上均匀分布）。然后每次训练的时候在这个函数中随机取值</p>
<p>Weight decay: log-uniform on $[1\times10^{-4},1\times10^{-1}]$;</p>
<p>Weight decay: log-uniform on $[1\times10^{-4},1\times10^{-1}]$;</p>
<p>在上面这个例子中，即在$[-4,-1]$中随机取值t，取$1\times 10^{-t}$作为参数</p>
<h3 id="两种搜索方法辨析"><a href="#两种搜索方法辨析" class="headerlink" title="两种搜索方法辨析"></a>两种搜索方法辨析</h3><p>在一个神经网络里面可能有很多超参数，有些超参数对神经网络的影响非常大，而有些超参对神经网络的影响几乎可以忽略不计。</p>
<p>此时，如果采用 Grid Search，如左下图所示，由于采用相等的间隔采样，我们很可能会略过最优值，而如果缩小采样间隔，会导致训练时间更长。</p>
<p>但是对于 Random Search，如右下图所示，更可能选择到好的重要参数，然后只要继续做微调即可</p>
<p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/39.png"></p>
<h3 id="一般模式"><a href="#一般模式" class="headerlink" title="一般模式"></a>一般模式</h3><p>最后我们来讲如何选择超参数</p>
<p>综上，我们可以归结为如下步骤：</p>
<ol>
<li><p>验证loss计算的正确性</p>
<ul>
<li>是否加上正则项</li>
</ul>
</li>
<li><p>确保能够overfit一个小样本集</p>
<ul>
<li>我们可以从cifar10中选取10~50张图片作为模型</li>
<li>在不用正则项的情况下，初步调整学习率和初始化方法。<ul>
<li>如果loss始终不下降，说明学习率太小</li>
<li>如果loss突然暴增，说明学习率太大，已经跳过了最优点</li>
</ul>
</li>
</ul>
</li>
<li><p>使用全部数据集寻找合适的学习率</p>
<ul>
<li>加上很小的weight decay之后，在100个iteration以内搜索能使loss快速下降的学习率</li>
<li>一般可以尝试 0.1,0.01,0.001,0.0001</li>
</ul>
</li>
<li><p>粗粒度搜索学习率和weight decay，观察验证集结果</p>
<ul>
<li>在第3步确定的学习率范围内随机搜索，并随机搜索 weight decay</li>
<li>每个学习率和weight decay组合训练 ，一般取5个epoch</li>
</ul>
</li>
<li><p>细粒度搜索学习率和weight decay，观察验证集结果</p>
<ul>
<li>缩小第四步的搜索范围，训练更长时间 (大概20个epoch)</li>
</ul>
</li>
<li><p>根据learning curve 采取相应措施</p>
<ul>
<li><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/40.png"></p>
<p>如果出现上面这种情况，说明初始化有问题，我们应该调整参数初始化</p>
</li>
<li><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/41.png"></p>
<p>若出现上面这种情况，loss一直降不下来，我们可以尝试衰减学习率。(采用不同的策略)</p>
</li>
<li><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/42.png"></p>
<p>如果衰减学习率之后，loss出现一个断层，之后平滑、不再下降。说明我们衰减的太早了，还需要多训练几个epoch</p>
</li>
<li><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/43.png"></p>
<p>如果随着时间的推移，发现训练集的正确率持续上升而测试集正确率却逐渐走低。说明出现了过拟合的情况，此时需要增加正则，并使用更多数据</p>
</li>
<li><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/44.png"></p>
<p>如果训练集合测试集的准确率考的太近，说明我们选用的模型太小了，需要考虑使用更大的模型</p>
</li>
</ul>
</li>
<li><p>如果还是不理想，那么需要回到第五步再寻找</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2021/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%AD%E7%BB%83/55.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/" class="post-title-link" itemprop="url">数据库-系统可用性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-01 18:55:07" itemprop="dateCreated datePublished" datetime="2021-12-01T18:55:07+08:00">2021-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-23 20:10:24" itemprop="dateModified" datetime="2022-06-23T20:10:24+08:00">2022-06-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据库-系统可用性"><a href="#数据库-系统可用性" class="headerlink" title="数据库-系统可用性"></a>数据库-系统可用性</h1><p>系统的可用性是指：一个系统处在正常工作状态的时间比例</p>
<p> 比如说，一台机器的 MTTR(mean time to failure)是81.5年，MTTF(mean time to repair)是1h，那么：</p>
<ul>
<li>MTTF in hours = 81.5$\times$365$\times$24 = 713940</li>
<li>Inherent availability(Ai) = 713940/(713940+1) = 99.99986%</li>
</ul>
<p>怎么才能让服务器变得高可用呢?</p>
<p>我们可以使用 冗余节点(Redundancy) 和数据复制(Replication)的技术，当某节点发生故障时，切换到冗余节点。</p>
<h2 id="MongoDB的容错方案"><a href="#MongoDB的容错方案" class="headerlink" title="MongoDB的容错方案"></a>MongoDB的容错方案</h2><p>MongoDB诞生的时候，就决定部署在云上。那么在部署的时候我们就不能只放在一台机器上，需要做备份，如下图：</p>
<p><img src="/2021/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/1.png"></p>
<p>Primary是主机，有两个Secondary是主机的备份。系统要做的就是在主机更新时通知备份的及其来让这三个机器的数据保持一致。为了实现同步，我们需要了解<strong>心跳</strong>的含义，简单来说，心跳就是主机过一段时间(可能是几十毫秒).告诉对方我还在，还有心跳。一旦有Primary机器出故障了，就会影响心跳。这时候Secondary机器会感知到，其中一台机器变成了Primary, 如下图所示：</p>
<p><img src="/2021/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/2.png"></p>
<p>那么有一个问题：为什么是一主两备，而不是一主一备呢？第三台机器存在的意义是什么</p>
<p>其实，原来的高可用机制就是单机热备：</p>
<p>它的期望效果是：只要S1和S2 其中一个在线，系统即可用，如下图：</p>
<p><img src="/2021/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/3.png"></p>
<p>第一种情况，当S2出问题的时候，Primary S1还可以正常运行，等S2重启之后，再去做更新。</p>
<p>第二种情况，当Primary S1发生故障的时候，S2会宣布自己没有心跳了(Timeout)，然后S2转换身份变成Primary，当S1恢复之后，再把S2的信息同步给S1</p>
<p>这种设计，看起来只要两个主机不同时发生故障，就会一直运行下去，但事实上并非如此。如下图：</p>
<p><img src="/2021/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/4.png"></p>
<p>比如，最后一种情况，S1只是卡了一下，它并不认为自己是宕机了或者故障了，但此时S2已经收不到S1的心跳了，因此它决定变成Primary，但此时S1却回过神来了。这种情况下到底谁是Primary呢？这便出现了<strong>争议</strong>。有的用户会认为S1是Primary，而有的用户认为S2才是Primary。</p>
<p>解决办法只能是再增加一个S3，当两个人出现争议的时候，可以通过<strong>投票</strong>的方式选出新的Primary。</p>
<h2 id="Raft算法"><a href="#Raft算法" class="headerlink" title="Raft算法"></a>Raft算法</h2><p> raft是一个共识算法（consensus algorithm），所谓共识，就是多个节点对某个事情达成一致的看法，即使是在部分节点故障、网络延时、网络分割的情况下</p>
<p>而在分布式系统中，共识算法更多用于提高系统的容错性，比如分布式存储中的复制集（replication），在 带着问题学习分布式系统之中心化复制集 一文中介绍了中心化复制集的相关知识。raft协议就是一种leader-based的共识算法，与之相应的是leaderless的共识算法。</p>
<p>简单概括算法就是：raft会先选举出leader，leader完全负责replicated log的管理。leader负责接受所有客户端更新请求，然后复制到follower节点，并在“安全”的时候执行这些请求。如果leader故障，followes会重新选举出新的leader。</p>
<p>Raft算法可以分为几个子问题：Leader election , Log replication</p>
<h3 id="Leader-election"><a href="#Leader-election" class="headerlink" title="Leader election"></a>Leader election</h3><p>在raft协议中，一个节点任意时刻都处于以下三个状态之一：</p>
<ul>
<li>Leader</li>
<li>Follower</li>
<li>Candidate</li>
</ul>
<p>给出状态转移图能很直观的知道这三个状态的区别：</p>
<p><img src="/2021/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/5.png"></p>
<p>可以看出所有节点启动时都是follower状态；在一段时间内如果没有收到来自leader的心跳，从follower切换到candidate，发起选举；如果收到大多数节点的票（含自己的一票）则切换到leader状态；如果发现其他节点比自己更新，则主动切换到follower。</p>
<p> 总之，系统中最多只有一个leader，如果在一段时间里发现没有leader，则大家通过选举-投票选出leader。leader会不停的给follower发心跳消息，表明自己的存活状态。如果leader故障，那么follower会转换成candidate，重新选出leader。</p>
<h4 id="term"><a href="#term" class="headerlink" title="term"></a>term</h4><p>从上面可以看出，哪个节点做leader是大家投票选举出来的，每个leader工作一段时间，然后选出新的leader继续负责。这根民主社会的选举很像，每一届新的履职期称之为一届任期，在raft协议中，也是这样的，对应的术语叫<strong>term</strong>。</p>
<p><img src="/2021/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/6.png"></p>
<p>term（任期）以选举（election）开始，然后就是一段或长或短的稳定工作期（normal Operation）。从上图可以看到，任期是递增的，这就充当了逻辑时钟的作用；另外，term 3展示了一种情况，就是说没有选举出leader就结束了，然后会发起新的选举，后面会解释这种<em>split vote</em>的情况。</p>
<h4 id="选举过程"><a href="#选举过程" class="headerlink" title="选举过程"></a>选举过程</h4><p> 上面已经说过，如果follower在<em>election timeout</em>内没有收到来自leader的心跳，（也许此时还没有选出leader，大家都在等；也许leader挂了；也许只是leader与该follower之间网络故障），则会主动发起选举。步骤如下：</p>
<ul>
<li>增加节点本地的 <em>current term</em> ，切换到candidate状态</li>
<li>投自己一票</li>
<li>并行给其他节点发送 <em>RequestVote RPCs</em></li>
<li><p>等待其他节点的回复</p>
<p>在这个过程中，根据来自其他节点的消息，可能出现三种结果</p>
</li>
</ul>
<ol>
<li>收到majority的投票（含自己的一票），则赢得选举，成为leader</li>
</ol>
<blockquote>
<p> 第一种情况，赢得了选举之后，新的leader会立刻给所有节点发消息，广而告之，避免其余节点触发新的选举。在这里，先回到投票者的视角，投票者如何决定是否给一个选举请求投票呢，有以下约束：</p>
<ul>
<li>在任一任期内，单个节点最多只能投一票</li>
<li>候选人知道的信息不能比自己的少（这一部分，后面介绍log replication和safety的时候会详细介绍）</li>
<li>first-come-first-served 先来先得</li>
</ul>
</blockquote>
<ol>
<li>被告知别人已当选，那么自行切换到follower</li>
</ol>
<blockquote>
<p>第二种情况，比如有三个节点A B C。A B同时发起选举，而A的选举消息先到达C，C给A投了一票，当B的消息到达C时，已经不能满足上面提到的第一个约束，即C不会给B投票，而A和B显然都不会给对方投票。A胜出之后，会给B,C发心跳消息，节点B发现节点A的term不低于自己的term，知道有已经有Leader了，于是转换成follower。</p>
</blockquote>
<ol>
<li>一段时间内没有收到majority投票，则保持candidate状态，重新发出选举</li>
</ol>
<p><img src="/2021/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/7.png"></p>
<blockquote>
<p>第三种情况如上图所示，总共有四个节点，Node C、Node D同时成为了candidate，进入了term 4，但Node A投了NodeD一票，NodeB投了Node C一票，这就出现了平票 split vote的情况。这个时候大家都在等啊等，直到超时后重新发起选举。如果出现平票的情况，那么就延长了系统不可用的时间（没有leader是不能处理客户端写请求的），因此raft引入了randomized election timeouts来尽量避免平票情况。同时，leader-based 共识算法中，节点的数目都是奇数个，尽量保证majority的出现。</p>
</blockquote>
<h3 id="Log-replication"><a href="#Log-replication" class="headerlink" title="Log replication"></a>Log replication</h3><p>当有了leader，系统应该进入对外工作期了。客户端的一切请求来发送到leader，leader来调度这些并发请求的顺序，并且保证leader与followers状态的一致性。raft中的做法是，将这些请求以及执行顺序告知followers。leader和followers以相同的顺序来执行这些请求，保证状态一致。</p>
<h4 id="Replicated-state-machines"><a href="#Replicated-state-machines" class="headerlink" title="Replicated state machines"></a>Replicated state machines</h4><p>   共识算法的实现一般是基于复制状态机（Replicated state machines），何为复制状态机：</p>
<blockquote>
<p>If two identical, <strong>deterministic</strong> processes begin in the same state and get the same inputs in the same order, they will produce the same output and end in the same state.</p>
</blockquote>
<p>   简单来说：<strong>相同的初识状态 + 相同的输入 = 相同的结束状态</strong>。引文中有一个很重要的词<code>deterministic</code>，就是说不同节点要以相同且确定性的函数来处理输入，而不要引入一些不确定的值，比如本地时间等。如何保证所有节点 <code>get the same inputs in the same order</code>，使用replicated log是一个很不错的注意，log具有持久化、保序的特点，是大多数分布式系统的基石。</p>
<p>  因此，可以这么说，在raft中，leader将客户端请求（command）封装到一个个log entry，将这些log entries复制（replicate）到所有follower节点，然后大家按相同顺序应用log entry中的command，则状态肯定是一致的。</p>
<p><img src="/2021/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/8.png"></p>
<h4 id="请求完整流程"><a href="#请求完整流程" class="headerlink" title="请求完整流程"></a>请求完整流程</h4><p>当系统（leader）收到一个来自客户端的写请求，到返回给客户端，整个过程从leader的视角来看会经历以下步骤：</p>
<ul>
<li>leader append log entry</li>
<li>leader issue AppendEntries RPC in parallel</li>
<li>leader wait for majority response</li>
<li>leader apply entry to state machine</li>
<li>leader reply to client</li>
<li>leader notify follower apply log</li>
</ul>
<p>  可以看到日志的提交过程有点类似两阶段提交(2PC)，不过与2PC的区别在于，leader只需要大多数（majority）节点的回复即可，这样只要超过一半节点处于工作状态则系统就是可用的。</p>
<p>  那么日志在每个节点上是什么样子的呢</p>
<p><img src="/2021/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/9.png"></p>
<p> 不难看到，logs由顺序编号的log entry组成 ，每个log entry除了包含command，还包含产生该log entry时的leader term。从上图可以看到，五个节点的日志并不完全一致，raft算法为了保证高可用，并不是强一致性，而是最终一致性，leader会不断尝试给follower发log entries，直到所有节点的log entries都相同。</p>
<p>  在上面的流程中，leader只需要日志被复制到大多数节点即可向客户端返回，一旦向客户端返回成功消息，那么系统就必须保证log（其实是log所包含的command）<strong>在任何异常的情况下都不会发生回滚</strong>。这里有两个词：commit（committed），apply(applied)，前者是指日志被复制到了大多数节点后<strong>日志的状态</strong>；而后者则是节点将日志应用到状态机，真正影响到<strong>节点状态</strong>。</p>
<blockquote>
<p>The leader decides when it is safe to apply a log entry to the state machines; such an entry is called committed. Raft guarantees that committed entries are durable and will eventually be executed by all of the available state machines. A log entry is committed once the leader that created the entry has replicated it on a majority of the servers</p>
</blockquote>
<h3 id="Safety"><a href="#Safety" class="headerlink" title="Safety"></a>Safety</h3><p>在上面提到只要日志被复制到majority节点，就能保证不会被回滚，即使在各种异常情况下，这根leader election提到的选举约束有关。在这一部分，主要讨论raft协议在各种各样的异常情况下如何工作的。</p>
<p>  衡量一个分布式算法，有许多属性，如</p>
<ul>
<li>safety：nothing bad happens,</li>
<li>liveness： something good eventually happens.</li>
</ul>
<p>  在任何系统模型下，都需要满足safety属性，即在任何情况下，系统都不能出现不可逆的错误，也不能向客户端返回错误的内容。比如，raft保证被复制到大多数节点的日志不会被回滚，那么就是safety属性。而raft最终会让所有节点状态一致，这属于liveness属性。</p>
<p>  raft协议会保证以下属性</p>
<p><img src="/2021/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/10.png"></p>
<h4 id="Election-safety"><a href="#Election-safety" class="headerlink" title="Election safety"></a>Election safety</h4><p>  选举安全性，即任一任期内最多一个leader被选出。这一点非常重要，在一个复制集中任何时刻只能有一个leader。系统中同时有多余一个leader，被称之为脑裂（brain split），这是非常严重的问题，会导致数据的覆盖丢失。在raft中，两点保证了这个属性：</p>
<ul>
<li>一个节点某一任期内最多只能投一票；</li>
<li>只有获得majority投票的节点才会成为leader。</li>
</ul>
<p>  因此，<strong>某一任期内一定只有一个leader</strong>。</p>
<h4 id="log-matching"><a href="#log-matching" class="headerlink" title="log matching"></a>log matching</h4><p>很有意思，log匹配特性， 就是说如果两个节点上的某个<code>log entry</code>的<code>log index</code>相同且term相同，那么在该index之前的所有log entry应该都是相同的。如何做到的？依赖于以下两点</p>
<ul>
<li>If two entries in different logs have the same index and term, then they store the same command.如果不同日志中的两个条目具有相同的索引和term，那么它们存储的是同一个命令。</li>
<li>If two entries in different logs have the same index and term, then the logs are identical in all preceding entries.如果不同日志中的两个条目具有相同的索引和term，那么日志中的所有前面的条目都是相同的。</li>
</ul>
<p>首先，leader在某一term的任一位置只会创建一个log entry，且log entry是append-only。其次，consistency check。leader在AppendEntries中包含最新log entry之前的一个log 的term和index，如果follower在对应的term index找不到日志，那么就会告知leader不一致。</p>
<p>在没有异常的情况下，log matching是很容易满足的，但如果出现了node crash，情况就会变得复杂。比如下图</p>
<p><img src="/2021/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/11.png"></p>
<p><strong>注意</strong>：上图的a-f不是6个follower，而是某个follower可能存在的六个状态</p>
<p>leader、follower都可能crash，那么follower维护的日志与leader相比可能出现以下情况</p>
<ul>
<li>比leader日志少，如上图中的ab</li>
<li>比leader日志多，如上图中的cd</li>
<li>某些位置比leader多，某些日志比leader少，如ef（多少是针对某一任期而言）</li>
</ul>
<p>最终的结果是日志必须按照顺序记录的如下图：</p>
<p><img src="/2021/12/01/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B3%BB%E7%BB%9F%E5%8F%AF%E7%94%A8%E6%80%A7/9.png" style="zoom:50%;"></p>
<p> 因此，当出现了leader与follower不一致的情况，leader强制follower复制自己的log</p>
<blockquote>
<p>To bring a follower’s log into consistency with its own, the leader must find the latest log entry where the two logs agree, delete any entries in the follower’s log after that point, and send the follower all of the leader’s entries after that point.</p>
</blockquote>
<p>leader会维护一个<code>nextIndex[]</code>数组，记录了leader可以发送每一个follower的log index，初始化为eader最后一个log index加1， 前面也提到，leader选举成功之后会立即给所有follower发送AppendEntries RPC（不包含任何log entry， 也充当心跳消息）,那么流程总结为：</p>
<blockquote>
<p>s1 leader 初始化nextIndex[x]为 leader最后一个 log index + 1<br>s2 AppendEntries里prevLogTerm prevLogIndex来自 logs[nextIndex[x] - 1]<br>s3 如果follower判断prevLogIndex位置的log term不等于prevLogTerm，那么返回 False，否则返回True<br>s4 leader收到follower的回复，如果返回值是False，则nextIndex[x] -= 1, 跳转到s2. 否则<br>s5 同步nextIndex[x]后的所有log entries</p>
</blockquote>
<h4 id="leader-completeness-vs-elcetion-restriction"><a href="#leader-completeness-vs-elcetion-restriction" class="headerlink" title="leader completeness vs elcetion restriction"></a>leader completeness vs elcetion restriction</h4><p>  leader完整性：如果一个log entry在某个任期被提交（committed），那么这条日志一定会出现在所有更高term的leader的日志里面。这个跟leader election、log replication都有关。</p>
<ul>
<li>一个日志被复制到majority节点才算committed</li>
<li>一个节点得到majority的投票才能成为leader，而节点A给节点B投票的其中一个前提是，B的日志不能比A的日志旧。下面的引文指处了如何判断日志的新旧</li>
</ul>
<blockquote>
<p>voter denies its vote if its own log is more up-to-date than that of the candidate.</p>
<p>If the logs have last entries with different terms, then the log with the later term is more up-to-date. If the logs end with the same term, then whichever log is longer is more up-to-date.</p>
</blockquote>
<p>  上面两点都提到了majority：commit majority and vote majority，根据Quorum，这两个majority一定是有重合的，因此被选举出的leader一定包含了最新的committed的日志。</p>
<p>  raft与其他协议（Viewstamped Replication、mongodb）不同，raft始终保证leade包含最新的已提交的日志，因此leader不会从follower catchup日志，这也大大简化了系统的复杂度。</p>
<p>我们可以在 Raft官网看到可视化的Raft，十分有趣 <a href="https://raft.github.io/" target="_blank" rel="noopener">https://raft.github.io/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/11/29/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch12-%E5%AD%90%E6%A8%A1%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/29/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch12-%E5%AD%90%E6%A8%A1%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">数据科学算法ch12-子模函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-29 15:54:33" itemprop="dateCreated datePublished" datetime="2021-11-29T15:54:33+08:00">2021-11-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-06 23:38:10" itemprop="dateModified" datetime="2022-01-06T23:38:10+08:00">2022-01-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据科学算法ch12-子模函数"><a href="#数据科学算法ch12-子模函数" class="headerlink" title="数据科学算法ch12-子模函数"></a>数据科学算法ch12-子模函数</h1><p>子模函数时边际效用递减规律的形式化表示。在机器学习和人工智能领域，子模函数有着广泛的应用，如文档摘要、信息扩散、传感器布置和图像采集描述等诸多问题</p>
<p>比如说：要在办公楼里面布置无线网络，由于在不同的位置安装无线路由器的效果是不同的，那么在那些地方安装无线路由器能满足上述条件且总花费越低？要知道，部署的无线路由器越多，对提升网络覆盖率的贡献就越低。</p>
<p>又比如说：在大数据时代，日常看到的信息可能是片面零散的，可以采用文本摘要技术来帮助人们解决碎片化阅读的问题。我们的目标是用尽量少的句子来覆盖用户感兴趣的关键词。当选择的句子越来越多，未被包含的关键词就越少，因此选择句子对文本中的关键词覆盖也符合边际效用递减的规律。</p>
<p>上面例子中都设计边际效用递减规律，在数学上这个规律可以被定义为子模函数</p>
<h2 id="子模函数"><a href="#子模函数" class="headerlink" title="子模函数"></a>子模函数</h2><p>在了解子模函数前，我们首先了解一下凸函数和凹函数：</p>
<p><img src="/2021/11/29/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch12-%E5%AD%90%E6%A8%A1%E5%87%BD%E6%95%B0/1.png" alt></p>
<p>现在我们从凹函数到子模：</p>
<p>对于集合函数$f:{0,1}^n\rightarrow \mathbb R,\forall i,\partial_if(x)=f(x+e_i)-f(x)$ <strong>是非增的</strong>，那么$f(x)$就是子模函数</p>
<p>也就是说，从集合中任意调出一个子集来，我们可以将其映射为一个实数，然后这个实数的变化趋势和凹函数是一致的。</p>
<p>但是对于集合函数来讲，单调性并不是说一个大小为5的子集对应的函数的值一定大于一个大小为4的子集。它只大于它自己的大于等于4的子集的函数值。</p>
<p>用集合的话来说：</p>
<p>集合函数： $f:{0,1}^n\rightarrow \mathbb R$ 是子模函数当且仅当对 $\forall A,B\subseteq V$, 以下不等式成立</p>
<script type="math/tex; mode=display">
f(A)+f(B)\geq f(A\cap B)+f(A\cup B)</script><p><img src="/2021/11/29/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch12-%E5%AD%90%E6%A8%A1%E5%87%BD%E6%95%B0/2.png"></p>
<h3 id="子模函数的等价定义"><a href="#子模函数的等价定义" class="headerlink" title="子模函数的等价定义"></a>子模函数的等价定义</h3><p>子模函数有两个等价定义：</p>
<p><strong>边际效用递减</strong>：</p>
<p>对任意的 $S\subseteq T\subseteq V$ 和 $v\in V \backslash T$ </p>
<script type="math/tex; mode=display">
f(S\cup \{v\})-f(S)\geq f(T\cup \{v\})-f(T)</script><p>这实际上就是边际效用递减规律的<strong>形式化表述</strong>。</p>
<ul>
<li>我们可以把边际效用看做是：$f(S\cup {v})-f(S)$ ，即在集合S中增加元素 $v$ 导致函数值变化。</li>
<li>进一步，随着集合$S$ 的不断增大，比如增加到集合<strong>T</strong> ,那么显然边际效用 $f(T\cup {v})-f(T)$ 是不断减少的。</li>
</ul>
<p>因此，我们说当 $S\subseteq T$ 的时候，$f(S\cup {v})-f(S)\geq f(T\cup {v})-f(T)$</p>
<p><strong>集合效用递减：</strong></p>
<p>对于任意的$S\subseteq T\subseteq V$ 以及 $C\subseteq V \backslash T$ </p>
<p>满足：</p>
<script type="math/tex; mode=display">
f(S\cup C)-f(S) \geq f(T\cup C)-f(T)</script><p>也很容易理解，上面是加一个元素，现在是加一个集合，归根到底就是边际效用递减</p>
<h3 id="子模函数的性质"><a href="#子模函数的性质" class="headerlink" title="子模函数的性质"></a>子模函数的性质</h3><p>假设 $f(A)$ 和 $g(A)$ 为任意两个子模函数，则：</p>
<ol>
<li>对 $\forall a&gt; 0$ ,$af(A)$ 也是一个子模函数</li>
<li>$f(A)+g(A)$ 也是一个子模函数</li>
<li>$\overline f(A)=f(A^c)$ 也是一个子模函数</li>
<li>对任意固定的 $S\subset U$,$f(A|S)=f(A\cap S)$ 也是一个子模函数</li>
<li>对任意固定的 $S\subset U$ ,$f(A|S^c) = f(A\cup S)-f(S)$  也是一个子模函数</li>
</ol>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h4><p>给定一个集合$ V$，当$A\subseteq V$ 的时候，有 $f(A)$ 是一个子模函数</p>
<p>a. 证明 $\overline f(A)= f(A^c)$ 是一个子模函数</p>
<p>b. 证明 当$S\subset V,~g(A) = f(A\cap S) $ 是一个子模函数</p>
<p>证明什么函数是一个子模函数，我们一定要从定义入手，也就是 $f(S)+f(T)\geq f(S\cup T)+f(S\cap T)$</p>
<p>比如说a, 我们令 $A = S^c,B=T^c$, 带入到 $f(A)$中，得到</p>
<script type="math/tex; mode=display">
f(A)+f(B) \geq f(A\cup B)+f(A\cap B)\\~\\
f(S^c)+f(T^c)\geq f(S^c\cup T^c)+f(S^c\cap T^c)</script><p>已知：</p>
<script type="math/tex; mode=display">
A\cup B = S^c\cup T^c = (S\cap T)^c\\
A\cap B = S^c\cap T^c = (S\cup T)^c\\

f(S\cap T)^c = \overline f(S\cap T)\\
f(S\cup T)^c = \overline f(S\cup T)</script><p>又：</p>
<script type="math/tex; mode=display">
f(S^c) = \overline f(S)\\
f(T^c) = \overline f(T)</script><p>因此，上式可以化为：</p>
<script type="math/tex; mode=display">
\overline f(S)+\overline f(T)\geq \overline f(S\cap T)+\overline f(S\cup T)</script><p>得证</p>
<hr>
<p>对于b，即：</p>
<script type="math/tex; mode=display">
\begin{align}
f(A\cap S)+f(B\cap S) &\geq f\bigg((A\cap S)\cup(B\cap S)\bigg)+f\bigg((A\cap S)\cap(B\cap S)\bigg)\\
&\geq f\bigg((A\cup B)\cap S \bigg)+f\bigg( (A\cap  B)\cap S \bigg)\\
\end{align}</script><p>我们令  $S = A\cap S, T = B\cap S$, 那么，根据上式，可知： $g(S)+g(T) \geq g(S\cap T)+g(S\cup T)$</p>
<h4 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h4><p>a. 证明<strong>边际效用递减</strong>的等价定义</p>
<p>需要分充分性和必要性证明，首先证明必要性</p>
<p>令 $S\subset T$ ，给定集合 $S\cup{V}$ 和 $T$， 如果 $v\notin T$, 根据定义，我们有：</p>
<script type="math/tex; mode=display">
f(S\cup\{v\})+f(T)\geq f(S\cup \{v\}\cup T)+f(S\cup\{v\}\cap T)</script><p>注意到： $f(S\cup{v}\cup T)=f(T\cup{v}),f((S\cup{v})\cap T)=f(S)$ </p>
<p>带入上式，有：</p>
<script type="math/tex; mode=display">
f(S\cup \{v\})-f(S)\geq f(T\cup\{v\})-f(T)</script><p>然后，我们来证明充分性</p>
<p>给定两个集合 $S$ 和 $T$ ,令 $T\backslash S = {v_1,v_2\cdots,v_k}$, $T_j = {v_1,\cdots,v_j}$ , 我们令：$A_j = (S\cap T)\cup T_j,B_j = S\cup T_j$ , 我们有：</p>
<script type="math/tex; mode=display">
f(A_j\cup{v_{j+1}})-f(A_j)\geq f(B_j\cup{v_{j+1}})-f(B_j),j = 0,\cdots,k-1</script><p>对上式的$k-1$ 个句子求和，可以得到：</p>
<script type="math/tex; mode=display">
f(S)+f(T)\geq f(S\cup T)+f(S\cap T)</script><p>b. 证明<strong>集合效用递减</strong>的等价定义</p>
<p>将上面的$v_i$ 换成集合$C$ 即可</p>
<h4 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h4><p>设 $w: N\rightarrow R$ 表示有限集 $N$ 中元素的权重，考虑一个线性函数为：</p>
<script type="math/tex; mode=display">
f(S) = \sum_{i\in S}w_i ,\forall S\subseteq N</script><p>证明这个线性函数是一个子模函数</p>
<script type="math/tex; mode=display">
f(S) = \sum_{i\in S} w_i\\
f(T) =\sum_{i\in T} w_i\\
f(S\cup T) = \sum_{i\in {S\cup T}} w_i\\
f(S\cap T) = \sum_{i\in {S\cap T}} w_i\\
f(S\cup T)+f(S\cap T) = \sum_{i\in S\cup T}w_i+\sum_{i\in S\cap T} w_i= \sum_{i\in S}w_i+\sum_{i\in T}w_i-\sum_{i\in S\cap T}+\sum_{i\in S\cap T}=f(S)+f(T)\\</script><p>满足 子模函数对 $f(S)+f(T)\geq f(S\cup T)+f(S\cap T)$ 的定义，因此这个函数是一个子模函数</p>
<h2 id="集合覆盖"><a href="#集合覆盖" class="headerlink" title="集合覆盖"></a>集合覆盖</h2><p>首先给出覆盖及其相关定义：</p>
<blockquote>
<p>集合覆盖</p>
</blockquote>
<p>设A是非空集，C是集合A的非空子集组成的集合，即$C={A<em>\alpha|A</em>\alpha\in A,A_\alpha\neq \empty}$ ，C是集合A的覆盖，若C满足：</p>
<script type="math/tex; mode=display">
\bigcup_{A_\alpha\in C}A_{\alpha} = A</script><blockquote>
<p>最小全覆盖问题</p>
</blockquote>
<p>令U为一有限集，$\mathcal S = {s_1,\cdots,s_n}$ 为 由U的n个子集构成的集族，全覆盖问题是找到$\mathcal S$最小的子集盖 集合U</p>
<p>简单来说，就是找到最小的 句子集合包含所有的单词</p>
<blockquote>
<p>k-最大覆盖问题</p>
</blockquote>
<p>令$U$为一有限集，$\mathcal S={s_1,s_2\cdots,s_n}$ 为由$U$的n个子集构成的集族，给定正整数k，最大子覆盖问题就是从$\mathcal S$ 中找到k个子集，使得这k个子集覆盖集合$U$中最多的元素</p>
<p>简单来说，找到k个句子使得其包含的单词数量最多</p>
<h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p>比如话务验业务技能全集$U={a,b,c,d,e,f,g,h,i,j,k,l}$，现在考虑有7名候选话务员的集合$S={A_1,A_2\cdots,A_7}$ ,其中，7位话务员的技能分别为：</p>
<script type="math/tex; mode=display">
A_1= \{a,b,c,d\},A_2= \{e,f,g,h\},A_3 = \{i,j,k,l\}\\
A_4 = \{a,e\},A_5 = \{i,b,f,g\},A_6 = \{c,e,h,j,k,l\},A_7 = \{l\}</script><p> 对于最小全覆盖问题：</p>
<p>话务员集合 $C_1 = {A_1,A_2,A_3,A_4}$和$C_2={A_1,A_5,A_6}$ 中的话务员都能满足客户所有类型的需求。但是集族$C_1$需要4位话务员，而集族$C_2$ 只需要3为话务员。因此$C_1$并不可能是$U$的最小全覆盖，而不存在两位话务员的集合就能实现全覆盖，因此$C_2$ 是全集U的一个最小全覆盖。</p>
<p>当然，$S={A_1,A_2,A_3}$ 也是一个大小为3 的全覆盖</p>
<p>对于最大覆盖问题：</p>
<p>假定只能制定两名话务员向客户提供服务，应该选择那两位话务员呢？</p>
<p>由于第6位话务员包含了6种技能，是所有话务员中技能最多的，为了使得应对的客户需求尽可能的多，可以把第6位作为候选之一。而且${A_1,A_2,A_3,A_5}$都有4种业务技能，且：</p>
<script type="math/tex; mode=display">
A_1\cap A_6 = \{c\},A_2\cap A_6 = \{e,h\}\\
A_3\cap A_6 = \{j,k,l\},A_5\cap A_6 = \{\empty\}</script><p>进一步：</p>
<script type="math/tex; mode=display">
\abs{A_1\cap A_6} = 9,\abs{A_2\cap A_6} = 8\\
\abs{A_3\cap A_6} =7,\abs{A_5\cap A_6} = 10</script><p>因此，集族$C={A_5,A_6}$ 能够覆盖客户10类不同的需求，因此集族$C={A_5,A_6}$ 构成$k=2$时的最大覆盖</p>
<p>对于这种小数据量问题，从中发现最大覆盖还是比较容易的。但是很多应用中数据规模都很大，比如在文本摘要中全集可以是一些关键词。给定的语料中可能包含成千上万的句子，此时要发现最大覆盖就不那么容易了</p>
<h3 id="抽取式文本摘要"><a href="#抽取式文本摘要" class="headerlink" title="抽取式文本摘要"></a>抽取式文本摘要</h3><p>给定用户定义的n个关键词组成的集合 $W={w_1,w_2\cdots,w_n}$ 和 m个候选句子集合$\mathcal S = {s_i|s_i\sub W,i=1,2\cdots,m}$ ，其中句子$s_i$ 表示该句子包含的关键词集合。抽取式文本摘要问题旨在选择k个句子，使得这k个句子能够包含最多数量的关键词</p>
<p>用整数规划的形式来表达，可以是：</p>
<p>令$\mathscr{C}$ 为找出的k个句子，那么设</p>
<script type="math/tex; mode=display">
x_i=\cases{1,S_i\in \mathscr C\\0,S_i\notin\mathscr C} 
\\~\\
y_i = \cases{1,w_j\in \bigcup_{S\in \mathscr T}S\\0,w_j\notin \bigcup_{S\in\mathscr T}S}</script><p>整数规划问题可写为：</p>
<script type="math/tex; mode=display">
\begin{align}
&\max \sum_j y_j\\
s.t.&\sum_i x_i\leq k\\
&\sum_{w_j\in S_i} x_i\geq y_j\\
&x_i\in\{0,1\},\forall i\in[m]\\
&y_j\in\{0,1\},\forall j\in [n]
\end{align}</script><h2 id="爬山算法"><a href="#爬山算法" class="headerlink" title="爬山算法"></a>爬山算法</h2><p>爬山算法是一个解决子模优化问题的局部搜索算法。下图是爬山算法的一个实例，它解决了最大子覆盖问题。该算法在每次迭代过程中选择使得集合覆盖函数$f(A)$<strong>边际增幅最大 </strong>的候选元素u，通过不停地迭代，从一个候选结果想另一个候选结果”移动”直到终止条件满足</p>
<p><img src="/2021/11/29/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch12-%E5%AD%90%E6%A8%A1%E5%87%BD%E6%95%B0/3.png"></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>假设给定的关键词集合为 $W={w_1,w_2\cdots,w_S}$ ，共有9个候选句子$D={s_1,s_2\cdots,s_9}$ ，用于文本摘要，其中这9个句子包含的关键词分别为：</p>
<script type="math/tex; mode=display">
\begin{align}
&s_1 = \{w_1,w_2,w_8\}~s_2=\{w_1,w_3,w_7\}~s_3 = \{w_1,w_6\}\\
&s_4 = \{w_1,w_3,w_7,w_8\}~s_5=\{w_1,w_5,w_6\}~s_6 = \{w_1,w_5,w_8\}\\
&s_7 = \{w_5\},s_8 = \{w_1,w_4,w_6\} ,s_9 = \{w_2,w_8\}
\end{align}</script><ul>
<li>第一轮迭代：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>子集</th>
<th>f(A)</th>
<th>$f(A\cup A_i)$</th>
<th>$\Delta$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$s_1$</td>
<td>0</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>$s_2$</td>
<td>0</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>$s_3$</td>
<td>0</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>$s_4$</td>
<td>0</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>$s_5$</td>
<td>0</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>$s_6$</td>
<td>0</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>$s_7$</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>$s_8$</td>
<td>0</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>$s_9$</td>
<td>0</td>
<td>2</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<p>我们看到，第一轮，一定是选择包含关键词最多的那个句子，也就是 $s_4$. 现在，$f(A) = {w_1,w_3,w_7,w_8}$ </p>
<ul>
<li>第二轮迭代：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>子集</th>
<th>f(A)</th>
<th>$f(A\cup A_i)$</th>
<th>$\Delta$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$s_1$</td>
<td>4</td>
<td>5</td>
<td>1</td>
</tr>
<tr>
<td>$s_2$</td>
<td>4</td>
<td>4</td>
<td>0</td>
</tr>
<tr>
<td>$s_3$</td>
<td>4</td>
<td>5</td>
<td>1</td>
</tr>
<tr>
<td>$s_5$</td>
<td>4</td>
<td>6</td>
<td>2</td>
</tr>
<tr>
<td>$s_6$</td>
<td>4</td>
<td>5</td>
<td>1</td>
</tr>
<tr>
<td>$s_7$</td>
<td>4</td>
<td>5</td>
<td>1</td>
</tr>
<tr>
<td>$s_8$</td>
<td>4</td>
<td>6</td>
<td>2</td>
</tr>
<tr>
<td>$s_9$</td>
<td>4</td>
<td>5</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>在第二轮迭代中，边际效益就少了很多了，我们看到 边际效益最大的是 $s_5,s_8$，这里选择靠前的，也就是$s_5$, 更新 $f(A) = {w_1,w_3,w_5,w_6,w_7,w_8}$</p>
<ul>
<li>第三轮迭代</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>子集</th>
<th>f(A)</th>
<th>$f(A\cup A_i)$</th>
<th>$\Delta$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$s_1$</td>
<td>6</td>
<td>7</td>
<td>1</td>
</tr>
<tr>
<td>$s_2$</td>
<td>6</td>
<td>6</td>
<td>0</td>
</tr>
<tr>
<td>$s_3$</td>
<td>6</td>
<td>6</td>
<td>0</td>
</tr>
<tr>
<td>$s_6$</td>
<td>6</td>
<td>6</td>
<td>0</td>
</tr>
<tr>
<td>$s_7$</td>
<td>6</td>
<td>6</td>
<td>0</td>
</tr>
<tr>
<td>$s_8$</td>
<td>6</td>
<td>7</td>
<td>1</td>
</tr>
<tr>
<td>$s_9$</td>
<td>6</td>
<td>7</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>第三轮迭代，大多数边际效益都为0了，这里选择 最靠前的边际效益最大的句子 $s_1$</p>
<p>因此，我们看见，爬山算法并不是只有一种结果，只要让$f(A)$ 到达终止条件即可</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">数据科学算法ch11-整数规划</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-23 22:27:16" itemprop="dateCreated datePublished" datetime="2021-11-23T22:27:16+08:00">2021-11-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-06 20:39:04" itemprop="dateModified" datetime="2022-01-06T20:39:04+08:00">2022-01-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据科学算法ch11-整数规划"><a href="#数据科学算法ch11-整数规划" class="headerlink" title="数据科学算法ch11-整数规划"></a>数据科学算法ch11-整数规划</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>这章我们来学习<strong>离散变量的优化问题</strong>。这些问题的描述非常简单，但是由于”组合爆炸”的原因，导致求解此类问题的最优解变得非常困难。典型的问题有：旅行商问题(TSP),集合覆盖问题(SCP)等。这里给出几例</p>
<h3 id="旅行商问题"><a href="#旅行商问题" class="headerlink" title="旅行商问题"></a>旅行商问题</h3><p>给定一组城市以及每两个城市间的旅行成本(或距离)，旅行商问题(TSP)旨在：在经过每个城市一次的情况下最后回到出发的城市，应该如何选择行进路线以使总行程最短？ </p>
<p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/1.png" style="zoom:67%;"></p>
<p>即输入：包含n个点的几何，以及两两间的成本</p>
<p>输出：如果遍访所有顶点，对 对称TSP问题 的可行解决方案为$\frac{(n-1)!}2$ </p>
<p>目标函数：最小化旅行成本(或距离)的大小</p>
<p>那么TSP就可以定义在一个无向图上：$G=(V,E)$,其中$V$为顶点集合 $E$为边的集合，且每条边的成本为 $c_{jj}$</p>
<p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/18.png"></p>
<p>约束的第一个式子：保证从一个城市出发只能去一个城市</p>
<p>约束的第二个式子：保证每个城市只能被访问一次 </p>
<p>约束的第三个式子：保证只有n个顶点构成的一个环，从而回到出发的城市。如果地图上有两个环，就不是TSP问题的解</p>
<h3 id="集合覆盖问题-SCP"><a href="#集合覆盖问题-SCP" class="headerlink" title="集合覆盖问题(SCP)"></a>集合覆盖问题(SCP)</h3><p>输入：</p>
<ul>
<li>全集 $U = {u_1,u_2,\cdots,u_n}$</li>
<li>子集簇 $S = {S_i|S_i\subseteq U ,i\in [1,\cdots,m]}$​​</li>
<li>成本 $C = {c_1,\cdots,c_m}$</li>
</ul>
<p>目标：找到一个指标集 $I\in {1,\cdots,m}$ ，使得$\sum<em>{i\in I}c_i$ 最小且满足 $\bigcup</em>{i\in I}S_i = U$</p>
<p>集合覆盖问题具有广泛的应用：</p>
<ul>
<li>全覆盖和最大覆盖</li>
<li>顶点覆盖</li>
<li>信息传播</li>
<li>文本摘要</li>
</ul>
<h3 id="Fiver-游戏"><a href="#Fiver-游戏" class="headerlink" title="Fiver 游戏"></a>Fiver 游戏</h3><p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/2.png" style="zoom:67%;"></p>
<p>问题定义：我们注意到，同一个圆圈被点击两次，又恢复了原样，若一个圆圈为红色，这个圆圈及其周围4个圆圈总共被点击的次数一定为一个奇数。</p>
<p>因此我们可以定义：</p>
<script type="math/tex; mode=display">
x_{ij} = \cases{1,\text{circle}~(i,j) ~\text{is clicked}\\0,\text{otherwise}}</script><p>该问题可以建模为：</p>
<script type="math/tex; mode=display">
\begin{align}
&\min \sum_{i}^5\sum_i^5x_{ij}\\
&x_{ij}+x_{i(j-1)}+x_{i(j+1)}+x_{(i-1)j}+x_{(i+1)j} ~\text{is odd}\\
&x_{ij}\in\{0,1\},\forall i,j\in[1,5]\\
&x_{ij}=0,\text{otherwise}\\
\end{align}</script><p>然而，这并不是一个规划问题，因为其中的约束条件并不是线性的。我们知道最坏的条件就是一个圆圈被点击了五次变为红色(自己+左右上下)，那通过引入一个自由变量$y_{ij}$​, 令其取值为$[0,2]$,我们就可以将这个问题转化成一个整数规划的问题：</p>
<script type="math/tex; mode=display">
\begin{align}
&\min \sum_{i}^5\sum_i^5x_{ij}\\
&x_{ij}+x_{i(j-1)}+x_{i(j+1)}+x_{(i-1)j}+x_{(i+1)j} -2y_{ij} =1\\
&x_{ij}\in\{0,1\},\forall i,j\in[1,5]\\
&x_{ij}=0,\text{otherwise}\\
&0\leq y_{ij}\leq 2,y_{ij}\in N,1\leq i,j\leq 5
\end{align}</script><p>这里，$y<em>{ij}=0$，就是取1的情况；$y</em>{ij}=1$ 就是取3的情况；$y_{ij}=2$​ ,就是填5的情况。也就是覆盖了所有情境，将自然语言转换成了优化条件</p>
<p>以上举的三个例子，最后都转换成了线性整数规划，其要求就是输入和输出都是线性函数，可行解是所有满足这些线性等式(不等式)，且要满足完整性(即整数)，接下来详细来介绍一下：</p>
<h2 id="整数规划"><a href="#整数规划" class="headerlink" title="整数规划"></a>整数规划</h2><p>线性整数规划化在我们初中的时候就已经学过了，就是一类需要用画图解决的应用题。但是难点就在于如何建模，使得自然语言转换成约束条件。</p>
<p>线性整数规划类型可以分成下面三种：</p>
<p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/3.png" style="zoom:67%;"></p>
<p>第一种 混合线性整数规划。在这章中没有涉及，没有特别有效的方法来解决。</p>
<p>第二种 线性整数规划，即目标函数是线性的，约束是线性条件，<strong>解的类型是整数</strong></p>
<p>第三种 0-1线性规划，是线性整数规划的一种特殊类型，比如Fiver问题、TSP问题。其特点就是变量的类型都是布尔型。 </p>
<p>比如说这里有一个整数规划的问题：</p>
<script type="math/tex; mode=display">
\max z = 3x+4y\\
\text{约束条件}~ x+y\leq4\\
2x+3y\leq 9\\
0\leq x,y\in \boldsymbol Z</script><p>其可行域就是由空心点组成的集合：</p>
<p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/4.png" style="zoom:67%;"></p>
<h2 id="分支定界法"><a href="#分支定界法" class="headerlink" title="分支定界法"></a>分支定界法</h2><p>上面这个整数规划的例子，只有两个决策变量，即使每个可行解都试一遍，也很快就能得到该整数规划问题的解，那么如果有很多决策变量的情况该怎么办呢？</p>
<p>我们要学习：枚举树</p>
<p>比如下面这个例子</p>
<script type="math/tex; mode=display">
\max 24x_1+2x_2+20x_3+4x_4\\
\text{约束条件} ~~~8x_1+x_2+20x_3+4x_4\leq 9\\
x_i\in\{0,1\},1\leq i\leq 4</script><p>如果我们一一枚举，那么所有可能的取值有$2^4$种，但是在现实生活中，决策变量的数量可能为n，如果一个一个去，那么可行域的大小就可能是$2^n$ 。因此，如何有效地遍历整个可行域成为一个关键的问题。</p>
<p>通常，我们可以利用枚举树把整个可行域迭代地分割为越来越小的子集，每个子集称为一个<strong>分支</strong>。</p>
<p>在枚举树中，每个节点对应一个整数规划的问题，<strong>其中根节点是原始的整数规划问题</strong>，每个节点的孩子，是在父亲节点对应的整数规划问题上，通过<strong>固定某个决策变量</strong>的取值来得到一个新的整数规划问题。</p>
<p>以上面这个整数规划问题为例，那么$IP(1)$ 对应的整数规划问题是：</p>
<script type="math/tex; mode=display">
\begin{align}
&\text{IP(1)}\\
&\max 24x_1+2x_2+20x_3+4x_4\\
&\text{约束条件} ~~~8x_1+x_2+5x_3+4x_4\leq 9\\
&x_i\in\{0,1\},1\leq i\leq 4\\
\end{align}</script><p>那么根节点的两个孩子节点$IP(2)$和$IP(3)$ 分别为如下的整数规划问题：</p>
<script type="math/tex; mode=display">
\begin{align}
&\text{IP(2)}\\
&\max 24x_1+2x_2+5x_3+4x_4\\
&\text{约束条件} ~~~8x_1+x_2+20x_3+4x_4\leq 9\\
&x_1=0\\
&x_i\in\{0,1\},2\leq i\leq 4\\~\\
&\text{IP(3)}\\
&\max 24x_1+2x_2+20x_3+4x_4\\
&\text{约束条件} ~~~8x_1+x_2+5x_3+4x_4\leq 9\\
&x_1=1\\
&x_i\in\{0,1\},2\leq i\leq 4\\
\end{align}</script><p>以此类推，每个节点都有两个孩子节点，对于整数规划问题$IP(1)$ ,可以构建下图所示的枚举树</p>
<p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/5.png"></p>
<h3 id="松弛和定界"><a href="#松弛和定界" class="headerlink" title="松弛和定界"></a>松弛和定界</h3><p>但这样也并不能解决变量一多以后的运算问题，如果能够去掉一些明显不会称为最优解的分支，那么求解整数规划的问题会变得更为高效。</p>
<p>比如说对于上面这棵枚举树中的 $IP(4)$和$IP(7)$. </p>
<p>关于$IP(4)$ ，我们的整数规划的定义如下：</p>
<script type="math/tex; mode=display">
\begin{align}
&\text{IP(4)}\\
&\max 24x_1+2x_2+20x_3+4x_4\\
&\text{约束条件} ~~~8x_1+x_2+5x_3+4x_4\leq 9\\
&x_1=0,x_2=0\\
&x_i\in\{0,1\},3\leq i\leq 4\\
\end{align}</script><p>我们已经知道了它的最优解，那么$IP(4)$ 的所有子孙结点都不需要在进行计算，因为$IP(4)$的最优解一定是其子孙结点的一个上界。</p>
<p>我们需要把$IP(4)$中的整数约束去掉，问题就转化为如下的一个<strong>线性规划问题</strong>，这样的目的是，<strong>LP问题的最优解一定是IP问题的最优解的上界</strong>。</p>
<p>记作$LP(4)$:</p>
<script type="math/tex; mode=display">
\begin{align}
&\text{LP(4)}\\
&\max 24x_1+2x_2+20x_3+4x_4\\
&\text{约束条件} ~~~8x_1+x_2+5x_3+4x_4\leq 9\\
&x_1=0,x_2=0\\
&0\leq x\leq1,3\leq i\leq 4\\
\end{align}</script><p>我们很容易发现对于线性规划问题 $LP(4)$ ，很容易发现它的最优解是 $x_1=0,x_2=0,x_3=1,x_4=1,z=24$ .</p>
<p>关于$IP(7)$ ，我们将其转化为线性规划问题：</p>
<script type="math/tex; mode=display">
\begin{align}
&\text{LP(7)}\\
&\max 24x_1+2x_2+20x_3+4x_4\\
&\text{约束条件} ~~~8x_1+x_2+5x_3+4x_4\leq 9\\
&x_1=1,x_2=1\\
&0\leq x\leq1,3\leq i\leq 4\\
\end{align}</script><p>同样可以发现其最优解为：$x<em>1=1,x_2=1,x_3=0,x_4=0,z</em>{IP(7)}=26$ .</p>
<p>如果$IP(8)$的最优解不会超过$IP(7)$ ,那么包括节点$IP(8)$ 和它的自己孙节点也都不需要再进行计算了。</p>
<p><strong>重点：</strong></p>
<p>整数规划的松弛线性规划问题的解释整数规划问题解的上界。如果$IP(8)$ 对应的松弛线性规划问题$LP(8)$ 的解都不超过$IP(7)$,即：</p>
<script type="math/tex; mode=display">
Z_{IP}(8)\leq Z_{LP}(8)\leq Z_{IP}(7)</script><p>因此，通过整数规划问题的松弛找到了响应节点整数最优解的上界</p>
<h3 id="分支定界算法"><a href="#分支定界算法" class="headerlink" title="分支定界算法"></a>分支定界算法</h3><p>现在我们来对枚举树进行剪枝规则</p>
<ol>
<li><strong>已经找到了某个节点的最优解</strong>，该节点的所有子孙结点都不需要再解。因此其所有的子孙结点都可以从枚举树中删除</li>
<li>如果已知枚举树中某个节点的最优解，而当前节点的松弛线性规划问题的最优解都比已知的最优解要小，那么当前结点对应的整数规划问题不可能成为最优解，当前节点及其子孙结点都不用再解、因此当前节点及其子孙结点都可以直接从枚举树中删除</li>
<li>如果当前结点对应的松弛线性规划问题没有可行解，那么当前节点及其子孙结点都不可能存在可行解。因此可以直接从枚举树中删除。</li>
</ol>
<p>我们可以用一下伪代码概括</p>
<p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/6.png"></p>
<p>算法中的 active结点，意味着这些节点对应的整数规划问题可能是该整数规划的最优解。只要枚举树中还有active结点，分支定界算法就要继续执行，直到没有为止</p>
<p>算法记录当前位置所发现的最优解，记为$Z_I$ ，初始值为$-\infty$ 。算法基于线性规划问题$LP(j)$的最优解$x(j)$来判断：</p>
<ol>
<li>第一种情形：线性规划问题$LP(j)$无解，则枚举树中的节点$IP(j)$及其子孙结点会被剪枝</li>
<li>第二种情形：如果$Z_{LP}(j)\leq Z_I$ ，则枚举树中的节点$IP(j)$及其子孙结点会被剪枝</li>
<li><p>第三种情形：如果$Z<em>{LP}(j)&gt;Z_I$ ，且$x(j)$为整数解，即$x(j)$也是$IP(j)$ 的可行解，算法找到一个比当前最优解还要更优的一个可行整数解$x(j)$, 因此当前最优解$Z_I$ 更新为$Z</em>{LP}(j)=Z_{IP}(j)$，并将枚举树中的节点$IP(j)$ 及其子节点全部剪枝</p>
</li>
<li><p>第四种情形：如果$Z_{LP}(j)&gt;Z_I$，但是$x(j)$为<strong>非整数解</strong>，即 $x(j)$ 不是$IP(j)$ 的可行解，算法无法判断节点$IP(j)$的子孙结点中是否存在更优的解，因此将节点$IP(j)$的孩子标记为active结点</p>
</li>
</ol>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>我们还是用刚才的整数规划例子：</p>
<script type="math/tex; mode=display">
\max 24x_1+2x_2+20x_3+4x_4\\
\text{约束条件} ~~~8x_1+x_2+5x_3+4x_4\leq 9\\
x_i\in\{0,1\},1\leq i\leq 4</script><h4 id="迭代1"><a href="#迭代1" class="headerlink" title="迭代1"></a>迭代1</h4><p>初始状态$IP(1)$的松弛线性规划$LP(1)$作为枚举树根节点，标记为active，当前最优解$Z_I=-\infty$ </p>
<p>通过解决线性规划问题$LP(1)$，得到$LP(1)$的最优解为：</p>
<script type="math/tex; mode=display">
x_1=\frac{1}{2},x_2=0,x_3=1,x_4=0,z_{LP}(1)=32</script><p>（关于如何解决线性规划问题，可以通过python的pulp包来求解）</p>
<p>因为$Z_{LP}(1)&gt;Z_I$ ，且$x(1)$为非整数解，即$x(1)$不是$IP(1)$的可行解，属于第4种情形，那么将$IP(1)$标记为inactive，并将$IP(1)$的两个孩子结点$IP(2)$和$IP(3)$ 标记为active结点</p>
<h4 id="迭代2"><a href="#迭代2" class="headerlink" title="迭代2"></a>迭代2</h4><p>迭代2选择了结点$IP(2)$，如图所示</p>
<p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/7.png"></p>
<p>这里枚举树中的结点$IP(2)$ 的松弛线性规划问题为$LP(2)$。通过解决线性规划问题$LP(2)$可以得到最优解：</p>
<script type="math/tex; mode=display">
\begin{align}
LP(2):
&\max 24x_1+2x_2+20x_3+4x_4\\~\\
\text{s.t.}
&8x_1+x_2+5x_3+4x_4\leq 9\\
&x_1=0\\
&0\leq x_i\leq 1,2\leq i\leq 4\\
&\text{解得:}~x_1=0,x_2=1,x_3=1,x_4=\frac{3}{4},Z_{LP}(2)=25
\end{align}</script><p>由于$Z_{LP(2)}&gt;Z_I$ ，且$x(2)$ 为非整数解，即$x(2)$ 不是$IP(2)$ 的可行解，属于第4种情形。</p>
<p>分支定界算法将$IP(2)$标记为inactive，并将$IP(2)$ 的两个孩子节点$IP(4)$和$IP(5)$ 标记为active结点 </p>
<h4 id="迭代3"><a href="#迭代3" class="headerlink" title="迭代3"></a>迭代3</h4><p>第三次迭代选择$IP(3)$，如图所示：</p>
<p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/8.png"></p>
<p>这里枚举树中的结点$IP(3)$ 的松弛线性规划问题为$LP(3)$。通过解决线性规划问题$LP(3)$可以得到最优解：</p>
<script type="math/tex; mode=display">
\begin{align}
LP(3):
&\max 24x_1+2x_2+20x_3+4x_4\\~\\
\text{s.t.} &8x_1+x_2+5x_3+4x_4\leq 9\\
&x_1=1\\
&0\leq x_i\leq 1,2\leq i\leq 4\\
&\text{解得:}~~~x_1=1,x_2=0,x_3=\frac{1}{4},x_4=0,Z_{LP}(3)=28
\end{align}</script><p>由于$Z_{LP(3)}&gt;Z_I$ ，且$x(3)$ 为非整数解，即$x(3)$ 不是$IP(3)$ 的可行解，属于第4种情形。</p>
<p>分支定界算法将$IP(3)$标记为inactive，并将$IP(3)$ 的两个孩子节点$IP(6)$和$IP(7)$ 标记为active结点 </p>
<h4 id="迭代4"><a href="#迭代4" class="headerlink" title="迭代4"></a>迭代4</h4><p>第四次选择了$IP(4)$,如下图：</p>
<p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/9.png"></p>
<p>这里枚举树中的结点$IP(4)$ 的松弛线性规划问题为$LP(4)$。通过解决线性规划问题$LP(4)$可以得到最优解：</p>
<script type="math/tex; mode=display">
\begin{align}
LP(4):
&\max 24 x_1+2x_2+20x_3+4x_4\\~\\
\text{s.t.} &8x_1+x_2+5x_3+4x_4\leq 9\\
&x_1=0,x_2=0\\
&0\leq x_i\leq 1,3\leq i\leq 4\\
&\text{解得:}~~~x_1=0,x_2=0,x_3=1,x_4=1,Z_{LP}(4)= 24
\end{align}</script><p>由于$Z_{LP(4)}&gt;Z_I$ ，且$x(4)$ 是整数解，即$x(4)$  是$IP(4)$ 的可行解，属于第3种情形。</p>
<p> 因此，分支定界算法将当前的最优解更新为：$Z<em>I=Z</em>{LP(4)}=Z_{IP(4)}$，并进一步将$IP(4)$所有的孩子结点剪枝</p>
<h4 id="迭代5"><a href="#迭代5" class="headerlink" title="迭代5"></a>迭代5</h4><p>第5次迭代中，选择active结点$IP(5)$,如下图：</p>
<p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/10.png"></p>
<p>这里枚举树中的结点$IP(5)$ 的松弛线性规划问题为$LP(5)$。通过解决线性规划问题$LP(5)$可以得到最优解：</p>
<script type="math/tex; mode=display">
\begin{align}
&LP(5):
\max ~24 x_1+2x_2+20x_3+4x_4\\~\\
\text{s.t.} &8x_1+x_2+5x_3+4x_4\leq 9\\
&x_1=0,x_2=1\\
&0\leq x_i\leq 1,3\leq i\leq 4\\
&\text{解得:}~~~x_1=0,x_2=1,x_1=1,x_4=\frac{3}{4},Z_{LP}(5)= 25
\end{align}</script><p>由于$Z_{LP(5)}&gt;Z_I$ ，但$x(5)$ 为非整数解，即$x(5)$ 不是$IP(5)$ 的可行解，属于第4种情形。</p>
<p>分支定界算法将$IP(5)$标记为inactive，并将$IP(5)$ 的两个孩子节点$IP(8)$和$IP(9)$ 标记为active结点 </p>
<h4 id="迭代6"><a href="#迭代6" class="headerlink" title="迭代6"></a>迭代6</h4><p>选择active节点 $IP(6)$ ,如下图：</p>
<p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/12.png"></p>
<p>这里枚举树中的结点$IP(6)$ 的松弛线性规划问题为$LP(6)$。通过解决线性规划问题$LP(6)$可以得到最优解：</p>
<script type="math/tex; mode=display">
\begin{align}
LP(6):
&\max ~24 x_1+2x_2+20x_3+4x_4\\~\\
\text{s.t.} &8x_1+x_2+5x_3+4x_4\leq 9\\
&x_1=1,x_2=0\\
&0\leq x_i\leq 1,3\leq i\leq 4\\
&\text{解得:}~~~x_1=0,x_2=1,x_1=1,x_4=\frac{3}{4},Z_{LP}(6)= 25
\end{align}</script><p>由于$Z_{LP(6)}&gt;Z_I$ ，但$x(6)$ 为非整数解，即$x(6)$ 不是$IP(6)$ 的可行解，属于第4种情形。</p>
<p>分支定界算法将$IP(6)$标记为inactive，并将$IP(6)$ 的两个孩子节点$IP(10)$和$IP(11)$ 标记为active结点 </p>
<h4 id="迭代7"><a href="#迭代7" class="headerlink" title="迭代7"></a>迭代7</h4><p>选择active节点 $IP(7)$ ,如下图：</p>
<p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/13.png"></p>
<p>这里枚举树中的结点$IP(7)$ 的松弛线性规划问题为$LP(7)$。通过解决线性规划问题$LP(7)$可以得到最优解：</p>
<script type="math/tex; mode=display">
\begin{align}
LP(7):
&\max ~24 x_1+2x_2+20x_3+4x_4\\~\\
\text{s.t.} &8x_1+x_2+5x_3+4x_4\leq 9\\
&x_1=1,x_2=1\\
&0\leq x_i\leq 1,3\leq i\leq 4\\
&\text{解得:}~~~x_1=1,x_2=1,x_1=0,x_4=0,Z_{LP}(7)= 26
\end{align}</script><p>此时发现$Z<em>{LP}(7)&gt;Z_I$ 且$x(7)$为整数解，因此$x(7)$是$IP(7)$的可行解，属于第3种情形。因此，分支定界算法将当前的最优解更新为：$Z_I=Z</em>{LP}(7)=Z_{IP}(7)$,并进一步将$IP(7)$所有的孩子结点剪枝</p>
<h4 id="迭代8"><a href="#迭代8" class="headerlink" title="迭代8"></a>迭代8</h4><p>选择active节点 $IP(8)$ ,如下图：</p>
<p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/14.png"></p>
<p>这里枚举树中的结点$IP(8)$ 的松弛线性规划问题为$LP(8)$。通过解决线性规划问题$LP(8)$可以得到最优解：</p>
<script type="math/tex; mode=display">
\begin{align}
LP(8):
&\max ~24 x_1+2x_2+20x_3+4x_4\\~\\
\text{s.t.} &8x_1+x_2+5x_3+4x_4\leq 9\\
&x_1=0,x_2=1,x_3=0\\
&0\leq x_4\leq 1\\
&\text{解得:}~~~x_1=0,x_2=1,x_1=0,x_4=1,Z_{LP}(8)= 6
\end{align}</script><p>此时发现$Z_{LP}(8)&lt;Z_I$ ,属于第2种情形，分支定界算法将$IP(8)$标记为Inactive，并将IP(8)的两个孩子结点全部剪枝</p>
<h4 id="迭代9"><a href="#迭代9" class="headerlink" title="迭代9"></a>迭代9</h4><p>选择active节点 $IP(9)$ ,如下图：</p>
<p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/15.png"></p>
<p>这里枚举树中的结点$IP(9)$ 的松弛线性规划问题为$LP(9)$。通过解决线性规划问题$LP(9)$可以得到最优解：</p>
<script type="math/tex; mode=display">
\begin{align}
LP(9):
&\max ~24 x_1+2x_2+20x_3+4x_4\\~\\
\text{s.t.} &8x_1+x_2+5x_3+4x_4\leq 9\\
&x_1=0,x_2=1,x_3=1\\
&0\leq x_4\leq 1\\
&\text{解得:}~~~x_1=0,x_2=1,x_1=1,x_4=\frac{3}{4},Z_{LP}(9)= 25
\end{align}</script><p>由于$Z_{LP(9)}&lt;Z_I$ ， 属于第2种情形，分支定界算法将$IP(9)$标记为Inactive，并将$IP(9)$的两个孩子结点全部剪枝</p>
<h4 id="迭代10"><a href="#迭代10" class="headerlink" title="迭代10"></a>迭代10</h4><p>选择active节点 $IP(9)$ ,如下图：</p>
<p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/16.png"></p>
<p>这里枚举树中的结点$IP(10)$ 的松弛线性规划问题为$LP(10)$。通过解决线性规划问题$LP(10)$可以得到最优解：</p>
<script type="math/tex; mode=display">
\begin{align}
LP(10):
&\max ~24 x_1+2x_2+20x_3+4x_4\\~\\
\text{s.t.} &8x_1+x_2+5x_3+4x_4\leq 9\\
&x_1=0,x_2=1,x_3=1\\
&0\leq x_4\leq 1\\
&\text{解得:}~~~x_1=1,x_2=0,x_1=0,x_4=\frac{1}{4},Z_{LP}(10)= 25
\end{align}</script><p>由于$Z_{LP(9)}&lt;Z_I$ ， 属于第2种情形，分支定界算法将$IP(10)$标记为Inactive，并将$IP(10)$的两个孩子结点全部剪枝</p>
<h4 id="迭代11"><a href="#迭代11" class="headerlink" title="迭代11"></a>迭代11</h4><p>选择active节点 $IP(11)$ ,如下图：</p>
<p><img src="/2021/11/23/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch11-%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/17.png"></p>
<p>这里枚举树中的结点$IP(11)$ 的松弛线性规划问题为$LP(11)$。通过解决线性规划问题$LP(11)$可以得到最优解：</p>
<script type="math/tex; mode=display">
\begin{align}
LP(11):
&\max ~24 x_1+2x_2+20x_3+4x_4\\~\\
\text{s.t.} &8x_1+x_2+5x_3+4x_4\leq 9\\
&x_1=1,x_2=0,x_3=1\\
&0\leq x_4\leq 1\\
&\text{无解}
\end{align}</script><p>因此，最终得到的结果是 $Z = 26$</p>
<h2 id="割平面法"><a href="#割平面法" class="headerlink" title="割平面法"></a>割平面法</h2><p>找到合适的约束可以大大减低整数规划问题的求解过程，为了找到合适的约束条件，这里先定义有效不等式的概念。</p>
<h3 id="有效不等式"><a href="#有效不等式" class="headerlink" title="有效不等式"></a>有效不等式</h3><p>给定一个整数规划问题，一个约束条件可以减小松弛线性规划问题的可行域，但却不减少任何整数的可行解，则称其为有效不等式，有事又被称为<strong>割平面</strong>或者<strong>割</strong></p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>将下列条件改成整数规划的约束，<strong>保证两个不等式中至少有一个成立</strong></p>
<script type="math/tex; mode=display">
x_1+x_2+x_3+x_4 \leq 4&&(1)\\
3x_1-x_2-x_3+x_4\leq 3&&(2)</script><p>其中 $x_j\geq 0,j=1,\cdots,4$, 并且每一个变量都是整数。</p>
<p>解：</p>
<p>我们可以把这个问题变成0-1整数规划问题，令：</p>
<script type="math/tex; mode=display">
w = \begin{cases}
1&x_1+x_2+x_3+x_4 \leq 4\\~\\
0&-3x_1+x_2+x_3-x_4\geq -3
\end{cases}</script><p>令 $M&gt;0$</p>
<p>则有：</p>
<script type="math/tex; mode=display">
\begin{cases}
x_1+x_2+x_3+x_4 \leq 4+M(1-w)\\~\\
-3x_1+x_2+x_3-x_4\geq -3-Mw
\end{cases}</script><p>其中 $w={0,1}$</p>
<p>这样， 不管 $w$ 的取值如何，$(1),(2)$ 至少有一个成立</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jason</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">439</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    

  

</body>
</html>
