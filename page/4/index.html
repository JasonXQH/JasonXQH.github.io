<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=">


  <link rel="mask-icon" href="/images/logo.svg?v=" color="#222">














<meta property="og:type" content="website">
<meta property="og:title" content="Jason‘s Blog">
<meta property="og:url" content="https://jasonxqh.github.io/page/4/index.html">
<meta property="og:site_name" content="Jason‘s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '',
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    fancybox: false,
    tabs: ,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: 'undefined',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>







  <title>Jason‘s Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', '[object Object]', 'auto');
  ga('send', 'pageview');
</script>





<meta name="generator" content="Hexo 4.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">
  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
<a href="https://github.com/JasonXQH/JasonXQH.github.io" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jason‘s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/%20" rel="section">
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/06/06/go%E5%AD%A6%E4%B9%A01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/06/06/go%E5%AD%A6%E4%B9%A01/" itemprop="url">go学习1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-06-06T13:42:19+08:00">
                2022-06-06
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2023-07-08T14:01:49+08:00">
                2023-07-08
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="go学习-part1"><a href="#go学习-part1" class="headerlink" title="go学习-part1"></a>go学习-part1</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在这学期的区块链以及数据库的课程中，需要我们使用go语言来编写Fabric中的链码、共识算法等程序。那么go语言为什么这么有用呢？</p>
<ul>
<li><p><strong>go语言执行速度更快</strong>。因为go可以直接将代码编译成machine code，不像python这类解释性语言，需要一个python解释器。在执行速度方面，Golang总是比Java领先一步。基于Golang的程序速度超快，编译也很迅速， 开发人员喜欢使用Golang来满足更快的后端开发的要求。</p>
</li>
<li><p><strong>go有着活跃的开发者社区</strong>。目前，有超过100万的开发者精通Golang的工作。这个数字预计在未来会有更大的增长。拥有一个强大而活跃的开发者社区，可以确保在开发过程中遇到的任何问题都能得到支持。</p>
</li>
<li><p><strong>go有着全面的开发工具</strong>。 诚然，它没有类似于Java的庞大的第三方工具，然而，Go配备了一套全面的工具，使开发人员的编码变得简单。Go提供的IDE，如Visual Studio Code、Goland等</p>
<p>此外，<em>go语言可以通过内嵌c代码的形式调用c语言</em>,也可以通过调用共享库函数的方式实现; 至于c语言调用go函数,则可以通过go build将go代码编译成共享库提供给c代码使用</p>
</li>
<li><p><strong>可扩展性强</strong>。在为一个项目选择编程语言时，可扩展性往往是一个重要的因素。没有人希望在以后需要为应用程序引入新功能时被卡住。Golang提供了更大的可扩展性空间。它提供了在同一时间执行多种功能的可能性。当你选择Golang时，你可以在未来更长时间内使用它。</p>
</li>
</ul>
<p>与此同时，go语言也存在着一些缺点：</p>
<ul>
<li><strong>编程更消耗时间</strong>。Golang并不像Python一样具有解释性，而是一种编译型语言，所以实现同一个功能所需要的代码量要比python更多</li>
<li><strong>golang不支持泛型</strong>。如果不支持泛型，代码的重复性可能会很高，因为需要重写多个函数来处理不同类型的参数。这就像Golang所基于的C语言一样，缺乏对通用函数的支持会严重限制代码的可重用性，降低开发过程中的效率。 </li>
</ul>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>在进行Go语言开发的时候，我们的代码总是会保存在<code>$GOPATH/src</code>目录下。在工程经过<code>go build</code>、<code>go install</code>或<code>go get</code>等指令后，会将下载的第三方包源代码文件放在  目录下，产生的二进制可执行文件放在 <code>$GOPATH/bin</code>目录下，生成的中间缓存文件会被保存在 <code>$GOPATH/pkg</code> 下。</p>
<p><img src="/2022/06/06/go%E5%AD%A6%E4%B9%A01/1.jpeg"></p>
<h3 id="如何编译"><a href="#如何编译" class="headerlink" title="如何编译"></a>如何编译</h3><h4 id="go-build"><a href="#go-build" class="headerlink" title="go build"></a>go build</h4><p><code>go build</code>这个指令用来编译指定 packages 里的源码文件以及它们的依赖包，编译的时候会到 <code>$goPath/src/package</code>路径下寻找源码文件。go build 还可以直接编译指定的源码文件，并且可以同时指定多个。</p>
<p><code>usage: go build [-o output] [-i] [build flags] [packages]</code></p>
<blockquote>
<p><code>-o</code> 只能在编译单个包的时候出现，它指定输出的可执行文件的名字。</p>
<p><code>-i</code> 会安装编译目标所依赖的包，安装是指生成与代码包相对应的 <code>.a</code> 文件，即静态库文件（后面要参与链接），并且放置到当前工作区的 pkg 目录下，且库文件的目录层级和源码层级一致。</p>
<p> build flags 参数，<code>build, clean, get, install, list, run, test</code> 这些命令会共用一套：</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>强制重新编译所有涉及到的包，包括标准库中的代码包，这会重写 /usr/local/go 目录下的 <code>.a</code> 文件</td>
</tr>
<tr>
<td>-n</td>
<td>打印命令执行过程，不真正执行</td>
</tr>
<tr>
<td>-p n</td>
<td>指定编译过程中命令执行的并行数，n 默认为 CPU 核数</td>
</tr>
<tr>
<td>-race</td>
<td>检测并报告程序中的数据竞争问题</td>
</tr>
<tr>
<td>-v</td>
<td>打印命令执行过程中所涉及到的代码包名称</td>
</tr>
<tr>
<td>-x</td>
<td>打印命令执行过程中所涉及到的命令，并执行</td>
</tr>
<tr>
<td>-work</td>
<td>打印编译过程中的临时文件夹。通常情况下，编译完成后会被删除</td>
</tr>
</tbody>
</table>
</div>
<p>我们拿区块链上的一个项目来展示如何编译。首先，这个项目结构如下图所示：</p>
<ul>
<li>主目录下有naive.go, 其实就是main包，里面有个func main函数.这是go程序的入口</li>
<li>zkv模块，是一个简单的键值对数据库</li>
<li>zlog模块，用于日志记录、打印</li>
<li>zpbft模块，实现算法</li>
</ul>
<p><img src="/2022/06/06/go%E5%AD%A6%E4%B9%A01/2.png"></p>
<p>我们可以用 <code>go build naive.go</code> 即可编译naive.go文件，得到mac下的可执行文件 naive</p>
<p>也可以用<code>go build -o main2 main.go</code> 讲编译得到的文件命名为main2</p>
<p>当然，我们可以用更复杂的编译指令： <code>go build -v -x -work -o bin/hello main.go</code> (naive被改名了)。<code>-v</code> 会打印所编译过的包名字，<code>-x</code> 打印编译期间所执行的命令，<code>-work</code> 打印编译期间生成的临时文件路径，并且编译完成之后不会被删除。</p>
<p>执行结果如下，我们看到，一开始编译了一系列package文件，在编译这些文件的时候调用了go语言的静态库(.a文件)。在EOF指令出现后，说明已经编译完成，然后会将编译好的静态文件相连接，最终生成可执行文件，并将其移动到bin目录下，改名为hello</p>
<p><img src="/2022/06/06/go%E5%AD%A6%E4%B9%A01/3.png"> </p>
<h4 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a>go install</h4><p><code>go install</code> 用于编译并安装指定的代码包及它们的依赖包。相比 <code>go build</code>，它只是多了一个“安装编译后的结果文件到指定目录”的步骤。</p>
<p>使用这条指令，会在GOPATH目录下的pkg文件夹中生成.a文件，在bin文件夹生成可执行文件</p>
<h4 id="go-run"><a href="#go-run" class="headerlink" title="go run"></a>go run</h4><p><code>go run</code> 用于编译并运行命令源码文件。如 <code>go run -x -work main.go</code></p>
<h4 id="gofmt"><a href="#gofmt" class="headerlink" title="gofmt"></a>gofmt</h4><p><code>gofmt</code>  可以帮我们吧源代码文件排列的更好。比如说当我们打印一些多余的空格的时候，会将空格去掉。在一些IDE中(如VsCode和Goland), 每次保存文件都会自动执行 gofmt</p>
<h2 id="Go-Basics"><a href="#Go-Basics" class="headerlink" title="Go Basics"></a>Go Basics</h2><h3 id="Variables-in-Go"><a href="#Variables-in-Go" class="headerlink" title="Variables in Go"></a>Variables in Go</h3><p>在Go语言中，一旦一个变量被声明，它就必须被调用，否则会出现错误。但有时你并不需要使用从一个函数得到的所有返回值。因此，我们可以使用<code>_</code> 空白表示符</p>
<p><code>_</code> 被用于抛弃值，你不能得到它的值，如值 5 在：_, b = 5, 7 中被抛弃。</p>
<ol>
<li><p>```go<br>//声明变量<br>var x int = 7<br>var s string<br>s1 = “Learning Go!” </p>
<p>//打印使用Println,不同元素之间用 , 隔开<br>var age int = 30<br>fmt.Println(“age: “, age)</p>
<p>var name = “Dan”<br>fmt.Println(“Your name is: “, name) </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 我们也可以用更简单的方式声明： &#96;age :&#x3D; 30&#96; ,可以不用显式定义变量类型</span><br><span class="line"></span><br><span class="line">### Multiple Declarations</span><br><span class="line"></span><br><span class="line">我们可以用一行代码来定义多个变量</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;go</span><br><span class="line">car,cost :&#x3D; &quot;Audi&quot;,50000</span><br><span class="line">fmt.Println(car, cost)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>但是函数体内不允许使用 <strong>:=</strong> 重复声明同名变量。 因为 := 通常是用来声明新的变量的，如果我们要重复定义，可以使用 <code>=</code></p>
<p><img src="/2022/06/06/go%E5%AD%A6%E4%B9%A01/4.png"></p>
<p>或者，我们可以在左侧出现至少1个新的变量，也可以规避这个错误</p>
<p><img src="/2022/06/06/go%E5%AD%A6%E4%B9%A01/5.png"></p>
<h4 id="var"><a href="#var" class="headerlink" title="var"></a>var</h4><p>此外，我们可以用 var 来进行多变量声明，可读性会更强：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用var声明，默认会将变量置为0值</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">		salary <span class="keyword">float64</span></span><br><span class="line">		firstName <span class="keyword">string</span></span><br><span class="line">		gender <span class="keyword">bool</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fmt.Println(salary,firstName,gender)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i,j <span class="keyword">int</span></span><br><span class="line">i,j = <span class="number">5</span>,<span class="number">8</span></span><br><span class="line">j,i = i,j<span class="comment">//交换i，j位置 </span></span><br><span class="line">fmt.Println(i,j)<span class="comment">//  8,5</span></span><br></pre></td></tr></table></figure>
<h3 id="Types-and-Zero-Values"><a href="#Types-and-Zero-Values" class="headerlink" title="Types and Zero Values"></a>Types and Zero Values</h3><p>由于Go还是算静态语言的一种，因此每一个变量都需要有一个类型。我们之所以可以用<code>:=</code>定义变量是因为go帮我们做了隐式变量推导。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">   <span class="keyword">var</span> b = <span class="number">4.2</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们将b赋值给a，go会马上报错，因为这种隐式变量转换在go语言中是不被允许的</p>
<p><img src="/2022/06/06/go%E5%AD%A6%E4%B9%A01/6.png"></p>
<p>同样的，int和string之间也无法进行隐式类型转换</p>
<h4 id="go中如何表达0-空"><a href="#go中如何表达0-空" class="headerlink" title="go中如何表达0/空"></a>go中如何表达0/空</h4><ul>
<li>在数字类型中： 0</li>
<li>在布尔类型中： false</li>
<li>在字符串类型中： “”</li>
<li>在指针类型中： nil</li>
</ul>
<h3 id="Naming-Conventions-in-Go"><a href="#Naming-Conventions-in-Go" class="headerlink" title="Naming Conventions in Go"></a>Naming Conventions in Go</h3><p>现在我们来介绍一下Go语言的命名规则：</p>
<ul>
<li>变量必须以字母或者下划线<code>_</code>开头</li>
<li>大小写敏感</li>
<li>Go的25个关键词不能被作为变量名</li>
<li>命名尽量简短、但保持可读性、变量可以使用驼峰命名法</li>
</ul>
<h3 id="Package-fmt"><a href="#Package-fmt" class="headerlink" title="Package fmt"></a>Package fmt</h3><p>fmt是Go标准库中很重要的一个包。它可以帮助我们格式化并打印内容</p>
<p><code>Println</code> 函数可以帮我们打印一行内容，可以是不同类型的变量的组合，中间用<code>,</code>分隔.</p>
<p><code>Printf</code> 函数是用来格式化输出内容的, 但是每次打印结束不会换行。比如：</p>
<h4 id="通用verbs"><a href="#通用verbs" class="headerlink" title="通用verbs"></a>通用verbs</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">%v       　值的默认格式</span><br><span class="line">%+v      　类似%v,但输出结构体时会添加字段名</span><br><span class="line">%#v 　　 Go语法表示值</span><br><span class="line">%T  　　 Go语法表示类型</span><br><span class="line">%%     　 百分号表示</span><br><span class="line"></span><br><span class="line"><span class="comment">//如下示例：</span></span><br><span class="line"><span class="keyword">type</span> Sample <span class="keyword">struct</span> &#123;</span><br><span class="line">    Title   <span class="keyword">string</span></span><br><span class="line">    name    <span class="keyword">string</span></span><br><span class="line">    Age     <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    s := Sample&#123;<span class="string">"测试"</span>, <span class="string">"wentao"</span>, <span class="number">26</span>&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, s)    		<span class="comment">// &#123;测试 wentao 26&#125;</span></span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, s)  		<span class="comment">// &#123;Title:测试 name:wentao Age:26&#125;</span></span><br><span class="line">    fmt.Printf(<span class="string">"%#v\n"</span>, s)  		<span class="comment">// main.Sample&#123;Title:"测试", name:"wentao", Age:26&#125;</span></span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, s)       <span class="comment">//  main.Sample</span></span><br><span class="line">    fmt.Printf(<span class="string">"%v%%\n"</span>, s.Age) <span class="comment">//  26%</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%t  <span class="literal">true</span>或<span class="literal">false</span> </span><br><span class="line"><span class="comment">//如下示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%t\n"</span>, <span class="literal">true</span>)  <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">%b  表示二进制</span><br><span class="line">%c  该值对应的unicode吗值</span><br><span class="line">%d  表示十进制</span><br><span class="line">%o  表示八进制</span><br><span class="line">%q  该值对应的单引号括起来的<span class="keyword">go</span>语法字符字面值，必要时会采用安全的转义表示</span><br><span class="line">%x  表示为十六进制，使用a-f</span><br><span class="line">%X  表示为十六进制，使用A-F</span><br><span class="line">%U  表示为Unicode格式：U+<span class="number">1234</span>，等价于<span class="string">"U+%04X"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如下示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%b\n"</span>, <span class="number">26</span>)          <span class="comment">//11010</span></span><br><span class="line">    fmt.Printf(<span class="string">"%c\n"</span>, <span class="number">0x4E2D</span>)      <span class="comment">//中</span></span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, <span class="number">0x12</span>)        <span class="comment">//18</span></span><br><span class="line">    fmt.Printf(<span class="string">"%o\n"</span>, <span class="number">20</span>)          <span class="comment">//24</span></span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, <span class="number">0x4E2D</span>)      <span class="comment">//'中'</span></span><br><span class="line">    fmt.Printf(<span class="string">"%x\n"</span>, <span class="number">14</span>)          <span class="comment">//e</span></span><br><span class="line">    fmt.Printf(<span class="string">"%X\n"</span>, <span class="number">14</span>)          <span class="comment">//E</span></span><br><span class="line">    fmt.Printf(<span class="string">"%U\n"</span>, <span class="number">0x4E2D</span>)     <span class="comment">//U+4E2D</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="浮点数与复数"><a href="#浮点数与复数" class="headerlink" title="浮点数与复数"></a>浮点数与复数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">%b  无小数部分、二进制指数的科学计数法，如<span class="number">-123456</span>p<span class="number">-78</span>；参见strconv.FormatFloat</span><br><span class="line">%e  科学计数法，例如 <span class="number">-1234.456e+78</span> </span><br><span class="line">%E  科学计数法，例如 <span class="number">-1234.456E+78</span></span><br><span class="line">%f  有小数点而无指数，例如 <span class="number">123.456</span> </span><br><span class="line">%F  等价于%f</span><br><span class="line">%g  根据实际情况采用%e或%f格式（以获得更简洁、准确的输出）</span><br><span class="line">%G  根据实际情况采用%E或%F格式（以获得更简洁、准确的输出）</span><br><span class="line"><span class="comment">//如下示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%b\n"</span>, <span class="number">10.45</span>)   <span class="comment">//5882827013252710p-49</span></span><br><span class="line">    fmt.Printf(<span class="string">"%e\n"</span>, <span class="number">10.45</span>)   <span class="comment">//1.045000E+01</span></span><br><span class="line">    fmt.Printf(<span class="string">"%E\n"</span>, <span class="number">10.45</span>)   <span class="comment">//1.045000E+01</span></span><br><span class="line">    fmt.Printf(<span class="string">"%f\n"</span>, <span class="number">10.45</span>)   <span class="comment">//10.450000</span></span><br><span class="line">    fmt.Printf(<span class="string">"%F\n"</span>, <span class="number">10.45</span>)   <span class="comment">//10.450000</span></span><br><span class="line">    fmt.Printf(<span class="string">"%g\n"</span>, <span class="number">10.45</span>)   <span class="comment">//10.45</span></span><br><span class="line">    fmt.Printf(<span class="string">"%G\n"</span>, <span class="number">10.45</span>)   <span class="comment">//10.45</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="string与-byte"><a href="#string与-byte" class="headerlink" title="string与[]byte"></a>string与[]byte</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">%s  输出字符串表示（<span class="keyword">string</span>类型或[]<span class="keyword">byte</span>) </span><br><span class="line">%q  双引号围绕的字符串，由Go语法安全地转义</span><br><span class="line">%x  十六进制，小写字母，每字节两个字符 （使用a-f）</span><br><span class="line">%X  十六进制，大写字母，每字节两个字符 （使用A-F） </span><br><span class="line"></span><br><span class="line"><span class="comment">//如下示例：</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, []<span class="keyword">byte</span>(<span class="string">"go开发"</span>))      <span class="comment">//go开发</span></span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, <span class="string">"go开发"</span>)          <span class="comment">//go开发</span></span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, <span class="string">"go开发"</span>)          <span class="comment">//"go开发"</span></span><br><span class="line">    fmt.Printf(<span class="string">"%x\n"</span>, <span class="string">"go开发"</span>)          <span class="comment">//676fe5bc80e58f91</span></span><br><span class="line">    fmt.Printf(<span class="string">"%X\n"</span>, <span class="string">"go开发"</span>)          <span class="comment">//676FE5BC80E58F91</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">%p       切片第一个元素的指针</span><br><span class="line"><span class="comment">//如下示例</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%p\n"</span>, []<span class="keyword">byte</span>(<span class="string">"go开发"</span>))          <span class="comment">//0xc42001a0d8</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p\n"</span>, []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">65</span>&#125;)  <span class="comment">//0xc420020180</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="point"><a href="#point" class="headerlink" title="point"></a>point</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%p       十六进制内存地址,前缀ox</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    str := <span class="string">"go开发"</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p\n"</span>, &amp;str)            <span class="comment">//0xc42000e1e0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Constants-in-Go"><a href="#Constants-in-Go" class="headerlink" title="Constants in Go"></a>Constants in Go</h3><p>Go 语言中声明常量使用的关键字是<code>const</code>。常量的使用非常广泛，比如说圆周率，再比如说一些明确的错误信息等一些容易被<strong>多次使用的值</strong>，一般都会使用常量进行实例化，使其在需要更改时，更容易维护，同时增加代码可读性。</p>
<p>常量在声明的时候就必须初始化，但是和变量不一样，常量声明了以后，不使用也不会报错。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">//常量定义</span></span><br><span class="line">   <span class="keyword">const</span> secondsInHour = <span class="number">3600</span></span><br><span class="line"></span><br><span class="line">   duration := <span class="number">234</span></span><br><span class="line">   fmt.Printf(<span class="string">"Duration in seconds: %v\n"</span>, duration*secondsInHour)</span><br><span class="line">   <span class="comment">//多常量定义</span></span><br><span class="line">   <span class="keyword">const</span> n, m <span class="keyword">int</span> = <span class="number">4</span>, <span class="number">5</span></span><br><span class="line">   <span class="keyword">const</span> n1, m1 = <span class="number">6</span>, <span class="number">7</span></span><br><span class="line">	<span class="comment">//在使用这种方式进行多常量定义的时候，如果后面的常量未初始化，会自动沿用第一个常量的值</span></span><br><span class="line">   <span class="keyword">const</span> (</span><br><span class="line">      min1 = <span class="number">-400</span></span><br><span class="line">      min2</span><br><span class="line">      min3</span><br><span class="line">   )</span><br><span class="line">   fmt.Println(min1, min2, min3) <span class="comment">//-400 -400 -400</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="常量声明规则"><a href="#常量声明规则" class="headerlink" title="常量声明规则"></a>常量声明规则</h4><ul>
<li>声明之后无法修改</li>
<li><p>给常量赋值的时候不能涉及运行时计算,如：<code>const power = math.Pow(2,3)</code></p>
</li>
<li><p>我们不能给一个常量付一个变量的值</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t := <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> tc = t <span class="comment">//会报错</span></span><br></pre></td></tr></table></figure>
<ul>
<li>特殊情况，当我们使用内建函数(如len)时，可以使用其返回结果给常量赋值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const l1 &#x3D; len(&quot;hello&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="Constant-Expressions-Typed-vs-Untyped-Constants"><a href="#Constant-Expressions-Typed-vs-Untyped-Constants" class="headerlink" title="Constant Expressions Typed vs Untyped Constants"></a>Constant Expressions Typed vs Untyped Constants</h3><p>当我们在申明常量的时候，如果指明了常量类型，那么就无法做隐式类型转换了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x <span class="keyword">int</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> y <span class="keyword">float64</span> = <span class="number">2.2</span> * x  <span class="comment">//会报错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是，如果我们不确定常量数值类型，就不会报错。 此时go给了x一定的freedom，能让它做隐式类型转换</span></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> y <span class="keyword">float64</span> = <span class="number">2.2</span> * x <span class="comment">//不会报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x  = <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> y  = <span class="number">2.2</span> * x <span class="comment">//不会报错</span></span><br></pre></td></tr></table></figure>
<h3 id="IOTA"><a href="#IOTA" class="headerlink" title="IOTA"></a>IOTA</h3><p><code>iota</code>是golang的常量计数器，只能在常量的表达式中使用。</p>
<p> 使用<code>iota</code>时只需要记住以下两点</p>
<p>1.<code>iota</code>在<code>const</code>关键字出现时将被重置为0。</p>
<p>2.<code>const</code>中每新增一行常量声明将使<code>iota</code>计数一次(iota可理解为<code>const</code>语句块中的行索引)。</p>
<p>可以用这个关键词来实现枚举结构</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">		n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">		n2        <span class="comment">//1 	顺延第一行的表达式</span></span><br><span class="line">		n3        <span class="comment">//2</span></span><br><span class="line">		n4        <span class="comment">//3</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">		n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">		n2        <span class="comment">//1</span></span><br><span class="line">		_		  		<span class="comment">//丢弃该值，常用在错误处理中</span></span><br><span class="line">		n4        <span class="comment">//3</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">		n1 = <span class="literal">iota</span> <span class="comment">//0					</span></span><br><span class="line">		n2 = <span class="number">100</span>  <span class="comment">//100 		即使没有出现iota，iota 也会自增1</span></span><br><span class="line">		n3 = <span class="literal">iota</span> <span class="comment">//2</span></span><br><span class="line">		n4        <span class="comment">//3</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> n5 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">		_  = <span class="literal">iota</span>							<span class="comment">// iota = 0</span></span><br><span class="line">		KB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>) <span class="comment">// iota = 1, &lt;&lt;移位操作，速度比乘除法快 ,因此KB = 2^10</span></span><br><span class="line">		MB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>) <span class="comment">// 以此类推</span></span><br><span class="line">		GB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">		TB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">		PB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">	)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">		a, b = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span> <span class="comment">//1,2</span></span><br><span class="line">		c, d                      <span class="comment">//2,3 常量如果没有初始化，会顺延第一行的表达式</span></span><br><span class="line">		e, f                      <span class="comment">//3,4</span></span><br><span class="line">	)</span><br></pre></td></tr></table></figure>
<p>注意：常量只能声明布尔值、整数值、rune constant(即int32)、complex constant(复数)、浮点数值、字符串值。</p>
<p><strong>不能声明数组常量、结构常量，它们用var声明</strong></p>
<h3 id="Go-Data-Types"><a href="#Go-Data-Types" class="headerlink" title="Go Data Types"></a>Go Data Types</h3><h4 id="Numeric-types"><a href="#Numeric-types" class="headerlink" title="Numeric types"></a>Numeric types</h4><ul>
<li><p>int8, int16, int32, int64 ：注意，go有溢出检测，如果 声明<code>var i1 int8 = -129</code> 会直接报错。</p>
</li>
<li><p>uint8, uint16, uint32, uint64: 无符号整数</p>
</li>
<li><p>uint is an alias for uint32 or uint64 based on platform.  直接使用uint/int的话，会随着平台的不同而变化</p>
</li>
<li>int is an alias for int32 or int64 based on platform. </li>
<li>float32, float64: 如果小数点之前为0，则0可省略 ( -.5 -3. -0. 1.4).</li>
<li>complex64, complex128. </li>
<li>byte (alias for uint8). </li>
<li>rune (alias for int32). </li>
</ul>
<h4 id="Bool-type"><a href="#Bool-type" class="headerlink" title="Bool type"></a>Bool type</h4><ul>
<li>布尔值，只有 true / false 两个值</li>
</ul>
<h4 id="String-type"><a href="#String-type" class="headerlink" title="String type"></a>String type</h4><p>字符串类型，用双引号</p>
<p>现在来介绍go中的复合变量</p>
<h4 id="Array-and-Slice-Type"><a href="#Array-and-Slice-Type" class="headerlink" title="Array and Slice Type"></a>Array and Slice Type</h4><ul>
<li><p>数组<br>数组是一个长度固定的数据类型，用于存储一段具有相同类型的元素的连续块。数组存储的类型可以是内置类型，如整型或者字符串，也可以是某种结构类型。</p>
</li>
<li><p>切片<br>切片是围绕动态数组的概念构建的，可以按需自动增长和缩小<br>切片是一个很小的对象，对底层数组进行了抽象，并提供了相关的操作方法。切片有3个字段分别是<code>指向底层数组的指针</code>，<code>切片访问的元素个数（即长度）</code>和<code>切片允许增长到的元素个数（即容量）</code></p>
</li>
</ul>
<p>切片的长度和容量在概念上有以下区别：</p>
<ul>
<li>长度（Length）：切片的长度表示切片中实际包含的元素个数。长度可以通过内置函数 <code>len()</code> 来获取。在上述示例中，切片 <code>slice</code> 的长度为 3，表示切片中有 3 个元素。</li>
<li>容量（Capacity）：切片的容量表示切片从第一个元素开始算起，到底层数组末尾的元素个数。容量可以通过内置函数 <code>cap()</code> 来获取。在<code>slice := make([]int, 3, 5)</code>这个例子中，切片 <code>slice</code> 的容量为 5，表示切片底层的数组中还有 5 - 3 = 2 个空闲的位置。</li>
</ul>
<p>数组</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个包含5个元素的整型数组，并设置为零值</span></span><br><span class="line"><span class="keyword">var</span> array [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line"><span class="comment">//使用数组字面量声明数组</span></span><br><span class="line">array := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line"><span class="comment">//隐式声明数组长度</span></span><br><span class="line">array := [...]<span class="keyword">int</span>&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line"><span class="comment">//声明数组并指定特定元素</span></span><br><span class="line">array := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>:<span class="number">10</span>,<span class="number">2</span>:<span class="number">30</span>&#125; <span class="comment">// =&gt; [10 0 30 0 0]</span></span><br></pre></td></tr></table></figure>
<p>切片</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用make(声明是不会分配内存的，初始化需要 make ，分配内存后才能赋值和使用。)</span></span><br><span class="line"><span class="comment">//长度和容量都是5个元素</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">//长度为3，容量为5个元素</span></span><br><span class="line"><span class="comment">//3是这是切片的长度，表示切片中实际包含的元素个数</span></span><br><span class="line"><span class="comment">//5是切片的容量，表示底层数组从切片的第一个元素开始，到底层数组末尾的元素个数。</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用字面量声明</span></span><br><span class="line"><span class="comment">//长度和容量都是4个元素</span></span><br><span class="line">slice := []<span class="keyword">string</span>&#123;<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>,<span class="string">"yellow"</span>&#125;</span><br><span class="line"><span class="comment">//这行代码创建了一个字符串切片 slice，其中包含了 100 个元素</span></span><br><span class="line"><span class="comment">//其中前 99 个元素的值为空字符串，而最后一个元素的值为 "!!"。</span></span><br><span class="line"><span class="comment">//在大括号内，我们使用键值对的方式来初始化切片的元素。键表示切片中的索引，值表示对应索引处的元素值</span></span><br><span class="line"><span class="comment">//这里的 99 是键，表示切片中的索引位置，而 "!!" 是值，表示该索引位置的元素的值。</span></span><br><span class="line">slice := []<span class="keyword">string</span>&#123;<span class="number">99</span>:<span class="string">"!!"</span>&#125;</span><br></pre></td></tr></table></figure>
<p> 在之后会详细介绍 </p>
<h4 id="Map-Type"><a href="#Map-Type" class="headerlink" title="Map Type"></a>Map Type</h4><ul>
<li>在 Go 语言中，Map（映射）是一种集合类型，用于存储键值对（key-value）数据。Map 是无序的，每个键在 Map 中必须是唯一的。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 初始化一个map，键是string类型，值是map类型(又是一个string-string键值对)</span></span><br><span class="line">   studentMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">  <span class="comment">// 先初始化 map 大小</span></span><br><span class="line">   studentMap[<span class="string">"stu01"</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line">   studentMap[<span class="string">"stu01"</span>][<span class="string">"name"</span>] = <span class="string">"tom"</span></span><br><span class="line">   studentMap[<span class="string">"stu01"</span>][<span class="string">"sex"</span>] = <span class="string">"男"</span></span><br><span class="line">   studentMap[<span class="string">"stu01"</span>][<span class="string">"address"</span>] = <span class="string">"北京长安街"</span></span><br><span class="line">  </span><br><span class="line">   studentMap[<span class="string">"stu02"</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>) <span class="comment">// 这句话不能少</span></span><br><span class="line">   studentMap[<span class="string">"stu02"</span>][<span class="string">"name"</span>] = <span class="string">"mary"</span></span><br><span class="line">   studentMap[<span class="string">"stu02"</span>][<span class="string">"sex"</span>] = <span class="string">"女"</span></span><br><span class="line">   studentMap[<span class="string">"stu02"</span>][<span class="string">"address"</span>] = <span class="string">"上海黄浦江"</span></span><br><span class="line">   fmt.Println(studentMap)</span><br><span class="line">  <span class="comment">//map[stu01:map[address:北京长安街 name:tom sex:男] stu02:map[address:上海黄浦江 name:mary sex:女]]</span></span><br><span class="line"></span><br><span class="line">   fmt.Println(studentMap[<span class="string">"stu02"</span>])</span><br><span class="line">  <span class="comment">//map[address:上海黄浦江 name:mary sex:女]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Struct-Type-User-defined-type"><a href="#Struct-Type-User-defined-type" class="headerlink" title="Struct Type (User defined type)"></a>Struct Type (User defined type)</h4><p>struct和C++中的类似，可以将其适用于结构类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">   brand <span class="keyword">string</span></span><br><span class="line">   price <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Pointer-Type"><a href="#Pointer-Type" class="headerlink" title="Pointer Type"></a>Pointer Type</h4><p>指针存储了一个变量的地址、如果未初始化，默认为 nil</p>
<h4 id="Function-and-Interface-Type"><a href="#Function-and-Interface-Type" class="headerlink" title="Function and Interface Type"></a>Function and Interface Type</h4><p>函数类型、接口类型</p>
<h4 id="Channel-Type"><a href="#Channel-Type" class="headerlink" title="Channel Type"></a>Channel Type</h4><p>通道类型 为 通信而设计。</p>
<p>谁会用到它呢？<a href="https://so.csdn.net/so/search?q=协程&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">协程</a>，就是Go协程（goroutine），使用 go语句并发执行的函数或方法（concurrently executing functions）。</p>
<p>通信 包括 发送、接收指定的元素类型的 值。</p>
<p>没有被初始化的 通道 的值为 nil</p>
<h3 id="Operations-On-Types-Arithmetic-and-Assignment-Operators"><a href="#Operations-On-Types-Arithmetic-and-Assignment-Operators" class="headerlink" title="Operations On Types: Arithmetic and Assignment Operators"></a>Operations On Types: Arithmetic and Assignment Operators</h3><p>和C++一样，不赘述</p>
<h3 id="Comparison-and-Logical-Operators"><a href="#Comparison-and-Logical-Operators" class="headerlink" title="Comparison and Logical Operators"></a>Comparison and Logical Operators</h3><p>和C++一样，不赘述</p>
<h3 id="Overflows"><a href="#Overflows" class="headerlink" title="Overflows"></a>Overflows</h3><p>在go中也有向上溢出和向下溢出的概念。在 Go 中，整数溢出的行为与编译时和运行时的上下文有关。</p>
<p>在编译时，对于常量表达式，编译器会进行常量折叠和溢出检查。如果一个常量表达式的结果溢出了其类型的取值范围，编译器会在编译时就发出溢出错误。</p>
<p>比如，在声明的时候，如果检测到overflow，会直接报错：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	a := <span class="keyword">int8</span>(<span class="number">255</span>+<span class="number">1</span>)<span class="comment">//会报错overflow</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在运行时，对于变量的计算，Go 语言允许进行溢出操作。当对 <code>var b int8 = 127</code> 进行 <code>b+1</code> 的计算时，编译器不会报告溢出错误，因为这是在运行时动态计算的，而非在编译时。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> x	<span class="keyword">uint8</span> = <span class="number">255</span></span><br><span class="line">	x++ <span class="comment">// overflow, x is 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，向下溢出操作如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b <span class="keyword">int8</span> = <span class="number">-128</span></span><br><span class="line">b--</span><br><span class="line">fmt.Printf(<span class="string">"%d\n"</span>,b+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>有意思的是，浮点数也会溢出，向上溢出到正无穷 ，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f := <span class="keyword">float32</span>(math.MaxFloat32)</span><br><span class="line">f = f*<span class="number">1.2</span></span><br><span class="line">fmt.Println(f) <span class="comment">// =&gt;  +Inf</span></span><br></pre></td></tr></table></figure>
<p>如果需要计算很大的，可能溢出的数，可以使用 <code>math/big</code> 包, 它可以进行高精度计算，处理大数和分数等复杂数学运算。它对于需要处理精确度要求较高的场景非常有用，如密码学、金融计算、科学计算等。</p>
<h3 id="Converting-Numeric-Types"><a href="#Converting-Numeric-Types" class="headerlink" title="Converting Numeric Types"></a>Converting Numeric Types</h3><p>在 Go 中，变量转换通常需要显式进行类型转换，以确保类型安全性。Go 语言不支持隐式变量转换，这是为了避免潜在的类型错误。</p>
<p>比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> x = <span class="number">3</span> <span class="comment">// int type</span></span><br><span class="line">	<span class="keyword">var</span> y = <span class="number">3.1</span> <span class="comment">// float type</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// x = x*y //会报错</span></span><br><span class="line">	<span class="comment">//如果要相乘，必须：</span></span><br><span class="line">	newx := x*<span class="keyword">int</span>(y)    <span class="comment">//=&gt; 9</span></span><br><span class="line">	newy := float(x)*y	<span class="comment">//=&gt; 9.3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是：在 Go 中，<code>int</code> 和 <code>int64</code> 是不同的类型。它们表示不同的整数类型，具有不同的大小和范围。</p>
<ul>
<li><code>int</code> 类型是一个有符号整数类型，其大小和范围在不同的操作系统和架构上可能会有所不同。在大多数情况下，<code>int</code> 的大小为 32 位或 64 位。</li>
<li><code>int64</code> 类型是一个明确表示 64 位有符号整数的类型</li>
</ul>
<p>由于 <code>int</code> 和 <code>int64</code> 是不同的类型，因此不能直接进行类型转换。你需要使用显式类型转换来将一个类型转换为另一个类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> y <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 x 的值转换为 int64 类型，并赋值给 y</span></span><br><span class="line">    y = <span class="keyword">int64</span>(x)</span><br><span class="line"></span><br><span class="line">    fmt.Println(x, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Converting-Numbers-to-Strings-and-Strings-to-Numbers"><a href="#Converting-Numbers-to-Strings-and-Strings-to-Numbers" class="headerlink" title="Converting Numbers to Strings and Strings to Numbers"></a>Converting Numbers to Strings and Strings to Numbers</h3><p>在 Go 中，可以使用 <code>fmt.Sprintf</code> 函数将不同类型的值转换为字符串类型。该函数允许使用格式化字符串来构建一个字符串，其中可以包含不同类型的值。比如int类型和float类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 将整数转换为字符串</span></span><br><span class="line">    num := <span class="number">42</span></span><br><span class="line">    str := fmt.Sprintf(<span class="string">"%d"</span>, num)</span><br><span class="line">    fmt.Println(str) <span class="comment">// 输出: "42"</span></span><br><span class="line">		<span class="comment">// 将浮点数转换为字符串</span></span><br><span class="line">  myStr := fmt.Sprintf(<span class="string">"%f"</span>,<span class="number">44.2</span>)</span><br><span class="line">  fmt.Println(myStr) <span class="comment">// 输出 "44.2"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以用strconv来实现字符串往浮点数的转换</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">"3.123"</span> <span class="comment">// type string</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>,s1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f1,err = strconv.ParseFloat(s1,<span class="number">64</span>)</span><br><span class="line">_ = err</span><br><span class="line">fmt.Println(f1)</span><br></pre></td></tr></table></figure>
<p>我们可以用 Atoi 和 Itoa来实现整数和字符串之间的转换，更加方便</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i,err := strconv.Atoi(<span class="string">"-50"</span>)	<span class="comment">// -50, int类型</span></span><br><span class="line">s2 := strconv.Itoa(<span class="number">20</span>)				<span class="comment">// "20",string类型</span></span><br></pre></td></tr></table></figure>
<h3 id="Defined-Named-Types"><a href="#Defined-Named-Types" class="headerlink" title="Defined(Named) Types"></a>Defined(Named) Types</h3><p>在 Go 中，”defined type” 和 “source type” 是类型系统中的两个概念。</p>
<ul>
<li><p>Defined Type（定义类型）：在 Go 中，你可以使用 <code>type</code> 关键字创建一个新的类型，该类型基于一个已有的类型。这种通过 <code>type</code> 关键字定义的类型称为 “defined type”。它们在语法上与其基础类型相同，但在类型系统中被视为不同的类型。</p>
<p>例如，假设你有一个 <code>int</code> 类型的变量 <code>x</code>，你可以使用 <code>type</code> 关键字创建一个新类型 <code>MyInt</code>，它是基于 <code>int</code> 类型的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> x MyInt = <span class="number">10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Source Type（源类型）：源类型是指定义类型的基础类型，也就是定义类型是基于的类型。在定义类型中，源类型扮演着基础类型的角色，提供了定义类型的底层实现和行为。</p>
<p>在上述示例中，<code>int</code> 就是 <code>MyInt</code> 的源类型。<code>MyInt</code> 类型继承了 <code>int</code> 类型的所有属性和方法，因此可以在 <code>MyInt</code> 类型的变量上执行与 <code>int</code> 类型相同的操作。</p>
</li>
</ul>
<p>在Defined Type和 Source Type之间，可以进行隐式类型转换，所以我们看到10可以直接赋值给 MyInt类型的 x</p>
<p>需要注意的是，两个不同的 Defined Type之间，虽然他们可能源于同一个 source type，但是他们之间没有办法进行隐式类型转换，需要显式类型转换！！</p>
<p>比如说：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> km <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">type</span> mile <span class="keyword">float64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> parisToLondon km = <span class="number">465</span></span><br><span class="line">	<span class="keyword">var</span> distanceInMiles mile</span><br><span class="line">	<span class="comment">//distanceInMiles = parisToLondon * 0.621 //会报错，因为 mile 和 parisToLandon不是一种类型的</span></span><br><span class="line">	distanceInMiles = mile(parisToLondon) * <span class="number">0.621</span></span><br><span class="line">	fmt.Println(distanceInMiles)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>distanceInMiles = mile(parisToLondon) * 0.621</code>  的底层逻辑是，将parisToLondon转换成mile类型，由于mile类型的底层类型是float,因此他们可以相乘并赋值给mile类型的distanceInMiles</p>
<p>我们再举一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> second <span class="keyword">uint</span></span><br><span class="line"><span class="keyword">type</span> duration second</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> minute = <span class="keyword">uint</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> t1 duration = <span class="number">10</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">var</span> x <span class="keyword">uint</span> = t1</span><br><span class="line">	_ = x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的的代码中，<code>second</code> 和 <code>duration</code> 都是通过类型定义创建的新类型。它们并不是别名类型。对于类型定义而言，尽管它们的底层类型相同，但在类型系统中它们被视为不同的类型。</p>
<p>在这种情况下，你可以将 <code>10</code> 隐式转换为 <code>duration</code> 类型，因为 <code>10</code> 是一个无类型常量，它可以自动转换为 <code>duration</code> 类型。这是由于编译器在编译时会将无类型常量转换为目标类型。</p>
<p>然而，将 <code>duration</code> 类型的变量赋值给 <code>uint</code> 类型的变量时，需要进行显式类型转换，因为在类型系统中，它们被视为不同的类型。</p>
<p>所以，<code>10</code> 可以隐式转换为 <code>duration</code> 类型，但 <code>duration</code> 类型的变量不能隐式转换为 <code>uint</code> 类型。</p>
<h3 id="Alias-Declarations"><a href="#Alias-Declarations" class="headerlink" title="Alias Declarations"></a>Alias Declarations</h3><p>在 Go 中，Alias Declaration（别名声明）是一种创建类型别名的语法。它允许你为现有的类型创建一个新的名称，以便在代码中更清晰地表达其含义或提供更具可读性的标识符。和 上面的 named type不一样，别名类型和原始类型具有相同的底层结构和行为，它们是完全兼容的，可以互相替代使用。</p>
<p>Alias Declaration 使用 <code>type</code> 关键字，后面紧跟新的类型名称和等号，然后是现有的类型。</p>
<p>下面是一个示例，展示了如何使用 Alias Declaration 创建类型别名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type MyFloat64 &#x3D; float64</span><br></pre></td></tr></table></figure>
<p>需要注意的是，在 Go 中，<code>byte</code> 和 <code>uint8</code> 是相同的类型，它们是别名关系。同样地，<code>rune</code> 和 <code>int32</code> 也是相同的类型，它们也是别名关系。它们之间可以进行隐式类型转换，并且可以互相替代使用。</p>
<p>在特定的上下文中</p>
<ul>
<li><p>用 <code>byte</code> 表示一个无符号的8位整数，通常用于表示字节数据</p>
</li>
<li><p>而使用 <code>rune</code> 表示一个Unicode码点，通常用于处理字符和文本数据。</p>
</li>
</ul>
<h2 id="Program-Flow-Control-in-Go"><a href="#Program-Flow-Control-in-Go" class="headerlink" title="Program Flow Control in Go"></a>Program Flow Control in Go</h2><h3 id="If-Else"><a href="#If-Else" class="headerlink" title="If-Else"></a>If-Else</h3><p>在 Go 中，<code>if-else</code> 是一种条件语句，用于根据条件的真假来执行不同的代码块。它的基本语法如下：条件不需要加括号，但是代码块需要使用花括号 <code>{}</code> 来界定。另外，条件表达式的结果<strong>必须是布尔类型</strong>的值（<code>true</code> 或 <code>false</code>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if condition &#123;</span><br><span class="line">    &#x2F;&#x2F; 当条件为真时执行的代码块</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 当条件为假时执行的代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Command-Line-Arguments-os-Args"><a href="#Command-Line-Arguments-os-Args" class="headerlink" title="Command Line Arguments: os.Args"></a>Command Line Arguments: os.Args</h3><p>在 Go 中，<code>os.Args</code> 是一个字符串切片（<code>[]string</code>），用于获取命令行参数。</p>
<p>当我们在终端或命令行中执行一个可执行程序时，可以通过命令行参数来传递额外的信息给程序。<code>os.Args</code> 变量提供了对这些命令行参数的访问。</p>
<p><code>os.Args</code> 切片的第一个元素是可执行程序的名称，后面的元素是传递给程序的命令行参数。下标从 0 开始。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取所有命令行参数</span></span><br><span class="line">	args := os.Args</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印可执行程序的路径</span></span><br><span class="line">	fmt.Println(<span class="string">"程序路径:"</span>, args[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印其他命令行参数</span></span><br><span class="line">	fmt.Println(<span class="string">"命令行参数:"</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(args); i++ &#123;</span><br><span class="line">		fmt.Println(i, args[i])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设我们将上述程序保存为 <code>commandline.go</code>，然后在终端中执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run naive.go arg1 arg2 arg3</span><br></pre></td></tr></table></figure>
<p>程序的输出将会是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">程序路径: &#x2F;var&#x2F;folders&#x2F;lp&#x2F;52cjrdtd4_59hlqcsgrcwc_m0000gn&#x2F;T&#x2F;go-build1548655087&#x2F;b001&#x2F;exe&#x2F;naive</span><br><span class="line">命令行参数:</span><br><span class="line">1 arg1</span><br><span class="line">2 arg2</span><br><span class="line">3 arg3</span><br></pre></td></tr></table></figure>
<p>我们再看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	&#x2F;&#x2F; 获取所有命令行参数</span><br><span class="line">	var result, err &#x3D; strconv.ParseFloat(os.Args[1], 64)</span><br><span class="line">	fmt.Printf(&quot;%T\n&quot;, os.Args[1])</span><br><span class="line">	fmt.Printf(&quot;%T\n&quot;, result)</span><br><span class="line">	_ &#x3D; err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行<code>go run naive.go 50</code> 可得到如下打印结果：这也说明os.Args中的参数都是字符串形类型的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string</span><br><span class="line">float64</span><br></pre></td></tr></table></figure>
<h3 id="Simple-If-Statement"><a href="#Simple-If-Statement" class="headerlink" title="Simple If Statement"></a>Simple If Statement</h3><p>对于一些If语句，我们可以对其进行简化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// converting string to int:</span></span><br><span class="line">    i, err := strconv.Atoi(<span class="string">"45"</span>)</span><br><span class="line"> 		</span><br><span class="line">    <span class="comment">// error handling</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// simple (short) statement -&gt;  the same effect as the above code</span></span><br><span class="line">    <span class="comment">// 把第一句话和判断放在一起，中间用逗号隔开</span></span><br><span class="line">    <span class="keyword">if</span> i, err := strconv.Atoi(<span class="string">"34"</span>); err == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"No error. i is "</span>, i)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="For-Loops"><a href="#For-Loops" class="headerlink" title="For Loops"></a>For Loops</h3><p>在 Go 中，<code>for</code> 是用于循环执行代码块的关键字。Go 提供了几种不同形式的 <code>for</code> 循环，以满足不同的需求。</p>
<ol>
<li>基本的 <code>for</code> 循环：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> initialization; condition; post &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在基本的 <code>for</code> 循环中，我们可以指定初始化语句、循环条件和后置语句。初始化语句在循环开始前执行一次，循环条件在每次迭代前进行判断，循环体执行完后会执行后置语句。</p>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>for</code> 循环的初始化和后置语句是可选的：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> condition &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种形式的 <code>for</code> 循环中，我们只需要指定循环条件。如果条件为真，则执行循环体。在每次迭代结束后，循环条件会被重新评估。</p>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="number">5</span> &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>除了上述基本的 <code>for</code> 循环形式外，Go 还提供了 <code>range</code> 关键字来迭代集合类型（如数组、切片、映射等）的元素。<code>range</code> 循环会依次迭代集合中的每个元素，并提供索引和对应的值。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numbers := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> numbers &#123;</span><br><span class="line">    fmt.Println(index, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Go 中没有专门的 <code>while</code> 关键字，但是你可以使用 <code>for</code> 循环来实现类似 <code>while</code> 的功能。你可以通过省略初始化语句和后置语句，并只保留循环条件，来使用 <code>for</code> 循环作为 <code>while</code> 循环的替代。</p>
<p>下面是一个示例，展示如何在 Go 中使用 <code>for</code> 循环来实现 <code>while</code> 循环：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="number">5</span> &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们就实现了一个类似于 <code>while</code> 循环的行为，只要循环条件为真，就会不断地执行循环体。</p>
<p>需要注意的是，在使用 <code>for</code> 循环作为 <code>while</code> 循环的替代时，你需要确保在循环体内部更新循环条件的值，以免出现死循环。在上述示例中，我们在循环体内部使用 <code>i++</code> 来逐步增加 <code>i</code> 的值，以确保循环条件最终不再满足，从而终止循环。</p>
<h3 id="For-and-Continue-Statements"><a href="#For-and-Continue-Statements" class="headerlink" title="For and Continue Statements"></a>For and Continue Statements</h3><p>在 go中，也有continue关键词 ,当<code>continue</code>语句执行时，它会立即终止当前迭代的执行，并跳到循环的下一次迭代。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">continue</span> <span class="comment">// 跳过奇数</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码将打印出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，当<code>i</code>为奇数时，<code>continue</code>语句将被执行，跳过当前迭代，然后继续执行下一次迭代。只有当<code>i</code>为偶数时，<code>fmt.Println(i)</code>语句才会执行。</p>
<h3 id="For-and-Break-Statements"><a href="#For-and-Break-Statements" class="headerlink" title="For and Break Statements"></a>For and Break Statements</h3><p>在Go语言中，<code>break</code>是一个控制流语句，用于在循环或<code>switch</code>语句中立即终止当前的执行流程并跳出循环或<code>switch</code>语句。</p>
<p>当<code>break</code>语句执行时，它会立即终止当前的循环或<code>switch</code>语句的执行，并将控制转移到循环或<code>switch</code>语句之后的下一行代码。</p>
<p>下面是一个使用<code>break</code>语句的示例，演示了在循环中使用<code>break</code>来提前结束循环的情况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">goCopy code</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">5</span> &#123;</span><br><span class="line">        <span class="keyword">break</span> <span class="comment">// 当 i 等于 5 时终止循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，<code>break</code>语句只会影响当前所在的循环或<code>switch</code>语句。如果有嵌套循环或嵌套<code>switch</code>语句，<code>break</code>语句只会跳出最内层的循环或<code>switch</code>语句。如果想要跳出外层的循环或<code>switch</code>语句，可以使用标签（label）来标识循环或<code>switch</code>语句，并在<code>break</code>语句中指定标签。</p>
<h3 id="Label-Statement"><a href="#Label-Statement" class="headerlink" title="Label Statement"></a>Label Statement</h3><h3 id="Goto"><a href="#Goto" class="headerlink" title="Goto"></a>Goto</h3><h3 id="Switch-Statement"><a href="#Switch-Statement" class="headerlink" title="Switch Statement"></a>Switch Statement</h3><h3 id="Scopes-in-Go"><a href="#Scopes-in-Go" class="headerlink" title="Scopes in Go"></a>Scopes in Go</h3><h2 id="Arrays-in-Go"><a href="#Arrays-in-Go" class="headerlink" title="Arrays in Go"></a>Arrays in Go</h2><h2 id="Slice-in-Go"><a href="#Slice-in-Go" class="headerlink" title="Slice in Go"></a>Slice in Go</h2>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/06/05/%E5%8C%BA%E5%9D%97%E9%93%BE-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/06/05/%E5%8C%BA%E5%9D%97%E9%93%BE-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" itemprop="url">区块链-共识算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-06-05T09:03:11+08:00">
                2022-06-05
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2025-04-11T10:20:01+08:00">
                2025-04-11
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先我们知道有两种故障容错类型：拜占庭容错(BFT)和崩溃容错(CFT)。</p>
<ul>
<li>崩溃容错（CFT）是一种弹性，在这种情况下，如果组件出现故障，系统仍可以正确地达成共识。</li>
<li>拜占庭的容错（BFT）表示即使在存在恶意参与者的情况下也可以完成共识。 </li>
</ul>
<h3 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h3><p>共识算法一般在分布式系统中经常使用，而且我们这学期也在想学习MapReduce、Spark、Flink这类框架。其实，区块链系统也是一种分布式系统，因为在区块链中每个节点独立运行交易，不同的节点可能运行在地理上分离的区域，而有些节点可能存在恶意、可能发生故障。</p>
<p>因此，区块链系统作为一个整体应该对外提供可靠、可用、一致性的服务，但处理结果的一致性是基础。</p>
<p>分布式系统分为同步和异步分布式系统。</p>
<h4 id="同步分布式系统"><a href="#同步分布式系统" class="headerlink" title="同步分布式系统"></a>同步分布式系统</h4><p>同步分布式系统需要严格满足：</p>
<p>（1）节点运行指令的时间有严格的上限和下限；</p>
<p>（2）消息能够在有限的时间内传输到目标节点；</p>
<p>（3）每个节点有一个本地时钟，与实际时间的偏移率在一个已知的范围内。</p>
<p>同步分布式网络就像两个人打电话，只要不挂断，一个人就必须等待在那边听声音</p>
<p>对于运行在广域网上的区块链系统来说，上述约束条件很难满足(因为区块产生的速度比较慢)，而且区块链网络中的节点可能在空间上的距离不等。因此区块链系统一般采用异步分布式系统(弱同步)。</p>
<h4 id="异步分布式系统"><a href="#异步分布式系统" class="headerlink" title="异步分布式系统"></a>异步分布式系统</h4><p>异步分布式系统具有如下性质：异构性、并发性、可靠性、可用性、缺乏全局时钟、故障独立性</p>
<p>异步分布式系统存在一些限制：</p>
<ol>
<li>每一个动作在不同的节点运行时间不同，因为机器的性能不一样</li>
<li>消息可以在任意长时间后接收到，因为网络存在延迟</li>
<li>时钟漂移率可以使任意的</li>
</ol>
<p>异步模型对运行速度和消息延迟没有任何假设，这就要求区块链系统中的模型和算法不应立足于某些限制进行设计。就好比发微信，我看到了别人发来的微信，才会回复，而不是一直抱着手机等在那边</p>
<ul>
<li><p>一致性问题</p>
<ul>
<li><strong>处理结果一致</strong>（状态一致）。指分布式系统中多个节点就某一处理结果达成一致，基本方法是状态复制（State Replication）。如传统数据库的发布<strong>订阅模式</strong>，就实现了数据库的一致性。</li>
<li><strong>输入的一致性</strong>。指从多个节点的输入值中，选取其中一个作为决策值，并作为分布式系统共同的输入。这也是区块链中通常所说的共识。</li>
</ul>
</li>
<li><p>可靠性问题</p>
<ul>
<li><strong>可靠性（可用性）</strong>是描述系统可以提供服务能力的重要指标，通常用两个时间指标MTBF（ Mean Time Between Failures ，平均故障间隔时间）和MTTR（ Mean Time to  Repair ，平均修复时间）来衡量。一个高可用性系统应该具有尽量长的MTBF和尽量短的MTTR。</li>
</ul>
</li>
</ul>
<h3 id="共识"><a href="#共识" class="headerlink" title="共识"></a>共识</h3><p>在集中式系统中，一旦出现单点故障，就只能让系统重启，任务会被搁置。分布式系统就解决了这个问题，分布式系统需要首先保证高可靠、高可用性。由此，在分布式系统中需要有多个节点。</p>
<p>假设系统中有n个节点，其中最多有f个节点可能崩溃，在剩下的n-f个好的节点中，从节点i提交一个区块$B_i$(输入值)开始，所有节点要遵循相同的协议，从全部提交的区块中选择一个区块(一致性结果，决策值)，并用该去快提交到区块链系统</p>
<p>从多个节点输入值中选取一个决策之就称为共识，达成共识过程中所遵循的协议就是共识算法</p>
<p>共识需要满足的条件</p>
<ul>
<li><strong>一致性</strong>： 所有好节点的决策之必定相同</li>
<li><strong>可终止性</strong>： 所有好节点在有限的时间内结束决策过程</li>
<li><strong>有效性</strong>: 选择出的决策之必须是某个节点的输入值</li>
</ul>
<h4 id="故障容错"><a href="#故障容错" class="headerlink" title="故障容错"></a>故障容错</h4><p>故障容错是指区块链系统中<strong>节点</strong>和<strong>通信信道</strong>都有可能出现故障，导致部分节点不可用或者偏离被认为正确的结果或行为。</p>
<p>不同故障的影响：“遗漏故障”，“随机故障”，“时序故障”（时序故障主要针对同步分布式系统，对执行时间、通信时间和时钟漂移均有限制）。</p>
<h5 id="遗漏故障"><a href="#遗漏故障" class="headerlink" title="遗漏故障"></a>遗漏故障</h5><p>遗漏故障是指节点或通信信道不能完成它应该做的动作，就是崩溃了。也称为CFT。在异步环境下，由于对节点的运行速度和消息传递延迟没有限制，因此我们无法判断消息到底是在路上，还是节点已经崩溃。这种情况被称为<strong>可变消息延迟</strong>。区块链系统中共识算法的设计应该基于可变消息延迟的模式</p>
<ul>
<li><strong>节点遗漏故障</strong>： 主要是崩溃，意味着节点停止并不再执行任何动作，也不再对消息进行响应。一般用一段固定时间等待故障节点对消息的应答来检测，如果其他节点能确切检测到节点已经崩溃，那么这个节点崩溃称为故障-停止。但对异步系统，超时只能表明节点没有响应，这可能是节点崩溃了，也可能是节点执行速度慢甚至是消息还没有到达</li>
<li><strong>通信遗漏故障</strong>： 指通过通信信道，节点A不能把消息m成功传送到节点B，也叫信息丢失。在存在消息丢失的消息传递模式下，任何一条消息都不能保证可以安全地到达消息的接收者。存在两种情况，一种是消息到达节点B，但消息内容已经损坏，这种可以通过消息签名检测；另一种情况就是消息丢失。</li>
</ul>
<p>遗漏故障在异步分布式系统中是比较难解决的——无论是节点还是通信，都难以判断其是否发生了故障。</p>
<h4 id="随机故障"><a href="#随机故障" class="headerlink" title="随机故障"></a>随机故障</h4><p>随机故障也称为拜占庭故障，用于描述可能发生的任何类型故障，如故意返回错误结果或者处理的结果本身就是一个错误的。</p>
<ul>
<li>节点的随机故障通常是指节点进程<strong>随机地省略</strong>要做的处理步骤或执行一些不需要的步骤，从而导致产生错误的执行结果。这类故障<strong>不能通过查看节点是否应答来检测</strong>，也无法通过<strong>密码学的方式</strong>来进行判断，因为它可能随机地应答或者应答错误的结果。</li>
<li>通信通道也会出现随机故障，如消息内容可能被损坏或者传递不存在的消息，也可能多次传递同样的消息。这类故障可以通过校验、消息签名或时间戳等机制进行检测。</li>
</ul>
<p>因此在基于拜占庭故障的共识算法在设计时，除了考虑拜占庭节点是否返回结果，还需要考虑返回错误结果的情况，因此基于拜占庭的共识算法通常要求不超过1/3的出错节点，就是考虑到即使1/3的正常节点和1/3的故障节点对冲后，仍然有多数1/3能够使算法形成共识</p>
<h3 id="FLP原理"><a href="#FLP原理" class="headerlink" title="FLP原理"></a>FLP原理</h3><p>FLP不可能原理：当允许存在<strong>节点失效</strong>的情况下，不存在一个确定性的共识算法总能<strong>在异步模型</strong>下达成一致。就连POW也不是确定性的，也可能存在一条链被推翻的情况</p>
<p>但是，在同步模型下，由于其对节点处理时间、消息传递、始终都有要求，很容易判断是否失败，从而决定是否重传或者其他方式进行故障排除。</p>
<p>FLP原理实际上说明对于允许节点失效的情况下，纯粹的异步系统无法确保一致性在有限的时间内完成。即便对于非拜占庭错误的前提下，包括Paxos、Raft等共识算法都存在无法达成共识的情况。</p>
<p>但是，在工程实践中，在付出一些代价的情况下，获得高效的共识算法还是很有必要的。具体付出什么代价，共识算法能达到什么程度，往往通过CAP原理进行衡量。</p>
<h3 id="CAP原理"><a href="#CAP原理" class="headerlink" title="CAP原理"></a>CAP原理</h3><p>在这篇博客<a href="https://jasonxqh.github.io/2022/01/01/数据库扩展性问题/#数据库扩展性问题">数据库扩展性问题</a>中学习过，这边再复习一下</p>
<p>CAP 原理是指在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance），三者不可兼得。</p>
<p><img src="/2022/06/05/%E5%8C%BA%E5%9D%97%E9%93%BE-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/1.png" style="zoom:67%;"></p>
<h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p><strong>用如下系统进行解释</strong></p>
<p><img src="/2022/06/05/%E5%8C%BA%E5%9D%97%E9%93%BE-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/2.png"></p>
<ol>
<li>客户端向G1写入数据v1，并等待响应</li>
<li>此时，G1服务器的数据为v1，而G2服务器的数据为v0，两者不一致</li>
<li>接着，在返回响应给客户端之前，G2服务器会自动同步G1服务器的数据，使得G2服务器的数据也是v1</li>
<li>一致性保证了不管向哪台服务器（比如这边向G1）写入数据，其他的服务器（G2）能实时同步数据</li>
<li>G2已经同步了G1的数据，会告诉G1，我已经同步了</li>
<li>G1接收了所有同步服务器的已同步的报告，才将“写入成功”信息响应给client</li>
<li>client再发起请求，读取G2的数据</li>
<li>此时得到的响应是v1，即使client从未写入数据到G2</li>
</ol>
<p>一致性的要求就是，在没有达到全部同步之前，是没有办法向客户提供服务的。</p>
<h4 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h4><p>系统中非故障节点收到的每个请求都必须有响应</p>
<p>即可用性，所有的节点都保持<strong>高可用性</strong>。<strong>注意</strong>，这里的高可用还包括不能出现延迟，比如如果某节点由于等待数据同步而阻塞客户端请求，那么节点就不满足高可用性。也就是说，任何没有发生故障的服务必须在有限的时间内返回合理的结果集。</p>
<h4 id="分区容错性"><a href="#分区容错性" class="headerlink" title="分区容错性"></a>分区容错性</h4><p><strong>允许网络丢失从一个节点发送到另一个节点的任意多条消息，即不同步 。常常会发生在分布式系统出现网络故障的时候，但由于网络是脆弱不稳定的，因此分区容错性常常必不可少</strong></p>
<p>我们举个例子，比如A、B两个机房构成一个分布式集群，如果A和B机房之间的网络不通了，那么一个分布式集群就会拆分成A和B两个集群。如果出现了分区，那肯定保证不了数据的强一致性。</p>
<h4 id="A与C的取舍"><a href="#A与C的取舍" class="headerlink" title="A与C的取舍"></a>A与C的取舍</h4><p>分区容忍性是在物理上进行保证的，比如说在海底铺设多条光缆，出现光缆故障的概率较小且难以完全避免。因此我们只能在AC之间做一个trade-off，这是由业务场景决定的</p>
<ol>
<li>保证AP, 弱化一致性(C)，允许某个时刻不一致，但是最终仍然会达到一致<ul>
<li>适用于对结果一致性不敏感的应用，可以允许新的数据副本产生后经过一段时间后，所有节点才更新成功，期间不保证一致性。如简单分布式p2p协议Gossip</li>
<li>不同的区块链系统采用不同的机制来确保新的交易所基于的区块链数据库是最新状态。如比特币要求6个区块确认，Fabric要求背书节点对交易背书</li>
</ul>
</li>
<li>保证CP, 弱化可用性(A) 允许执行过程”慢一些“，甚至拒绝服务<ul>
<li>适用于对结果一致性很敏感的应用，例如银行取款机，当分布式系统对处理不能达到一致结果时会拒绝服务。</li>
<li>Mongodb、Redis这样的NoSQL数据库，也满足CP原则</li>
<li>Paxos 、Raft 等共识算法，主要处理这种情况。在Paxos 类算法中，可能存在着无法提供可用执行结果的情形，但同时允许少数节点离线。</li>
</ul>
</li>
</ol>
<p>有人会问，就不能保证AC吗？那就需要非常严格的全体一致协议，不能容忍网络错误或者节点错误，一旦出现这样的问题，整个系统就会拒绝写请求，因为它并不知道对面的那个结点是否挂掉了。</p>
<p><img src="/2022/06/05/%E5%8C%BA%E5%9D%97%E9%93%BE-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/3.png"></p>
<h3 id="区块链系统中的ACID原则"><a href="#区块链系统中的ACID原则" class="headerlink" title="区块链系统中的ACID原则"></a>区块链系统中的ACID原则</h3><p>事务的ACID我们已经不陌生了，那么区块链中的ACID是什么样的呢？</p>
<ul>
<li>原子性：每次对系统的更新操作都是原子的，要么成功，要么不执行。对于区块链系统，一个原子操作是一个 区块，因此区块的提交应满足原子性要求。</li>
<li>一致性：上面我们说的都是一致性。一个操作开始和结束时，数据库的状态是一致的，无中间状态。对于区块链系统，不同节点在一个区块提交前后的状态应该是一致的。</li>
<li>隔离性：并发操作时，彼此不需要知晓对方存在，执行互不影响，需要串行化执行，有时间顺序。在区块链系统中，要根据并发交易到达的顺序逐个添加到区块中，在区块提交时按照排序顺序执行。</li>
<li>永久性： 状态的改变是持久的，不会失效，也不会无缘无故回滚。区块链系统中，一个区块一旦达成共识，会永久附加到原有的区块链中，不可篡改。</li>
</ul>
<h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><p>在计算机网络中中，还有一个很重要的理论：BASE (Basic Availability ,Soft-state, Eventual Consistency 三个短语的缩写) </p>
<p>这个原则与ACID相对，就是说牺牲掉对一致性的约束(最终仍然实现一致性)，来换取一定的可用性。BASE理论的核心思想是：<strong>即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性</strong></p>
<ul>
<li>Basic Availability(基本可用,总归会可用的)。分布式系统在出现不可预知故障的时候，允许损失部分可用性，如响应时间上的损失或系统功能上的损失。实际例子：12306抢票</li>
<li>Soft-state(允许系统中的数据存在中间状态)。认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。即节点之间不一致的状态</li>
<li>Eventual Consistency(最终一致性)。所有的数据副本在经过一段时间的同步之后，最终都能够达到一个一致的状态。因此本质是需要保证最终达到一致，而不需要实时保证强一致性。</li>
</ul>
<p>BASE理论是对CAP中一致性和可用性权衡的结果(牺牲一致性，换取可用性)、其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的。</p>
<p>BASE理论面向的是<strong>大型高可用可扩展的分布式系统</strong>，和传统的事务ACID特性是相反的，它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。</p>
<p>在实际的分布式场景种，由于不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性和BASE理论又往往会结合在一起</p>
<h2 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h2><p>Paxos算法是基于消息传递且具有高度容错的一致性算法，是目前公认的解决分布式一致性问题最有效的算法之一。该算法能够解决分布式网络中存在遗漏故障，并且故障节点数小于总节点数的1/2的场景下的共识问题。</p>
<h2 id="RAFT"><a href="#RAFT" class="headerlink" title="RAFT"></a>RAFT</h2><p>在我的这篇博客已经写的很详细了<a href="https://jasonxqh.github.io/2022/06/10/Raft/#Raft">Raft</a></p>
<h2 id="PBFT算法"><a href="#PBFT算法" class="headerlink" title="PBFT算法"></a>PBFT算法</h2><p>PBFT常常运用于联盟链当中，进入联盟链需要一个CA(合法性证明)。在公链系统中，共识是通过POW实现的，但是由于POW需要消耗大量能源，因此饱受诟病。在联盟链中，由于存在一定的信任基础(CA)，使得共识可以通过PBFT算法实现，其主要原理就是CPU投票。</p>
<h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>PBFT是Practical Byzantine Fault Tolerance的缩写，意为实用拜占庭容错算法。它解决了原始拜占庭容错算法效率不高的问题，将算法复杂度由指数级降低到多项式级，是的拜占庭容错算法在实际系统应用中变得可行。</p>
<p>PBFT算法是基于<strong>状态机复制</strong>理念(听起来很耳熟，raft也是这个原理)设计的一个使用的并能解决拜占庭容错的算法，当存在f个失效节点时必须保证存在至少3f+1个副本，才能保证在异步分布式系统中达成共识，并且算法满足安全性和活性要求，即提供 $(n-1)/3$ 的容错性</p>
<p>在采用PBFT算法的区块链系统中，每个节点维护服务在本节点的状态(区块链)及相关服务操作(交易)，这里的服务被称为在系统中不同节点之间复制(消息传输)的状态机，包含状态和操作。 </p>
<p>整个系统共同维护一个状态，并在不同节点之间赋值，所有的节点采取一致的行动，从而满足分布式系统的一致性要求。状态机在每个节点的复制体称为副本，<strong>每个节点都有一个完整的副本</strong>，所有副本的集合用R表示，每个副本用$R_i~ ,R_i\in(0\sim|R|-1)$ 表示。</p>
<p>同所有的状态机复制技术一样，PBFT对每个副本节点提出了两个限定条件：</p>
<ol>
<li>所有节点必须是确定性的。也就是说，在给定状态和参数相同的情况下，操作执行的结果必须相同</li>
<li>所有节点必须从相同的状态开始执行</li>
</ol>
<h3 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h3><h4 id="视图-view"><a href="#视图-view" class="headerlink" title="视图(view)"></a>视图(view)</h4><p>视图可以理解为Raft当中的任期，其视图编号也是连续的。</p>
<p>视图是一次成功地节点配置轮换过程。在一个视图中，会根据算法来确认一个副本作为主节点(primary),其他副本作为备份(backups)。</p>
<p>但是与Raft算法竞争Leader不同，PBFT算法中，主节点由公式 $p=\text{v mod |R|}$ 计算得到，这里v是视图编号，p是副本编号，$|R|$ 是副本集合的个数。因此，在PBFT中，是轮流做庄的，谁当Leader是确定的。</p>
<h4 id="主节点"><a href="#主节点" class="headerlink" title="主节点"></a>主节点</h4><p>主要用于分配基于本视图的消息序列号(全局编号)，从而对分布式系统的消息进行全局排序。进而，所有副本会按照视图编号、序列号的顺序处理消息，变更状态，使得所有副本的状态保持一致</p>
<h4 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h4><p>使用加密和签名技术来防止欺骗攻击和重放攻击，以及检测被破坏的信息。但是，对消息本身的错误、消息的延迟或者不响应则要通过共识算法来防止。</p>
<p>因此，算法中消息包含了<strong>公钥签名、消息摘要</strong>等安全信息及检测消息重复的消息验证编码(MAC)。</p>
<p>算法中，使用m表示消息，$m_i$表示由节点i签名的消息，$D(m)$ 表示消息m的摘要。</p>
<h3 id="客户端-消息发起者"><a href="#客户端-消息发起者" class="headerlink" title="客户端(消息发起者)"></a>客户端(消息发起者)</h3><p>客户端c向主节点发送请求 <code>&lt;REQUEST,o,t,c&gt;</code>, 请求执行状态机操作o。</p>
<ul>
<li>其中t是时间戳，用来保证客户端请求只会执行一次</li>
<li>客户端c发出请求的时间戳是全序排列的，不可逆的，后续发出的请求比以前发出的请求拥有跟高的时间戳。</li>
<li>对于客户端，请求发起的时间戳可以是本地时钟值</li>
</ul>
<p>客户端发起消息之后，副本会给客户端一个Reply，响应格式是：<code>&lt;REPLY,v,t,c,i,r&gt;</code> ，其中v是视图编号，t是时间戳，i是副本节点的编号，r是请求执行的结果。</p>
<ul>
<li>每个由副本节点发送给客户端的消息，都包含了当前的视图编号，使得客户端能够跟踪视图编号，从而进一步推算出当前主节点的编号</li>
<li>客户端通过点对点消息向它自己认为的主节点发送请求，然后主节点自动将该请求向所有备份节点进行广播。由于系统中最多存在f个<strong>坏节点</strong>，因此，当有f+1个响应相同时，客户端把r作为正确的执行结果。所谓的响应相同，是指：签名正确；具有同样的时间戳t；执行结果r相同</li>
<li>如果客户端在有限时间内，没有收到f+1个相同的响应，客户端应该重新讲该请求向所有副本节点进行广播。这时候，如果副本节点已经处理过该请求，则可以直接把上次发送的响应重新发送给客户端。如果没有处理过，则副本节点进行处理请求的同时，会将该请求转发给主节点。</li>
</ul>
<h3 id="三段提交协议"><a href="#三段提交协议" class="headerlink" title="三段提交协议"></a>三段提交协议</h3><p>主节点接收到来自客户端的请求之后，按照三阶段协议，会向全网广播该消息。主要包括<strong>预准备(pre-prepare)、准备(prepare)和确认(commit)</strong>三个阶段</p>
<ul>
<li>预准备和准备两个阶段用来确保同一个视图中请求发送的时序性</li>
<li>准备和确认两个阶段用来确保在不同的视图之间的已接受的请求命令是严格排序的。</li>
</ul>
<p><img src="/2022/06/05/%E5%8C%BA%E5%9D%97%E9%93%BE-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/4.png"></p>
<p>我们看到，由于大家都知道主节点是谁(通过视图号v取模运算得出)，因此客户端直接向主节点发起请求。这是<strong>request</strong>阶段</p>
<h4 id="预准备阶段"><a href="#预准备阶段" class="headerlink" title="预准备阶段"></a>预准备阶段</h4><p>由上图可知，预准备阶段主节点给予当前视图v分配一个序列号n给收到客户端请求，然后，向所有备份节点群发送预准备消息。</p>
<p>这个消息格式为:<code>&lt;&lt;PRE-PREPARE,v,n,d&gt;,m&gt;</code> ，这里v是视图编号，m是客户端发送的请求消息，d是请求消息m的摘要。</p>
<p>注意，客户端请求本身是不包含在预准备的消息里面的，其目的有两个：</p>
<ul>
<li>每个由副本节点发给客户端的消息，都包含了当前的视图编号，使得客户端能够跟踪视图编号，从而推算出主节点的编号</li>
<li>客户端通过点对点消息向它自己认为的主节点发送请求，然后主节点自动将该请求向所有备份节点进行广播。</li>
</ul>
<p>备份节点收到预准备信息后，需要开始验证、检查一些内容：</p>
<ul>
<li>请求和预准备消息的签名正确，并且d与m的摘要需一致</li>
<li>检查预准备消息中的视图编号是否为当前视图编号</li>
<li>节点是否接受过视图编号为v，序号为n，但消息摘要与d不同的消息？如果有的话，现在这条消息就会失效</li>
<li>消息的序号n必须在水线(watermark)上下限h和H之间。水线在之后会说明</li>
</ul>
<p>一旦某个备份节点 i 接收并验证了预准备信息，那么它就会进入准备阶段</p>
<h4 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h4><p>节点i开始准备阶段之后，会向所有副本节点发送准备消息<code>&lt;PREPARE,v,n,d,i&gt;</code>，并将预准备消息和准备消息在节点i进行保存。</p>
<p>当节点i收到来自其他节点的准备消息，那么当满足如下条件时</p>
<ul>
<li>条件1: 接收到超过 2f 个节点的准备消息</li>
<li>条件2: 接收到2f个与预准备消息一致的准备消息，一致的检查内容包括：视图编号v、消息序号n、摘要d</li>
</ul>
<p>副本节点i将 <code>(m,v,n,i)</code> 保存到本地并标记为Prepared状态，即为<code>prepared(m,v,n,i)</code> 。其中</p>
<ul>
<li>m是预准备消息中的消息</li>
<li>v是预准备消息中的视图编号</li>
<li>n是预准备消息中的序号。</li>
</ul>
<p>当变更为<code>prepared(m,v,n,i)</code> 之后，节点i 向其他副本节点广播格式为 <code>&lt;COMMIT,v,n,D(m),i&gt;</code> 的确认消息，于是协议进入确认阶段。</p>
<p>我们看到，每个节点在接收到信息之后，又会向全体节点发送消息。因此消息的复杂度到达了$O(n^2)$ </p>
<h4 id="确认阶段"><a href="#确认阶段" class="headerlink" title="确认阶段"></a>确认阶段</h4><p>在确认阶段，每个副本节点接收确认消息并写入消息日志，具体条件为：</p>
<ul>
<li>签名正确</li>
<li>消息的视图编号与节点的当前视图编号一致</li>
<li>消息的序号n满足水线条件，在h和H之间</li>
</ul>
<p>当副本节点i接收到2f+1个m的确认消息、并都满足上述条件之后，消息m会变更为committed-local状态，记为 <code>committed-local(m,v,n,i)</code>。具体条件为：</p>
<ul>
<li>节点i的 <code>prepared(m,v,n,i)</code>为真</li>
<li>节点i已经接收了2f+1个确认消息(包括自身在内)，与预准备消息一致。一致的检查内容包括：视图编号v，消息序号n，摘要d</li>
</ul>
<p>当消息m在节点i的状态为<code>committed-local(m,v,n,i)</code>时，节点执行m的请求，节点i的状态能够确保所有编号小于n的请求一次顺序执行。在完成m的请求操作之后，每个副本节点都会向客户端发送回复</p>
<p>副本节点会把时间戳比已回复时间戳更小的请求丢弃，以保证请求只会被执行一次。</p>
<p>当节点i的消息m变更为<code>committed-local(m,v,n,i)</code>时，对于分布式系统来说，消息m会变更为<code>commited(m,v,n)</code> 。也就是意味着，任意f+1个正常副本结点集合中的所有副本节点i ，其<code>prepared(m,v,n,i)</code>为真。这就确保了所有正常节点以同样的顺序执行所有请求，确保了节点状态的复制并保证了算法的正确性</p>
<p>节点状态变化路线 ：</p>
<p><img src="/2022/06/05/%E5%8C%BA%E5%9D%97%E9%93%BE-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/1.jpg"></p>
<h4 id="探讨"><a href="#探讨" class="headerlink" title="探讨"></a>探讨</h4><p>一轮投票可以不可以？ 在不换主或者主节点不作恶的情况下，是可以的，但是我们举一个极端的例子：</p>
<p>在分布式系统下，假设现在少部分进入prepared阶段，另外一些节点还没有进入prepare阶段。此时， 若主节点是恶意节点的话，它可以改变原来的信息，将m修改为具有相同序号的m’,并获得大多数未提交的节点的同意。</p>
<p>但是，如果有两轮投票的话，两轮就可以保证一致性。</p>
<h3 id="检查点协议"><a href="#检查点协议" class="headerlink" title="检查点协议"></a>检查点协议</h3><p>为了节省存储，系统需要一种将日志中的无异议消息记录删除的机制：算法设置周期性的检查点协议，将系统中的服务器同步到某一个相同的状态，同时可以定期地处理日志、节约资源并及时纠正服务器状态。</p>
<ul>
<li><p>在PBFT算法中，会保存所有接收到的消息并记录到日志中，如果日志不能及时清理，会导致奈统资源被大量的日志占用并影响系统的性能和可用性。</p>
</li>
<li><p>另一方面由于拜占庭节点的存在，算法不能保证每个节点执行了相同序列的请求，因此所有节点状态可能不一致。</p>
</li>
</ul>
<h4 id="执行过程："><a href="#执行过程：" class="headerlink" title="执行过程："></a>执行过程：</h4><ul>
<li><p>当副本节点i接收到的请求消息的序号可以被某个常数（如100）整除时会周期性向其他节点广播检查点消息 <code>&lt;CHECKPOINT, n,d,i&gt;</code>, 这里n是最近一个影响状态的请求序号，d是状态的摘要。</p>
</li>
<li><p>每个副本节点都默默地在各自的日志中收集并记录其他节点发过来的检查点消息，直到收到来自<strong>2f+1</strong>个不同副本节点的具有相同序号n和摘要d的检查点消息。</p>
</li>
<li>这2f+1个消息就是这个检查点的正确性证明。</li>
</ul>
<p>算法将这些请求执行后得到的状态称作检查点 (checkpoint)并且将具有证明的检查点称作<strong>稳定检查点 (stable checkpoint)</strong>。每个副本节点保存了服务状态的多个逻辑版本：包括最新的稳定检查点，零个或者多个非稳定的检查点，以及个当前状态。</p>
<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>节点确认某个检查点为稳定检查点后，然后副本节点就可以将所有序号小于等于口的预准各、准备和确认消息从日志中删除。同时也可以将之前的检查点和检查点消息一并删除。</p>
<h4 id="更新水线（watermark）的高低值-（h和H）："><a href="#更新水线（watermark）的高低值-（h和H）：" class="headerlink" title="更新水线（watermark）的高低值 （h和H）："></a>更新水线（watermark）的高低值 （h和H）：</h4><p>这两个高低值限定了可以被接受的消息。水线的低值h与最近稳定检查点的序列号相同，而水线的高值$H=h+k$，k需要足够大才能使副本不至于为了等待稳定检查点而停顿。假如检查点每100个请求产生一次，k的取值可以是200。</p>
<h3 id="水线-watermark"><a href="#水线-watermark" class="headerlink" title="水线(watermark)"></a>水线(watermark)</h3><p><img src="/2022/06/05/%E5%8C%BA%E5%9D%97%E9%93%BE-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/5.png" style="zoom:50%;"></p>
<p>图中A节点的当前请求编号是1039, B节点的请求编号是1133</p>
<p>当前系统的stable checkpoint 为1034，那么这个1034 就是低水位；而高水位$H=h+L$， 即1134</p>
<p>我们看到，A和B的请求编号在高水位和低水位之间，因此这两个请求都会被应答</p>
<p>如果B的请求编号位1135，那么说明B节点处理得很快，跑到很前面去了，这时候B就会停止应答，一直到其编号落入新的高低水位之间。</p>
<h3 id="视图更换协议"><a href="#视图更换协议" class="headerlink" title="视图更换协议"></a>视图更换协议</h3><p>在PBFT算法中，主节点承担消息序号分配、请求转发等核心功能。因此一旦主节点发生了错误，就会导致系统无法正常运行</p>
<p>视图更换协议就是确保主节点失效时算法的活性。</p>
<p>视图更换的触发可以通过备份节点中一个请求的超时执行触发。当一个节点i的超时产生时，会启动视图更换，并将视图编号v变更为v+1,同时不再接受处检查点消息、视图更换消息和新视图消息以外的其他消息请求</p>
<p>这时候，节点i 会向其他副本节点广播视图更换消息<code>&lt;VIEW-CHANGE,v+1,n,C,P,i&gt;</code></p>
<ul>
<li>n是节点i的最新稳定检查点s的序号</li>
<li>C是证明s是稳定检查点的2f+1个检查点消息</li>
<li>P是所有序号大于n的所有<code>prepared(m,v,n,i)</code> 为真的消息集合$P_m$ ,包括请求消息m的有效的预准备消息和与预准备消息一致的2f个准备消息。</li>
</ul>
<p>然后，会通过公式 $p = \text{v mod |R|}$ 计算得到主节点p，当主节点p收到2f个来自其他复制节点的有效的视图更换消息之后，节点p向其他复制节点广播新视图消息<code>&lt;NEW-VIEW,v+1,V,Q&gt;</code></p>
<ul>
<li><p>V包含主节点收到的2f+1个有效的视图更换消息(包括主节点p本身发送的视图更换消息)</p>
</li>
<li><p>Q包含有效的预准备消息（不包括请求消息），其范围通过以下算法获得：从集合V中获取最小的稳定检查点序号<code>min_s</code>和最大的稳定检查点<code>max_s</code>，主节点p为<code>min_s</code>到<code>max_s</code>中间的每个序号n在新的视图v+1中创建新的预准备消息。</p>
</li>
<li>这时序号n存在两种情况：<code>min_s</code>和<code>max_s</code>之间，是否存在于P消息集合<ul>
<li>至少存在一个V中的视图变更消息的集合P中包含序号n，这说明存在一个预准备消息m，则主节点向其他备份节点广播新的预准备消息<code>&lt;PRE-PREPARE,v+1,n,d&gt;</code></li>
<li>V中所有的视图变更消息的集合P中都不包含序号n，则主节点向其他备份节点广播预准备消息<code>&lt;PRE-PREPARE,v+1,n,d_null&gt;</code> ，<code>d_null</code> 是对null消息的签名，null消息执行空动作</li>
</ul>
</li>
<li>最后，主节点以<code>min_s</code>为最新的稳定检查点，并更新水线h为<code>min_s</code></li>
<li>备份节点接收到新视图消息之后，主要完成如下操作<ul>
<li>采用主节点相同的算法校验新视图消息中的Q，校验通过后，将Q中的预准备消息写入本节点的日志</li>
<li>为Q中的每个预准备消息创建准备消息，并向其他复制节点进行广播并将准备消息写入本节点日志。</li>
<li>更新视图编号为 v+1</li>
</ul>
</li>
<li>副本节点会对<code>min_s</code>到<code>max_s</code>中间的消息重新执行三阶段提交协议，在运行阶段，协议会通过本地存储的回复客户端的消息进行校验，已经回复的消息不会重新执行。</li>
</ul>
<p>示意图如下：</p>
<p><img src="/2022/06/05/%E5%8C%BA%E5%9D%97%E9%93%BE-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/6.png"></p>
<p> 通过视图更换协议，是的即使拜占庭节点被称为主节点，也能在视图变换后确保分布式系统的一致性</p>
<h3 id="共识问题"><a href="#共识问题" class="headerlink" title="共识问题"></a>共识问题</h3><p>在PBFT算法中，通过一下四个方面来确保分布式系统中的共识：</p>
<ol>
<li>由单一主节点对来自多个客户端的请求分配序号n，从而对分布式系统的消息进行全局排序</li>
<li>任一复制节点i 的消息m 进入状态<code>prepared(m,v,n,i)</code>,则意味着所有正常节点对同一个视图中的请求序号达成一致，即<strong>当任意两个正常节点，v和n相同时，消息m也相同</strong></li>
<li>任意f+1个正常副本节点集合中的所有副本i其<code>prepared (m,v,n,i)</code>为真，意味着消息m已成功提交给分布式系统即<code>committed (m,v,n)</code>在三阶段提交协议的确认阶段，任一节点i上消息m满足<code>committed-local (m,v,n,i)</code>为真，则<code>committed (m,v,n)</code>，进而节点i可以执行消息并向客户端返回结果，其他节点i也会按照相同的顺序执行消息m，从而实现状态复制。</li>
<li>当客户端收到f+1个从不同副本的同样响应时，则意味着f+1个正常节点己成功执行消息。当f+1个副本节点成功执行消息，就确保了所有正常的节点以同样的顺序执行所有请求。</li>
</ol>
<h3 id="RAFT和PBFT协议的比较"><a href="#RAFT和PBFT协议的比较" class="headerlink" title="RAFT和PBFT协议的比较"></a>RAFT和PBFT协议的比较</h3><div class="table-container">
<table>
<thead>
<tr>
<th>对比点</th>
<th>RAFT</th>
<th>PBFT</th>
</tr>
</thead>
<tbody>
<tr>
<td>适用环境</td>
<td>私有链(不支持拜占庭容错)</td>
<td>联盟链</td>
</tr>
<tr>
<td>算法通信复杂度</td>
<td>$O(n)$</td>
<td>$O(n^2)$</td>
</tr>
<tr>
<td>最大故障和容错节点</td>
<td>故障节点数量f满足 $ 2f+1&lt;= N$</td>
<td>容错节点数量f满足$ 3f+1 &lt;= N$</td>
</tr>
<tr>
<td>流程对比</td>
<td>1. 初始化Leader选举(谁快谁当)<br>2. 共识过程<br>3. 重选Leader机制</td>
<td>1. 初始化Leader选举(轮流坐庄)<br>2. 共识过程<br>3. 重选Leader机制</td>
</tr>
</tbody>
</table>
</div>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/" itemprop="url">高级数据库-事务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-05-11T06:16:41+08:00">
                2022-05-11
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2023-03-25T14:41:56+08:00">
                2023-03-25
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="高级数据库-事务"><a href="#高级数据库-事务" class="headerlink" title="高级数据库-事务"></a>高级数据库-事务</h1><h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><p>首先，我们来复习一下事务的概念：ACID，(其实在sql中已经学过了)</p>
<ul>
<li>原子性(Atomicity): 一个事务要么没有开始，要么全部完成，不存在中间状态</li>
<li>一致性(Consistency): 事务的执行不会破坏数据的正确性，即符合约束</li>
<li>隔离性(Isolation): 多个事务不会相互破坏</li>
<li>持久性(Durability): 事务一旦提交成功，对数据的修改不会丢失</li>
</ul>
<p>事务面向的负载在于查询和更新。其主要特征是：</p>
<ul>
<li>查询：较大数据集合的计算</li>
<li>更新：通常是小部分数据，点数据的更新 </li>
</ul>
<h3 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h3><ul>
<li>实现并发控制：隔离性</li>
<li>实现日志：原子性，持久性</li>
<li>一致性：应用或其他实现保证</li>
</ul>
<h4 id="并发控制的主要内容"><a href="#并发控制的主要内容" class="headerlink" title="并发控制的主要内容"></a>并发控制的主要内容</h4><p>并发控制的意思就是在有多个并发的事务的情况下怎么保持数据库的一致的状态。这个状态有不同的层次，这些层次就是<strong>隔离级别</strong>。隔离级别越高，并发能力越弱；隔离级别越低，并发能力越强。比如说，可串行化是最高的隔离级别。</p>
<p>接下来，我们就要着重了解可序列化这个隔离等级</p>
<h2 id="隔离等级"><a href="#隔离等级" class="headerlink" title="隔离等级"></a>隔离等级</h2><h4 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h4><p>首先给出调度(shedule)的定义：a <strong>sequence</strong> of <strong>(important) steps</strong> taken by <strong>one or more</strong> transactions</p>
<p>那么这些重要的步骤是什么？在并发控制中，往往是对于某一个值的读写操作：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read operation(<span class="type">Read</span>(<span class="type">X</span>))</span><br><span class="line">write operations(<span class="type">Write</span>(<span class="type">X</span>))</span><br></pre></td></tr></table></figure>
<p>我们给一个例子</p>
<p>现在有两个数据库中的值：A和B，它们相等</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">A</span> = <span class="number">25</span></span><br><span class="line"><span class="type">B</span> = <span class="number">25</span></span><br></pre></td></tr></table></figure>
<p>然后有两个事务,第一个事务负责把A和B各加上100，第二个事务负责把A和B各乘以2</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/2.png"></p>
<p>那么其中的一个可能的调度如下：</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/3.png"></p>
<p>当然，T1,T2可能是串行的，也就是先做完T1再做T2</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/4.jpeg" style="zoom: 67%;"></p>
<h3 id="串行执行"><a href="#串行执行" class="headerlink" title="串行执行"></a>串行执行</h3><p>在了解可序列化之前，我们先看看顺序执行是怎么做的。顺序执行非常好理解——它是单线程调度的，做完事务1之后才能做事务2.</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/5.png"></p>
<p>这是事务执行最理想的状态，但同时由于是单线程调度，其没有并发能力</p>
<h3 id="可串行化-Serializable"><a href="#可串行化-Serializable" class="headerlink" title="可串行化(Serializable)"></a>可串行化(Serializable)</h3><p>那么，可串行化的意思说，具有一定的并发能力，但同时让事务的调度结果和串行化是等价的。</p>
<p>比如说还是用上面那个例子，可串行化的调度如下：我们发现，这样的调度和串行化的调度是等价的，最终都能达到 A = B = 250的效果。</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/6.png"></p>
<p>那么<strong>非可串行化</strong>的调度是怎么样的呢？我们看看下图：得到的结果是 A=250,B=150，和串行化调度不等价</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/7.png"></p>
<p>可串行化对事务的执行先后没有要求，但是最后结果需要和串行化调度的结果达成一致</p>
<h3 id="冲突可串行化调度-Conflict-serializable"><a href="#冲突可串行化调度-Conflict-serializable" class="headerlink" title="冲突可串行化调度(Conflict-serializable)"></a>冲突可串行化调度(Conflict-serializable)</h3><h4 id="冲突等价"><a href="#冲突等价" class="headerlink" title="冲突等价"></a>冲突等价</h4><p>冲突操作指的是不同事务对于同一数据的读写操作与写写操作。但是有些冲突操作是<strong>可以交换次序</strong>的(non-conflicting swaps)，有些冲突操作<strong>不能交换次序</strong>(conflicting swaps)。</p>
<p>不能交换位置的次序为：   </p>
<ul>
<li>不同事务对同一个对象的冲突操作</li>
<li>同一事务对同一个对象的两个操作(如读写)</li>
</ul>
<p>定义冲突等价：</p>
<p>如果两个Schedule S1和S2 ， S1可以通过 non-conflicting swaps 转换成 S2的话，那么S1和S2就是冲突等价的</p>
<p>比如说, 现在有这样一个调度，我们将其分为四个色块，分别标记为A,B,C,D</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/8.png"></p>
<p>从块与块之间的角度来看，显然A和B是冲突操作，C和D是冲突操作，因为都涉及到不同事务修改同一个值。所以AB不能交换，CD不能交换</p>
<p>从块内角度分析：A内部$r_1(A)w_1(A)$ 是冲突的，因为这属于同一事务对同一个值的冲突操作。同理BCD也是这样，因此色块内部的顺序也不能调整</p>
<p>但是，我们可以打破块的束缚，从整体来看，下图绿色块跟青色块可以交换次序，因为这两个操作不冲突，不符合第三条的任意一种情况。</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/9.png"></p>
<p>再看新的绿色块与青色块，如果交换它俩也不会发生冲突：</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/10.png"></p>
<p>那么我们说，原调度和这些变化都是冲突等价的</p>
<h4 id="冲突可串行化"><a href="#冲突可串行化" class="headerlink" title="冲突可串行化"></a>冲突可串行化</h4><p>一个调度Schedule1在保证冲突操作次序不变的情况下，通过交换两个事务不冲突操作的次序得到另外一个调度Schedule2，如果Schedule2与串行化等价，那么称调度Schedule1是冲突可串行化的调度。同时称Schedule1和Schedule2是冲突等价的</p>
<p>我们还是拿刚才那个调度为例，经过了两次交换顺序之后, 经过了如下变化：</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/11.png"></p>
<p>最终结果是我们发现T1和T2被串行起来了，这和串行化是等价的。因此我们称原调度是冲突可串行化的</p>
<p>此外隔离等级还有Read Uncommitted，Read Commited， Repeatable Read 等</p>
<h4 id="冲突可串行化的性质"><a href="#冲突可串行化的性质" class="headerlink" title="冲突可串行化的性质"></a>冲突可串行化的性质</h4><p>然后我们要介绍冲突可串行化的一个性质：<strong>冲突可串行化永远是可串行化的</strong>. 因为如果调度是冲突可串行化的，那么必定可以通过交换non-conflicting operations的方法，得到一个新的调度，这个调度是串行化的。因此根据可串行化的定义，冲突可串行化也是可串行化的 </p>
<p>但是要注意，<strong>可串行化的调度，不一定是冲突可串行化的</strong>，我们来举一个例子：现在有三个事务如下</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/12.png"></p>
<p>有两个Schedule如下：其中S2是串行的调度</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/13.png"></p>
<p>显然，S1和S2最终达到的效果是一样的，因此S1是可串行化的。但是<strong>S1却不是冲突可串行化</strong>的。因为没有办法通过non-conflicts swap将S1转换为S2</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/14.png"></p>
<h3 id="Recoverble-Schedule"><a href="#Recoverble-Schedule" class="headerlink" title="Recoverble Schedule"></a>Recoverble Schedule</h3><p>可恢复的调度(<strong>recoverable schedule</strong>)：是指已提交的事务不应该发生回滚的调度。我们用一张图来说明：如果$T_k$需要读取T1、T2、T3的写，那么T1、T2、T3就需要在$T_k$之前提交。</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/15.png" style="zoom:67%;"></p>
<p>可恢复的调度分为以下几类：</p>
<ol>
<li>层联回滚(<strong>Cascading rollback</strong>)调度：未提交的事务从未提交的(失败)事务中读取了错误的数据（<strong>Dirty Read</strong> ），必须回滚。</li>
<li>无层联回滚的：事务只读取已提交事务写的数据(<strong>Read Commited</strong>)。</li>
<li>严格调度(<strong>Strict Schedule</strong>)：在写数据项的最后一个事务提交之后事务才能开始读/写该数据项。</li>
</ol>
<p>为什么要有这个概念呢？如果不是recovery的调度的话，一旦系统发生了故障，就无法恢复。试想，如果T1写了A，然后Tk读取了A，并先于T1提交了。那么假设在Tk提交到T1提交这个时间段出现了系统故障，那么当系统重启之后按道理来说需要回滚到T1写A之前，但是T1并没有提交，系统只会回滚到Tk读取A的那个状态。因此丢失了A原来的值。</p>
<h4 id="Read-Uncommitted"><a href="#Read-Uncommitted" class="headerlink" title="Read Uncommitted"></a>Read Uncommitted</h4><p>是最低级别的隔离等级。它什么都不会做，漏洞最多。会出现上面所说的所有问题。因为事务之间没有互相隔离，他们可以读取互相做出的未提交修改。<strong>在这种情况下不允许发生脏写</strong>，但是可能发生脏读、不可重复读、幻读。</p>
<h4 id="Read-Committed"><a href="#Read-Committed" class="headerlink" title="Read Committed."></a>Read Committed.</h4><p>当我们使用这个隔离级别时，事务只能读取已经提交了的数据。如果我们需要在事务中进行商务上的计算，我们的决定是基于有效的、已经提交的数据。事务运行之后有数据发生了变化，事务也不会去关注这个问题。这个隔离级别可以避免Dirty Read这个问题</p>
<h4 id="Repeatable-Read"><a href="#Repeatable-Read" class="headerlink" title="Repeatable Read:"></a>Repeatable Read:</h4><p>在这种级别下，读取的内容是可重复的，就算是数据被其他的事务修改了也没事。我们看到的只是第一次读取时就生成的快照。这个级别可以避免 Lost Updates, Dirty Reads 和 Non-repeating Reads这三个问题</p>
<h3 id="异常等级"><a href="#异常等级" class="headerlink" title="异常等级"></a>异常等级</h3><h4 id="Dirty-Writes"><a href="#Dirty-Writes" class="headerlink" title="Dirty Writes"></a>Dirty Writes</h4><p>两个事务在没提交的情况下去更新同一行数据的值</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/17.png" style="zoom:67%;"></p>
<p>我们对一条数据进行两次更新，一次更改洲名，一次更改积分，但是这样一来，如果B是后更新的，那么B中的数据会覆盖掉A中更新的数据，造成更新丢失。我们这时候就需要Locks来规避这种情况的发生，默认情况下，Mysql使用了锁定机制以防止两个事务同时更新相同的数据，他们在一个队列中，按照顺序进行。</p>
<h4 id="Dirty-Reads"><a href="#Dirty-Reads" class="headerlink" title="Dirty Reads"></a>Dirty Reads</h4><p>Dirty Reads 发生在事务读取还没有提交的数据时，比如下图。事务A想把顾客的分设置为20，在还没有提交的时候，事务B读取了表中更新过后的数据。如果每一分代表优惠一元，那么这位顾客可以优惠20元。但是事务A在提交前发生回滚。这时候事务B还没结束，所以事务B读取的数据是非法的。也就是说，在这种情况下，白给了顾客20元的优惠，因为事务B中读取了未提交的数据 。这就是 Dirty Reads，很形象。因为我们读取了污染的数据。 </p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/18.png" style="zoom:67%;"></p>
<p>为了解决这个问题，我们需要围绕事务提供一定程度的隔离度。所以事务修改的数据并不会立刻被其他事务读取到。为了规避这个问题，可以使用Read Committed及以上的隔离等级。</p>
<h4 id="Non-repeating-Reads"><a href="#Non-repeating-Reads" class="headerlink" title="Non-repeating Reads"></a>Non-repeating Reads</h4><p> 如果在事务进行过程中，我们读取了两次、得到了不一样的结果怎么办.比如下图。事务A中选择了数据表中一条值为10的信息，但是这时候，B把这条信息的数据改成了0，现在A中的子查询又想读取这条信息，发现这时候其值已经变成0了。对于这种不重复读取的异常，我们可以将隔离级别从 read committed（读已提交）提升到repeatable read（可重复读）。</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/19.png" style="zoom:67%;"></p>
<h4 id="Phantom-Reads"><a href="#Phantom-Reads" class="headerlink" title="Phantom Reads"></a>Phantom Reads</h4><p>假设有个事务A，我们查询了所有积分大于10的客户，发给他们额外的打折券。这时候，一个事务B修改了一位顾客甲，把他的分从0修改到了20。但这时候事务A已经完成查询，甲并不在查询结果当中。这就是我们说的Phantom Read，数据有时候会像幽灵一样突然冒出来。是否解决这个问题要看我们的业务、以及把这个客户纳入我们的事务中的重要性。</p>
<p>不可重复读和幻读区别：不可重复读的重点是修改；同样的条件，第1次和第2次读取的值不一样。幻读的重点在于新增或者删除；同样的条件， 第1次和第2次读出来的记录数不一样。从控制角度来看，不可重复读只需要锁住满足条件的记录，幻读要锁住满足条件及其相近的记录。</p>
<hr>
<p>事实上，隔离等级是根据异常等级的不同而划分的。我们可以用一张表来总结：</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/1.jpg" style="zoom:67%;"></p>
<h3 id="实现隔离级别"><a href="#实现隔离级别" class="headerlink" title="实现隔离级别"></a>实现隔离级别</h3><p>首先我们来介绍几种锁</p>
<ul>
<li><p>共享锁 shared lock (简称S锁) : 应用于所有读操作</p>
<ul>
<li>如果事务T1对数据对象O1加上了共享锁，那么当前事务只能对O1进行读取操作，其他事务也只能对这个数据对象加共享锁——直到该数据对象上的所有共享锁都被释放。</li>
<li>共享锁和排他锁最根本的区别在于，加上排他锁后，数据对象只对一个事务可见，而加上共享锁后，数据对所有事务都可见。</li>
</ul>
</li>
<li><p>排他锁 exclusive lock(简称X锁): 应用于所有写操作</p>
<ul>
<li>如果事务 T1对数据对象 O1加上了排他锁，那么在整个加锁期间，<strong>只允许事务 T1</strong>对 O1进行<strong>读取和更新</strong>操作，其他任何事务都不能再对这个数据对象进行任何类型的操作——直到T1释放了排他锁</li>
</ul>
</li>
<li><p>Short duration lock: 短锁，动作完成前申请，完成后立即释放锁</p>
</li>
<li>Long duration lock: 长锁, 动作完成前申请，直到Commit之后才会释放锁</li>
</ul>
<p>我们可以用锁来定义不同的隔离级别:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Consistency Level = Locking Isolation Levo</th>
<th>Read Locks on Data Items and Predicates</th>
<th>Write Locks on Data Item and Predicates</th>
</tr>
</thead>
<tbody>
<tr>
<td>Degree 0</td>
<td>没有要求</td>
<td>Well-formed Writes</td>
</tr>
<tr>
<td>Degree1  <br>READ UNCOMMITED</td>
<td>没有要求</td>
<td>Well-formed Writes<br> Long duration Write locks</td>
</tr>
<tr>
<td>Degree2   <br>READ COMMITED(读已提交)</td>
<td>Well-formed Reads<br>Short duration Read locks(both)</td>
<td>Well-formed Writes<br> Long duration Write locks</td>
</tr>
<tr>
<td>REPEATABLE READ(可重复读)</td>
<td>Well-formed Reads<br>Long duration <strong>data-item</strong> Read locks<br>Short duration Read Predicate  locks(both)</td>
<td>Well-formed Reads<br>Long duration Write locks</td>
</tr>
<tr>
<td>SERIALIZABLE(序列化)</td>
<td>Well-formed Reads<br>Long duration Read locks(both)</td>
<td>Well-formed Reads<br>Long duration Write locks</td>
</tr>
</tbody>
</table>
</div>
<h4 id="实现的原理"><a href="#实现的原理" class="headerlink" title="实现的原理"></a>实现的原理</h4><ul>
<li>READ UNCOMMITED: 事务在读数据的时候并未对数据加锁。事务在修改数据的时候只对数据增加行级共享锁。<ul>
<li>此时，事务1读取某行记录的时候，事务2也可以对这行数据进行读取、更新(因为事务1未加锁)</li>
<li>事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。（因为事务一对数据增加了共享读锁，事务二不能增加排他写锁进行数据的修改）。因此，可以避免脏写的情况。</li>
<li>当事务2对该记录进行更新时，事务1再次读取该记录，能读到事务2对该记录的修改版本（因为事务二只增加了共享读锁，事务一可以再增加共享读锁读取数据），即使该修改尚未被提交。但是，无法避免脏读、重复读、幻读的情况，因为它对读操作并没有上锁。</li>
</ul>
</li>
<li>READ COMMITED: 事务对当前被读取的数据加<strong>行级共享锁(当读到时才加锁)</strong>，一旦读完该行，立即释放该行级共享锁，(短锁)；事务在更新某数据的瞬间(就是发生更新的瞬间），必须先对其加 行级排他锁(长锁)，直到事务结束才释放。<ul>
<li>脏读发生的环境是，事务A修改了一个变量，另一个事务B刚好读取了这个变量，但事务A还没有提交的时候，就发生了回滚。因此B读取到了一个脏的数据(还没持久化的数据)。当使用READ COMMITED隔离级别的时候，在更新数据的时候加上了排它锁，因此在事务B读取特定变量的时候，无法对数据加读共享锁。事务B只能等待事务A的写操作提交以后，或者事务A回滚以后，释放了排它锁，才能读取该变量的值。</li>
<li>但此时，由于是对读操作上了短共享锁，读取完成后立即释放。试想一下这个情景，事务A需要读取一个x的值10，读取完后释放锁，但事务A还没有结束，去忙别的事情了。这时候，事务B对x进行了更新，将其改为了20并提交了。那么，当事务A再次去读取x的时候，发现变成了20。这就是<strong>不可重复读错误</strong></li>
<li>再来思考一个场景，事务A筛选出积分大于10的客户，并要对其发送优惠券。此时x的积分为0，不属于A的筛选范畴，因此事务A不需要对x上锁。但是，这时候事务B修改了x的积分，到20，并成功提交。那么这时候，事务A还没结束，但是其筛选出来的值与真实的数目不符。因此，幻读还是没有办法避免的。</li>
</ul>
</li>
<li>REPEATABLE READ: 事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 行级共享锁，直到事务结束才释放(长锁)；事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放(长锁)。<ul>
<li>此时来看不可重复读，当事务A开始读取变量x的时候，会对其上长共享锁，直到事务提交才会释放。那么这时候，如果B尝试对x进行更新的话，需要获取对x的排它锁,这是不被允许的。因此只有当事务A执行结束之后，事务B才可以修改x的值。</li>
<li>但是来看幻读，当事务A只会对某一行上长共享锁，并不会对整张表上长共享锁。因此，如果事务A一开始没有选中对象x，那么也不会对其上锁，还是会蹦出来新的数据。因此也不能避免幻读的发生</li>
</ul>
</li>
<li>SERIALIZABLE：事务在读取数据时，必须先对其加 表级共享锁 ，直到事务结束才释放；事务在更新数据时，必须先对其加 表级排他锁 ，直到事务结束才释放。<ul>
<li>此时，当对一张表进行读取的时候，会对读取的所有内容上长锁(共享锁)，因此事务B如果要对表中的内容进行修改，必须等事务A先提交以后，才可以获取排它锁并进行修改，因此也不会有新的内容产生、避免了幻读。</li>
<li>这种序列化隔离条件，对并发性能的影响是很大的</li>
</ul>
</li>
</ul>
<h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p>下面的调度至高是在那种隔离级别下产生的调度？</p>
<p><code>R1(x)W2(x)C2 W1(x)C1</code></p>
<p>首先，不可能是Repeated Read,因为这种情况会给读操作上长锁，需要提交后才会释放锁，因此不可能在 R1(x)之后就发生W2(x)</p>
<p>那么可能是Read Commited吗? 在R1(x)处读上了短读锁，释放后在W2(x)上了一个长写锁，在C2结束后释放。然后在W1(x)处上了长写锁，在C1结束后释放。因此，Read Commited是可能发生的</p>
<h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><h3 id="2PL"><a href="#2PL" class="headerlink" title="2PL"></a>2PL</h3><p>参考： <a href="https://zhuanlan.zhihu.com/p/480379228" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/480379228</a></p>
<h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>在事务并发的时候，我们需要找到一种机制来实现事务的冲突可串行化。那么2PL就是这样一种机制。它属于“悲观锁”，因为这个策略的核心就是：一个事务中，在拿到所有锁之前，不能释放锁。</p>
<p>一个朴素的加锁的方法如下：</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/2.jpg"></p>
<p>流程如下：</p>
<ol>
<li>在事务$T1$ 访问A之前，先通过DBMS的锁管理器（Lock Manager）获取A的锁并且注册（记录下来“A的锁当前归T1所有”）</li>
<li>事务T2想访问A，于是也要获得A的锁，锁管理器便会<strong>拒绝</strong>它的请求，T2之后便阻塞在这里</li>
<li>直到T1完成了对A的全部操作后通过锁管理器释放A的锁，T2才可以通过锁管理器获取A的锁，并且完成对A的全部操作后释放A的锁</li>
</ol>
<h4 id="Locks-Type"><a href="#Locks-Type" class="headerlink" title="Locks Type"></a>Locks Type</h4><p>事实上，数据库中有两种保护数据的方式： Locks 和 Latches 。</p>
<p>Latches 就是大家在学习多线程编程时接触到的锁，如 <code>mutex</code>、<code>rwlock</code>、<code>semaphore</code>、<code>spinlock</code>。用来做<strong>线程之间</strong>的并发控制。</p>
<p>数据库中的 locks 一般是指行锁、范围锁、表锁这些。用来做<strong>事务之间</strong>的并发控制。它保护的不是具体的数据结构，而是数据库的抽象的内容，比如说向锁管理器申请的可以是对数据库的表的某一行的锁，这个锁会保护涉及这一行的所有的索引里面关于这一行的部分</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>Locks</th>
<th>Latches</th>
</tr>
</thead>
<tbody>
<tr>
<td>Separate</td>
<td>User Transactions(用来隔离事务)</td>
<td>Threads(用来线程并发)</td>
</tr>
<tr>
<td>Protect</td>
<td>Database Contents(数据库中持久化的内容)</td>
<td>In-Memory Data Structures(内存中的数据结构)</td>
</tr>
<tr>
<td>During</td>
<td>Entire Transactions</td>
<td>Critical Sections</td>
</tr>
<tr>
<td>Modes</td>
<td>Shared(共享锁), Exclusive(排他锁)</td>
<td>Read(读锁)，Write(写锁)</td>
</tr>
<tr>
<td>Deadlock</td>
<td>Detection &amp; Resolution</td>
<td>Avoidance</td>
</tr>
<tr>
<td>死锁解决方式</td>
<td>Waits-For, Time out, Aborts</td>
<td>Coding Discipline</td>
</tr>
<tr>
<td>Kept in..</td>
<td>Lock Manager</td>
<td>Protected Data Structure</td>
</tr>
</tbody>
</table>
</div>
<p>我们在数据库中，主要用的是Lock，之前也说了Lock分为共享锁和排他锁两种：</p>
<ul>
<li>S-Lock : Shared locks for reads , 和Latch中的读锁差不多</li>
<li>X-Lock : Exclusive locks for writes ，和Latch中的写锁差不多</li>
</ul>
<p>在带有Lock的情况下，事务的执行过程如下：</p>
<ul>
<li>事务获取对应的锁</li>
<li>锁管理器(Lock Manager) 授权或者阻塞事务</li>
<li>事务释放锁</li>
</ul>
<p>其中，LM内部有数据结构，记录着一张锁的表格，包括什么事务在用这个锁，是什么类型的锁，什么事务在等待用这个锁</p>
<p>以下场景就是用了 X/S 这两种锁，分别用来做A的读写操作：</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/3.jpg"></p>
<p>但是仅仅通过加锁，能将原本不可串行化的执行调度的执行结果变正确吗？我们看到，在T1释放了锁以后，T2立马得到了X锁并对A进行修改，解这 T1再次获取S锁、读取A的时候，就会发现这个A并不是它最后修改的A。</p>
<p>这就是发生了不可重复读的错误。因此，后来的DBMS方面的学者专家们就在此之上进行改进，提出了两阶段锁来实现并发控制</p>
<h4 id="Two-Phase-Locking"><a href="#Two-Phase-Locking" class="headerlink" title="Two-Phase Locking"></a>Two-Phase Locking</h4><p>两阶段所是一个并发控制协议，它规定了一个事务在运行的过程中如何跟其他事务之间协调锁，从而实现可串行化。使用两阶段锁<strong>不需要提前知道</strong>完整的执行调度，它会在调度进行的过程中避免不可串行化的情况发生</p>
<p>两阶段锁，顾名思义有两个阶段：</p>
<ul>
<li>增长阶段( Growing )<ul>
<li>在这个阶段，每个事务都只能不断的从LM那边获得锁，不能释放锁</li>
<li>LM可以根据情况给事务所需要的锁，或者阻塞事务(不给锁)</li>
</ul>
</li>
<li>缩小阶段 ( Shrinking )<ul>
<li>在这个阶段事务只能释放它之前拥有的锁，并且不能再获取新的锁</li>
</ul>
</li>
</ul>
<p>因此，在一个事务的生命周期里，它所持有的锁的数量的变化趋势如下所示，最后所有获取过的锁都被释放之后，会提交事务(Commit)</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/4.jpg"></p>
<p>使用二阶段锁便可以使得不可串行化的执行调度的最终执行结果具有一致性，如下所示，在两阶段锁协议下，事务T1执行完<code>W(A)</code>后并不会立即释放A的锁，因为二阶段锁协议的规定就是“先一直获取各个锁，然后把所有获取的锁逐个释放”，直到<code>R(A)</code>执行完了之后T1才会释放锁（如果按照之前的策略，先获取X-Lock，再释放X-Lock，然后再获取S-Lock，之后再释放S-Lock，这就违反了两阶段锁的协议）</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/5.jpg"></p>
<p>与此同时，在事务T1释放A的锁之前，事务T2获取A的锁的操作会被一直阻塞，直到T1把A的锁释放</p>
<p>在使用了二阶段锁协议后，相应的执行调度对应的依赖图（Dependency Graph）一定没有环，二阶段锁可以严格地保证冲突可串行化</p>
<h5 id="级联回滚"><a href="#级联回滚" class="headerlink" title="级联回滚"></a>级联回滚</h5><p>但是二阶段锁也有一些问题：级联回滚（Cascading Aborts）</p>
<p>如下所示，T1释放锁之后，T2事务开始被执行，T2对A的操作是基于T1对A进行临时修改后的版本进行的，如果T1事务没有提交而是被abort了，那么T2必须跟着T1一起回滚（如果T2进行的是读操作，那么这也被称为脏读，”dirty reads”）</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/6.jpg"></p>
<p>级联回滚本质上的原因是T2事务在T1事务更新得到的临时版本的数据上进行了操作，那我们可以通过一些手段让T2不在T1修改得到的临时版本上进行操作：</p>
<ul>
<li>可以让事务先获取各个需要获取的锁，等到它commit的时候，再一次性将这些锁释放掉，这样的话，T2就不可能再临时版本上进行操作。因为T2能获得锁并执行事务的时候，它所访问的一些数据已经被提交并持久化了。</li>
</ul>
<p>因此，这个方法也叫做严格二阶段锁(Strong Strict 2PL,简称 SS2PL) </p>
<p>再严格二阶段锁协议下，事务所持有锁的数量变化，如下所示：</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/7.jpg"></p>
<p>严格二阶段所协议的特点是事务所修改的数据在事务结束之前，其他事务都不能读写，这个协议的<strong>好处就是不会产生级联回滚</strong>。而且事务可能对数据进行了很多次更新，但在严格二阶段锁协议下，需要回滚时，直接回滚到事务开始时即可，不用管它进行过多少次更新，因为这个事务在进行数据更新时，<strong>绝对不会有其他的事务也在更新共享的数据</strong></p>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>举个例子： 事务T1是A给B转账100，事务T2是计算A和B的账户余额的和</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/46.png"></p>
<ul>
<li>如果完全不适用二阶段锁，那么可能出现不一致的情况：</li>
</ul>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/8.jpg"></p>
<ul>
<li>如果使用二阶段锁协议</li>
</ul>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/9.jpg"></p>
<p>那就可以保证一致性，等效成T1事务先执行，然后T2事务执行，即冲突可串行化。但存在潜在的级联回滚问题</p>
<ul>
<li>如果使用了严格二阶段锁协议，如下所示，既可以保证一致性，也可以避免级联回滚</li>
</ul>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/10.jpg"></p>
<h5 id="Venn图总结"><a href="#Venn图总结" class="headerlink" title="Venn图总结"></a>Venn图总结</h5><p>我们可以将 <strong>视图可串行化, 冲突可串行化 , 严格二阶段锁 , 序列化 ,级联回滚</strong> 这几个概念组成一个Venn图</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/27.jpg"></p>
<p>在全部可能发生的执行调度里, 事务串行执行是很小的子集，冲突可串行化的执行调度是更大的子集，视图可串行化的执行调度对应还要再大一点的子集</p>
<h3 id="TO"><a href="#TO" class="headerlink" title="TO"></a>TO</h3><p>TO(Timestamp Ordering)</p>
<h3 id="OCC"><a href="#OCC" class="headerlink" title="OCC"></a>OCC</h3><p>OCC(Optimistic Concurrency Control) 是事务的乐观并发控制，乐观是说冲突没那么容易产生，因此只在事务要提交的时候去检测冲突。现在有很多内存数据库中采用这种机制，因为数据所有的操作都在内存里完成，事务的运行时间会缩短，因此出错的概率也会变小。从理论上来说，内存数据库中最佳的并发控制策略就是OCC。但是OCC也存在一些问题，比如说事务会经常重启(遇到错误时)，很多事务会一直达不到结束的条件，导致无法完成。</p>
<h4 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h4><p>OCC的基本思路是：每个事务会产生一个私有空间，并在里面维护事务中的读写集合。在事务提交的时候，验证读写集合是否与其他事务冲突，如果没有，则将写集合应用于数据;否则就把事务abort掉，再重做</p>
<p>另外，OCC为每个事务分配了一个时间戳，反映了事务的可串行化顺序，以方便验证</p>
<h4 id="OCC的三个阶段"><a href="#OCC的三个阶段" class="headerlink" title="OCC的三个阶段"></a>OCC的三个阶段</h4><ul>
<li>读阶段<ul>
<li>执行事务，并在事务的私有空间生成事务的读写集合</li>
</ul>
</li>
<li>验证阶段<ul>
<li>提交之前，通过读写集合验证是否有冲突。这是整个策略的重点</li>
</ul>
</li>
<li>写阶段<ul>
<li>将写集合应用到数据，commit or abort</li>
</ul>
</li>
</ul>
<h4 id="OCC例子"><a href="#OCC例子" class="headerlink" title="OCC例子"></a>OCC例子</h4><h5 id="读阶段"><a href="#读阶段" class="headerlink" title="读阶段"></a>读阶段</h5><p>读阶段生成读集合。 此时所有事务都是并发的</p>
<ul>
<li>T1 有两步： <code>T1.ReadSet={A}，T1.WriteSet={A}</code></li>
<li>T2有一步：<code>T2.ReadSet={A}</code></li>
</ul>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/36.png"></p>
<h5 id="验证阶段"><a href="#验证阶段" class="headerlink" title="验证阶段"></a>验证阶段</h5><p>在最原始的OCC中，<strong>只有读阶段是并发的</strong>，验证阶段和写阶段是阻塞的，因此当一个事务在验证或者写的时候，另外的事务是无法运作的。现在有些研究速度更快、并行度更高的验证规则。</p>
<p>一般来说，现在都会在验证阶段给事务分配时间戳，如下：</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/37.png"></p>
<p>验证阶段的目标就是要保证事务的可串行化，即Ti需要和其他事务是否有读写冲突和写写冲突。</p>
<p>在验证的时候主要要关注三个时间点：事务开始(读阶段)时间、事务结束(写阶段)时间，验证阶段开始时间。由于…导致会有不同情况的出现，接下来我们来介绍几种在满足<code>Ti&lt;Tj</code>之后可以提交事务Ti的情况</p>
<h5 id="Case1"><a href="#Case1" class="headerlink" title="Case1"></a>Case1</h5><ul>
<li>要求：Ti在Tj事务开始之前完成写阶段</li>
</ul>
<p>这很容易理解，时间戳示意图如下：</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/39.png"></p>
<p>事务调度顺序如下：</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/38.png"></p>
<p>这很容易理解，此时Ti和Tj是没有冲突的</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/39.png"></p>
<h5 id="Case2"><a href="#Case2" class="headerlink" title="Case2"></a>Case2</h5><ul>
<li>要求： $T_i$ 在 $T_j$的验证阶段开始前完成写阶段， 并且 $\text{WriteSet}(T_i)\cap \text{ReadSet}(T_j)=\empty$ </li>
</ul>
<p>第二种情况，相当于在Case1的基础上，将 <code>tj</code>事务左移了一段距离，如下：</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/40.png"></p>
<p>注意，Ti的写集合和Tj的读集合的交集必须为空，否则会发生读写冲突。如下所示：我们看到，T1还没有提交关于B的修改，T2就开始读取B了，这时候就不是可串行化了。</p>
<p>那么有人要问了，如果T1的写集合是A，且在T1提交时T2才刚好读取A，看起来不会有问题，可行吗？其实这种也会被abort掉，因为毕竟是小概率事件，为了方便都会中止事务</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/41.png"></p>
<h5 id="Case3"><a href="#Case3" class="headerlink" title="Case3"></a>Case3</h5><ul>
<li>要求：$T_i $在$T_j$的读阶段结束前开始验证阶段， 并且<ul>
<li>$\text{WriteSet}(T_i)\cap \text{ReadSet}(T_j)=\empty$ </li>
<li>$\text{WriteSet}(T_i)\cap \text{WriteSet}(T_j)=\empty$ </li>
</ul>
</li>
</ul>
<p>示意图如下：</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/42.png"></p>
<p>第一个条件可以理解，和case 2是一样的，那么为什么要满足第二个条件呢？</p>
<p>因为如果两个事务的写集合发生重复，而且二者的写阶段也是可能发生重叠的，因此这个要求是为了避免写覆盖的发生。</p>
<h4 id="OCC基本实现"><a href="#OCC基本实现" class="headerlink" title="OCC基本实现"></a>OCC基本实现</h4><p>事实上，在设计OCC的时候我们设计了 验证阶段+写阶段的临界区</p>
<ul>
<li>在临界区中，只能让一个事务的读阶段去和另外一个事务的读/写阶段去并行。</li>
<li>因为临界区只能允许一个事务进入，因此所有事物之间的验证阶段和写阶段是互斥的</li>
<li>因此，Case3实际不会出现</li>
</ul>
<p>总结一下Case1和Case2：</p>
<ul>
<li>Case1: <code>Finish(Ti)&lt;Start(Tj)</code></li>
<li>Case2: <code>Start(Tj)&lt;Finish(Ti)&lt;Validation(Tj)</code> ,且对$T_j$的读集合，需要验证他和所有满足上面范围的$T_i$的写集合是否有交集，这样就意味着只需要维护每个事物的写集合即可。<ul>
<li>这里不用写集合去和别人的读集合做验证的原因是，维护读集合的难度要比维护写集合要大得多</li>
</ul>
</li>
</ul>
<p>思考算法是如何巧妙利用时间戳实现Case1 和Case2的？</p>
<ul>
<li>Case1， 事务开始获得当前时间戳<code>start tn</code>，在 比较时从<code>start tn+1</code>开始的事务去验证，因为 start tn之前的事务已经完成。</li>
<li>Case2， 事务再次获取当前时间戳<code>finish tn</code>, 因此所有在<code>start tn</code>与<code>finish tn</code>之间提交的事务都是满足 case2的。</li>
</ul>
<p>伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">thegin = &#123;</span><br><span class="line">	create <span class="built_in">set</span> := empty;</span><br><span class="line">	<span class="built_in">read</span> <span class="built_in">set</span> := empty;</span><br><span class="line">	<span class="built_in">write</span> <span class="built_in">set</span> := empty;</span><br><span class="line">	<span class="keyword">delete</span> <span class="built_in">set</span> := empty;</span><br><span class="line">	start tn := tnc <span class="comment">//tnc是一个单调递增公共时间戳，事务一开始时就获取</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 临界区</span></span><br><span class="line">tend = &#123;</span><br><span class="line">		&lt; finish tn := tnc;</span><br><span class="line">			valid := <span class="literal">true</span>;</span><br><span class="line">			<span class="comment">// 满足case2的条件的事务t(当前事务开始到上个事务结束这段时间)</span></span><br><span class="line">			<span class="keyword">for</span> t from start tn+<span class="number">1</span> to finish tn <span class="keyword">do</span></span><br><span class="line">			<span class="comment">// 这边用当前事务的读集合去和满足条件的t的写集合去做检查，即case2</span></span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">write</span> <span class="built_in">set</span> of transaction with transaction number t intersects <span class="built_in">read</span> <span class="built_in">set</span>)</span><br><span class="line">						then valid := <span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">if</span> valid</span><br><span class="line">					then((<span class="built_in">write</span> phase); tnc := tnc + <span class="number">1</span>; tn = tnc)&gt;;</span><br><span class="line">					</span><br><span class="line">				<span class="keyword">if</span> valid</span><br><span class="line">						then (clean up);</span><br><span class="line">				<span class="keyword">else</span> (backup)</span><br><span class="line">				</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h3><p>多版本是指：对某一数据项，数据库中存储其多个不同时间点上的状态(一次修改看做是一次状态)。不同的状态存储在链上</p>
<ul>
<li>每次写操作，创造一个新的版本</li>
<li>每个读操作，通常事务开始时获取一个版本，读取小于等于该版本的最新数据，因此可以避免不可重复读的错误</li>
</ul>
<p>多版本能实现读写分离(优点)：</p>
<ul>
<li>读不阻塞写</li>
<li>写不阻塞读</li>
</ul>
<h4 id="SnapShot-Isolation"><a href="#SnapShot-Isolation" class="headerlink" title="SnapShot Isolation"></a>SnapShot Isolation</h4><p>SI既是一种实现，也是一种隔离级别(快照隔离级别)，为什么是快照？因为SnapShot读取的是数据库中的旧版本</p>
<p>SI流程如下：</p>
<ul>
<li>事务开始:<ul>
<li>– Get snapshot  定义快照时间点</li>
</ul>
</li>
<li>事务执行: <ul>
<li>Reads from snapshot 从快照中读取</li>
<li>Writes to private workspace </li>
</ul>
</li>
<li>事务提交:<ul>
<li>Check for write-write conflicts <ul>
<li>如果有abort到只有一个事务提交 </li>
</ul>
</li>
<li>Install updates</li>
</ul>
</li>
</ul>
<h4 id="例子：SI的版本变化"><a href="#例子：SI的版本变化" class="headerlink" title="例子：SI的版本变化"></a>例子：SI的版本变化</h4><p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/44.png"></p>
<p>如上图，已知有三个提交: Commit T1,T2,T3，每次都会生成一个时间戳</p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>首先，我们先学习ACID与日志的关系——ACID那些性质与日志存在关系呢？显然是原子性和持久性 </p>
<p>从单机数据库角度来说，需要使用日志的地方有很多——各种故障</p>
<ul>
<li>存储介质故障</li>
<li>灾难性故障</li>
<li>系统故障<ul>
<li>断电</li>
<li>软件中止</li>
<li>操作系统中止</li>
</ul>
</li>
</ul>
<p>不管是什么故障，有日志的存在，就能是数据库恢复到一致的状态，已经提交的事务就是持久化了,还没有提交的事务需要回滚</p>
<h3 id="缓冲区策略与日志的关系"><a href="#缓冲区策略与日志的关系" class="headerlink" title="缓冲区策略与日志的关系"></a>缓冲区策略与日志的关系</h3><p>之前我们学过数据库中有个缓冲区，还写了一个BPManager的程序来进行lru调度。</p>
<p>现在我们来讨论一下事务、脏页、日志三者之间的关系，来看下图</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/16.png" style="zoom:67%;"></p>
<ul>
<li>Steal: 允许未提交事务刷入磁盘</li>
<li>Force: 只有事务的所有数据都刷入磁盘，事务才能提交</li>
</ul>
<h4 id="Steal-No-Steal"><a href="#Steal-No-Steal" class="headerlink" title="Steal/ No-Steal"></a>Steal/ No-Steal</h4><p>现在来定义 No-Steal 策略，No-Steal是说在事务提交之前，页面不能被写入磁盘。这去报了我们不会让数据库处于一个中间状态——因为如果该事务没有完成，那么它的任何变化也不应该被持久化。但这个策略的缺陷在于它束缚了我们使用内存的方式，我们必须把每个脏页保留下来，直到一个事务完成——可能会占用大量内存空间</p>
<p>因此我们提出Steal策略，即允许在事务完成之前将修改过后的脏页写回到磁盘上。</p>
<p>Steal的例子如下，我们看到，在把A从100改为90的之后，还未提交就把A刷入了磁盘。就好像偷偷摸摸的把页给写到磁盘里去了 </p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/20.jpg" style="zoom:67%;"></p>
<p>那么显然这种方法是有问题的，比如在这里修改了A，然后直接把A写回磁盘，这时候突然发生了系统故障。由于B还没有被修改，因此数据库需要回滚到A被修改前的状态。因此，这里需要用到Undo日志，记录修改前的状态。</p>
<h4 id="Force-No-Force"><a href="#Force-No-Force" class="headerlink" title="Force/No Force"></a>Force/No Force</h4><p>force是说在事务提交前<strong>强制所有修改过的数据页到磁盘</strong>， 这将确保耐久性。但是这种方法的缺点是性能不足，最终我们会做很多不必要的写操作。</p>
<p>因此No Force策略更加常用。这种策略是说，<strong>只在脏页要被从缓冲区删除的时候再写回磁盘</strong>。这样可以减少不必要的写入，但它是的数据库的持久性变得复杂。因为可能出现没有把脏页全刷回磁盘的情况，发生故障之后可能会导致数据丢失，因此需要Redo日志。</p>
<p>也就是说，<strong>日志需要记录修改后的值</strong>，这样一旦发生故障，可以通过Redo日志将数据库改为日志提交过后的状态，体现了数据库的持久性。</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/22.png" style="zoom:67%;"></p>
<p>再回到上面那个四宫格，我们看到Force+No Steal策略是最方便的，最容易实现的。但是我们还是选择NoForce+Steal策略，虽然仅用这个策略无法满足持久性和原子性，但是可以获得最好的功能。至于如何实现原子性和持久性，我们就需要靠undo+redo日志来帮忙了</p>
<h3 id="WAL日志"><a href="#WAL日志" class="headerlink" title="WAL日志"></a>WAL日志</h3><p>先写日志 WAL(write-ahead logging)，做一个操作之前先讲这件事情。</p>
<ol>
<li>将对数据库的修改记录在单独的存储空间中（日志缓冲区） 日志缓冲区和数据缓冲区是两回事</li>
<li>日志只支持追加操作（顺序I/O）</li>
<li>修改的数据对象持久化之前，需要保证其对应的修改已记录在日志文件中(WAL)</li>
<li>日志落盘后事务即可提交 S2PL释放锁的时间呢？</li>
</ol>
<p>日志生成的主要步骤：</p>
<ul>
<li><p>生成日志 </p>
</li>
<li><p>在缓冲区中占位（生成LSN） </p>
</li>
<li><p>刷盘</p>
<ul>
<li>注意，在日志刷盘阶段，需要一组一组提交，因为每条日志刷盘的I/O代价比较高。因此需要多个事务的日志一起按批次刷盘。这样会减少I/O次数</li>
<li><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/24.png" style="zoom:67%;"></li>
</ul>
</li>
</ul>
<ul>
<li>事务提交(可以理解为返回客户端，事务修改 对外部可见)</li>
</ul>
<h4 id="WAL实现"><a href="#WAL实现" class="headerlink" title="WAL实现"></a>WAL实现</h4><p>Redo引申出了WAL，即事务日志会在COMMIT或COMMIT之前写入持久化存储中，然后事务对数据本身的修改才能生效。因此就能够保证在系统故障时可以通过读取Redo日志来实现持久化操作(数据恢复)。<br>因此对于最终用户可以显示事务已经提交而暂时不用将所修改的数据写入持久化存储。由于数据在日志未写入持久化存储之前数据无法持久化，则需要更大的主存作为BUFFER空间，这就是为什么Redo的内存开销更大。</p>
<p>为了实现 WAL策略，我们需要在日志记录中添加一个字段——LSN。它代表了日志序列号，LSN是一个唯一的递增的数字，它有助于标志着操作的顺序(如果你看到一条LSN=20的日志记录，那么该操作一定是发生在LSN=10的记录之后的)。我们还将为每条日志记录添加一个<strong>prevLSN</strong>字段，该字段存储了同一事务的最后一次操作，这对撤销一个交易来说是很有用的。</p>
<p>数据库还将跟踪存储在RAM中的flushedLSN。flushedLSN追踪最后一条被刷入磁盘的日志记录的LSN，它意味着该页已经被写入磁盘，也意味着在内存中我们不再需要这个页了。</p>
<p>我们还将为<strong>每个数据页</strong>添加一段元数据，称为pageLSN。pageLSN 存储了最后修改该页的操作的LSN。我们将用它来告诉我们哪些操作的操作，以及哪些操作必须重做。</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/23.png" style="zoom:67%;"></p>
<h3 id="ARIES-Recovery-Algorithm"><a href="#ARIES-Recovery-Algorithm" class="headerlink" title="ARIES Recovery Algorithm"></a>ARIES Recovery Algorithm</h3><p>当数据库系统崩溃之后，我们只能获得数据库写到磁盘中去的数据页和日志。在重启之后，我们要对数据库进行恢复，达到两个目标：</p>
<ul>
<li>所有已经提交的事务，都要恢复到提交事务之后的状态(持久性)</li>
<li>所有未提交的事务，都要恢复到事务执行之前的状态(原子性)</li>
</ul>
<p>这个算法就是说在No Force和Steal的情况下，如何将数据库日志恢复到上面两个状态.这个算法主要分为三个阶段：</p>
<ol>
<li><p>Analysis Phase: 重新构建 transaction table 和 DPT</p>
</li>
<li><p>Redo Phase: 重复提交后却未写回的操作，以实现持久性</p>
</li>
<li>Undo Phase：撤销未提交但已写回的事务操作，以保证事务的持久性</li>
</ol>
<p>首先我们来说说 transaction table 和 DPT是什么：</p>
<h4 id="transaction-table"><a href="#transaction-table" class="headerlink" title="transaction table"></a>transaction table</h4><p>Transaction table 记录了活跃的事务的相关信息，它有三个字段。活跃事务表示用来做undo的，因为</p>
<ul>
<li>XID: 事务 ID</li>
<li>status: either running, committing, or aborting</li>
<li>lastLSN: the LSN of the most recent operation for this transaction</li>
</ul>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/25.jpg"></p>
<h4 id="Dirty-Page-Table-DPT"><a href="#Dirty-Page-Table-DPT" class="headerlink" title="Dirty Page Table (DPT)"></a>Dirty Page Table (DPT)</h4><p>DPT记录了那些页是脏页(被修改过后的), 它有两个字段。脏页表主要是用来做Redo的</p>
<ul>
<li><p>Page ID</p>
</li>
<li><p>recLSN: 第一个产生这个脏页的LSN</p>
</li>
</ul>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/26.jpg"></p>
<h4 id="Analyse-phase"><a href="#Analyse-phase" class="headerlink" title="Analyse phase"></a>Analyse phase</h4><p>Analyse phase 就是把系统crush的那一瞬间的两张表给重构出来。为了实现这个操作，我们需要扫描所有的日志记录。下面是遇到各种日志的处理方法</p>
<ul>
<li>任何只要不是END的记录，就说明该事务尚未结束，就需要将其加入到transaction Table中，同时设置LSN为当前记录的LSN</li>
<li>如果该记录是COMMIT或者是ABORT，那么就修改相应transaction在transaction Table中的记录(修改状态)</li>
<li>如果该记录是UPDATE，而且日志中对应的页不再DPT当中，说明发现了一个新的脏页。那么就要把这页加到DPT中并设置recLSN=该日志的LSN</li>
<li>如果该记录是END，那就从transaction表中删除该事务</li>
</ul>
<p>在Analyse phase的最后阶段，对于任何正在COMMIT的事务，他只是在等待提交罢了，对数据的修改、更新操作都已经做完了(相当于END)，因此我们需要把 END记录到日志中，并从transaction表中删除该事务。最终只会让ABORT或者RUNNING的事务留在transaction表中</p>
<p>如果我们按照上面的操作，老老实实得把数据库日志从头到尾扫描一遍，显然这样的性能很低，不切实际。因此我们可以用到checkpoint，它像一个快照一样，每隔一段时间会把transaction Table和DPT记录在日志中。</p>
<p>我们来举一个例子:</p>
<p>下面这张图是我们要恢复数据库时从磁盘中提出来的数据，左侧是日志，看到LSN50是Begin Checkpoint，说明在这一时刻开始形成一个快照，LSN50之前的transaction Table和DPT都会保存下来。检查点在LSN80处生成结束。</p>
<p>右侧就是从检查点提出的transaction Table和DPT，但是这两张表记录的信息是不全的，我们要从LSN60处开始复原重构两张表</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/27.png"></p>
<ol>
<li>首先，我们从LSN60开始构建，它记录了T3事务对P3页进行了update。因为P3已经在DPT中，因此不用改。但是它更新了transaction Table中的T3记录，需要将字段lastLSN改为当前LSN（即60)</li>
</ol>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/28.png"></p>
<ol>
<li>LSN70是 T3的 Aborts，因此修改 transaction Table中的T3记录，将Status改为Aborts即可</li>
</ol>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/29.png"></p>
<ol>
<li>LSN90是也是一条动作，就是把T3 Update P3给撤销了，因此需要更新transaction Table中的T3记录，将lastLSN改为90</li>
</ol>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/30.png"></p>
<ol>
<li>LSN100是T1事务对P4页做的Update操作，DPT中没有P1，因此需要把P4加入DPT；同时要更新transaction  Table的T1记录，将lastLSN更新为100</li>
</ol>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/31.png"></p>
<ol>
<li>LSN110是T1事务的提交，因此更新transaction Table T1记录，将Status改为 Committing</li>
</ol>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/32.png"></p>
<ol>
<li>LSN120是T1事务的结束，因此可以从transaction Table中删除T1记录</li>
</ol>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/33.png"></p>
<h4 id="Redo-phase"><a href="#Redo-phase" class="headerlink" title="Redo phase"></a>Redo phase</h4><p>Redo phase使用来保证持久化的，我们从DPT中最小的recLSN记录开始，因为那是时可能还没有进行第一个刷盘的操作。</p>
<p>我们将会redo所有的Update操作和CLR操作 ，如果某一个LSN符合下面三条中的一条，那么就跳过：</p>
<ul>
<li>该页不再DPT中，意味着所有对该页修改都已经持久化到磁盘了</li>
<li>如果 recLSN &gt; LSN， 因为正常情况下LSN是大于等于 recLSN的，如果recLSN &gt; LSN,说明污染该页的第一个动作要比当前的LSN发生的更晚，因次当前LSN并不需要被redo</li>
<li>pageLSN(disk) &gt;= LSN, 因为pageLSN记录了最后修改该页的操作日志，如果大于LSN的话，那说明并不需要redo当前的LSN</li>
</ul>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/34.png"></p>
<p>现在复原了两张表，transaction Table是要做Undo操作的，DPT是要做Redo的。</p>
<p>那么，应该从哪里开始恢复操作呢？DPT中最小的recLSN是 10，因此我们从LSN10开始看。</p>
<ul>
<li>LSN10 : 更新 P3</li>
<li>LSN20 ：P1.recLSN=40 &gt; 20, 跳过</li>
<li>LSN30: Page2不再DPT中，因此跳过</li>
<li>LSN40: P1.recLSN=40 = 40 , 执行update p1操作</li>
<li>LSN50: 跳过</li>
<li>LSN60：符合条件，更新P3</li>
<li>LSN70: 只redo Update操作和CLR操作</li>
<li>LSN80: 跳过</li>
<li>LSN90: 执行CLR操作</li>
<li>LSN100: P4.recLSN=100==LSN,因此执行更新P4操作</li>
<li>LSN110-LSN120: 跳过</li>
</ul>
<h4 id="Undo-phase"><a href="#Undo-phase" class="headerlink" title="Undo phase"></a>Undo phase</h4><p>Undo 阶段和Redo阶段的起始位置不同 ，Undo是从Transaction Table中各个事务的LastLSN往前回滚。</p>
<p>我们要做的是把transaction Table中没有完成的事务给回滚掉。其具体操作就是：撤销所有在transaction Table中所有事务的Update操作。使数据其从中间态恢复到事务执行前的状态</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/34.png"></p>
<p>还是以上图为例，我们看到transaction Table中有T2和T3是需要回滚的。对于每个需要回滚的事务，直接从lastLSN开始。</p>
<ul>
<li>对于T2，我们可以直接从LSN30开始回滚</li>
<li>对于T3，我们可以从LSN90 开始回滚</li>
</ul>
<p>注意，回滚也会记录日志：</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/35.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/45.png"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/" itemprop="url">Flink学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-05-10T19:44:56+08:00">
                2022-05-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-06-19T11:02:40+08:00">
                2022-06-19
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Flink学习"><a href="#Flink学习" class="headerlink" title="Flink学习"></a>Flink学习</h1><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p> 大数据运算主要有2个领域：1：流式计算 2：批量计算。在数据操作层面可以看做如下的两类</p>
<p>有限数据集：数据大小有限（固定大小，比如固定的文件），用于批处理。比如说MapReduce，Spark</p>
<p>无限数据集：数据持续增长（属于无限大小，比如kafka中的日志数据，总是有新数据进入，并且不知道什么时候结束或者是永远不结束），用于流式处理。 </p>
<p>我们要学习的Flink就是一个面向流处理和批处理的分布式计算框架，既支持流处理，也支持批处理.</p>
<p>现在我们来看看三种计算框架的区别：</p>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/1.png"></p>
<p>下图是Flink的技术栈，我们看到最上面一层是工具库，中间层是输入数据的类型(有流数据和固定数据)，第三层是Stream Dataflow Engine,是Flink的核心部分。最下面一层是Flink的底层依赖</p>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/1.jpeg"></p>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>与Storm类似，Flink将输入数据看作是一 个不间断的、无界的连续记录序列  </p>
<p>有所不同的是，Flink将这一系列的记录抽象成DataStream 类似于RDD，DataStream是不可变的</p>
<p>这里的不可变，指的是unmutable, 即我们对DataSteam进行修改的话，会返回一个新的Stream，原来的Stream不会发生变化</p>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/2.png"></p>
<p>现在对之前学过的几个计算框架中的数据模型做一个总结：</p>
<ul>
<li>MapReduce: Key-value Pair</li>
<li>Spark: RDD, 实际上就是键值对的集合</li>
<li>Storm: Tuple</li>
<li>Flink: DataStream 实际上是Tuple的集合</li>
</ul>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/3.png"></p>
<h3 id="计算模型"><a href="#计算模型" class="headerlink" title="计算模型"></a>计算模型</h3><p>Flink和Spark有点像，也是一系列的变换操作构成一张有向无环图， 即描述计算过程的DAG</p>
<p>Flink算子也分为3类：</p>
<ul>
<li>数据源（DataSource） </li>
<li>转换（Transformation） </li>
<li>数据池（DataSink）</li>
</ul>
<h4 id="DataSource"><a href="#DataSource" class="headerlink" title="DataSource"></a>DataSource</h4><div class="table-container">
<table>
<thead>
<tr>
<th>操作算子</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>fromElements(elements)</td>
<td>从相同类型的记录创建DataStream</td>
</tr>
<tr>
<td>fromCollection(collection)</td>
<td>从内存集合创建DataStream</td>
</tr>
<tr>
<td>readTextFile(path)</td>
<td>逐行读取文件内容来创建DataStream</td>
</tr>
<tr>
<td>socketTextSteam(hostname,port)</td>
<td>接收来自套接字的内容来创建DataStream</td>
</tr>
<tr>
<td>addSource(customer-source-func)</td>
<td>使用户自定义source func来创建DataStream</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h4><div class="table-container">
<table>
<thead>
<tr>
<th>操作算子</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>map</strong></td>
<td>将DataSet中的每一个元素转换为另外一个元素，返回一个新的DataStream</td>
</tr>
<tr>
<td><strong>flatMap</strong></td>
<td>与map类似，但是对DataStream中的每个记录都可以映射成0个或者多个新的记录</td>
</tr>
<tr>
<td><strong>union</strong>(otherDataStream)</td>
<td>若干个数据类型相同的DataStream，取其并集得到一个新的DataStream</td>
</tr>
<tr>
<td><strong>connect</strong>(otherDataStream)</td>
<td>两个数据类型可能不同的DataStream，取并集得到一个新的DataStream</td>
</tr>
<tr>
<td><strong>keyBy</strong>(key)</td>
<td>以给定的key划分DataStream来创建KeyedStream(类似于Spark中的PairRDD)</td>
</tr>
<tr>
<td><strong>window</strong>(WubdiwAssigner)</td>
<td>对KeyedStream中按键按分组的记录根据WindowAssigner将其划分为多个窗口，返回一个WindowedStream</td>
</tr>
<tr>
<td><strong>reduce</strong>(func)</td>
<td>通过func简化DataStream中的记录，返回一个新的DataStream</td>
</tr>
<tr>
<td><strong>aggregate</strong>(func)</td>
<td>对DataStream中每个窗口中记录使用func聚合为结果记录，返回一个新DataStream</td>
</tr>
<tr>
<td><strong>join</strong>(otherDataStream)</td>
<td>[K,V1]和[K,V2] 分别属于两个DataStream.返回一个[K,(V1,V2)]组成的JoinedStream</td>
</tr>
</tbody>
</table>
</div>
<h4 id="DataSink"><a href="#DataSink" class="headerlink" title="DataSink"></a>DataSink</h4><div class="table-container">
<table>
<thead>
<tr>
<th>操作算子</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>print()</td>
<td>将DataStream写入标准输出</td>
</tr>
<tr>
<td>writeAsText(path)</td>
<td>将DataStream以文本格式写入指定的文件中</td>
</tr>
<tr>
<td>writeToSocket(hostname,port, schema)</td>
<td>将DataStream作为字节数组写入套接字，输出格式由schema指定</td>
</tr>
<tr>
<td>addSink(customer-sink-func)</td>
<td>使用用户自定义sinkfunc作为数据池操作</td>
</tr>
</tbody>
</table>
</div>
<h3 id="逻辑计算模型"><a href="#逻辑计算模型" class="headerlink" title="逻辑计算模型"></a>逻辑计算模型</h3><p>通常来说，Flink系统的一个应用对应一个DAG，而Spark中的一个应用包含一个或者多个DAG</p>
<p>比如说下面这个Wordcount例子：我们假定socketTextStream和print的并行度为1，其余并行度为2</p>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/5.png"></p>
<p>在Spark中，有两种逻辑计算模型：OperatorDAG和RDD Lineage。但是Flink只有DAG没有Datasteam Lineage</p>
<h3 id="迭代模型"><a href="#迭代模型" class="headerlink" title="迭代模型"></a>迭代模型</h3><p>由于Flink和Spark相比，除了数据模型从固定的变成流动的之外，最重要的就是增加了迭代算子。因此我们要着重来介绍这个新的算子，其他部分和spark是差不多的</p>
<p>Flink中的迭代过程内部必定存在环路，和Spark不一样，Spark中的迭代需要我们自己设计算法，但在Flink中我们将迭代部分整体视为一个算子，计算的过程仍然是DAG, 如下：</p>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/7.png"></p>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/6.png"></p>
<p>我们发现，Flink中系统提供了迭代算子，内置了一些优化，不需要我们手写for 和 while循环，因此性能更高。但是同样的，这种方法把整个系统变得更复杂了，丧失了一些编程的灵活性</p>
<p>还有一个问题，Spark、Flink这种计算框架中是否存在 If 算子或者 类似于Switch的算子？其实我们是需要这种算子的，因为if和switch这类的控制类的算子在逻辑中还是比较有用的。但是使用条件语句会让我们的DAG变得复杂，因为本来的DAG是静态的，数据朝着一个方向流动，一旦加了条件和控制之后，DAG会不断发生变化，这是不利于分布式系统的</p>
<p>所以我们把大数据处理系统也称为 Dataflow system, 而之前我们写的Java、C++都是Controlflow,这两者和计算机体系结构有关：</p>
<p>我们可以通过下面这个示意图来知悉两者关系：Controlflow 是指令和数据同时存储的，而Dataflow编程模型是算子级别的，把controlflow中的指令替换成算子</p>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/8.png"></p>
<h2 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h2><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p>Flink的架构和Spark非常类似，也是分为一个主节点和若干从节点。</p>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/9.png"></p>
<h4 id="Standalone-模式架构图"><a href="#Standalone-模式架构图" class="headerlink" title="Standalone 模式架构图"></a>Standalone 模式架构图</h4><p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/10.png"></p>
<p>我们来逐步看一下每个部件的作用</p>
<ul>
<li>Client: 讲用户编写的DataStream 程序翻译为逻辑执行图病进行优化，并将优化后的逻辑执行图提交到JobManager。<ul>
<li>在Standalone模式下，Client的进程名为 CliFrontend</li>
</ul>
</li>
<li>JobManager: 根据逻辑执行图产生<strong>物理执行图</strong>，负责协调系统的作业执行，包括任务调度，协调检查点和故障恢复等。<ul>
<li>在Standalone模式下，JobManager还负责Flink系统的资源管理</li>
<li>JobManager的进程名为 StandaloneSessionClusterEntryPoint</li>
</ul>
</li>
<li>TaskManager: 用来执行JobManager分配的任务，并且负责读取数据、缓存数据以及其他TaskManager进行数据传输<ul>
<li>在Standalone模式下，TaskManager还负责所在节点的<strong>资源管理</strong>，将内存等资源抽象成若干个TaskSlot用于任务的执行</li>
<li>TaskManager 的进程名为 TaskManagerRunner</li>
</ul>
</li>
</ul>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/11.png"></p>
<h4 id="Yarn模式架构"><a href="#Yarn模式架构" class="headerlink" title="Yarn模式架构"></a>Yarn模式架构</h4><p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/12.png"></p>
<p>横向比较一下，从Yarn的角度来说就是让资源管理和作业管理分离</p>
<ul>
<li>Standalone模式中的JobManager、TaskManager对应变成了Resource Manager和NodeManager</li>
</ul>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/13.png"></p>
<h3 id="应用程序执行流程"><a href="#应用程序执行流程" class="headerlink" title="应用程序执行流程"></a>应用程序执行流程</h3><h4 id="Standalone模式"><a href="#Standalone模式" class="headerlink" title="Standalone模式"></a>Standalone模式</h4><p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/14.png"></p>
<ol>
<li>客户端将用户编写的程序进行解析，并将 解析  后的作业描述交给StandaloneSessionClusterEntrypoint </li>
<li>StandaloneSessionClusterEntrypoint根据 作业的描述进行任务分解，确定各个TaskManagerRunner所负责执行的任务 </li>
<li>TaskManagerRunner执行所负责的任务</li>
</ol>
<h5 id="提交方式"><a href="#提交方式" class="headerlink" title="提交方式"></a>提交方式</h5><p>在Standalone模式下，当用户使用客户端 提交Flink应用程序时，可以选择Attached 方式或者Detached方式</p>
<ul>
<li>Attached提交方式：客户端与JobManager保持连接，可以获取关于应用程序执行的信息</li>
<li>Detached提交方式：客户端与JobManager断开连接，无法获得关于应用程序执行的信息</li>
</ul>
<p>这两种提交方式和Spark中的两种提交方式有点像。Attached和Client 比较类似，Detached和Cluster比较类似。</p>
<p>但是他们又有一些区别：</p>
<p>在spark 中，以cluster模式提交，其客户端还是存在的运行，只不过Driver从本地客户端跑到了远端集群当中；但是在Flink中用Detached方式提交，则是没有客户端了，没有办法获取应用程序的打印信息</p>
<h3 id="Yarn-模式"><a href="#Yarn-模式" class="headerlink" title="Yarn 模式"></a>Yarn 模式</h3><p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/15.png">我们看到Yarn的执行模式比Standalone要复杂得多，而且必须要用到HDFS</p>
<ol>
<li><p>客户端启动<code>CliFrontend</code>进程，<code>CliFrontend</code>将用户编写的程序进行解 析，并将运行Flink系统的jar包以及配置文件上传至HDFS</p>
</li>
<li><p><code>CliFrontend</code>向<code>ResourceManager</code>申请启动 <code>YarnJobClusterEntrypoint (ApplicationMaster)</code>，<code>ResourceManager</code>确定启动<code>YarnJobClusterEntrypoint</code>的节点 </p>
</li>
<li>需启动<code>YarnJobClusterEntrypoint</code>进程的节点上的<code>NodeManager</code>将 HDFS中的jar包与配置文件下载到该节点 </li>
<li><code>NodeManager</code>启动<code>YarnJobClusterEntrypoint</code>进程 </li>
<li><code>CliFrontend</code>进程将解析后的作业描述交给<code>YarnJobClusterEntrypoint</code></li>
<li><code>YarnJobClusterEntrypoint</code>向<code>ResourceManager</code>注册，这样客户端可 以通过 <code>ResourceManager</code>查看Flink应用程序的资源使用情况。 <code>YarnJobClusterEntrypoint</code>根据作业的描述进行任务分解，并向 <code>ResourceManager</code>申请启动这些任务的资源</li>
<li><code>ResourceManager</code>以Container形式向提出申请的 <code>YarnJobClusterEntrypoint</code>分配资源。得到资源后，它在多个任务间 进行资源分配 </li>
<li><code>YarnJobClusterEntrypoint</code>确定资源分配方案后，便与对应的 <code>NodeManager</code>通信</li>
<li>如果该<code>NodeManager</code>所在节点尚未下载，则将HDFS中的jar包与配 置文件下载到本地，并在相应的Container中启动相应的 <code>YarnTaskExecutorRunner</code>进程用于执行任务 </li>
<li>各个任务向<code>YarnJobClusterEntrypoint</code>汇报自己的状态和进度，以便让 <code>YarnJobClusterEntrypoint</code>随时掌握各个任务的运行状态 </li>
<li>随着部分任务执行结束，<code>YarnJobClusterEntrypoint</code>逐步释放所占用 的资源，最终向<code>ResourceManager</code>注销并关闭自己</li>
</ol>
<h5 id="提交方式-1"><a href="#提交方式-1" class="headerlink" title="提交方式"></a>提交方式</h5><ul>
<li>Attached提交方式：<code>CliFrontend</code>将与 <code>YarnJobClusterEntrypoint</code>保持连接，可以获取 关于应用程序执行的信息 </li>
<li>Detached提交方式：<code>CliFrontend</code>将与 <code>YarnJobClusterEntrypoint</code>断开连接，无法获得 关于应用程序执行的信息</li>
</ul>
<p>我们之前说过，Yarn是应用作为粒度来管理的，Spark中的Application和MapReduce中的Job对应一个Yarn中的应用。在Flink当中，既可以以一个任务作为Yarn的一个应用，又可以拿整一个Application作为Yarn的一个应用</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>现在我们来介绍Flink框架的内部工作原理，这其实和Sql的执行过程类似</p>
<ul>
<li>首先生成逻辑执行计划，然后进行逻辑优化</li>
<li>接着生成物理执行计划，并执行</li>
</ul>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/16.png"></p>
<h3 id="逻辑执行图的生成与优化"><a href="#逻辑执行图的生成与优化" class="headerlink" title="逻辑执行图的生成与优化"></a>逻辑执行图的生成与优化</h3><p>首先什么是逻辑执行图？ 给定用户编写的DataStream程序，Flink的 Client将其解析产生逻辑执行图，即DAG.</p>
<p>那么逻辑执行图怎么优化？ 有一种Chaining优化的方法：将”窄依赖“算子合并起来形成一个大的算子。如下图所示，我们将flatMap、map合并成一个 flatMap-map算子, 然后将keyBy、window、sum合并成一个keyed-window-sumAgg算子。</p>
<p>不能合并的情况：</p>
<ul>
<li>因为 map到keyBy之间是宽依赖，有交叉的，因此不能合并。</li>
<li>并行度不同，不能合并</li>
</ul>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/17.png"></p>
<p>事实上，Flink的Chaining优化方法，很类似于Spark中的Pipeline，二者效果相同，只是名字有所不同</p>
<h3 id="物理执行图的生成与任务分配"><a href="#物理执行图的生成与任务分配" class="headerlink" title="物理执行图的生成与任务分配"></a>物理执行图的生成与任务分配</h3><p>JobManager收到Client提交的逻辑执行图 之后，<strong>根据算子的并行度</strong>，将逻辑执行图 转换为物理执行图 </p>
<p>物理执行图中的一个结点对应一个任务， 将分配给TaskManager来执行</p>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/19.png"></p>
<h5 id="任务分配"><a href="#任务分配" class="headerlink" title="任务分配"></a>任务分配</h5><p>JobManager将各算子的任务分配给 TaskManager </p>
<p>根据任务槽(TaskSlot)的容量，尽可能将存在数据传输关系的算子实例放在同一个任务槽， 保持数据传输的本地性。 和上图对照，发现上面4个算子放在一个TaskManager中，说明这一个流水线中的数据都是在内存中传递的。而对于下面一行，从<code>socketTextStream</code>到<code>flatMap-map</code>以及从<code>keyedwindow-sumAgg</code>到<code>print</code>的数据传输是在节点之间进行的</p>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/19.jpg"></p>
<p>从逻辑执行图到物理执行图的整个过程如下图所示:</p>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/18.jpg"></p>
<h3 id="非迭代任务间的数据传输"><a href="#非迭代任务间的数据传输" class="headerlink" title="非迭代任务间的数据传输"></a>非迭代任务间的数据传输</h3><p>Flink在不同Task之间的数据传输方式是：流水线机制。也就是说：上游的Task将数据存放在 buffer 中，一旦Buffer满了或者超时，就像下游Task发送</p>
<p>Flink并不是生成一个item传递一次，也不是像MapReduce、Spark一样，把所有item全部处理完成后下游任务才能继续运行(因此MR和Spark无法处理流数据)。</p>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/20.png"></p>
<p>注意，Spark中的pipline和Flink中的pipeline是不同的概念</p>
<ul>
<li>在Flink中，pipline表示在不同Task之间的数据传输方式，区别于MR和Spark中的Shuffle</li>
<li>在Spark中，pipline指内部<strong>同一个Task实现多个不同算子之间</strong>的数据传输方式，粒度更细<ul>
<li>Spark Pipline和Flink Chaining类似</li>
</ul>
</li>
</ul>
<h4 id="Task间数据传输方式"><a href="#Task间数据传输方式" class="headerlink" title="Task间数据传输方式"></a>Task间数据传输方式</h4><ul>
<li><p><strong>阻塞式数据传输：</strong> 一个Task（运行某个或某些算子）将所有需要处理的数据计算完，甚至要将结果写入磁盘， 才会发送给位于下游Task或被其读取  。 比如说MapReduce、Spark</p>
</li>
<li><p><strong>非阻塞式数据传输：</strong> 云计算天然需要非阻塞式数据传输这种特性。一个Task处理一条或一部分数据，通常将计算结果放在缓存里，就会发送给位于下游Task或被其读取。比如说Storm、Flink</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>系统</th>
<th>数据传输方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>MapReduce</td>
<td>阻塞式数据传输</td>
</tr>
<tr>
<td>Spark</td>
<td>阻塞式数据传输</td>
</tr>
<tr>
<td>Storm</td>
<td>非阻塞式数据传输</td>
</tr>
<tr>
<td>Flink</td>
<td>非阻塞式数据传播</td>
</tr>
</tbody>
</table>
</div>
<h3 id="迭代任务内部的数据传输"><a href="#迭代任务内部的数据传输" class="headerlink" title="迭代任务内部的数据传输"></a>迭代任务内部的数据传输</h3><h4 id="迭代的实现"><a href="#迭代的实现" class="headerlink" title="迭代的实现"></a>迭代的实现</h4><p>迭代算子是Flink 特有的，它是嵌套在DAG中的一个整体。迭代算子<strong>内部存在数据反馈的环路</strong>。</p>
<p>那么数据反馈如何实现？</p>
<ul>
<li>在同一个TaskManager当中会成对出现迭代前端(Iteration Source)和迭代末端(Iteration Sink) 两类特殊的任务。迭代末端任务的输出可以再次作为迭代前端任务的输入。</li>
</ul>
<h4 id="流式迭代"><a href="#流式迭代" class="headerlink" title="流式迭代"></a>流式迭代</h4><p>在流式迭代计算中，通常每一轮迭代计算的部分结果作为输出向后传递，而另一部分结果作为下一轮迭代计算的输入，并且迭代过程会一直进行下去。</p>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/21.png"></p>
<p>流式迭代计算中，迭代前端下一轮的计算并不依赖与迭代末端前一轮迭代得到的所有记录。同时，迭代前端收到迭代末端的反馈后，可以立即进行新一轮迭代计算。</p>
<p>因此，这种方式仍然是采用流水线方式进行数据传输。</p>
<h4 id="批式迭代"><a href="#批式迭代" class="headerlink" title="批式迭代"></a>批式迭代</h4><p>在批式迭代计算中，每一轮迭代计算的<strong>全部结果</strong>通常都是下一轮迭代计算的输入， 直到迭代过程在满足<strong>收敛条件</strong>时停止迭代。比如梯度下降，k均值.</p>
<p>迭代前端中发出特殊的控制事件（control event），即特殊的记录(如达到某一条件)，表示迭代计算的结束</p>
<p>在批式迭代计算中，迭代前端必须收到迭代 末端反馈的所有记录后才可以开始新一轮迭代计算。因此这时一种阻塞的过程，<strong>无法采用流水线机制</strong>进行数据传输</p>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/22.png"></p>
<h2 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h2><p>在容错机制中，我们主要需要解决当TaskManager故障了，怎么办？</p>
<ul>
<li>运行了非迭代算子的容错</li>
<li>运行了迭代算子的容错</li>
</ul>
<h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><p>首先，我们要了解什么是状态？</p>
<p>在输出数据是无界的场景中，数据会源源不断地流入Flink系统。</p>
<p>例如，在某一窗口中统计单词的个数: </p>
<ul>
<li>窗口需要将原始的单词记录保存起来，直到窗口触发时，一并进行统计</li>
<li>或者将单词以及当前观察到的个数保存起来，并逐步累加</li>
<li>窗口这个算子所需维护的内容，就是状态</li>
</ul>
<p>注意，我们要区分算子的状态与进程/节点的状态，前者类似于完成作业的一个进度</p>
<h4 id="为什么需要系统管理状态"><a href="#为什么需要系统管理状态" class="headerlink" title="为什么需要系统管理状态"></a>为什么需要系统管理状态</h4><p>假设我们使用用户程序来管理状态，那么</p>
<ul>
<li>用户需要编写一个HashMap来记录计数保存状态，那么一旦该算子所在的task发生了故障，内存中的HashMap就丢失了。</li>
<li><p>因此为了支持容错，需要编写程序将HashMap写入磁盘等可靠的存储设备，故障恢复后再读取。这样一来，不同数据结构都需要编写相应的保存、读取代码</p>
<p>因此，状态管理对用户应该是透明的，交给系统来做。</p>
</li>
</ul>
<h4 id="状态定义"><a href="#状态定义" class="headerlink" title="状态定义"></a>状态定义</h4><p>状态是系统定义的特殊的数据结构，用于记录需要保存的算子计算结果</p>
<ul>
<li><code>ValueState&lt;T&gt;</code>: 状态保存的是每个Key的一个值，可以通过<code>update(T)</code>来更新，<code>T.value()</code>获取</li>
<li><code>ListState&lt;T&gt;</code>: 状态保存的是每个key的一个列表，通过<code>add(T)</code>添加数据，<code>Iterable.get()</code>获取</li>
<li><code>ReaducingState&lt;T&gt;</code>: 状态保存的是关于每个key经过聚合之后的值列表，通过<code>add(T)</code>添加数据，通过指定的聚合方法来获取</li>
</ul>
<h4 id="有状态算子-无状态算子"><a href="#有状态算子-无状态算子" class="headerlink" title="有状态算子/无状态算子"></a>有状态算子/无状态算子</h4><ul>
<li>有状态算子：具备记忆能力的算子<ul>
<li>可以保留已经处理记录的结果，并对后续记录的处理造成影响</li>
<li>例如：Window，Sum</li>
</ul>
</li>
<li>无状态算子：不具备记忆能力的算子<ul>
<li>只考虑到当前处理的记录，不会受到已处理记录的影响，也不会影响到后续待处理的记录</li>
<li>例如: Map</li>
</ul>
</li>
</ul>
<h4 id="状态管理与容错"><a href="#状态管理与容错" class="headerlink" title="状态管理与容错"></a>状态管理与容错</h4><ul>
<li>算子级别的容错<ul>
<li>运行时保存其状态，在发生故障时重置状态，并继续处理尚未保存到状态中的记录</li>
</ul>
</li>
<li>DAG级别的容错<ul>
<li>既然一个算子可以保存其状态，那么我们是不是可以对DAG中所有的算子都进行这个操作？</li>
<li>这就是DAG级别的容错，我们可以在<strong>同一时刻</strong>将所有算子的状态保存起来形成检查点，一旦出现故障，则所有算子都根据检查点来重置状态，并处理尚未保存到检查点中的记录。</li>
<li>难点是：DAG可能在分布式系统下运行，要做到<strong>同一时刻</strong>，必须要求所有节点的物理时钟<strong>绝对同步</strong>。但这是不可能的。那么怎么办？我们可以分两种情况来讨论</li>
</ul>
</li>
</ul>
<h3 id="非迭代计算过程的容错"><a href="#非迭代计算过程的容错" class="headerlink" title="非迭代计算过程的容错"></a>非迭代计算过程的容错</h3><h4 id="系统中的记录"><a href="#系统中的记录" class="headerlink" title="系统中的记录"></a>系统中的记录</h4><p>上面我们说的DAG容错，虽然无法实现，但其Idea就是将Flink中的不同种类的记录区分开来：</p>
<p>在某一时刻，流计算系统所处理的记录，可以分为三种类型</p>
<ul>
<li>已经处理完毕的记录，即所有算子都已经处理了这些记录</li>
<li>正在处理的记录，即部分算子处理了这些记录</li>
<li>尚未处理的记录，即没有算子处理过这些记录</li>
</ul>
<p>因此，虽然绝对同步的时钟是不存在的，但是同一时刻保存所有算子状态到检查点的目的是<strong>区分第一种记录和后两种记录</strong></p>
<h4 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h4><p>JobManager在输入记录中插入屏障，这些屏障与记录一起向下游的计算任务流动。我们可以将其理解为标记，将数据流进行一个分割。一个任务，需要收到来自上有任务中所有标识为n的屏障之后，才能将其状态保存起来，这被称为<strong>屏障对齐</strong>。每个检查点的保留结果相互独立，都保留了一份计算结果。</p>
<p>某一人任务将标识为n的屏障对齐之后，可以继续接收属于 检查点 n+1 的数据</p>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/23.png">如上图：</p>
<ol>
<li>最右侧两个黄色的记录，就是已经处理完毕的记录</li>
<li>中间虚框框起来的记录则是正在处理的记录</li>
<li>最右侧是尚未处理的记录</li>
</ol>
<h4 id="异步屏障快照"><a href="#异步屏障快照" class="headerlink" title="异步屏障快照"></a>异步屏障快照</h4><p>异步屏障快照算法是由Chandy-Lamport算法(分布式系统中用于保存系统状态)扩展而来的 :</p>
<ul>
<li>所保存的快照就是检查点</li>
<li>通过在输入数据中注入屏障，并异步地保存快照，达到和在同一时刻保存所有算子状态到检查点相同的目的</li>
</ul>
<h4 id="Flink状态存储"><a href="#Flink状态存储" class="headerlink" title="Flink状态存储"></a>Flink状态存储</h4><div class="table-container">
<table>
<thead>
<tr>
<th>状态存储方式</th>
<th>正常运行时</th>
<th>写检查点时</th>
</tr>
</thead>
<tbody>
<tr>
<td>MemoryStateBackend</td>
<td>本地内存</td>
<td>JobManager内存</td>
</tr>
<tr>
<td>FsStateBackend</td>
<td>本地内存</td>
<td>HDFS</td>
</tr>
<tr>
<td>RocksDBStateBackend</td>
<td>本地RocksDB</td>
<td>HDFS</td>
</tr>
</tbody>
</table>
</div>
<h4 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h4><p>当发生故障时，Flink选择最近完整的检查点n，将系统中每个算子的状态重置为检查点中保存的状态。</p>
<p>从数据源重新读取属于屏障n之后的记录</p>
<ul>
<li>这要求数据源具备一定的记忆功能</li>
<li>例如，Flink从Kafka中重新读取屏障n对应偏移量之后的记录</li>
</ul>
<p>Flink的容错机制能够满足<strong>准确一次</strong>的容错语义</p>
<h3 id="迭代计算过程的容错"><a href="#迭代计算过程的容错" class="headerlink" title="迭代计算过程的容错"></a>迭代计算过程的容错</h3><h2 id="编程实例"><a href="#编程实例" class="headerlink" title="编程实例"></a>编程实例</h2>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/05/09/Yarn%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/05/09/Yarn%E5%AD%A6%E4%B9%A0/" itemprop="url">Yarn学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-05-09T16:20:58+08:00">
                2022-05-09
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-05-16T22:46:20+08:00">
                2022-05-16
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Yarn学习"><a href="#Yarn学习" class="headerlink" title="Yarn学习"></a>Yarn学习</h1><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><h3 id="作业与资源管理"><a href="#作业与资源管理" class="headerlink" title="作业与资源管理"></a>作业与资源管理</h3><p>在学习Yarn之前，我们先学习一下作业管理和资源管理。</p>
<p>在MapReduce中，有一个部件是 JobTracker，它负责作业管理和资源管理</p>
<ul>
<li>作业管理：状态监控、信息汇总、任务调度</li>
<li>资源管理：管理主从节点</li>
</ul>
<p>但是，资源管理和计算框架不能结合得这样紧密(因此这也是MapReduce的一个弊端之一)，资源管理应该是由操作系统来分配的，是通用的</p>
<p>而且，MapReduce的作业管理也有缺陷：JobTracker需要维护所有作业的元信息，内存开销大。那么，当同一时刻执行的作业数量增加时， JobTracker与执行这些作业中的任务以及 TaskTracker之间的通信频率增大，造成 JobTracker进程的不稳定。</p>
<p>基于此，我们提出了HADOOP 2.0，其结构如下：也就是将资源管理单独剥离出来，交给Yarn去管理。有了Yarn以后，MapReduce就只需要负责数据处理就好了，而且还可以在此基础上运行Spark、Flink，以实现资源的共享</p>
<p>因此，Yarn从某个角度上来说可以看做是一个操作系统，MapReduce、Spark可以看做是在这个操作系统上的软件。</p>
<p><img src="/2022/05/09/Yarn%E5%AD%A6%E4%B9%A0/1.png" style="zoom:67%;"></p>
<h3 id="平台与框架"><a href="#平台与框架" class="headerlink" title="平台与框架"></a>平台与框架</h3><p>我们要理清楚平台和框架的区别：</p>
<ul>
<li>平台：具有提供资源功能的系统，如 Yarn,K8s, Mesos</li>
<li>框架：运行在平台上的系统，如Spark, Flink, MapReduce</li>
</ul>
<p>在Yarn这个平台中，管理的粒度是<strong>应用</strong>。</p>
<ul>
<li>这个应用不一定是是框架中的应用</li>
<li>运行在Yarn这个平台上的框架，可以将应用或者作业映射为Yarn的应用。</li>
</ul>
<p>比如, 在Spark中，一个application 映射成 Yarn中的一个应用。但在MapReduce中，是以Job为单位的，因此一个Job作为Yarn中的一个应用。</p>
<h2 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h2><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p><img src="/2022/05/09/Yarn%E5%AD%A6%E4%B9%A0/2.png" style="zoom:67%;"></p>
<p>Yarn的架构和MapReduce差不多，也是分为主从节点，不过名字换了一下，变成了 Resource Manager和Node Manager。</p>
<p>我们看到上图中有两组不同颜色的工作进程和Application Master。说明此时在Yarn中有两个应用正在工作。</p>
<h4 id="ResourceManager"><a href="#ResourceManager" class="headerlink" title="ResourceManager"></a>ResourceManager</h4><p>资源管理器：负责整个系统的资源管理和分配 (全局)。</p>
<p>它分为两部分：</p>
<ul>
<li>资源调度器(Resource Scheduler)：分配 Container并进行资源调度 </li>
<li>应用程序管理器(Application Manager)：管理整个系统中运行的所有应用 <ul>
<li>应用程序提交 </li>
<li>与调度器协商资源以启动ApplicationMaster </li>
<li>监控Application Master运行状态</li>
</ul>
</li>
</ul>
<p>注意：Application Manager<strong>并不管理 </strong>Application内部的资源如何分配、如何协调。有点像班长，只管小组长是否还工作。关于每个小组如何分工，他不负责</p>
<h4 id="NodeManager"><a href="#NodeManager" class="headerlink" title="NodeManager"></a>NodeManager</h4><p>节点管理器：负责每个节点资源和任务管理 </p>
<ul>
<li>定时地向ResourceManager汇报本节点的资源使用情况和 Container运行状态 </li>
<li>接受并处理来自Application Master的Container启动/停止等各 种请求</li>
</ul>
<h4 id="Application-Master"><a href="#Application-Master" class="headerlink" title="Application Master"></a>Application Master</h4><p>当用户基于Yarn平台提交一个框架应用， Yarn均启动一个 AM用于管理该应用</p>
<ul>
<li>AM与RM调度器协商以获取资源（以Container 表示），将获取的资源进一步分配给应用内部的任务 </li>
<li>AM与NM通信以启动/停止任务，监控所有任务运行状态， 并在任务发生故障时重新申请资源来重启任务</li>
</ul>
<h4 id="container"><a href="#container" class="headerlink" title="container"></a>container</h4><p>我们可能已经注意到，前面的AM以及工作进程，进程都被虚线框了起来。这些虚线就是Container</p>
<ul>
<li>Container是资源的抽象表示，包含CPU、 内存等资源，是一个动态资源划分单位</li>
<li>当AM向RM申请资源时，RM向AM返回以 Container表示的资源</li>
</ul>
<h3 id="YARN和Mapreduce1-0的对比"><a href="#YARN和Mapreduce1-0的对比" class="headerlink" title="YARN和Mapreduce1.0的对比"></a>YARN和Mapreduce1.0的对比</h3><ul>
<li>MapReduce 1.0既是计算系统，需要负责作业 管理，也是资源管理系统</li>
<li>Yarn是独立出来的资源管理系统，而 MapReduce 2.0作为计算系统负责作业管理</li>
</ul>
<p><img src="/2022/05/09/Yarn%E5%AD%A6%E4%B9%A0/3.png" style="zoom:67%;"></p>
<p>Container对应Task并不是特别准确，因为Task是一个进程，Container是容器。因此用child和YarnChild对应更加准确。</p>
<h3 id="执行流程图"><a href="#执行流程图" class="headerlink" title="执行流程图"></a>执行流程图</h3><p><img src="/2022/05/09/Yarn%E5%AD%A6%E4%B9%A0/4.png" style="zoom:67%;"></p>
<p>当用户向Yarn中提交应用程序之后，Yarn先启动Application Master，再由AM根据应用程序进行任务划分，并为个任务申请资源，同时监控整个运行过程</p>
<ol>
<li>用户编写客户端应用程序，想Yarn提交应用程序</li>
<li>ResourceManager负责接收和处理来自客户端的请求，尝试为该应用程序分配第一个Container，若分配成功则在这个Container中启动应用程序的Application Master</li>
<li>Application Master想Resource Manager注册，这样客户端可以通过ResourceManager查看应用的资源使用情况。ApplicationMaster将应用解析为作业并进一步分解为若干任务，并向Resource Manager申请启动这些任务的资源。</li>
<li>RM想提出的AM分配Container形式表示的资源。一旦AM申请到资源后，在多个任务之间进行分配</li>
<li>AM确定资源分配方案后，便于对应的NodeManager通信，在相应的Container中启动相应的工作进程用于执行任务</li>
<li>各个任务向AM汇报自己的状态和进度，以便让AM随时掌握各个任务的运行状态</li>
<li>随着任务执行结束，AM逐步释放所占用的资源，最终向RM注销并关闭自己</li>
</ol>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><h3 id="单平台多框架"><a href="#单平台多框架" class="headerlink" title="单平台多框架"></a>单平台多框架</h3><p>Yarn 其实就是一个资源管理的平台，其上可以运行多个框架，并为多个应用进行资源的分配。比如说，在Yarn上可以运行MapReduce、Spark、Flink等应用，而且能实现动态共享物力资源。对于Yarn阿狸说，它值负责想框架提供Container，而不关心在Container中运行何种任务。</p>
<p>如下图，Yarn中部署了MR和Spark两个计算框架，并且提交了两个MapReduce应用和一个Spark应用。由此看出，每当提交了一个应用，Yarn都会启动一个对应的AM(即使是同一类型的应用)。这就说明Yarn是按照应用粒度来划分的，每个应用之间相互独立地控制执行的目的。</p>
<p><img src="/2022/05/09/Yarn%E5%AD%A6%E4%B9%A0/5.png" style="zoom:67%;"></p>
<h3 id="平台资源分配"><a href="#平台资源分配" class="headerlink" title="平台资源分配"></a>平台资源分配</h3><ul>
<li>Resource Manager中的调度器维护了一个 或多个应用队列(queue) ,每个队列拥有一定量的资源，位于同一队列中的应用共享该队列所拥有的资源。</li>
<li>Yarn进行资源分配对象是应用，用户提交 的每个应用会分配到其中一个队列当中， 而队列决定了该应用能使用的资源上限。</li>
<li>资源调度实际上是决定如何将资源分配给队列、以及如何分配给队列中应用的过程</li>
</ul>
<h4 id="资源分配策略-FIFO"><a href="#资源分配策略-FIFO" class="headerlink" title="资源分配策略-FIFO"></a>资源分配策略-FIFO</h4><p>FIFO调度器只维护一个队列，该队列拥有集群中所有资源，调度器的资源分配方式是<strong>先提交的应用先得到资源</strong></p>
<p>该调度器实现起来比较简单，但是很可能导致一个应用独占所有的资源，而其他资源需不断等待。</p>
<p><img src="/2022/05/09/Yarn%E5%AD%A6%E4%B9%A0/6.png" style="zoom:67%;"></p>
<h4 id="资源分配策略-Capacity"><a href="#资源分配策略-Capacity" class="headerlink" title="资源分配策略-Capacity"></a>资源分配策略-Capacity</h4><p>改进FIFO调度器的思想是将一个队列分解为多个队列，每个队列都拥有一定的资源。某一应用最多只会占用其中一个队列所拥有的资源，而不会占用集群中的所有资源。</p>
<p>因此进化成了 Capacity 策略：Capacity Scheduler维护了层级式队列，集群中的资源划分给了这些队列，队列内部的资源分配方式是FIFO</p>
<p><img src="/2022/05/09/Yarn%E5%AD%A6%E4%B9%A0/7.png" style="zoom:67%;"></p>
<h4 id="资源分配策略-Fair"><a href="#资源分配策略-Fair" class="headerlink" title="资源分配策略-Fair"></a>资源分配策略-Fair</h4><p>改进Capacity调度器的思想是容许队列之间共享资源，从而避免浪费。因此提出了Fair Scheduler, Fair Scheduler维护层级式的队列，集群中的资源划分给这些队列，但是这些队列可以共享资源，因而这些队列逻辑上可以看作是一个共享队列 </p>
<p><img src="/2022/05/09/Yarn%E5%AD%A6%E4%B9%A0/8.png" style="zoom:67%;"></p>
<p>当然这种方法也有弊端，应用2在提交之后需要和应用1抢占资源，因此会导致一定的时间延迟</p>
<h2 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h2><p>YARN中的故障主要分为四部分：</p>
<ul>
<li>Resource Manager故障 </li>
<li>Node Manager故障 </li>
<li>Application Master故障：重启 </li>
<li>Container中的任务故障：重启</li>
</ul>
<p>由于AM和Container中运行的任务与具体框架相关，作为资源管理平台的Yarn在它们发生故障的情况下只能重启来恢复</p>
<h3 id="RM故障"><a href="#RM故障" class="headerlink" title="RM故障"></a>RM故障</h3><ul>
<li>如果Resource Manager发生故障，那么它 在进行故障恢复时需要从某一持久化存储 系统中恢复状态信息，所有应用将会重新执行 </li>
<li>我们可以部署多个Resource Manager并通过ZooKeeper进行协调，从而保证 Resource Manager的高可用性</li>
</ul>
<h3 id="NM故障"><a href="#NM故障" class="headerlink" title="NM故障"></a>NM故障</h3><p>Resource Manager认为Node Manager所在节点上所有容器运行的任务也都执行失 败，并把执行失败的信息告诉Application Master </p>
<ul>
<li>AM将向RM重新申请资源运行这些任务</li>
<li><p>RM将分配其它节点的Container执行这些任务</p>
<p>如果发生故障的Node Manager进行恢复， 那么它将向Resource Manager重新注册，重置本地的状态信息</p>
</li>
</ul>
<h2 id="典型示例"><a href="#典型示例" class="headerlink" title="典型示例"></a>典型示例</h2>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/05/08/%E7%94%A8Scala%E5%AE%9E%E7%8E%B0Spark%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/05/08/%E7%94%A8Scala%E5%AE%9E%E7%8E%B0Spark%E7%BC%96%E7%A8%8B/" itemprop="url">用Scala实现Spark编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-05-08T13:39:07+08:00">
                2022-05-08
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-05-09T15:00:32+08:00">
                2022-05-09
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/05/08/advanced-Scala%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/05/08/advanced-Scala%E5%AD%A6%E4%B9%A0/" itemprop="url">advanced-Scala学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-05-08T13:37:48+08:00">
                2022-05-08
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-05-08T13:37:50+08:00">
                2022-05-08
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/04/28/scala%E5%88%9D%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/28/scala%E5%88%9D%E8%AF%86/" itemprop="url">scala初识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-04-28T10:29:01+08:00">
                2022-04-28
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-05-09T14:59:58+08:00">
                2022-05-09
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Scala初识"><a href="#Scala初识" class="headerlink" title="Scala初识"></a>Scala初识</h1><h2 id="The-Absolute-Scala-Basics"><a href="#The-Absolute-Scala-Basics" class="headerlink" title="The Absolute Scala Basics"></a>The Absolute Scala Basics</h2><h3 id="Values-Variables-and-Types"><a href="#Values-Variables-and-Types" class="headerlink" title="Values, Variables and Types"></a>Values, Variables and Types</h3><p>学习一门新的语言，自然要先从数值类型入手。在scala中，常量用val定义，变量用var定义。</p>
<ul>
<li>定义常量Int</li>
</ul>
<p>一个量有两种定义方式，一种是显式的定义x. 指明其为类型；另外一种则是隐式的声明，让编译器来判断的类型。推荐使用显式的定义，可读性更强一些。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x : <span class="type">Int</span> = <span class="number">62</span></span><br><span class="line"><span class="keyword">val</span> x = <span class="number">62</span></span><br></pre></td></tr></table></figure>
<ul>
<li>定义常量String，同样分显式和隐式两种。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aString : <span class="type">String</span> = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">val</span> bString = <span class="string">"goodbye"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>定义布尔值Boolean</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aBoolean: <span class="type">Boolean</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>定义字符类型 Char</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aChar: <span class="type">Char</span> = 'a'</span><br><span class="line"><span class="keyword">val</span> bChar = 'b'</span><br></pre></td></tr></table></figure>
<ul>
<li>定义Short类型整数</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aShort : <span class="type">Short</span> = <span class="number">3456</span></span><br></pre></td></tr></table></figure>
<ul>
<li>定义Long 整数, 需要在数值尾部加上L</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aLong : <span class="type">Long</span> =<span class="number">5273985273895237</span>L</span><br><span class="line"><span class="keyword">val</span> bLong = <span class="number">5273985273895237</span>L</span><br></pre></td></tr></table></figure>
<ul>
<li>定义浮点数Float, 需要在尾部加上f</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aFloat: <span class="type">Float</span> = <span class="number">2.0</span>f</span><br><span class="line"><span class="keyword">val</span> bFloat = <span class="number">2.0</span>f</span><br></pre></td></tr></table></figure>
<ul>
<li>定义双精度浮点数Double</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aDouble: <span class="type">Double</span> = <span class="number">3.14</span></span><br><span class="line"><span class="keyword">val</span> bDouble = <span class="number">2.0</span></span><br></pre></td></tr></table></figure>
<p>scala中还有一个特殊的类型：Unit类型，它表示无值，和其他语言中的void等同。用作不返回任何结果的方法的结果类型。Unit只有一个实例值，写成 <code>()</code></p>
<p>比如说：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aWeirdValue = (aVariable = <span class="number">3</span>)<span class="comment">// Unit == void</span></span><br><span class="line">println(aWeirdValue)</span><br></pre></td></tr></table></figure>
<h3 id="Expressions"><a href="#Expressions" class="headerlink" title="Expressions"></a>Expressions</h3><ul>
<li>操作符</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="number">3</span>+<span class="number">5</span></span><br><span class="line"><span class="keyword">val</span> xIsEven = x%<span class="number">2</span> == <span class="number">0</span></span><br><span class="line"><span class="keyword">val</span> xIsOdd = !xIsEven</span><br></pre></td></tr></table></figure>
<p>scala中的操作符和Java中的操作符是一样的，包括||, &amp;&amp; ， &gt;&gt;,&lt;&lt;, ^ ,+= , 但是注意，没有++，—</p>
<ul>
<li>if 表达式，if在scala中是以表达式的形式存在，而不是以指令的形式存在的，如下</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> cond: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">val</span> i = <span class="keyword">if</span>(cond) <span class="number">42</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>当然也可以写正常的 If-else  指令</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(aVariable==<span class="number">4</span>)&#123;</span><br><span class="line">  println(<span class="string">"12dsdawd"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  println(<span class="number">2112</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>while表达式，在Scala中请不要写while表达式，因为scala有更方便的方法进行遍历。 while表达式也是可以返回值的，只不过返回一个unit。</li>
</ul>
<p>在scala中,所有的代码都是以表达式的形式呈现的，因此我们在写scala的时候要尽量减少如 <code>println()</code>、 <code>while</code>、以及变量再赋值这类的命令式语言的代码。虽然他们有效，但本质上还是表达式，返回的值是Unit，且会干扰我们代码的工整</p>
<ul>
<li>code block, 此外scala还有一种特殊的表达式 ： CodeBlocks .这种表达式返回的值是代码块的最后一行得到的值，在这里 <code>aCodeBlock = &quot;goodbye&quot;</code>. 此外要记住，在CodeBlocks中定义的val定量，在块外是无法被访问到的</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aCodeBlock = &#123;</span><br><span class="line">  <span class="keyword">val</span> y = <span class="number">2</span></span><br><span class="line">  <span class="keyword">val</span> z = y+<span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span>(z &gt; <span class="number">2</span>) <span class="string">"hello"</span> <span class="keyword">else</span> <span class="string">"goodbye"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> somValue = &#123;</span><br><span class="line">	<span class="number">2</span>&lt;<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> someOtherValue = &#123;</span><br><span class="line">	<span class="keyword">if</span>(someValue) <span class="number">239</span> <span class="keyword">else</span> <span class="number">2120</span></span><br><span class="line">	<span class="number">42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请问someOtherValue的结果是什么? 因为CodeBlock的值等于最后一行代码的值，在这里someOtherValue = 42</p>
<h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><p>在Scala中，一个函数的定义如下：</p>
<p><code>aFunction</code>是函数的名字，a和b是函数的两个需要被输入的参数，String是该函数的返回值类型</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aFunction</span> </span>(a: <span class="type">String</span>,b: <span class="type">Int</span>) <span class="type">String</span> = &#123;</span><br><span class="line">	a + <span class="string">" "</span> + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果函数只有一行，那么可以不需要用<code>{}</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如这个函数只需要返回42</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aParameterlessFunction</span></span>(): <span class="type">Int</span> = <span class="number">42</span></span><br><span class="line"><span class="comment">// 这个函数负责打印,不需要返回值，因此返回一个Unit对象</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aFunctionWithSideEffects</span></span>(aString: <span class="type">String</span>): <span class="type">Unit</span> = println(aString)</span><br></pre></td></tr></table></figure>
<p>我们可以写一个递归函数：会连续打印n遍 aString。 在scala中，当我们需要写一个for/while循环的时候，我们需要写一个等价的递归函数。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aRepeatedFunction</span></span>(aString: <span class="type">String</span>, n: <span class="type">Int</span>): <span class="type">String</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) aString</span><br><span class="line">  <span class="keyword">else</span> aString + aRepeatedFunction(aString, n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(aRepeatedFunction(<span class="string">"hello"</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>我们也可以在一个函数里面写另外一个函数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aBigFunction</span></span>(n: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">aSmallerFunction</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Int</span> = a + b</span><br><span class="line">  aSmallerFunction(n, n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(aBigFunction(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise"></a>Exercise</h4><p>写一个函数，用来判断一个数是否为素数？</p>
<p>在其他语言中，我们可能会用一个for循环，每次循环都让n除以一个不大于其自身$\frac{1}{2}$ 的数(1除外)，如果都不能整除，就说明这个数是素数。</p>
<p>在Scala中，由于我们要用递归去代替循环，那么就只能这么写：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span></span>(n: <span class="type">Int</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isPrimeUntil</span></span>(t: <span class="type">Int</span>): <span class="type">Boolean</span> =</span><br><span class="line">    <span class="keyword">if</span> (t &lt;= <span class="number">1</span>) <span class="literal">true</span></span><br><span class="line">    <span class="keyword">else</span> n % t != <span class="number">0</span> &amp;&amp; isPrimeUntil(t<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">  isPrimeUntil(n / <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Type-Inference"><a href="#Type-Inference" class="headerlink" title="Type Inference"></a>Type Inference</h3><p>Scala有隐式的类型转换，比如说：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="number">2</span></span><br><span class="line"><span class="keyword">val</span> y = x + <span class="string">"items"</span></span><br></pre></td></tr></table></figure>
<p>此时，编译器认为一个Int+一个String还是String，因此y的类型就是一个String类型的常量。</p>
<p>但是，也存在编译器推测失灵的情况，主要发生在递归函数里面。我们看到，如果n&lt;=0，会返回1，此时编译器会认为函数的返回类型为诶Int，但是第二行，返回的值类型是Int乘以一个函数调用，这就把便一起搞混了，到底是不是返回Int呢？</p>
<p>因此，在创建函数的时候最好点名函数的返回类型，如果返回类型为空，那么就将类型置为Unit</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span></span>(n: <span class="type">Int</span>): <span class="type">Int</span> =</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span> n * factorial(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">println(factorial(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<h3 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h3><p>使用递归函数的时候，很容易出现一种情况：<strong>栈溢出</strong>。就拿连乘函数来说，<code>factorial(10)</code> 还可以跑，但是<code>factorial(5000)</code> 就会报错。</p>
<p>那么怎么避免这个问题？</p>
<p>要解决问题就需要找到问题为什么会发生,<code>if (n &lt;= 0) 1 else n * factorial(n-1)</code> 这句代码中，每调用一次factorial，就会占用一行栈空间。</p>
<p>如果n=5，那么这个递归的调用过程大致如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">factorial(<span class="number">5</span>)</span><br><span class="line"><span class="number">5</span> * factorial(<span class="number">4</span>)</span><br><span class="line"><span class="number">5</span> * (<span class="number">4</span> * factorial(<span class="number">3</span>))</span><br><span class="line"><span class="number">5</span> * (<span class="number">4</span> * (<span class="number">3</span> * factorial(<span class="number">2</span>)))</span><br><span class="line"><span class="number">5</span> * (<span class="number">4</span> * (<span class="number">3</span> * (<span class="number">2</span> * factorial(<span class="number">1</span>))))</span><br><span class="line"><span class="number">5</span> * (<span class="number">4</span> * (<span class="number">3</span> * (<span class="number">2</span> * <span class="number">1</span>)))</span><br></pre></td></tr></table></figure>
<p>为了解决这个问题，需要学习“尾递归”的概念。什么是尾递归？尾递归是指递归调用是函数的最后一个语句，而且其结果被直接返回，这是一类特殊的递归调用。 由于递归结果总是直接返回，尾递归比较方便转换为循环，因此编译器容易对它进行优化。</p>
<p>以上阶乘函数不是尾递归，因为递归调用的结果有一次额外的乘法计算，这导致每一次递归调用留在堆栈中的数据都必须保留。我们可以将它修改为尾递归的方式。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">anotherFactorial</span></span>(n: <span class="type">Int</span>): <span class="type">BigInt</span> = &#123;</span><br><span class="line">  <span class="meta">@tailrec</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">factHelper</span></span>(x: <span class="type">Int</span>, accumulator: <span class="type">BigInt</span>): <span class="type">BigInt</span> =</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) accumulator</span><br><span class="line">    <span class="keyword">else</span> factHelper(x - <span class="number">1</span>, x * accumulator) </span><br><span class="line">  <span class="comment">// TAIL RECURSION = use recursive call as the LAST expression</span></span><br><span class="line">  factHelper(n, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的调用，由于调用结果都是直接返回，所以之前的递归调用留在堆栈中的数据可以丢弃，只需要保留最后一次的数据，这就是尾递归容易优化的原因所在， 而它的秘密武器就是上面的acc，它是一个累加器（accumulator，习惯上翻译为累加器，其实不一定非是“加”，任何形式的积聚都可以），用来积累之前调用的结果，这样之前调用的数据就可以被丢弃了。</p>
<p>因此，当我们需要用循环的时候，就可以用到 Tail Recursion</p>
<p>比如说我要用tail recursion来写一个判断是否为素数的函数，在这里我们的accumulator是一个布尔值的变量，用来记录在当前情况下，n是否还为素数。如果布尔值为否，那么就返回false，如果t&lt;=1了，说除到2还是素数，说明n是真的素数，因此返回true。如果t还没到1，那么就递归调用IsPrimeUntil函数，将布尔值设定为 <code>n%t != 0</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">IsPrime</span></span>(n: <span class="type">Int</span>): <span class="type">Boolean</span> =&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@tailrec</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">IsPrimeUntil</span></span>( isPrimeNow:<span class="type">Boolean</span>, t:<span class="type">Int</span>):<span class="type">Boolean</span> =&#123;</span><br><span class="line">    <span class="keyword">if</span>(!isPrimeNow) <span class="literal">false</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t&lt;=<span class="number">1</span>) <span class="literal">true</span></span><br><span class="line">    <span class="keyword">else</span> <span class="type">IsPrimeUntil</span>(n%t!=<span class="number">0</span>,t<span class="number">-1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">IsPrimeUntil</span>( <span class="literal">true</span>,n/<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如我要写一个Fibonacci的递归函数，这个比较难一些。和一般的Fibonacci思维不同，如果使用tail recursion，是从底部想上去加，而且要有两个accumulator来记录$f(n-1),f(n-2)$的值</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span></span>(n: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">   <span class="meta">@tailrec</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">fiboTailrec</span></span>(i: <span class="type">Int</span>, last: <span class="type">Int</span>, nextToLast: <span class="type">Int</span>): <span class="type">Int</span> =</span><br><span class="line">     <span class="keyword">if</span>(i &gt;= n) last</span><br><span class="line">     <span class="keyword">else</span> fiboTailrec(i + <span class="number">1</span>, last + nextToLast, last)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="number">1</span></span><br><span class="line">   <span class="keyword">else</span> fiboTailrec(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> println(fibonacci(<span class="number">8</span>)) <span class="comment">// 1 1 2 3 5 8 13, 21</span></span><br></pre></td></tr></table></figure>
<h3 id="Call-by-Name-and-Call-by-Value"><a href="#Call-by-Name-and-Call-by-Value" class="headerlink" title="Call-by-Name and Call-by-Value"></a>Call-by-Name and Call-by-Value</h3><p>scala的call by name 和call by value最大的区别就是：</p>
<p><strong>call-by-name在调用的时候会重新根据name做计算，而call-by-value预先计算，然后保留计算值后一直使用这个value。</strong></p>
<p>比如说：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calledByValue</span></span>(x: <span class="type">Long</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  println(<span class="string">"by value: "</span> + x)</span><br><span class="line">  println(<span class="string">"by value: "</span> + x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意，call by name的话，需要用到的语法不同，还要加上 =&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calledByName</span></span>(x: =&gt; <span class="type">Long</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  println(<span class="string">"by name: "</span> + x)</span><br><span class="line">  println(<span class="string">"by name: "</span> + x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">calledByValue(<span class="type">System</span>.nanoTime())</span><br><span class="line">calledByName(<span class="type">System</span>.nanoTime())</span><br></pre></td></tr></table></figure>
<p>结果如下图所示，我们看到，call by name的话，每次都会计算x的值；而call by value的话，会预计算x的值</p>
<p><img src="/2022/04/28/scala%E5%88%9D%E8%AF%86/1.png"></p>
<p>同时call by name传入的表达式是<strong>lazy</strong> 的，也就是说，只有要用到这个参数的时候，才回去计算这个参数的值。</p>
<p>比如说：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">infinite</span></span>(): <span class="type">Int</span> = <span class="number">1</span> + infinite()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printFirst</span></span>(x: <span class="type">Int</span>, y: =&gt; <span class="type">Int</span>) = println(x)</span><br><span class="line"></span><br><span class="line">printFirst(infinite(), <span class="number">34</span>) <span class="comment">// stack overflow</span></span><br><span class="line">printFirst(<span class="number">34</span>, infinite())</span><br></pre></td></tr></table></figure>
<p>如上面这几行代码，我们定义了一个无限递归的函数infinite，如果调用infinite()必会导致stackoverflow</p>
<p>然后我们有定义了一个printFirst函数，第一个参数是call by value的，第二个是call by name的。</p>
<p>如果我们调用<code>printFirst(infinite(), 34)</code>，会报错，因为x是call by value的，需要预计算，那么丢会调用<code>infinite()</code>.导致栈溢出</p>
<p>但是如果我们调用<code>printFirst(34,infinite())</code>,就不会报错，因为y是call by name的，是<strong>lazy</strong> 的，若函数体内没有关于y的调用，就不会去计算y的值。因此不会报错。</p>
<p>当然，如果输入的都是数字的话，那么call by name和call by value就是一样的了</p>
<h3 id="Default-and-Named-Arguments"><a href="#Default-and-Named-Arguments" class="headerlink" title="Default and Named Arguments"></a>Default and Named Arguments</h3><p>在写下尾递归的时候，我们常常会选择两个函数嵌套的写法，这是因为我们不想让用户手动输入accumulator的值，函数嵌套可以实现对用户的透明机制。</p>
<p>那么可不可以既实现透明，又只写一层函数的方法呢？显然，我们可以用默认参数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trFact</span></span>(n: <span class="type">Int</span>, acc: <span class="type">Int</span> = <span class="number">1</span>): <span class="type">Int</span> =</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) acc</span><br><span class="line">  <span class="keyword">else</span> trFact(n<span class="number">-1</span>, n*acc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> fact10 = trFact(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>如果一个函数有多个默认参数的话，编译器会默认输入的第一个参数对应函数中第一个place holder，因此如果我们想让第一个参数默认，其他两个参数自己设置的话，就需要我们显式得设置参数的名字。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">savePicture</span></span>(format: <span class="type">String</span> = <span class="string">"jpg"</span>, width: <span class="type">Int</span> = <span class="number">1920</span>, height: <span class="type">Int</span> = <span class="number">1080</span>): <span class="type">Unit</span> = println(<span class="string">"saving picture"</span>)</span><br><span class="line"> savePicture(<span class="string">"jpg"</span>,<span class="number">800</span>,<span class="number">600</span>)<span class="comment">// 这是可以的</span></span><br><span class="line"> savePicture(height = <span class="number">600</span>, width = <span class="number">800</span>)<span class="comment">//这也是可以的</span></span><br><span class="line">savePicture(<span class="number">800</span>,<span class="number">600</span>)<span class="comment">//这就会报错</span></span><br></pre></td></tr></table></figure>
<h3 id="Smart-Operations-on-Strings"><a href="#Smart-Operations-on-Strings" class="headerlink" title="Smart Operations on Strings"></a>Smart Operations on Strings</h3><p>现在我们来介绍一些对于字符串的操作</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> str: <span class="type">String</span> = <span class="string">"Hello, I am learning Scala"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>输出指定位置的字符</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(str.charAt(<span class="number">2</span>)) <span class="comment">// l</span></span><br></pre></td></tr></table></figure>
<ul>
<li>节选字符串</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(str.substring(<span class="number">7</span>,<span class="number">11</span>))	<span class="comment">//I am</span></span><br><span class="line">println(str.take(<span class="number">2</span>)) <span class="comment">//He</span></span><br></pre></td></tr></table></figure>
<ul>
<li>切分字符串</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(str.split(<span class="string">" "</span>).toList) <span class="comment">//List(Hello,, I, am, learning, Scala)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>判断字符串是否从某字符串开始</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(str.startsWith(<span class="string">"Hello"</span>)) <span class="comment">//True</span></span><br></pre></td></tr></table></figure>
<ul>
<li>字符串替换</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(str.replace(<span class="string">" "</span>, <span class="string">"-"</span>)) <span class="comment">//Hello,-I-am-learning-Scala</span></span><br></pre></td></tr></table></figure>
<ul>
<li>小写化</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(str.toLowerCase()) <span class="comment">//hello, i am learning scala</span></span><br></pre></td></tr></table></figure>
<ul>
<li>字符串长度</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(str.length) <span class="comment">// 26</span></span><br></pre></td></tr></table></figure>
<ul>
<li>字符串反转</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(str.reverse) <span class="comment">// alacS gninrael ma I ,olleH</span></span><br></pre></td></tr></table></figure>
<ul>
<li>字符串转为数字</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aNumberString = <span class="string">"2"</span></span><br><span class="line"><span class="keyword">val</span> aNumber = aNumberString.toInt</span><br></pre></td></tr></table></figure>
<ul>
<li><p>字符串和数字拼接，需要用到特殊的拼接符号。</p>
<ul>
<li>+: 用于在list的头部添加元素</li>
<li>:+ 用于在list尾部追加元素; </li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println('a' +: aNumberString :+ 'z')</span><br></pre></td></tr></table></figure>
</li>
<li><p>S-插值器</p>
</li>
</ul>
<p>S-插值器的语法有点类似于CSS、PHP中的变量。也就是说，利用S-插值器可以往字符串中插入变量，比如说”</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name = <span class="string">"David"</span></span><br><span class="line"><span class="keyword">val</span> age = <span class="number">12</span></span><br><span class="line"><span class="keyword">val</span> greeting = <span class="string">s"Hello, my name is <span class="subst">$name</span> and I am <span class="subst">$age</span> years old"</span></span><br><span class="line"><span class="keyword">val</span> anotherGreeting = <span class="string">s"Hello, my name is <span class="subst">$name</span> and I will be turning <span class="subst">$&#123;age + 1&#125;</span> years old."</span></span><br><span class="line">println(anotherGreeting) <span class="comment">//Hello, my name is David and I will be turning 13 years old.</span></span><br></pre></td></tr></table></figure>
<ul>
<li>F-插值器</li>
</ul>
<p>F-插值器的作用是用来格式化的</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> speed = <span class="number">1.2</span>f</span><br><span class="line"><span class="keyword">val</span> myth = <span class="string">f"<span class="subst">$name</span> can eat <span class="subst">$speed</span>%2.2f burgers per minute"</span></span><br><span class="line">println(myth) <span class="comment">// David can eat 1.20 burgers per minute</span></span><br></pre></td></tr></table></figure>
<ul>
<li>raw-插值器</li>
</ul>
<p>raw插值器则是让字符串中的转义符失效 。 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> str2 = <span class="string">"a\nb"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> str3 = <span class="string">raw"a\nb"</span></span><br><span class="line"></span><br><span class="line">println(str2) <span class="comment">// \n 生效，a和b之间换行</span></span><br><span class="line"></span><br><span class="line">println(str3)	<span class="comment">// a\nb , \n失效</span></span><br></pre></td></tr></table></figure>
<p>但是我如果把string当做一个插入的参数打印，那么转义符就不会失效，比如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> escaped = <span class="string">"This is a \n newline"</span></span><br><span class="line">println(<span class="string">raw"<span class="subst">$escaped</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">This is a </span></span><br><span class="line"><span class="comment"> newline</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="Object-Oriented-Programming-in-Scala"><a href="#Object-Oriented-Programming-in-Scala" class="headerlink" title="Object Oriented Programming in Scala"></a>Object Oriented Programming in Scala</h2><h3 id="Object-Oriented-Basics"><a href="#Object-Oriented-Basics" class="headerlink" title="Object-Oriented Basics"></a>Object-Oriented Basics</h3><p>现在我们来创建一个最简单的类</p>
<p>我们首先从构造类的参数说起。这个Person类需要两个构造参数：name和age，其中，age用val来修饰，说明age变成了类中的一个成员，我们可以用<code>person.age</code>来访问；但是name只是一个参数，我们无法用<code>person.name</code> 来获取这个参数。</p>
<p>然后我们来看类中的body部分，这一部分类似于CodeBlock，一些逻辑会直接运行。如果在里面定义了常量或者定量，他们都会变成<strong>fields</strong>我们都可以通过点运算符对其进行访问</p>
<p>接着我们来看两个函数，函数名都是greet，因此会发生函数重载。第一个greet函数接收一个String类型的参数，并打印字符串，这个字符串里面如果需要引用这个传参，需要用<code>${this.name}</code> ，而不能单纯的用<code>$name</code></p>
<p>第二个函数没有任何输入参数，直接打印字符串，这里调用的参数是 <code>$name</code> ,是类里面的成员变量</p>
<p>和C++一样，scala也支持在类里面写多个构造函数，可以是没有参数的构造函数，也可以是有参数的</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, val age: <span class="type">Int</span> = 0</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body</span></span><br><span class="line">  <span class="keyword">val</span> x = <span class="number">2</span></span><br><span class="line">  println(<span class="number">1</span> + <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// method</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">greet</span></span>(name: <span class="type">String</span>): <span class="type">Unit</span> = println(<span class="string">s"<span class="subst">$&#123;this.name&#125;</span> says: Hi, <span class="subst">$name</span>"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// overloading</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">greet</span></span>(): <span class="type">Unit</span> = println(<span class="string">s"Hi, I am <span class="subst">$name</span>"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// multiple constructors</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(name: <span class="type">String</span>) = <span class="keyword">this</span>(name, <span class="number">0</span>) <span class="comment">//如果只有一个string参数的构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>() = <span class="keyword">this</span>(<span class="string">"John Doe"</span>)		<span class="comment">//如果没有参数，其构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> person = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"John"</span>, <span class="number">26</span>) <span class="comment">//在创建对象时就会打印 4</span></span><br><span class="line">  println(person.x)			 <span class="comment">// 2</span></span><br><span class="line">  person.greet(<span class="string">"Daniel"</span>) <span class="comment">//John says: Hi, Daniel</span></span><br><span class="line">  person.greet() 				 <span class="comment">//Hi, I am John</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">val</span> person2 = <span class="keyword">new</span> <span class="type">Person</span>()</span><br><span class="line">  person2.greet()					<span class="comment">//Hi, I am John Doe</span></span><br></pre></td></tr></table></figure>
<h4 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise"></a>Exercise</h4><ol>
<li><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Novel and a Writer</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Writer: first name, surname, year(出生年)</span></span><br><span class="line"><span class="comment">    - method fullname 返回全名</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Novel: name, year of release, author</span></span><br><span class="line"><span class="comment">  - authorAge 返回作者的年龄</span></span><br><span class="line"><span class="comment">  - isWrittenBy(author) 返回作者对象</span></span><br><span class="line"><span class="comment">  - copy (new year of release) = new instance of Novel 返回一个新实例</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Writer</span>(<span class="params">firstName: <span class="type">String</span>, surname: <span class="type">String</span>, val year: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fullName</span></span>: <span class="type">String</span> = firstName + <span class="string">" "</span> + surname</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Novel</span>(<span class="params">name: <span class="type">String</span>, year: <span class="type">Int</span>, author: <span class="type">Writer</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">authorAge</span> </span>= year - author.year</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isWrittenBy</span></span>(author: <span class="type">Writer</span>) = author == <span class="keyword">this</span>.author</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">copy</span></span>(newYear: <span class="type">Int</span>): <span class="type">Novel</span> = <span class="keyword">new</span> <span class="type">Novel</span>(name, newYear, author)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Counter class</span></span><br><span class="line"><span class="comment">    - receives an int value</span></span><br><span class="line"><span class="comment">    - method current count </span></span><br><span class="line"><span class="comment">    // 需要实现两个方法，一个增1，一个减1</span></span><br><span class="line"><span class="comment">    - method to increment/decrement =&gt; new Counter</span></span><br><span class="line"><span class="comment">    // 还要实现函数重载，输入一个n，要增加n次</span></span><br><span class="line"><span class="comment">    - overload inc/dec to receive an amount</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span>(<span class="params">val count: <span class="type">Int</span> = 0</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inc</span> </span>= &#123;</span><br><span class="line">    println(<span class="string">"incrementing"</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Counter</span>(count + <span class="number">1</span>)  <span class="comment">// immutability</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//	def dec():Counter =&#123;&#125;</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dec</span> </span>= &#123;</span><br><span class="line">    println(<span class="string">"decrementing"</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Counter</span>(count - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 这是一个递归函数，但是不是下尾递归</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inc</span></span>(n: <span class="type">Int</span>): <span class="type">Counter</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">else</span> inc.inc(n<span class="number">-1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dec</span></span>(n: <span class="type">Int</span>): <span class="type">Counter</span> =</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">else</span> dec.dec(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">print</span> </span>= println(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于函数返回一个Counter，所以可以在调用inc之后继续调用inc，如果调用了三次，那么会让count+3 = 3</p>
<p>但是如果重新调用inc，那么之前的inc并不会累加，对于counter来说，其count值始终为零。 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">调用: counter.inc.print</span><br><span class="line">incrementing</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line">调用: counter.inc.inc.inc.print</span><br><span class="line">incrementing</span><br><span class="line">incrementing</span><br><span class="line">incrementing</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">调用: counter.inc(<span class="number">10</span>).print</span><br><span class="line">incrementing</span><br><span class="line">incrementing</span><br><span class="line">incrementing</span><br><span class="line">incrementing</span><br><span class="line">incrementing</span><br><span class="line">incrementing</span><br><span class="line">incrementing</span><br><span class="line">incrementing</span><br><span class="line">incrementing</span><br><span class="line">incrementing</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<h3 id="Syntactic-Sugar-Method-Notations"><a href="#Syntactic-Sugar-Method-Notations" class="headerlink" title="Syntactic Sugar: Method Notations"></a>Syntactic Sugar: Method Notations</h3><p>现在来介绍一些语法糖。scala是一个很”自然语言化”的语言，里面有很多特殊的语法，我觉得很像是C++中的运算符重载。</p>
<ul>
<li>infix notation/ operator notation ，这种语法只适用于<strong>只有一个参数的函数</strong>中 。 在scala中，我们要理解一个概念：所有的操作符，同时也是一个函数。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val name: <span class="type">String</span>, favoriteMovie: <span class="type">String</span>,val age: <span class="type">Int</span> = 0</span>)</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">likes</span></span>(movie:<span class="type">String</span>): <span class="type">Boolean</span> = movie == favourite</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hangOutWith</span></span>(person: <span class="type">Person</span>): <span class="type">String</span> = <span class="string">s"<span class="subst">$&#123;this.name&#125;</span> is hanging out with <span class="subst">$&#123;person.name&#125;</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> mary = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"Mary"</span>,<span class="string">"Inception"</span>)</span><br><span class="line"><span class="keyword">val</span> tom - <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"Tom"</span>,<span class="string">"Fight Club"</span>)</span><br></pre></td></tr></table></figure>
<p>我们要调用Person中的likes函数,正常的写法如下：<code>mary.likes(&quot;Inception&quot;)</code></p>
<p>但我们可以直接这样写： <code>mary likes &quot;Inception&quot;</code>， 也就是将其他特殊符号全部略去，只留下最重要的三个部分。又比如说，可以直接写  <code>mary hangOutWith tom</code></p>
<p>甚至我可以重命名hangOutWith函数为 <code>def +(person: Person): String = s&quot;${this.name} is hanging out with ${person.name}&quot;</code>， 那么就可以这么写： <code>mary + tom</code></p>
<p>而<code>+</code> 和<code>.+</code> 是相等的，所以我们还可以这么写： <code>mary.+(tom)</code></p>
<ul>
<li>prefix notation，主要是 <code>unary_</code> 前缀，它只<strong>适用于单目运算符</strong><code>-,+,~,!</code> </li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="number">-1</span>  <span class="comment">// equivalent with 1.unary_-</span></span><br><span class="line"><span class="keyword">val</span> y = <span class="number">1.</span>unary_- <span class="comment">// x和y是相等的</span></span><br></pre></td></tr></table></figure>
<p>同样的，我们也可以在Person类中定义 名为<code>unary_!</code>的函数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val name: <span class="type">String</span>, favoriteMovie: <span class="type">String</span>,val age: <span class="type">Int</span> = 0</span>)</span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">unary_!</span> </span>: <span class="type">String</span> = <span class="string">s"<span class="subst">$name</span>, what the heck?!"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unary_+</span> </span>: <span class="type">Person</span> = <span class="keyword">new</span> <span class="type">Person</span>(name, favoriteMovie, age + <span class="number">1</span>)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面两个表达式是等价的 打印值： Hi, my name is Mary and I like Inception</span></span><br><span class="line">println(!mary)				</span><br><span class="line">println(mary.unary_!)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面两个表达式也是等价的，打印值： 1</span></span><br><span class="line">println(+mary.age)</span><br><span class="line">println(mary.unary_+.age)</span><br></pre></td></tr></table></figure>
<ul>
<li>Postfix notation 适用于<strong>没有任何参数的函数</strong></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val name: <span class="type">String</span>, favoriteMovie: <span class="type">String</span>, val age: <span class="type">Int</span> = 0</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isAlive</span></span>: <span class="type">Boolean</span> = <span class="literal">true</span> <span class="comment">//直接返回true</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(): <span class="type">String</span> = <span class="string">s"Hi, my name is <span class="subst">$name</span> and I like <span class="subst">$favoriteMovie</span>"</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(n: <span class="type">Int</span>): <span class="type">String</span> = <span class="string">s"<span class="subst">$name</span> watched <span class="subst">$favoriteMovie</span> <span class="subst">$n</span> times"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.language.postfixOps</span><br><span class="line"></span><br><span class="line">println(mary.isAlive)</span><br><span class="line"><span class="comment">//用这种写法也可以，只不过需要导入一个包，不建议使用</span></span><br><span class="line">println(mary isAlive)</span><br></pre></td></tr></table></figure>
<ul>
<li>apply () 函数</li>
</ul>
<p>当我们直接在一个对象后面加上<code>()</code>,编译器就会自动调用该类中的apply函数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val name: <span class="type">String</span>, favoriteMovie: <span class="type">String</span>, val age: <span class="type">Int</span> = 0</span>) </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(): <span class="type">String</span> = <span class="string">s"Hi, my name is <span class="subst">$name</span> and I like <span class="subst">$favoriteMovie</span>"</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(n: <span class="type">Int</span>): <span class="type">String</span> = <span class="string">s"<span class="subst">$name</span> watched <span class="subst">$favoriteMovie</span> <span class="subst">$n</span> times"</span></span><br><span class="line">&#125;</span><br><span class="line">println(mary.apply())</span><br><span class="line">println(mary()) <span class="comment">// equivalent</span></span><br></pre></td></tr></table></figure>
<h4 id="Method-Notations-Exercises"><a href="#Method-Notations-Exercises" class="headerlink" title="Method Notations (Exercises)"></a>Method Notations (Exercises)</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  1.  Overload the + operator</span></span><br><span class="line"><span class="comment">      mary + "the rockstar" =&gt; new person "Mary (the rockstar)"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">+</span></span>(nickname:<span class="type">String</span>) = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">s"name(<span class="subst">$nickname</span>)"</span>,favoriteMovie)</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  2.  Add an age to the Person class</span></span><br><span class="line"><span class="comment">      Add a unary + operator =&gt; new person with the age + 1</span></span><br><span class="line"><span class="comment">      +mary =&gt; mary with the age incrementer</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unary_+</span> </span>: <span class="type">Person</span> = <span class="keyword">new</span> <span class="type">Person</span>(name,favoriteMovie,age+<span class="number">1</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  3.  Add a "learns" method in the Person class =&gt; "Mary learns Scala"</span></span><br><span class="line"><span class="comment">      Add a learnsScala method, calls learns method with "Scala".</span></span><br><span class="line"><span class="comment">      Use it in postfix notation.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">learns</span></span>(lessons:<span class="type">String</span>) = <span class="string">s"<span class="subst">$name</span> learns <span class="subst">$lessons</span>"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">learnScala</span> </span>= <span class="keyword">this</span> learns <span class="string">"Scala"</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  4.  Overload the apply method</span></span><br><span class="line"><span class="comment">      mary.apply(2) =&gt; "Mary watched Inception 2 times"</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(n: <span class="type">Int</span>): <span class="type">String</span> = <span class="string">s"<span class="subst">$name</span> watched <span class="subst">$favoriteMovie</span> <span class="subst">$n</span> times"</span></span><br></pre></td></tr></table></figure>
<h3 id="Scala-Objects"><a href="#Scala-Objects" class="headerlink" title="Scala Objects"></a>Scala Objects</h3><p>Scala既然可以当做面向对象的语言来写，那么就必须具备面向对象语言的特征。那么其中一个特征就是：类内静态方法、静态成员变量。静态方法我们在Java中学过，就是只能被类调用，而不能被实例调用。比如说：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    public static <span class="keyword">final</span> int <span class="type">N_EYES</span> = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么在scala中，如何实现类内静态成员呢？ 答案就是Object</p>
<p>比如我创建一个名为Person的Object，里面的所有成员都是静态的，如果要调用，只能这样来写<code>Person.N_EYES</code>,<code>Person.canFlay</code>, <code>Person.apply</code> </p>
<p>此外，Object只有唯一一个实例，就是他自己，如果我令 <code>mary = Person(&quot;Mary&quot;)</code> ，又令 <code>john = Person(&quot;John&quot;)</code> 。那么事实上，mary和john是相等的，它们都是同一个实例。 专业一点叫做singleton instance</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123; <span class="comment">// type + its only instance</span></span><br><span class="line">  <span class="comment">// "static"/"class" - level functionality</span></span><br><span class="line">  <span class="keyword">val</span> <span class="type">N_EYES</span> = <span class="number">2</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">canFly</span></span>: <span class="type">Boolean</span> = <span class="literal">false</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> mary = <span class="type">Person</span></span><br><span class="line">    <span class="keyword">val</span> john = <span class="type">Person</span></span><br><span class="line">    println(mary == john) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>那么如果要创建一个实例的的话，就需要另外创建一个<code>class Person</code>, 这里object 和 class后面的名字必须相同。可以这么说，<strong>Scala中的Object和Class共同构成了Java中的类</strong>。</p>
<p>如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123; <span class="comment">// type + its only instance</span></span><br><span class="line">  <span class="comment">// "static"/"class" - level functionality</span></span><br><span class="line">  <span class="keyword">val</span> <span class="type">N_EYES</span> = <span class="number">2</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">canFly</span></span>: <span class="type">Boolean</span> = <span class="literal">false</span></span><br><span class="line">	<span class="comment">// 静态方法，只能通过Person.apply调用</span></span><br><span class="line">  <span class="comment">// factory method</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(mother: <span class="type">Person</span>, father: <span class="type">Person</span>): <span class="type">Person</span> = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"Bobbie"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val name: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// instance-level functionality</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意，如果既写了 object，又写了 class. 那么如果我们用new的话，一定是新建一个实例。</span></span><br><span class="line"><span class="keyword">val</span> mary = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"Mary"</span>) <span class="comment">// 新实例 mary</span></span><br><span class="line"><span class="keyword">val</span> john = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"John"</span>) <span class="comment">// 新实例 John</span></span><br><span class="line">println(mary == john)					<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如果我想调用类内静态方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> bobbie = <span class="type">Person</span>(mary,john)</span><br></pre></td></tr></table></figure>
<p>最后，我们来说为什么我们现在都用<code>object xxx extends App</code> 来运行scala文件：</p>
<p>在Java中，要使程序能够运行，需要有一个main函数，如下所示：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; </span><br><span class="line">    public static void main(<span class="type">String</span>[] args) &#123; </span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于scala到最后也是需要放到JVM上去运行的，因此也需要有一个main函数。scala中的main函数如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span></span><br></pre></td></tr></table></figure>
<p>但是如果我们用 <code>object xxx extends App</code> ，那么就会继承 App中的main函数，我们就不用每次都写了。</p>
<h3 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h3><p>既然上面提到了 继承，现在我们就来说说scala中的继承是怎么回事。</p>
<p>scala的继承以及一些关键字基本和Java中的类似。</p>
<h4 id="单类继承"><a href="#单类继承" class="headerlink" title="单类继承"></a>单类继承</h4><p>一个基本的单类继承如下：我创建了一个Animal类，然后有创建了一个Cat类去继承Animal，此时在Cat类中就可以继承Animal中的成员了。</p>
<p>成员默认是<strong>public</strong>,子类和外部都可以调用</p>
<p>如果成员被<strong>private</strong>修饰，那么其子类就无法调用和外部就无法调用</p>
<p>如果成员被<strong>protected</strong>修饰，那么其子类内部可以调用，但外部无法调用(实例调用)</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> creatureType = <span class="string">"wild"</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eat</span> </span>= println(<span class="string">"nomnom"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">crunch</span> </span>= &#123;</span><br><span class="line">    eat</span><br><span class="line">    println(<span class="string">"crunch crunch"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> cat = <span class="keyword">new</span> <span class="type">Cat</span></span><br><span class="line">cat.crunch</span><br></pre></td></tr></table></figure>
<p>那么如果父类和子类的参数不同，该如何写继承语法？</p>
<p>比如说，Person有两个参数，Adult有三个参数，如果我们还是直接 <code>extends Person</code> ,编译器会报错。因此这样如果新建一个Adult实例的话，Adult事实上会调用Person中的构造函数，而Person中的构造函数只接受两个参数。因此，对于子类和父类参数不同的情况下，在继承时就要调用父类的构造函数，如下</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(name: <span class="type">String</span>) = <span class="keyword">this</span>(name, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adult</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span>, idCard: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Person</span>(<span class="params">name</span>)<span class="title">//Person</span>(<span class="params">name,age</span>) <span class="title">这里父类有两个构造函数，因此传入一个或者两个都可</span></span></span><br><span class="line"><span class="class"><span class="title">/*</span></span></span><br><span class="line"><span class="class"><span class="title">当然，如果父类中有这样的</span>  <span class="title">def</span> <span class="title">this</span>(<span class="params"></span>) </span>= <span class="keyword">this</span>(<span class="string">"112"</span>,<span class="number">0</span>)构造函数</span><br><span class="line">那么子类也可以直接 <span class="keyword">extends</span> <span class="type">Person</span></span><br><span class="line"></span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h4 id="函数重写"><a href="#函数重写" class="headerlink" title="函数重写"></a>函数重写</h4><p>在子类 可以重写父类中的函数和成员变量，需要使用override关键词。</p>
<p>当然，如果重写的是父类中的成员变量，可以放在子类的构造函数中，比如：<code>Dog(override val creatureType: String)</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">override val creatureType: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//override val creatureType = "domestic" // can override in the body or directly in the constructor arguments</span></span><br><span class="line">  	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">eat</span> </span>= &#123; </span><br><span class="line">    println(<span class="string">"crunch, crunch"</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>如果想要在重写的函数中仍然运行父类中的代码，可以使用<code>super</code>，super就代表父类，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Dog(override val creatureType: String) extends Animal &#123;</span><br><span class="line">  	override def eat &#x3D; &#123; </span><br><span class="line">  	super.eat</span><br><span class="line">    println(&quot;crunch, crunch&quot;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>事实上我们要尽量避免函数继承，因为会很乱。这里提供了一些办法来避免函数的重载：</p>
<ul>
<li>对成员变量、成员函数使用 final 关键词修饰，就可以避免被重写</li>
<li>对类用final关键词修饰，就可以避免该类被继承</li>
<li>新语法：使用seal关键词，如果用seal来修饰类，那么<strong>仅在此文件中可以继承该类</strong>，但是其他文件中无法继承该类</li>
</ul>
<h3 id="Inheritance-Continued-Abstract-Classes-and-Traits"><a href="#Inheritance-Continued-Abstract-Classes-and-Traits" class="headerlink" title="Inheritance, Continued:  Abstract Classes and Traits"></a>Inheritance, Continued:  Abstract Classes and Traits</h3><h4 id="Abstract-class"><a href="#Abstract-class" class="headerlink" title="Abstract  class"></a>Abstract  class</h4><ul>
<li>抽象类的一个或者多个方法没有完整的定义</li>
<li>声明抽象方法不需要加abstract关键字，<strong>只需要不写方法体</strong>，如<code>def eat: Unit</code></li>
<li>子类重写父类的抽象方法时<strong>不需要</strong>加override</li>
<li>父类可以声明抽象字段（没有初始值的字段）</li>
<li>子类重写父类的抽象字段时不需要加override</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> creatureType: <span class="type">String</span> = <span class="string">"wild"</span> <span class="comment">// 非抽象字段</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>: <span class="type">Unit</span> <span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> creatureType: <span class="type">String</span> = <span class="string">"Canine"</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>: <span class="type">Unit</span> = println(<span class="string">"crunch crunch"</span>) <span class="comment">//重写父类抽象方法时不需要加override </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Traits"><a href="#Traits" class="headerlink" title="Traits"></a>Traits</h4><p>类似于Java中的接口，trait被用于通过所支持的方法特例化来定义对象。如Java 8中一样，<a href="https://so.csdn.net/so/search?q=Scala&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">Scala</a>允许trait被部分实现。其有以下特征：</p>
<ul>
<li>Abstract class和Traits 可以<strong>同时有抽象成员和非抽象成员</strong> </li>
<li>但是和class相比，trait 没有构造函数. </li>
<li>一个类只能继承一个抽象类，但可以混合多个traits。 比如说下面的Crocodile，继承了Animal，同时继承了两个traits: Carnivore和ColdBlooded</li>
<li>一般 抽象类是描述一种物体的，而一个traits 是用来描述该物体的行为的</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Carnivore</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>(animal: <span class="type">Animal</span>): <span class="type">Unit</span></span><br><span class="line">  <span class="keyword">val</span> preferredMeal: <span class="type">String</span> = <span class="string">"fresh meat"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ColdBlooded</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Crocodile</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">with</span> <span class="title">Carnivore</span> <span class="keyword">with</span> <span class="title">ColdBlooded</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> creatureType: <span class="type">String</span> = <span class="string">"croc"</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>: <span class="type">Unit</span> = println(<span class="string">"nomnomnom"</span>) <span class="comment">//重写抽象类中的抽象方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>(animal: <span class="type">Animal</span>): <span class="type">Unit</span> = println(<span class="string">s"I'm a croc and I'm eating <span class="subst">$&#123;animal.creatureType&#125;</span>"</span>)<span class="comment">//重写traits中的抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Type-Hierarchy"><a href="#Type-Hierarchy" class="headerlink" title="Type Hierarchy"></a>Type Hierarchy</h4><p>最后提一嘴Scala中的类型结构，首先，所有类型都是继承自 <code>scala.Any</code> , 这就类似于JavaScript中的Object类， Any是整个Scala类型系统的<strong>超类</strong>。 </p>
<p><code>scala.Any</code>下面分为两个类： <code>scala.AnyVal</code>  和 <code>scala.AnyRef</code> 。</p>
<ul>
<li><code>scala.AnyVal</code>类中，主要是Int，Unit，Boolean，Float这几个数值类</li>
<li><code>scala.AnyRef</code>类中，主要是String，List, Set 这几个引用类型</li>
<li><code>scala.Noting</code>类是一切类的<strong>子类</strong>，包括我们自己创建的类</li>
</ul>
<p><img src="/2022/04/28/scala%E5%88%9D%E8%AF%86/2.jpeg"></p>
<h3 id="Inheritance-Exercises-Implementing-Our-Own-Collection"><a href="#Inheritance-Exercises-Implementing-Our-Own-Collection" class="headerlink" title="Inheritance Exercises Implementing Our Own Collection"></a>Inheritance Exercises Implementing Our Own Collection</h3><p>现在我们要实现一个Int类型的链表，链表要实现这样几个功能：</p>
<ul>
<li><code>head</code>：返回链表头部</li>
<li><code>def tail</code>: 返回除了链表头部以外的剩余部分</li>
<li><code>def isEmpty</code>: 返回链表是否为空</li>
<li><code>def add(int)</code>: 往链表中添加元素</li>
<li><code>def toString</code>: 可以打印链表中的元素</li>
</ul>
<p>根据上述要求我们写一个抽象类如下：我们要用函数式编程的思路去设计这个列表。所以添加一各元素，需要返回一个新的对象。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyList</span> </span>&#123;  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">head</span></span>: <span class="type">Int</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tail</span></span>: <span class="type">MyList</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>: <span class="type">Boolean</span></span><br><span class="line"> 	<span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(element:<span class="type">Int</span>): <span class="type">MyList</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printElements</span></span>: <span class="type">String</span></span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>: <span class="type">String</span> = <span class="string">"["</span>+printElements+<span class="string">"]"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们要实现这个列表：由于一开始新建链表的时候，肯定需要一个空链表，因此我们要创建一个Empty的对象。这里Object没必要用class, 因为我们没有创建一个Empty实例然后去调用其内部方法的需求和必要。</p>
<p>然后创建 一个Cons类，同样继承MyList，这个类需要传入两个参数，链表的头部和其他部分。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Empty</span> <span class="keyword">extends</span> <span class="title">MyList</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">head</span></span>: <span class="type">Int</span> = <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchElementException</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tail</span></span>: <span class="type">MyList</span> = <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchElementException</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(element : <span class="type">Int</span>): <span class="type">MyList</span> = <span class="keyword">new</span> <span class="type">Cons</span>(element,<span class="type">Empty</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printElements</span></span>: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cons</span>(<span class="params">head:<span class="type">Int</span>,tail:<span class="type">MyList</span></span>) <span class="keyword">extends</span> <span class="title">MyList</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">head</span></span>: <span class="type">Int</span> = head;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tail</span></span>: <span class="type">MyList</span> = tail;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>: <span class="type">Boolean</span> = <span class="literal">false</span>; </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(element:<span class="type">Int</span>):<span class="type">MyList</span> = <span class="keyword">new</span> <span class="type">Cons</span>(element,<span class="keyword">this</span>)</span><br><span class="line">  <span class="comment">//这是一个递归，每次只打印一个节点的头部</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printElements</span></span>: <span class="type">String</span> = </span><br><span class="line">  	<span class="keyword">if</span> (t.isEmpty)<span class="string">""</span>+h</span><br><span class="line">  	<span class="keyword">else</span> h+<span class="string">" "</span>+t.printElements </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">1</span>,<span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">3</span>,<span class="type">Empty</span>))) <span class="comment">// 1,2,3</span></span><br><span class="line">println(list.tail.head)			<span class="comment">// 2</span></span><br><span class="line">println(list.add(<span class="number">4</span>).head)   <span class="comment">// 4</span></span><br><span class="line">println(list.isEmpty)       <span class="comment">// false</span></span><br><span class="line">println(list.toString) 			<span class="comment">// [1 2 3]</span></span><br></pre></td></tr></table></figure>
<h3 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h3><p>现在来谈谈scala中的泛型类，这一块比较难</p>
<p>泛型类使用中括号 <code>[]</code> 接收类型参数，虽然类型参数可以是任何名字，但是一个惯例是使用字母 <code>A</code> 作为类型参数标识符。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如说我定义一个MyList的泛型类：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">	<span class="comment">// use the type A</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型类不一定只有一个参数,比如说我创建一个映射类，Key可以使一个数据类型，Value则可是另一种数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMap</span>[<span class="type">Key</span>,<span class="type">Value</span>]</span></span><br></pre></td></tr></table></figure>
<p>这个MyList泛型类使用A作为类型参数。这意味着这个 MyList[A] 只能存储类型为A的元素。因此，我可以创建一个字符串类型的列表，一个整数类型的列表：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listOfIntegers = <span class="keyword">new</span> <span class="type">MyList</span>[<span class="type">Int</span>]</span><br><span class="line"><span class="keyword">val</span> listOfStrings = <span class="keyword">new</span> <span class="type">MyList</span>[<span class="type">String</span>]</span><br></pre></td></tr></table></figure></p>
<p> 然后我们来说说泛型方法：泛型方法就是接收了泛型参数的方法，如下</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generic methods</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyList</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">empty</span></span>[<span class="type">A</span>]: <span class="type">MyList</span>[<span class="type">A</span>] = ??? <span class="comment">//这是一个静态方法，返回MyList[A]</span></span><br><span class="line">  <span class="comment">// ??? 是TODO的意思，这里只讲语法，因此不表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//比如我要创建一个空的存放整数类型的list，可以这样写：</span></span><br><span class="line"><span class="keyword">val</span> emptyListOfIntegers = <span class="type">MyList</span>.empty[<span class="type">Int</span>]</span><br></pre></td></tr></table></figure>
<h4 id="variance-problem"><a href="#variance-problem" class="headerlink" title="variance problem"></a>variance problem</h4><p>现在我们来讨论一下泛型中多样化的问题</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span></span><br></pre></td></tr></table></figure>
<p>我们来看，Cat是Animal的子类，Dog也是Animal的子类，那么，<code>MyList[Cat]</code>是不是<code>MyList[Animal]</code>的子类</p>
<p>我们有三种推测</p>
<ul>
<li><code>MyList[Cat]</code>是 <code>MyList[Animal]</code>的子类, 即  <code>List[Cat] extends List[Animal]</code>，二者 Covariance(协变)</li>
<li><code>MyList[Cat]</code>不是<code>MyList[Animal]</code>的子类，即 二者 Invariance(不可变)</li>
<li><code>MyList[Cat]</code>反而要比<code>MyList[Animal]</code>更高一级，是<code>MyList[Animal]</code>的父类，即二者 Contravariance(逆变)</li>
</ul>
<p>在scala中，这三种方法其实都可以实现，但是需要不同的符号：用加号表示为协变，减号表示逆变，如: </p>
<ul>
<li><p>Convariance : 参数类型前面需要有一个<code>+</code> 。如果是类型是协变的，那么我们可以用一个<code>ConvarianceList[Cat]</code> 去替换<code>ConvariantList[Animal]</code> ，说明Cat是Animal的子集</p>
<p><strong>那么这时候其实出了一个大问题</strong>：我们能不能加其他类型的动物进去？<code>animalList.add(new Dog)</code>合法吗？按照道理来说，Dog属于Animal，添加到animalList中是没有逻辑上的问题的，但是显然会污染一个cat类型的animallist。 如果我们要创建一个convariant的类，就必须解决这个问题——我们学完bounded types就知道了。</p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConvarianceList</span>[+<span class="type">A</span>]</span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">animal</span> </span>: <span class="type">Animal</span> = <span class="keyword">new</span> <span class="type">Cat</span></span><br><span class="line"><span class="keyword">val</span> animalList: <span class="type">ConvariantList</span>[<span class="type">Animal</span>] = <span class="keyword">new</span> <span class="type">ConvarianceList</span>[<span class="type">Cat</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>Invariance ：在scala中，什么符号都不加就是Invariance。在这种情况下，<code>InvariantList[Animal]</code> 只能对应 Animal类型</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invariant</span>[<span class="type">A</span>]</span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">invariantAnimalList</span></span>: <span class="type">InvariantList</span>[<span class="type">Animal</span>] = <span class="keyword">new</span> <span class="type">InvariantList</span>[<span class="type">Animal</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Contravariance: 参数类型前面需要有一个<code>-</code>， 这是最难以理解的，特别是如果我们还以列表为例的话——那么只能写成<code>InvariantList[cat] = new InvariantList[Animal]</code>，我们用Animal可以去替换Cat，说明Animal是Cat的一个子类<strong>，语法上没问题但是逻辑上有问题</strong>。为了方便理解，我们可以重新设计一个类Trainer</p>
<p>这样的话，<strong>一个动物训练师当然可以替换一个猫咪训练师，因为动物训练师可以训练所有动物</strong>，也包括猫。从这个角度上来看 逆变关系比较好理解。<strong>但是从动物训练师是猫咪训练师的一个子类来理解，就比较奇怪了。</strong></p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">contravariantTrainer</span>[-<span class="type">A</span>]</span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">contravariantTrainer</span>[cat] </span>= <span class="keyword">new</span> contravariantTrainer[<span class="type">Animal</span>]</span><br></pre></td></tr></table></figure>
<h4 id="bounded-types"><a href="#bounded-types" class="headerlink" title="bounded types"></a>bounded types</h4><p>在Scala中，类型界限是对类型参数或类型变量的限制。 通过使用类型边界，我们可以定义类型变量的限制。</p>
<ul>
<li>上界：这里<strong>T是类型参数</strong>，而<strong>S是类型</strong>。 通过将“上界”声明为“ <strong>[T &lt;：S]</strong> ”，表示此类型<strong>参数T必须与S相同或S的子类型</strong>。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里，我们要求Cage中的输入参数必须是Animal的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cage</span>[<span class="type">A</span> &lt;: <span class="type">Animal</span>](<span class="params">animal: <span class="type">A</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">因此，我们将Dog作为参数是合法的</span></span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">cage</span> </span>= <span class="keyword">new</span> <span class="type">Cage</span>(<span class="keyword">new</span> <span class="type">Dog</span>)</span><br></pre></td></tr></table></figure>
<p>我们看到，如果是另外一个不是animal的子类，我们就没有办法将其放到Cage里面，因为Cage有类型限制</p>
<p><img src="/2022/04/28/scala%E5%88%9D%E8%AF%86/3.png"></p>
<ul>
<li>下界：这里<strong>T是类型参数，而S是类型</strong>。 通过将“下界”声明为“ <strong>[T&gt;：S]</strong> ”，表示此类型<strong>参数T必须与S相同或为S的超类型</strong>。</li>
</ul>
<p>现在我们可以解决上面那个可不可以把Dog插入 <code>List[Cat]</code>的难题了,解决方法就是，如果我往一个List[Cat]里面插入Dog，就会返回一个 <code>List[Animal]</code> ，也就是说把类型更泛化一个级别</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>[+<span class="type">A</span>] </span>&#123; </span><br><span class="line">  <span class="comment">//要实现以上功能，我们可以用到下界符号，当与A同类型或者超类要加入到MyList[A]中，就会返回MyList[B]</span></span><br><span class="line">  <span class="comment">//那么如果添加一个Dog，就会返回一个MyList[Animal]</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(<span class="type">B</span> &gt;:<span class="type">A</span>)(element:<span class="type">B</span>): <span class="type">MyList</span>[<span class="type">B</span>] = ???</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们对之前写的MyList进行修改：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyList</span>[+<span class="type">A</span>] </span>&#123; <span class="comment">//将MyList改为泛型抽象类</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">head</span></span>: <span class="type">A</span>								<span class="comment">//返回的参数从Int改为A</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tail</span></span>: <span class="type">MyList</span>[<span class="type">A</span>]				<span class="comment">//同理，返回类型为A的MyList</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>: <span class="type">Boolean</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>[<span class="type">B</span> &gt;: <span class="type">A</span>](element: <span class="type">B</span>): <span class="type">MyList</span>[<span class="type">B</span>] <span class="comment">//在add设置下界</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printElements</span></span>: <span class="type">String</span></span><br><span class="line">  <span class="comment">// polymorphic call</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>: <span class="type">String</span> = <span class="string">"["</span> + printElements + <span class="string">"]"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//由于这里返回的是一个Exception,而Empty里面没有任何类型的数据，因此将Empty对象继承自MyList[Nothing]</span></span><br><span class="line"><span class="comment">//因为Nothing是任何类的子类，因此可以用Nothing来替换之前的Int</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Empty</span> <span class="keyword">extends</span> <span class="title">MyList</span>[<span class="type">Nothing</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">head</span></span>: <span class="type">Nothing</span> = <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchElementException</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tail</span></span>: <span class="type">MyList</span>[<span class="type">Nothing</span>] = <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchElementException</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line">  <span class="comment">//这里也要将函数改为下界，B &gt;: Nothing，返回一个MyList[B]</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>[<span class="type">B</span> &gt;: <span class="type">Nothing</span>](element: <span class="type">B</span>): <span class="type">MyList</span>[<span class="type">B</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(element, <span class="type">Empty</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printElements</span></span>: <span class="type">String</span> = <span class="string">""</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cons</span>[+<span class="type">A</span>](<span class="params">head: <span class="type">A</span>, tail: <span class="type">MyList</span>[<span class="type">A</span>]</span>) <span class="keyword">extends</span> <span class="title">MyList</span>[<span class="type">A</span>] <span class="title">/*注意这里只能是</span>[<span class="type">A</span>],<span class="title">不能是</span>[+<span class="type">A</span>]<span class="title">*/</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">head</span></span>: <span class="type">A</span> = h</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tail</span></span>: <span class="type">MyList</span>[<span class="type">A</span>] = t</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>: <span class="type">Boolean</span> = <span class="literal">false</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>[<span class="type">B</span> &gt;: <span class="type">A</span>](element: <span class="type">B</span>): <span class="type">MyList</span>[<span class="type">B</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(element, <span class="keyword">this</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printElements</span></span>: <span class="type">String</span> =</span><br><span class="line">    <span class="keyword">if</span>(t.isEmpty) <span class="string">""</span> + h</span><br><span class="line">    <span class="keyword">else</span> <span class="string">s"<span class="subst">$h</span> <span class="subst">$&#123;t.printElements&#125;</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试如下：</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ListTest</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> listOfIntegers: <span class="type">MyList</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">1</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">3</span>, <span class="type">Empty</span>)))</span><br><span class="line">  <span class="keyword">val</span> listOfStrings: <span class="type">MyList</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="string">"Hello"</span>,<span class="keyword">new</span> <span class="type">Cons</span>(<span class="string">"scala"</span>,<span class="type">Empty</span>)) </span><br><span class="line">  println(listOfStrings.toString) <span class="comment">//[Hello scala]</span></span><br><span class="line">  println(listOfIntegers.toString)<span class="comment">//[1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Anonymous-Classes"><a href="#Anonymous-Classes" class="headerlink" title="Anonymous Classes"></a>Anonymous Classes</h3><p> <strong>匿名类：</strong>也就是没有命名的类. 对于一个类的子类，如果我们只需要实现其一次(创建一个实例), 我们就可以使用匿名类</p>
<p>首先我们来看不使用匿名类的写法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先创建一个抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>: <span class="type">Unit</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//然后创建抽象类的一个子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnonymousClasses$$anon$1</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>: <span class="type">Unit</span> = println(<span class="string">"ahahahahahaah"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最后为这个子类创建一个实例</span></span><br><span class="line"><span class="keyword">val</span> funnyAnimal: <span class="type">Animal</span> = <span class="keyword">new</span> <span class="type">AnonymousClasses</span>$$anon$<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>那么如果这个类的实例只会被创建一次，我们就没必要搞这么复杂，直接使用匿名类就可以：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>: <span class="type">Unit</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">val</span> funnyAnimal: <span class="type">Animal</span> = <span class="keyword">new</span> <span class="type">Animal</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>: <span class="type">Unit</span> = println(<span class="string">"ahahahahahaah"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匿名类不只有抽象类能使用，正常的类中也可以使用, 但是需要显式得写 override</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sayHi</span></span>: <span class="type">Unit</span> = println(<span class="string">s"Hi, my name is <span class="subst">$name</span>, how can I help?"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> jim = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"Jim"</span>) &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">sayHi</span></span>: <span class="type">Unit</span> = println(<span class="string">s"Hi, my name is Jim, how can I be of service?"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Object-Oriented-Exercises-Expanding-Our-Collection"><a href="#Object-Oriented-Exercises-Expanding-Our-Collection" class="headerlink" title="Object-Oriented Exercises : Expanding Our Collection"></a>Object-Oriented Exercises : Expanding Our Collection</h3><p>现在我们在来扩展一下之前写的MyLIst，往里面添加三个函数： map，filter 和flatmap，示例和要求如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Exercises:</span></span><br><span class="line"><span class="comment">  首先创建两个接口</span></span><br><span class="line"><span class="comment">  1.  Generic trait MyPredicate[-T] with a little method test(T) =&gt; Boolean</span></span><br><span class="line"><span class="comment">  2.  Generic trait MyTransformer[-A, B] with a method transform(A) =&gt; B</span></span><br><span class="line"><span class="comment">  然后创建三个函数</span></span><br><span class="line"><span class="comment">  3.  MyList:</span></span><br><span class="line"><span class="comment">      - map(transformer) =&gt; MyList</span></span><br><span class="line"><span class="comment">      - filter(predicate) =&gt; MyList</span></span><br><span class="line"><span class="comment">      - flatMap(transformer from A to MyList[B]) =&gt; MyList[B]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      class EvenPredicate extends MyPredicate[Int]</span></span><br><span class="line"><span class="comment">      class StringToIntTransformer extends MyTransformer[String, Int]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      [1,2,3].map(n * 2) = [2,4,6]</span></span><br><span class="line"><span class="comment">      [1,2,3,4].filter(n % 2) = [2,4]</span></span><br><span class="line"><span class="comment">      [1,2,3].flatMap(n =&gt; [n, n+1]) =&gt; [1,2,2,3,3,4]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//一个Predicate接口，用来判断是否符合条件</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">MyPredicate</span>[-<span class="type">T</span>] </span>&#123;</span><br><span class="line">  	<span class="function"><span class="keyword">def</span> <span class="title">test</span></span>(elem: <span class="type">T</span>) : <span class="type">Boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个MyTransfomer结构，用来进行类型转换</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">MyTransformer</span>[-<span class="type">A</span>,<span class="type">B</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">transform</span></span>(elem : <span class="type">A</span>): <span class="type">B</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyList</span>[+<span class="type">A</span>] </span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	...</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">  <span class="comment">//  higher-order functions</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](transformer: <span class="type">MyTransformer</span>[<span class="type">A</span>,<span class="type">B</span>]): <span class="type">MyList</span>[<span class="type">B</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(predicate: <span class="type">MyPredicate</span>[<span class="type">A</span>]): <span class="type">MyList</span>[<span class="type">A</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](transformer: <span class="type">MyTransformer</span>[<span class="type">A</span>,<span class="type">MyList</span>[<span class="type">B</span>]]): <span class="type">MyList</span>[<span class="type">B</span>]</span><br><span class="line">&#125;</span><br><span class="line">                                            </span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Empty</span> <span class="keyword">extends</span> <span class="title">MyList</span>[<span class="type">Noting</span>] </span>&#123;</span><br><span class="line">  <span class="comment">// 对一个Empty对象试行Map和filter操作，得到的肯定都是Empty本身</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](transformer: <span class="type">MyTransformer</span>[<span class="type">Nothing</span>,<span class="type">B</span>]):<span class="type">MyList</span>[<span class="type">B</span>] = <span class="type">Empty</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](tranformer:<span class="type">MyTransformer</span>[<span class="type">Nothing</span>,<span class="type">MyList</span>[<span class="type">B</span>]]):<span class="type">MyList</span>[<span class="type">B</span>] = <span class="type">Empty</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(predicate: <span class="type">MyPredicate</span>[<span class="type">Nothing</span>]): <span class="type">MyList</span>[<span class="type">Nothing</span>] =  <span class="type">Empty</span></span><br><span class="line">&#125;</span><br><span class="line">                                            </span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Cons</span>[+<span class="type">A</span>](<span class="params">h: <span class="type">A</span>, t: <span class="type">MyList</span>[<span class="type">A</span>]</span>) <span class="keyword">extends</span> <span class="title">MyList</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="comment">/* 对于List中的每一个元素，都进行predicate判定</span></span><br><span class="line"><span class="comment">  		+ 如果符合判定条件，就留下</span></span><br><span class="line"><span class="comment">		  + 否则就递归判定tail</span></span><br><span class="line"><span class="comment">		  </span></span><br><span class="line"><span class="comment">		 比如说 [1,2,3].filter(n%2 == 0)</span></span><br><span class="line"><span class="comment">		 = [2,3].filter(n%2 == 0)</span></span><br><span class="line"><span class="comment">		 = new Cons(2,[3].filter(n%2 == 0))</span></span><br><span class="line"><span class="comment">		 = new Cons(2,Empty.filter(n%2 == 0))</span></span><br><span class="line"><span class="comment">		 = new Cons(2,Empty)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(predicate: <span class="type">MyPredicate</span>[<span class="type">A</span>]) : <span class="type">MyList</span>[<span class="type">A</span>] = </span><br><span class="line">  		<span class="keyword">if</span> (predicate.test(h)) <span class="keyword">new</span> <span class="type">Cons</span>(h,t.filter(predicate))</span><br><span class="line">  		<span class="keyword">else</span> t.filter(predict)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 对于map来说，原先的列表有多长，新的列表就有多长，只不过对每个元素做了一个映射</span></span><br><span class="line"><span class="comment">  	 比如说[1,2,3].map(n*2)</span></span><br><span class="line"><span class="comment">  	  =  new Cons(2,[2,3].map(n*2))</span></span><br><span class="line"><span class="comment">  	  =  new Cons(2,new Cons(4,[3].map(n*2)))</span></span><br><span class="line"><span class="comment">  	  =  new Cons(2,new Cons(4,new Cons(6,Empty)))</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](transformer: <span class="type">MyTransformer</span>[<span class="type">A</span>,<span class="type">B</span>]):<span class="type">MyList</span>[<span class="type">B</span>] = </span><br><span class="line">  		<span class="keyword">new</span> <span class="type">Cons</span>(transformer(h),t.map(transformer))</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// flatmap比较难一些，因为列表中每个元素可能会被映射为多个元素</span></span><br><span class="line">  <span class="comment">// 因此需要我们设计一个concatenation function</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//这里用到了下界，只有相等类型或超类的列表才能连接起来，比如:</span></span><br><span class="line">  <span class="comment">/* [1,2] ++ [3,4,5]</span></span><br><span class="line"><span class="comment">  =  new Cons(1,[2]++[3,4,5])</span></span><br><span class="line"><span class="comment">  =	 new Cons(1,new Cons(2,Empty++[3,4,5]))</span></span><br><span class="line"><span class="comment">  =  new Cons(1,new Cons(2, new Cons(3,new Cons(4, new Cons(5)))))</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">++</span></span>[<span class="type">B</span> &gt;: <span class="type">A</span>](list: <span class="type">MyList</span>[<span class="type">B</span>]): <span class="type">MyList</span>[<span class="type">B</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(h, t ++ list)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*然后我们就可以写flatmap函数了</span></span><br><span class="line"><span class="comment">  比如说：[1,2].flatmap(n =&gt; [3n,4n])</span></span><br><span class="line"><span class="comment">  = [3,4] ++ [2].flatMap(n =&gt; [3n,4n])</span></span><br><span class="line"><span class="comment">  = [3,4] ++ [6,8] ++ Empty.flatmap(n =&gt; [n,n+1])</span></span><br><span class="line"><span class="comment">  = [3,4,6,8]</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](transformer: <span class="type">MyTransformer</span>[<span class="type">A</span>,<span class="type">MyList</span>[<span class="type">B</span>]]): <span class="type">MyList</span>[<span class="type">B</span>] = </span><br><span class="line">      transformer.transform(h)++t.flatMap(transformer)</span><br><span class="line">&#125;</span><br><span class="line">                                            </span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ListTest</span> <span class="keyword">extends</span> <span class="title">App</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> listOfIntegers: <span class="type">MyList</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">1</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">3</span>, <span class="type">Empty</span>)))</span><br><span class="line">  <span class="keyword">val</span> anatherListOfIntegers: <span class="type">MyList</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">4</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">5</span>, <span class="type">Empty</span>))</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//[2]</span></span><br><span class="line">  println(listOfIntegers.filter(<span class="keyword">new</span> <span class="type">MyPredicate</span>[<span class="type">Int</span>]&#123;</span><br><span class="line">    	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">test</span></span>(elem : <span class="type">Int</span>): <span class="type">Boolean</span> = elem % <span class="number">2</span> == <span class="number">0</span><span class="comment">// elem % 2==0 是一个表达式</span></span><br><span class="line">  &#125;))</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//[2,4,6]</span></span><br><span class="line">  println(listOfIntegers.map(<span class="keyword">new</span> <span class="type">MyTransformer</span>[<span class="type">Int</span>,<span class="type">Int</span>]&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">transform</span></span>(elem: <span class="type">Int</span>): <span class="type">Int</span> = elem*<span class="number">2</span></span><br><span class="line">  &#125;))</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//[1,2,3,4,5]</span></span><br><span class="line">  println((listOfIntegers ++ anotherListOfIntegers).toString)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//[1,2,2,3,3,4]</span></span><br><span class="line">  println(listOfIntegers.flatMap(<span class="keyword">new</span> <span class="type">MyTransformer</span>[<span class="type">Int</span>,<span class="type">MyList</span>[<span class="type">Int</span>]]&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">transform</span></span>(elem: <span class="type">Int</span>): <span class="type">MyList</span>[<span class="type">Int</span>] = </span><br><span class="line">    				 <span class="keyword">new</span> <span class="type">Cons</span>(elem,<span class="keyword">new</span> <span class="type">Cons</span>(elem+<span class="number">1</span>,<span class="type">Empty</span>)).toString <span class="comment">//返回一个新的MyList</span></span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Case-Classes"><a href="#Case-Classes" class="headerlink" title="Case Classes"></a>Case Classes</h3><p>case class是scala中的一种更强大的创建类的方式。它不仅拥有普通class的功能，又有很多内建方法，不用我们自己去实现。</p>
<p>比如说我创建一个case class如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>,age: <span class="type">Int</span></span>)</span></span><br></pre></td></tr></table></figure>
<p>现在来一一介绍case class的一些特性</p>
<ul>
<li>类的构造参数默认是类内成员</li>
<li>初始化的时候可以不用new，也可以加上，但是普通类必须加new</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> jim = <span class="type">Person</span>(<span class="string">"Jim"</span>,<span class="number">34</span>)<span class="comment">//初始化的时候可以不用new</span></span><br><span class="line">println(jim.name)<span class="comment">//这对于case class是合法的，因为name是类内成员；而对于普通class则无法编译</span></span><br></pre></td></tr></table></figure>
<ul>
<li>toString的实现更漂亮</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">println(jim)<span class="comment">//Person(Jim,34) 我们看到直接打印case class的实例很直观的显示Person的参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果不加case的class，直接打印实例则是返回哈希字符串*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">noCasePerson</span>(<span class="params">name: <span class="type">String</span>,age:<span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">nocaseJim</span> </span>= <span class="keyword">new</span> noCasePerson(<span class="string">"Jim"</span>,<span class="number">34</span>)<span class="comment">//初始化必然要 new</span></span><br><span class="line">println(nocaseJim)<span class="comment">//lectures.part2oop.CaseClasses$noCasePerson@7a0ac6e3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>默认实现了equals 和hashCode；</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*在case class中，如果两个类参数相等，那么会默认判定这两个类是相等的(内置了equals方法)*/</span></span><br><span class="line"><span class="keyword">val</span> jim2 = <span class="type">Person</span>(<span class="string">"Jim"</span>,<span class="number">34</span>)</span><br><span class="line">println(jim = jim2)<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*但是在class中，则会返回false，因为这是两个实例*/</span></span><br><span class="line"><span class="keyword">val</span> nocaseJim2 = <span class="keyword">new</span> noCasePerson(<span class="string">"Jim"</span>,<span class="number">34</span>)</span><br><span class="line">println(nocaseJim = nocaseJim2) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>case class 实现了 copy方法</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> jim3 = jim.copy()<span class="comment">//创建一个和jim一模一样的实例</span></span><br><span class="line"><span class="keyword">val</span> jim4 = jim.copy(age = <span class="number">45</span>)<span class="comment">//创建一个除了age不同，其余都和jim一模一样的实例</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Case class 在创建时同时创建了companion object(伴生对象)，同时在里面给我们实现子apply方法，使得我们在使用的时候可以不直接显示地new对象；</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> thePerson = <span class="type">Person</span><span class="comment">//合法，这里的Person是case class Person的伴生对象</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>Case Class 可以序列化(Serializable)</p>
</li>
<li><p>Case Class  可以用于模式匹配，这是case class最重要的特性关于模式识别是什么，我们最后一章会学</p>
</li>
<li>除了Case Class之外，还有Case Object，其主要特性和Case Class相同，但不会创建伴生对象——因为他们自己就是自己的伴生对象</li>
</ul>
<h3 id="Scala-3-Enums"><a href="#Scala-3-Enums" class="headerlink" title="Scala 3: Enums"></a>Scala 3: Enums</h3><p>现在我们来说说Scala中的枚举类，枚举类是Scala3中的新语法</p>
<h4 id="基础定义"><a href="#基础定义" class="headerlink" title="基础定义"></a>基础定义</h4><p>首先我们可以给出一个最基本的枚举类的定义，我们可以将scala中的enum理解为一中数据类型，case后面的是该类型可选的值</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="type">Permissions</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">READ</span>,<span class="type">WRITE</span>,<span class="type">EXECUTE</span>,<span class="type">NONE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> somePermissions : <span class="type">Permissions</span> = <span class="type">Permissions</span>.<span class="type">READ</span></span><br></pre></td></tr></table></figure>
<h4 id="Enum中也可以有函数"><a href="#Enum中也可以有函数" class="headerlink" title="Enum中也可以有函数"></a>Enum中也可以有函数</h4><p>在Enum中也可以定义函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="type">Permissions</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">READ</span>,<span class="type">WRITE</span>,<span class="type">EXECUTE</span>,<span class="type">NONE</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">openDocument</span></span>():<span class="type">Unit</span> =</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == <span class="type">READ</span> || <span class="keyword">this</span> == <span class="type">WRITE</span>) println(<span class="string">"opening document"</span>)</span><br><span class="line">    <span class="keyword">else</span> println(<span class="string">"reading not allowed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> somePermissions: <span class="type">Permissions</span> = <span class="type">Permissions</span>.<span class="type">READ</span></span><br><span class="line">  somePermissions.openDocument()<span class="comment">// opening document</span></span><br></pre></td></tr></table></figure>
<h4 id="constructor-args"><a href="#constructor-args" class="headerlink" title="constructor args"></a>constructor args</h4><p>Enum也可以接收参数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="type">Color</span>(<span class="keyword">val</span> rgb: <span class="type">Int</span>)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Red</span>   <span class="keyword">extends</span> <span class="type">Color</span>(<span class="number">0xFF0000</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Green</span> <span class="keyword">extends</span> <span class="type">Color</span>(<span class="number">0x00FF00</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Blue</span>  <span class="keyword">extends</span> <span class="type">Color</span>(<span class="number">0x0000FF</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="type">Color</span>.<span class="type">Red</span>.rgb) <span class="comment">// 255 (即0xFF0000)</span></span><br></pre></td></tr></table></figure>
<h4 id="companion-objects"><a href="#companion-objects" class="headerlink" title="companion objects"></a>companion objects</h4><p>我们可以为Enum创建伴生对象：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Color</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">fromRGB</span></span>(<span class="keyword">val</span> rgb : <span class="type">Int</span>) :  <span class="type">Color</span> = ??? <span class="comment">//写从RGB到Color的逻辑(if-else)，这里略去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Enum的一些标准接口"><a href="#Enum的一些标准接口" class="headerlink" title="Enum的一些标准接口"></a>Enum的一些标准接口</h4><ul>
<li><code>Enum.ordinal</code>, 通过ordinal可以返回某个枚举值在类中的index，比如：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">al somePermissions: <span class="type">Permissions</span> = <span class="type">Permissions</span>.<span class="type">READ</span> </span><br><span class="line"><span class="comment">// Read在Perssions中的index 是 0 ，因此 somePermissions.ordinal = 0</span></span><br><span class="line"><span class="keyword">val</span> somPermissionsOrdinal = somePermissions.ordinal</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Enum.values</code> 可以以数组的方式返回Enums中的所有值</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">Permissions</span>.values.mkString(<span class="string">"Array("</span>, <span class="string">", "</span>, <span class="string">")"</span>))</span><br><span class="line"><span class="comment">//Array(READ, WRITE, EXECUTE, NONE)</span></span><br><span class="line">println(<span class="type">Color</span>.values.mkString(<span class="string">"Array("</span>, <span class="string">", "</span>, <span class="string">")"</span>) )</span><br><span class="line"><span class="comment">//Array(Red, Green, Blue)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>Enum.valueOf</code> 这个方法感觉有点鸡肋..</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">Color</span>.valueOf(<span class="string">"Blue"</span>)) <span class="comment">// Color.Blue </span></span><br><span class="line">println(<span class="type">Permissions</span>.valueOf(<span class="string">"READ"</span>)) <span class="comment">// Permissions.READ</span></span><br></pre></td></tr></table></figure>
<p>有了case class，我们可以让MyList的功能变得更加强大。</p>
<ul>
<li>首先有了equals方法，可以方便的比较两个List的元素是否相等</li>
<li>能序列化，使得在分布式系统中更加方便操作</li>
</ul>
<h3 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h3><p>现在来学习scala中的异常处理。首先来分辨一下Error和Exception的区别：</p>
<ul>
<li><p>Error 是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。既然是非正常情况，<strong>所以不便于也不需要捕获</strong>，常见的比如 OutOfMemoryError , StackOverFlowError, 都是 Error 的子类。</p>
</li>
<li><p>Exception 是程序正常运行中，可以预料的意外情况，<strong>可能并且应该被捕获</strong>，进行相应处理。Exception 又分为可检查（checked）异常和不检查（unchecked）异常【即运行时异常】，可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。</p>
<ul>
<li>检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li>
<li>运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常<strong>可以在编译时被忽略</strong>，类似 NullPointerException、ArrayIndexOutOfBoundsException 之类，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。</li>
</ul>
</li>
</ul>
<p>在JVM中，Exception和Error都继承了Throwable类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。</p>
<h4 id="throw-catch"><a href="#throw-catch" class="headerlink" title="throw-catch"></a>throw-catch</h4><ul>
<li>首先来说怎么抛出一个异常：</li>
</ul>
<p>要知道  <code>throw new NullPointerException</code> 也是一个表达式，返回一个Nothing, 所以我们可以用String类型接收它，因为Nothing是任何类的子类</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aWeirdValue: <span class="type">String</span> = <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NullPointerException</span> <span class="comment">// also crashes</span></span><br></pre></td></tr></table></figure>
<ul>
<li>然后我们来说怎么catch一个异常</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getInt</span></span>(withExceptions: <span class="type">Boolean</span>): <span class="type">Int</span> =</span><br><span class="line">  <span class="keyword">if</span> (withExceptions) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">"No int for you!"</span>)</span><br><span class="line">  <span class="keyword">else</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> potentialFail = <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 调用getInt函数，导致其抛出一个异常</span></span><br><span class="line">  getInt(<span class="literal">true</span>) </span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="comment">// catch一个RuntimeException的异常的话，就打印</span></span><br><span class="line">  <span class="comment">// 如果getInt抛出的是一个NullPointerException的话，虽然有try-catch，还是会报错</span></span><br><span class="line">  <span class="keyword">case</span> e: <span class="type">RuntimeException</span> =&gt;  println(<span class="string">"caught a runtime exception"</span>)</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// finally和java中一样，无论怎么样都会执行，可写可不写</span></span><br><span class="line">  <span class="comment">// finally不会影响代码块的返回值类型</span></span><br><span class="line">  <span class="comment">// use finally only for side effects</span></span><br><span class="line">  println(<span class="string">"finally"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(potentialFail)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/28/scala%E5%88%9D%E8%AF%86/5.png"></p>
<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>scala中自定义异常也非常容易，只需要让其继承某一异常类即可</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  1.  Crash your program with an OutOfMemoryError</span></span><br><span class="line"><span class="comment">  2.  Crash with SOError</span></span><br><span class="line"><span class="comment">  3.  PocketCalculator</span></span><br><span class="line"><span class="comment">      - add(x,y)</span></span><br><span class="line"><span class="comment">      - subtract(x,y)</span></span><br><span class="line"><span class="comment">      - multiply(x,y)</span></span><br><span class="line"><span class="comment">      - divide(x,y)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Throw</span></span><br><span class="line"><span class="comment">        - OverflowException if add(x,y) exceeds Int.MAX_VALUE</span></span><br><span class="line"><span class="comment">        - UnderflowException if subtract(x,y) exceeds Int.MIN_VALUE</span></span><br><span class="line"><span class="comment">        - MathCalculationException for division by 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先我们要创建一些自定义异常类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OverflowException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span>(<span class="params">"<span class="type">Overflow</span>"</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">UnderflowException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span>(<span class="params">"<span class="type">Underflow</span>"</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">MathCalculationException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span>(<span class="params">"<span class="type">Division</span> by 0"</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">然后我们构造简易的计算器</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">object</span> <span class="title">PocketCalculator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x: <span class="type">Int</span>,y:<span class="type">Int</span>) = &#123;</span><br><span class="line">    <span class="keyword">val</span> result = x + y</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span> &amp;&amp; x+y &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">OverFlowException</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span> &amp;&amp; x+y &gt; <span class="number">0</span> ) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UnderFlowException</span></span><br><span class="line">    <span class="keyword">else</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">substract</span></span>(x: <span class="type">Int</span>,y:<span class="type">Int</span>) = &#123;</span><br><span class="line">      <span class="keyword">val</span> result = x - y</span><br><span class="line">      <span class="keyword">if</span>(x &gt; <span class="number">0</span> &amp;&amp; y&lt;<span class="number">0</span> &amp;&amp; x-y &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">OverFlowException</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span> &amp;&amp; x-y &gt; <span class="number">0</span> ) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UnderFlowException</span></span><br><span class="line">      <span class="keyword">else</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">multiply</span></span>(x: <span class="type">Int</span>,y:<span class="type">Int</span>) = &#123;</span><br><span class="line">      <span class="keyword">val</span> result = x * y</span><br><span class="line">      <span class="keyword">if</span>(x &gt; <span class="number">0</span> &amp;&amp; y&gt; <span class="number">0</span> &amp;&amp; x*y &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">OverFlowException</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(x &gt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span> &amp;&amp; x*y &gt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UnderFlowException</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span> &amp;&amp; x*y &lt; <span class="number">0</span> ) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">OverFlowException</span></span><br><span class="line">     	<span class="keyword">else</span> <span class="keyword">if</span>(x &lt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span> &amp;&amp; x*y &gt; <span class="number">0</span> ) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UnderFlowException</span></span><br><span class="line">      <span class="keyword">else</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">divide</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) = &#123;</span><br><span class="line">      <span class="keyword">if</span> (y == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">MathCalculationException</span></span><br><span class="line">      <span class="keyword">else</span> x / y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后我们测试</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> calculatorFail = <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="type">PocketCalculator</span>.add(<span class="type">Int</span>.<span class="type">MaxValue</span>, <span class="number">10</span>)</span><br><span class="line">  &#125;<span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> e: <span class="type">OverflowException</span> =&gt; println(<span class="string">"OverflowException"</span>)</span><br><span class="line">    <span class="keyword">case</span> e: <span class="type">UnderflowException</span> =&gt; println(<span class="string">"UnderflowException"</span>)</span><br><span class="line">    <span class="keyword">case</span> e: <span class="type">MathCalculationException</span> =&gt; println(<span class="string">"MathCalculationException"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// OverflowException</span></span><br></pre></td></tr></table></figure>
<h3 id="Packaging-and-Imports"><a href="#Packaging-and-Imports" class="headerlink" title="Packaging and Imports"></a>Packaging and Imports</h3><h2 id="Functional-Programming-in-Scala"><a href="#Functional-Programming-in-Scala" class="headerlink" title="Functional Programming in Scala"></a>Functional Programming in Scala</h2><h3 id="What’s-a-Function-Really"><a href="#What’s-a-Function-Really" class="headerlink" title="What’s a Function, Really"></a>What’s a Function, Really</h3><p>我们要学习scala中的函数式编程特性，就先要弄明白函数式编程是什么。</p>
<p>函数式编程中的函数指的并不是编程语言中的函数（或方法），它指的是数学意义上的函数，即映射关系（如：y = f(x)），就是 y 和 x 的对应关系。</p>
<h4 id="函数式编程的特性"><a href="#函数式编程的特性" class="headerlink" title="函数式编程的特性"></a>函数式编程的特性</h4><ol>
<li><p>函数是一等公民，它的意思就是函数与其他数据类型一样，可以把它们存在数组里，当做参数传递，赋值给变量，可以在任何地方定义，在函数内或函数外，可以作为函数的参数和返回值，也可以对函数进行组合。</p>
</li>
<li><p>高阶函数(Higher Order Function, HOF)，在函数式编程中， 高阶函数的定义是把其它函数当做参数，或者返回一个函数作为结果的函数。</p>
</li>
<li><p><strong>柯里化</strong>，就是把一个多参数的函数 f，转换为单参数函数 g，并且这个函数的返回值也是一个函数。</p>
</li>
<li><p>Side Effects，所谓“副作用”，指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。<br>   在像 C++ 这样的命令式语言中，函数的意义与数学函数完全不同。例如，假设我们有一个 C++ 函数，它接受一个浮点参数并返回一个浮点结果。从表面上看它可能看起来有点像数学函数意义上的映射实数成实数，但是 C++ 函数可以做的不仅仅是返回一个取决于其参数的数字，它还可以读写其他的全局变量，也可将将输出写入屏幕并接收来自用户的输入。但是，在纯函数式语言中，函数只能读取其参数提供给它的内容，并且它对世界产生影响的唯一方式就是通过它返回的值。</p>
</li>
<li><p>纯函数，纯函数编程和函数编程的区别在于：是否允许在函数内部执行一些非函数式的操作，同时这些操作是否会暴露给系统中的其他地方？也就是是否存在副作用。如果不存在副作用，或者说可以不用在意这些副作用，那么就将其称为纯粹的函数式编程。</p>
</li>
<li><p>引用透明性，函数无论在何处、何时调用，如果使用相同的输入总能持续地得到相同的结果，就具备了函数式的特征。这种不依赖外部变量或“状态”，只依赖输入的参数的特性就被称为引用透明性（referential transparency）。“没有可感知的副作用”（比如不改变对调用者可见的变量，进行I/O，不抛出异常等）的这些限制都隐含着引用透明性</p>
</li>
<li>递归和迭代，对于函数式而言，循环体有一个无法避免的副作用，就是它会修改某些对象的状态，通常这些对象又是和其他部分共享的。而且也因为变量值是不可变的，纯函数编程语言也无法实现循环。所以纯函数编程语言通常不包含像 while 和 for 这样的迭代构造器，而是采用的无需修改的递归。 </li>
</ol>
<h4 id="function-value"><a href="#function-value" class="headerlink" title="function value"></a>function value</h4><p>Scala编译后是要放到JVM上运行的，其实本质上是一个面向对象的编程语言。但是为了让他可以实现函数式编程，就需要对其方法(method)做一定的包装(变为函数)。因此，我们要理解——在scala里面，函数和方法是两个不同的概念。</p>
<ul>
<li>函数接口是 FunctionN(N可以是1,2,3…代表接收的参数个数) ，将其理解为一个<strong>实体</strong>，在实体中包装了一个<strong>行为方式</strong>，写在了其apply方法里</li>
<li>方法是 Method(在实体中用def定义)，将其理解为一种行为方式，这个行为方式可以通过转换来包装成一个FunctionN实体</li>
</ul>
<p>比如说，我想创建一个函数，它可以将字符串转移成数字，那么显然它接受1个参数，并返回一个Int类型的值。那么此时我需要用到Function1接口:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stringToIntConverter 接收String类型的参数，返回 Int类型的值</span></span><br><span class="line"><span class="keyword">val</span> stringToIntConverter = <span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">String</span>, <span class="type">Int</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(string: <span class="type">String</span>): <span class="type">Int</span> = string.toInt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(stringToIntConverter(<span class="string">"3"</span>) + <span class="number">4</span>) <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<p>Function1接口的源码如下：我们看到，其内部只有一个apply函数，之前我们学过，在一个对象后面加上<code>()</code>,编译器就会自动调用该类中的apply函数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@annotation</span>.implicitNotFound(msg = <span class="string">"No implicit view available from $&#123;T1&#125; =&gt; $&#123;R&#125;."</span>)</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Function1</span>[@specialized(<span class="type">Specializable</span>.<span class="type">Arg</span>) -<span class="type">T1</span>, @specialized(<span class="type">Specializable</span>.<span class="type">Return</span>) +<span class="type">R</span>] <span class="keyword">extends</span> <span class="title">AnyRef</span> </span>&#123; self =&gt;</span><br><span class="line">  <span class="comment">/** Apply the body of this function to the argument.</span></span><br><span class="line"><span class="comment">   *  @return   the result of function application.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(v1: <span class="type">T1</span>): <span class="type">R</span></span><br></pre></td></tr></table></figure>
<p>再比如说，我想创建一个函数，它可以实现两个Int值相加，那么此时我需要用Function2接口</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">val</span> adder = <span class="keyword">new</span> <span class="type">Function2</span>[<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>] &#123;</span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Int</span> = a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h4><p>事实上，我们在创建函数的时候，  <code>Function2[A,B,R]</code> 与 <code>(A,B) =&gt; R</code>是等价的，因此为了简介，我们也可以直接这样写：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> adder: ((<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span>) = <span class="keyword">new</span> <span class="type">Function2</span>[<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Int</span> = a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是感觉比原来更复杂了，我们接下来学习匿名函数的时候会对其做一个简化</p>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><ul>
<li>write  a function which takes 2 strings and concatenates them</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> concatenator:((<span class="type">String</span>,<span class="type">String</span>) =&gt; <span class="type">String</span> ) = <span class="keyword">new</span> <span class="type">Function2</span>[<span class="type">Int</span>,<span class="type">Int</span>,<span class="type">Int</span>]&#123;</span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span> </span>(a:<span class="type">String</span>, b:<span class="type">String</span>): <span class="type">String</span> = a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>transform the MyPredicate and MyTransformer into function types</li>
</ul>
<p>要对MyList中的MyPredicate和MyTransformer做一个改造，使其成为function types. 事实上，我们可以直接删去这两个接口</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> exercises</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyList</span>[+<span class="type">A</span>] </span>&#123; </span><br><span class="line">  <span class="comment">//主要改这三个函数</span></span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">   我们要把圈来的 Mytransformer接口和MyPredicate接口改成函数式接口，可以是 Function1[A,B]</span></span><br><span class="line"><span class="comment">   但是为了更加直观，我们可以将其直接写为 A =&gt; B</span></span><br><span class="line"><span class="comment">   higher-order functions</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](transformer: <span class="type">Function1</span>[<span class="type">A</span>,<span class="type">B</span>]): <span class="type">MyList</span>[<span class="type">B</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](transformer: <span class="type">A</span> =&gt; <span class="type">MyList</span>[<span class="type">B</span>]): <span class="type">MyList</span>[<span class="type">B</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(predicate: <span class="type">A</span> =&gt; <span class="type">Boolean</span>): <span class="type">MyList</span>[<span class="type">A</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Empty</span> <span class="keyword">extends</span> <span class="title">MyList</span>[<span class="type">Nothing</span>] </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](transformer: <span class="type">Nothing</span> =&gt; <span class="type">B</span>): <span class="type">MyList</span>[<span class="type">B</span>] = <span class="type">Empty</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](transformer: <span class="type">Nothing</span> =&gt; <span class="type">MyList</span>[<span class="type">B</span>]): <span class="type">MyList</span>[<span class="type">B</span>] = <span class="type">Empty</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(predicate: <span class="type">Nothing</span> =&gt; <span class="type">Boolean</span>): <span class="type">MyList</span>[<span class="type">Nothing</span>] = <span class="type">Empty</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Cons</span>[+<span class="type">A</span>](<span class="params">h: <span class="type">A</span>, t: <span class="type">MyList</span>[<span class="type">A</span>]</span>) <span class="keyword">extends</span> <span class="title">MyList</span>[<span class="type">A</span>] </span>&#123; </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(predicate: <span class="type">A</span> =&gt; <span class="type">Boolean</span>): <span class="type">MyList</span>[<span class="type">A</span>] =</span><br><span class="line">    <span class="keyword">if</span> (predicate(h)) <span class="keyword">new</span> <span class="type">Cons</span>(h, t.filter(predicate))</span><br><span class="line">    <span class="keyword">else</span> t.filter(predicate)</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](transformer: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">MyList</span>[<span class="type">B</span>] =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Cons</span>(transformer(h), t.map(transformer))</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">++</span></span>[<span class="type">B</span> &gt;: <span class="type">A</span>](list: <span class="type">MyList</span>[<span class="type">B</span>]): <span class="type">MyList</span>[<span class="type">B</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(h, t ++ list)</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](transformer: <span class="type">A</span> =&gt; <span class="type">MyList</span>[<span class="type">B</span>]): <span class="type">MyList</span>[<span class="type">B</span>] =</span><br><span class="line">    transformer(h) ++ t.flatMap(transformer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ListTest</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> listOfIntegers: <span class="type">MyList</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">1</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">3</span>, <span class="type">Empty</span>)))</span><br><span class="line">  <span class="keyword">val</span> cloneListOfIntegers: <span class="type">MyList</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">1</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">3</span>, <span class="type">Empty</span>)))</span><br><span class="line">  <span class="keyword">val</span> anotherListOfIntegers: <span class="type">MyList</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">4</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">5</span>, <span class="type">Empty</span>))</span><br><span class="line"> </span><br><span class="line">  println(listOfIntegers.filter(<span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>,<span class="type">Boolean</span>]&#123;</span><br><span class="line">    	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(elem : <span class="type">Int</span>): <span class="type">Boolean</span> = elem % <span class="number">2</span> == <span class="number">0</span> </span><br><span class="line">  &#125;))</span><br><span class="line">   </span><br><span class="line">  println(listOfIntegers.map(<span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>,<span class="type">Int</span>]&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(elem: <span class="type">Int</span>): <span class="type">Int</span> = elem*<span class="number">2</span></span><br><span class="line">  &#125;))</span><br><span class="line">   </span><br><span class="line">  println((listOfIntegers ++ anotherListOfIntegers).toString)</span><br><span class="line">   </span><br><span class="line">  println(listOfIntegers.flatMap(<span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>,<span class="type">MyList</span>[<span class="type">Int</span>]]&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(elem: <span class="type">Int</span>): <span class="type">MyList</span>[<span class="type">Int</span>] = </span><br><span class="line">    				 <span class="keyword">new</span> <span class="type">Cons</span>(elem,<span class="keyword">new</span> <span class="type">Cons</span>(elem+<span class="number">1</span>,<span class="type">Empty</span>)).toString <span class="comment">//返回一个新的MyList</span></span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>define a function which takes an int and returns another function which takes an int and returns an int</li>
</ul>
<p>对于这个问题我们要从两个方面来思考：</p>
<ol>
<li>这个函数是什么类型的？接收一个Int，返回一个function，因此是Function1类型的</li>
<li>怎么实现？如下  </li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> superAdder: <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>]] = <span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>]] &#123;</span><br><span class="line">  <span class="comment">// 在这里实现apply函数，接收一个Int，返回一个Function type</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">Int</span>): <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>] &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(y: <span class="type">Int</span>): <span class="type">Int</span> = x + y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">val</span> adder3 = superAdder(<span class="number">3</span>)<span class="comment">// 此时adder3是外层的apply函数，仍然接收一个Int</span></span><br><span class="line">  println(adder3(<span class="number">4</span>))				<span class="comment">// 	adder3(4)其实调用的是内部的apply函数，返回值是int，结果是7</span></span><br><span class="line">  println(superAdder(<span class="number">3</span>)(<span class="number">4</span>)) <span class="comment">// curried function 7</span></span><br><span class="line"> 	<span class="comment">//superAdder就是一个Curried function，他将原来多参数的函数变为单参数的函数，</span></span><br></pre></td></tr></table></figure>
<h3 id="Anonymous-Functions"><a href="#Anonymous-Functions" class="headerlink" title="Anonymous Functions"></a>Anonymous Functions</h3><p>不知道你们有没有发现，我们利用Function  type来实现函数接口，从语法上还是遵循了 定义类、重载函数的思想，实际上还没有摆脱面向对象的编程思维。</p>
<p>因此我们可以使用 匿名函数，也就是 JavaScript中的 Lambda函数。 Scala 中定义匿名函数的语法很简单，箭头左边是参数列表，右边是函数体。</p>
<p>使用匿名函数后，我们的代码变得更简洁了。比如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> doubler = (x:<span class="type">Int</span>) =&gt; x*<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>同样我们可以在匿名函数中定义多个参数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> adder = (x: <span class="type">Int</span>, y: <span class="type">Int</span>) =&gt; x+y</span><br></pre></td></tr></table></figure>
<p>也可以不给匿名函数传入参数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> justDoSth = () =&gt; <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>需要注意，<code>println(justDoSth)</code> 和 <code>println(justDoSth())</code> 是不同的，前者是打印函数本身，后者是打印调用函数后返回的结果</p>
<h4 id="语法糖-1"><a href="#语法糖-1" class="headerlink" title="语法糖"></a>语法糖</h4><p>我们再来介绍一个匿名类中的语法糖：可以用下划线来代替传入的参数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> niceIncrementer: <span class="type">Int</span> =&gt; <span class="type">Int</span> = _ + <span class="number">1</span> <span class="comment">// equivalant to x =&gt; x+1</span></span><br><span class="line"><span class="keyword">val</span> niceAdder: (<span class="type">Int</span>,<span class="type">Int</span>) =&gt; <span class="type">Int</span> = _+_ <span class="comment">// equivalent to (a,b) =&gt; a+b</span></span><br></pre></td></tr></table></figure>
<h4 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise"></a>Exercise</h4><p>现在我们将MyList中的FunctionN接口都改为匿名函数</p>
<p>改之前：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ListTest</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> listOfIntegers: <span class="type">MyList</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">1</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">3</span>, <span class="type">Empty</span>))) </span><br><span class="line"> </span><br><span class="line">  println(listOfIntegers.filter(<span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>,<span class="type">Boolean</span>]&#123;</span><br><span class="line">    	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(elem : <span class="type">Int</span>): <span class="type">Boolean</span> = elem % <span class="number">2</span> == <span class="number">0</span> </span><br><span class="line">  &#125;)) </span><br><span class="line">  println(listOfIntegers.map(<span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>,<span class="type">Int</span>]&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(elem: <span class="type">Int</span>): <span class="type">Int</span> = elem*<span class="number">2</span></span><br><span class="line">  &#125;)) </span><br><span class="line">  println(listOfIntegers.flatMap(<span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>,<span class="type">MyList</span>[<span class="type">Int</span>]]&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(elem: <span class="type">Int</span>): <span class="type">MyList</span>[<span class="type">Int</span>] = </span><br><span class="line">    				 <span class="keyword">new</span> <span class="type">Cons</span>(elem,<span class="keyword">new</span> <span class="type">Cons</span>(elem+<span class="number">1</span>,<span class="type">Empty</span>)).toString <span class="comment">//返回一个新的MyList</span></span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改之后：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ListTest</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> listOfIntegers: <span class="type">MyList</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">1</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">3</span>, <span class="type">Empty</span>))) </span><br><span class="line"> </span><br><span class="line">  	println(listOfIntegers.filter(_%<span class="number">2</span> == <span class="number">0</span>).toString)</span><br><span class="line">  	println(listOfIntegers.map(_ * <span class="number">2</span>))</span><br><span class="line">  	println(listOfIntegers.flatmap(elem =&gt; <span class="type">Cons</span>(elem, <span class="type">Cons</span>(elem+<span class="number">1</span>,<span class="type">Empty</span>)).toString)</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们将之前的 super adder改成匿名函数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改之前</span></span><br><span class="line"><span class="keyword">val</span> superAdder: <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>]] = <span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>]] &#123; </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">Int</span>): <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>] &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(y: <span class="type">Int</span>): <span class="type">Int</span> = x + y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//改之后,接收了x参数，返回一个需要接受y的函数，然后再返回x+y</span></span><br><span class="line"><span class="keyword">val</span> superAdd = (x: <span class="type">Int</span>) =&gt; (y: <span class="type">Int</span>) =&gt; x + y</span><br></pre></td></tr></table></figure>
<h3 id="Higher-Order-Functions-and-Curries"><a href="#Higher-Order-Functions-and-Curries" class="headerlink" title="Higher-Order-Functions and Curries"></a>Higher-Order-Functions and Curries</h3><p>我们之前说过scala中的高阶函数要么接收一个函数为参数，要么返回一个函数。</p>
<p>比如说，我想设计一个可以重复将某一函数执行n次的函数，那么就需要传入一个函数f、参数n、初始值x</p>
<p>如 <code>nTimes(f,3,x) = nTimes(f,2,f(x)) = nTimes(f,1,f(f(x)))=nTimes(f,0,f(f(f(x))))</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nTimes</span></span>(f:<span class="type">Int</span> =&gt; <span class="type">Int</span>, n: <span class="type">Int</span>, x:<span class="type">Int</span>) : <span class="type">Int</span> = </span><br><span class="line">		<span class="keyword">if</span>(n &lt;= <span class="number">0</span>) x</span><br><span class="line">		<span class="keyword">else</span> nTimes(f,n<span class="number">-1</span>,f(x))</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"></span><br><span class="line">print(nTimes(plusOne,<span class="number">100000</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>但我们有没有感到一丝奇怪，就是我们说的函数式编程，是希望像数学里的那样，实现一个映射关系。每次只对一个参数x进行操作，而不是像上面的调用那样，一次要输入3个参数</p>
<p>因此我们可以对nTimes函数做一个改进：改进后的nTimes，每次返回的不再是Int，而是一个<code>(Int =&gt; Int)</code>的函数, 因此，我们可以调用返回的函数去计算</p>
<p>但是这种方法也有弊端，就是会出现栈溢出的问题，不是下尾递归</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nTimesBetter</span></span>(f: <span class="type">Int</span> =&gt; <span class="type">Int</span>, n: <span class="type">Int</span>): (<span class="type">Int</span> =&gt; <span class="type">Int</span>) = </span><br><span class="line">		<span class="keyword">if</span> (n &lt;= <span class="number">0</span>)(x: <span class="type">Int</span>) =&gt; x</span><br><span class="line">		<span class="keyword">else</span> (x: <span class="type">Int</span>) =&gt; nTimesBetter(f,n<span class="number">-1</span>)(f(x))</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用，此时，plus10变成了一个 Int=&gt;Int的函数</span></span><br><span class="line"><span class="keyword">val</span> plus10 = nTimesBetter(plusOne,<span class="number">100</span>)</span><br><span class="line">println(plus10(<span class="number">1</span>)) <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>
<h4 id="多个参数列表"><a href="#多个参数列表" class="headerlink" title="多个参数列表"></a>多个参数列表</h4><p>多个参数列表(multiple parameter lists)常常和柯里化常常一起用,比如说，我想创建一个函数，它可以将double类型的浮点数格式化成想要的样子。正常来说，需要输入两个参数，一个是需要被格式化的浮点数，另一个是String类型的格式本身。但是若要对其进行柯里化，就只能让函数每次只接收一个参数。</p>
<p>因此，我们可以使用多个参数列表的语法。也就是使用多个<code>()</code>, 注意，括号的顺序和参数输入的顺序是有关的。比如说下面这个<code>curriedFormatter</code>,需要先输入String, 然后在去处理Double，最后返回String</p>
<p>其本质上是一个<code>String =&gt; Double =&gt; String</code> 的函数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">curriedFormatter</span></span>(c: <span class="type">String</span>)(x: <span class="type">Double</span>) : <span class="type">String</span> = c.format(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试：</span></span><br><span class="line">	<span class="comment">//curriedFormatter返回一个Double=&gt;String的函数</span></span><br><span class="line">  <span class="keyword">val</span> standardFormat: (<span class="type">Double</span> =&gt; <span class="type">String</span>) = curriedFormatter(<span class="string">"%4.2f"</span>)</span><br><span class="line">  <span class="keyword">val</span> preciseFormat: (<span class="type">Double</span> =&gt; <span class="type">String</span>) = curriedFormatter(<span class="string">"%10.8f"</span>)   			   </span><br><span class="line">	</span><br><span class="line">  println(standardFormat(<span class="type">Math</span>.<span class="type">PI</span>)) <span class="comment">// 3.14</span></span><br><span class="line">  println(preciseFormat(<span class="type">Math</span>.<span class="type">PI</span>))	 <span class="comment">// 3.1415926</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果使用 多个参数列表的话，我们在定义子函数的时候(如上面的standardFormat和preciseFormat)，需要显式得注明函数接受的参数及其返回类型。</p>
<p>为了把多个参数列表讲清楚，我们在来举一个三个参数列表的例子：</p>
<ul>
<li>首先，我定义了triplefunc，它是一个<code>String =&gt; Double =&gt; Int =&gt;String</code>的函数</li>
<li>然后，我有定义了一个doubleFormatter， 它是triplefunc接收了一个参数后的返回值，类型为<code>Double =&gt; Int =&gt; String</code></li>
<li>接着，我又定义了一个IntAdder，它是doubleFormatter接收了一个参数后的返回值，类型为<code>Int=&gt;String</code></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">triplefunc</span></span>(c:<span class="type">String</span>)(x:<span class="type">Double</span>)(y:<span class="type">Int</span>):<span class="type">String</span> = c.format(x+y)</span><br><span class="line"><span class="keyword">val</span> doubleFormatter: <span class="type">Double</span> =&gt; <span class="type">Int</span> =&gt; <span class="type">String</span> = triplefunc(<span class="string">"%4.2f"</span>)</span><br><span class="line"><span class="keyword">val</span> <span class="type">IntAdder</span>: <span class="type">Int</span> =&gt; <span class="type">String</span> = doubleFormatter(<span class="number">2.33</span>)</span><br><span class="line"><span class="comment">//最后我们将三个函数全部调用，得到的结果是一样的 6.33</span></span><br><span class="line">println(triplefunc(<span class="string">"%4.2f"</span>)(<span class="number">2.33</span>)(<span class="number">4</span>))</span><br><span class="line">println(doubleFormatter(<span class="number">2.33</span>)(<span class="number">4</span>))</span><br><span class="line">println(<span class="type">IntAdder</span>(<span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<h4 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  1.  Expand MyList</span></span><br><span class="line"><span class="comment">      - foreach method A =&gt; Unit</span></span><br><span class="line"><span class="comment">        [1,2,3].foreach(x =&gt; println(x))</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      - sort function ((A, A) =&gt; Int) =&gt; MyList</span></span><br><span class="line"><span class="comment">        [1,2,3].sort((x, y) =&gt; y - x) =&gt; [3,2,1]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      - zipWith (list, (A, B) =&gt; C) =&gt; MyList[C]</span></span><br><span class="line"><span class="comment">        [1,2,3].zipWith([4,5,6], x * y) =&gt; [1 * 4, 2 * 5, 3 * 6] = [4,10,18]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      - fold(start)(function) =&gt; a value</span></span><br><span class="line"><span class="comment">        [1,2,3].fold(0)(x + y) = 6</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  2.  toCurry(f: (Int, Int) =&gt; Int) =&gt; (Int =&gt; Int =&gt; Int)</span></span><br><span class="line"><span class="comment">      fromCurry(f: (Int =&gt; Int =&gt; Int)) =&gt; (Int, Int) =&gt; Int</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  3.  compose(f,g) =&gt; x =&gt; f(g(x))</span></span><br><span class="line"><span class="comment">      andThen(f,g) =&gt; x =&gt; g(f(x))</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p><strong>Exercise1</strong></p>
<p>首先对MyList进行改进，新加入了四个高阶函数</p>
<ul>
<li>abstract class</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyList</span>[+<span class="type">A</span>]</span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">foreach</span></span>(f: <span class="type">A</span> =&gt; <span class="type">Unit</span>) : <span class="type">Unit</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">sort</span></span>(compare:(<span class="type">A</span>,<span class="type">A</span>)=&gt;<span class="type">Int</span>) =&gt; <span class="type">MyList</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">zipWith</span></span>[<span class="type">B</span>,<span class="type">C</span>](list:<span class="type">MyList</span>[<span class="type">B</span>],zip:(<span class="type">A</span>,<span class="type">B</span>)=&gt;<span class="type">C</span>):<span class="type">MyList</span>[<span class="type">C</span>]</span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">fold</span></span>[<span class="type">B</span>](start:<span class="type">B</span>)(operator:(<span class="type">B</span>,<span class="type">A</span>)=&gt;<span class="type">B</span>):<span class="type">B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>object Empty </li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Empty</span> <span class="keyword">extends</span> <span class="title">MyList</span>[<span class="type">Nothing</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foreach</span></span>(f: <span class="type">Nothing</span> =&gt; <span class="type">Unit</span>):<span class="type">Unit</span> = ()</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sort</span></span>(compare:(<span class="type">Nothing</span>,<span class="type">Nothing</span>)=&gt;<span class="type">Int</span>):<span class="type">MyList</span> = <span class="type">Empty</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">zipWith</span></span>[<span class="type">B</span>,<span class="type">C</span>](list:<span class="type">MyList</span>[<span class="type">B</span>],zip:(<span class="type">Nothing</span>,<span class="type">B</span>)=&gt;<span class="type">C</span>):<span class="type">MyList</span>[<span class="type">C</span>]=</span><br><span class="line">  	<span class="keyword">if</span>(!list.isEmpty)  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">"Lists do not have the same length"</span>)</span><br><span class="line">    <span class="keyword">else</span> <span class="type">Empty</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fold</span></span>[<span class="type">B</span>](start:<span class="type">B</span>)(operator:(<span class="type">B</span>:<span class="type">Nothing</span>)=&gt; <span class="type">B</span>):<span class="type">B</span> = start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>class Cons</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Cons</span>[+<span class="type">A</span>](<span class="params">h: <span class="type">A</span>, t: <span class="type">MyList</span>[<span class="type">A</span>]</span>) <span class="keyword">extends</span> <span class="title">MyList</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foreach</span></span>(f: <span class="type">A</span> =&gt; <span class="type">Unit</span>):<span class="type">Unit</span> = &#123;</span><br><span class="line">			f(h)</span><br><span class="line">			t.foreach(f)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">sort</span></span>(compare:(<span class="type">A</span>,<span class="type">A</span>)=&gt;<span class="type">Int</span>):<span class="type">MyList</span> = &#123;</span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">insert</span></span>(x: <span class="type">A</span>, sortedList: <span class="type">MyList</span>[<span class="type">A</span>]): <span class="type">MyList</span>[<span class="type">A</span>] =</span><br><span class="line">      <span class="keyword">if</span> (sortedList.isEmpty) <span class="keyword">new</span> <span class="type">Cons</span>(x, <span class="type">Empty</span>)</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (compare(x, sortedList.head) &lt;= <span class="number">0</span>) <span class="keyword">new</span> <span class="type">Cons</span>(x, sortedList)</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">new</span> <span class="type">Cons</span>(sortedList.head, insert(x, sortedList.tail))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sortedTail = t.sort(compare)</span><br><span class="line">    insert(h, sortedTail)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">zipWith</span></span>[<span class="type">B</span>,<span class="type">C</span>](list:<span class="type">MyList</span>[<span class="type">B</span>],zip:(<span class="type">A</span>,<span class="type">B</span>)=&gt;<span class="type">C</span>):<span class="type">MyList</span>[<span class="type">C</span>] =  </span><br><span class="line">    <span class="keyword">if</span> (list.isEmpty) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">"Lists do not have the same length"</span>)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">new</span> <span class="type">Cons</span>(zip(h,list.head),t.zipWith(list.tail,zip))</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fold</span></span>[<span class="type">B</span>](start:<span class="type">B</span>)(operator:(<span class="type">B</span>,<span class="type">A</span>)=&gt;<span class="type">B</span>):<span class="type">B</span> = </span><br><span class="line">  	t.fold(operator(start,h))(operator)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="map-flatMap-filter-and-for-comprehensions"><a href="#map-flatMap-filter-and-for-comprehensions" class="headerlink" title="map, flatMap, filter and for-comprehensions"></a>map, flatMap, filter and for-comprehensions</h3><p>我们之前实现了自己的List，并在其中实现了map，flatmap和filter的相关功能，现在来介绍Scala中的内置方法。</p>
<p>首先来创建一个List：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">println(list.head)<span class="comment">// 打印头部，即1</span></span><br><span class="line">println(list.tail)<span class="comment">// 打印除了头之外的部分，List(2, 3)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>map</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(list.map(_ + <span class="number">1</span>))							<span class="comment">//List(2, 3, 4)</span></span><br><span class="line">println(list.map(_ + <span class="string">" is a number"</span>))	<span class="comment">//List(1 is a number, 2 is a number, 3 is a number)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>filter</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(list.filter(_ % <span class="number">2</span> == <span class="number">0</span>)) 	<span class="comment">//List(2)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>flatMap</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> toPair = (x: <span class="type">Int</span>) =&gt; <span class="type">List</span>(x, x+<span class="number">1</span>)</span><br><span class="line">println(list.flatMap(toPair))		<span class="comment">//List(1, 2, 2, 3, 3, 4)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>foreach </li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.foreach(println)<span class="comment">// 1,2,3</span></span><br></pre></td></tr></table></figure>
<p>我们看到这些函数和我们之前自己实现的功能是一样的。</p>
<h4 id="多重循环"><a href="#多重循环" class="headerlink" title="多重循环"></a>多重循环</h4><p>现在如果我想输出两个甚至更多个list的笛卡尔积，该如何操作？在面向对象的语言中，我们会使用双重循环for-loops，但是在scala中，我们需要用flatmap和map的组合来实现</p>
<ul>
<li>如果是双重循环，外循环中的每个值，都会产生一个list，是一对多的映射，因此使用flatMap；内循环每个值只生成一个对应的值，是一对一映射，因此使用map</li>
<li>如果是三重循环，除了最内层循环使用map，外层循环都会产生一个list，因此使用flatMap</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">val</span> numbers = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">  <span class="keyword">val</span> chars = <span class="type">List</span>('a','b','c','d')</span><br><span class="line">  <span class="keyword">val</span> colors = <span class="type">List</span>(<span class="string">"black"</span>, <span class="string">"white"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果我想做a1,a2,...d3,d4</span></span><br><span class="line">println(numbers.flatMap(n =&gt; chars.map(c =&gt; <span class="string">""</span>+c+n)))</span><br><span class="line"><span class="comment">//List(a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3, a4, b4, c4, d4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果我想对三个list做笛卡尔积：</span></span><br><span class="line">println(numbers.flatMap(n =&gt; chars.flatmap(c =&gt; colors.map(color=&gt;<span class="string">""</span>+c+n+<span class="string">"-"</span>+color))))</span><br><span class="line"><span class="comment">//List(a2-black, a2-white, b2-black, b2-white, c2-black, c2-white, d2-black, d2-white, a4-black, a4-white, b4-black, b4-white, c4-black, c4-white, d4-black, d4-white)=</span></span><br></pre></td></tr></table></figure>
<p>事实上，这种代码的可读性是比较差的，因此，scala提供了多重循环的简化版本。也就是 for循环，如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> forCombinations = <span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="comment">// guards, 也就是for循环中的if条件判断，编译器会将其翻译为filter</span></span><br><span class="line">  n &lt;- numbers <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">  c &lt;- chars</span><br><span class="line">  color &lt;- colors</span><br><span class="line">&#125; <span class="keyword">yield</span> <span class="string">""</span> + c + n + <span class="string">"-"</span> + color</span><br><span class="line">println(forCombinations)</span><br></pre></td></tr></table></figure>
<p>for 循环中的 yield 会把当前的元素记下来，保存在集合中，循环结束后将返回该集合。Scala中 for 循环是有返回值的。如果被循环的是 Map，返回的就是  Map，被循环的是 List，返回的就是 List，以此类推。</p>
<p>上面这句话的意思就是，对于numbers中的偶数、chars中的字符，colors中的颜色，都将其组合并保存在集合中</p>
<p>但是这只是一种语法糖，在编译器内部，还是将for语句转换成map和flatmap来执行的。</p>
<ul>
<li>注意，以下两种写法都是可以的，属于语法重载。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list.map &#123; x =&gt;</span><br><span class="line">  x * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list.map(_*<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h4 id="发散"><a href="#发散" class="headerlink" title="发散"></a>发散</h4><p>试问，我们之前创建的MyList对象，是不是也可以使用for语句进行循环呢？可以的，只要我们在函数内定义了逻辑正确的map、flatMap、filter函数，就可以应用for</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">val</span> listOfIntegers: <span class="type">MyList</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">1</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">3</span>, <span class="type">Empty</span>))) </span><br><span class="line">  <span class="keyword">val</span> listOfStrings: <span class="type">MyList</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="string">"Hello"</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="string">"Scala"</span>, <span class="type">Empty</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> combinations = <span class="keyword">for</span> &#123;</span><br><span class="line">  n &lt;- listOfIntegers</span><br><span class="line">  string &lt;- listOfStrings</span><br><span class="line">&#125; <span class="keyword">yield</span> n + <span class="string">"-"</span> + string</span><br><span class="line">println(combinations)<span class="comment">//[1-Hello 1-Scala 2-Hello 2-Scala 3-Hello 3-Scala]</span></span><br></pre></td></tr></table></figure>
<h3 id="A-Collections-Overview"><a href="#A-Collections-Overview" class="headerlink" title="A Collections Overview"></a>A Collections Overview</h3><p>这一节我们来学习scala中的 集合类,这是一个比较大的类，包含了很多子类.</p>
<p>首先，我们要了解scala中的集合分为 mutable(可变) collection 和immutable(不可变) collection。</p>
<ul>
<li>可变集合可以在适当的地方被更新或扩展。这意味着你可以修改，添加，移除一个集合的元素。</li>
<li>不可变集合类，相比之下，永远不会改变。不过，你仍然可以模拟添加，移除或更新操作。但是这些操作将在每一种情况下都返回一个新的集合，同时使原来的集合不发生改变。</li>
</ul>
<p>之前我们自己写的MyList，List都属于immutable collection之列。</p>
<h4 id="mutable-collection架构图"><a href="#mutable-collection架构图" class="headerlink" title="mutable collection架构图"></a>mutable collection架构图</h4><p><img src="/2022/04/28/scala%E5%88%9D%E8%AF%86/7.svg"></p>
<p>在本篇文章中不会介绍mutable collection的相关内容</p>
<h4 id="immutable-collection-架构图"><a href="#immutable-collection-架构图" class="headerlink" title="immutable collection 架构图"></a>immutable collection 架构图</h4><p><img src="/2022/04/28/scala%E5%88%9D%E8%AF%86/6.svg"></p>
<p>Traversable是所有collection的母类，然后在Iterable下面主要分三大类：Set，Map, 和Seq。 Set是不包含重复数据的集合, Maps是键值对集合，Seq是适合存有序重复数据的列表集合。</p>
<p>Seq下面还是有 IndexSeq 和 LinearSeq两种， 前者可以通过 索引来快速定位元素。后者的元素则是线性的，按照某种顺序排列的。</p>
<h3 id="Sequences-List-Array-Vector"><a href="#Sequences-List-Array-Vector" class="headerlink" title="Sequences:  List, Array, Vector"></a>Sequences:  List, Array, Vector</h3><p>首先我们来看看 Seq接口提供了哪些操作：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Seq</span>[+<span class="type">A</span>] </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">head</span></span>: <span class="type">A</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">tail</span> </span>: <span class="type">Seq</span>[<span class="type">A</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Seq接口是一个很general(不知道怎么翻译了)的接口，其中的元素是按照清晰地顺序进行排列的。而且可以通过下标index进行访问。</p>
<p>Seq接口提供很多操作：</p>
<ul>
<li><p>在索引和迭代方面</p>
<ul>
<li><code>apply</code>: 可以直接通过<code>Seq(1,3,2,4)</code> 这样的方法构造Seq</li>
<li>iterator: 详细用法可以参考文档</li>
<li>length:返回seq长度</li>
<li>reverse: 倒转seq</li>
</ul>
</li>
<li><p>创建新的Seq方面</p>
<ul>
<li>concatenation: 两个seq连接</li>
<li>appending: seq之后连一个元素</li>
<li>prepending: seq之前连一个元素</li>
</ul>
</li>
<li>其他<ul>
<li>grouping</li>
<li>sorting</li>
<li>zipping</li>
<li>searching</li>
<li>slicing</li>
</ul>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aSequence = <span class="type">Seq</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">println(aSequence)		<span class="comment">// List(1, 3, 2, 4)</span></span><br><span class="line">println(aSequence.reverse)<span class="comment">// List(4, 2, 3, 1)</span></span><br><span class="line">println(aSequence(<span class="number">2</span>))	<span class="comment">// 2</span></span><br><span class="line">println(aSequence ++ <span class="type">Seq</span>(<span class="number">7</span>,<span class="number">5</span>,<span class="number">6</span>))<span class="comment">// List(1, 3, 2, 4, 7, 5, 6)</span></span><br><span class="line">println(aSequence.sorted)		<span class="comment">// List(1, 2, 3, 4)</span></span><br></pre></td></tr></table></figure>
<h4 id="Ranges"><a href="#Ranges" class="headerlink" title="Ranges"></a>Ranges</h4><p>scala中的Range也是一种类型，其本质上是一种特殊的 Array</p>
<p>range有两种定义方式：</p>
<ul>
<li>利用until / to 定义 . to代表前闭后闭区间；until代表前闭后开区间</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aRange: <span class="type">Seq</span>[<span class="type">Int</span>] = <span class="number">1</span> until <span class="number">10</span> </span><br><span class="line">aRange.foreach(println)<span class="comment">//1 2 3 4 5 6 7 8 9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> bRange: <span class="type">Seq</span>[<span class="type">Int</span>] = <span class="number">1</span> to <span class="number">10</span> </span><br><span class="line">bRange.foreach(println)<span class="comment">//1 2 3 4 5 6 7 8 9 10</span></span><br></pre></td></tr></table></figure>
<ul>
<li>利用Range(A,B) by C 定义。Range(A,B)代表A和B的前闭后开区间 ，C代表自定义步长</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//范围需要在最大值和最小值范围内即 2 &lt;= 元素 &lt;= 19</span></span><br><span class="line"><span class="keyword">val</span> res: <span class="type">Range</span> = <span class="type">Range</span>(<span class="number">2</span>, <span class="number">20</span>) by <span class="number">3</span></span><br><span class="line">println(res.foreach(println))</span><br></pre></td></tr></table></figure>
<p>利用 Ranges我们可以实现类似循环的效果：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span> to <span class="number">10</span>).foreach(x =&gt; println(<span class="string">"Hello"</span>)) <span class="comment">// 打印10遍 Hello</span></span><br></pre></td></tr></table></figure>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>List列表：不可变</p>
<p>LIst支持在头部快速添加和移除条目,意味着模式匹配很顺畅, head、tail、isEmpty操作只需要 $O(1)$的复杂度。</p>
<p>大多数List操作还是需要遍历整个列表的，需要O(n)的复杂度，如length，reverse。</p>
<p>List不支持索引直接定位，如 <code>list(2)=10</code> (非法)； 但是可以使用updated方法，但此方法也不是索引定位，而是线性复杂度的。</p>
<p>List列表跟其他语言中的数组非常像，二者都是同构的，同一个列表的所有元素必须是相同类型。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aList = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">// +: 是prepend, :+ 是 append，我们只要记住 : 都是靠近List一边的即可</span></span><br><span class="line"><span class="keyword">val</span> prepended = <span class="number">42</span> +: aList :+ <span class="number">89</span></span><br><span class="line">println(prepended) <span class="comment">// List(42, 1, 2, 3, 89)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fill函数是创建一个长度为5的数组，数组中每个元素都是 字符串 apple</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">val</span> apples5 = <span class="type">List</span>.fill(<span class="number">5</span>)(<span class="string">"apple"</span>)</span><br><span class="line">println(apples5)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将list中的元素按一定格式排列，mkString中的参数就是每个元素之间的分割符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">println(aList.mkString(<span class="string">"-|-"</span>))</span><br></pre></td></tr></table></figure>
<h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><p>Array和List不一样，它和Java中的arrays是等价的</p>
<ul>
<li>在创建的时候，可以预先其分配内存，而不对其进行赋值</li>
<li>在适当的位置可以被修改(更新)，所以是部分可变的</li>
<li>可以和 Java的 T[] arrays互相操作</li>
<li>可以通过索引访问，速度很快</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是创建一个长度为4的Array，同时赋值</span></span><br><span class="line"><span class="keyword">val</span> numbers = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">//创建一个String类型、长度为3的Array，但不赋值</span></span><br><span class="line"><span class="keyword">val</span> threeElements = <span class="type">Array</span>.ofDim[<span class="type">String</span>](<span class="number">3</span>)</span><br><span class="line">threeElements.foreach(println)<span class="comment">// 打印会得到null</span></span><br><span class="line"><span class="comment">//如果是数值类型的数组，不赋值，打印会得到0或者false(bool)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// array是部分可变的，比如我们可以将某一位置上的值更新。</span></span><br><span class="line">numbers(<span class="number">2</span>) = <span class="number">0</span>  <span class="comment">// 这种写法比较直白，其实是numbers.update(2, 0)的语法糖</span></span><br><span class="line">println(numbers.mkString(<span class="string">" "</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>seq和array之间的转化</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays and seq</span></span><br><span class="line"><span class="keyword">val</span> numbersSeq: <span class="type">Seq</span>[<span class="type">Int</span>] = numbers  <span class="comment">// 隐式转化，将array转换为ArraySeq</span></span><br><span class="line">println(numbersSeq) <span class="comment">//ArraySeq(1 2 0 4)</span></span><br></pre></td></tr></table></figure>
<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>vector是另外一个独立的体系，也是 Imuutable的</p>
<ul>
<li>vector可以利用索引来进行读写，复杂度为$O(\log_{32}(n))$,因此vector的索引操作是非常快的</li>
<li>可以使用append和prepend</li>
<li>底层数据结构是fixed-branched Trie树(字典树)，</li>
<li>当vector中数据很大时，表现很好</li>
<li>可以使用prepend和append方法，也可以调用 updated 进行更新</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> vector: <span class="type">Vector</span>[<span class="type">Int</span>] = <span class="type">Vector</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">println(vector)</span><br></pre></td></tr></table></figure>
<ul>
<li>vectors和lists性能对比</li>
</ul>
<p>在数据量很大的情况下，vectors的表现要远远优于list：</p>
<p>首先我们写一个函数，对一个长度为1,000,000的Seq(vector和list都继承自seq)，随机替换seq中的某一个值，重复1,000遍。最终返回平均每次updated操作的运算时间。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> maxRuns = <span class="number">1000</span></span><br><span class="line"><span class="keyword">val</span> maxCapacity = <span class="number">1000000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getWriteTime</span></span>(collection: <span class="type">Seq</span>[<span class="type">Int</span>]): <span class="type">Double</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> r = <span class="keyword">new</span> <span class="type">Random</span></span><br><span class="line">  <span class="keyword">val</span> times = <span class="keyword">for</span> &#123;</span><br><span class="line">    it &lt;- <span class="number">1</span> to maxRuns</span><br><span class="line">  &#125; <span class="keyword">yield</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> currentTime = <span class="type">System</span>.nanoTime()</span><br><span class="line">    collection.updated(r.nextInt(maxCapacity), r.nextInt())</span><br><span class="line">    <span class="type">System</span>.nanoTime() - currentTime</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  times.sum * <span class="number">1.0</span> / maxRuns</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> numbersList = (<span class="number">1</span> to maxCapacity).toList</span><br><span class="line"><span class="keyword">val</span> numbersVector = (<span class="number">1</span> to maxCapacity).toVector</span><br><span class="line"></span><br><span class="line"><span class="comment">// keeps reference to tail</span></span><br><span class="line"><span class="comment">// updating an element in the middle takes long</span></span><br><span class="line">println(getWriteTime(numbersList)) <span class="comment">//耗费 2673515.435 纳秒</span></span><br><span class="line"><span class="comment">// depth of the tree is small</span></span><br><span class="line"><span class="comment">// needs to replace an entire 32-element chunk</span></span><br><span class="line">println(getWriteTime(numbersVector))<span class="comment">//耗费 8457.379 纳秒</span></span><br></pre></td></tr></table></figure>
<p>我们看到，list和vector在updated 操作上，有着近三百多倍的差距，而且差距会随着规模的增大而继续拉大</p>
<h3 id="Tuples-and-Maps"><a href="#Tuples-and-Maps" class="headerlink" title="Tuples and Maps"></a>Tuples and Maps</h3><p>和List一样，Tuple也是不可变的，但是和list也有不同之处：<strong>元组可以包含不同类型的元素</strong>，但是list为元素为统一中类型</p>
<h4 id="Tuples"><a href="#Tuples" class="headerlink" title="Tuples"></a>Tuples</h4><p>声明元组的语法如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aTuple = <span class="keyword">new</span> <span class="type">Tuple2</span>(<span class="number">2</span>,<span class="string">"hello scala"</span>)<span class="comment">//最正规也最复杂的定义</span></span><br><span class="line"><span class="keyword">val</span> aTuple = <span class="type">Tuple2</span>(<span class="number">2</span>,<span class="string">"hello scala"</span>)		<span class="comment">//可以把new去掉，因为Tuple2中有apple方法</span></span><br><span class="line"><span class="keyword">val</span> aTuple = (<span class="number">2</span>, <span class="string">"hello, Scala"</span>)  			<span class="comment">// 这是一种语法糖，等价于用Tuple2来定义</span></span><br></pre></td></tr></table></figure>
<p>事实上，scala会自动根据元组里面的元素类型以及个数去创建 TuplesN[]，N最大为22(因为是根据FunctionN来的)，所以说元组的最大容量只有22</p>
<ul>
<li>tuple 访问元素的方法</li>
</ul>
<p>tuple访问里面的第一个元素用<code>._1</code>; 第二个元素用<code>._2</code> ，以此类推</p>
<p>如果想要修改tuple中的元素，需要使用copy方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(aTuple._1)  <span class="comment">// 2</span></span><br><span class="line">println(aTuple.copy(_2 = <span class="string">"goodbye Java"</span>)) <span class="comment">//(2,goodbye Java)</span></span><br><span class="line">println(aTuple.swap)  <span class="comment">// ("hello, Scala", 2) 只有Tuple2有这个swap方法，其他都没有</span></span><br></pre></td></tr></table></figure>
<h4 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h4><ul>
<li>Maps是键值对集合，可以由如下定义：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string 是key， Int 是value</span></span><br><span class="line"><span class="keyword">val</span> aMap: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>] = <span class="type">Map</span>()</span><br><span class="line"><span class="comment">// 键值对可以使一个Tuple2，也可以是 key -&gt; value形式的(语法糖)</span></span><br><span class="line"><span class="comment">// withDefaultValue(-1)的意思是，如果查到Map中没有的键，就返回-1;若不设置，遇到的时候会报错</span></span><br><span class="line"><span class="keyword">val</span> phonebook = <span class="type">Map</span>((<span class="string">"Jim"</span>, <span class="number">555</span>), <span class="string">"Daniel"</span> -&gt; <span class="number">789</span>, (<span class="string">"JIM"</span>, <span class="number">9000</span>)).withDefaultValue(<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>判断map是否包含某个键</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(phonebook.contains(<span class="string">"Jim"</span>))<span class="comment">// true</span></span><br><span class="line">print(phonebook(<span class="string">"Mary"</span>))<span class="comment">//-1,因为 Mary这个键不存在</span></span><br></pre></td></tr></table></figure>
<ul>
<li>由于map是immutable的，因此如果要往原来的map里插入新键值对，</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> newPairing = <span class="string">"Mary"</span> -&gt; <span class="number">678</span></span><br><span class="line"><span class="keyword">val</span> newPhonebook = phonebook + newPairing</span><br><span class="line">println(newPhonebook)</span><br></pre></td></tr></table></figure>
<ul>
<li>让tuples打印得更漂亮</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(tuple.toString)</span><br></pre></td></tr></table></figure>
<h5 id="functionals-on-maps"><a href="#functionals-on-maps" class="headerlink" title="functionals on maps"></a>functionals on maps</h5><ul>
<li>map 函数</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(phonebook.map(pair =&gt; pair._1.toLowerCase -&gt; pair._2))</span><br></pre></td></tr></table></figure>
<ul>
<li>filter函数</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(phonebook.view.filterKeys(x =&gt; x.startsWith(<span class="string">"J"</span>)).toMap)</span><br></pre></td></tr></table></figure>
<ul>
<li>mapValues</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(phonebook.view.mapValues(number =&gt; <span class="string">"0245-"</span> + number).toMap)</span><br></pre></td></tr></table></figure>
<h5 id="map与其结构之间的转换"><a href="#map与其结构之间的转换" class="headerlink" title="map与其结构之间的转换"></a>map与其结构之间的转换</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// conversions to other collections</span></span><br><span class="line"><span class="comment">// map转换为List</span></span><br><span class="line">println(phonebook.toList) </span><br><span class="line"><span class="comment">// List转换为Map</span></span><br><span class="line">println(<span class="type">List</span>((<span class="string">"Daniel"</span>, <span class="number">555</span>)).toMap)</span><br></pre></td></tr></table></figure>
<h5 id="groupBy函数"><a href="#groupBy函数" class="headerlink" title="groupBy函数"></a>groupBy函数</h5><p>groupBy函数比较有用，可以将List中的元素分成组。比如说</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> names = <span class="type">List</span>(<span class="string">"Bob"</span>, <span class="string">"James"</span>, <span class="string">"Angela"</span>, <span class="string">"Mary"</span>, <span class="string">"Daniel"</span>, <span class="string">"Jim"</span>)</span><br><span class="line">println(names.groupBy(name =&gt; name.charAt(<span class="number">0</span>)))</span><br><span class="line"><span class="comment">//HashMap(J -&gt; List(James, Jim), A -&gt; List(Angela), M -&gt; List(Mary), B -&gt; List(Bob), D -&gt; List(Daniel))</span></span><br><span class="line">println(names.groupBy(name =&gt; name.charAt(<span class="number">0</span>) == '<span class="type">J</span>'))</span><br><span class="line"><span class="comment">//HashMap(false -&gt; List(Bob, Angela, Mary, Daniel), true -&gt; List(James, Jim))</span></span><br></pre></td></tr></table></figure>
<h4 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise"></a>Exercise</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  1.  What would happen if I had two original entries "Jim" -&gt; 555 and "JIM" -&gt; 900</span></span><br><span class="line"><span class="comment">      !!! careful with mapping keys.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  2.  Overly simplified social network based on maps</span></span><br><span class="line"><span class="comment">      Person = String</span></span><br><span class="line"><span class="comment">      - add a person to the network</span></span><br><span class="line"><span class="comment">      - remove</span></span><br><span class="line"><span class="comment">      - friend (mutual)</span></span><br><span class="line"><span class="comment">      - unfriend</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      - number of friends of a person</span></span><br><span class="line"><span class="comment">      - person with most friends</span></span><br><span class="line"><span class="comment">      - how many people have NO friends</span></span><br><span class="line"><span class="comment">      - if there is a social connection between two people (direct or not)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h3><p>现在来介绍一下Scala中一种特殊的类: Option</p>
<p>Option 可以看做一个容器要么有东西(Some),要么什么东西都没有。<strong>我们可将其看成一个长度为0或1的List。当Option里面有东西的时候，这个List的长度是1（也就是 Some），而当你的Option里没有东西的时候，它的长度是0（也就是 None）。</strong></p>
<p>那么Option可以应用在哪里？我们设想一个情况：打印一个还未分配内存的字符串，显然，这会导致 Null Pointer Error并使得程序崩溃。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> string: <span class="type">String</span> = <span class="literal">null</span></span><br><span class="line">println(string.length)</span><br></pre></td></tr></table></figure>
<p>为了解决这个问题，正常方法可以这样写,但是如果通篇都是这样的处理，就会显得很杂乱</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> string : <span class="type">String</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">if</span> (string != <span class="literal">null</span>) &#123;</span><br><span class="line">		println(string.length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，Option就发挥其作用了。Option可以作为一个wrapper，被它包含的值可以使存在的，也可以是Nothing。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unsafeMethod</span></span>(): <span class="type">String</span> = <span class="literal">null</span></span><br><span class="line"><span class="comment">//  val result = Some(null) // WRONG</span></span><br><span class="line"><span class="keyword">val</span> result = <span class="type">Option</span>(unsafeMethod()) <span class="comment">// Some or None</span></span><br><span class="line">println(result)	<span class="comment">//None</span></span><br></pre></td></tr></table></figure>
<p>此外，在 map 中，我们可以用Option来包裹 <code>map.get(&quot;key&quot;)</code> 如果key不存在，那么值就是 None</p>
<p>又比如，在访问一个空列表的头部的时候，也可以用Option。</p>
<p>我的理解是，option有点像植物大战僵尸中的南瓜，南瓜里面可以有植物，也可以什么都没有，但南瓜放在那边就会起一个保护作用。</p>
<h4 id="使用-getOrElse-方法"><a href="#使用-getOrElse-方法" class="headerlink" title="使用 getOrElse() 方法"></a>使用 getOrElse() 方法</h4><p>以下是示例程序，显示了如何使用<strong>getOrElse()</strong>方法访问值或不存在值时的默认值。</p>
<p>比如说：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backupMethod</span></span>(): <span class="type">String</span> = <span class="string">"A valid result"</span></span><br><span class="line"><span class="comment">// 如果前面函数的调用值是None，那么就会调用后面的函数</span></span><br><span class="line"><span class="keyword">val</span> chainedResult = <span class="type">Option</span>(unsafeMethod()).orElse(<span class="type">Option</span>(backupMethod()))</span><br></pre></td></tr></table></figure>
<p>事实上，我们可以在进行优化，在定义函数的时候，就将返回值定为 Option, 这样可读性更强，而且对用户更友好(api中已经设定了option，用户不用自己再套一层option)</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">betterUnsafeMethod</span></span>(): <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">betterBackupMethod</span></span>(): <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">Some</span>(<span class="string">"A valid result"</span>)</span><br><span class="line"><span class="keyword">val</span> betterChainedResult = betterUnsafeMethod() orElse betterBackupMethod()</span><br></pre></td></tr></table></figure>
<h4 id="functions-on-Options"><a href="#functions-on-Options" class="headerlink" title="functions on Options"></a>functions on Options</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(myFirstOption.isEmpty) <span class="comment">// 判断是否为空</span></span><br><span class="line">println(myFirstOption.get)   	<span class="comment">// 获得Option中的值，由于可能是空值，因此不安全</span></span><br></pre></td></tr></table></figure>
<p>Option也可以使用map、filter和flatMap函数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myFirstOption: <span class="type">Option</span>[<span class="type">Int</span>] = <span class="type">Some</span>(<span class="number">4</span>)</span><br><span class="line">println(myFirstOption.map(_ * <span class="number">2</span>)) 	<span class="comment">// Some(8)</span></span><br><span class="line">println(myFirstOption.filter(x =&gt; x &gt; <span class="number">10</span>))<span class="comment">// None </span></span><br><span class="line">println(myFirstOption.flatMap(x =&gt; <span class="type">Option</span>(x * <span class="number">10</span>)))<span class="comment">// Some(40)</span></span><br></pre></td></tr></table></figure>
<h4 id="for-comprehensions"><a href="#for-comprehensions" class="headerlink" title="for-comprehensions"></a>for-comprehensions</h4><p>在设计api的时候，如果返回值可能是None，我们需要在前面套一层Option使得api更加安全。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Connection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span> </span>= <span class="string">"Connected"</span> <span class="comment">// connect to some server</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">object</span> <span class="title">Connection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> random = <span class="keyword">new</span> <span class="type">Random</span>(<span class="type">System</span>.nanoTime())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(host: <span class="type">String</span>, port: <span class="type">String</span>): <span class="type">Option</span>[<span class="type">Connection</span>] =</span><br><span class="line">      <span class="keyword">if</span> (random.nextBoolean()) <span class="type">Some</span>(<span class="keyword">new</span> <span class="type">Connection</span>)</span><br><span class="line">      <span class="keyword">else</span> <span class="type">None</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> forConnectionStatus = <span class="keyword">for</span> &#123;</span><br><span class="line">  host &lt;- config.get(<span class="string">"host"</span>)</span><br><span class="line">  port &lt;- config.get(<span class="string">"port"</span>)</span><br><span class="line">  connection &lt;- <span class="type">Connection</span>(host, port)</span><br><span class="line">&#125; <span class="keyword">yield</span> connection.connect</span><br><span class="line"></span><br><span class="line">forConnectionStatus.foreach(println)</span><br></pre></td></tr></table></figure>
<h3 id="Handling-Failure"><a href="#Handling-Failure" class="headerlink" title="Handling Failure"></a>Handling Failure</h3><h2 id="Pattern-Matching"><a href="#Pattern-Matching" class="headerlink" title="Pattern Matching"></a>Pattern Matching</h2><h3 id="Pattern-Matching-1"><a href="#Pattern-Matching-1" class="headerlink" title="Pattern Matching"></a>Pattern Matching</h3><p>pattern matching是scala中很重要的一部分，它类似于switch case，可以对一个值进行条件判断，然后针对不同的条件进行不同的处理。</p>
<p>但是Scala的模式匹配的功能比Java的swich case语法的功能要强大的多，Java的swich case语法<strong>只能对值</strong>进行匹配。但是Scala的模式匹配除了可以对值进行匹配之外，还可以<strong>对类型进行匹配、对Array和List的元素情况进行匹配、对case class进行匹配、甚至对有值或没值（Option）进行匹配</strong>。 </p>
<p>一个常见的pattern match的语法如下：很容易理解，就是swich case</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> random = <span class="keyword">new</span> <span class="type">Random</span></span><br><span class="line"><span class="keyword">val</span> x = random.nextInt(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> description = x <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">"the ONE"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span> =&gt; <span class="string">"double or nothing"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span> =&gt; <span class="string">"third time is the charm"</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="string">"something else"</span>  <span class="comment">// _ = WILDCARD</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用pattern matching的时候我们要注意几点：</p>
<ul>
<li>case 要按照一定的顺序来组织，增强可读性</li>
<li>为了防止出现 MatchError的情况，一定要设置 Wildcard，也就是默认不匹配情况下的返回值。(用 <code>_</code>符号)</li>
</ul>
<p>pattern matching还有其他好用的特性</p>
<h4 id="解耦合"><a href="#解耦合" class="headerlink" title="解耦合"></a>解耦合</h4><p>模式匹配不单匹配值，甚至可以匹配类中的某个成员变量来进行条件筛选</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">bob</span> </span>= <span class="type">Person</span>(<span class="string">"Bob"</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> greeting = bob <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Person</span>(n, a) <span class="keyword">if</span> a &lt; <span class="number">21</span> =&gt; <span class="string">s"Hi, my name is <span class="subst">$n</span> and I can't drink in the US"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Person</span>(n, a) =&gt; <span class="string">s"Hi, my name is <span class="subst">$n</span> and I am <span class="subst">$a</span> years old"</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="string">"I don't know who I am"</span></span><br><span class="line">&#125;</span><br><span class="line">println(greeting)</span><br></pre></td></tr></table></figure>
<h4 id="PM在继承类中的应用"><a href="#PM在继承类中的应用" class="headerlink" title="PM在继承类中的应用"></a>PM在继承类中的应用</h4><p>Pattern Matching 甚至可以匹配子类类型。如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">  <span class="title">case</span> <span class="title">class</span> <span class="title">Dog</span>(<span class="params">breed: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">  <span class="title">case</span> <span class="title">class</span> <span class="title">Parrot</span>(<span class="params">greeting: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">  <span class="title">case</span> <span class="title">class</span> <span class="title">Cat</span>(<span class="params">meow: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">animal</span></span>: <span class="type">Animal</span> = <span class="type">Dog</span>(<span class="string">"Terra Nova"</span>)</span><br><span class="line"><span class="keyword">val</span> animal2: <span class="type">Animal</span> = <span class="type">Parrot</span>(<span class="string">"Terra Nova"</span>)</span><br><span class="line"><span class="keyword">val</span> animal3: <span class="type">Animal</span> = <span class="type">Cat</span>(<span class="string">"Meow Meow"</span>)</span><br><span class="line"></span><br><span class="line">animal3 <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Dog</span>(someBreed) =&gt; println(<span class="string">s"Matched a dog of the <span class="subst">$someBreed</span> breed"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Parrot</span>(someGreetings) =&gt; println(<span class="string">s"Match a parrot of <span class="subst">$someGreetings</span> greeting"</span>)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; println(<span class="string">"Something else"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise"></a>Exercise</h4><p>给出如下要求：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Exercise</span></span><br><span class="line"><span class="comment">  simple function uses PM</span></span><br><span class="line"><span class="comment">   takes an Expr =&gt; human readable form</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Sum(Number(2), Number(3)) =&gt; 2 + 3</span></span><br><span class="line"><span class="comment">   Sum(Number(2), Number(3), Number(4)) =&gt; 2 + 3 + 4</span></span><br><span class="line"><span class="comment">   Prod(Sum(Number(2), Number(1)), Number(3)) = (2 + 1) * 3</span></span><br><span class="line"><span class="comment">   Sum(Prod(Number(2), Number(1)), Number(3)) = 2 * 1 + 3</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>要我们用PM实现代码到数学公式的转换。这里最难想到的就是乘法的处理：</p>
<ul>
<li><code>Prod(Number(2), Number(1))</code> , 对2和1不需要改，直接变成 <code>2*1</code></li>
<li><code>Prod(Sum(Number(2),Number(1)),Number3)</code>,那么前面的<code>Sum(Number(2),Number(1))</code> 就需要额外加个括号，符合预算规则</li>
<li><code>Prod(Prod(Number(2),Number(1)),Number(3))</code> ，那么不需要括号，计算出<code>2*1</code>之后在和3计算得到<code>2*1*3</code></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Expr</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Number</span>(<span class="params">n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Sum</span>(<span class="params">e1: <span class="type">Expr</span>, e2: <span class="type">Expr</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Prod</span>(<span class="params">e1: <span class="type">Expr</span>, e2: <span class="type">Expr</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">show</span>(<span class="params">e: <span class="type">Expr</span></span>)</span>: <span class="type">String</span> = e <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Number</span>(n) =&gt;	<span class="string">s"<span class="subst">$n</span>"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Sum</span>(e1,e2) =&gt; show(e1)+<span class="string">" + "</span>+show(e2)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Prod</span>(e1,e2) =&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">matchInProdExp</span></span>(e: <span class="type">Expr</span>): <span class="type">String</span> = e <span class="keyword">match</span> &#123;</span><br><span class="line">      	<span class="keyword">case</span> <span class="type">Number</span>(n) =&gt; show(e)</span><br><span class="line">      	<span class="keyword">case</span> <span class="type">Prod</span>(e1,e2) =&gt; show(e)</span><br><span class="line">      	<span class="keyword">case</span> _ =&gt; <span class="string">"("</span>+ show(e)+<span class="string">")"</span></span><br><span class="line">    &#125;</span><br><span class="line">    matchInProdExp(e1)+<span class="string">" * "</span>+matchInProdExp(e2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">println(show(<span class="type">Sum</span>(<span class="type">Number</span>(<span class="number">2</span>), <span class="type">Number</span>(<span class="number">3</span>))))</span><br><span class="line">println(show(<span class="type">Sum</span>(<span class="type">Sum</span>(<span class="type">Number</span>(<span class="number">2</span>), <span class="type">Number</span>(<span class="number">3</span>)), <span class="type">Number</span>(<span class="number">4</span>))))</span><br><span class="line">println(show(<span class="type">Prod</span>(<span class="type">Sum</span>(<span class="type">Number</span>(<span class="number">2</span>), <span class="type">Number</span>(<span class="number">1</span>)), <span class="type">Number</span>(<span class="number">3</span>))))</span><br><span class="line">println(show(<span class="type">Prod</span>(<span class="type">Sum</span>(<span class="type">Number</span>(<span class="number">2</span>), <span class="type">Number</span>(<span class="number">1</span>)), <span class="type">Sum</span>(<span class="type">Number</span>(<span class="number">3</span>), <span class="type">Number</span>(<span class="number">4</span>)))))</span><br><span class="line">println(show(<span class="type">Sum</span>(<span class="type">Prod</span>(<span class="type">Number</span>(<span class="number">2</span>), <span class="type">Number</span>(<span class="number">1</span>)), <span class="type">Number</span>(<span class="number">3</span>))))</span><br></pre></td></tr></table></figure>
<h3 id="ALL-the-Patterns"><a href="#ALL-the-Patterns" class="headerlink" title="ALL the Patterns"></a>ALL the Patterns</h3><p>这一节我们来系统总结一下总共有多少Patterns可以供我们去匹配</p>
<h4 id="constants"><a href="#constants" class="headerlink" title="constants"></a>constants</h4><p>case里面可以是很多类型，数字、字符串、布尔值、对象等</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x: <span class="type">Any</span> = <span class="string">"Scala"</span></span><br><span class="line"><span class="keyword">val</span> constants = x <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">"a number"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">"Scala"</span> =&gt; <span class="string">"THE Scala"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="literal">true</span> =&gt; <span class="string">"The Truth"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">AllThePatterns</span> =&gt; <span class="string">"A singleton object"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="variables"><a href="#variables" class="headerlink" title="variables"></a>variables</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> matchAVariable = x <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> something =&gt; <span class="string">s"I've found <span class="subst">$something</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="wildcard"><a href="#wildcard" class="headerlink" title="wildcard"></a>wildcard</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> matchAnything = x <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> _ =&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="tuples"><a href="#tuples" class="headerlink" title="tuples"></a>tuples</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aTuple = (<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> matchATuple = aTuple <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> (<span class="number">1</span>, <span class="number">1</span>) =&gt;</span><br><span class="line">  <span class="keyword">case</span> (something, <span class="number">2</span>) =&gt; <span class="string">s"I've found <span class="subst">$something</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>甚至可以匹配 嵌套元组：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> nestedTuple = (<span class="number">1</span>, (<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="keyword">val</span> matchANestedTuple = nestedTuple <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> (_, (<span class="number">2</span>, variable)) =&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="case-classes"><a href="#case-classes" class="headerlink" title="case classes"></a>case classes</h4><p>constructor pattern可以匹配我们自己创建的case class。比如说我创建了一个MyList[Int]类型的列表。case类型可以类似于case class的构造器，用来解构类中的成员</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aList: <span class="type">MyList</span>[<span class="type">Int</span>] = <span class="type">Cons</span>(<span class="number">1</span>, <span class="type">Cons</span>(<span class="number">2</span>, <span class="type">Empty</span>))</span><br><span class="line">  </span><br><span class="line"><span class="keyword">val</span> matchAList = aList <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Empty</span> =&gt; <span class="string">"Empty"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Cons</span>(head, <span class="type">Cons</span>(subhead, subtail)) =&gt; <span class="string">s"head is <span class="subst">$head</span>, subhead is <span class="subst">$subhead</span>, subtail is <span class="subst">$subtail</span>"</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">println(matchAList)<span class="comment">//head is 1, subhead is 2, subtail is []</span></span><br></pre></td></tr></table></figure>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>List  patterns非常有用,它可以有很多种形式的case</p>
<ul>
<li><code>case List(1, _, _, _)</code>  匹配开头为1，长度为4的List</li>
<li><code>case List(1, _*)</code> 匹配开头为1，长度不限的List</li>
<li><code>case 1 :: List(_)</code> 匹配开头为1的List</li>
<li><code>case List(1,2,_) :+ 42</code> 匹配以42结束的List</li>
<li><code>case h :: t =&gt; h + &quot;&quot; + processList(t)</code> 提取list的头元素和尾元素</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aStandardList = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">42</span>)</span><br><span class="line"><span class="keyword">val</span> standardListMatching = aStandardList <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">List</span>(<span class="number">1</span>, _, _, _) =&gt; <span class="comment">// extractor - advanced</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">List</span>(<span class="number">1</span>, _*) =&gt; <span class="comment">// list of arbitrary length - advanced</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span> :: <span class="type">List</span>(_) =&gt; <span class="comment">// infix pattern</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,_) :+ <span class="number">42</span> =&gt; <span class="string">"lala"</span><span class="comment">// infix pattern</span></span><br><span class="line">  <span class="keyword">case</span> h :: t =&gt; h + <span class="string">""</span> + processList(t) <span class="comment">//haskell-like prepending</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>scala还可以匹配输入对象的类型，如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> unknown: <span class="type">Any</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">val</span> unknownMatch = unknown <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> list: <span class="type">List</span>[<span class="type">Int</span>] =&gt; <span class="comment">// explicit type specifier</span></span><br><span class="line">  <span class="keyword">case</span> _:<span class="type">String</span> =&gt; <span class="string">"this method returns String"</span></span><br><span class="line">  <span class="keyword">case</span> _:<span class="type">Int</span> =&gt; <span class="string">"this method returns Int"</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="string">"this method returns something else"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="name-binding"><a href="#name-binding" class="headerlink" title="name binding"></a>name binding</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> nameBindingMatch = aList <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> nonEmptyList @ <span class="type">Cons</span>(_, _) =&gt; <span class="comment">// name binding =&gt; use the name later(here)</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Cons</span>(<span class="number">1</span>, rest @ <span class="type">Cons</span>(<span class="number">2</span>, _)) =&gt; <span class="comment">// name binding inside nested patterns</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="multi-patterns"><a href="#multi-patterns" class="headerlink" title="multi-patterns"></a>multi-patterns</h4><p>multiple patterns就是将两个模式用 Pipe符号连接起来——只要符合其中一个模式，就匹配成功，如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 8 - multi-patterns</span></span><br><span class="line"><span class="keyword">val</span> multipattern = aList <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Empty</span> | <span class="type">Cons</span>(<span class="number">0</span>, _) =&gt; <span class="comment">// compound pattern (multi-pattern)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="if-guards"><a href="#if-guards" class="headerlink" title="if guards"></a>if guards</h4><p>可在模式后添加 if 语句</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> secondElementSpecial = aList <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Cons</span>(_, <span class="type">Cons</span>(specialElement, _)) <span class="keyword">if</span> specialElement % <span class="number">2</span> == <span class="number">0</span> =&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注明"><a href="#注明" class="headerlink" title="注明"></a>注明</h4><p>JVM中会存在type erase的情况，如下：</p>
<p>此时打印 numbersMath，会得到 a list of strings，这是因为在 Java刚开始被创建时，是没有泛型这一概念的，泛型直到Java5才被加入。因此，JVM在做类型判断的时候，为了能让Java1的程序也能运行，在判断的时候，将泛型全部抹去了</p>
<p>因此，在java内部，事实上不会对List究竟是哪一种类型的做匹配，而是只匹配是否为List</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numbers: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"> <span class="keyword">val</span> numbersMatch = numbers <span class="keyword">match</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> listOfStrings: <span class="type">List</span>[<span class="type">String</span>] =&gt; <span class="string">"a list of strings"</span></span><br><span class="line">   <span class="keyword">case</span> listOfNumbers: <span class="type">List</span>[<span class="type">Int</span>] =&gt; <span class="string">"a list of numbers"</span></span><br><span class="line">   <span class="keyword">case</span> _ =&gt; <span class="string">""</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> println(numbersMatch)</span><br></pre></td></tr></table></figure>
<h3 id="Patterns-Everywhere"><a href="#Patterns-Everywhere" class="headerlink" title="Patterns Everywhere"></a>Patterns Everywhere</h3><p>事实上，模式匹配的思想在 scala中随处可见：</p>
<h4 id="在try-catch中"><a href="#在try-catch中" class="headerlink" title="在try-catch中"></a>在try-catch中</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> e: <span class="type">RuntimeException</span> =&gt; <span class="string">"runtime"</span></span><br><span class="line">  <span class="keyword">case</span> npe: <span class="type">NullPointerException</span> =&gt; <span class="string">"npe"</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="string">"something else"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在try-catch中的case 其实是简写的形式，事实上在catch里面也有一个match，如下</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  e <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> e: <span class="type">RuntimeException</span> =&gt; <span class="string">"runtime"</span></span><br><span class="line">    <span class="keyword">case</span> npe: <span class="type">NullPointerException</span> =&gt; <span class="string">"npe"</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="string">"something else"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在-for-中"><a href="#在-for-中" class="headerlink" title="在 for 中"></a>在 for 中</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="keyword">val</span> evenOnes = <span class="keyword">for</span> &#123;</span><br><span class="line">  x &lt;- list <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="comment">//也是一种模式匹配</span></span><br><span class="line">&#125; <span class="keyword">yield</span> <span class="number">10</span> * x</span><br><span class="line"></span><br><span class="line"><span class="comment">// generators are also based on PATTERN MATCHING</span></span><br><span class="line"><span class="keyword">val</span> tuples = <span class="type">List</span>((<span class="number">1</span>,<span class="number">2</span>), (<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="keyword">val</span> filterTuples = <span class="keyword">for</span> &#123;</span><br><span class="line">  (first, second) &lt;- tuples</span><br><span class="line">&#125; <span class="keyword">yield</span> first * second</span><br></pre></td></tr></table></figure>
<h4 id="Tuple-List"><a href="#Tuple-List" class="headerlink" title="Tuple, List"></a>Tuple, List</h4><p>可以直接提取出tuple、list中的元素，这也包含了PM的思想。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> tuple = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> (a, b, c) = tuple</span><br><span class="line">println(b) </span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> head :: tail = list</span><br><span class="line">println(head)</span><br><span class="line">println(tail)</span><br></pre></td></tr></table></figure>
<h4 id="partial-function"><a href="#partial-function" class="headerlink" title="partial function"></a>partial function</h4><p>有时我们会遇到这样子的函数，可能会被搞得不知道是什么意思，其实这也是PM的简化形式</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="keyword">val</span> mappedList = list.map &#123;</span><br><span class="line">  <span class="keyword">case</span> v <span class="keyword">if</span> v % <span class="number">2</span> == <span class="number">0</span> =&gt; v + <span class="string">" is even"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">"the one"</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="string">"something else"</span></span><br><span class="line">&#125; <span class="comment">// partial function literal</span></span><br></pre></td></tr></table></figure>
<p>省去了对每一个list中的元素x做match的过程</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mappedList2 = list.map &#123; x =&gt; x <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> v <span class="keyword">if</span> v % <span class="number">2</span> == <span class="number">0</span> =&gt; v + <span class="string">" is even"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">"the one"</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="string">"something else"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/04/08/Solidity%E5%88%9D%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/" itemprop="url">Solidity初识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-04-08T19:05:05+08:00">
                2022-04-08
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2025-04-11T10:18:57+08:00">
                2025-04-11
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Solidity初识"><a href="#Solidity初识" class="headerlink" title="Solidity初识"></a>Solidity初识</h1><p>Solidity是编写智能合约的语言，由于区块链课程需要我们编写Solidity智能合约，我又从来没对Solidity有过了解，因此借这篇博客了解一些有关Solidity的知识。</p>
<p>我们的IDE主要是在线的Remix：<a href="https://remix.ethereum.org/" target="_blank" rel="noopener">https://remix.ethereum.org/</a></p>
<p>我们也可以在本地安装solc编译器：brew install solidity(mac端)</p>
<h3 id="Smart-Contract-Compilation-In-Depth-ABI-and-Bytecode"><a href="#Smart-Contract-Compilation-In-Depth-ABI-and-Bytecode" class="headerlink" title="Smart Contract Compilation In Depth ABI and Bytecode"></a>Smart Contract Compilation In Depth ABI and Bytecode</h3><p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/1.png" style="zoom:60%;"></p>
<p>首先，我们来看看Solidity的编译过程。首先，我们写好智能合约文件，并交给Solidity Compiler 去编译。并得到一个ABI文件和一个Contract Bytecode文件。 </p>
<ul>
<li>ABI文件是函数描述符(Application Binary Interface)的缩写，它是智能合约的接口描述，描述了字段名称、字段类型、方法名称、参数名称、参数类型、方法返回值类型等。</li>
<li>Bytecode就是字节码，类似于Java 编译后的字节码。有了字节码就可以在任何安装了EVM的机器上运行了。</li>
</ul>
<p>比如我们编写一个最简单的 智能合约：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: GPL-3.0</span><br><span class="line"></span><br><span class="line">pragma solidity 0.8.7;</span><br><span class="line"></span><br><span class="line">contract Property &#123;</span><br><span class="line">    int public value;</span><br><span class="line"></span><br><span class="line">    function setValue(int _value) public&#123;</span><br><span class="line">        value &#x3D; _value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Remix上编译后可以得到其ABI和Bytecode：</p>
<ul>
<li>下面是一个json格式的文档，从remix上复制下来的，object的这串数字就是这个程序的Bytecode，是以16进制编写的，在本地用solc编译的话只会得Bytecode</li>
<li>opcodes是操作代码，有点像汇编。当Bytecode输入到EVM之后，会被翻译成操作码。操作码是程序的低级可读指令，所有操作码都有对应的16进制值,我们可以在<a href="https://ethereum.org/en/developers/docs/evm/opcodes/" target="_blank" rel="noopener">这个网站</a> 找到与其对应的值。比如说MUL 代表乘法操作，对应的值为<code>0x02</code>, 消耗的Gas为5。</li>
</ul>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/2.png" style="zoom:60%;"></p>
<p>事实上，我们可以在<a href="https://etherscan.io/opcode-tool" target="_blank" rel="noopener">Etherscan这个网站</a> 来解码 ByteCode，得到Opcode：</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/3.png" style="zoom:60%;"></p>
<p>现在我们来看看ABI, ABI是以json格式组织的。ABI文件中各参数如下</p>
<ul>
<li>name: 函数名称</li>
<li>type：方法类型，包括function, constructor, fallback(缺省方法)可以缺省，默认为function</li>
<li>constant：布尔值，如果为true指明方法不会修改合约字段的状态变量</li>
<li>payable：布尔值，标明方法是否可以接收ether</li>
<li>stateMutability：状态类型，包括pure (不读取区块链状态)，view (和constant类型，只能查看，不会修改合约字段)，nonpayable（和payable含义一样），payable（和payable含义一样）。其实保留payable和constant是为了向后兼容</li>
<li>inputs：数组，描述参数的名称和类型<ul>
<li>name：参数名称</li>
<li>type：参数类型</li>
</ul>
</li>
<li>outputs：和inputs一样，如果没有返回值，缺省是一个空数组</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">"inputs"</span>: [</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">"internalType"</span>: <span class="string">"int256"</span>,</span><br><span class="line">				<span class="attr">"name"</span>: <span class="string">"_value"</span>,</span><br><span class="line">				<span class="attr">"type"</span>: <span class="string">"int256"</span></span><br><span class="line">			&#125;</span><br><span class="line">		],</span><br><span class="line">		<span class="attr">"name"</span>: <span class="string">"setValue"</span>,</span><br><span class="line">		<span class="attr">"outputs"</span>: [],</span><br><span class="line">		<span class="attr">"stateMutability"</span>: <span class="string">"nonpayable"</span>,</span><br><span class="line">		<span class="attr">"type"</span>: <span class="string">"function"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">"inputs"</span>: [],</span><br><span class="line">		<span class="attr">"name"</span>: <span class="string">"value"</span>,</span><br><span class="line">		<span class="attr">"outputs"</span>: [</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">"internalType"</span>: <span class="string">"int256"</span>,</span><br><span class="line">				<span class="attr">"name"</span>: <span class="string">""</span>,</span><br><span class="line">				<span class="attr">"type"</span>: <span class="string">"int256"</span></span><br><span class="line">			&#125;</span><br><span class="line">		],</span><br><span class="line">		<span class="attr">"stateMutability"</span>: <span class="string">"view"</span>,</span><br><span class="line">		<span class="attr">"type"</span>: <span class="string">"function"</span></span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="Contract-Deployment-on-JS-VM"><a href="#Contract-Deployment-on-JS-VM" class="headerlink" title="Contract Deployment on JS VM"></a>Contract Deployment on JS VM</h3><p>我们在部署界面可以选择合约部署的环境，在这里我们有三个选择：</p>
<ul>
<li>JavaScript VM，这种方式就是在Remix网页上启动一个虚拟区块链环境，然后所有的交易都会在这个虚拟环境(沙箱)中执行。每次刷新页面，JS VM都会重置整个区块链。虽然不是永久的，但是在测试阶段还是非常有用的。</li>
<li>Injected Web3, remix会连接一个web3 provider(如MetaMask)并自动获取地址和余额，点击Deploy发布，会在测试网络中发布刚刚编译好的合约，（可能会是10s钟的时间，也可能久一些），当合约部署完毕，我们就可以在区块浏览器上查看到这条合约的详细信息了。当我们想在以太坊主网或者测试网上部署交易，可以选择这种。</li>
<li>Web3 Provider，使用这种模式Remix会连接一个远程的以太坊客户端，比如说geth。</li>
</ul>
<p>这里我们主要使用前两种方式。首先我们看看第一个 JavaScript VM，在我们编译完成之后，我们进入部署页面：</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/4.png" style="zoom:60%;"></p>
<p>看到默认会生成若干以太坊账户，每个账户中都有100个虚拟的以太币。</p>
<p>然后我们点击Deploy,发现在Deployed Contract中已经有一个合约了，里面有setValue函数接口可以供我们调试。同时我们发现，部署这个合约需要消耗一定量的以太币。</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/5.png" style="zoom:60%;"></p>
<p>现在我们看看调用setValue会怎么样：我们看到，setValue也需要消耗一定量的代价(这里是43724 gas)</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/6.png" style="zoom:60%;"></p>
<p>当然我们也可以将一个智能合约部署多次，每个合约的地址都不同，它们之间的变量是不共享、不互通的 </p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/7.png" style="zoom:60%;"></p>
<h3 id="Contract-Deployment-on-Rinkeby-Using-Remix-and-MetaMask"><a href="#Contract-Deployment-on-Rinkeby-Using-Remix-and-MetaMask" class="headerlink" title="Contract Deployment on Rinkeby Using Remix and MetaMask"></a>Contract Deployment on Rinkeby Using Remix and MetaMask</h3><p>现在我们用第二种Injected Web3方式来部署合约到Rinkeby测试网络上，这是一种更接近真实情况。首先，我们要注册MetaMask账号，然后通过一些列设置就可以让Remix获取我们的账号地址和账户余额了。</p>
<p>如果我们选择在以太坊主网上部署，是需要钱的，我们自然不可能在这上面部署。</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/8.png" style="zoom:60%;"></p>
<p>因此我们可以切换网络：</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/9.png" style="zoom:60%;"></p>
<p>但是我们看到这个账户在Ropsten测试网络一开始也是没有以太币的，我们需要到某些特殊的网站中去乞讨(水龙头网站)，比如：</p>
<ul>
<li><a href="https://faucet.egorfine.com/" target="_blank" rel="noopener">https://faucet.egorfine.com/</a> ，每次可以领0.15个以太币，间隔时长为1天，只限制Ropsten测试网络</li>
<li><a href="https://faucet.dimensions.network/" target="_blank" rel="noopener">https://faucet.dimensions.network/</a> ，每次可以领取1个以太币，间隔时长为1天，Ropsten测试网络</li>
<li><a href="https://faucets.chain.link/rinkeby" target="_blank" rel="noopener">https://faucets.chain.link/rinkeby</a> ，每次可以领0.1个以太币，不限次数，限制在Kovan和Rinkeby测试网络</li>
<li><a href="https://moonborrow.com/" target="_blank" rel="noopener">https://moonborrow.com/</a> , 每次随机，仅限Ropsten</li>
</ul>
<p>当我领完以太币以后，就可以点击部署了,我们看到部署这个比特币需要0.00029921个Ropsten测试网络上的以太币</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/10.jpg" style="zoom:60%;"></p>
<p>我们也可以在 Etherscan 上看到被我们部署上去的合约：</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/11.png" style="zoom:60%;"></p>
<p>如果我们想调用setValue, 还是需要”花钱的”, 如下所示：</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/12.png" style="zoom:60%;"></p>
<p>经过了一段时间的等待，在这个过程中需要经过提交、验证等操作，成功以后，我们在EtherScan上可以看到这个交易</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/13.png" style="zoom:60%;"></p>
<p>在交易未成功的时候，点击value仍然会返回0，但是当交易success之后，点击value就可以返回我们的当时设定的值了。</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/14.png" style="zoom:60%;"></p>
<h3 id="The-Structure-of-a-Smart-Contract"><a href="#The-Structure-of-a-Smart-Contract" class="headerlink" title="The Structure of a Smart Contract"></a>The Structure of a Smart Contract</h3><p>现在来介绍一下一个智能合约的结构</p>
<ul>
<li>SPDX版本</li>
</ul>
<p>首先，在合约的一开始一定要标明 SPDX License Identifier的版本, 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: GPL-3.0</span><br></pre></td></tr></table></figure>
<p>因为从Solidity ^ 0.6.8开始，引入了SPDX许可证。因此，你需要在代码中使用SPDX-License-Identifier，虽然它被注释掉了，但是在编译后的Bytecode中还是能被EVM识别到的。如果我们不写的话，会出现Warning。</p>
<ul>
<li>Solidity版本</li>
</ul>
<p>然后，需要写明这个智能合约用的是solidity的哪个版本。我们可以在 <a href="https://docs.soliditylang.org/en/v0.8.13/080-breaking-changes.html" target="_blank" rel="noopener">solidity文档</a> 中查看每个版本的更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.8.7;</span><br></pre></td></tr></table></figure>
<p>此外，也可以划定 Solidity 版本的一个范围，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;&#x3D;0.5.0 &lt;0.9.0</span><br></pre></td></tr></table></figure>
<ul>
<li>合约本体</li>
</ul>
<p>最后就是整个合约的本体了，这就类似于一个class的概念，我们以这个合约为例，看看合约里面有哪些成员</p>
<ol>
<li>首先是两个成员变量 price和owner</li>
<li>然后是一个构造函数，构造函数只会被调用一次</li>
<li>接下来是一个Function Modifier,也就是函数修饰器。利用函数修饰器可在执行函数之前自动检查条件。比如说，这边changeOwner就调用了这个函数修饰器。是用来检查发起者是否等于当前owner的，如果不是，就会抛出错误信息。<ul>
<li>在定义onlyOwner出现的特殊符号 <code>_</code>，是使用该修饰器的函数体插入位置。 ‘_’符号可多次出现，替换成对应的函数体即可。</li>
</ul>
</li>
<li>changeOwner函数和setPrice都是 setter，即给合约的成员变量赋值的。</li>
<li>getPrice函数时getter，用来返回price，因此需要在定义函数后还要写上返回值的类型。</li>
<li><p>以上函数都是public的，也就是外部可以调用的(比如python可以就可以通过这些函数调用来获取一些值)</p>
</li>
<li><p>最后是event(事件)，事件是以太坊虚拟机(EVM)日志基础设施提供的一个便利接口。当被发送事件（调用）时，会触发参数存储到交易的日志中（一种区块链上的特殊数据结构）。这些日志与合约的地址关联，并记录到区块链中.</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: GPL-3.0</span><br><span class="line"></span><br><span class="line">pragma solidity &gt;&#x3D;0.5.0 &lt;0.9.0</span><br><span class="line">contract Property&#123;</span><br><span class="line">  uint private price;</span><br><span class="line">  address public owner;</span><br><span class="line">  </span><br><span class="line">  constructor ()&#123;</span><br><span class="line">	  price &#x3D;0;</span><br><span class="line"> 		owner &#x3D; msg. sender;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; Function Modifier</span><br><span class="line">  modifier onlyOwner()&#123;</span><br><span class="line">  		require(msg.sender &#x3D;&#x3D; owner);</span><br><span class="line">  		_;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function changeOwner (address _owner) public onlyOwner &#123;</span><br><span class="line">  		owner &#x3D;  _owner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function setPrice(uint _price) public &#123;</span><br><span class="line">  		price &#x3D; _price;</span><br><span class="line">  &#125;</span><br><span class="line">  function getPrice() view public returns (uint) &#123;</span><br><span class="line">  		return price;</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  &#x2F;&#x2F; Event </span><br><span class="line">  event OwnerChanged(address owner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Solidity-Basic-Syntax-Rules"><a href="#Solidity-Basic-Syntax-Rules" class="headerlink" title="Solidity Basic Syntax Rules"></a>Solidity Basic Syntax Rules</h3><p>下面来介绍下solidity 的一些基本语法：</p>
<ul>
<li>Solidity是一种高级静态类型的智能合约编程语言，类似于JavaScript。sol是solidity的命令行编译器。</li>
<li>Solidity是区分大小写的。</li>
<li><p>每条语句都必须以分号结尾。</p>
</li>
<li><p>它使用大括号{}来划分代码块的界限。</p>
</li>
<li><p><code>//</code>代表一个单行注释。</p>
</li>
<li><p><code>/*... */</code>代表多行（块）注释。</p>
</li>
<li><p><code>///</code>代表单行natspec注释，<code>/**...*/</code>代表块状natspec注释。 natspec用于函数声明文档。</p>
</li>
<li>大多数控制结构都是可用的：if, else, while, for, break, continue, return。</li>
</ul>
<h3 id="State-and-Local-Variables"><a href="#State-and-Local-Variables" class="headerlink" title="State and Local Variables"></a>State and Local Variables</h3><p>solidity 是显式的语言，因此在声明变量和函数的时候都要注明其类型及其公有还是私有的。</p>
<p>但是变量也是分为 state variables(状态变量)和local variable(本地变量)两种。</p>
<ol>
<li><p>State Variale</p>
<ul>
<li><p>是在合约层面定义的</p>
</li>
<li><p>使用旧的存储在合约里面的</p>
</li>
<li><p>可以被置为常量，如<code>string constant public location=&quot;London&quot;</code></p>
</li>
<li><p>设置State Variable需要消耗 gas</p>
</li>
<li><p>在声明的时候需要初始化，后续可以使用构造函数或者setter对其进行修改。注意如下情况是不被允许的:</p>
<ul>
<li>```solidity<br>int public price ;<br>price = 1;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. Local Variable</span><br><span class="line"></span><br><span class="line">   + 在函数内部被声明</span><br><span class="line">   + 不消耗gas</span><br><span class="line"></span><br><span class="line">比如下面这个函数 ，在函数里面定义变量和直接对变量 修改都是被允许的。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;solidity</span><br><span class="line">function f1() public pure returns(uint256)&#123;</span><br><span class="line">    int x &#x3D; 5;</span><br><span class="line">    x &#x3D; x*2;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="view-amp-pure"><a href="#view-amp-pure" class="headerlink" title="view &amp; pure"></a>view &amp; pure</h4><p>在这里还要区分一下两个函数修饰符：view和pure，如上面我们就用pure来修饰f1</p>
<ol>
<li>View 表示一个函数不能修改状态，在本地执行时并不消耗gas</li>
<li>Pure 表示一个函数不读取状态，也不修改状态</li>
</ol>
<p>下面几种情况认为是修改了状态：</p>
<ul>
<li>写状态变量</li>
<li>触发时间</li>
<li>创建其他合约</li>
<li>call 调用附加了以太币</li>
<li>调用了任何没有view或pure修饰的函数</li>
<li>使用了低级别的调用(low-level calls)</li>
</ul>
<p>下面集中情况是读取了状态：</p>
<ul>
<li>读状态变量</li>
<li>访问了.balance属性</li>
<li>访问了block、tx、msg成员(msg.sig和msg.data除外)</li>
<li>调用了任何没有pure修饰的函数</li>
</ul>
<p>因此，getter一般需要用view进行修饰，因为他们通常需要读取状态变量，但不涉及写状态变量；但是setter一般不需要view和pure进行修饰，因为setter修改了状态</p>
<h4 id="storage-amp-memory-amp-stack"><a href="#storage-amp-memory-amp-stack" class="headerlink" title="storage &amp; memory &amp; stack"></a>storage &amp; memory &amp; stack</h4><p>在solidity合约内部， 函数外部声明的变量默认储存在storage里，函数内部声明的变量默认储存在memory里。那么storage和memory有什么区别呢？</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">storage</th>
<th>memory</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">储存的变量</td>
<td style="text-align:left">函数外部声明的变量，即状态变量</td>
<td>函数内部声明的变量，即局部变量</td>
</tr>
<tr>
<td style="text-align:left">存储的位置</td>
<td style="text-align:left">区块链上，永久存在</td>
<td>内存中，运行完之后销毁(与RAM类似)</td>
</tr>
<tr>
<td style="text-align:left">运行的位置</td>
<td style="text-align:left">区块链网络上</td>
<td>单个节点</td>
</tr>
</tbody>
</table>
</div>
<p>但是，比如我想在函数中声明一个字符串变量，如<code>string tmp = &quot;xxx&quot;</code> ,是会报错的。因为string 是一种比较特殊的类型，它不能隐式地转换为预期的字符串存储指针。因此，为了解决这个问题，我们需要显式地定义函数中的字符串，也就是 <code>string memory tmp = &quot;xxx&quot;</code> </p>
<p>其实，solidity 还有一部分空间被称为stack，他存储的是那些在函数中声明的，<strong>非引用类型的局部变量</strong>(比如int)</p>
<p>stack和memory的区别在于，memory存放的是在函数中声明的且用memory修饰的<strong>引用类型的 </strong>局部变量。</p>
<p>常见的引用类型有：string、array、struct 和 mapping， 在函数中声明这些类型的变量都需要用memory修饰</p>
<h3 id="Functions-Setters-and-Getters"><a href="#Functions-Setters-and-Getters" class="headerlink" title="Functions, Setters, and Getters"></a>Functions, Setters, and Getters</h3><p>Functions可以理解为是在合约内部的接口。函数类型也是值类型的一种，和C语言中的函数指针类似，用于指向一个函数，可以用于实现回调等功能。</p>
<h4 id="setter"><a href="#setter" class="headerlink" title="setter"></a>setter</h4><p>我们现在来讲讲Getter和Setter的定义规范</p>
<ul>
<li>setter：setter需要外部传入信息，因此在函数名称之后要用括号来包含传参，为了和状态变量有所区分，传参前面要加下划线。因为setter需要修改状态，所以不能用view/pure修饰；又是需要外部调用的，所以用public修饰。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function setPrice(int _price) public&#123;</span><br><span class="line">		price &#x3D; _price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function setLocation(string memory _location) public&#123;</span><br><span class="line">		localtion &#x3D; _location;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h4><ul>
<li>getter: getter需要向调用者返回信息，因此不需要传参。由于getter只需要访问状态变量，不需要改写状态变量，因此需要用view来进行修饰。同时因为要返回信息，因此在view修饰词之后还要写 <code>return(返回信息的类型)</code> </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function getPrice() public view returns(int)&#123;</span><br><span class="line">	return price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getLocation() public view returns(string memory _location) &#123;</span><br><span class="line">		localtion &#x3D; _location;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="The-Constructor"><a href="#The-Constructor" class="headerlink" title="The Constructor"></a>The Constructor</h3><p>构造函数我们已经很熟悉了，当合约被创建的时候它就会被调用，且仅被调用一次。默认是public的，我们不用显式声明。</p>
<p>我们看到下面这个构造函数中，出现了<code>owner =  msg.sender</code> ,这是什么意思</p>
<ul>
<li><strong>msg.sender</strong>，它指的是<strong>当前调用者（或智能合约）的 address</strong> <ul>
<li>在 Solidity 中，功能执行始终需要从<strong>外部调用者</strong>开始。 一个合约只会在区块链上什么也不做，除非有人调用其中的函数。所以 msg.sender总是存在的。</li>
</ul>
</li>
</ul>
<p>在这里，由于是我自己发布的合约，因此这里msg.sender就是我的address</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract Property&#123;</span><br><span class="line">		string public location;</span><br><span class="line">		int public price;</span><br><span class="line">		address public owner</span><br><span class="line">		</span><br><span class="line">		constructor(int _price, string memory _location)&#123;</span><br><span class="line">				price &#x3D; _price;</span><br><span class="line">				location &#x3D; _location;</span><br><span class="line">				owner &#x3D; msg.sender;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="immutable-amp-constant"><a href="#immutable-amp-constant" class="headerlink" title="immutable&amp;constant"></a>immutable&amp;constant</h4><ul>
<li>Constant</li>
</ul>
<p>当然，如果我在合约中声明的成员是一个常量，那么就不需要再constructor中对其进行赋值了，但是，在声明的时候就需要对其进行赋值，同时使用constant进行修饰</p>
<p>constant 修饰的变量需要在<strong>编译期确定值</strong>, 链上不会为这个变量分配存储空间, 它会在编译时用具体的值替代, 因此, constant常量是不支持使用运行时状态赋值的 (例如: <code>block.number</code> , <code>now</code> , <code>msg.sender</code> 等 )</p>
<p>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int constant area &#x3D; 100;</span><br></pre></td></tr></table></figure>
<ul>
<li>Immutable</li>
</ul>
<p>immutable 修饰的变量是在<strong>部署的时候确定变量的值</strong>, 它在构造函数中赋值一次之后,就不在改变, 这是一个运行时赋值, 就可以解除之前 constant 不支持使用运行时状态赋值的限制.</p>
<p>immutable不可变量同样不会占用状态变量存储空间, 在部署时,变量的值会被追加的运行时字节码中, 因此它<strong>比使用状态变量便宜的多</strong>, 同样带来了更多的安全性(确保了这个值无法在修改).</p>
<p>可以这样理解：constant是声明时候赋值，不能经constructor赋值；immutable可以不在声明时赋值，可以由constructor赋值，之后就不能再改变。</p>
<h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>Solidity是静态类型语言,也就是数据类型是在编译期间就决定的，和C++、Java是一样的。<code>solidity</code>编程语言提供了一些<code>基本类型（simple types）</code>可以用来组合成复杂类型。</p>
<h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><p>值类型包含</p>
<ul>
<li>布尔（Booleans）</li>
<li>整形（Integer）</li>
<li>地址（Address）</li>
<li>定长字节数组（fixed byte arras）</li>
<li>有理数和整形（Rational and Integer Literals，String literals）</li>
<li>枚举类型（Enums）</li>
<li>函数（Function Types）</li>
</ul>
<p>为什么会叫值类型，是因为上述这些类型在传值时，总是值传递。比如在函数传参数时，或进行变量赋值时。</p>
<h4 id="引用类型（Reference-Types）"><a href="#引用类型（Reference-Types）" class="headerlink" title="引用类型（Reference Types）"></a>引用类型（Reference Types）</h4><p>复杂类型，占用空间较大的。在拷贝时占用空间较大。所以考虑通过引用传递。常见引用类型有：</p>
<ul>
<li>不定长字节数组（bytes）</li>
<li>字符串（string）</li>
<li>数组（Array）</li>
<li>结构体（Structs）</li>
</ul>
<h4 id="布尔（Booleans）"><a href="#布尔（Booleans）" class="headerlink" title="布尔（Booleans）"></a>布尔（Booleans）</h4><p>bool：可能的取值为常量true 和 false<br>支持的运算符：</p>
<ul>
<li><code>!</code> 逻辑非</li>
<li><code>&amp;&amp;</code>逻辑与</li>
<li><code>||</code>逻辑或</li>
<li><code>==</code>等于</li>
<li><code>!=</code>不等于<br>注意：<code>&amp;&amp;</code>和 <code>||</code> 是短路运算符，他只会先执行前面的，如果无法判定结果才会执行后面的，比如 <code>f(x) || g(y)</code>，如果<code>f(x</code>)已经判定为false,则结果为false,不会再执行<code>g(y)</code>;同理 <code>f(x) &amp;&amp; g(y)</code>若<code>f(x)</code>判定为真,则 <code>g(y)</code>也不会再执行。</li>
</ul>
<p>如果声明的布尔变量未被初始化，那么其会被默认置为false</p>
<h4 id="整形（Integer）"><a href="#整形（Integer）" class="headerlink" title="整形（Integer）"></a>整形（Integer）</h4><p>int/uint: 变长的有符号或无符号整形.变量支持的步长以8递增,支持从 <code>uint8</code> 到 <code>uint256</code>,以及 <code>int8</code> 到 int256。需要<code>注意</code>的是，<code>uint</code> 和 <code>int</code> 默认代表的是 <code>uint256</code>($0\sim2^{256}$) 和 <code>int256</code>($2^{-128}\sim 2^{127}$)</p>
<p>支持的运算符:</p>
<ul>
<li>比较: <code>&lt;=</code> , <code>&lt;</code> , <code>==</code>, <code>!=</code> , <code>&gt;=</code>, <code>&gt;</code>, 返回值为bool类型。</li>
<li>位运算符： <code>&amp;</code> ， <code>|</code> ， (<code>^</code>异或) , (<code>~</code>非).</li>
<li>数学运算: <code>+</code> , <code>-</code>, <code>*</code> ,<code>/</code>, (<code>%</code>求余), ( <code>**</code>幂)</li>
</ul>
<p>整数除法总是截断的,但如果运算符是字面量,则不会截断(后面会进一步提到).另外除 0 会抛出异常.</p>
<p>如果声明了整型但不对其进行初始化，那么会被默认置为0；</p>
<h4 id="定长数组-Fixed-Size-Arrays"><a href="#定长数组-Fixed-Size-Arrays" class="headerlink" title="定长数组 Fixed-Size Arrays"></a>定长数组 Fixed-Size Arrays</h4><p>现在我们来介绍定长数组，在编译的时候它的长度已经被确定下来了。</p>
<p><strong>成员变量</strong><br><code>.length</code> 表示这个字符数组的长度（只读）</p>
<p>固定大小字节数组可以通过 <code>bytes1, bytes2, bytes3, …, bytes32</code>来进行声明。PS：<code>byte</code>的别名就是 <code>byte1</code>。</p>
<ul>
<li><code>bytes1</code>只能存储<code>一个</code>字节，也就是二进制<code>8位</code>的内容。</li>
<li><code>bytes2</code>只能存储<code>两个</code>字节，也就是二进制<code>16位</code>的内容。</li>
<li><code>bytes3</code>只能存储<code>三个</code>字节，也就是二进制<code>24位</code>的内容。<br> ……</li>
<li><p><code>bytes32</code>能存储<code>三十二个</code>字节，也就是二进制<code>32 * 8 = 256</code>位的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">contract C &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 0x6c697975656368756e</span><br><span class="line">    </span><br><span class="line">    byte public a &#x3D; 0x6c; &#x2F;&#x2F; 0110 1100</span><br><span class="line">    bytes1 public b &#x3D; 0x6c; &#x2F;&#x2F; 0110 1100</span><br><span class="line">    bytes2 public c &#x3D; 0x6c69; &#x2F;&#x2F; 0110 1100 0110 1001</span><br><span class="line">    bytes3 public d &#x3D; 0x6c6979; &#x2F;&#x2F; 0110 1100 0110 1001 0111 1001</span><br><span class="line">    bytes4 public e &#x3D; 0x6c697975; &#x2F;&#x2F; 0110 1100 0110 1001 0111 1001 0111 0101</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    </span><br><span class="line">    bytes8 public f &#x3D; 0x6c69797565636875; &#x2F;&#x2F; 0110 1100 0110 1001 0111 1001 0111 0101 0110 0101 0110 0011 0110 1000 0111 0101</span><br><span class="line">    bytes9 public g &#x3D; 0x6c697975656368756e; &#x2F;&#x2F; &#x2F;&#x2F; 0110 1100 0110 1001 0111 1001 0111 0101 0110 0101 0110 0011 0110 1000 0111 0101 0110 1110</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>使用这种方法来定义的话，无法对特定的位数进行赋值，比如<code>a[0]=&#39;a&#39;</code> 是不可以的</p>
<p>而且这样很不直观，我们可以像定义普通数组一样来声明定长数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">contract FixedSizeArrays&#123;</span><br><span class="line">		uint[3] public numbers;&#x2F;&#x2F;未初始化，就都为0</span><br><span class="line">		uint[3] public numbers3 &#x3D; [2,3,4];&#x2F;&#x2F;初始化</span><br><span class="line">		</span><br><span class="line">		&#x2F;*</span><br><span class="line">		setter 可以调用此函数为数组中的某个元素赋值</span><br><span class="line">		*&#x2F;</span><br><span class="line">		function setElement(uint index,uint value) public&#123;</span><br><span class="line">				numbers[index] &#x3D; value;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;*</span><br><span class="line">		getter 获取数组长度</span><br><span class="line">		*&#x2F;</span><br><span class="line">		function getLength() public view returns(uint) &#123;</span><br><span class="line">				return numbers.length;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们访问越界的时候，就会报错</p>
<h4 id="变长数组-Dynamically-Sized-Arrays"><a href="#变长数组-Dynamically-Sized-Arrays" class="headerlink" title="变长数组 Dynamically-Sized Arrays"></a>变长数组 Dynamically-Sized Arrays</h4><p>变长数组顾名思义可以改变是数组的长度, 类似于一个栈，后进先出。</p>
<p><strong>成员变量</strong></p>
<p><code>.length</code> 表示这个字符数组的长度</p>
<p><code>.push</code> 表示往这个数组中添加成员</p>
<p><code>.pop</code> 表示将数组中某成员删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">contract DynamicArrays&#123;</span><br><span class="line">		uint[] public numbers;</span><br><span class="line">		</span><br><span class="line">		function getLength() pubilc view returns (uint)&#123;</span><br><span class="line">				return numbers.length;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		function addElement(uint item)public &#123;</span><br><span class="line">				numbers.push(item);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		function popElement() public &#123;</span><br><span class="line">				numbers.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		function getElement(uint i) public view returns (uint)&#123;</span><br><span class="line">				if(i &lt; numbers.length)&#123;</span><br><span class="line">						return numbers[i];</span><br><span class="line">				&#125; </span><br><span class="line">				return 0;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以定义局部变量数组。 需要注意的是，array属于引用类型，需要显式用memory修饰。和Storage Array不同，Memory Array无法使用pop和push，而且也无法使用.length得到长度。因此，如果要将Memory Array赋值给Storage Array的话，需要在声明时注明数组的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f() public &#123;</span><br><span class="line">		uint[] memory y &#x3D; new uint[](3);</span><br><span class="line">		y[0] &#x3D; 10;</span><br><span class="line">		y[1] &#x3D; 20;</span><br><span class="line">		y[2] &#x3D; 30;</span><br><span class="line">		numbers &#x3D; y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Bytes-and-String-Types"><a href="#Bytes-and-String-Types" class="headerlink" title="Bytes and String Types"></a>Bytes and String Types</h4><p>字符串常量是指由单引号，或双引号引起来的字符串（<code>&quot;foo&quot;</code>or <code>&#39;bar&#39;</code>）。solidity字符串并不像C语言一样包含结束符，<code>”foo“</code>这个字符串大小仅为3字节。和整数常量一样，字符串的长度类型可以是变长的。字符串可以隐式的转换为byte1…byte32如果合适，也会转为bytes 或 String。</p>
<p>字符串常量支持转义字符，比如<code>\n</code>,<code>\xNN</code>,<code>\uNNN</code>。其中<code>\xNN</code>表示16进制值,最终转换合适的字节.而<code>\uNNNN</code>表示Unicode编码值,最终会转换为UTF8的序列.</p>
<p>现在我们来看一下Bytes和String的区别，比如我都将其初始化为<code>&#39;abc&#39;</code>,但实际上bytes变量是按照ASCII码存储的，而string则是由UTF-8格式存储的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">contract DynamicArrays&#123;</span><br><span class="line">	bytes public b1 &#x3D; &#39;abc&#39;;</span><br><span class="line">  string public s1 &#x3D; &#39;abc&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Structs-and-Enums"><a href="#Structs-and-Enums" class="headerlink" title="Structs and Enums"></a>Structs and Enums</h4><ul>
<li>Struct</li>
</ul>
<p>Solidity中的Struct与C语言中的struct类似。是一个键值对的集合，类似于映射，但值可以有不同的类型。</p>
<p>struct 会被存储在<strong>storage</strong>里面。一般来说，struct是定义在contract外的。下面我定义了一个Instructor 结构，然后在智能合约中通过constructor进行初始化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">struct Instructor &#123;</span><br><span class="line">		uint age;</span><br><span class="line">		string name;</span><br><span class="line">		address addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Academy&#123;</span><br><span class="line">		Instructor public academyInstructor;</span><br><span class="line">		</span><br><span class="line">		constructor (uint _age , string memory _name)&#123;</span><br><span class="line">				academyInstructor.age &#x3D; _age;</span><br><span class="line">				academyInstructor.name &#x3D; _name;</span><br><span class="line">				academyInstructor.addr &#x3D; msg.sender;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;*</span><br><span class="line">		此外，如果我们需要修改状态变量academyInstructor，需要传入struct所需的全部参数。</span><br><span class="line">		而且，由于struct是引用变量，因此需要用memory显式修饰。</span><br><span class="line">		*&#x2F;</span><br><span class="line">		function changeInstructor(uint _age, string memory _name ,address _addr) public&#123;</span><br><span class="line">				Instructor memory myInstructor &#x3D; Instructor(&#123;</span><br><span class="line">						age: _age,</span><br><span class="line">						name: _name,</span><br><span class="line">						addr: _addr</span><br><span class="line">				&#125;);</span><br><span class="line">				academyInstructor &#x3D; myInstructor;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Enum</li>
</ul>
<p>Enum和java中的Enum类似，可以用于定义取值范围有限的类型。Solidity 中Enum可以和整形显式的相互转换，整形再转换成enum时，编译器/EVM会检查取值范围，如果范围有误则会产生一个错误。 下面是一个例子：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">contract EnumTest &#123;</span><br><span class="line">    </span><br><span class="line">    event UintValue(uint value);</span><br><span class="line">    event EnumValue(Status status);</span><br><span class="line">    </span><br><span class="line">    enum Status &#123;ACTIVE,SUSPENDED&#125;</span><br><span class="line">    </span><br><span class="line">    function enumTest() public &#123;</span><br><span class="line">        Status s1 &#x3D; Status.ACTIVE;</span><br><span class="line">        &#x2F;&#x2F;0 will be emited</span><br><span class="line">        emit UintValue(uint(s1));</span><br><span class="line">        </span><br><span class="line">        Status s2 &#x3D; Status(1);</span><br><span class="line">        &#x2F;&#x2F;1 will be emited</span><br><span class="line">        emit EnumValue(s2);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;Next line will get an compile time error for 2 is out of range</span><br><span class="line">        &#x2F;&#x2F;Status s2 &#x3D; Status(2);</span><br><span class="line">        </span><br><span class="line">        uint x &#x3D; 4 - 4;</span><br><span class="line">        Status s3 &#x3D; Status(x);</span><br><span class="line">        &#x2F;&#x2F;0 will be emited</span><br><span class="line">        emit EnumValue(s3);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; x &#x3D; 4 - 2;</span><br><span class="line">        &#x2F;&#x2F;The next line will get an run time error for x is out of range</span><br><span class="line">        &#x2F;&#x2F; Status s4 &#x3D; Status(x);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Mappings"><a href="#Mappings" class="headerlink" title="Mappings"></a>Mappings</h4><p>solidity里的映射可以理解为python里的字典，建立键－值的对应关系，可以通过键来查找值，键必须是唯一的，但值可以重复。</p>
<p>定义方式为：mapping（键类型=&gt;值类型），例如<code>mapping(address=&gt;uint)  public  balances</code>，这个映射的名字是balances，权限类型为public，键的类型是地址address，值的类型是整型uint，在solidity中这个映射的意思是将参数amount的值和msg.sender这个地址对应起来。</p>
<p>在solidity中，一般有如下性质</p>
<ul>
<li>所有的键都必须是一个类型的；所有的值也必须是同一类型的</li>
<li>Mapping永远是被存放在storage中的，它是状态变量。就算是在函数中定义的mapping也会被存放在storage里</li>
<li>Mapping的优势在于查找过程是$O(1)$的，相比与线性查找的数组，要快很多。</li>
<li>Mapping并不是可迭代的，也没有一个迭代器可以遍历mapping</li>
<li>如果我们用一个不存在的key去mapping查找，就会得到一个默认的值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contract Auction&#123;</span><br><span class="line">		mapping(address &#x3D;&gt; uint) public bids;</span><br><span class="line">		</span><br><span class="line">		function bid() payable public &#123;</span><br><span class="line">				bids[msg.sender] &#x3D; msg.value;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Overflows-and-Underflows"><a href="#Overflows-and-Underflows" class="headerlink" title="Overflows and Underflows"></a>Overflows and Underflows</h3><p>在早期的solidity版本中，整型变量是会发生上溢和下溢的，比如，我把solidity版本置为0.5.0， 然后定义一个uint8=255的变量，利用一个函数调用让其发生上溢：</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/1.gif"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract Property&#123;</span><br><span class="line">        uint8 public x &#x3D; 255;</span><br><span class="line">        </span><br><span class="line">        function f1() public&#123;</span><br><span class="line">            x +&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，我若将uint8类型的255加上1，不会报错，但是数值从255变为了0</p>
<p>在比较新的solidity版本中(比如0.8.0)，当我使用同样的代码时，调用该函数会报错，x保持255的值不变。这是因为在新版本的solidity对可运算的数值类型加入了自动检查的功能。如果我们偏要忽略运算检查，可以使用unchecked来修饰，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function f1() public&#123;</span><br><span class="line">	unchecked &#123;x +&#x3D; 1&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/16.png"></p>
<p>此外，还有一个显著的差别就是：bytes变量可以调用push函数插入字符、可以用pop弹出字符、可以用length获取长度，但是string都不行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contract DynamicArrays&#123;</span><br><span class="line">	bytes public b1 &#x3D; &#39;abc&#39;;</span><br><span class="line">    string public s1 &#x3D; &#39;abc&#39;;</span><br><span class="line"></span><br><span class="line">    function addElement() public &#123;</span><br><span class="line">        b1.push(&#39;x&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/2.gif"></p>
<p>需要注明的是，相比于变长数组，定长数组消耗更少的gas，因此能用则用。</p>
<h3 id="Built-In-Global-Variables"><a href="#Built-In-Global-Variables" class="headerlink" title="Built-In Global Variables"></a>Built-In Global Variables</h3><p>现在我们要学习一些solidity 内建的全局变量。其实之前我们已经接触到了这些变量，比如msg系列的、block系列的</p>
<h4 id="abi"><a href="#abi" class="headerlink" title="abi"></a>abi</h4><ul>
<li><code>abi.encode(...) returns (bytes)</code>:对给定的参数进行ABI编码。</li>
<li><code>abi.encodePacked(...) returns (bytes)</code>: Performes packed encoding of the given arguments</li>
<li><code>abi.encodeWithSelector(bytes4 selector, ...) returns (bytes)</code>::对给定的参数进行ABI编码——从第二个预置给定的四字节选择器开始</li>
<li><code>abi.encodeWithSignature(string signature, ...) returns (bytes)</code>:相当于<code>abi.encodeWithSelector(bytes4(keccak256(signature), ...)</code></li>
</ul>
<h4 id="block系列"><a href="#block系列" class="headerlink" title="block系列"></a>block系列</h4><ul>
<li><code>blockhash(uint blockNumber)</code>: 给定的块的hash值, 只有最近工作的256个块的hash值 </li>
<li><code>block.coinbase</code> (<code>address</code>): 当前块的矿工的地址</li>
<li><code>block.difficulty</code> (<code>uint</code>): 当前块的难度</li>
<li><code>block.gaslimit</code> (<code>uint</code>): 当前块的gaslimit</li>
<li><code>block.number</code> (<code>uint</code>):当前块的数量</li>
<li><code>block.timestamp</code> (<code>uint</code>):当前块的时间戳，注：不要依赖于<code>block.timestamp</code>，<code>now</code>和<code>blockhash</code>用作随机性的来源，除非你知道你在做什么。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">contract Academy&#123;</span><br><span class="line">    uint public this_moment &#x3D; block.timestamp;</span><br><span class="line">    uint public block_number &#x3D; block.number;</span><br><span class="line">    uint public difficulty &#x3D; block.difficulty;</span><br><span class="line">    uint public gaslimit &#x3D; block.gaslimit;</span><br><span class="line">    address public coinbase &#x3D; block.coinbase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/17.png"></p>
<p>在这里，由于是在JS VM上跑的，所以block_number并不是真实的。</p>
<h4 id="msg系列"><a href="#msg系列" class="headerlink" title="msg系列"></a>msg系列</h4><ul>
<li><p><code>msg.data</code>(<code>bytes</code>): 完整的calldata </p>
</li>
<li><p><code>msg.sender</code> (<code>address</code>): 消息的发送者（当前调用）</p>
</li>
<li><p><code>msg.value</code> (<code>uint</code>): 和消息一起发送的wei的数量</p>
<ul>
<li>```solidity<br>function sendEther() public payable{<pre><code>    sendValue = msg.value;
</code></pre>}</li>
</ul>
</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li><p><code>now</code> (<code>uint</code>): 当前块的时间戳（<code>block.timestamp</code>的别名）</p>
</li>
<li><p><code>gasleft() returns (uint256)</code>: 剩余 gas </p>
<ul>
<li>```solidity<br>function howMuchGas() public view returns(uint){<pre><code>    uint start = gasleft();
    uint j = 1;
    for (uint i = 1;i&lt;20;i++){
            j*=1;
    }
    uint end = gasleft();
    return start-end;
</code></pre>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    通过&#96;gasleft()&#96;我们可以 获取一段代码消耗了多少gas</span><br><span class="line"></span><br><span class="line">    &lt;img src&#x3D;&quot;.&#x2F;Solidity初识&#x2F;18.png&quot;  &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">- &#96;tx.gasprice&#96; (&#96;uint&#96;):交易的gas价格</span><br><span class="line">- &#96;tx.origin&#96; (&#96;address&#96;):交易的发送者（全调用链）</span><br><span class="line">- &#96;assert(bool condition)&#96;: abort execution and revert state changes if condition is &#96;false&#96; (用于内部错误)</span><br><span class="line">- &#96;require(bool condition)&#96;: abort execution and revert state changes if condition is &#96;false&#96; (用于输入错误或外部组件的错误)</span><br><span class="line">- &#96;require(bool condition, string message)&#96;: abort execution and revert state changes if condition is &#96;false&#96; (用于输入错误或外部组件的错误). 并提供错误信息.</span><br><span class="line">- &#96;revert()&#96;: 中止执行并还原状态更改</span><br><span class="line">- &#96;revert(string message)&#96;:中止执行并还原状态更改，提供解释字符串</span><br><span class="line">- &#96;blockhash(uint blockNumber) returns (bytes32)&#96;: : 给定的块的hash值, 只有最近工作的256个块的hash值</span><br><span class="line">- &#96;keccak256(...) returns (bytes32)&#96;:计算（紧凑排列的）参数的 Ethereum-SHA3 hash值</span><br><span class="line">- &#96;sha3(...) returns (bytes32)&#96;: an alias to &#96;keccak256&#96;</span><br><span class="line">- &#96;sha256(...) returns (bytes32)&#96;: 计算（紧凑排列的）参数的SHA256 hash值</span><br><span class="line">- &#96;ripemd160(...) returns (bytes20)&#96;:计算 256个（紧凑排列的）参数的RIPEMD</span><br><span class="line">- &#96;ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)&#96;: 椭圆曲线签名公钥恢复，错误时返回0</span><br><span class="line"></span><br><span class="line">- &#96;this&#96; (current contract’s type): 当前合约，在地址上显式转换</span><br><span class="line"></span><br><span class="line">- &#96;super&#96;: 在层次关系上一层的合约</span><br><span class="line"></span><br><span class="line">- &#96;selfdestruct(address recipient)&#96;: 销毁当前的合约，将其资金发送到指定&#96;address&#96;</span><br><span class="line"></span><br><span class="line">- &#96;suicide(address recipient)&#96;: a deprecated alias to &#96;selfdestruct&#96;</span><br><span class="line"></span><br><span class="line">- &#96;&lt;address&gt;.balance&#96; (&#96;uint256&#96;): address地址中的账户余额（以wei为单位）</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;solidity</span><br><span class="line">    &#x2F;&#x2F; 当前合约的剩余额(单位是wei)</span><br><span class="line">    function getBalance() public view returns(uint) &#123;</span><br><span class="line">    		return address(this).balance</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><code>&lt;address&gt;.send(uint256 amount) returns (bool)</code>: 将一定量wei发送给address地址，若失败返回<code>false</code>。</li>
<li><code>&lt;address&gt;.transfer(uint256 amount)</code>: 将一定量wei发送给address地址，若失败抛出异常。</li>
</ul>
<h3 id="Contract’s-Address-and-Balance-Payable-Receive-and-Fallback-Functions"><a href="#Contract’s-Address-and-Balance-Payable-Receive-and-Fallback-Functions" class="headerlink" title="Contract’s Address and Balance Payable, Receive and Fallback Functions"></a>Contract’s Address and Balance Payable, Receive and Fallback Functions</h3><p>在学习以太坊的时候，我们知道账户也分为两类：外部账户和 合约账户</p>
<ul>
<li>外部账户(EOAs) 由公钥-私钥对 控制，它拥有私钥，没有相关代码，其codeHash为空。</li>
<li>合约账户由交易类型、消息类型进行创建，由代码控制，简称CA，它没有私钥，其codeHash<strong>非空</strong>。</li>
</ul>
<p>因此，我们需要去理解的是，合约也是一种账户，也有它自己的地址(在部署的时候生成)。因此，合约也可以接收以太币、支付以太币。</p>
<p>但是需要注意，有两种合约地址类型：plain和payable。前者我们无法向其发送以太币，后者我们可以向其发送以太币。</p>
<p>同时，我们也要知道 address是一种特殊的变量类型，他有很多成员可供调用：</p>
<ul>
<li><p><code>balance</code>： 余额</p>
</li>
<li><p><code>transfer()</code>: 是一种最安全的方法用于发送ETH</p>
</li>
<li><p><code>send()</code> :类似于低配版的transfer，当执行失败的时候，合约并不会停止，而且send会返回false。<code>transfer()</code> 和 <code>send()</code> 只有 payable address才可以使用</p>
</li>
</ul>
<h4 id="payable-functions-and-contract-balance"><a href="#payable-functions-and-contract-balance" class="headerlink" title="payable functions and contract balance"></a>payable functions and contract balance</h4><p>只有当payable function被定义了，这个合约才可以收取ETH并有ETH余额。</p>
<p>一个合约可以通过多种方法获取ETH:</p>
<ul>
<li>用外部账户(EOA) 向一个合约地址转ETH。在这种情况下，合约至少需要定义<code>receive()</code>或者<code>fallback()</code>函数中的一个<ul>
<li>fallback函数的性质如下：<ul>
<li><strong>三无函数</strong>。没有名字、没有参数、没有返回值。</li>
<li><strong>替补函数</strong>。如果在一个对合约调用中，没有其他函数与给定的函数标识符匹配fallback会被调用． 或者在没有 receive 函数时，而没有提供附加数据对合约调用，那么fallback 函数会被执行。</li>
<li><strong>收币函数</strong>。通过钱包向一个合约转账时，会执行Fallback函数，这一点很有用。</li>
<li>fallback　函数始终会接收数据，但为了同时接收以太币，必须标记为　<code>payable</code> 。</li>
</ul>
</li>
<li>receive函数性质如下：<ul>
<li>一个合约最多有一个 <code>receive</code> 函数, 声明函数为： <code>receive() external payable { ... }</code></li>
<li>不需要 <code>function</code> 关键字，也没有参数和返回值并且必须是　<code>external</code>　可见性和　<code>payable</code> 修饰． 它可以是 <code>virtual</code> 的，可以被重载也可以有 修改器modifier 。</li>
<li>在对合约没有任何附加数据调用（通常是对合约转账）时会执行 <code>receive</code> 函数。如果receive函数不存在，但是有fallback函数。那么在进行纯以太币转账的时候，fallback会被调用</li>
<li>如果两个函数都没有，这个合约就没法通过常规的转账交易接收以太币（会抛出异常）．</li>
</ul>
</li>
</ul>
</li>
<li>调用payable function，并在那个交易中附带着发送ETH</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">contract Deposit&#123;</span><br><span class="line">        receive() external payable&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fallback() external payable&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function getBalance() public view returns(uint)&#123;</span><br><span class="line">            return address(this).balance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了调试这个合约，我们需要将其在以太坊测试网络上进行部署：上链之后，我们看到这个合约地址已经生成了。</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/19.png"></p>
<p>在Remix上，我们可以调用getBalance来看合约账户的余额，由于没有为其转账，因此余额为零</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/20.png"></p>
<p><strong>方式1: 外部账户给合约账户直接转账</strong></p>
<p>现在，我到 <a href="https://www.myetherwallet.com/" target="_blank" rel="noopener">MEW</a> 网站上又注册了一个账号，并向这个合约地址转账了0.2个ETH，然后，我们就可以看到</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/22.png"></p>
<p><strong>调用合约内部的payable function</strong></p>
<p>当然，我们也可以采取第二种方式调用合约内部的 payable function来对合约进行转账。</p>
<p>首先我们要创建一个payable function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function sendEther() public payable&#123;</span><br><span class="line">		uint x;</span><br><span class="line">		x++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们需要在value中设置需要转账的钱， 1Finney = 0.001ETH</p>
<p>点击sendEther按钮之后，就会转接到metamask界面进行转账操作了。</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/23.png"></p>
<h3 id="Accessing-the-Contract’s-Balance"><a href="#Accessing-the-Contract’s-Balance" class="headerlink" title="Accessing the Contract’s Balance"></a>Accessing the Contract’s Balance</h3><p>前面我们学习了如何向一个合约转账，现在我们要来学如何获取一个合约账户的余额，并向其它合约账户、外部账户转账。</p>
<p>为此，我们要设计一个transfer函数用来实现账户之间的转账。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function transferEther(address payable recipient,uint amount)public returns(bool)&#123;</span><br><span class="line">    if(amount &lt;&#x3D; getBalance())&#123;</span><br><span class="line">        recipient.transfer(amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>部署以后我们往这个账户中转一些以太币以供后续测试用。然后，我们要给上面的那个合约转账的话，我们只需在transferEther里面输入目标地址和转账数目即可。</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/25.png"></p>
<p>值得注意的是，这仅仅涉及合约与合约之间的转账，但是转账交易需要消耗一定的燃料，这仍然是需要EOA来支付的。</p>
<h3 id="Protecting-the-Contract’s-Balance"><a href="#Protecting-the-Contract’s-Balance" class="headerlink" title="Protecting the Contract’s Balance"></a>Protecting the Contract’s Balance</h3><p>现在有一个问题，就是说我们这个transferEther函数时完全公开的，外部的人只要能获取合约地址就可以调用这个函数，因此是非常不安全的。因此对一个合约我们要保护好其余额.</p>
<p>为此我们可以使用 require 函数，它可以在执行函数逻辑之前做一些检查。这里我们首先创建一个owner状态变量，然后为其创建构造函数并为其赋值。因此，当这个合约被部署的时候，owner就会被设定为部署者的账号。然后，当要调用transferEther函数的时候，会调用<code>require(owner == msg.sender)</code> 进行核查，如果调用者不是owner，那么就会直接返回false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">contract Deposit&#123;</span><br><span class="line">        address public owner;</span><br><span class="line"></span><br><span class="line">        constructor()&#123;</span><br><span class="line">            owner &#x3D; msg.sendEther;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        receive() external payable&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        fallback() external payable&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function getBalance() public view returns(uint)&#123;</span><br><span class="line">            return address(this).balance;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        function sendEther() public payable&#123;</span><br><span class="line">        		uint x;</span><br><span class="line">        		x++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function transferEther(address payable recipient,uint amount)public returns(bool)&#123;</span><br><span class="line">            require(owner &#x3D;&#x3D; msg.sender,&quot;Transfer failed ,you are not the owner&quot;);</span><br><span class="line">            if(amount &lt;&#x3D; getBalance())&#123;</span><br><span class="line">                recipient.transfer(amount);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以来做个实验, 我们用账户1部署好合约之后，切换到账户2，然后进行转账活动</p>
<h3 id="Variables-and-Functions-Visibility-Private-Public-Internal-External"><a href="#Variables-and-Functions-Visibility-Private-Public-Internal-External" class="headerlink" title="Variables and Functions Visibility Private, Public, Internal, External"></a>Variables and Functions Visibility Private, Public, Internal, External</h3><p>函数类型分为<code>internal</code> 和<code>external</code>, 标记有<code>internal</code>函数类型只能引用当前contract中的函数，标记有<code>external</code>函数类型可以应用定义在其他contract中的函数。</p>
<p>除此之外，还有一个<code>payable</code> 修饰词 ，如果在函数中涉及到以太币的转移，需要使用到payable关键词。意味着可以在调用这笔函数的消息中附带以太币。可以参考<a href="https://blog.51cto.com/u_13784902/2321571" target="_blank" rel="noopener">这篇博客</a></p>
<p>对于函数和状态变量，有四种类型的可见性。</p>
<ul>
<li><p>public</p>
<ul>
<li>该函数可以在内部（从同一合约内）和外部（从其他合约或EOA账户）调用。</li>
<li>创建一个函数，默认为public</li>
<li>一个getter被自动创建为公共变量。它们可以很容易地从dApps中访问。</li>
</ul>
</li>
<li><p>private</p>
<ul>
<li>私有函数和变量只在它们所定义的合约中可用（不在其他合约中：派生或次生）。Private是Internal的一个子集。</li>
<li>它们只能通过getter函数在当前合约中被访问。</li>
</ul>
</li>
<li><p>internal</p>
<ul>
<li>函数只能从它们所定义的合约中和派生合约中访问。EOA是无法访问的</li>
<li>对于状态变量来说，默认是internal的,外部无法访问，但它们可以在当前合约和派生合约中被访问。</li>
</ul>
</li>
<li><p>external</p>
<ul>
<li><p>该函数是合约接口的一部分，<strong>只能</strong>从<strong>其他合约</strong>或<strong>使用交易的EOA账户</strong>访问。它也是public的。</p>
</li>
<li><p>External不适用于状态变量</p>
</li>
</ul>
</li>
</ul>
<p>现在我们来看一些例子：</p>
<p>在这里我们定义了两个状态变量，x是public的，y是默认internal的</p>
<ul>
<li>get_y函数，是public的可以返回成员变量 y</li>
<li>f1函数，是private的，只能在合约A中调用，其他账户一概不能调用</li>
<li>f2函数，是public的，但是在public函数中可以调用private函数，因为这是在合约A里面</li>
<li>f3函数，是internal的，可以在合约A中调用，也可以在合约A的派生合约中调用。但其他账户不能调用</li>
<li>f4函数，是external的，只能在外部调用，合约A内部无法调用f4，同样也无法在合约A的派生合约中调用f4</li>
<li>B合约，这里使用了类似于继承的思想，用<code>B is A</code> 表示继承，在B合约中，可以调用f2和f3，f1和f4是无法被调用的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    int public x &#x3D; 10;</span><br><span class="line">    int y &#x3D; 20;</span><br><span class="line"></span><br><span class="line">    function get_y() public view returns (int)&#123;</span><br><span class="line">        return y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function f1() private view returns(int)&#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function f2() public view returns(int)&#123;</span><br><span class="line">        int a;</span><br><span class="line">        a &#x3D; f1();</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function f3() internal view returns(int)&#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function f4() external view returns(int)&#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract B is A&#123;</span><br><span class="line">    int public xx &#x3D; f3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们部署以后，发现在合约外，是无法调用f1、f3的。</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/26.png"></p>
<p>最后，我们试一下在合约里面部署一个合约，然后调用内部合约的函数。在合约C中我们创建了一个新的A类型的合约。我们发现，可以调用external函数(f4)和public函数(f2)，但是无法调用private函数(f1)和internal函数(f3)</p>
<p>因此我们知道，就算在合约中创建的新合约，也是无法调用新合约中的private和internal函数的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">contract C&#123;</span><br><span class="line">    A public contract_a &#x3D; new A();</span><br><span class="line">    int public xx &#x3D; contract_a.f4();</span><br><span class="line">    int public xxx &#x3D; contract_a.f2();</span><br><span class="line">    &#x2F;&#x2F; int public y &#x3D; contract_a.f1();</span><br><span class="line">    &#x2F;&#x2F; int public yy &#x3D; contract_a.f3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/04/03/AI-Adversarial/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/04/03/AI-Adversarial/" itemprop="url">AI-Adversarial</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-04-03T15:59:44+08:00">
                2022-04-03
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-04-07T14:39:56+08:00">
                2022-04-07
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="搜索树1-博弈"><a href="#搜索树1-博弈" class="headerlink" title="搜索树1:  博弈"></a>搜索树1:  博弈</h1><h3 id="博弈的类型和区分axes"><a href="#博弈的类型和区分axes" class="headerlink" title="博弈的类型和区分axes"></a>博弈的类型和区分axes</h3><ul>
<li>Deterministic or stochastic? 象棋是确定性的、足球是不确定的</li>
<li>One, two, or more players? 玩家数量</li>
<li>Zero sum? 零和、协同合作（例如王者荣耀的队友）</li>
<li>Perfect information (can you see the state)? 完整的信息（例如整个状态和棋子分布）是否都能完全观察到</li>
</ul>
<h3 id="Deterministic-Games-确定性的博弈"><a href="#Deterministic-Games-确定性的博弈" class="headerlink" title="Deterministic Games 确定性的博弈"></a>Deterministic Games 确定性的博弈</h3><ul>
<li><p>状态 States: $S$ (start at $s_0$)</p>
<p>例如下象棋中棋子的分布</p>
</li>
<li><p>玩家 Players: $P={1…N}$ (usually take turns)</p>
<p>代表玩家的个数</p>
</li>
<li><p>行为 Actions: $A$ (may depend on player / state)</p>
</li>
<li><p>转移函数 Transition Function: $S\times A \rightarrow S$</p>
<p>从状态出发经过相应的行为可以到达的一个新的状态</p>
</li>
<li><p>是否到达最终状态 Terminal Test: $S\rightarrow {\text{true},\text{false}}$</p>
<p>一个终止状态的节点，未必最优。</p>
</li>
<li><p>最终效用值 Terminal Utilities: $S\times P \rightarrow R$</p>
<p>得分或者奖励值</p>
</li>
<li><p>策略<strong>policy</strong>: 智能体处于某种状态时该发出的行为，从状态映射到行为 $S\rightarrow A$</p>
</li>
</ul>
<h3 id="Zero-Sum-Games-零和游戏"><a href="#Zero-Sum-Games-零和游戏" class="headerlink" title="Zero-Sum Games 零和游戏"></a>Zero-Sum Games 零和游戏</h3><ul>
<li><p>Zero-Sum Games：</p>
<p>Agents have opposite utilities (values on outcomes)</p>
<p>多个 agents 拥有恰巧相反的目标，例如两个agent的分别希望最大化/最小化同一个值并不完全是两方的期望的加和是0</p>
</li>
<li><p>General Games:</p>
<p>Agents have independent utilities (values on outcomes)</p>
<p>协同合作等</p>
</li>
</ul>
<h3 id="Adversarial-Search-对抗搜索、博弈搜索"><a href="#Adversarial-Search-对抗搜索、博弈搜索" class="headerlink" title="Adversarial Search 对抗搜索、博弈搜索"></a>Adversarial Search 对抗搜索、博弈搜索</h3><p><img src="/2022/04/03/AI-Adversarial/1.png" alt></p>
<p>上图是 Single-Agent Trees 一个智能体对应的搜索树。左边的状态表示往左移一步，右边的状态表示往右移</p>
<p><strong>Value of a State 状态的价值</strong>：从当前状态出发能够获得的最好效用值 The best achievable outcome (utility) from that state</p>
<p>Non-Terminal States 的状态的价值也是孩子节点状态中最好的value值</p>
<script type="math/tex; mode=display">
V(s) = \max_{s'\in\text{ children(s)}} V(s')</script><p><img src="/2022/04/03/AI-Adversarial/2.png" alt></p>
<p>Adversarial Game Trees。存在对抗，一方走完另一方走。鬼希望吃掉Pacman， Pacman希望吃掉豆子。不同层的目标不一样，轮流希望最大化各自的效用值。通过交替的方式对状态展开。</p>
<h3 id="Minimax-Values：轮流进行min和max的操作"><a href="#Minimax-Values：轮流进行min和max的操作" class="headerlink" title="Minimax Values：轮流进行min和max的操作"></a>Minimax Values：轮流进行min和max的操作</h3><ul>
<li>对Pacman来说 States Under Agent’s Control：希望最大化 Pacman 的收益 ，最大化后继节点的状态价值</li>
</ul>
<script type="math/tex; mode=display">
V(s) = \max_{s'\in\text{successors(s)}}V(s')</script><ul>
<li>对鬼来说States Under Opponent’s Control：希望最小化 Pacman 的收益，最小化后继节点的状态价值</li>
</ul>
<script type="math/tex; mode=display">
V(s) = \min_{s'\in\text{successors(s)}}V(s')</script><p><img src="/2022/04/03/AI-Adversarial/3.png" alt></p>
<h3 id="Adversarial-Search-Minimax-对抗搜索"><a href="#Adversarial-Search-Minimax-对抗搜索" class="headerlink" title="Adversarial Search (Minimax) 对抗搜索"></a>Adversarial Search (Minimax) 对抗搜索</h3><p>是在树上的搜索。计算非terminal的每一个节点对应的Minimax值，蓝色上三角表示希望最大化效用值，红色的下三角表示希望最小化效用值。由孩子节点的效用值得到。</p>
<p><img src="/2022/04/03/AI-Adversarial/4.png"></p>
<p>对每一个给定的状态，希望求它的所有后继的最大/最小值。由于是Minimax问题，对每个希望求最大/最小值的节点来说，它的后继相应的希望求最小/最大值。</p>
<p><img src="/2022/04/03/AI-Adversarial/5.png"></p>
<p>对terminal状态来说，直接返回最终的值。否则分别调用max-value或者min-value函数。</p>
<h3 id="搜索树的提速方式"><a href="#搜索树的提速方式" class="headerlink" title="搜索树的提速方式"></a>搜索树的提速方式</h3><p>我们首先来看看没有剪枝的情况下搜索树得到的结果：</p>
<p><img src="/2022/04/03/AI-Adversarial/7.png"></p>
<p>但是，我们如何减少搜索的次数呢？答：进行剪枝</p>
<p>为了提升搜索树的搜索速度，我们可以对其进行 $\alpha-\beta$ 剪枝，其中：</p>
<ul>
<li>$\alpha:$  Max’s best option on path to root , 即 $\alpha$ 是上限</li>
<li>$\beta:$  Min’s best option on path to root，即$\beta$ 是下限 </li>
</ul>
<p>和普通搜索树算法的区别就在于引入了$\alpha,\beta$ 两个值</p>
<p><img src="/2022/04/03/AI-Adversarial/8.png"></p>
<p>我们结合具体的例子来看：</p>
<p>首先，我们还是将最左边的节点的最小值3计算出来，此时根节点的值暂且为3，即$\alpha=3$；然后，我们需要计算中间节点的值, 为此我们需要遍历其子节点，当我们读取到第一个子节点为2的时候，那么不管后面的孩子节点的值是大于2还是小于2，中间这个节点的值一定是小于等于2的。而且2已经比根节点3小了，由于根节点求的是max操作，因此当我们读取到2的时候，其实已经不需要再去读取后面的孩子节点了，这棵子树相当于被废弃了。</p>
<p>也就是说，在这一层因为求得是 min值，使用的是min-value函数， 因此当看到$ 2=v&lt;\alpha=3$ 的时候，就可以直接范围 $v$ 了，完成剪枝</p>
<p>对于最右边这颗子树，首先读取到的是14，14是大于根节点3的，但我们并没法判断后面是否有比3小的数，因此我们无法进行剪枝，仍然需要读取。</p>
<p>剪枝后的搜索树如下图所示：</p>
<p><img src="/2022/04/03/AI-Adversarial/6.png"></p>
<h4 id="Quiz"><a href="#Quiz" class="headerlink" title="Quiz"></a>Quiz</h4><ol>
<li><img src="/2022/04/03/AI-Adversarial/9.png"></li>
</ol>
<p>最左边的孩子都需要遍历的，得到$\alpha=8$ ，右孩子的第一个数值是$4&lt;\alpha$ ，因此可以进行剪枝，直接返回4</p>
<ol>
<li><p><img src="/2022/04/03/AI-Adversarial/11.png"></p>
</li>
</ol>
<p>结果：</p>
<p><img src="/2022/04/03/AI-Adversarial/10.png"></p>
<ol>
<li>首先，遍历最左的这颗子树，得到10和6的最大值为10，因此设定了$\beta = 10$ ，</li>
<li>读取f节点之后，发现等于100，是大于$\beta=10$的，因此，可以直接剪枝</li>
<li>因此得到了节点B=10，同时可以得到 $\alpha = 10$</li>
<li>读取右边的子树，发现F节点的值是2，而$2\leq \alpha=10$ ，因此直接可以剪枝，G节点可以不去探索了</li>
</ol>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>$\alpha-\beta$ 剪枝的性质：</p>
<ol>
<li>中间节点的值可能是错误的。</li>
</ol>
<p>比如说下图，通过左子树，得到$\alpha=10$ , 然后扫描右边的子树，发现左孩子满足 $10\leq \alpha$ ，因此直接返回。但是，事实上左子树的根的真实值应该等于0，这里还没有读取到0就被剪枝了，因此可能是错误的</p>
<p><img src="/2022/04/03/AI-Adversarial/12.png"></p>
<ol>
<li>合适的叶子结点的顺序可以提升搜索树的速度。因为如果是按从小到大的顺序排列的话，可能读取一个叶子就可以完成剪枝操作；但是如果按照从大到小的顺序来排列，可能就需要读完所有叶子结点。 <ul>
<li>这样可以降低一点时间复杂度，但是对于象棋这种搜索空间特别大的情况，使用$\alpha-\beta$剪枝还是不够的</li>
</ul>
</li>
</ol>
<h3 id="Resource-Limits"><a href="#Resource-Limits" class="headerlink" title="Resource Limits"></a>Resource Limits</h3><p><img src="/2022/04/03/AI-Adversarial/13.png" style="zoom:50%;"></p>
<p><strong>问题</strong>：  在现实情况中，很难沿着这棵树去搜索叶子结点</p>
<p><strong>解决办法</strong>：除了$\alpha-\beta$ 剪枝之外，还可以限制搜索的深度。比如上面这颗树，我们可以只搜索到第二层后就停止。这时候就没有中间节点的效用值了。那么怎么得到第二层的值?</p>
<p>我们可以引入一个 Evaluation Function，他可以估计中间节点的效用值，如上图所示。</p>
<p>因此，我们引入的Evaluation Function的估计精度就非常重要了，如果估计完全准确，那么就不需要再增加接下来几层节点的访问开销了。</p>
<p><strong>例子</strong>：在象棋比赛中，假设我们有100秒，每秒可以探索1万个节点。因此，每回合我们可以探索 1 million 的节点。借此我们大致可以再搜索树里面探索8层，这已经可以得到很好的结果了。</p>
<p>同时我们要知道，限制层数的搜索方式，和层数的多少有着密切关系。搜索的层数越深，那么非叶子结点的估计也就会越准确，越有可能返回真实的结果。</p>
<h4 id="Evaluation-Functions"><a href="#Evaluation-Functions" class="headerlink" title="Evaluation Functions"></a>Evaluation Functions</h4><p>理想的Evaluation Function可以返回完全正确的估计</p>
<p>比如说，我们可以采用线性加和的方式对当前状态的效应值进行估计</p>
<script type="math/tex; mode=display">
Eval(s) = w_1f_1(s) + w_2f_2(s)+\cdots+w_nf_n(s)</script><p>举个例子，我们以象棋为例，我们可以把$f_1(s)$ 设置为 白色queen的数量减去黑色queen的数量，把$f_2(s)$  设置为白色马的数量减去黑色马的数量，以此类推</p>
<p><img src="/2022/04/03/AI-Adversarial/14.png" style="zoom:50%;"></p>
<p>当然，也可以用神经网络来作为Evaluation Function</p>
<h4 id="Depth-Matters"><a href="#Depth-Matters" class="headerlink" title="Depth Matters"></a>Depth Matters</h4><p>首先我们要明白，Evaluation并不是一直准确的。但是随着Evaluation所在的层数的加深，其估计的质量也就会越高。最后，Evaluation可以对特征复杂度和计算复杂度做一个推导，因为如果Evaluation很准，那么就可以剩下很多计算，但是如何构建准确的Evaluation的工作量就要上升了</p>
<h5 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h5><p>我们看到如果只探索两层的话，pacman的动作如下所示：</p>
<p><img src="/2022/04/03/AI-Adversarial/1.gif"></p>
<p>我们看到，由于pacman并不知道之后几步的行踪，因此被鬼给吃了</p>
<p>但是如果把探索层数扩大到10层，那么pacman的行动如下所示：</p>
<p><img src="/2022/04/03/AI-Adversarial/2.gif"></p>
<p>由于Pacman掌握了更多信息，因此鬼捉不到pacman，但pacman可以吃到果子。</p>
<h5 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h5><p>我们再来看一个例子，下面这个pacman一直在踱步，但是始终没有下去吃果子，这是为什么呢？这和我们设计的Evaluation有关</p>
<p><img src="/2022/04/03/AI-Adversarial/3.gif"></p>
<p>由于我们只考虑了两层，我们将搜索树全部画出来看看：</p>
<p><img src="/2022/04/03/AI-Adversarial/15.png"></p>
<p>假设吃到果子后可以加上10分那么上面搜索树的值为：</p>
<p><img src="/2022/04/03/AI-Adversarial/16.png"></p>
<p>那么对于根节点来说，往左走和往右走的Evaluation是一样的，往左往右都可以，所以一直在左右徘徊。</p>
<p>因此我们需要更准确的Evaluation，我们看到叶子结点中，最左边的情况实际上比最右边的情况更加接近果子，因此我们不妨将这个状态设置为11，那么pacman的行动轨迹就会变成先往左走吃掉果子，再往右走吃掉右边的果子，如下所示：</p>
<p><img src="/2022/04/03/AI-Adversarial/4.gif"></p>
<h1 id="搜索树-Part2-Uncertainty-and-Utilities"><a href="#搜索树-Part2-Uncertainty-and-Utilities" class="headerlink" title="搜索树 Part2: Uncertainty and Utilities"></a>搜索树 Part2: Uncertainty and Utilities</h1><p>我们要让自己赢一个游戏的话，肯定需要让自己的利益最大化，由于游戏是存在不确定性的，因此我们需要计算整个游戏的期望。</p>
<h2 id="Expectimax-Search"><a href="#Expectimax-Search" class="headerlink" title="Expectimax Search"></a>Expectimax Search</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>如下图两个游戏，对于画圈画叉来说，游戏下一步的状态是确定的，因此可以用 MinMax Tree来做搜索，但是对于掷骰子，下一步是什么状态是不确定的。</p>
<p><img src="/2022/04/03/AI-Adversarial/17.png"></p>
<p>如上图所示，因此我们把中间层的倒三角替换成圆形了，圆形代表什么？其实圆形就是引入概率的、引入随机性的博弈。比如说两条边的概率都是0.5的话，右边的节点的值就是$\frac{1}{2}\cdot (9+100)$ </p>
<p>由此，这颗搜索树从 Minmax Search 变成了 Expectimax Search。当我们考虑随机性的时候，就不去靠考虑最大值最小值了，而是考虑期望和均值。实际上，Expectimax在日常生活中很常见。比如说投色子，又比如说在pacman中鬼是随机游走的，不再是你死我亡型的鬼了。</p>
<h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><p>那么Expectimax Search是如何计算的？</p>
<p><img src="/2022/04/03/AI-Adversarial/18.png"></p>
<p>首先，对于chance节点，求的不再是最小值，而是 期望效用值。他和min的功能是一样的，只是结果是不确定的。</p>
<p>同时，max节点还是会计算chance节点的最大值，这和minimax search中的max节点功能一致</p>
<p>我们可以看一下Minimax search和 Expectimax search的区别</p>
<ul>
<li>Minimax Search</li>
</ul>
<p><img src="/2022/04/03/AI-Adversarial/5.gif"></p>
<ul>
<li>Expectimax Search</li>
</ul>
<p><img src="/2022/04/03/AI-Adversarial/6.gif"></p>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p>现在我们来看一下Expectimax Search的伪代码：</p>
<ul>
<li>value函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">value</span><span class="params">(state)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> the state <span class="keyword">is</span> a terminal state: <span class="keyword">return</span> the state’s utility</span><br><span class="line">    <span class="comment"># 子节点是max-value节点，那么调用max-value函数</span></span><br><span class="line">    <span class="keyword">if</span> the next agent <span class="keyword">is</span> MAX: <span class="keyword">return</span> max-value(state)</span><br><span class="line">    <span class="comment"># 子节点是exp-value节点，那么调用exp-value函数</span></span><br><span class="line">    <span class="keyword">if</span> the next agent <span class="keyword">is</span> EXP: <span class="keyword">return</span> exp-value(state)</span><br></pre></td></tr></table></figure>
<ul>
<li>max-value函数, 这和minimax search的max节点是类似的</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span>-<span class="title">value</span><span class="params">(state)</span>:</span></span><br><span class="line">    initialize v = -∞</span><br><span class="line">    <span class="keyword">for</span> each successor of state:</span><br><span class="line">    		v = max(v, value(successor))</span><br><span class="line">    <span class="keyword">return</span> v</span><br></pre></td></tr></table></figure>
<ul>
<li>exp-value函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>-<span class="title">value</span><span class="params">(state)</span>:</span></span><br><span class="line">    initialize v = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> each successor of state:</span><br><span class="line">      <span class="comment"># 由于chance节点的每条边都是由概率的，所以要先获取概率然后累加计算节点的值</span></span><br><span class="line">        p = probability(successor)</span><br><span class="line">    		v += p * value(successor)</span><br><span class="line">    <span class="keyword">return</span> v</span><br></pre></td></tr></table></figure>
<h3 id="Expectimax可以剪枝吗"><a href="#Expectimax可以剪枝吗" class="headerlink" title="Expectimax可以剪枝吗"></a>Expectimax可以剪枝吗</h3><p>首先，我们来看看不剪枝的情况下，Expectimax Search计算的一个例子：</p>
<p><img src="/2022/04/03/AI-Adversarial/19.png"></p>
<p>但是对于Expectimax来说，情况就变得很不一样了。假设我们遍历了最右边的子树，得到了其值为8，令$\alpha=8$，那么我们可以在遍历中间子树的第一个叶子(其值为2)之后就能对其进行剪枝吗？</p>
<p>显然是不行的，因为虽然每条边的概率是一样的，但是并不能确定叶子的值是多少，可能2后面的叶子是1亿，那么显然中间的chance节点的值是大于8的</p>
<p>因此Expectimax Search是不能做剪枝的，但如果在知道bound的情况下，还是可以做剪枝的。比如说，我知道2后面两个叶子的值都是小于10的，那么就可以做剪枝了</p>
<h3 id="Expectimax-可以做限高吗"><a href="#Expectimax-可以做限高吗" class="headerlink" title="Expectimax 可以做限高吗"></a>Expectimax 可以做限高吗</h3><p><img src="/2022/04/03/AI-Adversarial/20.png"></p>
<p>可以限高，但是比minimax更为复杂，因为其中涉及到概率相关的问题。</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>在一个游戏中，如果对手在80%的时间里采用深度为2的minimax search，剩余20%的时间在随机游走，应该用什么？Expectimax Search</p>
<p>但这时候，chance节点的两条边的权重就不一样了。在80%的情况下，是求min的操作；在20%的情况下随机进行。通过这种方式去模拟可以求得针对该问题的概率值。但这种方法速度很慢，需要访问到最底部的叶子结点。</p>
<h2 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h2><p>在设计智能体的时候，常常会对日常生活做一个建模，两个极端的方向就是：过度乐观和过度悲观</p>
<ul>
<li>乐观派是说，前面就算有鬼我也要走过去</li>
<li>悲观派是说， 前面就算是无害的小动物我也不敢走过去</li>
</ul>
<p>我们用pacman为例：下面有四种情况，博弈的鬼和随机游走的鬼与Minimax和Expectimax两两搭配，我们来看一下结果是什么样的。</p>
<p><img src="/2022/04/03/AI-Adversarial/21.png"></p>
<ul>
<li>Expectimax Pacman——Random Ghost</li>
</ul>
<p><img src="/2022/04/03/AI-Adversarial/7.gif"></p>
<ul>
<li>Adversarial Ghost —— Minimax Pacman(对抗性的鬼和对抗性的pacman)</li>
</ul>
<p><img src="/2022/04/03/AI-Adversarial/8.gif"></p>
<p>我们看到，因为鬼是对抗性的，所以一直在追着pacman跑，pacman则已知躲着鬼，然后吃到了果子</p>
<ul>
<li>Adversarial Ghost —— Expectimax Pacman(对抗性的鬼和Expectimax 的pacman)</li>
</ul>
<p><img src="/2022/04/03/AI-Adversarial/9.gif"></p>
<p>我们看到鬼是Adversarial 的，非常具有攻击性。而pacman考虑了随机性后，有一定几率躲掉鬼，但不能保证每次都可以逃脱。视频中是赢了，但不一定下次还能赢。</p>
<ul>
<li>Random Gost——Minimax Pacman</li>
</ul>
<p><img src="/2022/04/03/AI-Adversarial/10.gif"></p>
<p>我们看到在这种情况下，只要鬼还在地图的下半部分移动，上面的pacman就非常害怕不敢轻举妄动。因此，minimax其实是一种过度悲观的方式。</p>
<p>最后 我们来看一下，玩五次游戏以后，上面四种方式得到的分数：</p>
<p><img src="/2022/04/03/AI-Adversarial/22.png"></p>
<ul>
<li>我们看到，Expectimax对上Random Gost五次都能赢，因为考虑了随机性</li>
<li>Minimax对上Adversarial Ghost，由于Adversarial具有强烈的攻击性，而Minimax又是比较悲观的，因此他虽然赢了5次，但是平均得分不如Expectimax对上Random Ghost</li>
<li><p>Expectimax对上Adversarial Ghost，我们看到只赢了一次，这是因为鬼具有强烈的攻击性，但是Pacman的行动却具有随机性，因此一着不慎就可能被鬼吃掉。</p>
</li>
<li><p>MiniMax 对上Random Ghost，虽然小心翼翼地再走，但是最终还是能赢的</p>
</li>
</ul>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/5/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/%5Bobject%20Object%5D"
                alt="Jason" />
            
              <p class="site-author-name" itemprop="name">Jason</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20fa%20fa-archive">
              
                  <span class="site-state-item-count">435</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">61</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="true"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
 <!--
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>







-->
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>




















  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v="></script>

  <script type="text/javascript" src="/js/src/motion.js?v="></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v="></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
