<!DOCTYPE html>
<html lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jasonxqh.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jason‘s Blog">
<meta property="og:url" content="https://jasonxqh.github.io/page/4/index.html">
<meta property="og:site_name" content="Jason‘s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jasonxqh.github.io/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jason‘s Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jason‘s Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/08/21/Design-Patterns-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/21/Design-Patterns-3/" class="post-title-link" itemprop="url">Design-Patterns-3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-21 21:37:56" itemprop="dateCreated datePublished" datetime="2022-08-21T21:37:56+08:00">2022-08-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-22 11:28:32" itemprop="dateModified" datetime="2022-08-22T11:28:32+08:00">2022-08-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Design-Patterns-创建型模式"><a href="#Design-Patterns-创建型模式" class="headerlink" title="Design Patterns 创建型模式"></a>Design Patterns 创建型模式</h1><h2 id="Prototype-Pattern"><a href="#Prototype-Pattern" class="headerlink" title="Prototype Pattern"></a>Prototype Pattern</h2><h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h3><h2 id="Singleton-Pattern"><a href="#Singleton-Pattern" class="headerlink" title="Singleton Pattern"></a>Singleton Pattern</h2><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p><strong>注意：</strong></p>
<ul>
<li>1、单例类只能有一个实例。</li>
<li>2、单例类必须自己创建自己的唯一实例。</li>
<li>3、单例类必须给所有其他对象提供这一实例。</li>
</ul>
<h3 id="The-Problem-1"><a href="#The-Problem-1" class="headerlink" title="The Problem"></a>The Problem</h3><p>我们看到，如果不是用单例模式创建的类，可以申明多个实例，每个实例之间是互相独立的。那么有没有办法，能让这个类只能有唯一实例，而且提供给其他对象这个唯一实例呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; settings = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key,Object value)</span> </span>&#123;</span><br><span class="line">        settings.put(key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> settings.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       ConfigManager manager = <span class="keyword">new</span> ConfigManager();<span class="comment">//创建了ConfigManager第一个实例</span></span><br><span class="line">       manager.set(<span class="string">"name"</span>,<span class="string">"Mosh"</span>);<span class="comment">//设置一个键值对 </span></span><br><span class="line">       ConfigManager other = <span class="keyword">new</span> ConfigManager();<span class="comment">//创建了第二个实例，但是查询结果为null</span></span><br><span class="line">       System.out.println(other.get(<span class="string">"name"</span>)); <span class="comment">//null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外还有如下应用场景：</p>
<ul>
<li>一个班级只有一个班主任。</li>
<li>Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。</li>
<li>一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</li>
<li>要求生产唯一序列号。</li>
<li>WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</li>
<li>创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</li>
</ul>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p><strong>如何解决：</strong>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p>
<p><strong>关键代码：</strong>构造函数是私有的。</p>
<p>我们将创建一个 <code>SingleObject</code> 类。<em>SingleObject</em> 类有它的私有构造函数和本身的一个静态实例。</p>
<p><code>SingleObject</code> 类提供了一个静态方法，<strong>供外界获取它的静态实例</strong>。<code>SingletonPatternDemo</code> 类使用 <code>SingleObject</code>类来获取 <code>SingleObject</code>对象。</p>
<p><img src="/2022/08/21/Design-Patterns-3/1.png" style="zoom:67%;"></p>
<h3 id="Implementation-1"><a href="#Implementation-1" class="headerlink" title="Implementation"></a>Implementation</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; settings = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">    <span class="comment">//必须设为静态的</span></span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">static</span> ConfigManager instance = <span class="keyword">new</span> ConfigManager();<span class="comment">//实例在类中构造</span></span><br><span class="line">		<span class="comment">//必须设为静态的，只能类内调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigManager <span class="title">getInstance</span><span class="params">()</span> </span>&#123;<span class="comment">//单例getter</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ConfigManager</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//私有的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key,Object value)</span> </span>&#123;</span><br><span class="line">        settings.put(key,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> settings.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       ConfigManager manager = ConfigManager.getInstance();</span><br><span class="line">       manager.set(<span class="string">"name"</span>,<span class="string">"Jason"</span>);</span><br><span class="line">       ConfigManager other =  ConfigManager.getInstance();<span class="comment">//类外获得的始终是一个实例</span></span><br><span class="line">       System.out.println(other.get(<span class="string">"name"</span>));   <span class="comment">//Jason</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>优点：</strong></p>
<ul>
<li>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li>
<li>2、避免对资源的多重占用（比如写文件操作）。</li>
</ul>
<p><strong>缺点：</strong>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<h3 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise"></a>Exercise</h3><p>Look at the Logger class in the singleton package of the Exercises project. With the current implementation, we can create multiple loggers writing to the same log file in parallel.</p>
<p>Use the singleton pattern to ensure only a single logger can be instantiated for a given file.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLogger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; loggerList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MyLogger instance = <span class="keyword">new</span> MyLogger();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyLogger <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyLogger</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getLoggerList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> loggerList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printLog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String log : loggerList)&#123;</span><br><span class="line">            System.out.println(log);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLog</span><span class="params">(String log)</span> </span>&#123;</span><br><span class="line">        loggerList.add(log);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyLogger logger = MyLogger.getInstance();</span><br><span class="line"></span><br><span class="line">        logger.addLog(<span class="string">"2022 8 22 11:26"</span>);</span><br><span class="line"></span><br><span class="line">        MyLogger logger2 = MyLogger.getInstance();</span><br><span class="line">        logger2.addLog(<span class="string">"2022 8 22 11:27"</span>);</span><br><span class="line"></span><br><span class="line">        MyLogger.printLog();</span><br><span class="line">      <span class="comment">//2022 8 22 11:26</span></span><br><span class="line">			<span class="comment">//2022 8 22 11:27</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Factory-Method-Pattern"><a href="#Factory-Method-Pattern" class="headerlink" title="Factory Method Pattern"></a>Factory Method Pattern</h2><h3 id="The-Problem-2"><a href="#The-Problem-2" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-2"><a href="#Implementation-2" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise"></a>Exercise</h3><h2 id="Abstract-Factory-Pattern"><a href="#Abstract-Factory-Pattern" class="headerlink" title="Abstract Factory Pattern"></a>Abstract Factory Pattern</h2><h3 id="The-Problem-3"><a href="#The-Problem-3" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-3"><a href="#Implementation-3" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise"></a>Exercise</h3><h2 id="Builder-Pattern"><a href="#Builder-Pattern" class="headerlink" title="Builder Pattern"></a>Builder Pattern</h2><h3 id="The-Problem-4"><a href="#The-Problem-4" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-4"><a href="#Implementation-4" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise"></a>Exercise</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/08/21/Design-Patterns-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/21/Design-Patterns-2/" class="post-title-link" itemprop="url">Design-Patterns-2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-21 21:37:51" itemprop="dateCreated datePublished" datetime="2022-08-21T21:37:51+08:00">2022-08-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-22 01:01:36" itemprop="dateModified" datetime="2022-08-22T01:01:36+08:00">2022-08-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="设计模式2-结构型模式"><a href="#设计模式2-结构型模式" class="headerlink" title="设计模式2-结构型模式"></a>设计模式2-结构型模式</h1><h2 id="Composite-Pattern"><a href="#Composite-Pattern" class="headerlink" title="Composite Pattern"></a>Composite Pattern</h2><p>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。</p>
<h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>比如说，在PPT中我创建了两个长方形，两个圆形，那么我们可以选中两个长方形将它们同时移动或者缩放；同样的，我们甚至可以选中四个物体同时移动缩放</p>
<p><img src="/2022/08/21/Design-Patterns-2/1.gif" style="zoom:67%;"></p>
<p>除此之外，最经典的例子是文件夹与文件的表示，一个文件夹（容器对象）既可以存放文件夹（容器对象），也可以存放文件（叶子对象）。如果把树的每个节点摊平，那就是<code>List</code>。而树结构，则是更能直观的体现每个节点与整体的关系。</p>
<p><strong>为什么需要这个模式呢？它的目的是什么？</strong></p>
<p>可以体现出类与类之间的层级结构</p>
<p>主要是想要对外提供一致性的使用方式，即使容器对象与叶子对象之间属性差别可能非常大，我们希望抽象出相同的地方，一致的处理。</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>组合模式中一般有以下三种角色：</p>
<ul>
<li>抽象构件（<code>Component</code>）：一般是接口或者抽象类，是叶子构件和容器构件对象声明接口，抽象出访问以及管理子构件的方法。</li>
<li>叶子节点（<code>Leaf</code>）：在组合中表示叶子节点对象，叶子节点没有子节点，也就没有子构件。</li>
<li>容器构件（<code>Composite</code>）：容器节点可以包含子节点，子节点可以是叶子节点，也可以是容器节点。</li>
</ul>
<p><img src="/2022/08/21/Design-Patterns-2/2.png" style="zoom:67%;"></p>
<h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Component</span> </span>&#123; <span class="comment">// Component接口，容器和叶子都需要实现它</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">render</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> <span class="keyword">implements</span> <span class="title">Component</span></span>&#123; <span class="comment">//实现component接口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写render方法，因为是叶子类，因此只需要实现单个逻辑即可</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Render Shape"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Group</span> <span class="keyword">implements</span> <span class="title">Component</span></span>&#123; <span class="comment">// 实现接口</span></span><br><span class="line">    <span class="comment">// Group中可以有多个component组成，这个角度看Group和Shape是相等的</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Component&gt; components = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以往components中添加shape/group</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component shape)</span></span>&#123;</span><br><span class="line">        components.add(shape);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写render方法，对列表中的每一个Component都调用render</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Component component:components)&#123;</span><br><span class="line">            component.render();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       Group group1 = <span class="keyword">new</span> Group();</span><br><span class="line">       group1.add(<span class="keyword">new</span> Shape());</span><br><span class="line">       group1.add(<span class="keyword">new</span> Shape());</span><br><span class="line"></span><br><span class="line">       Group group2 = <span class="keyword">new</span> Group();</span><br><span class="line">       group2.add(<span class="keyword">new</span> Shape());</span><br><span class="line">       group2.add(<span class="keyword">new</span> Shape());</span><br><span class="line"></span><br><span class="line">       Group group = <span class="keyword">new</span> Group();</span><br><span class="line">       group.add(group1);</span><br><span class="line">       group.add(group2);</span><br><span class="line">      <span class="comment">//层次结构如下：</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      - group</span></span><br><span class="line"><span class="comment">      -	-	group1</span></span><br><span class="line"><span class="comment">      -	-	- shape</span></span><br><span class="line"><span class="comment">      -	-	-	shape</span></span><br><span class="line"><span class="comment">      -	-	group2</span></span><br><span class="line"><span class="comment">      -	-	-	shape</span></span><br><span class="line"><span class="comment">      -	-	- shape</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">       group.render();<span class="comment">//一共是四个叶子结点，执行四次render</span></span><br><span class="line">       <span class="comment">//Render Shape</span></span><br><span class="line">        <span class="comment">//Render Shape</span></span><br><span class="line">        <span class="comment">//Render Shape</span></span><br><span class="line">        <span class="comment">//Render Shape</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>组合模式的优点：</p>
<ul>
<li>可以分层次定义复杂对象，表示局部和全部，客户端可以忽略不同的节点的差异。</li>
<li>从高层次调用，可以很顺畅的调用到每一个局部，一致性比较强。</li>
<li>节点自由搭配，灵活度比较高。</li>
</ul>
<p>缺点：</p>
<ul>
<li>在使用组合模式时，其叶子和组合节点的声明都是实现类，而不是接口，违反了依赖倒置原则。</li>
</ul>
<p>使用场景：</p>
<ul>
<li>希望忽略每个部分的差异，客户端一致使用</li>
<li>需要表现为树形结构，以表示“整体-部分”的结构层次。</li>
</ul>
<h3 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h3><p>We’re building an application for an incident management organization. When an incident (eg fire) occurs, one or more teams may be deployed to attack the incident. </p>
<p>A team often includes a truck and one or more human resources. It can also include a sub team. For example, for a medium-sized incident, we may need to deploy two teams and each team may contain a truck and two persons. </p>
<ul>
<li><p>Team </p>
<ul>
<li><p>Sub Team 1 </p>
<ul>
<li>Truck </li>
<li>Human Resource </li>
<li>Human Resource </li>
</ul>
</li>
<li><p>Sub Team 2 </p>
<ul>
<li>Truck </li>
<li>Human Resource </li>
<li>Human Resource </li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Look at the current implementation of our application in the composite package. </p>
<p>What are the problems with this implementation? Refactor the code using the composite pattern. </p>
<h2 id="Adapter-Pattern"><a href="#Adapter-Pattern" class="headerlink" title="Adapter Pattern"></a>Adapter Pattern</h2><h3 id="The-Problem-1"><a href="#The-Problem-1" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-1"><a href="#Implementation-1" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise"></a>Exercise</h3><h2 id="Decorator-Pattern"><a href="#Decorator-Pattern" class="headerlink" title="Decorator Pattern"></a>Decorator Pattern</h2><h3 id="The-Problem-2"><a href="#The-Problem-2" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-2"><a href="#Implementation-2" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise"></a>Exercise</h3><h2 id="Facade-Pattern"><a href="#Facade-Pattern" class="headerlink" title="Facade Pattern"></a>Facade Pattern</h2><h3 id="The-Problem-3"><a href="#The-Problem-3" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-3"><a href="#Implementation-3" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise"></a>Exercise</h3><h2 id="Flyweight-Pattern"><a href="#Flyweight-Pattern" class="headerlink" title="Flyweight Pattern"></a>Flyweight Pattern</h2><h3 id="The-Problem-4"><a href="#The-Problem-4" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-4"><a href="#Implementation-4" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise"></a>Exercise</h3><h2 id="Bridge-Pattern"><a href="#Bridge-Pattern" class="headerlink" title="Bridge Pattern"></a>Bridge Pattern</h2><h3 id="The-Problem-5"><a href="#The-Problem-5" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-5"><a href="#Implementation-5" class="headerlink" title="Implementation"></a>Implementation</h3><h2 id="Proxy-Pattern"><a href="#Proxy-Pattern" class="headerlink" title="Proxy Pattern"></a>Proxy Pattern</h2><h3 id="The-Problem-6"><a href="#The-Problem-6" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-6"><a href="#Implementation-6" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise"></a>Exercise</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/08/19/Design-Patterns-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/19/Design-Patterns-1/" class="post-title-link" itemprop="url">Design-Patterns-1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-19 10:52:17" itemprop="dateCreated datePublished" datetime="2022-08-19T10:52:17+08:00">2022-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-22 12:50:22" itemprop="dateModified" datetime="2022-08-22T12:50:22+08:00">2022-08-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Design-Patterns-Behavioural"><a href="#Design-Patterns-Behavioural" class="headerlink" title="Design Patterns - Behavioural"></a>Design Patterns - Behavioural</h1><p>首先，什么是设计模式？设计模式是软件开发人员在软件开发过程中面临的<strong>一般问题</strong>的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>
<p>设计模式可以教我们如何去架构一个类、以及类与类之间如何联系起来。在90年代由GoF(四人帮)出版的《设计模式-可复用的面向对象软件元素》的数介绍了23种设计模式</p>
<p>这些设计模式会被分成三类：Creational(创建型)、 Structure(结构型)、Behavioural(行为型)</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left"></th>
<th style="text-align:left"><span style="display:inline-block;width: 400px">包括</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>创建型模式</strong> 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</td>
<td style="text-align:left">工厂模式（Factory Pattern）<br>抽象工厂模式（Abstract Factory Pattern）<br>单例模式（Singleton Pattern）<br>建造者模式（Builder Pattern）<br>原型模式（Prototype Pattern）</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>结构型模式</strong> 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td>
<td style="text-align:left">适配器模式（Adapter Pattern）<br>桥接模式（Bridge Pattern）<br>过滤器模式（Filter、Criteria Pattern）<br>组合模式（Composite Pattern）<br>装饰器模式（Decorator Pattern）<br>外观模式（Facade Pattern）<br>享元模式（Flyweight Pattern）<br>代理模式（Proxy Pattern）</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>行为型模式</strong> 这些设计模式特别关注对象之间的通信。</td>
<td style="text-align:left">责任链模式（Chain of Responsibility Pattern）<br>命令模式（Command Pattern）<br>解释器模式（Interpreter Pattern）<br>迭代器模式（Iterator Pattern）<br>中介者模式（Mediator Pattern）<br>备忘录模式（Memento Pattern）<br>观察者模式（Observer Pattern）<br>状态模式（State Pattern）<br>空对象模式（Null Object Pattern）<br>策略模式（Strategy Pattern）<br>模板模式（Template Pattern）<br>访问者模式（Visitor Pattern）</td>
</tr>
</tbody>
</table>
</div>
<h2 id="The-Essentials"><a href="#The-Essentials" class="headerlink" title="The Essentials"></a>The Essentials</h2><p>首先我们要复习一些Java OOP的基本知识</p>
<h3 id="Coupling"><a href="#Coupling" class="headerlink" title="Coupling"></a>Coupling</h3><h3 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h3><p>接下来介绍OOP的<strong>四大特性</strong>： </p>
<ul>
<li><strong>封装性</strong>：对象属性是隐藏的，对象属性修改需要通过对象方法。</li>
<li><strong>继承性</strong>：子类可以把父类的属性和方法都继承过来，无需重新定义。</li>
<li><strong>多态性</strong>：多态分为静态和动态，静态是指同一个对象可以有不同的表现形式，动态指一个父类型可以指向其子类型的实例，使子类型对同一方法作出不同的回应。</li>
<li><strong>抽象性</strong>：抽象指把一类东西的共同属性和行为提取出来存在一个类里面，而不关注具体行为如何实现。</li>
</ul>
<h3 id="Encapsulation"><a href="#Encapsulation" class="headerlink" title="Encapsulation"></a>Encapsulation</h3><p>见博客：<a href="https://jasonxqh.github.io/2020/07/05/Java基础2/#Encapsulation">Encapsulation</a></p>
<h3 id="Abstraction"><a href="#Abstraction" class="headerlink" title="Abstraction"></a>Abstraction</h3><h3 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h3><p>我们知道抽象类和接口都可以用于实现抽象，但是他们应用的场景有所区别。</p>
<p>接口和抽象类的区别在于，接口一般只提供函数定义，并不会进行声明；抽象类允许包含某些方法的实现。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>共性</th>
<th>都是不断抽取出来的抽象概念</th>
</tr>
</thead>
<tbody>
<tr>
<td>区别1</td>
<td>抽象类体现继承关系，一个类只能单继承<br>接口体现实现关系，一个类可以多实现</td>
</tr>
<tr>
<td>区别2</td>
<td>抽象类是继承，是 “is a”关系<br>接口是实现，是”like a”关系</td>
</tr>
<tr>
<td>区别3</td>
<td>抽象类中可以定义非抽象方法，供子类直接使用<br>接口的方法都是抽象，接口中的成员都有固定修饰符</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Polymorphism"><a href="#Polymorphism" class="headerlink" title="Polymorphism"></a>Polymorphism</h3><p><a href="https://jasonxqh.github.io/2020/07/05/Java基础2/#Polymorphism">Polymorphism</a></p>
<h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p>UML 是 Unified Modeling Language的缩写，即一种统一建模语言</p>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><ul>
<li>由用例图抽象出来的静态结构图，描述类的内部结构</li>
<li>“-”代表成员变量</li>
<li>“+”代表方法</li>
</ul>
<p>比如，对于一个 shape 类来说，它的类图如下设计：</p>
<p><img src="/2022/08/19/Design-Patterns-1/1.png" style="zoom:67%;"></p>
<p>那么，其代码结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> positionX;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h4><h5 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h5><ul>
<li>类型：General Relationship</li>
<li>描述：使用另一个类（uses a)，某个对象的功能依赖于另外的某个对象，而被依赖的对象知识作为一种工具在使用，并不持有对它的引用</li>
<li>表现：局部变量、方法参数、静态方法的调用</li>
<li>表示：<strong>带箭头的虚线</strong>，由使用者指向被使用者</li>
</ul>
<p>比如下图，展示了Shape类中使用了Document类：</p>
<p><img src="/2022/08/19/Design-Patterns-1/2.png" style="zoom:67%;"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(Document doc)</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="继承（extends）"><a href="#继承（extends）" class="headerlink" title="继承（extends）"></a><strong>继承（extends）</strong></h5><ul>
<li>类型：Class Level Relationship</li>
<li>描述：指定了子类如何继承父类的所有特征和行为</li>
<li>表示：带三角形箭头的实线，由子类指向父类</li>
</ul>
<p><img src="/2022/08/19/Design-Patterns-1/3.png" style="zoom:67%;"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Rectangle extends Shape&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="组合（Composition）"><a href="#组合（Composition）" class="headerlink" title="组合（Composition）"></a>组合（Composition）</h5><ul>
<li>描述：组合是关系当中的最强版本，它直接要求包含对象对被包含对象的拥有（is a part of）以及包含对象与被包含对象⽣命期的关系。被包含的对象还可以再被别的对象关联，所以被包含对象是可以共享的，然⽽绝不存在两个包含对象对同⼀个被包含对象的共享。</li>
<li>表现：成员变量</li>
<li>表示：箭尾有一实心菱形的“关联”</li>
</ul>
<p><img src="/2022/08/19/Design-Patterns-1/4.png" style="zoom:67%;"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Shape&#123;</span><br><span class="line">	private Size size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Memento-Pattern"><a href="#Memento-Pattern" class="headerlink" title="Memento Pattern"></a>Memento Pattern</h2><p>第一种我们要学习的是备忘录模式（Memento Pattern）。备忘录模式保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。</p>
<h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>在不破坏封装性的前提下，如何捕获并保存一个对象的内部状态，并在该对象之外保存这个状态。这样可以在以后将对象回复到原先保存的状态。</p>
<p>比如说，我有一个Editor类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Editor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我在main函数中多次设置了这个Editor，现在我想回退(undo)一个状态，请问该怎么实现？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Editor editor = <span class="keyword">new</span> Editor();</span><br><span class="line">        editor.setContent(<span class="string">"a"</span>);</span><br><span class="line">        editor.setContent(<span class="string">"b"</span>);</span><br><span class="line">        editor.undo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如何解决：</strong>通过一个备忘录类专门存储对象状态。</p>
<p><strong>关键代码：</strong>客户不与备忘录类耦合，与备忘录管理类耦合。</p>
<p><strong>应用实例：</strong> 1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctrl + z。 4、IE 中的后退。 5、数据库的事务管理。</p>
<p><strong>优点：</strong> 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2、实现了信息的封装，使得用户不需要关心状态的保存细节。</p>
<p><strong>缺点：</strong>消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</p>
<p><strong>使用场景：</strong> 1、需要保存/恢复数据的相关状态场景。 2、提供一个可回滚的操作。</p>
<p><strong>注意事项：</strong> 1、为了符合迪米特原则，还要增加一个管理备忘录的类。 2、为了节约内存，可使用原型模式+备忘录模式。</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>根据 Single Responsibility Principle ，每个类只需要负责一项任务.</p>
<p>因此，Editor类中，只需要保存当前状态的内容，以及两个方法：</p>
<ul>
<li><code>createState()</code>： 将当前Editor中的内容创建一个 EditorState对象, 并返回这个对象。然后，History类会调用push方法将该状态添加到状态列表中</li>
<li><code>restore()</code>:   从一个EditorState对象中恢复得到content内容</li>
</ul>
<p>在 EditorState类：这是一个保存状态的类，里面除了content之外还有 getter(UML图中省略了)</p>
<p>在History类：这个类中保存了一个状态列表，用来保存之前的状态。此外，还有push和pop方法，用来添加和删除状态</p>
<p><img src="/2022/08/19/Design-Patterns-1/6.png" style="zoom:67%;"></p>
<p>事实上，将这三个类抽象出来，是三种不同的类： <em>Memento</em>、<em>Originator</em> 和 <em>CareTaker</em>。</p>
<ul>
<li><p>Originator(Editor) 创建并在 Memento 对象中存储状态</p>
</li>
<li><p>Memento (EditorState) 包含了要被恢复的对象的状态。</p>
</li>
<li>Caretaker (History) 对象负责从 Memento 中恢复对象的状态。</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 </li>
<li>实现了信息的封装，使得用户不需要关心状态的保存细节。</li>
</ol>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li>消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</li>
</ol>
<h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p>备忘录模式实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Editor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EditorState <span class="title">createState</span><span class="params">()</span> </span>&#123; <span class="comment">// 创建一个新的EditorState</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EditorState(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restore</span><span class="params">(EditorState state)</span> </span>&#123; <span class="comment">// 从一个state中恢复数据</span></span><br><span class="line">        content = state.getContent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123; <span class="comment">//getter</span></span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;<span class="comment">//setter</span></span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EditorState</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String content; 	</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EditorState</span><span class="params">(String content)</span> </span>&#123; <span class="comment">//构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">History</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;EditorState&gt; states = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">// State列表</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">push</span> <span class="params">(EditorState state)</span> </span>&#123; <span class="comment">// 加入列表</span></span><br><span class="line">        states.add(state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> EditorState <span class="title">pop</span> <span class="params">()</span></span>&#123;	<span class="comment">//选择最近的状态，pop</span></span><br><span class="line">        <span class="keyword">int</span> lastIndex = states.size()-<span class="number">1</span>;</span><br><span class="line">        EditorState lastState = states.get(lastIndex);</span><br><span class="line">        states.remove(lastState);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lastState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Editor editor = <span class="keyword">new</span> Editor();</span><br><span class="line">        History history = <span class="keyword">new</span> History();</span><br><span class="line"></span><br><span class="line">        editor.setContent(<span class="string">"a"</span>);</span><br><span class="line">        history.push(editor.createState());</span><br><span class="line"></span><br><span class="line">        editor.setContent(<span class="string">"b"</span>);</span><br><span class="line">        history.push(editor.createState());</span><br><span class="line"></span><br><span class="line">        editor.setContent(<span class="string">"c"</span>);<span class="comment">//此时状态为c</span></span><br><span class="line">        editor.restore(history.pop());<span class="comment">//但是因为调用了restore,因此回退了一个版本</span></span><br><span class="line"></span><br><span class="line">        System.out.println(editor.getContent());<span class="comment">//此时editor版本为b</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h3><p>In the Exercises project, look at the code in the memento/Document class. This class represents a document in a word processor like MS Word or Apple Pages.</p>
<p>Our Document class has three attributes: </p>
<ul>
<li>content </li>
<li>fontName</li>
<li>fontSize </li>
</ul>
<p>We should allow the user to undo the changes to any of these attributes. In the future, we may add additional attributes in this class and these attributes should also be undoable. </p>
<p>Implement the undo feature using the memento pattern</p>
<h2 id="State-Pattern"><a href="#State-Pattern" class="headerlink" title="State Pattern"></a>State Pattern</h2><p>在状态模式（State Pattern）中，类的行为是基于它的状态改变的。在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。</p>
<h3 id="The-Problem-1"><a href="#The-Problem-1" class="headerlink" title="The Problem"></a>The Problem</h3><p><strong>意图：</strong>允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</p>
<p><strong>主要解决：</strong>对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。</p>
<p><strong>何时使用：</strong>代码中包含大量与对象状态有关的条件语句。</p>
<p>比如说，我现在要设计一个和PS类似的软件，那么，当我点击不同的侧栏工具的时候，鼠标在画板上拖动的效果也是不一样的。比如有选择工具、画笔工具、橡皮擦工具等</p>
<p>因此，一个原始的想法就是用很多if else语句或者switch case，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ToolType &#123;</span><br><span class="line">    SELECTION,</span><br><span class="line">    BRUSH,</span><br><span class="line">    ERASER</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Canvas</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ToolType currentTool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseDown</span><span class="params">()</span></span>&#123;<span class="comment">//点击icon后鼠标的形状</span></span><br><span class="line">        <span class="keyword">if</span>(currentTool == ToolType.SELECTION)</span><br><span class="line">            System.out.println(<span class="string">"Selection icon"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(currentTool == ToolType.BRUSH)</span><br><span class="line">            System.out.println(<span class="string">"Brush icon"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (currentTool==ToolType.ERASER)</span><br><span class="line">            System.out.println(<span class="string">"Eraser icon"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseUp</span><span class="params">()</span></span>&#123;<span class="comment">//在画布上拖动的效果</span></span><br><span class="line">        <span class="keyword">if</span>(currentTool == ToolType.SELECTION)</span><br><span class="line">            System.out.println(<span class="string">"Draw dashed rectangle"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(currentTool == ToolType.BRUSH)</span><br><span class="line">            System.out.println(<span class="string">"Draw a line"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (currentTool==ToolType.ERASER)</span><br><span class="line">            System.out.println(<span class="string">"Erase something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么有没有更好的办法呢？</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>我们可以创建一个Tool接口，里面定义两个函数 mouseDown()和mouseUp()，然后用两个具体的状态来实现这个接口，如下所示：</p>
<p><img src="/2022/08/19/Design-Patterns-1/7.png" style="zoom:67%;"></p>
<p>将其抽象出来，如下所示：</p>
<p><img src="/2022/08/19/Design-Patterns-1/8.png" style="zoom:67%;"></p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a><strong>优点：</strong></h4><ol>
<li>封装了转换规则。</li>
<li>枚举可能的状态，在枚举状态之前需要确定状态种类。 </li>
<li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 </li>
<li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 </li>
<li>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</li>
</ol>
<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li>状态模式的使用必然会增加系统类和对象的个数。 </li>
<li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。</li>
<li>状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。</li>
</ol>
<h3 id="Implementation-1"><a href="#Implementation-1" class="headerlink" title="Implementation"></a>Implementation</h3><p>首先，我可以创建一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Tool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseDown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseUp</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们创建两个状态类，用来实现这个接口，每个状态类中mouseDown和mouseUp的行为都是不同的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrushTool</span> <span class="keyword">implements</span> <span class="title">Tool</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Brush icon"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Draw a line"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionTool</span> <span class="keyword">implements</span> <span class="title">Tool</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Selection icon"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Draw a Dashed Rectangle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是，在Canvas中就不用写繁琐的switch case或者if-else case了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Canvas</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Tool currentTool;	</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 调用当前接口的mouseDown或者mouseUp方法就可以实现不同结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseDown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        currentTool.mouseDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        currentTool.mouseUp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Tool <span class="title">getCurrentTool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentTool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrentTool</span><span class="params">(Tool currentTool)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentTool = currentTool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，只要给Canvas设置不同的状态，就可以展现不同的行为了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Canvas canvas = <span class="keyword">new</span> Canvas();</span><br><span class="line"></span><br><span class="line">        canvas.setCurrentTool(<span class="keyword">new</span> SelectionTool());</span><br><span class="line">        canvas.mouseDown(); <span class="comment">// Selection icon</span></span><br><span class="line">        canvas.mouseUp();   <span class="comment">// Draw a Dashed Rectangle</span></span><br><span class="line"></span><br><span class="line">        canvas.setCurrentTool(<span class="keyword">new</span> BrushTool());</span><br><span class="line">        canvas.mouseDown(); <span class="comment">// Brush icon</span></span><br><span class="line">        canvas.mouseUp();   <span class="comment">// Draw a line</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Abusing-the-State-Pattern"><a href="#Abusing-the-State-Pattern" class="headerlink" title="Abusing the State Pattern"></a>Abusing the State Pattern</h3><p>之前说了，State Pattern 必然会增加系统类和对象的个数。 因此，如果不正确使用它的话，很可能造成滥用。比如说下面这个情况：</p>
<p>比如说我想设计一个时钟类，这个类很不需要很多状态，只有<code>running</code>和<code>stop</code>，也只需要一个方法：<code>click</code>。因此，对这种不会有“发展”的、简单的类，用if-else case就可以解决了，不需要再使用state pattern</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopWatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isRunning;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isRunning)&#123;</span><br><span class="line">            isRunning = <span class="keyword">false</span>;</span><br><span class="line">            System.out.println(<span class="string">"Stopped"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            isRunning = <span class="keyword">true</span>;</span><br><span class="line">            System.out.println(<span class="string">"Running"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StopWatch stop_watch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">        stop_watch.click();	<span class="comment">// Running</span></span><br><span class="line">        stop_watch.click();	<span class="comment">// Stopped</span></span><br><span class="line">        stop_watch.click(); <span class="comment">// Running</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，如果对State Pattern了解不够的话，在这种情况下很可能会滥用，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopWatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> State currentState = <span class="keyword">new</span> StopState(<span class="keyword">this</span>); <span class="comment">//初始化是停止状态</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrentState</span><span class="params">(State currentState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState = currentState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">()</span></span>&#123; <span class="comment">//调用click，就会开始/停止</span></span><br><span class="line">        currentState.click();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;<span class="comment">//创建接口函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">click</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunningState</span> <span class="keyword">implements</span> <span class="title">State</span></span>&#123; <span class="comment">//分别实现运行时状态和停止状态</span></span><br><span class="line">    <span class="keyword">private</span> StopWatch stopWatch;								</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RunningState</span><span class="params">(StopWatch stopWatch)</span> </span>&#123;<span class="comment">//构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.stopWatch = stopWatch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">()</span></span>&#123;<span class="comment">//每次点击时，先设置相反的状态，然后打印</span></span><br><span class="line">        stopWatch.setCurrentState(<span class="keyword">new</span> StopState(stopWatch));</span><br><span class="line">        System.out.println(<span class="string">"Stopped"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopState</span> <span class="keyword">implements</span> <span class="title">State</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StopWatch stopWatch;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StopState</span><span class="params">(StopWatch stopWatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stopWatch = stopWatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stopWatch.setCurrentState(<span class="keyword">new</span> RunningState(stopWatch));</span><br><span class="line">        System.out.println(<span class="string">"Running"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样虽然结果是一样的，但就会显得非常繁琐，多出来很多类，浪费很多空间。</p>
<h3 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise"></a>Exercise</h3><p>In the Exercises project, look at the code in the state/ DirectionService class. This is the class that powers our mapping app. It provides two methods for calculating the estimated time of arrival (ETA) and the direction between two points. </p>
<p>Identify the problems in this implementation. Then, refactor the code to use the state pattern. What are the benefits of the new implementation?</p>
<h2 id="Iterator-Pattern"><a href="#Iterator-Pattern" class="headerlink" title="Iterator Pattern"></a>Iterator Pattern</h2><h3 id="The-Problem-2"><a href="#The-Problem-2" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-2"><a href="#Implementation-2" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Benefits"><a href="#Benefits" class="headerlink" title="Benefits"></a>Benefits</h3><h3 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise"></a>Exercise</h3><h3 id="A-Quick-Note"><a href="#A-Quick-Note" class="headerlink" title="A Quick Note"></a>A Quick Note</h3><h2 id="Strategy-Pattern"><a href="#Strategy-Pattern" class="headerlink" title="Strategy Pattern"></a>Strategy Pattern</h2><h3 id="The-Problem-3"><a href="#The-Problem-3" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-3"><a href="#Implementation-3" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise"></a>Exercise</h3><h2 id="Template-Method-Pattern"><a href="#Template-Method-Pattern" class="headerlink" title="Template Method Pattern"></a>Template Method Pattern</h2><h3 id="The-Problem-4"><a href="#The-Problem-4" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-4"><a href="#Implementation-4" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise"></a>Exercise</h3><h2 id="Command-Pattern"><a href="#Command-Pattern" class="headerlink" title="Command Pattern"></a>Command Pattern</h2><h3 id="The-Problem-5"><a href="#The-Problem-5" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-5"><a href="#Implementation-5" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Composite-Commands"><a href="#Composite-Commands" class="headerlink" title="Composite Commands"></a>Composite Commands</h3><h3 id="Undoable-Commands"><a href="#Undoable-Commands" class="headerlink" title="Undoable Commands"></a>Undoable Commands</h3><h3 id="Implementing-Undo-Mechanism"><a href="#Implementing-Undo-Mechanism" class="headerlink" title="Implementing Undo Mechanism"></a>Implementing Undo Mechanism</h3><h3 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise"></a>Exercise</h3><h2 id="Observer-Pattern"><a href="#Observer-Pattern" class="headerlink" title="Observer Pattern"></a>Observer Pattern</h2><h3 id="The-Problem-6"><a href="#The-Problem-6" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-6"><a href="#Implementation-6" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Communication-Styles"><a href="#Communication-Styles" class="headerlink" title="Communication Styles"></a>Communication Styles</h3><h3 id="The-Push-Style"><a href="#The-Push-Style" class="headerlink" title="The Push Style"></a>The Push Style</h3><h3 id="The-Pull-Style"><a href="#The-Pull-Style" class="headerlink" title="The Pull Style"></a>The Pull Style</h3><h3 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise"></a>Exercise</h3><h2 id="Mediator-Pattern"><a href="#Mediator-Pattern" class="headerlink" title="Mediator Pattern"></a>Mediator Pattern</h2><h3 id="The-Problem-7"><a href="#The-Problem-7" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-7"><a href="#Implementation-7" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Using-the-Observer-Pattern"><a href="#Using-the-Observer-Pattern" class="headerlink" title="Using the Observer Pattern"></a>Using the Observer Pattern</h3><h3 id="Implementation-Using-the-Observer-Pattern"><a href="#Implementation-Using-the-Observer-Pattern" class="headerlink" title="Implementation Using the Observer Pattern"></a>Implementation Using the Observer Pattern</h3><h3 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise"></a>Exercise</h3><h2 id="Chain-of-Responsibility"><a href="#Chain-of-Responsibility" class="headerlink" title="Chain of Responsibility"></a>Chain of Responsibility</h2><h3 id="The-Problem-8"><a href="#The-Problem-8" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-8"><a href="#Implementation-8" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise"></a>Exercise</h3><h2 id="Visitor-Pattern"><a href="#Visitor-Pattern" class="headerlink" title="Visitor Pattern"></a>Visitor Pattern</h2><h3 id="The-Problem-9"><a href="#The-Problem-9" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-9"><a href="#Implementation-9" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise"></a>Exercise</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/06/10/Raft/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/10/Raft/" class="post-title-link" itemprop="url">Raft</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-10 20:24:06" itemprop="dateCreated datePublished" datetime="2022-06-10T20:24:06+08:00">2022-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-24 09:50:02" itemprop="dateModified" datetime="2022-06-24T09:50:02+08:00">2022-06-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h1><p>在 <a href="https://jasonxqh.github.io/2021/12/01/数据库-系统可用性/#Raft算法">Raft算法</a> 这篇博客中，我们初步学习了Raft算法，但是介绍的不够详细，我会在原来的基础上增加一部分内容</p>
<p>在介绍Raft算法前，我们首先要知道Paxos算法，但是它难以理解，状态空间十分复杂，因此没有构建显示系统的统一基础。由此才提出了Raft算法。</p>
<ul>
<li>Raft算法的应用：<ul>
<li>分布式KV系统，etcd</li>
<li>微服务基础设施，consul</li>
</ul>
</li>
</ul>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p> raft是一个共识算法（consensus algorithm），所谓共识，就是即使在部分节点故障、网络延时、网络分割的情况下，多个节点对某个事情达成一致的看法</p>
<p>而在分布式系统中，共识算法更多用于提高系统的容错性，比如分布式存储中的复制集（replication），在 带着问题学习分布式系统之中心化复制集 一文中介绍了中心化复制集的相关知识。raft协议就是一种leader-based的共识算法，与之相应的是leaderless的共识算法。</p>
<p>简单概括算法就是：raft会先选举出leader，leader完全负责replicated log的管理。leader负责接受所有客户端更新请求，然后复制到follower节点，并在“安全”的时候执行这些请求。如果leader故障，followes会重新选举出新的leader。</p>
<h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><p> 在正式介绍方法前，我们先来介绍一些基本知识</p>
<h4 id="复制状态机"><a href="#复制状态机" class="headerlink" title="复制状态机"></a>复制状态机</h4><p> 共识算法的实现一般是基于复制状态机（Replicated state machines），何为复制状态机：</p>
<blockquote>
<p>If two identical, <strong>deterministic</strong> processes begin in the same state and get the same inputs in the same order, they will produce the same output and end in the same state.</p>
</blockquote>
<p>   简单来说：<strong>相同的初识状态 + 相同的输入 = 相同的结束状态</strong>。引文中有一个很重要的词<code>deterministic</code>，就是说不同节点要以相同且确定性的函数来处理输入，而不要引入一些不确定的值，比如本地时间等。如何保证所有节点 <code>get the same inputs in the same order</code>，使用replicated log是一个很不错的注意，log具有持久化、保序的特点，是大多数分布式系统的基石。</p>
<p>  因此，可以这么说，在raft中，leader将客户端请求（command）封装到一个个log entry，将这些log entries复制（replicate）到所有follower节点，然后大家按相同顺序应用log entry中的command，则状态肯定是一致的。</p>
<p><img src="/2022/06/10/Raft/1.png"></p>
<p>如上图，在这个server中记录了日志 <code>x&lt;-3,y&lt;-1,y-9</code>(第二步)，那么日志发送给其他server之后(第二步)，其他server的状态也会和这个一致(第三步).</p>
<p>结合数据库来看，数据库会产生日志，实际上就是状态机中的log模块，数据库之间同步的时候，会先把日志部分同步到其他机器上，通过raft协议认证过日志之后(主要是在第二步)，就可以应用到数据库当中。</p>
<h4 id="任期"><a href="#任期" class="headerlink" title="任期"></a>任期</h4><p>在Raft算法中，哪个节点做leader是大家投票选举出来的，每个leader工作一段时间，然后选出新的leader继续负责。这根民主社会的选举很像，每一届新的履职期称之为一届任期，在raft协议中，也是这样的，对应的术语叫<strong>term</strong>。</p>
<p>如下图所示，是一个时间轴上的几种任期的情况</p>
<p><img src="/2022/06/10/Raft/2.png"></p>
<p>第1、2、4是正常的任期，即先进行选举，然后是常规操作(复制日志等)</p>
<p>第3个任期没有产生leader，说明选举失败了，那么会直接开始下一个任期，发起新的选举，没有常规操作。后面会解释这种 <em>split vote</em> 的情况。</p>
<ol>
<li>时间按任期划分，通过任期识别过时消息等</li>
<li>每个任期从Leader选举开始，选举结束后才正常处理客户端请求</li>
<li>存在某些选票被瓜分的情况，没有Leader产生，开始下一个任期</li>
</ol>
<p>term（任期）以选举（election）开始，然后就是一段或长或短的稳定工作期（normal Operation）。从上图可以看到，任期是递增的，这就充当了逻辑时钟的作用；</p>
<p>为什么要设置term？term就相当于把系统时间切成不规则的一片一片，每个term的作用就是确保一段时间内只能有一个leader。因为在分布式系统中，很容易出现脑裂的问题(出现多个leader)，那么这时候两个leader之间很容易出现矛盾，无法保证系统的一致性。Raft采用Term的方法，确保当前任期内只会选举出一个leader，且上一个term的leader不能管理下一个term。</p>
<h4 id="三种角色"><a href="#三种角色" class="headerlink" title="三种角色"></a>三种角色</h4><ul>
<li>Leader: 响应客户端的请求，同步数据</li>
<li>Candidate: Leader选举时的状态，获得多数选票可担任Leader</li>
<li>Follower: 初始启动状态，接收日志同步请求并响应</li>
</ul>
<h4 id="三种远程过程调用-RPC"><a href="#三种远程过程调用-RPC" class="headerlink" title="三种远程过程调用(RPC):"></a>三种远程过程调用(RPC):</h4><ul>
<li>RequestVote RPC : 用于Candidate收集选票</li>
<li>AppendEntries RPC: Leader日志复制或发送心跳(不含日志项)</li>
<li>InstallSnapshot RPC: Leader通过此RPC发送快照给Follower</li>
</ul>
<h2 id="Leader-election"><a href="#Leader-election" class="headerlink" title="Leader election"></a>Leader election</h2><p>在raft协议中，一个节点任意时刻都处于以下三个状态之一：</p>
<ul>
<li>Leader</li>
<li>Follower</li>
<li>Candidate</li>
</ul>
<p>给出状态转移图能很直观的知道这三个状态的区别：</p>
<p><img src="/2022/06/10/Raft/5.png"></p>
<p>什么时候会发起选举？</p>
<ul>
<li><p>首先，所有节点启动时都是follower状态</p>
</li>
<li><p>如果在一段时间内如果没有收到来自leader的心跳，此时leader可能出错/挂了，此时节点从follower切换到candidate，发起选举</p>
</li>
<li><p>如果收到大多数节点的票（含自己的一票），节点会切换到leader状态</p>
</li>
<li>如果节点发现有一个节点比自己先更新，则主动从candidate  切换到follower。如果上一个Leader收到下一个任期的Leader发送的消息，也会从leader切换到follower</li>
</ul>
<p>总之，系统中最多只有一个leader，如果在一段时间里发现没有leader，则大家通过选举-投票选出leader。leader会不停的给follower发心跳消息，表明自己的存活状态。如果leader故障，那么follower会转换成candidate，重新选出leader。</p>
<h3 id="选举过程"><a href="#选举过程" class="headerlink" title="选举过程"></a>选举过程</h3><p>一个Follower在<strong>随机的</strong>选举超时时间内(election timeout)内没有收到来自Leader的心跳（也许此时还没有选出leader，大家都在等；也许leader挂了；也许只是leader与该follower之间网络故障），就会发起选举，选出新Leader</p>
<p>步骤如下：</p>
<ul>
<li>增加节点本地的 <em>current term</em> ，切换到candidate状态</li>
<li>投自己一票</li>
<li>并行给其他节点发送 <em>RequestVote RPCs</em></li>
<li><p>等待其他节点的回复</p>
<p>在这个过程中，根据来自其他节点的消息，可能出现三种结果</p>
</li>
</ul>
<h4 id="结果1"><a href="#结果1" class="headerlink" title="结果1"></a>结果1</h4><ol>
<li>收到majority的投票（含自己的一票），则赢得选举，成为leader</li>
</ol>
<blockquote>
<p> 第一种情况，赢得了选举之后，新的leader会立刻给所有节点发消息，广而告之，避免其余节点触发新的选举。在这里，先回到投票者的视角，投票者如何决定是否给一个选举请求投票呢，有以下约束：</p>
<ul>
<li>在任一任期内，单个节点最多只能投一票</li>
<li>候选人知道的信息不能比自己的少（这一部分，后面介绍log replication和safety的时候会详细介绍）</li>
<li>first-come-first-served 先来先得</li>
</ul>
</blockquote>
<h4 id="结果2"><a href="#结果2" class="headerlink" title="结果2"></a>结果2</h4><ol>
<li>被告知别人已当选，那么自行切换到follower</li>
</ol>
<blockquote>
<p>第二种情况，比如有三个节点A B C。A B同时发起选举，而A的选举消息先到达C，C给A投了一票，当B的消息到达C时，已经不能满足上面提到的第一个约束，即C不会给B投票，而A和B显然都不会给对方投票。A胜出之后，会给B,C发心跳消息，节点B发现节点A的term不低于自己的term，知道有已经有Leader了，于是转换成follower。</p>
</blockquote>
<h5 id="例子-初始状态"><a href="#例子-初始状态" class="headerlink" title="例子-初始状态"></a>例子-初始状态</h5><p>正如下面这个gif所展示的。</p>
<ul>
<li>一开始处于橘黄色阶段，大家都是Follower</li>
<li>S4和S5的等待时间相继结束，S4快一点，S5结束的时候因为没有收到来自S4发送的选举消息，还以为没人发起选举，于是也开始发送。</li>
<li>S4和S5首先把第一票都投给自己了，然后向其他节点发送选举信息，其他节点收到信息后会给发送者投票。每个节点只能投一票，先到先得。投票显示为<code>+</code>号，如果已经投给别人了，再收到选举信息，则会返回<code>-</code>号<ul>
<li>我们看到：S1先收到S4的选举信息，然后收到S5的选举信息，因此给S4返回+，给S5返回-</li>
<li>S2先收到来自S5的选举信息，然后收到S4的选举信息，因此给S5返回+，给S4返回-</li>
<li>S3先收到来自S4的消息，然后收到来自S5的消息，因此给S4返回+，给S5返回-</li>
<li>S4、S5收到来自对方的消息后，由于已经把票给了自己，所以都回给对方 -</li>
<li>最终，S4收到了S4、S1、S3的票, 是大多数，由此称为Leader</li>
</ul>
</li>
</ul>
<p><img src="/2022/06/10/Raft/1.gif"></p>
<h4 id="结果3"><a href="#结果3" class="headerlink" title="结果3"></a>结果3</h4><ol>
<li>一段时间内没有收到majority投票，则保持candidate状态，重新发出选举</li>
</ol>
<h5 id="例子-server挂了"><a href="#例子-server挂了" class="headerlink" title="例子-server挂了"></a>例子-server挂了</h5><p>如下图所示，在第二个任期中，S2是Leader，然后我们手动让S2挂机</p>
<p><img src="/2022/06/10/Raft/12.gif"></p>
<blockquote>
<ul>
<li>此时只剩下四个节点了，S1和S3因为收不到来自Leader的心跳，term结束后便发起了投票。</li>
<li>由于只剩下4个节点，S1和S3由于发送的消息过于同步，导致每个节点都获得了两票，由此在term3中无法选出leader</li>
<li>因此某个节点term3结束后，会立即进入term4，并向外发送选举信号，开启新一轮选举。</li>
</ul>
<p>因此raft引入了randomized election timeouts来尽量避免平票情况。同时，leader-based 共识算法中，节点的数目都是奇数个，尽量保证majority的出现。</p>
</blockquote>
<h4 id="重要保证"><a href="#重要保证" class="headerlink" title="重要保证"></a>重要保证</h4><ul>
<li>随机的选举超时时间(150-300ms) ，减少3.3中瓜分选票的情况</li>
<li>每个人起内最多一个Leader，任何节点收到之前任期的消息都不会影响现在的状态</li>
<li>选票先到先得，只要请求消息满足要求(任期+日志)则投票</li>
<li>大多数选票原则，这也要求每个节点在每个任期内有且只有一张选票</li>
</ul>
<h2 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h2><p>当有了leader，系统应该进入对外工作期了。客户端的一切请求来发送到leader，leader来调度这些并发请求的顺序，并且保证leader与followers状态的一致性。raft中的做法是，将这些请求以及执行顺序告知followers。leader和followers以相同的顺序来执行这些请求，保证状态一致。</p>
<h3 id="日志复制-1"><a href="#日志复制-1" class="headerlink" title="日志复制"></a>日志复制</h3><p>每个节点上的日志复制流程有是怎么样的呢？</p>
<ul>
<li>复制： 某个日志把写入到Follower的日志中</li>
<li>提交：如果当前任期内的日志项被多数节点写入，则可以变为提交状态。此状态下日志项不再被修改</li>
<li>应用： 将已经提交的日志项应用到状态机，会真正影响节点状态</li>
</ul>
<p><img src="/2022/06/10/Raft/9.png"></p>
<p>不难看到，logs由顺序编号的log entry组成 ，每个log entry除了包含command，还包含产生该log entry时的leader term。从上图可以看到，五个节点的日志并不完全一致，raft算法为了保证高可用，并不是强一致性，而是最终一致性，leader会不断尝试给follower发log entries，直到所有节点的log entries都相同。</p>
<h3 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h3><p>当系统（leader）收到一个来自客户端的写请求，到返回给客户端，整个过程从leader的视角来看会经历以下步骤</p>
<ol>
<li>客户端将包含一条指令的请求发送到Leader上</li>
<li>Leader把这条指令作为日志项附加到本地的日志中，并发送AppendEntriesRPC给其他服务器，复制日志项</li>
<li>Follower返回复制结果给Leader</li>
<li>当Leader认为这个日志项已经被多数节点复制，那么在提交此日志项并将这条日志项应用到状态机后，会返回给客户端</li>
</ol>
<p>可以看到日志的提交过程有点类似两阶段提交(2PC)，不过与2PC的区别在于，<strong>leader只需要大多数（majority）节点的回复即可</strong>，这样只要超过一半节点处于工作状态则系统就是可用的。一旦向客户端返回成功消息，那么系统就必须保证log（其实是log所包含的command）<strong>在任何异常的情况下都不会发生回滚</strong>。 </p>
<p>示意图如下：</p>
<p><img src="/2022/06/10/Raft/12.png"></p>
<h5 id="例子-复制"><a href="#例子-复制" class="headerlink" title="例子-复制"></a>例子-复制</h5><ol>
<li>首先，我在S2节点发起request(只能对leader发起request)。这时候Leader会把这条指令附加到本地的日志中，但并未提交(虚线框)</li>
<li>然后，S2向其他节点发送者条日志，其他节点收到之后，都把这条日志加到本中，但是没有提交(虚线框)</li>
<li>Follower把成功复制的结果返回给Leader，Leader收到了4票，认为这个日志项已经被多数节点复制</li>
<li>Leader把这项日志应用到状态机(变成实线框)，并将结果返回给客户端。</li>
<li>Leader给Folloer发信息，意思是说我已经提交成功并应用了，你们也可以提交了，因此Folloer也相继提交并应用了</li>
</ol>
<p><img src="/2022/06/10/Raft/3.gif"></p>
<h3 id="日志复制的保证"><a href="#日志复制的保证" class="headerlink" title="日志复制的保证"></a>日志复制的保证</h3><ul>
<li>如果不同日志中的两个条目有着相同的索引和任期号，则它们所存储的命令是相同的</li>
<li>如果不同日志中的两个条目有着相同的索引和任期号，则它们之前所有条目都是完全一样的。<ul>
<li>在复制日志项的时候，会携带上一个日志项的index和term序号，如果不匹配，会一直查找，直到匹配了才把日志复制过来</li>
</ul>
</li>
</ul>
<h4 id="可能出现不一致的场景"><a href="#可能出现不一致的场景" class="headerlink" title="可能出现不一致的场景"></a>可能出现不一致的场景</h4><p>我们举几个例子，下图 a-f是follower可能出现的场景(不是说有6个follower)</p>
<p><img src="/2022/06/10/Raft/11.png"></p>
<h5 id="日志项缺失"><a href="#日志项缺失" class="headerlink" title="日志项缺失"></a><strong>日志项缺失</strong></h5><ul>
<li><p>a在收到(6,9)之后宕机 , 示意图如下图所示(不是完全匹配)</p>
<p><img src="/2022/06/10/Raft/4.gif"></p>
</li>
<li><p>b在收到(4,4)之后宕机，后面几个term一直没有恢复</p>
</li>
</ul>
<h5 id="日志项多余"><a href="#日志项多余" class="headerlink" title="日志项多余"></a><strong>日志项多余</strong></h5><ul>
<li><p>c作为follower收到了来自leader的(6,11)日志之后，Leader宕机，而此时其他节点可能还没收到</p>
</li>
<li><p>d可能本来就是Leader，接收了来自客户端的两次请求之后，还没把信息传递出去，就宕机了，再次选举得到的新Leader已经不是它了，因此不会有Term7的信息</p>
</li>
</ul>
<p>示意图如下:</p>
<p><img src="/2022/06/10/Raft/6.gif"></p>
<h5 id="日志项不匹配"><a href="#日志项不匹配" class="headerlink" title="日志项不匹配"></a><strong>日志项不匹配</strong></h5><ul>
<li>e收到(4,6)(4,7)之后宕机，示意图如下所示：<ul>
<li><img src="/2022/06/10/Raft/5.gif"></li>
</ul>
</li>
</ul>
<ul>
<li>F多收到任期2,3的日志项，但是都没有提交成功。这时候f宕机，系统选取了新的leader，开启term4。由于之前term2、3没有提交成功，导致该term的日志没有写入多数节点，导致term4的leader没有term2、3的日志项</li>
</ul>
<p>那么如果出现了不一致的情况，此时Leader首先会进行要如何解决？首先要知道的一个原则：<strong>Leader不会覆盖或者删除自己的日志</strong></p>
<ul>
<li><strong>日志项缺失</strong><ul>
<li>Leader会从最新的日志开始发起，因为每条日志都会保留上一条日志的index和term序号，因此可以和上一条做比较。如果Folloer没有找到对应的日志项，就会拒绝。</li>
<li>Leader发现拒绝接受的消息，就会向前逐个排查，直到Follower最终找到与Leader对应的相同位置，</li>
<li>然后，Leader把条该日志之后的所有日志全部发送给follow，让其同步，覆盖掉不匹配的日志项</li>
</ul>
</li>
<li><strong>日志项多余</strong> <ul>
<li>Leader发现follower的日志项比自己多，会发送信息给follower让他同步我自己的日志项。这是一个强制性的同步，既然选择了leader，就一定要让folloer和leader一致</li>
</ul>
</li>
<li>日志项不匹配的操作逻辑和日志项缺失一样</li>
</ul>
<p>可能有人说一个一个找会比较麻烦，那么可以进行一些优化，比如三个三个找，或者按照任期向前搜索</p>
<p>最终的结果是日志必须按照顺序记录的如下图：</p>
<p><img src="/2022/06/10/Raft/9.png" style="zoom:50%;"></p>
<h2 id="Safety"><a href="#Safety" class="headerlink" title="Safety"></a>Safety</h2><p>在上面提到只要日志被复制到majority节点，就能保证不会被回滚，即使在各种异常情况下，这根leader election提到的选举约束有关。在这一部分，主要讨论raft协议在各种各样的异常情况下如何工作的。</p>
<p>衡量一个分布式算法，有许多属性，如</p>
<ul>
<li>safety：nothing bad happens,</li>
<li>liveness： something good eventually happens.</li>
</ul>
<p>任何系统模型下，都需要满足safety属性，即在任何情况下，系统都不能出现不可逆的错误，也不能向客户端返回错误的内容。比如，raft保证被复制到大多数节点的日志不会被回滚，那么就是safety属性。而raft最终会让所有节点状态一致，这属于liveness属性。</p>
<p>raft协议 会保证以下属性</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>性质</th>
<th>描述</th>
<th>问题</th>
<th>解决</th>
</tr>
</thead>
<tbody>
<tr>
<td>选举安全原则(Election Safty)</td>
<td>一个任期内最多允许一个Leader</td>
<td>Split Vote</td>
<td>随机选举时间，多次选举</td>
</tr>
<tr>
<td>Leader只追加原则(Leader Apeend-Only)</td>
<td>Leader永远不会覆盖或者删除自己的日志，它只会增加日志项</td>
<td>日志不一致</td>
<td>强制Follower与其一致</td>
</tr>
<tr>
<td>日志匹配原则(Log Match)</td>
<td>如果两个日志在相同的索引位置上的日志项的任期号相同，那么就认为这个日志项索引位置之前的日志也完全相同</td>
<td>日志不一致</td>
<td>日志复制，一致性检验</td>
</tr>
<tr>
<td>Leader完全原则(Leader Completeness)</td>
<td>如果一个日志项在一个给定任期内被提交，那么这个日志项一定会出现在所有任期号更大的Leader中</td>
<td>无法判断某个entry是否被提交</td>
<td>选举限制+推迟提交</td>
</tr>
<tr>
<td>状态机安全原则(State Machine Safety)</td>
<td>如果一个节点已经将给定索引位置的日志项应用到状态机中，则所有其他节点不会再该索引位置应用不同的日志项</td>
<td>反证法</td>
<td>反证法</td>
</tr>
</tbody>
</table>
</div>
<p>前三点我在<a href="#重要保证">Leader election</a>和<a href="#日志复制的保证">日志复制的保证</a> 章节都已经谈到了,因此着重来说说后面：</p>
<h3 id="leader-completeness-vs-elcetion-restriction"><a href="#leader-completeness-vs-elcetion-restriction" class="headerlink" title="leader completeness vs elcetion restriction"></a>leader completeness vs elcetion restriction</h3><p>Leader完全原则是说：如果一个日志项在一个给定任期内被提交，那么这个日志项一定会出现在所有任期号更大的Leader中 。</p>
<p>要满足这个原则，就要在选举的时候加入一些判断——如何保证日志项一定会出现在任期更大的Leader当中呢？</p>
<h4 id="选举时判断最新的日志项"><a href="#选举时判断最新的日志项" class="headerlink" title="选举时判断最新的日志项"></a>选举时判断最新的日志项</h4><p><img src="/2022/06/10/Raft/14.png"></p>
<p>如上面这个情况：</p>
<ol>
<li>S3、S4处于宕机状态，不去考虑</li>
<li>S1、S2、S5 由于没有Leader，因此投票选举，此时S1正处于Candidate状态。</li>
<li>但是，我们看到S2和S5并没有投票给S1，这是因为S2、S5比S1多了一个Term6日志项 。因为对于S2、S5来说，Term6的日志并没有在本地提交，但是它并不知道Term6的Leader是否已经提交了这个日志。因为从复制过程我们也可以看出，Leader提交日志的时候，实际上Follower是还没有提交的。S2、S5看到S1的日志项并不是最新的，因此会拒绝投票</li>
</ol>
<p><img src="/2022/06/10/Raft/14.gif"></p>
<p>破解这个问题，就会使用到随机选举时间，下次可能是S2、S5发起选举，从而避免选举失败的问题</p>
<h3 id="可能触发安全性隐患的问题"><a href="#可能触发安全性隐患的问题" class="headerlink" title="可能触发安全性隐患的问题"></a>可能触发安全性隐患的问题</h3><h4 id="宕机异常"><a href="#宕机异常" class="headerlink" title="宕机异常"></a>宕机异常</h4><ul>
<li>Leader 宕机： 其余节点超时后重新选举，选出新的Leader。当此节点重新进入集群之后，接收心跳信息</li>
<li>Candidate/Follower 宕机：集群没有出现故障问题，重启后恢复为Follower节点加入集群</li>
</ul>
<h4 id="网络分区"><a href="#网络分区" class="headerlink" title="网络分区"></a>网络分区</h4><p>问题：某一节点再次加入集群之后，增大的任期会打断当前系统的执行</p>
<p>解决方法：Pre-Vote方案就像是一次Leader选举，不过不改变节点状态。如果能够获取多数选票，则可以发起新一轮选举。如下图所示：</p>
<p><img src="/2022/06/10/Raft/15.png"></p>
<ul>
<li>当前集群中，可能网络突然出现了问题，五个节点变分为了两组：AB可以互相通信、CDE可以相互通信，但是他们之间没有办法相互通信</li>
<li>因此，对A、B来说，A本来就是Leader，状态不会发生改变，B会收到来自Leader的信号，也不会发起选举；C D E收不到来自Leader的信息，因此发起选举，选出了他们的Leader C</li>
<li>对于C来说，它可以达到多数派要求(多余一半的节点会投票给它)，它会为C、D、E这组节点提供服务。但是对于旧的Leader A,它不能得到多数票，因为联系不到其他节点，而且也不知道当前实际上有一个新的Leader可以提供服务。</li>
</ul>
<p>在这种情况下，如果网络被修复之后，旧的Leader A 会接收到来自Leader C发送的消息，从中发现对方的Term 比自己的更大，因此从Leader转换为Follower</p>
<p>还有一种网络分区导致的情况：</p>
<p><img src="/2022/06/10/Raft/16.png"></p>
<ul>
<li>网络突然出现了问题，C、D被隔开，A虽然找不到CD，但是仍能获得多数选票，为A、B、E提供服务</li>
<li>C、D由于没办法取得Leader心跳，因此转变为Candidate发送选举请求，但是都无法获得多数选票，因此始终在选举当中，term号一直在增加</li>
<li><p>因此当网络分区消失之后，C、D重新加入集群，此时A就会发现：自己Term号要远远小于C的Term号，按照道理自己必须变成Follower，把Leader位置禅让给C。但是C又没有A、B、E在网络分区时间段记录下的日志。此时C、D的加入就会打断当前系统的执行。</p>
</li>
<li><p>由于C和D的日志项是落后于A、B、E的，所以它发送的消息，别人都是不认可的，因此最终A、B、E中的某个节点会发起选举，抢夺C的Leader。</p>
</li>
</ul>
<p>为了解决这个问题，有 Pre-Vote 的解决方案。对于C和D节点来说，在网络分区结束之后加入集群，会进行一轮预投票，这个阶段与Leader选举类似，但是不会改变节点的状态。如果在这轮预投票中可以获得多数票，那么就可以增加任期，发起新一轮选举。而显然，C和D并不会在这轮选举中获取大多数票</p>
<h2 id="线性一致性"><a href="#线性一致性" class="headerlink" title="线性一致性"></a>线性一致性</h2><ul>
<li>定义：数据像只有一个副本一样，在各节点上写生效顺序相同，写写全局的先后一致，能读到最新的写</li>
</ul>
<p>而Raft并不等于线性一致，但可以基于Raft实现线性一致性。但这是较弱的一致性，在上面我们也说到了，在网络分区的时候，有可能读取到旧的数据</p>
<p><img src="/2022/06/10/Raft/17.png"></p>
<p>我们看到，从用户看到的情况看：</p>
<p>S1节点先写入<code>W(x=1)</code>; S2节点再写入<code>W(x=2)</code>, 但是读取的时候，先读取得到<code>R(x=2)</code>,再读取<code>R(x=1)</code>。可能认为出现了线性不一致。</p>
<p>其实这是被允许的，只要能在时间轴上，每一个事务(读、写)都能抽象成一个点，就可以满足若线性一致性了</p>
<h3 id="强一致性"><a href="#强一致性" class="headerlink" title="强一致性"></a>强一致性</h3><p>实现强一致性的三种读方法</p>
<h4 id="Read-Log"><a href="#Read-Log" class="headerlink" title="Read Log"></a>Read Log</h4><p>这种方式，读写都会经过Leader，通过日志应用到复制状态机以获得正确的结果</p>
<ul>
<li>优点： 读写操作采用相同 的处理方法，容易实现线性一致性</li>
<li>缺点：读操作不改变状态机的状态，但还要写日志，开销大</li>
</ul>
<p><img src="/2022/06/10/Raft/18.png"></p>
<h4 id="Read-Index"><a href="#Read-Index" class="headerlink" title="Read Index"></a>Read Index</h4><p>读操作不经过复制状态机，通过索引判断当前最新日志项写入位置。为了防止从旧Leader获取信息，因此需要一轮心跳来确认当前的Leader。</p>
<p>当Leader接收到读请求的时候，需要通过一轮心跳来确保当前自己仍然是Leader，并记录当前的Commit index为Read index，然后等到apply &gt;= read index 再提供读服务</p>
<p>如果客户端是从Follower处读取x的值，那么Follower会去Leader问询，Leader会执行上述操作并返回值。相比直接询问Leader多了一次访问开销</p>
<p>优点： 省掉了同步日志的开销，能够大幅提升读的吞吐量，并且在一定程度上降低了读的时延</p>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>CDE一开始出现了网络分区，因此独立出来，选择了C作为Leader。然后，有一个客户端在新Leader这边发起了 <code>W(x=1)</code>的请求，由于得到大多数节点支持，该操作可以顺利通过。</p>
<p>此时，如果有客户端向老的Leader A发送读取请求——如果有了Read Index机制，Leader A会发送一轮消息，来确认自己是否仍然是Leader，现实是他并不是，因此客户端无法从A节点读取x的值。</p>
<p><img src="/2022/06/10/Raft/19.png"></p>
<h5 id="Lease-Read"><a href="#Lease-Read" class="headerlink" title="Lease Read"></a>Lease Read</h5><p>前提：已经确定了当前的Leader就是全局唯一的Leader,  要实现这个方法可以规定一段时间内，保证各节点不会发生选举</p>
<p>那么，当Leader接收到读请求的时候，由于可以保证Leader是唯一Leader， <code>apply &gt;= read index</code> ，可以直接提供读服务。</p>
<ul>
<li>优点： 与Read Index相比，Lease Read 进一步省去了网络交互开销，因此更能显著降低读的时延</li>
<li>缺点：由于使用的是每个服务器各自的时钟，存在着时钟飘逸现象(比如，A节点1秒等于B节点2秒)，那么如果误差过大可能线性化的保证就丢失了</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/06/06/go%E5%AD%A6%E4%B9%A01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/06/go%E5%AD%A6%E4%B9%A01/" class="post-title-link" itemprop="url">go学习1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-06 13:42:19" itemprop="dateCreated datePublished" datetime="2022-06-06T13:42:19+08:00">2022-06-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-07-08 14:01:49" itemprop="dateModified" datetime="2023-07-08T14:01:49+08:00">2023-07-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="go学习-part1"><a href="#go学习-part1" class="headerlink" title="go学习-part1"></a>go学习-part1</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在这学期的区块链以及数据库的课程中，需要我们使用go语言来编写Fabric中的链码、共识算法等程序。那么go语言为什么这么有用呢？</p>
<ul>
<li><p><strong>go语言执行速度更快</strong>。因为go可以直接将代码编译成machine code，不像python这类解释性语言，需要一个python解释器。在执行速度方面，Golang总是比Java领先一步。基于Golang的程序速度超快，编译也很迅速， 开发人员喜欢使用Golang来满足更快的后端开发的要求。</p>
</li>
<li><p><strong>go有着活跃的开发者社区</strong>。目前，有超过100万的开发者精通Golang的工作。这个数字预计在未来会有更大的增长。拥有一个强大而活跃的开发者社区，可以确保在开发过程中遇到的任何问题都能得到支持。</p>
</li>
<li><p><strong>go有着全面的开发工具</strong>。 诚然，它没有类似于Java的庞大的第三方工具，然而，Go配备了一套全面的工具，使开发人员的编码变得简单。Go提供的IDE，如Visual Studio Code、Goland等</p>
<p>此外，<em>go语言可以通过内嵌c代码的形式调用c语言</em>,也可以通过调用共享库函数的方式实现; 至于c语言调用go函数,则可以通过go build将go代码编译成共享库提供给c代码使用</p>
</li>
<li><p><strong>可扩展性强</strong>。在为一个项目选择编程语言时，可扩展性往往是一个重要的因素。没有人希望在以后需要为应用程序引入新功能时被卡住。Golang提供了更大的可扩展性空间。它提供了在同一时间执行多种功能的可能性。当你选择Golang时，你可以在未来更长时间内使用它。</p>
</li>
</ul>
<p>与此同时，go语言也存在着一些缺点：</p>
<ul>
<li><strong>编程更消耗时间</strong>。Golang并不像Python一样具有解释性，而是一种编译型语言，所以实现同一个功能所需要的代码量要比python更多</li>
<li><strong>golang不支持泛型</strong>。如果不支持泛型，代码的重复性可能会很高，因为需要重写多个函数来处理不同类型的参数。这就像Golang所基于的C语言一样，缺乏对通用函数的支持会严重限制代码的可重用性，降低开发过程中的效率。 </li>
</ul>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>在进行Go语言开发的时候，我们的代码总是会保存在<code>$GOPATH/src</code>目录下。在工程经过<code>go build</code>、<code>go install</code>或<code>go get</code>等指令后，会将下载的第三方包源代码文件放在  目录下，产生的二进制可执行文件放在 <code>$GOPATH/bin</code>目录下，生成的中间缓存文件会被保存在 <code>$GOPATH/pkg</code> 下。</p>
<p><img src="/2022/06/06/go%E5%AD%A6%E4%B9%A01/1.jpeg"></p>
<h3 id="如何编译"><a href="#如何编译" class="headerlink" title="如何编译"></a>如何编译</h3><h4 id="go-build"><a href="#go-build" class="headerlink" title="go build"></a>go build</h4><p><code>go build</code>这个指令用来编译指定 packages 里的源码文件以及它们的依赖包，编译的时候会到 <code>$goPath/src/package</code>路径下寻找源码文件。go build 还可以直接编译指定的源码文件，并且可以同时指定多个。</p>
<p><code>usage: go build [-o output] [-i] [build flags] [packages]</code></p>
<blockquote>
<p><code>-o</code> 只能在编译单个包的时候出现，它指定输出的可执行文件的名字。</p>
<p><code>-i</code> 会安装编译目标所依赖的包，安装是指生成与代码包相对应的 <code>.a</code> 文件，即静态库文件（后面要参与链接），并且放置到当前工作区的 pkg 目录下，且库文件的目录层级和源码层级一致。</p>
<p> build flags 参数，<code>build, clean, get, install, list, run, test</code> 这些命令会共用一套：</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>强制重新编译所有涉及到的包，包括标准库中的代码包，这会重写 /usr/local/go 目录下的 <code>.a</code> 文件</td>
</tr>
<tr>
<td>-n</td>
<td>打印命令执行过程，不真正执行</td>
</tr>
<tr>
<td>-p n</td>
<td>指定编译过程中命令执行的并行数，n 默认为 CPU 核数</td>
</tr>
<tr>
<td>-race</td>
<td>检测并报告程序中的数据竞争问题</td>
</tr>
<tr>
<td>-v</td>
<td>打印命令执行过程中所涉及到的代码包名称</td>
</tr>
<tr>
<td>-x</td>
<td>打印命令执行过程中所涉及到的命令，并执行</td>
</tr>
<tr>
<td>-work</td>
<td>打印编译过程中的临时文件夹。通常情况下，编译完成后会被删除</td>
</tr>
</tbody>
</table>
</div>
<p>我们拿区块链上的一个项目来展示如何编译。首先，这个项目结构如下图所示：</p>
<ul>
<li>主目录下有naive.go, 其实就是main包，里面有个func main函数.这是go程序的入口</li>
<li>zkv模块，是一个简单的键值对数据库</li>
<li>zlog模块，用于日志记录、打印</li>
<li>zpbft模块，实现算法</li>
</ul>
<p><img src="/2022/06/06/go%E5%AD%A6%E4%B9%A01/2.png"></p>
<p>我们可以用 <code>go build naive.go</code> 即可编译naive.go文件，得到mac下的可执行文件 naive</p>
<p>也可以用<code>go build -o main2 main.go</code> 讲编译得到的文件命名为main2</p>
<p>当然，我们可以用更复杂的编译指令： <code>go build -v -x -work -o bin/hello main.go</code> (naive被改名了)。<code>-v</code> 会打印所编译过的包名字，<code>-x</code> 打印编译期间所执行的命令，<code>-work</code> 打印编译期间生成的临时文件路径，并且编译完成之后不会被删除。</p>
<p>执行结果如下，我们看到，一开始编译了一系列package文件，在编译这些文件的时候调用了go语言的静态库(.a文件)。在EOF指令出现后，说明已经编译完成，然后会将编译好的静态文件相连接，最终生成可执行文件，并将其移动到bin目录下，改名为hello</p>
<p><img src="/2022/06/06/go%E5%AD%A6%E4%B9%A01/3.png"> </p>
<h4 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a>go install</h4><p><code>go install</code> 用于编译并安装指定的代码包及它们的依赖包。相比 <code>go build</code>，它只是多了一个“安装编译后的结果文件到指定目录”的步骤。</p>
<p>使用这条指令，会在GOPATH目录下的pkg文件夹中生成.a文件，在bin文件夹生成可执行文件</p>
<h4 id="go-run"><a href="#go-run" class="headerlink" title="go run"></a>go run</h4><p><code>go run</code> 用于编译并运行命令源码文件。如 <code>go run -x -work main.go</code></p>
<h4 id="gofmt"><a href="#gofmt" class="headerlink" title="gofmt"></a>gofmt</h4><p><code>gofmt</code>  可以帮我们吧源代码文件排列的更好。比如说当我们打印一些多余的空格的时候，会将空格去掉。在一些IDE中(如VsCode和Goland), 每次保存文件都会自动执行 gofmt</p>
<h2 id="Go-Basics"><a href="#Go-Basics" class="headerlink" title="Go Basics"></a>Go Basics</h2><h3 id="Variables-in-Go"><a href="#Variables-in-Go" class="headerlink" title="Variables in Go"></a>Variables in Go</h3><p>在Go语言中，一旦一个变量被声明，它就必须被调用，否则会出现错误。但有时你并不需要使用从一个函数得到的所有返回值。因此，我们可以使用<code>_</code> 空白表示符</p>
<p><code>_</code> 被用于抛弃值，你不能得到它的值，如值 5 在：_, b = 5, 7 中被抛弃。</p>
<ol>
<li><p>```go<br>//声明变量<br>var x int = 7<br>var s string<br>s1 = “Learning Go!” </p>
<p>//打印使用Println,不同元素之间用 , 隔开<br>var age int = 30<br>fmt.Println(“age: “, age)</p>
<p>var name = “Dan”<br>fmt.Println(“Your name is: “, name) </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 我们也可以用更简单的方式声明： &#96;age :&#x3D; 30&#96; ,可以不用显式定义变量类型</span><br><span class="line"></span><br><span class="line">### Multiple Declarations</span><br><span class="line"></span><br><span class="line">我们可以用一行代码来定义多个变量</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;go</span><br><span class="line">car,cost :&#x3D; &quot;Audi&quot;,50000</span><br><span class="line">fmt.Println(car, cost)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>但是函数体内不允许使用 <strong>:=</strong> 重复声明同名变量。 因为 := 通常是用来声明新的变量的，如果我们要重复定义，可以使用 <code>=</code></p>
<p><img src="/2022/06/06/go%E5%AD%A6%E4%B9%A01/4.png"></p>
<p>或者，我们可以在左侧出现至少1个新的变量，也可以规避这个错误</p>
<p><img src="/2022/06/06/go%E5%AD%A6%E4%B9%A01/5.png"></p>
<h4 id="var"><a href="#var" class="headerlink" title="var"></a>var</h4><p>此外，我们可以用 var 来进行多变量声明，可读性会更强：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用var声明，默认会将变量置为0值</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">		salary <span class="keyword">float64</span></span><br><span class="line">		firstName <span class="keyword">string</span></span><br><span class="line">		gender <span class="keyword">bool</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fmt.Println(salary,firstName,gender)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i,j <span class="keyword">int</span></span><br><span class="line">i,j = <span class="number">5</span>,<span class="number">8</span></span><br><span class="line">j,i = i,j<span class="comment">//交换i，j位置 </span></span><br><span class="line">fmt.Println(i,j)<span class="comment">//  8,5</span></span><br></pre></td></tr></table></figure>
<h3 id="Types-and-Zero-Values"><a href="#Types-and-Zero-Values" class="headerlink" title="Types and Zero Values"></a>Types and Zero Values</h3><p>由于Go还是算静态语言的一种，因此每一个变量都需要有一个类型。我们之所以可以用<code>:=</code>定义变量是因为go帮我们做了隐式变量推导。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">   <span class="keyword">var</span> b = <span class="number">4.2</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们将b赋值给a，go会马上报错，因为这种隐式变量转换在go语言中是不被允许的</p>
<p><img src="/2022/06/06/go%E5%AD%A6%E4%B9%A01/6.png"></p>
<p>同样的，int和string之间也无法进行隐式类型转换</p>
<h4 id="go中如何表达0-空"><a href="#go中如何表达0-空" class="headerlink" title="go中如何表达0/空"></a>go中如何表达0/空</h4><ul>
<li>在数字类型中： 0</li>
<li>在布尔类型中： false</li>
<li>在字符串类型中： “”</li>
<li>在指针类型中： nil</li>
</ul>
<h3 id="Naming-Conventions-in-Go"><a href="#Naming-Conventions-in-Go" class="headerlink" title="Naming Conventions in Go"></a>Naming Conventions in Go</h3><p>现在我们来介绍一下Go语言的命名规则：</p>
<ul>
<li>变量必须以字母或者下划线<code>_</code>开头</li>
<li>大小写敏感</li>
<li>Go的25个关键词不能被作为变量名</li>
<li>命名尽量简短、但保持可读性、变量可以使用驼峰命名法</li>
</ul>
<h3 id="Package-fmt"><a href="#Package-fmt" class="headerlink" title="Package fmt"></a>Package fmt</h3><p>fmt是Go标准库中很重要的一个包。它可以帮助我们格式化并打印内容</p>
<p><code>Println</code> 函数可以帮我们打印一行内容，可以是不同类型的变量的组合，中间用<code>,</code>分隔.</p>
<p><code>Printf</code> 函数是用来格式化输出内容的, 但是每次打印结束不会换行。比如：</p>
<h4 id="通用verbs"><a href="#通用verbs" class="headerlink" title="通用verbs"></a>通用verbs</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">%v       　值的默认格式</span><br><span class="line">%+v      　类似%v,但输出结构体时会添加字段名</span><br><span class="line">%#v 　　 Go语法表示值</span><br><span class="line">%T  　　 Go语法表示类型</span><br><span class="line">%%     　 百分号表示</span><br><span class="line"></span><br><span class="line"><span class="comment">//如下示例：</span></span><br><span class="line"><span class="keyword">type</span> Sample <span class="keyword">struct</span> &#123;</span><br><span class="line">    Title   <span class="keyword">string</span></span><br><span class="line">    name    <span class="keyword">string</span></span><br><span class="line">    Age     <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    s := Sample&#123;<span class="string">"测试"</span>, <span class="string">"wentao"</span>, <span class="number">26</span>&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, s)    		<span class="comment">// &#123;测试 wentao 26&#125;</span></span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, s)  		<span class="comment">// &#123;Title:测试 name:wentao Age:26&#125;</span></span><br><span class="line">    fmt.Printf(<span class="string">"%#v\n"</span>, s)  		<span class="comment">// main.Sample&#123;Title:"测试", name:"wentao", Age:26&#125;</span></span><br><span class="line">    fmt.Printf(<span class="string">"%T\n"</span>, s)       <span class="comment">//  main.Sample</span></span><br><span class="line">    fmt.Printf(<span class="string">"%v%%\n"</span>, s.Age) <span class="comment">//  26%</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%t  <span class="literal">true</span>或<span class="literal">false</span> </span><br><span class="line"><span class="comment">//如下示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%t\n"</span>, <span class="literal">true</span>)  <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">%b  表示二进制</span><br><span class="line">%c  该值对应的unicode吗值</span><br><span class="line">%d  表示十进制</span><br><span class="line">%o  表示八进制</span><br><span class="line">%q  该值对应的单引号括起来的<span class="keyword">go</span>语法字符字面值，必要时会采用安全的转义表示</span><br><span class="line">%x  表示为十六进制，使用a-f</span><br><span class="line">%X  表示为十六进制，使用A-F</span><br><span class="line">%U  表示为Unicode格式：U+<span class="number">1234</span>，等价于<span class="string">"U+%04X"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如下示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%b\n"</span>, <span class="number">26</span>)          <span class="comment">//11010</span></span><br><span class="line">    fmt.Printf(<span class="string">"%c\n"</span>, <span class="number">0x4E2D</span>)      <span class="comment">//中</span></span><br><span class="line">    fmt.Printf(<span class="string">"%d\n"</span>, <span class="number">0x12</span>)        <span class="comment">//18</span></span><br><span class="line">    fmt.Printf(<span class="string">"%o\n"</span>, <span class="number">20</span>)          <span class="comment">//24</span></span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, <span class="number">0x4E2D</span>)      <span class="comment">//'中'</span></span><br><span class="line">    fmt.Printf(<span class="string">"%x\n"</span>, <span class="number">14</span>)          <span class="comment">//e</span></span><br><span class="line">    fmt.Printf(<span class="string">"%X\n"</span>, <span class="number">14</span>)          <span class="comment">//E</span></span><br><span class="line">    fmt.Printf(<span class="string">"%U\n"</span>, <span class="number">0x4E2D</span>)     <span class="comment">//U+4E2D</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="浮点数与复数"><a href="#浮点数与复数" class="headerlink" title="浮点数与复数"></a>浮点数与复数</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">%b  无小数部分、二进制指数的科学计数法，如<span class="number">-123456</span>p<span class="number">-78</span>；参见strconv.FormatFloat</span><br><span class="line">%e  科学计数法，例如 <span class="number">-1234.456e+78</span> </span><br><span class="line">%E  科学计数法，例如 <span class="number">-1234.456E+78</span></span><br><span class="line">%f  有小数点而无指数，例如 <span class="number">123.456</span> </span><br><span class="line">%F  等价于%f</span><br><span class="line">%g  根据实际情况采用%e或%f格式（以获得更简洁、准确的输出）</span><br><span class="line">%G  根据实际情况采用%E或%F格式（以获得更简洁、准确的输出）</span><br><span class="line"><span class="comment">//如下示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%b\n"</span>, <span class="number">10.45</span>)   <span class="comment">//5882827013252710p-49</span></span><br><span class="line">    fmt.Printf(<span class="string">"%e\n"</span>, <span class="number">10.45</span>)   <span class="comment">//1.045000E+01</span></span><br><span class="line">    fmt.Printf(<span class="string">"%E\n"</span>, <span class="number">10.45</span>)   <span class="comment">//1.045000E+01</span></span><br><span class="line">    fmt.Printf(<span class="string">"%f\n"</span>, <span class="number">10.45</span>)   <span class="comment">//10.450000</span></span><br><span class="line">    fmt.Printf(<span class="string">"%F\n"</span>, <span class="number">10.45</span>)   <span class="comment">//10.450000</span></span><br><span class="line">    fmt.Printf(<span class="string">"%g\n"</span>, <span class="number">10.45</span>)   <span class="comment">//10.45</span></span><br><span class="line">    fmt.Printf(<span class="string">"%G\n"</span>, <span class="number">10.45</span>)   <span class="comment">//10.45</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="string与-byte"><a href="#string与-byte" class="headerlink" title="string与[]byte"></a>string与[]byte</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">%s  输出字符串表示（<span class="keyword">string</span>类型或[]<span class="keyword">byte</span>) </span><br><span class="line">%q  双引号围绕的字符串，由Go语法安全地转义</span><br><span class="line">%x  十六进制，小写字母，每字节两个字符 （使用a-f）</span><br><span class="line">%X  十六进制，大写字母，每字节两个字符 （使用A-F） </span><br><span class="line"></span><br><span class="line"><span class="comment">//如下示例：</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, []<span class="keyword">byte</span>(<span class="string">"go开发"</span>))      <span class="comment">//go开发</span></span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, <span class="string">"go开发"</span>)          <span class="comment">//go开发</span></span><br><span class="line">    fmt.Printf(<span class="string">"%q\n"</span>, <span class="string">"go开发"</span>)          <span class="comment">//"go开发"</span></span><br><span class="line">    fmt.Printf(<span class="string">"%x\n"</span>, <span class="string">"go开发"</span>)          <span class="comment">//676fe5bc80e58f91</span></span><br><span class="line">    fmt.Printf(<span class="string">"%X\n"</span>, <span class="string">"go开发"</span>)          <span class="comment">//676FE5BC80E58F91</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">%p       切片第一个元素的指针</span><br><span class="line"><span class="comment">//如下示例</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%p\n"</span>, []<span class="keyword">byte</span>(<span class="string">"go开发"</span>))          <span class="comment">//0xc42001a0d8</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p\n"</span>, []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">65</span>&#125;)  <span class="comment">//0xc420020180</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="point"><a href="#point" class="headerlink" title="point"></a>point</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%p       十六进制内存地址,前缀ox</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    str := <span class="string">"go开发"</span></span><br><span class="line">    fmt.Printf(<span class="string">"%p\n"</span>, &amp;str)            <span class="comment">//0xc42000e1e0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Constants-in-Go"><a href="#Constants-in-Go" class="headerlink" title="Constants in Go"></a>Constants in Go</h3><p>Go 语言中声明常量使用的关键字是<code>const</code>。常量的使用非常广泛，比如说圆周率，再比如说一些明确的错误信息等一些容易被<strong>多次使用的值</strong>，一般都会使用常量进行实例化，使其在需要更改时，更容易维护，同时增加代码可读性。</p>
<p>常量在声明的时候就必须初始化，但是和变量不一样，常量声明了以后，不使用也不会报错。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">//常量定义</span></span><br><span class="line">   <span class="keyword">const</span> secondsInHour = <span class="number">3600</span></span><br><span class="line"></span><br><span class="line">   duration := <span class="number">234</span></span><br><span class="line">   fmt.Printf(<span class="string">"Duration in seconds: %v\n"</span>, duration*secondsInHour)</span><br><span class="line">   <span class="comment">//多常量定义</span></span><br><span class="line">   <span class="keyword">const</span> n, m <span class="keyword">int</span> = <span class="number">4</span>, <span class="number">5</span></span><br><span class="line">   <span class="keyword">const</span> n1, m1 = <span class="number">6</span>, <span class="number">7</span></span><br><span class="line">	<span class="comment">//在使用这种方式进行多常量定义的时候，如果后面的常量未初始化，会自动沿用第一个常量的值</span></span><br><span class="line">   <span class="keyword">const</span> (</span><br><span class="line">      min1 = <span class="number">-400</span></span><br><span class="line">      min2</span><br><span class="line">      min3</span><br><span class="line">   )</span><br><span class="line">   fmt.Println(min1, min2, min3) <span class="comment">//-400 -400 -400</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="常量声明规则"><a href="#常量声明规则" class="headerlink" title="常量声明规则"></a>常量声明规则</h4><ul>
<li>声明之后无法修改</li>
<li><p>给常量赋值的时候不能涉及运行时计算,如：<code>const power = math.Pow(2,3)</code></p>
</li>
<li><p>我们不能给一个常量付一个变量的值</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t := <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> tc = t <span class="comment">//会报错</span></span><br></pre></td></tr></table></figure>
<ul>
<li>特殊情况，当我们使用内建函数(如len)时，可以使用其返回结果给常量赋值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const l1 &#x3D; len(&quot;hello&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="Constant-Expressions-Typed-vs-Untyped-Constants"><a href="#Constant-Expressions-Typed-vs-Untyped-Constants" class="headerlink" title="Constant Expressions Typed vs Untyped Constants"></a>Constant Expressions Typed vs Untyped Constants</h3><p>当我们在申明常量的时候，如果指明了常量类型，那么就无法做隐式类型转换了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x <span class="keyword">int</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> y <span class="keyword">float64</span> = <span class="number">2.2</span> * x  <span class="comment">//会报错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是，如果我们不确定常量数值类型，就不会报错。 此时go给了x一定的freedom，能让它做隐式类型转换</span></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> y <span class="keyword">float64</span> = <span class="number">2.2</span> * x <span class="comment">//不会报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x  = <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> y  = <span class="number">2.2</span> * x <span class="comment">//不会报错</span></span><br></pre></td></tr></table></figure>
<h3 id="IOTA"><a href="#IOTA" class="headerlink" title="IOTA"></a>IOTA</h3><p><code>iota</code>是golang的常量计数器，只能在常量的表达式中使用。</p>
<p> 使用<code>iota</code>时只需要记住以下两点</p>
<p>1.<code>iota</code>在<code>const</code>关键字出现时将被重置为0。</p>
<p>2.<code>const</code>中每新增一行常量声明将使<code>iota</code>计数一次(iota可理解为<code>const</code>语句块中的行索引)。</p>
<p>可以用这个关键词来实现枚举结构</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">		n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">		n2        <span class="comment">//1 	顺延第一行的表达式</span></span><br><span class="line">		n3        <span class="comment">//2</span></span><br><span class="line">		n4        <span class="comment">//3</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">		n1 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">		n2        <span class="comment">//1</span></span><br><span class="line">		_		  		<span class="comment">//丢弃该值，常用在错误处理中</span></span><br><span class="line">		n4        <span class="comment">//3</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">		n1 = <span class="literal">iota</span> <span class="comment">//0					</span></span><br><span class="line">		n2 = <span class="number">100</span>  <span class="comment">//100 		即使没有出现iota，iota 也会自增1</span></span><br><span class="line">		n3 = <span class="literal">iota</span> <span class="comment">//2</span></span><br><span class="line">		n4        <span class="comment">//3</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> n5 = <span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">		_  = <span class="literal">iota</span>							<span class="comment">// iota = 0</span></span><br><span class="line">		KB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>) <span class="comment">// iota = 1, &lt;&lt;移位操作，速度比乘除法快 ,因此KB = 2^10</span></span><br><span class="line">		MB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>) <span class="comment">// 以此类推</span></span><br><span class="line">		GB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">		TB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">		PB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">	)</span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">		a, b = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span> <span class="comment">//1,2</span></span><br><span class="line">		c, d                      <span class="comment">//2,3 常量如果没有初始化，会顺延第一行的表达式</span></span><br><span class="line">		e, f                      <span class="comment">//3,4</span></span><br><span class="line">	)</span><br></pre></td></tr></table></figure>
<p>注意：常量只能声明布尔值、整数值、rune constant(即int32)、complex constant(复数)、浮点数值、字符串值。</p>
<p><strong>不能声明数组常量、结构常量，它们用var声明</strong></p>
<h3 id="Go-Data-Types"><a href="#Go-Data-Types" class="headerlink" title="Go Data Types"></a>Go Data Types</h3><h4 id="Numeric-types"><a href="#Numeric-types" class="headerlink" title="Numeric types"></a>Numeric types</h4><ul>
<li><p>int8, int16, int32, int64 ：注意，go有溢出检测，如果 声明<code>var i1 int8 = -129</code> 会直接报错。</p>
</li>
<li><p>uint8, uint16, uint32, uint64: 无符号整数</p>
</li>
<li><p>uint is an alias for uint32 or uint64 based on platform.  直接使用uint/int的话，会随着平台的不同而变化</p>
</li>
<li>int is an alias for int32 or int64 based on platform. </li>
<li>float32, float64: 如果小数点之前为0，则0可省略 ( -.5 -3. -0. 1.4).</li>
<li>complex64, complex128. </li>
<li>byte (alias for uint8). </li>
<li>rune (alias for int32). </li>
</ul>
<h4 id="Bool-type"><a href="#Bool-type" class="headerlink" title="Bool type"></a>Bool type</h4><ul>
<li>布尔值，只有 true / false 两个值</li>
</ul>
<h4 id="String-type"><a href="#String-type" class="headerlink" title="String type"></a>String type</h4><p>字符串类型，用双引号</p>
<p>现在来介绍go中的复合变量</p>
<h4 id="Array-and-Slice-Type"><a href="#Array-and-Slice-Type" class="headerlink" title="Array and Slice Type"></a>Array and Slice Type</h4><ul>
<li><p>数组<br>数组是一个长度固定的数据类型，用于存储一段具有相同类型的元素的连续块。数组存储的类型可以是内置类型，如整型或者字符串，也可以是某种结构类型。</p>
</li>
<li><p>切片<br>切片是围绕动态数组的概念构建的，可以按需自动增长和缩小<br>切片是一个很小的对象，对底层数组进行了抽象，并提供了相关的操作方法。切片有3个字段分别是<code>指向底层数组的指针</code>，<code>切片访问的元素个数（即长度）</code>和<code>切片允许增长到的元素个数（即容量）</code></p>
</li>
</ul>
<p>切片的长度和容量在概念上有以下区别：</p>
<ul>
<li>长度（Length）：切片的长度表示切片中实际包含的元素个数。长度可以通过内置函数 <code>len()</code> 来获取。在上述示例中，切片 <code>slice</code> 的长度为 3，表示切片中有 3 个元素。</li>
<li>容量（Capacity）：切片的容量表示切片从第一个元素开始算起，到底层数组末尾的元素个数。容量可以通过内置函数 <code>cap()</code> 来获取。在<code>slice := make([]int, 3, 5)</code>这个例子中，切片 <code>slice</code> 的容量为 5，表示切片底层的数组中还有 5 - 3 = 2 个空闲的位置。</li>
</ul>
<p>数组</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个包含5个元素的整型数组，并设置为零值</span></span><br><span class="line"><span class="keyword">var</span> array [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line"><span class="comment">//使用数组字面量声明数组</span></span><br><span class="line">array := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line"><span class="comment">//隐式声明数组长度</span></span><br><span class="line">array := [...]<span class="keyword">int</span>&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line"><span class="comment">//声明数组并指定特定元素</span></span><br><span class="line">array := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>:<span class="number">10</span>,<span class="number">2</span>:<span class="number">30</span>&#125; <span class="comment">// =&gt; [10 0 30 0 0]</span></span><br></pre></td></tr></table></figure>
<p>切片</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用make(声明是不会分配内存的，初始化需要 make ，分配内存后才能赋值和使用。)</span></span><br><span class="line"><span class="comment">//长度和容量都是5个元素</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">//长度为3，容量为5个元素</span></span><br><span class="line"><span class="comment">//3是这是切片的长度，表示切片中实际包含的元素个数</span></span><br><span class="line"><span class="comment">//5是切片的容量，表示底层数组从切片的第一个元素开始，到底层数组末尾的元素个数。</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用字面量声明</span></span><br><span class="line"><span class="comment">//长度和容量都是4个元素</span></span><br><span class="line">slice := []<span class="keyword">string</span>&#123;<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"green"</span>,<span class="string">"yellow"</span>&#125;</span><br><span class="line"><span class="comment">//这行代码创建了一个字符串切片 slice，其中包含了 100 个元素</span></span><br><span class="line"><span class="comment">//其中前 99 个元素的值为空字符串，而最后一个元素的值为 "!!"。</span></span><br><span class="line"><span class="comment">//在大括号内，我们使用键值对的方式来初始化切片的元素。键表示切片中的索引，值表示对应索引处的元素值</span></span><br><span class="line"><span class="comment">//这里的 99 是键，表示切片中的索引位置，而 "!!" 是值，表示该索引位置的元素的值。</span></span><br><span class="line">slice := []<span class="keyword">string</span>&#123;<span class="number">99</span>:<span class="string">"!!"</span>&#125;</span><br></pre></td></tr></table></figure>
<p> 在之后会详细介绍 </p>
<h4 id="Map-Type"><a href="#Map-Type" class="headerlink" title="Map Type"></a>Map Type</h4><ul>
<li>在 Go 语言中，Map（映射）是一种集合类型，用于存储键值对（key-value）数据。Map 是无序的，每个键在 Map 中必须是唯一的。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 初始化一个map，键是string类型，值是map类型(又是一个string-string键值对)</span></span><br><span class="line">   studentMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">  <span class="comment">// 先初始化 map 大小</span></span><br><span class="line">   studentMap[<span class="string">"stu01"</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line">   studentMap[<span class="string">"stu01"</span>][<span class="string">"name"</span>] = <span class="string">"tom"</span></span><br><span class="line">   studentMap[<span class="string">"stu01"</span>][<span class="string">"sex"</span>] = <span class="string">"男"</span></span><br><span class="line">   studentMap[<span class="string">"stu01"</span>][<span class="string">"address"</span>] = <span class="string">"北京长安街"</span></span><br><span class="line">  </span><br><span class="line">   studentMap[<span class="string">"stu02"</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>) <span class="comment">// 这句话不能少</span></span><br><span class="line">   studentMap[<span class="string">"stu02"</span>][<span class="string">"name"</span>] = <span class="string">"mary"</span></span><br><span class="line">   studentMap[<span class="string">"stu02"</span>][<span class="string">"sex"</span>] = <span class="string">"女"</span></span><br><span class="line">   studentMap[<span class="string">"stu02"</span>][<span class="string">"address"</span>] = <span class="string">"上海黄浦江"</span></span><br><span class="line">   fmt.Println(studentMap)</span><br><span class="line">  <span class="comment">//map[stu01:map[address:北京长安街 name:tom sex:男] stu02:map[address:上海黄浦江 name:mary sex:女]]</span></span><br><span class="line"></span><br><span class="line">   fmt.Println(studentMap[<span class="string">"stu02"</span>])</span><br><span class="line">  <span class="comment">//map[address:上海黄浦江 name:mary sex:女]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Struct-Type-User-defined-type"><a href="#Struct-Type-User-defined-type" class="headerlink" title="Struct Type (User defined type)"></a>Struct Type (User defined type)</h4><p>struct和C++中的类似，可以将其适用于结构类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">   brand <span class="keyword">string</span></span><br><span class="line">   price <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Pointer-Type"><a href="#Pointer-Type" class="headerlink" title="Pointer Type"></a>Pointer Type</h4><p>指针存储了一个变量的地址、如果未初始化，默认为 nil</p>
<h4 id="Function-and-Interface-Type"><a href="#Function-and-Interface-Type" class="headerlink" title="Function and Interface Type"></a>Function and Interface Type</h4><p>函数类型、接口类型</p>
<h4 id="Channel-Type"><a href="#Channel-Type" class="headerlink" title="Channel Type"></a>Channel Type</h4><p>通道类型 为 通信而设计。</p>
<p>谁会用到它呢？<a href="https://so.csdn.net/so/search?q=协程&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">协程</a>，就是Go协程（goroutine），使用 go语句并发执行的函数或方法（concurrently executing functions）。</p>
<p>通信 包括 发送、接收指定的元素类型的 值。</p>
<p>没有被初始化的 通道 的值为 nil</p>
<h3 id="Operations-On-Types-Arithmetic-and-Assignment-Operators"><a href="#Operations-On-Types-Arithmetic-and-Assignment-Operators" class="headerlink" title="Operations On Types: Arithmetic and Assignment Operators"></a>Operations On Types: Arithmetic and Assignment Operators</h3><p>和C++一样，不赘述</p>
<h3 id="Comparison-and-Logical-Operators"><a href="#Comparison-and-Logical-Operators" class="headerlink" title="Comparison and Logical Operators"></a>Comparison and Logical Operators</h3><p>和C++一样，不赘述</p>
<h3 id="Overflows"><a href="#Overflows" class="headerlink" title="Overflows"></a>Overflows</h3><p>在go中也有向上溢出和向下溢出的概念。在 Go 中，整数溢出的行为与编译时和运行时的上下文有关。</p>
<p>在编译时，对于常量表达式，编译器会进行常量折叠和溢出检查。如果一个常量表达式的结果溢出了其类型的取值范围，编译器会在编译时就发出溢出错误。</p>
<p>比如，在声明的时候，如果检测到overflow，会直接报错：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	a := <span class="keyword">int8</span>(<span class="number">255</span>+<span class="number">1</span>)<span class="comment">//会报错overflow</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在运行时，对于变量的计算，Go 语言允许进行溢出操作。当对 <code>var b int8 = 127</code> 进行 <code>b+1</code> 的计算时，编译器不会报告溢出错误，因为这是在运行时动态计算的，而非在编译时。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> x	<span class="keyword">uint8</span> = <span class="number">255</span></span><br><span class="line">	x++ <span class="comment">// overflow, x is 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，向下溢出操作如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b <span class="keyword">int8</span> = <span class="number">-128</span></span><br><span class="line">b--</span><br><span class="line">fmt.Printf(<span class="string">"%d\n"</span>,b+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>有意思的是，浮点数也会溢出，向上溢出到正无穷 ，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f := <span class="keyword">float32</span>(math.MaxFloat32)</span><br><span class="line">f = f*<span class="number">1.2</span></span><br><span class="line">fmt.Println(f) <span class="comment">// =&gt;  +Inf</span></span><br></pre></td></tr></table></figure>
<p>如果需要计算很大的，可能溢出的数，可以使用 <code>math/big</code> 包, 它可以进行高精度计算，处理大数和分数等复杂数学运算。它对于需要处理精确度要求较高的场景非常有用，如密码学、金融计算、科学计算等。</p>
<h3 id="Converting-Numeric-Types"><a href="#Converting-Numeric-Types" class="headerlink" title="Converting Numeric Types"></a>Converting Numeric Types</h3><p>在 Go 中，变量转换通常需要显式进行类型转换，以确保类型安全性。Go 语言不支持隐式变量转换，这是为了避免潜在的类型错误。</p>
<p>比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> x = <span class="number">3</span> <span class="comment">// int type</span></span><br><span class="line">	<span class="keyword">var</span> y = <span class="number">3.1</span> <span class="comment">// float type</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// x = x*y //会报错</span></span><br><span class="line">	<span class="comment">//如果要相乘，必须：</span></span><br><span class="line">	newx := x*<span class="keyword">int</span>(y)    <span class="comment">//=&gt; 9</span></span><br><span class="line">	newy := float(x)*y	<span class="comment">//=&gt; 9.3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是：在 Go 中，<code>int</code> 和 <code>int64</code> 是不同的类型。它们表示不同的整数类型，具有不同的大小和范围。</p>
<ul>
<li><code>int</code> 类型是一个有符号整数类型，其大小和范围在不同的操作系统和架构上可能会有所不同。在大多数情况下，<code>int</code> 的大小为 32 位或 64 位。</li>
<li><code>int64</code> 类型是一个明确表示 64 位有符号整数的类型</li>
</ul>
<p>由于 <code>int</code> 和 <code>int64</code> 是不同的类型，因此不能直接进行类型转换。你需要使用显式类型转换来将一个类型转换为另一个类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> y <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 x 的值转换为 int64 类型，并赋值给 y</span></span><br><span class="line">    y = <span class="keyword">int64</span>(x)</span><br><span class="line"></span><br><span class="line">    fmt.Println(x, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Converting-Numbers-to-Strings-and-Strings-to-Numbers"><a href="#Converting-Numbers-to-Strings-and-Strings-to-Numbers" class="headerlink" title="Converting Numbers to Strings and Strings to Numbers"></a>Converting Numbers to Strings and Strings to Numbers</h3><p>在 Go 中，可以使用 <code>fmt.Sprintf</code> 函数将不同类型的值转换为字符串类型。该函数允许使用格式化字符串来构建一个字符串，其中可以包含不同类型的值。比如int类型和float类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 将整数转换为字符串</span></span><br><span class="line">    num := <span class="number">42</span></span><br><span class="line">    str := fmt.Sprintf(<span class="string">"%d"</span>, num)</span><br><span class="line">    fmt.Println(str) <span class="comment">// 输出: "42"</span></span><br><span class="line">		<span class="comment">// 将浮点数转换为字符串</span></span><br><span class="line">  myStr := fmt.Sprintf(<span class="string">"%f"</span>,<span class="number">44.2</span>)</span><br><span class="line">  fmt.Println(myStr) <span class="comment">// 输出 "44.2"</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以用strconv来实现字符串往浮点数的转换</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">"3.123"</span> <span class="comment">// type string</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>,s1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f1,err = strconv.ParseFloat(s1,<span class="number">64</span>)</span><br><span class="line">_ = err</span><br><span class="line">fmt.Println(f1)</span><br></pre></td></tr></table></figure>
<p>我们可以用 Atoi 和 Itoa来实现整数和字符串之间的转换，更加方便</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i,err := strconv.Atoi(<span class="string">"-50"</span>)	<span class="comment">// -50, int类型</span></span><br><span class="line">s2 := strconv.Itoa(<span class="number">20</span>)				<span class="comment">// "20",string类型</span></span><br></pre></td></tr></table></figure>
<h3 id="Defined-Named-Types"><a href="#Defined-Named-Types" class="headerlink" title="Defined(Named) Types"></a>Defined(Named) Types</h3><p>在 Go 中，”defined type” 和 “source type” 是类型系统中的两个概念。</p>
<ul>
<li><p>Defined Type（定义类型）：在 Go 中，你可以使用 <code>type</code> 关键字创建一个新的类型，该类型基于一个已有的类型。这种通过 <code>type</code> 关键字定义的类型称为 “defined type”。它们在语法上与其基础类型相同，但在类型系统中被视为不同的类型。</p>
<p>例如，假设你有一个 <code>int</code> 类型的变量 <code>x</code>，你可以使用 <code>type</code> 关键字创建一个新类型 <code>MyInt</code>，它是基于 <code>int</code> 类型的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> x MyInt = <span class="number">10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Source Type（源类型）：源类型是指定义类型的基础类型，也就是定义类型是基于的类型。在定义类型中，源类型扮演着基础类型的角色，提供了定义类型的底层实现和行为。</p>
<p>在上述示例中，<code>int</code> 就是 <code>MyInt</code> 的源类型。<code>MyInt</code> 类型继承了 <code>int</code> 类型的所有属性和方法，因此可以在 <code>MyInt</code> 类型的变量上执行与 <code>int</code> 类型相同的操作。</p>
</li>
</ul>
<p>在Defined Type和 Source Type之间，可以进行隐式类型转换，所以我们看到10可以直接赋值给 MyInt类型的 x</p>
<p>需要注意的是，两个不同的 Defined Type之间，虽然他们可能源于同一个 source type，但是他们之间没有办法进行隐式类型转换，需要显式类型转换！！</p>
<p>比如说：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> km <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">type</span> mile <span class="keyword">float64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> parisToLondon km = <span class="number">465</span></span><br><span class="line">	<span class="keyword">var</span> distanceInMiles mile</span><br><span class="line">	<span class="comment">//distanceInMiles = parisToLondon * 0.621 //会报错，因为 mile 和 parisToLandon不是一种类型的</span></span><br><span class="line">	distanceInMiles = mile(parisToLondon) * <span class="number">0.621</span></span><br><span class="line">	fmt.Println(distanceInMiles)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>distanceInMiles = mile(parisToLondon) * 0.621</code>  的底层逻辑是，将parisToLondon转换成mile类型，由于mile类型的底层类型是float,因此他们可以相乘并赋值给mile类型的distanceInMiles</p>
<p>我们再举一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> second <span class="keyword">uint</span></span><br><span class="line"><span class="keyword">type</span> duration second</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> minute = <span class="keyword">uint</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> t1 duration = <span class="number">10</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">var</span> x <span class="keyword">uint</span> = t1</span><br><span class="line">	_ = x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的的代码中，<code>second</code> 和 <code>duration</code> 都是通过类型定义创建的新类型。它们并不是别名类型。对于类型定义而言，尽管它们的底层类型相同，但在类型系统中它们被视为不同的类型。</p>
<p>在这种情况下，你可以将 <code>10</code> 隐式转换为 <code>duration</code> 类型，因为 <code>10</code> 是一个无类型常量，它可以自动转换为 <code>duration</code> 类型。这是由于编译器在编译时会将无类型常量转换为目标类型。</p>
<p>然而，将 <code>duration</code> 类型的变量赋值给 <code>uint</code> 类型的变量时，需要进行显式类型转换，因为在类型系统中，它们被视为不同的类型。</p>
<p>所以，<code>10</code> 可以隐式转换为 <code>duration</code> 类型，但 <code>duration</code> 类型的变量不能隐式转换为 <code>uint</code> 类型。</p>
<h3 id="Alias-Declarations"><a href="#Alias-Declarations" class="headerlink" title="Alias Declarations"></a>Alias Declarations</h3><p>在 Go 中，Alias Declaration（别名声明）是一种创建类型别名的语法。它允许你为现有的类型创建一个新的名称，以便在代码中更清晰地表达其含义或提供更具可读性的标识符。和 上面的 named type不一样，别名类型和原始类型具有相同的底层结构和行为，它们是完全兼容的，可以互相替代使用。</p>
<p>Alias Declaration 使用 <code>type</code> 关键字，后面紧跟新的类型名称和等号，然后是现有的类型。</p>
<p>下面是一个示例，展示了如何使用 Alias Declaration 创建类型别名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type MyFloat64 &#x3D; float64</span><br></pre></td></tr></table></figure>
<p>需要注意的是，在 Go 中，<code>byte</code> 和 <code>uint8</code> 是相同的类型，它们是别名关系。同样地，<code>rune</code> 和 <code>int32</code> 也是相同的类型，它们也是别名关系。它们之间可以进行隐式类型转换，并且可以互相替代使用。</p>
<p>在特定的上下文中</p>
<ul>
<li><p>用 <code>byte</code> 表示一个无符号的8位整数，通常用于表示字节数据</p>
</li>
<li><p>而使用 <code>rune</code> 表示一个Unicode码点，通常用于处理字符和文本数据。</p>
</li>
</ul>
<h2 id="Program-Flow-Control-in-Go"><a href="#Program-Flow-Control-in-Go" class="headerlink" title="Program Flow Control in Go"></a>Program Flow Control in Go</h2><h3 id="If-Else"><a href="#If-Else" class="headerlink" title="If-Else"></a>If-Else</h3><p>在 Go 中，<code>if-else</code> 是一种条件语句，用于根据条件的真假来执行不同的代码块。它的基本语法如下：条件不需要加括号，但是代码块需要使用花括号 <code>{}</code> 来界定。另外，条件表达式的结果<strong>必须是布尔类型</strong>的值（<code>true</code> 或 <code>false</code>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if condition &#123;</span><br><span class="line">    &#x2F;&#x2F; 当条件为真时执行的代码块</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 当条件为假时执行的代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Command-Line-Arguments-os-Args"><a href="#Command-Line-Arguments-os-Args" class="headerlink" title="Command Line Arguments: os.Args"></a>Command Line Arguments: os.Args</h3><p>在 Go 中，<code>os.Args</code> 是一个字符串切片（<code>[]string</code>），用于获取命令行参数。</p>
<p>当我们在终端或命令行中执行一个可执行程序时，可以通过命令行参数来传递额外的信息给程序。<code>os.Args</code> 变量提供了对这些命令行参数的访问。</p>
<p><code>os.Args</code> 切片的第一个元素是可执行程序的名称，后面的元素是传递给程序的命令行参数。下标从 0 开始。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取所有命令行参数</span></span><br><span class="line">	args := os.Args</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印可执行程序的路径</span></span><br><span class="line">	fmt.Println(<span class="string">"程序路径:"</span>, args[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印其他命令行参数</span></span><br><span class="line">	fmt.Println(<span class="string">"命令行参数:"</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(args); i++ &#123;</span><br><span class="line">		fmt.Println(i, args[i])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设我们将上述程序保存为 <code>commandline.go</code>，然后在终端中执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run naive.go arg1 arg2 arg3</span><br></pre></td></tr></table></figure>
<p>程序的输出将会是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">程序路径: &#x2F;var&#x2F;folders&#x2F;lp&#x2F;52cjrdtd4_59hlqcsgrcwc_m0000gn&#x2F;T&#x2F;go-build1548655087&#x2F;b001&#x2F;exe&#x2F;naive</span><br><span class="line">命令行参数:</span><br><span class="line">1 arg1</span><br><span class="line">2 arg2</span><br><span class="line">3 arg3</span><br></pre></td></tr></table></figure>
<p>我们再看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	&#x2F;&#x2F; 获取所有命令行参数</span><br><span class="line">	var result, err &#x3D; strconv.ParseFloat(os.Args[1], 64)</span><br><span class="line">	fmt.Printf(&quot;%T\n&quot;, os.Args[1])</span><br><span class="line">	fmt.Printf(&quot;%T\n&quot;, result)</span><br><span class="line">	_ &#x3D; err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行<code>go run naive.go 50</code> 可得到如下打印结果：这也说明os.Args中的参数都是字符串形类型的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string</span><br><span class="line">float64</span><br></pre></td></tr></table></figure>
<h3 id="Simple-If-Statement"><a href="#Simple-If-Statement" class="headerlink" title="Simple If Statement"></a>Simple If Statement</h3><p>对于一些If语句，我们可以对其进行简化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// converting string to int:</span></span><br><span class="line">    i, err := strconv.Atoi(<span class="string">"45"</span>)</span><br><span class="line"> 		</span><br><span class="line">    <span class="comment">// error handling</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// simple (short) statement -&gt;  the same effect as the above code</span></span><br><span class="line">    <span class="comment">// 把第一句话和判断放在一起，中间用逗号隔开</span></span><br><span class="line">    <span class="keyword">if</span> i, err := strconv.Atoi(<span class="string">"34"</span>); err == <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"No error. i is "</span>, i)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="For-Loops"><a href="#For-Loops" class="headerlink" title="For Loops"></a>For Loops</h3><p>在 Go 中，<code>for</code> 是用于循环执行代码块的关键字。Go 提供了几种不同形式的 <code>for</code> 循环，以满足不同的需求。</p>
<ol>
<li>基本的 <code>for</code> 循环：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> initialization; condition; post &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在基本的 <code>for</code> 循环中，我们可以指定初始化语句、循环条件和后置语句。初始化语句在循环开始前执行一次，循环条件在每次迭代前进行判断，循环体执行完后会执行后置语句。</p>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>for</code> 循环的初始化和后置语句是可选的：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> condition &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种形式的 <code>for</code> 循环中，我们只需要指定循环条件。如果条件为真，则执行循环体。在每次迭代结束后，循环条件会被重新评估。</p>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="number">5</span> &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">    i++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>除了上述基本的 <code>for</code> 循环形式外，Go 还提供了 <code>range</code> 关键字来迭代集合类型（如数组、切片、映射等）的元素。<code>range</code> 循环会依次迭代集合中的每个元素，并提供索引和对应的值。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numbers := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> numbers &#123;</span><br><span class="line">    fmt.Println(index, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Go 中没有专门的 <code>while</code> 关键字，但是你可以使用 <code>for</code> 循环来实现类似 <code>while</code> 的功能。你可以通过省略初始化语句和后置语句，并只保留循环条件，来使用 <code>for</code> 循环作为 <code>while</code> 循环的替代。</p>
<p>下面是一个示例，展示如何在 Go 中使用 <code>for</code> 循环来实现 <code>while</code> 循环：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="number">5</span> &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们就实现了一个类似于 <code>while</code> 循环的行为，只要循环条件为真，就会不断地执行循环体。</p>
<p>需要注意的是，在使用 <code>for</code> 循环作为 <code>while</code> 循环的替代时，你需要确保在循环体内部更新循环条件的值，以免出现死循环。在上述示例中，我们在循环体内部使用 <code>i++</code> 来逐步增加 <code>i</code> 的值，以确保循环条件最终不再满足，从而终止循环。</p>
<h3 id="For-and-Continue-Statements"><a href="#For-and-Continue-Statements" class="headerlink" title="For and Continue Statements"></a>For and Continue Statements</h3><p>在 go中，也有continue关键词 ,当<code>continue</code>语句执行时，它会立即终止当前迭代的执行，并跳到循环的下一次迭代。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> i%<span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">continue</span> <span class="comment">// 跳过奇数</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码将打印出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，当<code>i</code>为奇数时，<code>continue</code>语句将被执行，跳过当前迭代，然后继续执行下一次迭代。只有当<code>i</code>为偶数时，<code>fmt.Println(i)</code>语句才会执行。</p>
<h3 id="For-and-Break-Statements"><a href="#For-and-Break-Statements" class="headerlink" title="For and Break Statements"></a>For and Break Statements</h3><p>在Go语言中，<code>break</code>是一个控制流语句，用于在循环或<code>switch</code>语句中立即终止当前的执行流程并跳出循环或<code>switch</code>语句。</p>
<p>当<code>break</code>语句执行时，它会立即终止当前的循环或<code>switch</code>语句的执行，并将控制转移到循环或<code>switch</code>语句之后的下一行代码。</p>
<p>下面是一个使用<code>break</code>语句的示例，演示了在循环中使用<code>break</code>来提前结束循环的情况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">goCopy code</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">5</span> &#123;</span><br><span class="line">        <span class="keyword">break</span> <span class="comment">// 当 i 等于 5 时终止循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，<code>break</code>语句只会影响当前所在的循环或<code>switch</code>语句。如果有嵌套循环或嵌套<code>switch</code>语句，<code>break</code>语句只会跳出最内层的循环或<code>switch</code>语句。如果想要跳出外层的循环或<code>switch</code>语句，可以使用标签（label）来标识循环或<code>switch</code>语句，并在<code>break</code>语句中指定标签。</p>
<h3 id="Label-Statement"><a href="#Label-Statement" class="headerlink" title="Label Statement"></a>Label Statement</h3><h3 id="Goto"><a href="#Goto" class="headerlink" title="Goto"></a>Goto</h3><h3 id="Switch-Statement"><a href="#Switch-Statement" class="headerlink" title="Switch Statement"></a>Switch Statement</h3><h3 id="Scopes-in-Go"><a href="#Scopes-in-Go" class="headerlink" title="Scopes in Go"></a>Scopes in Go</h3><h2 id="Arrays-in-Go"><a href="#Arrays-in-Go" class="headerlink" title="Arrays in Go"></a>Arrays in Go</h2><h2 id="Slice-in-Go"><a href="#Slice-in-Go" class="headerlink" title="Slice in Go"></a>Slice in Go</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/06/05/%E5%8C%BA%E5%9D%97%E9%93%BE-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/05/%E5%8C%BA%E5%9D%97%E9%93%BE-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">区块链-共识算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-05 09:03:11" itemprop="dateCreated datePublished" datetime="2022-06-05T09:03:11+08:00">2022-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-27 10:56:34" itemprop="dateModified" datetime="2022-12-27T10:56:34+08:00">2022-12-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先我们知道有两种故障容错类型：拜占庭容错(BFT)和崩溃容错(CFT)。</p>
<ul>
<li>崩溃容错（CFT）是一种弹性，在这种情况下，如果组件出现故障，系统仍可以正确地达成共识。</li>
<li>拜占庭的容错（BFT）表示即使在存在恶意参与者的情况下也可以完成共识。 </li>
</ul>
<h3 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h3><p>共识算法一般在分布式系统中经常使用，而且我们这学期也在想学习MapReduce、Spark、Flink这类框架。其实，区块链系统也是一种分布式系统，因为在区块链中每个节点独立运行交易，不同的节点可能运行在地理上分离的区域，而有些节点可能存在恶意、可能发生故障。</p>
<p>因此，区块链系统作为一个整体应该对外提供可靠、可用、一致性的服务，但处理结果的一致性是基础。</p>
<p>分布式系统分为同步和异步分布式系统。</p>
<h4 id="同步分布式系统"><a href="#同步分布式系统" class="headerlink" title="同步分布式系统"></a>同步分布式系统</h4><p>同步分布式系统需要严格满足：</p>
<p>（1）节点运行指令的时间有严格的上限和下限；</p>
<p>（2）消息能够在有限的时间内传输到目标节点；</p>
<p>（3）每个节点有一个本地时钟，与实际时间的偏移率在一个已知的范围内。</p>
<p>同步分布式网络就像两个人打电话，只要不挂断，一个人就必须等待在那边听声音</p>
<p>对于运行在广域网上的区块链系统来说，上述约束条件很难满足(因为区块产生的速度比较慢)，而且区块链网络中的节点可能在空间上的距离不等。因此区块链系统一般采用异步分布式系统(弱同步)。</p>
<h4 id="异步分布式系统"><a href="#异步分布式系统" class="headerlink" title="异步分布式系统"></a>异步分布式系统</h4><p>异步分布式系统具有如下性质：异构性、并发性、可靠性、可用性、缺乏全局时钟、故障独立性</p>
<p>异步分布式系统存在一些限制：</p>
<ol>
<li>每一个动作在不同的节点运行时间不同，因为机器的性能不一样</li>
<li>消息可以在任意长时间后接收到，因为网络存在延迟</li>
<li>时钟漂移率可以使任意的</li>
</ol>
<p>异步模型对运行速度和消息延迟没有任何假设，这就要求区块链系统中的模型和算法不应立足于某些限制进行设计。就好比发微信，我看到了别人发来的微信，才会回复，而不是一直抱着手机等在那边</p>
<ul>
<li><p>一致性问题</p>
<ul>
<li><strong>处理结果一致</strong>（状态一致）。指分布式系统中多个节点就某一处理结果达成一致，基本方法是状态复制（State Replication）。如传统数据库的发布<strong>订阅模式</strong>，就实现了数据库的一致性。</li>
<li><strong>输入的一致性</strong>。指从多个节点的输入值中，选取其中一个作为决策值，并作为分布式系统共同的输入。这也是区块链中通常所说的共识。</li>
</ul>
</li>
<li><p>可靠性问题</p>
<ul>
<li><strong>可靠性（可用性）</strong>是描述系统可以提供服务能力的重要指标，通常用两个时间指标MTBF（ Mean Time Between Failures ，平均故障间隔时间）和MTTR（ Mean Time to  Repair ，平均修复时间）来衡量。一个高可用性系统应该具有尽量长的MTBF和尽量短的MTTR。</li>
</ul>
</li>
</ul>
<h3 id="共识"><a href="#共识" class="headerlink" title="共识"></a>共识</h3><p>在集中式系统中，一旦出现单点故障，就只能让系统重启，任务会被搁置。分布式系统就解决了这个问题，分布式系统需要首先保证高可靠、高可用性。由此，在分布式系统中需要有多个节点。</p>
<p>假设系统中有n个节点，其中最多有f个节点可能崩溃，在剩下的n-f个好的节点中，从节点i提交一个区块$B_i$(输入值)开始，所有节点要遵循相同的协议，从全部提交的区块中选择一个区块(一致性结果，决策值)，并用该去快提交到区块链系统</p>
<p>从多个节点输入值中选取一个决策之就称为共识，达成共识过程中所遵循的协议就是共识算法</p>
<p>共识需要满足的条件</p>
<ul>
<li><strong>一致性</strong>： 所有好节点的决策之必定相同</li>
<li><strong>可终止性</strong>： 所有好节点在有限的时间内结束决策过程</li>
<li><strong>有效性</strong>: 选择出的决策之必须是某个节点的输入值</li>
</ul>
<h4 id="故障容错"><a href="#故障容错" class="headerlink" title="故障容错"></a>故障容错</h4><p>故障容错是指区块链系统中<strong>节点</strong>和<strong>通信信道</strong>都有可能出现故障，导致部分节点不可用或者偏离被认为正确的结果或行为。</p>
<p>不同故障的影响：“遗漏故障”，“随机故障”，“时序故障”（时序故障主要针对同步分布式系统，对执行时间、通信时间和时钟漂移均有限制）。</p>
<h5 id="遗漏故障"><a href="#遗漏故障" class="headerlink" title="遗漏故障"></a>遗漏故障</h5><p>遗漏故障是指节点或通信信道不能完成它应该做的动作，就是崩溃了。也称为CFT。在异步环境下，由于对节点的运行速度和消息传递延迟没有限制，因此我们无法判断消息到底是在路上，还是节点已经崩溃。这种情况被称为<strong>可变消息延迟</strong>。区块链系统中共识算法的设计应该基于可变消息延迟的模式</p>
<ul>
<li><strong>节点遗漏故障</strong>： 主要是崩溃，意味着节点停止并不再执行任何动作，也不再对消息进行响应。一般用一段固定时间等待故障节点对消息的应答来检测，如果其他节点能确切检测到节点已经崩溃，那么这个节点崩溃称为故障-停止。但对异步系统，超时只能表明节点没有响应，这可能是节点崩溃了，也可能是节点执行速度慢甚至是消息还没有到达</li>
<li><strong>通信遗漏故障</strong>： 指通过通信信道，节点A不能把消息m成功传送到节点B，也叫信息丢失。在存在消息丢失的消息传递模式下，任何一条消息都不能保证可以安全地到达消息的接收者。存在两种情况，一种是消息到达节点B，但消息内容已经损坏，这种可以通过消息签名检测；另一种情况就是消息丢失。</li>
</ul>
<p>遗漏故障在异步分布式系统中是比较难解决的——无论是节点还是通信，都难以判断其是否发生了故障。</p>
<h4 id="随机故障"><a href="#随机故障" class="headerlink" title="随机故障"></a>随机故障</h4><p>随机故障也称为拜占庭故障，用于描述可能发生的任何类型故障，如故意返回错误结果或者处理的结果本身就是一个错误的。</p>
<ul>
<li>节点的随机故障通常是指节点进程<strong>随机地省略</strong>要做的处理步骤或执行一些不需要的步骤，从而导致产生错误的执行结果。这类故障<strong>不能通过查看节点是否应答来检测</strong>，也无法通过<strong>密码学的方式</strong>来进行判断，因为它可能随机地应答或者应答错误的结果。</li>
<li>通信通道也会出现随机故障，如消息内容可能被损坏或者传递不存在的消息，也可能多次传递同样的消息。这类故障可以通过校验、消息签名或时间戳等机制进行检测。</li>
</ul>
<p>因此在基于拜占庭故障的共识算法在设计时，除了考虑拜占庭节点是否返回结果，还需要考虑返回错误结果的情况，因此基于拜占庭的共识算法通常要求不超过1/3的出错节点，就是考虑到即使1/3的正常节点和1/3的故障节点对冲后，仍然有多数1/3能够使算法形成共识</p>
<h3 id="FLP原理"><a href="#FLP原理" class="headerlink" title="FLP原理"></a>FLP原理</h3><p>FLP不可能原理：当允许存在<strong>节点失效</strong>的情况下，不存在一个确定性的共识算法总能<strong>在异步模型</strong>下达成一致。就连POW也不是确定性的，也可能存在一条链被推翻的情况</p>
<p>但是，在同步模型下，由于其对节点处理时间、消息传递、始终都有要求，很容易判断是否失败，从而决定是否重传或者其他方式进行故障排除。</p>
<p>FLP原理实际上说明对于允许节点失效的情况下，纯粹的异步系统无法确保一致性在有限的时间内完成。即便对于非拜占庭错误的前提下，包括Paxos、Raft等共识算法都存在无法达成共识的情况。</p>
<p>但是，在工程实践中，在付出一些代价的情况下，获得高效的共识算法还是很有必要的。具体付出什么代价，共识算法能达到什么程度，往往通过CAP原理进行衡量。</p>
<h3 id="CAP原理"><a href="#CAP原理" class="headerlink" title="CAP原理"></a>CAP原理</h3><p>在这篇博客<a href="https://jasonxqh.github.io/2022/01/01/数据库扩展性问题/#数据库扩展性问题">数据库扩展性问题</a>中学习过，这边再复习一下</p>
<p>CAP 原理是指在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance），三者不可兼得。</p>
<p><img src="/2022/06/05/%E5%8C%BA%E5%9D%97%E9%93%BE-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/1.png" style="zoom:67%;"></p>
<h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p><strong>用如下系统进行解释</strong></p>
<p><img src="/2022/06/05/%E5%8C%BA%E5%9D%97%E9%93%BE-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/2.png"></p>
<ol>
<li>客户端向G1写入数据v1，并等待响应</li>
<li>此时，G1服务器的数据为v1，而G2服务器的数据为v0，两者不一致</li>
<li>接着，在返回响应给客户端之前，G2服务器会自动同步G1服务器的数据，使得G2服务器的数据也是v1</li>
<li>一致性保证了不管向哪台服务器（比如这边向G1）写入数据，其他的服务器（G2）能实时同步数据</li>
<li>G2已经同步了G1的数据，会告诉G1，我已经同步了</li>
<li>G1接收了所有同步服务器的已同步的报告，才将“写入成功”信息响应给client</li>
<li>client再发起请求，读取G2的数据</li>
<li>此时得到的响应是v1，即使client从未写入数据到G2</li>
</ol>
<p>一致性的要求就是，在没有达到全部同步之前，是没有办法向客户提供服务的。</p>
<h4 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h4><p>系统中非故障节点收到的每个请求都必须有响应</p>
<p>即可用性，所有的节点都保持<strong>高可用性</strong>。<strong>注意</strong>，这里的高可用还包括不能出现延迟，比如如果某节点由于等待数据同步而阻塞客户端请求，那么节点就不满足高可用性。也就是说，任何没有发生故障的服务必须在有限的时间内返回合理的结果集。</p>
<h4 id="分区容错性"><a href="#分区容错性" class="headerlink" title="分区容错性"></a>分区容错性</h4><p><strong>允许网络丢失从一个节点发送到另一个节点的任意多条消息，即不同步 。常常会发生在分布式系统出现网络故障的时候，但由于网络是脆弱不稳定的，因此分区容错性常常必不可少</strong></p>
<p>我们举个例子，比如A、B两个机房构成一个分布式集群，如果A和B机房之间的网络不通了，那么一个分布式集群就会拆分成A和B两个集群。如果出现了分区，那肯定保证不了数据的强一致性。</p>
<h4 id="A与C的取舍"><a href="#A与C的取舍" class="headerlink" title="A与C的取舍"></a>A与C的取舍</h4><p>分区容忍性是在物理上进行保证的，比如说在海底铺设多条光缆，出现光缆故障的概率较小且难以完全避免。因此我们只能在AC之间做一个trade-off，这是由业务场景决定的</p>
<ol>
<li>保证AP, 弱化一致性(C)，允许某个时刻不一致，但是最终仍然会达到一致<ul>
<li>适用于对结果一致性不敏感的应用，可以允许新的数据副本产生后经过一段时间后，所有节点才更新成功，期间不保证一致性。如简单分布式p2p协议Gossip</li>
<li>不同的区块链系统采用不同的机制来确保新的交易所基于的区块链数据库是最新状态。如比特币要求6个区块确认，Fabric要求背书节点对交易背书</li>
</ul>
</li>
<li>保证CP, 弱化可用性(A) 允许执行过程”慢一些“，甚至拒绝服务<ul>
<li>适用于对结果一致性很敏感的应用，例如银行取款机，当分布式系统对处理不能达到一致结果时会拒绝服务。</li>
<li>Mongodb、Redis这样的NoSQL数据库，也满足CP原则</li>
<li>Paxos 、Raft 等共识算法，主要处理这种情况。在Paxos 类算法中，可能存在着无法提供可用执行结果的情形，但同时允许少数节点离线。</li>
</ul>
</li>
</ol>
<p>有人会问，就不能保证AC吗？那就需要非常严格的全体一致协议，不能容忍网络错误或者节点错误，一旦出现这样的问题，整个系统就会拒绝写请求，因为它并不知道对面的那个结点是否挂掉了。</p>
<p><img src="/2022/06/05/%E5%8C%BA%E5%9D%97%E9%93%BE-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/3.png"></p>
<h3 id="区块链系统中的ACID原则"><a href="#区块链系统中的ACID原则" class="headerlink" title="区块链系统中的ACID原则"></a>区块链系统中的ACID原则</h3><p>事务的ACID我们已经不陌生了，那么区块链中的ACID是什么样的呢？</p>
<ul>
<li>原子性：每次对系统的更新操作都是原子的，要么成功，要么不执行。对于区块链系统，一个原子操作是一个 区块，因此区块的提交应满足原子性要求。</li>
<li>一致性：上面我们说的都是一致性。一个操作开始和结束时，数据库的状态是一致的，无中间状态。对于区块链系统，不同节点在一个区块提交前后的状态应该是一致的。</li>
<li>隔离性：并发操作时，彼此不需要知晓对方存在，执行互不影响，需要串行化执行，有时间顺序。在区块链系统中，要根据并发交易到达的顺序逐个添加到区块中，在区块提交时按照排序顺序执行。</li>
<li>永久性： 状态的改变是持久的，不会失效，也不会无缘无故回滚。区块链系统中，一个区块一旦达成共识，会永久附加到原有的区块链中，不可篡改。</li>
</ul>
<h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><p>在计算机网络中中，还有一个很重要的理论：BASE (Basic Availability ,Soft-state, Eventual Consistency 三个短语的缩写) </p>
<p>这个原则与ACID相对，就是说牺牲掉对一致性的约束(最终仍然实现一致性)，来换取一定的可用性。BASE理论的核心思想是：<strong>即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性</strong></p>
<ul>
<li>Basic Availability(基本可用,总归会可用的)。分布式系统在出现不可预知故障的时候，允许损失部分可用性，如响应时间上的损失或系统功能上的损失。实际例子：12306抢票</li>
<li>Soft-state(允许系统中的数据存在中间状态)。认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。即节点之间不一致的状态</li>
<li>Eventual Consistency(最终一致性)。所有的数据副本在经过一段时间的同步之后，最终都能够达到一个一致的状态。因此本质是需要保证最终达到一致，而不需要实时保证强一致性。</li>
</ul>
<p>BASE理论是对CAP中一致性和可用性权衡的结果(牺牲一致性，换取可用性)、其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的。</p>
<p>BASE理论面向的是<strong>大型高可用可扩展的分布式系统</strong>，和传统的事务ACID特性是相反的，它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。</p>
<p>在实际的分布式场景种，由于不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性和BASE理论又往往会结合在一起</p>
<h2 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h2><p>Paxos算法是基于消息传递且具有高度容错的一致性算法，是目前公认的解决分布式一致性问题最有效的算法之一。该算法能够解决分布式网络中存在遗漏故障，并且故障节点数小于总节点数的1/2的场景下的共识问题。</p>
<h2 id="RAFT"><a href="#RAFT" class="headerlink" title="RAFT"></a>RAFT</h2><p>在我的这篇博客已经写的很详细了<a href="https://jasonxqh.github.io/2022/06/10/Raft/#Raft">Raft</a></p>
<h2 id="PBFT算法"><a href="#PBFT算法" class="headerlink" title="PBFT算法"></a>PBFT算法</h2><p>PBFT常常运用于联盟链当中，进入联盟链需要一个CA(合法性证明)。在公链系统中，共识是通过POW实现的，但是由于POW需要消耗大量能源，因此饱受诟病。在联盟链中，由于存在一定的信任基础(CA)，使得共识可以通过PBFT算法实现，其主要原理就是CPU投票。</p>
<h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>PBFT是Practical Byzantine Fault Tolerance的缩写，意为实用拜占庭容错算法。它解决了原始拜占庭容错算法效率不高的问题，将算法复杂度由指数级降低到多项式级，是的拜占庭容错算法在实际系统应用中变得可行。</p>
<p>PBFT算法是基于<strong>状态机复制</strong>理念(听起来很耳熟，raft也是这个原理)设计的一个使用的并能解决拜占庭容错的算法，当存在f个失效节点时必须保证存在至少3f+1个副本，才能保证在异步分布式系统中达成共识，并且算法满足安全性和活性要求，即提供 $(n-1)/3$ 的容错性</p>
<p>在采用PBFT算法的区块链系统中，每个节点维护服务在本节点的状态(区块链)及相关服务操作(交易)，这里的服务被称为在系统中不同节点之间复制(消息传输)的状态机，包含状态和操作。 </p>
<p>整个系统共同维护一个状态，并在不同节点之间赋值，所有的节点采取一致的行动，从而满足分布式系统的一致性要求。状态机在每个节点的复制体称为副本，<strong>每个节点都有一个完整的副本</strong>，所有副本的集合用R表示，每个副本用$R_i~ ,R_i\in(0\sim|R|-1)$ 表示。</p>
<p>同所有的状态机复制技术一样，PBFT对每个副本节点提出了两个限定条件：</p>
<ol>
<li>所有节点必须是确定性的。也就是说，在给定状态和参数相同的情况下，操作执行的结果必须相同</li>
<li>所有节点必须从相同的状态开始执行</li>
</ol>
<h3 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h3><h4 id="视图-view"><a href="#视图-view" class="headerlink" title="视图(view)"></a>视图(view)</h4><p>视图可以理解为Raft当中的任期，其视图编号也是连续的。</p>
<p>视图是一次成功地节点配置轮换过程。在一个视图中，会根据算法来确认一个副本作为主节点(primary),其他副本作为备份(backups)。</p>
<p>但是与Raft算法竞争Leader不同，PBFT算法中，主节点由公式 $p=\text{v mod |R|}$ 计算得到，这里v是视图编号，p是副本编号，$|R|$ 是副本集合的个数。因此，在PBFT中，是轮流做庄的，谁当Leader是确定的。</p>
<h4 id="主节点"><a href="#主节点" class="headerlink" title="主节点"></a>主节点</h4><p>主要用于分配基于本视图的消息序列号(全局编号)，从而对分布式系统的消息进行全局排序。进而，所有副本会按照视图编号、序列号的顺序处理消息，变更状态，使得所有副本的状态保持一致</p>
<h4 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h4><p>使用加密和签名技术来防止欺骗攻击和重放攻击，以及检测被破坏的信息。但是，对消息本身的错误、消息的延迟或者不响应则要通过共识算法来防止。</p>
<p>因此，算法中消息包含了<strong>公钥签名、消息摘要</strong>等安全信息及检测消息重复的消息验证编码(MAC)。</p>
<p>算法中，使用m表示消息，$m_i$表示由节点i签名的消息，$D(m)$ 表示消息m的摘要。</p>
<h3 id="客户端-消息发起者"><a href="#客户端-消息发起者" class="headerlink" title="客户端(消息发起者)"></a>客户端(消息发起者)</h3><p>客户端c向主节点发送请求 <code>&lt;REQUEST,o,t,c&gt;</code>, 请求执行状态机操作o。</p>
<ul>
<li>其中t是时间戳，用来保证客户端请求只会执行一次</li>
<li>客户端c发出请求的时间戳是全序排列的，不可逆的，后续发出的请求比以前发出的请求拥有跟高的时间戳。</li>
<li>对于客户端，请求发起的时间戳可以是本地时钟值</li>
</ul>
<p>客户端发起消息之后，副本会给客户端一个Reply，响应格式是：<code>&lt;REPLY,v,t,c,i,r&gt;</code> ，其中v是视图编号，t是时间戳，i是副本节点的编号，r是请求执行的结果。</p>
<ul>
<li>每个由副本节点发送给客户端的消息，都包含了当前的视图编号，使得客户端能够跟踪视图编号，从而进一步推算出当前主节点的编号</li>
<li>客户端通过点对点消息向它自己认为的主节点发送请求，然后主节点自动将该请求向所有备份节点进行广播。由于系统中最多存在f个<strong>坏节点</strong>，因此，当有f+1个响应相同时，客户端把r作为正确的执行结果。所谓的响应相同，是指：签名正确；具有同样的时间戳t；执行结果r相同</li>
<li>如果客户端在有限时间内，没有收到f+1个相同的响应，客户端应该重新讲该请求向所有副本节点进行广播。这时候，如果副本节点已经处理过该请求，则可以直接把上次发送的响应重新发送给客户端。如果没有处理过，则副本节点进行处理请求的同时，会将该请求转发给主节点。</li>
</ul>
<h3 id="三段提交协议"><a href="#三段提交协议" class="headerlink" title="三段提交协议"></a>三段提交协议</h3><p>主节点接收到来自客户端的请求之后，按照三阶段协议，会向全网广播该消息。主要包括<strong>预准备(pre-prepare)、准备(prepare)和确认(commit)</strong>三个阶段</p>
<ul>
<li>预准备和准备两个阶段用来确保同一个视图中请求发送的时序性</li>
<li>准备和确认两个阶段用来确保在不同的视图之间的已接受的请求命令是严格排序的。</li>
</ul>
<p><img src="/2022/06/05/%E5%8C%BA%E5%9D%97%E9%93%BE-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/4.png"></p>
<p>我们看到，由于大家都知道主节点是谁(通过视图号v取模运算得出)，因此客户端直接向主节点发起请求。这是<strong>request</strong>阶段</p>
<h4 id="预准备阶段"><a href="#预准备阶段" class="headerlink" title="预准备阶段"></a>预准备阶段</h4><p>由上图可知，预准备阶段主节点给予当前视图v分配一个序列号n给收到客户端请求，然后，向所有备份节点群发送预准备消息。</p>
<p>这个消息格式为:<code>&lt;&lt;PRE-PREPARE,v,n,d&gt;,m&gt;</code> ，这里v是视图编号，m是客户端发送的请求消息，d是请求消息m的摘要。</p>
<p>注意，客户端请求本身是不包含在预准备的消息里面的，其目的有两个：</p>
<ul>
<li>每个由副本节点发给客户端的消息，都包含了当前的视图编号，使得客户端能够跟踪视图编号，从而推算出主节点的编号</li>
<li>客户端通过点对点消息向它自己认为的主节点发送请求，然后主节点自动将该请求向所有备份节点进行广播。</li>
</ul>
<p>备份节点收到预准备信息后，需要开始验证、检查一些内容：</p>
<ul>
<li>请求和预准备消息的签名正确，并且d与m的摘要需一致</li>
<li>检查预准备消息中的视图编号是否为当前视图编号</li>
<li>节点是否接受过视图编号为v，序号为n，但消息摘要与d不同的消息？如果有的话，现在这条消息就会失效</li>
<li>消息的序号n必须在水线(watermark)上下限h和H之间。水线在之后会说明</li>
</ul>
<p>一旦某个备份节点 i 接收并验证了预准备信息，那么它就会进入准备阶段</p>
<h4 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h4><p>节点i开始准备阶段之后，会向所有副本节点发送准备消息<code>&lt;PREPARE,v,n,d,i&gt;</code>，并将预准备消息和准备消息在节点i进行保存。</p>
<p>当节点i收到来自其他节点的准备消息，那么当满足如下条件时</p>
<ul>
<li>条件1: 接收到超过 2f 个节点的准备消息</li>
<li>条件2: 接收到2f个与预准备消息一致的准备消息，一致的检查内容包括：视图编号v、消息序号n、摘要d</li>
</ul>
<p>副本节点i将 <code>(m,v,n,i)</code> 保存到本地并标记为Prepared状态，即为<code>prepared(m,v,n,i)</code> 。其中</p>
<ul>
<li>m是预准备消息中的消息</li>
<li>v是预准备消息中的视图编号</li>
<li>n是预准备消息中的序号。</li>
</ul>
<p>当变更为<code>prepared(m,v,n,i)</code> 之后，节点i 向其他副本节点广播格式为 <code>&lt;COMMIT,v,n,D(m),i&gt;</code> 的确认消息，于是协议进入确认阶段。</p>
<p>我们看到，每个节点在接收到信息之后，又会向全体节点发送消息。因此消息的复杂度到达了$O(n^2)$ </p>
<h4 id="确认阶段"><a href="#确认阶段" class="headerlink" title="确认阶段"></a>确认阶段</h4><p>在确认阶段，每个副本节点接收确认消息并写入消息日志，具体条件为：</p>
<ul>
<li>签名正确</li>
<li>消息的视图编号与节点的当前视图编号一致</li>
<li>消息的序号n满足水线条件，在h和H之间</li>
</ul>
<p>当副本节点i接收到2f+1个m的确认消息、并都满足上述条件之后，消息m会变更为committed-local状态，记为 <code>committed-local(m,v,n,i)</code>。具体条件为：</p>
<ul>
<li>节点i的 <code>prepared(m,v,n,i)</code>为真</li>
<li>节点i已经接收了2f+1个确认消息(包括自身在内)，与预准备消息一致。一致的检查内容包括：视图编号v，消息序号n，摘要d</li>
</ul>
<p>当消息m在节点i的状态为<code>committed-local(m,v,n,i)</code>时，节点执行m的请求，节点i的状态能够确保所有编号小于n的请求一次顺序执行。在完成m的请求操作之后，每个副本节点都会向客户端发送回复</p>
<p>副本节点会把时间戳比已回复时间戳更小的请求丢弃，以保证请求只会被执行一次。</p>
<p>当节点i的消息m变更为<code>committed-local(m,v,n,i)</code>时，对于分布式系统来说，消息m会变更为<code>commited(m,v,n)</code> 。也就是意味着，任意f+1个正常副本结点集合中的所有副本节点i ，其<code>prepared(m,v,n,i)</code>为真。这就确保了所有正常节点以同样的顺序执行所有请求，确保了节点状态的复制并保证了算法的正确性</p>
<p>节点状态变化路线 ：</p>
<p><img src="/2022/06/05/%E5%8C%BA%E5%9D%97%E9%93%BE-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/1.jpg"></p>
<h4 id="探讨"><a href="#探讨" class="headerlink" title="探讨"></a>探讨</h4><p>一轮投票可以不可以？ 在不换主或者主节点不作恶的情况下，是可以的，但是我们举一个极端的例子：</p>
<p>在分布式系统下，假设现在少部分进入prepared阶段，另外一些节点还没有进入prepare阶段。此时， 若主节点是恶意节点的话，它可以改变原来的信息，将m修改为具有相同序号的m’,并获得大多数未提交的节点的同意。</p>
<p>但是，如果有两轮投票的话，两轮就可以保证一致性。</p>
<h3 id="检查点协议"><a href="#检查点协议" class="headerlink" title="检查点协议"></a>检查点协议</h3><p>为了节省存储，系统需要一种将日志中的无异议消息记录删除的机制：算法设置周期性的检查点协议，将系统中的服务器同步到某一个相同的状态，同时可以定期地处理日志、节约资源并及时纠正服务器状态。</p>
<ul>
<li><p>在PBFT算法中，会保存所有接收到的消息并记录到日志中，如果日志不能及时清理，会导致奈统资源被大量的日志占用并影响系统的性能和可用性。</p>
</li>
<li><p>另一方面由于拜占庭节点的存在，算法不能保证每个节点执行了相同序列的请求，因此所有节点状态可能不一致。</p>
</li>
</ul>
<h4 id="执行过程："><a href="#执行过程：" class="headerlink" title="执行过程："></a>执行过程：</h4><ul>
<li><p>当副本节点i接收到的请求消息的序号可以被某个常数（如100）整除时会周期性向其他节点广播检查点消息 <code>&lt;CHECKPOINT, n,d,i&gt;</code>, 这里n是最近一个影响状态的请求序号，d是状态的摘要。</p>
</li>
<li><p>每个副本节点都默默地在各自的日志中收集并记录其他节点发过来的检查点消息，直到收到来自<strong>2f+1</strong>个不同副本节点的具有相同序号n和摘要d的检查点消息。</p>
</li>
<li>这2f+1个消息就是这个检查点的正确性证明。</li>
</ul>
<p>算法将这些请求执行后得到的状态称作检查点 (checkpoint)并且将具有证明的检查点称作<strong>稳定检查点 (stable checkpoint)</strong>。每个副本节点保存了服务状态的多个逻辑版本：包括最新的稳定检查点，零个或者多个非稳定的检查点，以及个当前状态。</p>
<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>节点确认某个检查点为稳定检查点后，然后副本节点就可以将所有序号小于等于口的预准各、准备和确认消息从日志中删除。同时也可以将之前的检查点和检查点消息一并删除。</p>
<h4 id="更新水线（watermark）的高低值-（h和H）："><a href="#更新水线（watermark）的高低值-（h和H）：" class="headerlink" title="更新水线（watermark）的高低值 （h和H）："></a>更新水线（watermark）的高低值 （h和H）：</h4><p>这两个高低值限定了可以被接受的消息。水线的低值h与最近稳定检查点的序列号相同，而水线的高值$H=h+k$，k需要足够大才能使副本不至于为了等待稳定检查点而停顿。假如检查点每100个请求产生一次，k的取值可以是200。</p>
<h3 id="水线-watermark"><a href="#水线-watermark" class="headerlink" title="水线(watermark)"></a>水线(watermark)</h3><p><img src="/2022/06/05/%E5%8C%BA%E5%9D%97%E9%93%BE-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/5.png" style="zoom:50%;"></p>
<p>图中A节点的当前请求编号是1039, B节点的请求编号是1133</p>
<p>当前系统的stable checkpoint 为1034，那么这个1034 就是低水位；而高水位$H=h+L$， 即1134</p>
<p>我们看到，A和B的请求编号在高水位和低水位之间，因此这两个请求都会被应答</p>
<p>如果B的请求编号位1135，那么说明B节点处理得很快，跑到很前面去了，这时候B就会停止应答，一直到其编号落入新的高低水位之间。</p>
<h3 id="视图更换协议"><a href="#视图更换协议" class="headerlink" title="视图更换协议"></a>视图更换协议</h3><p>在PBFT算法中，主节点承担消息序号分配、请求转发等核心功能。因此一旦主节点发生了错误，就会导致系统无法正常运行</p>
<p>视图更换协议就是确保主节点失效时算法的活性。</p>
<p>视图更换的触发可以通过备份节点中一个请求的超时执行触发。当一个节点i的超时产生时，会启动视图更换，并将视图编号v变更为v+1,同时不再接受处检查点消息、视图更换消息和新视图消息以外的其他消息请求</p>
<p>这时候，节点i 会向其他副本节点广播视图更换消息<code>&lt;VIEW-CHANGE,v+1,n,C,P,i&gt;</code></p>
<ul>
<li>n是节点i的最新稳定检查点s的序号</li>
<li>C是证明s是稳定检查点的2f+1个检查点消息</li>
<li>P是所有序号大于n的所有<code>prepared(m,v,n,i)</code> 为真的消息集合$P_m$ ,包括请求消息m的有效的预准备消息和与预准备消息一致的2f个准备消息。</li>
</ul>
<p>然后，会通过公式 $p = \text{v mod |R|}$ 计算得到主节点p，当主节点p收到2f个来自其他复制节点的有效的视图更换消息之后，节点p向其他复制节点广播新视图消息<code>&lt;NEW-VIEW,v+1,V,Q&gt;</code></p>
<ul>
<li><p>V包含主节点收到的2f+1个有效的视图更换消息(包括主节点p本身发送的视图更换消息)</p>
</li>
<li><p>Q包含有效的预准备消息（不包括请求消息），其范围通过以下算法获得：从集合V中获取最小的稳定检查点序号<code>min_s</code>和最大的稳定检查点<code>max_s</code>，主节点p为<code>min_s</code>到<code>max_s</code>中间的每个序号n在新的视图v+1中创建新的预准备消息。</p>
</li>
<li>这时序号n存在两种情况：<code>min_s</code>和<code>max_s</code>之间，是否存在于P消息集合<ul>
<li>至少存在一个V中的视图变更消息的集合P中包含序号n，这说明存在一个预准备消息m，则主节点向其他备份节点广播新的预准备消息<code>&lt;PRE-PREPARE,v+1,n,d&gt;</code></li>
<li>V中所有的视图变更消息的集合P中都不包含序号n，则主节点向其他备份节点广播预准备消息<code>&lt;PRE-PREPARE,v+1,n,d_null&gt;</code> ，<code>d_null</code> 是对null消息的签名，null消息执行空动作</li>
</ul>
</li>
<li>最后，主节点以<code>min_s</code>为最新的稳定检查点，并更新水线h为<code>min_s</code></li>
<li>备份节点接收到新视图消息之后，主要完成如下操作<ul>
<li>采用主节点相同的算法校验新视图消息中的Q，校验通过后，将Q中的预准备消息写入本节点的日志</li>
<li>为Q中的每个预准备消息创建准备消息，并向其他复制节点进行广播并将准备消息写入本节点日志。</li>
<li>更新视图编号为 v+1</li>
</ul>
</li>
<li>副本节点会对<code>min_s</code>到<code>max_s</code>中间的消息重新执行三阶段提交协议，在运行阶段，协议会通过本地存储的回复客户端的消息进行校验，已经回复的消息不会重新执行。</li>
</ul>
<p>示意图如下：</p>
<p><img src="/2022/06/05/%E5%8C%BA%E5%9D%97%E9%93%BE-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/6.png"></p>
<p> 通过视图更换协议，是的即使拜占庭节点被称为主节点，也能在视图变换后确保分布式系统的一致性</p>
<h3 id="共识问题"><a href="#共识问题" class="headerlink" title="共识问题"></a>共识问题</h3><p>在PBFT算法中，通过一下四个方面来确保分布式系统中的共识：</p>
<ol>
<li>由单一主节点对来自多个客户端的请求分配序号n，从而对分布式系统的消息进行全局排序</li>
<li>任一复制节点i 的消息m 进入状态<code>prepared(m,v,n,i)</code>,则意味着所有正常节点对同一个视图中的请求序号达成一致，即<strong>当任意两个正常节点，v和n相同时，消息m也相同</strong></li>
<li>任意f+1个正常副本节点集合中的所有副本i其<code>prepared (m,v,n,i)</code>为真，意味着消息m已成功提交给分布式系统即<code>committed (m,v,n)</code>在三阶段提交协议的确认阶段，任一节点i上消息m满足<code>committed-local (m,v,n,i)</code>为真，则<code>committed (m,v,n)</code>，进而节点i可以执行消息并向客户端返回结果，其他节点i也会按照相同的顺序执行消息m，从而实现状态复制。</li>
<li>当客户端收到f+1个从不同副本的同样响应时，则意味着f+1个正常节点己成功执行消息。当f+1个副本节点成功执行消息，就确保了所有正常的节点以同样的顺序执行所有请求。</li>
</ol>
<h3 id="RAFT和PBFT协议的比较"><a href="#RAFT和PBFT协议的比较" class="headerlink" title="RAFT和PBFT协议的比较"></a>RAFT和PBFT协议的比较</h3><div class="table-container">
<table>
<thead>
<tr>
<th>对比点</th>
<th>RAFT</th>
<th>PBFT</th>
</tr>
</thead>
<tbody>
<tr>
<td>适用环境</td>
<td>私有链(不支持拜占庭容错)</td>
<td>联盟链</td>
</tr>
<tr>
<td>算法通信复杂度</td>
<td>$O(n)$</td>
<td>$O(n^2)$</td>
</tr>
<tr>
<td>最大故障和容错节点</td>
<td>故障节点数量f满足 $ 2f+1&lt;= N$</td>
<td>容错节点数量f满足$ 3f+1 &lt;= N$</td>
</tr>
<tr>
<td>流程对比</td>
<td>1. 初始化Leader选举(谁快谁当)<br>2. 共识过程<br>3. 重选Leader机制</td>
<td>1. 初始化Leader选举(轮流坐庄)<br>2. 共识过程<br>3. 重选Leader机制</td>
</tr>
</tbody>
</table>
</div>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/" class="post-title-link" itemprop="url">高级数据库-事务</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-11 06:16:41" itemprop="dateCreated datePublished" datetime="2022-05-11T06:16:41+08:00">2022-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-25 14:41:56" itemprop="dateModified" datetime="2023-03-25T14:41:56+08:00">2023-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="高级数据库-事务"><a href="#高级数据库-事务" class="headerlink" title="高级数据库-事务"></a>高级数据库-事务</h1><h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><p>首先，我们来复习一下事务的概念：ACID，(其实在sql中已经学过了)</p>
<ul>
<li>原子性(Atomicity): 一个事务要么没有开始，要么全部完成，不存在中间状态</li>
<li>一致性(Consistency): 事务的执行不会破坏数据的正确性，即符合约束</li>
<li>隔离性(Isolation): 多个事务不会相互破坏</li>
<li>持久性(Durability): 事务一旦提交成功，对数据的修改不会丢失</li>
</ul>
<p>事务面向的负载在于查询和更新。其主要特征是：</p>
<ul>
<li>查询：较大数据集合的计算</li>
<li>更新：通常是小部分数据，点数据的更新 </li>
</ul>
<h3 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h3><ul>
<li>实现并发控制：隔离性</li>
<li>实现日志：原子性，持久性</li>
<li>一致性：应用或其他实现保证</li>
</ul>
<h4 id="并发控制的主要内容"><a href="#并发控制的主要内容" class="headerlink" title="并发控制的主要内容"></a>并发控制的主要内容</h4><p>并发控制的意思就是在有多个并发的事务的情况下怎么保持数据库的一致的状态。这个状态有不同的层次，这些层次就是<strong>隔离级别</strong>。隔离级别越高，并发能力越弱；隔离级别越低，并发能力越强。比如说，可串行化是最高的隔离级别。</p>
<p>接下来，我们就要着重了解可序列化这个隔离等级</p>
<h2 id="隔离等级"><a href="#隔离等级" class="headerlink" title="隔离等级"></a>隔离等级</h2><h4 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h4><p>首先给出调度(shedule)的定义：a <strong>sequence</strong> of <strong>(important) steps</strong> taken by <strong>one or more</strong> transactions</p>
<p>那么这些重要的步骤是什么？在并发控制中，往往是对于某一个值的读写操作：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read operation(<span class="type">Read</span>(<span class="type">X</span>))</span><br><span class="line">write operations(<span class="type">Write</span>(<span class="type">X</span>))</span><br></pre></td></tr></table></figure>
<p>我们给一个例子</p>
<p>现在有两个数据库中的值：A和B，它们相等</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">A</span> = <span class="number">25</span></span><br><span class="line"><span class="type">B</span> = <span class="number">25</span></span><br></pre></td></tr></table></figure>
<p>然后有两个事务,第一个事务负责把A和B各加上100，第二个事务负责把A和B各乘以2</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/2.png"></p>
<p>那么其中的一个可能的调度如下：</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/3.png"></p>
<p>当然，T1,T2可能是串行的，也就是先做完T1再做T2</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/4.jpeg" style="zoom: 67%;"></p>
<h3 id="串行执行"><a href="#串行执行" class="headerlink" title="串行执行"></a>串行执行</h3><p>在了解可序列化之前，我们先看看顺序执行是怎么做的。顺序执行非常好理解——它是单线程调度的，做完事务1之后才能做事务2.</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/5.png"></p>
<p>这是事务执行最理想的状态，但同时由于是单线程调度，其没有并发能力</p>
<h3 id="可串行化-Serializable"><a href="#可串行化-Serializable" class="headerlink" title="可串行化(Serializable)"></a>可串行化(Serializable)</h3><p>那么，可串行化的意思说，具有一定的并发能力，但同时让事务的调度结果和串行化是等价的。</p>
<p>比如说还是用上面那个例子，可串行化的调度如下：我们发现，这样的调度和串行化的调度是等价的，最终都能达到 A = B = 250的效果。</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/6.png"></p>
<p>那么<strong>非可串行化</strong>的调度是怎么样的呢？我们看看下图：得到的结果是 A=250,B=150，和串行化调度不等价</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/7.png"></p>
<p>可串行化对事务的执行先后没有要求，但是最后结果需要和串行化调度的结果达成一致</p>
<h3 id="冲突可串行化调度-Conflict-serializable"><a href="#冲突可串行化调度-Conflict-serializable" class="headerlink" title="冲突可串行化调度(Conflict-serializable)"></a>冲突可串行化调度(Conflict-serializable)</h3><h4 id="冲突等价"><a href="#冲突等价" class="headerlink" title="冲突等价"></a>冲突等价</h4><p>冲突操作指的是不同事务对于同一数据的读写操作与写写操作。但是有些冲突操作是<strong>可以交换次序</strong>的(non-conflicting swaps)，有些冲突操作<strong>不能交换次序</strong>(conflicting swaps)。</p>
<p>不能交换位置的次序为：   </p>
<ul>
<li>不同事务对同一个对象的冲突操作</li>
<li>同一事务对同一个对象的两个操作(如读写)</li>
</ul>
<p>定义冲突等价：</p>
<p>如果两个Schedule S1和S2 ， S1可以通过 non-conflicting swaps 转换成 S2的话，那么S1和S2就是冲突等价的</p>
<p>比如说, 现在有这样一个调度，我们将其分为四个色块，分别标记为A,B,C,D</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/8.png"></p>
<p>从块与块之间的角度来看，显然A和B是冲突操作，C和D是冲突操作，因为都涉及到不同事务修改同一个值。所以AB不能交换，CD不能交换</p>
<p>从块内角度分析：A内部$r_1(A)w_1(A)$ 是冲突的，因为这属于同一事务对同一个值的冲突操作。同理BCD也是这样，因此色块内部的顺序也不能调整</p>
<p>但是，我们可以打破块的束缚，从整体来看，下图绿色块跟青色块可以交换次序，因为这两个操作不冲突，不符合第三条的任意一种情况。</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/9.png"></p>
<p>再看新的绿色块与青色块，如果交换它俩也不会发生冲突：</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/10.png"></p>
<p>那么我们说，原调度和这些变化都是冲突等价的</p>
<h4 id="冲突可串行化"><a href="#冲突可串行化" class="headerlink" title="冲突可串行化"></a>冲突可串行化</h4><p>一个调度Schedule1在保证冲突操作次序不变的情况下，通过交换两个事务不冲突操作的次序得到另外一个调度Schedule2，如果Schedule2与串行化等价，那么称调度Schedule1是冲突可串行化的调度。同时称Schedule1和Schedule2是冲突等价的</p>
<p>我们还是拿刚才那个调度为例，经过了两次交换顺序之后, 经过了如下变化：</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/11.png"></p>
<p>最终结果是我们发现T1和T2被串行起来了，这和串行化是等价的。因此我们称原调度是冲突可串行化的</p>
<p>此外隔离等级还有Read Uncommitted，Read Commited， Repeatable Read 等</p>
<h4 id="冲突可串行化的性质"><a href="#冲突可串行化的性质" class="headerlink" title="冲突可串行化的性质"></a>冲突可串行化的性质</h4><p>然后我们要介绍冲突可串行化的一个性质：<strong>冲突可串行化永远是可串行化的</strong>. 因为如果调度是冲突可串行化的，那么必定可以通过交换non-conflicting operations的方法，得到一个新的调度，这个调度是串行化的。因此根据可串行化的定义，冲突可串行化也是可串行化的 </p>
<p>但是要注意，<strong>可串行化的调度，不一定是冲突可串行化的</strong>，我们来举一个例子：现在有三个事务如下</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/12.png"></p>
<p>有两个Schedule如下：其中S2是串行的调度</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/13.png"></p>
<p>显然，S1和S2最终达到的效果是一样的，因此S1是可串行化的。但是<strong>S1却不是冲突可串行化</strong>的。因为没有办法通过non-conflicts swap将S1转换为S2</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/14.png"></p>
<h3 id="Recoverble-Schedule"><a href="#Recoverble-Schedule" class="headerlink" title="Recoverble Schedule"></a>Recoverble Schedule</h3><p>可恢复的调度(<strong>recoverable schedule</strong>)：是指已提交的事务不应该发生回滚的调度。我们用一张图来说明：如果$T_k$需要读取T1、T2、T3的写，那么T1、T2、T3就需要在$T_k$之前提交。</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/15.png" style="zoom:67%;"></p>
<p>可恢复的调度分为以下几类：</p>
<ol>
<li>层联回滚(<strong>Cascading rollback</strong>)调度：未提交的事务从未提交的(失败)事务中读取了错误的数据（<strong>Dirty Read</strong> ），必须回滚。</li>
<li>无层联回滚的：事务只读取已提交事务写的数据(<strong>Read Commited</strong>)。</li>
<li>严格调度(<strong>Strict Schedule</strong>)：在写数据项的最后一个事务提交之后事务才能开始读/写该数据项。</li>
</ol>
<p>为什么要有这个概念呢？如果不是recovery的调度的话，一旦系统发生了故障，就无法恢复。试想，如果T1写了A，然后Tk读取了A，并先于T1提交了。那么假设在Tk提交到T1提交这个时间段出现了系统故障，那么当系统重启之后按道理来说需要回滚到T1写A之前，但是T1并没有提交，系统只会回滚到Tk读取A的那个状态。因此丢失了A原来的值。</p>
<h4 id="Read-Uncommitted"><a href="#Read-Uncommitted" class="headerlink" title="Read Uncommitted"></a>Read Uncommitted</h4><p>是最低级别的隔离等级。它什么都不会做，漏洞最多。会出现上面所说的所有问题。因为事务之间没有互相隔离，他们可以读取互相做出的未提交修改。<strong>在这种情况下不允许发生脏写</strong>，但是可能发生脏读、不可重复读、幻读。</p>
<h4 id="Read-Committed"><a href="#Read-Committed" class="headerlink" title="Read Committed."></a>Read Committed.</h4><p>当我们使用这个隔离级别时，事务只能读取已经提交了的数据。如果我们需要在事务中进行商务上的计算，我们的决定是基于有效的、已经提交的数据。事务运行之后有数据发生了变化，事务也不会去关注这个问题。这个隔离级别可以避免Dirty Read这个问题</p>
<h4 id="Repeatable-Read"><a href="#Repeatable-Read" class="headerlink" title="Repeatable Read:"></a>Repeatable Read:</h4><p>在这种级别下，读取的内容是可重复的，就算是数据被其他的事务修改了也没事。我们看到的只是第一次读取时就生成的快照。这个级别可以避免 Lost Updates, Dirty Reads 和 Non-repeating Reads这三个问题</p>
<h3 id="异常等级"><a href="#异常等级" class="headerlink" title="异常等级"></a>异常等级</h3><h4 id="Dirty-Writes"><a href="#Dirty-Writes" class="headerlink" title="Dirty Writes"></a>Dirty Writes</h4><p>两个事务在没提交的情况下去更新同一行数据的值</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/17.png" style="zoom:67%;"></p>
<p>我们对一条数据进行两次更新，一次更改洲名，一次更改积分，但是这样一来，如果B是后更新的，那么B中的数据会覆盖掉A中更新的数据，造成更新丢失。我们这时候就需要Locks来规避这种情况的发生，默认情况下，Mysql使用了锁定机制以防止两个事务同时更新相同的数据，他们在一个队列中，按照顺序进行。</p>
<h4 id="Dirty-Reads"><a href="#Dirty-Reads" class="headerlink" title="Dirty Reads"></a>Dirty Reads</h4><p>Dirty Reads 发生在事务读取还没有提交的数据时，比如下图。事务A想把顾客的分设置为20，在还没有提交的时候，事务B读取了表中更新过后的数据。如果每一分代表优惠一元，那么这位顾客可以优惠20元。但是事务A在提交前发生回滚。这时候事务B还没结束，所以事务B读取的数据是非法的。也就是说，在这种情况下，白给了顾客20元的优惠，因为事务B中读取了未提交的数据 。这就是 Dirty Reads，很形象。因为我们读取了污染的数据。 </p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/18.png" style="zoom:67%;"></p>
<p>为了解决这个问题，我们需要围绕事务提供一定程度的隔离度。所以事务修改的数据并不会立刻被其他事务读取到。为了规避这个问题，可以使用Read Committed及以上的隔离等级。</p>
<h4 id="Non-repeating-Reads"><a href="#Non-repeating-Reads" class="headerlink" title="Non-repeating Reads"></a>Non-repeating Reads</h4><p> 如果在事务进行过程中，我们读取了两次、得到了不一样的结果怎么办.比如下图。事务A中选择了数据表中一条值为10的信息，但是这时候，B把这条信息的数据改成了0，现在A中的子查询又想读取这条信息，发现这时候其值已经变成0了。对于这种不重复读取的异常，我们可以将隔离级别从 read committed（读已提交）提升到repeatable read（可重复读）。</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/19.png" style="zoom:67%;"></p>
<h4 id="Phantom-Reads"><a href="#Phantom-Reads" class="headerlink" title="Phantom Reads"></a>Phantom Reads</h4><p>假设有个事务A，我们查询了所有积分大于10的客户，发给他们额外的打折券。这时候，一个事务B修改了一位顾客甲，把他的分从0修改到了20。但这时候事务A已经完成查询，甲并不在查询结果当中。这就是我们说的Phantom Read，数据有时候会像幽灵一样突然冒出来。是否解决这个问题要看我们的业务、以及把这个客户纳入我们的事务中的重要性。</p>
<p>不可重复读和幻读区别：不可重复读的重点是修改；同样的条件，第1次和第2次读取的值不一样。幻读的重点在于新增或者删除；同样的条件， 第1次和第2次读出来的记录数不一样。从控制角度来看，不可重复读只需要锁住满足条件的记录，幻读要锁住满足条件及其相近的记录。</p>
<hr>
<p>事实上，隔离等级是根据异常等级的不同而划分的。我们可以用一张表来总结：</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/1.jpg" style="zoom:67%;"></p>
<h3 id="实现隔离级别"><a href="#实现隔离级别" class="headerlink" title="实现隔离级别"></a>实现隔离级别</h3><p>首先我们来介绍几种锁</p>
<ul>
<li><p>共享锁 shared lock (简称S锁) : 应用于所有读操作</p>
<ul>
<li>如果事务T1对数据对象O1加上了共享锁，那么当前事务只能对O1进行读取操作，其他事务也只能对这个数据对象加共享锁——直到该数据对象上的所有共享锁都被释放。</li>
<li>共享锁和排他锁最根本的区别在于，加上排他锁后，数据对象只对一个事务可见，而加上共享锁后，数据对所有事务都可见。</li>
</ul>
</li>
<li><p>排他锁 exclusive lock(简称X锁): 应用于所有写操作</p>
<ul>
<li>如果事务 T1对数据对象 O1加上了排他锁，那么在整个加锁期间，<strong>只允许事务 T1</strong>对 O1进行<strong>读取和更新</strong>操作，其他任何事务都不能再对这个数据对象进行任何类型的操作——直到T1释放了排他锁</li>
</ul>
</li>
<li><p>Short duration lock: 短锁，动作完成前申请，完成后立即释放锁</p>
</li>
<li>Long duration lock: 长锁, 动作完成前申请，直到Commit之后才会释放锁</li>
</ul>
<p>我们可以用锁来定义不同的隔离级别:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Consistency Level = Locking Isolation Levo</th>
<th>Read Locks on Data Items and Predicates</th>
<th>Write Locks on Data Item and Predicates</th>
</tr>
</thead>
<tbody>
<tr>
<td>Degree 0</td>
<td>没有要求</td>
<td>Well-formed Writes</td>
</tr>
<tr>
<td>Degree1  <br>READ UNCOMMITED</td>
<td>没有要求</td>
<td>Well-formed Writes<br> Long duration Write locks</td>
</tr>
<tr>
<td>Degree2   <br>READ COMMITED(读已提交)</td>
<td>Well-formed Reads<br>Short duration Read locks(both)</td>
<td>Well-formed Writes<br> Long duration Write locks</td>
</tr>
<tr>
<td>REPEATABLE READ(可重复读)</td>
<td>Well-formed Reads<br>Long duration <strong>data-item</strong> Read locks<br>Short duration Read Predicate  locks(both)</td>
<td>Well-formed Reads<br>Long duration Write locks</td>
</tr>
<tr>
<td>SERIALIZABLE(序列化)</td>
<td>Well-formed Reads<br>Long duration Read locks(both)</td>
<td>Well-formed Reads<br>Long duration Write locks</td>
</tr>
</tbody>
</table>
</div>
<h4 id="实现的原理"><a href="#实现的原理" class="headerlink" title="实现的原理"></a>实现的原理</h4><ul>
<li>READ UNCOMMITED: 事务在读数据的时候并未对数据加锁。事务在修改数据的时候只对数据增加行级共享锁。<ul>
<li>此时，事务1读取某行记录的时候，事务2也可以对这行数据进行读取、更新(因为事务1未加锁)</li>
<li>事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。（因为事务一对数据增加了共享读锁，事务二不能增加排他写锁进行数据的修改）。因此，可以避免脏写的情况。</li>
<li>当事务2对该记录进行更新时，事务1再次读取该记录，能读到事务2对该记录的修改版本（因为事务二只增加了共享读锁，事务一可以再增加共享读锁读取数据），即使该修改尚未被提交。但是，无法避免脏读、重复读、幻读的情况，因为它对读操作并没有上锁。</li>
</ul>
</li>
<li>READ COMMITED: 事务对当前被读取的数据加<strong>行级共享锁(当读到时才加锁)</strong>，一旦读完该行，立即释放该行级共享锁，(短锁)；事务在更新某数据的瞬间(就是发生更新的瞬间），必须先对其加 行级排他锁(长锁)，直到事务结束才释放。<ul>
<li>脏读发生的环境是，事务A修改了一个变量，另一个事务B刚好读取了这个变量，但事务A还没有提交的时候，就发生了回滚。因此B读取到了一个脏的数据(还没持久化的数据)。当使用READ COMMITED隔离级别的时候，在更新数据的时候加上了排它锁，因此在事务B读取特定变量的时候，无法对数据加读共享锁。事务B只能等待事务A的写操作提交以后，或者事务A回滚以后，释放了排它锁，才能读取该变量的值。</li>
<li>但此时，由于是对读操作上了短共享锁，读取完成后立即释放。试想一下这个情景，事务A需要读取一个x的值10，读取完后释放锁，但事务A还没有结束，去忙别的事情了。这时候，事务B对x进行了更新，将其改为了20并提交了。那么，当事务A再次去读取x的时候，发现变成了20。这就是<strong>不可重复读错误</strong></li>
<li>再来思考一个场景，事务A筛选出积分大于10的客户，并要对其发送优惠券。此时x的积分为0，不属于A的筛选范畴，因此事务A不需要对x上锁。但是，这时候事务B修改了x的积分，到20，并成功提交。那么这时候，事务A还没结束，但是其筛选出来的值与真实的数目不符。因此，幻读还是没有办法避免的。</li>
</ul>
</li>
<li>REPEATABLE READ: 事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 行级共享锁，直到事务结束才释放(长锁)；事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放(长锁)。<ul>
<li>此时来看不可重复读，当事务A开始读取变量x的时候，会对其上长共享锁，直到事务提交才会释放。那么这时候，如果B尝试对x进行更新的话，需要获取对x的排它锁,这是不被允许的。因此只有当事务A执行结束之后，事务B才可以修改x的值。</li>
<li>但是来看幻读，当事务A只会对某一行上长共享锁，并不会对整张表上长共享锁。因此，如果事务A一开始没有选中对象x，那么也不会对其上锁，还是会蹦出来新的数据。因此也不能避免幻读的发生</li>
</ul>
</li>
<li>SERIALIZABLE：事务在读取数据时，必须先对其加 表级共享锁 ，直到事务结束才释放；事务在更新数据时，必须先对其加 表级排他锁 ，直到事务结束才释放。<ul>
<li>此时，当对一张表进行读取的时候，会对读取的所有内容上长锁(共享锁)，因此事务B如果要对表中的内容进行修改，必须等事务A先提交以后，才可以获取排它锁并进行修改，因此也不会有新的内容产生、避免了幻读。</li>
<li>这种序列化隔离条件，对并发性能的影响是很大的</li>
</ul>
</li>
</ul>
<h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p>下面的调度至高是在那种隔离级别下产生的调度？</p>
<p><code>R1(x)W2(x)C2 W1(x)C1</code></p>
<p>首先，不可能是Repeated Read,因为这种情况会给读操作上长锁，需要提交后才会释放锁，因此不可能在 R1(x)之后就发生W2(x)</p>
<p>那么可能是Read Commited吗? 在R1(x)处读上了短读锁，释放后在W2(x)上了一个长写锁，在C2结束后释放。然后在W1(x)处上了长写锁，在C1结束后释放。因此，Read Commited是可能发生的</p>
<h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><h3 id="2PL"><a href="#2PL" class="headerlink" title="2PL"></a>2PL</h3><p>参考： <a href="https://zhuanlan.zhihu.com/p/480379228" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/480379228</a></p>
<h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>在事务并发的时候，我们需要找到一种机制来实现事务的冲突可串行化。那么2PL就是这样一种机制。它属于“悲观锁”，因为这个策略的核心就是：一个事务中，在拿到所有锁之前，不能释放锁。</p>
<p>一个朴素的加锁的方法如下：</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/2.jpg"></p>
<p>流程如下：</p>
<ol>
<li>在事务$T1$ 访问A之前，先通过DBMS的锁管理器（Lock Manager）获取A的锁并且注册（记录下来“A的锁当前归T1所有”）</li>
<li>事务T2想访问A，于是也要获得A的锁，锁管理器便会<strong>拒绝</strong>它的请求，T2之后便阻塞在这里</li>
<li>直到T1完成了对A的全部操作后通过锁管理器释放A的锁，T2才可以通过锁管理器获取A的锁，并且完成对A的全部操作后释放A的锁</li>
</ol>
<h4 id="Locks-Type"><a href="#Locks-Type" class="headerlink" title="Locks Type"></a>Locks Type</h4><p>事实上，数据库中有两种保护数据的方式： Locks 和 Latches 。</p>
<p>Latches 就是大家在学习多线程编程时接触到的锁，如 <code>mutex</code>、<code>rwlock</code>、<code>semaphore</code>、<code>spinlock</code>。用来做<strong>线程之间</strong>的并发控制。</p>
<p>数据库中的 locks 一般是指行锁、范围锁、表锁这些。用来做<strong>事务之间</strong>的并发控制。它保护的不是具体的数据结构，而是数据库的抽象的内容，比如说向锁管理器申请的可以是对数据库的表的某一行的锁，这个锁会保护涉及这一行的所有的索引里面关于这一行的部分</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>Locks</th>
<th>Latches</th>
</tr>
</thead>
<tbody>
<tr>
<td>Separate</td>
<td>User Transactions(用来隔离事务)</td>
<td>Threads(用来线程并发)</td>
</tr>
<tr>
<td>Protect</td>
<td>Database Contents(数据库中持久化的内容)</td>
<td>In-Memory Data Structures(内存中的数据结构)</td>
</tr>
<tr>
<td>During</td>
<td>Entire Transactions</td>
<td>Critical Sections</td>
</tr>
<tr>
<td>Modes</td>
<td>Shared(共享锁), Exclusive(排他锁)</td>
<td>Read(读锁)，Write(写锁)</td>
</tr>
<tr>
<td>Deadlock</td>
<td>Detection &amp; Resolution</td>
<td>Avoidance</td>
</tr>
<tr>
<td>死锁解决方式</td>
<td>Waits-For, Time out, Aborts</td>
<td>Coding Discipline</td>
</tr>
<tr>
<td>Kept in..</td>
<td>Lock Manager</td>
<td>Protected Data Structure</td>
</tr>
</tbody>
</table>
</div>
<p>我们在数据库中，主要用的是Lock，之前也说了Lock分为共享锁和排他锁两种：</p>
<ul>
<li>S-Lock : Shared locks for reads , 和Latch中的读锁差不多</li>
<li>X-Lock : Exclusive locks for writes ，和Latch中的写锁差不多</li>
</ul>
<p>在带有Lock的情况下，事务的执行过程如下：</p>
<ul>
<li>事务获取对应的锁</li>
<li>锁管理器(Lock Manager) 授权或者阻塞事务</li>
<li>事务释放锁</li>
</ul>
<p>其中，LM内部有数据结构，记录着一张锁的表格，包括什么事务在用这个锁，是什么类型的锁，什么事务在等待用这个锁</p>
<p>以下场景就是用了 X/S 这两种锁，分别用来做A的读写操作：</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/3.jpg"></p>
<p>但是仅仅通过加锁，能将原本不可串行化的执行调度的执行结果变正确吗？我们看到，在T1释放了锁以后，T2立马得到了X锁并对A进行修改，解这 T1再次获取S锁、读取A的时候，就会发现这个A并不是它最后修改的A。</p>
<p>这就是发生了不可重复读的错误。因此，后来的DBMS方面的学者专家们就在此之上进行改进，提出了两阶段锁来实现并发控制</p>
<h4 id="Two-Phase-Locking"><a href="#Two-Phase-Locking" class="headerlink" title="Two-Phase Locking"></a>Two-Phase Locking</h4><p>两阶段所是一个并发控制协议，它规定了一个事务在运行的过程中如何跟其他事务之间协调锁，从而实现可串行化。使用两阶段锁<strong>不需要提前知道</strong>完整的执行调度，它会在调度进行的过程中避免不可串行化的情况发生</p>
<p>两阶段锁，顾名思义有两个阶段：</p>
<ul>
<li>增长阶段( Growing )<ul>
<li>在这个阶段，每个事务都只能不断的从LM那边获得锁，不能释放锁</li>
<li>LM可以根据情况给事务所需要的锁，或者阻塞事务(不给锁)</li>
</ul>
</li>
<li>缩小阶段 ( Shrinking )<ul>
<li>在这个阶段事务只能释放它之前拥有的锁，并且不能再获取新的锁</li>
</ul>
</li>
</ul>
<p>因此，在一个事务的生命周期里，它所持有的锁的数量的变化趋势如下所示，最后所有获取过的锁都被释放之后，会提交事务(Commit)</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/4.jpg"></p>
<p>使用二阶段锁便可以使得不可串行化的执行调度的最终执行结果具有一致性，如下所示，在两阶段锁协议下，事务T1执行完<code>W(A)</code>后并不会立即释放A的锁，因为二阶段锁协议的规定就是“先一直获取各个锁，然后把所有获取的锁逐个释放”，直到<code>R(A)</code>执行完了之后T1才会释放锁（如果按照之前的策略，先获取X-Lock，再释放X-Lock，然后再获取S-Lock，之后再释放S-Lock，这就违反了两阶段锁的协议）</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/5.jpg"></p>
<p>与此同时，在事务T1释放A的锁之前，事务T2获取A的锁的操作会被一直阻塞，直到T1把A的锁释放</p>
<p>在使用了二阶段锁协议后，相应的执行调度对应的依赖图（Dependency Graph）一定没有环，二阶段锁可以严格地保证冲突可串行化</p>
<h5 id="级联回滚"><a href="#级联回滚" class="headerlink" title="级联回滚"></a>级联回滚</h5><p>但是二阶段锁也有一些问题：级联回滚（Cascading Aborts）</p>
<p>如下所示，T1释放锁之后，T2事务开始被执行，T2对A的操作是基于T1对A进行临时修改后的版本进行的，如果T1事务没有提交而是被abort了，那么T2必须跟着T1一起回滚（如果T2进行的是读操作，那么这也被称为脏读，”dirty reads”）</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/6.jpg"></p>
<p>级联回滚本质上的原因是T2事务在T1事务更新得到的临时版本的数据上进行了操作，那我们可以通过一些手段让T2不在T1修改得到的临时版本上进行操作：</p>
<ul>
<li>可以让事务先获取各个需要获取的锁，等到它commit的时候，再一次性将这些锁释放掉，这样的话，T2就不可能再临时版本上进行操作。因为T2能获得锁并执行事务的时候，它所访问的一些数据已经被提交并持久化了。</li>
</ul>
<p>因此，这个方法也叫做严格二阶段锁(Strong Strict 2PL,简称 SS2PL) </p>
<p>再严格二阶段锁协议下，事务所持有锁的数量变化，如下所示：</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/7.jpg"></p>
<p>严格二阶段所协议的特点是事务所修改的数据在事务结束之前，其他事务都不能读写，这个协议的<strong>好处就是不会产生级联回滚</strong>。而且事务可能对数据进行了很多次更新，但在严格二阶段锁协议下，需要回滚时，直接回滚到事务开始时即可，不用管它进行过多少次更新，因为这个事务在进行数据更新时，<strong>绝对不会有其他的事务也在更新共享的数据</strong></p>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>举个例子： 事务T1是A给B转账100，事务T2是计算A和B的账户余额的和</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/46.png"></p>
<ul>
<li>如果完全不适用二阶段锁，那么可能出现不一致的情况：</li>
</ul>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/8.jpg"></p>
<ul>
<li>如果使用二阶段锁协议</li>
</ul>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/9.jpg"></p>
<p>那就可以保证一致性，等效成T1事务先执行，然后T2事务执行，即冲突可串行化。但存在潜在的级联回滚问题</p>
<ul>
<li>如果使用了严格二阶段锁协议，如下所示，既可以保证一致性，也可以避免级联回滚</li>
</ul>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/10.jpg"></p>
<h5 id="Venn图总结"><a href="#Venn图总结" class="headerlink" title="Venn图总结"></a>Venn图总结</h5><p>我们可以将 <strong>视图可串行化, 冲突可串行化 , 严格二阶段锁 , 序列化 ,级联回滚</strong> 这几个概念组成一个Venn图</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/27.jpg"></p>
<p>在全部可能发生的执行调度里, 事务串行执行是很小的子集，冲突可串行化的执行调度是更大的子集，视图可串行化的执行调度对应还要再大一点的子集</p>
<h3 id="TO"><a href="#TO" class="headerlink" title="TO"></a>TO</h3><p>TO(Timestamp Ordering)</p>
<h3 id="OCC"><a href="#OCC" class="headerlink" title="OCC"></a>OCC</h3><p>OCC(Optimistic Concurrency Control) 是事务的乐观并发控制，乐观是说冲突没那么容易产生，因此只在事务要提交的时候去检测冲突。现在有很多内存数据库中采用这种机制，因为数据所有的操作都在内存里完成，事务的运行时间会缩短，因此出错的概率也会变小。从理论上来说，内存数据库中最佳的并发控制策略就是OCC。但是OCC也存在一些问题，比如说事务会经常重启(遇到错误时)，很多事务会一直达不到结束的条件，导致无法完成。</p>
<h4 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h4><p>OCC的基本思路是：每个事务会产生一个私有空间，并在里面维护事务中的读写集合。在事务提交的时候，验证读写集合是否与其他事务冲突，如果没有，则将写集合应用于数据;否则就把事务abort掉，再重做</p>
<p>另外，OCC为每个事务分配了一个时间戳，反映了事务的可串行化顺序，以方便验证</p>
<h4 id="OCC的三个阶段"><a href="#OCC的三个阶段" class="headerlink" title="OCC的三个阶段"></a>OCC的三个阶段</h4><ul>
<li>读阶段<ul>
<li>执行事务，并在事务的私有空间生成事务的读写集合</li>
</ul>
</li>
<li>验证阶段<ul>
<li>提交之前，通过读写集合验证是否有冲突。这是整个策略的重点</li>
</ul>
</li>
<li>写阶段<ul>
<li>将写集合应用到数据，commit or abort</li>
</ul>
</li>
</ul>
<h4 id="OCC例子"><a href="#OCC例子" class="headerlink" title="OCC例子"></a>OCC例子</h4><h5 id="读阶段"><a href="#读阶段" class="headerlink" title="读阶段"></a>读阶段</h5><p>读阶段生成读集合。 此时所有事务都是并发的</p>
<ul>
<li>T1 有两步： <code>T1.ReadSet={A}，T1.WriteSet={A}</code></li>
<li>T2有一步：<code>T2.ReadSet={A}</code></li>
</ul>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/36.png"></p>
<h5 id="验证阶段"><a href="#验证阶段" class="headerlink" title="验证阶段"></a>验证阶段</h5><p>在最原始的OCC中，<strong>只有读阶段是并发的</strong>，验证阶段和写阶段是阻塞的，因此当一个事务在验证或者写的时候，另外的事务是无法运作的。现在有些研究速度更快、并行度更高的验证规则。</p>
<p>一般来说，现在都会在验证阶段给事务分配时间戳，如下：</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/37.png"></p>
<p>验证阶段的目标就是要保证事务的可串行化，即Ti需要和其他事务是否有读写冲突和写写冲突。</p>
<p>在验证的时候主要要关注三个时间点：事务开始(读阶段)时间、事务结束(写阶段)时间，验证阶段开始时间。由于…导致会有不同情况的出现，接下来我们来介绍几种在满足<code>Ti&lt;Tj</code>之后可以提交事务Ti的情况</p>
<h5 id="Case1"><a href="#Case1" class="headerlink" title="Case1"></a>Case1</h5><ul>
<li>要求：Ti在Tj事务开始之前完成写阶段</li>
</ul>
<p>这很容易理解，时间戳示意图如下：</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/39.png"></p>
<p>事务调度顺序如下：</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/38.png"></p>
<p>这很容易理解，此时Ti和Tj是没有冲突的</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/39.png"></p>
<h5 id="Case2"><a href="#Case2" class="headerlink" title="Case2"></a>Case2</h5><ul>
<li>要求： $T_i$ 在 $T_j$的验证阶段开始前完成写阶段， 并且 $\text{WriteSet}(T_i)\cap \text{ReadSet}(T_j)=\empty$ </li>
</ul>
<p>第二种情况，相当于在Case1的基础上，将 <code>tj</code>事务左移了一段距离，如下：</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/40.png"></p>
<p>注意，Ti的写集合和Tj的读集合的交集必须为空，否则会发生读写冲突。如下所示：我们看到，T1还没有提交关于B的修改，T2就开始读取B了，这时候就不是可串行化了。</p>
<p>那么有人要问了，如果T1的写集合是A，且在T1提交时T2才刚好读取A，看起来不会有问题，可行吗？其实这种也会被abort掉，因为毕竟是小概率事件，为了方便都会中止事务</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/41.png"></p>
<h5 id="Case3"><a href="#Case3" class="headerlink" title="Case3"></a>Case3</h5><ul>
<li>要求：$T_i $在$T_j$的读阶段结束前开始验证阶段， 并且<ul>
<li>$\text{WriteSet}(T_i)\cap \text{ReadSet}(T_j)=\empty$ </li>
<li>$\text{WriteSet}(T_i)\cap \text{WriteSet}(T_j)=\empty$ </li>
</ul>
</li>
</ul>
<p>示意图如下：</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/42.png"></p>
<p>第一个条件可以理解，和case 2是一样的，那么为什么要满足第二个条件呢？</p>
<p>因为如果两个事务的写集合发生重复，而且二者的写阶段也是可能发生重叠的，因此这个要求是为了避免写覆盖的发生。</p>
<h4 id="OCC基本实现"><a href="#OCC基本实现" class="headerlink" title="OCC基本实现"></a>OCC基本实现</h4><p>事实上，在设计OCC的时候我们设计了 验证阶段+写阶段的临界区</p>
<ul>
<li>在临界区中，只能让一个事务的读阶段去和另外一个事务的读/写阶段去并行。</li>
<li>因为临界区只能允许一个事务进入，因此所有事物之间的验证阶段和写阶段是互斥的</li>
<li>因此，Case3实际不会出现</li>
</ul>
<p>总结一下Case1和Case2：</p>
<ul>
<li>Case1: <code>Finish(Ti)&lt;Start(Tj)</code></li>
<li>Case2: <code>Start(Tj)&lt;Finish(Ti)&lt;Validation(Tj)</code> ,且对$T_j$的读集合，需要验证他和所有满足上面范围的$T_i$的写集合是否有交集，这样就意味着只需要维护每个事物的写集合即可。<ul>
<li>这里不用写集合去和别人的读集合做验证的原因是，维护读集合的难度要比维护写集合要大得多</li>
</ul>
</li>
</ul>
<p>思考算法是如何巧妙利用时间戳实现Case1 和Case2的？</p>
<ul>
<li>Case1， 事务开始获得当前时间戳<code>start tn</code>，在 比较时从<code>start tn+1</code>开始的事务去验证，因为 start tn之前的事务已经完成。</li>
<li>Case2， 事务再次获取当前时间戳<code>finish tn</code>, 因此所有在<code>start tn</code>与<code>finish tn</code>之间提交的事务都是满足 case2的。</li>
</ul>
<p>伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">thegin = &#123;</span><br><span class="line">	create <span class="built_in">set</span> := empty;</span><br><span class="line">	<span class="built_in">read</span> <span class="built_in">set</span> := empty;</span><br><span class="line">	<span class="built_in">write</span> <span class="built_in">set</span> := empty;</span><br><span class="line">	<span class="keyword">delete</span> <span class="built_in">set</span> := empty;</span><br><span class="line">	start tn := tnc <span class="comment">//tnc是一个单调递增公共时间戳，事务一开始时就获取</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 临界区</span></span><br><span class="line">tend = &#123;</span><br><span class="line">		&lt; finish tn := tnc;</span><br><span class="line">			valid := <span class="literal">true</span>;</span><br><span class="line">			<span class="comment">// 满足case2的条件的事务t(当前事务开始到上个事务结束这段时间)</span></span><br><span class="line">			<span class="keyword">for</span> t from start tn+<span class="number">1</span> to finish tn <span class="keyword">do</span></span><br><span class="line">			<span class="comment">// 这边用当前事务的读集合去和满足条件的t的写集合去做检查，即case2</span></span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">write</span> <span class="built_in">set</span> of transaction with transaction number t intersects <span class="built_in">read</span> <span class="built_in">set</span>)</span><br><span class="line">						then valid := <span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">if</span> valid</span><br><span class="line">					then((<span class="built_in">write</span> phase); tnc := tnc + <span class="number">1</span>; tn = tnc)&gt;;</span><br><span class="line">					</span><br><span class="line">				<span class="keyword">if</span> valid</span><br><span class="line">						then (clean up);</span><br><span class="line">				<span class="keyword">else</span> (backup)</span><br><span class="line">				</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h3><p>多版本是指：对某一数据项，数据库中存储其多个不同时间点上的状态(一次修改看做是一次状态)。不同的状态存储在链上</p>
<ul>
<li>每次写操作，创造一个新的版本</li>
<li>每个读操作，通常事务开始时获取一个版本，读取小于等于该版本的最新数据，因此可以避免不可重复读的错误</li>
</ul>
<p>多版本能实现读写分离(优点)：</p>
<ul>
<li>读不阻塞写</li>
<li>写不阻塞读</li>
</ul>
<h4 id="SnapShot-Isolation"><a href="#SnapShot-Isolation" class="headerlink" title="SnapShot Isolation"></a>SnapShot Isolation</h4><p>SI既是一种实现，也是一种隔离级别(快照隔离级别)，为什么是快照？因为SnapShot读取的是数据库中的旧版本</p>
<p>SI流程如下：</p>
<ul>
<li>事务开始:<ul>
<li>– Get snapshot  定义快照时间点</li>
</ul>
</li>
<li>事务执行: <ul>
<li>Reads from snapshot 从快照中读取</li>
<li>Writes to private workspace </li>
</ul>
</li>
<li>事务提交:<ul>
<li>Check for write-write conflicts <ul>
<li>如果有abort到只有一个事务提交 </li>
</ul>
</li>
<li>Install updates</li>
</ul>
</li>
</ul>
<h4 id="例子：SI的版本变化"><a href="#例子：SI的版本变化" class="headerlink" title="例子：SI的版本变化"></a>例子：SI的版本变化</h4><p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/44.png"></p>
<p>如上图，已知有三个提交: Commit T1,T2,T3，每次都会生成一个时间戳</p>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>首先，我们先学习ACID与日志的关系——ACID那些性质与日志存在关系呢？显然是原子性和持久性 </p>
<p>从单机数据库角度来说，需要使用日志的地方有很多——各种故障</p>
<ul>
<li>存储介质故障</li>
<li>灾难性故障</li>
<li>系统故障<ul>
<li>断电</li>
<li>软件中止</li>
<li>操作系统中止</li>
</ul>
</li>
</ul>
<p>不管是什么故障，有日志的存在，就能是数据库恢复到一致的状态，已经提交的事务就是持久化了,还没有提交的事务需要回滚</p>
<h3 id="缓冲区策略与日志的关系"><a href="#缓冲区策略与日志的关系" class="headerlink" title="缓冲区策略与日志的关系"></a>缓冲区策略与日志的关系</h3><p>之前我们学过数据库中有个缓冲区，还写了一个BPManager的程序来进行lru调度。</p>
<p>现在我们来讨论一下事务、脏页、日志三者之间的关系，来看下图</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/16.png" style="zoom:67%;"></p>
<ul>
<li>Steal: 允许未提交事务刷入磁盘</li>
<li>Force: 只有事务的所有数据都刷入磁盘，事务才能提交</li>
</ul>
<h4 id="Steal-No-Steal"><a href="#Steal-No-Steal" class="headerlink" title="Steal/ No-Steal"></a>Steal/ No-Steal</h4><p>现在来定义 No-Steal 策略，No-Steal是说在事务提交之前，页面不能被写入磁盘。这去报了我们不会让数据库处于一个中间状态——因为如果该事务没有完成，那么它的任何变化也不应该被持久化。但这个策略的缺陷在于它束缚了我们使用内存的方式，我们必须把每个脏页保留下来，直到一个事务完成——可能会占用大量内存空间</p>
<p>因此我们提出Steal策略，即允许在事务完成之前将修改过后的脏页写回到磁盘上。</p>
<p>Steal的例子如下，我们看到，在把A从100改为90的之后，还未提交就把A刷入了磁盘。就好像偷偷摸摸的把页给写到磁盘里去了 </p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/20.jpg" style="zoom:67%;"></p>
<p>那么显然这种方法是有问题的，比如在这里修改了A，然后直接把A写回磁盘，这时候突然发生了系统故障。由于B还没有被修改，因此数据库需要回滚到A被修改前的状态。因此，这里需要用到Undo日志，记录修改前的状态。</p>
<h4 id="Force-No-Force"><a href="#Force-No-Force" class="headerlink" title="Force/No Force"></a>Force/No Force</h4><p>force是说在事务提交前<strong>强制所有修改过的数据页到磁盘</strong>， 这将确保耐久性。但是这种方法的缺点是性能不足，最终我们会做很多不必要的写操作。</p>
<p>因此No Force策略更加常用。这种策略是说，<strong>只在脏页要被从缓冲区删除的时候再写回磁盘</strong>。这样可以减少不必要的写入，但它是的数据库的持久性变得复杂。因为可能出现没有把脏页全刷回磁盘的情况，发生故障之后可能会导致数据丢失，因此需要Redo日志。</p>
<p>也就是说，<strong>日志需要记录修改后的值</strong>，这样一旦发生故障，可以通过Redo日志将数据库改为日志提交过后的状态，体现了数据库的持久性。</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/22.png" style="zoom:67%;"></p>
<p>再回到上面那个四宫格，我们看到Force+No Steal策略是最方便的，最容易实现的。但是我们还是选择NoForce+Steal策略，虽然仅用这个策略无法满足持久性和原子性，但是可以获得最好的功能。至于如何实现原子性和持久性，我们就需要靠undo+redo日志来帮忙了</p>
<h3 id="WAL日志"><a href="#WAL日志" class="headerlink" title="WAL日志"></a>WAL日志</h3><p>先写日志 WAL(write-ahead logging)，做一个操作之前先讲这件事情。</p>
<ol>
<li>将对数据库的修改记录在单独的存储空间中（日志缓冲区） 日志缓冲区和数据缓冲区是两回事</li>
<li>日志只支持追加操作（顺序I/O）</li>
<li>修改的数据对象持久化之前，需要保证其对应的修改已记录在日志文件中(WAL)</li>
<li>日志落盘后事务即可提交 S2PL释放锁的时间呢？</li>
</ol>
<p>日志生成的主要步骤：</p>
<ul>
<li><p>生成日志 </p>
</li>
<li><p>在缓冲区中占位（生成LSN） </p>
</li>
<li><p>刷盘</p>
<ul>
<li>注意，在日志刷盘阶段，需要一组一组提交，因为每条日志刷盘的I/O代价比较高。因此需要多个事务的日志一起按批次刷盘。这样会减少I/O次数</li>
<li><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/24.png" style="zoom:67%;"></li>
</ul>
</li>
</ul>
<ul>
<li>事务提交(可以理解为返回客户端，事务修改 对外部可见)</li>
</ul>
<h4 id="WAL实现"><a href="#WAL实现" class="headerlink" title="WAL实现"></a>WAL实现</h4><p>Redo引申出了WAL，即事务日志会在COMMIT或COMMIT之前写入持久化存储中，然后事务对数据本身的修改才能生效。因此就能够保证在系统故障时可以通过读取Redo日志来实现持久化操作(数据恢复)。<br>因此对于最终用户可以显示事务已经提交而暂时不用将所修改的数据写入持久化存储。由于数据在日志未写入持久化存储之前数据无法持久化，则需要更大的主存作为BUFFER空间，这就是为什么Redo的内存开销更大。</p>
<p>为了实现 WAL策略，我们需要在日志记录中添加一个字段——LSN。它代表了日志序列号，LSN是一个唯一的递增的数字，它有助于标志着操作的顺序(如果你看到一条LSN=20的日志记录，那么该操作一定是发生在LSN=10的记录之后的)。我们还将为每条日志记录添加一个<strong>prevLSN</strong>字段，该字段存储了同一事务的最后一次操作，这对撤销一个交易来说是很有用的。</p>
<p>数据库还将跟踪存储在RAM中的flushedLSN。flushedLSN追踪最后一条被刷入磁盘的日志记录的LSN，它意味着该页已经被写入磁盘，也意味着在内存中我们不再需要这个页了。</p>
<p>我们还将为<strong>每个数据页</strong>添加一段元数据，称为pageLSN。pageLSN 存储了最后修改该页的操作的LSN。我们将用它来告诉我们哪些操作的操作，以及哪些操作必须重做。</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/23.png" style="zoom:67%;"></p>
<h3 id="ARIES-Recovery-Algorithm"><a href="#ARIES-Recovery-Algorithm" class="headerlink" title="ARIES Recovery Algorithm"></a>ARIES Recovery Algorithm</h3><p>当数据库系统崩溃之后，我们只能获得数据库写到磁盘中去的数据页和日志。在重启之后，我们要对数据库进行恢复，达到两个目标：</p>
<ul>
<li>所有已经提交的事务，都要恢复到提交事务之后的状态(持久性)</li>
<li>所有未提交的事务，都要恢复到事务执行之前的状态(原子性)</li>
</ul>
<p>这个算法就是说在No Force和Steal的情况下，如何将数据库日志恢复到上面两个状态.这个算法主要分为三个阶段：</p>
<ol>
<li><p>Analysis Phase: 重新构建 transaction table 和 DPT</p>
</li>
<li><p>Redo Phase: 重复提交后却未写回的操作，以实现持久性</p>
</li>
<li>Undo Phase：撤销未提交但已写回的事务操作，以保证事务的持久性</li>
</ol>
<p>首先我们来说说 transaction table 和 DPT是什么：</p>
<h4 id="transaction-table"><a href="#transaction-table" class="headerlink" title="transaction table"></a>transaction table</h4><p>Transaction table 记录了活跃的事务的相关信息，它有三个字段。活跃事务表示用来做undo的，因为</p>
<ul>
<li>XID: 事务 ID</li>
<li>status: either running, committing, or aborting</li>
<li>lastLSN: the LSN of the most recent operation for this transaction</li>
</ul>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/25.jpg"></p>
<h4 id="Dirty-Page-Table-DPT"><a href="#Dirty-Page-Table-DPT" class="headerlink" title="Dirty Page Table (DPT)"></a>Dirty Page Table (DPT)</h4><p>DPT记录了那些页是脏页(被修改过后的), 它有两个字段。脏页表主要是用来做Redo的</p>
<ul>
<li><p>Page ID</p>
</li>
<li><p>recLSN: 第一个产生这个脏页的LSN</p>
</li>
</ul>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/26.jpg"></p>
<h4 id="Analyse-phase"><a href="#Analyse-phase" class="headerlink" title="Analyse phase"></a>Analyse phase</h4><p>Analyse phase 就是把系统crush的那一瞬间的两张表给重构出来。为了实现这个操作，我们需要扫描所有的日志记录。下面是遇到各种日志的处理方法</p>
<ul>
<li>任何只要不是END的记录，就说明该事务尚未结束，就需要将其加入到transaction Table中，同时设置LSN为当前记录的LSN</li>
<li>如果该记录是COMMIT或者是ABORT，那么就修改相应transaction在transaction Table中的记录(修改状态)</li>
<li>如果该记录是UPDATE，而且日志中对应的页不再DPT当中，说明发现了一个新的脏页。那么就要把这页加到DPT中并设置recLSN=该日志的LSN</li>
<li>如果该记录是END，那就从transaction表中删除该事务</li>
</ul>
<p>在Analyse phase的最后阶段，对于任何正在COMMIT的事务，他只是在等待提交罢了，对数据的修改、更新操作都已经做完了(相当于END)，因此我们需要把 END记录到日志中，并从transaction表中删除该事务。最终只会让ABORT或者RUNNING的事务留在transaction表中</p>
<p>如果我们按照上面的操作，老老实实得把数据库日志从头到尾扫描一遍，显然这样的性能很低，不切实际。因此我们可以用到checkpoint，它像一个快照一样，每隔一段时间会把transaction Table和DPT记录在日志中。</p>
<p>我们来举一个例子:</p>
<p>下面这张图是我们要恢复数据库时从磁盘中提出来的数据，左侧是日志，看到LSN50是Begin Checkpoint，说明在这一时刻开始形成一个快照，LSN50之前的transaction Table和DPT都会保存下来。检查点在LSN80处生成结束。</p>
<p>右侧就是从检查点提出的transaction Table和DPT，但是这两张表记录的信息是不全的，我们要从LSN60处开始复原重构两张表</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/27.png"></p>
<ol>
<li>首先，我们从LSN60开始构建，它记录了T3事务对P3页进行了update。因为P3已经在DPT中，因此不用改。但是它更新了transaction Table中的T3记录，需要将字段lastLSN改为当前LSN（即60)</li>
</ol>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/28.png"></p>
<ol>
<li>LSN70是 T3的 Aborts，因此修改 transaction Table中的T3记录，将Status改为Aborts即可</li>
</ol>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/29.png"></p>
<ol>
<li>LSN90是也是一条动作，就是把T3 Update P3给撤销了，因此需要更新transaction Table中的T3记录，将lastLSN改为90</li>
</ol>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/30.png"></p>
<ol>
<li>LSN100是T1事务对P4页做的Update操作，DPT中没有P1，因此需要把P4加入DPT；同时要更新transaction  Table的T1记录，将lastLSN更新为100</li>
</ol>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/31.png"></p>
<ol>
<li>LSN110是T1事务的提交，因此更新transaction Table T1记录，将Status改为 Committing</li>
</ol>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/32.png"></p>
<ol>
<li>LSN120是T1事务的结束，因此可以从transaction Table中删除T1记录</li>
</ol>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/33.png"></p>
<h4 id="Redo-phase"><a href="#Redo-phase" class="headerlink" title="Redo phase"></a>Redo phase</h4><p>Redo phase使用来保证持久化的，我们从DPT中最小的recLSN记录开始，因为那是时可能还没有进行第一个刷盘的操作。</p>
<p>我们将会redo所有的Update操作和CLR操作 ，如果某一个LSN符合下面三条中的一条，那么就跳过：</p>
<ul>
<li>该页不再DPT中，意味着所有对该页修改都已经持久化到磁盘了</li>
<li>如果 recLSN &gt; LSN， 因为正常情况下LSN是大于等于 recLSN的，如果recLSN &gt; LSN,说明污染该页的第一个动作要比当前的LSN发生的更晚，因次当前LSN并不需要被redo</li>
<li>pageLSN(disk) &gt;= LSN, 因为pageLSN记录了最后修改该页的操作日志，如果大于LSN的话，那说明并不需要redo当前的LSN</li>
</ul>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/34.png"></p>
<p>现在复原了两张表，transaction Table是要做Undo操作的，DPT是要做Redo的。</p>
<p>那么，应该从哪里开始恢复操作呢？DPT中最小的recLSN是 10，因此我们从LSN10开始看。</p>
<ul>
<li>LSN10 : 更新 P3</li>
<li>LSN20 ：P1.recLSN=40 &gt; 20, 跳过</li>
<li>LSN30: Page2不再DPT中，因此跳过</li>
<li>LSN40: P1.recLSN=40 = 40 , 执行update p1操作</li>
<li>LSN50: 跳过</li>
<li>LSN60：符合条件，更新P3</li>
<li>LSN70: 只redo Update操作和CLR操作</li>
<li>LSN80: 跳过</li>
<li>LSN90: 执行CLR操作</li>
<li>LSN100: P4.recLSN=100==LSN,因此执行更新P4操作</li>
<li>LSN110-LSN120: 跳过</li>
</ul>
<h4 id="Undo-phase"><a href="#Undo-phase" class="headerlink" title="Undo phase"></a>Undo phase</h4><p>Undo 阶段和Redo阶段的起始位置不同 ，Undo是从Transaction Table中各个事务的LastLSN往前回滚。</p>
<p>我们要做的是把transaction Table中没有完成的事务给回滚掉。其具体操作就是：撤销所有在transaction Table中所有事务的Update操作。使数据其从中间态恢复到事务执行前的状态</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/34.png"></p>
<p>还是以上图为例，我们看到transaction Table中有T2和T3是需要回滚的。对于每个需要回滚的事务，直接从lastLSN开始。</p>
<ul>
<li>对于T2，我们可以直接从LSN30开始回滚</li>
<li>对于T3，我们可以从LSN90 开始回滚</li>
</ul>
<p>注意，回滚也会记录日志：</p>
<p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/35.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2022/05/11/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/45.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Flink学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-10 19:44:56" itemprop="dateCreated datePublished" datetime="2022-05-10T19:44:56+08:00">2022-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-19 11:02:40" itemprop="dateModified" datetime="2022-06-19T11:02:40+08:00">2022-06-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Flink学习"><a href="#Flink学习" class="headerlink" title="Flink学习"></a>Flink学习</h1><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p> 大数据运算主要有2个领域：1：流式计算 2：批量计算。在数据操作层面可以看做如下的两类</p>
<p>有限数据集：数据大小有限（固定大小，比如固定的文件），用于批处理。比如说MapReduce，Spark</p>
<p>无限数据集：数据持续增长（属于无限大小，比如kafka中的日志数据，总是有新数据进入，并且不知道什么时候结束或者是永远不结束），用于流式处理。 </p>
<p>我们要学习的Flink就是一个面向流处理和批处理的分布式计算框架，既支持流处理，也支持批处理.</p>
<p>现在我们来看看三种计算框架的区别：</p>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/1.png"></p>
<p>下图是Flink的技术栈，我们看到最上面一层是工具库，中间层是输入数据的类型(有流数据和固定数据)，第三层是Stream Dataflow Engine,是Flink的核心部分。最下面一层是Flink的底层依赖</p>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/1.jpeg"></p>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>与Storm类似，Flink将输入数据看作是一 个不间断的、无界的连续记录序列  </p>
<p>有所不同的是，Flink将这一系列的记录抽象成DataStream 类似于RDD，DataStream是不可变的</p>
<p>这里的不可变，指的是unmutable, 即我们对DataSteam进行修改的话，会返回一个新的Stream，原来的Stream不会发生变化</p>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/2.png"></p>
<p>现在对之前学过的几个计算框架中的数据模型做一个总结：</p>
<ul>
<li>MapReduce: Key-value Pair</li>
<li>Spark: RDD, 实际上就是键值对的集合</li>
<li>Storm: Tuple</li>
<li>Flink: DataStream 实际上是Tuple的集合</li>
</ul>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/3.png"></p>
<h3 id="计算模型"><a href="#计算模型" class="headerlink" title="计算模型"></a>计算模型</h3><p>Flink和Spark有点像，也是一系列的变换操作构成一张有向无环图， 即描述计算过程的DAG</p>
<p>Flink算子也分为3类：</p>
<ul>
<li>数据源（DataSource） </li>
<li>转换（Transformation） </li>
<li>数据池（DataSink）</li>
</ul>
<h4 id="DataSource"><a href="#DataSource" class="headerlink" title="DataSource"></a>DataSource</h4><div class="table-container">
<table>
<thead>
<tr>
<th>操作算子</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>fromElements(elements)</td>
<td>从相同类型的记录创建DataStream</td>
</tr>
<tr>
<td>fromCollection(collection)</td>
<td>从内存集合创建DataStream</td>
</tr>
<tr>
<td>readTextFile(path)</td>
<td>逐行读取文件内容来创建DataStream</td>
</tr>
<tr>
<td>socketTextSteam(hostname,port)</td>
<td>接收来自套接字的内容来创建DataStream</td>
</tr>
<tr>
<td>addSource(customer-source-func)</td>
<td>使用户自定义source func来创建DataStream</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h4><div class="table-container">
<table>
<thead>
<tr>
<th>操作算子</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>map</strong></td>
<td>将DataSet中的每一个元素转换为另外一个元素，返回一个新的DataStream</td>
</tr>
<tr>
<td><strong>flatMap</strong></td>
<td>与map类似，但是对DataStream中的每个记录都可以映射成0个或者多个新的记录</td>
</tr>
<tr>
<td><strong>union</strong>(otherDataStream)</td>
<td>若干个数据类型相同的DataStream，取其并集得到一个新的DataStream</td>
</tr>
<tr>
<td><strong>connect</strong>(otherDataStream)</td>
<td>两个数据类型可能不同的DataStream，取并集得到一个新的DataStream</td>
</tr>
<tr>
<td><strong>keyBy</strong>(key)</td>
<td>以给定的key划分DataStream来创建KeyedStream(类似于Spark中的PairRDD)</td>
</tr>
<tr>
<td><strong>window</strong>(WubdiwAssigner)</td>
<td>对KeyedStream中按键按分组的记录根据WindowAssigner将其划分为多个窗口，返回一个WindowedStream</td>
</tr>
<tr>
<td><strong>reduce</strong>(func)</td>
<td>通过func简化DataStream中的记录，返回一个新的DataStream</td>
</tr>
<tr>
<td><strong>aggregate</strong>(func)</td>
<td>对DataStream中每个窗口中记录使用func聚合为结果记录，返回一个新DataStream</td>
</tr>
<tr>
<td><strong>join</strong>(otherDataStream)</td>
<td>[K,V1]和[K,V2] 分别属于两个DataStream.返回一个[K,(V1,V2)]组成的JoinedStream</td>
</tr>
</tbody>
</table>
</div>
<h4 id="DataSink"><a href="#DataSink" class="headerlink" title="DataSink"></a>DataSink</h4><div class="table-container">
<table>
<thead>
<tr>
<th>操作算子</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>print()</td>
<td>将DataStream写入标准输出</td>
</tr>
<tr>
<td>writeAsText(path)</td>
<td>将DataStream以文本格式写入指定的文件中</td>
</tr>
<tr>
<td>writeToSocket(hostname,port, schema)</td>
<td>将DataStream作为字节数组写入套接字，输出格式由schema指定</td>
</tr>
<tr>
<td>addSink(customer-sink-func)</td>
<td>使用用户自定义sinkfunc作为数据池操作</td>
</tr>
</tbody>
</table>
</div>
<h3 id="逻辑计算模型"><a href="#逻辑计算模型" class="headerlink" title="逻辑计算模型"></a>逻辑计算模型</h3><p>通常来说，Flink系统的一个应用对应一个DAG，而Spark中的一个应用包含一个或者多个DAG</p>
<p>比如说下面这个Wordcount例子：我们假定socketTextStream和print的并行度为1，其余并行度为2</p>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/5.png"></p>
<p>在Spark中，有两种逻辑计算模型：OperatorDAG和RDD Lineage。但是Flink只有DAG没有Datasteam Lineage</p>
<h3 id="迭代模型"><a href="#迭代模型" class="headerlink" title="迭代模型"></a>迭代模型</h3><p>由于Flink和Spark相比，除了数据模型从固定的变成流动的之外，最重要的就是增加了迭代算子。因此我们要着重来介绍这个新的算子，其他部分和spark是差不多的</p>
<p>Flink中的迭代过程内部必定存在环路，和Spark不一样，Spark中的迭代需要我们自己设计算法，但在Flink中我们将迭代部分整体视为一个算子，计算的过程仍然是DAG, 如下：</p>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/7.png"></p>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/6.png"></p>
<p>我们发现，Flink中系统提供了迭代算子，内置了一些优化，不需要我们手写for 和 while循环，因此性能更高。但是同样的，这种方法把整个系统变得更复杂了，丧失了一些编程的灵活性</p>
<p>还有一个问题，Spark、Flink这种计算框架中是否存在 If 算子或者 类似于Switch的算子？其实我们是需要这种算子的，因为if和switch这类的控制类的算子在逻辑中还是比较有用的。但是使用条件语句会让我们的DAG变得复杂，因为本来的DAG是静态的，数据朝着一个方向流动，一旦加了条件和控制之后，DAG会不断发生变化，这是不利于分布式系统的</p>
<p>所以我们把大数据处理系统也称为 Dataflow system, 而之前我们写的Java、C++都是Controlflow,这两者和计算机体系结构有关：</p>
<p>我们可以通过下面这个示意图来知悉两者关系：Controlflow 是指令和数据同时存储的，而Dataflow编程模型是算子级别的，把controlflow中的指令替换成算子</p>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/8.png"></p>
<h2 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h2><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p>Flink的架构和Spark非常类似，也是分为一个主节点和若干从节点。</p>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/9.png"></p>
<h4 id="Standalone-模式架构图"><a href="#Standalone-模式架构图" class="headerlink" title="Standalone 模式架构图"></a>Standalone 模式架构图</h4><p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/10.png"></p>
<p>我们来逐步看一下每个部件的作用</p>
<ul>
<li>Client: 讲用户编写的DataStream 程序翻译为逻辑执行图病进行优化，并将优化后的逻辑执行图提交到JobManager。<ul>
<li>在Standalone模式下，Client的进程名为 CliFrontend</li>
</ul>
</li>
<li>JobManager: 根据逻辑执行图产生<strong>物理执行图</strong>，负责协调系统的作业执行，包括任务调度，协调检查点和故障恢复等。<ul>
<li>在Standalone模式下，JobManager还负责Flink系统的资源管理</li>
<li>JobManager的进程名为 StandaloneSessionClusterEntryPoint</li>
</ul>
</li>
<li>TaskManager: 用来执行JobManager分配的任务，并且负责读取数据、缓存数据以及其他TaskManager进行数据传输<ul>
<li>在Standalone模式下，TaskManager还负责所在节点的<strong>资源管理</strong>，将内存等资源抽象成若干个TaskSlot用于任务的执行</li>
<li>TaskManager 的进程名为 TaskManagerRunner</li>
</ul>
</li>
</ul>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/11.png"></p>
<h4 id="Yarn模式架构"><a href="#Yarn模式架构" class="headerlink" title="Yarn模式架构"></a>Yarn模式架构</h4><p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/12.png"></p>
<p>横向比较一下，从Yarn的角度来说就是让资源管理和作业管理分离</p>
<ul>
<li>Standalone模式中的JobManager、TaskManager对应变成了Resource Manager和NodeManager</li>
</ul>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/13.png"></p>
<h3 id="应用程序执行流程"><a href="#应用程序执行流程" class="headerlink" title="应用程序执行流程"></a>应用程序执行流程</h3><h4 id="Standalone模式"><a href="#Standalone模式" class="headerlink" title="Standalone模式"></a>Standalone模式</h4><p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/14.png"></p>
<ol>
<li>客户端将用户编写的程序进行解析，并将 解析  后的作业描述交给StandaloneSessionClusterEntrypoint </li>
<li>StandaloneSessionClusterEntrypoint根据 作业的描述进行任务分解，确定各个TaskManagerRunner所负责执行的任务 </li>
<li>TaskManagerRunner执行所负责的任务</li>
</ol>
<h5 id="提交方式"><a href="#提交方式" class="headerlink" title="提交方式"></a>提交方式</h5><p>在Standalone模式下，当用户使用客户端 提交Flink应用程序时，可以选择Attached 方式或者Detached方式</p>
<ul>
<li>Attached提交方式：客户端与JobManager保持连接，可以获取关于应用程序执行的信息</li>
<li>Detached提交方式：客户端与JobManager断开连接，无法获得关于应用程序执行的信息</li>
</ul>
<p>这两种提交方式和Spark中的两种提交方式有点像。Attached和Client 比较类似，Detached和Cluster比较类似。</p>
<p>但是他们又有一些区别：</p>
<p>在spark 中，以cluster模式提交，其客户端还是存在的运行，只不过Driver从本地客户端跑到了远端集群当中；但是在Flink中用Detached方式提交，则是没有客户端了，没有办法获取应用程序的打印信息</p>
<h3 id="Yarn-模式"><a href="#Yarn-模式" class="headerlink" title="Yarn 模式"></a>Yarn 模式</h3><p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/15.png">我们看到Yarn的执行模式比Standalone要复杂得多，而且必须要用到HDFS</p>
<ol>
<li><p>客户端启动<code>CliFrontend</code>进程，<code>CliFrontend</code>将用户编写的程序进行解 析，并将运行Flink系统的jar包以及配置文件上传至HDFS</p>
</li>
<li><p><code>CliFrontend</code>向<code>ResourceManager</code>申请启动 <code>YarnJobClusterEntrypoint (ApplicationMaster)</code>，<code>ResourceManager</code>确定启动<code>YarnJobClusterEntrypoint</code>的节点 </p>
</li>
<li>需启动<code>YarnJobClusterEntrypoint</code>进程的节点上的<code>NodeManager</code>将 HDFS中的jar包与配置文件下载到该节点 </li>
<li><code>NodeManager</code>启动<code>YarnJobClusterEntrypoint</code>进程 </li>
<li><code>CliFrontend</code>进程将解析后的作业描述交给<code>YarnJobClusterEntrypoint</code></li>
<li><code>YarnJobClusterEntrypoint</code>向<code>ResourceManager</code>注册，这样客户端可 以通过 <code>ResourceManager</code>查看Flink应用程序的资源使用情况。 <code>YarnJobClusterEntrypoint</code>根据作业的描述进行任务分解，并向 <code>ResourceManager</code>申请启动这些任务的资源</li>
<li><code>ResourceManager</code>以Container形式向提出申请的 <code>YarnJobClusterEntrypoint</code>分配资源。得到资源后，它在多个任务间 进行资源分配 </li>
<li><code>YarnJobClusterEntrypoint</code>确定资源分配方案后，便与对应的 <code>NodeManager</code>通信</li>
<li>如果该<code>NodeManager</code>所在节点尚未下载，则将HDFS中的jar包与配 置文件下载到本地，并在相应的Container中启动相应的 <code>YarnTaskExecutorRunner</code>进程用于执行任务 </li>
<li>各个任务向<code>YarnJobClusterEntrypoint</code>汇报自己的状态和进度，以便让 <code>YarnJobClusterEntrypoint</code>随时掌握各个任务的运行状态 </li>
<li>随着部分任务执行结束，<code>YarnJobClusterEntrypoint</code>逐步释放所占用 的资源，最终向<code>ResourceManager</code>注销并关闭自己</li>
</ol>
<h5 id="提交方式-1"><a href="#提交方式-1" class="headerlink" title="提交方式"></a>提交方式</h5><ul>
<li>Attached提交方式：<code>CliFrontend</code>将与 <code>YarnJobClusterEntrypoint</code>保持连接，可以获取 关于应用程序执行的信息 </li>
<li>Detached提交方式：<code>CliFrontend</code>将与 <code>YarnJobClusterEntrypoint</code>断开连接，无法获得 关于应用程序执行的信息</li>
</ul>
<p>我们之前说过，Yarn是应用作为粒度来管理的，Spark中的Application和MapReduce中的Job对应一个Yarn中的应用。在Flink当中，既可以以一个任务作为Yarn的一个应用，又可以拿整一个Application作为Yarn的一个应用</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>现在我们来介绍Flink框架的内部工作原理，这其实和Sql的执行过程类似</p>
<ul>
<li>首先生成逻辑执行计划，然后进行逻辑优化</li>
<li>接着生成物理执行计划，并执行</li>
</ul>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/16.png"></p>
<h3 id="逻辑执行图的生成与优化"><a href="#逻辑执行图的生成与优化" class="headerlink" title="逻辑执行图的生成与优化"></a>逻辑执行图的生成与优化</h3><p>首先什么是逻辑执行图？ 给定用户编写的DataStream程序，Flink的 Client将其解析产生逻辑执行图，即DAG.</p>
<p>那么逻辑执行图怎么优化？ 有一种Chaining优化的方法：将”窄依赖“算子合并起来形成一个大的算子。如下图所示，我们将flatMap、map合并成一个 flatMap-map算子, 然后将keyBy、window、sum合并成一个keyed-window-sumAgg算子。</p>
<p>不能合并的情况：</p>
<ul>
<li>因为 map到keyBy之间是宽依赖，有交叉的，因此不能合并。</li>
<li>并行度不同，不能合并</li>
</ul>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/17.png"></p>
<p>事实上，Flink的Chaining优化方法，很类似于Spark中的Pipeline，二者效果相同，只是名字有所不同</p>
<h3 id="物理执行图的生成与任务分配"><a href="#物理执行图的生成与任务分配" class="headerlink" title="物理执行图的生成与任务分配"></a>物理执行图的生成与任务分配</h3><p>JobManager收到Client提交的逻辑执行图 之后，<strong>根据算子的并行度</strong>，将逻辑执行图 转换为物理执行图 </p>
<p>物理执行图中的一个结点对应一个任务， 将分配给TaskManager来执行</p>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/19.png"></p>
<h5 id="任务分配"><a href="#任务分配" class="headerlink" title="任务分配"></a>任务分配</h5><p>JobManager将各算子的任务分配给 TaskManager </p>
<p>根据任务槽(TaskSlot)的容量，尽可能将存在数据传输关系的算子实例放在同一个任务槽， 保持数据传输的本地性。 和上图对照，发现上面4个算子放在一个TaskManager中，说明这一个流水线中的数据都是在内存中传递的。而对于下面一行，从<code>socketTextStream</code>到<code>flatMap-map</code>以及从<code>keyedwindow-sumAgg</code>到<code>print</code>的数据传输是在节点之间进行的</p>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/19.jpg"></p>
<p>从逻辑执行图到物理执行图的整个过程如下图所示:</p>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/18.jpg"></p>
<h3 id="非迭代任务间的数据传输"><a href="#非迭代任务间的数据传输" class="headerlink" title="非迭代任务间的数据传输"></a>非迭代任务间的数据传输</h3><p>Flink在不同Task之间的数据传输方式是：流水线机制。也就是说：上游的Task将数据存放在 buffer 中，一旦Buffer满了或者超时，就像下游Task发送</p>
<p>Flink并不是生成一个item传递一次，也不是像MapReduce、Spark一样，把所有item全部处理完成后下游任务才能继续运行(因此MR和Spark无法处理流数据)。</p>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/20.png"></p>
<p>注意，Spark中的pipline和Flink中的pipeline是不同的概念</p>
<ul>
<li>在Flink中，pipline表示在不同Task之间的数据传输方式，区别于MR和Spark中的Shuffle</li>
<li>在Spark中，pipline指内部<strong>同一个Task实现多个不同算子之间</strong>的数据传输方式，粒度更细<ul>
<li>Spark Pipline和Flink Chaining类似</li>
</ul>
</li>
</ul>
<h4 id="Task间数据传输方式"><a href="#Task间数据传输方式" class="headerlink" title="Task间数据传输方式"></a>Task间数据传输方式</h4><ul>
<li><p><strong>阻塞式数据传输：</strong> 一个Task（运行某个或某些算子）将所有需要处理的数据计算完，甚至要将结果写入磁盘， 才会发送给位于下游Task或被其读取  。 比如说MapReduce、Spark</p>
</li>
<li><p><strong>非阻塞式数据传输：</strong> 云计算天然需要非阻塞式数据传输这种特性。一个Task处理一条或一部分数据，通常将计算结果放在缓存里，就会发送给位于下游Task或被其读取。比如说Storm、Flink</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>系统</th>
<th>数据传输方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>MapReduce</td>
<td>阻塞式数据传输</td>
</tr>
<tr>
<td>Spark</td>
<td>阻塞式数据传输</td>
</tr>
<tr>
<td>Storm</td>
<td>非阻塞式数据传输</td>
</tr>
<tr>
<td>Flink</td>
<td>非阻塞式数据传播</td>
</tr>
</tbody>
</table>
</div>
<h3 id="迭代任务内部的数据传输"><a href="#迭代任务内部的数据传输" class="headerlink" title="迭代任务内部的数据传输"></a>迭代任务内部的数据传输</h3><h4 id="迭代的实现"><a href="#迭代的实现" class="headerlink" title="迭代的实现"></a>迭代的实现</h4><p>迭代算子是Flink 特有的，它是嵌套在DAG中的一个整体。迭代算子<strong>内部存在数据反馈的环路</strong>。</p>
<p>那么数据反馈如何实现？</p>
<ul>
<li>在同一个TaskManager当中会成对出现迭代前端(Iteration Source)和迭代末端(Iteration Sink) 两类特殊的任务。迭代末端任务的输出可以再次作为迭代前端任务的输入。</li>
</ul>
<h4 id="流式迭代"><a href="#流式迭代" class="headerlink" title="流式迭代"></a>流式迭代</h4><p>在流式迭代计算中，通常每一轮迭代计算的部分结果作为输出向后传递，而另一部分结果作为下一轮迭代计算的输入，并且迭代过程会一直进行下去。</p>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/21.png"></p>
<p>流式迭代计算中，迭代前端下一轮的计算并不依赖与迭代末端前一轮迭代得到的所有记录。同时，迭代前端收到迭代末端的反馈后，可以立即进行新一轮迭代计算。</p>
<p>因此，这种方式仍然是采用流水线方式进行数据传输。</p>
<h4 id="批式迭代"><a href="#批式迭代" class="headerlink" title="批式迭代"></a>批式迭代</h4><p>在批式迭代计算中，每一轮迭代计算的<strong>全部结果</strong>通常都是下一轮迭代计算的输入， 直到迭代过程在满足<strong>收敛条件</strong>时停止迭代。比如梯度下降，k均值.</p>
<p>迭代前端中发出特殊的控制事件（control event），即特殊的记录(如达到某一条件)，表示迭代计算的结束</p>
<p>在批式迭代计算中，迭代前端必须收到迭代 末端反馈的所有记录后才可以开始新一轮迭代计算。因此这时一种阻塞的过程，<strong>无法采用流水线机制</strong>进行数据传输</p>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/22.png"></p>
<h2 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h2><p>在容错机制中，我们主要需要解决当TaskManager故障了，怎么办？</p>
<ul>
<li>运行了非迭代算子的容错</li>
<li>运行了迭代算子的容错</li>
</ul>
<h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><p>首先，我们要了解什么是状态？</p>
<p>在输出数据是无界的场景中，数据会源源不断地流入Flink系统。</p>
<p>例如，在某一窗口中统计单词的个数: </p>
<ul>
<li>窗口需要将原始的单词记录保存起来，直到窗口触发时，一并进行统计</li>
<li>或者将单词以及当前观察到的个数保存起来，并逐步累加</li>
<li>窗口这个算子所需维护的内容，就是状态</li>
</ul>
<p>注意，我们要区分算子的状态与进程/节点的状态，前者类似于完成作业的一个进度</p>
<h4 id="为什么需要系统管理状态"><a href="#为什么需要系统管理状态" class="headerlink" title="为什么需要系统管理状态"></a>为什么需要系统管理状态</h4><p>假设我们使用用户程序来管理状态，那么</p>
<ul>
<li>用户需要编写一个HashMap来记录计数保存状态，那么一旦该算子所在的task发生了故障，内存中的HashMap就丢失了。</li>
<li><p>因此为了支持容错，需要编写程序将HashMap写入磁盘等可靠的存储设备，故障恢复后再读取。这样一来，不同数据结构都需要编写相应的保存、读取代码</p>
<p>因此，状态管理对用户应该是透明的，交给系统来做。</p>
</li>
</ul>
<h4 id="状态定义"><a href="#状态定义" class="headerlink" title="状态定义"></a>状态定义</h4><p>状态是系统定义的特殊的数据结构，用于记录需要保存的算子计算结果</p>
<ul>
<li><code>ValueState&lt;T&gt;</code>: 状态保存的是每个Key的一个值，可以通过<code>update(T)</code>来更新，<code>T.value()</code>获取</li>
<li><code>ListState&lt;T&gt;</code>: 状态保存的是每个key的一个列表，通过<code>add(T)</code>添加数据，<code>Iterable.get()</code>获取</li>
<li><code>ReaducingState&lt;T&gt;</code>: 状态保存的是关于每个key经过聚合之后的值列表，通过<code>add(T)</code>添加数据，通过指定的聚合方法来获取</li>
</ul>
<h4 id="有状态算子-无状态算子"><a href="#有状态算子-无状态算子" class="headerlink" title="有状态算子/无状态算子"></a>有状态算子/无状态算子</h4><ul>
<li>有状态算子：具备记忆能力的算子<ul>
<li>可以保留已经处理记录的结果，并对后续记录的处理造成影响</li>
<li>例如：Window，Sum</li>
</ul>
</li>
<li>无状态算子：不具备记忆能力的算子<ul>
<li>只考虑到当前处理的记录，不会受到已处理记录的影响，也不会影响到后续待处理的记录</li>
<li>例如: Map</li>
</ul>
</li>
</ul>
<h4 id="状态管理与容错"><a href="#状态管理与容错" class="headerlink" title="状态管理与容错"></a>状态管理与容错</h4><ul>
<li>算子级别的容错<ul>
<li>运行时保存其状态，在发生故障时重置状态，并继续处理尚未保存到状态中的记录</li>
</ul>
</li>
<li>DAG级别的容错<ul>
<li>既然一个算子可以保存其状态，那么我们是不是可以对DAG中所有的算子都进行这个操作？</li>
<li>这就是DAG级别的容错，我们可以在<strong>同一时刻</strong>将所有算子的状态保存起来形成检查点，一旦出现故障，则所有算子都根据检查点来重置状态，并处理尚未保存到检查点中的记录。</li>
<li>难点是：DAG可能在分布式系统下运行，要做到<strong>同一时刻</strong>，必须要求所有节点的物理时钟<strong>绝对同步</strong>。但这是不可能的。那么怎么办？我们可以分两种情况来讨论</li>
</ul>
</li>
</ul>
<h3 id="非迭代计算过程的容错"><a href="#非迭代计算过程的容错" class="headerlink" title="非迭代计算过程的容错"></a>非迭代计算过程的容错</h3><h4 id="系统中的记录"><a href="#系统中的记录" class="headerlink" title="系统中的记录"></a>系统中的记录</h4><p>上面我们说的DAG容错，虽然无法实现，但其Idea就是将Flink中的不同种类的记录区分开来：</p>
<p>在某一时刻，流计算系统所处理的记录，可以分为三种类型</p>
<ul>
<li>已经处理完毕的记录，即所有算子都已经处理了这些记录</li>
<li>正在处理的记录，即部分算子处理了这些记录</li>
<li>尚未处理的记录，即没有算子处理过这些记录</li>
</ul>
<p>因此，虽然绝对同步的时钟是不存在的，但是同一时刻保存所有算子状态到检查点的目的是<strong>区分第一种记录和后两种记录</strong></p>
<h4 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h4><p>JobManager在输入记录中插入屏障，这些屏障与记录一起向下游的计算任务流动。我们可以将其理解为标记，将数据流进行一个分割。一个任务，需要收到来自上有任务中所有标识为n的屏障之后，才能将其状态保存起来，这被称为<strong>屏障对齐</strong>。每个检查点的保留结果相互独立，都保留了一份计算结果。</p>
<p>某一人任务将标识为n的屏障对齐之后，可以继续接收属于 检查点 n+1 的数据</p>
<p><img src="/2022/05/10/Flink%E5%AD%A6%E4%B9%A0/23.png">如上图：</p>
<ol>
<li>最右侧两个黄色的记录，就是已经处理完毕的记录</li>
<li>中间虚框框起来的记录则是正在处理的记录</li>
<li>最右侧是尚未处理的记录</li>
</ol>
<h4 id="异步屏障快照"><a href="#异步屏障快照" class="headerlink" title="异步屏障快照"></a>异步屏障快照</h4><p>异步屏障快照算法是由Chandy-Lamport算法(分布式系统中用于保存系统状态)扩展而来的 :</p>
<ul>
<li>所保存的快照就是检查点</li>
<li>通过在输入数据中注入屏障，并异步地保存快照，达到和在同一时刻保存所有算子状态到检查点相同的目的</li>
</ul>
<h4 id="Flink状态存储"><a href="#Flink状态存储" class="headerlink" title="Flink状态存储"></a>Flink状态存储</h4><div class="table-container">
<table>
<thead>
<tr>
<th>状态存储方式</th>
<th>正常运行时</th>
<th>写检查点时</th>
</tr>
</thead>
<tbody>
<tr>
<td>MemoryStateBackend</td>
<td>本地内存</td>
<td>JobManager内存</td>
</tr>
<tr>
<td>FsStateBackend</td>
<td>本地内存</td>
<td>HDFS</td>
</tr>
<tr>
<td>RocksDBStateBackend</td>
<td>本地RocksDB</td>
<td>HDFS</td>
</tr>
</tbody>
</table>
</div>
<h4 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h4><p>当发生故障时，Flink选择最近完整的检查点n，将系统中每个算子的状态重置为检查点中保存的状态。</p>
<p>从数据源重新读取属于屏障n之后的记录</p>
<ul>
<li>这要求数据源具备一定的记忆功能</li>
<li>例如，Flink从Kafka中重新读取屏障n对应偏移量之后的记录</li>
</ul>
<p>Flink的容错机制能够满足<strong>准确一次</strong>的容错语义</p>
<h3 id="迭代计算过程的容错"><a href="#迭代计算过程的容错" class="headerlink" title="迭代计算过程的容错"></a>迭代计算过程的容错</h3><h2 id="编程实例"><a href="#编程实例" class="headerlink" title="编程实例"></a>编程实例</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/05/09/Yarn%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/09/Yarn%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Yarn学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-09 16:20:58" itemprop="dateCreated datePublished" datetime="2022-05-09T16:20:58+08:00">2022-05-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-16 22:46:20" itemprop="dateModified" datetime="2022-05-16T22:46:20+08:00">2022-05-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Yarn学习"><a href="#Yarn学习" class="headerlink" title="Yarn学习"></a>Yarn学习</h1><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><h3 id="作业与资源管理"><a href="#作业与资源管理" class="headerlink" title="作业与资源管理"></a>作业与资源管理</h3><p>在学习Yarn之前，我们先学习一下作业管理和资源管理。</p>
<p>在MapReduce中，有一个部件是 JobTracker，它负责作业管理和资源管理</p>
<ul>
<li>作业管理：状态监控、信息汇总、任务调度</li>
<li>资源管理：管理主从节点</li>
</ul>
<p>但是，资源管理和计算框架不能结合得这样紧密(因此这也是MapReduce的一个弊端之一)，资源管理应该是由操作系统来分配的，是通用的</p>
<p>而且，MapReduce的作业管理也有缺陷：JobTracker需要维护所有作业的元信息，内存开销大。那么，当同一时刻执行的作业数量增加时， JobTracker与执行这些作业中的任务以及 TaskTracker之间的通信频率增大，造成 JobTracker进程的不稳定。</p>
<p>基于此，我们提出了HADOOP 2.0，其结构如下：也就是将资源管理单独剥离出来，交给Yarn去管理。有了Yarn以后，MapReduce就只需要负责数据处理就好了，而且还可以在此基础上运行Spark、Flink，以实现资源的共享</p>
<p>因此，Yarn从某个角度上来说可以看做是一个操作系统，MapReduce、Spark可以看做是在这个操作系统上的软件。</p>
<p><img src="/2022/05/09/Yarn%E5%AD%A6%E4%B9%A0/1.png" style="zoom:67%;"></p>
<h3 id="平台与框架"><a href="#平台与框架" class="headerlink" title="平台与框架"></a>平台与框架</h3><p>我们要理清楚平台和框架的区别：</p>
<ul>
<li>平台：具有提供资源功能的系统，如 Yarn,K8s, Mesos</li>
<li>框架：运行在平台上的系统，如Spark, Flink, MapReduce</li>
</ul>
<p>在Yarn这个平台中，管理的粒度是<strong>应用</strong>。</p>
<ul>
<li>这个应用不一定是是框架中的应用</li>
<li>运行在Yarn这个平台上的框架，可以将应用或者作业映射为Yarn的应用。</li>
</ul>
<p>比如, 在Spark中，一个application 映射成 Yarn中的一个应用。但在MapReduce中，是以Job为单位的，因此一个Job作为Yarn中的一个应用。</p>
<h2 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h2><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p><img src="/2022/05/09/Yarn%E5%AD%A6%E4%B9%A0/2.png" style="zoom:67%;"></p>
<p>Yarn的架构和MapReduce差不多，也是分为主从节点，不过名字换了一下，变成了 Resource Manager和Node Manager。</p>
<p>我们看到上图中有两组不同颜色的工作进程和Application Master。说明此时在Yarn中有两个应用正在工作。</p>
<h4 id="ResourceManager"><a href="#ResourceManager" class="headerlink" title="ResourceManager"></a>ResourceManager</h4><p>资源管理器：负责整个系统的资源管理和分配 (全局)。</p>
<p>它分为两部分：</p>
<ul>
<li>资源调度器(Resource Scheduler)：分配 Container并进行资源调度 </li>
<li>应用程序管理器(Application Manager)：管理整个系统中运行的所有应用 <ul>
<li>应用程序提交 </li>
<li>与调度器协商资源以启动ApplicationMaster </li>
<li>监控Application Master运行状态</li>
</ul>
</li>
</ul>
<p>注意：Application Manager<strong>并不管理 </strong>Application内部的资源如何分配、如何协调。有点像班长，只管小组长是否还工作。关于每个小组如何分工，他不负责</p>
<h4 id="NodeManager"><a href="#NodeManager" class="headerlink" title="NodeManager"></a>NodeManager</h4><p>节点管理器：负责每个节点资源和任务管理 </p>
<ul>
<li>定时地向ResourceManager汇报本节点的资源使用情况和 Container运行状态 </li>
<li>接受并处理来自Application Master的Container启动/停止等各 种请求</li>
</ul>
<h4 id="Application-Master"><a href="#Application-Master" class="headerlink" title="Application Master"></a>Application Master</h4><p>当用户基于Yarn平台提交一个框架应用， Yarn均启动一个 AM用于管理该应用</p>
<ul>
<li>AM与RM调度器协商以获取资源（以Container 表示），将获取的资源进一步分配给应用内部的任务 </li>
<li>AM与NM通信以启动/停止任务，监控所有任务运行状态， 并在任务发生故障时重新申请资源来重启任务</li>
</ul>
<h4 id="container"><a href="#container" class="headerlink" title="container"></a>container</h4><p>我们可能已经注意到，前面的AM以及工作进程，进程都被虚线框了起来。这些虚线就是Container</p>
<ul>
<li>Container是资源的抽象表示，包含CPU、 内存等资源，是一个动态资源划分单位</li>
<li>当AM向RM申请资源时，RM向AM返回以 Container表示的资源</li>
</ul>
<h3 id="YARN和Mapreduce1-0的对比"><a href="#YARN和Mapreduce1-0的对比" class="headerlink" title="YARN和Mapreduce1.0的对比"></a>YARN和Mapreduce1.0的对比</h3><ul>
<li>MapReduce 1.0既是计算系统，需要负责作业 管理，也是资源管理系统</li>
<li>Yarn是独立出来的资源管理系统，而 MapReduce 2.0作为计算系统负责作业管理</li>
</ul>
<p><img src="/2022/05/09/Yarn%E5%AD%A6%E4%B9%A0/3.png" style="zoom:67%;"></p>
<p>Container对应Task并不是特别准确，因为Task是一个进程，Container是容器。因此用child和YarnChild对应更加准确。</p>
<h3 id="执行流程图"><a href="#执行流程图" class="headerlink" title="执行流程图"></a>执行流程图</h3><p><img src="/2022/05/09/Yarn%E5%AD%A6%E4%B9%A0/4.png" style="zoom:67%;"></p>
<p>当用户向Yarn中提交应用程序之后，Yarn先启动Application Master，再由AM根据应用程序进行任务划分，并为个任务申请资源，同时监控整个运行过程</p>
<ol>
<li>用户编写客户端应用程序，想Yarn提交应用程序</li>
<li>ResourceManager负责接收和处理来自客户端的请求，尝试为该应用程序分配第一个Container，若分配成功则在这个Container中启动应用程序的Application Master</li>
<li>Application Master想Resource Manager注册，这样客户端可以通过ResourceManager查看应用的资源使用情况。ApplicationMaster将应用解析为作业并进一步分解为若干任务，并向Resource Manager申请启动这些任务的资源。</li>
<li>RM想提出的AM分配Container形式表示的资源。一旦AM申请到资源后，在多个任务之间进行分配</li>
<li>AM确定资源分配方案后，便于对应的NodeManager通信，在相应的Container中启动相应的工作进程用于执行任务</li>
<li>各个任务向AM汇报自己的状态和进度，以便让AM随时掌握各个任务的运行状态</li>
<li>随着任务执行结束，AM逐步释放所占用的资源，最终向RM注销并关闭自己</li>
</ol>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><h3 id="单平台多框架"><a href="#单平台多框架" class="headerlink" title="单平台多框架"></a>单平台多框架</h3><p>Yarn 其实就是一个资源管理的平台，其上可以运行多个框架，并为多个应用进行资源的分配。比如说，在Yarn上可以运行MapReduce、Spark、Flink等应用，而且能实现动态共享物力资源。对于Yarn阿狸说，它值负责想框架提供Container，而不关心在Container中运行何种任务。</p>
<p>如下图，Yarn中部署了MR和Spark两个计算框架，并且提交了两个MapReduce应用和一个Spark应用。由此看出，每当提交了一个应用，Yarn都会启动一个对应的AM(即使是同一类型的应用)。这就说明Yarn是按照应用粒度来划分的，每个应用之间相互独立地控制执行的目的。</p>
<p><img src="/2022/05/09/Yarn%E5%AD%A6%E4%B9%A0/5.png" style="zoom:67%;"></p>
<h3 id="平台资源分配"><a href="#平台资源分配" class="headerlink" title="平台资源分配"></a>平台资源分配</h3><ul>
<li>Resource Manager中的调度器维护了一个 或多个应用队列(queue) ,每个队列拥有一定量的资源，位于同一队列中的应用共享该队列所拥有的资源。</li>
<li>Yarn进行资源分配对象是应用，用户提交 的每个应用会分配到其中一个队列当中， 而队列决定了该应用能使用的资源上限。</li>
<li>资源调度实际上是决定如何将资源分配给队列、以及如何分配给队列中应用的过程</li>
</ul>
<h4 id="资源分配策略-FIFO"><a href="#资源分配策略-FIFO" class="headerlink" title="资源分配策略-FIFO"></a>资源分配策略-FIFO</h4><p>FIFO调度器只维护一个队列，该队列拥有集群中所有资源，调度器的资源分配方式是<strong>先提交的应用先得到资源</strong></p>
<p>该调度器实现起来比较简单，但是很可能导致一个应用独占所有的资源，而其他资源需不断等待。</p>
<p><img src="/2022/05/09/Yarn%E5%AD%A6%E4%B9%A0/6.png" style="zoom:67%;"></p>
<h4 id="资源分配策略-Capacity"><a href="#资源分配策略-Capacity" class="headerlink" title="资源分配策略-Capacity"></a>资源分配策略-Capacity</h4><p>改进FIFO调度器的思想是将一个队列分解为多个队列，每个队列都拥有一定的资源。某一应用最多只会占用其中一个队列所拥有的资源，而不会占用集群中的所有资源。</p>
<p>因此进化成了 Capacity 策略：Capacity Scheduler维护了层级式队列，集群中的资源划分给了这些队列，队列内部的资源分配方式是FIFO</p>
<p><img src="/2022/05/09/Yarn%E5%AD%A6%E4%B9%A0/7.png" style="zoom:67%;"></p>
<h4 id="资源分配策略-Fair"><a href="#资源分配策略-Fair" class="headerlink" title="资源分配策略-Fair"></a>资源分配策略-Fair</h4><p>改进Capacity调度器的思想是容许队列之间共享资源，从而避免浪费。因此提出了Fair Scheduler, Fair Scheduler维护层级式的队列，集群中的资源划分给这些队列，但是这些队列可以共享资源，因而这些队列逻辑上可以看作是一个共享队列 </p>
<p><img src="/2022/05/09/Yarn%E5%AD%A6%E4%B9%A0/8.png" style="zoom:67%;"></p>
<p>当然这种方法也有弊端，应用2在提交之后需要和应用1抢占资源，因此会导致一定的时间延迟</p>
<h2 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h2><p>YARN中的故障主要分为四部分：</p>
<ul>
<li>Resource Manager故障 </li>
<li>Node Manager故障 </li>
<li>Application Master故障：重启 </li>
<li>Container中的任务故障：重启</li>
</ul>
<p>由于AM和Container中运行的任务与具体框架相关，作为资源管理平台的Yarn在它们发生故障的情况下只能重启来恢复</p>
<h3 id="RM故障"><a href="#RM故障" class="headerlink" title="RM故障"></a>RM故障</h3><ul>
<li>如果Resource Manager发生故障，那么它 在进行故障恢复时需要从某一持久化存储 系统中恢复状态信息，所有应用将会重新执行 </li>
<li>我们可以部署多个Resource Manager并通过ZooKeeper进行协调，从而保证 Resource Manager的高可用性</li>
</ul>
<h3 id="NM故障"><a href="#NM故障" class="headerlink" title="NM故障"></a>NM故障</h3><p>Resource Manager认为Node Manager所在节点上所有容器运行的任务也都执行失 败，并把执行失败的信息告诉Application Master </p>
<ul>
<li>AM将向RM重新申请资源运行这些任务</li>
<li><p>RM将分配其它节点的Container执行这些任务</p>
<p>如果发生故障的Node Manager进行恢复， 那么它将向Resource Manager重新注册，重置本地的状态信息</p>
</li>
</ul>
<h2 id="典型示例"><a href="#典型示例" class="headerlink" title="典型示例"></a>典型示例</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/05/08/%E7%94%A8Scala%E5%AE%9E%E7%8E%B0Spark%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/08/%E7%94%A8Scala%E5%AE%9E%E7%8E%B0Spark%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">用Scala实现Spark编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-08 13:39:07" itemprop="dateCreated datePublished" datetime="2022-05-08T13:39:07+08:00">2022-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-09 15:00:32" itemprop="dateModified" datetime="2022-05-09T15:00:32+08:00">2022-05-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jason</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">439</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    

  

</body>
</html>
