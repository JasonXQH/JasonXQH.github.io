<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=">


  <link rel="mask-icon" href="/images/logo.svg?v=" color="#222">














<meta property="og:type" content="website">
<meta property="og:title" content="Jason‘s Blog">
<meta property="og:url" content="https://jasonxqh.github.io/page/3/index.html">
<meta property="og:site_name" content="Jason‘s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '',
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    fancybox: false,
    tabs: ,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: 'undefined',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>







  <title>Jason‘s Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', '[object Object]', 'auto');
  ga('send', 'pageview');
</script>





<meta name="generator" content="Hexo 4.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">
  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
<a href="https://github.com/JasonXQH/JasonXQH.github.io" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jason‘s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/%20" rel="section">
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2023/01/16/FISCO-BCOS%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/01/16/FISCO-BCOS%E5%AD%A6%E4%B9%A0/" itemprop="url">FISCO-BCOS学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2023-01-16T11:53:40+08:00">
                2023-01-16
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2023-01-30T16:58:43+08:00">
                2023-01-30
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="FISCO-BCOS核心模块"><a href="#FISCO-BCOS核心模块" class="headerlink" title="FISCO-BCOS核心模块"></a>FISCO-BCOS核心模块</h1><h2 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h2><p>FISCO BCOS基于多群组架构实现了插件化的共识算法，不同群组可运行不同的共识算法，组与组之间的共识过程互不影响，FISCO BCOS目前支持PBFT(Practical Byzantine Fault Tolerance)和Raft(Replication and Fault Tolerant)两种共识算法。共识模块框架如下图：</p>
<p><img src="/2023/01/16/FISCO-BCOS%E5%AD%A6%E4%B9%A0/1.png" style="zoom:67%;"></p>
<p><strong>Sealer线程</strong></p>
<p>交易打包线程，负责从交易池取交易，并基于节点最高块打包交易，产生新区块，产生的新区块交给Engine线程处理，PBFT和Raft的交易打包线程分别为PBFTSealer和RaftSealer。</p>
<p><strong>Engine线程</strong></p>
<p>共识线程，负责从本地或通过网络接收新区块，并根据接收的共识消息包完成共识流程，最终将达成共识的新区块写入区块链(BlockChain)，区块上链后，从交易池中删除已经上链的交易，PBFT和Raft的共识线程分别为PBFTEngine和RaftEngine。</p>
<h3 id="PBFT基础流程"><a href="#PBFT基础流程" class="headerlink" title="PBFT基础流程"></a>PBFT基础流程</h3><p>详见<a href="https://jasonxqh.github.io/2022/06/05/区块链-共识算法/#PBFT算法">PBFT算法</a></p>
<h3 id="PBFT网络优化"><a href="#PBFT网络优化" class="headerlink" title="PBFT网络优化"></a>PBFT网络优化</h3><p>FISCO BCOS  v2.2.0优化了PBFT消息转发机制和Prepare包的结构，尽量减少网络中冗余的数据包，提升网络效率</p>
<p>之前，在共识节点</p>
<p><img src="/2023/01/16/FISCO-BCOS%E5%AD%A6%E4%B9%A0/2.png" style="zoom:67%;"></p>
<h2 id="交易并行"><a href="#交易并行" class="headerlink" title="交易并行"></a>交易并行</h2>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2023/01/15/fabric%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/01/15/fabric%E5%AD%A6%E4%B9%A0/" itemprop="url">fabric学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2023-01-15T17:50:52+08:00">
                2023-01-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2023-01-03T14:56:32+08:00">
                2023-01-03
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>                                                            </p>
<h1 id="Fabric-学习"><a href="#Fabric-学习" class="headerlink" title="Fabric 学习"></a>Fabric 学习</h1><h2 id="Fabric简介"><a href="#Fabric简介" class="headerlink" title="Fabric简介"></a>Fabric简介</h2><p>Hyperledger Fabric 项目是一个旨在推动区块链跨行业应用的开源项目。它是一个联盟链系统，和我们之前学的以太坊和 比特币不同。</p>
<p>Fabric是企业级开源的并且基于<strong>许可模式</strong>的分布式账本平台。它专门为企业级应用环境设计，实现了一个高度模块化和可配置的体系结构。在联盟链场景下，有一定的<strong>信任基础</strong>和<strong>行政约束力</strong>，因此，在Fabric中没有币和账户钱包的概念, 也不需要激励机制。</p>
<p>允许不同行业基于不同的行业用例对Fabric进行扩展、创新、优化，建立不同的行业应用模块和平台</p>
<h3 id="框架图"><a href="#框架图" class="headerlink" title="框架图"></a>框架图</h3><p><img src="/2023/01/15/fabric%E5%AD%A6%E4%B9%A0/1.png" style="zoom:67%;"></p>
<p>现在来看一下fabric的架构，fabric和以太坊一样，都是一个区块链2.0的平台，支持可编程</p>
<ul>
<li><p>底层</p>
<ul>
<li>fabric的底层也是p2p网络，通过gRPC的通道进行交互，利用Gossip协议进行区块链同步(节点少的话可以使用tcp进行连接)</li>
</ul>
</li>
<li><p>第二层</p>
<ul>
<li><p>fabric和以太坊一样，拥有属于自己的状态数据库，拥有自己的共识机制</p>
</li>
<li><p>fabric的智能合约被称为链码</p>
</li>
<li><p>fabric没有像以太坊那样的EVM，它是运行在Docker中的容器里的</p>
</li>
<li><p>由于fabric是联盟链，具有准入机制，因此还有以太坊中没有的两个模块：成员服务提供者MSP和区块链加密服务提供者BCCSP。</p>
<ul>
<li>成员服务提供者则是Fabric的安全认证体系，包括用户管理、权限管理、证书管理等；</li>
<li>区块链加密服务提供者是Fabric以可插拔的方式提供的加解密算法等；</li>
</ul>
</li>
</ul>
</li>
<li><p>第三层</p>
<ul>
<li>fabric是以交易、事件的方式来驱动的。应用通过交易向账本记录数据，改变状态，交易的执行逻辑则由链码来完成。企业应用依据Fabric区块链中的事件触发企业应用中的后续处理流程，从而完成基于事件驱动的异步模型。</li>
</ul>
</li>
<li>顶层<ul>
<li>软件开发工具、接口和命令行界面。 Fabric对外提供了基于gRPC的API以及封装API的相应语言的SDK，操作员也可以通过命令行（CLI）直接执行Fabric支持的命令。企业应用通过SDK或API接口访问Fabric区块链网络的多种资源，包括账本、交易、链码并可进行权限管理。</li>
</ul>
</li>
</ul>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><h4 id="模块化框架"><a href="#模块化框架" class="headerlink" title="模块化框架"></a>模块化框架</h4><p>Fabric的核心模块具有高度模块化，都可通过更改配置文件来加载不同的模块实现。比如说：</p>
<ul>
<li>可插拔的共识模块<ul>
<li>可以用国密算法，也可以用SHA来加密。</li>
<li>目前Fabric1.3版本已经实现了solo模式、Kafka模式</li>
</ul>
</li>
<li>可随意安装部署的智能合约<ul>
<li>Fabric中的智能合约称之为链码，链码可以动态安装与升级，从而拓展平台的业务逻辑</li>
</ul>
</li>
<li>可插拔的背书和验证系统链码<ul>
<li>可以给每个通道的每个链码指定不同的背书和验证系统链码，从而完成个性化的验证要求</li>
</ul>
</li>
<li>可选的对等网络gossip服务<ul>
<li>传播来自共识服务所形成的区块</li>
</ul>
</li>
<li>不同形式的账本结构<ul>
<li>Fabric的账本状态数据可以使用不同的数据库管理系统</li>
<li>默认数据库是LevelDB，也可以配置成第三方数据库，如CouchDB。</li>
</ul>
</li>
<li>可插拔的成员服务提供者<ul>
<li>主要负责将网络中的某个实体（节点、组织、成员）和一个加密身份相关联，对实体身份进行认证，是权限管理的基础</li>
</ul>
</li>
</ul>
<h4 id="基于许可的区块链"><a href="#基于许可的区块链" class="headerlink" title="基于许可的区块链"></a>基于许可的区块链</h4><p>这个特性是说，fabric的参与者需要经过认证、审查才能参与到区块链交易中。参与者在一种具有一定程度信任的治理模式下相互协作</p>
<p>由于有信任的存在，可以使用更传统的崩溃容错(CFT)的共识协议，从而避免昂贵的POW等共识协议(因此fabric没有挖矿)</p>
<p>fabric中的许可方法如下：</p>
<ul>
<li>颁发交易参与方、节点等实体的身份证书和用户的身份证书</li>
<li>交易经过签名、背书，证明了其合法性。</li>
</ul>
<h4 id="新的交易模型"><a href="#新的交易模型" class="headerlink" title="新的交易模型"></a>新的交易模型</h4><p>fabric中有区别于传统区块链的交易模型。传统区块链是<strong>先共识再运行</strong>，而fabric是<strong>运行再共识</strong></p>
<h4 id="传统模型"><a href="#传统模型" class="headerlink" title="传统模型"></a>传统模型</h4><p>在P2P网络中，每一个节点都需要进行交易，那么这时候需要确立一个顺序。这时就需要矿工来确认这些交易的执行顺序。</p>
<p>传统区块链的运行步骤是：先通过共识协议对一组交易形成共识区块，再在每个节点中顺序运行共识区块中的交易。因此传统区块链有如下缺陷：</p>
<ul>
<li>所有节点顺序执行交易，导致性能和规模受限</li>
<li>智能合约要在系统中每个节点执行，要求系统采取复杂措施来保护整个系统免受恶意合同的影响，从而限制了系统弹性</li>
<li>如智能合约存储于账本中，限制了智能合约的规模。</li>
</ul>
<h4 id="Fabric中的新模型"><a href="#Fabric中的新模型" class="headerlink" title="Fabric中的新模型"></a>Fabric中的新模型</h4><p>但是在Fabric中，采用了<strong>运行-共识-验证 </strong>的交易执行框架。这个模式在Fabric1.0中开始实行，有客户端、背书节点和排序节点三种角色：</p>
<ul>
<li>客户端发送交易</li>
<li>背书节点执行和验证交易</li>
<li>排序节点通过共识确定一批交易的全局顺序</li>
</ul>
<p>交易运行过程分为三个步骤</p>
<ul>
<li>交易在各个channel之间并行<strong>模拟执行</strong>，但<strong>执行结果不写入</strong> 。</li>
<li>共识节点(排序节点)对多channel提交的交易进行<strong>共识排序</strong>，并打包成区块</li>
<li>各节点验证该共识顺序是否破坏模拟执行的客串行性 ,若通过，就更改本地账本状态</li>
</ul>
<p><img src="/2023/01/15/fabric%E5%AD%A6%E4%B9%A0/3.png"></p>
<p>这边来解决几个问题：</p>
<ol>
<li><p>那么fabric中有没有区块呢？ <strong>有的</strong>。在排序节点中，进行共识服务时会对排序的交易进行打包处理。</p>
</li>
<li><p>在以太坊中，为了限制某些合约无限制调用资源(比如说死循环和生成随机数)，使用了gas进行限制，那么在fabric中是否有这种策略呢？ </p>
<ul>
<li><p>对于随机数，因为fabric并不会像solitude(没有随机函数)一样对java进行限制。因此采用了曲线救国的形式：由于多个背书节点会同时执行，运行结果会有影响，因此无法保证一致性，如果背书节点的运行结果不一致，那么根本不会走到下一步(发送给排序节点)</p>
</li>
<li><p>对于死循环，可以运用超时机制，运行一段时间后没出结果的话就会停止</p>
</li>
</ul>
</li>
</ol>
<p>综上：</p>
<ul>
<li><p>运行交易的节点是智能合约要求的有限的几个节点，也就是上图channel中的背书节点。我们可以来做这样一个类比：Fabric中的节点类似于一个年级群，channel就是不同的班群，不同channel中运行的信息相互独立。而且允许一个节点参与多个channel，就好比一个辅导员管理多个班级一样</p>
</li>
<li><p>在取得共识前运行智能合约，使得账本仅需保存智能合约的运行结果而不是智能合约本身</p>
</li>
<li><p>智能合约可以以文件的形式部署在需要的节点中</p>
</li>
</ul>
<h4 id="企业级智能合约"><a href="#企业级智能合约" class="headerlink" title="企业级智能合约"></a>企业级智能合约</h4><p>智能合约在Fabric中称为链码（chaincode），是区块链应用中的业务逻辑。基于链码的背书策略是指：<strong>哪些节点以及多少节点需要保证智能合约的正确运行</strong></p>
<ul>
<li>每个交易仅需背书策略所必需的节点的子集来认可交易执行结果。</li>
<li>这使得Fabric在运行阶段能够过滤掉不一致的结果，从而消除不确定性(random函数)。</li>
</ul>
<p>因此，运行不确定性的消除使得Fabric成为第一个支持使用通用语言(如Java、Go和Node.js)开发智能合约的区块链平台</p>
<p>比如说，把Fabric运用到工业领域，可以避免仓单重复质押这类非法现象的出现，可以保证账目公开透明</p>
<h4 id="隐私和保密"><a href="#隐私和保密" class="headerlink" title="隐私和保密"></a>隐私和保密</h4><p>Fabric在数据加密、数字签名、安全网络传输的基础上，针对企业应用进行了如下设计：</p>
<ul>
<li>智能合约的保密要求 <ul>
<li>实例：合同的签署各方能够看到优惠的费率及交易的金额，业务流程是保密的</li>
<li>通过将智能合约部署在特定的背书节点，从而保证智能合约仅对特定的交易方可见，从而确保了智能合约的私密性。 [物理隔离]</li>
</ul>
</li>
<li>账本的保密要求 <ul>
<li>传统的区块链平台中，账本数据经过加密处理，但账本数据部署在所有的节点，经过足够的时间或者资源，这些数据还是能被破解，导致企业敏感数据的泄密</li>
<li>Fabric中引入通道（channel）的概念，<strong>有关交易参与方建立一个通道</strong>，账本数据仅仅保存在参与通道的相关节点中[物理隔离]</li>
</ul>
</li>
</ul>
<h2 id="Fabric核心概念"><a href="#Fabric核心概念" class="headerlink" title="Fabric核心概念"></a>Fabric核心概念</h2><h3 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h3><p>Fabric中交易是链码的一次调用，根据链码完成的业务逻辑完成不同的功能，可以实现对账本状态的改变，也可以是一次对账本数据的查询。</p>
<h4 id="部署交易"><a href="#部署交易" class="headerlink" title="部署交易"></a>部署交易</h4><p>主要完成新建链码的安装和初始化，部署交易执行成功也就意味着一个新的链码已经准备好执行对链码调用的交易</p>
<h4 id="调用交易"><a href="#调用交易" class="headerlink" title="调用交易"></a>调用交易</h4><ul>
<li>调用已部署的链码的指定的方法，返回方法的执行结果。</li>
<li>部署交易是调用交易的特例，其参数是打包的链码。</li>
<li>一个完整的交易执行过程需要经过提案、背书、共识(排序)最终提交到账本中</li>
</ul>
<h3 id="背书"><a href="#背书" class="headerlink" title="背书"></a>背书</h3><p>背书在商业上是指对某种交易行为进行担保、保证</p>
<p>Fabric借签这一流程，在交易进入排序和计入账本之前需要交易的相关各方进行背书：</p>
<ul>
<li>Fabric中背书是指背书节点对收到的客户端的交易提案按照自身逻辑进行检查，并调用链码执行交易，背书节点对请求的提案和链码执行结果（状态变更有关的读写集合）进行数字签名的过程。</li>
<li>对于调用链码的应用来说，需要根据链码的要求进行背书才会认为合法，才能提交给排序节点。</li>
</ul>
<p>在Fabric中链码的背书要求称之为背书策略</p>
<ul>
<li>背书策略可以要求指定成员集合中成员的一致同意或者一部分成员的同意甚至某个成员的支持，可以使用多种规则组合。但是一定要找信任的节点，因为其会看到我们所有的交易过程</li>
</ul>
<h3 id="链码（chaincode）"><a href="#链码（chaincode）" class="headerlink" title="链码（chaincode）"></a>链码（chaincode）</h3><p>Fabric中智能合约称为链码（Chaincode），链码是使用编程语言实现预定义接口（Chaincode接口）的一段应用程序，支持Go、Node.js、Java等高级编程语言</p>
<p>链码分为用户链码和系统链码</p>
<ul>
<li><strong>用户链码</strong>运行于独立的容器中，通常所说的链码是用户链码即开发人员基于企业用例所开发的链码</li>
<li><strong>系统链码</strong>则完成链码生命周期管理、分布式账本查询、背书签名、提交验证等系统功能</li>
</ul>
<h3 id="通道（channel）"><a href="#通道（channel）" class="headerlink" title="通道（channel）"></a>通道（channel）</h3><p>通道从狭义讲是Fabric网络成员中一部分节点构成的一个专用通信通道，从而限制网络中其他成员的访问。 Fabric中通道还包括绑定在通道上t的交易、链码、共享账本、成员节点、排序节点等配置和数据。加入通道的节点要有MSP赋予的唯一身份标识，并通过MSP认证通道的相关节点及服务。</p>
<p>Fabric把通道分为两类系统通道（System Channel）和应用通道（Application Channel）</p>
<ul>
<li>系统通道则主要负责对应用通道进行管理，比如为通道增加或者减少一个成员</li>
<li>应用通道主要运行用户链码交易</li>
</ul>
<p>此外，Fabric中还有个创始通道(Genesis Chanel)</p>
<ul>
<li>初始Fabric网络启动时对于每个排序服务来说，启动的一个特殊的排序系统通道 </li>
<li>该通道绑定排序节点并负责应用通道的创建，作为系统创建的首个通道</li>
</ul>
<h4 id="应用通道创建"><a href="#应用通道创建" class="headerlink" title="应用通道创建"></a>应用通道创建</h4><ol>
<li>首先，向系统通道发送配置交易（Configuration Transaction）</li>
<li>然后，排序服务会为该应用通道创建一个创始区块（Genesis Block），创始区块中包含该配置交易及初始配置的相关信息，该配置信息包括通道基本信息、通道访问策略、初始包含的成员信息、锚节点、排序服务地址等。</li>
<li>最后，当某个节点申请加入某条通道时，获取指定通道的配置区块，并调用系统链码的JoinChain方法获取创世区块，并完成账本、通道相关数据结构的初始化工作</li>
</ol>
<h3 id="排序服务"><a href="#排序服务" class="headerlink" title="排序服务"></a>排序服务</h3><p>Fabric的排序服务接收来自客户端的背书后的交易并按通道进行全局一致的排序，将一段时间内的交易形成区块并广播给相应的通道</p>
<p>排序服务就是Fabric提供共识服务的模块，以可插拔的形式实现。</p>
<ul>
<li>目前Fabric除了测试的solo模式，还包括已商业应用的Kafka模式</li>
<li>第三方的CFT或者BFT共识算法也可以插件的形式包含在Fabric中。</li>
</ul>
<p>Fabric排序服务除对交易进行排序形成共识区块或者创建用户通道外并不执行其他操作，也可以通过多个排序节点扩展性能。</p>
<h2 id="Fabric-区块链数据结构"><a href="#Fabric-区块链数据结构" class="headerlink" title="Fabric 区块链数据结构"></a>Fabric 区块链数据结构</h2><h3 id="账本"><a href="#账本" class="headerlink" title="账本"></a>账本</h3><p>首先，我们来说账本、状态数据库以及区块链之间的关系。可由下图表示：</p>
<p><img src="/2023/01/15/fabric%E5%AD%A6%E4%B9%A0/5.png"></p>
<p>账本是一个很宽泛的的概念，它包含了区块链本体以及状态数据库。在以太坊中，状态数据和区块数据都是持久化存放在LevelDB里的；而在Fabric中，有些不一样，二者是分开存储的</p>
<ul>
<li><p>区块链结构记录发生在网络中的交易以及交易所引起的状态的变更</p>
<ul>
<li>一般区块链结构<strong>通过文件系统进行存储</strong>。从数据库角度讲，区块链结构保存了状态变更的记录(可以理解为存放日志)，记录中保存了本次交易设计的变更前状态数据(读集合)和变更后状态数据(写集合)</li>
</ul>
</li>
<li><p>状态数据库则是由区块链结构中交易执行的结果生成，里面记录了最新的世界状态</p>
<ul>
<li>数据通过具有版本号的键值对存储</li>
<li>状态数据库则支持可插拔模块，可支持LevelDB、CouchDB，目前Fabric默认支持LevelDB。</li>
<li>从数据库角度讲，状态数据库则保存了<strong>最新的状态信息</strong></li>
</ul>
</li>
</ul>
<p>事实上，以太坊在LevelDB中，为了保持信息的可验证性，使用的不仅仅是LevelDB中的LSM Tree作为索引,但是LSM不具有防篡改功能，因此使用了改进的MPT树。在Fabric中，用的是Merkle Bucket Tree。</p>
<p>此外，还有历史数据库，里面存放着各个状态的历史变化记录</p>
<h3 id="区块链结构"><a href="#区块链结构" class="headerlink" title="区块链结构"></a>区块链结构</h3><p>区块链的第一个区块是创世区块</p>
<p>在Fabric中并不保存用户交易，主要保存通道创建时的通道配置交易，以后通道配置信息的更改会有新的配置区块来代替。</p>
<p>链式的结构连接所有区块，经过排序服务达成共识的最新区块，会根据区块编号追加到区块链的末尾，每个区块中包含了顺序执行的交易，这些交易可能成功也可能失败。</p>
<p><img src="/2023/01/15/fabric%E5%AD%A6%E4%B9%A0/6.png"></p>
<h3 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h3><ul>
<li><p>区块头部</p>
<ul>
<li>区块编号，包含一个数字区块编号，从0开始递增，最新的区块追加到链的尾部；</li>
<li>当前区块Hash值，即，当前区块包含所有交易的散列</li>
<li>前一个区块Hash值，通过该值所有区块形成链状结构。</li>
</ul>
</li>
<li><p>区块数据</p>
<ul>
<li>按照排序服务形成顺序排列的交易列表。</li>
</ul>
</li>
<li>区块元数据 <ul>
<li>包括块的写入时间及写入者的签名、公钥和证书等信息</li>
<li>提交节点提交区块时，还为每个交易添加是否有效的指示标志</li>
<li>该指示标志不包含在区块Hash值(区块创建时生成)中</li>
</ul>
</li>
</ul>
<h2 id="Fabric框架"><a href="#Fabric框架" class="headerlink" title="Fabric框架"></a>Fabric框架</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p><img src="/2023/01/15/fabric%E5%AD%A6%E4%B9%A0/1.png" style="zoom:67%;"></p>
<h3 id="节点网络"><a href="#节点网络" class="headerlink" title="节点网络"></a>节点网络</h3><p>Fabric中的节点概念来自于P2P网络，节点功能可能是对等一致的，也可能是分工合作的。在Fabric中，节点是区块链网络中的通信主体，一个节点也是一组逻辑功能的逻辑表示，因此一个物理服务器中可以运行不同类型的节点。</p>
<p>因此，在部署时需要考虑如何对节点进行分组并对节点进行访问控制，从而形成一个高效、安全的节点网络。</p>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><ul>
<li>客户端代表最终的用户实体，可以是命令行客户端，也可以是一个应用程序，当作为应用程序时，通过Fabric提供的SDK和区块链网络进行交互。</li>
<li>客户端通常会同时连接到一个节点和一个排序节点，客户端创建并发送交易给相关背书节点，符合背书要求后，发送交易给排序节点。</li>
</ul>
<h4 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h4><ul>
<li>提交节点<ul>
<li>对来自排序节点的新共识块进行验证</li>
<li>记入账本和状态数据库</li>
<li>Fabric中的所有节点都包含该逻辑功能，也就是说所有节点都是提交节点</li>
</ul>
</li>
<li>背书节点<ul>
<li>执行链码并对执行结果进行背书</li>
<li>每个链码的背书节点由链码背书策略决定，不同链码对应的背书借点也可能是不同的</li>
</ul>
</li>
<li>排序服务节点(排序节点)<ul>
<li>排序服务节点接收包含背书签名的交易</li>
<li>对未打包的交易进行排序生成区块</li>
<li>广播给Peer节点</li>
</ul>
</li>
<li>CA节点<ul>
<li>CA节点是可选的，它主要作为证书颁发机构，也可以用其他成熟的第三方CA颁发证书</li>
</ul>
</li>
</ul>
<p><img src="/2023/01/15/fabric%E5%AD%A6%E4%B9%A0/7.png" style="zoom:67%;"></p>
<p>从上图我们可以得到如下信息：</p>
<ul>
<li>一个Fabric网络可以由多个组织(成员)，一个组织在一个通道上可以由多个节点</li>
<li>主节点(Leader Peer)作为代表和排序服务节点通信，负责从排序服务节点处获取最新的区块，并在组织内部同步</li>
<li><p>锚节点代表组织节点与其他组织成员进行信息交换</p>
</li>
<li><p>为保证私密性Fabric区块链网络引入通道（channel）的概念，一个通道可以认为是区块链的一个虚拟专用子网（类似于VPN）</p>
<ul>
<li>区块链网络初始建立时系统默认启动一个包含所有排序节点的系统通道，组织成员根据需要通过系统通道创建专有通道，一个节点可以加入一个或多个通道，一个通道也可以包含多个节点。</li>
<li>Fabric基于通道提交交易、保存账本、执行链码、保存状态，不同通道的账本、状态和智能合约、策略都是隔离的。</li>
</ul>
</li>
</ul>
<h2 id="交易流程"><a href="#交易流程" class="headerlink" title="交易流程"></a>交易流程</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>比如说，企业A向企业B支付一笔货款</p>
<p>节点网络：假设企业A和企业B都有一个节点连接到网络，组织A和B的节点都连接到一个存在的通道</p>
<p>安全体系：应用程序的用户具有CA签发的数字证书并具有相应的权限</p>
<p>链码：链码已经安装到Fabric系统并绑定到通道。链码的背书策略要求转账交易必须有节点A和B的背书</p>
<h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><h4 id="Step1"><a href="#Step1" class="headerlink" title="Step1"></a>Step1</h4><p>客户端创建一个交易提案并根据背书策略发送给相应的背书节点</p>
<ul>
<li>创建<code>ChaincodeInvocationSpec</code>结构，主要包括<code>ChaincodeId</code>和链码方法名及相关参数；</li>
<li>计算交易Id（Transaction Id）</li>
<li>创建<code>Proposal</code>结构，通道头部信息中指定交易类型<code>HeaderType_ENDORSER_TRANSACTION</code>，设置通道Id、交易Id，设置签名头部的随机数和交易创建者；</li>
<li>使用创建者的数字证书对<code>Proposal</code>结构进行签名，形成<code>SignedProposal</code>结构。</li>
<li>根据链码的背书策略获取需要提交的背书节点；</li>
<li>把签名后的交易提案（<code>SignedProposal</code>）提交给相应的背书节点运行。调用<code>EndorserClient</code>接口的<code>ProcessProposal</code>方法</li>
</ul>
<h4 id="Step2"><a href="#Step2" class="headerlink" title="Step2"></a>Step2</h4><p>背书节点收到<code>SignedProposal</code>消息后调用<code>EndorserServer</code>接口的<code>ProcessProposal</code>方法处理签名的交易提案。</p>
<ul>
<li>对签名提案进行检查和校验，具体内容包括：<ul>
<li>消息结构是否完整</li>
<li>消息是否已经被提交过，从而避免重发攻击</li>
<li>客户端签名是否有效，主要是调用MSP的相关服务来完成</li>
<li>提交交易的客户端是否具有相应通道的权限，如读写权限。</li>
</ul>
</li>
<li>启动仿真模式，构造链码Invoke参数，并调用链码相关方法<ul>
<li>链码基于当前状态数据库执行链码并返回响应消息，包括响应值、读集合、写集合，在这个步骤<strong>不涉及任何对状态数据库和账本的更改</strong></li>
</ul>
</li>
<li>调用相应的ESCC链码，对交易结果进行背书，最终形成ProposalResponse结构 <ul>
<li>包含Payload（Response的读写数据集）、Endorsement（背书信息）</li>
</ul>
</li>
<li>背书响应及相关的事件返回客户端</li>
</ul>
<h4 id="Step3"><a href="#Step3" class="headerlink" title="Step3"></a>Step3</h4><p>客户端收集足够的提案背书响应，并向排序服务广播具有足够背书的交易</p>
<ul>
<li>若该交易仅仅查询账本、交易、状态等信息，客户端仅需解析响应消息不需要把交易提交给排序服务。</li>
<li>若该交易涉及账本数据变更，则需向排序服务提交交易，这时客户端需确保提案响应的Payload属性是一致的即交易执行的结果是一致的。</li>
<li>客户端把提案、响应及背书信息打包形成一个完整的交易 (Transaction)，添加头部及客户端签名后形成Envelope，最后通过BroadcastClient向排序服务广播该Envelope。</li>
<li>在该阶段，客户端会过滤掉TransientMap等受限访问的数据，这些数据也不会写入区块链数据库。</li>
</ul>
<h4 id="Step4"><a href="#Step4" class="headerlink" title="Step4"></a>Step4</h4><p>排序服务形成最新的共识块</p>
<ul>
<li>排序服务接收到来自客户端或代理节点广播的交易消息，这些消息可能来自不同的通道 </li>
<li>排序服务按照通道根据可插拔的共识算法，创建每个通道的最新共识块 </li>
<li>排序服务形成共识块后把共识块交付给各个组织的主节点</li>
<li>主节点收到共识块后通过Gossip协议向本组织的其他节点传播，最终一个通道中所有节点都能收到最新的共识块。</li>
</ul>
<h4 id="Step5"><a href="#Step5" class="headerlink" title="Step5"></a>Step5</h4><p>验证和提交交易到账本数据库</p>
<ul>
<li>节点接收到共识块后，对块中的所有交易进行验证<ul>
<li>检查交易的数字签名 </li>
<li>交易符合背书策略 </li>
<li>交易仿真运行时的读取集合版本自运行以来没有变化(KVS中的S即版本，如果S发生变化即会abort)</li>
</ul>
</li>
<li>在提交阶段检查(validation)，确保客户端即使没有对提案响应进行分析并检查背书策略，也能在提交阶段过滤掉不符合要求的交易。</li>
<li>在验证阶段，如果一笔交易中每个读集中的键与世界状态中对应键的版本号一致，那么该笔交易被认为是有效的。</li>
</ul>
<h4 id="Step6"><a href="#Step6" class="headerlink" title="Step6"></a>Step6</h4><p>更新账本数据库</p>
<ul>
<li>节点把验证过的区块附加到相应通道的区块链中</li>
<li>对于区块中验证通过的交易，把写集合提交到状态数据库</li>
<li>向客户端发出一个事件用于通知交易已经写入账本或者交易验证无效，客户端收到事件后完成后续的业务处理。客户端如果收到了abort掉的交易，会重新执行。</li>
</ul>
<h2 id="权限管理与策略"><a href="#权限管理与策略" class="headerlink" title="权限管理与策略"></a>权限管理与策略</h2><h3 id="组织体系"><a href="#组织体系" class="headerlink" title="组织体系"></a>组织体系</h3><ul>
<li>联盟（Consortium）<ul>
<li>若干个组织构成的集合，联盟中的组织成员使用同一个排序服务；</li>
<li>联盟中的每个组织成员都有一个成员服务提供者（MSP）分配的ID信息。</li>
</ul>
</li>
<li>组织(Organization)<ul>
<li>代表一组<strong>拥有共同信任的根证书</strong>的成员（节点）</li>
<li>根证书是CA认证中心给自己颁发的证书,是信任链的起始点。</li>
<li>组织一般包括ID、名称、MSP信息、管理策略、认证密码库类型、锚节点位置等信息。</li>
</ul>
</li>
</ul>
<h3 id="权限体系"><a href="#权限体系" class="headerlink" title="权限体系"></a>权限体系</h3><ul>
<li><p>权限：管理员权限(admin)、读权限(read)和写权限(write)</p>
<ul>
<li><p>读权限（Readers）的操作限制包括获取通道的交易、区块等数据</p>
</li>
<li><p>写权限（ Writers）包括向通道发起交易等</p>
</li>
<li><p>管理员权限（Admins）包括加入通道、修改通道的配置信息等</p>
</li>
</ul>
</li>
<li><p>角色:管理员角色和普通成员角色</p>
<ul>
<li>管理员角色具有管理员权限 </li>
<li>普通成员角色则具有读或写权限</li>
</ul>
</li>
</ul>
<h3 id="通道策略"><a href="#通道策略" class="headerlink" title="通道策略"></a>通道策略</h3><p>在Fabric中通道配置文件中的通道策略负责对通道内各种操作权限进行管理。</p>
<ul>
<li><p>通道策略中会对管理员、读、写等权限定义具体允许的操作以及授权的用户列表。 </p>
</li>
<li><p>通道策略(Channel Policy)是层级化结构，最上层为/Channel ，各级元素，下一级则挂接组织或组织单元</p>
</li>
</ul>
<h3 id="证书体系"><a href="#证书体系" class="headerlink" title="证书体系"></a>证书体系</h3><h4 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h4><p>以每个组织为单位，每个OU（Organizational Unit，组织单位）会生成单独的根证书。</p>
<p>组织的证书信息包括：</p>
<ul>
<li>CA：存放组织的根证书和对应的私钥文件，默认采用EC算法，证书为自签名。组织内的实体将基于该根证书作为证书根。</li>
<li>MSP：存放代表该组织的身份信息，用于节点和客户端的MSP服务。<ul>
<li><code>admincerts</code> ：组织管理员的身份验证证书，被根证书签名。</li>
<li><code>cacerts</code> ：组织的根证书，同ca 目录下文件。 </li>
<li><code>tlscacerts</code> ：用于TLS（Transport Layer Security，传输层安全协议）的CA证书，自签名。</li>
</ul>
</li>
</ul>
<h4 id="节点-1"><a href="#节点-1" class="headerlink" title="节点"></a>节点</h4><p>Fabric中每个节点（背书节点、提交节点、排序节点）、客户端都会在相应目录中建立一套目录，用于存放相关的证书文件。该目录结构包括MSP 证书和TLS 证书两类。</p>
<ul>
<li>MSP <ul>
<li><code>admincerts</code> ：组织管理员的身份验证证书。Peer 将基于这些证书来认证交易签署者是否为管理员身份。 </li>
<li><code>cacerts</code>：存放组织的根证书。 </li>
<li><code>keystore</code> ：本节点的身份私钥，用来签名。 </li>
<li><code>signcerts</code>： 验证本节点签名的证书，被组织根证书签名。</li>
<li><code>tlscacerts</code> : TLS 连接用的身份证书，即组织TLS 证书。</li>
</ul>
</li>
<li>TLS，存放TLS相关的证书和私钥<ul>
<li><code>ca.crt</code>：组织的根证书。 </li>
<li><code>server.crt</code> ：验证本节点签名的证书，被组织根证书签名。</li>
<li><code>server.key</code> ： 本节点的身份私钥，用来签名。</li>
</ul>
</li>
</ul>
<h3 id="成员服务提供者-MSP"><a href="#成员服务提供者-MSP" class="headerlink" title="成员服务提供者 - MSP"></a>成员服务提供者 - MSP</h3><p>MSP（Membership Service Providers，成员服务提供者 ）用于对某个资源（组织、节点、用户等）进行身份验证的一组机制，是实现权限管理的基础</p>
<ul>
<li>具体的身份</li>
<li>用户证书验证</li>
<li>用户证书撤销</li>
<li><p>签名生成和验证</p>
<p>MSP是一个可插拔模块，其设计了成员服务相关操作的框架，具体的证书验证与认证由相应的MSP实现模块完成，用户可以根据要求完成个性化MSP的实现模块</p>
</li>
</ul>
<p>MSP的划分比较灵活，一般可以一个组织有一个MSP。</p>
<p><img src="/2023/01/15/fabric%E5%AD%A6%E4%B9%A0/8.png" style="zoom:67%;"></p>
<p>Fabric中同一个内部的成员之间共有一个根证书，Gossip也是基于MSP进行数据同步。</p>
<h4 id="MSP结构"><a href="#MSP结构" class="headerlink" title="MSP结构"></a>MSP结构</h4><p>一个MSP一般包括9个部分，并以目录的形式存储在节点或客户端，MSP的名称是根目录，每个部分是子目录。MSP会在节点启动时把目录中的信息加载到<code>FabricMSPConfig</code>结构中。如下图所示：</p>
<p><img src="/2023/01/15/fabric%E5%AD%A6%E4%B9%A0/9.png"></p>
<ul>
<li>根证书列表(Root Cas)，一个自签名的证书列表，MSP中的成员都是以根证书列表为根的证书，同一根证书列表中的证书构成一个信任域； </li>
<li>中间证书列表(Intermediate Cas)，根证书到叶子证书的信任链中的中间部分证书，可以按组织机构或业务等划分，是可选参数。类比一下，根证书类似于教育部；华师大就类似于中间证书，还有叶子证书等划分</li>
<li>组织单元列表(Organizational Units (OUs))，组织的下级单元列表，当基于OU限制一些权限时，可以设置该参数，是可选参数；</li>
<li>管理员列表(Administrators)，组织的管理员证书列表；</li>
<li>吊销列表(Revoked Certificates)，已经从CA吊销的证书列表，该列表中的证书没有权限访问Fabric中的资源；</li>
<li>节点身份证书(Node Identity)，表明节点的身份信息，一般用于背书验证； </li>
<li>签名证书(KeyStore for Private Key)，节点身份证书的私钥，用于数字签名或背书；</li>
<li>TLS根证书列表(TLS Root Cas)，用于TLS通讯的根证书列表，一般组织之间、节点与排序节点之间跨网通讯时需使用TLS进行消息传输；</li>
<li>TLS中间证书列表(TLS Intermediate CA)，用于TLS通讯的中间证书，是可选参数。</li>
</ul>
<h4 id="MSP层级"><a href="#MSP层级" class="headerlink" title="MSP层级"></a>MSP层级</h4><ul>
<li>全局MSP(Network MSP)，面向整个Fabric网络，配置网络管理员列表，其成员能够完成一些网络管理任务，如创建应用通道；</li>
<li>通道MSP(Channel MSP)，通道MSP是虚拟的MSP，存在通道配置文件中，当通道MSP发生改变时，需要通过配置管理交易进行通道内节点的同步，通道内所有节点和客户端的通道MSP是一致的；</li>
<li>本地MSP(Local MSP)，定义了本地资源（节点、客户端）的管理和参与权限，每个节点或客户端仅仅对应一个本地MSP，并且本地MSP以目录的形式在文件系统中保存</li>
</ul>
<p>本地MSP和通道MSP的关系 </p>
<ul>
<li>对于一个有两个组织Org1和Org2的网络，每个组织有一个节点</li>
<li>当一个管理员B连接到节点，B具有RCA1签发的证书，当B试图在节点上安装链码时，系统会在本地MSP（ORG1-MSP）中验证B是否是Org1的合法成员，验证成功则B可以安装该链码。</li>
</ul>
<p><img src="/2023/01/15/fabric%E5%AD%A6%E4%B9%A0/10.png"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/08/24/HTTPS%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/08/24/HTTPS%E5%AD%A6%E4%B9%A0/" itemprop="url">HTTPS学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-08-24T23:11:29+08:00">
                2022-08-24
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-08-26T20:07:56+08:00">
                2022-08-26
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HTTPS学习"><a href="#HTTPS学习" class="headerlink" title="HTTPS学习"></a>HTTPS学习</h1><p>参考博客</p>
<ul>
<li><a href="https://blog.csdn.net/qq_36885515/article/details/123137827" target="_blank" rel="noopener">https://blog.csdn.net/qq_36885515/article/details/123137827</a></li>
<li><a href="https://www.cnblogs.com/loleina/p/8418085.html" target="_blank" rel="noopener">https://www.cnblogs.com/loleina/p/8418085.html</a></li>
<li><a href="https://www.jianshu.com/p/4932cb1499bf" target="_blank" rel="noopener">https://www.jianshu.com/p/4932cb1499bf</a></li>
</ul>
<h2 id="HTTPS的基本概念"><a href="#HTTPS的基本概念" class="headerlink" title="HTTPS的基本概念"></a>HTTPS的基本概念</h2><p>HTTPS 是最流行的HTTP 安全形式。它是由网景公司首创的，所有主要的浏览器和服务器都支持此协议。HTTPS 的URL 以<code>https://</code>，而不是<code>http://</code>开头，据此就可以分辨某个Web 页面是通过HTTPS 而不是HTTP 访问的。</p>
<p> <code>HTTPS = HTTP + SSL（TLS）</code>，HTTPS 就是在安全的传输层上发送的HTTP。如下图所示：HTTPS 没有将未加密的HTTP 报文发送给TCP，它在将HTTP 报文发送给TCP 之前，先将其发送给了一个安全层，对其进行加密。现在，HTTP 安全层是通过SSL 及其现代替代协议TLS 来实现的。我们遵循常见的用法，用术语SSL 来表示SSL 或者TLS。</p>
<h3 id="HTTPS与HTTP的区别"><a href="#HTTPS与HTTP的区别" class="headerlink" title="HTTPS与HTTP的区别"></a>HTTPS与HTTP的区别</h3><p>HTTPS跟HTTP相比，有以下几个明显的优点：</p>
<ul>
<li>服务器认证（客户端知道它们是在与真正的而不是伪造的服务器通话）</li>
<li>客户端认证（服务器知道它们是在与真正的而不是伪造的客户端通话），通常现在web服务，不需要做客户端认证，只需要做服务器认证；</li>
<li>完整性（客户端和服务器的数据不会被修改），因为整个传输过程是加密的；</li>
<li>加密（客户端和服务器的对话是私密的，无需担心被窃听），使用wireshake监听HTTPS端口会捕获不到数据。</li>
<li>效率（一个运行的足够快的算法，以便低端的客户端和服务器使用），如果使用HTTP+特别复杂的数据加密技术来试图替代HTTPS，交互的双方在加解密的过程会消耗大量的性能，性能下降特别明显。</li>
<li>普适性（基本上所有的客户端和服务器都支持这些协议）。</li>
<li>管理的可扩展性（在任何地方的任何人都可以立即进行安全通信）。</li>
<li>适应性（能够支持当前最知名的安全方法）。</li>
<li>在社会上的可行性（满足社会的政治文化需要）。</li>
</ul>
<h2 id="TLS-SSL"><a href="#TLS-SSL" class="headerlink" title="TLS/SSL"></a>TLS/SSL</h2><p>早期的互联网协议基本都是不加密进行传输的，如HTTP、FTP、telnet.等协议的</p>
<p><strong>传输层安全性协议</strong>（英语：<strong>T</strong>ransport <strong>L</strong>ayer <strong>S</strong>ecurity，缩写：<strong>TLS</strong>）及其前身<strong>安全套接层</strong>（英语：<strong>S</strong>ecure <strong>S</strong>ockets <strong>L</strong>ayer，缩写：<strong>SSL</strong>）的历史进程如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>协议</th>
<th>发布时间</th>
<th>状态</th>
</tr>
</thead>
<tbody>
<tr>
<td>SSL 1.0</td>
<td>未公布</td>
<td>未公布</td>
</tr>
<tr>
<td>SSL 2.0</td>
<td>1995年</td>
<td>已于2011年弃用</td>
</tr>
<tr>
<td>SSL 3.0</td>
<td>1996年</td>
<td>已于2015年弃用</td>
</tr>
<tr>
<td>TLS 1.0</td>
<td>1999年</td>
<td>已于2020年弃用</td>
</tr>
<tr>
<td>TLS 1.1</td>
<td>2006年</td>
<td>已于2020年弃用</td>
</tr>
<tr>
<td>TLS 1.2</td>
<td>2008年</td>
<td></td>
</tr>
<tr>
<td>TLS 1.3</td>
<td>2018年</td>
</tr>
</tbody>
</table>
</div>
<h3 id="SSL-TLS属于哪一层"><a href="#SSL-TLS属于哪一层" class="headerlink" title="SSL/TLS属于哪一层"></a>SSL/TLS属于哪一层</h3><p>这个问题十分有意思，从前面的发展历史中我们不难知道，TLS可以视为是SSL的高级版本（主要体现在更加安全上），而从TLS的名字（传输层安全性协议）就会觉得它应该是传输层的协议，当然这可能就望文生义了，实际上在网上有不少的文章在讨论TLS/SSL属于应用层还是传输层，实际上的情况要更为复杂一些</p>
<p>我们知道，网络层有三种划分：OSI模型、TCP/IP模型和五层网络模型，如下图所示：</p>
<p><img src="/2022/08/24/HTTPS%E5%AD%A6%E4%B9%A0/2.png" style="zoom:150%;"></p>
<p>首先我们对SSL/TLS的作用进行分析：SSL/TLS最初是为了给HTTP协议加密使用，也就是HTTPS协议，通常来说我们可以认为HTTP+SSL/TLS=HTTPS，而实际上现在我们的很多其他应用层协议都可以使用SSL/TLS，比如SSH、FTPS、POP3S、IMAPS等等。再以HTTPS为例，一个HTTPS建立连接需要经过TCP握手建立连接这一步骤的，也就是说HTTPS还是基于TCP的，而TCP属于传输层这是毫无争论的。也就是说从划分最细的OSI七层参考模型来看，SSL/TLS应该是在传输层和应用层之间。</p>
<p>实际上从SSL/TLS的功能来分析：</p>
<p><img src="/2022/08/24/HTTPS%E5%AD%A6%E4%B9%A0/3.png" style="zoom:150%;"></p>
<ul>
<li>SSL Record Protocol（SSL记录协议），它建立在可靠的传输协议（如TCP）之上，SSL/TLS使用了双向字节流传输（全双工），为高层协议提供数据封装、压缩、加密等基本功能的支持，从功能上看这应该是OSI的L6（表示层）</li>
<li>SSL Handshake Protocol（SSL握手协议）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等，从功能上看这应该是OSI的L5（会话层）</li>
</ul>
<p>对应五层的网络模型呢？由于OSI模型中的L5、L6、L7都合并成了应用层，所以SSL/TLS应该是属于传输层和应用层了。</p>
<h3 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h3><p>这一部分我在 <a href="https://jasonxqh.github.io/2022/03/03/区块链基础-哈希/#哈希函数在区块链中的应用">哈希函数在区块链中的应用</a> 博客中已经学习过了，但是我们再来加深一边印象</p>
<p>讲到加密，必然需要理解加密算法，而加密算法一般来说可以分为<strong>对称加密</strong>和<strong>非对称加密</strong>两种。</p>
<p><img src="/2022/08/24/HTTPS%E5%AD%A6%E4%B9%A0/4.png" style="zoom:150%;"></p>
<p>这里的对称和非对称是针对加密和解密这两个操作而言的，一般来说是消息发送方发送消息时需要加密，消息接收方在接收消息后需要进行解密。<strong>如果加密和解密用的密钥是相同的，则是对称加密；如果不同则是非对称加密。</strong></p>
<h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><p><strong>对称加密算法的特点是算法公开、计算量小、加密速度快、加密效率高。</strong>常见的对称加密算法有AES、DES等。</p>
<p>对称加密最大的问题在于密钥的传输：因为如果信息的发送方和接收方是通过网络来进行通信的，而在网络中使用明文通信是不安全的，想要安全通信必须使用密钥加密，同时要保证密钥只有通信双方知道，但是在传输密钥之前双方并没有一个安全可靠双方都知道的密钥。如果最开始的密钥传输过程使用明文，就可能会被别有用心的人截获密钥，之后的加密就毫无意义。</p>
<p>当然，最保险的方法就是线下传输密钥然后再线上通信，可以参考谍战片中的特务舍生取义护送密码本，但是这在互联网时代显然不靠谱。</p>
<h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><p>这时候非对称加密就出现了，非对称加密最大的特点就是把密钥进行分离，将其分成公钥和私钥两个部分，常见的非对称加密算法主要有 RSA 、 DSA 、ECC等。</p>
<p>顾名思义，公钥是可以用在互联网中随意传播的，而私钥则是需要自己小心保存避免泄露的。消息的发送方只需要知道消息接受方的公钥，即可将明文通过公钥加密然后通过网络传输给消息接收方。消息接收方收到密文后，通过非对称加密算法，使用自己的私钥进行解密，即可获取消息内容。</p>
<p> 这里面有几个点需要额外关注一下：</p>
<ul>
<li>公钥是所有人都可以获取的，因此想要给接收方发送消息只需要获取公钥即可，所以公钥可以用明文直接传输，因为即使是在传输过程中泄露了公钥，由于解密只能使用私钥，因此整个数据传输也还是安全的</li>
<li>在通信过程中一般两边都涉及到消息的发送和接收，因此在通信过程中一般会有两套密钥对</li>
<li>可以根据私钥生成公钥，反之不行</li>
<li>消息发送方是无法对发送出去的密文解密的，它只能读取自己保存的明文来了解之前发送过的消息</li>
<li>如果用私钥加密，由于公钥的信息是在全网传播的，那么在这种情况下是否可以认为非对称加密的意义不大？会有第三方用公钥嗅探的可能？<ul>
<li>有可能，此时就需要加入时间的因素，我们可以给一个HTTPs定一个会话时间 ，只要这个时间设置的合理，那么及时第三方嗅探到了，当前的会话也早已经结束了</li>
</ul>
</li>
</ul>
<h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><h5 id="场景引入"><a href="#场景引入" class="headerlink" title="场景引入"></a>场景引入</h5><p><strong>在通信的过程中，我们使用公钥加密，私钥解密，因为私钥是自己才有的，而传输的信息是不安全的可能被别人截获的，但是只要对其进行加密，然后保证自己才能解密，就可以认为传输信息是安全的。</strong>这就好比使用了一个很安全的保险箱来存放重要资料再快递到别的地方去，只要保证只有自己能够解锁保险箱，那么运输过程中保险箱会被谁接触到都不重要，只要保险箱送到目的地就可以了。</p>
<p>即便是非对称加密，也存在一个公钥传输的问题。基本上存在着两种方案，一种是直接把公钥放到网上，然后让需要使用的用户去下载，另一种就是在通信传输过程中，由服务器直接发送给客户端。这两种方法都存在一个问题就是无法保证公钥传输的安全性，虽然公钥是可以给任何人知道的，但是在通信过程中使用的公钥必须是通信双方的公钥，否则如果出现中间人劫持了通信并且将公钥替换为中间人自己的公钥，那么中间人就可以获取到通信内容。</p>
<p>我们设想一个情景：</p>
<p>现在Bob决定给Pat写一份信，信件的内容不用加密，但是要保证Pat收到信件后，能够确认信件的确是Bob发出的，而不是别人冒充Bob发给Pat的，应该如果做呢？</p>
<h5 id="数字签名-1"><a href="#数字签名-1" class="headerlink" title="数字签名"></a>数字签名</h5><p>首先，Bob将信件通过hash软件计算一下，得到一串消息摘要（有的文章也称之为“hash值”）。这一过程能够保证2点：</p>
<ol>
<li><p>过程不可逆。即不能通过消息摘计算出信件的内容。</p>
</li>
<li><p>消息摘要不会重复。即如果信件有任何改动，再次hash计算出的消息摘要一定不会和改动前的消息摘要一致。</p>
</li>
</ol>
<p><img src="/2022/08/24/HTTPS%E5%AD%A6%E4%B9%A0/7.png" style="zoom:150%;"></p>
<p>然后，Bob<strong>使用自己的私钥</strong>，将消息摘要加密。加密后的结果，我们称之为“数字签名”。现在，Bob就可以将信件连同数字签名一起发给Pat。</p>
<p><img src="/2022/08/24/HTTPS%E5%AD%A6%E4%B9%A0/9.png" style="zoom:150%;"></p>
<p><img src="/2022/08/24/HTTPS%E5%AD%A6%E4%B9%A0/10.png" style="zoom:150%;"></p>
<p>Pat收到信件以后，会做2件事：</p>
<ol>
<li><strong>使用Bob的公钥将数字签名解密</strong>，得到信息摘要。如果顺利解密，说明的确是Bob签发的数字签名，不是别人签发的，因为Bob的私钥没有公开。</li>
<li>Pat使用hash软件对信件再次进行hash计算，和<strong>解密数字签名得到的消息摘要对比</strong>，如果一致，说明信件没有篡改，确实是Bob发出的。这就是数字签名的过程。它能够确保签名人发出的消息不被篡改，也能证明的确是签名人发出的消息。</li>
</ol>
<p> <img src="/2022/08/24/HTTPS%E5%AD%A6%E4%B9%A0/8.png" style="zoom:150%;"></p>
<p>通过数字签名，可以保证公钥传输的安全性，如果在路上公钥被人劫持，那么用其他人的公钥是无法顺利解锁Bob的数字签名的。</p>
<p>一切看上去是那么的完美，使用公钥私钥，即能加解密消息，又可以数字签名。</p>
<p>但是，我们再设想一个情况，如果有个坏人Doug, 他要欺骗Pat，冒充Bob给Pat写信，他应该怎么做的？</p>
<p>由于公钥是公开的，并可以导入到电脑，这时候Doug可以偷偷在Pat的电脑上，用自己的公钥替换了Bob的公钥，然后用自己的私钥加密数据，给Pat发送Email。这时候Pat收到的邮件其实是Doug冒充的，但是由于公钥被替换，所以他无法察觉。这时候，该怎么办呢？</p>
<h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><p>这时候数字证书的用处就来了，使用数字证书可以确保公钥不被冒充。Bob该如何操作的呢？</p>
<ol>
<li><p>首先Bob去找证书中心(CA)，为公钥做认证。 CA用自己的私钥，对Bob的公钥和一些相关信息一起加密。生成了数字证书：</p>
<p><img src="/2022/08/24/HTTPS%E5%AD%A6%E4%B9%A0/11.jpg" style="zoom:150%;"></p>
<ol>
<li>Bob在写给Pat的邮件中，除了数字签名，另外加上了这张数字证书，告诉Pat我的公钥是可信的</li>
</ol>
<p><img src="/2022/08/24/HTTPS%E5%AD%A6%E4%B9%A0/12.jpg" style="zoom:150%;"></p>
<ol>
<li>Pat收到Email后用CA的公钥解密这份数字证书，拿到Bob的公钥，然后验证数字签名，后面流程就和图1的流程一样了。由于坏人Doug不能伪造这样一封数字证书(数字证书拥有权威性)，也就不能伪装Bob了。</li>
</ol>
</li>
</ol>
<p>那么，还是有几点疑惑需要解决：</p>
<ul>
<li>假设数字证书被伪造了呢？<ul>
<li>是的，传输中数字证书有可能被篡改。因此数字证书也是经过数字签名的，上文说道数字签名的作用就是验证数据来源以及数据完整性！Pat收到邮件后可以先验证这份数字证书的可靠性，通过后再验证数字签名。</li>
</ul>
</li>
<li>要是有1万个人要给Pat发邮件，难道Pat要保存1万份不同的CA公钥吗？<ul>
<li>不需要，CA认证中心给可以给B一份“根证书”，里面存储CA公钥来验证所有CA分中心颁发的数字证书。CA中心是分叉树结构，类似于公安部-&gt;省公安厅-&gt;市级派出所，不管A从哪个CA分支机构申请的证书，B只要预存根证书就可以验证下级证书可靠性。</li>
</ul>
</li>
<li>如何验证根证书可靠性？<ul>
<li>无法验证。根证书是自验证证书，CA机构是获得社会绝对认可和有绝对权威的第三方机构，这一点保证了根证书的绝对可靠。如果根证书都有问题那么整个加密体系毫无意义。</li>
</ul>
</li>
</ul>
<h5 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h5><p>数字证书是部署HTTPS认证的网站的必需品，我们在访问一个网站的时候，一般点击浏览器地址栏旁边的小锁就可以看到这时候正在使用的数字证书：</p>
<p><img src="/2022/08/24/HTTPS%E5%AD%A6%E4%B9%A0/5.png" style="zoom:150%;"></p>
<p>点击进去就可以看到相关的证书信息。证书中包含着十分多的信息，首先最重要的当然是对应的域名和公钥，其他的还有证书的生效时间，使用的加密算法、签名算法等各种相关信息。</p>
<p><img src="/2022/08/24/HTTPS%E5%AD%A6%E4%B9%A0/13.png"></p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>签发证书的机构被称为 CA（ Certificate Authority），理论上每个人都可以成为CA，因为每个人都可以自己签发证书，但是只有极少数的权威CA颁发的证书才会被承认，这几大权威CA的称为ROOT CA，他们的证书一般都会内置在操作系统中，浏览器默认是信任这些ROOT CA的证书的，而这些ROOT CA下属还有其他的CA，这些下属的CA可以为各种网站颁发证书，根据层层信任的原则，浏览器也会信任这些CA下发的证书，最终就保证了通信中公钥传输的安全。</p>
<p>早期的证书是需要收费的，但是到了近几年加密通信的需求增加，很多网站的运营者并没有那么多钱来购买证书（证书过期了续费也是要钱的），这时候就出现了以Encryption Everywhere、 Let’s Encrypt等为首的CA开始大量普及免费的数字证书，如今国内的很多云厂商也提供了各种免费的数字证书，从而很好的推动了加密通信的发展。不过这些免费的数字证书在安全性上并没有企业级的收费证书那么高，大多数都只是DV证书，如果对安全性有很高的追求，还是建议购买收费的证书。</p>
<p>一般来说数字证书可以按照安全程度分为以下三类：</p>
<p>EV：<strong>EV证书(Extended Validation Certificate)</strong>是一种根据一系列特定标准颁发的X.509电子证书，根据要求，在颁发证书之前，证书颁发机构(CA)必须验证申请者的身份。不同机构根据证书标准发行的扩展验证证书并无太大差异，但是有时候根据一些具体的要求，特定机构发行的证书可以被特定的软件识别</p>
<p>OV：OV证书(Organization Validation SSL)，指需要验证网站所有单位的真实身份的标准型SSL证书，此类证书不仅能够起到网站信息加密的作用，而且能向用户证明网站的真实身份</p>
<p>DV：DV证书(Domain Validation SSL)，指需要验证域名的有效性。该类证书只提供基本的加密保障，不能提供域名所有者的信息</p>
<h3 id="TLS加密握手过程"><a href="#TLS加密握手过程" class="headerlink" title="TLS加密握手过程"></a>TLS加密握手过程</h3><p>TLS本身是一个混合加密系统，也就是说它使用了对称加密和非对称加密两种方式，<strong>首先是使用非对称加密来传输在这次会话过程中生成的用于生成对称加密的密钥（ pre-master key），结合明文传输的随机数和算法生成对称加密的密钥之后再使用对称加密进行通信。</strong>这样通信的原因是因为非对称加密虽然很安全，但是效率实在是太低了（比对称加密慢几个数量级），因此只用来传输对称加密的密钥，之后就使用效率更高的对称加密来通信。</p>
<p>TLS支持多种密钥交换算法（key exchange algorithms） 和加密算法（ciphersuites），不同的客户端和服务器之间支持的也各不相同，因此在加密通信之间就需要进行协商，<strong>客户端和服务端需要协商清楚使用何种算法，使用何种加密方式，使用什么密钥等等问题，这一个过程称为握手过程（handshake）。</strong>就好像TCP连接在建立前需要进行三次握手一样，所有的TLS通信在开始之前都需要进行握手（handshake）。当客户端和服务器完成TCP三次握手建立TCP连接之后，就开始进行TLS的握手过程，具体的流程如下：</p>
<ol>
<li><p>首先由客户端发送Client Hello 消息到服务器，消息中主要包含了客户端支持的<code>ciphersuites</code>, TLS版本信息和客户端随机数，此时是<strong>明文传输</strong></p>
</li>
<li><p>服务器接收到消息后，返回自己支持的<code>ciphersuites</code>， TLS 版本，自己的数字证书和服务器端生成的随机数。<strong>注意此时是明文传输</strong></p>
</li>
<li><p>客户端开始验证数字证书，可能会不断往上追溯 CA、CA 的 CA、CA 的 CA 的 CA，<strong>直到一个授信的 CA</strong>。验证完证书之后生成一个新的<code>pre-master key</code>，再使用证书中的公钥来对<code>pre-master key</code>进行加密，然后发送给服务器。<strong>注意此时是非对称加密传输</strong></p>
</li>
<li><p>服务器接收到客户端发送过来的非对称加密的密文，使用自己的私钥进行解密，获得了<code>pre-master key</code>。<strong>注意此时是非对称加密传输</strong></p>
</li>
</ol>
<p>到这里为止，服务器和客户端都有三组数字，<strong>分别是客户端的随机数、服务器的随机数和pre-master key。</strong>其中由于客户端的随机数和服务器的随机数都是使用明文传输，所以这两个数字是有被暴露的风险的，但是由于pre-master key是使用非对称加密传输，十分安全，所以将这三者结合，使用之前协商好的特定的算法就可以生成一个密钥，<strong>这个密钥称为shared secert</strong>。也就是<strong>之后用来对称加密的密钥</strong>。</p>
<ol>
<li><p>客户端在计算出对称加密的密钥之后，使用该密钥进行对称加密通信，告知服务器之后都使用该密钥进行对称加密。注意此时是对称加密传输</p>
</li>
<li><p>服务器接收到密文后，使用之前计算出的密钥来进行对称解密，解密成功之后，再使用该密钥进行对称加密通信。告知客户端密钥确认无误，可以使用该密钥进行通信。注意此时是对称加密传输</p>
</li>
<li><p>至此，整个TLS的握手过程完整，之后就可以开始对称加密的通信了。</p>
</li>
</ol>
<p><img src="/2022/08/24/HTTPS%E5%AD%A6%E4%B9%A0/14.png"></p>
<p>疑问：既然</p>
<h3 id="TLS1-2"><a href="#TLS1-2" class="headerlink" title="TLS1.2"></a>TLS1.2</h3><p>纵观整个SSL/TLS协议的发展史，我们可以发现整个SSL/TLS协议就是不断地填坑的一个过程，不断地对旧版本的协议中的各种漏洞进行修补迭代更新，然后发布新的版本，直到TLSv1.2版本才算是一个不错的可用的加密协议版本。即便如此，对应TLSv1.2来说还是有着太多的历史包袱和兼容性的问题，尽管在功能实现上的漏洞可以通过补丁来进行修补，但是在协议设计之初就存在的问题是没有办法修复的，只能推倒重来，于是就出现了后面的TLSv1.3。这里我们先了解一下TLSv1.2版本中的一些主要的问题：</p>
<h5 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h5><p>作为一个提供安全通信的协议，安全问题是首要的也是致命的问题。TLS发展到1.2以来，已经被很多机构和学者曝出有各种各样的安全漏洞，包括密钥交换算法（key exchange algorithms）、加密套件（ciphersuites）和数字签名（digital signatures）各个方面都存在安全问题，很多都是由于历史原因兼容问题而遗留下来的问题。</p>
<p>还有一些则是设计协议本身就存在的问题如TLS重新协议（renegotiation）可以让心怀不轨的人将高版本的TLS协议重新协商降级到低版本的不安全的协议然后进行攻击。</p>
<p>或者是SNI的不加密问题，TLS1.2及之前的协议都不SNI进行加密，这也存在了很大的风险。</p>
<h5 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h5><p>互联网上一直存在着加密传输对性能有很大损耗的说法，实际上了解了上面的TLSv1.2握手过程之后，我们可以知道加密传输对性能确实有损耗，但是远没有到很多人鼓吹的那么严重的程度。而且在后面也加入了很多诸如OCSP、HSTS等技术来提高其性能表现，但是即便如此，整个TLSv1.2的握手过程也需要2-RTT，也就是在客户端和服务器之间来回两次才能顺利建立TLS传输，这还是在一切都进行顺利的情况下。</p>
<h3 id="TLS1-3"><a href="#TLS1-3" class="headerlink" title="TLS1.3"></a>TLS1.3</h3><p>TLSv1.3是TLS协议更新中变化非常大的一个版本，加入了许多新的特性和性能优化，并且不完全前向兼容，因此也有些人认为应该称为TLSv2.0，不过最后还是命名为TLSv1.3。</p>
<p>针对TLSv1.2中存在的安全和性能问题，TLSv1.3在设计的时候就放弃了前向兼容性，不再对之前的版本进行兼容，同时禁用了大量不安全的算法，使用了少量安全的算法来设计协议，这样的好处就是可以简化握手过程中的操作，使得握手过程从2-RTT变为1-RTT，同时有效提高安全性和性能。</p>
<h4 id="TLS1-3和TLS1-2的主要不同"><a href="#TLS1-3和TLS1-2的主要不同" class="headerlink" title="TLS1.3和TLS1.2的主要不同"></a>TLS1.3和TLS1.2的主要不同</h4><ul>
<li>部分新的密码套件（ciphersuite）只能在TLSv1.3中工作，并且TLSv1.3不支持之前在TLSv1.2前用的旧的密码套件ciphersuites。也就是说如果需要使用TLSv1.3就必须要添加新的只能在TLSv1.3中使用的密码套件</li>
<li>新的密码套件（ciphersuites）和之前的密码套件定义不同，并不需要指定对应的证书类型(e.g. RSA, DSA, ECDSA) 或者是密钥交换机制 (e.g. DHE or ECHDE)</li>
<li>TLSv1.3不再支持DSA证书</li>
<li>TLS1.3中不再支持重新协商（Renegotiation），即不可能像TLSv1.2之前那样通过重新协商来回退到更早的更不安全的版本</li>
<li>TLS1.3中更多的握手过程都被加密了（Server Hello之后都会进行加密）</li>
<li>TLSv1.3支持更多的的消息类型，即对自定义的扩展API和认证传输有更好的扩展性<br>客户端在TLS握手阶段发送ClientHello数据包的时候需要提供支持的密码套件（ciphersuite）和密钥共享（key_share）从而提高速度，如果client发送的keyshare类型是server不支持，那就不是1-RTT。<br>sessions会话在TLS握手完成之后才会建立，所以在session和TLS握手之间可能会有空隙（即不是连续的）</li>
</ul>
<h4 id="TLS1-3中的密钥交换算法"><a href="#TLS1-3中的密钥交换算法" class="headerlink" title="TLS1.3中的密钥交换算法"></a>TLS1.3中的密钥交换算法</h4><p>TLS 1.3的核心宗旨是简单性。在新版本中，除去了Diffie-Hellman（DH）密钥交换以外的所有密钥交换算法。TLS 1.3还定义了一组经过测试的DH参数，无需与服务器协商参数。由于只有一个密钥交换算法（具有内置参数）和少数支持的密码，因此设置TLS 1.3通道所需的绝对带宽比早期版本要少得多。</p>
<p>我们来看DH算法交换密钥的步骤。假设客户端和服务器双方需要传递密钥，他们之间可以这么做：</p>
<ol>
<li>客户端首选选择一个素数p，例如509; 底数g，任选，例如5 ; 随机数a，例如123; 然后计算A=$g^a \mod p$，结果是215，然后，客户端发送p＝509，g=5，A=215给服务器；</li>
<li>服务器收到后，也选择一个随机数b，例如，456，然后计算$B=g^b \mod p$，结果是181，服务器再同时计算$s=A^b \mod p$，结果是121；</li>
<li>服务器把计算的B=181发给客户端，客户端计算$s＝B^a \mod p$的余数，计算结果与服务器算出的结果一样，都是121。</li>
</ol>
<p>所以最终双方协商出的密钥s是121。注意到这个密钥s并没有在网络上传输。而通过网络传输的p，g，A和B是无法推算出s的，因为实际算法选择的素数是非常大的。所以，更确切地说，DH算法是一个密钥协商算法，双方最终协商出一个共同的密钥，而这个密钥不会通过网络传输。</p>
<h4 id="TLS1-3握手过程"><a href="#TLS1-3握手过程" class="headerlink" title="TLS1.3握手过程"></a>TLS1.3握手过程</h4><p>整个流程的目的和TLS 1.2是相似的，TLS握手过程就是为了让双方能够得到一个安全的可用于对称加密的密钥。和之前不一样的就是，无非就是客户端提前把所有的公钥计算了一遍，发给server，server再挑选。</p>
<p><img src="/2022/08/24/HTTPS%E5%AD%A6%E4%B9%A0/15.png"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/08/23/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/08/23/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url">Java多线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-08-23T14:48:52+08:00">
                2022-08-23
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-08-23T14:48:54+08:00">
                2022-08-23
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/08/23/%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%AE%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/08/23/%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%AE%AF/" itemprop="url">进程通讯</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-08-23T14:42:18+08:00">
                2022-08-23
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-08-23T22:44:08+08:00">
                2022-08-23
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="进程通讯"><a href="#进程通讯" class="headerlink" title="进程通讯"></a>进程通讯</h1><p>参考博客：<a href="https://www.jianshu.com/p/c1015f5ffa74" target="_blank" rel="noopener">https://www.jianshu.com/p/c1015f5ffa74</a></p>
<h2 id="进程间通信的概念"><a href="#进程间通信的概念" class="headerlink" title="进程间通信的概念"></a>进程间通信的概念</h2><p>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据<strong>必须通过内核</strong>，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为<strong>进程间通信（IPC，InterProcess Communication）</strong></p>
<h2 id="进程间通信的7种方式"><a href="#进程间通信的7种方式" class="headerlink" title="进程间通信的7种方式"></a>进程间通信的7种方式</h2><h3 id="管道-匿名管道-pipe"><a href="#管道-匿名管道-pipe" class="headerlink" title="管道/匿名管道(pipe)"></a>管道/匿名管道(pipe)</h3><p>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。</p>
<p>只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);</p>
<p>单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。</p>
<p>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</p>
<p><img src="/2022/08/23/%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%AE%AF/1.jpg" style="zoom:150%;"></p>
<p><strong>管道的实质：</strong><br>管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。</p>
<p>该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。</p>
<p> 当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。</p>
<p><strong>管道的局限：</strong><br> 管道的主要局限性正体现在它的特点上：</p>
<ul>
<li>只支持单向数据流；</li>
<li>只能用于具有亲缘关系的进程之间；</li>
<li>没有名字；</li>
<li>管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）；</li>
<li>管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等；</li>
</ul>
<h4 id="管道实践-C"><a href="#管道实践-C" class="headerlink" title="管道实践(C++)"></a>管道实践(C++)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fds[<span class="number">2</span>]; 		<span class="comment">//2个元素的int类型的数组，filedes[0]读端、filedes[1]写端。</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>]=&#123;&#125;;<span class="comment">// 缓冲区</span></span><br><span class="line">    <span class="keyword">if</span>(pipe(fds)==<span class="number">-1</span>) <span class="comment">//创建管道</span></span><br><span class="line">        perror(<span class="string">"pipe"</span>),<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf,<span class="number">100</span>,<span class="built_in">stdin</span>)) <span class="comment">//把输入先读入buf当中</span></span><br><span class="line">    &#123;</span><br><span class="line">        len = <span class="built_in">strlen</span>(buf);							<span class="comment">//求出buf中字符串的长度</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">write</span>(fds[<span class="number">1</span>],buf,len)==<span class="number">-1</span>) 	<span class="comment">//把内容写进管道</span></span><br><span class="line">            perror(<span class="string">"write"</span>),<span class="built_in">exit</span>(<span class="number">1</span>);		</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0x00</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">100</span>);<span class="comment">//把buf缓存初始化掉</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">read</span>(fds[<span class="number">0</span>],buf,len)==<span class="number">-1</span>) 		<span class="comment">//再从管道里面读取内容到数组中</span></span><br><span class="line">            perror(<span class="string">"read"</span>),<span class="built_in">exit</span>(<span class="number">1</span>);			</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">write</span>(STDOUT_FILENO,buf,len)==<span class="number">-1</span>) 				<span class="comment">//把从管道里读出的内容写到标准输出</span></span><br><span class="line">            perror(<span class="string">"write"</span>),<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父子进程之间的管道通讯：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];<span class="comment">//定义管道的读、写端文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* str = <span class="string">"hello pipe\n"</span>;<span class="comment">//指定写数据</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];<span class="comment">//定义接收缓冲区</span></span><br><span class="line">    ret = pipe(fd);<span class="comment">//调用pipe()函数就已将管道打开</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"pipe error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid = fork();	<span class="comment">// fork子进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)<span class="comment">//父进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">write</span>(fd[<span class="number">1</span>],str,<span class="built_in">strlen</span>(str));<span class="comment">//写到管道中</span></span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)<span class="comment">//子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">1</span>]);</span><br><span class="line">        ret = <span class="built_in">read</span>(fd[<span class="number">0</span>],buf,<span class="keyword">sizeof</span>(buf));<span class="comment">//从管道中的读，返回读到的字节数</span></span><br><span class="line">        <span class="built_in">write</span>(STDOUT_FILENO,buf,ret);<span class="comment">//写到标准输出</span></span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有名管道-FIFO"><a href="#有名管道-FIFO" class="headerlink" title="有名管道(FIFO)"></a>有名管道(FIFO)</h3><p>匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道(FIFO)。</p>
<p>有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，<strong>以有名管道的文件形式存在于文件系统中</strong>，这样，<strong>即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信</strong>，因此，通过有名管道不相关的进程也能交换数据。值的注意的是，有名管道严格遵循<strong>先进先出(first in first out)</strong>,对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如<code>lseek()</code>等文件定位操作。<strong>有名管道的名字存在于文件系统中，内容存放在内存中。</strong></p>
<p><strong>匿名管道和有名管道总结：</strong><br> （1）管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。<br> （2）匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。<br> （3）<strong>无名管道阻塞问题：</strong>无名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。<br> （4）<strong>有名管道阻塞问题：</strong>有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。</p>
<h3 id="信号-Signal"><a href="#信号-Signal" class="headerlink" title="信号(Signal)"></a><strong>信号(Signal)</strong></h3><ul>
<li>信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。</li>
<li>如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。</li>
<li>如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。</li>
</ul>
<h4 id="Linux系统中常用信号："><a href="#Linux系统中常用信号：" class="headerlink" title="Linux系统中常用信号："></a><strong>Linux系统中常用信号：</strong></h4><p> （1）<strong>SIGHUP：</strong>用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。<br> （2）<strong>SIGINT：</strong>程序终止信号。程序运行过程中，按<code>Ctrl+C</code>键将产生该信号。<br> （3）<strong>SIGQUIT：</strong>程序退出信号。程序运行过程中，按<code>Ctrl+\\</code>键将产生该信号。<br> （4）<strong>SIGBUS和SIGSEGV：</strong>进程访问非法地址。<br> （5）<strong>SIGFPE：</strong>运算中出现致命错误，如除零操作、数据溢出等。<br> （6）<strong>SIGKILL：</strong>用户终止进程执行信号。shell下执行<code>kill -9</code>发送该信号。<br> （7）<strong>SIGTERM：</strong>结束进程信号。shell下执行<code>kill 进程pid</code>发送该信号。<br> （8）<strong>SIGALRM：</strong>定时器信号。<br> （9）<strong>SIGCLD：</strong>子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。</p>
<h4 id="信号来源"><a href="#信号来源" class="headerlink" title="信号来源"></a>信号来源</h4><p> 信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件主要有两个来源：</p>
<ul>
<li>硬件来源：用户按键输入<code>Ctrl+C</code>退出、硬件异常如无效的存储访问等。</li>
<li>软件终止：终止进程信号、其他进程调用kill函数、软件异常产生信号。</li>
</ul>
<h4 id="信号生命周期和处理流程"><a href="#信号生命周期和处理流程" class="headerlink" title="信号生命周期和处理流程"></a>信号生命周期和处理流程</h4><ol>
<li><p>信号被某个进程产生，并设置此信号传递的对象（一般为对应进程的pid），然后传递给操作系统；</p>
</li>
<li><p>操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），如果对应进程没有阻塞，操作系统将传递此信号。</p>
</li>
<li>目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时终止当前代码的执行，保护上下文（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、转而执行中断服务程序，执行完成后在回复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度。</li>
</ol>
<p><img src="/2022/08/23/%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%AE%AF/2.jpg" style="zoom:150%;"></p>
<h4 id="信号实践-C"><a href="#信号实践-C" class="headerlink" title="信号实践(C++)"></a>信号实践(C++)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> childpid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    childpid = fork();  <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == childpid)  <span class="comment">//判断是否创建失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == childpid)<span class="comment">// 子进程创建成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"In child process"</span>);</span><br><span class="line">        sleep(<span class="number">1000</span>); <span class="comment">//让子进程睡眠，以便父进程查看其行为</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == (waitpid(childpid, &amp;status, WNOHANG))) <span class="comment">//判断子进程是否已经退出</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">//发送SIGKILL给子进程，要求其停止运行。成功返回0，不成功就返回-1；</span></span><br><span class="line">            retval = kill(childpid, SIGKILL);  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (retval)   <span class="comment">//判断是否发生信号，</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"kill failed."</span>);</span><br><span class="line">                perror(<span class="string">"kill"</span>);</span><br><span class="line">                waitpid(childpid, &amp;status, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d killed\n"</span>, childpid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><code>55382 killed</code></p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p><strong>消息(Message)队列</strong></p>
<ul>
<li>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。</li>
<li>与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。</li>
<li>另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。</li>
</ul>
<p><strong>消息队列特点总结：</strong></p>
<ol>
<li>消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识.</li>
<li>消息队列允许一个或多个进程向它写入与读取消息. </li>
<li>管道和消息队列的通信数据都是先进先出的原则。</li>
<li>消息队列可以<strong>实现消息的随机查询</strong>,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势。</li>
<li>消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺。</li>
<li>目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，System V消息队列目前被大量使用。System V消息队列是随内核持续的，只有在内核重起或者人工删除时，该消息队列才会被删除。</li>
</ol>
<h3 id="共享内存-share-memory"><a href="#共享内存-share-memory" class="headerlink" title="共享内存(share memory)"></a>共享内存(share memory)</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>在<a href="https://jasonxqh.github.io/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/">CSAPP虚拟内存</a>这篇博客中，我们学习到虚拟内存可以简化共享。例如，每个进程必须调用相同的<strong>操作系统内核代码</strong>，而每个C 程序都会调用C 标准库中的程序，比如 <code>printf()</code> . 操作系统通过<strong>将不同进程中适当的虚拟页面映射到相同的物理页面</strong>，从而安排<strong>多个进程共享这部分代码的一个副本</strong>，而不是在每个进程中都包括单独的内核和C标准库的副本</p>
<p>那么，将共享内存用来进程之间的通讯，以传送数据为目的，显然这是进程通信中速度最快的一种方式（例：进程一向共享内存传送数据，进程二能够立马看见传送的数据，少了若干次拷贝）</p>
<p>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率</p>
<p>共享内存生命周期跟随内核，共享没有自带同步或互斥，由用户来维护共享内存。因此，信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问</p>
<h4 id="共享内存的优缺点"><a href="#共享内存的优缺点" class="headerlink" title="共享内存的优缺点"></a>共享内存的优缺点</h4><p>1、优点：我们可以看到使用共享内存进行进程间的通信真的是非常方便，而且函数的接口也简单，数据的共享还使进程间的数据不用传送，而是直接访问内存，也加快了程序的效率。同时，它也不像匿名管道那样要求通信的进程有一定的父子关系。</p>
<p>2、缺点：共享内存没有提供同步的机制，这使得我们在使用共享内存进行进程间通信时，往往要借助其他的手段来进行进程间的同步工作。(如信号量)</p>
<h4 id="共享内存接口"><a href="#共享内存接口" class="headerlink" title="共享内存接口"></a>共享内存接口</h4><p>在C++中，有关于和共享内存的库是<code>#include &lt;sys/shm.h&gt;</code>，里面有对共享内存的方法：</p>
<h5 id="共享内存的创建："><a href="#共享内存的创建：" class="headerlink" title="共享内存的创建："></a>共享内存的创建：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="comment">//如果共享内存不存在，创建共享内存，如果存在就打开共享内存</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line"><span class="comment">//返回值：成功返回共享内存的标识符，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p>参数：共享内存的关键字key</p>
<blockquote>
<p>共享内存的标识符，获取方法和消息队列 key的方法一致，也可认为key就是共享内存的名字</p>
</blockquote>
<p>参数：共享内存的大小size：</p>
<blockquote>
<p>由你自己指定，一般指定为4k的倍数（内存4k为一页）</p>
</blockquote>
<p>参数：共享内存的访问权限shmflg</p>
<blockquote>
<p>共享内存的权限，它与文件的访问权限一样<br><code>IPC_CREAT</code>:创建新的共享内存。</p>
<p><code>IPC_EXCL</code>:与IPC_CREAT一同使用，表示如果要创建的共享内存已经存在，则返回错误。 </p>
<p><code>IPC_NOWAIT</code>:读写共享内存要求无法满足时，不阻塞</p>
<p>0：如果是打开文件，即文件已存在，写0</p>
</blockquote>
<h5 id="共享内存的挂载"><a href="#共享内存的挂载" class="headerlink" title="共享内存的挂载"></a>共享内存的挂载</h5><p>共享内存的挂载</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="comment">//将共享内存链接到进程地址空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line"><span class="comment">//返回值：失败返回NULL,成功返回一个指针，为地址空间的虚拟地址，并且连接数加1（nattch）</span></span><br></pre></td></tr></table></figure>
<p>参数：共享内存的标识符shmid</p>
<blockquote>
<p>shmget的返回值</p>
</blockquote>
<p>参数：指定连接进程地址空间的地址shmaddr</p>
<blockquote>
<p>共享存储段连接到调用进程的哪个地址上与addr参数以及在flag中是否指定<code>SHM_RND</code>位有关</p>
<p>如果addr为0，则此段连接到由内核选择的第一个可用地址上。这是推荐的使用方式。</p>
<p>如果addr非0，并且没有指定SHM_RND，则此段连接到addr所指定的地址上。</p>
<p>如果addr非0,并且指定了SHM_ RND，则此段连接到（shmaddr -（shmaddr % SHMLBA））所表示的地址上。SHM_RND命令的意思是取整。SHMLBA的意思是低边界地址倍数，它总是2的乘方。该算式是将地址向下取最近1个SHMLBA的倍数。</p>
<p>注：除非只计划在一种硬件上运行应用程序（这在当今是不大可能的），否则不应指定共享段所连接到的地址。所以一般应指定addr为0，以便由内核选择地址</p>
</blockquote>
<p>参数：共享内存的权限shmflg</p>
<blockquote>
<p>shmflg = SHM_RDONLY，表示连接操作作用来只读共享内存</p>
</blockquote>
<h5 id="共享内存的卸载"><a href="#共享内存的卸载" class="headerlink" title="共享内存的卸载"></a>共享内存的卸载</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="comment">//将共享内存与当前连接进程脱离</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* shmaddr)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回值：成功返回0,失败返回-1</span></span></span><br><span class="line"><span class="function"><span class="comment">//参数：由shmat返回的指针</span></span></span><br><span class="line"><span class="function"><span class="comment">//注意：将共享内存与进程脱离不等于删除共享内存</span></span></span><br></pre></td></tr></table></figure>
<h5 id="共享内存的控制"><a href="#共享内存的控制" class="headerlink" title="共享内存的控制"></a>共享内存的控制</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="comment">//shmctl系统调用对shmid标识的共享内存执行cmd操作</span></span><br><span class="line"><span class="comment">//返回值：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数：共享内存的表示符shmid</p>
<blockquote>
<p>shmget的返回值</p>
</blockquote>
<p>参数：将要采取的操作cmd</p>
<blockquote>
<p>选项 说明<br><code>IPC_STAT</code> 把shmid_ds结构中的数据设置为共享内存的当前关联值</p>
<p><code>IPC_SET</code> 在进程有足够权限的前提下，把共享内存的当前关联值设置为shmid_ds数 据结构中给出的值</p>
<p><code>IPC_RMID</code> 删除共享内存</p>
</blockquote>
<p>参数：保存共享内存的模式状态和访问权限的数据结构buf</p>
<blockquote>
<p>共享内存的一些属性，填NULL</p>
</blockquote>
<h4 id="封装API"><a href="#封装API" class="headerlink" title="封装API"></a>封装API</h4><p>我们要利用它封装一些自己的API，让其对用户操作友好</p>
<ul>
<li><code>int commShm(int size,int flags)</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">commShm</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">int</span> flags)</span> <span class="comment">//创建共享内存</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="comment">//利用 ftok获取key值，用来申请共享内存</span></span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(PATHNAME, PROJ_ID);</span><br><span class="line">    <span class="keyword">if</span> (key &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"ftok"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(key, <span class="built_in">size</span>, flags);</span><br><span class="line">    <span class="keyword">if</span> (shmid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"shmget"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shmid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>int createShm (int size)</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int createShm(int size)</span><br><span class="line">&#123;</span><br><span class="line">    return commShm(size, IPC_CREAT | IPC_EXCL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>int getShm(int size)//获取共享内存</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getShm</span><span class="params">(<span class="keyword">int</span> size)</span><span class="comment">//获取共享内存</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> commShm(size, IPC_CREAT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>int destoryShm(int shmid)</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">destoryShm</span><span class="params">(<span class="keyword">int</span> shmid)</span> <span class="comment">//销毁共享内存</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"shmctl"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="server进程"><a href="#server进程" class="headerlink" title="server进程"></a>server进程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"comm.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid = createShm(<span class="number">4096</span>);                <span class="comment">//创建共享内存</span></span><br><span class="line">    <span class="keyword">char</span> *addr = (<span class="keyword">char</span> *)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">//将共享内存进行挂接</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt; <span class="number">26</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="comment">//每次都输出 共享内存中的数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"client：%s\n"</span>, addr);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    shmdt(addr); <span class="comment">//删除共享内存</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    destoryShm(shmid);<span class="comment">//卸载共享内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="client进程"><a href="#client进程" class="headerlink" title="client进程"></a>client进程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"comm.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid = getShm(<span class="number">0</span>);                      <span class="comment">//创建共享内存</span></span><br><span class="line">    <span class="keyword">char</span> *addr = (<span class="keyword">char</span> *)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">//将共享内存进行挂接</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">26</span>)</span><br><span class="line">    &#123;</span><br><span class="line">  			addr[i] = <span class="string">'A'</span>+i;</span><br><span class="line">        i++;</span><br><span class="line">        addr[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"writing to shared memory: %s\n"</span>, addr);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    shmdt(addr); <span class="comment">//删除共享内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后如下：</p>
<p><img src="/2022/08/23/%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%AE%AF/3.gif" style="zoom:150%;"></p>
<p>在进程运行期间，我们通过<code>ipcs -m</code>观察挂载的共享内存，如下所示<br><img src="/2022/08/23/%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%AE%AF/4.png" style="zoom:150%;"></p>
<ul>
<li>这块共想内存的拥有者是root</li>
<li>大小为4096byte</li>
<li>当前连接了两个进程</li>
</ul>
<h3 id="信号量-semaphore"><a href="#信号量-semaphore" class="headerlink" title="信号量(semaphore)"></a><strong>信号量(semaphore)</strong></h3><p> 信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。<br> 为了获得共享资源，进程需要执行下列操作：</p>
<ol>
<li><strong>创建一个信号量</strong>：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。</li>
<li><strong>等待一个信号量</strong>：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。</li>
<li><strong>挂出一个信号量</strong>：该操作将信号量的值加1，也称为V操作。</li>
</ol>
<p>为了正确地实现信号量，信号量值的测试及减1操作应当是原子操作。为此，信号量通常是在内核中实现的。Linux环境中，有三种类型：<strong>Posix（<a href="https://link.jianshu.com?t=http://baike.baidu.com/link?url=hYEo6ngm9MlqsQHT3h28baIDxEooeSPX6wr_FdGF-F8mf7wDp2xJWIDtQWGEDxthtPNiJtlsw460g1_N0txJYa" target="_blank" rel="noopener">可移植性操作系统接口</a>）有名信号量（使用Posix IPC名字标识）</strong>、<strong>Posix基于内存的信号量（存放在共享内存区中）</strong>、<strong>System V信号量（在内核中维护）</strong>。这三种信号量都可用于进程间或线程间的同步。</p>
<blockquote>
<p><strong>信号量与普通整型变量的区别：</strong><br> （1）信号量是非负整型变量，除了初始化之外，它只能通过两个标准原子操作：wait(semap) , signal(semap) ; 来进行访问；<br> （2）操作也被成为PV原语（P来源于荷兰语proberen”测试”，V来源于荷兰语verhogen”增加”，P表示通过的意思，V表示释放的意思），而普通整型变量则可以在任何语句块中被访问；</p>
<p><strong>信号量与互斥量之间的区别：</strong><br> （1）互斥量用于线程的互斥，信号量用于线程的同步。这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。<br> <strong>互斥：</strong>是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。<br> <strong>同步：</strong>是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。<br> 在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源<br> （2）互斥量值只能为0/1，信号量值可以为非负整数。<br> 也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。<br> （3）互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。</p>
</blockquote>
<h3 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字(socket)"></a><strong>套接字(socket)</strong></h3><p> 套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。 </p>
<p>套接字是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p>
<h4 id="套接字特性"><a href="#套接字特性" class="headerlink" title="套接字特性"></a>套接字特性</h4><p> 套接字的特性由3个属性确定，它们分别是：域、端口号、协议类型。</p>
<ol>
<li><p>套接字的域</p>
<p>它指定套接字通信中使用的网络介质，最常见的套接字域有两种：</p>
<p> <strong>一是AF_INET，它指的是Internet网络。</strong>当客户使用套接字进行跨网络的连接时，它就需要用到服务器计算机的IP地址和端口来指定一台联网机器上的某个特定服务，所以在使用socket作为通信的终点，服务器应用程序必须在开始通信之前绑定一个端口，服务器在指定的端口等待客户的连接。</p>
<p><strong>另一个域AF_UNIX，表示UNIX文件系统，</strong>它就是文件输入/输出，而它的地址就是文件名。</p>
</li>
<li><p><strong>套接字的端口号</strong></p>
<p>每一个基于TCP/IP网络通讯的程序(进程)都被赋予了唯一的端口和端口号，端口是一个信息缓冲区，用于保留Socket中的输入/输出信息，端口号是一个16位无符号整数，范围是0-65535，以区别主机上的每一个程序（端口号就像房屋中的房间号），低于256的端口号保留给标准应用程序，比如pop3的端口号就是110，每一个套接字都组合进了IP地址、端口，这样形成的整体就可以区别每一个套接字</p>
</li>
<li><p><strong>套接字协议类型</strong></p>
<p>因特网提供三种通信机制，</p>
<ul>
<li><strong>流套接字，</strong>流套接字在域中通过TCP/IP连接实现，同时也是AF_UNIX中常用的套接字类型。流套接字提供的是一个有序、可靠、双向字节流的连接，因此发送的数据可以确保不会丢失、重复或乱序到达，而且它还有一定的出错后重新发送的机制。</li>
<li><strong>数据报套接字，</strong>它不需要建立连接和维持一个连接，它们在域中通常是通过UDP/IP协议实现的。它对可以发送的数据的长度有限制，数据报作为一个单独的网络消息被传输,它可能会丢失、复制或错乱到达，UDP不是一个可靠的协议，但是它的速度比较高，因为它并一需要总是要建立和维持一个连接。</li>
<li><strong>原始套接字，</strong>原始套接字允许对较低层次的协议直接访问，比如IP、 ICMP协议，它常用于检验新的协议实现，或者访问现有服务中配置的新设备，因为RAW SOCKET可以自如地控制Windows下的多种协议，能够对网络底层的传输机制进行控制，所以可以应用原始套接字来操纵网络层和传输层应用。比如，我们可以通过RAW SOCKET来接收发向本机的ICMP、IGMP协议包，或者接收TCP/IP栈不能够处理的IP包，也可以用来发送一些自定包头或自定协议的IP包。网络监听技术很大程度上依赖于SOCKET_RAW。</li>
</ul>
</li>
</ol>
<h4 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h4><ol>
<li>首先服务器应用程序用系统调用socket来创建一个套接字，它是系统分配给该服务器进程的类似文件描述符的资源，它不能与其他的进程共享。</li>
<li>然后，服务器进程会给套接字起个名字，我们使用系统调用bind来给套接字命名。然后服务器进程就开始等待客户连接到这个套接字。</li>
<li>接下来，系统调用listen来创建一个队列并将其用于存放来自客户的进入连接。</li>
<li>最后，服务器通过系统调用accept来接受客户的连接。它会创建一个与原有的命名套接不同的新套接字，这个套接字只用于与这个特定客户端进行通信，而命名套接字（即原先的套接字）则被保留下来继续处理来自其他客户的连接（建立客户端和服务端的用于通信的流，进行通信）。</li>
</ol>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p> （1）客户应用程序首先调用socket来创建一个未命名的套接字，然后将服务器的命名套接字作为一个地址来调用connect与服务器建立连接。<br> （2）一旦连接建立，我们就可以像使用底层的文件描述符那样用套接字来实现双向数据的通信（通过流进行数据传输）。</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/08/22/Mysql%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/08/22/Mysql%E7%B4%A2%E5%BC%95/" itemprop="url">Mysql索引</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-08-22T14:48:15+08:00">
                2022-08-22
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2025-04-11T10:17:52+08:00">
                2025-04-11
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Mysql索引"><a href="#Mysql索引" class="headerlink" title="Mysql索引"></a>Mysql索引</h1><p>参考博客 </p>
<ul>
<li><a href="https://www.cnblogs.com/zsql/p/13808417.html" target="_blank" rel="noopener">https://www.cnblogs.com/zsql/p/13808417.html</a></li>
<li><a href="https://juejin.cn/post/7031712626581356574" target="_blank" rel="noopener">https://juejin.cn/post/7031712626581356574</a></li>
</ul>
<h2 id="索引类别"><a href="#索引类别" class="headerlink" title="索引类别"></a>索引类别</h2><p>​        索引是一个单独的、存储在磁盘上的数据库结构，它们包含着对数据表里所有记录的引用指针。使用索引用于快速找出在某个或多个列中有一特定值的行，所有MySQL列类型都可以被索引，对相关列使用索引是提高查询操作速度的最佳途径。<br>　　MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。比如我们在查字典的时候，前面都有检索的拼音和偏旁、笔画等，然后找到对应字典页码，这样然后就打开字典的页数就可以知道我们要搜索的某一个key的全部值的信息了</p>
<p>​        创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)，而不是在select的字段中，实际上，索引也是一张“表”，该表保存了主键与索引字段，并指向实体表的记录，虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件，建立索引会占用磁盘空间的索引文件。说白了索引就是用来提高速度的，但是就需要维护索引造成资源的浪费，所以合理的创建索引是必要的。</p>
<p>在<a href="https://dev.mysql.com/doc/refman/8.0/en/create-index.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/create-index.html</a> 中，显示了不同数据库引擎不同类别索引的相关信息</p>
<h4 id="按照索引的特性分："><a href="#按照索引的特性分：" class="headerlink" title="按照索引的特性分："></a>按照索引的特性分：</h4><ol>
<li><p><strong>Primary Key（聚集索引）</strong>：InnoDB存储引擎的表一定存在主键（唯一非null），如果建表的时候没有指定主键，则会使用第一非空的唯一索引作为聚集索引，否则InnoDB会自动帮你创建一个不可见的、长度为6字节的row_id用来作为聚集索引。</p>
</li>
<li><p><strong>Unique（唯一索引）</strong>：索引列的值必须唯一，但允许有空值。若是组合索引，则列值的组合必须唯一。主键索引是一种特殊的唯一索引，不允许有空值</p>
</li>
<li><p><strong>Key（普通索引）</strong>：是MySQL中的基本索引类型，<strong>允许在定义索引的列中插入重复值和空值</strong></p>
</li>
<li><p><strong>FULLTEXT（全文索引）</strong>：全文索引类型为FULLTEXT，在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。<strong>全文索引可以在CHAR、VARCHAR或者TEXT类型的列上创建</strong></p>
</li>
<li><p><strong>SPATIAL（空间索引）</strong>：空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING和POLYGON。MySQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类似的语法创建空间索引。<strong>创建空间索引的列必须声明为NOT NULL</strong></p>
</li>
</ol>
<h4 id="按索引列的数量分："><a href="#按索引列的数量分：" class="headerlink" title="按索引列的数量分："></a>按索引列的数量分：</h4><ol>
<li><p><strong>单列索引</strong>：单列索引即一个索引只包含单个列</p>
</li>
<li><p><strong>联合索引</strong>：组合索引指在表的多个字段组合上创建的索引，只有在查询条件<strong>中使用了这些字段的左边字段</strong>时，索引才会被使用。使用组合索引时<strong>遵循最左前缀集合</strong></p>
</li>
</ol>
<h4 id="按数据结构分："><a href="#按数据结构分：" class="headerlink" title="按数据结构分："></a>按数据结构分：</h4><ol>
<li>B+ Tree索引</li>
<li>Hash索引</li>
<li>Full-text索引</li>
</ol>
<h4 id="按索引的物理存储方式分："><a href="#按索引的物理存储方式分：" class="headerlink" title="按索引的物理存储方式分："></a>按索引的物理存储方式分：</h4><ol>
<li><p><strong>聚簇索引(clustered index)</strong>：数据结构是B+树。数据文件是和（主键）索引绑在一起的，即索引 + 数据 = 整个表数据文件，通过主键索引到整个记录，必须要有主键，通过主键索引效率很高</p>
<ul>
<li><p>聚集索引的主键索引</p>
<p><img src="/2022/08/22/Mysql%E7%B4%A2%E5%BC%95/2.png"></p>
</li>
<li><p><strong>聚集索引的辅助索引(二级索引，secondary index)</strong>: 辅助索引需要两次查询，因为辅助索引是以建索引的字段为关键字索引到主键，所以需要两次，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。</p>
<p><img src="/2022/08/22/Mysql%E7%B4%A2%E5%BC%95/4.png"></p>
</li>
<li><p>我们看到，这个二级索引是建立在名字上的，那么如果要查询：<code>SELECT * FROM table WHERE name = ALICE</code>, 那么就先去根据二级索引的B+树上查找，得到Alice的主键是18；然后再根据18去主键上的B+树查找，最终可以找到该行的所有数据</p>
</li>
</ul>
</li>
</ol>
<ol>
<li><p><strong>非聚集索引</strong>：数据结构也是B+ 树，但是索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。也就是说：InnoDB的B+树<strong>主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值</strong>；而MyISAM的B+树主键索引和辅助索引的叶子节点<strong>都是数据文件的地址指针</strong>。</p>
<ul>
<li><p>非聚集索引的主键索引<br><img src="/2022/08/22/Mysql%E7%B4%A2%E5%BC%95/3.png"></p>
</li>
<li><p>非聚集索引的二级索引，对于MyISAM来说数据文件和索引文件则是分开的。</p>
<p><img src="/2022/08/22/Mysql%E7%B4%A2%E5%BC%95/5.png"></p>
</li>
</ul>
</li>
</ol>
<h3 id="Mysql中三种引擎的索引"><a href="#Mysql中三种引擎的索引" class="headerlink" title="Mysql中三种引擎的索引"></a>Mysql中三种引擎的索引</h3><p><img src="/2022/08/22/Mysql%E7%B4%A2%E5%BC%95/7.png"></p>
<p>我们看到，只有存放在内存中的表，才可以使用哈希索引，</p>
<h3 id="InnoDB-vs-Mysiam"><a href="#InnoDB-vs-Mysiam" class="headerlink" title="InnoDB vs Mysiam"></a>InnoDB vs Mysiam</h3><p><strong>聚集索引的优点：</strong></p>
<ul>
<li>可以把相关数据保存在一起，如：实现电子邮箱时，可以根据用户ID来聚集数据，这样只需要从磁盘读取少量的数据页就能获取某个用户全部邮件，如果没有使用聚集索引，则每封邮件都可能导致一次磁盘IO</li>
<li>数据访问更快，聚集索引将索引和数据保存在<strong>同一个btree</strong>中，因此从聚集索引中获取数据通常比在非聚集索引中查找要快</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值</li>
</ul>
<p><strong>聚集索引的缺点：</strong></p>
<ul>
<li>我们知道InnoDB使用的是聚集索引，根据聚集索引的特性，不建议使用过长的字段作为主键：因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。</li>
<li><p>此外，二级索引访问需要两次索引查找(回表)，而不是一次</p>
</li>
<li><p>用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。(这点在Mysiam中也是如此)</p>
</li>
<li>聚簇数据最大限度地提高了IO密集型应用的性能，但如果数据全部放在内存中，则访问的顺序就没有那么重要了，聚集索引也没有什么优势了</li>
<li>聚集索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候</li>
</ul>
<p><strong>非聚集索引的优点：</strong></p>
<p>我们知道，Myisam的主键索引的叶子节点只存放数据在物理磁盘上的指针，其他次索引也是一样的。因此，当存在大数据列(如<code>varchar(300)</code>),那么如果用聚簇索引会导致主键id排序比较慢，因为主键下存放着所有的数据列。但是Mysiam就不需要扫描数据列，可以直接进行排序。因此，非聚集索引在处理文本类型的数据时更有优势</p>
<h4 id="需要规避的设计"><a href="#需要规避的设计" class="headerlink" title="需要规避的设计"></a>需要规避的设计</h4><p><strong>不要使用UUID来作为聚集索引，否则性能会很糟糕</strong>。</p>
<ul>
<li>写入的目标页可能已经刷到磁盘上并从缓存中移除，或者是还没有被加载到缓存中，innodb在插入前不得不先找到并从磁盘读取目标页到内存中，这将导致大量的随机IO</li>
<li>因为写入是乱序的，innodb不得不频繁地做页分裂操作，以便为新的行分配空间，页分裂会导致移动大量数据，一次插入最少需要修改三个页不是一个页</li>
<li>由于频繁的页分裂，页会变得稀疏并被不规则地填充，所以最终数据会有碎片</li>
</ul>
<h2 id="索引的创建管理"><a href="#索引的创建管理" class="headerlink" title="索引的创建管理"></a>索引的创建管理</h2><h3 id="索引的创建原则"><a href="#索引的创建原则" class="headerlink" title="索引的创建原则"></a>索引的创建原则</h3><ol>
<li>索引并非越多越好，一个表中如果有大量的索引，不仅占用磁盘空间，而且会影响INSERT、DELETE、UPDATE等语句的性能，因为在表中的数据更改的同时，索引也会进行调整和更新</li>
<li>避免对经常更新的表进行过多的索引，并且索引中的列尽可能少。而对经常用于查询的字段应该创建索引，但要避免添加不必要的字段。</li>
<li>数据量小的表最好不要使用索引，由于数据较少，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。</li>
<li>在条件表达式中经常用到的不同值较多的列上建立索引，在不同值很少的列上不要建立索引。比如在学生表的“性别”字段上只有“男”与“女”两个不同值，因此就无须建立索引。如果建立索引，不但不会提高查询效率，反而会严重降低数据更新速度。</li>
<li>当唯一性是某种数据本身的特征时，指定唯一索引。使用唯一索引需能确保定义的列的数据完整性，以提高查询速度。</li>
<li>在频繁进行排序或分组（即进行group by或order by操作）的列上建立索引，如果待排序的列有多个，可以在这些列上建立组合索引。</li>
<li>搜索的索引列，不一定是所要选择的列。换句话说，<strong>最适合索引的列是出现在WHERE子句中的列</strong>，或连接子句中指定的列，而不是出现在SELECT关键字后的选择列表中的列。</li>
<li>使用短索引。如果对字符串列进行索引，应该指定一个前缀长度，只要有可能就应该这样做。例如，有一个CHAR(200)列，如果在前10个或20个字符内，多数值是唯一的，那么就不要对整个列进行索引。对前10个或20个字符进行索引能够节省大量索引空间，也可能会使查询更快。较小的索引涉及的磁盘 IO 较少，较短的值比较起来更快。更为重要的是，对于较短的键值，索引高速缓存中的块能容纳更多的键值，因此，MySQL 也可以在内存中容纳更多的值。这样就增加了找到行而不用读取索引中较多块的可能性。</li>
<li>利用最左前缀。在创建一个n列的索引时，实际是创建了MySQL可利用的n个索引。多列索引可起几个索引的作用，因为可利用索引中最左边的列集来匹配行。这样的列集称为最左前缀。</li>
<li>对于InnoDB存储引擎的表，记录默认会按照一定的顺序保存，如果有明确定义的主键，则按照主键顺序保存。如果没有主键，但是有唯一索引，那么就是按照唯一索引的顺序保存。如果既没有主键又没有唯一索引，那么表中会自动生成一个内部列，按照这个列的顺序保存。按照主键或者内部列进行的访问是最快的，所以<strong>InnoDB表尽量自己指定主键，当表中同时有几个列都是唯一的，都可以作为主键的时候，要选择最常作为访问条件的列作为主键，提高查询的效率</strong>。另外，还需要注意，InnoDB 表的普通索引都会保存主键的键值，所以主键要尽可能选择较短的数据类型，可以有效地减少索引的磁盘占用，提高索引的缓存效果</li>
</ol>
<h3 id="索引创建SQL"><a href="#索引创建SQL" class="headerlink" title="索引创建SQL"></a>索引创建SQL</h3><h2 id="索引的查询"><a href="#索引的查询" class="headerlink" title="索引的查询"></a>索引的查询</h2><p>平时设计的时候很多时候都会用到联合索引，一般很少用单个字段作为索引，这样可以让索引尽量少一些，避免磁盘占用太多，增删改性能太差。</p>
<p>加入有叫学生分数表，包含：班级，姓名，科目名称，成绩分数，一般我们都会根据学生的班级+姓名+科目来查询，这时候就需要建立二级索引KEY（class_name，student_name ，subject_nane  ）。这时候索引的数据结构图如下图所示：</p>
<p><img src="/2022/08/22/Mysql%E7%B4%A2%E5%BC%95/10.png"></p>
<p>那么，在查询过程中，会用到各式各样SELECT语句，它们对联合索引是怎么利用的呢？</p>
<h3 id="等值匹配"><a href="#等值匹配" class="headerlink" title="等值匹配"></a>等值匹配</h3><p>如果执行下面的语句：<code>SELECT * FROM student_scope where class_name= &#39;1班&#39; AND student_name =&#39;小明&#39; AND subject_nane =&#39;英语&#39;;</code></p>
<p>因为WHERE条件里的<strong>几个字段的名称和顺序跟建立的联合索引一模一样</strong>，此时就会等值匹配，从索引页依次往下查找，会定位到：1+小明+英语（id=100）这条数据，然后根据id 从聚簇索引(主键)中回表查询提取所有的字段信息。</p>
<p>注意，由于Mysql有优化器，因此，这边的列如果顺序打乱(但是数量还是要和索引一样)，还是可以走索引的</p>
<h3 id="最左侧列匹配"><a href="#最左侧列匹配" class="headerlink" title="最左侧列匹配"></a>最左侧列匹配</h3><p>例如联合索引：KEY（class_name，student_name ，subject_nane ），不一定在where条件中都要写3个字段来才会走索引查询，<strong>只要根据最左侧的部分字段来查询也要走索引</strong>，下面的3条SQL都会走索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student_scope <span class="keyword">where</span> class_name= <span class="string">'1班'</span>  </span><br><span class="line">																	<span class="keyword">AND</span> student_name =<span class="string">'小明'</span> </span><br><span class="line">																	<span class="keyword">AND</span> subject_nane  =<span class="string">'英语'</span>; <span class="comment"># 等值匹配</span></span><br><span class="line">																	</span><br><span class="line">																	</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student_scope <span class="keyword">where</span> class_name= <span class="string">'1班'</span> </span><br><span class="line">																	<span class="keyword">AND</span> student_name =<span class="string">'小明'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student_scope <span class="keyword">where</span> class_name= <span class="string">'1班'</span> ;</span><br></pre></td></tr></table></figure>
<p>此外，如果查询顺序和索引顺序不一样，也会采取最左侧来匹配，比如当执行下面的SQL，class_name字段会走索引，subject_name 就不会走索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student_scope <span class="keyword">where</span> class_name= <span class="string">'1班'</span> <span class="keyword">AND</span> subject_nane  =<span class="string">'英语'</span>;</span><br></pre></td></tr></table></figure>
<p>但是，如果WHERE后面第一个字段不是class_name，那就不符合最左匹配原则，完全不会用到索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student_scope <span class="keyword">where</span> student_name =<span class="string">'小明'</span> <span class="keyword">AND</span> subject_nane  =<span class="string">'英语'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student_scope <span class="keyword">where</span> subject_nane  =<span class="string">'英语'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a>最左前缀匹配原则</h3><p>在SQL查询的时候，我们经常会根据LIKE语法来查询，比如查询班级为1开头的数据，也可以用到索引，<strong>因为你的联合索引的B+树里，都是按照class_name排序的，所以你要是给出class_name的确定的最左前缀就是1</strong>，然后在后面给一个模糊匹配符号，那也是可以基于索引来查找。</p>
<p> 比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student_scope <span class="keyword">where</span> class_name <span class="keyword">like</span> <span class="string">'1%'</span>;</span><br></pre></td></tr></table></figure>
<p>但是执行以班结尾的数据就不会走到索引，因为不知道左侧前缀是多少，无法基于排序来查找。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student_scope <span class="keyword">where</span> class_name <span class="keyword">like</span> <span class="string">'%班'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="范围查找规则"><a href="#范围查找规则" class="headerlink" title="范围查找规则"></a>范围查找规则</h3><p>如果SQL查询的字段基于某个索引列采取范围查询，例如下面的SQL，也会走索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student_scope <span class="keyword">where</span> class_name &gt;= <span class="string">'1班'</span> <span class="keyword">AND</span> class_name &lt;<span class="string">'10班'</span>;</span><br></pre></td></tr></table></figure>
<p>但是当第一个字段是范围查询的时候，后面的第二个字段是没法走索引，例如下面的<strong>SQL</strong>,class_name 会走索引，后面的student_name 不会走索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student_scope <span class="keyword">where</span> class_name &gt;= <span class="string">'1班'</span> </span><br><span class="line">																	<span class="keyword">AND</span> class_name &lt;<span class="string">'10班'</span> </span><br><span class="line">																	<span class="keyword">AND</span> student_name =<span class="string">'小明'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="等值匹配-范围匹配规则"><a href="#等值匹配-范围匹配规则" class="headerlink" title="等值匹配+范围匹配规则"></a>等值匹配+范围匹配规则</h3><p>如果要使用下面的SQL进行查询的时候，此时class_name 会走索引，精准定位到一波数据，接下来这波被命中的数据，是按照student_name排序而来，这时候student_name &gt;= ‘小明’也会基于索引来查找，但是后面的student_name &lt;’王五’就不能用索引。</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student_scope <span class="keyword">where</span> class_name = <span class="string">'1班'</span> </span><br><span class="line">														<span class="keyword">AND</span> student_name &gt;= <span class="string">'小明'</span> <span class="keyword">AND</span> student_name &lt;<span class="string">'王五'</span>;</span><br></pre></td></tr></table></figure>
<p>一般写SQL语句，都是用联合索引的最左侧的多个字段来进行等值匹配+范围搜索，或者是基于最左侧的部分字段来进行最左前缀模糊匹配，或者基于最左侧字段来进行范围搜索，这就要写符合规则的SQL语句，才能用上建立好的联合索引。</p>
<h3 id="排序如何使用索引"><a href="#排序如何使用索引" class="headerlink" title="排序如何使用索引"></a>排序如何使用索引</h3><p>当我们的SQL 语句需要使用ORDER BY语句进行排序的时候，似乎应该是通过索引快速筛选出来一波数据，接着把数据放入内存，或者放在一个临时磁盘文件里，然后通过排序算法按照ORDER BY后面的字段进行排序，然后把排序好的数据返回，当排序的数据量比较大的时候，就不能够用内存进行排序，就会基于磁盘文件来排序（filesort），这样的话就比较慢。 因为建立的联合索引是按照一定的顺序已经排序好的，如果order by 后面的排序字段能够命中联合索引的时候，就会走索引，例如下面的排序SQL就会走索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student_scope </span><br><span class="line">					ORDER BY class_name,student_name ,subject_nane</span><br><span class="line">					LIMIT 10;</span><br></pre></td></tr></table></figure>
<p>因此，在排序的时候尽量按照查询的联合索引去进行order by排序，这样就可以直接使用联合索引树里的数据有序性到索引数里直接按照字段的顺序获取所需要的数据。但是也有一定的限制，因为联合索引里的字段值在索引树里都是从小到大依次排列的 ，所以在ORDER BY里要不然就是每个字段后面什么都不加，直接就是ORDER BY xx1,xx2,xx3，要不然就都加DESC降序排列，就是ORDER BY xx1 DESC,xx2 DESC,xx3 DESC。 </p>
<p>当ORDER BY 排序字段<strong>既有升序，又有降序，那么是没法走索引进行排序</strong>，例如下面的SQL语句没法走索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student_scope</span><br><span class="line">				 ORDER BY class_name DESC,student_name ASC,subject_nane DESC </span><br><span class="line">				 LIMIT 10;</span><br></pre></td></tr></table></figure>
<h3 id="分组如何使用索引"><a href="#分组如何使用索引" class="headerlink" title="分组如何使用索引"></a>分组如何使用索引</h3><p>GROUP BY 语句使用索引的时候跟ORDER BY排序使用索引的规则一样，对于group by后的字段，最好也是按照联合索引里的最左侧的字段开始，按顺序排列开来，这样的话，就可以完美的运用上索引来直接提取一组一组的数据，然后针对每一组的数据执行聚合函数就可以。</p>
<h2 id="索引实现原理"><a href="#索引实现原理" class="headerlink" title="索引实现原理"></a>索引实现原理</h2><h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h3><p>上面我们说过，Primary Key、Unique和Key都是基于B+树实现的。首先，我们可以从<a href="https://jasonxqh.github.io/2020/06/17/B%E6%A0%91/">我的这篇博客</a>来了解B+树的数据结构。</p>
<p>那么数据库索引为什么要用 B+ 树而不用红黑树呢？</p>
<p>AVL 树和红黑树这些二叉树结构的数据结构可以达到最高的查询效率这是毋庸置疑的。</p>
<p>既然如此，那么数据库索引为什么不用 AVL 树或者红黑树呢？</p>
<p>这就牵扯到一个问题了，不考虑每种数据结构的前提条件而选择数据结构都是在耍流氓。</p>
<p>AVL 数和红黑树基本都是存储在内存中才会使用的数据结构，那磁盘中会有什么不同呢？</p>
<p>这就要牵扯到磁盘的存储原理了</p>
<p>操作系统读写磁盘的基本单位是扇区，而文件系统的基本单位是簇(Cluster)。</p>
<p>也就是说，磁盘读写有一个最少内容的限制，即使我们只需要这个簇上的一个字节的内容，我们也要含着泪把一整个簇上的内容读完。</p>
<p>那么，现在问题就来了</p>
<p>一个父节点只有 2 个子节点，并不能填满一个簇上的所有内容啊？那多余的内容岂不是要浪费了？我们怎么才能把浪费的这部分内容利用起来呢？哈哈，答案就是 B+ 树。</p>
<p>由于 B+ 树分支比二叉树更多，所以相同数量的内容，B+ 树的深度更浅，深度代表什么？代表磁盘 io 次数啊！数据库设计的时候 B+ 树有多少个分支都是按照磁盘一个簇上最多能放多少节点设计的啊！</p>
<p>所以，涉及到磁盘上查询的数据结构，一般都用 B+ 树啦。</p>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>哈希索引自然是基于哈希表实现，<strong>只有匹配所有列的查询才有效</strong>。对于每一行数据，存储引擎都会对所有索引列计算一个哈希码，哈希码是一个较小的值，不同键值的行计算出的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时保存指向每个数据行的指针。</p>
<p>如果多个列的哈希值相同(哈希冲突)，索引会以链表的方式存放多个记录指针到同一个哈希条目中去。</p>
<p><img src="/2022/08/22/Mysql%E7%B4%A2%E5%BC%95/6.png"></p>
<h4 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h4><ol>
<li>哈希索引只保存哈希码和指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过访问内存中的行速度非常快（因为是MEMORY引擎），所以对性能影响并不大</li>
<li>哈希索引数据并不是按照索引值顺序存储的，所以无法用于排序</li>
<li>哈希索引不支持部分索引列查找，因为哈希索引始终是使用索引列的全部内容来计算哈希码。 如，在数据列（A,B）上建立哈希索引，如果查询只有数据列A，则无法使用该哈希索引</li>
<li>哈希索引只支持等值比较查询，包括<code>=</code> ,<code>IN()</code> ,<code>&lt;=&gt;</code>  ;哈希索引<strong>不支持范围查询</strong>，如where price &gt; 100</li>
<li>哈希冲突（不同索引列会用相同的哈希码）会影响查询速度，此时需遍历索引中的行指针，<strong>逐行进行比较</strong>。</li>
</ol>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/08/21/Design-Patterns-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/08/21/Design-Patterns-3/" itemprop="url">Design-Patterns-3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-08-21T21:37:56+08:00">
                2022-08-21
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-08-22T11:28:32+08:00">
                2022-08-22
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Design-Patterns-创建型模式"><a href="#Design-Patterns-创建型模式" class="headerlink" title="Design Patterns 创建型模式"></a>Design Patterns 创建型模式</h1><h2 id="Prototype-Pattern"><a href="#Prototype-Pattern" class="headerlink" title="Prototype Pattern"></a>Prototype Pattern</h2><h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h3><h2 id="Singleton-Pattern"><a href="#Singleton-Pattern" class="headerlink" title="Singleton Pattern"></a>Singleton Pattern</h2><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p><strong>注意：</strong></p>
<ul>
<li>1、单例类只能有一个实例。</li>
<li>2、单例类必须自己创建自己的唯一实例。</li>
<li>3、单例类必须给所有其他对象提供这一实例。</li>
</ul>
<h3 id="The-Problem-1"><a href="#The-Problem-1" class="headerlink" title="The Problem"></a>The Problem</h3><p>我们看到，如果不是用单例模式创建的类，可以申明多个实例，每个实例之间是互相独立的。那么有没有办法，能让这个类只能有唯一实例，而且提供给其他对象这个唯一实例呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; settings = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key,Object value)</span> </span>&#123;</span><br><span class="line">        settings.put(key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> settings.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       ConfigManager manager = <span class="keyword">new</span> ConfigManager();<span class="comment">//创建了ConfigManager第一个实例</span></span><br><span class="line">       manager.set(<span class="string">"name"</span>,<span class="string">"Mosh"</span>);<span class="comment">//设置一个键值对 </span></span><br><span class="line">       ConfigManager other = <span class="keyword">new</span> ConfigManager();<span class="comment">//创建了第二个实例，但是查询结果为null</span></span><br><span class="line">       System.out.println(other.get(<span class="string">"name"</span>)); <span class="comment">//null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外还有如下应用场景：</p>
<ul>
<li>一个班级只有一个班主任。</li>
<li>Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。</li>
<li>一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</li>
<li>要求生产唯一序列号。</li>
<li>WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</li>
<li>创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</li>
</ul>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p><strong>如何解决：</strong>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p>
<p><strong>关键代码：</strong>构造函数是私有的。</p>
<p>我们将创建一个 <code>SingleObject</code> 类。<em>SingleObject</em> 类有它的私有构造函数和本身的一个静态实例。</p>
<p><code>SingleObject</code> 类提供了一个静态方法，<strong>供外界获取它的静态实例</strong>。<code>SingletonPatternDemo</code> 类使用 <code>SingleObject</code>类来获取 <code>SingleObject</code>对象。</p>
<p><img src="/2022/08/21/Design-Patterns-3/1.png" style="zoom:67%;"></p>
<h3 id="Implementation-1"><a href="#Implementation-1" class="headerlink" title="Implementation"></a>Implementation</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; settings = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">    <span class="comment">//必须设为静态的</span></span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">static</span> ConfigManager instance = <span class="keyword">new</span> ConfigManager();<span class="comment">//实例在类中构造</span></span><br><span class="line">		<span class="comment">//必须设为静态的，只能类内调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigManager <span class="title">getInstance</span><span class="params">()</span> </span>&#123;<span class="comment">//单例getter</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ConfigManager</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">//私有的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String key,Object value)</span> </span>&#123;</span><br><span class="line">        settings.put(key,value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> settings.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       ConfigManager manager = ConfigManager.getInstance();</span><br><span class="line">       manager.set(<span class="string">"name"</span>,<span class="string">"Jason"</span>);</span><br><span class="line">       ConfigManager other =  ConfigManager.getInstance();<span class="comment">//类外获得的始终是一个实例</span></span><br><span class="line">       System.out.println(other.get(<span class="string">"name"</span>));   <span class="comment">//Jason</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>优点：</strong></p>
<ul>
<li>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li>
<li>2、避免对资源的多重占用（比如写文件操作）。</li>
</ul>
<p><strong>缺点：</strong>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<h3 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise"></a>Exercise</h3><p>Look at the Logger class in the singleton package of the Exercises project. With the current implementation, we can create multiple loggers writing to the same log file in parallel.</p>
<p>Use the singleton pattern to ensure only a single logger can be instantiated for a given file.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLogger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; loggerList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MyLogger instance = <span class="keyword">new</span> MyLogger();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyLogger <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyLogger</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getLoggerList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> loggerList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printLog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String log : loggerList)&#123;</span><br><span class="line">            System.out.println(log);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLog</span><span class="params">(String log)</span> </span>&#123;</span><br><span class="line">        loggerList.add(log);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyLogger logger = MyLogger.getInstance();</span><br><span class="line"></span><br><span class="line">        logger.addLog(<span class="string">"2022 8 22 11:26"</span>);</span><br><span class="line"></span><br><span class="line">        MyLogger logger2 = MyLogger.getInstance();</span><br><span class="line">        logger2.addLog(<span class="string">"2022 8 22 11:27"</span>);</span><br><span class="line"></span><br><span class="line">        MyLogger.printLog();</span><br><span class="line">      <span class="comment">//2022 8 22 11:26</span></span><br><span class="line">			<span class="comment">//2022 8 22 11:27</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Factory-Method-Pattern"><a href="#Factory-Method-Pattern" class="headerlink" title="Factory Method Pattern"></a>Factory Method Pattern</h2><h3 id="The-Problem-2"><a href="#The-Problem-2" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-2"><a href="#Implementation-2" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise"></a>Exercise</h3><h2 id="Abstract-Factory-Pattern"><a href="#Abstract-Factory-Pattern" class="headerlink" title="Abstract Factory Pattern"></a>Abstract Factory Pattern</h2><h3 id="The-Problem-3"><a href="#The-Problem-3" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-3"><a href="#Implementation-3" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise"></a>Exercise</h3><h2 id="Builder-Pattern"><a href="#Builder-Pattern" class="headerlink" title="Builder Pattern"></a>Builder Pattern</h2><h3 id="The-Problem-4"><a href="#The-Problem-4" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-4"><a href="#Implementation-4" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise"></a>Exercise</h3>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/08/21/Design-Patterns-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/08/21/Design-Patterns-2/" itemprop="url">Design-Patterns-2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-08-21T21:37:51+08:00">
                2022-08-21
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-08-22T01:01:36+08:00">
                2022-08-22
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="设计模式2-结构型模式"><a href="#设计模式2-结构型模式" class="headerlink" title="设计模式2-结构型模式"></a>设计模式2-结构型模式</h1><h2 id="Composite-Pattern"><a href="#Composite-Pattern" class="headerlink" title="Composite Pattern"></a>Composite Pattern</h2><p>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。</p>
<h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>比如说，在PPT中我创建了两个长方形，两个圆形，那么我们可以选中两个长方形将它们同时移动或者缩放；同样的，我们甚至可以选中四个物体同时移动缩放</p>
<p><img src="/2022/08/21/Design-Patterns-2/1.gif" style="zoom:67%;"></p>
<p>除此之外，最经典的例子是文件夹与文件的表示，一个文件夹（容器对象）既可以存放文件夹（容器对象），也可以存放文件（叶子对象）。如果把树的每个节点摊平，那就是<code>List</code>。而树结构，则是更能直观的体现每个节点与整体的关系。</p>
<p><strong>为什么需要这个模式呢？它的目的是什么？</strong></p>
<p>可以体现出类与类之间的层级结构</p>
<p>主要是想要对外提供一致性的使用方式，即使容器对象与叶子对象之间属性差别可能非常大，我们希望抽象出相同的地方，一致的处理。</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>组合模式中一般有以下三种角色：</p>
<ul>
<li>抽象构件（<code>Component</code>）：一般是接口或者抽象类，是叶子构件和容器构件对象声明接口，抽象出访问以及管理子构件的方法。</li>
<li>叶子节点（<code>Leaf</code>）：在组合中表示叶子节点对象，叶子节点没有子节点，也就没有子构件。</li>
<li>容器构件（<code>Composite</code>）：容器节点可以包含子节点，子节点可以是叶子节点，也可以是容器节点。</li>
</ul>
<p><img src="/2022/08/21/Design-Patterns-2/2.png" style="zoom:67%;"></p>
<h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Component</span> </span>&#123; <span class="comment">// Component接口，容器和叶子都需要实现它</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">render</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> <span class="keyword">implements</span> <span class="title">Component</span></span>&#123; <span class="comment">//实现component接口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写render方法，因为是叶子类，因此只需要实现单个逻辑即可</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Render Shape"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Group</span> <span class="keyword">implements</span> <span class="title">Component</span></span>&#123; <span class="comment">// 实现接口</span></span><br><span class="line">    <span class="comment">// Group中可以有多个component组成，这个角度看Group和Shape是相等的</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Component&gt; components = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以往components中添加shape/group</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component shape)</span></span>&#123;</span><br><span class="line">        components.add(shape);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写render方法，对列表中的每一个Component都调用render</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Component component:components)&#123;</span><br><span class="line">            component.render();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       Group group1 = <span class="keyword">new</span> Group();</span><br><span class="line">       group1.add(<span class="keyword">new</span> Shape());</span><br><span class="line">       group1.add(<span class="keyword">new</span> Shape());</span><br><span class="line"></span><br><span class="line">       Group group2 = <span class="keyword">new</span> Group();</span><br><span class="line">       group2.add(<span class="keyword">new</span> Shape());</span><br><span class="line">       group2.add(<span class="keyword">new</span> Shape());</span><br><span class="line"></span><br><span class="line">       Group group = <span class="keyword">new</span> Group();</span><br><span class="line">       group.add(group1);</span><br><span class="line">       group.add(group2);</span><br><span class="line">      <span class="comment">//层次结构如下：</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      - group</span></span><br><span class="line"><span class="comment">      -	-	group1</span></span><br><span class="line"><span class="comment">      -	-	- shape</span></span><br><span class="line"><span class="comment">      -	-	-	shape</span></span><br><span class="line"><span class="comment">      -	-	group2</span></span><br><span class="line"><span class="comment">      -	-	-	shape</span></span><br><span class="line"><span class="comment">      -	-	- shape</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">       group.render();<span class="comment">//一共是四个叶子结点，执行四次render</span></span><br><span class="line">       <span class="comment">//Render Shape</span></span><br><span class="line">        <span class="comment">//Render Shape</span></span><br><span class="line">        <span class="comment">//Render Shape</span></span><br><span class="line">        <span class="comment">//Render Shape</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>组合模式的优点：</p>
<ul>
<li>可以分层次定义复杂对象，表示局部和全部，客户端可以忽略不同的节点的差异。</li>
<li>从高层次调用，可以很顺畅的调用到每一个局部，一致性比较强。</li>
<li>节点自由搭配，灵活度比较高。</li>
</ul>
<p>缺点：</p>
<ul>
<li>在使用组合模式时，其叶子和组合节点的声明都是实现类，而不是接口，违反了依赖倒置原则。</li>
</ul>
<p>使用场景：</p>
<ul>
<li>希望忽略每个部分的差异，客户端一致使用</li>
<li>需要表现为树形结构，以表示“整体-部分”的结构层次。</li>
</ul>
<h3 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h3><p>We’re building an application for an incident management organization. When an incident (eg fire) occurs, one or more teams may be deployed to attack the incident. </p>
<p>A team often includes a truck and one or more human resources. It can also include a sub team. For example, for a medium-sized incident, we may need to deploy two teams and each team may contain a truck and two persons. </p>
<ul>
<li><p>Team </p>
<ul>
<li><p>Sub Team 1 </p>
<ul>
<li>Truck </li>
<li>Human Resource </li>
<li>Human Resource </li>
</ul>
</li>
<li><p>Sub Team 2 </p>
<ul>
<li>Truck </li>
<li>Human Resource </li>
<li>Human Resource </li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Look at the current implementation of our application in the composite package. </p>
<p>What are the problems with this implementation? Refactor the code using the composite pattern. </p>
<h2 id="Adapter-Pattern"><a href="#Adapter-Pattern" class="headerlink" title="Adapter Pattern"></a>Adapter Pattern</h2><h3 id="The-Problem-1"><a href="#The-Problem-1" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-1"><a href="#Implementation-1" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise"></a>Exercise</h3><h2 id="Decorator-Pattern"><a href="#Decorator-Pattern" class="headerlink" title="Decorator Pattern"></a>Decorator Pattern</h2><h3 id="The-Problem-2"><a href="#The-Problem-2" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-2"><a href="#Implementation-2" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise"></a>Exercise</h3><h2 id="Facade-Pattern"><a href="#Facade-Pattern" class="headerlink" title="Facade Pattern"></a>Facade Pattern</h2><h3 id="The-Problem-3"><a href="#The-Problem-3" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-3"><a href="#Implementation-3" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise"></a>Exercise</h3><h2 id="Flyweight-Pattern"><a href="#Flyweight-Pattern" class="headerlink" title="Flyweight Pattern"></a>Flyweight Pattern</h2><h3 id="The-Problem-4"><a href="#The-Problem-4" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-4"><a href="#Implementation-4" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise"></a>Exercise</h3><h2 id="Bridge-Pattern"><a href="#Bridge-Pattern" class="headerlink" title="Bridge Pattern"></a>Bridge Pattern</h2><h3 id="The-Problem-5"><a href="#The-Problem-5" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-5"><a href="#Implementation-5" class="headerlink" title="Implementation"></a>Implementation</h3><h2 id="Proxy-Pattern"><a href="#Proxy-Pattern" class="headerlink" title="Proxy Pattern"></a>Proxy Pattern</h2><h3 id="The-Problem-6"><a href="#The-Problem-6" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-6"><a href="#Implementation-6" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise"></a>Exercise</h3>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/08/19/Design-Patterns-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/08/19/Design-Patterns-1/" itemprop="url">Design-Patterns-1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-08-19T10:52:17+08:00">
                2022-08-19
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-08-22T12:50:22+08:00">
                2022-08-22
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Design-Patterns-Behavioural"><a href="#Design-Patterns-Behavioural" class="headerlink" title="Design Patterns - Behavioural"></a>Design Patterns - Behavioural</h1><p>首先，什么是设计模式？设计模式是软件开发人员在软件开发过程中面临的<strong>一般问题</strong>的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>
<p>设计模式可以教我们如何去架构一个类、以及类与类之间如何联系起来。在90年代由GoF(四人帮)出版的《设计模式-可复用的面向对象软件元素》的数介绍了23种设计模式</p>
<p>这些设计模式会被分成三类：Creational(创建型)、 Structure(结构型)、Behavioural(行为型)</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left"></th>
<th style="text-align:left"><span style="display:inline-block;width: 400px">包括</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>创建型模式</strong> 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</td>
<td style="text-align:left">工厂模式（Factory Pattern）<br>抽象工厂模式（Abstract Factory Pattern）<br>单例模式（Singleton Pattern）<br>建造者模式（Builder Pattern）<br>原型模式（Prototype Pattern）</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>结构型模式</strong> 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td>
<td style="text-align:left">适配器模式（Adapter Pattern）<br>桥接模式（Bridge Pattern）<br>过滤器模式（Filter、Criteria Pattern）<br>组合模式（Composite Pattern）<br>装饰器模式（Decorator Pattern）<br>外观模式（Facade Pattern）<br>享元模式（Flyweight Pattern）<br>代理模式（Proxy Pattern）</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>行为型模式</strong> 这些设计模式特别关注对象之间的通信。</td>
<td style="text-align:left">责任链模式（Chain of Responsibility Pattern）<br>命令模式（Command Pattern）<br>解释器模式（Interpreter Pattern）<br>迭代器模式（Iterator Pattern）<br>中介者模式（Mediator Pattern）<br>备忘录模式（Memento Pattern）<br>观察者模式（Observer Pattern）<br>状态模式（State Pattern）<br>空对象模式（Null Object Pattern）<br>策略模式（Strategy Pattern）<br>模板模式（Template Pattern）<br>访问者模式（Visitor Pattern）</td>
</tr>
</tbody>
</table>
</div>
<h2 id="The-Essentials"><a href="#The-Essentials" class="headerlink" title="The Essentials"></a>The Essentials</h2><p>首先我们要复习一些Java OOP的基本知识</p>
<h3 id="Coupling"><a href="#Coupling" class="headerlink" title="Coupling"></a>Coupling</h3><h3 id="Interfaces"><a href="#Interfaces" class="headerlink" title="Interfaces"></a>Interfaces</h3><p>接下来介绍OOP的<strong>四大特性</strong>： </p>
<ul>
<li><strong>封装性</strong>：对象属性是隐藏的，对象属性修改需要通过对象方法。</li>
<li><strong>继承性</strong>：子类可以把父类的属性和方法都继承过来，无需重新定义。</li>
<li><strong>多态性</strong>：多态分为静态和动态，静态是指同一个对象可以有不同的表现形式，动态指一个父类型可以指向其子类型的实例，使子类型对同一方法作出不同的回应。</li>
<li><strong>抽象性</strong>：抽象指把一类东西的共同属性和行为提取出来存在一个类里面，而不关注具体行为如何实现。</li>
</ul>
<h3 id="Encapsulation"><a href="#Encapsulation" class="headerlink" title="Encapsulation"></a>Encapsulation</h3><p>见博客：<a href="https://jasonxqh.github.io/2020/07/05/Java基础2/#Encapsulation">Encapsulation</a></p>
<h3 id="Abstraction"><a href="#Abstraction" class="headerlink" title="Abstraction"></a>Abstraction</h3><h3 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h3><p>我们知道抽象类和接口都可以用于实现抽象，但是他们应用的场景有所区别。</p>
<p>接口和抽象类的区别在于，接口一般只提供函数定义，并不会进行声明；抽象类允许包含某些方法的实现。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>共性</th>
<th>都是不断抽取出来的抽象概念</th>
</tr>
</thead>
<tbody>
<tr>
<td>区别1</td>
<td>抽象类体现继承关系，一个类只能单继承<br>接口体现实现关系，一个类可以多实现</td>
</tr>
<tr>
<td>区别2</td>
<td>抽象类是继承，是 “is a”关系<br>接口是实现，是”like a”关系</td>
</tr>
<tr>
<td>区别3</td>
<td>抽象类中可以定义非抽象方法，供子类直接使用<br>接口的方法都是抽象，接口中的成员都有固定修饰符</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Polymorphism"><a href="#Polymorphism" class="headerlink" title="Polymorphism"></a>Polymorphism</h3><p><a href="https://jasonxqh.github.io/2020/07/05/Java基础2/#Polymorphism">Polymorphism</a></p>
<h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><p>UML 是 Unified Modeling Language的缩写，即一种统一建模语言</p>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><ul>
<li>由用例图抽象出来的静态结构图，描述类的内部结构</li>
<li>“-”代表成员变量</li>
<li>“+”代表方法</li>
</ul>
<p>比如，对于一个 shape 类来说，它的类图如下设计：</p>
<p><img src="/2022/08/19/Design-Patterns-1/1.png" style="zoom:67%;"></p>
<p>那么，其代码结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> positionX;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h4><h5 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h5><ul>
<li>类型：General Relationship</li>
<li>描述：使用另一个类（uses a)，某个对象的功能依赖于另外的某个对象，而被依赖的对象知识作为一种工具在使用，并不持有对它的引用</li>
<li>表现：局部变量、方法参数、静态方法的调用</li>
<li>表示：<strong>带箭头的虚线</strong>，由使用者指向被使用者</li>
</ul>
<p>比如下图，展示了Shape类中使用了Document类：</p>
<p><img src="/2022/08/19/Design-Patterns-1/2.png" style="zoom:67%;"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(Document doc)</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="继承（extends）"><a href="#继承（extends）" class="headerlink" title="继承（extends）"></a><strong>继承（extends）</strong></h5><ul>
<li>类型：Class Level Relationship</li>
<li>描述：指定了子类如何继承父类的所有特征和行为</li>
<li>表示：带三角形箭头的实线，由子类指向父类</li>
</ul>
<p><img src="/2022/08/19/Design-Patterns-1/3.png" style="zoom:67%;"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Rectangle extends Shape&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="组合（Composition）"><a href="#组合（Composition）" class="headerlink" title="组合（Composition）"></a>组合（Composition）</h5><ul>
<li>描述：组合是关系当中的最强版本，它直接要求包含对象对被包含对象的拥有（is a part of）以及包含对象与被包含对象⽣命期的关系。被包含的对象还可以再被别的对象关联，所以被包含对象是可以共享的，然⽽绝不存在两个包含对象对同⼀个被包含对象的共享。</li>
<li>表现：成员变量</li>
<li>表示：箭尾有一实心菱形的“关联”</li>
</ul>
<p><img src="/2022/08/19/Design-Patterns-1/4.png" style="zoom:67%;"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Shape&#123;</span><br><span class="line">	private Size size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Memento-Pattern"><a href="#Memento-Pattern" class="headerlink" title="Memento Pattern"></a>Memento Pattern</h2><p>第一种我们要学习的是备忘录模式（Memento Pattern）。备忘录模式保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。</p>
<h3 id="The-Problem"><a href="#The-Problem" class="headerlink" title="The Problem"></a>The Problem</h3><p>在不破坏封装性的前提下，如何捕获并保存一个对象的内部状态，并在该对象之外保存这个状态。这样可以在以后将对象回复到原先保存的状态。</p>
<p>比如说，我有一个Editor类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Editor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我在main函数中多次设置了这个Editor，现在我想回退(undo)一个状态，请问该怎么实现？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Editor editor = <span class="keyword">new</span> Editor();</span><br><span class="line">        editor.setContent(<span class="string">"a"</span>);</span><br><span class="line">        editor.setContent(<span class="string">"b"</span>);</span><br><span class="line">        editor.undo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如何解决：</strong>通过一个备忘录类专门存储对象状态。</p>
<p><strong>关键代码：</strong>客户不与备忘录类耦合，与备忘录管理类耦合。</p>
<p><strong>应用实例：</strong> 1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctrl + z。 4、IE 中的后退。 5、数据库的事务管理。</p>
<p><strong>优点：</strong> 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2、实现了信息的封装，使得用户不需要关心状态的保存细节。</p>
<p><strong>缺点：</strong>消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</p>
<p><strong>使用场景：</strong> 1、需要保存/恢复数据的相关状态场景。 2、提供一个可回滚的操作。</p>
<p><strong>注意事项：</strong> 1、为了符合迪米特原则，还要增加一个管理备忘录的类。 2、为了节约内存，可使用原型模式+备忘录模式。</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>根据 Single Responsibility Principle ，每个类只需要负责一项任务.</p>
<p>因此，Editor类中，只需要保存当前状态的内容，以及两个方法：</p>
<ul>
<li><code>createState()</code>： 将当前Editor中的内容创建一个 EditorState对象, 并返回这个对象。然后，History类会调用push方法将该状态添加到状态列表中</li>
<li><code>restore()</code>:   从一个EditorState对象中恢复得到content内容</li>
</ul>
<p>在 EditorState类：这是一个保存状态的类，里面除了content之外还有 getter(UML图中省略了)</p>
<p>在History类：这个类中保存了一个状态列表，用来保存之前的状态。此外，还有push和pop方法，用来添加和删除状态</p>
<p><img src="/2022/08/19/Design-Patterns-1/6.png" style="zoom:67%;"></p>
<p>事实上，将这三个类抽象出来，是三种不同的类： <em>Memento</em>、<em>Originator</em> 和 <em>CareTaker</em>。</p>
<ul>
<li><p>Originator(Editor) 创建并在 Memento 对象中存储状态</p>
</li>
<li><p>Memento (EditorState) 包含了要被恢复的对象的状态。</p>
</li>
<li>Caretaker (History) 对象负责从 Memento 中恢复对象的状态。</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 </li>
<li>实现了信息的封装，使得用户不需要关心状态的保存细节。</li>
</ol>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li>消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</li>
</ol>
<h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p>备忘录模式实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Editor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EditorState <span class="title">createState</span><span class="params">()</span> </span>&#123; <span class="comment">// 创建一个新的EditorState</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EditorState(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restore</span><span class="params">(EditorState state)</span> </span>&#123; <span class="comment">// 从一个state中恢复数据</span></span><br><span class="line">        content = state.getContent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123; <span class="comment">//getter</span></span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;<span class="comment">//setter</span></span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EditorState</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String content; 	</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EditorState</span><span class="params">(String content)</span> </span>&#123; <span class="comment">//构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">History</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;EditorState&gt; states = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">// State列表</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">push</span> <span class="params">(EditorState state)</span> </span>&#123; <span class="comment">// 加入列表</span></span><br><span class="line">        states.add(state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> EditorState <span class="title">pop</span> <span class="params">()</span></span>&#123;	<span class="comment">//选择最近的状态，pop</span></span><br><span class="line">        <span class="keyword">int</span> lastIndex = states.size()-<span class="number">1</span>;</span><br><span class="line">        EditorState lastState = states.get(lastIndex);</span><br><span class="line">        states.remove(lastState);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lastState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Editor editor = <span class="keyword">new</span> Editor();</span><br><span class="line">        History history = <span class="keyword">new</span> History();</span><br><span class="line"></span><br><span class="line">        editor.setContent(<span class="string">"a"</span>);</span><br><span class="line">        history.push(editor.createState());</span><br><span class="line"></span><br><span class="line">        editor.setContent(<span class="string">"b"</span>);</span><br><span class="line">        history.push(editor.createState());</span><br><span class="line"></span><br><span class="line">        editor.setContent(<span class="string">"c"</span>);<span class="comment">//此时状态为c</span></span><br><span class="line">        editor.restore(history.pop());<span class="comment">//但是因为调用了restore,因此回退了一个版本</span></span><br><span class="line"></span><br><span class="line">        System.out.println(editor.getContent());<span class="comment">//此时editor版本为b</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h3><p>In the Exercises project, look at the code in the memento/Document class. This class represents a document in a word processor like MS Word or Apple Pages.</p>
<p>Our Document class has three attributes: </p>
<ul>
<li>content </li>
<li>fontName</li>
<li>fontSize </li>
</ul>
<p>We should allow the user to undo the changes to any of these attributes. In the future, we may add additional attributes in this class and these attributes should also be undoable. </p>
<p>Implement the undo feature using the memento pattern</p>
<h2 id="State-Pattern"><a href="#State-Pattern" class="headerlink" title="State Pattern"></a>State Pattern</h2><p>在状态模式（State Pattern）中，类的行为是基于它的状态改变的。在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。</p>
<h3 id="The-Problem-1"><a href="#The-Problem-1" class="headerlink" title="The Problem"></a>The Problem</h3><p><strong>意图：</strong>允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</p>
<p><strong>主要解决：</strong>对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。</p>
<p><strong>何时使用：</strong>代码中包含大量与对象状态有关的条件语句。</p>
<p>比如说，我现在要设计一个和PS类似的软件，那么，当我点击不同的侧栏工具的时候，鼠标在画板上拖动的效果也是不一样的。比如有选择工具、画笔工具、橡皮擦工具等</p>
<p>因此，一个原始的想法就是用很多if else语句或者switch case，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ToolType &#123;</span><br><span class="line">    SELECTION,</span><br><span class="line">    BRUSH,</span><br><span class="line">    ERASER</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Canvas</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ToolType currentTool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseDown</span><span class="params">()</span></span>&#123;<span class="comment">//点击icon后鼠标的形状</span></span><br><span class="line">        <span class="keyword">if</span>(currentTool == ToolType.SELECTION)</span><br><span class="line">            System.out.println(<span class="string">"Selection icon"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(currentTool == ToolType.BRUSH)</span><br><span class="line">            System.out.println(<span class="string">"Brush icon"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (currentTool==ToolType.ERASER)</span><br><span class="line">            System.out.println(<span class="string">"Eraser icon"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseUp</span><span class="params">()</span></span>&#123;<span class="comment">//在画布上拖动的效果</span></span><br><span class="line">        <span class="keyword">if</span>(currentTool == ToolType.SELECTION)</span><br><span class="line">            System.out.println(<span class="string">"Draw dashed rectangle"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(currentTool == ToolType.BRUSH)</span><br><span class="line">            System.out.println(<span class="string">"Draw a line"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (currentTool==ToolType.ERASER)</span><br><span class="line">            System.out.println(<span class="string">"Erase something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么有没有更好的办法呢？</p>
<h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>我们可以创建一个Tool接口，里面定义两个函数 mouseDown()和mouseUp()，然后用两个具体的状态来实现这个接口，如下所示：</p>
<p><img src="/2022/08/19/Design-Patterns-1/7.png" style="zoom:67%;"></p>
<p>将其抽象出来，如下所示：</p>
<p><img src="/2022/08/19/Design-Patterns-1/8.png" style="zoom:67%;"></p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a><strong>优点：</strong></h4><ol>
<li>封装了转换规则。</li>
<li>枚举可能的状态，在枚举状态之前需要确定状态种类。 </li>
<li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 </li>
<li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 </li>
<li>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</li>
</ol>
<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li>状态模式的使用必然会增加系统类和对象的个数。 </li>
<li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。</li>
<li>状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。</li>
</ol>
<h3 id="Implementation-1"><a href="#Implementation-1" class="headerlink" title="Implementation"></a>Implementation</h3><p>首先，我可以创建一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Tool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseDown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseUp</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们创建两个状态类，用来实现这个接口，每个状态类中mouseDown和mouseUp的行为都是不同的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrushTool</span> <span class="keyword">implements</span> <span class="title">Tool</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Brush icon"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Draw a line"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionTool</span> <span class="keyword">implements</span> <span class="title">Tool</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Selection icon"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Draw a Dashed Rectangle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是，在Canvas中就不用写繁琐的switch case或者if-else case了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Canvas</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Tool currentTool;	</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 调用当前接口的mouseDown或者mouseUp方法就可以实现不同结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseDown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        currentTool.mouseDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        currentTool.mouseUp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Tool <span class="title">getCurrentTool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentTool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrentTool</span><span class="params">(Tool currentTool)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentTool = currentTool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，只要给Canvas设置不同的状态，就可以展现不同的行为了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Canvas canvas = <span class="keyword">new</span> Canvas();</span><br><span class="line"></span><br><span class="line">        canvas.setCurrentTool(<span class="keyword">new</span> SelectionTool());</span><br><span class="line">        canvas.mouseDown(); <span class="comment">// Selection icon</span></span><br><span class="line">        canvas.mouseUp();   <span class="comment">// Draw a Dashed Rectangle</span></span><br><span class="line"></span><br><span class="line">        canvas.setCurrentTool(<span class="keyword">new</span> BrushTool());</span><br><span class="line">        canvas.mouseDown(); <span class="comment">// Brush icon</span></span><br><span class="line">        canvas.mouseUp();   <span class="comment">// Draw a line</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Abusing-the-State-Pattern"><a href="#Abusing-the-State-Pattern" class="headerlink" title="Abusing the State Pattern"></a>Abusing the State Pattern</h3><p>之前说了，State Pattern 必然会增加系统类和对象的个数。 因此，如果不正确使用它的话，很可能造成滥用。比如说下面这个情况：</p>
<p>比如说我想设计一个时钟类，这个类很不需要很多状态，只有<code>running</code>和<code>stop</code>，也只需要一个方法：<code>click</code>。因此，对这种不会有“发展”的、简单的类，用if-else case就可以解决了，不需要再使用state pattern</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopWatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isRunning;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isRunning)&#123;</span><br><span class="line">            isRunning = <span class="keyword">false</span>;</span><br><span class="line">            System.out.println(<span class="string">"Stopped"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            isRunning = <span class="keyword">true</span>;</span><br><span class="line">            System.out.println(<span class="string">"Running"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StopWatch stop_watch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">        stop_watch.click();	<span class="comment">// Running</span></span><br><span class="line">        stop_watch.click();	<span class="comment">// Stopped</span></span><br><span class="line">        stop_watch.click(); <span class="comment">// Running</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，如果对State Pattern了解不够的话，在这种情况下很可能会滥用，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopWatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> State currentState = <span class="keyword">new</span> StopState(<span class="keyword">this</span>); <span class="comment">//初始化是停止状态</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrentState</span><span class="params">(State currentState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState = currentState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">()</span></span>&#123; <span class="comment">//调用click，就会开始/停止</span></span><br><span class="line">        currentState.click();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;<span class="comment">//创建接口函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">click</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunningState</span> <span class="keyword">implements</span> <span class="title">State</span></span>&#123; <span class="comment">//分别实现运行时状态和停止状态</span></span><br><span class="line">    <span class="keyword">private</span> StopWatch stopWatch;								</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RunningState</span><span class="params">(StopWatch stopWatch)</span> </span>&#123;<span class="comment">//构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.stopWatch = stopWatch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">()</span></span>&#123;<span class="comment">//每次点击时，先设置相反的状态，然后打印</span></span><br><span class="line">        stopWatch.setCurrentState(<span class="keyword">new</span> StopState(stopWatch));</span><br><span class="line">        System.out.println(<span class="string">"Stopped"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopState</span> <span class="keyword">implements</span> <span class="title">State</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StopWatch stopWatch;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StopState</span><span class="params">(StopWatch stopWatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stopWatch = stopWatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stopWatch.setCurrentState(<span class="keyword">new</span> RunningState(stopWatch));</span><br><span class="line">        System.out.println(<span class="string">"Running"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样虽然结果是一样的，但就会显得非常繁琐，多出来很多类，浪费很多空间。</p>
<h3 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise"></a>Exercise</h3><p>In the Exercises project, look at the code in the state/ DirectionService class. This is the class that powers our mapping app. It provides two methods for calculating the estimated time of arrival (ETA) and the direction between two points. </p>
<p>Identify the problems in this implementation. Then, refactor the code to use the state pattern. What are the benefits of the new implementation?</p>
<h2 id="Iterator-Pattern"><a href="#Iterator-Pattern" class="headerlink" title="Iterator Pattern"></a>Iterator Pattern</h2><h3 id="The-Problem-2"><a href="#The-Problem-2" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-2"><a href="#Implementation-2" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Benefits"><a href="#Benefits" class="headerlink" title="Benefits"></a>Benefits</h3><h3 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise"></a>Exercise</h3><h3 id="A-Quick-Note"><a href="#A-Quick-Note" class="headerlink" title="A Quick Note"></a>A Quick Note</h3><h2 id="Strategy-Pattern"><a href="#Strategy-Pattern" class="headerlink" title="Strategy Pattern"></a>Strategy Pattern</h2><h3 id="The-Problem-3"><a href="#The-Problem-3" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-3"><a href="#Implementation-3" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise"></a>Exercise</h3><h2 id="Template-Method-Pattern"><a href="#Template-Method-Pattern" class="headerlink" title="Template Method Pattern"></a>Template Method Pattern</h2><h3 id="The-Problem-4"><a href="#The-Problem-4" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-4"><a href="#Implementation-4" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise"></a>Exercise</h3><h2 id="Command-Pattern"><a href="#Command-Pattern" class="headerlink" title="Command Pattern"></a>Command Pattern</h2><h3 id="The-Problem-5"><a href="#The-Problem-5" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-5"><a href="#Implementation-5" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Composite-Commands"><a href="#Composite-Commands" class="headerlink" title="Composite Commands"></a>Composite Commands</h3><h3 id="Undoable-Commands"><a href="#Undoable-Commands" class="headerlink" title="Undoable Commands"></a>Undoable Commands</h3><h3 id="Implementing-Undo-Mechanism"><a href="#Implementing-Undo-Mechanism" class="headerlink" title="Implementing Undo Mechanism"></a>Implementing Undo Mechanism</h3><h3 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise"></a>Exercise</h3><h2 id="Observer-Pattern"><a href="#Observer-Pattern" class="headerlink" title="Observer Pattern"></a>Observer Pattern</h2><h3 id="The-Problem-6"><a href="#The-Problem-6" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-6"><a href="#Implementation-6" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Communication-Styles"><a href="#Communication-Styles" class="headerlink" title="Communication Styles"></a>Communication Styles</h3><h3 id="The-Push-Style"><a href="#The-Push-Style" class="headerlink" title="The Push Style"></a>The Push Style</h3><h3 id="The-Pull-Style"><a href="#The-Pull-Style" class="headerlink" title="The Pull Style"></a>The Pull Style</h3><h3 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise"></a>Exercise</h3><h2 id="Mediator-Pattern"><a href="#Mediator-Pattern" class="headerlink" title="Mediator Pattern"></a>Mediator Pattern</h2><h3 id="The-Problem-7"><a href="#The-Problem-7" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-7"><a href="#Implementation-7" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Using-the-Observer-Pattern"><a href="#Using-the-Observer-Pattern" class="headerlink" title="Using the Observer Pattern"></a>Using the Observer Pattern</h3><h3 id="Implementation-Using-the-Observer-Pattern"><a href="#Implementation-Using-the-Observer-Pattern" class="headerlink" title="Implementation Using the Observer Pattern"></a>Implementation Using the Observer Pattern</h3><h3 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise"></a>Exercise</h3><h2 id="Chain-of-Responsibility"><a href="#Chain-of-Responsibility" class="headerlink" title="Chain of Responsibility"></a>Chain of Responsibility</h2><h3 id="The-Problem-8"><a href="#The-Problem-8" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-8"><a href="#Implementation-8" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise"></a>Exercise</h3><h2 id="Visitor-Pattern"><a href="#Visitor-Pattern" class="headerlink" title="Visitor Pattern"></a>Visitor Pattern</h2><h3 id="The-Problem-9"><a href="#The-Problem-9" class="headerlink" title="The Problem"></a>The Problem</h3><h3 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h3><h3 id="Implementation-9"><a href="#Implementation-9" class="headerlink" title="Implementation"></a>Implementation</h3><h3 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise"></a>Exercise</h3>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/06/10/Raft/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/06/10/Raft/" itemprop="url">Raft</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-06-10T20:24:06+08:00">
                2022-06-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-06-24T09:50:02+08:00">
                2022-06-24
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h1><p>在 <a href="https://jasonxqh.github.io/2021/12/01/数据库-系统可用性/#Raft算法">Raft算法</a> 这篇博客中，我们初步学习了Raft算法，但是介绍的不够详细，我会在原来的基础上增加一部分内容</p>
<p>在介绍Raft算法前，我们首先要知道Paxos算法，但是它难以理解，状态空间十分复杂，因此没有构建显示系统的统一基础。由此才提出了Raft算法。</p>
<ul>
<li>Raft算法的应用：<ul>
<li>分布式KV系统，etcd</li>
<li>微服务基础设施，consul</li>
</ul>
</li>
</ul>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p> raft是一个共识算法（consensus algorithm），所谓共识，就是即使在部分节点故障、网络延时、网络分割的情况下，多个节点对某个事情达成一致的看法</p>
<p>而在分布式系统中，共识算法更多用于提高系统的容错性，比如分布式存储中的复制集（replication），在 带着问题学习分布式系统之中心化复制集 一文中介绍了中心化复制集的相关知识。raft协议就是一种leader-based的共识算法，与之相应的是leaderless的共识算法。</p>
<p>简单概括算法就是：raft会先选举出leader，leader完全负责replicated log的管理。leader负责接受所有客户端更新请求，然后复制到follower节点，并在“安全”的时候执行这些请求。如果leader故障，followes会重新选举出新的leader。</p>
<h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><p> 在正式介绍方法前，我们先来介绍一些基本知识</p>
<h4 id="复制状态机"><a href="#复制状态机" class="headerlink" title="复制状态机"></a>复制状态机</h4><p> 共识算法的实现一般是基于复制状态机（Replicated state machines），何为复制状态机：</p>
<blockquote>
<p>If two identical, <strong>deterministic</strong> processes begin in the same state and get the same inputs in the same order, they will produce the same output and end in the same state.</p>
</blockquote>
<p>   简单来说：<strong>相同的初识状态 + 相同的输入 = 相同的结束状态</strong>。引文中有一个很重要的词<code>deterministic</code>，就是说不同节点要以相同且确定性的函数来处理输入，而不要引入一些不确定的值，比如本地时间等。如何保证所有节点 <code>get the same inputs in the same order</code>，使用replicated log是一个很不错的注意，log具有持久化、保序的特点，是大多数分布式系统的基石。</p>
<p>  因此，可以这么说，在raft中，leader将客户端请求（command）封装到一个个log entry，将这些log entries复制（replicate）到所有follower节点，然后大家按相同顺序应用log entry中的command，则状态肯定是一致的。</p>
<p><img src="/2022/06/10/Raft/1.png"></p>
<p>如上图，在这个server中记录了日志 <code>x&lt;-3,y&lt;-1,y-9</code>(第二步)，那么日志发送给其他server之后(第二步)，其他server的状态也会和这个一致(第三步).</p>
<p>结合数据库来看，数据库会产生日志，实际上就是状态机中的log模块，数据库之间同步的时候，会先把日志部分同步到其他机器上，通过raft协议认证过日志之后(主要是在第二步)，就可以应用到数据库当中。</p>
<h4 id="任期"><a href="#任期" class="headerlink" title="任期"></a>任期</h4><p>在Raft算法中，哪个节点做leader是大家投票选举出来的，每个leader工作一段时间，然后选出新的leader继续负责。这根民主社会的选举很像，每一届新的履职期称之为一届任期，在raft协议中，也是这样的，对应的术语叫<strong>term</strong>。</p>
<p>如下图所示，是一个时间轴上的几种任期的情况</p>
<p><img src="/2022/06/10/Raft/2.png"></p>
<p>第1、2、4是正常的任期，即先进行选举，然后是常规操作(复制日志等)</p>
<p>第3个任期没有产生leader，说明选举失败了，那么会直接开始下一个任期，发起新的选举，没有常规操作。后面会解释这种 <em>split vote</em> 的情况。</p>
<ol>
<li>时间按任期划分，通过任期识别过时消息等</li>
<li>每个任期从Leader选举开始，选举结束后才正常处理客户端请求</li>
<li>存在某些选票被瓜分的情况，没有Leader产生，开始下一个任期</li>
</ol>
<p>term（任期）以选举（election）开始，然后就是一段或长或短的稳定工作期（normal Operation）。从上图可以看到，任期是递增的，这就充当了逻辑时钟的作用；</p>
<p>为什么要设置term？term就相当于把系统时间切成不规则的一片一片，每个term的作用就是确保一段时间内只能有一个leader。因为在分布式系统中，很容易出现脑裂的问题(出现多个leader)，那么这时候两个leader之间很容易出现矛盾，无法保证系统的一致性。Raft采用Term的方法，确保当前任期内只会选举出一个leader，且上一个term的leader不能管理下一个term。</p>
<h4 id="三种角色"><a href="#三种角色" class="headerlink" title="三种角色"></a>三种角色</h4><ul>
<li>Leader: 响应客户端的请求，同步数据</li>
<li>Candidate: Leader选举时的状态，获得多数选票可担任Leader</li>
<li>Follower: 初始启动状态，接收日志同步请求并响应</li>
</ul>
<h4 id="三种远程过程调用-RPC"><a href="#三种远程过程调用-RPC" class="headerlink" title="三种远程过程调用(RPC):"></a>三种远程过程调用(RPC):</h4><ul>
<li>RequestVote RPC : 用于Candidate收集选票</li>
<li>AppendEntries RPC: Leader日志复制或发送心跳(不含日志项)</li>
<li>InstallSnapshot RPC: Leader通过此RPC发送快照给Follower</li>
</ul>
<h2 id="Leader-election"><a href="#Leader-election" class="headerlink" title="Leader election"></a>Leader election</h2><p>在raft协议中，一个节点任意时刻都处于以下三个状态之一：</p>
<ul>
<li>Leader</li>
<li>Follower</li>
<li>Candidate</li>
</ul>
<p>给出状态转移图能很直观的知道这三个状态的区别：</p>
<p><img src="/2022/06/10/Raft/5.png"></p>
<p>什么时候会发起选举？</p>
<ul>
<li><p>首先，所有节点启动时都是follower状态</p>
</li>
<li><p>如果在一段时间内如果没有收到来自leader的心跳，此时leader可能出错/挂了，此时节点从follower切换到candidate，发起选举</p>
</li>
<li><p>如果收到大多数节点的票（含自己的一票），节点会切换到leader状态</p>
</li>
<li>如果节点发现有一个节点比自己先更新，则主动从candidate  切换到follower。如果上一个Leader收到下一个任期的Leader发送的消息，也会从leader切换到follower</li>
</ul>
<p>总之，系统中最多只有一个leader，如果在一段时间里发现没有leader，则大家通过选举-投票选出leader。leader会不停的给follower发心跳消息，表明自己的存活状态。如果leader故障，那么follower会转换成candidate，重新选出leader。</p>
<h3 id="选举过程"><a href="#选举过程" class="headerlink" title="选举过程"></a>选举过程</h3><p>一个Follower在<strong>随机的</strong>选举超时时间内(election timeout)内没有收到来自Leader的心跳（也许此时还没有选出leader，大家都在等；也许leader挂了；也许只是leader与该follower之间网络故障），就会发起选举，选出新Leader</p>
<p>步骤如下：</p>
<ul>
<li>增加节点本地的 <em>current term</em> ，切换到candidate状态</li>
<li>投自己一票</li>
<li>并行给其他节点发送 <em>RequestVote RPCs</em></li>
<li><p>等待其他节点的回复</p>
<p>在这个过程中，根据来自其他节点的消息，可能出现三种结果</p>
</li>
</ul>
<h4 id="结果1"><a href="#结果1" class="headerlink" title="结果1"></a>结果1</h4><ol>
<li>收到majority的投票（含自己的一票），则赢得选举，成为leader</li>
</ol>
<blockquote>
<p> 第一种情况，赢得了选举之后，新的leader会立刻给所有节点发消息，广而告之，避免其余节点触发新的选举。在这里，先回到投票者的视角，投票者如何决定是否给一个选举请求投票呢，有以下约束：</p>
<ul>
<li>在任一任期内，单个节点最多只能投一票</li>
<li>候选人知道的信息不能比自己的少（这一部分，后面介绍log replication和safety的时候会详细介绍）</li>
<li>first-come-first-served 先来先得</li>
</ul>
</blockquote>
<h4 id="结果2"><a href="#结果2" class="headerlink" title="结果2"></a>结果2</h4><ol>
<li>被告知别人已当选，那么自行切换到follower</li>
</ol>
<blockquote>
<p>第二种情况，比如有三个节点A B C。A B同时发起选举，而A的选举消息先到达C，C给A投了一票，当B的消息到达C时，已经不能满足上面提到的第一个约束，即C不会给B投票，而A和B显然都不会给对方投票。A胜出之后，会给B,C发心跳消息，节点B发现节点A的term不低于自己的term，知道有已经有Leader了，于是转换成follower。</p>
</blockquote>
<h5 id="例子-初始状态"><a href="#例子-初始状态" class="headerlink" title="例子-初始状态"></a>例子-初始状态</h5><p>正如下面这个gif所展示的。</p>
<ul>
<li>一开始处于橘黄色阶段，大家都是Follower</li>
<li>S4和S5的等待时间相继结束，S4快一点，S5结束的时候因为没有收到来自S4发送的选举消息，还以为没人发起选举，于是也开始发送。</li>
<li>S4和S5首先把第一票都投给自己了，然后向其他节点发送选举信息，其他节点收到信息后会给发送者投票。每个节点只能投一票，先到先得。投票显示为<code>+</code>号，如果已经投给别人了，再收到选举信息，则会返回<code>-</code>号<ul>
<li>我们看到：S1先收到S4的选举信息，然后收到S5的选举信息，因此给S4返回+，给S5返回-</li>
<li>S2先收到来自S5的选举信息，然后收到S4的选举信息，因此给S5返回+，给S4返回-</li>
<li>S3先收到来自S4的消息，然后收到来自S5的消息，因此给S4返回+，给S5返回-</li>
<li>S4、S5收到来自对方的消息后，由于已经把票给了自己，所以都回给对方 -</li>
<li>最终，S4收到了S4、S1、S3的票, 是大多数，由此称为Leader</li>
</ul>
</li>
</ul>
<p><img src="/2022/06/10/Raft/1.gif"></p>
<h4 id="结果3"><a href="#结果3" class="headerlink" title="结果3"></a>结果3</h4><ol>
<li>一段时间内没有收到majority投票，则保持candidate状态，重新发出选举</li>
</ol>
<h5 id="例子-server挂了"><a href="#例子-server挂了" class="headerlink" title="例子-server挂了"></a>例子-server挂了</h5><p>如下图所示，在第二个任期中，S2是Leader，然后我们手动让S2挂机</p>
<p><img src="/2022/06/10/Raft/12.gif"></p>
<blockquote>
<ul>
<li>此时只剩下四个节点了，S1和S3因为收不到来自Leader的心跳，term结束后便发起了投票。</li>
<li>由于只剩下4个节点，S1和S3由于发送的消息过于同步，导致每个节点都获得了两票，由此在term3中无法选出leader</li>
<li>因此某个节点term3结束后，会立即进入term4，并向外发送选举信号，开启新一轮选举。</li>
</ul>
<p>因此raft引入了randomized election timeouts来尽量避免平票情况。同时，leader-based 共识算法中，节点的数目都是奇数个，尽量保证majority的出现。</p>
</blockquote>
<h4 id="重要保证"><a href="#重要保证" class="headerlink" title="重要保证"></a>重要保证</h4><ul>
<li>随机的选举超时时间(150-300ms) ，减少3.3中瓜分选票的情况</li>
<li>每个人起内最多一个Leader，任何节点收到之前任期的消息都不会影响现在的状态</li>
<li>选票先到先得，只要请求消息满足要求(任期+日志)则投票</li>
<li>大多数选票原则，这也要求每个节点在每个任期内有且只有一张选票</li>
</ul>
<h2 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h2><p>当有了leader，系统应该进入对外工作期了。客户端的一切请求来发送到leader，leader来调度这些并发请求的顺序，并且保证leader与followers状态的一致性。raft中的做法是，将这些请求以及执行顺序告知followers。leader和followers以相同的顺序来执行这些请求，保证状态一致。</p>
<h3 id="日志复制-1"><a href="#日志复制-1" class="headerlink" title="日志复制"></a>日志复制</h3><p>每个节点上的日志复制流程有是怎么样的呢？</p>
<ul>
<li>复制： 某个日志把写入到Follower的日志中</li>
<li>提交：如果当前任期内的日志项被多数节点写入，则可以变为提交状态。此状态下日志项不再被修改</li>
<li>应用： 将已经提交的日志项应用到状态机，会真正影响节点状态</li>
</ul>
<p><img src="/2022/06/10/Raft/9.png"></p>
<p>不难看到，logs由顺序编号的log entry组成 ，每个log entry除了包含command，还包含产生该log entry时的leader term。从上图可以看到，五个节点的日志并不完全一致，raft算法为了保证高可用，并不是强一致性，而是最终一致性，leader会不断尝试给follower发log entries，直到所有节点的log entries都相同。</p>
<h3 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h3><p>当系统（leader）收到一个来自客户端的写请求，到返回给客户端，整个过程从leader的视角来看会经历以下步骤</p>
<ol>
<li>客户端将包含一条指令的请求发送到Leader上</li>
<li>Leader把这条指令作为日志项附加到本地的日志中，并发送AppendEntriesRPC给其他服务器，复制日志项</li>
<li>Follower返回复制结果给Leader</li>
<li>当Leader认为这个日志项已经被多数节点复制，那么在提交此日志项并将这条日志项应用到状态机后，会返回给客户端</li>
</ol>
<p>可以看到日志的提交过程有点类似两阶段提交(2PC)，不过与2PC的区别在于，<strong>leader只需要大多数（majority）节点的回复即可</strong>，这样只要超过一半节点处于工作状态则系统就是可用的。一旦向客户端返回成功消息，那么系统就必须保证log（其实是log所包含的command）<strong>在任何异常的情况下都不会发生回滚</strong>。 </p>
<p>示意图如下：</p>
<p><img src="/2022/06/10/Raft/12.png"></p>
<h5 id="例子-复制"><a href="#例子-复制" class="headerlink" title="例子-复制"></a>例子-复制</h5><ol>
<li>首先，我在S2节点发起request(只能对leader发起request)。这时候Leader会把这条指令附加到本地的日志中，但并未提交(虚线框)</li>
<li>然后，S2向其他节点发送者条日志，其他节点收到之后，都把这条日志加到本中，但是没有提交(虚线框)</li>
<li>Follower把成功复制的结果返回给Leader，Leader收到了4票，认为这个日志项已经被多数节点复制</li>
<li>Leader把这项日志应用到状态机(变成实线框)，并将结果返回给客户端。</li>
<li>Leader给Folloer发信息，意思是说我已经提交成功并应用了，你们也可以提交了，因此Folloer也相继提交并应用了</li>
</ol>
<p><img src="/2022/06/10/Raft/3.gif"></p>
<h3 id="日志复制的保证"><a href="#日志复制的保证" class="headerlink" title="日志复制的保证"></a>日志复制的保证</h3><ul>
<li>如果不同日志中的两个条目有着相同的索引和任期号，则它们所存储的命令是相同的</li>
<li>如果不同日志中的两个条目有着相同的索引和任期号，则它们之前所有条目都是完全一样的。<ul>
<li>在复制日志项的时候，会携带上一个日志项的index和term序号，如果不匹配，会一直查找，直到匹配了才把日志复制过来</li>
</ul>
</li>
</ul>
<h4 id="可能出现不一致的场景"><a href="#可能出现不一致的场景" class="headerlink" title="可能出现不一致的场景"></a>可能出现不一致的场景</h4><p>我们举几个例子，下图 a-f是follower可能出现的场景(不是说有6个follower)</p>
<p><img src="/2022/06/10/Raft/11.png"></p>
<h5 id="日志项缺失"><a href="#日志项缺失" class="headerlink" title="日志项缺失"></a><strong>日志项缺失</strong></h5><ul>
<li><p>a在收到(6,9)之后宕机 , 示意图如下图所示(不是完全匹配)</p>
<p><img src="/2022/06/10/Raft/4.gif"></p>
</li>
<li><p>b在收到(4,4)之后宕机，后面几个term一直没有恢复</p>
</li>
</ul>
<h5 id="日志项多余"><a href="#日志项多余" class="headerlink" title="日志项多余"></a><strong>日志项多余</strong></h5><ul>
<li><p>c作为follower收到了来自leader的(6,11)日志之后，Leader宕机，而此时其他节点可能还没收到</p>
</li>
<li><p>d可能本来就是Leader，接收了来自客户端的两次请求之后，还没把信息传递出去，就宕机了，再次选举得到的新Leader已经不是它了，因此不会有Term7的信息</p>
</li>
</ul>
<p>示意图如下:</p>
<p><img src="/2022/06/10/Raft/6.gif"></p>
<h5 id="日志项不匹配"><a href="#日志项不匹配" class="headerlink" title="日志项不匹配"></a><strong>日志项不匹配</strong></h5><ul>
<li>e收到(4,6)(4,7)之后宕机，示意图如下所示：<ul>
<li><img src="/2022/06/10/Raft/5.gif"></li>
</ul>
</li>
</ul>
<ul>
<li>F多收到任期2,3的日志项，但是都没有提交成功。这时候f宕机，系统选取了新的leader，开启term4。由于之前term2、3没有提交成功，导致该term的日志没有写入多数节点，导致term4的leader没有term2、3的日志项</li>
</ul>
<p>那么如果出现了不一致的情况，此时Leader首先会进行要如何解决？首先要知道的一个原则：<strong>Leader不会覆盖或者删除自己的日志</strong></p>
<ul>
<li><strong>日志项缺失</strong><ul>
<li>Leader会从最新的日志开始发起，因为每条日志都会保留上一条日志的index和term序号，因此可以和上一条做比较。如果Folloer没有找到对应的日志项，就会拒绝。</li>
<li>Leader发现拒绝接受的消息，就会向前逐个排查，直到Follower最终找到与Leader对应的相同位置，</li>
<li>然后，Leader把条该日志之后的所有日志全部发送给follow，让其同步，覆盖掉不匹配的日志项</li>
</ul>
</li>
<li><strong>日志项多余</strong> <ul>
<li>Leader发现follower的日志项比自己多，会发送信息给follower让他同步我自己的日志项。这是一个强制性的同步，既然选择了leader，就一定要让folloer和leader一致</li>
</ul>
</li>
<li>日志项不匹配的操作逻辑和日志项缺失一样</li>
</ul>
<p>可能有人说一个一个找会比较麻烦，那么可以进行一些优化，比如三个三个找，或者按照任期向前搜索</p>
<p>最终的结果是日志必须按照顺序记录的如下图：</p>
<p><img src="/2022/06/10/Raft/9.png" style="zoom:50%;"></p>
<h2 id="Safety"><a href="#Safety" class="headerlink" title="Safety"></a>Safety</h2><p>在上面提到只要日志被复制到majority节点，就能保证不会被回滚，即使在各种异常情况下，这根leader election提到的选举约束有关。在这一部分，主要讨论raft协议在各种各样的异常情况下如何工作的。</p>
<p>衡量一个分布式算法，有许多属性，如</p>
<ul>
<li>safety：nothing bad happens,</li>
<li>liveness： something good eventually happens.</li>
</ul>
<p>任何系统模型下，都需要满足safety属性，即在任何情况下，系统都不能出现不可逆的错误，也不能向客户端返回错误的内容。比如，raft保证被复制到大多数节点的日志不会被回滚，那么就是safety属性。而raft最终会让所有节点状态一致，这属于liveness属性。</p>
<p>raft协议 会保证以下属性</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>性质</th>
<th>描述</th>
<th>问题</th>
<th>解决</th>
</tr>
</thead>
<tbody>
<tr>
<td>选举安全原则(Election Safty)</td>
<td>一个任期内最多允许一个Leader</td>
<td>Split Vote</td>
<td>随机选举时间，多次选举</td>
</tr>
<tr>
<td>Leader只追加原则(Leader Apeend-Only)</td>
<td>Leader永远不会覆盖或者删除自己的日志，它只会增加日志项</td>
<td>日志不一致</td>
<td>强制Follower与其一致</td>
</tr>
<tr>
<td>日志匹配原则(Log Match)</td>
<td>如果两个日志在相同的索引位置上的日志项的任期号相同，那么就认为这个日志项索引位置之前的日志也完全相同</td>
<td>日志不一致</td>
<td>日志复制，一致性检验</td>
</tr>
<tr>
<td>Leader完全原则(Leader Completeness)</td>
<td>如果一个日志项在一个给定任期内被提交，那么这个日志项一定会出现在所有任期号更大的Leader中</td>
<td>无法判断某个entry是否被提交</td>
<td>选举限制+推迟提交</td>
</tr>
<tr>
<td>状态机安全原则(State Machine Safety)</td>
<td>如果一个节点已经将给定索引位置的日志项应用到状态机中，则所有其他节点不会再该索引位置应用不同的日志项</td>
<td>反证法</td>
<td>反证法</td>
</tr>
</tbody>
</table>
</div>
<p>前三点我在<a href="#重要保证">Leader election</a>和<a href="#日志复制的保证">日志复制的保证</a> 章节都已经谈到了,因此着重来说说后面：</p>
<h3 id="leader-completeness-vs-elcetion-restriction"><a href="#leader-completeness-vs-elcetion-restriction" class="headerlink" title="leader completeness vs elcetion restriction"></a>leader completeness vs elcetion restriction</h3><p>Leader完全原则是说：如果一个日志项在一个给定任期内被提交，那么这个日志项一定会出现在所有任期号更大的Leader中 。</p>
<p>要满足这个原则，就要在选举的时候加入一些判断——如何保证日志项一定会出现在任期更大的Leader当中呢？</p>
<h4 id="选举时判断最新的日志项"><a href="#选举时判断最新的日志项" class="headerlink" title="选举时判断最新的日志项"></a>选举时判断最新的日志项</h4><p><img src="/2022/06/10/Raft/14.png"></p>
<p>如上面这个情况：</p>
<ol>
<li>S3、S4处于宕机状态，不去考虑</li>
<li>S1、S2、S5 由于没有Leader，因此投票选举，此时S1正处于Candidate状态。</li>
<li>但是，我们看到S2和S5并没有投票给S1，这是因为S2、S5比S1多了一个Term6日志项 。因为对于S2、S5来说，Term6的日志并没有在本地提交，但是它并不知道Term6的Leader是否已经提交了这个日志。因为从复制过程我们也可以看出，Leader提交日志的时候，实际上Follower是还没有提交的。S2、S5看到S1的日志项并不是最新的，因此会拒绝投票</li>
</ol>
<p><img src="/2022/06/10/Raft/14.gif"></p>
<p>破解这个问题，就会使用到随机选举时间，下次可能是S2、S5发起选举，从而避免选举失败的问题</p>
<h3 id="可能触发安全性隐患的问题"><a href="#可能触发安全性隐患的问题" class="headerlink" title="可能触发安全性隐患的问题"></a>可能触发安全性隐患的问题</h3><h4 id="宕机异常"><a href="#宕机异常" class="headerlink" title="宕机异常"></a>宕机异常</h4><ul>
<li>Leader 宕机： 其余节点超时后重新选举，选出新的Leader。当此节点重新进入集群之后，接收心跳信息</li>
<li>Candidate/Follower 宕机：集群没有出现故障问题，重启后恢复为Follower节点加入集群</li>
</ul>
<h4 id="网络分区"><a href="#网络分区" class="headerlink" title="网络分区"></a>网络分区</h4><p>问题：某一节点再次加入集群之后，增大的任期会打断当前系统的执行</p>
<p>解决方法：Pre-Vote方案就像是一次Leader选举，不过不改变节点状态。如果能够获取多数选票，则可以发起新一轮选举。如下图所示：</p>
<p><img src="/2022/06/10/Raft/15.png"></p>
<ul>
<li>当前集群中，可能网络突然出现了问题，五个节点变分为了两组：AB可以互相通信、CDE可以相互通信，但是他们之间没有办法相互通信</li>
<li>因此，对A、B来说，A本来就是Leader，状态不会发生改变，B会收到来自Leader的信号，也不会发起选举；C D E收不到来自Leader的信息，因此发起选举，选出了他们的Leader C</li>
<li>对于C来说，它可以达到多数派要求(多余一半的节点会投票给它)，它会为C、D、E这组节点提供服务。但是对于旧的Leader A,它不能得到多数票，因为联系不到其他节点，而且也不知道当前实际上有一个新的Leader可以提供服务。</li>
</ul>
<p>在这种情况下，如果网络被修复之后，旧的Leader A 会接收到来自Leader C发送的消息，从中发现对方的Term 比自己的更大，因此从Leader转换为Follower</p>
<p>还有一种网络分区导致的情况：</p>
<p><img src="/2022/06/10/Raft/16.png"></p>
<ul>
<li>网络突然出现了问题，C、D被隔开，A虽然找不到CD，但是仍能获得多数选票，为A、B、E提供服务</li>
<li>C、D由于没办法取得Leader心跳，因此转变为Candidate发送选举请求，但是都无法获得多数选票，因此始终在选举当中，term号一直在增加</li>
<li><p>因此当网络分区消失之后，C、D重新加入集群，此时A就会发现：自己Term号要远远小于C的Term号，按照道理自己必须变成Follower，把Leader位置禅让给C。但是C又没有A、B、E在网络分区时间段记录下的日志。此时C、D的加入就会打断当前系统的执行。</p>
</li>
<li><p>由于C和D的日志项是落后于A、B、E的，所以它发送的消息，别人都是不认可的，因此最终A、B、E中的某个节点会发起选举，抢夺C的Leader。</p>
</li>
</ul>
<p>为了解决这个问题，有 Pre-Vote 的解决方案。对于C和D节点来说，在网络分区结束之后加入集群，会进行一轮预投票，这个阶段与Leader选举类似，但是不会改变节点的状态。如果在这轮预投票中可以获得多数票，那么就可以增加任期，发起新一轮选举。而显然，C和D并不会在这轮选举中获取大多数票</p>
<h2 id="线性一致性"><a href="#线性一致性" class="headerlink" title="线性一致性"></a>线性一致性</h2><ul>
<li>定义：数据像只有一个副本一样，在各节点上写生效顺序相同，写写全局的先后一致，能读到最新的写</li>
</ul>
<p>而Raft并不等于线性一致，但可以基于Raft实现线性一致性。但这是较弱的一致性，在上面我们也说到了，在网络分区的时候，有可能读取到旧的数据</p>
<p><img src="/2022/06/10/Raft/17.png"></p>
<p>我们看到，从用户看到的情况看：</p>
<p>S1节点先写入<code>W(x=1)</code>; S2节点再写入<code>W(x=2)</code>, 但是读取的时候，先读取得到<code>R(x=2)</code>,再读取<code>R(x=1)</code>。可能认为出现了线性不一致。</p>
<p>其实这是被允许的，只要能在时间轴上，每一个事务(读、写)都能抽象成一个点，就可以满足若线性一致性了</p>
<h3 id="强一致性"><a href="#强一致性" class="headerlink" title="强一致性"></a>强一致性</h3><p>实现强一致性的三种读方法</p>
<h4 id="Read-Log"><a href="#Read-Log" class="headerlink" title="Read Log"></a>Read Log</h4><p>这种方式，读写都会经过Leader，通过日志应用到复制状态机以获得正确的结果</p>
<ul>
<li>优点： 读写操作采用相同 的处理方法，容易实现线性一致性</li>
<li>缺点：读操作不改变状态机的状态，但还要写日志，开销大</li>
</ul>
<p><img src="/2022/06/10/Raft/18.png"></p>
<h4 id="Read-Index"><a href="#Read-Index" class="headerlink" title="Read Index"></a>Read Index</h4><p>读操作不经过复制状态机，通过索引判断当前最新日志项写入位置。为了防止从旧Leader获取信息，因此需要一轮心跳来确认当前的Leader。</p>
<p>当Leader接收到读请求的时候，需要通过一轮心跳来确保当前自己仍然是Leader，并记录当前的Commit index为Read index，然后等到apply &gt;= read index 再提供读服务</p>
<p>如果客户端是从Follower处读取x的值，那么Follower会去Leader问询，Leader会执行上述操作并返回值。相比直接询问Leader多了一次访问开销</p>
<p>优点： 省掉了同步日志的开销，能够大幅提升读的吞吐量，并且在一定程度上降低了读的时延</p>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>CDE一开始出现了网络分区，因此独立出来，选择了C作为Leader。然后，有一个客户端在新Leader这边发起了 <code>W(x=1)</code>的请求，由于得到大多数节点支持，该操作可以顺利通过。</p>
<p>此时，如果有客户端向老的Leader A发送读取请求——如果有了Read Index机制，Leader A会发送一轮消息，来确认自己是否仍然是Leader，现实是他并不是，因此客户端无法从A节点读取x的值。</p>
<p><img src="/2022/06/10/Raft/19.png"></p>
<h5 id="Lease-Read"><a href="#Lease-Read" class="headerlink" title="Lease Read"></a>Lease Read</h5><p>前提：已经确定了当前的Leader就是全局唯一的Leader,  要实现这个方法可以规定一段时间内，保证各节点不会发生选举</p>
<p>那么，当Leader接收到读请求的时候，由于可以保证Leader是唯一Leader， <code>apply &gt;= read index</code> ，可以直接提供读服务。</p>
<ul>
<li>优点： 与Read Index相比，Lease Read 进一步省去了网络交互开销，因此更能显著降低读的时延</li>
<li>缺点：由于使用的是每个服务器各自的时钟，存在着时钟飘逸现象(比如，A节点1秒等于B节点2秒)，那么如果误差过大可能线性化的保证就丢失了</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/4/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/%5Bobject%20Object%5D"
                alt="Jason" />
            
              <p class="site-author-name" itemprop="name">Jason</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20fa%20fa-archive">
              
                  <span class="site-state-item-count">435</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">61</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="true"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
 <!--
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>







-->
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>




















  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v="></script>

  <script type="text/javascript" src="/js/src/motion.js?v="></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v="></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
