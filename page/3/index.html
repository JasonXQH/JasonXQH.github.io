<!DOCTYPE html>
<html lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jasonxqh.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jason‘s Blog">
<meta property="og:url" content="https://jasonxqh.github.io/page/3/index.html">
<meta property="og:site_name" content="Jason‘s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jasonxqh.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jason‘s Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jason‘s Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2023/04/16/ubuntu-samba%E9%83%A8%E7%BD%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/16/ubuntu-samba%E9%83%A8%E7%BD%B2/" class="post-title-link" itemprop="url">ubuntu_samba部署</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-04-16 15:27:11 / Modified: 15:45:21" itemprop="dateCreated datePublished" datetime="2023-04-16T15:27:11+08:00">2023-04-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>由于之前装过samba但是被我稀里糊涂一顿操作给卸载了，显然也没有卸干净，于是打算重装一下。把能踩的坑基本都踩了。</p>
<p>首先我由于之前手动删除了 <code>/etc/samba</code>文件夹，导致重新下载以后这个文件夹不会自动生成。因此我需要删除samba所依赖的所有相关包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove samba*</span><br></pre></td></tr></table></figure>
<p>重新安装后还是会出现错误：<code>dpkg：处理 samba-common (--configure)时出错：</code></p>
<p>因此要这样操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo&#96; &#96;mv&#96; &#96;&#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;info&#96; &#96;&#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;info_old</span><br><span class="line">sudo&#96; &#96;mkdir&#96; &#96;&#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;info</span><br><span class="line">sudo&#96; &#96;apt-get update, apt-get -f &#96;&#96;install</span><br><span class="line">sudo&#96; &#96;mv&#96; &#96;&#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;info&#x2F;&#96;&#96;* &#96;&#96;&#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;info_old</span><br><span class="line">sudo&#96; &#96;rm&#96; &#96;-rf &#96;&#96;&#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;info</span><br><span class="line">sudo&#96; &#96;mv&#96; &#96;&#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;info_old&#96; &#96;&#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;info</span><br></pre></td></tr></table></figure>
<p>然后就有<code>/etc/samba</code> 文件夹，但是smb.conf文件仍然需要自己配置：<br>其中，[share] 是自定义的，里面的path指向我需要共享的文件夹。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># Global parameters</span><br><span class="line">[global]</span><br><span class="line">        log file &#x3D; &#x2F;var&#x2F;log&#x2F;samba&#x2F;log.%m</span><br><span class="line">        logging &#x3D; file</span><br><span class="line">        map to guest &#x3D; Bad User</span><br><span class="line">        max log size &#x3D; 1000</span><br><span class="line">        obey pam restrictions &#x3D; Yes</span><br><span class="line">        pam password change &#x3D; Yes</span><br><span class="line">        panic action &#x3D; &#x2F;usr&#x2F;share&#x2F;samba&#x2F;panic-action %d</span><br><span class="line">        passwd chat &#x3D; *Enter\snew\s*\spassword:* %n\n *Retype\snew\s*\spassword:* %n\n *password\supdated\ssuccessfully* .</span><br><span class="line">        passwd program &#x3D; &#x2F;usr&#x2F;bin&#x2F;passwd %u</span><br><span class="line">        server role &#x3D; standalone server</span><br><span class="line">        server string &#x3D; %h server (Samba, Ubuntu)</span><br><span class="line">        unix password sync &#x3D; Yes</span><br><span class="line">        usershare allow guests &#x3D; Yes</span><br><span class="line">        idmap config * : backend &#x3D; tdb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[printers]</span><br><span class="line">        browseable &#x3D; No</span><br><span class="line">        comment &#x3D; All Printers</span><br><span class="line">        create mask &#x3D; 0700</span><br><span class="line">        path &#x3D; &#x2F;var&#x2F;spool&#x2F;samba</span><br><span class="line">        printable &#x3D; Yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[print$]</span><br><span class="line">        comment &#x3D; Printer Drivers</span><br><span class="line">        path &#x3D; &#x2F;var&#x2F;lib&#x2F;samba&#x2F;printers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[share]</span><br><span class="line">        comment &#x3D; this is Linux share directory</span><br><span class="line">        guest ok &#x3D; Yes</span><br><span class="line">        path &#x3D; &#x2F;home&#x2F;jason&#x2F;sharefile</span><br></pre></td></tr></table></figure>
<p>然后，要运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smbpasswd -a root</span><br></pre></td></tr></table></figure>
<p>来设置root用户，否则samba无法启动</p>
<p>设置完以后，我尝试启动samba服务：<code>sudo system restart smbd.service</code> ，结果失败：<code>Failed to restart smbd.service: Unit smbd.service is masked</code></p>
<p>需要如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl unmask smbd.service</span><br><span class="line">sudo systemctl enable smbd.service</span><br><span class="line">sudo systemctl restart smbd.service</span><br></pre></td></tr></table></figure>
<p>成功启动samba服务</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2023/01/16/FISCO-BCOS%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/16/FISCO-BCOS%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">FISCO-BCOS学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-01-16 11:53:40" itemprop="dateCreated datePublished" datetime="2023-01-16T11:53:40+08:00">2023-01-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-30 16:58:43" itemprop="dateModified" datetime="2023-01-30T16:58:43+08:00">2023-01-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="FISCO-BCOS核心模块"><a href="#FISCO-BCOS核心模块" class="headerlink" title="FISCO-BCOS核心模块"></a>FISCO-BCOS核心模块</h1><h2 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h2><p>FISCO BCOS基于多群组架构实现了插件化的共识算法，不同群组可运行不同的共识算法，组与组之间的共识过程互不影响，FISCO BCOS目前支持PBFT(Practical Byzantine Fault Tolerance)和Raft(Replication and Fault Tolerant)两种共识算法。共识模块框架如下图：</p>
<p><img src="/2023/01/16/FISCO-BCOS%E5%AD%A6%E4%B9%A0/1.png" style="zoom:67%;"></p>
<p><strong>Sealer线程</strong></p>
<p>交易打包线程，负责从交易池取交易，并基于节点最高块打包交易，产生新区块，产生的新区块交给Engine线程处理，PBFT和Raft的交易打包线程分别为PBFTSealer和RaftSealer。</p>
<p><strong>Engine线程</strong></p>
<p>共识线程，负责从本地或通过网络接收新区块，并根据接收的共识消息包完成共识流程，最终将达成共识的新区块写入区块链(BlockChain)，区块上链后，从交易池中删除已经上链的交易，PBFT和Raft的共识线程分别为PBFTEngine和RaftEngine。</p>
<h3 id="PBFT基础流程"><a href="#PBFT基础流程" class="headerlink" title="PBFT基础流程"></a>PBFT基础流程</h3><p>详见<a href="https://jasonxqh.github.io/2022/06/05/区块链-共识算法/#PBFT算法">PBFT算法</a></p>
<h3 id="PBFT网络优化"><a href="#PBFT网络优化" class="headerlink" title="PBFT网络优化"></a>PBFT网络优化</h3><p>FISCO BCOS  v2.2.0优化了PBFT消息转发机制和Prepare包的结构，尽量减少网络中冗余的数据包，提升网络效率</p>
<p>之前，在共识节点</p>
<p><img src="/2023/01/16/FISCO-BCOS%E5%AD%A6%E4%B9%A0/2.png" style="zoom:67%;"></p>
<h2 id="交易并行"><a href="#交易并行" class="headerlink" title="交易并行"></a>交易并行</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2023/01/15/fabric%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/15/fabric%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">fabric学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-01-15 17:50:52" itemprop="dateCreated datePublished" datetime="2023-01-15T17:50:52+08:00">2023-01-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-03 14:56:32" itemprop="dateModified" datetime="2023-01-03T14:56:32+08:00">2023-01-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>                                                            </p>
<h1 id="Fabric-学习"><a href="#Fabric-学习" class="headerlink" title="Fabric 学习"></a>Fabric 学习</h1><h2 id="Fabric简介"><a href="#Fabric简介" class="headerlink" title="Fabric简介"></a>Fabric简介</h2><p>Hyperledger Fabric 项目是一个旨在推动区块链跨行业应用的开源项目。它是一个联盟链系统，和我们之前学的以太坊和 比特币不同。</p>
<p>Fabric是企业级开源的并且基于<strong>许可模式</strong>的分布式账本平台。它专门为企业级应用环境设计，实现了一个高度模块化和可配置的体系结构。在联盟链场景下，有一定的<strong>信任基础</strong>和<strong>行政约束力</strong>，因此，在Fabric中没有币和账户钱包的概念, 也不需要激励机制。</p>
<p>允许不同行业基于不同的行业用例对Fabric进行扩展、创新、优化，建立不同的行业应用模块和平台</p>
<h3 id="框架图"><a href="#框架图" class="headerlink" title="框架图"></a>框架图</h3><p><img src="/2023/01/15/fabric%E5%AD%A6%E4%B9%A0/1.png" style="zoom:67%;"></p>
<p>现在来看一下fabric的架构，fabric和以太坊一样，都是一个区块链2.0的平台，支持可编程</p>
<ul>
<li><p>底层</p>
<ul>
<li>fabric的底层也是p2p网络，通过gRPC的通道进行交互，利用Gossip协议进行区块链同步(节点少的话可以使用tcp进行连接)</li>
</ul>
</li>
<li><p>第二层</p>
<ul>
<li><p>fabric和以太坊一样，拥有属于自己的状态数据库，拥有自己的共识机制</p>
</li>
<li><p>fabric的智能合约被称为链码</p>
</li>
<li><p>fabric没有像以太坊那样的EVM，它是运行在Docker中的容器里的</p>
</li>
<li><p>由于fabric是联盟链，具有准入机制，因此还有以太坊中没有的两个模块：成员服务提供者MSP和区块链加密服务提供者BCCSP。</p>
<ul>
<li>成员服务提供者则是Fabric的安全认证体系，包括用户管理、权限管理、证书管理等；</li>
<li>区块链加密服务提供者是Fabric以可插拔的方式提供的加解密算法等；</li>
</ul>
</li>
</ul>
</li>
<li><p>第三层</p>
<ul>
<li>fabric是以交易、事件的方式来驱动的。应用通过交易向账本记录数据，改变状态，交易的执行逻辑则由链码来完成。企业应用依据Fabric区块链中的事件触发企业应用中的后续处理流程，从而完成基于事件驱动的异步模型。</li>
</ul>
</li>
<li>顶层<ul>
<li>软件开发工具、接口和命令行界面。 Fabric对外提供了基于gRPC的API以及封装API的相应语言的SDK，操作员也可以通过命令行（CLI）直接执行Fabric支持的命令。企业应用通过SDK或API接口访问Fabric区块链网络的多种资源，包括账本、交易、链码并可进行权限管理。</li>
</ul>
</li>
</ul>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><h4 id="模块化框架"><a href="#模块化框架" class="headerlink" title="模块化框架"></a>模块化框架</h4><p>Fabric的核心模块具有高度模块化，都可通过更改配置文件来加载不同的模块实现。比如说：</p>
<ul>
<li>可插拔的共识模块<ul>
<li>可以用国密算法，也可以用SHA来加密。</li>
<li>目前Fabric1.3版本已经实现了solo模式、Kafka模式</li>
</ul>
</li>
<li>可随意安装部署的智能合约<ul>
<li>Fabric中的智能合约称之为链码，链码可以动态安装与升级，从而拓展平台的业务逻辑</li>
</ul>
</li>
<li>可插拔的背书和验证系统链码<ul>
<li>可以给每个通道的每个链码指定不同的背书和验证系统链码，从而完成个性化的验证要求</li>
</ul>
</li>
<li>可选的对等网络gossip服务<ul>
<li>传播来自共识服务所形成的区块</li>
</ul>
</li>
<li>不同形式的账本结构<ul>
<li>Fabric的账本状态数据可以使用不同的数据库管理系统</li>
<li>默认数据库是LevelDB，也可以配置成第三方数据库，如CouchDB。</li>
</ul>
</li>
<li>可插拔的成员服务提供者<ul>
<li>主要负责将网络中的某个实体（节点、组织、成员）和一个加密身份相关联，对实体身份进行认证，是权限管理的基础</li>
</ul>
</li>
</ul>
<h4 id="基于许可的区块链"><a href="#基于许可的区块链" class="headerlink" title="基于许可的区块链"></a>基于许可的区块链</h4><p>这个特性是说，fabric的参与者需要经过认证、审查才能参与到区块链交易中。参与者在一种具有一定程度信任的治理模式下相互协作</p>
<p>由于有信任的存在，可以使用更传统的崩溃容错(CFT)的共识协议，从而避免昂贵的POW等共识协议(因此fabric没有挖矿)</p>
<p>fabric中的许可方法如下：</p>
<ul>
<li>颁发交易参与方、节点等实体的身份证书和用户的身份证书</li>
<li>交易经过签名、背书，证明了其合法性。</li>
</ul>
<h4 id="新的交易模型"><a href="#新的交易模型" class="headerlink" title="新的交易模型"></a>新的交易模型</h4><p>fabric中有区别于传统区块链的交易模型。传统区块链是<strong>先共识再运行</strong>，而fabric是<strong>运行再共识</strong></p>
<h4 id="传统模型"><a href="#传统模型" class="headerlink" title="传统模型"></a>传统模型</h4><p>在P2P网络中，每一个节点都需要进行交易，那么这时候需要确立一个顺序。这时就需要矿工来确认这些交易的执行顺序。</p>
<p>传统区块链的运行步骤是：先通过共识协议对一组交易形成共识区块，再在每个节点中顺序运行共识区块中的交易。因此传统区块链有如下缺陷：</p>
<ul>
<li>所有节点顺序执行交易，导致性能和规模受限</li>
<li>智能合约要在系统中每个节点执行，要求系统采取复杂措施来保护整个系统免受恶意合同的影响，从而限制了系统弹性</li>
<li>如智能合约存储于账本中，限制了智能合约的规模。</li>
</ul>
<h4 id="Fabric中的新模型"><a href="#Fabric中的新模型" class="headerlink" title="Fabric中的新模型"></a>Fabric中的新模型</h4><p>但是在Fabric中，采用了<strong>运行-共识-验证 </strong>的交易执行框架。这个模式在Fabric1.0中开始实行，有客户端、背书节点和排序节点三种角色：</p>
<ul>
<li>客户端发送交易</li>
<li>背书节点执行和验证交易</li>
<li>排序节点通过共识确定一批交易的全局顺序</li>
</ul>
<p>交易运行过程分为三个步骤</p>
<ul>
<li>交易在各个channel之间并行<strong>模拟执行</strong>，但<strong>执行结果不写入</strong> 。</li>
<li>共识节点(排序节点)对多channel提交的交易进行<strong>共识排序</strong>，并打包成区块</li>
<li>各节点验证该共识顺序是否破坏模拟执行的客串行性 ,若通过，就更改本地账本状态</li>
</ul>
<p><img src="/2023/01/15/fabric%E5%AD%A6%E4%B9%A0/3.png"></p>
<p>这边来解决几个问题：</p>
<ol>
<li><p>那么fabric中有没有区块呢？ <strong>有的</strong>。在排序节点中，进行共识服务时会对排序的交易进行打包处理。</p>
</li>
<li><p>在以太坊中，为了限制某些合约无限制调用资源(比如说死循环和生成随机数)，使用了gas进行限制，那么在fabric中是否有这种策略呢？ </p>
<ul>
<li><p>对于随机数，因为fabric并不会像solitude(没有随机函数)一样对java进行限制。因此采用了曲线救国的形式：由于多个背书节点会同时执行，运行结果会有影响，因此无法保证一致性，如果背书节点的运行结果不一致，那么根本不会走到下一步(发送给排序节点)</p>
</li>
<li><p>对于死循环，可以运用超时机制，运行一段时间后没出结果的话就会停止</p>
</li>
</ul>
</li>
</ol>
<p>综上：</p>
<ul>
<li><p>运行交易的节点是智能合约要求的有限的几个节点，也就是上图channel中的背书节点。我们可以来做这样一个类比：Fabric中的节点类似于一个年级群，channel就是不同的班群，不同channel中运行的信息相互独立。而且允许一个节点参与多个channel，就好比一个辅导员管理多个班级一样</p>
</li>
<li><p>在取得共识前运行智能合约，使得账本仅需保存智能合约的运行结果而不是智能合约本身</p>
</li>
<li><p>智能合约可以以文件的形式部署在需要的节点中</p>
</li>
</ul>
<h4 id="企业级智能合约"><a href="#企业级智能合约" class="headerlink" title="企业级智能合约"></a>企业级智能合约</h4><p>智能合约在Fabric中称为链码（chaincode），是区块链应用中的业务逻辑。基于链码的背书策略是指：<strong>哪些节点以及多少节点需要保证智能合约的正确运行</strong></p>
<ul>
<li>每个交易仅需背书策略所必需的节点的子集来认可交易执行结果。</li>
<li>这使得Fabric在运行阶段能够过滤掉不一致的结果，从而消除不确定性(random函数)。</li>
</ul>
<p>因此，运行不确定性的消除使得Fabric成为第一个支持使用通用语言(如Java、Go和Node.js)开发智能合约的区块链平台</p>
<p>比如说，把Fabric运用到工业领域，可以避免仓单重复质押这类非法现象的出现，可以保证账目公开透明</p>
<h4 id="隐私和保密"><a href="#隐私和保密" class="headerlink" title="隐私和保密"></a>隐私和保密</h4><p>Fabric在数据加密、数字签名、安全网络传输的基础上，针对企业应用进行了如下设计：</p>
<ul>
<li>智能合约的保密要求 <ul>
<li>实例：合同的签署各方能够看到优惠的费率及交易的金额，业务流程是保密的</li>
<li>通过将智能合约部署在特定的背书节点，从而保证智能合约仅对特定的交易方可见，从而确保了智能合约的私密性。 [物理隔离]</li>
</ul>
</li>
<li>账本的保密要求 <ul>
<li>传统的区块链平台中，账本数据经过加密处理，但账本数据部署在所有的节点，经过足够的时间或者资源，这些数据还是能被破解，导致企业敏感数据的泄密</li>
<li>Fabric中引入通道（channel）的概念，<strong>有关交易参与方建立一个通道</strong>，账本数据仅仅保存在参与通道的相关节点中[物理隔离]</li>
</ul>
</li>
</ul>
<h2 id="Fabric核心概念"><a href="#Fabric核心概念" class="headerlink" title="Fabric核心概念"></a>Fabric核心概念</h2><h3 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h3><p>Fabric中交易是链码的一次调用，根据链码完成的业务逻辑完成不同的功能，可以实现对账本状态的改变，也可以是一次对账本数据的查询。</p>
<h4 id="部署交易"><a href="#部署交易" class="headerlink" title="部署交易"></a>部署交易</h4><p>主要完成新建链码的安装和初始化，部署交易执行成功也就意味着一个新的链码已经准备好执行对链码调用的交易</p>
<h4 id="调用交易"><a href="#调用交易" class="headerlink" title="调用交易"></a>调用交易</h4><ul>
<li>调用已部署的链码的指定的方法，返回方法的执行结果。</li>
<li>部署交易是调用交易的特例，其参数是打包的链码。</li>
<li>一个完整的交易执行过程需要经过提案、背书、共识(排序)最终提交到账本中</li>
</ul>
<h3 id="背书"><a href="#背书" class="headerlink" title="背书"></a>背书</h3><p>背书在商业上是指对某种交易行为进行担保、保证</p>
<p>Fabric借签这一流程，在交易进入排序和计入账本之前需要交易的相关各方进行背书：</p>
<ul>
<li>Fabric中背书是指背书节点对收到的客户端的交易提案按照自身逻辑进行检查，并调用链码执行交易，背书节点对请求的提案和链码执行结果（状态变更有关的读写集合）进行数字签名的过程。</li>
<li>对于调用链码的应用来说，需要根据链码的要求进行背书才会认为合法，才能提交给排序节点。</li>
</ul>
<p>在Fabric中链码的背书要求称之为背书策略</p>
<ul>
<li>背书策略可以要求指定成员集合中成员的一致同意或者一部分成员的同意甚至某个成员的支持，可以使用多种规则组合。但是一定要找信任的节点，因为其会看到我们所有的交易过程</li>
</ul>
<h3 id="链码（chaincode）"><a href="#链码（chaincode）" class="headerlink" title="链码（chaincode）"></a>链码（chaincode）</h3><p>Fabric中智能合约称为链码（Chaincode），链码是使用编程语言实现预定义接口（Chaincode接口）的一段应用程序，支持Go、Node.js、Java等高级编程语言</p>
<p>链码分为用户链码和系统链码</p>
<ul>
<li><strong>用户链码</strong>运行于独立的容器中，通常所说的链码是用户链码即开发人员基于企业用例所开发的链码</li>
<li><strong>系统链码</strong>则完成链码生命周期管理、分布式账本查询、背书签名、提交验证等系统功能</li>
</ul>
<h3 id="通道（channel）"><a href="#通道（channel）" class="headerlink" title="通道（channel）"></a>通道（channel）</h3><p>通道从狭义讲是Fabric网络成员中一部分节点构成的一个专用通信通道，从而限制网络中其他成员的访问。 Fabric中通道还包括绑定在通道上t的交易、链码、共享账本、成员节点、排序节点等配置和数据。加入通道的节点要有MSP赋予的唯一身份标识，并通过MSP认证通道的相关节点及服务。</p>
<p>Fabric把通道分为两类系统通道（System Channel）和应用通道（Application Channel）</p>
<ul>
<li>系统通道则主要负责对应用通道进行管理，比如为通道增加或者减少一个成员</li>
<li>应用通道主要运行用户链码交易</li>
</ul>
<p>此外，Fabric中还有个创始通道(Genesis Chanel)</p>
<ul>
<li>初始Fabric网络启动时对于每个排序服务来说，启动的一个特殊的排序系统通道 </li>
<li>该通道绑定排序节点并负责应用通道的创建，作为系统创建的首个通道</li>
</ul>
<h4 id="应用通道创建"><a href="#应用通道创建" class="headerlink" title="应用通道创建"></a>应用通道创建</h4><ol>
<li>首先，向系统通道发送配置交易（Configuration Transaction）</li>
<li>然后，排序服务会为该应用通道创建一个创始区块（Genesis Block），创始区块中包含该配置交易及初始配置的相关信息，该配置信息包括通道基本信息、通道访问策略、初始包含的成员信息、锚节点、排序服务地址等。</li>
<li>最后，当某个节点申请加入某条通道时，获取指定通道的配置区块，并调用系统链码的JoinChain方法获取创世区块，并完成账本、通道相关数据结构的初始化工作</li>
</ol>
<h3 id="排序服务"><a href="#排序服务" class="headerlink" title="排序服务"></a>排序服务</h3><p>Fabric的排序服务接收来自客户端的背书后的交易并按通道进行全局一致的排序，将一段时间内的交易形成区块并广播给相应的通道</p>
<p>排序服务就是Fabric提供共识服务的模块，以可插拔的形式实现。</p>
<ul>
<li>目前Fabric除了测试的solo模式，还包括已商业应用的Kafka模式</li>
<li>第三方的CFT或者BFT共识算法也可以插件的形式包含在Fabric中。</li>
</ul>
<p>Fabric排序服务除对交易进行排序形成共识区块或者创建用户通道外并不执行其他操作，也可以通过多个排序节点扩展性能。</p>
<h2 id="Fabric-区块链数据结构"><a href="#Fabric-区块链数据结构" class="headerlink" title="Fabric 区块链数据结构"></a>Fabric 区块链数据结构</h2><h3 id="账本"><a href="#账本" class="headerlink" title="账本"></a>账本</h3><p>首先，我们来说账本、状态数据库以及区块链之间的关系。可由下图表示：</p>
<p><img src="/2023/01/15/fabric%E5%AD%A6%E4%B9%A0/5.png"></p>
<p>账本是一个很宽泛的的概念，它包含了区块链本体以及状态数据库。在以太坊中，状态数据和区块数据都是持久化存放在LevelDB里的；而在Fabric中，有些不一样，二者是分开存储的</p>
<ul>
<li><p>区块链结构记录发生在网络中的交易以及交易所引起的状态的变更</p>
<ul>
<li>一般区块链结构<strong>通过文件系统进行存储</strong>。从数据库角度讲，区块链结构保存了状态变更的记录(可以理解为存放日志)，记录中保存了本次交易设计的变更前状态数据(读集合)和变更后状态数据(写集合)</li>
</ul>
</li>
<li><p>状态数据库则是由区块链结构中交易执行的结果生成，里面记录了最新的世界状态</p>
<ul>
<li>数据通过具有版本号的键值对存储</li>
<li>状态数据库则支持可插拔模块，可支持LevelDB、CouchDB，目前Fabric默认支持LevelDB。</li>
<li>从数据库角度讲，状态数据库则保存了<strong>最新的状态信息</strong></li>
</ul>
</li>
</ul>
<p>事实上，以太坊在LevelDB中，为了保持信息的可验证性，使用的不仅仅是LevelDB中的LSM Tree作为索引,但是LSM不具有防篡改功能，因此使用了改进的MPT树。在Fabric中，用的是Merkle Bucket Tree。</p>
<p>此外，还有历史数据库，里面存放着各个状态的历史变化记录</p>
<h3 id="区块链结构"><a href="#区块链结构" class="headerlink" title="区块链结构"></a>区块链结构</h3><p>区块链的第一个区块是创世区块</p>
<p>在Fabric中并不保存用户交易，主要保存通道创建时的通道配置交易，以后通道配置信息的更改会有新的配置区块来代替。</p>
<p>链式的结构连接所有区块，经过排序服务达成共识的最新区块，会根据区块编号追加到区块链的末尾，每个区块中包含了顺序执行的交易，这些交易可能成功也可能失败。</p>
<p><img src="/2023/01/15/fabric%E5%AD%A6%E4%B9%A0/6.png"></p>
<h3 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h3><ul>
<li><p>区块头部</p>
<ul>
<li>区块编号，包含一个数字区块编号，从0开始递增，最新的区块追加到链的尾部；</li>
<li>当前区块Hash值，即，当前区块包含所有交易的散列</li>
<li>前一个区块Hash值，通过该值所有区块形成链状结构。</li>
</ul>
</li>
<li><p>区块数据</p>
<ul>
<li>按照排序服务形成顺序排列的交易列表。</li>
</ul>
</li>
<li>区块元数据 <ul>
<li>包括块的写入时间及写入者的签名、公钥和证书等信息</li>
<li>提交节点提交区块时，还为每个交易添加是否有效的指示标志</li>
<li>该指示标志不包含在区块Hash值(区块创建时生成)中</li>
</ul>
</li>
</ul>
<h2 id="Fabric框架"><a href="#Fabric框架" class="headerlink" title="Fabric框架"></a>Fabric框架</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p><img src="/2023/01/15/fabric%E5%AD%A6%E4%B9%A0/1.png" style="zoom:67%;"></p>
<h3 id="节点网络"><a href="#节点网络" class="headerlink" title="节点网络"></a>节点网络</h3><p>Fabric中的节点概念来自于P2P网络，节点功能可能是对等一致的，也可能是分工合作的。在Fabric中，节点是区块链网络中的通信主体，一个节点也是一组逻辑功能的逻辑表示，因此一个物理服务器中可以运行不同类型的节点。</p>
<p>因此，在部署时需要考虑如何对节点进行分组并对节点进行访问控制，从而形成一个高效、安全的节点网络。</p>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><ul>
<li>客户端代表最终的用户实体，可以是命令行客户端，也可以是一个应用程序，当作为应用程序时，通过Fabric提供的SDK和区块链网络进行交互。</li>
<li>客户端通常会同时连接到一个节点和一个排序节点，客户端创建并发送交易给相关背书节点，符合背书要求后，发送交易给排序节点。</li>
</ul>
<h4 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h4><ul>
<li>提交节点<ul>
<li>对来自排序节点的新共识块进行验证</li>
<li>记入账本和状态数据库</li>
<li>Fabric中的所有节点都包含该逻辑功能，也就是说所有节点都是提交节点</li>
</ul>
</li>
<li>背书节点<ul>
<li>执行链码并对执行结果进行背书</li>
<li>每个链码的背书节点由链码背书策略决定，不同链码对应的背书借点也可能是不同的</li>
</ul>
</li>
<li>排序服务节点(排序节点)<ul>
<li>排序服务节点接收包含背书签名的交易</li>
<li>对未打包的交易进行排序生成区块</li>
<li>广播给Peer节点</li>
</ul>
</li>
<li>CA节点<ul>
<li>CA节点是可选的，它主要作为证书颁发机构，也可以用其他成熟的第三方CA颁发证书</li>
</ul>
</li>
</ul>
<p><img src="/2023/01/15/fabric%E5%AD%A6%E4%B9%A0/7.png" style="zoom:67%;"></p>
<p>从上图我们可以得到如下信息：</p>
<ul>
<li>一个Fabric网络可以由多个组织(成员)，一个组织在一个通道上可以由多个节点</li>
<li>主节点(Leader Peer)作为代表和排序服务节点通信，负责从排序服务节点处获取最新的区块，并在组织内部同步</li>
<li><p>锚节点代表组织节点与其他组织成员进行信息交换</p>
</li>
<li><p>为保证私密性Fabric区块链网络引入通道（channel）的概念，一个通道可以认为是区块链的一个虚拟专用子网（类似于VPN）</p>
<ul>
<li>区块链网络初始建立时系统默认启动一个包含所有排序节点的系统通道，组织成员根据需要通过系统通道创建专有通道，一个节点可以加入一个或多个通道，一个通道也可以包含多个节点。</li>
<li>Fabric基于通道提交交易、保存账本、执行链码、保存状态，不同通道的账本、状态和智能合约、策略都是隔离的。</li>
</ul>
</li>
</ul>
<h2 id="交易流程"><a href="#交易流程" class="headerlink" title="交易流程"></a>交易流程</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>比如说，企业A向企业B支付一笔货款</p>
<p>节点网络：假设企业A和企业B都有一个节点连接到网络，组织A和B的节点都连接到一个存在的通道</p>
<p>安全体系：应用程序的用户具有CA签发的数字证书并具有相应的权限</p>
<p>链码：链码已经安装到Fabric系统并绑定到通道。链码的背书策略要求转账交易必须有节点A和B的背书</p>
<h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><h4 id="Step1"><a href="#Step1" class="headerlink" title="Step1"></a>Step1</h4><p>客户端创建一个交易提案并根据背书策略发送给相应的背书节点</p>
<ul>
<li>创建<code>ChaincodeInvocationSpec</code>结构，主要包括<code>ChaincodeId</code>和链码方法名及相关参数；</li>
<li>计算交易Id（Transaction Id）</li>
<li>创建<code>Proposal</code>结构，通道头部信息中指定交易类型<code>HeaderType_ENDORSER_TRANSACTION</code>，设置通道Id、交易Id，设置签名头部的随机数和交易创建者；</li>
<li>使用创建者的数字证书对<code>Proposal</code>结构进行签名，形成<code>SignedProposal</code>结构。</li>
<li>根据链码的背书策略获取需要提交的背书节点；</li>
<li>把签名后的交易提案（<code>SignedProposal</code>）提交给相应的背书节点运行。调用<code>EndorserClient</code>接口的<code>ProcessProposal</code>方法</li>
</ul>
<h4 id="Step2"><a href="#Step2" class="headerlink" title="Step2"></a>Step2</h4><p>背书节点收到<code>SignedProposal</code>消息后调用<code>EndorserServer</code>接口的<code>ProcessProposal</code>方法处理签名的交易提案。</p>
<ul>
<li>对签名提案进行检查和校验，具体内容包括：<ul>
<li>消息结构是否完整</li>
<li>消息是否已经被提交过，从而避免重发攻击</li>
<li>客户端签名是否有效，主要是调用MSP的相关服务来完成</li>
<li>提交交易的客户端是否具有相应通道的权限，如读写权限。</li>
</ul>
</li>
<li>启动仿真模式，构造链码Invoke参数，并调用链码相关方法<ul>
<li>链码基于当前状态数据库执行链码并返回响应消息，包括响应值、读集合、写集合，在这个步骤<strong>不涉及任何对状态数据库和账本的更改</strong></li>
</ul>
</li>
<li>调用相应的ESCC链码，对交易结果进行背书，最终形成ProposalResponse结构 <ul>
<li>包含Payload（Response的读写数据集）、Endorsement（背书信息）</li>
</ul>
</li>
<li>背书响应及相关的事件返回客户端</li>
</ul>
<h4 id="Step3"><a href="#Step3" class="headerlink" title="Step3"></a>Step3</h4><p>客户端收集足够的提案背书响应，并向排序服务广播具有足够背书的交易</p>
<ul>
<li>若该交易仅仅查询账本、交易、状态等信息，客户端仅需解析响应消息不需要把交易提交给排序服务。</li>
<li>若该交易涉及账本数据变更，则需向排序服务提交交易，这时客户端需确保提案响应的Payload属性是一致的即交易执行的结果是一致的。</li>
<li>客户端把提案、响应及背书信息打包形成一个完整的交易 (Transaction)，添加头部及客户端签名后形成Envelope，最后通过BroadcastClient向排序服务广播该Envelope。</li>
<li>在该阶段，客户端会过滤掉TransientMap等受限访问的数据，这些数据也不会写入区块链数据库。</li>
</ul>
<h4 id="Step4"><a href="#Step4" class="headerlink" title="Step4"></a>Step4</h4><p>排序服务形成最新的共识块</p>
<ul>
<li>排序服务接收到来自客户端或代理节点广播的交易消息，这些消息可能来自不同的通道 </li>
<li>排序服务按照通道根据可插拔的共识算法，创建每个通道的最新共识块 </li>
<li>排序服务形成共识块后把共识块交付给各个组织的主节点</li>
<li>主节点收到共识块后通过Gossip协议向本组织的其他节点传播，最终一个通道中所有节点都能收到最新的共识块。</li>
</ul>
<h4 id="Step5"><a href="#Step5" class="headerlink" title="Step5"></a>Step5</h4><p>验证和提交交易到账本数据库</p>
<ul>
<li>节点接收到共识块后，对块中的所有交易进行验证<ul>
<li>检查交易的数字签名 </li>
<li>交易符合背书策略 </li>
<li>交易仿真运行时的读取集合版本自运行以来没有变化(KVS中的S即版本，如果S发生变化即会abort)</li>
</ul>
</li>
<li>在提交阶段检查(validation)，确保客户端即使没有对提案响应进行分析并检查背书策略，也能在提交阶段过滤掉不符合要求的交易。</li>
<li>在验证阶段，如果一笔交易中每个读集中的键与世界状态中对应键的版本号一致，那么该笔交易被认为是有效的。</li>
</ul>
<h4 id="Step6"><a href="#Step6" class="headerlink" title="Step6"></a>Step6</h4><p>更新账本数据库</p>
<ul>
<li>节点把验证过的区块附加到相应通道的区块链中</li>
<li>对于区块中验证通过的交易，把写集合提交到状态数据库</li>
<li>向客户端发出一个事件用于通知交易已经写入账本或者交易验证无效，客户端收到事件后完成后续的业务处理。客户端如果收到了abort掉的交易，会重新执行。</li>
</ul>
<h2 id="权限管理与策略"><a href="#权限管理与策略" class="headerlink" title="权限管理与策略"></a>权限管理与策略</h2><h3 id="组织体系"><a href="#组织体系" class="headerlink" title="组织体系"></a>组织体系</h3><ul>
<li>联盟（Consortium）<ul>
<li>若干个组织构成的集合，联盟中的组织成员使用同一个排序服务；</li>
<li>联盟中的每个组织成员都有一个成员服务提供者（MSP）分配的ID信息。</li>
</ul>
</li>
<li>组织(Organization)<ul>
<li>代表一组<strong>拥有共同信任的根证书</strong>的成员（节点）</li>
<li>根证书是CA认证中心给自己颁发的证书,是信任链的起始点。</li>
<li>组织一般包括ID、名称、MSP信息、管理策略、认证密码库类型、锚节点位置等信息。</li>
</ul>
</li>
</ul>
<h3 id="权限体系"><a href="#权限体系" class="headerlink" title="权限体系"></a>权限体系</h3><ul>
<li><p>权限：管理员权限(admin)、读权限(read)和写权限(write)</p>
<ul>
<li><p>读权限（Readers）的操作限制包括获取通道的交易、区块等数据</p>
</li>
<li><p>写权限（ Writers）包括向通道发起交易等</p>
</li>
<li><p>管理员权限（Admins）包括加入通道、修改通道的配置信息等</p>
</li>
</ul>
</li>
<li><p>角色:管理员角色和普通成员角色</p>
<ul>
<li>管理员角色具有管理员权限 </li>
<li>普通成员角色则具有读或写权限</li>
</ul>
</li>
</ul>
<h3 id="通道策略"><a href="#通道策略" class="headerlink" title="通道策略"></a>通道策略</h3><p>在Fabric中通道配置文件中的通道策略负责对通道内各种操作权限进行管理。</p>
<ul>
<li><p>通道策略中会对管理员、读、写等权限定义具体允许的操作以及授权的用户列表。 </p>
</li>
<li><p>通道策略(Channel Policy)是层级化结构，最上层为/Channel ，各级元素，下一级则挂接组织或组织单元</p>
</li>
</ul>
<h3 id="证书体系"><a href="#证书体系" class="headerlink" title="证书体系"></a>证书体系</h3><h4 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h4><p>以每个组织为单位，每个OU（Organizational Unit，组织单位）会生成单独的根证书。</p>
<p>组织的证书信息包括：</p>
<ul>
<li>CA：存放组织的根证书和对应的私钥文件，默认采用EC算法，证书为自签名。组织内的实体将基于该根证书作为证书根。</li>
<li>MSP：存放代表该组织的身份信息，用于节点和客户端的MSP服务。<ul>
<li><code>admincerts</code> ：组织管理员的身份验证证书，被根证书签名。</li>
<li><code>cacerts</code> ：组织的根证书，同ca 目录下文件。 </li>
<li><code>tlscacerts</code> ：用于TLS（Transport Layer Security，传输层安全协议）的CA证书，自签名。</li>
</ul>
</li>
</ul>
<h4 id="节点-1"><a href="#节点-1" class="headerlink" title="节点"></a>节点</h4><p>Fabric中每个节点（背书节点、提交节点、排序节点）、客户端都会在相应目录中建立一套目录，用于存放相关的证书文件。该目录结构包括MSP 证书和TLS 证书两类。</p>
<ul>
<li>MSP <ul>
<li><code>admincerts</code> ：组织管理员的身份验证证书。Peer 将基于这些证书来认证交易签署者是否为管理员身份。 </li>
<li><code>cacerts</code>：存放组织的根证书。 </li>
<li><code>keystore</code> ：本节点的身份私钥，用来签名。 </li>
<li><code>signcerts</code>： 验证本节点签名的证书，被组织根证书签名。</li>
<li><code>tlscacerts</code> : TLS 连接用的身份证书，即组织TLS 证书。</li>
</ul>
</li>
<li>TLS，存放TLS相关的证书和私钥<ul>
<li><code>ca.crt</code>：组织的根证书。 </li>
<li><code>server.crt</code> ：验证本节点签名的证书，被组织根证书签名。</li>
<li><code>server.key</code> ： 本节点的身份私钥，用来签名。</li>
</ul>
</li>
</ul>
<h3 id="成员服务提供者-MSP"><a href="#成员服务提供者-MSP" class="headerlink" title="成员服务提供者 - MSP"></a>成员服务提供者 - MSP</h3><p>MSP（Membership Service Providers，成员服务提供者 ）用于对某个资源（组织、节点、用户等）进行身份验证的一组机制，是实现权限管理的基础</p>
<ul>
<li>具体的身份</li>
<li>用户证书验证</li>
<li>用户证书撤销</li>
<li><p>签名生成和验证</p>
<p>MSP是一个可插拔模块，其设计了成员服务相关操作的框架，具体的证书验证与认证由相应的MSP实现模块完成，用户可以根据要求完成个性化MSP的实现模块</p>
</li>
</ul>
<p>MSP的划分比较灵活，一般可以一个组织有一个MSP。</p>
<p><img src="/2023/01/15/fabric%E5%AD%A6%E4%B9%A0/8.png" style="zoom:67%;"></p>
<p>Fabric中同一个内部的成员之间共有一个根证书，Gossip也是基于MSP进行数据同步。</p>
<h4 id="MSP结构"><a href="#MSP结构" class="headerlink" title="MSP结构"></a>MSP结构</h4><p>一个MSP一般包括9个部分，并以目录的形式存储在节点或客户端，MSP的名称是根目录，每个部分是子目录。MSP会在节点启动时把目录中的信息加载到<code>FabricMSPConfig</code>结构中。如下图所示：</p>
<p><img src="/2023/01/15/fabric%E5%AD%A6%E4%B9%A0/9.png"></p>
<ul>
<li>根证书列表(Root Cas)，一个自签名的证书列表，MSP中的成员都是以根证书列表为根的证书，同一根证书列表中的证书构成一个信任域； </li>
<li>中间证书列表(Intermediate Cas)，根证书到叶子证书的信任链中的中间部分证书，可以按组织机构或业务等划分，是可选参数。类比一下，根证书类似于教育部；华师大就类似于中间证书，还有叶子证书等划分</li>
<li>组织单元列表(Organizational Units (OUs))，组织的下级单元列表，当基于OU限制一些权限时，可以设置该参数，是可选参数；</li>
<li>管理员列表(Administrators)，组织的管理员证书列表；</li>
<li>吊销列表(Revoked Certificates)，已经从CA吊销的证书列表，该列表中的证书没有权限访问Fabric中的资源；</li>
<li>节点身份证书(Node Identity)，表明节点的身份信息，一般用于背书验证； </li>
<li>签名证书(KeyStore for Private Key)，节点身份证书的私钥，用于数字签名或背书；</li>
<li>TLS根证书列表(TLS Root Cas)，用于TLS通讯的根证书列表，一般组织之间、节点与排序节点之间跨网通讯时需使用TLS进行消息传输；</li>
<li>TLS中间证书列表(TLS Intermediate CA)，用于TLS通讯的中间证书，是可选参数。</li>
</ul>
<h4 id="MSP层级"><a href="#MSP层级" class="headerlink" title="MSP层级"></a>MSP层级</h4><ul>
<li>全局MSP(Network MSP)，面向整个Fabric网络，配置网络管理员列表，其成员能够完成一些网络管理任务，如创建应用通道；</li>
<li>通道MSP(Channel MSP)，通道MSP是虚拟的MSP，存在通道配置文件中，当通道MSP发生改变时，需要通过配置管理交易进行通道内节点的同步，通道内所有节点和客户端的通道MSP是一致的；</li>
<li>本地MSP(Local MSP)，定义了本地资源（节点、客户端）的管理和参与权限，每个节点或客户端仅仅对应一个本地MSP，并且本地MSP以目录的形式在文件系统中保存</li>
</ul>
<p>本地MSP和通道MSP的关系 </p>
<ul>
<li>对于一个有两个组织Org1和Org2的网络，每个组织有一个节点</li>
<li>当一个管理员B连接到节点，B具有RCA1签发的证书，当B试图在节点上安装链码时，系统会在本地MSP（ORG1-MSP）中验证B是否是Org1的合法成员，验证成功则B可以安装该链码。</li>
</ul>
<p><img src="/2023/01/15/fabric%E5%AD%A6%E4%B9%A0/10.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/08/27/C-%E5%AD%A6%E4%B9%A03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/27/C-%E5%AD%A6%E4%B9%A03/" class="post-title-link" itemprop="url">C#学习3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-27 12:49:47 / Modified: 12:54:20" itemprop="dateCreated datePublished" datetime="2022-08-27T12:49:47+08:00">2022-08-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C-学习3"><a href="#C-学习3" class="headerlink" title="C#学习3"></a>C#学习3</h1><h2 id="Introduction-1m"><a href="#Introduction-1m" class="headerlink" title="Introduction (1m)"></a>Introduction (1m)</h2><pre><code>          About the Course
            (0:39)
          Source Code
</code></pre><h2 id="Advanced-C-Topics-2h25m"><a href="#Advanced-C-Topics-2h25m" class="headerlink" title="Advanced C# Topics (2h25m)"></a>Advanced C# Topics (2h25m)</h2><h3 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h3><h3 id="Delegates"><a href="#Delegates" class="headerlink" title="Delegates"></a>Delegates</h3><h3 id="Lambda-Expressions"><a href="#Lambda-Expressions" class="headerlink" title="Lambda Expressions"></a>Lambda Expressions</h3><h3 id="Events-and-Delegates"><a href="#Events-and-Delegates" class="headerlink" title="Events and Delegates"></a>Events and Delegates</h3><h3 id="Extension-Methods"><a href="#Extension-Methods" class="headerlink" title="Extension Methods"></a>Extension Methods</h3><h3 id="LINQ"><a href="#LINQ" class="headerlink" title="LINQ"></a>LINQ</h3><h3 id="Nullable-Types"><a href="#Nullable-Types" class="headerlink" title="Nullable Types"></a>Nullable Types</h3><h3 id="Dynamic"><a href="#Dynamic" class="headerlink" title="Dynamic"></a>Dynamic</h3><h3 id="Exception-Handling"><a href="#Exception-Handling" class="headerlink" title="Exception Handling"></a>Exception Handling</h3><h3 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async/Await"></a>Async/Await</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/08/27/C-%E5%AD%A6%E4%B9%A02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/27/C-%E5%AD%A6%E4%B9%A02/" class="post-title-link" itemprop="url">C#学习2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-27 12:49:43 / Modified: 12:53:18" itemprop="dateCreated datePublished" datetime="2022-08-27T12:49:43+08:00">2022-08-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C-学习2"><a href="#C-学习2" class="headerlink" title="C#学习2"></a>C#学习2</h1><h2 id="Introduction-3m"><a href="#Introduction-3m" class="headerlink" title="Introduction (3m)"></a>Introduction (3m)</h2><h3 id="About-this-Course"><a href="#About-this-Course" class="headerlink" title="About this Course"></a>About this Course</h3><h2 id="Classes-1h50m"><a href="#Classes-1h50m" class="headerlink" title="Classes (1h50m)"></a>Classes (1h50m)</h2><h3 id="Introduction-to-Classes"><a href="#Introduction-to-Classes" class="headerlink" title="Introduction to Classes"></a>Introduction to Classes</h3><h3 id="Constructors"><a href="#Constructors" class="headerlink" title="Constructors"></a>Constructors</h3><h3 id="Object-Initializers"><a href="#Object-Initializers" class="headerlink" title="Object Initializers"></a>Object Initializers</h3><h3 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h3><h3 id="Fields"><a href="#Fields" class="headerlink" title="Fields"></a>Fields</h3><h3 id="Access-Modifiers"><a href="#Access-Modifiers" class="headerlink" title="Access Modifiers"></a>Access Modifiers</h3><h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><h3 id="Indexers"><a href="#Indexers" class="headerlink" title="Indexers"></a>Indexers</h3><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><h2 id="Association-Between-Classes-25m"><a href="#Association-Between-Classes-25m" class="headerlink" title="Association Between Classes (25m)"></a>Association Between Classes (25m)</h2><h3 id="Class-Coupling"><a href="#Class-Coupling" class="headerlink" title="Class Coupling"></a>Class Coupling</h3><h3 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h3><h3 id="Composition"><a href="#Composition" class="headerlink" title="Composition"></a>Composition</h3><h3 id="Composition-over-Inheritance"><a href="#Composition-over-Inheritance" class="headerlink" title="Composition over Inheritance"></a>Composition over Inheritance</h3><h3 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h3><h2 id="Inheritance-Second-Pillar-of-OOP-50m"><a href="#Inheritance-Second-Pillar-of-OOP-50m" class="headerlink" title="Inheritance: Second Pillar of OOP (50m)"></a>Inheritance: Second Pillar of OOP (50m)</h2><h3 id="Access-Modifiers-1"><a href="#Access-Modifiers-1" class="headerlink" title="Access Modifiers"></a>Access Modifiers</h3><h3 id="Constructors-and-Inheritance"><a href="#Constructors-and-Inheritance" class="headerlink" title="Constructors and Inheritance"></a>Constructors and Inheritance</h3><h3 id="Upcasting-and-Downcasting"><a href="#Upcasting-and-Downcasting" class="headerlink" title="Upcasting and Downcasting"></a>Upcasting and Downcasting</h3><h3 id="Boxing-and-Unboxing"><a href="#Boxing-and-Unboxing" class="headerlink" title="Boxing and Unboxing"></a>Boxing and Unboxing</h3><h3 id="Summary-2"><a href="#Summary-2" class="headerlink" title="Summary"></a>Summary</h3><h3 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h3><h2 id="Polymorphism-Third-Pillar-of-OOP-35m"><a href="#Polymorphism-Third-Pillar-of-OOP-35m" class="headerlink" title="Polymorphism: Third Pillar of OOP (35m)"></a>Polymorphism: Third Pillar of OOP (35m)</h2><h3 id="Method-Overriding"><a href="#Method-Overriding" class="headerlink" title="Method Overriding"></a>Method Overriding</h3><h3 id="Abstract-Classes-and-Members"><a href="#Abstract-Classes-and-Members" class="headerlink" title="Abstract Classes and Members"></a>Abstract Classes and Members</h3><h3 id="Sealed-Classes-and-Members"><a href="#Sealed-Classes-and-Members" class="headerlink" title="Sealed Classes and Members"></a>Sealed Classes and Members</h3><h3 id="Summary-3"><a href="#Summary-3" class="headerlink" title="Summary"></a>Summary</h3><h3 id="Exercises-1"><a href="#Exercises-1" class="headerlink" title="Exercises"></a>Exercises</h3><h2 id="Interfaces-1h5m"><a href="#Interfaces-1h5m" class="headerlink" title="Interfaces (1h5m)"></a>Interfaces (1h5m)</h2><h3 id="What-is-an-Interface"><a href="#What-is-an-Interface" class="headerlink" title="What is an Interface?"></a>What is an Interface?</h3><h3 id="Interfaces-and-Testability"><a href="#Interfaces-and-Testability" class="headerlink" title="Interfaces and Testability"></a>Interfaces and Testability</h3><h3 id="Interfaces-and-Extensibility"><a href="#Interfaces-and-Extensibility" class="headerlink" title="Interfaces and Extensibility"></a>Interfaces and Extensibility</h3><h3 id="Interfaces-are-NOT-for-Multiple-Inheritance"><a href="#Interfaces-are-NOT-for-Multiple-Inheritance" class="headerlink" title="Interfaces are NOT for Multiple Inheritance"></a>Interfaces are NOT for Multiple Inheritance</h3><h3 id="Interfaces-and-Polymorphism"><a href="#Interfaces-and-Polymorphism" class="headerlink" title="Interfaces and Polymorphism"></a>Interfaces and Polymorphism</h3><h3 id="Summary-4"><a href="#Summary-4" class="headerlink" title="Summary"></a>Summary</h3><h3 id="Exercises-2"><a href="#Exercises-2" class="headerlink" title="Exercises"></a>Exercises</h3><h2 id="Students’-Code-Reviews-35m"><a href="#Students’-Code-Reviews-35m" class="headerlink" title="Students’ Code Reviews (35m)"></a>Students’ Code Reviews (35m)</h2><h3 id="StopWatch-Exercise"><a href="#StopWatch-Exercise" class="headerlink" title="StopWatch Exercise"></a>StopWatch Exercise</h3><h3 id="Stack-Exercise"><a href="#Stack-Exercise" class="headerlink" title="Stack Exercise"></a>Stack Exercise</h3><h3 id="WorkflowEngine-Exercise"><a href="#WorkflowEngine-Exercise" class="headerlink" title="WorkflowEngine Exercise"></a>WorkflowEngine Exercise</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/08/27/C-%E5%AD%A6%E4%B9%A01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/27/C-%E5%AD%A6%E4%B9%A01/" class="post-title-link" itemprop="url">C#学习1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-27 11:16:54 / Modified: 11:33:32" itemprop="dateCreated datePublished" datetime="2022-08-27T11:16:54+08:00">2022-08-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C-学习1"><a href="#C-学习1" class="headerlink" title="C#学习1"></a>C#学习1</h1><h2 id="Getting-Started-20m"><a href="#Getting-Started-20m" class="headerlink" title="Getting Started (20m)"></a>Getting Started (20m)</h2><h3 id="C-vs-NET"><a href="#C-vs-NET" class="headerlink" title="C# vs .NET"></a>C# vs .NET</h3><h3 id="What-is-CLR"><a href="#What-is-CLR" class="headerlink" title="What is CLR"></a>What is CLR</h3><h3 id="Architecture-of-NET-Applications"><a href="#Architecture-of-NET-Applications" class="headerlink" title="Architecture of .NET Applications"></a>Architecture of .NET Applications</h3><h3 id="Getting-Visual-Studio"><a href="#Getting-Visual-Studio" class="headerlink" title="Getting Visual Studio"></a>Getting Visual Studio</h3><h3 id="Your-First-C-Application"><a href="#Your-First-C-Application" class="headerlink" title="Your First C# Application"></a>Your First C# Application</h3><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><h2 id="Primitive-Types-and-Expressions"><a href="#Primitive-Types-and-Expressions" class="headerlink" title="Primitive Types and Expressions"></a>Primitive Types and Expressions</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><h3 id="Variables-and-Constants"><a href="#Variables-and-Constants" class="headerlink" title="Variables and Constants"></a>Variables and Constants</h3><h3 id="Overflowing"><a href="#Overflowing" class="headerlink" title="Overflowing"></a>Overflowing</h3><h3 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h3><h3 id="Demo-Variables-and-Constants"><a href="#Demo-Variables-and-Constants" class="headerlink" title="Demo: Variables and Constants"></a>Demo: Variables and Constants</h3><h3 id="Type-Conversion"><a href="#Type-Conversion" class="headerlink" title="Type Conversion"></a>Type Conversion</h3><h3 id="Demo-Type-Conversion"><a href="#Demo-Type-Conversion" class="headerlink" title="Demo: Type Conversion"></a>Demo: Type Conversion</h3><h3 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h3><h3 id="What-are-Logical-Operations"><a href="#What-are-Logical-Operations" class="headerlink" title="What are Logical Operations?"></a>What are Logical Operations?</h3><h3 id="Demo-Operators"><a href="#Demo-Operators" class="headerlink" title="Demo: Operators"></a>Demo: Operators</h3><h3 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h3><h3 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h3><h2 id="Non-Primitive-Types-1h"><a href="#Non-Primitive-Types-1h" class="headerlink" title="Non-Primitive Types (1h)"></a>Non-Primitive Types (1h)</h2><h3 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h3><h3 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h3><h3 id="Demo-Classes"><a href="#Demo-Classes" class="headerlink" title="Demo: Classes"></a>Demo: Classes</h3><h3 id="Structs"><a href="#Structs" class="headerlink" title="Structs"></a>Structs</h3><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><h3 id="Demo-Arrays"><a href="#Demo-Arrays" class="headerlink" title="Demo: Arrays"></a>Demo: Arrays</h3><h3 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h3><h3 id="Demo-Strings"><a href="#Demo-Strings" class="headerlink" title="Demo: Strings"></a>Demo: Strings</h3><h3 id="Enums"><a href="#Enums" class="headerlink" title="Enums"></a>Enums</h3><h3 id="Demo-Enums"><a href="#Demo-Enums" class="headerlink" title="Demo: Enums"></a>Demo: Enums</h3><h3 id="Reference-Types-and-Value-Types"><a href="#Reference-Types-and-Value-Types" class="headerlink" title="Reference Types and Value Types"></a>Reference Types and Value Types</h3><h3 id="Demo-Reference-Types-and-Value-Types"><a href="#Demo-Reference-Types-and-Value-Types" class="headerlink" title="Demo: Reference Types and Value Types"></a>Demo: Reference Types and Value Types</h3><h3 id="Summary-2"><a href="#Summary-2" class="headerlink" title="Summary"></a>Summary</h3><h2 id="Control-Flow-40m"><a href="#Control-Flow-40m" class="headerlink" title="Control Flow (40m)"></a>Control Flow (40m)</h2><h3 id="Introduction-2"><a href="#Introduction-2" class="headerlink" title="Introduction"></a>Introduction</h3><h3 id="Conditional-Statements"><a href="#Conditional-Statements" class="headerlink" title="Conditional Statements"></a>Conditional Statements</h3><h3 id="Demo-If-Else-Switch-Case"><a href="#Demo-If-Else-Switch-Case" class="headerlink" title="Demo: If/Else, Switch/Case"></a>Demo: If/Else, Switch/Case</h3><h3 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h3><h3 id="Iteration-Statements"><a href="#Iteration-Statements" class="headerlink" title="Iteration Statements"></a>Iteration Statements</h3><h3 id="Demo-For-loops"><a href="#Demo-For-loops" class="headerlink" title="Demo: For loops"></a>Demo: For loops</h3><h3 id="Demo-Foreach-loops"><a href="#Demo-Foreach-loops" class="headerlink" title="Demo: Foreach loops"></a>Demo: Foreach loops</h3><h3 id="Demo-While-loops"><a href="#Demo-While-loops" class="headerlink" title="Demo: While loops"></a>Demo: While loops</h3><h3 id="Random-Class"><a href="#Random-Class" class="headerlink" title="Random Class"></a>Random Class</h3><h3 id="Exercises-1"><a href="#Exercises-1" class="headerlink" title="Exercises"></a>Exercises</h3><h3 id="Summary-3"><a href="#Summary-3" class="headerlink" title="Summary"></a>Summary</h3><h2 id="Arrays-and-Lists-30m"><a href="#Arrays-and-Lists-30m" class="headerlink" title="Arrays and Lists (30m)"></a>Arrays and Lists (30m)</h2><h3 id="Introduction-3"><a href="#Introduction-3" class="headerlink" title="Introduction"></a>Introduction</h3><h3 id="Arrays-1"><a href="#Arrays-1" class="headerlink" title="Arrays"></a>Arrays</h3><h3 id="Demo-Arrays-1"><a href="#Demo-Arrays-1" class="headerlink" title="Demo: Arrays"></a>Demo: Arrays</h3><h3 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h3><h3 id="Demo-Lists"><a href="#Demo-Lists" class="headerlink" title="Demo: Lists"></a>Demo: Lists</h3><h3 id="Excercises"><a href="#Excercises" class="headerlink" title="Excercises"></a>Excercises</h3><h3 id="Summary-4"><a href="#Summary-4" class="headerlink" title="Summary"></a>Summary</h3><h2 id="Working-with-Dates-10m"><a href="#Working-with-Dates-10m" class="headerlink" title="Working with Dates (10m)"></a>Working with Dates (10m)</h2><h3 id="Introduction-4"><a href="#Introduction-4" class="headerlink" title="Introduction"></a>Introduction</h3><h3 id="DateTime"><a href="#DateTime" class="headerlink" title="DateTime"></a>DateTime</h3><h3 id="TimeSpan"><a href="#TimeSpan" class="headerlink" title="TimeSpan"></a>TimeSpan</h3><h3 id="Summary-5"><a href="#Summary-5" class="headerlink" title="Summary"></a>Summary</h3><h2 id="Working-with-Text-50m"><a href="#Working-with-Text-50m" class="headerlink" title="Working with Text (50m)"></a>Working with Text (50m)</h2><h3 id="Introduction-5"><a href="#Introduction-5" class="headerlink" title="Introduction"></a>Introduction</h3><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h3 id="Demo-Strings-1"><a href="#Demo-Strings-1" class="headerlink" title="Demo: Strings"></a>Demo: Strings</h3><h3 id="Live-Coding-Summarizing-Text"><a href="#Live-Coding-Summarizing-Text" class="headerlink" title="Live Coding: Summarizing Text"></a>Live Coding: Summarizing Text</h3><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><h3 id="Demo-StringBuilder"><a href="#Demo-StringBuilder" class="headerlink" title="Demo: StringBuilder"></a>Demo: StringBuilder</h3><h3 id="Exercises-2"><a href="#Exercises-2" class="headerlink" title="Exercises"></a>Exercises</h3><h3 id="Procedural-Programming"><a href="#Procedural-Programming" class="headerlink" title="Procedural Programming"></a>Procedural Programming</h3><h3 id="Summary-6"><a href="#Summary-6" class="headerlink" title="Summary"></a>Summary</h3><h2 id="Working-with-Files-25m"><a href="#Working-with-Files-25m" class="headerlink" title="Working with Files (25m)"></a>Working with Files (25m)</h2><h3 id="Introduction-6"><a href="#Introduction-6" class="headerlink" title="Introduction"></a>Introduction</h3><h3 id="Introduction-to-System-IO"><a href="#Introduction-to-System-IO" class="headerlink" title="Introduction to System.IO"></a>Introduction to System.IO</h3><h3 id="File-and-File-Info"><a href="#File-and-File-Info" class="headerlink" title="File and File Info"></a>File and File Info</h3><h3 id="Directory-and-Directory-Info"><a href="#Directory-and-Directory-Info" class="headerlink" title="Directory and Directory Info"></a>Directory and Directory Info</h3><h3 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h3><h3 id="Exercises-3"><a href="#Exercises-3" class="headerlink" title="Exercises"></a>Exercises</h3><h3 id="Summary-7"><a href="#Summary-7" class="headerlink" title="Summary"></a>Summary</h3><h2 id="Debugging-Applications-40m"><a href="#Debugging-Applications-40m" class="headerlink" title="Debugging Applications (40m)"></a>Debugging Applications (40m)</h2><h3 id="Introduction-7"><a href="#Introduction-7" class="headerlink" title="Introduction"></a>Introduction</h3><h3 id="Debugging-Tools-in-Visual-Studio"><a href="#Debugging-Tools-in-Visual-Studio" class="headerlink" title="Debugging Tools in Visual Studio"></a>Debugging Tools in Visual Studio</h3><h3 id="Removing-Side-Effects"><a href="#Removing-Side-Effects" class="headerlink" title="Removing Side Effects"></a>Removing Side Effects</h3><h3 id="Defensive-Programming"><a href="#Defensive-Programming" class="headerlink" title="Defensive Programming"></a>Defensive Programming</h3><h3 id="Call-Stack-Window"><a href="#Call-Stack-Window" class="headerlink" title="Call Stack Window"></a>Call Stack Window</h3><h3 id="Locals-and-Autos-Windows"><a href="#Locals-and-Autos-Windows" class="headerlink" title="Locals and Autos Windows"></a>Locals and Autos Windows</h3><h3 id="Summary-8"><a href="#Summary-8" class="headerlink" title="Summary"></a>Summary</h3><h3 id="Whats-Next"><a href="#Whats-Next" class="headerlink" title="Whats Next"></a>Whats Next</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/08/24/HTTPS%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/24/HTTPS%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">HTTPS学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-24 23:11:29" itemprop="dateCreated datePublished" datetime="2022-08-24T23:11:29+08:00">2022-08-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-26 20:07:56" itemprop="dateModified" datetime="2022-08-26T20:07:56+08:00">2022-08-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="HTTPS学习"><a href="#HTTPS学习" class="headerlink" title="HTTPS学习"></a>HTTPS学习</h1><p>参考博客</p>
<ul>
<li><a href="https://blog.csdn.net/qq_36885515/article/details/123137827" target="_blank" rel="noopener">https://blog.csdn.net/qq_36885515/article/details/123137827</a></li>
<li><a href="https://www.cnblogs.com/loleina/p/8418085.html" target="_blank" rel="noopener">https://www.cnblogs.com/loleina/p/8418085.html</a></li>
<li><a href="https://www.jianshu.com/p/4932cb1499bf" target="_blank" rel="noopener">https://www.jianshu.com/p/4932cb1499bf</a></li>
</ul>
<h2 id="HTTPS的基本概念"><a href="#HTTPS的基本概念" class="headerlink" title="HTTPS的基本概念"></a>HTTPS的基本概念</h2><p>HTTPS 是最流行的HTTP 安全形式。它是由网景公司首创的，所有主要的浏览器和服务器都支持此协议。HTTPS 的URL 以<code>https://</code>，而不是<code>http://</code>开头，据此就可以分辨某个Web 页面是通过HTTPS 而不是HTTP 访问的。</p>
<p> <code>HTTPS = HTTP + SSL（TLS）</code>，HTTPS 就是在安全的传输层上发送的HTTP。如下图所示：HTTPS 没有将未加密的HTTP 报文发送给TCP，它在将HTTP 报文发送给TCP 之前，先将其发送给了一个安全层，对其进行加密。现在，HTTP 安全层是通过SSL 及其现代替代协议TLS 来实现的。我们遵循常见的用法，用术语SSL 来表示SSL 或者TLS。</p>
<h3 id="HTTPS与HTTP的区别"><a href="#HTTPS与HTTP的区别" class="headerlink" title="HTTPS与HTTP的区别"></a>HTTPS与HTTP的区别</h3><p>HTTPS跟HTTP相比，有以下几个明显的优点：</p>
<ul>
<li>服务器认证（客户端知道它们是在与真正的而不是伪造的服务器通话）</li>
<li>客户端认证（服务器知道它们是在与真正的而不是伪造的客户端通话），通常现在web服务，不需要做客户端认证，只需要做服务器认证；</li>
<li>完整性（客户端和服务器的数据不会被修改），因为整个传输过程是加密的；</li>
<li>加密（客户端和服务器的对话是私密的，无需担心被窃听），使用wireshake监听HTTPS端口会捕获不到数据。</li>
<li>效率（一个运行的足够快的算法，以便低端的客户端和服务器使用），如果使用HTTP+特别复杂的数据加密技术来试图替代HTTPS，交互的双方在加解密的过程会消耗大量的性能，性能下降特别明显。</li>
<li>普适性（基本上所有的客户端和服务器都支持这些协议）。</li>
<li>管理的可扩展性（在任何地方的任何人都可以立即进行安全通信）。</li>
<li>适应性（能够支持当前最知名的安全方法）。</li>
<li>在社会上的可行性（满足社会的政治文化需要）。</li>
</ul>
<h2 id="TLS-SSL"><a href="#TLS-SSL" class="headerlink" title="TLS/SSL"></a>TLS/SSL</h2><p>早期的互联网协议基本都是不加密进行传输的，如HTTP、FTP、telnet.等协议的</p>
<p><strong>传输层安全性协议</strong>（英语：<strong>T</strong>ransport <strong>L</strong>ayer <strong>S</strong>ecurity，缩写：<strong>TLS</strong>）及其前身<strong>安全套接层</strong>（英语：<strong>S</strong>ecure <strong>S</strong>ockets <strong>L</strong>ayer，缩写：<strong>SSL</strong>）的历史进程如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>协议</th>
<th>发布时间</th>
<th>状态</th>
</tr>
</thead>
<tbody>
<tr>
<td>SSL 1.0</td>
<td>未公布</td>
<td>未公布</td>
</tr>
<tr>
<td>SSL 2.0</td>
<td>1995年</td>
<td>已于2011年弃用</td>
</tr>
<tr>
<td>SSL 3.0</td>
<td>1996年</td>
<td>已于2015年弃用</td>
</tr>
<tr>
<td>TLS 1.0</td>
<td>1999年</td>
<td>已于2020年弃用</td>
</tr>
<tr>
<td>TLS 1.1</td>
<td>2006年</td>
<td>已于2020年弃用</td>
</tr>
<tr>
<td>TLS 1.2</td>
<td>2008年</td>
<td></td>
</tr>
<tr>
<td>TLS 1.3</td>
<td>2018年</td>
</tr>
</tbody>
</table>
</div>
<h3 id="SSL-TLS属于哪一层"><a href="#SSL-TLS属于哪一层" class="headerlink" title="SSL/TLS属于哪一层"></a>SSL/TLS属于哪一层</h3><p>这个问题十分有意思，从前面的发展历史中我们不难知道，TLS可以视为是SSL的高级版本（主要体现在更加安全上），而从TLS的名字（传输层安全性协议）就会觉得它应该是传输层的协议，当然这可能就望文生义了，实际上在网上有不少的文章在讨论TLS/SSL属于应用层还是传输层，实际上的情况要更为复杂一些</p>
<p>我们知道，网络层有三种划分：OSI模型、TCP/IP模型和五层网络模型，如下图所示：</p>
<p><img src="/2022/08/24/HTTPS%E5%AD%A6%E4%B9%A0/2.png" style="zoom:150%;"></p>
<p>首先我们对SSL/TLS的作用进行分析：SSL/TLS最初是为了给HTTP协议加密使用，也就是HTTPS协议，通常来说我们可以认为HTTP+SSL/TLS=HTTPS，而实际上现在我们的很多其他应用层协议都可以使用SSL/TLS，比如SSH、FTPS、POP3S、IMAPS等等。再以HTTPS为例，一个HTTPS建立连接需要经过TCP握手建立连接这一步骤的，也就是说HTTPS还是基于TCP的，而TCP属于传输层这是毫无争论的。也就是说从划分最细的OSI七层参考模型来看，SSL/TLS应该是在传输层和应用层之间。</p>
<p>实际上从SSL/TLS的功能来分析：</p>
<p><img src="/2022/08/24/HTTPS%E5%AD%A6%E4%B9%A0/3.png" style="zoom:150%;"></p>
<ul>
<li>SSL Record Protocol（SSL记录协议），它建立在可靠的传输协议（如TCP）之上，SSL/TLS使用了双向字节流传输（全双工），为高层协议提供数据封装、压缩、加密等基本功能的支持，从功能上看这应该是OSI的L6（表示层）</li>
<li>SSL Handshake Protocol（SSL握手协议）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等，从功能上看这应该是OSI的L5（会话层）</li>
</ul>
<p>对应五层的网络模型呢？由于OSI模型中的L5、L6、L7都合并成了应用层，所以SSL/TLS应该是属于传输层和应用层了。</p>
<h3 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h3><p>这一部分我在 <a href="https://jasonxqh.github.io/2022/03/03/区块链基础-哈希/#哈希函数在区块链中的应用">哈希函数在区块链中的应用</a> 博客中已经学习过了，但是我们再来加深一边印象</p>
<p>讲到加密，必然需要理解加密算法，而加密算法一般来说可以分为<strong>对称加密</strong>和<strong>非对称加密</strong>两种。</p>
<p><img src="/2022/08/24/HTTPS%E5%AD%A6%E4%B9%A0/4.png" style="zoom:150%;"></p>
<p>这里的对称和非对称是针对加密和解密这两个操作而言的，一般来说是消息发送方发送消息时需要加密，消息接收方在接收消息后需要进行解密。<strong>如果加密和解密用的密钥是相同的，则是对称加密；如果不同则是非对称加密。</strong></p>
<h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><p><strong>对称加密算法的特点是算法公开、计算量小、加密速度快、加密效率高。</strong>常见的对称加密算法有AES、DES等。</p>
<p>对称加密最大的问题在于密钥的传输：因为如果信息的发送方和接收方是通过网络来进行通信的，而在网络中使用明文通信是不安全的，想要安全通信必须使用密钥加密，同时要保证密钥只有通信双方知道，但是在传输密钥之前双方并没有一个安全可靠双方都知道的密钥。如果最开始的密钥传输过程使用明文，就可能会被别有用心的人截获密钥，之后的加密就毫无意义。</p>
<p>当然，最保险的方法就是线下传输密钥然后再线上通信，可以参考谍战片中的特务舍生取义护送密码本，但是这在互联网时代显然不靠谱。</p>
<h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><p>这时候非对称加密就出现了，非对称加密最大的特点就是把密钥进行分离，将其分成公钥和私钥两个部分，常见的非对称加密算法主要有 RSA 、 DSA 、ECC等。</p>
<p>顾名思义，公钥是可以用在互联网中随意传播的，而私钥则是需要自己小心保存避免泄露的。消息的发送方只需要知道消息接受方的公钥，即可将明文通过公钥加密然后通过网络传输给消息接收方。消息接收方收到密文后，通过非对称加密算法，使用自己的私钥进行解密，即可获取消息内容。</p>
<p> 这里面有几个点需要额外关注一下：</p>
<ul>
<li>公钥是所有人都可以获取的，因此想要给接收方发送消息只需要获取公钥即可，所以公钥可以用明文直接传输，因为即使是在传输过程中泄露了公钥，由于解密只能使用私钥，因此整个数据传输也还是安全的</li>
<li>在通信过程中一般两边都涉及到消息的发送和接收，因此在通信过程中一般会有两套密钥对</li>
<li>可以根据私钥生成公钥，反之不行</li>
<li>消息发送方是无法对发送出去的密文解密的，它只能读取自己保存的明文来了解之前发送过的消息</li>
<li>如果用私钥加密，由于公钥的信息是在全网传播的，那么在这种情况下是否可以认为非对称加密的意义不大？会有第三方用公钥嗅探的可能？<ul>
<li>有可能，此时就需要加入时间的因素，我们可以给一个HTTPs定一个会话时间 ，只要这个时间设置的合理，那么及时第三方嗅探到了，当前的会话也早已经结束了</li>
</ul>
</li>
</ul>
<h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><h5 id="场景引入"><a href="#场景引入" class="headerlink" title="场景引入"></a>场景引入</h5><p><strong>在通信的过程中，我们使用公钥加密，私钥解密，因为私钥是自己才有的，而传输的信息是不安全的可能被别人截获的，但是只要对其进行加密，然后保证自己才能解密，就可以认为传输信息是安全的。</strong>这就好比使用了一个很安全的保险箱来存放重要资料再快递到别的地方去，只要保证只有自己能够解锁保险箱，那么运输过程中保险箱会被谁接触到都不重要，只要保险箱送到目的地就可以了。</p>
<p>即便是非对称加密，也存在一个公钥传输的问题。基本上存在着两种方案，一种是直接把公钥放到网上，然后让需要使用的用户去下载，另一种就是在通信传输过程中，由服务器直接发送给客户端。这两种方法都存在一个问题就是无法保证公钥传输的安全性，虽然公钥是可以给任何人知道的，但是在通信过程中使用的公钥必须是通信双方的公钥，否则如果出现中间人劫持了通信并且将公钥替换为中间人自己的公钥，那么中间人就可以获取到通信内容。</p>
<p>我们设想一个情景：</p>
<p>现在Bob决定给Pat写一份信，信件的内容不用加密，但是要保证Pat收到信件后，能够确认信件的确是Bob发出的，而不是别人冒充Bob发给Pat的，应该如果做呢？</p>
<h5 id="数字签名-1"><a href="#数字签名-1" class="headerlink" title="数字签名"></a>数字签名</h5><p>首先，Bob将信件通过hash软件计算一下，得到一串消息摘要（有的文章也称之为“hash值”）。这一过程能够保证2点：</p>
<ol>
<li><p>过程不可逆。即不能通过消息摘计算出信件的内容。</p>
</li>
<li><p>消息摘要不会重复。即如果信件有任何改动，再次hash计算出的消息摘要一定不会和改动前的消息摘要一致。</p>
</li>
</ol>
<p><img src="/2022/08/24/HTTPS%E5%AD%A6%E4%B9%A0/7.png" style="zoom:150%;"></p>
<p>然后，Bob<strong>使用自己的私钥</strong>，将消息摘要加密。加密后的结果，我们称之为“数字签名”。现在，Bob就可以将信件连同数字签名一起发给Pat。</p>
<p><img src="/2022/08/24/HTTPS%E5%AD%A6%E4%B9%A0/9.png" style="zoom:150%;"></p>
<p><img src="/2022/08/24/HTTPS%E5%AD%A6%E4%B9%A0/10.png" style="zoom:150%;"></p>
<p>Pat收到信件以后，会做2件事：</p>
<ol>
<li><strong>使用Bob的公钥将数字签名解密</strong>，得到信息摘要。如果顺利解密，说明的确是Bob签发的数字签名，不是别人签发的，因为Bob的私钥没有公开。</li>
<li>Pat使用hash软件对信件再次进行hash计算，和<strong>解密数字签名得到的消息摘要对比</strong>，如果一致，说明信件没有篡改，确实是Bob发出的。这就是数字签名的过程。它能够确保签名人发出的消息不被篡改，也能证明的确是签名人发出的消息。</li>
</ol>
<p> <img src="/2022/08/24/HTTPS%E5%AD%A6%E4%B9%A0/8.png" style="zoom:150%;"></p>
<p>通过数字签名，可以保证公钥传输的安全性，如果在路上公钥被人劫持，那么用其他人的公钥是无法顺利解锁Bob的数字签名的。</p>
<p>一切看上去是那么的完美，使用公钥私钥，即能加解密消息，又可以数字签名。</p>
<p>但是，我们再设想一个情况，如果有个坏人Doug, 他要欺骗Pat，冒充Bob给Pat写信，他应该怎么做的？</p>
<p>由于公钥是公开的，并可以导入到电脑，这时候Doug可以偷偷在Pat的电脑上，用自己的公钥替换了Bob的公钥，然后用自己的私钥加密数据，给Pat发送Email。这时候Pat收到的邮件其实是Doug冒充的，但是由于公钥被替换，所以他无法察觉。这时候，该怎么办呢？</p>
<h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><p>这时候数字证书的用处就来了，使用数字证书可以确保公钥不被冒充。Bob该如何操作的呢？</p>
<ol>
<li><p>首先Bob去找证书中心(CA)，为公钥做认证。 CA用自己的私钥，对Bob的公钥和一些相关信息一起加密。生成了数字证书：</p>
<p><img src="/2022/08/24/HTTPS%E5%AD%A6%E4%B9%A0/11.jpg" style="zoom:150%;"></p>
<ol>
<li>Bob在写给Pat的邮件中，除了数字签名，另外加上了这张数字证书，告诉Pat我的公钥是可信的</li>
</ol>
<p><img src="/2022/08/24/HTTPS%E5%AD%A6%E4%B9%A0/12.jpg" style="zoom:150%;"></p>
<ol>
<li>Pat收到Email后用CA的公钥解密这份数字证书，拿到Bob的公钥，然后验证数字签名，后面流程就和图1的流程一样了。由于坏人Doug不能伪造这样一封数字证书(数字证书拥有权威性)，也就不能伪装Bob了。</li>
</ol>
</li>
</ol>
<p>那么，还是有几点疑惑需要解决：</p>
<ul>
<li>假设数字证书被伪造了呢？<ul>
<li>是的，传输中数字证书有可能被篡改。因此数字证书也是经过数字签名的，上文说道数字签名的作用就是验证数据来源以及数据完整性！Pat收到邮件后可以先验证这份数字证书的可靠性，通过后再验证数字签名。</li>
</ul>
</li>
<li>要是有1万个人要给Pat发邮件，难道Pat要保存1万份不同的CA公钥吗？<ul>
<li>不需要，CA认证中心给可以给B一份“根证书”，里面存储CA公钥来验证所有CA分中心颁发的数字证书。CA中心是分叉树结构，类似于公安部-&gt;省公安厅-&gt;市级派出所，不管A从哪个CA分支机构申请的证书，B只要预存根证书就可以验证下级证书可靠性。</li>
</ul>
</li>
<li>如何验证根证书可靠性？<ul>
<li>无法验证。根证书是自验证证书，CA机构是获得社会绝对认可和有绝对权威的第三方机构，这一点保证了根证书的绝对可靠。如果根证书都有问题那么整个加密体系毫无意义。</li>
</ul>
</li>
</ul>
<h5 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h5><p>数字证书是部署HTTPS认证的网站的必需品，我们在访问一个网站的时候，一般点击浏览器地址栏旁边的小锁就可以看到这时候正在使用的数字证书：</p>
<p><img src="/2022/08/24/HTTPS%E5%AD%A6%E4%B9%A0/5.png" style="zoom:150%;"></p>
<p>点击进去就可以看到相关的证书信息。证书中包含着十分多的信息，首先最重要的当然是对应的域名和公钥，其他的还有证书的生效时间，使用的加密算法、签名算法等各种相关信息。</p>
<p><img src="/2022/08/24/HTTPS%E5%AD%A6%E4%B9%A0/13.png"></p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>签发证书的机构被称为 CA（ Certificate Authority），理论上每个人都可以成为CA，因为每个人都可以自己签发证书，但是只有极少数的权威CA颁发的证书才会被承认，这几大权威CA的称为ROOT CA，他们的证书一般都会内置在操作系统中，浏览器默认是信任这些ROOT CA的证书的，而这些ROOT CA下属还有其他的CA，这些下属的CA可以为各种网站颁发证书，根据层层信任的原则，浏览器也会信任这些CA下发的证书，最终就保证了通信中公钥传输的安全。</p>
<p>早期的证书是需要收费的，但是到了近几年加密通信的需求增加，很多网站的运营者并没有那么多钱来购买证书（证书过期了续费也是要钱的），这时候就出现了以Encryption Everywhere、 Let’s Encrypt等为首的CA开始大量普及免费的数字证书，如今国内的很多云厂商也提供了各种免费的数字证书，从而很好的推动了加密通信的发展。不过这些免费的数字证书在安全性上并没有企业级的收费证书那么高，大多数都只是DV证书，如果对安全性有很高的追求，还是建议购买收费的证书。</p>
<p>一般来说数字证书可以按照安全程度分为以下三类：</p>
<p>EV：<strong>EV证书(Extended Validation Certificate)</strong>是一种根据一系列特定标准颁发的X.509电子证书，根据要求，在颁发证书之前，证书颁发机构(CA)必须验证申请者的身份。不同机构根据证书标准发行的扩展验证证书并无太大差异，但是有时候根据一些具体的要求，特定机构发行的证书可以被特定的软件识别</p>
<p>OV：OV证书(Organization Validation SSL)，指需要验证网站所有单位的真实身份的标准型SSL证书，此类证书不仅能够起到网站信息加密的作用，而且能向用户证明网站的真实身份</p>
<p>DV：DV证书(Domain Validation SSL)，指需要验证域名的有效性。该类证书只提供基本的加密保障，不能提供域名所有者的信息</p>
<h3 id="TLS加密握手过程"><a href="#TLS加密握手过程" class="headerlink" title="TLS加密握手过程"></a>TLS加密握手过程</h3><p>TLS本身是一个混合加密系统，也就是说它使用了对称加密和非对称加密两种方式，<strong>首先是使用非对称加密来传输在这次会话过程中生成的用于生成对称加密的密钥（ pre-master key），结合明文传输的随机数和算法生成对称加密的密钥之后再使用对称加密进行通信。</strong>这样通信的原因是因为非对称加密虽然很安全，但是效率实在是太低了（比对称加密慢几个数量级），因此只用来传输对称加密的密钥，之后就使用效率更高的对称加密来通信。</p>
<p>TLS支持多种密钥交换算法（key exchange algorithms） 和加密算法（ciphersuites），不同的客户端和服务器之间支持的也各不相同，因此在加密通信之间就需要进行协商，<strong>客户端和服务端需要协商清楚使用何种算法，使用何种加密方式，使用什么密钥等等问题，这一个过程称为握手过程（handshake）。</strong>就好像TCP连接在建立前需要进行三次握手一样，所有的TLS通信在开始之前都需要进行握手（handshake）。当客户端和服务器完成TCP三次握手建立TCP连接之后，就开始进行TLS的握手过程，具体的流程如下：</p>
<ol>
<li><p>首先由客户端发送Client Hello 消息到服务器，消息中主要包含了客户端支持的<code>ciphersuites</code>, TLS版本信息和客户端随机数，此时是<strong>明文传输</strong></p>
</li>
<li><p>服务器接收到消息后，返回自己支持的<code>ciphersuites</code>， TLS 版本，自己的数字证书和服务器端生成的随机数。<strong>注意此时是明文传输</strong></p>
</li>
<li><p>客户端开始验证数字证书，可能会不断往上追溯 CA、CA 的 CA、CA 的 CA 的 CA，<strong>直到一个授信的 CA</strong>。验证完证书之后生成一个新的<code>pre-master key</code>，再使用证书中的公钥来对<code>pre-master key</code>进行加密，然后发送给服务器。<strong>注意此时是非对称加密传输</strong></p>
</li>
<li><p>服务器接收到客户端发送过来的非对称加密的密文，使用自己的私钥进行解密，获得了<code>pre-master key</code>。<strong>注意此时是非对称加密传输</strong></p>
</li>
</ol>
<p>到这里为止，服务器和客户端都有三组数字，<strong>分别是客户端的随机数、服务器的随机数和pre-master key。</strong>其中由于客户端的随机数和服务器的随机数都是使用明文传输，所以这两个数字是有被暴露的风险的，但是由于pre-master key是使用非对称加密传输，十分安全，所以将这三者结合，使用之前协商好的特定的算法就可以生成一个密钥，<strong>这个密钥称为shared secert</strong>。也就是<strong>之后用来对称加密的密钥</strong>。</p>
<ol>
<li><p>客户端在计算出对称加密的密钥之后，使用该密钥进行对称加密通信，告知服务器之后都使用该密钥进行对称加密。注意此时是对称加密传输</p>
</li>
<li><p>服务器接收到密文后，使用之前计算出的密钥来进行对称解密，解密成功之后，再使用该密钥进行对称加密通信。告知客户端密钥确认无误，可以使用该密钥进行通信。注意此时是对称加密传输</p>
</li>
<li><p>至此，整个TLS的握手过程完整，之后就可以开始对称加密的通信了。</p>
</li>
</ol>
<p><img src="/2022/08/24/HTTPS%E5%AD%A6%E4%B9%A0/14.png"></p>
<p>疑问：既然</p>
<h3 id="TLS1-2"><a href="#TLS1-2" class="headerlink" title="TLS1.2"></a>TLS1.2</h3><p>纵观整个SSL/TLS协议的发展史，我们可以发现整个SSL/TLS协议就是不断地填坑的一个过程，不断地对旧版本的协议中的各种漏洞进行修补迭代更新，然后发布新的版本，直到TLSv1.2版本才算是一个不错的可用的加密协议版本。即便如此，对应TLSv1.2来说还是有着太多的历史包袱和兼容性的问题，尽管在功能实现上的漏洞可以通过补丁来进行修补，但是在协议设计之初就存在的问题是没有办法修复的，只能推倒重来，于是就出现了后面的TLSv1.3。这里我们先了解一下TLSv1.2版本中的一些主要的问题：</p>
<h5 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h5><p>作为一个提供安全通信的协议，安全问题是首要的也是致命的问题。TLS发展到1.2以来，已经被很多机构和学者曝出有各种各样的安全漏洞，包括密钥交换算法（key exchange algorithms）、加密套件（ciphersuites）和数字签名（digital signatures）各个方面都存在安全问题，很多都是由于历史原因兼容问题而遗留下来的问题。</p>
<p>还有一些则是设计协议本身就存在的问题如TLS重新协议（renegotiation）可以让心怀不轨的人将高版本的TLS协议重新协商降级到低版本的不安全的协议然后进行攻击。</p>
<p>或者是SNI的不加密问题，TLS1.2及之前的协议都不SNI进行加密，这也存在了很大的风险。</p>
<h5 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h5><p>互联网上一直存在着加密传输对性能有很大损耗的说法，实际上了解了上面的TLSv1.2握手过程之后，我们可以知道加密传输对性能确实有损耗，但是远没有到很多人鼓吹的那么严重的程度。而且在后面也加入了很多诸如OCSP、HSTS等技术来提高其性能表现，但是即便如此，整个TLSv1.2的握手过程也需要2-RTT，也就是在客户端和服务器之间来回两次才能顺利建立TLS传输，这还是在一切都进行顺利的情况下。</p>
<h3 id="TLS1-3"><a href="#TLS1-3" class="headerlink" title="TLS1.3"></a>TLS1.3</h3><p>TLSv1.3是TLS协议更新中变化非常大的一个版本，加入了许多新的特性和性能优化，并且不完全前向兼容，因此也有些人认为应该称为TLSv2.0，不过最后还是命名为TLSv1.3。</p>
<p>针对TLSv1.2中存在的安全和性能问题，TLSv1.3在设计的时候就放弃了前向兼容性，不再对之前的版本进行兼容，同时禁用了大量不安全的算法，使用了少量安全的算法来设计协议，这样的好处就是可以简化握手过程中的操作，使得握手过程从2-RTT变为1-RTT，同时有效提高安全性和性能。</p>
<h4 id="TLS1-3和TLS1-2的主要不同"><a href="#TLS1-3和TLS1-2的主要不同" class="headerlink" title="TLS1.3和TLS1.2的主要不同"></a>TLS1.3和TLS1.2的主要不同</h4><ul>
<li>部分新的密码套件（ciphersuite）只能在TLSv1.3中工作，并且TLSv1.3不支持之前在TLSv1.2前用的旧的密码套件ciphersuites。也就是说如果需要使用TLSv1.3就必须要添加新的只能在TLSv1.3中使用的密码套件</li>
<li>新的密码套件（ciphersuites）和之前的密码套件定义不同，并不需要指定对应的证书类型(e.g. RSA, DSA, ECDSA) 或者是密钥交换机制 (e.g. DHE or ECHDE)</li>
<li>TLSv1.3不再支持DSA证书</li>
<li>TLS1.3中不再支持重新协商（Renegotiation），即不可能像TLSv1.2之前那样通过重新协商来回退到更早的更不安全的版本</li>
<li>TLS1.3中更多的握手过程都被加密了（Server Hello之后都会进行加密）</li>
<li>TLSv1.3支持更多的的消息类型，即对自定义的扩展API和认证传输有更好的扩展性<br>客户端在TLS握手阶段发送ClientHello数据包的时候需要提供支持的密码套件（ciphersuite）和密钥共享（key_share）从而提高速度，如果client发送的keyshare类型是server不支持，那就不是1-RTT。<br>sessions会话在TLS握手完成之后才会建立，所以在session和TLS握手之间可能会有空隙（即不是连续的）</li>
</ul>
<h4 id="TLS1-3中的密钥交换算法"><a href="#TLS1-3中的密钥交换算法" class="headerlink" title="TLS1.3中的密钥交换算法"></a>TLS1.3中的密钥交换算法</h4><p>TLS 1.3的核心宗旨是简单性。在新版本中，除去了Diffie-Hellman（DH）密钥交换以外的所有密钥交换算法。TLS 1.3还定义了一组经过测试的DH参数，无需与服务器协商参数。由于只有一个密钥交换算法（具有内置参数）和少数支持的密码，因此设置TLS 1.3通道所需的绝对带宽比早期版本要少得多。</p>
<p>我们来看DH算法交换密钥的步骤。假设客户端和服务器双方需要传递密钥，他们之间可以这么做：</p>
<ol>
<li>客户端首选选择一个素数p，例如509; 底数g，任选，例如5 ; 随机数a，例如123; 然后计算A=$g^a \mod p$，结果是215，然后，客户端发送p＝509，g=5，A=215给服务器；</li>
<li>服务器收到后，也选择一个随机数b，例如，456，然后计算$B=g^b \mod p$，结果是181，服务器再同时计算$s=A^b \mod p$，结果是121；</li>
<li>服务器把计算的B=181发给客户端，客户端计算$s＝B^a \mod p$的余数，计算结果与服务器算出的结果一样，都是121。</li>
</ol>
<p>所以最终双方协商出的密钥s是121。注意到这个密钥s并没有在网络上传输。而通过网络传输的p，g，A和B是无法推算出s的，因为实际算法选择的素数是非常大的。所以，更确切地说，DH算法是一个密钥协商算法，双方最终协商出一个共同的密钥，而这个密钥不会通过网络传输。</p>
<h4 id="TLS1-3握手过程"><a href="#TLS1-3握手过程" class="headerlink" title="TLS1.3握手过程"></a>TLS1.3握手过程</h4><p>整个流程的目的和TLS 1.2是相似的，TLS握手过程就是为了让双方能够得到一个安全的可用于对称加密的密钥。和之前不一样的就是，无非就是客户端提前把所有的公钥计算了一遍，发给server，server再挑选。</p>
<p><img src="/2022/08/24/HTTPS%E5%AD%A6%E4%B9%A0/15.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/08/23/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/23/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">Java多线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-23 14:48:52 / Modified: 14:48:54" itemprop="dateCreated datePublished" datetime="2022-08-23T14:48:52+08:00">2022-08-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/08/23/%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%AE%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/23/%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%AE%AF/" class="post-title-link" itemprop="url">进程通讯</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-23 14:42:18 / Modified: 22:44:08" itemprop="dateCreated datePublished" datetime="2022-08-23T14:42:18+08:00">2022-08-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="进程通讯"><a href="#进程通讯" class="headerlink" title="进程通讯"></a>进程通讯</h1><p>参考博客：<a href="https://www.jianshu.com/p/c1015f5ffa74" target="_blank" rel="noopener">https://www.jianshu.com/p/c1015f5ffa74</a></p>
<h2 id="进程间通信的概念"><a href="#进程间通信的概念" class="headerlink" title="进程间通信的概念"></a>进程间通信的概念</h2><p>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据<strong>必须通过内核</strong>，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为<strong>进程间通信（IPC，InterProcess Communication）</strong></p>
<h2 id="进程间通信的7种方式"><a href="#进程间通信的7种方式" class="headerlink" title="进程间通信的7种方式"></a>进程间通信的7种方式</h2><h3 id="管道-匿名管道-pipe"><a href="#管道-匿名管道-pipe" class="headerlink" title="管道/匿名管道(pipe)"></a>管道/匿名管道(pipe)</h3><p>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。</p>
<p>只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);</p>
<p>单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。</p>
<p>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</p>
<p><img src="/2022/08/23/%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%AE%AF/1.jpg" style="zoom:150%;"></p>
<p><strong>管道的实质：</strong><br>管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。</p>
<p>该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。</p>
<p> 当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。</p>
<p><strong>管道的局限：</strong><br> 管道的主要局限性正体现在它的特点上：</p>
<ul>
<li>只支持单向数据流；</li>
<li>只能用于具有亲缘关系的进程之间；</li>
<li>没有名字；</li>
<li>管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）；</li>
<li>管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等；</li>
</ul>
<h4 id="管道实践-C"><a href="#管道实践-C" class="headerlink" title="管道实践(C++)"></a>管道实践(C++)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fds[<span class="number">2</span>]; 		<span class="comment">//2个元素的int类型的数组，filedes[0]读端、filedes[1]写端。</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>]=&#123;&#125;;<span class="comment">// 缓冲区</span></span><br><span class="line">    <span class="keyword">if</span>(pipe(fds)==<span class="number">-1</span>) <span class="comment">//创建管道</span></span><br><span class="line">        perror(<span class="string">"pipe"</span>),<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf,<span class="number">100</span>,<span class="built_in">stdin</span>)) <span class="comment">//把输入先读入buf当中</span></span><br><span class="line">    &#123;</span><br><span class="line">        len = <span class="built_in">strlen</span>(buf);							<span class="comment">//求出buf中字符串的长度</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">write</span>(fds[<span class="number">1</span>],buf,len)==<span class="number">-1</span>) 	<span class="comment">//把内容写进管道</span></span><br><span class="line">            perror(<span class="string">"write"</span>),<span class="built_in">exit</span>(<span class="number">1</span>);		</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0x00</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">100</span>);<span class="comment">//把buf缓存初始化掉</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">read</span>(fds[<span class="number">0</span>],buf,len)==<span class="number">-1</span>) 		<span class="comment">//再从管道里面读取内容到数组中</span></span><br><span class="line">            perror(<span class="string">"read"</span>),<span class="built_in">exit</span>(<span class="number">1</span>);			</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">write</span>(STDOUT_FILENO,buf,len)==<span class="number">-1</span>) 				<span class="comment">//把从管道里读出的内容写到标准输出</span></span><br><span class="line">            perror(<span class="string">"write"</span>),<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父子进程之间的管道通讯：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];<span class="comment">//定义管道的读、写端文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* str = <span class="string">"hello pipe\n"</span>;<span class="comment">//指定写数据</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];<span class="comment">//定义接收缓冲区</span></span><br><span class="line">    ret = pipe(fd);<span class="comment">//调用pipe()函数就已将管道打开</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"pipe error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid = fork();	<span class="comment">// fork子进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)<span class="comment">//父进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">write</span>(fd[<span class="number">1</span>],str,<span class="built_in">strlen</span>(str));<span class="comment">//写到管道中</span></span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)<span class="comment">//子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">1</span>]);</span><br><span class="line">        ret = <span class="built_in">read</span>(fd[<span class="number">0</span>],buf,<span class="keyword">sizeof</span>(buf));<span class="comment">//从管道中的读，返回读到的字节数</span></span><br><span class="line">        <span class="built_in">write</span>(STDOUT_FILENO,buf,ret);<span class="comment">//写到标准输出</span></span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有名管道-FIFO"><a href="#有名管道-FIFO" class="headerlink" title="有名管道(FIFO)"></a>有名管道(FIFO)</h3><p>匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道(FIFO)。</p>
<p>有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，<strong>以有名管道的文件形式存在于文件系统中</strong>，这样，<strong>即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信</strong>，因此，通过有名管道不相关的进程也能交换数据。值的注意的是，有名管道严格遵循<strong>先进先出(first in first out)</strong>,对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如<code>lseek()</code>等文件定位操作。<strong>有名管道的名字存在于文件系统中，内容存放在内存中。</strong></p>
<p><strong>匿名管道和有名管道总结：</strong><br> （1）管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。<br> （2）匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。<br> （3）<strong>无名管道阻塞问题：</strong>无名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。<br> （4）<strong>有名管道阻塞问题：</strong>有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。</p>
<h3 id="信号-Signal"><a href="#信号-Signal" class="headerlink" title="信号(Signal)"></a><strong>信号(Signal)</strong></h3><ul>
<li>信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。</li>
<li>如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。</li>
<li>如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。</li>
</ul>
<h4 id="Linux系统中常用信号："><a href="#Linux系统中常用信号：" class="headerlink" title="Linux系统中常用信号："></a><strong>Linux系统中常用信号：</strong></h4><p> （1）<strong>SIGHUP：</strong>用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。<br> （2）<strong>SIGINT：</strong>程序终止信号。程序运行过程中，按<code>Ctrl+C</code>键将产生该信号。<br> （3）<strong>SIGQUIT：</strong>程序退出信号。程序运行过程中，按<code>Ctrl+\\</code>键将产生该信号。<br> （4）<strong>SIGBUS和SIGSEGV：</strong>进程访问非法地址。<br> （5）<strong>SIGFPE：</strong>运算中出现致命错误，如除零操作、数据溢出等。<br> （6）<strong>SIGKILL：</strong>用户终止进程执行信号。shell下执行<code>kill -9</code>发送该信号。<br> （7）<strong>SIGTERM：</strong>结束进程信号。shell下执行<code>kill 进程pid</code>发送该信号。<br> （8）<strong>SIGALRM：</strong>定时器信号。<br> （9）<strong>SIGCLD：</strong>子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。</p>
<h4 id="信号来源"><a href="#信号来源" class="headerlink" title="信号来源"></a>信号来源</h4><p> 信号是软件层次上对中断机制的一种模拟，是一种异步通信方式，信号可以在用户空间进程和内核之间直接交互，内核可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件主要有两个来源：</p>
<ul>
<li>硬件来源：用户按键输入<code>Ctrl+C</code>退出、硬件异常如无效的存储访问等。</li>
<li>软件终止：终止进程信号、其他进程调用kill函数、软件异常产生信号。</li>
</ul>
<h4 id="信号生命周期和处理流程"><a href="#信号生命周期和处理流程" class="headerlink" title="信号生命周期和处理流程"></a>信号生命周期和处理流程</h4><ol>
<li><p>信号被某个进程产生，并设置此信号传递的对象（一般为对应进程的pid），然后传递给操作系统；</p>
</li>
<li><p>操作系统根据接收进程的设置（是否阻塞）而选择性的发送给接收者，如果接收者阻塞该信号（且该信号是可以阻塞的），操作系统将暂时保留该信号，而不传递，直到该进程解除了对此信号的阻塞（如果对应进程已经退出，则丢弃此信号），如果对应进程没有阻塞，操作系统将传递此信号。</p>
</li>
<li>目的进程接收到此信号后，将根据当前进程对此信号设置的预处理方式，暂时终止当前代码的执行，保护上下文（主要包括临时寄存器数据，当前程序位置以及当前CPU的状态）、转而执行中断服务程序，执行完成后在回复到中断的位置。当然，对于抢占式内核，在中断返回时还将引发新的调度。</li>
</ol>
<p><img src="/2022/08/23/%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%AE%AF/2.jpg" style="zoom:150%;"></p>
<h4 id="信号实践-C"><a href="#信号实践-C" class="headerlink" title="信号实践(C++)"></a>信号实践(C++)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> childpid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    childpid = fork();  <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == childpid)  <span class="comment">//判断是否创建失败</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fork()"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> == childpid)<span class="comment">// 子进程创建成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"In child process"</span>);</span><br><span class="line">        sleep(<span class="number">1000</span>); <span class="comment">//让子进程睡眠，以便父进程查看其行为</span></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == (waitpid(childpid, &amp;status, WNOHANG))) <span class="comment">//判断子进程是否已经退出</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">//发送SIGKILL给子进程，要求其停止运行。成功返回0，不成功就返回-1；</span></span><br><span class="line">            retval = kill(childpid, SIGKILL);  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (retval)   <span class="comment">//判断是否发生信号，</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"kill failed."</span>);</span><br><span class="line">                perror(<span class="string">"kill"</span>);</span><br><span class="line">                waitpid(childpid, &amp;status, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d killed\n"</span>, childpid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><code>55382 killed</code></p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p><strong>消息(Message)队列</strong></p>
<ul>
<li>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。</li>
<li>与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。</li>
<li>另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。</li>
</ul>
<p><strong>消息队列特点总结：</strong></p>
<ol>
<li>消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识.</li>
<li>消息队列允许一个或多个进程向它写入与读取消息. </li>
<li>管道和消息队列的通信数据都是先进先出的原则。</li>
<li>消息队列可以<strong>实现消息的随机查询</strong>,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势。</li>
<li>消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺。</li>
<li>目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，System V消息队列目前被大量使用。System V消息队列是随内核持续的，只有在内核重起或者人工删除时，该消息队列才会被删除。</li>
</ol>
<h3 id="共享内存-share-memory"><a href="#共享内存-share-memory" class="headerlink" title="共享内存(share memory)"></a>共享内存(share memory)</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>在<a href="https://jasonxqh.github.io/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/">CSAPP虚拟内存</a>这篇博客中，我们学习到虚拟内存可以简化共享。例如，每个进程必须调用相同的<strong>操作系统内核代码</strong>，而每个C 程序都会调用C 标准库中的程序，比如 <code>printf()</code> . 操作系统通过<strong>将不同进程中适当的虚拟页面映射到相同的物理页面</strong>，从而安排<strong>多个进程共享这部分代码的一个副本</strong>，而不是在每个进程中都包括单独的内核和C标准库的副本</p>
<p>那么，将共享内存用来进程之间的通讯，以传送数据为目的，显然这是进程通信中速度最快的一种方式（例：进程一向共享内存传送数据，进程二能够立马看见传送的数据，少了若干次拷贝）</p>
<p>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率</p>
<p>共享内存生命周期跟随内核，共享没有自带同步或互斥，由用户来维护共享内存。因此，信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问</p>
<h4 id="共享内存的优缺点"><a href="#共享内存的优缺点" class="headerlink" title="共享内存的优缺点"></a>共享内存的优缺点</h4><p>1、优点：我们可以看到使用共享内存进行进程间的通信真的是非常方便，而且函数的接口也简单，数据的共享还使进程间的数据不用传送，而是直接访问内存，也加快了程序的效率。同时，它也不像匿名管道那样要求通信的进程有一定的父子关系。</p>
<p>2、缺点：共享内存没有提供同步的机制，这使得我们在使用共享内存进行进程间通信时，往往要借助其他的手段来进行进程间的同步工作。(如信号量)</p>
<h4 id="共享内存接口"><a href="#共享内存接口" class="headerlink" title="共享内存接口"></a>共享内存接口</h4><p>在C++中，有关于和共享内存的库是<code>#include &lt;sys/shm.h&gt;</code>，里面有对共享内存的方法：</p>
<h5 id="共享内存的创建："><a href="#共享内存的创建：" class="headerlink" title="共享内存的创建："></a>共享内存的创建：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="comment">//如果共享内存不存在，创建共享内存，如果存在就打开共享内存</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line"><span class="comment">//返回值：成功返回共享内存的标识符，失败返回-1</span></span><br></pre></td></tr></table></figure>
<p>参数：共享内存的关键字key</p>
<blockquote>
<p>共享内存的标识符，获取方法和消息队列 key的方法一致，也可认为key就是共享内存的名字</p>
</blockquote>
<p>参数：共享内存的大小size：</p>
<blockquote>
<p>由你自己指定，一般指定为4k的倍数（内存4k为一页）</p>
</blockquote>
<p>参数：共享内存的访问权限shmflg</p>
<blockquote>
<p>共享内存的权限，它与文件的访问权限一样<br><code>IPC_CREAT</code>:创建新的共享内存。</p>
<p><code>IPC_EXCL</code>:与IPC_CREAT一同使用，表示如果要创建的共享内存已经存在，则返回错误。 </p>
<p><code>IPC_NOWAIT</code>:读写共享内存要求无法满足时，不阻塞</p>
<p>0：如果是打开文件，即文件已存在，写0</p>
</blockquote>
<h5 id="共享内存的挂载"><a href="#共享内存的挂载" class="headerlink" title="共享内存的挂载"></a>共享内存的挂载</h5><p>共享内存的挂载</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="comment">//将共享内存链接到进程地址空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line"><span class="comment">//返回值：失败返回NULL,成功返回一个指针，为地址空间的虚拟地址，并且连接数加1（nattch）</span></span><br></pre></td></tr></table></figure>
<p>参数：共享内存的标识符shmid</p>
<blockquote>
<p>shmget的返回值</p>
</blockquote>
<p>参数：指定连接进程地址空间的地址shmaddr</p>
<blockquote>
<p>共享存储段连接到调用进程的哪个地址上与addr参数以及在flag中是否指定<code>SHM_RND</code>位有关</p>
<p>如果addr为0，则此段连接到由内核选择的第一个可用地址上。这是推荐的使用方式。</p>
<p>如果addr非0，并且没有指定SHM_RND，则此段连接到addr所指定的地址上。</p>
<p>如果addr非0,并且指定了SHM_ RND，则此段连接到（shmaddr -（shmaddr % SHMLBA））所表示的地址上。SHM_RND命令的意思是取整。SHMLBA的意思是低边界地址倍数，它总是2的乘方。该算式是将地址向下取最近1个SHMLBA的倍数。</p>
<p>注：除非只计划在一种硬件上运行应用程序（这在当今是不大可能的），否则不应指定共享段所连接到的地址。所以一般应指定addr为0，以便由内核选择地址</p>
</blockquote>
<p>参数：共享内存的权限shmflg</p>
<blockquote>
<p>shmflg = SHM_RDONLY，表示连接操作作用来只读共享内存</p>
</blockquote>
<h5 id="共享内存的卸载"><a href="#共享内存的卸载" class="headerlink" title="共享内存的卸载"></a>共享内存的卸载</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="comment">//将共享内存与当前连接进程脱离</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* shmaddr)</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回值：成功返回0,失败返回-1</span></span></span><br><span class="line"><span class="function"><span class="comment">//参数：由shmat返回的指针</span></span></span><br><span class="line"><span class="function"><span class="comment">//注意：将共享内存与进程脱离不等于删除共享内存</span></span></span><br></pre></td></tr></table></figure>
<h5 id="共享内存的控制"><a href="#共享内存的控制" class="headerlink" title="共享内存的控制"></a>共享内存的控制</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="comment">//shmctl系统调用对shmid标识的共享内存执行cmd操作</span></span><br><span class="line"><span class="comment">//返回值：成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数：共享内存的表示符shmid</p>
<blockquote>
<p>shmget的返回值</p>
</blockquote>
<p>参数：将要采取的操作cmd</p>
<blockquote>
<p>选项 说明<br><code>IPC_STAT</code> 把shmid_ds结构中的数据设置为共享内存的当前关联值</p>
<p><code>IPC_SET</code> 在进程有足够权限的前提下，把共享内存的当前关联值设置为shmid_ds数 据结构中给出的值</p>
<p><code>IPC_RMID</code> 删除共享内存</p>
</blockquote>
<p>参数：保存共享内存的模式状态和访问权限的数据结构buf</p>
<blockquote>
<p>共享内存的一些属性，填NULL</p>
</blockquote>
<h4 id="封装API"><a href="#封装API" class="headerlink" title="封装API"></a>封装API</h4><p>我们要利用它封装一些自己的API，让其对用户操作友好</p>
<ul>
<li><code>int commShm(int size,int flags)</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">commShm</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">int</span> flags)</span> <span class="comment">//创建共享内存</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="comment">//利用 ftok获取key值，用来申请共享内存</span></span><br><span class="line">    <span class="keyword">key_t</span> key = ftok(PATHNAME, PROJ_ID);</span><br><span class="line">    <span class="keyword">if</span> (key &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"ftok"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(key, <span class="built_in">size</span>, flags);</span><br><span class="line">    <span class="keyword">if</span> (shmid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"shmget"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shmid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>int createShm (int size)</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int createShm(int size)</span><br><span class="line">&#123;</span><br><span class="line">    return commShm(size, IPC_CREAT | IPC_EXCL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>int getShm(int size)//获取共享内存</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getShm</span><span class="params">(<span class="keyword">int</span> size)</span><span class="comment">//获取共享内存</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> commShm(size, IPC_CREAT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>int destoryShm(int shmid)</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">destoryShm</span><span class="params">(<span class="keyword">int</span> shmid)</span> <span class="comment">//销毁共享内存</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"shmctl"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="server进程"><a href="#server进程" class="headerlink" title="server进程"></a>server进程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"comm.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid = createShm(<span class="number">4096</span>);                <span class="comment">//创建共享内存</span></span><br><span class="line">    <span class="keyword">char</span> *addr = (<span class="keyword">char</span> *)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">//将共享内存进行挂接</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt; <span class="number">26</span>)</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="comment">//每次都输出 共享内存中的数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"client：%s\n"</span>, addr);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    shmdt(addr); <span class="comment">//删除共享内存</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    destoryShm(shmid);<span class="comment">//卸载共享内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="client进程"><a href="#client进程" class="headerlink" title="client进程"></a>client进程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"comm.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> shmid = getShm(<span class="number">0</span>);                      <span class="comment">//创建共享内存</span></span><br><span class="line">    <span class="keyword">char</span> *addr = (<span class="keyword">char</span> *)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">//将共享内存进行挂接</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">26</span>)</span><br><span class="line">    &#123;</span><br><span class="line">  			addr[i] = <span class="string">'A'</span>+i;</span><br><span class="line">        i++;</span><br><span class="line">        addr[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"writing to shared memory: %s\n"</span>, addr);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    shmdt(addr); <span class="comment">//删除共享内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后如下：</p>
<p><img src="/2022/08/23/%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%AE%AF/3.gif" style="zoom:150%;"></p>
<p>在进程运行期间，我们通过<code>ipcs -m</code>观察挂载的共享内存，如下所示<br><img src="/2022/08/23/%E8%BF%9B%E7%A8%8B%E9%80%9A%E8%AE%AF/4.png" style="zoom:150%;"></p>
<ul>
<li>这块共想内存的拥有者是root</li>
<li>大小为4096byte</li>
<li>当前连接了两个进程</li>
</ul>
<h3 id="信号量-semaphore"><a href="#信号量-semaphore" class="headerlink" title="信号量(semaphore)"></a><strong>信号量(semaphore)</strong></h3><p> 信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。<br> 为了获得共享资源，进程需要执行下列操作：</p>
<ol>
<li><strong>创建一个信号量</strong>：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。</li>
<li><strong>等待一个信号量</strong>：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。</li>
<li><strong>挂出一个信号量</strong>：该操作将信号量的值加1，也称为V操作。</li>
</ol>
<p>为了正确地实现信号量，信号量值的测试及减1操作应当是原子操作。为此，信号量通常是在内核中实现的。Linux环境中，有三种类型：<strong>Posix（<a href="https://link.jianshu.com?t=http://baike.baidu.com/link?url=hYEo6ngm9MlqsQHT3h28baIDxEooeSPX6wr_FdGF-F8mf7wDp2xJWIDtQWGEDxthtPNiJtlsw460g1_N0txJYa" target="_blank" rel="noopener">可移植性操作系统接口</a>）有名信号量（使用Posix IPC名字标识）</strong>、<strong>Posix基于内存的信号量（存放在共享内存区中）</strong>、<strong>System V信号量（在内核中维护）</strong>。这三种信号量都可用于进程间或线程间的同步。</p>
<blockquote>
<p><strong>信号量与普通整型变量的区别：</strong><br> （1）信号量是非负整型变量，除了初始化之外，它只能通过两个标准原子操作：wait(semap) , signal(semap) ; 来进行访问；<br> （2）操作也被成为PV原语（P来源于荷兰语proberen”测试”，V来源于荷兰语verhogen”增加”，P表示通过的意思，V表示释放的意思），而普通整型变量则可以在任何语句块中被访问；</p>
<p><strong>信号量与互斥量之间的区别：</strong><br> （1）互斥量用于线程的互斥，信号量用于线程的同步。这是互斥量和信号量的根本区别，也就是互斥和同步之间的区别。<br> <strong>互斥：</strong>是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。<br> <strong>同步：</strong>是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。<br> 在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源<br> （2）互斥量值只能为0/1，信号量值可以为非负整数。<br> 也就是说，一个互斥量只能用于一个资源的互斥访问，它不能实现多个资源的多线程互斥问题。信号量可以实现多个同类资源的多线程互斥和同步。当信号量为单值信号量是，也可以完成一个资源的互斥访问。<br> （3）互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。</p>
</blockquote>
<h3 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字(socket)"></a><strong>套接字(socket)</strong></h3><p> 套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。 </p>
<p>套接字是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p>
<h4 id="套接字特性"><a href="#套接字特性" class="headerlink" title="套接字特性"></a>套接字特性</h4><p> 套接字的特性由3个属性确定，它们分别是：域、端口号、协议类型。</p>
<ol>
<li><p>套接字的域</p>
<p>它指定套接字通信中使用的网络介质，最常见的套接字域有两种：</p>
<p> <strong>一是AF_INET，它指的是Internet网络。</strong>当客户使用套接字进行跨网络的连接时，它就需要用到服务器计算机的IP地址和端口来指定一台联网机器上的某个特定服务，所以在使用socket作为通信的终点，服务器应用程序必须在开始通信之前绑定一个端口，服务器在指定的端口等待客户的连接。</p>
<p><strong>另一个域AF_UNIX，表示UNIX文件系统，</strong>它就是文件输入/输出，而它的地址就是文件名。</p>
</li>
<li><p><strong>套接字的端口号</strong></p>
<p>每一个基于TCP/IP网络通讯的程序(进程)都被赋予了唯一的端口和端口号，端口是一个信息缓冲区，用于保留Socket中的输入/输出信息，端口号是一个16位无符号整数，范围是0-65535，以区别主机上的每一个程序（端口号就像房屋中的房间号），低于256的端口号保留给标准应用程序，比如pop3的端口号就是110，每一个套接字都组合进了IP地址、端口，这样形成的整体就可以区别每一个套接字</p>
</li>
<li><p><strong>套接字协议类型</strong></p>
<p>因特网提供三种通信机制，</p>
<ul>
<li><strong>流套接字，</strong>流套接字在域中通过TCP/IP连接实现，同时也是AF_UNIX中常用的套接字类型。流套接字提供的是一个有序、可靠、双向字节流的连接，因此发送的数据可以确保不会丢失、重复或乱序到达，而且它还有一定的出错后重新发送的机制。</li>
<li><strong>数据报套接字，</strong>它不需要建立连接和维持一个连接，它们在域中通常是通过UDP/IP协议实现的。它对可以发送的数据的长度有限制，数据报作为一个单独的网络消息被传输,它可能会丢失、复制或错乱到达，UDP不是一个可靠的协议，但是它的速度比较高，因为它并一需要总是要建立和维持一个连接。</li>
<li><strong>原始套接字，</strong>原始套接字允许对较低层次的协议直接访问，比如IP、 ICMP协议，它常用于检验新的协议实现，或者访问现有服务中配置的新设备，因为RAW SOCKET可以自如地控制Windows下的多种协议，能够对网络底层的传输机制进行控制，所以可以应用原始套接字来操纵网络层和传输层应用。比如，我们可以通过RAW SOCKET来接收发向本机的ICMP、IGMP协议包，或者接收TCP/IP栈不能够处理的IP包，也可以用来发送一些自定包头或自定协议的IP包。网络监听技术很大程度上依赖于SOCKET_RAW。</li>
</ul>
</li>
</ol>
<h4 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h4><ol>
<li>首先服务器应用程序用系统调用socket来创建一个套接字，它是系统分配给该服务器进程的类似文件描述符的资源，它不能与其他的进程共享。</li>
<li>然后，服务器进程会给套接字起个名字，我们使用系统调用bind来给套接字命名。然后服务器进程就开始等待客户连接到这个套接字。</li>
<li>接下来，系统调用listen来创建一个队列并将其用于存放来自客户的进入连接。</li>
<li>最后，服务器通过系统调用accept来接受客户的连接。它会创建一个与原有的命名套接不同的新套接字，这个套接字只用于与这个特定客户端进行通信，而命名套接字（即原先的套接字）则被保留下来继续处理来自其他客户的连接（建立客户端和服务端的用于通信的流，进行通信）。</li>
</ol>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p> （1）客户应用程序首先调用socket来创建一个未命名的套接字，然后将服务器的命名套接字作为一个地址来调用connect与服务器建立连接。<br> （2）一旦连接建立，我们就可以像使用底层的文件描述符那样用套接字来实现双向数据的通信（通过流进行数据传输）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/08/22/Mysql%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/22/Mysql%E7%B4%A2%E5%BC%95/" class="post-title-link" itemprop="url">Mysql索引</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-08-22 14:48:15 / Modified: 17:03:12" itemprop="dateCreated datePublished" datetime="2022-08-22T14:48:15+08:00">2022-08-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Mysql索引"><a href="#Mysql索引" class="headerlink" title="Mysql索引"></a>Mysql索引</h1><p>参考博客 </p>
<ul>
<li><a href="https://www.cnblogs.com/zsql/p/13808417.html" target="_blank" rel="noopener">https://www.cnblogs.com/zsql/p/13808417.html</a></li>
<li><a href="https://juejin.cn/post/7031712626581356574" target="_blank" rel="noopener">https://juejin.cn/post/7031712626581356574</a></li>
</ul>
<h2 id="索引类别"><a href="#索引类别" class="headerlink" title="索引类别"></a>索引类别</h2><p>​        索引是一个单独的、存储在磁盘上的数据库结构，它们包含着对数据表里所有记录的引用指针。使用索引用于快速找出在某个或多个列中有一特定值的行，所有MySQL列类型都可以被索引，对相关列使用索引是提高查询操作速度的最佳途径。<br>　　MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。比如我们在查字典的时候，前面都有检索的拼音和偏旁、笔画等，然后找到对应字典页码，这样然后就打开字典的页数就可以知道我们要搜索的某一个key的全部值的信息了</p>
<p>​        创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)，而不是在select的字段中，实际上，索引也是一张“表”，该表保存了主键与索引字段，并指向实体表的记录，虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件，建立索引会占用磁盘空间的索引文件。说白了索引就是用来提高速度的，但是就需要维护索引造成资源的浪费，所以合理的创建索引是必要的。</p>
<p>在<a href="https://dev.mysql.com/doc/refman/8.0/en/create-index.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/create-index.html</a> 中，显示了不同数据库引擎不同类别索引的相关信息</p>
<h4 id="按照索引的特性分："><a href="#按照索引的特性分：" class="headerlink" title="按照索引的特性分："></a>按照索引的特性分：</h4><ol>
<li><p><strong>Primary Key（聚集索引）</strong>：InnoDB存储引擎的表一定存在主键（唯一非null），如果建表的时候没有指定主键，则会使用第一非空的唯一索引作为聚集索引，否则InnoDB会自动帮你创建一个不可见的、长度为6字节的row_id用来作为聚集索引。</p>
</li>
<li><p><strong>Unique（唯一索引）</strong>：索引列的值必须唯一，但允许有空值。若是组合索引，则列值的组合必须唯一。主键索引是一种特殊的唯一索引，不允许有空值</p>
</li>
<li><p><strong>Key（普通索引）</strong>：是MySQL中的基本索引类型，<strong>允许在定义索引的列中插入重复值和空值</strong></p>
</li>
<li><p><strong>FULLTEXT（全文索引）</strong>：全文索引类型为FULLTEXT，在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。<strong>全文索引可以在CHAR、VARCHAR或者TEXT类型的列上创建</strong></p>
</li>
<li><p><strong>SPATIAL（空间索引）</strong>：空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING和POLYGON。MySQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类似的语法创建空间索引。<strong>创建空间索引的列必须声明为NOT NULL</strong></p>
</li>
</ol>
<h4 id="按索引列的数量分："><a href="#按索引列的数量分：" class="headerlink" title="按索引列的数量分："></a>按索引列的数量分：</h4><ol>
<li><p><strong>单列索引</strong>：单列索引即一个索引只包含单个列</p>
</li>
<li><p><strong>联合索引</strong>：组合索引指在表的多个字段组合上创建的索引，只有在查询条件<strong>中使用了这些字段的左边字段</strong>时，索引才会被使用。使用组合索引时<strong>遵循最左前缀集合</strong></p>
</li>
</ol>
<h4 id="按数据结构分："><a href="#按数据结构分：" class="headerlink" title="按数据结构分："></a>按数据结构分：</h4><ol>
<li>B+ Tree索引</li>
<li>Hash索引</li>
<li>Full-text索引</li>
</ol>
<h4 id="按索引的物理存储方式分："><a href="#按索引的物理存储方式分：" class="headerlink" title="按索引的物理存储方式分："></a>按索引的物理存储方式分：</h4><ol>
<li><p><strong>聚簇索引(clustered index)</strong>：数据结构是B+树。数据文件是和（主键）索引绑在一起的，即索引 + 数据 = 整个表数据文件，通过主键索引到整个记录，必须要有主键，通过主键索引效率很高</p>
<ul>
<li><p>聚集索引的主键索引</p>
<p><img src="/2022/08/22/Mysql%E7%B4%A2%E5%BC%95/2.png"></p>
</li>
<li><p><strong>聚集索引的辅助索引(二级索引，secondary index)</strong>: 辅助索引需要两次查询，因为辅助索引是以建索引的字段为关键字索引到主键，所以需要两次，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。</p>
<p><img src="/2022/08/22/Mysql%E7%B4%A2%E5%BC%95/4.png"></p>
</li>
<li><p>我们看到，这个二级索引是建立在名字上的，那么如果要查询：<code>SELECT * FROM table WHERE name = ALICE</code>, 那么就先去根据二级索引的B+树上查找，得到Alice的主键是18；然后再根据18去主键上的B+树查找，最终可以找到该行的所有数据</p>
</li>
</ul>
</li>
</ol>
<ol>
<li><p><strong>非聚集索引</strong>：数据结构也是B+ 树，但是索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。也就是说：InnoDB的B+树<strong>主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值</strong>；而MyISAM的B+树主键索引和辅助索引的叶子节点<strong>都是数据文件的地址指针</strong>。</p>
<ul>
<li><p>非聚集索引的主键索引<br><img src="/2022/08/22/Mysql%E7%B4%A2%E5%BC%95/3.png"></p>
</li>
<li><p>非聚集索引的二级索引，对于MyISAM来说数据文件和索引文件则是分开的。</p>
<p><img src="/2022/08/22/Mysql%E7%B4%A2%E5%BC%95/5.png"></p>
</li>
</ul>
</li>
</ol>
<h3 id="Mysql中三种引擎的索引"><a href="#Mysql中三种引擎的索引" class="headerlink" title="Mysql中三种引擎的索引"></a>Mysql中三种引擎的索引</h3><p><img src="/2022/08/22/Mysql%E7%B4%A2%E5%BC%95/7.png"></p>
<p>我们看到，只有存放在内存中的表，才可以使用哈希索引，</p>
<h3 id="InnoDB-vs-Mysiam"><a href="#InnoDB-vs-Mysiam" class="headerlink" title="InnoDB vs Mysiam"></a>InnoDB vs Mysiam</h3><p><strong>聚集索引的优点：</strong></p>
<ul>
<li>可以把相关数据保存在一起，如：实现电子邮箱时，可以根据用户ID来聚集数据，这样只需要从磁盘读取少量的数据页就能获取某个用户全部邮件，如果没有使用聚集索引，则每封邮件都可能导致一次磁盘IO</li>
<li>数据访问更快，聚集索引将索引和数据保存在<strong>同一个btree</strong>中，因此从聚集索引中获取数据通常比在非聚集索引中查找要快</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值</li>
</ul>
<p><strong>聚集索引的缺点：</strong></p>
<ul>
<li>我们知道InnoDB使用的是聚集索引，根据聚集索引的特性，不建议使用过长的字段作为主键：因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。</li>
<li><p>此外，二级索引访问需要两次索引查找(回表)，而不是一次</p>
</li>
<li><p>用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。(这点在Mysiam中也是如此)</p>
</li>
<li>聚簇数据最大限度地提高了IO密集型应用的性能，但如果数据全部放在内存中，则访问的顺序就没有那么重要了，聚集索引也没有什么优势了</li>
<li>聚集索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候</li>
</ul>
<p><strong>非聚集索引的优点：</strong></p>
<p>我们知道，Myisam的主键索引的叶子节点只存放数据在物理磁盘上的指针，其他次索引也是一样的。因此，当存在大数据列(如<code>varchar(300)</code>),那么如果用聚簇索引会导致主键id排序比较慢，因为主键下存放着所有的数据列。但是Mysiam就不需要扫描数据列，可以直接进行排序。因此，非聚集索引在处理文本类型的数据时更有优势</p>
<h4 id="需要规避的设计"><a href="#需要规避的设计" class="headerlink" title="需要规避的设计"></a>需要规避的设计</h4><p><strong>不要使用UUID来作为聚集索引，否则性能会很糟糕</strong>。</p>
<ul>
<li>写入的目标页可能已经刷到磁盘上并从缓存中移除，或者是还没有被加载到缓存中，innodb在插入前不得不先找到并从磁盘读取目标页到内存中，这将导致大量的随机IO</li>
<li>因为写入是乱序的，innodb不得不频繁地做页分裂操作，以便为新的行分配空间，页分裂会导致移动大量数据，一次插入最少需要修改三个页不是一个页</li>
<li>由于频繁的页分裂，页会变得稀疏并被不规则地填充，所以最终数据会有碎片</li>
</ul>
<h2 id="索引的创建管理"><a href="#索引的创建管理" class="headerlink" title="索引的创建管理"></a>索引的创建管理</h2><h3 id="索引的创建原则"><a href="#索引的创建原则" class="headerlink" title="索引的创建原则"></a>索引的创建原则</h3><ol>
<li>索引并非越多越好，一个表中如果有大量的索引，不仅占用磁盘空间，而且会影响INSERT、DELETE、UPDATE等语句的性能，因为在表中的数据更改的同时，索引也会进行调整和更新</li>
<li>避免对经常更新的表进行过多的索引，并且索引中的列尽可能少。而对经常用于查询的字段应该创建索引，但要避免添加不必要的字段。</li>
<li>数据量小的表最好不要使用索引，由于数据较少，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。</li>
<li>在条件表达式中经常用到的不同值较多的列上建立索引，在不同值很少的列上不要建立索引。比如在学生表的“性别”字段上只有“男”与“女”两个不同值，因此就无须建立索引。如果建立索引，不但不会提高查询效率，反而会严重降低数据更新速度。</li>
<li>当唯一性是某种数据本身的特征时，指定唯一索引。使用唯一索引需能确保定义的列的数据完整性，以提高查询速度。</li>
<li>在频繁进行排序或分组（即进行group by或order by操作）的列上建立索引，如果待排序的列有多个，可以在这些列上建立组合索引。</li>
<li>搜索的索引列，不一定是所要选择的列。换句话说，<strong>最适合索引的列是出现在WHERE子句中的列</strong>，或连接子句中指定的列，而不是出现在SELECT关键字后的选择列表中的列。</li>
<li>使用短索引。如果对字符串列进行索引，应该指定一个前缀长度，只要有可能就应该这样做。例如，有一个CHAR(200)列，如果在前10个或20个字符内，多数值是唯一的，那么就不要对整个列进行索引。对前10个或20个字符进行索引能够节省大量索引空间，也可能会使查询更快。较小的索引涉及的磁盘 IO 较少，较短的值比较起来更快。更为重要的是，对于较短的键值，索引高速缓存中的块能容纳更多的键值，因此，MySQL 也可以在内存中容纳更多的值。这样就增加了找到行而不用读取索引中较多块的可能性。</li>
<li>利用最左前缀。在创建一个n列的索引时，实际是创建了MySQL可利用的n个索引。多列索引可起几个索引的作用，因为可利用索引中最左边的列集来匹配行。这样的列集称为最左前缀。</li>
<li>对于InnoDB存储引擎的表，记录默认会按照一定的顺序保存，如果有明确定义的主键，则按照主键顺序保存。如果没有主键，但是有唯一索引，那么就是按照唯一索引的顺序保存。如果既没有主键又没有唯一索引，那么表中会自动生成一个内部列，按照这个列的顺序保存。按照主键或者内部列进行的访问是最快的，所以<strong>InnoDB表尽量自己指定主键，当表中同时有几个列都是唯一的，都可以作为主键的时候，要选择最常作为访问条件的列作为主键，提高查询的效率</strong>。另外，还需要注意，InnoDB 表的普通索引都会保存主键的键值，所以主键要尽可能选择较短的数据类型，可以有效地减少索引的磁盘占用，提高索引的缓存效果</li>
</ol>
<h3 id="索引创建SQL"><a href="#索引创建SQL" class="headerlink" title="索引创建SQL"></a>索引创建SQL</h3><h2 id="索引的查询"><a href="#索引的查询" class="headerlink" title="索引的查询"></a>索引的查询</h2><p>平时设计的时候很多时候都会用到联合索引，一般很少用单个字段作为索引，这样可以让索引尽量少一些，避免磁盘占用太多，增删改性能太差。</p>
<p>加入有叫学生分数表，包含：班级，姓名，科目名称，成绩分数，一般我们都会根据学生的班级+姓名+科目来查询，这时候就需要建立二级索引KEY（class_name，student_name ，subject_nane  ）。这时候索引的数据结构图如下图所示：</p>
<p><img src="/2022/08/22/Mysql%E7%B4%A2%E5%BC%95/10.png"></p>
<p>那么，在查询过程中，会用到各式各样SELECT语句，它们对联合索引是怎么利用的呢？</p>
<h3 id="等值匹配"><a href="#等值匹配" class="headerlink" title="等值匹配"></a>等值匹配</h3><p>如果执行下面的语句：<code>SELECT * FROM student_scope where class_name= &#39;1班&#39; AND student_name =&#39;小明&#39; AND subject_nane =&#39;英语&#39;;</code></p>
<p>因为WHERE条件里的<strong>几个字段的名称和顺序跟建立的联合索引一模一样</strong>，此时就会等值匹配，从索引页依次往下查找，会定位到：1+小明+英语（id=100）这条数据，然后根据id 从聚簇索引(主键)中回表查询提取所有的字段信息。</p>
<p>注意，由于Mysql有优化器，因此，这边的列如果顺序打乱(但是数量还是要和索引一样)，还是可以走索引的</p>
<h3 id="最左侧列匹配"><a href="#最左侧列匹配" class="headerlink" title="最左侧列匹配"></a>最左侧列匹配</h3><p>例如联合索引：KEY（class_name，student_name ，subject_nane ），不一定在where条件中都要写3个字段来才会走索引查询，<strong>只要根据最左侧的部分字段来查询也要走索引</strong>，下面的3条SQL都会走索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student_scope <span class="keyword">where</span> class_name= <span class="string">'1班'</span>  </span><br><span class="line">																	<span class="keyword">AND</span> student_name =<span class="string">'小明'</span> </span><br><span class="line">																	<span class="keyword">AND</span> subject_nane  =<span class="string">'英语'</span>; <span class="comment"># 等值匹配</span></span><br><span class="line">																	</span><br><span class="line">																	</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student_scope <span class="keyword">where</span> class_name= <span class="string">'1班'</span> </span><br><span class="line">																	<span class="keyword">AND</span> student_name =<span class="string">'小明'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student_scope <span class="keyword">where</span> class_name= <span class="string">'1班'</span> ;</span><br></pre></td></tr></table></figure>
<p>此外，如果查询顺序和索引顺序不一样，也会采取最左侧来匹配，比如当执行下面的SQL，class_name字段会走索引，subject_name 就不会走索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student_scope <span class="keyword">where</span> class_name= <span class="string">'1班'</span> <span class="keyword">AND</span> subject_nane  =<span class="string">'英语'</span>;</span><br></pre></td></tr></table></figure>
<p>但是，如果WHERE后面第一个字段不是class_name，那就不符合最左匹配原则，完全不会用到索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student_scope <span class="keyword">where</span> student_name =<span class="string">'小明'</span> <span class="keyword">AND</span> subject_nane  =<span class="string">'英语'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student_scope <span class="keyword">where</span> subject_nane  =<span class="string">'英语'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a>最左前缀匹配原则</h3><p>在SQL查询的时候，我们经常会根据LIKE语法来查询，比如查询班级为1开头的数据，也可以用到索引，<strong>因为你的联合索引的B+树里，都是按照class_name排序的，所以你要是给出class_name的确定的最左前缀就是1</strong>，然后在后面给一个模糊匹配符号，那也是可以基于索引来查找。</p>
<p> 比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student_scope <span class="keyword">where</span> class_name <span class="keyword">like</span> <span class="string">'1%'</span>;</span><br></pre></td></tr></table></figure>
<p>但是执行以班结尾的数据就不会走到索引，因为不知道左侧前缀是多少，无法基于排序来查找。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student_scope <span class="keyword">where</span> class_name <span class="keyword">like</span> <span class="string">'%班'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="范围查找规则"><a href="#范围查找规则" class="headerlink" title="范围查找规则"></a>范围查找规则</h3><p>如果SQL查询的字段基于某个索引列采取范围查询，例如下面的SQL，也会走索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student_scope <span class="keyword">where</span> class_name &gt;= <span class="string">'1班'</span> <span class="keyword">AND</span> class_name &lt;<span class="string">'10班'</span>;</span><br></pre></td></tr></table></figure>
<p>但是当第一个字段是范围查询的时候，后面的第二个字段是没法走索引，例如下面的<strong>SQL</strong>,class_name 会走索引，后面的student_name 不会走索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student_scope <span class="keyword">where</span> class_name &gt;= <span class="string">'1班'</span> </span><br><span class="line">																	<span class="keyword">AND</span> class_name &lt;<span class="string">'10班'</span> </span><br><span class="line">																	<span class="keyword">AND</span> student_name =<span class="string">'小明'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="等值匹配-范围匹配规则"><a href="#等值匹配-范围匹配规则" class="headerlink" title="等值匹配+范围匹配规则"></a>等值匹配+范围匹配规则</h3><p>如果要使用下面的SQL进行查询的时候，此时class_name 会走索引，精准定位到一波数据，接下来这波被命中的数据，是按照student_name排序而来，这时候student_name &gt;= ‘小明’也会基于索引来查找，但是后面的student_name &lt;’王五’就不能用索引。</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> student_scope <span class="keyword">where</span> class_name = <span class="string">'1班'</span> </span><br><span class="line">														<span class="keyword">AND</span> student_name &gt;= <span class="string">'小明'</span> <span class="keyword">AND</span> student_name &lt;<span class="string">'王五'</span>;</span><br></pre></td></tr></table></figure>
<p>一般写SQL语句，都是用联合索引的最左侧的多个字段来进行等值匹配+范围搜索，或者是基于最左侧的部分字段来进行最左前缀模糊匹配，或者基于最左侧字段来进行范围搜索，这就要写符合规则的SQL语句，才能用上建立好的联合索引。</p>
<h3 id="排序如何使用索引"><a href="#排序如何使用索引" class="headerlink" title="排序如何使用索引"></a>排序如何使用索引</h3><p>当我们的SQL 语句需要使用ORDER BY语句进行排序的时候，似乎应该是通过索引快速筛选出来一波数据，接着把数据放入内存，或者放在一个临时磁盘文件里，然后通过排序算法按照ORDER BY后面的字段进行排序，然后把排序好的数据返回，当排序的数据量比较大的时候，就不能够用内存进行排序，就会基于磁盘文件来排序（filesort），这样的话就比较慢。 因为建立的联合索引是按照一定的顺序已经排序好的，如果order by 后面的排序字段能够命中联合索引的时候，就会走索引，例如下面的排序SQL就会走索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student_scope </span><br><span class="line">					ORDER BY class_name,student_name ,subject_nane</span><br><span class="line">					LIMIT 10;</span><br></pre></td></tr></table></figure>
<p>因此，在排序的时候尽量按照查询的联合索引去进行order by排序，这样就可以直接使用联合索引树里的数据有序性到索引数里直接按照字段的顺序获取所需要的数据。但是也有一定的限制，因为联合索引里的字段值在索引树里都是从小到大依次排列的 ，所以在ORDER BY里要不然就是每个字段后面什么都不加，直接就是ORDER BY xx1,xx2,xx3，要不然就都加DESC降序排列，就是ORDER BY xx1 DESC,xx2 DESC,xx3 DESC。 </p>
<p>当ORDER BY 排序字段<strong>既有升序，又有降序，那么是没法走索引进行排序</strong>，例如下面的SQL语句没法走索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student_scope</span><br><span class="line">				 ORDER BY class_name DESC,student_name ASC,subject_nane DESC </span><br><span class="line">				 LIMIT 10;</span><br></pre></td></tr></table></figure>
<h3 id="分组如何使用索引"><a href="#分组如何使用索引" class="headerlink" title="分组如何使用索引"></a>分组如何使用索引</h3><p>GROUP BY 语句使用索引的时候跟ORDER BY排序使用索引的规则一样，对于group by后的字段，最好也是按照联合索引里的最左侧的字段开始，按顺序排列开来，这样的话，就可以完美的运用上索引来直接提取一组一组的数据，然后针对每一组的数据执行聚合函数就可以。</p>
<h2 id="索引实现原理"><a href="#索引实现原理" class="headerlink" title="索引实现原理"></a>索引实现原理</h2><h3 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h3><p>上面我们说过，Primary Key、Unique和Key都是基于B+树实现的。首先，我们可以从<a href="https://jasonxqh.github.io/2020/06/17/B%E6%A0%91/">我的这篇博客</a>来了解B+树的数据结构。</p>
<p>那么数据库索引为什么要用 B+ 树而不用红黑树呢？</p>
<p>AVL 树和红黑树这些二叉树结构的数据结构可以达到最高的查询效率这是毋庸置疑的。</p>
<p>既然如此，那么数据库索引为什么不用 AVL 树或者红黑树呢？</p>
<p>这就牵扯到一个问题了，不考虑每种数据结构的前提条件而选择数据结构都是在耍流氓。</p>
<p>AVL 数和红黑树基本都是存储在内存中才会使用的数据结构，那磁盘中会有什么不同呢？</p>
<p>这就要牵扯到磁盘的存储原理了</p>
<p>操作系统读写磁盘的基本单位是扇区，而文件系统的基本单位是簇(Cluster)。</p>
<p>也就是说，磁盘读写有一个最少内容的限制，即使我们只需要这个簇上的一个字节的内容，我们也要含着泪把一整个簇上的内容读完。</p>
<p>那么，现在问题就来了</p>
<p>一个父节点只有 2 个子节点，并不能填满一个簇上的所有内容啊？那多余的内容岂不是要浪费了？我们怎么才能把浪费的这部分内容利用起来呢？哈哈，答案就是 B+ 树。</p>
<p>由于 B+ 树分支比二叉树更多，所以相同数量的内容，B+ 树的深度更浅，深度代表什么？代表磁盘 io 次数啊！数据库设计的时候 B+ 树有多少个分支都是按照磁盘一个簇上最多能放多少节点设计的啊！</p>
<p>所以，涉及到磁盘上查询的数据结构，一般都用 B+ 树啦。</p>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>哈希索引自然是基于哈希表实现，<strong>只有匹配所有列的查询才有效</strong>。对于每一行数据，存储引擎都会对所有索引列计算一个哈希码，哈希码是一个较小的值，不同键值的行计算出的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时保存指向每个数据行的指针。</p>
<p>如果多个列的哈希值相同(哈希冲突)，索引会以链表的方式存放多个记录指针到同一个哈希条目中去。</p>
<p><img src="/2022/08/22/Mysql%E7%B4%A2%E5%BC%95/6.png"></p>
<h4 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h4><ol>
<li>哈希索引只保存哈希码和指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过访问内存中的行速度非常快（因为是MEMORY引擎），所以对性能影响并不大</li>
<li>哈希索引数据并不是按照索引值顺序存储的，所以无法用于排序</li>
<li>哈希索引不支持部分索引列查找，因为哈希索引始终是使用索引列的全部内容来计算哈希码。 如，在数据列（A,B）上建立哈希索引，如果查询只有数据列A，则无法使用该哈希索引</li>
<li>哈希索引只支持等值比较查询，包括<code>=</code> ,<code>IN()</code> ,<code>&lt;=&gt;</code>  ;哈希索引<strong>不支持范围查询</strong>，如where price &gt; 100</li>
<li>哈希冲突（不同索引列会用相同的哈希码）会影响查询速度，此时需遍历索引中的行指针，<strong>逐行进行比较</strong>。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jason</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">439</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->




  















  

  

  

</body>
</html>
