<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=">


  <link rel="mask-icon" href="/images/logo.svg?v=" color="#222">














<meta property="og:type" content="website">
<meta property="og:title" content="Jason‘s Blog">
<meta property="og:url" content="https://jasonxqh.github.io/page/20/index.html">
<meta property="og:site_name" content="Jason‘s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '',
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    fancybox: false,
    tabs: ,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: 'undefined',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>







  <title>Jason‘s Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', '[object Object]', 'auto');
  ga('send', 'pageview');
</script>





<meta name="generator" content="Hexo 4.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">
  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
<a href="https://github.com/JasonXQH/JasonXQH.github.io" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jason‘s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/%20" rel="section">
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/09/27/git%E5%AD%A6%E4%B9%A02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/27/git%E5%AD%A6%E4%B9%A02/" itemprop="url">git学习2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-27T13:04:51+08:00">
                2020-09-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-10-01T21:03:22+08:00">
                2020-10-01
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="git-学习笔记2"><a href="#git-学习笔记2" class="headerlink" title="git 学习笔记2"></a>git 学习笔记2</h1><h2 id="Browsing-History"><a href="#Browsing-History" class="headerlink" title="Browsing History"></a>Browsing History</h2><p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/1.png"></p>
<h3 id="Getting-a-Repository"><a href="#Getting-a-Repository" class="headerlink" title="Getting a Repository"></a>Getting a Repository</h3><p>下载： 链接：<a href="https://pan.baidu.com/s/12cWs65AEMGUvw1pr6yRI3A" target="_blank" rel="noopener">https://pan.baidu.com/s/12cWs65AEMGUvw1pr6yRI3A</a> 提取码：dpyi</p>
<h3 id="Viewing-the-History"><a href="#Viewing-the-History" class="headerlink" title="Viewing the History"></a>Viewing the History</h3><p>我们之前知道了 <code>git log</code> 可以查询详细信息， <code>git log --oneline</code>  可以查看简略信息。那么如果 <code>git log --oneline --stat</code> 就可以看到不同的commit的信息和它所做的修改。</p>
<p>比如最后一次提交，一共有五个文件改变了，一共有7个地方增加了，4个地方减少了。其中audience.txt 有三处地方增加了，一处地方减少了，以此类推。</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/2.png" style="zoom:120%;"></p>
<p><code>git log stat</code> 可以展示每一个提交的详细信息</p>
<p><code>git log --patch</code>可以看到每一个提交具体改变的内容，如下：</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/3.png" style="zoom:100%;"></p>
<h3 id="Filtering-the-History"><a href="#Filtering-the-History" class="headerlink" title="Filtering the History"></a>Filtering the History</h3><p>当项目的时间越来越长，内容越来越多的时候，我们不会想查看所有的commit，我们只想筛选符合我们条件的commit</p>
<p>我们能通过作者名字、commit日期、commit message， 内容等来进行筛选。</p>
<p>比如我们想筛选倒数后三个commit，可以用 <code>git log --oneline -3</code></p>
<p>比如我们想筛选出作者为Mosh的commit，可以用 <code>git log --oneline --author =&quot;Mosh&quot;</code></p>
<p>又比如我想筛选出日期在 2020年8月17号之后的commit，可以用 <code>git log --oneline --after =&quot;2020-08-17&quot;</code> </p>
<p>甚至可以这么写<code>git log --oneline --after =&quot;one week ago&quot;</code>   </p>
<p>如果想要筛选 git message ,那么可以用命令 <code>git log --oneline --grep = &quot;GUI&quot;</code> 那么Git就会筛选出 messages中包含 “GUI” 的内容。注意，这是区分大小写的!</p>
<p>如果我们要查询commit中的内容，可以用 <code>git log --oneline -S&quot;OBJECTIVES&quot;</code> 来筛选出commit中对OBJECTIVES进行修改的commit</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/4.png" style="zoom: 150%;"></p>
<p>如果我们想看看哪些commit对一特定文件进行修改的，我们可以用命令 <code>git log --oneline toc.txt</code> （toc.txt是目标文件）</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/5.png" style="zoom: 150%;"></p>
<p>当我们想看看这些commit的增删时，我们要注意 —patch 不能写在文件名的后面，否则会发生歧义。要这样写</p>
<p> <code>git log --oneline --patch toc.txt</code></p>
<h3 id="Formatting-the-Log-Output"><a href="#Formatting-the-Log-Output" class="headerlink" title="Formatting the Log Output"></a>Formatting the Log Output</h3><p>我们可以对 log 日志进行一些格式化输出：比如 %Cgreen 就是把字体颜色换成绿色，%an 就代表 author，%Creset 就是恢复默认颜 色。%h 就是精简ID，%H是完整ID，  %cd代表日期。</p>
<p><code>git log --pretty=format:&quot;%Cgreen%an %Creset committed %h on %cd  &quot;</code></p>
<p>我们可以从 <a href="git-scm.com/docs/git-log">git官网 </a> 中查看格式化日志的其他占位符</p>
<h3 id="Aliases"><a href="#Aliases" class="headerlink" title="Aliases"></a>Aliases</h3><p>现在我们对一个log格式化字符串取一个别名.我们可以使用命令</p>
<p><code>git config --global alias.lg &quot;log --pretty=format:&#39;%an committed %h&#39;&quot;</code></p>
<p>用 <code>git config --global -e</code> 查看 gitconfig 我们会发现</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/6.png" style="zoom: 150%;"></p>
<p>现在我们就可以用 <code>git lg</code> 来显示我们自定义的日志了。</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/7.png" style="zoom: 150%;"></p>
<p>同理，我们可以设置一个unstage命令，将staging area中的数据还原。</p>
<p><code>git config --global alias.unstage &quot;restore --staged .&quot;</code></p>
<h3 id="Viewing-a-Commit"><a href="#Viewing-a-Commit" class="headerlink" title="Viewing a Commit"></a>Viewing a Commit</h3><p>在 <a href="https://jasonxqh.github.io/2020/09/23/git基础/">git基础</a> 中我们讲过 <code>git show HEAD~n-1</code> ,其实 它完整的用法是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">usage: git log [&lt;options&gt;] [&lt;revision-range&gt;] [[--] &lt;path&gt;...]</span><br><span class="line">   or: git show [&lt;options&gt;] &lt;object&gt;...</span><br></pre></td></tr></table></figure>
<p>如果我不想看有哪些改变，我想改这个文件在这个commit中的内容。我们可以<code>git show HEAD</code>+文件相对路径</p>
<p><code>git show HEAD~2:sections/creating-snapshots/staging-changes.txt</code></p>
<p>如果我们只想看看这个commit中有哪些文件做了修改，我们可以</p>
<p><code>git show HEAD~2 --name-only</code> 我们发现在sections中的creating-snapshots文件夹中的staging-changes.txt</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/8.png" style="zoom: 150%;"></p>
<p><code>`git show HEAD~2 --name-status</code> 则会显示在这个commit当中文件的增改 ,比如下面 <code>sections/creating-snapshots/staging-changes.txt</code> 是被修改的.</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/9.png" style="zoom: 140%;"></p>
<h3 id="Viewing-the-Changes-Across-Commits"><a href="#Viewing-the-Changes-Across-Commits" class="headerlink" title="Viewing the Changes Across Commits"></a>Viewing the Changes Across Commits</h3><p>现在我们来思考一个问题,怎么才能看多次 commits中文件做出的改变呢?</p>
<p>我们使用 diff 命令 </p>
<p><code>git diff HEAD~2 HEAD audience.txt</code> </p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/10.png" style="zoom: 140%;"></p>
<p>当然也可以 <code>git diff HEAD~2 HEAD --name-status</code>  来查看现在到过去两个版本之间变动过的文件</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/11.png" style="zoom: 140%;"></p>
<h3 id="Checking-Out-a-Commit"><a href="#Checking-Out-a-Commit" class="headerlink" title="Checking Out a Commit"></a>Checking Out a Commit</h3><p>有时候我们想要看看某一个commit下所有的project文件,那么我们就需要将commit 复制出来然后粘贴到working directory.</p>
<p>我们现在选一个ID来checkout <code>git checkout dad47ed</code> ,再次<code>git log --oneline</code> 后发现</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/12.png" style="zoom: 140%;"></p>
<p>这里我们要理解HEAD和Master这两个概念</p>
<p>我们的commits就像一条链一样,一环指着一环的,MASTER始终指着最后一个commit,HEAD指向Master,这有了之前最后一个commit是这样表示:</p>
<p><code>a642e12  (HEAD -&gt; master) Add header to all pages.</code></p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/15.png" style="zoom: 140%;"></p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/13.png" style="zoom: 140%;"></p>
<p>现在我们check out一个commit,其实就是移动了HEAD指针,现在HEAD指向我们的目标commit了.</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/14.png" style="zoom: 140%;"></p>
<p>但是这样需要注意, 现在不要再进行commit操作了,因为commit会加在head指向的地方,也就是说现在如果commit的话会发现变成了这样.</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/16.png" style="zoom: 140%;"></p>
<p>那么当我的HEAD再次指向MASTER之后,新来的commit将永远不会被访问到了.我们要避免这种情况发生</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/17.png" style="zoom: 140%;"></p>
<p>如果我们想要让HEAD再次指向MASTER,之间<code>git checkout master</code> 即可</p>
<h3 id="Finding-Bugs-Using-Bisect"><a href="#Finding-Bugs-Using-Bisect" class="headerlink" title="Finding Bugs Using Bisect"></a>Finding Bugs Using Bisect</h3><h3 id="Finding-Contributors-Using-Shortlog"><a href="#Finding-Contributors-Using-Shortlog" class="headerlink" title="Finding Contributors Using Shortlog"></a>Finding Contributors Using Shortlog</h3><p>有些时候我们需要找到所有commit过的人.我们可以使用命令</p>
<p> <code>git shortlog</code></p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/18.png" style="zoom: 100%;"></p>
<p>我们可以 </p>
<p><code>git shortlog -n -s</code></p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/19.png" style="zoom: 100%;"></p>
<p><code>git short log -n -e</code> 来显示这个人的邮箱</p>
<p>甚至可以 <code>git shortlog -n -s -e --before=&quot;&quot; --after=&quot;&quot;</code> 来框定某一个特定时间内提交者的信息</p>
<h3 id="Viewing-the-History-of-a-File"><a href="#Viewing-the-History-of-a-File" class="headerlink" title="Viewing the History of a File"></a>Viewing the History of a File</h3><p>现在我们来看看一个文件在历次commits之间的变化情况.</p>
<p><code>git log --oneline toc.txt</code></p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/20.png" style="zoom: 100%;"></p>
<p>如果我们想看看这个文件在每次commit之中改了什么内容,可以用<br><code>git log --oneline --patch toc.txt</code> </p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/21.png" style="zoom: 100%;"></p>
<h3 id="Restoring-a-Deleting-File"><a href="#Restoring-a-Deleting-File" class="headerlink" title="Restoring a Deleting File"></a>Restoring a Deleting File</h3><p>我们有时候会误删一些文件,我们可以通过git来恢复. </p>
<p>我们先删除 toc.txt 也就是 <code>git rm toc.txt</code></p>
<p>然后我们<code>git log --oneline toc.txt</code> 却发现报错了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fatal: ambiguous argument &#39;toc.txt&#39;: unknown revision or path not in the working tree.</span><br><span class="line">Use &#39;--&#39; to separate paths from revisions, like this:</span><br><span class="line">&#39;git &lt;command&gt; [&lt;revision&gt;...] -- [&lt;file&gt;...]&#39;</span><br></pre></td></tr></table></figure>
<p>这是因为在删除了toc.txt之后,git就不能辨别 toc.txt 到底是命令还是一个文件了,我们需要 用 — 来分隔文件和命令</p>
<p><code>git log --oneline -- toc.txt</code></p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/22.png" style="zoom: 100%;"></p>
<p>我们要的是 a642e12 这个commit,然后我们用命令 <code>git checkout a642e12 toc.txt</code> 将 commit 中的 toc.txt 取出放到 working directory. </p>
<h3 id="Finding-the-Author-of-Line-Using-Blame"><a href="#Finding-the-Author-of-Line-Using-Blame" class="headerlink" title="Finding the Author of Line Using Blame"></a>Finding the Author of Line Using Blame</h3><p>如果我们觉得某一个人的某个文件代码写的很差,我们可以使用 Blame 功能 “责备他”</p>
<p><code>git blame audience.txt</code></p>
<p>-e 即查看他人的邮件</p>
<p><code>git blame -e audience.txt</code></p>
<p>-L 1,3 即显示前三行</p>
<p><code>git blame -e -L 1,3 audience.txt</code></p>
<p>(感觉这个功能也没啥用处…)</p>
<h3 id="Tagging"><a href="#Tagging" class="headerlink" title="Tagging"></a>Tagging</h3><p>我们可以给一些有里程碑意义的commit打标签 </p>
<p>比如 <code>git tag v1.0 a642e12</code></p>
<p> <img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/23.png" style="zoom: 100%;"></p>
<p>我们就发现倒数第二个commit被打上了 v1.0的标签</p>
<p>设置了 tag之后,checkout会变得非常方便了 ,直接 <code>git checkout v1.0</code> 就可以了。</p>
<p>这个tag可以看作是指针或者一个commit的别名。</p>
<p>还有一种 tag叫做 annotated tag. 这种tag是一个对象，里面有打tag的人的email之类的信息，比如</p>
<p><code>git tag -a v1.1 -m &quot;My version 1.1&quot;</code></p>
<p>如果我们要查看每个tag的 message，那么我们可以用 <code>git tag -n</code> </p>
<p>查看anotated tag的tageer的信息，可以使用 <code>git show tag名</code>，比如：</p>
<p>查看现在定了几个tag可以用<code>git tag</code> </p>
<p>删除某个tag可以用 <code>git tag -d v1.1</code>  这样的命令,那么在开头就会显示Author的信息和打标签的时间了</p>
<h3 id="Browsing-History-Using-VSCode"><a href="#Browsing-History-Using-VSCode" class="headerlink" title="Browsing History Using VSCode"></a>Browsing History Using VSCode</h3><p>用 Gitlens 会更加方便</p>
<h3 id="Browsing-the-History-Using-GitKraken"><a href="#Browsing-the-History-Using-GitKraken" class="headerlink" title="Browsing the History Using GitKraken"></a>Browsing the History Using GitKraken</h3><h2 id="Branching"><a href="#Branching" class="headerlink" title="Branching"></a>Branching</h2><ul>
<li>Use branches</li>
<li>Compare branches</li>
<li>Merge branches</li>
<li>Resolve conflicts</li>
<li>Undo a faulty merge</li>
<li>Essential tools(stashing ,cherry picking )</li>
</ul>
<h3 id="What-are-Branches"><a href="#What-are-Branches" class="headerlink" title="What are Branches"></a>What are Branches</h3><p>我们可以把 Branch 看成是 独立的分隔的 workspace</p>
<p>我们有一个working space MASTER，又有另外一个working space FEATURE 用来研究其他的特性。在FEATURE完成之前，我们不想让里面的代码对MASTER进行一个干扰。当FEATURE已经完善之后，我们再将其和MASTER进行合并。</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/24.png" style="zoom: 100%;"></p>
<p>branch 这个功能让我们能够对不同的对象进行不同的工作，两者互不干扰，因为我们需要保证 main line 尽可能稳定，以便branch能够随时发布，同时也有助于团队的新成员能尽快上手项目。  </p>
<p>Git中的Branch只是一个对commit的指针。Master只是一个指向 main line 最后一次commit的指针。当我们commit之后，git会自动移动 Master 指针。当我们新建了一个branch之后，我们实际是新建了一个指针，这个指针占有的内存很小。那么怎么才能知道当前我们是在那个 working space当中呢？git中还有一个指针HEAD，这个指针指向一个branch的名字，我们可以用 checkout 将HEAD指向不同的branch。</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/25.png" style="zoom: 100%;"></p>
<h3 id="Working-with-Branches"><a href="#Working-with-Branches" class="headerlink" title="Working with Branches"></a>Working with Branches</h3><p>比如我们现在发现了一个Bug，现在为了修复这个bug，我们新建一个branch叫做 bugfix</p>
<ul>
<li>使用命令 <code>git branch bugfix</code> 就可以创建branch</li>
<li><p>使用命令 <code>git branch</code> 可以查看当前的branches</p>
</li>
<li><p>如果要切换branches，可以使用 <code>git switch bugfix</code> 或者 <code>git checkout bugfix</code></p>
</li>
<li>如果要重命名branch ,可以使用 <code>git branch -m bugfix(原名) bugfix/signup-form(新名)</code></li>
</ul>
<p>我们对audience.txt 进行了改变并且提交了。然后查看日志，会发现 master是bugfix之前一个版本。</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/26.png" style="zoom: 100%;"></p>
<p>我们对audience做出的改变只能在bugfix这个commit 下才能查看。如果我们切换成master一支，我们是不会发现audience.txt做出了什么改变的。</p>
<ul>
<li>在切换回 master之后，我们是看不出bugfix的，如果要查看我们就要用<code>git log --oneline --all</code></li>
<li>如果我们已经成功修复了bug，需要和master合并然后删去这个bugfix branch，我们可以用命令<code>git branch -d bugfix/signup-form</code> 但是要注意，如果没有merge之前就删除这个branch会报错。如果我们真的要强制删除，我们可以使用 <code>git branch -D bugfix/signup-form</code> 也就是变成大写的D</li>
</ul>
<h3 id="Comparing-Branches"><a href="#Comparing-Branches" class="headerlink" title="Comparing Branches"></a>Comparing Branches</h3><p>当我们创建branches并对其commit时，我们需要看看它们是怎么与master主线岔开的。我们现在就来比比不同的branches。</p>
<p>我们可以用 <code>git log master..bugfix/sigup-form</code> 来查看哪些commit是在这条branch上递交的</p>
<p>如果我们不想看commits，而是看在branch上改变了哪些内容，我们可以这么写：</p>
<ul>
<li><code>git diff master..bugfix/signup-form</code> 或者 <code>git diff bugfix/signup-form</code> </li>
</ul>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/28.png" style="zoom: 100%;"></p>
<p>如果我们只想看看那些文件名改变了我们可以用这个命令</p>
<ul>
<li><code>git diff --name-status bugfix/signup-form</code></li>
</ul>
<h3 id="Stashing"><a href="#Stashing" class="headerlink" title="Stashing"></a>Stashing</h3><p>stach有存放之意。当我们在master中做了一些改变，现在却想切换到branch去，那么branch中的内容就会覆盖掉我们现在working directory中的内容。</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/29.png" style="zoom: 100%;"></p>
<p>这就是stash出现的场景了，我们需要用stash方法将当前的working directory保存起来，然后当我们处理完 branch的事情、切换回branch之后在取出来。</p>
<ul>
<li><code>git stash push -m &quot;New tax rules.&quot;</code>将当前的内容stash，-m 后填写说明</li>
</ul>
<p>但是我们要注意， git stash是不会将git 没有追踪的(untracked) 文件保存下来的。也就是说不会stash刚刚创建的文件</p>
<ul>
<li><p>那么为了解决上面的问题，我们可以使用 <code>git stash push -a -m&quot;My new stash&quot;</code>  -a 就代表了<br>-all</p>
</li>
<li><p>想看看当前的stash信息，可以使用 <code>git stash list</code></p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/30.png" style="zoom: 120%;"></p>
</li>
<li><p>现在假设我们再bugfix这支branch上的工作已经完成，我们切回master，想看看之前保留在stash中的文件做出了哪些改变 ，可以使用 <code>git stash show 1</code>来看 <code>stash@{1}</code> 中的内容</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/31.png" style="zoom: 120%;"></p>
</li>
<li><p>如果我想将stash中的文件放回到working directory，那么可以用<code>git stash apply 1</code> 来提取<code>stash@{1}</code> 中的内容。</p>
</li>
<li><p>如果我们已经不需要stash了，可以用<code>git stash drop 1</code> 来删除<code>stash@{1}</code></p>
</li>
<li><p>可以用 <code>git stash clear</code> 删除所有的stash</p>
</li>
</ul>
<h3 id="Merging"><a href="#Merging" class="headerlink" title="Merging"></a>Merging</h3><p>git提供了三种 commit 操作。</p>
<h4 id="Fast-forward-if-branches-have-not-diverged"><a href="#Fast-forward-if-branches-have-not-diverged" class="headerlink" title="Fast-forward (if branches have not diverged)"></a>Fast-forward (if branches have not diverged)</h4><p>就是master和branch是一条链上的。</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/32.png" style="zoom: 100%;"></p>
<p>如图所示，Master和BUGFIX 这支branch是线性关系，那么我们只需要将 MASTER 指针指向BUGFIX指向的commit，再将BUGFIX删除就能完成 合并操作。</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/33.png" style="zoom: 100%;"></p>
<p>Fast-forward merge 属于“快进方式”，不过这种情况如果删除分支，则会丢失分支信息。因为在这个过程中没有创建commit</p>
<h4 id="no-ff-merge"><a href="#no-ff-merge" class="headerlink" title="no-ff merge"></a>no-ff merge</h4><p>和Fast-forward merge的初始情况相同，但是no-ff merge在合并的时候并不是只将MASTER指向branch末尾，而是新建了一个commit</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/39.png" style="zoom: 100%;"></p>
<h4 id="3-way-if-branch-have-diverged"><a href="#3-way-if-branch-have-diverged" class="headerlink" title="3-way(if branch have diverged)"></a>3-way(if branch have diverged)</h4><p>master 和 branch 分叉了，各自有commit</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/34.png" style="zoom: 100%;"></p>
<p>现在我们执行合并操作的话，就是新建一个commit，将master和BUGFIX文件各自做出的改变合并起来。</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/35.png" style="zoom: 100%;"></p>
<h3 id="Fast-forward-Merges"><a href="#Fast-forward-Merges" class="headerlink" title="Fast-forward Merges"></a>Fast-forward Merges</h3><p>学了branch以后我们在查看log的时候记得加上 —graph, 这样git会以点线图的形式将master和branch所做的变更和合并呈现出来。这里展示的是Fast-forward , branch和master是一条链上的，所以graph是线性排列的。</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/36.png" style="zoom: 100%;"></p>
<ul>
<li>我们使用 <code>git merge bugfix/signup-form</code> <strong>在HEAD指向MASTER的时候</strong>来实现Fast-forward Merge</li>
</ul>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/37.png" style="zoom: 100%;"></p>
<p>再次查看log，发现 master和branch(bugfix) 都指向了一个commit了</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/38.png" style="zoom: 100%;"></p>
<h3 id="No-ff-merge"><a href="#No-ff-merge" class="headerlink" title="No-ff merge"></a>No-ff merge</h3><p><strong>同样是</strong>线性的branch和master，我们也可以选择<strong>不是 fast-forward merge的形式</strong>(no-ff)来进行合并。上文说过，Fast-forward merge 并没有创建新的commit，容易丢失 branch版本。若选择 no-ff 形式，在合并时会新建一个commit，这样就会保存branch的版本了。</p>
<p>接下来我们模拟 no-ff 合并操作。</p>
<ul>
<li>可以用 <code>git switch -C branch名字</code> 将创建和切换branch 缩在一条命令当中</li>
</ul>
<p>现在有一个master，一个bugfix/login-form 的branch</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/40.png" style="zoom: 100%;"></p>
<ul>
<li>我们使用 <code>git merge --no-ff bugfix/login-form</code> 这一命令来执行 no-ff 类的merge操作。</li>
</ul>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/41.png" style="zoom: 100%;"></p>
<p>查看merge做的点线图，我们可以很清楚的看到merge和master进行了一个合并且生成了一个新的commit</p>
<p>我们既要习惯fast-forward，也要习惯no-ff ,因为no-ff commit merge可以反映出一个项目创建后的一步步历史，而且no-ff merge能让在不想要branch的时候更方便地退回之前的master版本。</p>
<p>如果我们不喜欢(或者上司不喜欢) fast-forward 的话，我们可以把 no-ff 设置为全局变量，即对所有的repository通用。</p>
<ul>
<li><code>git config ff no</code>(对当前repository) / <code>git config --global ff no</code> 对所有repositories</li>
</ul>
<h3 id="Three-way-Merges"><a href="#Three-way-Merges" class="headerlink" title="Three-way Merges"></a>Three-way Merges</h3><p>现在我们来模拟 Three-way Merge 的操作。</p>
<p>流程：创建并切换至新branch,commit一次；切换回master，commit一次 ,我们就会发现branch和master发生了分叉。</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/43.png" style="zoom: 100%;"></p>
<p>现在我们要合并这两支，这两支有着共同的祖先。</p>
<ul>
<li>我们可以直接用 <code>git merge feature/change-password</code> 来进行 three-way merge</li>
</ul>
<p>我们看到下面git给出的路径，已经对两支进行了合并操作。</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/44.png" style="zoom: 100%;"></p>
<h3 id="Viewing-Merged-and-Unmerged-Branches"><a href="#Viewing-Merged-and-Unmerged-Branches" class="headerlink" title="Viewing Merged and Unmerged Branches"></a>Viewing Merged and Unmerged Branches</h3><p>有时候我们新建了一个branch，但是项目做着做着可能就忘记将这个branch合并了，于是我们可以通过命令</p>
<ul>
<li><code>git branch --merged</code> 来查看哪些branch已经合并了</li>
<li><code>git branch --no-merged</code> 来查看那些branch还没有进行合并</li>
</ul>
<p>对于已经合并的branch我们要养成好习惯及时删除。</p>
<p><code>git branch -d bugfix/login-form</code></p>
<h3 id="Merge-Conflicts"><a href="#Merge-Conflicts" class="headerlink" title="Merge Conflicts"></a>Merge Conflicts</h3><p>在Merge的时候我们常常会遇到冲突</p>
<ul>
<li>当一个文件同时被两支branch修改时</li>
<li>一个文件在一支里面被修改，却被另一支删除时</li>
<li>同一文件在两个分支中都加了点东西，但是加的内容不同</li>
</ul>
<p>遇到这些冲突的时候，git就会暂停合并，我们需要告诉Git我们想怎么选择。</p>
<p>我们现在通过git命令来模拟这一操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git switch -C bugfix&#x2F;change-password</span><br><span class="line">code change-password.txt</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Update change-password.txt&quot;</span><br><span class="line"></span><br><span class="line">git switch master</span><br><span class="line">code change-password.txt</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Update change-password.txt&quot;</span><br></pre></td></tr></table></figure>
<p>现在我 <code>git merge bugfix/change-password</code> 之后，会出现conflicts</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/46.png" style="zoom: 120%;"></p>
<p>这时候git就会自动跳到一个 master|MERGING 状态。在这个状态下我们输入 <code>git status</code> 就会发现change-password.txt 这个文件并没有被merge，因为它被 both modified 了。</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/47.png" style="zoom: 120%;"></p>
<p>这时候，我们可以用vscode打开 change-password.txt </p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/45.png" style="zoom: 150%;"></p>
<p>vscode可以使用 “采用当前更改(master)”、”采用传入的更改(branch)”、”保留双方更改”、”比较变更”这几种选项。</p>
<p>或者我们也可以直接手动更改再保存(但是尽量别再自己加东西了！)</p>
<p>修改好以后，我们再使用 <code>git add .</code> 和 <code>git commit</code> 将定稿commit</p>
<h3 id="Graphical-Merge-Tools"><a href="#Graphical-Merge-Tools" class="headerlink" title="Graphical Merge Tools"></a>Graphical Merge Tools</h3><p>VScode用来进行合并操作有点麻烦。这里介绍一些其他的工具</p>
<ul>
<li>Kdiff</li>
<li>P4Merge</li>
<li>WinMerge(Windows Only) </li>
</ul>
<p>p4Merge 的下载地址<a href="https://www.perforce.com/downloads/visual-merge-tool" target="_blank" rel="noopener">https://www.perforce.com/downloads/visual-merge-tool</a></p>
<p>下载完成后不需要点击软件，需要在git中进行配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global merge.tool p4merge</span><br><span class="line"></span><br><span class="line">git config --global mergetool.p4merge.path   &quot;C:\Program Files\Perforce\p4merge.exe&quot;&#x2F;&#x2F;exe所在的目录</span><br></pre></td></tr></table></figure>
<p>然后当文件发生冲突的时候，我们可以用命令</p>
<p><code>git mergetool</code>  来打开 p4merge界面</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/48.png" style="zoom: 100%;"></p>
<p>我们看到这就是 P4Merge的UI，操作很友好，支持不同conficts文件之间的切换。</p>
<h3 id="Aborting-a-Merge"><a href="#Aborting-a-Merge" class="headerlink" title="Aborting a Merge"></a>Aborting a Merge</h3><p>我们进行Merge操作的时候会遇到一些conflicts，但是当我们犹豫不决、没下定决心取舍哪个版本的时候。我们可以终止merging状态,回到合并之前的样子</p>
<ul>
<li>只要使用 <code>git merge --abort</code> 即可</li>
</ul>
<h3 id="Undoing-a-Faulty-Merge"><a href="#Undoing-a-Faulty-Merge" class="headerlink" title="Undoing a Faulty Merge"></a>Undoing a Faulty Merge</h3><p>有时候我们在Merge之后发现code没办法得到兼容或者编译，那么我们现在需要回退到之前的状态、取消当前的merge状态。待修改完成后，我们再重新merge</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/49.png" style="zoom: 100%;"></p>
<p>现在是这样子的。我们要撤回当前的merge状态，有两种选择：</p>
<ul>
<li><p>git reset 是将 merge 后的commit删除(remove),</p>
</li>
<li><p>git revert是用于“反做”某一个版本，以达到撤销该版本的修改的目的。现在我们的merge操作出现了点问题，但是我想保留这个commit，又想回退到上一个版本，这时候我们可以新建一个版本，这个版本和merge前的哪个版本一模一样，达到了退回的目的。</p>
</li>
</ul>
<p>首先我们来看 remove操作： 示意图如下</p>
<p>一开始的状态时这样子的</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/50.png" style="zoom: 100%;"></p>
<p>将Master 回退到之前状态后，没有任何指针指向最后一个commit，git会自行删除这个commit</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/51.png" style="zoom: 100%;"></p>
<ul>
<li><code>git reset --hard HEAD~1</code> 这行命令就可以完成 remove操作</li>
</ul>
<p>HEAD~1就代表当前HEAD之前一个版本的commit，但是hard怎么理解呢？</p>
<p>当我们执行 reset操作的时候，我们有三种选择：</p>
<ul>
<li>soft</li>
<li>mixed</li>
<li>hard</li>
</ul>
<p>当我们执行soft的时候,Last Snapshot 会回退到上一个版本，但是 Working directory 和 staging area中的内容是不会受影响的，也就是还和原来保持一样</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/52.png" style="zoom: 100%;"></p>
<p>当我们使用 mixed 操作的时候，git会取出上一次的commit的snapshot然后放到 Staging area 当中去。</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/53.png" style="zoom: 100%;"></p>
<p>hard 操作则是将快照应用在三个地方：</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/54.png" style="zoom: 100%;"></p>
<p>执行完命令后，发现log已经变成这样了:</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/55.png" style="zoom: 100%;"></p>
<p>我们可以再通过 <code>git reset --hard merge编号</code> 来重新变成merge之后的状态</p>
<p>下面来介绍 revert 操作,再revert的时候我们需要告诉git回退到哪一个版本，是master支上的还是 branch上的</p>
<ul>
<li><code>git revert -m 1 HEAD</code> -m 1 就代表着 first parent，也就是master上的版本。</li>
</ul>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/56.png" style="zoom: 100%;"></p>
<p>重新查看 log，可以发现新建了一个commit，这个commit和之前的9455172 是一模一样的</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/57.png" style="zoom: 100%;"></p>
<h3 id="Squash-Merging"><a href="#Squash-Merging" class="headerlink" title="Squash Merging"></a>Squash Merging</h3><p>Squash 是挤压之意，相比 merge 来说会减少分支合并的记录，会被压缩为一条 commit 记录。squash merge 本质是把 dev 分支的改动保存到 master 本地，接下来还需要手动提交一下。</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/58.png" style="zoom: 100%;"></p>
<p>我们先模拟当前的状况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git switch -C bugfix&#x2F;photo-upload </span><br><span class="line">echo bugfix &gt;&gt; audience.txt</span><br><span class="line">git commit -am &quot;Update audience.txt&quot;</span><br><span class="line"></span><br><span class="line">echo bugfix&gt;&gt;toc.txt</span><br><span class="line">git commit -am &quot;Update toc.txt&quot;</span><br></pre></td></tr></table></figure>
<p>然后我们进行 squash merge</p>
<ul>
<li>首先 <code>git switch master</code></li>
<li><code>git merge --squash bugfix/photho-upload</code> </li>
</ul>
<p>这还没完，这只是将branch 中修改的内容存放在staging area当中，还没有commit</p>
<p><code>git commit -m &quot;Fix the bug one the photo upload page&quot;</code> 以后</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/59.png" style="zoom: 100%;"></p>
<p>但是要注意，squash merge的应用情况是修改一些小bug，或者增加一些小feature，不宜修改太多。当我们commit之后也要及时删除。因为如果project很大的话，我们会忘记这支branch，<code>git branch --no-merged</code> 就会看到branch还未合并，可能会出现误解。</p>
<p><code>git branch -D bugfix/photo-upload</code> 可以删除这支branch。注意，这里不能写 -d,因为git会认为这支branch还没有合并，从而拒绝删除。 -D则是强制删除。                                          </p>
<h3 id="Rebasing"><a href="#Rebasing" class="headerlink" title="Rebasing"></a>Rebasing</h3><p>Rebasing 顾名思义就是将branch的Base重定向。</p>
<p>下面是初始状态：</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/60.png" style="zoom: 100%;"></p>
<p>Rebase之后，我们将FEATURE这支转移到Master上</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/61.png" style="zoom: 100%;"></p>
<p>最后将Master和Feature合并</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/62.png" style="zoom: 100%;"></p>
<p>Rebase 是一种修改Commit 历史的写法。我们不应该在多人团队协作的情况下擅自使用 Rebase</p>
<p>事实上，在Git 内部的实现原理如下：</p>
<p>首先在Master后面创建两个F1，F2 commit的拷贝F1*和F2*。然后再让Feature指向 F2*, 这时没有指针再指向F1、F2 了，git会自行删除它们。</p>
<p>我们先用命令创造出这样一个情况 ： </p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/63.png" style="zoom: 100%;"></p>
<p>然后我们将Head指向 feature/shopping-cart 并 <code>git rebase master</code></p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/64.png" style="zoom: 100%;"></p>
<p>最后我们只需要做一下 fast-forward merge 就可以将两个合并起来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git switch master</span><br><span class="line">git merge feature&#x2F;shopping-cart</span><br></pre></td></tr></table></figure>
<p>那么如果rebase发生冲突了该怎么办呢？</p>
<p>我们同样可以通过 <code>git mergetool</code> 来进行调整。</p>
<ul>
<li><p>一个文件调整完了，可以用 <code>git rebase --continue</code> 来进行下一个文件的处理</p>
</li>
<li><p>可以用<code>git rebase --skip</code> 来跳过当前文件的处理。</p>
</li>
<li>可以用 <code>git rebase --abort</code> 来回暂停rebase操作。</li>
</ul>
<h3 id="Cherry-Picking"><a href="#Cherry-Picking" class="headerlink" title="Cherry Picking"></a>Cherry Picking</h3><p>Cherry Picking 就是像在两个樱桃中选择一个去摘。在git中如图：</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/65.png" style="zoom: 100%;"></p>
<p>我们只要记下 F1 的ID，然后 <code>git cherry-pickl ID</code></p>
<p>如果发生了问题，那么我们也可以用 <code>git mergetool</code> 来解决。</p>
<h3 id="Picking-a-File-from-Another-Branch"><a href="#Picking-a-File-from-Another-Branch" class="headerlink" title="Picking a File from Another Branch"></a>Picking a File from Another Branch</h3><p>现在我们来看看怎么从一支branch中取出单独的一个文件放到当前的working directory</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git switch -C feature&#x2F;send-email</span><br><span class="line">echo river &gt; toc.txt</span><br><span class="line">git commit -am &quot;Update toc.txt&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>我们先 git switch master</p>
</li>
<li><p>然后 <code>git restore --source=feature/send-email -- toc.txt</code>  也就是从 feature/send-email这一支的最新commit中选出toc.txt 文件放到working directory当中</p>
</li>
<li>最后 add ，commit 即可</li>
</ul>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/" itemprop="url">CSAPP程序的机器级表示1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-24T08:43:24+08:00">
                2020-09-24
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-11-10T18:16:58+08:00">
                2020-11-10
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="CSAPP程序的机器级表示1"><a href="#CSAPP程序的机器级表示1" class="headerlink" title="CSAPP程序的机器级表示1"></a>CSAPP程序的机器级表示1</h1><p>本章内容：</p>
<ul>
<li>快速浏览C语言、汇编代码以及机器代码之间的关系。</li>
<li>介绍 x86-64 的细节：从数据的表示和处理以及控制的实现(C语言中的if,while,switch等控制结构)</li>
<li>过程的实现(如程序如何维护一个运行栈来支持过程间数据和控制的传递，以及局部变量的存储)</li>
<li>考虑在机器级如何实现像数组、结构和联合这样的数据结构</li>
<li>讨论内存访问越界问题、洗头膏容易遭到缓冲区溢出攻击的问题。</li>
<li>用GDB调试器检查机器级程序运行时行为的技巧</li>
<li>浮点数据和操作的代码的机器程序表示</li>
</ul>
<h2 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h2><p>之前我们讲过用 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Og -o p p1.c p2.c</span><br></pre></td></tr></table></figure>
<p>来编译 p1.c 和 p2.c 两个文件。编译选项 -Og 告诉编译器使用会产生<strong>符合原始C代码整体结构</strong>的机器代码的优化等级。因为使用较高级别的优化代码会使其严重变形，以至于产生的机器代码和源代码的关系变得难以理解。所以我们先从最基础的-Og开始，再看看较高级别的优化(-o1或-o2)会发生什么。</p>
<h3 id="机器级代码"><a href="#机器级代码" class="headerlink" title="机器级代码"></a>机器级代码</h3><p>在整个编译过程中，编译器会完成大部分的工作，把C语言转化成处理器执行的<strong>非常基本</strong>的指令。汇编代码非常接近于机器代码，与机器代码的二进制格式比，汇编的主要特点就是他用<strong>可读性更好</strong>的文本格式表示。能够理解汇编代码以及它原始C代码的联系，使理解计算机如何执行程序的关键一步。</p>
<p>我们先了解一些寄存器的概念：</p>
<ul>
<li>程序计数器(通常称为 “PC”, 在 x86-64中用 %rip 表示) 给出将要执行的下一条指令在内存当中的地址</li>
<li>整数寄存器文件包含16个命名的位置用来存储64位的值。这些寄存器可以存储地址(对应于C语言的指针) 或整数数据。有的寄存器被用来记录某些重要的程序状态；其他的寄存器哟个来保存临时数据(参数、局部变量、返回值)</li>
<li>条形码寄存器保存着最近执行的算术或者逻辑指令的状态信息。它们用来实现控制数据流中的条件变化(if 和 while)</li>
<li>一组向量寄存器可以存放一个或者多个整数或浮点数值</li>
</ul>
<p>一条机器指令只执行一个非常基本的操作。例如将存放在寄存器中的两个数字相加，在寄存器和存储器之间传送数据，或是条件分支转移到新的指令地址。编译器必须产生这些指令的序列，从而实现(如算术表达式求值、循环或者过程调用和返回)程序结构</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>比如我写一个C语言代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">mult2</span><span class="params">(<span class="keyword">long</span>,<span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multstore</span><span class="params">(<span class="keyword">long</span> x,<span class="keyword">long</span> y,<span class="keyword">long</span> *dest)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> t = mult2(x,y);</span><br><span class="line">    *dest = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们用 <code>gcc -Og -S mstore.c</code> 命令来进行编译</p>
<p>得到mulstore的汇编语言形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">multstore:</span><br><span class="line">	pushq			%rbx</span><br><span class="line">	.seh_pushreg	%rbx</span><br><span class="line">	subq			$32, %rsp</span><br><span class="line">	.seh_stackalloc	32</span><br><span class="line">	.seh_endprologue</span><br><span class="line">	movq			%r8, %rbx</span><br><span class="line">	call			mult2</span><br><span class="line">	movl			%eax, (%rbx)</span><br><span class="line">	addq			$32, %rsp</span><br><span class="line">	popq			%rbx</span><br><span class="line">	ret</span><br><span class="line">	.seh_endproc</span><br><span class="line">	.ident			&quot;GCC: (tdm64-1) 4.9.2&quot;</span><br><span class="line">	.def			mult2;	.scl	2;	.type	32;	.endef</span><br></pre></td></tr></table></figure>
<p>上面代码mulstore下的每行都代表一条机器指令。比如 pushq指令表示应该将寄存器 %rbx 的内容压入程序栈当中。这段代码中已经除去了所有关于局部变量名或者数据类型的信息。</p>
<p>我们再进一步用 <code>gcc -Og -c mstore.c</code> 来进行编译，这就会产生目标代码文件 mstore.c ，他是二进制格式的无法直接查看。转换为十六进制之后可以看到汇编指令对应的目标代码。</p>
<p>我们从中得到一个重要信息，即机器执行的程序只是一个字节序列，它是对一系列指令的编码。机器对产生这些指令的源代码几乎一无所知</p>
<p>要查看机器代码文件的内容，有一类称为 反汇编器的程序非常有用。这些程序根据机器代码产生一种类似于汇编代码的格式。我们可以用命令 <code>objdump -d mstore.o</code> 来实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 &lt;multstore&gt;:</span><br><span class="line">   0:   53                      push   %rbx</span><br><span class="line">   1:   48 83 ec 20             sub    $0x20,%rsp</span><br><span class="line">   5:   4c 89 c3                mov    %r8,%rbx</span><br><span class="line">   8:   e8 00 00 00 00          callq  d &lt;multstore+0xd&gt;</span><br><span class="line">   d:   89 03                   mov    %eax,(%rbx)</span><br><span class="line">   f:   48 83 c4 20             add    $0x20,%rsp</span><br><span class="line">  13:   5b                      pop    %rbx</span><br><span class="line">  14:   c3                      retq</span><br></pre></td></tr></table></figure>
<p>在左边十六进制字节值被分成了机组，每组都是一条指令，右边是等价的汇编语言。</p>
<p>其中，一些关于机器代码和它的反汇编表示的特性值得注意：</p>
<ul>
<li>x86-64 的指令长度从1到15个字节不等。<strong>常用的指令以及操作数较少</strong> 的指令所需的字节数<strong>少</strong>，而那些<strong>不太常用或操作数较多</strong>的指令所需的字节数较<strong>多</strong> </li>
<li>设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。例如，只有指令pushq %rbx 是以字节值53 开头的。</li>
<li>反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码。</li>
<li>反汇编器使用的指令命名规则与GCC 生成的汇编代码使用的有些细微的差别。在我们的示例中，它省略了很多指令结尾的  ‘q’ 这些后缀是大小指示符，在大多数情况中可以省略。相反，反汇编器给call 和ret 指令添加了 ‘q’ 后缀，同样，省略这些后缀也没有问题。</li>
</ul>
<h3 id="关于格式的注解"><a href="#关于格式的注解" class="headerlink" title="关于格式的注解"></a>关于格式的注解</h3><p>所有以 ‘.’ 开头的行 都是指导汇编器和链接器工作的伪指令。我们通常可以忽略这些行。另一方面，也没有关于指令的用途以及他们与源代码之间关系的解释说明。</p>
<p>为了清楚的说明汇编代码，我们用下面这种格式来表示汇编代码，他省略了大部分伪指令，但包括行号和解释性说明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void multstore(long x, long y, long *dest)</span><br><span class="line">x in %rdi, y in %rsi, dest in %rdx</span><br><span class="line">multstore:</span><br><span class="line">	pushq %rbx 					Save %rbx</span><br><span class="line">	movq %rdx, %rbx 			Copy dest to %rbx</span><br><span class="line">	call mult2 					Call mult2(x, y)</span><br><span class="line">	movq %rax, (%rbx) 			Store result at *dest</span><br><span class="line">	popq %rbx 					Restore %rbx</span><br><span class="line">	ret 						Return</span><br></pre></td></tr></table></figure>
<p>上面这种格式简单地描述了指令的效果以及它与原始C语言代码中的计算操作的关系。这是一种汇编语言程序员写代码的风格</p>
<h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><p>Intel用 “word” 表示16位数据类型。因此称32位数为 “double words” ，64位数为 “quad words” . 下图是C语言基本数据类型对应的 x86-64表示的表格</p>
<p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/1.png" style="zoom: 120%;"></p>
<p>浮点数主要有两种形式</p>
<ul>
<li><p>单精度(4字节) 值，对应于C中的 Float</p>
</li>
<li><p>双精度(8字节) 值，对应于C中的 Double</p>
<p>大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。比如 <code>moveb(传送字节)</code> 、<code>movw(传送字)</code> …</p>
<p>后缀‘l’用来表示双字，因为32 位数被看成是“长字（long word)” 。注意，汇编代码也使用后缀‘l’来表示4 字节整数和8 字节双精度浮点数。这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器。</p>
</li>
</ul>
<h2 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h2><p>我们首先来了解一下寄存器(register) 的历史</p>
<p><strong>最初</strong>的8086处理器中8个16位的寄存器，即位下面的 $\%ax$ 到 $\%bp$ 。 每一个寄存器都有特殊的用处。</p>
<p><strong>当扩展到IA32架构时</strong> ,这些寄存器也扩展成32位了，标号从 $\%eax$ 到 $\%ebp$ </p>
<p><strong>扩展到 x86-64 之后</strong>，从原来的8个寄存器扩展成64位，标号从 $\%rax$ 到 $\%rbp$ .此外还增加了8个新的寄存器，它们的表好是按照新的命名规则制定的 $\%r8$ 到 $\%r15$ </p>
<p>在常见的程序里不同的寄存器扮演着不同的角色。其中最特别的是栈指针 $\%rsp$ 用来指明栈的结束位置。有些程序会明确地读写这个寄存器。</p>
<p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/2.png" style="zoom: 120%;"></p>
<p>指令可以对这16个寄存器的低位字节中存放的不同的数据进行操作。</p>
<ul>
<li>字节级操作可以访问最低的字节(the least significant byte)</li>
<li>16位的操作能访问最低的2个字节</li>
<li>32位操作可以访问最低的4个字节</li>
<li>64位操作可以访问整个寄存器。</li>
</ul>
<p>当生成的指令以寄存器为目标时，对于生成小于8字节结果的指令，寄存器中剩下的字节会怎么样，对此有两条规则</p>
<ul>
<li>生成1字节和2字节数字的指令会保持剩下的字节不变</li>
<li>生成4字节的数字的指令会把高位4个字节设置为0。后面这条规则是作为从IA32到x86-64 的扩展的一部分而采用的</li>
</ul>
<h3 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h3><p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/4.png" style="zoom: 120%;"></p>
<p>大多数指令都有一个或者多个操作数(operand) , 指示出执行一个操作中要使用的源数据值以及放置结果的目的位置。</p>
<p>源数值可以存放在寄存器或内存当中。因此，各种不同的操作数的可能性被分成三种类型：</p>
<ul>
<li>立即数(immediate) ，用来表示常数值。 书写方式是 $ 后面跟一个标准C表示法表示的整数，比如 $-577 或$ 0x1F</li>
<li>寄存器(register), 我们用 $r_0$ 来表示任意寄存器 a, 用引用 $R[r_a]$ 来表示它的值，这是将寄存器集合看成一个数组R，用寄存器标识符作为索引</li>
<li>内存引用。它会根据计算出来的地址访问某个内存位置。因为将内存看成一个很大的字节数组，我们用负号$M_b[Addr]$ 表示对存储在内存中从地址 $Addr$ 开始的b个字节值的引用。为了简便，我们通常省略下标b</li>
</ul>
<p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/3.png" style="zoom: 100%;"></p>
<p>我们来 仔细解读一下这张表格，$$Imm 和R[r_a]$ 就不用说了。</p>
<ul>
<li>$M[Imm]$ 是绝对寻址。也就是按照<code>Imm</code> 取内存中寻址</li>
<li>$M[R[r_0]]$ 是间接寻址。也就是说寄存器R中指定了一段内存地址，然后以此去寻址。<ul>
<li><code>moveq (%rcx),%rax</code></li>
</ul>
</li>
<li>$M[Imm+R[r_b]]$ 是 基址+偏移量 寻址。寄存器指定了一段内存空间，然后 $Imm$ 表明了偏移量<ul>
<li><code>move 8(%rbp),%rdx</code> </li>
</ul>
</li>
<li>$M[R[r_b]+R[r_i]]$ 变址寻址 </li>
<li>$M[R[r_b]+R[r_i]+Imm]$ 变址寻址</li>
</ul>
<p>最后一行是 $M[Imm+R[r_b]+R[r_i]\cdot s]$</p>
<p>$IMM$ 就代表着 偏移数，1，2或者4个字节</p>
<p>$r_b$ 就是基址：任意一个寄存器</p>
<p>$r_i$ 是变址寄存器</p>
<p>s是比例因子，必须是1、2、4或者8</p>
<p>比如说，对于 $2(\%rsp,\%rax,4)$ 这个操作数来讲，它代表的是内存地址为 $2+\%rsp+4\cdot \%rax$  的存储器区域的值。</p>
<p>练习</p>
<p>比如说 现在 $\%rdx$中的数字为 $0xf000$ ,$\%rcx$ 中的数字为 $0x0100$ ,我们可以做一个这样的表格</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Expression</th>
<th>Address Computation</th>
<th>Address</th>
</tr>
</thead>
<tbody>
<tr>
<td>$0x8(\%rdx)$</td>
<td>0xf000+0x8</td>
<td>0xf008</td>
</tr>
<tr>
<td>$(\%rdx,\%rcx)$</td>
<td>0xf000+0x100</td>
<td>0xf100</td>
</tr>
<tr>
<td>$(\%rdx,\%rcx,4)$</td>
<td>0xf000+4*0x100</td>
<td>0xf400</td>
</tr>
<tr>
<td>$0x80(,rdx,2)$</td>
<td>2*0xf000+0x80</td>
<td>0x1e080</td>
</tr>
</tbody>
</table>
</div>
<h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p>下图列出了形式最简单的数据传送指令 $MOV$ 类。这些指令把数据从原位置复制到目的位置而不做任何变化。</p>
<p>MOV跟着的后缀不同，则指令可操作的数据大小也不同。</p>
<p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/5.png" style="zoom: 120%;"></p>
<p>源操作数指定的值是一个立即数，存储在寄存器或者内存中。</p>
<p>目的操作数指定一个位置们要么是一个寄存器地址要么是一个内存地址。</p>
<p>x86-64规定传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令：第一条指令将源值加载到寄存器中，第二条将该寄存器值写入目的位置。</p>
<p>这些指令的寄存器可以是16个寄存器有标号部分中的任意一个，寄存器部分的大小必须和指令的后缀(bwlq) 指定的大小相匹配。</p>
<p>有一个例外，当<code>movl</code>指令以寄存器位目的时，它会把该寄存器的高位4字节设置为0。这是因为x86-64采用的任何寄存器生成32位值都会把该寄存器的高位部分设置为0这一惯例。</p>
<p>例子：</p>
<p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/6.png" style="zoom: 120%;"></p>
<p>第一个是源操作数(source)，第二个是目的操作数(destination).</p>
<ul>
<li>第一行就是将一个立即数放到寄存器当中，长度为4个字节</li>
<li>第二行是将寄存器转移到寄存器当中，长度为2个字节</li>
<li>第三行是将内存中的数据转移到寄存器当中，长度为1个字节</li>
<li>第四行是将立即数存储到内存当中，长度为1个字节</li>
<li>第五行是将寄存器中的数存到内存当中，长度为8个字节</li>
</ul>
<p>下面两张表格记录的是两类移动指令，是当将较小的源值复制到较大的目的时使用的。</p>
<p>MOVZ类中的指令是在复制到寄存器后将剩余的字节填充为0</p>
<p>MOVS类中的指令则是通过符号扩展来填充，把源操作数的最高位进行赋值。</p>
<p>我们可以看到每条指令名字的后两个字符都是大小指示符，第一个字符指定源的大小，而第二个指明destination的大小</p>
<p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/7.png" style="zoom: 100%;"></p>
<p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/8.png" style="zoom: 130%;"></p>
<p>注意：cltq指令没有操作数，它总是以寄存器$\%eax$ 作为源，$\%rax$ 作为符号扩展结果的目的。它的效果与指令$moveslq~~ \%eax,\%rax$  完全一致，不过编码更紧凑。</p>
<h4 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h4><p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/18.png" style="zoom: 130%;"></p>
<p>我们知道，两个地址之间不能传值.操作指令的后缀取决于寄存器的大小: 两个寄存器之间如果要传值必须要保证两个寄存器的位数大小相同。地址和寄存器之间传递数据，指令后缀取决于寄存器。</p>
<ol>
<li>因为从%eax 传向 地址，所以后缀和 %eax相匹配，为 <code>movl</code></li>
<li>因为从地址传向 %dx ,所以后缀和 %dx 相匹配，为 <code>movw</code></li>
<li>因为从地址传向 %bl，所以后缀和 %bl 匹配，为 <code>movb</code></li>
<li>同上,为 <code>movb</code></li>
<li>从地址传向 %rax，所以后缀和%rax相匹配，为 <code>movq</code></li>
<li>从%dx传向地址，和%dx相匹配，为 <code>movw</code></li>
</ol>
<p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/19.png" style="zoom: 130%;"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>错误之处</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%bx</code>系列寄存器时被调用者保存的寄存器，不能拿来当成地址</td>
</tr>
<tr>
<td><code>%rax</code>是64位的寄存器，而<code>movl</code>匹配的是32位的寄存器，应该改为 <code>movq</code></td>
</tr>
<tr>
<td>不能在两个地址之间传递数据</td>
</tr>
<tr>
<td>没有<code>%sl</code>这个名字的寄存器</td>
</tr>
<tr>
<td>不能将寄存器中的数据移动给一个 <code>Immediate</code>(直接值)</td>
</tr>
<tr>
<td>在两个寄存器之间传递值的时候，两个寄存器的大小要保持相等</td>
</tr>
<tr>
<td><code>%si</code> 是16位寄存器，而 <code>movb</code>匹配的是8位寄存器，应该改为 <code>movw</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="数据传送示例"><a href="#数据传送示例" class="headerlink" title="数据传送示例"></a>数据传送示例</h3><p>我们现在来考虑一个exchange代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">exchange</span><span class="params">(<span class="keyword">long</span> *xp, <span class="keyword">long</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> x = *xp;</span><br><span class="line">    *xp = y;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后看看这个函数的汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">long exchange(long *xp, long y)</span><br><span class="line">xp in %rdi, y in %rsi</span><br><span class="line">exchange:</span><br><span class="line">	 movq 	(%rdi), %rax 		Get x at xp. Set as return value.</span><br><span class="line">	 movq 	%rsi, (%rdi) 		Store y at xp.</span><br><span class="line">	 ret 						Return.</span><br></pre></td></tr></table></figure>
<p>我们看到函数exchange由三条指令实现：两个数据传送(movq) 加上一条返回函数被调用点的指令(ret)</p>
<p>当过程开始时，参数xp和y分别存储在 $\%rdi$ 和$\%rsi$ 中。然后，指令2从内存中读出xp指向的x，将其存到寄存器$\%rax$ 中，直接实现了C程序中的操作 $x=*xp$ 。然后用 $\%rax$ 从这个函数返回一个值，因而返回的值就是x</p>
<p>指令3将y写入到寄存器$\%rdi$ 中的 $xp$ 指向的内存位置，直接实现了操作 $*xp=y$ 这个例子说明了如何用 $MOV$ 指令从内存中读值到寄存器，如何从寄存器写到内存当中。</p>
<p>我们要注意两点</p>
<ul>
<li>C语言中所谓的指针其实就是地址。简介引用指针就是将指针放在一个寄存器中，然后在内存引用中使用这个寄存器</li>
<li>像x这样的局部变量常常是保存在寄存器当中而不是内存中。访问寄存器比访问内存要快得多</li>
</ul>
<p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/20.png" style="zoom: 130%;"></p>
<p>这道题要注意几个点:</p>
<ul>
<li>高位转向低位(如 int 转成 char; unsigned 转换为 unsigned char)  不需要用 <code>movzbl,movsbl</code>之类的命令，直接将后几位移动到相应大小的寄存器即可</li>
<li>低位转为高位，需要进行符号扩展或零扩展；选择那种扩展取决于源数据的数据类型。比如<strong>源数据是char，转换为unsigned</strong>，那么就要用<code>movsbl</code>来进行符号扩展； 如果<strong>原来是unsigned char 要转换为long类型</strong>，那么就要用 <code>movzbl</code> 来 进行 零扩展。</li>
</ul>
<p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/21.png" style="zoom: 130%;"></p>
<p><code>%r8,%rcx,%rax</code>是三个新的变量，我们不妨将其命名为x,y,z</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decode1</span><span class="params">(<span class="keyword">long</span> *xp,<span class="keyword">long</span> *yp,<span class="keyword">long</span> *zp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x = *xp;</span><br><span class="line">	y = *yp</span><br><span class="line">	z = *zp;</span><br><span class="line">	*yp = x;</span><br><span class="line">	*zp = y;</span><br><span class="line">	*xp = z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="压入和弹出栈数据"><a href="#压入和弹出栈数据" class="headerlink" title="压入和弹出栈数据"></a>压入和弹出栈数据</h3><p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/9.png" style="zoom: 130%;"></p>
<p>pushq指令的功能就是把数据压入到栈上，而popq指令是弹出数据。这些指令都只有一个操作数-压入的数据源 和 弹出的数据目的</p>
<p>将一个四字值压入栈中，<strong>首先要将栈指针减去8</strong>，然后<strong>将值写到新的栈顶地址</strong>。因此指令 $pushq ~~\%rbp$ 的行为<strong>等价于</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subq $8,%rsp</span><br><span class="line">movq %rbp,(%rsp)</span><br></pre></td></tr></table></figure>
<p>只是前面的 $pushq ~~\%rbp$  只是一个字节，而后面两条指令一共需要8个字节。</p>
<p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/10.png" style="zoom: 130%;"></p>
<p>上图的最右边说得是在pushq后立即执行指令 popq %rdx 的效果。先从内存中读取值 0x123,再写道寄存器 $\%rdx$ 中，然后，寄存器 $\%rsp$ 的值将从 0x100增加到 0x108 . 如图，值0x123仍然会保存在内存位置 $0x100$ 中，直到被覆盖。无论如何，$\% rsp$ 指向的地址总是栈顶。</p>
<p>因为栈和程序代码以及其他形式的程序数据都是放在同一内存中，所以程序可以用标准的内存寻址方法访问栈内的任意位置。例如，假设栈顶元素是四字，指令movq 8(rsp),%rdx  会将第二个四字<strong>从栈中复制到寄存器</strong> %rdx</p>
<h2 id="算数和逻辑操作"><a href="#算数和逻辑操作" class="headerlink" title="算数和逻辑操作"></a>算数和逻辑操作</h2><p>下面是一些整数和逻辑操作。大多数操作分成了指令类，这些指令类有各种带不同大小操作数的变种(除了leaq外）。 例如ADD由四条加法指令 addb、addw、addl、addq 组成。</p>
<p>事实上给出的每个指令类都有对这四种大小不同的数据的指令。这些操作被分为四组：加载有效地址、一元操作、二元操作和移位。二元操作有两个操作数，而一元操作有一个操作数。</p>
<p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/11.png" style="zoom: 100%;"></p>
<h3 id="加载有效地址"><a href="#加载有效地址" class="headerlink" title="加载有效地址"></a>加载有效地址</h3><p>load effective address(加载有效地址)指令leaq 实际上是 movq的变形。</p>
<p><code>leaq src,Dst</code></p>
<ul>
<li>Src is address mode expression</li>
<li>Set Dst to address denoted by expression</li>
</ul>
<p><code>leaq</code>主要用来简洁的描述普通的算术操作。例如如果寄存器 $\%rdx$ 的值为x，那么指令 $leaq ~~7(\%rdx,\%rdx,4),\%rax$ 将设置寄存器 $\%rax$ 的值为 $5x+7$ ,编译器经常发现 <code>leaq</code> 的一些灵活用法，根本和有效地址计算无关</p>
<p>比如下面这个C程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">scale</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y, <span class="keyword">long</span> z)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> t = x + <span class="number">4</span> * y + <span class="number">12</span> * z;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译成汇编语言的到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">long scale(long x, long y, long z)</span><br><span class="line">x in %rdi, y in %rsi, z in %rdx</span><br><span class="line">scale:</span><br><span class="line">leaq (%rdi,%rsi,4), %rax 	x + 4*y</span><br><span class="line">leaq (%rdx,%rdx,2), %rdx 	z + 2*z &#x3D; 3*z</span><br><span class="line">leaq (%rax,%rdx,4), %rax 	(x+4*y) + 4*(3*z) &#x3D; x + 4*y + 12*z</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>leaq 能执行加法和有限形式的乘法，在编译如上简单的算术表达式时，是很有用处的。</p>
<h3 id="一元和二元操作"><a href="#一元和二元操作" class="headerlink" title="一元和二元操作"></a>一元和二元操作</h3><p>这一组操作是一元操作，只有一个操作数，既是源又是目的。这个操作数可以实寄存器也可以是一个内存位置。</p>
<p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/12.png" style="zoom: 100%;"></p>
<p>第三组是二元操作，其中，第二个操作数既是源又是目的。这种语法让人想起C 语言中的赋值运算符，例如x-=y。 不过，要注意，源操作数是第一个，目的操作数是第二个, 对于不可交换操作来说，这看上去很奇特。例如，指令<code>subq%rax,%rdx</code> 使寄存器<code>%rdx</code>的值减去<code>％rax</code> 中的值。（将指令解成”从<code>%rdx</code> 中减去<code>％rax</code>” 会有所帮助。）第一个操作数可以是立即数、寄存器或是内存位置。第二个操作数可以是寄存器或是内存位置。注意，当第二个操作数为内存地址时，处理器必须从内存读出值，执行操作，再把结果写回内存.</p>
<p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/13.png" style="zoom: 100%;"></p>
<h3 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h3><p>最后一组是移位操作，先给出移位量，然后第二项给出的是要移位的数。可以进行算术和逻辑右移。移位量可以是一个立即数，或者放在单字节寄存器％cl 中。（这些指令很特别，因为<strong>只允许</strong>以这个特定的寄存器作为操作数。）原则上来说，1 个字节的移位量使得移位量的编码范围可以达到$2^8-1= 255$。X86-64 中，移位操作对w 位长的数据值进行操作，移位量是由％cl 寄存器的低m 位决定的，这里$2^m=w$ 高位会被忽略。所以，例如当寄存器％cl 的十六进制值为OxFF 时，指令salb 会移7 位，salw 会移15 位，sail 会移31 位，而salq 会移63 位。<br>如下图所示，左移指令有两个名字：SAL 和SHL。两者的效果是一样的，都是将右边填上0。右移指令不同，SAR 执行算术移位（填上符号位）, 而SHR 执行逻辑移位（填上0）。</p>
<p>移位操作的目的操作数可以是一个寄存器或是一个内存位置。图 3-10 中用$&gt;&gt;_A$(算术)和$&gt;&gt;_L$(逻辑）来表示这两种不同的右移运算。</p>
<p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/22.png" style="zoom: 100%;"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/09/23/git%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/23/git%E5%9F%BA%E7%A1%80/" itemprop="url">git基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-23T08:28:09+08:00">
                2020-09-23
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-09-30T09:33:26+08:00">
                2020-09-30
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="git基础"><a href="#git基础" class="headerlink" title="git基础"></a>git基础</h1><p>git使世界上最受欢迎的版本控制系统，版本控制系统记录随着时间的推移对我们的代码所做的更改。他能知道谁在何时何地进行了那些修改。如果我们有一个版本搞砸了，我们可以轻松地将项目还原到之前的版本。在早期，没有这种版本控制系统，我们不得不不断地以各种方式存储整个项目的副本——这会严重地降低效率尤其是多个人在同一个项目上工作时。</p>
<p>版本控制系统分为2类：分布式和集中式。在集中式系统中，所有人必须连接到中央服务器获取代码的最新副本。比如说 Subversion和Team Foundation Server 。但集中式版本控制系统的问题就是服务器必须在线，否则我们将无法协作</p>
<p>在分布式系统中，我们就能很好的规避这些问题。因为每个团队成员都有一个项目副本及其历史记录。如果我们的中央服务器离线了，我们可以直接与他人同步我们的工作。比如Git和Mercurial</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/1.png" style="zoom: 80%;"></p>
<p>git是这些版本控制器中最流行的，因为git 免费开源，速度快且可扩展。并对分支合并操作十分友好。</p>
<p>那么怎么使用Git呢？</p>
<ul>
<li>我们可以在命令行上使用 Git，也就是在终端或者CMD上使用。</li>
<li>我们可以在代码编辑器或者IDE上的终端使用</li>
<li>Git有自身的GUI可以使用</li>
<li>第三方软件GitKraken、Sourcetree等 GUI (但是我们主要还是使用命令行因为有些远程服务器上不方便安装GUI，使用命令行会更快、更方便)</li>
</ul>
<p>在使用git之前，我们要设置一些信息</p>
<ul>
<li>名字</li>
<li>Email</li>
<li>Default Editor</li>
<li>Line Ending</li>
</ul>
<p>我们可以为三个不同层级设置这些信息</p>
<ul>
<li>System 最高级 面向所有的用户</li>
<li>Global 适用于当前用户的所有repositories</li>
<li>Local 当前repository</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;名字&quot;</span><br><span class="line">git config --global user.email 邮箱</span><br></pre></td></tr></table></figure>
<p>这两行是设置global邮箱和名字的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.editor &quot;code --wait&quot;</span><br></pre></td></tr></table></figure>
<p>这一行是用来告诉终端窗口在我们关闭 vs code界面之前保持等待。在gitbash 中输入code，就会自动跳转至 vsc </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global -e</span><br></pre></td></tr></table></figure>
<p>这行代码是用来看全局配置的.输入以后vscode会跳出一个 .gitconfig文件。</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/2.png" style="zoom: 120%;"></p>
<p>我们还需要设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf true</span><br></pre></td></tr></table></figure>
<p>这是因为不同操作系统下，处理行尾结束符的方法是不同的</p>
<p>首先了解回车和换行</p>
<p><strong>LF：Line Feed 换行</strong></p>
<p><strong>CRLF：Carriage Return Line Feed 回车换行键</strong> </p>
<ul>
<li>　windows下：CRLF（表示句尾使用回车换行两个字符，即windows下的”\r\n”换行）</li>
<li>​    unix下：LF（表示句尾，只使用换行）</li>
<li>​    mac下：CR（表示只使用回车）</li>
</ul>
<p>在git下处理换行有三种情况：</p>
<ul>
<li>设置为true<ul>
<li>当设置成true时，这意味着你在任何时候添加(add)文件到git仓库时，git都会视为它是一个文本文件(text file)。它将把CRLF变成LF。当有人check代码的时候，又会将LF变成CRLF。所以在 windows下使用这个模式。</li>
</ul>
</li>
<li>设置为false<ul>
<li>当设置成false时，line endings将不做转换操作。文本文件保持原来的样子。</li>
</ul>
</li>
<li>设置为input<ul>
<li>添加文件git仓库时，git把CRLF变成LF。当有人check代码的时候还是 LF 方式。因此在window操作系统下，不要使用这个设置。而mac使用这个模式。</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/3.png" style="zoom: 100%;"></p>
<h3 id="Getting-Help"><a href="#Getting-Help" class="headerlink" title="Getting Help"></a>Getting Help</h3><p>这是 git -config 的文档。</p>
<p><a href="https://git-scm.com/docs/git-config" target="_blank" rel="noopener">https://git-scm.com/docs/git-config</a></p>
<p>或者使用 git config  —help 来查看这个文档</p>
<p>git config -h 则会显示一个比较简短的总结。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">usage: git config [&lt;options&gt;]</span><br><span class="line"></span><br><span class="line">Config file location</span><br><span class="line">    --global              use global config file</span><br><span class="line">    --system              use system config file</span><br><span class="line">    --local               use repository config file</span><br><span class="line">    -f, --file &lt;file&gt;     use given config file</span><br><span class="line">    --blob &lt;blob-id&gt;      read config from given blob object</span><br><span class="line"></span><br><span class="line">Action</span><br><span class="line">    --get                 get value: name [value-regex]</span><br><span class="line">    --get-all             get all values: key [value-regex]</span><br><span class="line">    --get-regexp          get values for regexp: name-regex [value-regex]</span><br><span class="line">    --get-urlmatch        get value specific for the URL: section[.var] URL</span><br><span class="line">    --replace-all         replace all matching variables: name value [value_regex]</span><br><span class="line">    --add                 add a new variable: name value</span><br><span class="line">    --unset               remove a variable: name [value-regex]</span><br><span class="line">    --unset-all           remove all matches: name [value-regex]</span><br><span class="line">    --rename-section      rename section: old-name new-name</span><br><span class="line">    --remove-section      remove a section: name</span><br><span class="line">    -l, --list            list all</span><br><span class="line">    -e, --edit            open an editor</span><br><span class="line">    --get-color           find the color configured: slot [default]</span><br><span class="line">    --get-colorbool       find the color setting: slot [stdout-is-tty]</span><br><span class="line"></span><br><span class="line">Type</span><br><span class="line">    -t, --type &lt;&gt;         value is given this type</span><br><span class="line">    --bool                value is &quot;true&quot; or &quot;false&quot;</span><br><span class="line">    --int                 value is decimal number</span><br><span class="line">    --bool-or-int         value is --bool or --int</span><br><span class="line">    --path                value is a path (file or directory name)</span><br><span class="line">    --expiry-date         value is an expiry date</span><br><span class="line"></span><br><span class="line">Other</span><br><span class="line">    -z, --null            terminate values with NUL byte</span><br><span class="line">    --name-only           show variable names only</span><br><span class="line">    --includes            respect include directives on lookup</span><br><span class="line">    --show-origin         show origin of config (file, standard input, blob, command line)</span><br><span class="line">    --default &lt;value&gt;     with --get, use default value when missing entry</span><br></pre></td></tr></table></figure>
<h2 id="Creating-Snapshots"><a href="#Creating-Snapshots" class="headerlink" title="Creating Snapshots"></a>Creating Snapshots</h2><h3 id="Initializing-a-repository"><a href="#Initializing-a-repository" class="headerlink" title="Initializing a  repository"></a>Initializing a  repository</h3><p>我们现在要做的是为我们的project创建一个目录。</p>
<p>我们新建一个文件夹：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir moon</span><br></pre></td></tr></table></figure>
<p>然后再 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>就是在这个文件夹中新建了一个仓库。在win下就显示为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jason@JasonsT90 MINGW64 &#x2F;d&#x2F;projects&#x2F;moon (master)</span><br></pre></td></tr></table></figure>
<h3 id="Git-Workflow"><a href="#Git-Workflow" class="headerlink" title="Git Workflow"></a>Git Workflow</h3><p>现在来介绍一下 Git的工作流程</p>
<p>左边是我们的文件夹，最右边的是Git的仓库。在Git中有一个很多其他版本控制器没有的Staging Area。</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/4.png" style="zoom: 100%;"></p>
<p>当我们对一些文件作出修改之后，我们会将文件暂存在Staging Area中，等确认无误之后，我们才会对Staging Area中的文件进行一个snapshot ,将他们永久的保存在repository当中。有了这个机制之后，我们就能反复确认是否有不应该出现的改变。然后就可以在舍弃这些内容</p>
<p>下面是一个真实的例子，我们有两个文件file1和file2，我们首先将他们放在staging Area中，确认无误后我们递交一个commit,也就是初次提交：<code>git commit -m &quot;Initial commit&quot;</code> </p>
<p>以后，我们将如果修复了bugs、重构了代码，就在第一次的基础之上commit</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/5.png" style="zoom: 100%;"></p>
<p>我们会有一个错误的观念：提交了commit之后staging area就会清空。实际上并不是这样，staging area中的文件仍然是保留的。所以我们可以这样理解：再递交了commit之后， repository 中的文件和staging area中的文件是一模一样的(没递交之前可能有差别，因为staging area中的文件会有更新)</p>
<p>然后我们修改了一个文件 file1 通过代码<code>git add files1</code>将修改后的文件更新至staging area然后再git commit来提交第二个版本，备注了 ”Fixed the bug that…”</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/6.png" style="zoom: 100%;"></p>
<p>现在我们删除本地的 file2文件，再通过<code>git add file2</code>更新至staging area，我们会感到很奇怪，明明是要做删除，但是为什么用 <code>git add file2</code> 呢？ 这是因为git会自动检测 file2 是否在本地。因为本地没有file2，所以在staging area中的file也会删除。这里的add更偏向于更新的意思，而不是单纯的添加。</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/7.png" style="zoom: 100%;"></p>
<p>现在我们的repository中有3个commit了，每一个commit包含了一个git生成的独一无二的ID以及其他信息</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/8.png" style="zoom: 100%;"></p>
<p>我们也许会感到很奇怪git能保存下所有的snapshot，那不会非常消耗内存嘛？实际上 git的内存管理是非常有效的。这是因为git会压缩内容并且不存储重复的内容</p>
<h3 id="Staging-Files"><a href="#Staging-Files" class="headerlink" title="Staging Files"></a>Staging Files</h3><p>我们先创建两个文件 file1和file2，<code>echo hello&gt;&gt;file1.txt</code> 然后利用 git status查看现在的状态。我们发现现在没有commits，现在两个文件也是untracked的。也就是说，现在staging area中还没有文件</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/10.png" style="zoom:120%;"></p>
<p>我们可以使用 git add file1.txt  file2.txt 来添加这两个文件</p>
<p>也可以 git add *.txt 来添加所有扩展名为 txt 的文件。</p>
<p>当然，我们也可以直接 add . 来添加所有文件。但是对这行命令需要注意，因为有些大文件可能是我们不想要的。而且如果递交了大文件有可能会出错。</p>
<p>我们这里只有两个文件，所以我们用 git add . 即可<br>然后我们看看 git status ,我们发现刚才没有 的文件变成了绿色，说明已经被添加至staging area当中了</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/9.png" style="zoom: 100%;">、</p>
<p>现在我们使用 echo 来对file1.txt进行修改， <code>echo world&gt;&gt;file1.txt</code> 再用 git status 查看状态。</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/11.png" style="zoom: 120%;"></p>
<p>我们发现有两个file已经在staging area中了，但是还有一个已经修改过的文件没有提交给 staging area。现在的状态就如下图所示：本地有更新，但是staging area中的文件还未被更新</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/12.png" style="zoom: 100%;"></p>
<p>那么我们敲入 <code>git add .</code>并再次查看状态，发现刚刚修改的文件已经躺在staging area中了</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/13.png" style="zoom: 100%;"></p>
<h3 id="Committing-Changes"><a href="#Committing-Changes" class="headerlink" title="Committing Changes"></a>Committing Changes</h3><p>现在 staging  area保存了我们的文件，然后我们利用 commit 命令来将这些文件交给repository</p>
<p>我们可以用 <code>git commit -m &quot;description&quot;</code> 来提交。有时候短短一行description是不够的(修复 bugs)，我们可以 直接 <code>git commit</code> 然后 git bash 会唤醒 vscode，我们可以在vscode中做更为详细的描述</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/14.png" style="zoom: 100%;"></p>
<p>保存关闭之后，gitbash就会成功commit</p>
<h3 id="Committing-Best-Practices"><a href="#Committing-Best-Practices" class="headerlink" title="Committing Best Practices"></a>Committing Best Practices</h3><p>我们每次commit的代码不要太大或者太小：也就是说不要修改一次代码就commit一次或者写了好几天代码才commit一次，这都不太好。我们要保持一个合理的更新频率(大工作量下每天5-10次)，因为如果我们发现了一些严重问题我们还能够”读档“，”回滚“</p>
<p>而且我们要做到不把两个可以解决的问题放到一个commit当中，比如我现在修复了一个bug，又发现一个排版错误，我们不能把这两个问题合并起来commit 一次。而要分两次commit。</p>
<p>此外我们还要养成对每次commit创建有意义的commit messages(description) 。因为这些信息会显示commit的信息和历史。对未来版本的回退等会更加友好。</p>
<h3 id="Skipping-the-Staging-Area"><a href="#Skipping-the-Staging-Area" class="headerlink" title="Skipping the Staging Area"></a>Skipping the Staging Area</h3><p>我们初学者常常会问，我们一定要每次把我们修改过后的文件放在staging area后才能commit嘛？</p>
<p>事实上我们不必要，我们可以跳过 staging agea直接commit。但做这个行为之前我们必须百分之百保证我们的代码没有问题。</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/15.png" style="zoom: 100%;"></p>
<p>我们可以用命令行 </p>
<p><code>git commit -am &quot;Fix the bug that prevented the users from signing up&quot;</code></p>
<p>-am 也可以写成 -a -m : -a 代表着all，-m 代表 message</p>
<h3 id="Removing-Files"><a href="#Removing-Files" class="headerlink" title="Removing Files"></a>Removing Files</h3><p>有时候我们想删除我们不想要的代码，于是我们需要删除一些文件。</p>
<p>先利用 <code>rm file2.txt</code> 删除 file2.txt，然后我们利用 git ls-files 看看现在 staging area中的文件 :</p>
<p>因为没有更新，所以现在staging area中还是有两个文件。</p>
<p>现在我们 <code>git add file2.txt</code> 再次 git ls-files ，这时候staging area中就只存在一个文件 file1.txt 了</p>
<p>当然，除了  <code>rm file2.txt</code> 之外，我们可以用 <code>git rm file2.txt</code> 直接将本地文件夹和staging area中的file2.txt删除。 <code>git rm</code> 和<code>git add</code>后面都可以跟多个文件或者模板</p>
<h3 id="Renaming-or-Moving-Files"><a href="#Renaming-or-Moving-Files" class="headerlink" title="Renaming or Moving Files"></a>Renaming or Moving Files</h3><p>和 删除文件类似，重命名文件或者是移动文件(切换文件类型) 也有两种方式</p>
<p>第一种是用Unix代码 <code>mv file1.txt main.js</code>  将 file1.txt 转换成main.js 。这时候我们查看git status。我们发现file1.txt已经被删除了，而新增了一个文件main.js. 而这个文件还没有被放进staging area，是untracked的。</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/18.png" style="zoom: 100%;"></p>
<p>我们需要 <code>git add main.js</code> 将文件放入到 staging area当中</p>
<p>第二种方法就是git自己的命令 <code>git mv main.js file1.js</code>  再次查看 git status 我们发现git会直接在本地和staging area同时更新</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/19.png" style="zoom: 130%;"></p>
<h3 id="Ignoring-Files"><a href="#Ignoring-Files" class="headerlink" title="Ignoring Files"></a>Ignoring Files</h3><p>在很多的项目中，我们需要告诉git有些文件需要被忽略。比如日志文件或者机密二进制文件等。我们能通过一些命令来实现。</p>
<p>首先我们新建一个文件夹并在里面写一个log文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir logs</span><br><span class="line">echo hello&gt;logs&#x2F;dev.log</span><br></pre></td></tr></table></figure>
<p>然后我们需要告诉git忽略logs中的文件：</p>
<p>有一个专门的文件叫做 <code>.gitignore</code> 在这个文档里面记录的文件名都不会被git放到staging area中</p>
<p>我们可以通过命令<code>echo logs/ &gt; .gitignore</code>  让logs这个文件夹的内容全部处于被忽略状态</p>
<p>利用 <code>code .gitignore</code> 可以在vscode 中打开 .gitignore</p>
<p>我们也可以手动向<code>.gitignore</code> 中添加我们希望git要忽略的文件。比如 <code>main.log</code> 或者 <code>*.log</code> 等。最后我们需要将<code>.gitignore</code> 加入到staging area 中，再commit之后发现 logs文件夹确实没有被加入进来。</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/20.png" style="zoom: 100%;"></p>
<p>但是需要注意得是，<code>.gitignore</code> 只能对于并不在repository中的文件有效。如果有一个文件已经在repository中了，然后再将他添加到 <code>.gitignore</code> 中去，这是无效的。</p>
<p>下面我们来操作一下：</p>
<p>首先将bin文件夹和里面的一个hello.bin 文件commit到 repository当中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir bin</span><br><span class="line">echo hello &gt; bin &#x2F;hello.bin</span><br><span class="line">git add.</span><br><span class="line">git commit -m &quot;Add bin.&quot;</span><br></pre></td></tr></table></figure>
<p>我们再 <code>.gitignore</code> 中将 <code>bin/</code> 加入并 commit</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;Include bin&#x2F; in gitignore&quot;</span><br></pre></td></tr></table></figure>
<p>现在我们修改<code>hello.bin</code> ，再新建一个<code>app.bin</code>文件。git status 之后,会发现git竟仍然追踪者 bin中的<code>hello.bin</code>文件但是并不会追踪在bin中的新建的 <code>app.bin</code> 文件。</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/21.png" style="zoom: 100%;"></p>
<p>为了解决这个问题，我们需要删除躺在 staging area当中的bin文件夹。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached -r bin&#x2F;</span><br></pre></td></tr></table></figure>
<p>—cached代表着删除的范围是 staging  area， -r是删除文件夹的命令。 <code>git status</code> 之后，发现在staging area中的hello.bin 就被删除了(本地文件没有被删除！)</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/22.png" style="zoom: 100%;"></p>
<p>如果我们再次修改bin中的  <code>hello.bin</code> 文件，git也不会再追踪bin中的文件了。</p>
<h3 id="Short-Status"><a href="#Short-Status" class="headerlink" title="Short Status"></a>Short Status</h3><p>我们修改和新建一些文件，然后 <code>git status</code> 发现文字很多，看起来比较繁杂。我们可以利用 命令<code>git status -s</code> 来精简化它们</p>
<p>我们看到精简过后的status只有两行 。这两行也很容易理解，M files1.js 代表files1.js 被Modified了，而 ?? file2.js 说明file2.js 是未被追踪的。</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/23.png" style="zoom: 100%;"></p>
<h3 id="Viewing-Staged-and-Unstaged-Changes"><a href="#Viewing-Staged-and-Unstaged-Changes" class="headerlink" title="Viewing Staged and Unstaged Changes"></a>Viewing Staged and Unstaged Changes</h3><p>在我们将staging area 中的文件提交之前，我们需要再三回顾我们的代码，因为我们不想把有瑕疵的代码提交。那么我们怎么能看到在staging area当中的一行行代码2呢？ 我们需要使用diff命令</p>
<p><code>git diff --staged</code> </p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/24.png" style="zoom: 100%;"></p>
<p>我们发现这样的文档是比较难阅读的。一般我们会用 GUI 来运行diff命令。我们现在看看怎么来阅读这些文档</p>
<p>我们看到第一行是  diff —git a/file1.js b/file2.js ,说明我们能在比较同一份文件不同拷贝的内容差别。a是比较早的copy，b是比较新的copy(现在存放在staging area当中的copy )</p>
<p><code>@@ -1,3 +1,5 @@</code> 告诉我们那里发生了改变  负号代表了旧的copy，正号代表了新的copy</p>
<p>1,3 代表从第一行开始，一共三行；1,5 代表从第一行开始一共五行</p>
<p>对于 file2.js 文件，因为这是新建的，所以显示为 —- /dev/null  即不存在老的copy</p>
<p>那么如何看本地文件的修改内容呢？ 还是用 diff 命令，不过 这次命令变为 <code>diff --git</code></p>
<h3 id="Visual-Diff-Tools"><a href="#Visual-Diff-Tools" class="headerlink" title="Visual Diff Tools"></a>Visual Diff Tools</h3><p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/25.png" style="zoom: 100%;"></p>
<p>我们使用vscode来查看diff命令。首先我们来做一些设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global diff.tool vscode</span><br><span class="line">git config --global difftool.vscode.cmd &quot;code --wait --diff $LOCAL $REMOTE&quot;</span><br></pre></td></tr></table></figure>
<p>第一行命令是让我们将difftool设置为vscode 并对所有的repository适用</p>
<p>第二行命令是告诉git怎么唤醒vscode帮助我们diff文件。—wait 告诉终端保持等待状态直到我们关闭vscode为止，$LOCAL 和 $REMOTE 则代表了老的copy和新的copy</p>
<p>然后我们用 <code>git config --global -e</code> 打开vscode</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/26.png" style="zoom: 100%;"></p>
<p>我们发现diff 后面并没有$LOCAL 和 $REMOTE我们再把他补全</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/27.png" style="zoom: 100%;"></p>
<p>然后我们用 <code>git difftool --staged</code> 来让vscode充当我们的diff工具</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/30.png" style="zoom: 100%;"></p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/28.png" style="zoom: 100%;"></p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/29.png" style="zoom: 100%;"></p>
<p>但是现如今使用Diff工具的机会不多，大多数编辑器或者IDE都支持查看 staged 和 unstaged changes</p>
<h3 id="Viewing-History"><a href="#Viewing-History" class="headerlink" title="Viewing History"></a>Viewing History</h3><p>我们已经commit不少次了，那么我们怎么才能看这些commit的信息呢？</p>
<p>使用命令 <code>git log</code></p>
<p>如果觉得信息太繁杂，我们可以使用命令 <code>git log --oneline</code> </p>
<p>我们看到这个顺序是越上面的越晚提交。</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/31.png" style="zoom: 100%;"></p>
<p>如果我们想把最早递交的版本放到第一行，可以使用</p>
<p><code>git log --oneline --reverse</code></p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/32.png" style="zoom: 100%;"></p>
<h3 id="Viewing-a-Commit"><a href="#Viewing-a-Commit" class="headerlink" title="Viewing a Commit"></a>Viewing a Commit</h3><p>刚才我们看了整体递交的信息，但是如果我们想看看某一个特定commit所做的改变该怎么办呢？</p>
<p>我们看到在每个commit之前有一串序列。这就是这个commit的ID，我们用命令 <code>git show ID</code> 来查看这个commit的信息</p>
<p>如果我们只想看最后一次commit ，我们可以  <code>git show HEAD</code></p>
<p>或者我们想看倒数第n次的我们只要命令 <code>git show HEAD~n-1</code> 就行了</p>
<p>如果我们不想看commit更新了什么，我们只想看特定文件中的所有代码，我们可以再原来的基础上加上冒号和文件名即可。比如 <code>git show HEAD~1:.gitignore</code>  就是查看倒数第二次提交的 <code>.gitignore</code> 文件。</p>
<p>我们也可以使用 <code>git ls-tree</code> 来查看一个commit中的所有文件</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/33.png" style="zoom: 100%;"></p>
<p>我们看到在这个commit当中有三个Objects，两个文件和一个bin文件夹</p>
<p>git 有四种类型的Objects</p>
<ul>
<li>Commits</li>
<li>Blobs(Files)</li>
<li>Trees(Directories)</li>
<li>Tags</li>
</ul>
<h3 id="Unstaging-Files"><a href="#Unstaging-Files" class="headerlink" title="Unstaging Files"></a>Unstaging Files</h3><p>在 git add . 之后，我又修改了 file1.js ,那么现在的 status 就是一个绿色的M一个红色的M。现在我想撤回第一个 git add . 的命令，也就是将 file1.js 从staging area取出再放到本地。</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/35.png" style="zoom: 100%;"></p>
<p>我们可以使用 命令 <code>git restore --staged file1.js</code> 就可以了</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/36.png" style="zoom: 100%;"></p>
<p>如果我再 <code>git restore --staged file2.js</code> ，那么我们会发现file2也不会被git追踪了</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/37.png" style="zoom: 100%;"></p>
<h3 id="Discarding-Local-Changes"><a href="#Discarding-Local-Changes" class="headerlink" title="Discarding Local Changes"></a>Discarding Local Changes</h3><p>如果我们现在对本地文件进行了改变，但是发现这个改变有错误，想要取消。也可以用 restore命令来实现。其原理就是从 staging area中拷贝一份，再复制到 working directory</p>
<p><code>git restore file1.js</code></p>
<p>现在我们对本地的所有文件 执行命令 <code>git restore .</code> 却发现file2.js 这个问题。这是因为本来 file2.js 就不在staging area当中了。git不知道从哪里去复制。</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/38.png" style="zoom: 100%;">         </p>
<p>为了解决这个问题，我们可以使用 <code>git clean -fd</code> 来完成操作。这个操作其实就是将 file2.js 从我们的文件夹中删除。</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/39.png" style="zoom: 100%;">                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </p>
<h3 id="Restoring-a-File-to-an-Earlier-Version"><a href="#Restoring-a-File-to-an-Earlier-Version" class="headerlink" title="Restoring a File to an Earlier Version"></a>Restoring a File to an Earlier Version</h3><p>现在我们要演示一下如果我们误操作删除了一个本地文件，我们怎么利用git恢复到之前的版本。我们删除文件最好使用 <code>git rm</code> 因为git rm会将文件同时从staging area 和 working directory 中删除。</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/40.png" style="zoom: 100%;"></p>
<p>但是现在我发现这个文件是不该删除的！那么怎么回退呢？？</p>
<p>我们首先查看日志我们看到 ID为 6e72a9b 这个版本是我们要恢复的。</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/41.png" style="zoom: 100%;"></p>
<p>回复命令如下：<code>usage: git restore [&lt;options&gt;] [--source=&lt;branch&gt;] &lt;file&gt;...</code> </p>
<p>我们用命令 <code>git restore --source=HEAD~1 file1.js</code> 来恢复从HEAD开始数上一个版本中的file1.js 文件。</p>
<h3 id="Creating-Snapshots-with-VScode"><a href="#Creating-Snapshots-with-VScode" class="headerlink" title="Creating Snapshots with VScode"></a>Creating Snapshots with VScode</h3><p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/42.png" style="zoom: 100%;"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/" itemprop="url">CSAPP信息的表示和存储2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-17T18:48:14+08:00">
                2020-09-17
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2021-01-31T22:13:34+08:00">
                2021-01-31
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="CSAPP信息的表示和存储2"><a href="#CSAPP信息的表示和存储2" class="headerlink" title="CSAPP信息的表示和存储2"></a>CSAPP信息的表示和存储2</h1><h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><h3 id="无符号加法"><a href="#无符号加法" class="headerlink" title="无符号加法"></a>无符号加法</h3><p>当两个非负整数 x,y 满足 $0\leq x,y&lt; 2^w$ 。那么 $x+y$ 就有可能是一个w+1位数。比如一个四位的无符号整数的取值范围是0-15，但其和的范围是0~30. 我们要让无符号数之和仍然位w位，那么我们需要做数的截断。 </p>
<p>我们定义 一个运算 $+_w^u$ ，其操作是把整数 x+y <strong>截断</strong>为w位得到的结果，再把这个结果<strong>看作是一个无符号数</strong>。这可以被视为一种形式的模运算，对 $x+y$ 的位级表示，简单丢弃任何权重大于 $2^{w-1}$ 的位就可以了。比如考虑一个4位数字表示， $x=9$ 和 $y = 12$ 的位表示分别是 $[1001]$ 和 $[1100]$ 。他们的和是21，5位表示为$[10101]$ 但是如果丢弃最高位，我们就得到了 $[0101]$ 也就是说 十进制的值是5，这和21 mod 16 = 5 一致。</p>
<p>我们可以将操作 $+_w^u$ 这样描述</p>
<p>对满足 $0\leq x,y&lt; 2^w$ 的 x和y有：</p>
<p>$x<del>+_w^u</del> y =\begin{cases}x+y,x+y\leq 2^w ~~ 正常\ x+y-2^w,2^w\leq x+y&lt;2^{w+1}~~ 溢出\end{cases} $ </p>
<p>如下图，左边的 x+y  y映射到右边的无符号 w位的和 $x~+_w^u ~y$ 正常情况下 x+y 的值保持不变，而溢出的情况则是该和减去$2^w$ 后的结果。</p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/1.png" style="zoom: 150%;"></p>
<p>当执行 C程序时，不会将溢出作为错误而发信号。不过有的时候，我们可能希望判定是否发生了溢出</p>
<p>对在范围 $0\leq x,y\leq UMax_w $ 中的x和y， 令 $s=x~+_w^u ~y$ 。则对计算 s，当且仅当 $s&lt;x$ 时，发生了溢出。</p>
<p>比如说，在前面的示例中，我们看到 $9~+_4^u~12 = 5$. 由于 $5&lt;9$ ,我们可以看出发生了溢出。</p>
<h3 id="补码加法"><a href="#补码加法" class="headerlink" title="补码加法"></a>补码加法</h3><p>对于补码加法，我们必须确定当结果<strong>太大</strong>或者<strong>太小</strong>时，应该做些什么</p>
<p>给定在范围 $-2^{w-1}\leq x,y\leq 2^{w-1}-1$ 之内的整数值x和y，它们的和就在 $-2^w\leq x+y\leq2^w-2$ ，要想准确表示，可能需要w+1 位。我们把他截成w位，并将这个结果看做是补码数。</p>
<p>对满足 $-2^{w-1}\leq x,y\leq 2^{w-1}-1$ 的整数x和y，有：</p>
<p>$x+_w^t~y = \begin{cases}x+y-2^w,2^{w-1}\leq x+y <del>正溢出\ x+y,-2^{w-1}\leq x+y&lt;2^{w-1}</del>正常\x+y+2^w,x+y&lt;-2^{w-1} ~~ 负溢出\end{cases}$ </p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/2.png" style="zoom: 100%;"></p>
<p>两个数的w 位补码之和与无符号之和有完全相同的位级表示。实际上，大多数计算机使用同样的机器指令来执行无符号或者有符号加法。</p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/3.png" style="zoom: 100%;"></p>
<p>上图阐述了字长 $w=4$ 的补码加法。运算数的范围为 $-8到7$ 之间 。当$x+y&lt;-8$ 时，补码加法就会负溢出，导致和增长了16(Case 1)。当 当 $-8\leq x+y &lt;8$ 时，加法就产生了 $x+y$ 。当 $x+y\geq 8$ ,加法就会正溢出，让和减少了16。 </p>
<h4 id="检测补码加法中的溢出"><a href="#检测补码加法中的溢出" class="headerlink" title="检测补码加法中的溢出"></a>检测补码加法中的溢出</h4><p>对满足 $TMin_w\leq x,y\leq TMax_w$ 的x和y，令 $s=x~+_w^t~y$ . 当且仅当 $x&gt;0,y&gt;0$ 但是 $s\leq0$ 时，计算s发生了正溢出。当且仅当 $x&lt;0,y&lt;0$但是 $s\geq 0$ 时，计算s发生了负溢出。</p>
<h4 id="位操作相同的好处"><a href="#位操作相同的好处" class="headerlink" title="位操作相同的好处"></a>位操作相同的好处</h4><p>这样会让电路逻辑变得更简单，电路在设计的时候并不需要判断是否为补码或者无符号数。</p>
<h3 id="无符号的非"><a href="#无符号的非" class="headerlink" title="无符号的非"></a>无符号的非</h3><p>我们可以定义一个加法逆元(减) $-_w^u$ 。满足 $-_w^ux+_w^ux=0$ </p>
<p>无符号数求反</p>
<p>$-_w^u x=\begin{cases}x,x=0\ 2^w-x,x&gt;0\end{cases}$ </p>
<h3 id="补码的非"><a href="#补码的非" class="headerlink" title="补码的非"></a>补码的非</h3><p>可以看到范围在 $TMin_w\leq x\leq TMax_w$ 中的每个数字x都有 $+^t_w$ 下的加法逆元，我们把 $-_w^t x$ 表示如下：</p>
<p>补码的非</p>
<p>对满足 $TMin_w\leq x\leq TMax_w$ 的x，其补码的非 $-^t_w x$ 可表示为</p>
<p>$-_w^t x=\begin{cases}TMin_w,x=TMin_w\ -x,x&gt;TMin_W\end{cases}$ </p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/4.png" style="zoom: 100%;"></p>
<p>补码的非和无符号的非拥有相同的模式</p>
<h3 id="无符号乘法"><a href="#无符号乘法" class="headerlink" title="无符号乘法"></a>无符号乘法</h3><p>范围在 $0\leq x,y\leq 2^w-1$ 内的整数 x和y 可以被表示为 w位的无符号数，但是它们的乘积 $x\cdot y$ 的取值范围是 $(2^w-1)^2 = 2^{2w}-2^{w+1}+1$ 之间。这可能需要2w位来表示。不过C愿意浓重的无符号乘法被定义为产生w位的值。因此我们需要进行数的截断，我们将这个值表示为 $x *_w^u y$ </p>
<p>将一个无符号数截断位w位等价于计算值mod $2^w$ 得到：</p>
<p>对满足 $0\leq x,y\leq UMax_w$ 的x和y 有：</p>
<p>$x *_w^u y = (x\cdot y)<del>mod</del> 2^w$</p>
<h3 id="补码乘法"><a href="#补码乘法" class="headerlink" title="补码乘法"></a>补码乘法</h3><p>和无符号乘法类似， 范围在 $-2^{w-1}\leq x,y\leq 2^{w-1}-1$ 内的整数x和y可以被表示为位的补码数字，但是它们的乘积$x\cdot y$ 取值在 $-2^{2w-2}+2^{w-1}$ 到 $2^{2w-2}$ 之间，于是我们需要把这个可能长度位2w的串截断成w位的串。我们将这个数值表示为 $x*_w^t y$ 。将一个补码数截断为w位相当于先计算值模 $2^w$ 再把无符号数转换为补码，得到：</p>
<p>对满足 $TMin_w\leq x,y\leq TMax_w$ 的x和y有：</p>
<p>$x*_w^t y = U2T_w((x\cdot y) <del>mod</del> 2^w)$</p>
<p>所以对无符号和补码乘法来说，乘法运算的位级表示都是一样的，只是解释的方法不同而已。比如下面这个例子，我们就可以看到截断过后补码乘法和无符号乘法的编码都是相等的。</p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/5.png" style="zoom: 100%;"></p>
<p>如果乘法需要保留未被阉割的结果，需要扩展字长。如果需要，由软件(库)实现。</p>
<p>例子：11101001*11010101</p>
<h3 id="乘以常数"><a href="#乘以常数" class="headerlink" title="乘以常数"></a>乘以常数</h3><p>我们的编译器对整数乘法指令进行了一定的优化，试着用移位或者加法运算的组合来代替乘以常数因子的乘法。首先我们会考虑乘以2的幂的情况，然后再概括成乘以任意常数。</p>
<p>设x为位模式$[x<em>{w-1},x</em>{w-2},\cdots,x<em>0]$ 表示的无符号整数。那么对任何 $k\geq 0$ 我们都热为$[x</em>{w-1},x_{w-2},\cdots,x_0,0,\cdots,0]$ 给出了 $x2^k$ 的 $w+k$ 位的无符号表示，也就是右边加上了k个0</p>
<p>比如，当 $w=4$ 时， 11可以表示为 $[1011]$ 。$k=2$ 时将其左移得到6位向量[101100] ，即可编码为无符号数11*4 =44</p>
<p>那么我们可以固定字长，再左移k为时，相当于其最高的k位被丢弃。得到<br>$[x<em>{w-k-1},x</em>{w-k-2},\cdots,x_0,0,\cdots ,0]$ 而执行固定字长的乘法，也是这种情况，因此我么可以看出左移一个数值等价于执行一个于2的幂相乘的无符号乘法。</p>
<p>其实，在C里面就是通过移位来计算无符号乘法和补码乘法的</p>
<p>C变量x和k有无符号数值x和k，且 $0\leq k\leq w$ ,则C表达式 $x&lt;&lt;k$ 产生数值 $x<em>_w^u 2^k$ . 类似的，补码乘法也可以由此定义 ，只是将 $x&lt;&lt;k$ 产生的数值改变为 $x</em>_w^t2^k$</p>
<p><strong>注意</strong>，无论时无符号运算还是补码运算，乘以2的幂都有可能导致溢出。但是即使溢出时我们通过移位导致的运算结果也是一样的。比如说[1011]左移两位得到[101100] 这显然溢出了，我们将这个值截断位4位得到[1100] 也就是44 mod $2^4$ = 16</p>
<p>由于整数乘法比移位和加法的代价要大得多，许多C 语言编译器试图以移位、加法和减法的组合来消除很多整数乘以常数的情况</p>
<p>比如对于整数 4[100] 和7[111] 计算4*7 可以化为 $4*(2^2+2^1+2^0)$ ，也就是变成了 $[10000]+[01000]+[00100] = [11100] = 2^4+2^3+2^2=28$  </p>
<p>再将$[11100]$截断为4位也就是 $[1100]$ ,也就是28mod 16 = 12</p>
<p>当然有时候还可以变成减法，比如乘以14可以变为 $2^4-2^1$ ,将其重写为$(x&lt;&lt;4)-(x&lt;&lt;1)$ </p>
<p>当然，选择使用移位、加法和减法的组合，还是使用一条乘法指令，取决于这些指令的相对速度，而这些是与机器高度相关的。大多数编译器只在需要少量移位、加法和减法就足够的时候才使用这种优化</p>
<h3 id="除以2的幂"><a href="#除以2的幂" class="headerlink" title="除以2的幂"></a>除以2的幂</h3><p>除以2的幂的无符号除法</p>
<h4 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h4><p>有<strong>无符号</strong>数值x和k，且 $0\leq k<w$ 则c表达式 x>&gt;k 产生数值  ⌊$x/2^k$⌋<br>对无符号来说，右移采用的是逻辑右移。下面是一些无符号右移的例子：</w$></p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/6.png" style="zoom: 100%;"></p>
<p>对于无符号来说，右移和除法是等价的。<strong>都是向下取整</strong></p>
<h4 id="有符号数-补码"><a href="#有符号数-补码" class="headerlink" title="有符号数(补码)"></a>有符号数(补码)</h4><p>C语言中有补码值x和无符号数值k，且 $0\leq k<w$, 则当执行算数移位时，c表达式 $x>&gt;k$ 产生数值 ⌊$x/2^k$⌋  </w$,></p>
<p>对于 $x\geq 0$ 变量 x的最高有效位为0，所以效果与逻辑右移是一样的。因此对于非负数来说，算数右移k位与除以 $2^k$ 是一样的。</p>
<p>对于 $x<0$ ，情况要复杂一点，首先为了保证负数仍然为负，我们要执行的是算术右移。c表达式 x>&gt;k产生的数值为$[x/2^k]$ </0$></p>
<p>但是当补码除以$2^k$ 的时候，运行的是 $(x+(1&lt;<k)-1)>&gt;k$ ，这个是向上取整的。</k)-1)></p>
<p>关于这个公式。我们可以分几种情况来讨论。首先$1&lt;&lt;k -1 == 2^k-1$ 也就是 $\overline {1\cdots 1}$  </p>
<p>如果可以整除$2^k$ 说明二进制右边k位都为0，这样加上 $\overline {1\cdots 1}$  之后再右移k位相当于把  $\overline {1\cdots 1}$  都移走了。</p>
<p>如果不能整除$2^k$ 那么对于无符号数，$(x+(1&lt;<k)-1)>&gt;k$ 是<strong>向上取整</strong>的。对于有符号数的负数，$(x+(1&lt;<k)-1)>&gt;k$ 是向上取整的。<strong>有符号数的正数部分不要用这个公式</strong>。</k)-1)></k)-1)></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>无符号数</th>
<th>补码的正数</th>
<th>补码的负数</th>
</tr>
</thead>
<tbody>
<tr>
<td>除以$2^k$</td>
<td>向下取整(向0取整)</td>
<td>向下取整(向0取整)</td>
<td>$(x+(1&lt;<k)-1)>&gt;k$ 向上(0)取整</k)-1)></td>
</tr>
<tr>
<td>右移k位</td>
<td>向下取整，逻辑右移</td>
<td>向下取整(算数右移)</td>
<td>向下取整(算术右移)</td>
</tr>
</tbody>
</table>
</div>
<p>那么我们也可以从中推导出向0取整的位运算。$(x<0~~?~~x+(1<<k)-1 : x)>&gt; k$</0~~?~~x+(1<<k)-1></p>
<h3 id="补码的相反数"><a href="#补码的相反数" class="headerlink" title="补码的相反数"></a>补码的相反数</h3><p>$-x == $ ~$x +1$</p>
<h3 id="什么时候应该用无符号数"><a href="#什么时候应该用无符号数" class="headerlink" title="什么时候应该用无符号数"></a>什么时候应该用无符号数</h3><ul>
<li><p>Do Use When Performing Modular Arithmetic</p>
<ul>
<li>Multiprecision arithmetic</li>
</ul>
</li>
<li>Do Use When Using Bits to Represent Sets<ul>
<li>Logical right shift, no sign extension</li>
</ul>
</li>
<li>Do Use In System Programming<ul>
<li>Bit masks, device commands,…</li>
</ul>
</li>
</ul>
<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>这章我们将看到 IEEE浮点格式中数字是如何表示的，我们还将探讨舍入的问题，即向上调整或者向下调整。</p>
<h3 id="二进制小数"><a href="#二进制小数" class="headerlink" title="二进制小数"></a>二进制小数</h3><p>理解浮点数的第一步是考虑含有小数值的二进制数字. </p>
<p>首先我们来理解十进制下的小数，$d<em>md</em>{m-1}\cdots d<em>1d_0d</em>{-1}d<em>{-2}\cdots d</em>{-n}$  ，那么 $d=\Sigma_{i=-n}^m 10^i * d_i$ </p>
<p>比如12.34就相当于 $1<em>10^1+2</em>10^0+3<em>10^{-1}+4</em>10^{-2} = 12\frac{34}{100}$ </p>
<p>我们类比一下，二进制的浮点数就可以写为 $b<em>mb</em>{m-1}\cdots b<em>1b_0b</em>{-1}b<em>{-2}\cdots b</em>{-n}$  的表示法，其中每个二进制数字，或者称为位，$b_i$ 的取值范围是0和1，如</p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/7.png" style="zoom: 100%;"></p>
<h6 id="用这种方式定义的二进制如下：-b-Sigma-i-n-m-2-i-b-比如说-101-11-2-可以表示为数字-12-2-02-1-12-0-12-1-12-2-4-0-1-frac-1-2-frac-1-4-4-frac-3-4"><a href="#用这种方式定义的二进制如下：-b-Sigma-i-n-m-2-i-b-比如说-101-11-2-可以表示为数字-12-2-02-1-12-0-12-1-12-2-4-0-1-frac-1-2-frac-1-4-4-frac-3-4" class="headerlink" title="用这种方式定义的二进制如下： $b=\Sigma_{i=-n}^m 2^i b$ 比如说 $101.11_2$ 可以表示为数字 $12^2+02^1+12^0+12^{-1}+12^{-2}= 4+0+1+\frac{1}{2}+\frac{1}{4} = 4\frac{3}{4}$"></a>用这种方式定义的二进制如下： $b=\Sigma_{i=-n}^m 2^i <em>b$ 比如说 $101.11_2$ 可以表示为数字 $1</em>2^2+0<em>2^1+1</em>2^0+1<em>2^{-1}+1</em>2^{-2}= 4+0+1+\frac{1}{2}+\frac{1}{4} = 4\frac{3}{4}$</h6><p>从等式中可以很容易地看出来，二进制小数点向左移一位相当于这个数被2除。例如，$101.11_2$ 表示数 $5\frac{3}{4}$ 而 $10.111_2$ 表示数 $2+0+\frac{1}{2}+\frac{1}{4}+\frac{1}{8} = 2\frac{7}{8}$  类似，二进制小数点向右移动一位相当于将该数乘2，比如 $1011.1_2$ 可以表示数 $8+0+2+1=11\frac{1}{2}$ </p>
<p>注意，形如$0.11⋯1_2$的数表示的是刚好小于1 的数。例如，$0.111111_2$ 表示$\frac{63}{64}$ ，将用简单的表达法$1.0-\epsilon$ 来表示这样的数值。 </p>
<p>假定我们仅考虑有限长度的编码，那么10进制表示法不能准确地表达像$\frac{1}{3}$和$\frac{5}{7}$ 这样的数。类似，小数的二进制表示法只能表示那些只能够被写成 $x*2^y$ 的数，其他的值只能被近似的表示。</p>
<p>比如说 $\frac{1}{3}  = 0.0101010101[01]_2$  </p>
<p>比如说，数字 $\frac{1}{5}$ 可以用十进制小数 $0.20$ 精确表示。不过，我们并不能把它准确的表示为一个二进制小数，我们只能近似表示它，增加二进制表示的长度可以提高表示的精度。</p>
<h3 id="IEEE浮点表示"><a href="#IEEE浮点表示" class="headerlink" title="IEEE浮点表示"></a>IEEE浮点表示</h3><p>IEEE 浮点标准，使用 V(浮点数) = $(-1)^s\times M\times 2^E$ 的形式来表示一个数。这就是一个二进制科学计数法的表示形式。</p>
<p>s代表sign， 是决定这个数是负数(s=1) 还是正数(s=0) ,而对于数值0的符号位解释作为特殊情况处理。</p>
<p>M代表尾数(significand) M是一个二进制的小数，范围要么在 $(1,2-\epsilon)$ 之间要么在 $(0,1-\epsilon)$ 之间</p>
<p>E代表阶码(exponent) E的作用是对浮点数加权，这个权重 就是二的E次幂(可能是负数) </p>
<p>如下图所示</p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/8.png" style="zoom: 100%;"></p>
<p>在单精度浮点数(float) 中，s,exp,frac 字段分别为 1 位，$k=8$ 位和 $n=23$ 位</p>
<p>在双精度浮点数(double) 中，s、exp、frac 字段分别为1位，$k=11$ 和 $n=52$ 位，得到一个64位的表示。</p>
<p>将浮点数的这三个字段分别编码：</p>
<ul>
<li>一个单独的符号位 s 直接编码符号 s</li>
<li>k位的阶码字段 $exp = e_{k-1}\cdots e_1e_0$ 编码阶码E。</li>
<li>n位小数字段$frac= f_{n-1}\cdots f_1f_0$ 编码尾数M，但是编码出来的值也依赖于阶码的字段是否等于0。</li>
</ul>
<p>为什么exp再frac前面？当我们对两个同符号数比较大小的时候，可以先直接比较阶的大小。但是尾数在前面的话就会增大计算量。</p>
<p>根据 exp 的值，被编码的值可以分成三种不同的情况(最后一种情况有两个变种)</p>
<h4 id="1-Normalized"><a href="#1-Normalized" class="headerlink" title="1.Normalized"></a>1.Normalized</h4><p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/9.png" style="zoom: 100%;"></p>
<p>这是最普遍的情况。即当exp的位模式既不全为0(数值0) ,也不全为1(单精度数值为1，双精度数值为2047) 时，都属于这类情况，在这类情况中，阶码字段被解释为以偏置(biased)的形式表示的有符号整数。也就是说，阶码的值是 $E=e-Bias$, 其中e是无符号数，其为表示为 $e_{k-1}\cdots e_1e_0$ ,而$Bias$ 是一个等于 $2^{k-1}-1$(单精度是127, 双精度 1023) 的<strong>定值</strong>，目的是让原来都是正的指数一部分变成负的。由此产生指数的取值范围，对单精度是 $-126$~$+127$ ,而对于双精度来说是 $-1022到 +1023$  </p>
<p>那么问题来了，为什么我们不用补码去表示，而要用 e-Bias 这种移码来表示呢？ 因为对于阶来说，主要是用来比较大小和加减法，从这个角度看，虽然表示的范围相近，但是移码的计算更加方便。</p>
<p>小数字段frac 被解释为描述小数值f , 其中 $0\leq f&lt;1$ ，其二进制表示为 $0.f_{n-1}\cdots f_1f_0$ ,也就是二进制小数点在最高有效位的左边。尾数定义为 $M=1+f=1.frac$  。 </p>
<p>这个设计难懂但是非常巧妙。这个方法有时也被叫做隐含的以1 开头的(implied leading 1)表示 。也就是说我们可以把 M看作是一个二进制表达式 $1.f<em>{n-1}f</em>{n-2}\cdots f_0$ 的数字。既然我们总是能够调整阶码E，使得尾数M在范围 $1\leq M&lt;2$ 之中(假设没有溢出)。那么这种表示方法就可以轻松获得一个额外精度位的技巧。既然第一位总是等于1，那么我们就不需要显示地表示。</p>
<p>比如说对于一个浮点数 f=.10101,如果我们不把小数点左边的数值设置为1，让$exp(2^k)$ 来操纵小数点移位，那么表示.10101 就需要5位。但是我们如果把小数点左边的数值设置为1，那么再让$exp(2^k)$ 来操纵小数点移位后，表示.10101 只需要用 1.0101 表示后再像右移一位就行了，也就是说我们现在只需要4位就可以编码出 .10101. 相当于牺牲了阶码中的1，但获得一个精度位,能多表示 $2^{127}$ 个数。</p>
<h4 id="2-Denormalized"><a href="#2-Denormalized" class="headerlink" title="2.Denormalized"></a>2.Denormalized</h4><p>仅仅Normalized浮点数时不够的，因为Normalized能表示的绝对值最小的浮点数和绝对值次小值浮点数之间的差距是要小于绝对值最小的浮点数和0之间的差距的。这和科学计数法的“本意”相违背。科学计数法要求越接近0.数值越密，但是对Normalized来说，到0之间存在一段比较大的“真空”值。</p>
<p>从下面这张表格我们可以更明显地看出Normalized局限性。在8位浮点数种， 阶码位k=4,小数位 n=3,偏置量 $2^{3}-1 =7$ .那么这个8位浮点数能表示的最小的Normalized数就是 0.0001000，f=0 但是$ M = 1+f =\frac{8}{8}$  $V_1 = 2^E\times M = 2^{-6}\times 1=\frac{1}{64}$ = 0.015625<br>Normalized的次小值是 $0.0001001$ ，值$V_2=0.017578$ </p>
<p> $V_2-V_1&lt;V_1-0.0$ ，就不符合科学计数法的主旨。</p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/13.png" style="zoom: 100%;"></p>
<p>所以我们设计了Denormalized数，也就是阶码域为全0。这种情况下，阶码的值 是$E=1-Bias$ 。而尾数的值是 $M=f$，也就是小数字段的值，小数点左边为0。Denormalized能够提供一个逼近于0的数，也就是讲上面所说的那段真空区域等分。</p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/10.png" style="zoom: 100%;"></p>
<p>为什么将阶码的值设为 $E = 1-Bias$？把$M=f    $这样设计可以让最大的Denormalized和最小的Normalized能够平顺连接.我们知道在8位的浮点数下，最小的 Normalized 数为0.015625，而最大的Denormalized 为0.013672 ，他们之间相差了 $\frac{1}{512}$ 。从最大的Deormalized数继续向0逼近，所有的数之间都是等间距的，因为阶数始终为0。</p>
<p>非规格化数有两个用途。</p>
<p>首先，这<strong>提供了一种表示数值0的方法</strong>，因为使用规格化数，我们必须总是使 $M\geq 1$ ，因此我们不能表示0，实际上，$+0.0$ 的浮点表示的位模式为全0：符号位是0，阶码字段全为0(表明一个非格式化的值) ，而小数域也全为0，这就得到了 $M=f=0$ 令人奇怪的是，当符号位为1，而其他域全为0的时候，我们得到了值 $-0.0$。 +0和-0 其实表示了是从正向还是负向无限接近于0。</p>
<p>非格式化数的另外外一个功能是表示那些非常接近于0.0的数</p>
<h4 id="3-1Infinity"><a href="#3-1Infinity" class="headerlink" title="3.1Infinity"></a>3.1Infinity</h4><p>最后一类数值是当 阶码全为1的时候出现的。当小数域全为0时，得到的值表示无穷。当s=0 时是$+\infty$ ，或者当 $s=1$ 时是 $-\infty$ 。当我们把两个非常大的数相乘，或者除以0时，无穷能表示溢出的结果</p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/11.png" style="zoom: 100%;"></p>
<p>比如说 1.0/0.0可能会取到Infinity，这是因为 0.0可能不是真正的0，只是相近为0，所以1.0/0.0 可能是有意义的。</p>
<h4 id="3-2NaN"><a href="#3-2NaN" class="headerlink" title="3.2NaN"></a>3.2NaN</h4><p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/12.png" style="zoom: 100%;"></p>
<p>但是当小数域不为0的时候，结果值被称为 NaN，即(Not a Number)，一些运算的结果不能是实数或者无穷，就会返回这样的NaN值，比如当计算 $\sqrt{-1}$ 或 $\infty - \infty$ 的时。在某些应用中，表示未初始化的数据时，他们也很有用处。</p>
<h3 id="数字示例"><a href="#数字示例" class="headerlink" title="数字示例"></a>数字示例</h3><p>现在我们假设一个6位的浮点数，有 $k=3$ 的阶码位和 $n =2$ 的尾数位。偏置量是 $2^2-1=3$ 。那么下面的图就显示了所有可表示的值(除了NaN) 。两个无穷值在两个末端。最大数量值的Normalized数是 $\pm14$ Denormalized数聚集在 0 附近。</p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/14.png" style="zoom: 100%;"></p>
<p>我们发现, 那些可以表示的数并不是均匀分布的：越靠近原点处它们越稠密。</p>
<h3 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h3><p>因为表示的方法限制了浮点数的范围和精度，所以浮点运算只能近似地表示实数运算。因此对于值x，我们一般通过舍入运算来找到最接近的匹配值 x’, 那么我们就不能选择四舍五入。因为这样向上舍入的概率会大于向下舍入的概率。下面是四种不同的摄入方式，第一种是向偶数舍入，也就是说，出现 x.5 的时候，向这个数的最接近的偶数舍入。比如 1.5向2舍入；2.5向2舍入 -2.5向-2 舍入。这样一来，向上舍入和向下舍入的概率就相等了。单仅限于最后一位是5，其他的数字还是按照四舍六入的方式进行。</p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/15.png" style="zoom: 100%;"></p>
<p>那么，对于二进制小数，我们也可以使用向偶数舍入。我们将最低有效位的值0 认为是偶数，值1认为是奇数。那么只有对形如 $X\cdots X.Y\cdots Y100\cdots$  的二进制位模式的数才可以向偶数舍入。最右边的Y是要被舍入的位置。如果最后是100的话，就要把Y向偶数舍入，<strong>Y若为1，那么向上舍入取0进1，若Y为0，那么直接移去后面的100</strong>.</p>
<p>比如 $10.11100 $向上舍入成11.00，而10.10100 向下舍入成10.10</p>
<p>像其他的数，如 $10.00011_2$ 就直接向下舍入到 $10.00$ 而 $10.00110_2$ 向上舍入到 $10.01_2$ </p>
<h3 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h3><p>$x +_f y = Round(x + y)$<br>$x ×_f y = Round(x × y)$ </p>
<p>浮点数的加法或者乘法可能会溢出，也可能需要舍入。</p>
<h4 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h4><p>对于两个浮点数 $(-1)^s\times M\times 2^E$ 相乘得到 $=(-1)^{s_1}\times M_1\times 2^{E_1}\times(-1)^{s_2}\times M_2\times 2^{E_2}$ </p>
<p>所以结果就可以这样表示：$s = s_1$^$s_2,M=M_1\times M_2,E=E_1+E_2$  </p>
<p>那么，如果 出现了 $M\geq 2$ ，则M右移，增加E</p>
<p>如果E超过了范围，那么就发生了溢出</p>
<p>如果E不超过范围，那么对M进行舍入，计算得到frac</p>
<p>乘法的数学性质：</p>
<ul>
<li>封闭</li>
<li>交换律成立</li>
<li>结合律不成立</li>
<li>1的性质成立</li>
<li>乘法对加法的分配律不成立</li>
<li>单调性成立 $(a\geq b ~\&amp;~c\geq 0\Rightarrow a<em>c\geq b</em>c)$ (除了$\infty$和$NaN$)</li>
</ul>
<h4 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h4><p>结果$(-1)^s\times M\times 2^E=(-1)^{s_1}\times M_1\times 2^{E_1}+(-1)^{s_2}\times M_2\times 2^{E_2}$ </p>
<p>对于 s,M: <strong>小数点对齐</strong>之后做加法</p>
<p>E则取 对齐后的 $E_1$</p>
<ul>
<li>如果 $M\geq 2$ 则M右移，增加E</li>
<li>如果E超过范围，则溢出</li>
<li>如果E没超出范围，则M舍入，计算得到frac</li>
</ul>
<p>如果两个浮点数的阶数E不同，那么需要先移动小数点调整他们的阶相同之后再进行</p>
<p>加法的数学性质：</p>
<ul>
<li>封闭(包括NaN)</li>
<li>交换律成立</li>
<li>结合律不成立</li>
<li>0的性质成立</li>
<li>相反数存在(除了$\infty$和$NaN$)</li>
<li>单调性成立(除了$\infty$和$NaN$)</li>
</ul>
<h3 id="C语言中的浮点数"><a href="#C语言中的浮点数" class="headerlink" title="C语言中的浮点数"></a>C语言中的浮点数</h3><p>所有的C语言版本提供了两种不同的浮点数据类型：float 和double。 在支持IEEE 浮点格式的机器上，这些数据类型就对应于单精度和双精度浮点。另外，这类机器使用向偶数舍入的舍入方式。不幸的是，因为C语言标准不要求机器使用IEEE 浮点，所以没有标准的方法来改变舍人方式或者得到诸如$-0,+\infty,-\infty$ 或者 $NaN$ 之类的特殊值。大多数系统提供include(‘.h’) 文件和读取这些特征的过程库，但是细节随系统不同而不同。例如，当程序文件中出现下列句子时，GNU 编译器GCC 会定义程序常数 INFINITY($+\infty$) 和 $NaN$(表示$NaN$) </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/16.png" style="zoom: 100%;"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_ok</span><span class="params">(<span class="keyword">unsigned</span> x,<span class="keyword">unsigned</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x+y&gt;=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/17.png" style="zoom: 100%;"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tadd_ok</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = x+y;</span><br><span class="line">	<span class="keyword">int</span> neg_over = x&lt;<span class="number">0</span>&amp;&amp;y&lt;<span class="number">0</span>&amp;&amp;x+y&gt;=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> pos_over = x&gt;=<span class="number">0</span>&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;x+y&lt;<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> ~(neg_over||pos_over);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不管是否溢出，加减法仍然成立</p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/21.png" style="zoom: 100%;"></p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/18.png" style="zoom: 100%;"></p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/19.png" style="zoom: 100%;"></p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/20.png" style="zoom: 100%;"></p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/22.png" style="zoom: 100%;"></p>
<p>因为float只有32位，和int是一样的，8位阶码 ，23位尾数；而double有64位，11位阶码，52位尾数</p>
<p>double的尾数用来容纳int是绰绰有余的，而float的尾数则需要int舍弃一些精确度。于是A是正确的而B是错误的</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/" itemprop="url">CSAPP信息的表示和存储</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-15T15:50:21+08:00">
                2020-09-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-10-08T13:38:10+08:00">
                2020-10-08
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="CSAPP信息的表示和存储"><a href="#CSAPP信息的表示和存储" class="headerlink" title="CSAPP信息的表示和存储"></a>CSAPP信息的表示和存储</h1><p>怎么阅读CSAPP？</p>
<ol>
<li>首先看一下标题和<strong>插图</strong> </li>
<li>看懂示意图之后做一些 practice problem，有不懂的再去看书本内容</li>
<li>用例子来帮助我们理解</li>
</ol>
<h2 id="上课笔记"><a href="#上课笔记" class="headerlink" title="上课笔记"></a>上课笔记</h2><h3 id="main-arg-c-arg-v"><a href="#main-arg-c-arg-v" class="headerlink" title="main(arg c ,arg v)"></a>main(arg c ,arg v)</h3><p>argc和argv参数在用命令行编译程序时有用</p>
<p>第一个参数，int型的argc，为整型，用来统计程序运行时发送给main函数的命令行参数的<strong>个数</strong></p>
<p>第二个参数，char*型的argv[]，为字符串数组，用来存放指向的字符串参数的指针数组，每一个元素指向一个参数。各成员含义如下：argv[0]指向程序运行的全路径名<br>    argv[1]指向在DOS命令行中执行程序名后的第一个字符串<br>    argv[2]指向执行程序名后的第二个字符串<br>    argv[3]指向执行程序名后的第三个字符串<br>    argv[argc]为NULL</p>
<h3 id="shell-中的命令时怎么去运行的"><a href="#shell-中的命令时怎么去运行的" class="headerlink" title="shell 中的命令时怎么去运行的"></a>shell 中的命令时怎么去运行的</h3><p><a href="https://www.cnblogs.com/chaoguo1234/p/5724321.html" target="_blank" rel="noopener">https://www.cnblogs.com/chaoguo1234/p/5724321.html</a></p>
<h3 id="C中的内存管理"><a href="#C中的内存管理" class="headerlink" title="C中的内存管理"></a>C中的内存管理</h3><h4 id="存储时候的三个区域："><a href="#存储时候的三个区域：" class="headerlink" title="存储时候的三个区域："></a>存储时候的三个区域：</h4><p><strong>代码区</strong></p>
<p>存放CPU执行的机器指令（machine instructions）。通常，代码区是可共享的（即另外的执行程序可以调用它），因为对于频繁被执行的程序，只需要在内存中有一份代码即可。代码区通常是只读的，使其只读的原因是防止程序意外地修改它的指令。另外，代码区还规划了局部变量的相关信息。</p>
<p><strong>数据区</strong></p>
<p>该区包含了在程序中<strong>明确被初始化</strong>的全局变量、静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量）。</p>
<p><strong>未初始化数据区（BSS）</strong></p>
<p>存入的是全局未初始化变量。BSS区的数据在程序开始执行之前被内核初始化为0或者空指针（NULL）。</p>
<h4 id="运行时的几个区域"><a href="#运行时的几个区域" class="headerlink" title="运行时的几个区域"></a>运行时的几个区域</h4><p><strong>代码区</strong></p>
<p>代码区指令根据程序设计流程依次执行，对于顺序指令，则只会执行一次（每个进程），如果反复，则需要使用跳转指令，如果进行递归，则需要借助栈来实现。</p>
<p>代码区的指令中包括操作码和要操作的对象（或对象地址引用）。如果是立即数（即具体的数值），将直接包含在代码中；如果是局部数据，将在栈区分配空间，然后引用该数据地址；如果是BSS区和数据区，在代码中同样将引用该数据地址。</p>
<p><strong>全局初始化数据区</strong></p>
<p>同上</p>
<p><strong>未初始化数据区</strong></p>
<p>同上</p>
<p><strong>栈区</strong></p>
<p>由编译器自动分配释放，存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈。每当一个函数被调用，该函数返回地址和一些关于调用的信息，比如某些寄存器的内容，被存储到栈区。然后这个被调用的函数再为它的自动变量和临时变量在栈区上分配空间，这就是C实现函数递归调用的方法。每执行一次递归函数调用，一个新的栈框架就会被使用，这样这个新实例栈里的变量就不会和该函数的另一个实例栈里面的变量混淆。</p>
<p><strong>堆区</strong></p>
<p>用于动态内存分配。堆在内存中位于BSS区和栈区之间。一般 <strong>由程序员分配和释放</strong>，若程序员不释放，程序结束时有可能由OS回收。</p>
<p>之所以分成这么多个区域，主要基于以下考虑：</p>
<p>一个进程在运行过程中，代码是根据流程依次执行的，只需要访问一次，当然跳转和递归有可能使代码执行多次，而数据一般都需要访问多次，因此单独开辟空间以方便访问和节约空间。</p>
<p>临时数据及需要再次使用的代码在运行时放入栈区中，生命周期短。</p>
<p>全局数据和静态数据有可能在整个程序执行过程中都需要访问，因此单独存储管理。</p>
<p>堆区由用户自由分配，以便管理。</p>
<p>栈与堆的区别：</p>
<p>1、申请方式不同</p>
<p>2、管理方式不同。堆容易产生内存泄露。（这个就看程序员啦）</p>
<p>3、空间大小不同。</p>
<p>栈是<strong>向低地址扩展</strong>的数据结构，是一块连续的内存区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，当申请的空间超过栈的剩余空间时，将提示溢出。因此，用户能从栈获得的空间较小。</p>
<p>堆是<strong>向高地址扩展</strong>的数据结构（它的生长方向与内存的生长方向相同），是不连续的内存区域。因为系统是用链表来存储空闲内存地址的，且链表的遍历方向是由低地址向高地址。由此可见，堆获得的空间较灵活，也较大。</p>
<p>4、系统响应：</p>
<p>栈：只要栈的空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</p>
<p>堆：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的free语句才能正确的释放本内存空间。另外，找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</p>
<p>对于堆来讲，频繁的malloc/free势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈就不会存在这个问题。</p>
<p>5、增长方向不同</p>
<p>6、申请效率不同</p>
<p>堆的效率要低于栈。</p>
<h3 id="通讯录模型"><a href="#通讯录模型" class="headerlink" title="通讯录模型"></a>通讯录模型</h3><p>可以把内存理解为一片广袤的大地，那么， 操作系统就会交给我们一本通讯录，里面有0到$2^{64}-1$ 的地址，每一行地址对应着大地上的某处。我们能拿到的只有地址，但是这个数据具体存在哪里，我们是不清楚也不知道的，只有Kernel才可知道。</p>
<h3 id="多道程序、多线程"><a href="#多道程序、多线程" class="headerlink" title="多道程序、多线程"></a>多道程序、多线程</h3><p><a href="https://www.cnblogs.com/liao13160678112/p/6603381.html" target="_blank" rel="noopener">https://www.cnblogs.com/liao13160678112/p/6603381.html</a></p>
<h3 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h3><p>kernel是一个软硬件之间的连接器</p>
<p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/13.png"></p>
<h3 id="objdump-d-hello"><a href="#objdump-d-hello" class="headerlink" title="objdump -d hello"></a>objdump -d hello</h3><p>cat cpuinfo 显示cpu信息</p>
<p>cat meminfo 显示内存信息</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>内存是一个很大的数组空间。</p>
<h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p>地址空间也是一个很大的数组空间，由计算机的字长来决定，比如32位字长机器的内存理论上有4个GB，64位则有$2^{64}$ kb</p>
<h2 id="2-1-信息存储"><a href="#2-1-信息存储" class="headerlink" title="2.1 信息存储"></a>2.1 信息存储</h2><h3 id="十六进制表示法"><a href="#十六进制表示法" class="headerlink" title="十六进制表示法"></a>十六进制表示法</h3><p>记住十六进制、十进制、二进制的互相转换。记住下面几个表格，主要记牢 十进制的2，4，8,对应的二进制</p>
<p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/1.png"></p>
<ul>
<li>十六进制转换成二进制的时候，可以通过展开每个十六进制的数字来实现。</li>
</ul>
<p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/2.png"></p>
<ul>
<li>反过来如果给定一个二进制数字，可以通过首先将其从左到右每4位一组来转换为十六进制。如果位总数不是4的倍数，最左边的一组可以少于4位，前面用0补足。然后再将每个4位组转换为相应的十六进制数字</li>
</ul>
<ul>
<li><p>十进制和十六进制之间转换比较简单，使用乘法和除法就可以了。</p>
</li>
<li><p>值得注意的是当值工是2 的非负整数 $n$ 次幂时，也就是$x=2^n$ 我们可以很容易地将x 写成十六进<br>制形式，只要记住x的二进制表示就是1 后面跟n个0。十六进制数字0 代表4 个二进制 0。所以，当n表示成$i+4j$ 的形式，其中 $0\leq i\leq 3$, 我们可以把x 写成开头的十六进制数字为$1(i=0),2(i=1),4(i=2),8(i=3) $ 后面跟随着个十六进制的0。比如，$x=2048=2^{11}$ 我们有$n=11=3+4*2$ 从而得到十六进制表示 0x800</p>
</li>
</ul>
<h3 id="Data-sizes"><a href="#Data-sizes" class="headerlink" title="Data sizes"></a>Data sizes</h3><p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/3.png"></p>
<h3 id="Address-and-Byte-Ordering"><a href="#Address-and-Byte-Ordering" class="headerlink" title="Address and Byte Ordering"></a>Address and Byte Ordering</h3><h3 id="Representing-Strings"><a href="#Representing-Strings" class="headerlink" title="Representing Strings"></a>Representing Strings</h3><p>C 语言中字符串被编码为一个以null(其值为0)字符结尾的字符数组。每个字符都由某个标准编码来表示，最常见的是ASCII 字符码。因此，如果我们以参数“12345” 和6(包括终止符)来运行例show_bytes我们得到结果31 32 33 34 35 00。请注意，十进制数字x 的ASCII 码正好是0x3x, 而终止字节的十六进制表示为0x00。在使用ASCII 码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。因而，文本数据比二进制数据具有更强的平台独立性</p>
<p>下面对show_bytes 的调用将输出什么结果？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *byte_pointer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_bytes</span><span class="params">(byte_pointer start, <span class="keyword">size_t</span> len)</span></span>&#123;</span><br><span class="line"><span class="built_in">size</span>.t i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">printfC %<span class="number">.2</span>xn, start[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_int</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	show_bytes((byte_pointer) &amp;x, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_float</span><span class="params">(<span class="keyword">float</span> x)</span></span>&#123;</span><br><span class="line">	show_bytes((byte_pointer) &amp;xf <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_pointer</span><span class="params">(<span class="keyword">void</span> *x)</span></span>&#123;</span><br><span class="line">	show_bytes((<span class="keyword">byte</span>.pointer) &amp;x, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>要注意，strlen(s) 是不会计算结束符的！所以答案是61, 62，63，64，65</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *s = <span class="string">"abcdef"</span>;</span><br><span class="line">show_bytes((byte_pointer) s, <span class="built_in">strlen</span>(s));</span><br></pre></td></tr></table></figure>
<h3 id="Representing-Code"><a href="#Representing-Code" class="headerlink" title="Representing Code"></a>Representing Code</h3><p>考虑下面的C函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们在机器上编译时，生成如下字节表示的机器代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Linux 32 55 89 e5 8b 45 Oc 03 45 08 c9 c3</span><br><span class="line">Windows 55 89 e5 8b 45 0c 03 45 08 5d c3</span><br><span class="line">Sun 81 c3 eO 08 90 02 00 09</span><br><span class="line">Linux 64 55 48 89 e5 89 7d f c 89 75 f 8 03 45 f c c9 c3</span><br></pre></td></tr></table></figure>
<p>我们发现指令编码是不同的。不同的机器类型使用不同的且不兼容的指令和编码方式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。<br>计算机系统的一个基本概念就是，从机器的角度来看，程序仅仅只是字节序列。机器没有关于原始源程序的任何信息，除了可能有些用来帮助调试的辅助表以外。</p>
<h3 id="Boolean-Algebra"><a href="#Boolean-Algebra" class="headerlink" title="Boolean Algebra"></a>Boolean Algebra</h3><p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/4.png" style="zoom:120%;"></p>
<p>以上4个布尔运算可以扩展到bit vectors上的运算，也就是固定长度为$w$，由0，1组成的串。比如说$w = 4,a =[0110],b=[1100]$ 那么4种运算 $a\&amp;b,a|b,$ a^ b 和 ~b 会得到这样的结果。</p>
<p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/5.png" style="zoom:120%;"></p>
<p>使用bit vectors 一个很有用的应用就是表示有限的集合。我们可以用bit vector $[a_{w-1},\cdots,a_1,a_0]$ 来编码任何子集 $A\subseteq{0,1,\cdots,w-1}$ ,其中$a_i=1$ 当且仅当 $i\in A$ 比如说</p>
<p>$a=[01101001]$ 可以对应 $A={0,3,5,6}$ 因为对76543210 这个数来说，从右往左数第1，第4，第6、7 位都是1，其他位都是0。</p>
<p>同理，$b=[01010101]$ 可以表示 $B={0,2,4,6}$ </p>
<p>我们于是可以把位运算用到集合当中：</p>
<p>$A\&amp;B  = 01000001 ={0,6}$ </p>
<p>$A|B = 01111101 = {0,2,3,4,5,6}$ </p>
<p>A^B $= 00111100={2,3,4,5}$ </p>
<p>A~B $=10101010={1,3,5,7}$ </p>
<h3 id="Bit-Level-Operations-in-C"><a href="#Bit-Level-Operations-in-C" class="headerlink" title="Bit-Level Operations in C"></a>Bit-Level Operations in C</h3><h3 id="Logical-Operations-in-C"><a href="#Logical-Operations-in-C" class="headerlink" title="Logical Operations in C"></a>Logical Operations in C</h3><p>C语言种还提供了一组逻辑运算符 $||,\&amp;\&amp;,!$   分别对应OR，AND，NOT，千万不要把逻辑运算和位运算混淆，逻辑运算只有TRUE和FALSE，只返回1或者0。比如：</p>
<p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/6.png" style="zoom:150%;"></p>
<h3 id="Shift-Operations-in-C-移位运算"><a href="#Shift-Operations-in-C-移位运算" class="headerlink" title="Shift Operations in C  移位运算"></a>Shift Operations in C  移位运算</h3><h4 id="左移"><a href="#左移" class="headerlink" title="左移"></a>左移</h4><p>左移这种移位运算非常简单，x向左移动k位，丢弃最高的 $k$ 位，并在右端补上k个0。移位量应该是一个 0~w-1 之间的值。移位运算是从左到右可结合的 $x&lt;&lt;j&lt;&lt;k = (x&lt;&lt;j)&lt;&lt;k$ </p>
<h4 id="逻辑右移"><a href="#逻辑右移" class="headerlink" title="逻辑右移"></a>逻辑右移</h4><p>逻辑右移和左移刚好相反，x向右移k位，左边补上k个0</p>
<h4 id="算术右移"><a href="#算术右移" class="headerlink" title="算术右移"></a>算术右移</h4><p>为什么会有算数右移？</p>
<p>算术右移比较微妙，是在移动之后在左端补上k个最高有效位的值，得到的结果是 $[x<em>{w-1},\cdots,x</em>{w-1},x_{w-2},\cdots,x_k]$ </p>
<p>比如下面这个例子</p>
<p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/7.png" style="zoom:150%;"></p>
<p>斜体的数字表示的是最右端(左移）或最左端(右移)填充的值。可以看到除了一个条目之外，其他的都包含填充0。唯一的例外是算术右移[10010101]的情况。因为操作数的最高位是1，填充的值就是1。</p>
<p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/8.png" style="zoom:120%;"></p>
<p>对于 x&lt;<y 和 x>&gt;y 如果 $y<0$ 或者 $y>$字长，则行为无意义</0$></y></p>
<h2 id="2-2整数表示"><a href="#2-2整数表示" class="headerlink" title="2.2整数表示"></a>2.2整数表示</h2><h3 id="Integral-Data-Types"><a href="#Integral-Data-Types" class="headerlink" title="Integral Data Types"></a>Integral Data Types</h3><p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/10.png" style="zoom:100%;"></p>
<h3 id="Unsigned-Encodings-无符号数"><a href="#Unsigned-Encodings-无符号数" class="headerlink" title="Unsigned Encodings(无符号数)"></a>Unsigned Encodings(无符号数)</h3><p>假设有一个整数数据类型有w位。我们可以将其写成 $[x<em>{w-1},x</em>{w-2},…,x_0]$  ,表示向量中的每一位。然乎我们用一个 $B2U_w$(Binary to Unsigned 的缩写，长度位w) 来表示：</p>
<p>对向量 $\overrightarrow{x} = [x<em>{w-1},x</em>{w-2},\cdots,x_0]$  </p>
<p>$B2U<em>w(\overrightarrow{x}) = \Sigma</em>{i=0}^{w-1}x_i2^i$ </p>
<p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/11.png" style="zoom:100%;"></p>
<h3 id="Two’s-Complement-Encodings-补码"><a href="#Two’s-Complement-Encodings-补码" class="headerlink" title="Two’s-Complement Encodings(补码)"></a>Two’s-Complement Encodings(补码)</h3><p>基为2的补码的定义</p>
<p>仍然把最高位当成符号位，但是最高位还是带权重的</p>
<p>对向量 $\overrightarrow{x} = [x<em>{w-1},x</em>{w-2},\cdots,x_0]$: </p>
<p>$B2T<em>w(\overrightarrow{x}) = -x</em>{w-1}2^{w-1}+\Sigma_{i=0}^{w-2}x_i2^i$ </p>
<p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/12.png" style="zoom:100%;"></p>
<p>让我们来考虑一下w 位补码所能表示的值的范围。它能表示的最小值是位向量<a href="也就是设置这个位为负权，但是清除其他所有的位）其整数值为 $TMin_w=-2^{w-1}$ . 而最大值是为[01...1] (清除具有负权的位，而设置其他所有的位">10…0</a> ，其整数值为 $TMax<em>w = \Sigma</em>{i=0}^{w-2} 2^i = 2^{w-1}-1$  . 以4为例，我们有 $TMin_4 = B2T_4([1000]) = -2^3 = 8$,而 $TMax_4 = B2T_4([0111]) = 7$ </p>
<p>C语言标准不要求一定使用补码表示有符号的整数，但是几乎所有的机器上的实现都用补码</p>
<p>补码的最高位是1，那么这个补码就是负的</p>
<p>补码的好处就是只有一个零，而原码则有两个0</p>
<p>做一个小练习：</p>
<p>B2T (10) = 1010<br>B2T (−10) = 10110<br>B2T (15213) =<br>B2T (−15213) =</p>
<p>我们发现对于两个相反数的补码，我们第一眼是看不出相反数之间是有联系的。不像源码，第一位只代表符号位。对于负数的补码，就是把正数的补码取反码再+1</p>
<h3 id="Conversions-between-Signed-and-Unsigned"><a href="#Conversions-between-Signed-and-Unsigned" class="headerlink" title="Conversions between Signed and Unsigned"></a>Conversions between Signed and <strong>Unsigned</strong></h3><p>有符号数和无符号数之间的转换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">short <span class="keyword">int</span> v = <span class="number">-12345</span>;</span><br><span class="line"><span class="keyword">unsigned</span> short uv = (<span class="keyword">unsigned</span> short) v;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"v=%d,uv = %u\n"</span>,v,uv);</span><br></pre></td></tr></table></figure>
<p>结果是 v=-12345, uv = 53191</p>
<p>对C来说强制类型转换的结果保持位值不变，只是<strong>改变了解释这些位的方式</strong>。 因为十六进制表示写作0xCFC7 的16 位二进制码既是-12345的补码表示，又是53191 的无符号表示</p>
<p>也就是说 $T2U_{16}(-12345) = 53191,U2T_16(53191) = 12345$ </p>
<p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/14.png" style="zoom:100%;"></p>
<p>通过上述这些例子，我们可以总结出T2U的公式:对满足 $TMin_w\leq x\leq TMax_w$ </p>
<p>$T2U_w(x)=\begin{cases}x+2^w,x&lt;0\ x,x\geq 0\end{cases}$ </p>
<p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/15.png" style="zoom:100%;"></p>
<p>对 $0\leq u\leq UMax_x$ 的u 有</p>
<p>$U2T_w(x)=\begin{cases}u,u\leq TMax_w\ u-2^w,u\geq TMax_w\end{cases}$ </p>
<p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/16.png" style="zoom:100%;"></p>
<h3 id="Signed-versus-Unsigned-in-C"><a href="#Signed-versus-Unsigned-in-C" class="headerlink" title="Signed versus Unsigned in C"></a>Signed versus Unsigned in C</h3><p>C语言中，要创建一个无符号常量，必须加上后缀字符’U‘ 或者‘u‘例如，12345U 或者0x1A2Bu.</p>
<p>C 语言允许无符号数和有符号数之间的转换。在一台采用补码的机器上，当从无符号数转换为有符号数时，效果就是应用函数$U2T_w$，而从有符号数转换为无符号数时，就是应用函数$T2U_w$ 其中切表示数据类型的位数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant1</th>
<th>Constant2</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>位串保持不变，位串重复解读。可能会导致各种溢出：$$</p>
<h3 id="Expanding-the-Bit-Representation-of-a-Number"><a href="#Expanding-the-Bit-Representation-of-a-Number" class="headerlink" title="Expanding the Bit Representation of a Number"></a>Expanding the Bit Representation of a Number</h3><h4 id="零扩展"><a href="#零扩展" class="headerlink" title="零扩展"></a>零扩展</h4><p>要将一个无符号的数转换为一个更大的数据类型，我们只需要简单地在表示的开头添加0. 表示：</p>
<p>定义宽度为w的位向量 $\overrightarrow{u} = [u<em>{w-1},u</em>{w-2},…,u<em>0]$ 和宽度为 $w’$ 的位向量 $\overrightarrow{u}’ = [0,…,0,u</em>{w-1},u<em>{w-2},…,u_0]$ , 其中 $w’&gt;w$, 则 $B2U_w(\overrightarrow{u}) =B2U</em>{w’}(\overrightarrow{u’})$ </p>
<h4 id="符号扩展"><a href="#符号扩展" class="headerlink" title="符号扩展"></a>符号扩展</h4><p>要将一个<strong>补码数字</strong>转换成一个<strong>更大的</strong>数据类型，可以执行一个符号扩展，在表示中添加最高有效位的值。表示为如下原理。</p>
<p>定义宽度为 w的位向量 $\overrightarrow{x} = [x<em>{w-1},x</em>{w-2},…,x<em>0]$ 和宽度为 w的位向量 $\overrightarrow{x}’ = [x</em>{w-1},…,x<em>{w-1},x</em>{w-1},x<em>{w-2},…,x_0]$ ,其中 $w’&gt;w$ 。 则 $B2T_w(\overrightarrow{x}) =B2T</em>{w’}(\overrightarrow{x’})$</p>
<p>比如下面这个例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">short sx = <span class="number">-12345</span>; <span class="comment">/* -12345 */</span></span><br><span class="line"><span class="keyword">unsigned</span> short usx = sx; <span class="comment">/* 53191 */</span></span><br><span class="line"><span class="keyword">int</span> x = sx; <span class="comment">/* -12345 */</span></span><br><span class="line"><span class="keyword">unsigned</span> ux = usx; <span class="comment">/* 53191 */</span></span><br></pre></td></tr></table></figure>
<p>打印如下：</p>
<p>sx = -12345: cf c7<br>usx = 53191: cf c7<br>x = -12345: ff ff cf c7<br>ux = 53191: 00 00 cf c7</p>
<p>我们可以观察到，-12345的补码和53191的无符号表示在16位字长时是相同的，但是在32位字长时却不同的。因为前者用的是符号扩展，后者用的是零扩展</p>
<h3 id="Truncating-Numbers"><a href="#Truncating-Numbers" class="headerlink" title="Truncating Numbers"></a>Truncating Numbers</h3><p>刚才我们讲了怎么从位数较少的拓展成位数较多的数，现在来看看高位数怎么截断成较少位数</p>
<p>当我们将一个w位的数$ \overrightarrow{x} = [x<em>{w-1},x</em>{w-2},\cdots,x<em>0]$ 截断位一个k位数字时，我们会丢弃高 $w-k$ 位，得到一个位向量 $\overrightarrow{x’} =[x</em>{k-1},x_{k-2},\cdots,x_0]$  阶段一个数字很可能会改变它的值。</p>
<h4 id="截断无符号数"><a href="#截断无符号数" class="headerlink" title="截断无符号数"></a>截断无符号数</h4><p>对一个无符号数，我们可以很容易得出其数值结果</p>
<p>令$\overrightarrow{x} $ 等于位向量 $ \overrightarrow{x} = [x<em>{w-1},x</em>{w-2},\cdots,x<em>0]$ ,而 $\overrightarrow{x’}$  是将其截断为k位的结果：$\overrightarrow{x’} =[x</em>{k-1},x_{k-2},\cdots,x_0]$ 。 令 $x=B2U_w(\overrightarrow {x}),x’ = B2U_k(\overrightarrow{x’})$ 则 $x’ = x <del>mod</del> 2^k$</p>
<h4 id="截断补码数值"><a href="#截断补码数值" class="headerlink" title="截断补码数值"></a>截断补码数值</h4><p>截断补码也具有相似的属性，只不过要<strong>将最高位转换为符号位</strong>。</p>
<p>令 $\overrightarrow{x}$ 等于位向量 $[x<em>{w-1},x</em>{w-2},\cdots,x<em>0]$ ,而 $\overrightarrow{x’} $ 是将其截断为k位的结果： $\overrightarrow{x’} =[x</em>{k-1},x_{k-2},…,x_0]$ 令 $x=B2U_w(\overrightarrow{x})$, $x’ = B2T_k(\overrightarrow{x’})$ 则 $x’ = U2T_k(x <del>mod</del> 2^k)$ </p>
<p>在这个公式中， $x ~~ mod ~~2^k$ 将是一个 0 到 $2^k-1$ 之间的一个数。对其应用函数 $U2T<em>k$ 产生的效果就是把最高的有效位 $x</em>{k-1}$  的权重从 $2^{k-1}$ 转变为 $-2^{k-1}$ 。 举例来看，将数值 $x=53191$ 从int 转换为short。 由于 $2^{16} =66536 \geq x$ 我们有  $x ~~ mod ~~ 2^{16} =x$ 但是，当我们把这个数转换为16位的补码时，我们得到了 $x’ = 53191-65536 = -12345$ </p>
<h3 id="扩展和截断小结"><a href="#扩展和截断小结" class="headerlink" title="扩展和截断小结"></a>扩展和截断小结</h3><p>扩展：</p>
<p>⽆符号：加 0<br>有符号：最⾼位扩展<br>结果可靠（可预期）</p>
<p>截断：</p>
<p>⽆论有⽆符号：去掉⾼位，结果重新解释<br>⽆符号：等同于取模运算<br>有符号：类似于取模运算(先取模再重新解释)<br>对于不太⼤的数，结果可靠（可预期）</p>
<h3 id="Advice-on-Signed-versus-Unsigned"><a href="#Advice-on-Signed-versus-Unsigned" class="headerlink" title="Advice on Signed versus Unsigned"></a>Advice on Signed versus Unsigned</h3><p>就像我们看到的那样，有符号数到无符号数的隐式强制类型转换导致了某些非直观的行为。而这些非直观的特性经常导致程序错误，并且这种包含隐式强制类型转换的细微差别的错误很难被发现。因为这种强制类型转换是在代码中没有明确指示的情况下发生的，程序员经常忽视了它的影响。<br>下面两个练习题说明了某些由于隐式强制类型转换和无符号数据类型造成的细微的错误</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* WARNING: This is buggy code */</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">sum_elements</span><span class="params">(<span class="keyword">float</span> a[], <span class="keyword">unsigned</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">float</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= length<span class="number">-1</span>; i++)</span><br><span class="line">		result += a[i];</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当参数length 等于0 时，运行这段代码应该返回0.0。 但实际上，运行时会遇到一个内存错误。请解释为什么会发生这样的情况，并且说明如何修改代码.</p>
<p>因为length是unsigned 的，那么0-1 就会变成了Umax也就是4294967295，但是 $&lt;=$ 这个符号同样使用无符号数比较，而因为任何书都是小于等于UMax的，所以这个比较总是为真。因此代码将试图访问数组a的非法元素。</p>
<p>我们可以将length修改为int类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Prototype for library function strlen */</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br><span class="line">	<span class="comment">//Here is your first attempt at the function:</span></span><br><span class="line"><span class="comment">/* Determine whether string s is longer than string t */</span></span><br><span class="line"><span class="comment">/* WARNING: This function is buggy */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strlonger</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strlen</span>(s) - <span class="built_in">strlen</span>(t) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你在一些示例数据上测试这个函数时，一切似乎都是正确的。进一步研究发现在头文件stdio.h 中数据类型size_t 是定义成unsigned int 的。并解释为什么会出现这样不正确的结果。</p>
<p>当s比t更短的时候，因为strlen(s)和strlen(t) 都是unsigned的，所以不会出现负数而是一个很大的正数，任然会返回1<br>C. 说明如何修改这段代码好让它能可靠地工作 将代码修改为：return strlen(s) &gt; strlen(t);</p>
<h2 id="解题要点："><a href="#解题要点：" class="headerlink" title="解题要点："></a>解题要点：</h2><h3 id="Unsigned和补码之间的比较"><a href="#Unsigned和补码之间的比较" class="headerlink" title="Unsigned和补码之间的比较"></a>Unsigned和补码之间的比较</h3><p>如果左边的数是Unsigned，那么<strong>右边的数也会自动转换成Unsigned</strong>(最后一题有点坑)</p>
<p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/17.png" style="zoom:100%;"></p>
<p>最后一题，-2147483647-1U 会变成0，同时右边的-2147483647 会转换成1，0&lt;1 所以正确</p>
<p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/18.png" style="zoom:100%;"></p>
<p>对于fun1 来说，是unsigned类型移位之后再转换为int，所以进行的操作是左移或者逻辑右移</p>
<p>对于fun2 来说，左移后先转换成int再进行算术右移。</p>
<p>所以fun1就是不用变化，而对于fun2，我们要看哪些数在左移后以1开头，我们发现是0xC9000000 和 0x87000000,那么算数右移后，fun2(w) = 0xFFFFFFC9 和 0xFFFFFF87 </p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/09/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/" itemprop="url">深入了解计算机系统简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-14T15:54:39+08:00">
                2020-09-14
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-09-14T23:22:34+08:00">
                2020-09-14
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="深入了解计算机系统简介"><a href="#深入了解计算机系统简介" class="headerlink" title="深入了解计算机系统简介"></a>深入了解计算机系统简介</h1><h3 id="从helloworld入手"><a href="#从helloworld入手" class="headerlink" title="从helloworld入手"></a>从helloworld入手</h3><p>首先我们来理解一下简单的hello world 程序是怎么被电脑执行的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello, world\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个hello.c 文件在被电脑执行之前需要比其他程序转化为一系列的低级机器语言指令。然后这些指令按照一种称为可执行目标程序的格式打好包，并以<strong>二进制磁盘文件</strong>的形式存放起来。目标程序也成为可执行目标文件。</p>
<p>整个过程如下所示。</p>
<p><img src="/2020/09/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1.png"></p>
<ul>
<li>首先是preprocessor 阶段，预处理器(cpp) 会以# 开头的命令修改原始的C程序。比如 <code>hello.c</code>中的第一行<code>#include &lt;stdio.h&gt;</code> 命令告诉预处理器读取系统头文件 <code>stdio.h</code> 的内容，并把它直接插入到程序文本当中，结果就得到了另一个C程序，通常是以<code>.i</code>作为文件扩展名</li>
</ul>
<p>我们在命令行中敲入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure>
<p>预处理器就会读取头文件的内容然后直接插入到程序文本当中去。一共添加了了600多行，这里截取了最后一段。上面所有的内容都是头文件<code>stdio.h</code> 中包含的</p>
<p><img src="/2020/09/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/2.png"></p>
<ul>
<li>第二个阶段是编译阶段。编译器(ccl) 会将文本文件 <code>hello.i</code> 翻译成 <strong>文本文件</strong> <code>hello.s</code> 它包含一个汇编语言程序。该程序包含函数main的定义我们敲入命令行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure>
<p>随后文件夹下会多出一个<code>hello.s</code> 的文件，文件中的语言是汇编语言，是一种低级机器语言指令。文件中包含一个main函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   .file  &quot;hello.c&quot;</span><br><span class="line">   .def   __main;    .scl   2; .type  32;    .endef</span><br><span class="line">   .section .rdata,&quot;dr&quot;</span><br><span class="line">.LC0:</span><br><span class="line">   .ascii &quot;hello, world\0&quot;</span><br><span class="line">   .text</span><br><span class="line">   .globl main</span><br><span class="line">   .def   main;  .scl   2; .type  32;    .endef</span><br><span class="line">   .seh_proc  main</span><br><span class="line">main:</span><br><span class="line">   pushq  %rbp</span><br><span class="line">   .seh_pushreg   %rbp</span><br><span class="line">   movq   %rsp, %rbp</span><br><span class="line">   .seh_setframe  %rbp, 0</span><br><span class="line">   subq   $32, %rsp</span><br><span class="line">   .seh_stackalloc    32</span><br><span class="line">   .seh_endprologue</span><br><span class="line">   call   __main</span><br><span class="line">   leaq   .LC0(%rip), %rcx</span><br><span class="line">   call   puts</span><br><span class="line">   movl   $0, %eax</span><br><span class="line">   addq   $32, %rsp</span><br><span class="line">   popq   %rbp</span><br><span class="line">   ret</span><br><span class="line">   .seh_endproc</span><br><span class="line">   .ident &quot;GCC: (tdm64-1) 4.9.2&quot;</span><br><span class="line">   .def   puts;  .scl   2; .type  32;    .endef</span><br></pre></td></tr></table></figure>
<p>汇编语言是非常有用的。它为不同的高级语言的不同编译器提供了通用的输出语言</p>
<ul>
<li>汇编阶段 是汇编器(as) 将hello.s 翻译成机器语言指令，把这些指令打包成一种可叫做 relocatable object program 的格式，并将结果保存在目标文件hello.o 当中。hello.o文件是一个二进制文件，它包含的17 个字节是函数main的指令编码。如果我们在文本编辑器中打开hello.o文件，将看到一堆乱码。</li>
</ul>
<p>在命令行中输入,文件夹下多出一个 hello.o 的文件 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure>
<p><img src="/2020/09/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/3.png"></p>
<ul>
<li>最后一个是链接阶段。hello程序调用了printf函数，他是每个C编译器都提供的标准C库中的一个函数。printf函数存在于一个名为printf.o 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的hello.o 程序中。链接器(ld)就负责处理这种合并. 结果就得到了hello文件，它是一个可执行目标文件，可以加载到内存中并被系统调用</li>
</ul>
<h3 id="计算机是怎么运行hello程序的呢？"><a href="#计算机是怎么运行hello程序的呢？" class="headerlink" title="计算机是怎么运行hello程序的呢？"></a>计算机是怎么运行hello程序的呢？</h3><p>下面是一个冯诺依曼架构的计算机模型。里面分为好几个部分：主线，输入/输出，主存，处理器等。初始时，shell程序执行它的指令，等待我们输入一个命令当我们在键盘上输人字符串“./hello”后，shell 程序将字符逐一读入寄存器，再把它存放到内存中</p>
<p><img src="/2020/09/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/4.png"></p>
<p>当我们按下回车键的时候，shell会执行一系列指令来加载可执行的hello文件，这些指令将hello目标文件中的代码和数据从磁盘复制到主存。数据包括最终会被输出的字符串 “hello,world\n”</p>
<p><img src="/2020/09/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/5.png"></p>
<p>一旦目标文件hello 中的代码和数据被加载到主存，处理器就开始执行hello 程序的main 程序中的机器语言指令。这些指令将“hello, world\n 字符串中的字节从主存复制到寄存器文件(Register file)，再从寄存器文件中复制到显示设备，最终显示在屏幕上.</p>
<p><img src="/2020/09/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/6.png"></p>
<h3 id="存储设备形成层次结构"><a href="#存储设备形成层次结构" class="headerlink" title="存储设备形成层次结构"></a>存储设备形成层次结构</h3><p>每个计算机系统中的存储设备都被组织成了一个存储器层次结构。在这个层次结构中，从上至下，设备的访<br>问速度越来越慢、容量越来越大，并且每字节的造价也越来越便宜。寄存器文件在层次结构中位于最顶部，也就是第0级或记为$L_0$ 这里我们展示的是三层高速缓存L1 到L3,占据存储器层次结构的第1层到第3层。主存在第4 层, 以此类推。</p>
<p>存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。因此，寄存器文件就是L1 的高速缓存，L1 是L2 的高速缓存，L2 是L3 的高速缓存，L3 是主存 的高速缓存，而主存又是磁盘的高速缓存。在某些具有分布式文件系统的网络系统中，本地磁盘就是存储在其他系统中磁盘上的数据的高速缓存。</p>
<p>程序员可以利用对整个存储器层次结构的理解来提高程序性能。</p>
<p><img src="/2020/09/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/7.png"></p>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><ol>
<li>测试自己的编程环境下，C语言是否允许void main()？如果出错，报什么类型的错误。<br>如果文件为.cpp 的话，void main()会出现报错’::main’ must return ‘int’ ，<br><img src="/2020/09/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1.jpg"></li>
</ol>
<p>但是如果是.c文件的话，void main() 是可以通过编译并且运行的。<br><img src="/2020/09/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/2.jpg"></p>
<p>这是因为.cpp文件和.c文件的编译器是不同的。.c 文件的编译器是<code>gcc</code>，而<code>.cpp</code>文件的编译器是<code>g++</code>. </p>
<ol>
<li>尝试使用一个<code>int</code>型的4096x4096的二维数组，如果遇到错误，了解不同错误消息的具体含义。</li>
</ol>
<p>如果把这个二维数组定义在main() 函数当中, 那么是无法定义的。会遇到错误 ”Process finished with exit code -1073741571 (0xC00000FD)”，报错的提示是程序意外终止。查阅资料得到原因 StackOverflow也就是栈区溢出。Windows下栈区默认的大小为1024kb，但是4096x4096xsizeof(int) /1024/1024 =16 MB,所以导致了栈区溢出</p>
<p>但是如果把二维数组设置为静态变量或者全局变量，那么编译器并不会给报错。这是因为它们存储在大小比规定栈的大小更大的静态储存区，因此能申请到更大的数据。</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/09/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E9%9B%86%E5%90%88%E4%B8%8E%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E9%9B%86%E5%90%88%E4%B8%8E%E5%87%BD%E6%95%B0/" itemprop="url">离散数学之集合与函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-03T00:09:41+08:00">
                2020-09-03
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2023-01-16T11:56:31+08:00">
                2023-01-16
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="离散数学之集合与函数"><a href="#离散数学之集合与函数" class="headerlink" title="离散数学之集合与函数"></a>离散数学之集合与函数</h1><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>Set A is a collection of objects (or elements)</p>
<ul>
<li>$a\in A$: a is an elements of A or a is a member of A</li>
<li>$a\notin A:$ a is not an element of A</li>
<li>$A={a_1,a_2,\cdots,a_n}$: A contains $a_1,a_2,\cdots,a_n$ </li>
<li>Order of elements is meaningless（无序性）</li>
<li>It does not matter how often the same element is listed</li>
</ul>
<h3 id="集合等价"><a href="#集合等价" class="headerlink" title="集合等价"></a>集合等价</h3><p>集合A和集合B是相等的，当且仅当它们囊括了相等的元素。</p>
<p>If $A={9,2,7,-3}$ and $B={7,9,2,-3}$, then $A=B$ </p>
<p>if $A={9,2,-3,9,7,3}$ and $B={7,9,2,-3}$ ,then $A=B$ (因为A中实际上只有9，7，3，-3四个元素)</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li>Bag of words model: documents, reviews, tweets, news, etc;</li>
<li>Transactions: shopping list, app downloading, book reading, video watching, music listening, etc;</li>
<li>Records in a DB, data item in a data streaming, etc;</li>
<li>Neighbors of a vertex in a graph;</li>
</ul>
<p><strong>”Standard” sets</strong> </p>
<ul>
<li>自然数：$N={0,1,2,3…}$</li>
<li>整数：$Z={…,-2,-1,0,1,2}$</li>
<li>正整数：$Z^+ = {1,2,3,4…}$ </li>
<li>实数：$R={47.3,-12,-0.3,…}$ </li>
<li>有理数：$Q={1.5,2.6,-3.8,15}$ </li>
</ul>
<h3 id="集合的展现"><a href="#集合的展现" class="headerlink" title="集合的展现"></a>集合的展现</h3><h4 id="Tabular-form-表列式"><a href="#Tabular-form-表列式" class="headerlink" title="Tabular form 表列式"></a>Tabular form 表列式</h4><p>$A={1,2,3,4,5}$</p>
<p>$B={-2,0,2}$ </p>
<h4 id="Descriptive-form"><a href="#Descriptive-form" class="headerlink" title="Descriptive form"></a>Descriptive form</h4><p>A = set of rst ve natural numbers;<br>B = set of positive odd integers;</p>
<h4 id="Set-builder-form"><a href="#Set-builder-form" class="headerlink" title="Set builder form"></a>Set builder form</h4><p>$Q={a/b: a\in Z\land b\in Z\land b\neq 0 }$</p>
<p>$B={y:P(y)}$,where $P(Y):y\in E\land 0 &lt;y\leq 50$; </p>
<h4 id="Remarks"><a href="#Remarks" class="headerlink" title="Remarks"></a>Remarks</h4><ul>
<li>$A = \empty$ empty set, or null set </li>
<li><p>Universal set U: contains all the objects under consideration </p>
</li>
<li><script type="math/tex; mode=display">
A=\{\{a,b\},\{b,c,d\}\}</script></li>
</ul>
<h4 id="Venn-diagrams"><a href="#Venn-diagrams" class="headerlink" title="Venn diagrams"></a>Venn diagrams</h4><p>In general, a universal set is represented by a rectangle.</p>
<p><img src="/2020/09/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E9%9B%86%E5%90%88%E4%B8%8E%E5%87%BD%E6%95%B0/1.jpg" style="zoom:120%;"></p>
<h3 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h3><p>Set A is a subset of B is every element of A is also an element of B, denote as  $A\subseteq B$ </p>
<ul>
<li>$A\subseteq B = \forall x(x\in A\rightarrow x\in B)$ </li>
<li>对每一个集合 S， 我们有 (1)  $\empty \subseteq S$  (2) $S\subseteq S$ </li>
<li>When we wish to emphasize that set A is a subset of set B but that $A\neq B$ ,we write $A\subset B$ and say that A is a proper subset of |B, i.e., $\forall x(x\in A\rightarrow x\in B)\land\exists(x\in B\land x\notin A)$ </li>
<li>两个有用的结论： (1)$A=B\Leftrightarrow (A\subseteq B)\land (B\subseteq A)$ (2) $(A\subseteq B)\land(B\subseteq C)\Rightarrow (A\subseteq C)$ </li>
<li>给定一个集合S，那S的幂集就是S所有的子集，我们记为 $P(s)$. 那么 幂集的大小为 $2^{|S|}$, |S| 是 S 的size。</li>
</ul>
<h3 id="Cartesian-product"><a href="#Cartesian-product" class="headerlink" title="Cartesian product"></a>Cartesian product</h3><p>给定两个集合 A和B。那么A和B的笛卡尔集，记为 $A\times B$ , 运算方法为 $A\times B = {(a,b):a\in A\land b\in B}$ , 其中 (a,b) 是有序对</p>
<ul>
<li>Let A = {1,2} and B={a,b,c}  the Cartesian product $A\times B = {(1,a),(1,b),(1,c),(2,a),(2,b),(2,c) }$</li>
<li>The Cartesian product of $A_1,A_2,…,A_n$ is denoted as  $A_1\times A_2\times \dots \times A_n$</li>
</ul>
<p>$A_1\times A_2\times \dots \times A_n = {(a_1,a_2,\cdots,a_n):\forall i~~a_i\in A_i }$</p>
<ul>
<li>A subset R of the Cartesian product $A\times B$ is called a relation from A to B</li>
</ul>
<h3 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h3><ul>
<li>Union ： $A\cup B={x:x\in A\lor x\in B}$;</li>
<li>Intersection : $A\cap B = {x:x\in A\land x\in B}$</li>
<li>Difference: $A-B = {x:x\in A\land x\notin B}$ (sometimes denoted as A\B)</li>
<li>Complement: $\overline A = U-A = {x\in U: x\notin A}$ </li>
<li>$A-B=A\cap \overline B$</li>
<li>$|A\cup B| = |A|+|B|-|A\cap B|$ </li>
</ul>
<h3 id="Logical-equivalence"><a href="#Logical-equivalence" class="headerlink" title="Logical equivalence"></a>Logical equivalence</h3><p><img src="/2020/09/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E9%9B%86%E5%90%88%E4%B8%8E%E5%87%BD%E6%95%B0/1.png" style="zoom:120%;"><img src="/2020/09/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E9%9B%86%E5%90%88%E4%B8%8E%E5%87%BD%E6%95%B0/2.png" style="zoom:120%;"></p>
<h3 id="Generalized-unions-and-intersections"><a href="#Generalized-unions-and-intersections" class="headerlink" title="Generalized unions and intersections"></a>Generalized unions and intersections</h3><h4 id="union"><a href="#union" class="headerlink" title="union"></a>union</h4><p>$A<em>1\cup A_2\cup \cdots \cup A_n = \bigcup</em>{i=1}^n A_i$  </p>
<p>$A<em>1\cup A_2\cup \cdots \cup A_n\cup\dots = \bigcup</em>{i=1}^\infty A_i$  </p>
<h4 id="Intersection"><a href="#Intersection" class="headerlink" title="Intersection"></a>Intersection</h4><p>$A<em>1\cap A_2\cap \cdots \cap A_n = \cap</em>{i=1}^n A_i$  </p>
<p>$A<em>1\cap A_2\cap \cdots \cap A_n\cap\cdots = \bigcap</em>{i=1}^n A_i$  </p>
<h3 id="Set-covering-problem"><a href="#Set-covering-problem" class="headerlink" title="Set covering problem"></a>Set covering problem</h3><p><img src="/2020/09/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E9%9B%86%E5%90%88%E4%B8%8E%E5%87%BD%E6%95%B0/3.png" style="zoom:120%;"></p>
<h2 id="Sequence"><a href="#Sequence" class="headerlink" title="Sequence"></a>Sequence</h2><h3 id="Denition"><a href="#Denition" class="headerlink" title="Denition"></a>Denition</h3><p>A sequence is a function from a subset of the set of integers (usually either the set {0,1,2,…} or the set {1,2,3,…}) to a set S. We use the notation an to denote the image of integer n. We call an a term of the sequence.</p>
<h4 id="Some-usefull-sequences"><a href="#Some-usefull-sequences" class="headerlink" title="Some usefull sequences"></a>Some usefull sequences</h4><p><img src="/2020/09/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E9%9B%86%E5%90%88%E4%B8%8E%E5%87%BD%E6%95%B0/4.png" style="zoom:120%;"></p>
<h3 id="Progression-数列"><a href="#Progression-数列" class="headerlink" title="Progression 数列"></a>Progression 数列</h3><h4 id="Geometric-progression-等比数列"><a href="#Geometric-progression-等比数列" class="headerlink" title="Geometric progression 等比数列"></a>Geometric progression 等比数列</h4><p>A geometric progression is a sequence of form $a,ar,ar^2,\cdots,ar^n,\cdots$ where initial term a and common ratio r are real numbers.</p>
<h4 id="Arithmetic-progression-等差数列"><a href="#Arithmetic-progression-等差数列" class="headerlink" title="Arithmetic progression 等差数列"></a>Arithmetic progression 等差数列</h4><p>An arithmetic progression is a sequence of form $a,a+d,a+2d,\cdots ,a+nd,\cdots$ where initial term a and common difference d are real numbers.</p>
<h4 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h4><p>The sequences ${b_n}$  is a form of$ bn = (-1)^n$. The list of terms $b_0,b_1,b_2,b_3,\cdots$ begins with $1,-1,1,-1,\cdots$<br>The sequences ${s_n}$ is a form of $sn = -1 + 4n$. The list of terms $s_0,s_1,s_2,s_3,\cdots$ begins with $-1,3,7,11,\cdots$ . </p>
<h3 id="Recurrence-relation-递推关系"><a href="#Recurrence-relation-递推关系" class="headerlink" title="Recurrence relation 递推关系"></a>Recurrence relation 递推关系</h3><p>A recurrence relation for the sequence fang is an equation that expresses an in terms of one or more of the previous terms of the sequence, namely, $a<em>0,a_1,\cdots,a</em>{n-1}$, for all integers n with $n\geq n_0$, where $n_0$ is a nonnegative integer. A sequence is called a solution of a recurrence relation if its terms satisfy the recurrence relation.</p>
<h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><ul>
<li>Let ${a<em>n}$ be a sequence that satises the recurrence relation $a_n = a</em>{n-1} + 3$ for $1,2,3,\cdots,$ and suppose that $a_0=2$. What are a1, a2, and a3?</li>
<li>Let ${a<em>n}$ be a sequence that satises the recurrence relation $a_n = a</em>{n-1}-a_{n-2}$ for $n=2,3,4,\cdots$,  and suppose that $a_0 = 3$ and $a_1 = 5$. What are $a_2$ and $a_3$?</li>
</ul>
<h4 id="Fibonacci-sequence"><a href="#Fibonacci-sequence" class="headerlink" title="Fibonacci sequence"></a>Fibonacci sequence</h4><p>Fibonacci sequence, $f<em>0,f_1,f_2.\cdots,$ is dened by initial conditions $f_0 = 0,f_1 = 1$ and recurrence relation $f_n = f</em>{n-1}+f_{n-2}$ for $n=2,3,4,\cdots$</p>
<p>Determine whether sequence ${a<em>n}$, where $a_n = 3n$ for every nonnegative integer n, is a solution of recurrence relation $a_n = 2a</em>{n-1}-a_{n-2}$ for $n=2,3,4,\cdots$ Answer the same question where $a_n = 2^n$ and where $a_n = 5$. </p>
<h3 id="Summations"><a href="#Summations" class="headerlink" title="Summations"></a>Summations</h3><p>Some useful summation formula</p>
<p><img src="/2020/09/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E9%9B%86%E5%90%88%E4%B8%8E%E5%87%BD%E6%95%B0/5.png" style="zoom:100%;"></p>
<h3 id="Cardinality集的势"><a href="#Cardinality集的势" class="headerlink" title="Cardinality集的势"></a>Cardinality集的势</h3><p>集合的势是用来度量集合规模大小的属性的。</p>
<p>如果存在着从集合A到集合B的双射，那么称集合A与集合B等势。例：集合N={0,1,2…}，N2={0,2,4，…}定义映射：f：N→N2 ，f（n）=2n，f是从N到 N2的双射，从而N和N2 是等势的。</p>
<p>有很多集合都和全体正整数的集合等势，从而它们彼此也等势，称所有这样的集合为“可数无穷的（countably infinite）”。有很多无穷集合比全体正整数的集合的势更大，称所有这样的集合为不可数无穷的（uncountably infinite）。但是，不存在无穷集合的势比全体正整数的集合的势更小</p>
<p>Sets A and B have the same cardinality if and only if there is a one-to-one correspondence from A to B. When A and B have the same cardinality, we write |A| = |B|. </p>
<p>If there is a one-to-one function from A to B, the cardinality of A is less than or the same as the cardinality of B and we write $|A|\leq|B|$,<br>Moreover, when $|A|\leq|B|$, and A and B have different cardinality, we say that the cardinality of A is less than the cardinality of B and we write $|A|&lt;|B|$ </p>
<h3 id="Countable-sets"><a href="#Countable-sets" class="headerlink" title="Countable sets"></a>Countable sets</h3><p>A set that is either finite or has the same cardinality as $Z^+$ is called countable. If an finite set S is countable, then |S| = $\aleph_0$ </p>
<h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h4><p>Show that the set of odd positive integers is a countable set.</p>
<p><img src="/2020/09/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E9%9B%86%E5%90%88%E4%B8%8E%E5%87%BD%E6%95%B0/6.png" style="zoom:100%;"></p>
<h4 id="Hilberts-Grand-Hotel"><a href="#Hilberts-Grand-Hotel" class="headerlink" title="Hilberts Grand Hotel"></a>Hilberts Grand Hotel</h4><p>Grand Hotel with $\aleph_0$  rooms How can we accommodate a new guest arriving at the<br>fully occupied Grand Hotel without removing any of the current guests?</p>
<p>Solution<br>Because the rooms of the Grand Hotel are countable, we can list them as Room 1, Room 2, Room 3, and so on. When a new guest arrives, we move the guest in Room 1 to Room 2, the guest in Room 2 to Room 3, and in general, the guest in Room n to Room n + 1, for all positive integers n. This frees up Room 1, which we assign to the new guest, and all the current guests still have rooms.</p>
<h4 id="Integer-Set"><a href="#Integer-Set" class="headerlink" title="Integer Set"></a>Integer Set</h4><p>Show that the set of all integers is countable.</p>
<p><img src="/2020/09/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E9%9B%86%E5%90%88%E4%B8%8E%E5%87%BD%E6%95%B0/7.png" style="zoom:100%;"></p>
<h4 id="Positive-rational-numbers"><a href="#Positive-rational-numbers" class="headerlink" title="Positive rational numbers"></a>Positive rational numbers</h4><p>Show that all positive rational numbers is countable.</p>
<p><img src="/2020/09/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E9%9B%86%E5%90%88%E4%B8%8E%E5%87%BD%E6%95%B0/2.jpg" style="zoom:100%;"></p>
<h3 id="An-uncountable-set"><a href="#An-uncountable-set" class="headerlink" title="An uncountable set"></a>An uncountable set</h3><h4 id="Real-numbers"><a href="#Real-numbers" class="headerlink" title="Real numbers"></a>Real numbers</h4><p>Show that the set of real numbers is an uncountable set.</p>
<p><img src="/2020/09/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E9%9B%86%E5%90%88%E4%B8%8E%E5%87%BD%E6%95%B0/8.png" style="zoom:100%;"></p>
<p><img src="/2020/09/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E9%9B%86%E5%90%88%E4%B8%8E%E5%87%BD%E6%95%B0/10.png" style="zoom:100%;"></p>
<h3 id="Results-about-cardinality"><a href="#Results-about-cardinality" class="headerlink" title="Results about cardinality"></a>Results about cardinality</h3><p><img src="/2020/09/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E9%9B%86%E5%90%88%E4%B8%8E%E5%87%BD%E6%95%B0/11.png" style="zoom:100%;"></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><p>Let A and B be nonempty sets. A function f from A to B is an assignment of exactly one element of B to each element of A. We write $f (a) = b$ if b is the unique element of B assigned by function f to element a of A. If f is a function from A to B, we write $f: A\rightarrow B$ </p>
<h4 id="Domain-定义域-and-codomain-陪域"><a href="#Domain-定义域-and-codomain-陪域" class="headerlink" title="Domain(定义域) and codomain(陪域)"></a>Domain(定义域) and codomain(陪域)</h4><p>If f is a function from A to B, we say that A is the domain of f and B is the codomain of f . If f (a) = b, we say that b is the image of a and a is a preimage of b. The range, or image, of f is the set of all images of elements of A. Also, if f is a function from A to B, we say that f maps A to B.</p>
<p>Let g be the function that assigns a grade to a student in our discrete mathematics class. Note that g(Adams) = A, for instance.</p>
<p>The domain of g is set {Adams, Chou, Goodfriend, Rodriguez, Stevens}, and the<br>codomain is set {A, B, C ,D,F}.</p>
<p>The range of g is set {A, B, C, F}, because each grade except D is assigned to some students.</p>
<h4 id="Add-and-product"><a href="#Add-and-product" class="headerlink" title="Add and product"></a>Add and product</h4><p><strong>Definition</strong></p>
<p>Let $f_1$ and $f_2$ be functions from A to R. Then $f_1+f_2$ and $f_1f_2$ are also functions from A to R defined for all $x\in A$ by</p>
<p>$(f_1+f_2)(x) = f_1(x)+f_2(x)$</p>
<p>$(f_1f_2)(x) = f_1(x)f_2(x)$ </p>
<p><strong>Example</strong> </p>
<p>Let $f_1$ and $f_2$ be functions from R to R such that $f_1(x) = (x+1)^2$ and $f_2(x) = -(x-1)^2$ Thus we have</p>
<p>$(f_1+f_2)(x) = f_1(x)+f_2(x)= (x+1)^2-(x-1)^2 = 4x$ </p>
<p>$(f_1f_2)(x) = f_1(x)f_2(x) = -(x+1)^2(x-1)^2 = -(x^2-1)^2$ </p>
<h3 id="Projection-函数的投影"><a href="#Projection-函数的投影" class="headerlink" title="Projection 函数的投影"></a>Projection 函数的投影</h3><p><img src="/2020/09/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E9%9B%86%E5%90%88%E4%B8%8E%E5%87%BD%E6%95%B0/12.png" style="zoom:100%;"></p>
<h3 id="One-to-one-and-onto-functions"><a href="#One-to-one-and-onto-functions" class="headerlink" title="One-to-one and onto functions"></a>One-to-one and onto functions</h3><p><img src="/2020/09/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E9%9B%86%E5%90%88%E4%B8%8E%E5%87%BD%E6%95%B0/13.png" style="zoom:100%;"></p>
<h4 id="单射（one-to-one或injective）"><a href="#单射（one-to-one或injective）" class="headerlink" title="单射（one to one或injective）"></a>单射（one to one或injective）</h4><p>没有两个x有相同的y</p>
<h4 id="满射-onto-function-surjection"><a href="#满射-onto-function-surjection" class="headerlink" title="满射(onto function surjection):"></a>满射(onto function surjection):</h4><p>每一个y都必有至少一个x与之对应</p>
<h4 id="双射-又叫一一对应-bijection"><a href="#双射-又叫一一对应-bijection" class="headerlink" title="双射(又叫一一对应,bijection):"></a>双射(又叫一一对应,bijection):</h4><p>同时满足单射与满射，也就是常见的函数映射</p>
<p>那么通俗的说，单射就是只能一对一，不能多对一，满射就是不论一对一，还是多对一，在映射f:X→Y中，Y中任一元素y都是X中某元素的像，也就是Y中所有元素在X中都能找到原像，至于找到的只有一个原像,那就是双射，但有的可以找到一个以上的那就不是双射，即双射就是既是单射又是满射。</p>
<h3 id="Inverse-function-反函数"><a href="#Inverse-function-反函数" class="headerlink" title="Inverse function 反函数"></a>Inverse function 反函数</h3><p><img src="/2020/09/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E9%9B%86%E5%90%88%E4%B8%8E%E5%87%BD%E6%95%B0/14.png" style="zoom:100%;"></p>
<h3 id="Composition-of-functions-复合函数"><a href="#Composition-of-functions-复合函数" class="headerlink" title="Composition of functions 复合函数"></a>Composition of functions 复合函数</h3><p><img src="/2020/09/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E9%9B%86%E5%90%88%E4%B8%8E%E5%87%BD%E6%95%B0/15.png" style="zoom: 120%;"></p>
<p><img src="/2020/09/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E9%9B%86%E5%90%88%E4%B8%8E%E5%87%BD%E6%95%B0/16.png" style="zoom:100%;"></p>
<h4 id="Inverse-of-composition-of-functions"><a href="#Inverse-of-composition-of-functions" class="headerlink" title="Inverse of composition of functions"></a>Inverse of composition of functions</h4><p><img src="/2020/09/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E9%9B%86%E5%90%88%E4%B8%8E%E5%87%BD%E6%95%B0/17.png" style="zoom:100%;"></p>
<h3 id="Some-important-functions-Floor-and-ceiling-functions"><a href="#Some-important-functions-Floor-and-ceiling-functions" class="headerlink" title="Some important functions: Floor and ceiling functions"></a>Some important functions: Floor and ceiling functions</h3><p><img src="/2020/09/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E9%9B%86%E5%90%88%E4%B8%8E%E5%87%BD%E6%95%B0/18.png" style="zoom:100%;"></p>
<p><img src="/2020/09/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E9%9B%86%E5%90%88%E4%B8%8E%E5%87%BD%E6%95%B0/19.png" style="zoom:100%;"></p>
<h4 id="Useful-properties-of-floor-and-ceiling-functions"><a href="#Useful-properties-of-floor-and-ceiling-functions" class="headerlink" title="Useful properties of  floor and ceiling functions"></a>Useful properties of  floor and ceiling functions</h4><p><img src="/2020/09/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E9%9B%86%E5%90%88%E4%B8%8E%E5%87%BD%E6%95%B0/20.png" style="zoom:100%;"></p>
<h3 id="Some-important-functions-Indicator-function"><a href="#Some-important-functions-Indicator-function" class="headerlink" title="Some important functions: Indicator function"></a>Some important functions: Indicator function</h3><p><img src="/2020/09/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E9%9B%86%E5%90%88%E4%B8%8E%E5%87%BD%E6%95%B0/21.png" style="zoom:100%;"></p>
<p><img src="/2020/09/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E9%9B%86%E5%90%88%E4%B8%8E%E5%87%BD%E6%95%B0/22.png" style="zoom:100%;"></p>
<h3 id="Some-important-functions-Sigmoid-functions"><a href="#Some-important-functions-Sigmoid-functions" class="headerlink" title="Some important functions: Sigmoid functions"></a>Some important functions: Sigmoid functions</h3><p><img src="/2020/09/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E9%9B%86%E5%90%88%E4%B8%8E%E5%87%BD%E6%95%B0/23.png" style="zoom:100%;"></p>
<p><img src="/2020/09/03/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E9%9B%86%E5%90%88%E4%B8%8E%E5%87%BD%E6%95%B0/24.png" style="zoom:100%;"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/08/30/BFSandDFS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/30/BFSandDFS/" itemprop="url">BFSandDFS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-30T15:03:00+08:00">
                2020-08-30
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-12-08T15:29:22+08:00">
                2022-12-08
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="BFSandDFS"><a href="#BFSandDFS" class="headerlink" title="BFSandDFS"></a>BFSandDFS</h1><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>深度优先搜索（Depth First Search，DFS），是最常见的图搜索方法之一。深度优先搜索沿着一条路径一直走下去，无法行进时，回退回退到刚刚访问的结点，似不撞南墙不回头，不到黄河不死心。深度优先遍历是按照深度优先搜索的方式对图进行遍历。</p>
<p>时刻牢记：  <strong>后被访问的顶点，其邻接点先被访问。</strong>根据深度优先遍历秘籍，后来先服务，可以借助于栈实现。递归本身就是使用栈实现的，因此使用递归方法更方便。</p>
<p>1.初始化图中所有顶点未被访问。</p>
<p>2.从图中的某个顶点<em>v</em>出发，访问<em>v</em>并标记已访问；</p>
<p>3.依次检查<em>v</em>的所有邻接点<em>w</em>，如果<em>w</em>未被访问，则从<em>w</em>出发进行深度优先遍历（递归调用，重复2—3步）。</p>
<p><img src="/2020/08/30/BFSandDFS/1.png" style="zoom:80%;"></p>
<p><img src="/2020/08/30/BFSandDFS/2.png" style="zoom:80%;"></p>
<p><img src="/2020/08/30/BFSandDFS/3.png" style="zoom:80%;"></p>
<p><img src="/2020/08/30/BFSandDFS/4.png" style="zoom:80%;"></p>
<p><img src="/2020/08/30/BFSandDFS/5.png" style="zoom:80%;"></p>
<p><img src="/2020/08/30/BFSandDFS/6.png" style="zoom:80%;"></p>
<h3 id="代码一览"><a href="#代码一览" class="headerlink" title="代码一览"></a>代码一览</h3><p>基于邻接表的深度优先遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxVnum=<span class="number">100</span>;<span class="comment">//顶点数最大值</span></span><br><span class="line"><span class="keyword">bool</span> visited[MaxVnum];  <span class="comment">//访问标志数组，其初值为"false"</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VexType;<span class="comment">//顶点的数据类型为字符型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AdjNode</span>&#123;</span> <span class="comment">//定义邻接点类型</span></span><br><span class="line">	<span class="keyword">int</span> v; <span class="comment">//邻接点下标</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">AdjNode</span> *<span class="title">next</span>;</span> <span class="comment">//指向下一个邻接点</span></span><br><span class="line">&#125;AdjNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VexNode</span>&#123;</span> <span class="comment">//定义顶点类型</span></span><br><span class="line">   VexType data; <span class="comment">// VexType为顶点的数据类型，根据需要定义</span></span><br><span class="line">   AdjNode *first; <span class="comment">//指向第一个邻接点</span></span><br><span class="line">&#125;VexNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span><span class="comment">//定义邻接表类型</span></span><br><span class="line">    VexNode  Vex[MaxVnum];</span><br><span class="line">    <span class="keyword">int</span> vexnum,edgenum; <span class="comment">//顶点数，边数</span></span><br><span class="line">&#125;ALGragh;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">locatevex</span><span class="params">(ALGragh G,VexType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//查找顶点信息的下标</span></span><br><span class="line">		<span class="keyword">if</span>(x==G.Vex[i].data)</span><br><span class="line">        	<span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//没找到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertedge</span><span class="params">(ALGragh &amp;G,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span><span class="comment">//插入一条边</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AdjNode *s;</span><br><span class="line">    s=<span class="keyword">new</span> AdjNode;</span><br><span class="line">    s-&gt;v=j;</span><br><span class="line">    s-&gt;next=G.Vex[i].first;</span><br><span class="line">    G.Vex[i].first=s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printg</span><span class="params">(ALGragh G)</span><span class="comment">//输出邻接表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"----------邻接表如下：----------"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       AdjNode *t=G.Vex[i].first;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;G.Vex[i].data&lt;&lt;<span class="string">"：  "</span>;</span><br><span class="line">       <span class="keyword">while</span>(t!=<span class="literal">NULL</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">cout</span>&lt;&lt;<span class="string">"["</span>&lt;&lt;t-&gt;v&lt;&lt;<span class="string">"]  "</span>;</span><br><span class="line">           t=t-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateALGraph</span><span class="params">(ALGragh &amp;G)</span><span class="comment">//创建无向图邻接表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    VexType u,v;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入顶点数和边数:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;G.vexnum&gt;&gt;G.edgenum;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入顶点信息:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//输入顶点信息，存入顶点信息数组</span></span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;G.Vex[i].data;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">        G.Vex[i].first=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请依次输入每条边的两个顶点u,v"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span>(G.edgenum--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        i=locatevex(G,u);<span class="comment">//查找顶点u的存储下标</span></span><br><span class="line">        j=locatevex(G,v);<span class="comment">//查找顶点v的存储下标</span></span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">-1</span>&amp;&amp;j!=<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            insertedge(G,i,j);</span><br><span class="line">            insertedge(G,j,i);<span class="comment">//无向图多插入一条边</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"输入顶点信息错！请重新输入！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			G.edgenum++;<span class="comment">//本次输入不算</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_AL</span><span class="params">(ALGragh G,<span class="keyword">int</span> v)</span><span class="comment">//基于邻接表的深度优先遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    AdjNode *p;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;G.Vex[v].data&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">    visited[v]=<span class="literal">true</span>;</span><br><span class="line">    p=G.Vex[v].first;</span><br><span class="line">    <span class="keyword">while</span>(p)<span class="comment">//依次检查v的所有邻接点</span></span><br><span class="line">    &#123;</span><br><span class="line">		w=p-&gt;v;<span class="comment">//w为v的邻接点</span></span><br><span class="line">		<span class="keyword">if</span>(!visited[w])<span class="comment">//w未被访问</span></span><br><span class="line">       		DFS_AL(G,w);<span class="comment">//从w出发，递归深度优先遍历</span></span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_AL</span><span class="params">(ALGragh G)</span><span class="comment">//非连通图，基于邻接表的深度优先遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//非连通图需要查漏点，检查未被访问的顶点</span></span><br><span class="line">    	<span class="keyword">if</span>(!visited[i])<span class="comment">//i未被访问,以i为起点再次深度优先遍历</span></span><br><span class="line">       		DFS_AL(G,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ALGragh G;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    VexType c;</span><br><span class="line">    CreateALGraph(G);<span class="comment">//创建有向图邻接表</span></span><br><span class="line">    printg(G);<span class="comment">//输出邻接表</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入遍历连通图的起始点："</span>;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;c;</span><br><span class="line">	v=locatevex(G,c);<span class="comment">//查找顶点u的存储下标</span></span><br><span class="line">    <span class="keyword">if</span>(v!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"深度优先搜索遍历连通图结果："</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        DFS_AL(G,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入顶点信息错！请重新输入！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于邻接矩阵的深度优先遍历。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVnum 100  <span class="comment">//顶点数最大值</span></span></span><br><span class="line"><span class="keyword">bool</span> visited[MaxVnum];  <span class="comment">//访问标志数组，其初值为"false"</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VexType;  <span class="comment">//顶点的数据类型，根据需要定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;  <span class="comment">//边上权值的数据类型，若不带权值的图，则为0或1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  VexType Vex[MaxVnum];</span><br><span class="line">  EdgeType Edge[MaxVnum][MaxVnum];</span><br><span class="line">  <span class="keyword">int</span> vexnum,edgenum; <span class="comment">//顶点数，边数</span></span><br><span class="line">&#125;AMGragh;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">locatevex</span><span class="params">(AMGragh G,VexType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//查找顶点信息的下标</span></span><br><span class="line">       <span class="keyword">if</span>(x==G.Vex[i])</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//没找到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateAMGraph</span><span class="params">(AMGragh &amp;G)</span><span class="comment">//创建无向图的邻接矩阵</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    VexType u,v;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入顶点数："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;G.vexnum;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入边数:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;G.edgenum;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入顶点信息:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//输入顶点信息，存入顶点信息数组</span></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;G.Vex[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//初始化邻接矩阵所有值为0，如果是网，则初始化邻接矩阵为无穷大</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;G.vexnum;j++)</span><br><span class="line">         G.Edge[i][j]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入每条边依附的两个顶点："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span>(G.edgenum--)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">       i=locatevex(G,u);<span class="comment">//查找顶点u的存储下标</span></span><br><span class="line">       j=locatevex(G,v);<span class="comment">//查找顶点v的存储下标</span></span><br><span class="line">       <span class="keyword">if</span>(i!=<span class="number">-1</span>&amp;&amp;j!=<span class="number">-1</span>)</span><br><span class="line">         G.Edge[i][j]=G.Edge[j][i]=<span class="number">1</span>; <span class="comment">//邻接矩阵储置1，若有向图G.Edge[i][j]=1</span></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入顶点信息错！请重新输入！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">           G.edgenum++;<span class="comment">//本次输入不算</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(AMGragh G)</span><span class="comment">//输出邻接矩阵</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"图的邻接矩阵为："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;G.vexnum;j++)</span><br><span class="line">        	<span class="built_in">cout</span>&lt;&lt;G.Edge[i][j]&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_AM</span><span class="params">(AMGragh G,<span class="keyword">int</span> v)</span><span class="comment">//基于邻接矩阵的深度优先遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;G.Vex[v]&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">    visited[v]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;G.vexnum;w++)<span class="comment">//依次检查v的所有邻接点</span></span><br><span class="line">       <span class="keyword">if</span>(G.Edge[v][w]&amp;&amp;!visited[w])<span class="comment">//v、w邻接(G.Edge[v][w]为1)而且w未被访问</span></span><br><span class="line">          DFS_AM(G,w);<span class="comment">//从w顶点开始递归深度优先遍历</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    VexType c;</span><br><span class="line">    AMGragh G;</span><br><span class="line">    CreateAMGraph(G);</span><br><span class="line">    <span class="built_in">print</span>(G);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入遍历连通图的起始点："</span>;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;c;</span><br><span class="line">	v=locatevex(G,c);<span class="comment">//查找顶点u的存储下标</span></span><br><span class="line">    <span class="keyword">if</span>(v!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"深度优先搜索遍历连通图结果："</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        DFS_AM(G,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入顶点信息错！请重新输入！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>1.<strong>基于邻接矩阵的DFS算法</strong></p>
<p>查找每个顶点的邻接点需要<em>O</em>(<em>n</em>)时间，一共<em>n</em>个顶点，总的时间复杂度为$O(n^2)$，使用了一个递归工作栈，空间复杂度为<em>O</em>(<em>n</em>)。</p>
<p>2.<strong>基于邻接表的DFS算法</strong></p>
<p>查找顶点<em>vi</em>的邻接点需要<em>O</em>(<em>d</em>(<em>vi</em>))时间，<em>d</em>(<em>vi</em>)为<em>vi</em>的出度（无向图为度），对有向图而言，所有顶点的出度之和等于边数<em>e</em>，对无向图而言，所有顶点的度之和等于2e，因此查找邻接点的时间复杂度为$O(e)$，加上初始化时间$O(n)$，总的时间复杂度为$O(n+e)$，使用了一个递归工作栈，空间复杂度为$O(n)$。</p>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>广度优先搜索（Breadth First Search，BFS），又称为宽度优先搜索，是最常见的图搜索方法之一。广度优先搜索是从某个顶点（源点）出发，一次性访问所有未被访问的邻接点，再依次从这些访问过邻接点出发，…，似水中涟漪，似声音传播，一层层地传播开来。广度优先遍历是按照广度优先搜索的方式对图进行遍历。</p>
<p><img src="/2020/08/30/BFSandDFS/7.png" style="zoom:80%;"></p>
<p>记住： <strong>先被访问的顶点，其邻接点先被访问。</strong></p>
<p>根据广度优先遍历秘籍，先来先服务，可以借助于队列实现。每个结点访问一次且只访问一次，因此可以设置一个辅助数组：</p>
<p>visited[<em>i</em>]=false，表示第<em>i</em>个顶点未访问；</p>
<p>visited[<em>i</em>]=true，表示第<em>i</em>个顶点已访问。</p>
<p>1.初始化图中所有顶点未被访问，初始化一个空队列。</p>
<p>2.从图中的某个顶点<em>v</em>出发，访问<em>v</em>并标记已访问，将<em>v</em>入队；</p>
<p>3.如果队列非空，则继续执行，否则算法结束；</p>
<p>4.队头元素<em>v</em>出队，依次访问<em>v</em>的所有未被访问邻接点，标记已访问并入队。转向步骤3；</p>
<h3 id="代码一览-1"><a href="#代码一览-1" class="headerlink" title="代码一览"></a>代码一览</h3><p><strong>基于邻接表的广度优先遍历</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;//引入队列头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxVnum=<span class="number">100</span>;<span class="comment">//顶点数最大值</span></span><br><span class="line"><span class="keyword">bool</span> visited[MaxVnum];  <span class="comment">//访问标志数组，其初值为"false"</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VexType;<span class="comment">//顶点的数据类型为字符型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AdjNode</span>&#123;</span> <span class="comment">//定义邻接点类型</span></span><br><span class="line">	<span class="keyword">int</span> v; <span class="comment">//邻接点下标</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">AdjNode</span> *<span class="title">next</span>;</span> <span class="comment">//指向下一个邻接点</span></span><br><span class="line">&#125;AdjNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VexNode</span>&#123;</span> <span class="comment">//定义顶点类型</span></span><br><span class="line">	VexType data; <span class="comment">// VexType为顶点的数据类型，根据需要定义</span></span><br><span class="line">	AdjNode *first; <span class="comment">//指向第一个邻接点</span></span><br><span class="line">&#125;VexNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span><span class="comment">//定义邻接表类型</span></span><br><span class="line">    VexNode  Vex[MaxVnum];</span><br><span class="line">    <span class="keyword">int</span> vexnum,edgenum; <span class="comment">//顶点数，边数</span></span><br><span class="line">&#125;ALGragh;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">locatevex</span><span class="params">(ALGragh G,VexType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//查找顶点信息的下标</span></span><br><span class="line">		<span class="keyword">if</span>(x==G.Vex[i].data)</span><br><span class="line">			<span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//没找到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertedge</span><span class="params">(ALGragh &amp;G,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span><span class="comment">//插入一条边</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AdjNode *s;</span><br><span class="line">    s=<span class="keyword">new</span> AdjNode;</span><br><span class="line">    s-&gt;v=j;</span><br><span class="line">    s-&gt;next=G.Vex[i].first;</span><br><span class="line">    G.Vex[i].first=s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printg</span><span class="params">(ALGragh G)</span><span class="comment">//输出邻接表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"----------邻接表如下：----------"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       AdjNode *t=G.Vex[i].first;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;G.Vex[i].data&lt;&lt;<span class="string">"：  "</span>;</span><br><span class="line">       <span class="keyword">while</span>(t!=<span class="literal">NULL</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">cout</span>&lt;&lt;<span class="string">"["</span>&lt;&lt;t-&gt;v&lt;&lt;<span class="string">"]  "</span>;</span><br><span class="line">           t=t-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateALGraph</span><span class="params">(ALGragh &amp;G)</span><span class="comment">//创建有向图邻接表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    VexType u,v;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入顶点数和边数:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;G.vexnum&gt;&gt;G.edgenum;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入顶点信息:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//输入顶点信息，存入顶点信息数组</span></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;G.Vex[i].data;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">        G.Vex[i].first=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请依次输入每条边的两个顶点u,v"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span>(G.edgenum--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        i=locatevex(G,u);<span class="comment">//查找顶点u的存储下标</span></span><br><span class="line">        j=locatevex(G,v);<span class="comment">//查找顶点v的存储下标</span></span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">-1</span>&amp;&amp;j!=<span class="number">-1</span>)</span><br><span class="line">            insertedge(G,i,j);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"输入顶点信息错！请重新输入！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			G.edgenum++;<span class="comment">//本次输入不算</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS_AL</span><span class="params">(ALGragh G,<span class="keyword">int</span> v)</span><span class="comment">//基于邻接表的广度优先遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,w;</span><br><span class="line">    AdjNode *p;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;Q; <span class="comment">//创建一个普通队列(先进先出)，里面存放int类型</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;G.Vex[v].data&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">    visited[v]=<span class="literal">true</span>;</span><br><span class="line">    Q.push(v); <span class="comment">//源点v入队</span></span><br><span class="line">    <span class="keyword">while</span>(!Q.empty()) <span class="comment">//如果队列不空</span></span><br><span class="line">    &#123;</span><br><span class="line">        u=Q.front();<span class="comment">//取出队头元素赋值给u</span></span><br><span class="line">        Q.pop(); <span class="comment">//队头元素出队</span></span><br><span class="line">        p=G.Vex[u].first;</span><br><span class="line">        <span class="keyword">while</span>(p)<span class="comment">//依次检查u的所有邻接点</span></span><br><span class="line">        &#123;</span><br><span class="line">            w=p-&gt;v;<span class="comment">//w为u的邻接点</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[w])<span class="comment">//w未被访问</span></span><br><span class="line">            &#123;</span><br><span class="line">            	<span class="built_in">cout</span>&lt;&lt;G.Vex[w].data&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">            	visited[w]=<span class="literal">true</span>;</span><br><span class="line">            	Q.push(w);</span><br><span class="line">            &#125;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS_AL</span><span class="params">(ALGragh G)</span><span class="comment">//非连通图，基于邻接表的广度优先遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//非连通图需要查漏点，检查未被访问的顶点</span></span><br><span class="line">    	<span class="keyword">if</span>(!visited[i])<span class="comment">//i未被访问,以i为起点再次广度优先遍历</span></span><br><span class="line">       		BFS_AL(G,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ALGragh G;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    VexType c;</span><br><span class="line">    CreateALGraph(G);<span class="comment">//创建有向图邻接表</span></span><br><span class="line">    printg(G);<span class="comment">//输出邻接表</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入遍历连通图的起始点："</span>;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;c;</span><br><span class="line">	v=locatevex(G,c);<span class="comment">//查找顶点u的存储下标</span></span><br><span class="line">    <span class="keyword">if</span>(v!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">"广度优先搜索遍历连通图结果："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        BFS_AL(G,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"输入顶点信息错！请重新输入！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>基于邻接矩阵的广度优先遍历</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;//引入队列头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVnum 100  <span class="comment">//顶点数最大值</span></span></span><br><span class="line"><span class="keyword">bool</span> visited[MaxVnum];  <span class="comment">//访问标志数组，其初值为"false"</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VexType;  <span class="comment">//顶点的数据类型，根据需要定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;  <span class="comment">//边上权值的数据类型，若不带权值的图，则为0或1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	VexType Vex[MaxVnum];</span><br><span class="line">	EdgeType Edge[MaxVnum][MaxVnum];</span><br><span class="line">	<span class="keyword">int</span> vexnum,edgenum; <span class="comment">//顶点数，边数</span></span><br><span class="line">&#125;AMGragh;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">locatevex</span><span class="params">(AMGragh G,VexType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//查找顶点信息的下标</span></span><br><span class="line">		<span class="keyword">if</span>(x==G.Vex[i])</span><br><span class="line">       		<span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//没找到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateAMGraph</span><span class="params">(AMGragh &amp;G)</span><span class="comment">//创建有向图的邻接矩阵</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    VexType u,v;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入顶点数："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;G.vexnum;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入边数:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;G.edgenum;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入顶点信息:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//输入顶点信息，存入顶点信息数组</span></span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;G.Vex[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//初始化邻接矩阵所有值为0，如果是网，则初始化邻接矩阵为无穷大</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;G.vexnum;j++)</span><br><span class="line">			G.Edge[i][j]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入每条边依附的两个顶点："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span>(G.edgenum--)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">       i=locatevex(G,u);<span class="comment">//查找顶点u的存储下标</span></span><br><span class="line">       j=locatevex(G,v);<span class="comment">//查找顶点v的存储下标</span></span><br><span class="line">		<span class="keyword">if</span>(i!=<span class="number">-1</span>&amp;&amp;j!=<span class="number">-1</span>)</span><br><span class="line">			G.Edge[i][j]=<span class="number">1</span>; <span class="comment">//邻接矩阵储置1，若无向图G.Edge[i][j]=G.Edge[j][i]=1</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="string">"输入顶点信息错！请重新输入！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			G.edgenum++;<span class="comment">//本次输入不算</span></span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(AMGragh G)</span><span class="comment">//输出邻接矩阵</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"图的邻接矩阵为："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;G.vexnum;j++)</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;G.Edge[i][j]&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS_AM</span><span class="params">(AMGragh G,<span class="keyword">int</span> v)</span><span class="comment">//基于邻接矩阵的广度优先遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u,w;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;Q; <span class="comment">//创建一个普通队列(先进先出)，里面存放int类型</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;G.Vex[v]&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">    visited[v]=<span class="literal">true</span>;</span><br><span class="line">    Q.push(v); <span class="comment">//源点v入队</span></span><br><span class="line">    <span class="keyword">while</span>(!Q.empty()) <span class="comment">//如果队列不空</span></span><br><span class="line">    &#123;</span><br><span class="line">        u=Q.front();<span class="comment">//取出队头元素赋值给u</span></span><br><span class="line">        Q.pop(); <span class="comment">//队头元素出队</span></span><br><span class="line">        <span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;G.vexnum;w++)<span class="comment">//依次检查u的所有邻接点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(G.Edge[u][w]&amp;&amp;!visited[w])<span class="comment">//u、w邻接而且w未被访问</span></span><br><span class="line">            &#123;</span><br><span class="line">               <span class="built_in">cout</span>&lt;&lt;G.Vex[w]&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">               visited[w]=<span class="literal">true</span>;</span><br><span class="line">               Q.push(w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    VexType c;</span><br><span class="line">    AMGragh G;</span><br><span class="line">    CreateAMGraph(G);</span><br><span class="line">    <span class="built_in">print</span>(G);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入遍历连通图的起始点："</span>;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;c;</span><br><span class="line">	v=locatevex(G,c);<span class="comment">//查找顶点u的存储下标</span></span><br><span class="line">    <span class="keyword">if</span>(v!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"广度优先搜索遍历连通图结果："</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        BFS_AM(G,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入顶点信息错！请重新输入！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><p>1.<strong>基于邻接矩阵的BFS算法</strong></p>
<p>查找每个顶点的邻接点需要$O(n)$时间，一共$n$个顶点，总的时间复杂度为$O(n^2)$，使用了一个辅助队列，最坏的情况下每个顶点入队一次，空间复杂度为$O(n)$。</p>
<p>2.<strong>基于邻接表的BFS算法</strong></p>
<p>查找顶点<em>vi</em>的邻接点需要<em>O</em>(<em>d</em>(<em>vi</em>))时间，<em>d</em>(<em>vi</em>)为$v_i$的出度（无向图为度），对有向图而言，所有顶点的出度之和等于边数<em>e</em>，对无向图而言，所有顶点的度之和等于2<em>e</em>，因此查找邻接点的时间复杂度为<em>O</em>(<em>e</em>)，加上初始化时间$O(n)$，总的时间复杂度为$O(n+e)$，使用了一个辅助队列，最坏的情况下每个顶点入队一次，空间复杂度为$O(n)$。</p>
<p>总而言之，只要是邻接矩阵，BFS、DFS都是 $O(n^2)$ ； 只要是邻接表，BFS、DFS 时间复杂度都是 $O(n)$</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/08/29/%E6%9F%A5%E6%89%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/29/%E6%9F%A5%E6%89%BE/" itemprop="url">查找</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-29T16:49:49+08:00">
                2020-08-29
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-08-29T19:12:06+08:00">
                2020-08-29
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>查找算法的性能和下面几个因素有关：</p>
<p>1）算法</p>
<p>2） 数据规模</p>
<p>3）待查关键字在数据表中的位置</p>
<p>4）查找的频率</p>
<p>评价一个查找算法的好坏，一般采用平均查找长度(ASL) 来衡量。分为查找成功的平均查找长度和查找失败的平均查找长度。计算公式：</p>
<p>$ASL = \Sigma_{i=1}^n p_ic_i$</p>
<p>其中，n为数据规模，$p_i$ 为查找第i 个记录的概率，$c_i$ 为查找第i个记录所需要的关键字比较次数。</p>
<p>根据在查找过程中是否对表有修改操作，分为静态查找和动态查找。根据数据结构的不同又分为线性表查找、数表查找和散列表查找。散列表查找是一种比较特殊的查找方式。</p>
<p>线性表的查找非常简单，如果线性表无序，则采用顺序查找，如果线性表有序，则采用二分查找(折半查找)</p>
<p><img src="/2020/08/29/%E6%9F%A5%E6%89%BE/1.png" style="zoom:150%;"></p>
<p>平衡二叉查找树有AVL、tremp、splay、SBT、红黑树等</p>
<h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>例如，序列 ${8,12,5,16,55,24,20,18,36,6,50}$  ,用顺序查找法查找 55</p>
<p>1） 初始状态，将序列存储在数组 $r[0…10]$ 中， x=55</p>
<p>2）将 x 与 r[0] 比较，$x\neq r[0]$，则继续比较下一个。如图8-1所示。</p>
<p><img src="/2020/08/29/%E6%9F%A5%E6%89%BE/2.png" style="zoom:100%;"></p>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a>算法分析：</h3><p>1） 时间复杂度</p>
<p>顺序查找最好的情况，一次查找成功，最坏的情况n次查找成功。</p>
<p>假设查找每个关键字的概率均等，即查找概率 $p_i=1/n$ ，查找第i个关键字需要比较i次成功，则查找成功的平均查找长度:</p>
<p>$ASL = \sum<em>{i=1}^np_ic_i=\sum</em>{i=1}^n \frac{1}{n} i = \frac{n+1}{2}$   </p>
<p>如果查找的关键字不存在，则每次都会比较n次，时间复杂度为 $O(n)$ m</p>
<p>2) 空间复杂度</p>
<p>算法只使用了一个辅助变量i， 空间复杂度为$O(1)$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SqSearch</span><span class="params">(<span class="keyword">int</span> r[],<span class="keyword">int</span> n,<span class="keyword">int</span> x)</span><span class="comment">//顺序查找</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="comment">//要判断i是否超过范围n</span></span><br><span class="line">        <span class="keyword">if</span>(r[i]==x) <span class="comment">//r[i]和x比较</span></span><br><span class="line">            <span class="keyword">return</span> i;<span class="comment">//返回下标</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SqSearch2</span><span class="params">(<span class="keyword">int</span> r2[],<span class="keyword">int</span> n,<span class="keyword">int</span> x)</span><span class="comment">//顺序查找优化算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	r2[<span class="number">0</span>]=x;<span class="comment">//待查找元素放入r[0]，作为监视哨</span></span><br><span class="line">	<span class="keyword">for</span>(i=n;r2[i]!=x;i--);<span class="comment">//不需要判断i是否超过范围</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>给定n个元素序列，这些元素是有序的(假设为升序)，从序列中查找元素x。</p>
<p>用一维数组 S[] 存储该有序序列，设变量low和high表示查找范围的下界和上界，middle表示查找范围的中间位置，x为特定的查找元素。</p>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>1) 初始化。 令low = 0，即指向有序数组 $S[]$ 的第一个元素； high = n-1，即指向有序数组 $S[]$ 的最后一个元素</p>
<p>2）判定 $low\leq high$ 是否成立，如果成立，转向第三步，否则算法结束。</p>
<p>3）middle = (low+high)/2 即只想查找范围的中间元素。</p>
<p>4）判断x 与 $S[middle]$ 的关系。如果 $x= S[middle]$ ,则搜索成功，算法结束；如果 $x&gt;S[middle]$ 则令 $low = middle+1$ 否则令 $high = middle-1$ 转向第2步。</p>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>1） 时间复杂度</p>
<p>二分查找算法，时间复杂度怎么计算呢？ 如果用 $T(n)$ 来表示n个有序元素的二分查找算法的事件复杂度，那么： 当n=1 时，需要一次比较 $T(n)=O(1)$</p>
<p>当 $n&gt;1$ 时，带查找元素和中间位置元素比较，需要$O(1)$ 时间，如果比较不成功，那么需要在前半部分或者后半部分搜索，问题的规模缩小了一般，时间复杂度变为$T(n/2)$ </p>
<p><img src="/2020/08/29/%E6%9F%A5%E6%89%BE/3.png" style="zoom:100%;"></p>
<p>二分查找的非递归算法和递归算法有一样的时间复杂度，均为 $O(logn)$ </p>
<p>2) 空间复杂度</p>
<p>二分查找的非递归算法中，变量占用了一些辅助空间，这些辅助空间都是常数阶的，因此空间复杂度为$O(1)$ </p>
<p>二分查找递归算法，除了使用一些变量外，递归调用还需要使用栈来实现。</p>
<p><img src="/2020/08/29/%E6%9F%A5%E6%89%BE/4.png" style="zoom:100%;"></p>
<p>递归调用最重的规模为1，即 $n/2^x=1$ 则 $x=logn$ 设阴影部分时搜所经过的路径，一共经过了log n 个 节点，也就是说递归调用了 log n次。递归算法使用的栈空间为递归树的深度，因此二分查找递归算法的空间复杂度为$O(logn)$ </p>
<h3 id="代码一览"><a href="#代码一览" class="headerlink" title="代码一览"></a>代码一览</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> s[],<span class="keyword">int</span> n,<span class="keyword">int</span> x)</span><span class="comment">//二分查找非递归算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> low=<span class="number">0</span>,high=n<span class="number">-1</span>;  <span class="comment">//low指向有序数组的第一个元素，high指向有序数组的最后一个元素</span></span><br><span class="line">   <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">int</span> middle=(low+high)/<span class="number">2</span>;  <span class="comment">//middle为查找范围的中间值</span></span><br><span class="line">       <span class="keyword">if</span>(x==s[middle])  <span class="comment">//x等于查找范围的中间值，算法结束</span></span><br><span class="line">          <span class="keyword">return</span> middle;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;s[middle]) <span class="comment">//x大于查找范围的中间元素，则从左半部分查找</span></span><br><span class="line">              low=middle+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>            <span class="comment">//x小于查找范围的中间元素，则从右半部分查找</span></span><br><span class="line">              high=middle<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recursionBS</span> <span class="params">(<span class="keyword">int</span> s[],<span class="keyword">int</span> x,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span> <span class="comment">//二分查找递归算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//low指向数组的第一个元素，high指向数组的最后一个元素</span></span><br><span class="line">    <span class="keyword">if</span>(low&gt;high)              <span class="comment">//递归结束条件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> middle=(low+high)/<span class="number">2</span>;  <span class="comment">//计算middle值(查找范围的中间值)</span></span><br><span class="line">    <span class="keyword">if</span>(x==s[middle])          <span class="comment">//x等于s[middle]，查找成功，算法结束</span></span><br><span class="line">        <span class="keyword">return</span> middle;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;s[middle])      <span class="comment">//x小于s[middle]，则从前半部分查找</span></span><br><span class="line">             <span class="keyword">return</span> recursionBS (s,x,low,middle<span class="number">-1</span>);</span><br><span class="line">           <span class="keyword">else</span>               <span class="comment">//x大于s[middle]，则从后半部分查找</span></span><br><span class="line">             <span class="keyword">return</span> recursionBS (s,x,middle+<span class="number">1</span>,high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/08/29/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84C-%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/29/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%9A%84C-%E5%AE%9E%E7%8E%B0/" itemprop="url">循环队列的C++实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-29T10:24:21+08:00">
                2020-08-29
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-09-11T20:18:54+08:00">
                2020-09-11
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="循环队列的C-实现"><a href="#循环队列的C-实现" class="headerlink" title="循环队列的C++实现"></a>循环队列的C++实现</h1><p>文章选自</p>
<p><a href="https://www.cnblogs.com/diegodu/p/4619104.html" target="_blank" rel="noopener">https://www.cnblogs.com/diegodu/p/4619104.html</a></p>
<p><a href="https://blog.csdn.net/alidada_blog/article/details/80313388" target="_blank" rel="noopener">https://blog.csdn.net/alidada_blog/article/details/80313388</a></p>
<p>循环队列初始条件:队头指针（front）=队尾指针(rear)=0<br>循环队列队满条件:(rear+1)%size == front     (size是顺序表的最大储存空间)<br>循环队列空条件:队头指针（rear）=队尾指针(front)</p>
<p>队头指针向后移动计算:队头指针= (rear+1)%size    (size是顺序表的最大储存空间)<br>队尾指针向后移动计算:队尾指针= (front+1)%size   (size是顺序表的最大储存空间)</p>
<p>空队时指针（下标）front和rear在一起都指向队前方，当有元素进队，则rear后移；有元素出队，则front后移，最后，开始时分配给队的前端不再被利用。</p>
<p>注意：空队时rear等于front，满队时必须空一个位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">cycleQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> m_size;</span><br><span class="line">        <span class="keyword">int</span> m_front;</span><br><span class="line">        <span class="keyword">int</span> m_rear;</span><br><span class="line">        T*  m_data;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        cycleQueue(<span class="keyword">unsigned</span> <span class="built_in">size</span>):m_size(<span class="built_in">size</span>),m_front(<span class="number">0</span>),m_rear(<span class="number">0</span>)</span><br><span class="line">        &#123;   </span><br><span class="line">            m_data = <span class="keyword">new</span> T[<span class="built_in">size</span>];</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        ~cycleQueue()</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">delete</span> []m_data;</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;   </span><br><span class="line">            <span class="keyword">return</span> m_front == m_rear;</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">        </span>&#123;   </span><br><span class="line">            <span class="keyword">return</span> m_front == (m_rear + <span class="number">1</span>)%m_size;</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T ele)</span><span class="title">throw</span><span class="params">(bad_exception)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(isFull())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> bad_exception();</span><br><span class="line">            &#125;</span><br><span class="line">            m_data[m_rear] = ele;</span><br><span class="line">            m_rear = (m_rear + <span class="number">1</span>)%m_size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">T <span class="title">pop</span><span class="params">()</span> <span class="title">throw</span><span class="params">(bad_exception)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> bad_exception();</span><br><span class="line">            &#125;</span><br><span class="line">            T tmp = m_data[m_front];</span><br><span class="line">            m_front = (m_front + <span class="number">1</span>)%m_size;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">cycleQueue&lt;<span class="keyword">int</span>&gt; <span class="title">q</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    q.push(<span class="number">1</span>);</span><br><span class="line">    q.push(<span class="number">2</span>);</span><br><span class="line">    q.push(<span class="number">3</span>);</span><br><span class="line">    q.push(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span> ; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; q.pop() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    q.push(<span class="number">5</span>);</span><br><span class="line">    q.push(<span class="number">5</span>);</span><br><span class="line">    q.push(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; q.pop() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; q.pop() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; q.pop() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; q.pop() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/19/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><span class="page-number current">20</span><a class="page-number" href="/page/21/">21</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/21/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/%5Bobject%20Object%5D"
                alt="Jason" />
            
              <p class="site-author-name" itemprop="name">Jason</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20fa%20fa-archive">
              
                  <span class="site-state-item-count">435</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">61</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="true"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
 <!--
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>







-->
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>




















  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v="></script>

  <script type="text/javascript" src="/js/src/motion.js?v="></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v="></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
