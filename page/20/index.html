<!DOCTYPE html>
<html lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jasonxqh.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jason‘s Blog">
<meta property="og:url" content="https://jasonxqh.github.io/page/20/index.html">
<meta property="og:site_name" content="Jason‘s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jasonxqh.github.io/page/20/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jason‘s Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jason‘s Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/10/10/%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/10/%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">评估与选择合适的回归模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-10-10 18:59:40 / Modified: 21:50:58" itemprop="dateCreated datePublished" datetime="2020-10-10T18:59:40+08:00">2020-10-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="选择合适的回归模型"><a href="#选择合适的回归模型" class="headerlink" title="选择合适的回归模型"></a>选择合适的回归模型</h1><p>学习自： <a href="https://blog.csdn.net/zrh_CSDN/article/details/81190001" target="_blank" rel="noopener">https://blog.csdn.net/zrh_CSDN/article/details/81190001</a></p>
<h3 id="R-Squard-Intuition"><a href="#R-Squard-Intuition" class="headerlink" title="R-Squard Intuition"></a>R-Squard Intuition</h3><p>线性回归问题中，R-Squared 是用来衡量回归方程与真实样本输出之间的相似程度。其表达式如下所示：</p>
<p>$R^2 = 1-\frac{\sum(y-\hat y)^2}{\sum(y-\overline y)^2}$ </p>
<p>上式中，分子部分表示真实值与<strong>预测值</strong>的平方差之和，类似于 均方差 MSE；分母部分表示真是值与<strong>均值</strong>的平方差之和，类似于方差Var。</p>
<p><strong>根据 R-Squared 的取值，来判断模型的好坏：如果结果是 0，说明模型拟合效果很差；如果结果是 1，说明模型无错误。</strong></p>
<p>一般来说，R-Squared 越大，表示模型拟合效果越好。<strong>R-Squared 反映的是大概有多准，因为，随着特征数量的增加，R-Square必然增加，无法真正定量说明准确程度，只能大概定量。</strong></p>
<p><strong>单独看 R-Squared，并不能推断出增加的特征是否有意义</strong>。通常来说，增加一个特征，R-Squared 可能变大也可能保持不变，两者不一定呈正相关。</p>
<p><img src="/2020/10/10/%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/1.png" alt></p>
<h3 id="Adjusted-R-Squared"><a href="#Adjusted-R-Squared" class="headerlink" title="Adjusted R-Squared"></a>Adjusted R-Squared</h3><p>对于 $R-Squared$ 来说，如果加入一个新的 Feature，在回归模型下，系统会自动让 $SS<em>{res}$ 趋向于最小。那么如果这个Feature会让整个模型预测准确性下降的话，算法就会让这个Feature的系数趋于0甚至等于0，那么$R-Squared$ 值就不会变化(甚至还可能有轻微的提升);如果这个Feature 会让整个模型的预测准确性上升，那么 $SS</em>{res}$ 会变小，而$R-Squared$ 值就会变大，于是 这个值变成了一个只增不减的，是有一个局限性的。</p>
<p>所以 $R^2$ 并不能很好的让我们判断一个新的变量对整个模型的影响。</p>
<p>如果使用校正决定系数（Adjusted R-Square）：</p>
<p>$R^2_adjust = 1-(1-R^2)\frac{(n-1)}{n-p-1}$  </p>
<p>其中，n是<strong>样本数量</strong>(sample size)，p是<strong>特征数量</strong>(number of regressors)。 </p>
<p>我们看到如果我们一直增加特征数量的话， $\frac{n-1}{n-p-1}$ 就会增大，$(1-R^2)$ 会减小，所以这相当于是对增加样本做了一个补偿。</p>
<p>如果我们现在添加的特征是对整个模型基本没用的，那么 $\frac{n-1}{n-p-1}$ 对 $R^2-adjust$ 的影响就会高于其本身对$R^2$ 的影响，因此 $R^2-adjust$ 会下降。反之，如果这个变量是对整个模型特别有用的，那么其对$R^2$ 的影响就会大于 对$\frac{n-1}{n-p-1}$ 的影响，那么整个 $R^2-adjust$ 就会上升</p>
<p>$R^2-adjust$ 抵消样本数量对 R-Square 的影响，做到了真正的 $0\sim 1$ 越大越好 </p>
<h1 id="选择合适的回归模型-1"><a href="#选择合适的回归模型-1" class="headerlink" title="选择合适的回归模型"></a>选择合适的回归模型</h1><p>接下来我们通过一个实践，利用刚刚学习的$R^2$或者 $R^2-adjust$ 来选择最准确的模型。</p>
<h2 id="Preparation-of-the-Regression-Code"><a href="#Preparation-of-the-Regression-Code" class="headerlink" title="Preparation of the Regression Code"></a>Preparation of the Regression Code</h2><p>我们使用的是一个大约有10000行数据的csv文件，没有缺失数据。数据来自<a href="https://archive.ics.uci.edu/ml/index.php" target="_blank" rel="noopener">https://archive.ics.uci.edu/ml/index.php</a> 这里面有很多适合拿来练习data set。 接下来我会提供现在已经学到的五个模型的代码模板.并分别看看这些模板的准确性</p>
<h3 id="multiple-linear-regression"><a href="#multiple-linear-regression" class="headerlink" title="multiple linear regression"></a>multiple linear regression</h3><h4 id="Importing-the-libraries"><a href="#Importing-the-libraries" class="headerlink" title="Importing the libraries"></a>Importing the libraries</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>
<h4 id="Importing-the-dataset"><a href="#Importing-the-dataset" class="headerlink" title="Importing the dataset"></a>Importing the dataset</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataset = pd.read_csv(<span class="string">'ENTER_THE_NAME_OF_YOUR_DATASET_HERE.csv'</span>)</span><br><span class="line">X = dataset.iloc[:, :<span class="number">-1</span>].values</span><br><span class="line">y = dataset.iloc[:, <span class="number">-1</span>].values</span><br></pre></td></tr></table></figure>
<h4 id="Splitting-the-dataset-into-the-Training-set-and-Test-set"><a href="#Splitting-the-dataset-into-the-Training-set-and-Test-set" class="headerlink" title="Splitting the dataset into the Training set and Test set"></a>Splitting the dataset into the Training set and Test set</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = <span class="number">0.2</span>, random_state = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Training-the-Multiple-Linear-Regression-model-on-the-Training-set"><a href="#Training-the-Multiple-Linear-Regression-model-on-the-Training-set" class="headerlink" title="Training the Multiple Linear Regression model on the Training set"></a>Training the Multiple Linear Regression model on the Training set</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line">regressor = LinearRegression()</span><br><span class="line">regressor.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>
<h4 id="Predicting-the-Test-set-results"><a href="#Predicting-the-Test-set-results" class="headerlink" title="Predicting the Test set results"></a>Predicting the Test set results</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y_pred = regressor.predict(X_test)</span><br><span class="line">np.set_printoptions(precision=<span class="number">2</span>)</span><br><span class="line">print(np.concatenate((y_pred.reshape(len(y_pred),<span class="number">1</span>), y_test.reshape(len(y_test),<span class="number">1</span>)),<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<h4 id="Evaluating-the-Model-Performance"><a href="#Evaluating-the-Model-Performance" class="headerlink" title="Evaluating the Model Performance"></a>Evaluating the Model Performance</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> r2_score</span><br><span class="line">r2_score(y_test, y_pred)</span><br></pre></td></tr></table></figure>
<h3 id="Polynomial-Regression"><a href="#Polynomial-Regression" class="headerlink" title="Polynomial Regression"></a>Polynomial Regression</h3><h4 id="Importing-the-libraries-1"><a href="#Importing-the-libraries-1" class="headerlink" title="Importing the libraries"></a>Importing the libraries</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>
<h4 id="Importing-the-dataset-1"><a href="#Importing-the-dataset-1" class="headerlink" title="Importing the dataset"></a>Importing the dataset</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataset = pd.read_csv(<span class="string">'ENTER_THE_NAME_OF_YOUR_DATASET_HERE.csv'</span>)</span><br><span class="line">X = dataset.iloc[:, :<span class="number">-1</span>].values</span><br><span class="line">y = dataset.iloc[:, <span class="number">-1</span>].values</span><br></pre></td></tr></table></figure>
<h4 id="Splitting-the-dataset-into-the-Training-set-and-Test-set-1"><a href="#Splitting-the-dataset-into-the-Training-set-and-Test-set-1" class="headerlink" title="Splitting the dataset into the Training set and Test set"></a>Splitting the dataset into the Training set and Test set</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = <span class="number">0.2</span>, random_state = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Training-the-Polynomial-Regression-model-on-the-Training-set"><a href="#Training-the-Polynomial-Regression-model-on-the-Training-set" class="headerlink" title="Training the Polynomial Regression model on the Training set"></a>Training the Polynomial Regression model on the Training set</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line">poly_reg = PolynomialFeatures(degree = <span class="number">4</span>)</span><br><span class="line">X_poly = poly_reg.fit_transform(X_train)</span><br><span class="line">regressor = LinearRegression()</span><br><span class="line">regressor.fit(X_poly, y_train)</span><br></pre></td></tr></table></figure>
<h4 id="Predicting-the-Test-set-results-1"><a href="#Predicting-the-Test-set-results-1" class="headerlink" title="Predicting the Test set results"></a>Predicting the Test set results</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y_pred = regressor.predict(poly_reg.transform(X_test))</span><br><span class="line">np.set_printoptions(precision=<span class="number">2</span>)</span><br><span class="line">print(np.concatenate((y_pred.reshape(len(y_pred),<span class="number">1</span>), y_test.reshape(len(y_test),<span class="number">1</span>)),<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<h4 id="Evaluating-the-Model-Performance-1"><a href="#Evaluating-the-Model-Performance-1" class="headerlink" title="Evaluating the Model Performance"></a>Evaluating the Model Performance</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> r2_score</span><br><span class="line">r2_score(y_test, y_pred)</span><br></pre></td></tr></table></figure>
<h3 id="Support-Vector-Regression-SVR"><a href="#Support-Vector-Regression-SVR" class="headerlink" title="Support Vector Regression (SVR)"></a>Support Vector Regression (SVR)</h3><h4 id="Importing-the-libraries-2"><a href="#Importing-the-libraries-2" class="headerlink" title="Importing the libraries"></a>Importing the libraries</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>
<h4 id="Importing-the-dataset-2"><a href="#Importing-the-dataset-2" class="headerlink" title="Importing the dataset"></a>Importing the dataset</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataset = pd.read_csv(<span class="string">'ENTER_THE_NAME_OF_YOUR_DATASET_HERE.csv'</span>)</span><br><span class="line">X = dataset.iloc[:, :<span class="number">-1</span>].values</span><br><span class="line">y = dataset.iloc[:, <span class="number">-1</span>].values</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = y.reshape(len(y),<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Splitting-the-dataset-into-the-Training-set-and-Test-set-2"><a href="#Splitting-the-dataset-into-the-Training-set-and-Test-set-2" class="headerlink" title="Splitting the dataset into the Training set and Test set"></a>Splitting the dataset into the Training set and Test set</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = <span class="number">0.2</span>, random_state = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Feature-Scaling"><a href="#Feature-Scaling" class="headerlink" title="Feature Scaling"></a>Feature Scaling</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">sc_X = StandardScaler()</span><br><span class="line">sc_y = StandardScaler()</span><br><span class="line">X_train = sc_X.fit_transform(X_train)</span><br><span class="line">y_train = sc_y.fit_transform(y_train)</span><br></pre></td></tr></table></figure>
<h4 id="Training-the-SVR-model-on-the-Training-set"><a href="#Training-the-SVR-model-on-the-Training-set" class="headerlink" title="Training the SVR model on the Training set"></a>Training the SVR model on the Training set</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVR</span><br><span class="line">regressor = SVR(kernel = <span class="string">'rbf'</span>)</span><br><span class="line">regressor.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>
<h4 id="Predicting-the-Test-set-results-2"><a href="#Predicting-the-Test-set-results-2" class="headerlink" title="Predicting the Test set results"></a>Predicting the Test set results</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y_pred = sc_y.inverse_transform(regressor.predict(sc_X.transform(X_test)))</span><br><span class="line">np.set_printoptions(precision=<span class="number">2</span>)</span><br><span class="line">print(np.concatenate((y_pred.reshape(len(y_pred),<span class="number">1</span>), y_test.reshape(len(y_test),<span class="number">1</span>)),<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<h4 id="Evaluating-the-Model-Performance-2"><a href="#Evaluating-the-Model-Performance-2" class="headerlink" title="Evaluating the Model Performance"></a>Evaluating the Model Performance</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> r2_score</span><br><span class="line">r2_score(y_test, y_pred)</span><br></pre></td></tr></table></figure>
<h3 id="Decision-Tree-Regression"><a href="#Decision-Tree-Regression" class="headerlink" title="Decision Tree Regression"></a>Decision Tree Regression</h3><h4 id="Importing-the-libraries-3"><a href="#Importing-the-libraries-3" class="headerlink" title="Importing the libraries"></a>Importing the libraries</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>
<h4 id="Importing-the-dataset-3"><a href="#Importing-the-dataset-3" class="headerlink" title="Importing the dataset"></a>Importing the dataset</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataset = pd.read_csv(<span class="string">'ENTER_THE_NAME_OF_YOUR_DATASET_HERE.csv'</span>)</span><br><span class="line">X = dataset.iloc[:, :<span class="number">-1</span>].values</span><br><span class="line">y = dataset.iloc[:, <span class="number">-1</span>].values</span><br></pre></td></tr></table></figure>
<h4 id="Splitting-the-dataset-into-the-Training-set-and-Test-set-3"><a href="#Splitting-the-dataset-into-the-Training-set-and-Test-set-3" class="headerlink" title="Splitting the dataset into the Training set and Test set"></a>Splitting the dataset into the Training set and Test set</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = <span class="number">0.2</span>, random_state = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Training-the-Decision-Tree-Regression-model-on-the-Training-set"><a href="#Training-the-Decision-Tree-Regression-model-on-the-Training-set" class="headerlink" title="Training the Decision Tree Regression model on the Training set"></a>Training the Decision Tree Regression model on the Training set</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor</span><br><span class="line">regressor = DecisionTreeRegressor(random_state = <span class="number">0</span>)</span><br><span class="line">regressor.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>
<h4 id="Predicting-the-Test-set-results-3"><a href="#Predicting-the-Test-set-results-3" class="headerlink" title="Predicting the Test set results"></a>Predicting the Test set results</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y_pred = regressor.predict(X_test)</span><br><span class="line">np.set_printoptions(precision=<span class="number">2</span>)</span><br><span class="line">print(np.concatenate((y_pred.reshape(len(y_pred),<span class="number">1</span>), y_test.reshape(len(y_test),<span class="number">1</span>)),<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<h4 id="Evaluating-the-Model-Performance-3"><a href="#Evaluating-the-Model-Performance-3" class="headerlink" title="Evaluating the Model Performance"></a>Evaluating the Model Performance</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> r2_score</span><br><span class="line">r2_score(y_test, y_pred)</span><br></pre></td></tr></table></figure>
<h3 id="Random-Forest-Regression"><a href="#Random-Forest-Regression" class="headerlink" title="Random Forest Regression"></a>Random Forest Regression</h3><h4 id="Importing-the-libraries-4"><a href="#Importing-the-libraries-4" class="headerlink" title="Importing the libraries"></a>Importing the libraries</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>
<h4 id="Importing-the-dataset-4"><a href="#Importing-the-dataset-4" class="headerlink" title="Importing the dataset"></a>Importing the dataset</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataset = pd.read_csv(<span class="string">'ENTER_THE_NAME_OF_YOUR_DATASET_HERE.csv'</span>)</span><br><span class="line">X = dataset.iloc[:, :<span class="number">-1</span>].values</span><br><span class="line">y = dataset.iloc[:, <span class="number">-1</span>].values</span><br></pre></td></tr></table></figure>
<h4 id="Splitting-the-dataset-into-the-Training-set-and-Test-set-4"><a href="#Splitting-the-dataset-into-the-Training-set-and-Test-set-4" class="headerlink" title="Splitting the dataset into the Training set and Test set"></a>Splitting the dataset into the Training set and Test set</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = <span class="number">0.2</span>, random_state = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Training-the-Random-Forest-Regression-model-on-the-whole-dataset"><a href="#Training-the-Random-Forest-Regression-model-on-the-whole-dataset" class="headerlink" title="Training the Random Forest Regression model on the whole dataset"></a>Training the Random Forest Regression model on the whole dataset</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor</span><br><span class="line">regressor = RandomForestRegressor(n_estimators = <span class="number">10</span>, random_state = <span class="number">0</span>)</span><br><span class="line">regressor.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>
<h4 id="Predicting-the-Test-set-results-4"><a href="#Predicting-the-Test-set-results-4" class="headerlink" title="Predicting the Test set results"></a>Predicting the Test set results</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y_pred = regressor.predict(X_test)</span><br><span class="line">np.set_printoptions(precision=<span class="number">2</span>)</span><br><span class="line">print(np.concatenate((y_pred.reshape(len(y_pred),<span class="number">1</span>), y_test.reshape(len(y_test),<span class="number">1</span>)),<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<h4 id="Evaluating-the-Model-Performance-4"><a href="#Evaluating-the-Model-Performance-4" class="headerlink" title="Evaluating the Model Performance"></a>Evaluating the Model Performance</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> r2_score</span><br><span class="line">r2_score(y_test, y_pred)</span><br></pre></td></tr></table></figure>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>我们接下来就对上面的模型进行跑分：</p>
<ul>
<li>Multiple Linear Regression : 0.9325315554761303</li>
<li>Polynomial Regression :  0.945819297903489</li>
<li>Support Vector Regression(SVR) : 0.9480784049986258</li>
<li><p>Decision Tree Regression : 0.9226091050550043</p>
</li>
<li><p>Random Forest :  0.9615980699813017</p>
</li>
</ul>
<p>综上我们得到，Random Forest 随机森林模型对这个数据集的预测准确性在五个模型中分数最高，是最适合的回归模型。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/10/09/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%9B%9E%E5%BD%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/09/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%9B%9E%E5%BD%92/" class="post-title-link" itemprop="url">决策树和随机森林回归</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-09 23:16:25" itemprop="dateCreated datePublished" datetime="2020-10-09T23:16:25+08:00">2020-10-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-11 15:51:32" itemprop="dateModified" datetime="2020-10-11T15:51:32+08:00">2020-10-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="决策树和随机森林回归"><a href="#决策树和随机森林回归" class="headerlink" title="决策树和随机森林回归"></a>决策树和随机森林回归</h1><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p><a href="https://www.jianshu.com/p/fcbbd8f2acd5" target="_blank" rel="noopener">https://www.jianshu.com/p/fcbbd8f2acd5</a></p>
<p>首先我们来了解一下CART(Classification And Regression Tree) 的定义。它被分为两类：分类决策树(Classification Trees) 和 回归决策树 (Regression Trees). 这也是我们要用决策树解决的两类问题：分类问题和回归问题。</p>
<p><img src="/2020/10/09/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%9B%9E%E5%BD%92/1.png" style="zoom:80%;"></p>
<p>对于分类决策树，一般来说用于一些分类离散的数据，比如说人的性别是男或者女，水果的种类有苹果梨子等等都是离散的。反之回归决策树，那么对应的场景就是连续的数据，比如人的年龄或者室外的温度。当我们进行分类问题时，分类的组之间是无序的。这里首先介绍下什么是有序，可以举个例子比如年龄，又年龄大或者年龄小。那么对于性别问题，男或女，它是没有顺序的</p>
<p>对于下面这幅散点图，我们要通过其来预测一个第三个维度的独立变量y，我们在二维平面中没有办法看到</p>
<p><img src="/2020/10/09/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%9B%9E%E5%BD%92/2.png" style="zoom:80%;"></p>
<p>如果将其放到一个三维空间里，那么我们就可以将这个y变量显示出来。</p>
<p><img src="/2020/10/09/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%9B%9E%E5%BD%92/3.png" style="zoom:80%;"></p>
<p>当我们运行回归树/决策树模型的时候，上面的散点图就会被分成几个部分,就向下图一样。算法会计算信息熵并决定在那里执行划分，将这些散点分组。那么怎么停止呢？比如说当算法增加一个splits，有一个组(leaves)中的数据低于所有数据的5%，那么这个splits就不会被划分。</p>
<p><img src="/2020/10/09/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%9B%9E%E5%BD%92/4.png" style="zoom:80%;"></p>
<p>现在我们还原创建决策树的过程：</p>
<ul>
<li>首先在 $x_1 = 20$  处画一条分割线，那么决策树的第一个分支就是判断 $x_1$ 是否小于20，并分成2类。</li>
</ul>
<p><img src="/2020/10/09/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%9B%9E%E5%BD%92/5.png" style="zoom:80%;"></p>
<ul>
<li>然后我们在$x_2=170,x_1&gt;20$ 处画一条分割线，那么决策树在右孩子会生成第二个分支，判断 $x_2$ 是否大于170</li>
</ul>
<p><img src="/2020/10/09/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%9B%9E%E5%BD%92/6.png" style="zoom:80%;"></p>
<ul>
<li>接着我们在 $x_2=200,x_1&lt;20$ 画一条 分割线</li>
</ul>
<p><img src="/2020/10/09/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%9B%9E%E5%BD%92/7.png" style="zoom:80%;"></p>
<ul>
<li>最后我们在$x_1=40,x_2&lt;170$ 出画一条分割线，我们可以继续拓展一个分支。</li>
</ul>
<p><img src="/2020/10/09/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%9B%9E%E5%BD%92/8.png" style="zoom:80%;"></p>
<p>现在，我们分隔好了区域，我们怎么对一个新的数据进行预测呢？</p>
<p>其实很简单，我们把每个区域每一个散点的y值加起来求平均后，再赋值给新的、需要被预测的值。</p>
<p><img src="/2020/10/09/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%9B%9E%E5%BD%92/9.png" style="zoom:80%;"></p>
<p>现在我们已经求出了各个区域中y的平均值，现在来一个点(30,50) ，我们可以看到这个点落在中下区域，这个区域的平均值是 -64.1 那么这个我们预测(30,50) 这一个点的y值就是 -64.1</p>
<p>最后我们补全我们的决策树：</p>
<p><img src="/2020/10/09/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%9B%9E%E5%BD%92/10.png" style="zoom:80%;"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>首先还是进行数据集导入、分割</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">dataset = pd.read_csv(<span class="string">'Position_Salaries.csv'</span>)</span><br><span class="line">X = dataset.iloc[:, <span class="number">1</span>:<span class="number">-1</span>].values</span><br><span class="line">y = dataset.iloc[:, <span class="number">-1</span>].values</span><br></pre></td></tr></table></figure>
<p>然后我们训练决策树模型：</p>
<p>对于决策树模型的参数选择和设置，先不要过于纠结。对所有的机器学习模型有了一个认知和比较之后我们再来谈论参数。在这里我们设置 random_state 参数= 0。这个问题是因为，学习一个最优决策树是一个NP问题。 所以实际应用中，生成决策树是基于启发式算法的，比如贪婪算法，贪婪算法可以在每个节点进行局部最优点求解，但它无法保证返回全局最优解。不论是random forest还是decision tree，贪婪算法会随机且多次抽取<strong>部分</strong>特征和样本，这个随机抽取过程可以通过random_state来决定。让他等于零的意思是让每次建立出来的决策树都是一样的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor</span><br><span class="line">regressor = DecisionTreeRegressor(random_state = <span class="number">0</span>)</span><br><span class="line">regressor.fit(X, y)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/09/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%9B%9E%E5%BD%92/11.png" style="zoom:80%;"></p>
<p>我们可以用训练出来的模型预测新的数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regressor.predict([[<span class="number">6.5</span>]])</span><br></pre></td></tr></table></figure>
<p>打印得到： array([150000.])</p>
<p>如果我们要预测两个数据，我们可以这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regressor.predict([[<span class="number">1</span>],[<span class="number">2</span>]])</span><br></pre></td></tr></table></figure>
<p>我们可以这样理解，6.5经过了层层决策最后落到了一个区域，这个区域只有 Level=6这一个数据，那么这个数据的平均值 150000 就赋值给了6.5</p>
<p>最后进行一个可视化操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">X_grid = np.arange(min(X), max(X), <span class="number">0.01</span>)</span><br><span class="line">X_grid = X_grid.reshape((len(X_grid), <span class="number">1</span>))</span><br><span class="line">plt.scatter(X, y, color = <span class="string">'red'</span>)</span><br><span class="line">plt.plot(X_grid, regressor.predict(X_grid), color = <span class="string">'blue'</span>)</span><br><span class="line">plt.title(<span class="string">'Truth or Bluff (Decision Tree Regression)'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Position level'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Salary'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/09/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%9B%9E%E5%BD%92/12.png" style="zoom:100%;"></p>
<p>我们看到这个模型被训练成随机森林之后，因为数据量不足够，所以回归曲线呈现阶梯状。也就是说在一定范围内的所有的数都会被预测成相同的值。</p>
<h2 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h2><p>我们首先来了解一下 Ensemble Learning (集成学习)的概念。 Ensemble Learning 通俗的来说就是用多种算法或者一种算法运行多次来解决一个问题</p>
<p>那么随机森林的步骤可以概括如下：</p>
<ul>
<li><p>STEP1: Pick at random K data points from the Training set </p>
</li>
<li><p>SETP2: Build the Decision Tree associated to these K data points </p>
<ul>
<li>和决策树不同，决策树将所有的数据拿来建树而随机森林是从中选取K个数据来建树</li>
</ul>
</li>
<li><p>STEP3： Choose the number Ntree of trees you want to build and repeat STEPs 1&amp;2</p>
<ul>
<li>然后我们只要选择要建的树，重复步骤1和2就可以了</li>
</ul>
</li>
<li>STEP4: For a new data point,make each one of your Ntree trees predict the value of Y to for the data point in question,and assign the new data point the average across all of the predicted Y values<ul>
<li>对于预测的新数据，我们将其放到每一棵树里面去，分别对其预测，最后对这些预测值取平均，就得到了最终的预测值</li>
</ul>
</li>
</ul>
<p>这也是随机森林之所以叫做森林的原因了，因为我们创建了很多很多树。和决策树相比，随机森林模型会增加预测的准确性，因为我们对所有的预测值取了一个平均数。  </p>
<p>此外，随机森林相对于决策树更加稳定，因为他是一个集成算法</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>代码和决策树的差不多，但是实际效果要比决策树更好一些</p>
<p>前期准备是一模一样的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">dataset = pd.read_csv(<span class="string">'Position_Salaries.csv'</span>)</span><br><span class="line">X = dataset.iloc[:, <span class="number">1</span>:<span class="number">-1</span>].values</span><br><span class="line">y = dataset.iloc[:, <span class="number">-1</span>].values</span><br></pre></td></tr></table></figure>
<p>然后 我们从 sklearn.ensemble 中导入 RandomForestRegressor 这个类</p>
<p>n_estimators 就代表我要建几棵树</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor</span><br><span class="line">regressor = RandomForestRegressor(n_estimators = <span class="number">10</span>, random_state = <span class="number">0</span>)</span><br><span class="line">regressor.fit(X, y)</span><br></pre></td></tr></table></figure>
<p>最后我们讲建立好的模型贴出，我们可以对比一下随机森林和决策树有哪些不同</p>
<p><img src="/2020/10/09/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%9B%9E%E5%BD%92/13.png" style="zoom:100%;"></p>
<p><img src="/2020/10/09/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%9B%9E%E5%BD%92/12.png" style="zoom:100%;"></p>
<p>明显可以看到随机森林相对于决策树来说更准确，阶梯更多了</p>
<p>我们现在的重点是了解概念和初步时间，像这样一个简单的预测虽然在现实生活中是几乎不可能遇到的，但是能让我们更好的了解一些模型和对应建立模型的步骤。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/10/07/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E5%9B%9E%E5%BD%92%EF%BC%88SVR%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/07/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E5%9B%9E%E5%BD%92%EF%BC%88SVR%EF%BC%89/" class="post-title-link" itemprop="url">支持向量回归（SVR）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-07 18:08:16" itemprop="dateCreated datePublished" datetime="2020-10-07T18:08:16+08:00">2020-10-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-09 23:14:16" itemprop="dateModified" datetime="2020-10-09T23:14:16+08:00">2020-10-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="支持向量回归（SVR）"><a href="#支持向量回归（SVR）" class="headerlink" title="支持向量回归（SVR）"></a>支持向量回归（SVR）</h1><p><img src="/2020/10/07/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E5%9B%9E%E5%BD%92%EF%BC%88SVR%EF%BC%89/1.png" style="zoom:80%;"></p>
<p>左图是Linear Regression的 ,右边是svr 的loss function，右图中，$\epsilon-$ Insensitive tube描述的是黄色管道，$\epsilon$ 是管道边界到管道中心的垂直距离。我们定义这个区域内的点<strong>损失为0</strong>，这个区域以外的点的损失是点到区域边界的距离，这些区域外的点（或者有可能边界上的点）就是svr 的support vector。之所以这么称呼是因为这些点决定了我们划定的tube是否是合理的，这些点左右了tube的结构。 所以大致上来说，<strong>svr就是要找一条线，忽略它周围的点，对剩余的点进行回归</strong>。而对于Linear Regression来说，则是对每一个点都进行回归</p>
<p>Linear Regression 的计算公式是 $SUM(y-\hat y )^2 \rightarrow min$ </p>
<p>SVR 的计算公式则比较复杂， $\frac{1}{2}||w||^2+c\sum_{i=1}^{m}(\xi_i+\xi_i^*)\rightarrow min$  </p>
<p>补充资料： <a href="https://core.ac.uk/download/pdf/81523322.pdf" target="_blank" rel="noopener">https://core.ac.uk/download/pdf/81523322.pdf</a> </p>
<p>上面我们看到的是线性的支持向量回归，但是我们在接下来的例子中，却看到训练出来的模型是非线性的，这是因为我们使用了 Radial basis function kernel (<strong>径向基</strong>核函数)</p>
<p>我们可以先看看non-Linear SVR 长什么样</p>
<p><img src="/2020/10/07/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E5%9B%9E%E5%BD%92%EF%BC%88SVR%EF%BC%89/2.png" style="zoom:80%;"></p>
<p>可以看到它们长得还是非常不一样的。要了解non-Linear SVR,还是需要用到为学习过的许多知识</p>
<ul>
<li>Section on SVM:<ul>
<li>SVM Intuition</li>
</ul>
</li>
<li>Section on Kernel SVM:<ul>
<li>Kernel SVM Intuition</li>
<li>Mapping to a higher dimension</li>
<li>The kernel Trick</li>
<li>Types of Kernel Functions</li>
<li>Non-Linear Kernel SVR</li>
</ul>
</li>
</ul>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>这次我们使用的仍然是员工阶级和薪资的数据集。我们在进行试验的时候会遇到 Feature scaling (特征缩放) </p>
<p>在运用一些机器学习算法的时候不可避免地要对数据进行特征缩放（feature scaling），特征缩放可以使机器学习算法工作的更好。  如果某一列的值与其他列相比非常高，则具有更高值的列的影响将比其他低值列的影响高得多。 高强度的特征比低强度的特征重得多，即使它们在确定输出中更为关键。 因此，预测可能无法给出预期的结果，并且可能无法满足业务用例。</p>
<p>总而言之，功能缩放是必需的，因为：</p>
<ol>
<li>回归系数直接受特征范围的影响</li>
<li>具有较高比例的功能比具有较低比例的功能更重要</li>
<li>如果我们具有缩放值，则可以轻松实现渐变下降</li>
<li>如果按比例缩放，某些算法将减少执行时间。</li>
<li>一些算法基于欧几里得距离，欧几里得距离对特征尺度非常敏感。</li>
</ol>
<p>对于SVR来说，这是一个关于因变量的隐式函数，因此我们需要将数据进行特征缩放，来将员工的年龄和他的收入放到一个scale下进行建模。</p>
<p>对于简单线性、多项式线性回归，我们不需要利用特征缩放，因为可以找到能将高值和低值特征对应起来的系数。但是对于其他模型来说，在自变量x和应变量y之间他是找不到这样一个系数来对应的。这时候我们就会使用特征缩放。</p>
<p>另外，概率模型（树形模型）不需要归一化，因为它们不关心变量的值，而是关心变量的分布和变量之间的条件概率，如决策树、RF。而像Adaboost、SVM、LR、Knn、KMeans之类的最优化问题就需要归一化。</p>
<ul>
<li>当使用dummy variable的时候，没有必要再对其使用特征缩放了，因为本来就两个值0和1</li>
<li>当因变量的值是0或者1的时候，也没有必要对其使用特征缩放了</li>
</ul>
<h3 id="Processing-the-dataset"><a href="#Processing-the-dataset" class="headerlink" title="Processing the dataset"></a>Processing the dataset</h3><p>那么我们现在来看数据集</p>
<p><img src="/2020/10/07/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E5%9B%9E%E5%BD%92%EF%BC%88SVR%EF%BC%89/3.png" style="zoom:100%;"></p>
<p>因变量从1到10，Salary从4500-1000000，它们之间的差距实在是太大了。这还会导致一些数据被误认成偏离值而被模型忽略。如果不进行特征缩放的话，那么SVR将完全不会起作用。所以我们要把自变量和因变量缩放到一个唯独下进行建模。</p>
<p>在特征缩放之前，我们首先将自变量和因变量分离：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataset = pd.read_csv(<span class="string">'Position_Salaries.csv'</span>)</span><br><span class="line">X = dataset.iloc[:, <span class="number">1</span>:<span class="number">-1</span>].values</span><br><span class="line">y = dataset.iloc[:, <span class="number">-1</span>].values</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/07/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E5%9B%9E%E5%BD%92%EF%BC%88SVR%EF%BC%89/4.png" style="zoom:80%;"></p>
<p>但是现在我们看到数组y实际上是一个一维数组，我们需要将其变成二维数组。这是因为 StandardScaler在进行特征缩放的时候只接收二维数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = y.reshape(len(y),<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>运用reshape函数，可以进行这样的转换，其中第一个参数是行数，第二个参数是列数。</p>
<p><img src="/2020/10/07/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E5%9B%9E%E5%BD%92%EF%BC%88SVR%EF%BC%89/5.png" style="zoom:120%;"></p>
<h3 id="Feature-Scaling"><a href="#Feature-Scaling" class="headerlink" title="Feature Scaling"></a>Feature Scaling</h3><p>现在我们进行特征缩放</p>
<p>StandardScaler原理: 去均值和方差归一化。且是针对每一个特征维度来做的，而不是针对样本。 </p>
<p>标准差标准化（standardScale）使得经过处理的数据符合标准正态分布，即均值为0，标准差为1，其转化函数为：$x^* = \frac{x-\mu}{\sigma}$ ,其中 $\mu$ 为所有样本数据的均值， $\sigma$ 为所有样本数据的标准差</p>
<p>我们要注意，自变量和应变量应该选择不同的 StandardScaler，这是因为每列数据的均值和标准差都是不一样的</p>
<p><img src="/2020/10/07/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E5%9B%9E%E5%BD%92%EF%BC%88SVR%EF%BC%89/6.png" style="zoom:120%;"></p>
<h3 id="Training-the-SVR-model-on-the-whole-dataset"><a href="#Training-the-SVR-model-on-the-whole-dataset" class="headerlink" title="Training the SVR model on the whole dataset"></a>Training the SVR model on the whole dataset</h3><p>在训练SVR模型之前我们要了解核函数的概念。</p>
<p>对于<strong>线性不可分</strong>的数据集，可以利用<strong>核函数（kernel）</strong>将数据转换成易于分类器理解的形式。</p>
<p>如下图，如果在x轴和y轴构成的坐标系中插入直线进行分类的话， 不能得到理想的结果，或许我们可以对圆中的数据进行某种形式的转换，从而得到某些新的变量来表示数据。在这种表示情况下，我们就更容易得到大于0或者小于0的测试结果。在这个例子中，我们将数据从一个特征空间转换到另一个特征空间，在新的空间下，我们可以很容易利用已有的工具对数据进行处理，将这个过程称之为<strong>从一个特征空间到另一个特征空间的映射</strong>。在通常情况下，这种映射会<strong>将低维特征空间映射到高维空间</strong>。比如将二维空间映射到一个合适的三维空间，那么就能找到一个合适的划分超平面来分离。如果原始空间是有限维，即属性数有限，那么一定存在一个高维特征空间使样本可分。这种从某个特征空间到另一个特征空间的映射是通过核函数来实现的。</p>
<p><a href="https://www.jianshu.com/p/95e56d5126fd" target="_blank" rel="noopener">https://www.jianshu.com/p/95e56d5126fd</a></p>
<p><img src="/2020/10/07/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E5%9B%9E%E5%BD%92%EF%BC%88SVR%EF%BC%89/7.png" style="zoom:120%;"></p>
<p>径向基核函数是SVM中常用的一个<strong>核函数</strong>。<strong>径向基函数</strong>是一个<strong>采用向量作为自变量的函数</strong>，能够<strong>基于向量距离运算</strong>输出一个<strong>标量</strong>。</p>
<p>在python当中，我们从 svm中导入SVR并将其kernel参数设置为 rbf，然后再对X，y进行训练</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVR</span><br><span class="line">regressor = SVR(kernel= <span class="string">'rbf'</span>)</span><br><span class="line">regressor.fit(X,y)</span><br></pre></td></tr></table></figure>
<h3 id="Predicting-a-new-result"><a href="#Predicting-a-new-result" class="headerlink" title="Predicting a new result"></a>Predicting a new result</h3><p>现在我们通过训练好的模型来进行预测。注意了，我们传入的数据是特征放缩后的数据，我们预测出来的是特征放缩之后的结果，我们还需要用放缩尺将其还原成原来的数据</p>
<p>比如说我们要预测6.5级的员工薪水，传入一个二维数组(尽管只有一个数)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regressor.predict(sc_X.transform([[<span class="number">6.5</span>]]))</span><br></pre></td></tr></table></figure>
<p>这样返回的是在sc_y 标尺下的 薪水，打印出来得到：array([0.01150915])</p>
<p>接下来我们要做的就是将这个预测出来的数据还原回去,我们可以用 inverse_transform 来进行还原。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc_y.inverse_transform(regressor.predict(sc_X.transform([[<span class="number">6.5</span>]])))</span><br></pre></td></tr></table></figure>
<p>打印出来的数据是： array([170370.0204065])</p>
<h3 id="Visualizing-the-SVR-results"><a href="#Visualizing-the-SVR-results" class="headerlink" title="Visualizing the SVR results"></a>Visualizing the SVR results</h3><p>现在我们将SVR模型预测的结果画出来。</p>
<p>注意，这时候的X,y 是缩放后的，我们需要用 inverse_transform 来将其还原。因为x已经是二维数组了，我们就直接 regressor.predict(x) 即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(sc_X.inverse_transform(X), sc_y.inverse_transform(y), color = <span class="string">'red'</span>)</span><br><span class="line">plt.plot(sc_X.inverse_transform(X), sc_y.inverse_transform(regressor.predict(X)), color = <span class="string">'blue'</span>)</span><br><span class="line">plt.title(<span class="string">'Truth or Bluff (SVR)'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Position level'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Salary'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/07/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E5%9B%9E%E5%BD%92%EF%BC%88SVR%EF%BC%89/8.png"></p>
<h4 id="for-higher-resolution-and-smoother-curve"><a href="#for-higher-resolution-and-smoother-curve" class="headerlink" title="for higher resolution and smoother curve"></a>for higher resolution and smoother curve</h4><p>我们将预测出来的曲线变得更加光滑：</p>
<p>原理就是将1-10 从原来的间隔1到现在的间隔0.1 ，然后再将其变成一个新的二维数组进行预测画图。这样曲线就会变得更加光滑。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">X_grid = np.arange(min(sc_X.inverse_transform(X)), max(sc_X.inverse_transform(X)), <span class="number">0.1</span>)</span><br><span class="line">X_grid = X_grid.reshape((len(X_grid), <span class="number">1</span>))</span><br><span class="line">plt.scatter(sc_X.inverse_transform(X), sc_y.inverse_transform(y), color = <span class="string">'red'</span>)</span><br><span class="line">plt.plot(X_grid,</span><br><span class="line">         sc_y.inverse_transform(regressor.predict(sc_X.transform(X_grid))), color = <span class="string">'blue'</span>)</span><br><span class="line">plt.title(<span class="string">'Truth or Bluff (SVR)'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Position level'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Salary'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/07/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E5%9B%9E%E5%BD%92%EF%BC%88SVR%EF%BC%89/9.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/09/30/git%E5%9F%BA%E7%A1%803/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/30/git%E5%9F%BA%E7%A1%803/" class="post-title-link" itemprop="url">git基础3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-30 16:56:17" itemprop="dateCreated datePublished" datetime="2020-09-30T16:56:17+08:00">2020-09-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-05 20:01:46" itemprop="dateModified" datetime="2022-07-05T20:01:46+08:00">2022-07-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="git-基础3"><a href="#git-基础3" class="headerlink" title="git 基础3"></a>git 基础3</h1><h2 id="Collaboration-合作"><a href="#Collaboration-合作" class="headerlink" title="Collaboration 合作"></a>Collaboration 合作</h2><ul>
<li>Collaboration workflows</li>
<li>Pushing,fetching and pulling</li>
<li>Pull requests,issues and milestones</li>
<li>Contributing to open-source projects</li>
</ul>
<h3 id="Workflows"><a href="#Workflows" class="headerlink" title="Workflows"></a>Workflows</h3><h4 id="Centralized-Workflow"><a href="#Centralized-Workflow" class="headerlink" title="Centralized Workflow"></a>Centralized Workflow</h4><p>示意图如下：</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/1.png" style="zoom:80%;"></p>
<p>当John想要给Amy传代码的时候，他首先会将文件push到云上的repository，Amy看见之后，会从云上拉去John的代码到本地进行浏览或者修改。如果John和Amy的代码冲突了，那么Amy经过修改之后再将代码Push到云上。在大多数小团队中，都用这种工作流。</p>
<h4 id="Intergration-Manager"><a href="#Intergration-Manager" class="headerlink" title="Intergration-Manager"></a>Intergration-Manager</h4><p>对于一些开源项目，有很多contributors，他们的代码并不是完全安全的，所以它们递交的代码并不能直接放到云里。</p>
<p>当有一个contributor想要commit的时候，会从云上的repository中Fork一个新的Repository，然后再从这个新的Repository 中克隆代码。当修改完成递交后，也是递交到这个新的Repository</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/2.png" style="zoom:80%;"></p>
<p>然后，Contributor会给Maintainer发一个Pull request.当Maintainer收到请求之后，会从新的Repository中拉取Contributor修改后的代码，检查是合格。如果合格，他们就会将代码Push到原本的云端上去</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/3.png" style="zoom:80%;"></p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/25.jpg" style="zoom:80%;"></p>
<h3 id="Adding-Collaborators"><a href="#Adding-Collaborators" class="headerlink" title="Adding Collaborators"></a>Adding Collaborators</h3><p>自我们创建了新的Repository 之后，只有我一个人拥有push的权限。我们可以点击绿色的 Invite a collaborator 来给我们伙伴push的权限。</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/4.png" style="zoom:80%;"></p>
<h3 id="Fetching"><a href="#Fetching" class="headerlink" title="Fetching"></a>Fetching</h3><p>因为我们不能时刻和云上的repository保持同步，那么当云上的repository出现了新的commit的时候，本地暂时还没有，我们可以用 <code>git fetch</code> 命令将本地repository与云上的repository保持同步。 </p>
<p>但是当我们同步之后，我们本地的状态是这样的：</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/5.png" style="zoom:80%;"></p>
<p>也就是说现在有两个Master指针，一个是云上的Master指针。我们可以用 <code>git merge origin/master</code> 来将两个指针合并。</p>
<p>我们 <code>git fetch</code> 之后，发现 本地的master和origin/master指向的commit是不同的。</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/6.png" style="zoom:80%;"></p>
<p>然后我们用 <code>git merge origin/master</code> 将两个master指针合并</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/7.png" style="zoom:80%;"></p>
<p>结果如下</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/8.png" style="zoom:80%;"></p>
<h3 id="Pulling"><a href="#Pulling" class="headerlink" title="Pulling"></a>Pulling</h3><ul>
<li><strong>Pull = fetch + merge </strong></li>
</ul>
<p>git pull 命令，默认会使用 Three-Way Merge, 但是我们可以通过 git pull —rebase 把merge形式换成rebase</p>
<p>如果本地有一个commit B,云上有一个commit C，那么运行git pull 之后，在本地的 A之后又会跟上commit C，这时候出现了分支。然后再进行Three-Way Merge合并到一起。</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/9.png" style="zoom:80%;"></p>
<ul>
<li>git pull -rebase</li>
</ul>
<p>git pull -rebase 就是<strong>将 本地的MASTER移动到云端 origin/MASTER 之后</strong></p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/10.png" style="zoom:80%;"></p>
<p>我们在github上对readme文件进行一下修改，然后在本地使用rebase操作</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/11.png" style="zoom:140%;"></p>
<p>直接 <code>git pull</code> 之后，我们得到的 log 信息如下：</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/12.png" style="zoom:120%;"></p>
<p><code>git pull --rebase</code> 之后，log 信息如下：</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/13.png" style="zoom:140%;"></p>
<h3 id="Pushing"><a href="#Pushing" class="headerlink" title="Pushing"></a>Pushing</h3><p>一般我们利用 <code>git push</code> 就可以将本地的commit推送到云端去。但是遇到这种情况该怎么办？</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/14.png" style="zoom:100%;"></p>
<p>这里在确定之前，千万别用 <code>git push -f</code> 因为这个命令会让本地的 C commit 覆盖掉云端上的 D commit，这可能会酿成大祸。</p>
<p>所以遇到本地和云端当前的状态不一样的时候，最好的方法就是先将云端的D commit pull下来，和本地的C commit 合并，然后再用 <code>git push</code> 推送上去，最后的结果如下图：</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/15.png" style="zoom:100%;"></p>
<h3 id="Sharing-Tags"><a href="#Sharing-Tags" class="headerlink" title="Sharing Tags"></a>Sharing Tags</h3><p>在本地创建一个 tag  <code>git tag 1.0</code> </p>
<p>在本地删除一个tag <code>git tag -d v1.0</code></p>
<p>将tag push到云端去：<code>git push origin v1.0</code></p>
<p>将tag 从云端中删除： <code>git push origin --delete v1.0</code> </p>
<h3 id="Releases"><a href="#Releases" class="headerlink" title="Releases"></a>Releases</h3><p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/16.png" style="zoom:100%;"></p>
<p>如果这个版本只是先行版、测试版，可以在下面勾选 This is a pre-release </p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/17.png" style="zoom:100%;"></p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/18.png" style="zoom:100%;"></p>
<p>Release 不是git的特性，而是github特有的，比tag的层级更高</p>
<h3 id="Sharing-Branches"><a href="#Sharing-Branches" class="headerlink" title="Sharing Branches"></a>Sharing Branches</h3><p>如果我们要和其他队友在分支上进行合作，那么就要对分支进行分享。</p>
<p>首先我们新建一个分支：<code>git switch -C feature/change-password</code></p>
<p>然后我么用 <code>git push -u origin feature/change-password</code> 将这个分支push到云上。</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/20.png" style="zoom:100%;"></p>
<p>我们可以用 <code>git push -d origin feature/change-password</code> 将分支删除。</p>
<p>使用 <code>git -vv</code> 就能够看到本地分支跟踪的远程分支。</p>
<p>左边的是本地的分支，右边蓝色的的是远程的分支。在没有push上去之前，我们发现 本地有 feature/change-password 分支但远程没有</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/21.png" style="zoom:100%;"></p>
<p>在git push之后我们发现本地分支追踪到了远程的分支。</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/22.png" style="zoom:100%;"></p>
<p>使用 <code>git branch -r</code> 能看到远程所有的分支：</p>
<p>在没有push上去之间，云端只有HEAD和main</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/23.png" style="zoom:110%;"></p>
<p>在push 上去之后，云端有了一个新的 feature/change-password</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/24.png" style="zoom:100%;"></p>
<h3 id="Collaboration-Workflow"><a href="#Collaboration-Workflow" class="headerlink" title="Collaboration Workflow"></a>Collaboration Workflow</h3><h3 id="Pull-Requests"><a href="#Pull-Requests" class="headerlink" title="Pull Requests"></a>Pull Requests</h3><h3 id="Resolving-Conflicts"><a href="#Resolving-Conflicts" class="headerlink" title="Resolving Conflicts"></a>Resolving Conflicts</h3><h3 id="Issues"><a href="#Issues" class="headerlink" title="Issues"></a>Issues</h3><h3 id="Labels"><a href="#Labels" class="headerlink" title="Labels"></a>Labels</h3><h3 id="Milestones"><a href="#Milestones" class="headerlink" title="Milestones"></a>Milestones</h3><h3 id="Contributing-to-Open-source-Projects"><a href="#Contributing-to-Open-source-Projects" class="headerlink" title="Contributing to Open-source Projects"></a>Contributing to Open-source Projects</h3><h3 id="Keeping-a-Forked-Repository-Up-to-Date"><a href="#Keeping-a-Forked-Repository-Up-to-Date" class="headerlink" title="Keeping a Forked Repository Up to Date"></a>Keeping a Forked Repository Up to Date</h3><h3 id="Collaboration-Using-VSCode"><a href="#Collaboration-Using-VSCode" class="headerlink" title="Collaboration Using VSCode"></a>Collaboration Using VSCode</h3><h3 id="Collaboration-Using-GitKraken"><a href="#Collaboration-Using-GitKraken" class="headerlink" title="Collaboration Using GitKraken"></a>Collaboration Using GitKraken</h3><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><h3 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h3><h2 id="Rewriting-History"><a href="#Rewriting-History" class="headerlink" title="Rewriting History"></a>Rewriting History</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><h3 id="Why-Rewrite-History"><a href="#Why-Rewrite-History" class="headerlink" title="Why Rewrite History"></a>Why Rewrite History</h3><h3 id="The-Golden-Rule-of-Rewriting-History"><a href="#The-Golden-Rule-of-Rewriting-History" class="headerlink" title="The Golden Rule of Rewriting History"></a>The Golden Rule of Rewriting History</h3><h3 id="Example-of-a-Bad-History"><a href="#Example-of-a-Bad-History" class="headerlink" title="Example of a Bad History"></a>Example of a Bad History</h3><h3 id="Undoing-Commits"><a href="#Undoing-Commits" class="headerlink" title="Undoing Commits"></a>Undoing Commits</h3><h3 id="Reverting-Commits"><a href="#Reverting-Commits" class="headerlink" title="Reverting Commits"></a>Reverting Commits</h3><h3 id="Recovering-Lost-Commits"><a href="#Recovering-Lost-Commits" class="headerlink" title="Recovering Lost Commits"></a>Recovering Lost Commits</h3><h3 id="Amending-the-Last-Commit"><a href="#Amending-the-Last-Commit" class="headerlink" title="Amending the Last Commit"></a>Amending the Last Commit</h3><h3 id="Amending-an-Earlier-Commit"><a href="#Amending-an-Earlier-Commit" class="headerlink" title="Amending an Earlier Commit"></a>Amending an Earlier Commit</h3><h3 id="Dropping-Commits"><a href="#Dropping-Commits" class="headerlink" title="Dropping Commits"></a>Dropping Commits</h3><h3 id="Rewording-Commit-Messages"><a href="#Rewording-Commit-Messages" class="headerlink" title="Rewording Commit Messages"></a>Rewording Commit Messages</h3><h3 id="Reordering-Commits"><a href="#Reordering-Commits" class="headerlink" title="Reordering Commits"></a>Reordering Commits</h3><h3 id="Squashing-Commits"><a href="#Squashing-Commits" class="headerlink" title="Squashing Commits"></a>Squashing Commits</h3><h3 id="Splitting-a-Commit"><a href="#Splitting-a-Commit" class="headerlink" title="Splitting a Commit"></a>Splitting a Commit</h3><h3 id="Rewriting-History-Using-GitKraken"><a href="#Rewriting-History-Using-GitKraken" class="headerlink" title="Rewriting History Using GitKraken"></a>Rewriting History Using GitKraken</h3><h3 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/09/27/git%E5%AD%A6%E4%B9%A02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/27/git%E5%AD%A6%E4%B9%A02/" class="post-title-link" itemprop="url">git学习2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-27 13:04:51" itemprop="dateCreated datePublished" datetime="2020-09-27T13:04:51+08:00">2020-09-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-01 21:03:22" itemprop="dateModified" datetime="2020-10-01T21:03:22+08:00">2020-10-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="git-学习笔记2"><a href="#git-学习笔记2" class="headerlink" title="git 学习笔记2"></a>git 学习笔记2</h1><h2 id="Browsing-History"><a href="#Browsing-History" class="headerlink" title="Browsing History"></a>Browsing History</h2><p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/1.png"></p>
<h3 id="Getting-a-Repository"><a href="#Getting-a-Repository" class="headerlink" title="Getting a Repository"></a>Getting a Repository</h3><p>下载： 链接：<a href="https://pan.baidu.com/s/12cWs65AEMGUvw1pr6yRI3A" target="_blank" rel="noopener">https://pan.baidu.com/s/12cWs65AEMGUvw1pr6yRI3A</a> 提取码：dpyi</p>
<h3 id="Viewing-the-History"><a href="#Viewing-the-History" class="headerlink" title="Viewing the History"></a>Viewing the History</h3><p>我们之前知道了 <code>git log</code> 可以查询详细信息， <code>git log --oneline</code>  可以查看简略信息。那么如果 <code>git log --oneline --stat</code> 就可以看到不同的commit的信息和它所做的修改。</p>
<p>比如最后一次提交，一共有五个文件改变了，一共有7个地方增加了，4个地方减少了。其中audience.txt 有三处地方增加了，一处地方减少了，以此类推。</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/2.png" style="zoom:120%;"></p>
<p><code>git log stat</code> 可以展示每一个提交的详细信息</p>
<p><code>git log --patch</code>可以看到每一个提交具体改变的内容，如下：</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/3.png" style="zoom:100%;"></p>
<h3 id="Filtering-the-History"><a href="#Filtering-the-History" class="headerlink" title="Filtering the History"></a>Filtering the History</h3><p>当项目的时间越来越长，内容越来越多的时候，我们不会想查看所有的commit，我们只想筛选符合我们条件的commit</p>
<p>我们能通过作者名字、commit日期、commit message， 内容等来进行筛选。</p>
<p>比如我们想筛选倒数后三个commit，可以用 <code>git log --oneline -3</code></p>
<p>比如我们想筛选出作者为Mosh的commit，可以用 <code>git log --oneline --author =&quot;Mosh&quot;</code></p>
<p>又比如我想筛选出日期在 2020年8月17号之后的commit，可以用 <code>git log --oneline --after =&quot;2020-08-17&quot;</code> </p>
<p>甚至可以这么写<code>git log --oneline --after =&quot;one week ago&quot;</code>   </p>
<p>如果想要筛选 git message ,那么可以用命令 <code>git log --oneline --grep = &quot;GUI&quot;</code> 那么Git就会筛选出 messages中包含 “GUI” 的内容。注意，这是区分大小写的!</p>
<p>如果我们要查询commit中的内容，可以用 <code>git log --oneline -S&quot;OBJECTIVES&quot;</code> 来筛选出commit中对OBJECTIVES进行修改的commit</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/4.png" style="zoom: 150%;"></p>
<p>如果我们想看看哪些commit对一特定文件进行修改的，我们可以用命令 <code>git log --oneline toc.txt</code> （toc.txt是目标文件）</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/5.png" style="zoom: 150%;"></p>
<p>当我们想看看这些commit的增删时，我们要注意 —patch 不能写在文件名的后面，否则会发生歧义。要这样写</p>
<p> <code>git log --oneline --patch toc.txt</code></p>
<h3 id="Formatting-the-Log-Output"><a href="#Formatting-the-Log-Output" class="headerlink" title="Formatting the Log Output"></a>Formatting the Log Output</h3><p>我们可以对 log 日志进行一些格式化输出：比如 %Cgreen 就是把字体颜色换成绿色，%an 就代表 author，%Creset 就是恢复默认颜 色。%h 就是精简ID，%H是完整ID，  %cd代表日期。</p>
<p><code>git log --pretty=format:&quot;%Cgreen%an %Creset committed %h on %cd  &quot;</code></p>
<p>我们可以从 <a href="git-scm.com/docs/git-log">git官网 </a> 中查看格式化日志的其他占位符</p>
<h3 id="Aliases"><a href="#Aliases" class="headerlink" title="Aliases"></a>Aliases</h3><p>现在我们对一个log格式化字符串取一个别名.我们可以使用命令</p>
<p><code>git config --global alias.lg &quot;log --pretty=format:&#39;%an committed %h&#39;&quot;</code></p>
<p>用 <code>git config --global -e</code> 查看 gitconfig 我们会发现</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/6.png" style="zoom: 150%;"></p>
<p>现在我们就可以用 <code>git lg</code> 来显示我们自定义的日志了。</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/7.png" style="zoom: 150%;"></p>
<p>同理，我们可以设置一个unstage命令，将staging area中的数据还原。</p>
<p><code>git config --global alias.unstage &quot;restore --staged .&quot;</code></p>
<h3 id="Viewing-a-Commit"><a href="#Viewing-a-Commit" class="headerlink" title="Viewing a Commit"></a>Viewing a Commit</h3><p>在 <a href="https://jasonxqh.github.io/2020/09/23/git基础/">git基础</a> 中我们讲过 <code>git show HEAD~n-1</code> ,其实 它完整的用法是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">usage: git log [&lt;options&gt;] [&lt;revision-range&gt;] [[--] &lt;path&gt;...]</span><br><span class="line">   or: git show [&lt;options&gt;] &lt;object&gt;...</span><br></pre></td></tr></table></figure>
<p>如果我不想看有哪些改变，我想改这个文件在这个commit中的内容。我们可以<code>git show HEAD</code>+文件相对路径</p>
<p><code>git show HEAD~2:sections/creating-snapshots/staging-changes.txt</code></p>
<p>如果我们只想看看这个commit中有哪些文件做了修改，我们可以</p>
<p><code>git show HEAD~2 --name-only</code> 我们发现在sections中的creating-snapshots文件夹中的staging-changes.txt</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/8.png" style="zoom: 150%;"></p>
<p><code>`git show HEAD~2 --name-status</code> 则会显示在这个commit当中文件的增改 ,比如下面 <code>sections/creating-snapshots/staging-changes.txt</code> 是被修改的.</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/9.png" style="zoom: 140%;"></p>
<h3 id="Viewing-the-Changes-Across-Commits"><a href="#Viewing-the-Changes-Across-Commits" class="headerlink" title="Viewing the Changes Across Commits"></a>Viewing the Changes Across Commits</h3><p>现在我们来思考一个问题,怎么才能看多次 commits中文件做出的改变呢?</p>
<p>我们使用 diff 命令 </p>
<p><code>git diff HEAD~2 HEAD audience.txt</code> </p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/10.png" style="zoom: 140%;"></p>
<p>当然也可以 <code>git diff HEAD~2 HEAD --name-status</code>  来查看现在到过去两个版本之间变动过的文件</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/11.png" style="zoom: 140%;"></p>
<h3 id="Checking-Out-a-Commit"><a href="#Checking-Out-a-Commit" class="headerlink" title="Checking Out a Commit"></a>Checking Out a Commit</h3><p>有时候我们想要看看某一个commit下所有的project文件,那么我们就需要将commit 复制出来然后粘贴到working directory.</p>
<p>我们现在选一个ID来checkout <code>git checkout dad47ed</code> ,再次<code>git log --oneline</code> 后发现</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/12.png" style="zoom: 140%;"></p>
<p>这里我们要理解HEAD和Master这两个概念</p>
<p>我们的commits就像一条链一样,一环指着一环的,MASTER始终指着最后一个commit,HEAD指向Master,这有了之前最后一个commit是这样表示:</p>
<p><code>a642e12  (HEAD -&gt; master) Add header to all pages.</code></p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/15.png" style="zoom: 140%;"></p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/13.png" style="zoom: 140%;"></p>
<p>现在我们check out一个commit,其实就是移动了HEAD指针,现在HEAD指向我们的目标commit了.</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/14.png" style="zoom: 140%;"></p>
<p>但是这样需要注意, 现在不要再进行commit操作了,因为commit会加在head指向的地方,也就是说现在如果commit的话会发现变成了这样.</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/16.png" style="zoom: 140%;"></p>
<p>那么当我的HEAD再次指向MASTER之后,新来的commit将永远不会被访问到了.我们要避免这种情况发生</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/17.png" style="zoom: 140%;"></p>
<p>如果我们想要让HEAD再次指向MASTER,之间<code>git checkout master</code> 即可</p>
<h3 id="Finding-Bugs-Using-Bisect"><a href="#Finding-Bugs-Using-Bisect" class="headerlink" title="Finding Bugs Using Bisect"></a>Finding Bugs Using Bisect</h3><h3 id="Finding-Contributors-Using-Shortlog"><a href="#Finding-Contributors-Using-Shortlog" class="headerlink" title="Finding Contributors Using Shortlog"></a>Finding Contributors Using Shortlog</h3><p>有些时候我们需要找到所有commit过的人.我们可以使用命令</p>
<p> <code>git shortlog</code></p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/18.png" style="zoom: 100%;"></p>
<p>我们可以 </p>
<p><code>git shortlog -n -s</code></p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/19.png" style="zoom: 100%;"></p>
<p><code>git short log -n -e</code> 来显示这个人的邮箱</p>
<p>甚至可以 <code>git shortlog -n -s -e --before=&quot;&quot; --after=&quot;&quot;</code> 来框定某一个特定时间内提交者的信息</p>
<h3 id="Viewing-the-History-of-a-File"><a href="#Viewing-the-History-of-a-File" class="headerlink" title="Viewing the History of a File"></a>Viewing the History of a File</h3><p>现在我们来看看一个文件在历次commits之间的变化情况.</p>
<p><code>git log --oneline toc.txt</code></p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/20.png" style="zoom: 100%;"></p>
<p>如果我们想看看这个文件在每次commit之中改了什么内容,可以用<br><code>git log --oneline --patch toc.txt</code> </p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/21.png" style="zoom: 100%;"></p>
<h3 id="Restoring-a-Deleting-File"><a href="#Restoring-a-Deleting-File" class="headerlink" title="Restoring a Deleting File"></a>Restoring a Deleting File</h3><p>我们有时候会误删一些文件,我们可以通过git来恢复. </p>
<p>我们先删除 toc.txt 也就是 <code>git rm toc.txt</code></p>
<p>然后我们<code>git log --oneline toc.txt</code> 却发现报错了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fatal: ambiguous argument &#39;toc.txt&#39;: unknown revision or path not in the working tree.</span><br><span class="line">Use &#39;--&#39; to separate paths from revisions, like this:</span><br><span class="line">&#39;git &lt;command&gt; [&lt;revision&gt;...] -- [&lt;file&gt;...]&#39;</span><br></pre></td></tr></table></figure>
<p>这是因为在删除了toc.txt之后,git就不能辨别 toc.txt 到底是命令还是一个文件了,我们需要 用 — 来分隔文件和命令</p>
<p><code>git log --oneline -- toc.txt</code></p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/22.png" style="zoom: 100%;"></p>
<p>我们要的是 a642e12 这个commit,然后我们用命令 <code>git checkout a642e12 toc.txt</code> 将 commit 中的 toc.txt 取出放到 working directory. </p>
<h3 id="Finding-the-Author-of-Line-Using-Blame"><a href="#Finding-the-Author-of-Line-Using-Blame" class="headerlink" title="Finding the Author of Line Using Blame"></a>Finding the Author of Line Using Blame</h3><p>如果我们觉得某一个人的某个文件代码写的很差,我们可以使用 Blame 功能 “责备他”</p>
<p><code>git blame audience.txt</code></p>
<p>-e 即查看他人的邮件</p>
<p><code>git blame -e audience.txt</code></p>
<p>-L 1,3 即显示前三行</p>
<p><code>git blame -e -L 1,3 audience.txt</code></p>
<p>(感觉这个功能也没啥用处…)</p>
<h3 id="Tagging"><a href="#Tagging" class="headerlink" title="Tagging"></a>Tagging</h3><p>我们可以给一些有里程碑意义的commit打标签 </p>
<p>比如 <code>git tag v1.0 a642e12</code></p>
<p> <img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/23.png" style="zoom: 100%;"></p>
<p>我们就发现倒数第二个commit被打上了 v1.0的标签</p>
<p>设置了 tag之后,checkout会变得非常方便了 ,直接 <code>git checkout v1.0</code> 就可以了。</p>
<p>这个tag可以看作是指针或者一个commit的别名。</p>
<p>还有一种 tag叫做 annotated tag. 这种tag是一个对象，里面有打tag的人的email之类的信息，比如</p>
<p><code>git tag -a v1.1 -m &quot;My version 1.1&quot;</code></p>
<p>如果我们要查看每个tag的 message，那么我们可以用 <code>git tag -n</code> </p>
<p>查看anotated tag的tageer的信息，可以使用 <code>git show tag名</code>，比如：</p>
<p>查看现在定了几个tag可以用<code>git tag</code> </p>
<p>删除某个tag可以用 <code>git tag -d v1.1</code>  这样的命令,那么在开头就会显示Author的信息和打标签的时间了</p>
<h3 id="Browsing-History-Using-VSCode"><a href="#Browsing-History-Using-VSCode" class="headerlink" title="Browsing History Using VSCode"></a>Browsing History Using VSCode</h3><p>用 Gitlens 会更加方便</p>
<h3 id="Browsing-the-History-Using-GitKraken"><a href="#Browsing-the-History-Using-GitKraken" class="headerlink" title="Browsing the History Using GitKraken"></a>Browsing the History Using GitKraken</h3><h2 id="Branching"><a href="#Branching" class="headerlink" title="Branching"></a>Branching</h2><ul>
<li>Use branches</li>
<li>Compare branches</li>
<li>Merge branches</li>
<li>Resolve conflicts</li>
<li>Undo a faulty merge</li>
<li>Essential tools(stashing ,cherry picking )</li>
</ul>
<h3 id="What-are-Branches"><a href="#What-are-Branches" class="headerlink" title="What are Branches"></a>What are Branches</h3><p>我们可以把 Branch 看成是 独立的分隔的 workspace</p>
<p>我们有一个working space MASTER，又有另外一个working space FEATURE 用来研究其他的特性。在FEATURE完成之前，我们不想让里面的代码对MASTER进行一个干扰。当FEATURE已经完善之后，我们再将其和MASTER进行合并。</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/24.png" style="zoom: 100%;"></p>
<p>branch 这个功能让我们能够对不同的对象进行不同的工作，两者互不干扰，因为我们需要保证 main line 尽可能稳定，以便branch能够随时发布，同时也有助于团队的新成员能尽快上手项目。  </p>
<p>Git中的Branch只是一个对commit的指针。Master只是一个指向 main line 最后一次commit的指针。当我们commit之后，git会自动移动 Master 指针。当我们新建了一个branch之后，我们实际是新建了一个指针，这个指针占有的内存很小。那么怎么才能知道当前我们是在那个 working space当中呢？git中还有一个指针HEAD，这个指针指向一个branch的名字，我们可以用 checkout 将HEAD指向不同的branch。</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/25.png" style="zoom: 100%;"></p>
<h3 id="Working-with-Branches"><a href="#Working-with-Branches" class="headerlink" title="Working with Branches"></a>Working with Branches</h3><p>比如我们现在发现了一个Bug，现在为了修复这个bug，我们新建一个branch叫做 bugfix</p>
<ul>
<li>使用命令 <code>git branch bugfix</code> 就可以创建branch</li>
<li><p>使用命令 <code>git branch</code> 可以查看当前的branches</p>
</li>
<li><p>如果要切换branches，可以使用 <code>git switch bugfix</code> 或者 <code>git checkout bugfix</code></p>
</li>
<li>如果要重命名branch ,可以使用 <code>git branch -m bugfix(原名) bugfix/signup-form(新名)</code></li>
</ul>
<p>我们对audience.txt 进行了改变并且提交了。然后查看日志，会发现 master是bugfix之前一个版本。</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/26.png" style="zoom: 100%;"></p>
<p>我们对audience做出的改变只能在bugfix这个commit 下才能查看。如果我们切换成master一支，我们是不会发现audience.txt做出了什么改变的。</p>
<ul>
<li>在切换回 master之后，我们是看不出bugfix的，如果要查看我们就要用<code>git log --oneline --all</code></li>
<li>如果我们已经成功修复了bug，需要和master合并然后删去这个bugfix branch，我们可以用命令<code>git branch -d bugfix/signup-form</code> 但是要注意，如果没有merge之前就删除这个branch会报错。如果我们真的要强制删除，我们可以使用 <code>git branch -D bugfix/signup-form</code> 也就是变成大写的D</li>
</ul>
<h3 id="Comparing-Branches"><a href="#Comparing-Branches" class="headerlink" title="Comparing Branches"></a>Comparing Branches</h3><p>当我们创建branches并对其commit时，我们需要看看它们是怎么与master主线岔开的。我们现在就来比比不同的branches。</p>
<p>我们可以用 <code>git log master..bugfix/sigup-form</code> 来查看哪些commit是在这条branch上递交的</p>
<p>如果我们不想看commits，而是看在branch上改变了哪些内容，我们可以这么写：</p>
<ul>
<li><code>git diff master..bugfix/signup-form</code> 或者 <code>git diff bugfix/signup-form</code> </li>
</ul>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/28.png" style="zoom: 100%;"></p>
<p>如果我们只想看看那些文件名改变了我们可以用这个命令</p>
<ul>
<li><code>git diff --name-status bugfix/signup-form</code></li>
</ul>
<h3 id="Stashing"><a href="#Stashing" class="headerlink" title="Stashing"></a>Stashing</h3><p>stach有存放之意。当我们在master中做了一些改变，现在却想切换到branch去，那么branch中的内容就会覆盖掉我们现在working directory中的内容。</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/29.png" style="zoom: 100%;"></p>
<p>这就是stash出现的场景了，我们需要用stash方法将当前的working directory保存起来，然后当我们处理完 branch的事情、切换回branch之后在取出来。</p>
<ul>
<li><code>git stash push -m &quot;New tax rules.&quot;</code>将当前的内容stash，-m 后填写说明</li>
</ul>
<p>但是我们要注意， git stash是不会将git 没有追踪的(untracked) 文件保存下来的。也就是说不会stash刚刚创建的文件</p>
<ul>
<li><p>那么为了解决上面的问题，我们可以使用 <code>git stash push -a -m&quot;My new stash&quot;</code>  -a 就代表了<br>-all</p>
</li>
<li><p>想看看当前的stash信息，可以使用 <code>git stash list</code></p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/30.png" style="zoom: 120%;"></p>
</li>
<li><p>现在假设我们再bugfix这支branch上的工作已经完成，我们切回master，想看看之前保留在stash中的文件做出了哪些改变 ，可以使用 <code>git stash show 1</code>来看 <code>stash@{1}</code> 中的内容</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/31.png" style="zoom: 120%;"></p>
</li>
<li><p>如果我想将stash中的文件放回到working directory，那么可以用<code>git stash apply 1</code> 来提取<code>stash@{1}</code> 中的内容。</p>
</li>
<li><p>如果我们已经不需要stash了，可以用<code>git stash drop 1</code> 来删除<code>stash@{1}</code></p>
</li>
<li><p>可以用 <code>git stash clear</code> 删除所有的stash</p>
</li>
</ul>
<h3 id="Merging"><a href="#Merging" class="headerlink" title="Merging"></a>Merging</h3><p>git提供了三种 commit 操作。</p>
<h4 id="Fast-forward-if-branches-have-not-diverged"><a href="#Fast-forward-if-branches-have-not-diverged" class="headerlink" title="Fast-forward (if branches have not diverged)"></a>Fast-forward (if branches have not diverged)</h4><p>就是master和branch是一条链上的。</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/32.png" style="zoom: 100%;"></p>
<p>如图所示，Master和BUGFIX 这支branch是线性关系，那么我们只需要将 MASTER 指针指向BUGFIX指向的commit，再将BUGFIX删除就能完成 合并操作。</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/33.png" style="zoom: 100%;"></p>
<p>Fast-forward merge 属于“快进方式”，不过这种情况如果删除分支，则会丢失分支信息。因为在这个过程中没有创建commit</p>
<h4 id="no-ff-merge"><a href="#no-ff-merge" class="headerlink" title="no-ff merge"></a>no-ff merge</h4><p>和Fast-forward merge的初始情况相同，但是no-ff merge在合并的时候并不是只将MASTER指向branch末尾，而是新建了一个commit</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/39.png" style="zoom: 100%;"></p>
<h4 id="3-way-if-branch-have-diverged"><a href="#3-way-if-branch-have-diverged" class="headerlink" title="3-way(if branch have diverged)"></a>3-way(if branch have diverged)</h4><p>master 和 branch 分叉了，各自有commit</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/34.png" style="zoom: 100%;"></p>
<p>现在我们执行合并操作的话，就是新建一个commit，将master和BUGFIX文件各自做出的改变合并起来。</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/35.png" style="zoom: 100%;"></p>
<h3 id="Fast-forward-Merges"><a href="#Fast-forward-Merges" class="headerlink" title="Fast-forward Merges"></a>Fast-forward Merges</h3><p>学了branch以后我们在查看log的时候记得加上 —graph, 这样git会以点线图的形式将master和branch所做的变更和合并呈现出来。这里展示的是Fast-forward , branch和master是一条链上的，所以graph是线性排列的。</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/36.png" style="zoom: 100%;"></p>
<ul>
<li>我们使用 <code>git merge bugfix/signup-form</code> <strong>在HEAD指向MASTER的时候</strong>来实现Fast-forward Merge</li>
</ul>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/37.png" style="zoom: 100%;"></p>
<p>再次查看log，发现 master和branch(bugfix) 都指向了一个commit了</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/38.png" style="zoom: 100%;"></p>
<h3 id="No-ff-merge"><a href="#No-ff-merge" class="headerlink" title="No-ff merge"></a>No-ff merge</h3><p><strong>同样是</strong>线性的branch和master，我们也可以选择<strong>不是 fast-forward merge的形式</strong>(no-ff)来进行合并。上文说过，Fast-forward merge 并没有创建新的commit，容易丢失 branch版本。若选择 no-ff 形式，在合并时会新建一个commit，这样就会保存branch的版本了。</p>
<p>接下来我们模拟 no-ff 合并操作。</p>
<ul>
<li>可以用 <code>git switch -C branch名字</code> 将创建和切换branch 缩在一条命令当中</li>
</ul>
<p>现在有一个master，一个bugfix/login-form 的branch</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/40.png" style="zoom: 100%;"></p>
<ul>
<li>我们使用 <code>git merge --no-ff bugfix/login-form</code> 这一命令来执行 no-ff 类的merge操作。</li>
</ul>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/41.png" style="zoom: 100%;"></p>
<p>查看merge做的点线图，我们可以很清楚的看到merge和master进行了一个合并且生成了一个新的commit</p>
<p>我们既要习惯fast-forward，也要习惯no-ff ,因为no-ff commit merge可以反映出一个项目创建后的一步步历史，而且no-ff merge能让在不想要branch的时候更方便地退回之前的master版本。</p>
<p>如果我们不喜欢(或者上司不喜欢) fast-forward 的话，我们可以把 no-ff 设置为全局变量，即对所有的repository通用。</p>
<ul>
<li><code>git config ff no</code>(对当前repository) / <code>git config --global ff no</code> 对所有repositories</li>
</ul>
<h3 id="Three-way-Merges"><a href="#Three-way-Merges" class="headerlink" title="Three-way Merges"></a>Three-way Merges</h3><p>现在我们来模拟 Three-way Merge 的操作。</p>
<p>流程：创建并切换至新branch,commit一次；切换回master，commit一次 ,我们就会发现branch和master发生了分叉。</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/43.png" style="zoom: 100%;"></p>
<p>现在我们要合并这两支，这两支有着共同的祖先。</p>
<ul>
<li>我们可以直接用 <code>git merge feature/change-password</code> 来进行 three-way merge</li>
</ul>
<p>我们看到下面git给出的路径，已经对两支进行了合并操作。</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/44.png" style="zoom: 100%;"></p>
<h3 id="Viewing-Merged-and-Unmerged-Branches"><a href="#Viewing-Merged-and-Unmerged-Branches" class="headerlink" title="Viewing Merged and Unmerged Branches"></a>Viewing Merged and Unmerged Branches</h3><p>有时候我们新建了一个branch，但是项目做着做着可能就忘记将这个branch合并了，于是我们可以通过命令</p>
<ul>
<li><code>git branch --merged</code> 来查看哪些branch已经合并了</li>
<li><code>git branch --no-merged</code> 来查看那些branch还没有进行合并</li>
</ul>
<p>对于已经合并的branch我们要养成好习惯及时删除。</p>
<p><code>git branch -d bugfix/login-form</code></p>
<h3 id="Merge-Conflicts"><a href="#Merge-Conflicts" class="headerlink" title="Merge Conflicts"></a>Merge Conflicts</h3><p>在Merge的时候我们常常会遇到冲突</p>
<ul>
<li>当一个文件同时被两支branch修改时</li>
<li>一个文件在一支里面被修改，却被另一支删除时</li>
<li>同一文件在两个分支中都加了点东西，但是加的内容不同</li>
</ul>
<p>遇到这些冲突的时候，git就会暂停合并，我们需要告诉Git我们想怎么选择。</p>
<p>我们现在通过git命令来模拟这一操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git switch -C bugfix&#x2F;change-password</span><br><span class="line">code change-password.txt</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Update change-password.txt&quot;</span><br><span class="line"></span><br><span class="line">git switch master</span><br><span class="line">code change-password.txt</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;Update change-password.txt&quot;</span><br></pre></td></tr></table></figure>
<p>现在我 <code>git merge bugfix/change-password</code> 之后，会出现conflicts</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/46.png" style="zoom: 120%;"></p>
<p>这时候git就会自动跳到一个 master|MERGING 状态。在这个状态下我们输入 <code>git status</code> 就会发现change-password.txt 这个文件并没有被merge，因为它被 both modified 了。</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/47.png" style="zoom: 120%;"></p>
<p>这时候，我们可以用vscode打开 change-password.txt </p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/45.png" style="zoom: 150%;"></p>
<p>vscode可以使用 “采用当前更改(master)”、”采用传入的更改(branch)”、”保留双方更改”、”比较变更”这几种选项。</p>
<p>或者我们也可以直接手动更改再保存(但是尽量别再自己加东西了！)</p>
<p>修改好以后，我们再使用 <code>git add .</code> 和 <code>git commit</code> 将定稿commit</p>
<h3 id="Graphical-Merge-Tools"><a href="#Graphical-Merge-Tools" class="headerlink" title="Graphical Merge Tools"></a>Graphical Merge Tools</h3><p>VScode用来进行合并操作有点麻烦。这里介绍一些其他的工具</p>
<ul>
<li>Kdiff</li>
<li>P4Merge</li>
<li>WinMerge(Windows Only) </li>
</ul>
<p>p4Merge 的下载地址<a href="https://www.perforce.com/downloads/visual-merge-tool" target="_blank" rel="noopener">https://www.perforce.com/downloads/visual-merge-tool</a></p>
<p>下载完成后不需要点击软件，需要在git中进行配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global merge.tool p4merge</span><br><span class="line"></span><br><span class="line">git config --global mergetool.p4merge.path   &quot;C:\Program Files\Perforce\p4merge.exe&quot;&#x2F;&#x2F;exe所在的目录</span><br></pre></td></tr></table></figure>
<p>然后当文件发生冲突的时候，我们可以用命令</p>
<p><code>git mergetool</code>  来打开 p4merge界面</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/48.png" style="zoom: 100%;"></p>
<p>我们看到这就是 P4Merge的UI，操作很友好，支持不同conficts文件之间的切换。</p>
<h3 id="Aborting-a-Merge"><a href="#Aborting-a-Merge" class="headerlink" title="Aborting a Merge"></a>Aborting a Merge</h3><p>我们进行Merge操作的时候会遇到一些conflicts，但是当我们犹豫不决、没下定决心取舍哪个版本的时候。我们可以终止merging状态,回到合并之前的样子</p>
<ul>
<li>只要使用 <code>git merge --abort</code> 即可</li>
</ul>
<h3 id="Undoing-a-Faulty-Merge"><a href="#Undoing-a-Faulty-Merge" class="headerlink" title="Undoing a Faulty Merge"></a>Undoing a Faulty Merge</h3><p>有时候我们在Merge之后发现code没办法得到兼容或者编译，那么我们现在需要回退到之前的状态、取消当前的merge状态。待修改完成后，我们再重新merge</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/49.png" style="zoom: 100%;"></p>
<p>现在是这样子的。我们要撤回当前的merge状态，有两种选择：</p>
<ul>
<li><p>git reset 是将 merge 后的commit删除(remove),</p>
</li>
<li><p>git revert是用于“反做”某一个版本，以达到撤销该版本的修改的目的。现在我们的merge操作出现了点问题，但是我想保留这个commit，又想回退到上一个版本，这时候我们可以新建一个版本，这个版本和merge前的哪个版本一模一样，达到了退回的目的。</p>
</li>
</ul>
<p>首先我们来看 remove操作： 示意图如下</p>
<p>一开始的状态时这样子的</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/50.png" style="zoom: 100%;"></p>
<p>将Master 回退到之前状态后，没有任何指针指向最后一个commit，git会自行删除这个commit</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/51.png" style="zoom: 100%;"></p>
<ul>
<li><code>git reset --hard HEAD~1</code> 这行命令就可以完成 remove操作</li>
</ul>
<p>HEAD~1就代表当前HEAD之前一个版本的commit，但是hard怎么理解呢？</p>
<p>当我们执行 reset操作的时候，我们有三种选择：</p>
<ul>
<li>soft</li>
<li>mixed</li>
<li>hard</li>
</ul>
<p>当我们执行soft的时候,Last Snapshot 会回退到上一个版本，但是 Working directory 和 staging area中的内容是不会受影响的，也就是还和原来保持一样</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/52.png" style="zoom: 100%;"></p>
<p>当我们使用 mixed 操作的时候，git会取出上一次的commit的snapshot然后放到 Staging area 当中去。</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/53.png" style="zoom: 100%;"></p>
<p>hard 操作则是将快照应用在三个地方：</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/54.png" style="zoom: 100%;"></p>
<p>执行完命令后，发现log已经变成这样了:</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/55.png" style="zoom: 100%;"></p>
<p>我们可以再通过 <code>git reset --hard merge编号</code> 来重新变成merge之后的状态</p>
<p>下面来介绍 revert 操作,再revert的时候我们需要告诉git回退到哪一个版本，是master支上的还是 branch上的</p>
<ul>
<li><code>git revert -m 1 HEAD</code> -m 1 就代表着 first parent，也就是master上的版本。</li>
</ul>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/56.png" style="zoom: 100%;"></p>
<p>重新查看 log，可以发现新建了一个commit，这个commit和之前的9455172 是一模一样的</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/57.png" style="zoom: 100%;"></p>
<h3 id="Squash-Merging"><a href="#Squash-Merging" class="headerlink" title="Squash Merging"></a>Squash Merging</h3><p>Squash 是挤压之意，相比 merge 来说会减少分支合并的记录，会被压缩为一条 commit 记录。squash merge 本质是把 dev 分支的改动保存到 master 本地，接下来还需要手动提交一下。</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/58.png" style="zoom: 100%;"></p>
<p>我们先模拟当前的状况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git switch -C bugfix&#x2F;photo-upload </span><br><span class="line">echo bugfix &gt;&gt; audience.txt</span><br><span class="line">git commit -am &quot;Update audience.txt&quot;</span><br><span class="line"></span><br><span class="line">echo bugfix&gt;&gt;toc.txt</span><br><span class="line">git commit -am &quot;Update toc.txt&quot;</span><br></pre></td></tr></table></figure>
<p>然后我们进行 squash merge</p>
<ul>
<li>首先 <code>git switch master</code></li>
<li><code>git merge --squash bugfix/photho-upload</code> </li>
</ul>
<p>这还没完，这只是将branch 中修改的内容存放在staging area当中，还没有commit</p>
<p><code>git commit -m &quot;Fix the bug one the photo upload page&quot;</code> 以后</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/59.png" style="zoom: 100%;"></p>
<p>但是要注意，squash merge的应用情况是修改一些小bug，或者增加一些小feature，不宜修改太多。当我们commit之后也要及时删除。因为如果project很大的话，我们会忘记这支branch，<code>git branch --no-merged</code> 就会看到branch还未合并，可能会出现误解。</p>
<p><code>git branch -D bugfix/photo-upload</code> 可以删除这支branch。注意，这里不能写 -d,因为git会认为这支branch还没有合并，从而拒绝删除。 -D则是强制删除。                                          </p>
<h3 id="Rebasing"><a href="#Rebasing" class="headerlink" title="Rebasing"></a>Rebasing</h3><p>Rebasing 顾名思义就是将branch的Base重定向。</p>
<p>下面是初始状态：</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/60.png" style="zoom: 100%;"></p>
<p>Rebase之后，我们将FEATURE这支转移到Master上</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/61.png" style="zoom: 100%;"></p>
<p>最后将Master和Feature合并</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/62.png" style="zoom: 100%;"></p>
<p>Rebase 是一种修改Commit 历史的写法。我们不应该在多人团队协作的情况下擅自使用 Rebase</p>
<p>事实上，在Git 内部的实现原理如下：</p>
<p>首先在Master后面创建两个F1，F2 commit的拷贝F1*和F2*。然后再让Feature指向 F2*, 这时没有指针再指向F1、F2 了，git会自行删除它们。</p>
<p>我们先用命令创造出这样一个情况 ： </p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/63.png" style="zoom: 100%;"></p>
<p>然后我们将Head指向 feature/shopping-cart 并 <code>git rebase master</code></p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/64.png" style="zoom: 100%;"></p>
<p>最后我们只需要做一下 fast-forward merge 就可以将两个合并起来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git switch master</span><br><span class="line">git merge feature&#x2F;shopping-cart</span><br></pre></td></tr></table></figure>
<p>那么如果rebase发生冲突了该怎么办呢？</p>
<p>我们同样可以通过 <code>git mergetool</code> 来进行调整。</p>
<ul>
<li><p>一个文件调整完了，可以用 <code>git rebase --continue</code> 来进行下一个文件的处理</p>
</li>
<li><p>可以用<code>git rebase --skip</code> 来跳过当前文件的处理。</p>
</li>
<li>可以用 <code>git rebase --abort</code> 来回暂停rebase操作。</li>
</ul>
<h3 id="Cherry-Picking"><a href="#Cherry-Picking" class="headerlink" title="Cherry Picking"></a>Cherry Picking</h3><p>Cherry Picking 就是像在两个樱桃中选择一个去摘。在git中如图：</p>
<p><img src="/2020/09/27/git%E5%AD%A6%E4%B9%A02/65.png" style="zoom: 100%;"></p>
<p>我们只要记下 F1 的ID，然后 <code>git cherry-pickl ID</code></p>
<p>如果发生了问题，那么我们也可以用 <code>git mergetool</code> 来解决。</p>
<h3 id="Picking-a-File-from-Another-Branch"><a href="#Picking-a-File-from-Another-Branch" class="headerlink" title="Picking a File from Another Branch"></a>Picking a File from Another Branch</h3><p>现在我们来看看怎么从一支branch中取出单独的一个文件放到当前的working directory</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git switch -C feature&#x2F;send-email</span><br><span class="line">echo river &gt; toc.txt</span><br><span class="line">git commit -am &quot;Update toc.txt&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>我们先 git switch master</p>
</li>
<li><p>然后 <code>git restore --source=feature/send-email -- toc.txt</code>  也就是从 feature/send-email这一支的最新commit中选出toc.txt 文件放到working directory当中</p>
</li>
<li>最后 add ，commit 即可</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/" class="post-title-link" itemprop="url">CSAPP程序的机器级表示1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-24 08:43:24" itemprop="dateCreated datePublished" datetime="2020-09-24T08:43:24+08:00">2020-09-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-10 18:16:58" itemprop="dateModified" datetime="2020-11-10T18:16:58+08:00">2020-11-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CSAPP程序的机器级表示1"><a href="#CSAPP程序的机器级表示1" class="headerlink" title="CSAPP程序的机器级表示1"></a>CSAPP程序的机器级表示1</h1><p>本章内容：</p>
<ul>
<li>快速浏览C语言、汇编代码以及机器代码之间的关系。</li>
<li>介绍 x86-64 的细节：从数据的表示和处理以及控制的实现(C语言中的if,while,switch等控制结构)</li>
<li>过程的实现(如程序如何维护一个运行栈来支持过程间数据和控制的传递，以及局部变量的存储)</li>
<li>考虑在机器级如何实现像数组、结构和联合这样的数据结构</li>
<li>讨论内存访问越界问题、洗头膏容易遭到缓冲区溢出攻击的问题。</li>
<li>用GDB调试器检查机器级程序运行时行为的技巧</li>
<li>浮点数据和操作的代码的机器程序表示</li>
</ul>
<h2 id="程序编码"><a href="#程序编码" class="headerlink" title="程序编码"></a>程序编码</h2><p>之前我们讲过用 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Og -o p p1.c p2.c</span><br></pre></td></tr></table></figure>
<p>来编译 p1.c 和 p2.c 两个文件。编译选项 -Og 告诉编译器使用会产生<strong>符合原始C代码整体结构</strong>的机器代码的优化等级。因为使用较高级别的优化代码会使其严重变形，以至于产生的机器代码和源代码的关系变得难以理解。所以我们先从最基础的-Og开始，再看看较高级别的优化(-o1或-o2)会发生什么。</p>
<h3 id="机器级代码"><a href="#机器级代码" class="headerlink" title="机器级代码"></a>机器级代码</h3><p>在整个编译过程中，编译器会完成大部分的工作，把C语言转化成处理器执行的<strong>非常基本</strong>的指令。汇编代码非常接近于机器代码，与机器代码的二进制格式比，汇编的主要特点就是他用<strong>可读性更好</strong>的文本格式表示。能够理解汇编代码以及它原始C代码的联系，使理解计算机如何执行程序的关键一步。</p>
<p>我们先了解一些寄存器的概念：</p>
<ul>
<li>程序计数器(通常称为 “PC”, 在 x86-64中用 %rip 表示) 给出将要执行的下一条指令在内存当中的地址</li>
<li>整数寄存器文件包含16个命名的位置用来存储64位的值。这些寄存器可以存储地址(对应于C语言的指针) 或整数数据。有的寄存器被用来记录某些重要的程序状态；其他的寄存器哟个来保存临时数据(参数、局部变量、返回值)</li>
<li>条形码寄存器保存着最近执行的算术或者逻辑指令的状态信息。它们用来实现控制数据流中的条件变化(if 和 while)</li>
<li>一组向量寄存器可以存放一个或者多个整数或浮点数值</li>
</ul>
<p>一条机器指令只执行一个非常基本的操作。例如将存放在寄存器中的两个数字相加，在寄存器和存储器之间传送数据，或是条件分支转移到新的指令地址。编译器必须产生这些指令的序列，从而实现(如算术表达式求值、循环或者过程调用和返回)程序结构</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>比如我写一个C语言代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">mult2</span><span class="params">(<span class="keyword">long</span>,<span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multstore</span><span class="params">(<span class="keyword">long</span> x,<span class="keyword">long</span> y,<span class="keyword">long</span> *dest)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> t = mult2(x,y);</span><br><span class="line">    *dest = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们用 <code>gcc -Og -S mstore.c</code> 命令来进行编译</p>
<p>得到mulstore的汇编语言形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">multstore:</span><br><span class="line">	pushq			%rbx</span><br><span class="line">	.seh_pushreg	%rbx</span><br><span class="line">	subq			$32, %rsp</span><br><span class="line">	.seh_stackalloc	32</span><br><span class="line">	.seh_endprologue</span><br><span class="line">	movq			%r8, %rbx</span><br><span class="line">	call			mult2</span><br><span class="line">	movl			%eax, (%rbx)</span><br><span class="line">	addq			$32, %rsp</span><br><span class="line">	popq			%rbx</span><br><span class="line">	ret</span><br><span class="line">	.seh_endproc</span><br><span class="line">	.ident			&quot;GCC: (tdm64-1) 4.9.2&quot;</span><br><span class="line">	.def			mult2;	.scl	2;	.type	32;	.endef</span><br></pre></td></tr></table></figure>
<p>上面代码mulstore下的每行都代表一条机器指令。比如 pushq指令表示应该将寄存器 %rbx 的内容压入程序栈当中。这段代码中已经除去了所有关于局部变量名或者数据类型的信息。</p>
<p>我们再进一步用 <code>gcc -Og -c mstore.c</code> 来进行编译，这就会产生目标代码文件 mstore.c ，他是二进制格式的无法直接查看。转换为十六进制之后可以看到汇编指令对应的目标代码。</p>
<p>我们从中得到一个重要信息，即机器执行的程序只是一个字节序列，它是对一系列指令的编码。机器对产生这些指令的源代码几乎一无所知</p>
<p>要查看机器代码文件的内容，有一类称为 反汇编器的程序非常有用。这些程序根据机器代码产生一种类似于汇编代码的格式。我们可以用命令 <code>objdump -d mstore.o</code> 来实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 &lt;multstore&gt;:</span><br><span class="line">   0:   53                      push   %rbx</span><br><span class="line">   1:   48 83 ec 20             sub    $0x20,%rsp</span><br><span class="line">   5:   4c 89 c3                mov    %r8,%rbx</span><br><span class="line">   8:   e8 00 00 00 00          callq  d &lt;multstore+0xd&gt;</span><br><span class="line">   d:   89 03                   mov    %eax,(%rbx)</span><br><span class="line">   f:   48 83 c4 20             add    $0x20,%rsp</span><br><span class="line">  13:   5b                      pop    %rbx</span><br><span class="line">  14:   c3                      retq</span><br></pre></td></tr></table></figure>
<p>在左边十六进制字节值被分成了机组，每组都是一条指令，右边是等价的汇编语言。</p>
<p>其中，一些关于机器代码和它的反汇编表示的特性值得注意：</p>
<ul>
<li>x86-64 的指令长度从1到15个字节不等。<strong>常用的指令以及操作数较少</strong> 的指令所需的字节数<strong>少</strong>，而那些<strong>不太常用或操作数较多</strong>的指令所需的字节数较<strong>多</strong> </li>
<li>设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。例如，只有指令pushq %rbx 是以字节值53 开头的。</li>
<li>反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码。</li>
<li>反汇编器使用的指令命名规则与GCC 生成的汇编代码使用的有些细微的差别。在我们的示例中，它省略了很多指令结尾的  ‘q’ 这些后缀是大小指示符，在大多数情况中可以省略。相反，反汇编器给call 和ret 指令添加了 ‘q’ 后缀，同样，省略这些后缀也没有问题。</li>
</ul>
<h3 id="关于格式的注解"><a href="#关于格式的注解" class="headerlink" title="关于格式的注解"></a>关于格式的注解</h3><p>所有以 ‘.’ 开头的行 都是指导汇编器和链接器工作的伪指令。我们通常可以忽略这些行。另一方面，也没有关于指令的用途以及他们与源代码之间关系的解释说明。</p>
<p>为了清楚的说明汇编代码，我们用下面这种格式来表示汇编代码，他省略了大部分伪指令，但包括行号和解释性说明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void multstore(long x, long y, long *dest)</span><br><span class="line">x in %rdi, y in %rsi, dest in %rdx</span><br><span class="line">multstore:</span><br><span class="line">	pushq %rbx 					Save %rbx</span><br><span class="line">	movq %rdx, %rbx 			Copy dest to %rbx</span><br><span class="line">	call mult2 					Call mult2(x, y)</span><br><span class="line">	movq %rax, (%rbx) 			Store result at *dest</span><br><span class="line">	popq %rbx 					Restore %rbx</span><br><span class="line">	ret 						Return</span><br></pre></td></tr></table></figure>
<p>上面这种格式简单地描述了指令的效果以及它与原始C语言代码中的计算操作的关系。这是一种汇编语言程序员写代码的风格</p>
<h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><p>Intel用 “word” 表示16位数据类型。因此称32位数为 “double words” ，64位数为 “quad words” . 下图是C语言基本数据类型对应的 x86-64表示的表格</p>
<p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/1.png" style="zoom: 120%;"></p>
<p>浮点数主要有两种形式</p>
<ul>
<li><p>单精度(4字节) 值，对应于C中的 Float</p>
</li>
<li><p>双精度(8字节) 值，对应于C中的 Double</p>
<p>大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。比如 <code>moveb(传送字节)</code> 、<code>movw(传送字)</code> …</p>
<p>后缀‘l’用来表示双字，因为32 位数被看成是“长字（long word)” 。注意，汇编代码也使用后缀‘l’来表示4 字节整数和8 字节双精度浮点数。这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器。</p>
</li>
</ul>
<h2 id="访问信息"><a href="#访问信息" class="headerlink" title="访问信息"></a>访问信息</h2><p>我们首先来了解一下寄存器(register) 的历史</p>
<p><strong>最初</strong>的8086处理器中8个16位的寄存器，即位下面的 $\%ax$ 到 $\%bp$ 。 每一个寄存器都有特殊的用处。</p>
<p><strong>当扩展到IA32架构时</strong> ,这些寄存器也扩展成32位了，标号从 $\%eax$ 到 $\%ebp$ </p>
<p><strong>扩展到 x86-64 之后</strong>，从原来的8个寄存器扩展成64位，标号从 $\%rax$ 到 $\%rbp$ .此外还增加了8个新的寄存器，它们的表好是按照新的命名规则制定的 $\%r8$ 到 $\%r15$ </p>
<p>在常见的程序里不同的寄存器扮演着不同的角色。其中最特别的是栈指针 $\%rsp$ 用来指明栈的结束位置。有些程序会明确地读写这个寄存器。</p>
<p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/2.png" style="zoom: 120%;"></p>
<p>指令可以对这16个寄存器的低位字节中存放的不同的数据进行操作。</p>
<ul>
<li>字节级操作可以访问最低的字节(the least significant byte)</li>
<li>16位的操作能访问最低的2个字节</li>
<li>32位操作可以访问最低的4个字节</li>
<li>64位操作可以访问整个寄存器。</li>
</ul>
<p>当生成的指令以寄存器为目标时，对于生成小于8字节结果的指令，寄存器中剩下的字节会怎么样，对此有两条规则</p>
<ul>
<li>生成1字节和2字节数字的指令会保持剩下的字节不变</li>
<li>生成4字节的数字的指令会把高位4个字节设置为0。后面这条规则是作为从IA32到x86-64 的扩展的一部分而采用的</li>
</ul>
<h3 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h3><p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/4.png" style="zoom: 120%;"></p>
<p>大多数指令都有一个或者多个操作数(operand) , 指示出执行一个操作中要使用的源数据值以及放置结果的目的位置。</p>
<p>源数值可以存放在寄存器或内存当中。因此，各种不同的操作数的可能性被分成三种类型：</p>
<ul>
<li>立即数(immediate) ，用来表示常数值。 书写方式是 $ 后面跟一个标准C表示法表示的整数，比如 $-577 或$ 0x1F</li>
<li>寄存器(register), 我们用 $r_0$ 来表示任意寄存器 a, 用引用 $R[r_a]$ 来表示它的值，这是将寄存器集合看成一个数组R，用寄存器标识符作为索引</li>
<li>内存引用。它会根据计算出来的地址访问某个内存位置。因为将内存看成一个很大的字节数组，我们用负号$M_b[Addr]$ 表示对存储在内存中从地址 $Addr$ 开始的b个字节值的引用。为了简便，我们通常省略下标b</li>
</ul>
<p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/3.png" style="zoom: 100%;"></p>
<p>我们来 仔细解读一下这张表格，$$Imm 和R[r_a]$ 就不用说了。</p>
<ul>
<li>$M[Imm]$ 是绝对寻址。也就是按照<code>Imm</code> 取内存中寻址</li>
<li>$M[R[r_0]]$ 是间接寻址。也就是说寄存器R中指定了一段内存地址，然后以此去寻址。<ul>
<li><code>moveq (%rcx),%rax</code></li>
</ul>
</li>
<li>$M[Imm+R[r_b]]$ 是 基址+偏移量 寻址。寄存器指定了一段内存空间，然后 $Imm$ 表明了偏移量<ul>
<li><code>move 8(%rbp),%rdx</code> </li>
</ul>
</li>
<li>$M[R[r_b]+R[r_i]]$ 变址寻址 </li>
<li>$M[R[r_b]+R[r_i]+Imm]$ 变址寻址</li>
</ul>
<p>最后一行是 $M[Imm+R[r_b]+R[r_i]\cdot s]$</p>
<p>$IMM$ 就代表着 偏移数，1，2或者4个字节</p>
<p>$r_b$ 就是基址：任意一个寄存器</p>
<p>$r_i$ 是变址寄存器</p>
<p>s是比例因子，必须是1、2、4或者8</p>
<p>比如说，对于 $2(\%rsp,\%rax,4)$ 这个操作数来讲，它代表的是内存地址为 $2+\%rsp+4\cdot \%rax$  的存储器区域的值。</p>
<p>练习</p>
<p>比如说 现在 $\%rdx$中的数字为 $0xf000$ ,$\%rcx$ 中的数字为 $0x0100$ ,我们可以做一个这样的表格</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Expression</th>
<th>Address Computation</th>
<th>Address</th>
</tr>
</thead>
<tbody>
<tr>
<td>$0x8(\%rdx)$</td>
<td>0xf000+0x8</td>
<td>0xf008</td>
</tr>
<tr>
<td>$(\%rdx,\%rcx)$</td>
<td>0xf000+0x100</td>
<td>0xf100</td>
</tr>
<tr>
<td>$(\%rdx,\%rcx,4)$</td>
<td>0xf000+4*0x100</td>
<td>0xf400</td>
</tr>
<tr>
<td>$0x80(,rdx,2)$</td>
<td>2*0xf000+0x80</td>
<td>0x1e080</td>
</tr>
</tbody>
</table>
</div>
<h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p>下图列出了形式最简单的数据传送指令 $MOV$ 类。这些指令把数据从原位置复制到目的位置而不做任何变化。</p>
<p>MOV跟着的后缀不同，则指令可操作的数据大小也不同。</p>
<p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/5.png" style="zoom: 120%;"></p>
<p>源操作数指定的值是一个立即数，存储在寄存器或者内存中。</p>
<p>目的操作数指定一个位置们要么是一个寄存器地址要么是一个内存地址。</p>
<p>x86-64规定传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令：第一条指令将源值加载到寄存器中，第二条将该寄存器值写入目的位置。</p>
<p>这些指令的寄存器可以是16个寄存器有标号部分中的任意一个，寄存器部分的大小必须和指令的后缀(bwlq) 指定的大小相匹配。</p>
<p>有一个例外，当<code>movl</code>指令以寄存器位目的时，它会把该寄存器的高位4字节设置为0。这是因为x86-64采用的任何寄存器生成32位值都会把该寄存器的高位部分设置为0这一惯例。</p>
<p>例子：</p>
<p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/6.png" style="zoom: 120%;"></p>
<p>第一个是源操作数(source)，第二个是目的操作数(destination).</p>
<ul>
<li>第一行就是将一个立即数放到寄存器当中，长度为4个字节</li>
<li>第二行是将寄存器转移到寄存器当中，长度为2个字节</li>
<li>第三行是将内存中的数据转移到寄存器当中，长度为1个字节</li>
<li>第四行是将立即数存储到内存当中，长度为1个字节</li>
<li>第五行是将寄存器中的数存到内存当中，长度为8个字节</li>
</ul>
<p>下面两张表格记录的是两类移动指令，是当将较小的源值复制到较大的目的时使用的。</p>
<p>MOVZ类中的指令是在复制到寄存器后将剩余的字节填充为0</p>
<p>MOVS类中的指令则是通过符号扩展来填充，把源操作数的最高位进行赋值。</p>
<p>我们可以看到每条指令名字的后两个字符都是大小指示符，第一个字符指定源的大小，而第二个指明destination的大小</p>
<p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/7.png" style="zoom: 100%;"></p>
<p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/8.png" style="zoom: 130%;"></p>
<p>注意：cltq指令没有操作数，它总是以寄存器$\%eax$ 作为源，$\%rax$ 作为符号扩展结果的目的。它的效果与指令$moveslq~~ \%eax,\%rax$  完全一致，不过编码更紧凑。</p>
<h4 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h4><p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/18.png" style="zoom: 130%;"></p>
<p>我们知道，两个地址之间不能传值.操作指令的后缀取决于寄存器的大小: 两个寄存器之间如果要传值必须要保证两个寄存器的位数大小相同。地址和寄存器之间传递数据，指令后缀取决于寄存器。</p>
<ol>
<li>因为从%eax 传向 地址，所以后缀和 %eax相匹配，为 <code>movl</code></li>
<li>因为从地址传向 %dx ,所以后缀和 %dx 相匹配，为 <code>movw</code></li>
<li>因为从地址传向 %bl，所以后缀和 %bl 匹配，为 <code>movb</code></li>
<li>同上,为 <code>movb</code></li>
<li>从地址传向 %rax，所以后缀和%rax相匹配，为 <code>movq</code></li>
<li>从%dx传向地址，和%dx相匹配，为 <code>movw</code></li>
</ol>
<p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/19.png" style="zoom: 130%;"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>错误之处</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%bx</code>系列寄存器时被调用者保存的寄存器，不能拿来当成地址</td>
</tr>
<tr>
<td><code>%rax</code>是64位的寄存器，而<code>movl</code>匹配的是32位的寄存器，应该改为 <code>movq</code></td>
</tr>
<tr>
<td>不能在两个地址之间传递数据</td>
</tr>
<tr>
<td>没有<code>%sl</code>这个名字的寄存器</td>
</tr>
<tr>
<td>不能将寄存器中的数据移动给一个 <code>Immediate</code>(直接值)</td>
</tr>
<tr>
<td>在两个寄存器之间传递值的时候，两个寄存器的大小要保持相等</td>
</tr>
<tr>
<td><code>%si</code> 是16位寄存器，而 <code>movb</code>匹配的是8位寄存器，应该改为 <code>movw</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="数据传送示例"><a href="#数据传送示例" class="headerlink" title="数据传送示例"></a>数据传送示例</h3><p>我们现在来考虑一个exchange代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">exchange</span><span class="params">(<span class="keyword">long</span> *xp, <span class="keyword">long</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> x = *xp;</span><br><span class="line">    *xp = y;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后看看这个函数的汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">long exchange(long *xp, long y)</span><br><span class="line">xp in %rdi, y in %rsi</span><br><span class="line">exchange:</span><br><span class="line">	 movq 	(%rdi), %rax 		Get x at xp. Set as return value.</span><br><span class="line">	 movq 	%rsi, (%rdi) 		Store y at xp.</span><br><span class="line">	 ret 						Return.</span><br></pre></td></tr></table></figure>
<p>我们看到函数exchange由三条指令实现：两个数据传送(movq) 加上一条返回函数被调用点的指令(ret)</p>
<p>当过程开始时，参数xp和y分别存储在 $\%rdi$ 和$\%rsi$ 中。然后，指令2从内存中读出xp指向的x，将其存到寄存器$\%rax$ 中，直接实现了C程序中的操作 $x=*xp$ 。然后用 $\%rax$ 从这个函数返回一个值，因而返回的值就是x</p>
<p>指令3将y写入到寄存器$\%rdi$ 中的 $xp$ 指向的内存位置，直接实现了操作 $*xp=y$ 这个例子说明了如何用 $MOV$ 指令从内存中读值到寄存器，如何从寄存器写到内存当中。</p>
<p>我们要注意两点</p>
<ul>
<li>C语言中所谓的指针其实就是地址。简介引用指针就是将指针放在一个寄存器中，然后在内存引用中使用这个寄存器</li>
<li>像x这样的局部变量常常是保存在寄存器当中而不是内存中。访问寄存器比访问内存要快得多</li>
</ul>
<p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/20.png" style="zoom: 130%;"></p>
<p>这道题要注意几个点:</p>
<ul>
<li>高位转向低位(如 int 转成 char; unsigned 转换为 unsigned char)  不需要用 <code>movzbl,movsbl</code>之类的命令，直接将后几位移动到相应大小的寄存器即可</li>
<li>低位转为高位，需要进行符号扩展或零扩展；选择那种扩展取决于源数据的数据类型。比如<strong>源数据是char，转换为unsigned</strong>，那么就要用<code>movsbl</code>来进行符号扩展； 如果<strong>原来是unsigned char 要转换为long类型</strong>，那么就要用 <code>movzbl</code> 来 进行 零扩展。</li>
</ul>
<p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/21.png" style="zoom: 130%;"></p>
<p><code>%r8,%rcx,%rax</code>是三个新的变量，我们不妨将其命名为x,y,z</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decode1</span><span class="params">(<span class="keyword">long</span> *xp,<span class="keyword">long</span> *yp,<span class="keyword">long</span> *zp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x = *xp;</span><br><span class="line">	y = *yp</span><br><span class="line">	z = *zp;</span><br><span class="line">	*yp = x;</span><br><span class="line">	*zp = y;</span><br><span class="line">	*xp = z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="压入和弹出栈数据"><a href="#压入和弹出栈数据" class="headerlink" title="压入和弹出栈数据"></a>压入和弹出栈数据</h3><p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/9.png" style="zoom: 130%;"></p>
<p>pushq指令的功能就是把数据压入到栈上，而popq指令是弹出数据。这些指令都只有一个操作数-压入的数据源 和 弹出的数据目的</p>
<p>将一个四字值压入栈中，<strong>首先要将栈指针减去8</strong>，然后<strong>将值写到新的栈顶地址</strong>。因此指令 $pushq ~~\%rbp$ 的行为<strong>等价于</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subq $8,%rsp</span><br><span class="line">movq %rbp,(%rsp)</span><br></pre></td></tr></table></figure>
<p>只是前面的 $pushq ~~\%rbp$  只是一个字节，而后面两条指令一共需要8个字节。</p>
<p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/10.png" style="zoom: 130%;"></p>
<p>上图的最右边说得是在pushq后立即执行指令 popq %rdx 的效果。先从内存中读取值 0x123,再写道寄存器 $\%rdx$ 中，然后，寄存器 $\%rsp$ 的值将从 0x100增加到 0x108 . 如图，值0x123仍然会保存在内存位置 $0x100$ 中，直到被覆盖。无论如何，$\% rsp$ 指向的地址总是栈顶。</p>
<p>因为栈和程序代码以及其他形式的程序数据都是放在同一内存中，所以程序可以用标准的内存寻址方法访问栈内的任意位置。例如，假设栈顶元素是四字，指令movq 8(rsp),%rdx  会将第二个四字<strong>从栈中复制到寄存器</strong> %rdx</p>
<h2 id="算数和逻辑操作"><a href="#算数和逻辑操作" class="headerlink" title="算数和逻辑操作"></a>算数和逻辑操作</h2><p>下面是一些整数和逻辑操作。大多数操作分成了指令类，这些指令类有各种带不同大小操作数的变种(除了leaq外）。 例如ADD由四条加法指令 addb、addw、addl、addq 组成。</p>
<p>事实上给出的每个指令类都有对这四种大小不同的数据的指令。这些操作被分为四组：加载有效地址、一元操作、二元操作和移位。二元操作有两个操作数，而一元操作有一个操作数。</p>
<p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/11.png" style="zoom: 100%;"></p>
<h3 id="加载有效地址"><a href="#加载有效地址" class="headerlink" title="加载有效地址"></a>加载有效地址</h3><p>load effective address(加载有效地址)指令leaq 实际上是 movq的变形。</p>
<p><code>leaq src,Dst</code></p>
<ul>
<li>Src is address mode expression</li>
<li>Set Dst to address denoted by expression</li>
</ul>
<p><code>leaq</code>主要用来简洁的描述普通的算术操作。例如如果寄存器 $\%rdx$ 的值为x，那么指令 $leaq ~~7(\%rdx,\%rdx,4),\%rax$ 将设置寄存器 $\%rax$ 的值为 $5x+7$ ,编译器经常发现 <code>leaq</code> 的一些灵活用法，根本和有效地址计算无关</p>
<p>比如下面这个C程序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">scale</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y, <span class="keyword">long</span> z)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> t = x + <span class="number">4</span> * y + <span class="number">12</span> * z;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译成汇编语言的到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">long scale(long x, long y, long z)</span><br><span class="line">x in %rdi, y in %rsi, z in %rdx</span><br><span class="line">scale:</span><br><span class="line">leaq (%rdi,%rsi,4), %rax 	x + 4*y</span><br><span class="line">leaq (%rdx,%rdx,2), %rdx 	z + 2*z &#x3D; 3*z</span><br><span class="line">leaq (%rax,%rdx,4), %rax 	(x+4*y) + 4*(3*z) &#x3D; x + 4*y + 12*z</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>leaq 能执行加法和有限形式的乘法，在编译如上简单的算术表达式时，是很有用处的。</p>
<h3 id="一元和二元操作"><a href="#一元和二元操作" class="headerlink" title="一元和二元操作"></a>一元和二元操作</h3><p>这一组操作是一元操作，只有一个操作数，既是源又是目的。这个操作数可以实寄存器也可以是一个内存位置。</p>
<p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/12.png" style="zoom: 100%;"></p>
<p>第三组是二元操作，其中，第二个操作数既是源又是目的。这种语法让人想起C 语言中的赋值运算符，例如x-=y。 不过，要注意，源操作数是第一个，目的操作数是第二个, 对于不可交换操作来说，这看上去很奇特。例如，指令<code>subq%rax,%rdx</code> 使寄存器<code>%rdx</code>的值减去<code>％rax</code> 中的值。（将指令解成”从<code>%rdx</code> 中减去<code>％rax</code>” 会有所帮助。）第一个操作数可以是立即数、寄存器或是内存位置。第二个操作数可以是寄存器或是内存位置。注意，当第二个操作数为内存地址时，处理器必须从内存读出值，执行操作，再把结果写回内存.</p>
<p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/13.png" style="zoom: 100%;"></p>
<h3 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h3><p>最后一组是移位操作，先给出移位量，然后第二项给出的是要移位的数。可以进行算术和逻辑右移。移位量可以是一个立即数，或者放在单字节寄存器％cl 中。（这些指令很特别，因为<strong>只允许</strong>以这个特定的寄存器作为操作数。）原则上来说，1 个字节的移位量使得移位量的编码范围可以达到$2^8-1= 255$。X86-64 中，移位操作对w 位长的数据值进行操作，移位量是由％cl 寄存器的低m 位决定的，这里$2^m=w$ 高位会被忽略。所以，例如当寄存器％cl 的十六进制值为OxFF 时，指令salb 会移7 位，salw 会移15 位，sail 会移31 位，而salq 会移63 位。<br>如下图所示，左移指令有两个名字：SAL 和SHL。两者的效果是一样的，都是将右边填上0。右移指令不同，SAR 执行算术移位（填上符号位）, 而SHR 执行逻辑移位（填上0）。</p>
<p>移位操作的目的操作数可以是一个寄存器或是一个内存位置。图 3-10 中用$&gt;&gt;_A$(算术)和$&gt;&gt;_L$(逻辑）来表示这两种不同的右移运算。</p>
<p><img src="/2020/09/24/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA1/22.png" style="zoom: 100%;"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/09/23/git%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/23/git%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">git基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-23 08:28:09" itemprop="dateCreated datePublished" datetime="2020-09-23T08:28:09+08:00">2020-09-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-30 09:33:26" itemprop="dateModified" datetime="2020-09-30T09:33:26+08:00">2020-09-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="git基础"><a href="#git基础" class="headerlink" title="git基础"></a>git基础</h1><p>git使世界上最受欢迎的版本控制系统，版本控制系统记录随着时间的推移对我们的代码所做的更改。他能知道谁在何时何地进行了那些修改。如果我们有一个版本搞砸了，我们可以轻松地将项目还原到之前的版本。在早期，没有这种版本控制系统，我们不得不不断地以各种方式存储整个项目的副本——这会严重地降低效率尤其是多个人在同一个项目上工作时。</p>
<p>版本控制系统分为2类：分布式和集中式。在集中式系统中，所有人必须连接到中央服务器获取代码的最新副本。比如说 Subversion和Team Foundation Server 。但集中式版本控制系统的问题就是服务器必须在线，否则我们将无法协作</p>
<p>在分布式系统中，我们就能很好的规避这些问题。因为每个团队成员都有一个项目副本及其历史记录。如果我们的中央服务器离线了，我们可以直接与他人同步我们的工作。比如Git和Mercurial</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/1.png" style="zoom: 80%;"></p>
<p>git是这些版本控制器中最流行的，因为git 免费开源，速度快且可扩展。并对分支合并操作十分友好。</p>
<p>那么怎么使用Git呢？</p>
<ul>
<li>我们可以在命令行上使用 Git，也就是在终端或者CMD上使用。</li>
<li>我们可以在代码编辑器或者IDE上的终端使用</li>
<li>Git有自身的GUI可以使用</li>
<li>第三方软件GitKraken、Sourcetree等 GUI (但是我们主要还是使用命令行因为有些远程服务器上不方便安装GUI，使用命令行会更快、更方便)</li>
</ul>
<p>在使用git之前，我们要设置一些信息</p>
<ul>
<li>名字</li>
<li>Email</li>
<li>Default Editor</li>
<li>Line Ending</li>
</ul>
<p>我们可以为三个不同层级设置这些信息</p>
<ul>
<li>System 最高级 面向所有的用户</li>
<li>Global 适用于当前用户的所有repositories</li>
<li>Local 当前repository</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;名字&quot;</span><br><span class="line">git config --global user.email 邮箱</span><br></pre></td></tr></table></figure>
<p>这两行是设置global邮箱和名字的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.editor &quot;code --wait&quot;</span><br></pre></td></tr></table></figure>
<p>这一行是用来告诉终端窗口在我们关闭 vs code界面之前保持等待。在gitbash 中输入code，就会自动跳转至 vsc </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global -e</span><br></pre></td></tr></table></figure>
<p>这行代码是用来看全局配置的.输入以后vscode会跳出一个 .gitconfig文件。</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/2.png" style="zoom: 120%;"></p>
<p>我们还需要设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf true</span><br></pre></td></tr></table></figure>
<p>这是因为不同操作系统下，处理行尾结束符的方法是不同的</p>
<p>首先了解回车和换行</p>
<p><strong>LF：Line Feed 换行</strong></p>
<p><strong>CRLF：Carriage Return Line Feed 回车换行键</strong> </p>
<ul>
<li>　windows下：CRLF（表示句尾使用回车换行两个字符，即windows下的”\r\n”换行）</li>
<li>​    unix下：LF（表示句尾，只使用换行）</li>
<li>​    mac下：CR（表示只使用回车）</li>
</ul>
<p>在git下处理换行有三种情况：</p>
<ul>
<li>设置为true<ul>
<li>当设置成true时，这意味着你在任何时候添加(add)文件到git仓库时，git都会视为它是一个文本文件(text file)。它将把CRLF变成LF。当有人check代码的时候，又会将LF变成CRLF。所以在 windows下使用这个模式。</li>
</ul>
</li>
<li>设置为false<ul>
<li>当设置成false时，line endings将不做转换操作。文本文件保持原来的样子。</li>
</ul>
</li>
<li>设置为input<ul>
<li>添加文件git仓库时，git把CRLF变成LF。当有人check代码的时候还是 LF 方式。因此在window操作系统下，不要使用这个设置。而mac使用这个模式。</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/3.png" style="zoom: 100%;"></p>
<h3 id="Getting-Help"><a href="#Getting-Help" class="headerlink" title="Getting Help"></a>Getting Help</h3><p>这是 git -config 的文档。</p>
<p><a href="https://git-scm.com/docs/git-config" target="_blank" rel="noopener">https://git-scm.com/docs/git-config</a></p>
<p>或者使用 git config  —help 来查看这个文档</p>
<p>git config -h 则会显示一个比较简短的总结。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">usage: git config [&lt;options&gt;]</span><br><span class="line"></span><br><span class="line">Config file location</span><br><span class="line">    --global              use global config file</span><br><span class="line">    --system              use system config file</span><br><span class="line">    --local               use repository config file</span><br><span class="line">    -f, --file &lt;file&gt;     use given config file</span><br><span class="line">    --blob &lt;blob-id&gt;      read config from given blob object</span><br><span class="line"></span><br><span class="line">Action</span><br><span class="line">    --get                 get value: name [value-regex]</span><br><span class="line">    --get-all             get all values: key [value-regex]</span><br><span class="line">    --get-regexp          get values for regexp: name-regex [value-regex]</span><br><span class="line">    --get-urlmatch        get value specific for the URL: section[.var] URL</span><br><span class="line">    --replace-all         replace all matching variables: name value [value_regex]</span><br><span class="line">    --add                 add a new variable: name value</span><br><span class="line">    --unset               remove a variable: name [value-regex]</span><br><span class="line">    --unset-all           remove all matches: name [value-regex]</span><br><span class="line">    --rename-section      rename section: old-name new-name</span><br><span class="line">    --remove-section      remove a section: name</span><br><span class="line">    -l, --list            list all</span><br><span class="line">    -e, --edit            open an editor</span><br><span class="line">    --get-color           find the color configured: slot [default]</span><br><span class="line">    --get-colorbool       find the color setting: slot [stdout-is-tty]</span><br><span class="line"></span><br><span class="line">Type</span><br><span class="line">    -t, --type &lt;&gt;         value is given this type</span><br><span class="line">    --bool                value is &quot;true&quot; or &quot;false&quot;</span><br><span class="line">    --int                 value is decimal number</span><br><span class="line">    --bool-or-int         value is --bool or --int</span><br><span class="line">    --path                value is a path (file or directory name)</span><br><span class="line">    --expiry-date         value is an expiry date</span><br><span class="line"></span><br><span class="line">Other</span><br><span class="line">    -z, --null            terminate values with NUL byte</span><br><span class="line">    --name-only           show variable names only</span><br><span class="line">    --includes            respect include directives on lookup</span><br><span class="line">    --show-origin         show origin of config (file, standard input, blob, command line)</span><br><span class="line">    --default &lt;value&gt;     with --get, use default value when missing entry</span><br></pre></td></tr></table></figure>
<h2 id="Creating-Snapshots"><a href="#Creating-Snapshots" class="headerlink" title="Creating Snapshots"></a>Creating Snapshots</h2><h3 id="Initializing-a-repository"><a href="#Initializing-a-repository" class="headerlink" title="Initializing a  repository"></a>Initializing a  repository</h3><p>我们现在要做的是为我们的project创建一个目录。</p>
<p>我们新建一个文件夹：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir moon</span><br></pre></td></tr></table></figure>
<p>然后再 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>就是在这个文件夹中新建了一个仓库。在win下就显示为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jason@JasonsT90 MINGW64 &#x2F;d&#x2F;projects&#x2F;moon (master)</span><br></pre></td></tr></table></figure>
<h3 id="Git-Workflow"><a href="#Git-Workflow" class="headerlink" title="Git Workflow"></a>Git Workflow</h3><p>现在来介绍一下 Git的工作流程</p>
<p>左边是我们的文件夹，最右边的是Git的仓库。在Git中有一个很多其他版本控制器没有的Staging Area。</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/4.png" style="zoom: 100%;"></p>
<p>当我们对一些文件作出修改之后，我们会将文件暂存在Staging Area中，等确认无误之后，我们才会对Staging Area中的文件进行一个snapshot ,将他们永久的保存在repository当中。有了这个机制之后，我们就能反复确认是否有不应该出现的改变。然后就可以在舍弃这些内容</p>
<p>下面是一个真实的例子，我们有两个文件file1和file2，我们首先将他们放在staging Area中，确认无误后我们递交一个commit,也就是初次提交：<code>git commit -m &quot;Initial commit&quot;</code> </p>
<p>以后，我们将如果修复了bugs、重构了代码，就在第一次的基础之上commit</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/5.png" style="zoom: 100%;"></p>
<p>我们会有一个错误的观念：提交了commit之后staging area就会清空。实际上并不是这样，staging area中的文件仍然是保留的。所以我们可以这样理解：再递交了commit之后， repository 中的文件和staging area中的文件是一模一样的(没递交之前可能有差别，因为staging area中的文件会有更新)</p>
<p>然后我们修改了一个文件 file1 通过代码<code>git add files1</code>将修改后的文件更新至staging area然后再git commit来提交第二个版本，备注了 ”Fixed the bug that…”</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/6.png" style="zoom: 100%;"></p>
<p>现在我们删除本地的 file2文件，再通过<code>git add file2</code>更新至staging area，我们会感到很奇怪，明明是要做删除，但是为什么用 <code>git add file2</code> 呢？ 这是因为git会自动检测 file2 是否在本地。因为本地没有file2，所以在staging area中的file也会删除。这里的add更偏向于更新的意思，而不是单纯的添加。</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/7.png" style="zoom: 100%;"></p>
<p>现在我们的repository中有3个commit了，每一个commit包含了一个git生成的独一无二的ID以及其他信息</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/8.png" style="zoom: 100%;"></p>
<p>我们也许会感到很奇怪git能保存下所有的snapshot，那不会非常消耗内存嘛？实际上 git的内存管理是非常有效的。这是因为git会压缩内容并且不存储重复的内容</p>
<h3 id="Staging-Files"><a href="#Staging-Files" class="headerlink" title="Staging Files"></a>Staging Files</h3><p>我们先创建两个文件 file1和file2，<code>echo hello&gt;&gt;file1.txt</code> 然后利用 git status查看现在的状态。我们发现现在没有commits，现在两个文件也是untracked的。也就是说，现在staging area中还没有文件</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/10.png" style="zoom:120%;"></p>
<p>我们可以使用 git add file1.txt  file2.txt 来添加这两个文件</p>
<p>也可以 git add *.txt 来添加所有扩展名为 txt 的文件。</p>
<p>当然，我们也可以直接 add . 来添加所有文件。但是对这行命令需要注意，因为有些大文件可能是我们不想要的。而且如果递交了大文件有可能会出错。</p>
<p>我们这里只有两个文件，所以我们用 git add . 即可<br>然后我们看看 git status ,我们发现刚才没有 的文件变成了绿色，说明已经被添加至staging area当中了</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/9.png" style="zoom: 100%;">、</p>
<p>现在我们使用 echo 来对file1.txt进行修改， <code>echo world&gt;&gt;file1.txt</code> 再用 git status 查看状态。</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/11.png" style="zoom: 120%;"></p>
<p>我们发现有两个file已经在staging area中了，但是还有一个已经修改过的文件没有提交给 staging area。现在的状态就如下图所示：本地有更新，但是staging area中的文件还未被更新</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/12.png" style="zoom: 100%;"></p>
<p>那么我们敲入 <code>git add .</code>并再次查看状态，发现刚刚修改的文件已经躺在staging area中了</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/13.png" style="zoom: 100%;"></p>
<h3 id="Committing-Changes"><a href="#Committing-Changes" class="headerlink" title="Committing Changes"></a>Committing Changes</h3><p>现在 staging  area保存了我们的文件，然后我们利用 commit 命令来将这些文件交给repository</p>
<p>我们可以用 <code>git commit -m &quot;description&quot;</code> 来提交。有时候短短一行description是不够的(修复 bugs)，我们可以 直接 <code>git commit</code> 然后 git bash 会唤醒 vscode，我们可以在vscode中做更为详细的描述</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/14.png" style="zoom: 100%;"></p>
<p>保存关闭之后，gitbash就会成功commit</p>
<h3 id="Committing-Best-Practices"><a href="#Committing-Best-Practices" class="headerlink" title="Committing Best Practices"></a>Committing Best Practices</h3><p>我们每次commit的代码不要太大或者太小：也就是说不要修改一次代码就commit一次或者写了好几天代码才commit一次，这都不太好。我们要保持一个合理的更新频率(大工作量下每天5-10次)，因为如果我们发现了一些严重问题我们还能够”读档“，”回滚“</p>
<p>而且我们要做到不把两个可以解决的问题放到一个commit当中，比如我现在修复了一个bug，又发现一个排版错误，我们不能把这两个问题合并起来commit 一次。而要分两次commit。</p>
<p>此外我们还要养成对每次commit创建有意义的commit messages(description) 。因为这些信息会显示commit的信息和历史。对未来版本的回退等会更加友好。</p>
<h3 id="Skipping-the-Staging-Area"><a href="#Skipping-the-Staging-Area" class="headerlink" title="Skipping the Staging Area"></a>Skipping the Staging Area</h3><p>我们初学者常常会问，我们一定要每次把我们修改过后的文件放在staging area后才能commit嘛？</p>
<p>事实上我们不必要，我们可以跳过 staging agea直接commit。但做这个行为之前我们必须百分之百保证我们的代码没有问题。</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/15.png" style="zoom: 100%;"></p>
<p>我们可以用命令行 </p>
<p><code>git commit -am &quot;Fix the bug that prevented the users from signing up&quot;</code></p>
<p>-am 也可以写成 -a -m : -a 代表着all，-m 代表 message</p>
<h3 id="Removing-Files"><a href="#Removing-Files" class="headerlink" title="Removing Files"></a>Removing Files</h3><p>有时候我们想删除我们不想要的代码，于是我们需要删除一些文件。</p>
<p>先利用 <code>rm file2.txt</code> 删除 file2.txt，然后我们利用 git ls-files 看看现在 staging area中的文件 :</p>
<p>因为没有更新，所以现在staging area中还是有两个文件。</p>
<p>现在我们 <code>git add file2.txt</code> 再次 git ls-files ，这时候staging area中就只存在一个文件 file1.txt 了</p>
<p>当然，除了  <code>rm file2.txt</code> 之外，我们可以用 <code>git rm file2.txt</code> 直接将本地文件夹和staging area中的file2.txt删除。 <code>git rm</code> 和<code>git add</code>后面都可以跟多个文件或者模板</p>
<h3 id="Renaming-or-Moving-Files"><a href="#Renaming-or-Moving-Files" class="headerlink" title="Renaming or Moving Files"></a>Renaming or Moving Files</h3><p>和 删除文件类似，重命名文件或者是移动文件(切换文件类型) 也有两种方式</p>
<p>第一种是用Unix代码 <code>mv file1.txt main.js</code>  将 file1.txt 转换成main.js 。这时候我们查看git status。我们发现file1.txt已经被删除了，而新增了一个文件main.js. 而这个文件还没有被放进staging area，是untracked的。</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/18.png" style="zoom: 100%;"></p>
<p>我们需要 <code>git add main.js</code> 将文件放入到 staging area当中</p>
<p>第二种方法就是git自己的命令 <code>git mv main.js file1.js</code>  再次查看 git status 我们发现git会直接在本地和staging area同时更新</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/19.png" style="zoom: 130%;"></p>
<h3 id="Ignoring-Files"><a href="#Ignoring-Files" class="headerlink" title="Ignoring Files"></a>Ignoring Files</h3><p>在很多的项目中，我们需要告诉git有些文件需要被忽略。比如日志文件或者机密二进制文件等。我们能通过一些命令来实现。</p>
<p>首先我们新建一个文件夹并在里面写一个log文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir logs</span><br><span class="line">echo hello&gt;logs&#x2F;dev.log</span><br></pre></td></tr></table></figure>
<p>然后我们需要告诉git忽略logs中的文件：</p>
<p>有一个专门的文件叫做 <code>.gitignore</code> 在这个文档里面记录的文件名都不会被git放到staging area中</p>
<p>我们可以通过命令<code>echo logs/ &gt; .gitignore</code>  让logs这个文件夹的内容全部处于被忽略状态</p>
<p>利用 <code>code .gitignore</code> 可以在vscode 中打开 .gitignore</p>
<p>我们也可以手动向<code>.gitignore</code> 中添加我们希望git要忽略的文件。比如 <code>main.log</code> 或者 <code>*.log</code> 等。最后我们需要将<code>.gitignore</code> 加入到staging area 中，再commit之后发现 logs文件夹确实没有被加入进来。</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/20.png" style="zoom: 100%;"></p>
<p>但是需要注意得是，<code>.gitignore</code> 只能对于并不在repository中的文件有效。如果有一个文件已经在repository中了，然后再将他添加到 <code>.gitignore</code> 中去，这是无效的。</p>
<p>下面我们来操作一下：</p>
<p>首先将bin文件夹和里面的一个hello.bin 文件commit到 repository当中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir bin</span><br><span class="line">echo hello &gt; bin &#x2F;hello.bin</span><br><span class="line">git add.</span><br><span class="line">git commit -m &quot;Add bin.&quot;</span><br></pre></td></tr></table></figure>
<p>我们再 <code>.gitignore</code> 中将 <code>bin/</code> 加入并 commit</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;Include bin&#x2F; in gitignore&quot;</span><br></pre></td></tr></table></figure>
<p>现在我们修改<code>hello.bin</code> ，再新建一个<code>app.bin</code>文件。git status 之后,会发现git竟仍然追踪者 bin中的<code>hello.bin</code>文件但是并不会追踪在bin中的新建的 <code>app.bin</code> 文件。</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/21.png" style="zoom: 100%;"></p>
<p>为了解决这个问题，我们需要删除躺在 staging area当中的bin文件夹。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached -r bin&#x2F;</span><br></pre></td></tr></table></figure>
<p>—cached代表着删除的范围是 staging  area， -r是删除文件夹的命令。 <code>git status</code> 之后，发现在staging area中的hello.bin 就被删除了(本地文件没有被删除！)</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/22.png" style="zoom: 100%;"></p>
<p>如果我们再次修改bin中的  <code>hello.bin</code> 文件，git也不会再追踪bin中的文件了。</p>
<h3 id="Short-Status"><a href="#Short-Status" class="headerlink" title="Short Status"></a>Short Status</h3><p>我们修改和新建一些文件，然后 <code>git status</code> 发现文字很多，看起来比较繁杂。我们可以利用 命令<code>git status -s</code> 来精简化它们</p>
<p>我们看到精简过后的status只有两行 。这两行也很容易理解，M files1.js 代表files1.js 被Modified了，而 ?? file2.js 说明file2.js 是未被追踪的。</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/23.png" style="zoom: 100%;"></p>
<h3 id="Viewing-Staged-and-Unstaged-Changes"><a href="#Viewing-Staged-and-Unstaged-Changes" class="headerlink" title="Viewing Staged and Unstaged Changes"></a>Viewing Staged and Unstaged Changes</h3><p>在我们将staging area 中的文件提交之前，我们需要再三回顾我们的代码，因为我们不想把有瑕疵的代码提交。那么我们怎么能看到在staging area当中的一行行代码2呢？ 我们需要使用diff命令</p>
<p><code>git diff --staged</code> </p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/24.png" style="zoom: 100%;"></p>
<p>我们发现这样的文档是比较难阅读的。一般我们会用 GUI 来运行diff命令。我们现在看看怎么来阅读这些文档</p>
<p>我们看到第一行是  diff —git a/file1.js b/file2.js ,说明我们能在比较同一份文件不同拷贝的内容差别。a是比较早的copy，b是比较新的copy(现在存放在staging area当中的copy )</p>
<p><code>@@ -1,3 +1,5 @@</code> 告诉我们那里发生了改变  负号代表了旧的copy，正号代表了新的copy</p>
<p>1,3 代表从第一行开始，一共三行；1,5 代表从第一行开始一共五行</p>
<p>对于 file2.js 文件，因为这是新建的，所以显示为 —- /dev/null  即不存在老的copy</p>
<p>那么如何看本地文件的修改内容呢？ 还是用 diff 命令，不过 这次命令变为 <code>diff --git</code></p>
<h3 id="Visual-Diff-Tools"><a href="#Visual-Diff-Tools" class="headerlink" title="Visual Diff Tools"></a>Visual Diff Tools</h3><p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/25.png" style="zoom: 100%;"></p>
<p>我们使用vscode来查看diff命令。首先我们来做一些设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global diff.tool vscode</span><br><span class="line">git config --global difftool.vscode.cmd &quot;code --wait --diff $LOCAL $REMOTE&quot;</span><br></pre></td></tr></table></figure>
<p>第一行命令是让我们将difftool设置为vscode 并对所有的repository适用</p>
<p>第二行命令是告诉git怎么唤醒vscode帮助我们diff文件。—wait 告诉终端保持等待状态直到我们关闭vscode为止，$LOCAL 和 $REMOTE 则代表了老的copy和新的copy</p>
<p>然后我们用 <code>git config --global -e</code> 打开vscode</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/26.png" style="zoom: 100%;"></p>
<p>我们发现diff 后面并没有$LOCAL 和 $REMOTE我们再把他补全</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/27.png" style="zoom: 100%;"></p>
<p>然后我们用 <code>git difftool --staged</code> 来让vscode充当我们的diff工具</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/30.png" style="zoom: 100%;"></p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/28.png" style="zoom: 100%;"></p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/29.png" style="zoom: 100%;"></p>
<p>但是现如今使用Diff工具的机会不多，大多数编辑器或者IDE都支持查看 staged 和 unstaged changes</p>
<h3 id="Viewing-History"><a href="#Viewing-History" class="headerlink" title="Viewing History"></a>Viewing History</h3><p>我们已经commit不少次了，那么我们怎么才能看这些commit的信息呢？</p>
<p>使用命令 <code>git log</code></p>
<p>如果觉得信息太繁杂，我们可以使用命令 <code>git log --oneline</code> </p>
<p>我们看到这个顺序是越上面的越晚提交。</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/31.png" style="zoom: 100%;"></p>
<p>如果我们想把最早递交的版本放到第一行，可以使用</p>
<p><code>git log --oneline --reverse</code></p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/32.png" style="zoom: 100%;"></p>
<h3 id="Viewing-a-Commit"><a href="#Viewing-a-Commit" class="headerlink" title="Viewing a Commit"></a>Viewing a Commit</h3><p>刚才我们看了整体递交的信息，但是如果我们想看看某一个特定commit所做的改变该怎么办呢？</p>
<p>我们看到在每个commit之前有一串序列。这就是这个commit的ID，我们用命令 <code>git show ID</code> 来查看这个commit的信息</p>
<p>如果我们只想看最后一次commit ，我们可以  <code>git show HEAD</code></p>
<p>或者我们想看倒数第n次的我们只要命令 <code>git show HEAD~n-1</code> 就行了</p>
<p>如果我们不想看commit更新了什么，我们只想看特定文件中的所有代码，我们可以再原来的基础上加上冒号和文件名即可。比如 <code>git show HEAD~1:.gitignore</code>  就是查看倒数第二次提交的 <code>.gitignore</code> 文件。</p>
<p>我们也可以使用 <code>git ls-tree</code> 来查看一个commit中的所有文件</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/33.png" style="zoom: 100%;"></p>
<p>我们看到在这个commit当中有三个Objects，两个文件和一个bin文件夹</p>
<p>git 有四种类型的Objects</p>
<ul>
<li>Commits</li>
<li>Blobs(Files)</li>
<li>Trees(Directories)</li>
<li>Tags</li>
</ul>
<h3 id="Unstaging-Files"><a href="#Unstaging-Files" class="headerlink" title="Unstaging Files"></a>Unstaging Files</h3><p>在 git add . 之后，我又修改了 file1.js ,那么现在的 status 就是一个绿色的M一个红色的M。现在我想撤回第一个 git add . 的命令，也就是将 file1.js 从staging area取出再放到本地。</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/35.png" style="zoom: 100%;"></p>
<p>我们可以使用 命令 <code>git restore --staged file1.js</code> 就可以了</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/36.png" style="zoom: 100%;"></p>
<p>如果我再 <code>git restore --staged file2.js</code> ，那么我们会发现file2也不会被git追踪了</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/37.png" style="zoom: 100%;"></p>
<h3 id="Discarding-Local-Changes"><a href="#Discarding-Local-Changes" class="headerlink" title="Discarding Local Changes"></a>Discarding Local Changes</h3><p>如果我们现在对本地文件进行了改变，但是发现这个改变有错误，想要取消。也可以用 restore命令来实现。其原理就是从 staging area中拷贝一份，再复制到 working directory</p>
<p><code>git restore file1.js</code></p>
<p>现在我们对本地的所有文件 执行命令 <code>git restore .</code> 却发现file2.js 这个问题。这是因为本来 file2.js 就不在staging area当中了。git不知道从哪里去复制。</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/38.png" style="zoom: 100%;">         </p>
<p>为了解决这个问题，我们可以使用 <code>git clean -fd</code> 来完成操作。这个操作其实就是将 file2.js 从我们的文件夹中删除。</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/39.png" style="zoom: 100%;">                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </p>
<h3 id="Restoring-a-File-to-an-Earlier-Version"><a href="#Restoring-a-File-to-an-Earlier-Version" class="headerlink" title="Restoring a File to an Earlier Version"></a>Restoring a File to an Earlier Version</h3><p>现在我们要演示一下如果我们误操作删除了一个本地文件，我们怎么利用git恢复到之前的版本。我们删除文件最好使用 <code>git rm</code> 因为git rm会将文件同时从staging area 和 working directory 中删除。</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/40.png" style="zoom: 100%;"></p>
<p>但是现在我发现这个文件是不该删除的！那么怎么回退呢？？</p>
<p>我们首先查看日志我们看到 ID为 6e72a9b 这个版本是我们要恢复的。</p>
<p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/41.png" style="zoom: 100%;"></p>
<p>回复命令如下：<code>usage: git restore [&lt;options&gt;] [--source=&lt;branch&gt;] &lt;file&gt;...</code> </p>
<p>我们用命令 <code>git restore --source=HEAD~1 file1.js</code> 来恢复从HEAD开始数上一个版本中的file1.js 文件。</p>
<h3 id="Creating-Snapshots-with-VScode"><a href="#Creating-Snapshots-with-VScode" class="headerlink" title="Creating Snapshots with VScode"></a>Creating Snapshots with VScode</h3><p><img src="/2020/09/23/git%E5%9F%BA%E7%A1%80/42.png" style="zoom: 100%;"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/" class="post-title-link" itemprop="url">CSAPP信息的表示和存储2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-17 18:48:14" itemprop="dateCreated datePublished" datetime="2020-09-17T18:48:14+08:00">2020-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-31 22:13:34" itemprop="dateModified" datetime="2021-01-31T22:13:34+08:00">2021-01-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CSAPP信息的表示和存储2"><a href="#CSAPP信息的表示和存储2" class="headerlink" title="CSAPP信息的表示和存储2"></a>CSAPP信息的表示和存储2</h1><h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><h3 id="无符号加法"><a href="#无符号加法" class="headerlink" title="无符号加法"></a>无符号加法</h3><p>当两个非负整数 x,y 满足 $0\leq x,y&lt; 2^w$ 。那么 $x+y$ 就有可能是一个w+1位数。比如一个四位的无符号整数的取值范围是0-15，但其和的范围是0~30. 我们要让无符号数之和仍然位w位，那么我们需要做数的截断。 </p>
<p>我们定义 一个运算 $+_w^u$ ，其操作是把整数 x+y <strong>截断</strong>为w位得到的结果，再把这个结果<strong>看作是一个无符号数</strong>。这可以被视为一种形式的模运算，对 $x+y$ 的位级表示，简单丢弃任何权重大于 $2^{w-1}$ 的位就可以了。比如考虑一个4位数字表示， $x=9$ 和 $y = 12$ 的位表示分别是 $[1001]$ 和 $[1100]$ 。他们的和是21，5位表示为$[10101]$ 但是如果丢弃最高位，我们就得到了 $[0101]$ 也就是说 十进制的值是5，这和21 mod 16 = 5 一致。</p>
<p>我们可以将操作 $+_w^u$ 这样描述</p>
<p>对满足 $0\leq x,y&lt; 2^w$ 的 x和y有：</p>
<p>$x<del>+_w^u</del> y =\begin{cases}x+y,x+y\leq 2^w ~~ 正常\ x+y-2^w,2^w\leq x+y&lt;2^{w+1}~~ 溢出\end{cases} $ </p>
<p>如下图，左边的 x+y  y映射到右边的无符号 w位的和 $x~+_w^u ~y$ 正常情况下 x+y 的值保持不变，而溢出的情况则是该和减去$2^w$ 后的结果。</p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/1.png" style="zoom: 150%;"></p>
<p>当执行 C程序时，不会将溢出作为错误而发信号。不过有的时候，我们可能希望判定是否发生了溢出</p>
<p>对在范围 $0\leq x,y\leq UMax_w $ 中的x和y， 令 $s=x~+_w^u ~y$ 。则对计算 s，当且仅当 $s&lt;x$ 时，发生了溢出。</p>
<p>比如说，在前面的示例中，我们看到 $9~+_4^u~12 = 5$. 由于 $5&lt;9$ ,我们可以看出发生了溢出。</p>
<h3 id="补码加法"><a href="#补码加法" class="headerlink" title="补码加法"></a>补码加法</h3><p>对于补码加法，我们必须确定当结果<strong>太大</strong>或者<strong>太小</strong>时，应该做些什么</p>
<p>给定在范围 $-2^{w-1}\leq x,y\leq 2^{w-1}-1$ 之内的整数值x和y，它们的和就在 $-2^w\leq x+y\leq2^w-2$ ，要想准确表示，可能需要w+1 位。我们把他截成w位，并将这个结果看做是补码数。</p>
<p>对满足 $-2^{w-1}\leq x,y\leq 2^{w-1}-1$ 的整数x和y，有：</p>
<p>$x+_w^t~y = \begin{cases}x+y-2^w,2^{w-1}\leq x+y <del>正溢出\ x+y,-2^{w-1}\leq x+y&lt;2^{w-1}</del>正常\x+y+2^w,x+y&lt;-2^{w-1} ~~ 负溢出\end{cases}$ </p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/2.png" style="zoom: 100%;"></p>
<p>两个数的w 位补码之和与无符号之和有完全相同的位级表示。实际上，大多数计算机使用同样的机器指令来执行无符号或者有符号加法。</p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/3.png" style="zoom: 100%;"></p>
<p>上图阐述了字长 $w=4$ 的补码加法。运算数的范围为 $-8到7$ 之间 。当$x+y&lt;-8$ 时，补码加法就会负溢出，导致和增长了16(Case 1)。当 当 $-8\leq x+y &lt;8$ 时，加法就产生了 $x+y$ 。当 $x+y\geq 8$ ,加法就会正溢出，让和减少了16。 </p>
<h4 id="检测补码加法中的溢出"><a href="#检测补码加法中的溢出" class="headerlink" title="检测补码加法中的溢出"></a>检测补码加法中的溢出</h4><p>对满足 $TMin_w\leq x,y\leq TMax_w$ 的x和y，令 $s=x~+_w^t~y$ . 当且仅当 $x&gt;0,y&gt;0$ 但是 $s\leq0$ 时，计算s发生了正溢出。当且仅当 $x&lt;0,y&lt;0$但是 $s\geq 0$ 时，计算s发生了负溢出。</p>
<h4 id="位操作相同的好处"><a href="#位操作相同的好处" class="headerlink" title="位操作相同的好处"></a>位操作相同的好处</h4><p>这样会让电路逻辑变得更简单，电路在设计的时候并不需要判断是否为补码或者无符号数。</p>
<h3 id="无符号的非"><a href="#无符号的非" class="headerlink" title="无符号的非"></a>无符号的非</h3><p>我们可以定义一个加法逆元(减) $-_w^u$ 。满足 $-_w^ux+_w^ux=0$ </p>
<p>无符号数求反</p>
<p>$-_w^u x=\begin{cases}x,x=0\ 2^w-x,x&gt;0\end{cases}$ </p>
<h3 id="补码的非"><a href="#补码的非" class="headerlink" title="补码的非"></a>补码的非</h3><p>可以看到范围在 $TMin_w\leq x\leq TMax_w$ 中的每个数字x都有 $+^t_w$ 下的加法逆元，我们把 $-_w^t x$ 表示如下：</p>
<p>补码的非</p>
<p>对满足 $TMin_w\leq x\leq TMax_w$ 的x，其补码的非 $-^t_w x$ 可表示为</p>
<p>$-_w^t x=\begin{cases}TMin_w,x=TMin_w\ -x,x&gt;TMin_W\end{cases}$ </p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/4.png" style="zoom: 100%;"></p>
<p>补码的非和无符号的非拥有相同的模式</p>
<h3 id="无符号乘法"><a href="#无符号乘法" class="headerlink" title="无符号乘法"></a>无符号乘法</h3><p>范围在 $0\leq x,y\leq 2^w-1$ 内的整数 x和y 可以被表示为 w位的无符号数，但是它们的乘积 $x\cdot y$ 的取值范围是 $(2^w-1)^2 = 2^{2w}-2^{w+1}+1$ 之间。这可能需要2w位来表示。不过C愿意浓重的无符号乘法被定义为产生w位的值。因此我们需要进行数的截断，我们将这个值表示为 $x *_w^u y$ </p>
<p>将一个无符号数截断位w位等价于计算值mod $2^w$ 得到：</p>
<p>对满足 $0\leq x,y\leq UMax_w$ 的x和y 有：</p>
<p>$x *_w^u y = (x\cdot y)<del>mod</del> 2^w$</p>
<h3 id="补码乘法"><a href="#补码乘法" class="headerlink" title="补码乘法"></a>补码乘法</h3><p>和无符号乘法类似， 范围在 $-2^{w-1}\leq x,y\leq 2^{w-1}-1$ 内的整数x和y可以被表示为位的补码数字，但是它们的乘积$x\cdot y$ 取值在 $-2^{2w-2}+2^{w-1}$ 到 $2^{2w-2}$ 之间，于是我们需要把这个可能长度位2w的串截断成w位的串。我们将这个数值表示为 $x*_w^t y$ 。将一个补码数截断为w位相当于先计算值模 $2^w$ 再把无符号数转换为补码，得到：</p>
<p>对满足 $TMin_w\leq x,y\leq TMax_w$ 的x和y有：</p>
<p>$x*_w^t y = U2T_w((x\cdot y) <del>mod</del> 2^w)$</p>
<p>所以对无符号和补码乘法来说，乘法运算的位级表示都是一样的，只是解释的方法不同而已。比如下面这个例子，我们就可以看到截断过后补码乘法和无符号乘法的编码都是相等的。</p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/5.png" style="zoom: 100%;"></p>
<p>如果乘法需要保留未被阉割的结果，需要扩展字长。如果需要，由软件(库)实现。</p>
<p>例子：11101001*11010101</p>
<h3 id="乘以常数"><a href="#乘以常数" class="headerlink" title="乘以常数"></a>乘以常数</h3><p>我们的编译器对整数乘法指令进行了一定的优化，试着用移位或者加法运算的组合来代替乘以常数因子的乘法。首先我们会考虑乘以2的幂的情况，然后再概括成乘以任意常数。</p>
<p>设x为位模式$[x<em>{w-1},x</em>{w-2},\cdots,x<em>0]$ 表示的无符号整数。那么对任何 $k\geq 0$ 我们都热为$[x</em>{w-1},x_{w-2},\cdots,x_0,0,\cdots,0]$ 给出了 $x2^k$ 的 $w+k$ 位的无符号表示，也就是右边加上了k个0</p>
<p>比如，当 $w=4$ 时， 11可以表示为 $[1011]$ 。$k=2$ 时将其左移得到6位向量[101100] ，即可编码为无符号数11*4 =44</p>
<p>那么我们可以固定字长，再左移k为时，相当于其最高的k位被丢弃。得到<br>$[x<em>{w-k-1},x</em>{w-k-2},\cdots,x_0,0,\cdots ,0]$ 而执行固定字长的乘法，也是这种情况，因此我么可以看出左移一个数值等价于执行一个于2的幂相乘的无符号乘法。</p>
<p>其实，在C里面就是通过移位来计算无符号乘法和补码乘法的</p>
<p>C变量x和k有无符号数值x和k，且 $0\leq k\leq w$ ,则C表达式 $x&lt;&lt;k$ 产生数值 $x<em>_w^u 2^k$ . 类似的，补码乘法也可以由此定义 ，只是将 $x&lt;&lt;k$ 产生的数值改变为 $x</em>_w^t2^k$</p>
<p><strong>注意</strong>，无论时无符号运算还是补码运算，乘以2的幂都有可能导致溢出。但是即使溢出时我们通过移位导致的运算结果也是一样的。比如说[1011]左移两位得到[101100] 这显然溢出了，我们将这个值截断位4位得到[1100] 也就是44 mod $2^4$ = 16</p>
<p>由于整数乘法比移位和加法的代价要大得多，许多C 语言编译器试图以移位、加法和减法的组合来消除很多整数乘以常数的情况</p>
<p>比如对于整数 4[100] 和7[111] 计算4*7 可以化为 $4*(2^2+2^1+2^0)$ ，也就是变成了 $[10000]+[01000]+[00100] = [11100] = 2^4+2^3+2^2=28$  </p>
<p>再将$[11100]$截断为4位也就是 $[1100]$ ,也就是28mod 16 = 12</p>
<p>当然有时候还可以变成减法，比如乘以14可以变为 $2^4-2^1$ ,将其重写为$(x&lt;&lt;4)-(x&lt;&lt;1)$ </p>
<p>当然，选择使用移位、加法和减法的组合，还是使用一条乘法指令，取决于这些指令的相对速度，而这些是与机器高度相关的。大多数编译器只在需要少量移位、加法和减法就足够的时候才使用这种优化</p>
<h3 id="除以2的幂"><a href="#除以2的幂" class="headerlink" title="除以2的幂"></a>除以2的幂</h3><p>除以2的幂的无符号除法</p>
<h4 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h4><p>有<strong>无符号</strong>数值x和k，且 $0\leq k<w$ 则c表达式 x>&gt;k 产生数值  ⌊$x/2^k$⌋<br>对无符号来说，右移采用的是逻辑右移。下面是一些无符号右移的例子：</w$></p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/6.png" style="zoom: 100%;"></p>
<p>对于无符号来说，右移和除法是等价的。<strong>都是向下取整</strong></p>
<h4 id="有符号数-补码"><a href="#有符号数-补码" class="headerlink" title="有符号数(补码)"></a>有符号数(补码)</h4><p>C语言中有补码值x和无符号数值k，且 $0\leq k<w$, 则当执行算数移位时，c表达式 $x>&gt;k$ 产生数值 ⌊$x/2^k$⌋  </w$,></p>
<p>对于 $x\geq 0$ 变量 x的最高有效位为0，所以效果与逻辑右移是一样的。因此对于非负数来说，算数右移k位与除以 $2^k$ 是一样的。</p>
<p>对于 $x<0$ ，情况要复杂一点，首先为了保证负数仍然为负，我们要执行的是算术右移。c表达式 x>&gt;k产生的数值为$[x/2^k]$ </0$></p>
<p>但是当补码除以$2^k$ 的时候，运行的是 $(x+(1&lt;<k)-1)>&gt;k$ ，这个是向上取整的。</k)-1)></p>
<p>关于这个公式。我们可以分几种情况来讨论。首先$1&lt;&lt;k -1 == 2^k-1$ 也就是 $\overline {1\cdots 1}$  </p>
<p>如果可以整除$2^k$ 说明二进制右边k位都为0，这样加上 $\overline {1\cdots 1}$  之后再右移k位相当于把  $\overline {1\cdots 1}$  都移走了。</p>
<p>如果不能整除$2^k$ 那么对于无符号数，$(x+(1&lt;<k)-1)>&gt;k$ 是<strong>向上取整</strong>的。对于有符号数的负数，$(x+(1&lt;<k)-1)>&gt;k$ 是向上取整的。<strong>有符号数的正数部分不要用这个公式</strong>。</k)-1)></k)-1)></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>无符号数</th>
<th>补码的正数</th>
<th>补码的负数</th>
</tr>
</thead>
<tbody>
<tr>
<td>除以$2^k$</td>
<td>向下取整(向0取整)</td>
<td>向下取整(向0取整)</td>
<td>$(x+(1&lt;<k)-1)>&gt;k$ 向上(0)取整</k)-1)></td>
</tr>
<tr>
<td>右移k位</td>
<td>向下取整，逻辑右移</td>
<td>向下取整(算数右移)</td>
<td>向下取整(算术右移)</td>
</tr>
</tbody>
</table>
</div>
<p>那么我们也可以从中推导出向0取整的位运算。$(x<0~~?~~x+(1<<k)-1 : x)>&gt; k$</0~~?~~x+(1<<k)-1></p>
<h3 id="补码的相反数"><a href="#补码的相反数" class="headerlink" title="补码的相反数"></a>补码的相反数</h3><p>$-x == $ ~$x +1$</p>
<h3 id="什么时候应该用无符号数"><a href="#什么时候应该用无符号数" class="headerlink" title="什么时候应该用无符号数"></a>什么时候应该用无符号数</h3><ul>
<li><p>Do Use When Performing Modular Arithmetic</p>
<ul>
<li>Multiprecision arithmetic</li>
</ul>
</li>
<li>Do Use When Using Bits to Represent Sets<ul>
<li>Logical right shift, no sign extension</li>
</ul>
</li>
<li>Do Use In System Programming<ul>
<li>Bit masks, device commands,…</li>
</ul>
</li>
</ul>
<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>这章我们将看到 IEEE浮点格式中数字是如何表示的，我们还将探讨舍入的问题，即向上调整或者向下调整。</p>
<h3 id="二进制小数"><a href="#二进制小数" class="headerlink" title="二进制小数"></a>二进制小数</h3><p>理解浮点数的第一步是考虑含有小数值的二进制数字. </p>
<p>首先我们来理解十进制下的小数，$d<em>md</em>{m-1}\cdots d<em>1d_0d</em>{-1}d<em>{-2}\cdots d</em>{-n}$  ，那么 $d=\Sigma_{i=-n}^m 10^i * d_i$ </p>
<p>比如12.34就相当于 $1<em>10^1+2</em>10^0+3<em>10^{-1}+4</em>10^{-2} = 12\frac{34}{100}$ </p>
<p>我们类比一下，二进制的浮点数就可以写为 $b<em>mb</em>{m-1}\cdots b<em>1b_0b</em>{-1}b<em>{-2}\cdots b</em>{-n}$  的表示法，其中每个二进制数字，或者称为位，$b_i$ 的取值范围是0和1，如</p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/7.png" style="zoom: 100%;"></p>
<h6 id="用这种方式定义的二进制如下：-b-Sigma-i-n-m-2-i-b-比如说-101-11-2-可以表示为数字-12-2-02-1-12-0-12-1-12-2-4-0-1-frac-1-2-frac-1-4-4-frac-3-4"><a href="#用这种方式定义的二进制如下：-b-Sigma-i-n-m-2-i-b-比如说-101-11-2-可以表示为数字-12-2-02-1-12-0-12-1-12-2-4-0-1-frac-1-2-frac-1-4-4-frac-3-4" class="headerlink" title="用这种方式定义的二进制如下： $b=\Sigma_{i=-n}^m 2^i b$ 比如说 $101.11_2$ 可以表示为数字 $12^2+02^1+12^0+12^{-1}+12^{-2}= 4+0+1+\frac{1}{2}+\frac{1}{4} = 4\frac{3}{4}$"></a>用这种方式定义的二进制如下： $b=\Sigma_{i=-n}^m 2^i <em>b$ 比如说 $101.11_2$ 可以表示为数字 $1</em>2^2+0<em>2^1+1</em>2^0+1<em>2^{-1}+1</em>2^{-2}= 4+0+1+\frac{1}{2}+\frac{1}{4} = 4\frac{3}{4}$</h6><p>从等式中可以很容易地看出来，二进制小数点向左移一位相当于这个数被2除。例如，$101.11_2$ 表示数 $5\frac{3}{4}$ 而 $10.111_2$ 表示数 $2+0+\frac{1}{2}+\frac{1}{4}+\frac{1}{8} = 2\frac{7}{8}$  类似，二进制小数点向右移动一位相当于将该数乘2，比如 $1011.1_2$ 可以表示数 $8+0+2+1=11\frac{1}{2}$ </p>
<p>注意，形如$0.11⋯1_2$的数表示的是刚好小于1 的数。例如，$0.111111_2$ 表示$\frac{63}{64}$ ，将用简单的表达法$1.0-\epsilon$ 来表示这样的数值。 </p>
<p>假定我们仅考虑有限长度的编码，那么10进制表示法不能准确地表达像$\frac{1}{3}$和$\frac{5}{7}$ 这样的数。类似，小数的二进制表示法只能表示那些只能够被写成 $x*2^y$ 的数，其他的值只能被近似的表示。</p>
<p>比如说 $\frac{1}{3}  = 0.0101010101[01]_2$  </p>
<p>比如说，数字 $\frac{1}{5}$ 可以用十进制小数 $0.20$ 精确表示。不过，我们并不能把它准确的表示为一个二进制小数，我们只能近似表示它，增加二进制表示的长度可以提高表示的精度。</p>
<h3 id="IEEE浮点表示"><a href="#IEEE浮点表示" class="headerlink" title="IEEE浮点表示"></a>IEEE浮点表示</h3><p>IEEE 浮点标准，使用 V(浮点数) = $(-1)^s\times M\times 2^E$ 的形式来表示一个数。这就是一个二进制科学计数法的表示形式。</p>
<p>s代表sign， 是决定这个数是负数(s=1) 还是正数(s=0) ,而对于数值0的符号位解释作为特殊情况处理。</p>
<p>M代表尾数(significand) M是一个二进制的小数，范围要么在 $(1,2-\epsilon)$ 之间要么在 $(0,1-\epsilon)$ 之间</p>
<p>E代表阶码(exponent) E的作用是对浮点数加权，这个权重 就是二的E次幂(可能是负数) </p>
<p>如下图所示</p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/8.png" style="zoom: 100%;"></p>
<p>在单精度浮点数(float) 中，s,exp,frac 字段分别为 1 位，$k=8$ 位和 $n=23$ 位</p>
<p>在双精度浮点数(double) 中，s、exp、frac 字段分别为1位，$k=11$ 和 $n=52$ 位，得到一个64位的表示。</p>
<p>将浮点数的这三个字段分别编码：</p>
<ul>
<li>一个单独的符号位 s 直接编码符号 s</li>
<li>k位的阶码字段 $exp = e_{k-1}\cdots e_1e_0$ 编码阶码E。</li>
<li>n位小数字段$frac= f_{n-1}\cdots f_1f_0$ 编码尾数M，但是编码出来的值也依赖于阶码的字段是否等于0。</li>
</ul>
<p>为什么exp再frac前面？当我们对两个同符号数比较大小的时候，可以先直接比较阶的大小。但是尾数在前面的话就会增大计算量。</p>
<p>根据 exp 的值，被编码的值可以分成三种不同的情况(最后一种情况有两个变种)</p>
<h4 id="1-Normalized"><a href="#1-Normalized" class="headerlink" title="1.Normalized"></a>1.Normalized</h4><p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/9.png" style="zoom: 100%;"></p>
<p>这是最普遍的情况。即当exp的位模式既不全为0(数值0) ,也不全为1(单精度数值为1，双精度数值为2047) 时，都属于这类情况，在这类情况中，阶码字段被解释为以偏置(biased)的形式表示的有符号整数。也就是说，阶码的值是 $E=e-Bias$, 其中e是无符号数，其为表示为 $e_{k-1}\cdots e_1e_0$ ,而$Bias$ 是一个等于 $2^{k-1}-1$(单精度是127, 双精度 1023) 的<strong>定值</strong>，目的是让原来都是正的指数一部分变成负的。由此产生指数的取值范围，对单精度是 $-126$~$+127$ ,而对于双精度来说是 $-1022到 +1023$  </p>
<p>那么问题来了，为什么我们不用补码去表示，而要用 e-Bias 这种移码来表示呢？ 因为对于阶来说，主要是用来比较大小和加减法，从这个角度看，虽然表示的范围相近，但是移码的计算更加方便。</p>
<p>小数字段frac 被解释为描述小数值f , 其中 $0\leq f&lt;1$ ，其二进制表示为 $0.f_{n-1}\cdots f_1f_0$ ,也就是二进制小数点在最高有效位的左边。尾数定义为 $M=1+f=1.frac$  。 </p>
<p>这个设计难懂但是非常巧妙。这个方法有时也被叫做隐含的以1 开头的(implied leading 1)表示 。也就是说我们可以把 M看作是一个二进制表达式 $1.f<em>{n-1}f</em>{n-2}\cdots f_0$ 的数字。既然我们总是能够调整阶码E，使得尾数M在范围 $1\leq M&lt;2$ 之中(假设没有溢出)。那么这种表示方法就可以轻松获得一个额外精度位的技巧。既然第一位总是等于1，那么我们就不需要显示地表示。</p>
<p>比如说对于一个浮点数 f=.10101,如果我们不把小数点左边的数值设置为1，让$exp(2^k)$ 来操纵小数点移位，那么表示.10101 就需要5位。但是我们如果把小数点左边的数值设置为1，那么再让$exp(2^k)$ 来操纵小数点移位后，表示.10101 只需要用 1.0101 表示后再像右移一位就行了，也就是说我们现在只需要4位就可以编码出 .10101. 相当于牺牲了阶码中的1，但获得一个精度位,能多表示 $2^{127}$ 个数。</p>
<h4 id="2-Denormalized"><a href="#2-Denormalized" class="headerlink" title="2.Denormalized"></a>2.Denormalized</h4><p>仅仅Normalized浮点数时不够的，因为Normalized能表示的绝对值最小的浮点数和绝对值次小值浮点数之间的差距是要小于绝对值最小的浮点数和0之间的差距的。这和科学计数法的“本意”相违背。科学计数法要求越接近0.数值越密，但是对Normalized来说，到0之间存在一段比较大的“真空”值。</p>
<p>从下面这张表格我们可以更明显地看出Normalized局限性。在8位浮点数种， 阶码位k=4,小数位 n=3,偏置量 $2^{3}-1 =7$ .那么这个8位浮点数能表示的最小的Normalized数就是 0.0001000，f=0 但是$ M = 1+f =\frac{8}{8}$  $V_1 = 2^E\times M = 2^{-6}\times 1=\frac{1}{64}$ = 0.015625<br>Normalized的次小值是 $0.0001001$ ，值$V_2=0.017578$ </p>
<p> $V_2-V_1&lt;V_1-0.0$ ，就不符合科学计数法的主旨。</p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/13.png" style="zoom: 100%;"></p>
<p>所以我们设计了Denormalized数，也就是阶码域为全0。这种情况下，阶码的值 是$E=1-Bias$ 。而尾数的值是 $M=f$，也就是小数字段的值，小数点左边为0。Denormalized能够提供一个逼近于0的数，也就是讲上面所说的那段真空区域等分。</p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/10.png" style="zoom: 100%;"></p>
<p>为什么将阶码的值设为 $E = 1-Bias$？把$M=f    $这样设计可以让最大的Denormalized和最小的Normalized能够平顺连接.我们知道在8位的浮点数下，最小的 Normalized 数为0.015625，而最大的Denormalized 为0.013672 ，他们之间相差了 $\frac{1}{512}$ 。从最大的Deormalized数继续向0逼近，所有的数之间都是等间距的，因为阶数始终为0。</p>
<p>非规格化数有两个用途。</p>
<p>首先，这<strong>提供了一种表示数值0的方法</strong>，因为使用规格化数，我们必须总是使 $M\geq 1$ ，因此我们不能表示0，实际上，$+0.0$ 的浮点表示的位模式为全0：符号位是0，阶码字段全为0(表明一个非格式化的值) ，而小数域也全为0，这就得到了 $M=f=0$ 令人奇怪的是，当符号位为1，而其他域全为0的时候，我们得到了值 $-0.0$。 +0和-0 其实表示了是从正向还是负向无限接近于0。</p>
<p>非格式化数的另外外一个功能是表示那些非常接近于0.0的数</p>
<h4 id="3-1Infinity"><a href="#3-1Infinity" class="headerlink" title="3.1Infinity"></a>3.1Infinity</h4><p>最后一类数值是当 阶码全为1的时候出现的。当小数域全为0时，得到的值表示无穷。当s=0 时是$+\infty$ ，或者当 $s=1$ 时是 $-\infty$ 。当我们把两个非常大的数相乘，或者除以0时，无穷能表示溢出的结果</p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/11.png" style="zoom: 100%;"></p>
<p>比如说 1.0/0.0可能会取到Infinity，这是因为 0.0可能不是真正的0，只是相近为0，所以1.0/0.0 可能是有意义的。</p>
<h4 id="3-2NaN"><a href="#3-2NaN" class="headerlink" title="3.2NaN"></a>3.2NaN</h4><p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/12.png" style="zoom: 100%;"></p>
<p>但是当小数域不为0的时候，结果值被称为 NaN，即(Not a Number)，一些运算的结果不能是实数或者无穷，就会返回这样的NaN值，比如当计算 $\sqrt{-1}$ 或 $\infty - \infty$ 的时。在某些应用中，表示未初始化的数据时，他们也很有用处。</p>
<h3 id="数字示例"><a href="#数字示例" class="headerlink" title="数字示例"></a>数字示例</h3><p>现在我们假设一个6位的浮点数，有 $k=3$ 的阶码位和 $n =2$ 的尾数位。偏置量是 $2^2-1=3$ 。那么下面的图就显示了所有可表示的值(除了NaN) 。两个无穷值在两个末端。最大数量值的Normalized数是 $\pm14$ Denormalized数聚集在 0 附近。</p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/14.png" style="zoom: 100%;"></p>
<p>我们发现, 那些可以表示的数并不是均匀分布的：越靠近原点处它们越稠密。</p>
<h3 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h3><p>因为表示的方法限制了浮点数的范围和精度，所以浮点运算只能近似地表示实数运算。因此对于值x，我们一般通过舍入运算来找到最接近的匹配值 x’, 那么我们就不能选择四舍五入。因为这样向上舍入的概率会大于向下舍入的概率。下面是四种不同的摄入方式，第一种是向偶数舍入，也就是说，出现 x.5 的时候，向这个数的最接近的偶数舍入。比如 1.5向2舍入；2.5向2舍入 -2.5向-2 舍入。这样一来，向上舍入和向下舍入的概率就相等了。单仅限于最后一位是5，其他的数字还是按照四舍六入的方式进行。</p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/15.png" style="zoom: 100%;"></p>
<p>那么，对于二进制小数，我们也可以使用向偶数舍入。我们将最低有效位的值0 认为是偶数，值1认为是奇数。那么只有对形如 $X\cdots X.Y\cdots Y100\cdots$  的二进制位模式的数才可以向偶数舍入。最右边的Y是要被舍入的位置。如果最后是100的话，就要把Y向偶数舍入，<strong>Y若为1，那么向上舍入取0进1，若Y为0，那么直接移去后面的100</strong>.</p>
<p>比如 $10.11100 $向上舍入成11.00，而10.10100 向下舍入成10.10</p>
<p>像其他的数，如 $10.00011_2$ 就直接向下舍入到 $10.00$ 而 $10.00110_2$ 向上舍入到 $10.01_2$ </p>
<h3 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h3><p>$x +_f y = Round(x + y)$<br>$x ×_f y = Round(x × y)$ </p>
<p>浮点数的加法或者乘法可能会溢出，也可能需要舍入。</p>
<h4 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h4><p>对于两个浮点数 $(-1)^s\times M\times 2^E$ 相乘得到 $=(-1)^{s_1}\times M_1\times 2^{E_1}\times(-1)^{s_2}\times M_2\times 2^{E_2}$ </p>
<p>所以结果就可以这样表示：$s = s_1$^$s_2,M=M_1\times M_2,E=E_1+E_2$  </p>
<p>那么，如果 出现了 $M\geq 2$ ，则M右移，增加E</p>
<p>如果E超过了范围，那么就发生了溢出</p>
<p>如果E不超过范围，那么对M进行舍入，计算得到frac</p>
<p>乘法的数学性质：</p>
<ul>
<li>封闭</li>
<li>交换律成立</li>
<li>结合律不成立</li>
<li>1的性质成立</li>
<li>乘法对加法的分配律不成立</li>
<li>单调性成立 $(a\geq b ~\&amp;~c\geq 0\Rightarrow a<em>c\geq b</em>c)$ (除了$\infty$和$NaN$)</li>
</ul>
<h4 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h4><p>结果$(-1)^s\times M\times 2^E=(-1)^{s_1}\times M_1\times 2^{E_1}+(-1)^{s_2}\times M_2\times 2^{E_2}$ </p>
<p>对于 s,M: <strong>小数点对齐</strong>之后做加法</p>
<p>E则取 对齐后的 $E_1$</p>
<ul>
<li>如果 $M\geq 2$ 则M右移，增加E</li>
<li>如果E超过范围，则溢出</li>
<li>如果E没超出范围，则M舍入，计算得到frac</li>
</ul>
<p>如果两个浮点数的阶数E不同，那么需要先移动小数点调整他们的阶相同之后再进行</p>
<p>加法的数学性质：</p>
<ul>
<li>封闭(包括NaN)</li>
<li>交换律成立</li>
<li>结合律不成立</li>
<li>0的性质成立</li>
<li>相反数存在(除了$\infty$和$NaN$)</li>
<li>单调性成立(除了$\infty$和$NaN$)</li>
</ul>
<h3 id="C语言中的浮点数"><a href="#C语言中的浮点数" class="headerlink" title="C语言中的浮点数"></a>C语言中的浮点数</h3><p>所有的C语言版本提供了两种不同的浮点数据类型：float 和double。 在支持IEEE 浮点格式的机器上，这些数据类型就对应于单精度和双精度浮点。另外，这类机器使用向偶数舍入的舍入方式。不幸的是，因为C语言标准不要求机器使用IEEE 浮点，所以没有标准的方法来改变舍人方式或者得到诸如$-0,+\infty,-\infty$ 或者 $NaN$ 之类的特殊值。大多数系统提供include(‘.h’) 文件和读取这些特征的过程库，但是细节随系统不同而不同。例如，当程序文件中出现下列句子时，GNU 编译器GCC 会定义程序常数 INFINITY($+\infty$) 和 $NaN$(表示$NaN$) </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/16.png" style="zoom: 100%;"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_ok</span><span class="params">(<span class="keyword">unsigned</span> x,<span class="keyword">unsigned</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x+y&gt;=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/17.png" style="zoom: 100%;"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tadd_ok</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = x+y;</span><br><span class="line">	<span class="keyword">int</span> neg_over = x&lt;<span class="number">0</span>&amp;&amp;y&lt;<span class="number">0</span>&amp;&amp;x+y&gt;=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> pos_over = x&gt;=<span class="number">0</span>&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;x+y&lt;<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> ~(neg_over||pos_over);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不管是否溢出，加减法仍然成立</p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/21.png" style="zoom: 100%;"></p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/18.png" style="zoom: 100%;"></p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/19.png" style="zoom: 100%;"></p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/20.png" style="zoom: 100%;"></p>
<p><img src="/2020/09/17/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A82/22.png" style="zoom: 100%;"></p>
<p>因为float只有32位，和int是一样的，8位阶码 ，23位尾数；而double有64位，11位阶码，52位尾数</p>
<p>double的尾数用来容纳int是绰绰有余的，而float的尾数则需要int舍弃一些精确度。于是A是正确的而B是错误的</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/" class="post-title-link" itemprop="url">CSAPP信息的表示和存储</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-15 15:50:21" itemprop="dateCreated datePublished" datetime="2020-09-15T15:50:21+08:00">2020-09-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-08 13:38:10" itemprop="dateModified" datetime="2020-10-08T13:38:10+08:00">2020-10-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CSAPP信息的表示和存储"><a href="#CSAPP信息的表示和存储" class="headerlink" title="CSAPP信息的表示和存储"></a>CSAPP信息的表示和存储</h1><p>怎么阅读CSAPP？</p>
<ol>
<li>首先看一下标题和<strong>插图</strong> </li>
<li>看懂示意图之后做一些 practice problem，有不懂的再去看书本内容</li>
<li>用例子来帮助我们理解</li>
</ol>
<h2 id="上课笔记"><a href="#上课笔记" class="headerlink" title="上课笔记"></a>上课笔记</h2><h3 id="main-arg-c-arg-v"><a href="#main-arg-c-arg-v" class="headerlink" title="main(arg c ,arg v)"></a>main(arg c ,arg v)</h3><p>argc和argv参数在用命令行编译程序时有用</p>
<p>第一个参数，int型的argc，为整型，用来统计程序运行时发送给main函数的命令行参数的<strong>个数</strong></p>
<p>第二个参数，char*型的argv[]，为字符串数组，用来存放指向的字符串参数的指针数组，每一个元素指向一个参数。各成员含义如下：argv[0]指向程序运行的全路径名<br>    argv[1]指向在DOS命令行中执行程序名后的第一个字符串<br>    argv[2]指向执行程序名后的第二个字符串<br>    argv[3]指向执行程序名后的第三个字符串<br>    argv[argc]为NULL</p>
<h3 id="shell-中的命令时怎么去运行的"><a href="#shell-中的命令时怎么去运行的" class="headerlink" title="shell 中的命令时怎么去运行的"></a>shell 中的命令时怎么去运行的</h3><p><a href="https://www.cnblogs.com/chaoguo1234/p/5724321.html" target="_blank" rel="noopener">https://www.cnblogs.com/chaoguo1234/p/5724321.html</a></p>
<h3 id="C中的内存管理"><a href="#C中的内存管理" class="headerlink" title="C中的内存管理"></a>C中的内存管理</h3><h4 id="存储时候的三个区域："><a href="#存储时候的三个区域：" class="headerlink" title="存储时候的三个区域："></a>存储时候的三个区域：</h4><p><strong>代码区</strong></p>
<p>存放CPU执行的机器指令（machine instructions）。通常，代码区是可共享的（即另外的执行程序可以调用它），因为对于频繁被执行的程序，只需要在内存中有一份代码即可。代码区通常是只读的，使其只读的原因是防止程序意外地修改它的指令。另外，代码区还规划了局部变量的相关信息。</p>
<p><strong>数据区</strong></p>
<p>该区包含了在程序中<strong>明确被初始化</strong>的全局变量、静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量）。</p>
<p><strong>未初始化数据区（BSS）</strong></p>
<p>存入的是全局未初始化变量。BSS区的数据在程序开始执行之前被内核初始化为0或者空指针（NULL）。</p>
<h4 id="运行时的几个区域"><a href="#运行时的几个区域" class="headerlink" title="运行时的几个区域"></a>运行时的几个区域</h4><p><strong>代码区</strong></p>
<p>代码区指令根据程序设计流程依次执行，对于顺序指令，则只会执行一次（每个进程），如果反复，则需要使用跳转指令，如果进行递归，则需要借助栈来实现。</p>
<p>代码区的指令中包括操作码和要操作的对象（或对象地址引用）。如果是立即数（即具体的数值），将直接包含在代码中；如果是局部数据，将在栈区分配空间，然后引用该数据地址；如果是BSS区和数据区，在代码中同样将引用该数据地址。</p>
<p><strong>全局初始化数据区</strong></p>
<p>同上</p>
<p><strong>未初始化数据区</strong></p>
<p>同上</p>
<p><strong>栈区</strong></p>
<p>由编译器自动分配释放，存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈。每当一个函数被调用，该函数返回地址和一些关于调用的信息，比如某些寄存器的内容，被存储到栈区。然后这个被调用的函数再为它的自动变量和临时变量在栈区上分配空间，这就是C实现函数递归调用的方法。每执行一次递归函数调用，一个新的栈框架就会被使用，这样这个新实例栈里的变量就不会和该函数的另一个实例栈里面的变量混淆。</p>
<p><strong>堆区</strong></p>
<p>用于动态内存分配。堆在内存中位于BSS区和栈区之间。一般 <strong>由程序员分配和释放</strong>，若程序员不释放，程序结束时有可能由OS回收。</p>
<p>之所以分成这么多个区域，主要基于以下考虑：</p>
<p>一个进程在运行过程中，代码是根据流程依次执行的，只需要访问一次，当然跳转和递归有可能使代码执行多次，而数据一般都需要访问多次，因此单独开辟空间以方便访问和节约空间。</p>
<p>临时数据及需要再次使用的代码在运行时放入栈区中，生命周期短。</p>
<p>全局数据和静态数据有可能在整个程序执行过程中都需要访问，因此单独存储管理。</p>
<p>堆区由用户自由分配，以便管理。</p>
<p>栈与堆的区别：</p>
<p>1、申请方式不同</p>
<p>2、管理方式不同。堆容易产生内存泄露。（这个就看程序员啦）</p>
<p>3、空间大小不同。</p>
<p>栈是<strong>向低地址扩展</strong>的数据结构，是一块连续的内存区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，当申请的空间超过栈的剩余空间时，将提示溢出。因此，用户能从栈获得的空间较小。</p>
<p>堆是<strong>向高地址扩展</strong>的数据结构（它的生长方向与内存的生长方向相同），是不连续的内存区域。因为系统是用链表来存储空闲内存地址的，且链表的遍历方向是由低地址向高地址。由此可见，堆获得的空间较灵活，也较大。</p>
<p>4、系统响应：</p>
<p>栈：只要栈的空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</p>
<p>堆：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的free语句才能正确的释放本内存空间。另外，找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</p>
<p>对于堆来讲，频繁的malloc/free势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈就不会存在这个问题。</p>
<p>5、增长方向不同</p>
<p>6、申请效率不同</p>
<p>堆的效率要低于栈。</p>
<h3 id="通讯录模型"><a href="#通讯录模型" class="headerlink" title="通讯录模型"></a>通讯录模型</h3><p>可以把内存理解为一片广袤的大地，那么， 操作系统就会交给我们一本通讯录，里面有0到$2^{64}-1$ 的地址，每一行地址对应着大地上的某处。我们能拿到的只有地址，但是这个数据具体存在哪里，我们是不清楚也不知道的，只有Kernel才可知道。</p>
<h3 id="多道程序、多线程"><a href="#多道程序、多线程" class="headerlink" title="多道程序、多线程"></a>多道程序、多线程</h3><p><a href="https://www.cnblogs.com/liao13160678112/p/6603381.html" target="_blank" rel="noopener">https://www.cnblogs.com/liao13160678112/p/6603381.html</a></p>
<h3 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h3><p>kernel是一个软硬件之间的连接器</p>
<p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/13.png"></p>
<h3 id="objdump-d-hello"><a href="#objdump-d-hello" class="headerlink" title="objdump -d hello"></a>objdump -d hello</h3><p>cat cpuinfo 显示cpu信息</p>
<p>cat meminfo 显示内存信息</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>内存是一个很大的数组空间。</p>
<h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p>地址空间也是一个很大的数组空间，由计算机的字长来决定，比如32位字长机器的内存理论上有4个GB，64位则有$2^{64}$ kb</p>
<h2 id="2-1-信息存储"><a href="#2-1-信息存储" class="headerlink" title="2.1 信息存储"></a>2.1 信息存储</h2><h3 id="十六进制表示法"><a href="#十六进制表示法" class="headerlink" title="十六进制表示法"></a>十六进制表示法</h3><p>记住十六进制、十进制、二进制的互相转换。记住下面几个表格，主要记牢 十进制的2，4，8,对应的二进制</p>
<p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/1.png"></p>
<ul>
<li>十六进制转换成二进制的时候，可以通过展开每个十六进制的数字来实现。</li>
</ul>
<p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/2.png"></p>
<ul>
<li>反过来如果给定一个二进制数字，可以通过首先将其从左到右每4位一组来转换为十六进制。如果位总数不是4的倍数，最左边的一组可以少于4位，前面用0补足。然后再将每个4位组转换为相应的十六进制数字</li>
</ul>
<ul>
<li><p>十进制和十六进制之间转换比较简单，使用乘法和除法就可以了。</p>
</li>
<li><p>值得注意的是当值工是2 的非负整数 $n$ 次幂时，也就是$x=2^n$ 我们可以很容易地将x 写成十六进<br>制形式，只要记住x的二进制表示就是1 后面跟n个0。十六进制数字0 代表4 个二进制 0。所以，当n表示成$i+4j$ 的形式，其中 $0\leq i\leq 3$, 我们可以把x 写成开头的十六进制数字为$1(i=0),2(i=1),4(i=2),8(i=3) $ 后面跟随着个十六进制的0。比如，$x=2048=2^{11}$ 我们有$n=11=3+4*2$ 从而得到十六进制表示 0x800</p>
</li>
</ul>
<h3 id="Data-sizes"><a href="#Data-sizes" class="headerlink" title="Data sizes"></a>Data sizes</h3><p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/3.png"></p>
<h3 id="Address-and-Byte-Ordering"><a href="#Address-and-Byte-Ordering" class="headerlink" title="Address and Byte Ordering"></a>Address and Byte Ordering</h3><h3 id="Representing-Strings"><a href="#Representing-Strings" class="headerlink" title="Representing Strings"></a>Representing Strings</h3><p>C 语言中字符串被编码为一个以null(其值为0)字符结尾的字符数组。每个字符都由某个标准编码来表示，最常见的是ASCII 字符码。因此，如果我们以参数“12345” 和6(包括终止符)来运行例show_bytes我们得到结果31 32 33 34 35 00。请注意，十进制数字x 的ASCII 码正好是0x3x, 而终止字节的十六进制表示为0x00。在使用ASCII 码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。因而，文本数据比二进制数据具有更强的平台独立性</p>
<p>下面对show_bytes 的调用将输出什么结果？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *byte_pointer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_bytes</span><span class="params">(byte_pointer start, <span class="keyword">size_t</span> len)</span></span>&#123;</span><br><span class="line"><span class="built_in">size</span>.t i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">printfC %<span class="number">.2</span>xn, start[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_int</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	show_bytes((byte_pointer) &amp;x, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_float</span><span class="params">(<span class="keyword">float</span> x)</span></span>&#123;</span><br><span class="line">	show_bytes((byte_pointer) &amp;xf <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_pointer</span><span class="params">(<span class="keyword">void</span> *x)</span></span>&#123;</span><br><span class="line">	show_bytes((<span class="keyword">byte</span>.pointer) &amp;x, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>要注意，strlen(s) 是不会计算结束符的！所以答案是61, 62，63，64，65</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *s = <span class="string">"abcdef"</span>;</span><br><span class="line">show_bytes((byte_pointer) s, <span class="built_in">strlen</span>(s));</span><br></pre></td></tr></table></figure>
<h3 id="Representing-Code"><a href="#Representing-Code" class="headerlink" title="Representing Code"></a>Representing Code</h3><p>考虑下面的C函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们在机器上编译时，生成如下字节表示的机器代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Linux 32 55 89 e5 8b 45 Oc 03 45 08 c9 c3</span><br><span class="line">Windows 55 89 e5 8b 45 0c 03 45 08 5d c3</span><br><span class="line">Sun 81 c3 eO 08 90 02 00 09</span><br><span class="line">Linux 64 55 48 89 e5 89 7d f c 89 75 f 8 03 45 f c c9 c3</span><br></pre></td></tr></table></figure>
<p>我们发现指令编码是不同的。不同的机器类型使用不同的且不兼容的指令和编码方式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。<br>计算机系统的一个基本概念就是，从机器的角度来看，程序仅仅只是字节序列。机器没有关于原始源程序的任何信息，除了可能有些用来帮助调试的辅助表以外。</p>
<h3 id="Boolean-Algebra"><a href="#Boolean-Algebra" class="headerlink" title="Boolean Algebra"></a>Boolean Algebra</h3><p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/4.png" style="zoom:120%;"></p>
<p>以上4个布尔运算可以扩展到bit vectors上的运算，也就是固定长度为$w$，由0，1组成的串。比如说$w = 4,a =[0110],b=[1100]$ 那么4种运算 $a\&amp;b,a|b,$ a^ b 和 ~b 会得到这样的结果。</p>
<p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/5.png" style="zoom:120%;"></p>
<p>使用bit vectors 一个很有用的应用就是表示有限的集合。我们可以用bit vector $[a_{w-1},\cdots,a_1,a_0]$ 来编码任何子集 $A\subseteq{0,1,\cdots,w-1}$ ,其中$a_i=1$ 当且仅当 $i\in A$ 比如说</p>
<p>$a=[01101001]$ 可以对应 $A={0,3,5,6}$ 因为对76543210 这个数来说，从右往左数第1，第4，第6、7 位都是1，其他位都是0。</p>
<p>同理，$b=[01010101]$ 可以表示 $B={0,2,4,6}$ </p>
<p>我们于是可以把位运算用到集合当中：</p>
<p>$A\&amp;B  = 01000001 ={0,6}$ </p>
<p>$A|B = 01111101 = {0,2,3,4,5,6}$ </p>
<p>A^B $= 00111100={2,3,4,5}$ </p>
<p>A~B $=10101010={1,3,5,7}$ </p>
<h3 id="Bit-Level-Operations-in-C"><a href="#Bit-Level-Operations-in-C" class="headerlink" title="Bit-Level Operations in C"></a>Bit-Level Operations in C</h3><h3 id="Logical-Operations-in-C"><a href="#Logical-Operations-in-C" class="headerlink" title="Logical Operations in C"></a>Logical Operations in C</h3><p>C语言种还提供了一组逻辑运算符 $||,\&amp;\&amp;,!$   分别对应OR，AND，NOT，千万不要把逻辑运算和位运算混淆，逻辑运算只有TRUE和FALSE，只返回1或者0。比如：</p>
<p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/6.png" style="zoom:150%;"></p>
<h3 id="Shift-Operations-in-C-移位运算"><a href="#Shift-Operations-in-C-移位运算" class="headerlink" title="Shift Operations in C  移位运算"></a>Shift Operations in C  移位运算</h3><h4 id="左移"><a href="#左移" class="headerlink" title="左移"></a>左移</h4><p>左移这种移位运算非常简单，x向左移动k位，丢弃最高的 $k$ 位，并在右端补上k个0。移位量应该是一个 0~w-1 之间的值。移位运算是从左到右可结合的 $x&lt;&lt;j&lt;&lt;k = (x&lt;&lt;j)&lt;&lt;k$ </p>
<h4 id="逻辑右移"><a href="#逻辑右移" class="headerlink" title="逻辑右移"></a>逻辑右移</h4><p>逻辑右移和左移刚好相反，x向右移k位，左边补上k个0</p>
<h4 id="算术右移"><a href="#算术右移" class="headerlink" title="算术右移"></a>算术右移</h4><p>为什么会有算数右移？</p>
<p>算术右移比较微妙，是在移动之后在左端补上k个最高有效位的值，得到的结果是 $[x<em>{w-1},\cdots,x</em>{w-1},x_{w-2},\cdots,x_k]$ </p>
<p>比如下面这个例子</p>
<p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/7.png" style="zoom:150%;"></p>
<p>斜体的数字表示的是最右端(左移）或最左端(右移)填充的值。可以看到除了一个条目之外，其他的都包含填充0。唯一的例外是算术右移[10010101]的情况。因为操作数的最高位是1，填充的值就是1。</p>
<p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/8.png" style="zoom:120%;"></p>
<p>对于 x&lt;<y 和 x>&gt;y 如果 $y<0$ 或者 $y>$字长，则行为无意义</0$></y></p>
<h2 id="2-2整数表示"><a href="#2-2整数表示" class="headerlink" title="2.2整数表示"></a>2.2整数表示</h2><h3 id="Integral-Data-Types"><a href="#Integral-Data-Types" class="headerlink" title="Integral Data Types"></a>Integral Data Types</h3><p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/10.png" style="zoom:100%;"></p>
<h3 id="Unsigned-Encodings-无符号数"><a href="#Unsigned-Encodings-无符号数" class="headerlink" title="Unsigned Encodings(无符号数)"></a>Unsigned Encodings(无符号数)</h3><p>假设有一个整数数据类型有w位。我们可以将其写成 $[x<em>{w-1},x</em>{w-2},…,x_0]$  ,表示向量中的每一位。然乎我们用一个 $B2U_w$(Binary to Unsigned 的缩写，长度位w) 来表示：</p>
<p>对向量 $\overrightarrow{x} = [x<em>{w-1},x</em>{w-2},\cdots,x_0]$  </p>
<p>$B2U<em>w(\overrightarrow{x}) = \Sigma</em>{i=0}^{w-1}x_i2^i$ </p>
<p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/11.png" style="zoom:100%;"></p>
<h3 id="Two’s-Complement-Encodings-补码"><a href="#Two’s-Complement-Encodings-补码" class="headerlink" title="Two’s-Complement Encodings(补码)"></a>Two’s-Complement Encodings(补码)</h3><p>基为2的补码的定义</p>
<p>仍然把最高位当成符号位，但是最高位还是带权重的</p>
<p>对向量 $\overrightarrow{x} = [x<em>{w-1},x</em>{w-2},\cdots,x_0]$: </p>
<p>$B2T<em>w(\overrightarrow{x}) = -x</em>{w-1}2^{w-1}+\Sigma_{i=0}^{w-2}x_i2^i$ </p>
<p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/12.png" style="zoom:100%;"></p>
<p>让我们来考虑一下w 位补码所能表示的值的范围。它能表示的最小值是位向量<a href="也就是设置这个位为负权，但是清除其他所有的位）其整数值为 $TMin_w=-2^{w-1}$ . 而最大值是为[01...1] (清除具有负权的位，而设置其他所有的位">10…0</a> ，其整数值为 $TMax<em>w = \Sigma</em>{i=0}^{w-2} 2^i = 2^{w-1}-1$  . 以4为例，我们有 $TMin_4 = B2T_4([1000]) = -2^3 = 8$,而 $TMax_4 = B2T_4([0111]) = 7$ </p>
<p>C语言标准不要求一定使用补码表示有符号的整数，但是几乎所有的机器上的实现都用补码</p>
<p>补码的最高位是1，那么这个补码就是负的</p>
<p>补码的好处就是只有一个零，而原码则有两个0</p>
<p>做一个小练习：</p>
<p>B2T (10) = 1010<br>B2T (−10) = 10110<br>B2T (15213) =<br>B2T (−15213) =</p>
<p>我们发现对于两个相反数的补码，我们第一眼是看不出相反数之间是有联系的。不像源码，第一位只代表符号位。对于负数的补码，就是把正数的补码取反码再+1</p>
<h3 id="Conversions-between-Signed-and-Unsigned"><a href="#Conversions-between-Signed-and-Unsigned" class="headerlink" title="Conversions between Signed and Unsigned"></a>Conversions between Signed and <strong>Unsigned</strong></h3><p>有符号数和无符号数之间的转换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">short <span class="keyword">int</span> v = <span class="number">-12345</span>;</span><br><span class="line"><span class="keyword">unsigned</span> short uv = (<span class="keyword">unsigned</span> short) v;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"v=%d,uv = %u\n"</span>,v,uv);</span><br></pre></td></tr></table></figure>
<p>结果是 v=-12345, uv = 53191</p>
<p>对C来说强制类型转换的结果保持位值不变，只是<strong>改变了解释这些位的方式</strong>。 因为十六进制表示写作0xCFC7 的16 位二进制码既是-12345的补码表示，又是53191 的无符号表示</p>
<p>也就是说 $T2U_{16}(-12345) = 53191,U2T_16(53191) = 12345$ </p>
<p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/14.png" style="zoom:100%;"></p>
<p>通过上述这些例子，我们可以总结出T2U的公式:对满足 $TMin_w\leq x\leq TMax_w$ </p>
<p>$T2U_w(x)=\begin{cases}x+2^w,x&lt;0\ x,x\geq 0\end{cases}$ </p>
<p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/15.png" style="zoom:100%;"></p>
<p>对 $0\leq u\leq UMax_x$ 的u 有</p>
<p>$U2T_w(x)=\begin{cases}u,u\leq TMax_w\ u-2^w,u\geq TMax_w\end{cases}$ </p>
<p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/16.png" style="zoom:100%;"></p>
<h3 id="Signed-versus-Unsigned-in-C"><a href="#Signed-versus-Unsigned-in-C" class="headerlink" title="Signed versus Unsigned in C"></a>Signed versus Unsigned in C</h3><p>C语言中，要创建一个无符号常量，必须加上后缀字符’U‘ 或者‘u‘例如，12345U 或者0x1A2Bu.</p>
<p>C 语言允许无符号数和有符号数之间的转换。在一台采用补码的机器上，当从无符号数转换为有符号数时，效果就是应用函数$U2T_w$，而从有符号数转换为无符号数时，就是应用函数$T2U_w$ 其中切表示数据类型的位数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant1</th>
<th>Constant2</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>位串保持不变，位串重复解读。可能会导致各种溢出：$$</p>
<h3 id="Expanding-the-Bit-Representation-of-a-Number"><a href="#Expanding-the-Bit-Representation-of-a-Number" class="headerlink" title="Expanding the Bit Representation of a Number"></a>Expanding the Bit Representation of a Number</h3><h4 id="零扩展"><a href="#零扩展" class="headerlink" title="零扩展"></a>零扩展</h4><p>要将一个无符号的数转换为一个更大的数据类型，我们只需要简单地在表示的开头添加0. 表示：</p>
<p>定义宽度为w的位向量 $\overrightarrow{u} = [u<em>{w-1},u</em>{w-2},…,u<em>0]$ 和宽度为 $w’$ 的位向量 $\overrightarrow{u}’ = [0,…,0,u</em>{w-1},u<em>{w-2},…,u_0]$ , 其中 $w’&gt;w$, 则 $B2U_w(\overrightarrow{u}) =B2U</em>{w’}(\overrightarrow{u’})$ </p>
<h4 id="符号扩展"><a href="#符号扩展" class="headerlink" title="符号扩展"></a>符号扩展</h4><p>要将一个<strong>补码数字</strong>转换成一个<strong>更大的</strong>数据类型，可以执行一个符号扩展，在表示中添加最高有效位的值。表示为如下原理。</p>
<p>定义宽度为 w的位向量 $\overrightarrow{x} = [x<em>{w-1},x</em>{w-2},…,x<em>0]$ 和宽度为 w的位向量 $\overrightarrow{x}’ = [x</em>{w-1},…,x<em>{w-1},x</em>{w-1},x<em>{w-2},…,x_0]$ ,其中 $w’&gt;w$ 。 则 $B2T_w(\overrightarrow{x}) =B2T</em>{w’}(\overrightarrow{x’})$</p>
<p>比如下面这个例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">short sx = <span class="number">-12345</span>; <span class="comment">/* -12345 */</span></span><br><span class="line"><span class="keyword">unsigned</span> short usx = sx; <span class="comment">/* 53191 */</span></span><br><span class="line"><span class="keyword">int</span> x = sx; <span class="comment">/* -12345 */</span></span><br><span class="line"><span class="keyword">unsigned</span> ux = usx; <span class="comment">/* 53191 */</span></span><br></pre></td></tr></table></figure>
<p>打印如下：</p>
<p>sx = -12345: cf c7<br>usx = 53191: cf c7<br>x = -12345: ff ff cf c7<br>ux = 53191: 00 00 cf c7</p>
<p>我们可以观察到，-12345的补码和53191的无符号表示在16位字长时是相同的，但是在32位字长时却不同的。因为前者用的是符号扩展，后者用的是零扩展</p>
<h3 id="Truncating-Numbers"><a href="#Truncating-Numbers" class="headerlink" title="Truncating Numbers"></a>Truncating Numbers</h3><p>刚才我们讲了怎么从位数较少的拓展成位数较多的数，现在来看看高位数怎么截断成较少位数</p>
<p>当我们将一个w位的数$ \overrightarrow{x} = [x<em>{w-1},x</em>{w-2},\cdots,x<em>0]$ 截断位一个k位数字时，我们会丢弃高 $w-k$ 位，得到一个位向量 $\overrightarrow{x’} =[x</em>{k-1},x_{k-2},\cdots,x_0]$  阶段一个数字很可能会改变它的值。</p>
<h4 id="截断无符号数"><a href="#截断无符号数" class="headerlink" title="截断无符号数"></a>截断无符号数</h4><p>对一个无符号数，我们可以很容易得出其数值结果</p>
<p>令$\overrightarrow{x} $ 等于位向量 $ \overrightarrow{x} = [x<em>{w-1},x</em>{w-2},\cdots,x<em>0]$ ,而 $\overrightarrow{x’}$  是将其截断为k位的结果：$\overrightarrow{x’} =[x</em>{k-1},x_{k-2},\cdots,x_0]$ 。 令 $x=B2U_w(\overrightarrow {x}),x’ = B2U_k(\overrightarrow{x’})$ 则 $x’ = x <del>mod</del> 2^k$</p>
<h4 id="截断补码数值"><a href="#截断补码数值" class="headerlink" title="截断补码数值"></a>截断补码数值</h4><p>截断补码也具有相似的属性，只不过要<strong>将最高位转换为符号位</strong>。</p>
<p>令 $\overrightarrow{x}$ 等于位向量 $[x<em>{w-1},x</em>{w-2},\cdots,x<em>0]$ ,而 $\overrightarrow{x’} $ 是将其截断为k位的结果： $\overrightarrow{x’} =[x</em>{k-1},x_{k-2},…,x_0]$ 令 $x=B2U_w(\overrightarrow{x})$, $x’ = B2T_k(\overrightarrow{x’})$ 则 $x’ = U2T_k(x <del>mod</del> 2^k)$ </p>
<p>在这个公式中， $x ~~ mod ~~2^k$ 将是一个 0 到 $2^k-1$ 之间的一个数。对其应用函数 $U2T<em>k$ 产生的效果就是把最高的有效位 $x</em>{k-1}$  的权重从 $2^{k-1}$ 转变为 $-2^{k-1}$ 。 举例来看，将数值 $x=53191$ 从int 转换为short。 由于 $2^{16} =66536 \geq x$ 我们有  $x ~~ mod ~~ 2^{16} =x$ 但是，当我们把这个数转换为16位的补码时，我们得到了 $x’ = 53191-65536 = -12345$ </p>
<h3 id="扩展和截断小结"><a href="#扩展和截断小结" class="headerlink" title="扩展和截断小结"></a>扩展和截断小结</h3><p>扩展：</p>
<p>⽆符号：加 0<br>有符号：最⾼位扩展<br>结果可靠（可预期）</p>
<p>截断：</p>
<p>⽆论有⽆符号：去掉⾼位，结果重新解释<br>⽆符号：等同于取模运算<br>有符号：类似于取模运算(先取模再重新解释)<br>对于不太⼤的数，结果可靠（可预期）</p>
<h3 id="Advice-on-Signed-versus-Unsigned"><a href="#Advice-on-Signed-versus-Unsigned" class="headerlink" title="Advice on Signed versus Unsigned"></a>Advice on Signed versus Unsigned</h3><p>就像我们看到的那样，有符号数到无符号数的隐式强制类型转换导致了某些非直观的行为。而这些非直观的特性经常导致程序错误，并且这种包含隐式强制类型转换的细微差别的错误很难被发现。因为这种强制类型转换是在代码中没有明确指示的情况下发生的，程序员经常忽视了它的影响。<br>下面两个练习题说明了某些由于隐式强制类型转换和无符号数据类型造成的细微的错误</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* WARNING: This is buggy code */</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">sum_elements</span><span class="params">(<span class="keyword">float</span> a[], <span class="keyword">unsigned</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">float</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= length<span class="number">-1</span>; i++)</span><br><span class="line">		result += a[i];</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当参数length 等于0 时，运行这段代码应该返回0.0。 但实际上，运行时会遇到一个内存错误。请解释为什么会发生这样的情况，并且说明如何修改代码.</p>
<p>因为length是unsigned 的，那么0-1 就会变成了Umax也就是4294967295，但是 $&lt;=$ 这个符号同样使用无符号数比较，而因为任何书都是小于等于UMax的，所以这个比较总是为真。因此代码将试图访问数组a的非法元素。</p>
<p>我们可以将length修改为int类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Prototype for library function strlen */</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br><span class="line">	<span class="comment">//Here is your first attempt at the function:</span></span><br><span class="line"><span class="comment">/* Determine whether string s is longer than string t */</span></span><br><span class="line"><span class="comment">/* WARNING: This function is buggy */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strlonger</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">char</span> *t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">strlen</span>(s) - <span class="built_in">strlen</span>(t) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你在一些示例数据上测试这个函数时，一切似乎都是正确的。进一步研究发现在头文件stdio.h 中数据类型size_t 是定义成unsigned int 的。并解释为什么会出现这样不正确的结果。</p>
<p>当s比t更短的时候，因为strlen(s)和strlen(t) 都是unsigned的，所以不会出现负数而是一个很大的正数，任然会返回1<br>C. 说明如何修改这段代码好让它能可靠地工作 将代码修改为：return strlen(s) &gt; strlen(t);</p>
<h2 id="解题要点："><a href="#解题要点：" class="headerlink" title="解题要点："></a>解题要点：</h2><h3 id="Unsigned和补码之间的比较"><a href="#Unsigned和补码之间的比较" class="headerlink" title="Unsigned和补码之间的比较"></a>Unsigned和补码之间的比较</h3><p>如果左边的数是Unsigned，那么<strong>右边的数也会自动转换成Unsigned</strong>(最后一题有点坑)</p>
<p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/17.png" style="zoom:100%;"></p>
<p>最后一题，-2147483647-1U 会变成0，同时右边的-2147483647 会转换成1，0&lt;1 所以正确</p>
<p><img src="/2020/09/15/CSAPP%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AD%98%E5%82%A8/18.png" style="zoom:100%;"></p>
<p>对于fun1 来说，是unsigned类型移位之后再转换为int，所以进行的操作是左移或者逻辑右移</p>
<p>对于fun2 来说，左移后先转换成int再进行算术右移。</p>
<p>所以fun1就是不用变化，而对于fun2，我们要看哪些数在左移后以1开头，我们发现是0xC9000000 和 0x87000000,那么算数右移后，fun2(w) = 0xFFFFFFC9 和 0xFFFFFF87 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/09/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/" class="post-title-link" itemprop="url">深入了解计算机系统简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-14 15:54:39 / Modified: 23:22:34" itemprop="dateCreated datePublished" datetime="2020-09-14T15:54:39+08:00">2020-09-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="深入了解计算机系统简介"><a href="#深入了解计算机系统简介" class="headerlink" title="深入了解计算机系统简介"></a>深入了解计算机系统简介</h1><h3 id="从helloworld入手"><a href="#从helloworld入手" class="headerlink" title="从helloworld入手"></a>从helloworld入手</h3><p>首先我们来理解一下简单的hello world 程序是怎么被电脑执行的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello, world\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个hello.c 文件在被电脑执行之前需要比其他程序转化为一系列的低级机器语言指令。然后这些指令按照一种称为可执行目标程序的格式打好包，并以<strong>二进制磁盘文件</strong>的形式存放起来。目标程序也成为可执行目标文件。</p>
<p>整个过程如下所示。</p>
<p><img src="/2020/09/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1.png"></p>
<ul>
<li>首先是preprocessor 阶段，预处理器(cpp) 会以# 开头的命令修改原始的C程序。比如 <code>hello.c</code>中的第一行<code>#include &lt;stdio.h&gt;</code> 命令告诉预处理器读取系统头文件 <code>stdio.h</code> 的内容，并把它直接插入到程序文本当中，结果就得到了另一个C程序，通常是以<code>.i</code>作为文件扩展名</li>
</ul>
<p>我们在命令行中敲入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure>
<p>预处理器就会读取头文件的内容然后直接插入到程序文本当中去。一共添加了了600多行，这里截取了最后一段。上面所有的内容都是头文件<code>stdio.h</code> 中包含的</p>
<p><img src="/2020/09/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/2.png"></p>
<ul>
<li>第二个阶段是编译阶段。编译器(ccl) 会将文本文件 <code>hello.i</code> 翻译成 <strong>文本文件</strong> <code>hello.s</code> 它包含一个汇编语言程序。该程序包含函数main的定义我们敲入命令行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure>
<p>随后文件夹下会多出一个<code>hello.s</code> 的文件，文件中的语言是汇编语言，是一种低级机器语言指令。文件中包含一个main函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   .file  &quot;hello.c&quot;</span><br><span class="line">   .def   __main;    .scl   2; .type  32;    .endef</span><br><span class="line">   .section .rdata,&quot;dr&quot;</span><br><span class="line">.LC0:</span><br><span class="line">   .ascii &quot;hello, world\0&quot;</span><br><span class="line">   .text</span><br><span class="line">   .globl main</span><br><span class="line">   .def   main;  .scl   2; .type  32;    .endef</span><br><span class="line">   .seh_proc  main</span><br><span class="line">main:</span><br><span class="line">   pushq  %rbp</span><br><span class="line">   .seh_pushreg   %rbp</span><br><span class="line">   movq   %rsp, %rbp</span><br><span class="line">   .seh_setframe  %rbp, 0</span><br><span class="line">   subq   $32, %rsp</span><br><span class="line">   .seh_stackalloc    32</span><br><span class="line">   .seh_endprologue</span><br><span class="line">   call   __main</span><br><span class="line">   leaq   .LC0(%rip), %rcx</span><br><span class="line">   call   puts</span><br><span class="line">   movl   $0, %eax</span><br><span class="line">   addq   $32, %rsp</span><br><span class="line">   popq   %rbp</span><br><span class="line">   ret</span><br><span class="line">   .seh_endproc</span><br><span class="line">   .ident &quot;GCC: (tdm64-1) 4.9.2&quot;</span><br><span class="line">   .def   puts;  .scl   2; .type  32;    .endef</span><br></pre></td></tr></table></figure>
<p>汇编语言是非常有用的。它为不同的高级语言的不同编译器提供了通用的输出语言</p>
<ul>
<li>汇编阶段 是汇编器(as) 将hello.s 翻译成机器语言指令，把这些指令打包成一种可叫做 relocatable object program 的格式，并将结果保存在目标文件hello.o 当中。hello.o文件是一个二进制文件，它包含的17 个字节是函数main的指令编码。如果我们在文本编辑器中打开hello.o文件，将看到一堆乱码。</li>
</ul>
<p>在命令行中输入,文件夹下多出一个 hello.o 的文件 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure>
<p><img src="/2020/09/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/3.png"></p>
<ul>
<li>最后一个是链接阶段。hello程序调用了printf函数，他是每个C编译器都提供的标准C库中的一个函数。printf函数存在于一个名为printf.o 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的hello.o 程序中。链接器(ld)就负责处理这种合并. 结果就得到了hello文件，它是一个可执行目标文件，可以加载到内存中并被系统调用</li>
</ul>
<h3 id="计算机是怎么运行hello程序的呢？"><a href="#计算机是怎么运行hello程序的呢？" class="headerlink" title="计算机是怎么运行hello程序的呢？"></a>计算机是怎么运行hello程序的呢？</h3><p>下面是一个冯诺依曼架构的计算机模型。里面分为好几个部分：主线，输入/输出，主存，处理器等。初始时，shell程序执行它的指令，等待我们输入一个命令当我们在键盘上输人字符串“./hello”后，shell 程序将字符逐一读入寄存器，再把它存放到内存中</p>
<p><img src="/2020/09/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/4.png"></p>
<p>当我们按下回车键的时候，shell会执行一系列指令来加载可执行的hello文件，这些指令将hello目标文件中的代码和数据从磁盘复制到主存。数据包括最终会被输出的字符串 “hello,world\n”</p>
<p><img src="/2020/09/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/5.png"></p>
<p>一旦目标文件hello 中的代码和数据被加载到主存，处理器就开始执行hello 程序的main 程序中的机器语言指令。这些指令将“hello, world\n 字符串中的字节从主存复制到寄存器文件(Register file)，再从寄存器文件中复制到显示设备，最终显示在屏幕上.</p>
<p><img src="/2020/09/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/6.png"></p>
<h3 id="存储设备形成层次结构"><a href="#存储设备形成层次结构" class="headerlink" title="存储设备形成层次结构"></a>存储设备形成层次结构</h3><p>每个计算机系统中的存储设备都被组织成了一个存储器层次结构。在这个层次结构中，从上至下，设备的访<br>问速度越来越慢、容量越来越大，并且每字节的造价也越来越便宜。寄存器文件在层次结构中位于最顶部，也就是第0级或记为$L_0$ 这里我们展示的是三层高速缓存L1 到L3,占据存储器层次结构的第1层到第3层。主存在第4 层, 以此类推。</p>
<p>存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。因此，寄存器文件就是L1 的高速缓存，L1 是L2 的高速缓存，L2 是L3 的高速缓存，L3 是主存 的高速缓存，而主存又是磁盘的高速缓存。在某些具有分布式文件系统的网络系统中，本地磁盘就是存储在其他系统中磁盘上的数据的高速缓存。</p>
<p>程序员可以利用对整个存储器层次结构的理解来提高程序性能。</p>
<p><img src="/2020/09/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/7.png"></p>
<h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><ol>
<li>测试自己的编程环境下，C语言是否允许void main()？如果出错，报什么类型的错误。<br>如果文件为.cpp 的话，void main()会出现报错’::main’ must return ‘int’ ，<br><img src="/2020/09/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/1.jpg"></li>
</ol>
<p>但是如果是.c文件的话，void main() 是可以通过编译并且运行的。<br><img src="/2020/09/14/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/2.jpg"></p>
<p>这是因为.cpp文件和.c文件的编译器是不同的。.c 文件的编译器是<code>gcc</code>，而<code>.cpp</code>文件的编译器是<code>g++</code>. </p>
<ol>
<li>尝试使用一个<code>int</code>型的4096x4096的二维数组，如果遇到错误，了解不同错误消息的具体含义。</li>
</ol>
<p>如果把这个二维数组定义在main() 函数当中, 那么是无法定义的。会遇到错误 ”Process finished with exit code -1073741571 (0xC00000FD)”，报错的提示是程序意外终止。查阅资料得到原因 StackOverflow也就是栈区溢出。Windows下栈区默认的大小为1024kb，但是4096x4096xsizeof(int) /1024/1024 =16 MB,所以导致了栈区溢出</p>
<p>但是如果把二维数组设置为静态变量或者全局变量，那么编译器并不会给报错。这是因为它们存储在大小比规定栈的大小更大的静态储存区，因此能申请到更大的数据。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/19/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><span class="page-number current">20</span><a class="page-number" href="/page/21/">21</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/21/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jason</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">439</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    

  

</body>
</html>
