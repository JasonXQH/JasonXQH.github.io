<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=">


  <link rel="mask-icon" href="/images/logo.svg?v=" color="#222">














<meta property="og:type" content="website">
<meta property="og:title" content="Jason‘s Blog">
<meta property="og:url" content="https://jasonxqh.github.io/page/16/index.html">
<meta property="og:site_name" content="Jason‘s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '',
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    fancybox: false,
    tabs: ,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: 'undefined',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>







  <title>Jason‘s Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', '[object Object]', 'auto');
  ga('send', 'pageview');
</script>





<meta name="generator" content="Hexo 4.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">
  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
<a href="https://github.com/JasonXQH/JasonXQH.github.io" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jason‘s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/%20" rel="section">
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/01/22/malloc-lab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/22/malloc-lab/" itemprop="url">malloc_lab</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-22T16:10:40+08:00">
                2021-01-22
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2021-01-31T21:23:20+08:00">
                2021-01-31
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="malloc-lab"><a href="#malloc-lab" class="headerlink" title="malloc lab"></a>malloc lab</h1><h2 id="隐式空闲链表-书本"><a href="#隐式空闲链表-书本" class="headerlink" title="隐式空闲链表(书本)"></a>隐式空闲链表(书本)</h2><h3 id="基本设计"><a href="#基本设计" class="headerlink" title="基本设计"></a>基本设计</h3><p>在博客<a href="https://jasonxqh.github.io/2020/12/01/CSAPP动态内存分配/">CSAPP动态内存分配</a> 中，我们已经详细介绍了隐式空闲链表的分配原理了。那么我们这次就来手动实现一个简单的分配器</p>
<p>首先我们来介绍一下分配器需要输出给应用程序的三个函数： </p>
<p><code>extern int mm_init(void)</code>  这个函数的作用是初始化分配器，如果成功，那么就返回0；否则就返回-1</p>
<p><code>extern void *mm_malloc(size_t size)</code>  这个函数就是分配空间</p>
<p><code>extern void mm_free(void *ptr)</code>    这个函数是释放空间</p>
<p>我们要申请的块格式如下，具有头部和尾部，最小的块大小为16字节：</p>
<p><img src="/2021/01/22/malloc-lab/1.png" style="zoom:80%;"></p>
<p>整一个隐式空闲链表如下图所示：</p>
<p><img src="/2021/01/22/malloc-lab/2.png" style="zoom:80%;"></p>
<p>第一个字是一个双字边界对齐的不使用的填充字。填充后面紧跟着一个特殊的序言块。这是一个8字节的已分配块，只由头部和尾部组成。序言块是在初始化的时候创建的，并且是永不释放的。在序言块的后面紧跟着的是零个或者多个由mallock或者free调用创建的普通块。在结尾处，是一个大小为0的已分配块，只由一个头部组成。</p>
<p>序言块和结尾块是一种消除合并时边界条件的技巧。</p>
<h3 id="宏介绍"><a href="#宏介绍" class="headerlink" title="宏介绍"></a>宏介绍</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGNMENT 8<span class="comment">//首先是ALIGNMENT，也就是我们要8字节对齐，向8的倍数舍入。</span></span></span><br><span class="line"><span class="comment">/* rounds up to the nearest multiple of ALIGNMENT */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALIGN(size) (((size) + (ALIGNMENT - 1)) &amp; ~0x7)</span></span><br><span class="line"><span class="comment">//这是为size找到比它大又是最小的8的倍数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_T_SIZE (ALIGN(sizeof(size_t)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WSIZE 4				<span class="comment">//单字长度</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DSIZE 8             <span class="comment">/*Double word size*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNKSIZE (1 &lt;&lt; 12) <span class="comment">/*the page size in bytes is 4K*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x, y) ((x) &gt; (y) ? (x) : (y))<span class="comment">//两个数中取最大值</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PACK(size, alloc) ((size) | (alloc)) <span class="comment">//将分配大小和标记位合并</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET(p) (*(unsigned int *)(p)) <span class="comment">//读取和返回参数p引用的字</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUT(p, val) (*(unsigned int *)(p) = (val))<span class="comment">//将val存放在p指向的字中</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_SIZE(p) (GET(p) &amp; ~0x7)<span class="comment">// 从地址p处的头部或者脚部返回大小</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)<span class="comment">// 返回已分配位</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HDRP(bp) ((char *)(bp)-WSIZE)<span class="comment">//给定块指针，返回它的头部指针</span></span></span><br><span class="line"><span class="comment">//此bp是从有效载荷开始的，因此指向块的头部，得减去一个4字节</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)<span class="comment">//给定快指针，返回它的脚部指针</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp)-WSIZE)))</span></span><br><span class="line"><span class="comment">//下一个块的有效载荷处</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_BLKP(bp) ((char *)(bp)-GET_SIZE(((char *)(bp)-DSIZE)))</span></span><br><span class="line"><span class="comment">//指向前面的块的块指针</span></span><br></pre></td></tr></table></figure>
<h3 id="mm-init"><a href="#mm-init" class="headerlink" title="mm_init"></a>mm_init</h3><p>mm_init函数从内存系统得到4个字，并将其初始化，创建一个<strong>空的空闲链表</strong>。然后它调用extend_heap函数。这个函数将堆扩展<code>CHUNKSIZE</code> 字节，并且创建初始的空闲块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((heap_listp = mem_sbrk(<span class="number">4</span> * WSIZE)) == (<span class="keyword">void</span> *)<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PUT(heap_listp, <span class="number">0</span>); <span class="comment">//哨头</span></span><br><span class="line">    PUT(heap_listp + (<span class="number">1</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//序言头块，在此地址上写上块大小的数据</span></span><br><span class="line">    PUT(heap_listp + (<span class="number">2</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//序言尾块，在此地址上写上块大小的数据</span></span><br><span class="line">    PUT(heap_listp + (<span class="number">3</span> * WSIZE), PACK(<span class="number">0</span>, <span class="number">1</span>)); <span class="comment">//结束块</span></span><br><span class="line">    heap_listp += (<span class="number">2</span> * WSIZE);</span><br><span class="line">    <span class="comment">// 为我们的链表创造CHUNKSIZE的空间</span></span><br><span class="line">    <span class="keyword">if</span> (extend_heap(CHUNKSIZE / WSIZE) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，分配器已经初始化了，并且准备好接受来自应用的分配和释放请求</p>
<h3 id="extend-heap"><a href="#extend-heap" class="headerlink" title="extend_heap"></a>extend_heap</h3><p>这个函数当堆被初始化的时候或者当<code>mm_malloc</code> 不能找到一个合适的分配块的时候。为了保持对齐，extend_heap会将其请求大小向上舍入为最接近的2字(8字节)的倍数，然后向内存系统请求额外的堆空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">extend_heap</span><span class="params">(<span class="keyword">size_t</span> words)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">size</span> = (words % <span class="number">2</span>) ? (words + <span class="number">1</span>) * WSIZE : words * WSIZE;<span class="comment">//向上舍入</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">long</span>)(bp = mem_sbrk(<span class="built_in">size</span>)) == (<span class="keyword">void</span> *)<span class="number">-1</span>)<span class="comment">//向内存要空间</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    PUT(HDRP(bp), PACK(<span class="built_in">size</span>, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(<span class="built_in">size</span>, <span class="number">0</span>));</span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> coalesce(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="mm-free-函数"><a href="#mm-free-函数" class="headerlink" title="mm_free 函数"></a>mm_free 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bp == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">size</span> = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    PUT(HDRP(bp), PACK(<span class="built_in">size</span>, <span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(<span class="built_in">size</span>, <span class="number">0</span>));</span><br><span class="line">    coalesce(bp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>free函数可以释放一个以前分配的块，这个函数释放所请求的块bp,然后我们将<strong>其与邻接的空闲块合并</strong>起来</p>
<h3 id="coalesce函数"><a href="#coalesce函数" class="headerlink" title="coalesce函数"></a>coalesce函数</h3><p>coalesce函数就是将空闲块合并起来的函数，其函数示意图如下</p>
<p><img src="/2021/01/22/malloc-lab/3.png" style="zoom:100%;"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">coalesce</span><span class="params">(<span class="keyword">void</span> *bp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));<span class="comment">//首先我们获得前后块的分配位</span></span><br><span class="line">    <span class="keyword">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    <span class="keyword">size_t</span> <span class="built_in">size</span> = GET_SIZE(HDRP(bp));</span><br><span class="line">	<span class="comment">//如果前面和后面都是已分配的，那么就直接返回bp</span></span><br><span class="line">    <span class="keyword">if</span> (prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    <span class="comment">//如果前面的块已分配，后面的块没有分配，那么Size就等于当前块加上后面的块的大小</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (prev_alloc &amp;&amp; !next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">size</span> += GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(bp), PACK(<span class="built_in">size</span>, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(<span class="built_in">size</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果后面的块已分配，前面的块没分配，那么size就等于当前块加上前面的块的大小</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!prev_alloc &amp;&amp; next_alloc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">size</span> += GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        PUT(FTRP(bp), PACK(<span class="built_in">size</span>, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(<span class="built_in">size</span>, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果都是空的，那么size就等于前后中三个块的大小，然后修改指针</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">size</span> += GET_SIZE(FTRP(NEXT_BLKP(bp))) + GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)), PACK(<span class="built_in">size</span>, <span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)), PACK(<span class="built_in">size</span>, <span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="mm-malloc函数"><a href="#mm-malloc函数" class="headerlink" title="mm_malloc函数"></a>mm_malloc函数</h3><p>应用会通过调用<code>mm_malloc</code>函数来向内存请求大小为size字节的块。在检查完请求的真假之后，分配器必须调整请求快的大小，从而为头部和脚部留有空间并满足双字对齐的要求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_malloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> asize;</span><br><span class="line">    <span class="keyword">size_t</span> extendsize;</span><br><span class="line">    <span class="keyword">char</span> *bp;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> &lt;= DSIZE)<span class="comment">//强行限制了最小块大小为16字节；8字节用来满足对齐要求，8字节用来放头部尾部</span></span><br><span class="line">        asize = <span class="number">2</span> * (DSIZE);</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//向上舍入到最接近8的整数倍</span></span><br><span class="line">        asize = (DSIZE) * ((<span class="built_in">size</span> + (DSIZE) + (DSIZE - <span class="number">1</span>)) / (DSIZE));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((bp = find_fit(asize)) != <span class="literal">NULL</span>)<span class="comment">//找到合适的block存放</span></span><br><span class="line">    &#123;</span><br><span class="line">        place(bp, asize);</span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    extendsize = MAX(asize, CHUNKSIZE);<span class="comment">//如果没有合适的，那么我们就要extend_size了</span></span><br><span class="line">    <span class="keyword">if</span> ((bp = extend_heap(extendsize / WSIZE)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    place(bp, asize);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="find-fit函数"><a href="#find-fit函数" class="headerlink" title="find_fit函数"></a>find_fit函数</h3><p>这里，我们采取的方法是first_fit,也就是找到第一个符合条件的block来放置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">find_fit</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *bp;</span><br><span class="line">    <span class="keyword">for</span> (bp = heap_listp; GET_SIZE(HDRP(bp)) &gt; <span class="number">0</span>; bp = NEXT_BLKP(bp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!GET_ALLOC(HDRP(bp)) &amp;&amp; (<span class="built_in">size</span> &lt;= GET_SIZE(HDRP(bp))))</span><br><span class="line">            <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最佳适配"><a href="#最佳适配" class="headerlink" title="最佳适配"></a>最佳适配</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">best_fit</span><span class="params">(<span class="keyword">size_t</span> asize)</span></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> *bp = heap_listp;</span><br><span class="line">	<span class="keyword">size_t</span> <span class="built_in">size</span>;</span><br><span class="line">	<span class="keyword">void</span> *best = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">size_t</span> min_size = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((<span class="built_in">size</span> = GET_SIZE(HDRP(bp))) != <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">size</span> &gt;= asize &amp;&amp; !GET_ALLOC(HDRP(bp)) &amp;&amp; (min_size == <span class="number">0</span> || min_size&gt;<span class="built_in">size</span>))&#123;	</span><br><span class="line">            <span class="comment">//记录最小的合适的空闲块</span></span><br><span class="line">			min_size = <span class="built_in">size</span>;</span><br><span class="line">			best = bp;</span><br><span class="line">		&#125;</span><br><span class="line">		bp = NEXT_BLKP(bp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> best;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="place函数"><a href="#place函数" class="headerlink" title="place函数"></a>place函数</h3><p>place函数就是将此适配的块的头部和尾部进行修改，如果剩下的尺寸超过16，则将其重新加入空闲块中，避免内部碎片;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">void</span> *bp, <span class="keyword">size_t</span> asize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> csize = GET_SIZE(HDRP(bp));</span><br><span class="line">    <span class="keyword">if</span> ((csize - asize) &gt;= (<span class="number">2</span> * DSIZE))</span><br><span class="line">    &#123; </span><br><span class="line">        PUT(HDRP(bp), PACK(asize, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(asize, <span class="number">1</span>));</span><br><span class="line">        bp = NEXT_BLKP(bp);</span><br><span class="line">        PUT(HDRP(bp), PACK(csize - asize, <span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(csize - asize, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PUT(HDRP(bp), PACK(csize, <span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp), PACK(csize, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="mm-realloc函数"><a href="#mm-realloc函数" class="headerlink" title="mm_realloc函数"></a>mm_realloc函数</h3><p><code>realloc</code> 函数就是将旧的块中的内容复制到新的块当中去</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> oldsize;</span><br><span class="line">    <span class="keyword">void</span> *newptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If size == 0 then this is just free, and we return NULL. */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mm_free(ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If oldptr is NULL, then this is just malloc. */</span></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> mm_malloc(<span class="built_in">size</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newptr = mm_malloc(<span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If realloc() fails the original block is left untouched  */</span></span><br><span class="line">    <span class="keyword">if</span> (!newptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Copy the old data. */</span></span><br><span class="line">    oldsize = GET_SIZE(HDRP(ptr));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> &lt; oldsize)</span><br><span class="line">        oldsize = <span class="built_in">size</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(newptr, ptr, oldsize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free the old block. */</span></span><br><span class="line">    mm_free(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/01/17/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/17/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/" itemprop="url">哈夫曼编码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-17T16:08:13+08:00">
                2021-01-17
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2021-01-17T19:59:46+08:00">
                2021-01-17
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h1><p>通常的编码方法有固定长度和不等长度编码两种。</p>
<p>最优的编码方案的目的是使总码长度最短。利用字符的使用频率来编码使不等长编码方法，使得经常使用的字符编码较短，不常使用的字符编码较长。</p>
<p>不等长编码方法需要解决的两个关键问题：</p>
<p>1） 编码尽可能的短</p>
<p>使用频率高的字符编码较短，使用频率低的编码较长，可提高压缩率，节省空间，也能提高运算和通信速率。 即出现频率越高，编码越短</p>
<p>2)  编码不能有二义性</p>
<p>解决方法是：任何一个字符的编码不能是另一个字符编码的前缀，即前缀码特性 </p>
<p>于是我们可以通过二叉树编码，频率高的可以离根近一点，频率低的就可以离根远一点。而且，每一个字符都是一个叶子结点，这样就可以避免二义性，因为叶子是绝对不会有孩子的。</p>
<p>我们可以构造一颗哈夫曼树，这是一棵将所要编码的字符作为叶子结点，该字符在文件中的使用频率作为叶子结点的权值，以自底向上的方式，通过n-1次的合并运算后构造的树。其核心思想是让权值大的叶子离根最近。</p>
<p>哈夫曼采取的贪心策略是：每次从树的集合中取出没有双亲且权值最小的两颗树作为左右子树，并一次构建一颗新的树。新书根节点的权值为其左右孩子节点权值之和，将新树插入到树的集合中</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="/2021/01/17/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/1.png"></p>
<p>为了方便起见，我们可以将频率同时扩大100倍。</p>
<ol>
<li>我们选择没有双亲且权值最小的两个结点，$t_1,t_2$</li>
<li>将$t_1,t_2$作为左右子树构建一颗新的树,这里是a和d</li>
<li>将他们组合成一个新的树，他们的父结点的权重为12，这个12也需要加入到集合中作比较</li>
</ol>
<p><img src="/2021/01/17/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/1.jpg" style="zoom:50%;"></p>
<ol>
<li>接下来，f 和新结点组合生成了新的树</li>
</ol>
<p><img src="/2021/01/17/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/2.jpg" style="zoom:50%;"></p>
<p>但是现在问题来了，当前的集合中，最小是c，次小为e和新的结点。我们该选哪个？ 答案是选择 e。因为新产生的结点会放在集合的后面。我们碰到一样权重的节点的时候，选择前面那个。</p>
<p>最后，我们的哈夫曼树如下：</p>
<p><img src="/2021/01/17/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/3.jpg" style="zoom:50%;"></p>
<p>一般我们在程序中将最小的元素设置成左孩子，次小的设置成右孩子。</p>
<h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><h3 id="确定合适的数据结构"><a href="#确定合适的数据结构" class="headerlink" title="确定合适的数据结构"></a>确定合适的数据结构</h3><ul>
<li>哈夫曼树中没有度为1的结点，则一颗n个叶子结点的哈夫曼树共有 2n-1 个结点(n-1次的合并，每次产生一个新的结点)</li>
<li>构成哈夫曼树之后，为求编码需从叶子节点出发走一条<strong>从叶子到根的路径</strong>，是左孩子就编成0，是右孩子就编成1。</li>
<li>译码需要从根出发走一条从根到叶子的路径，那么对于每个结点而言，我们要知道每个结点的权值、双亲、左孩子和右孩子和节点的信息</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">double</span> weight;</span><br><span class="line">	<span class="keyword">int</span> parent;</span><br><span class="line">	<span class="keyword">int</span> lchild;</span><br><span class="line">	<span class="keyword">int</span> rchild;</span><br><span class="line">	<span class="keyword">char</span> value;<span class="comment">//该结点表示的字符</span></span><br><span class="line">&#125;HNodeType;</span><br></pre></td></tr></table></figure>
<p>下面我们来写出哈夫曼树的构建数组</p>
<p><img src="/2021/01/17/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/2.png"></p>
<p> 最终这张表如下图所示：</p>
<p><img src="/2021/01/17/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/3.png"></p>
<p>构建哈夫曼树的过程就是填写这张表的过程</p>
<p>编写哈夫曼编码的过程就是读表的过程</p>
<p>对于编码的存储，我们可以用这样一个struct数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">bit</span>[MAXBIT];<span class="comment">//存储编码的数组，从后往前存</span></span><br><span class="line">	<span class="keyword">int</span> start;		<span class="comment">//编码开始下标 </span></span><br><span class="line">&#125;HCodeType;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/01/17/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/4.png"></p>
<h3 id="哈夫曼树带权路径长度"><a href="#哈夫曼树带权路径长度" class="headerlink" title="哈夫曼树带权路径长度"></a>哈夫曼树带权路径长度</h3><p>WPL = 每个叶子的权值X该叶子到根的路径长度之和。 哈夫曼树带权路径长度之和等于各新生成节点的权值之和 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXBIT    100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVALUE  10000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEAF   30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXNODE   MAXLEAF*2 -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> weight;</span><br><span class="line">    <span class="keyword">int</span> parent;</span><br><span class="line">    <span class="keyword">int</span> lchild;</span><br><span class="line">    <span class="keyword">int</span> rchild;</span><br><span class="line">    <span class="keyword">char</span> value;</span><br><span class="line">&#125; HNodeType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">bit</span>[MAXBIT];</span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">&#125; HCodeType;</span><br><span class="line">HNodeType HuffNode[MAXNODE];<span class="comment">//定义一个结点结构体数组</span></span><br><span class="line">HCodeType HuffCode[MAXLEAF];<span class="comment">//定义一个编码结构体数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanTree</span> <span class="params">(HNodeType HuffNode[MAXNODE],  <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, x1, x2;<span class="comment">//最小值的下标和次小值得下标</span></span><br><span class="line">    <span class="keyword">double</span> m1,m2;<span class="comment">//最小值和次小值的权值</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">2</span>*n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        HuffNode[i].weight=<span class="number">0</span>;</span><br><span class="line">        HuffNode[i].parent=<span class="number">-1</span>;</span><br><span class="line">        HuffNode[i].lchild=<span class="number">-1</span>;</span><br><span class="line">        HuffNode[i].rchild=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Please input value and weight of leaf node "</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;HuffNode[i].value&gt;&gt;HuffNode[i].weight;<span class="comment">//输入值和weight</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)<span class="comment">//n-1次合并</span></span><br><span class="line">    &#123;</span><br><span class="line">        m1=m2=MAXVALUE;</span><br><span class="line">        x1=x2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;n+i;j++)<span class="comment">//找最小，每次要加上新的结点</span></span><br><span class="line">        &#123;<span class="comment">//满足的条件就是比m_1还小并且还没有父亲</span></span><br><span class="line">            <span class="keyword">if</span> (HuffNode[j].weight&lt;m1&amp;&amp;HuffNode[j].parent==<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                m2 = m1;</span><br><span class="line">                x2 = x1;</span><br><span class="line">                m1 = HuffNode[j].weight;</span><br><span class="line">                x1 = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//或者比次小值还小，并且没有父亲结点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (HuffNode[j].weight &lt; m2 &amp;&amp; HuffNode[j].parent==<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                m2=HuffNode[j].weight;</span><br><span class="line">                x2=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新节点的信息</span></span><br><span class="line">        HuffNode[x1].parent  = n+i;</span><br><span class="line">        HuffNode[x2].parent  = n+i;</span><br><span class="line">        HuffNode[n+i].weight = m1+m2;</span><br><span class="line">        HuffNode[n+i].lchild = x1;</span><br><span class="line">        HuffNode[n+i].rchild = x2;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"x1.weight and x2.weight in round "</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">"\t"</span>&lt;&lt;HuffNode[x1].weight&lt;&lt;<span class="string">"\t"</span>&lt;&lt;HuffNode[x2].weight&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanCode</span><span class="params">(HCodeType HuffCode[MAXLEAF],  <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    HCodeType cd;<span class="comment">//定义一个临时变量来存放求解编码时候的信息</span></span><br><span class="line">    <span class="keyword">int</span> i,j,c,p;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//从0号结点开始，为n个结点依次编码</span></span><br><span class="line">    &#123;</span><br><span class="line">        cd.start=n<span class="number">-1</span>; </span><br><span class="line">        c=i;</span><br><span class="line">        p=HuffNode[c].parent;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="number">-1</span>)<span class="comment">//从叶子向上找</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(HuffNode[p].lchild==c)</span><br><span class="line">                cd.<span class="built_in">bit</span>[cd.start]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cd.<span class="built_in">bit</span>[cd.start]=<span class="number">1</span>;</span><br><span class="line">            cd.start--;<span class="comment">//start指向标前移一位</span></span><br><span class="line">            c=p;<span class="comment">//更新当前得结点以及它的父结点</span></span><br><span class="line">            p=HuffNode[c].parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j=cd.start+<span class="number">1</span>; j&lt;n; j++)<span class="comment">//将cd中的数组赋值给Huffcode</span></span><br><span class="line">           HuffCode[i].<span class="built_in">bit</span>[j]=cd.<span class="built_in">bit</span>[j];</span><br><span class="line">        HuffCode[i].start=cd.start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Please input n:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    HuffmanTree(HuffNode,n);  </span><br><span class="line">    HuffmanCode(HuffCode,n);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;HuffNode[i].value&lt;&lt;<span class="string">": Huffman code is: "</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=HuffCode[i].start+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;HuffCode[i].<span class="built_in">bit</span>[j];</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/01/17/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/17/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" itemprop="url">算法期末复习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-17T10:41:15+08:00">
                2021-01-17
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2021-01-17T21:47:50+08:00">
                2021-01-17
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="算法期末复习"><a href="#算法期末复习" class="headerlink" title="算法期末复习"></a>算法期末复习</h1><h2 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p><a href="https://jasonxqh.github.io/2020/08/28/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%92%8C%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/">https://jasonxqh.github.io/2020/08/28/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%92%8C%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</a></p>
<h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><h2 id="渐近符号"><a href="#渐近符号" class="headerlink" title="渐近符号"></a>渐近符号</h2><p><a href="https://blog.csdn.net/so_geili/article/details/53353593" target="_blank" rel="noopener">https://blog.csdn.net/so_geili/article/details/53353593</a></p>
<p><img src="/2021/01/17/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/1.png" style="zoom:80%;"></p>
<h3 id="渐近紧确界记号-Theta"><a href="#渐近紧确界记号-Theta" class="headerlink" title="渐近紧确界记号 $\Theta$"></a>渐近紧确界记号 $\Theta$</h3><p><img src="/2021/01/17/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/2.png" style="zoom:80%;"></p>
<h3 id="渐近上界记号：-O"><a href="#渐近上界记号：-O" class="headerlink" title="渐近上界记号：$O$"></a>渐近上界记号：$O$</h3><p><img src="/2021/01/17/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/3.png" style="zoom:80%;"></p>
<h3 id="渐近下界记号：-Omega"><a href="#渐近下界记号：-Omega" class="headerlink" title="渐近下界记号：$\Omega$"></a>渐近下界记号：$\Omega$</h3><p><img src="/2021/01/17/%E7%AE%97%E6%B3%95%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/4.png" style="zoom:80%;"></p>
<h3 id="非渐近紧确上界：-o"><a href="#非渐近紧确上界：-o" class="headerlink" title="非渐近紧确上界：$o$"></a>非渐近紧确上界：$o$</h3><p> 小o和大O的区别就在于：</p>
<p>$O(n^2)$可以是 n,2n,1,$2n^2$等，但是$o(n^2)$ 可以是 n,1,3n等,但不能是 $n^2$ ,是 小于号的关系</p>
<h3 id="非渐近紧确下界：-omega"><a href="#非渐近紧确下界：-omega" class="headerlink" title="非渐近紧确下界：$\omega$"></a>非渐近紧确下界：$\omega$</h3><p>和o与O的关系一样。$ω(n^2)$可以是$n^3,n^{10}$等,但不能是$n^2$。$Ω(n^2)$可以是$n^2,n^3$,$n^{10}$等。</p>
<h2 id="分治策略"><a href="#分治策略" class="headerlink" title="分治策略*"></a>分治策略*</h2><h3 id="矩阵乘法-Strassen"><a href="#矩阵乘法-Strassen" class="headerlink" title="矩阵乘法 Strassen"></a>矩阵乘法 Strassen</h3><h3 id="代入法求解递归式"><a href="#代入法求解递归式" class="headerlink" title="代入法求解递归式"></a>代入法求解递归式</h3><h3 id="递归树方法求解递归式"><a href="#递归树方法求解递归式" class="headerlink" title="递归树方法求解递归式"></a>递归树方法求解递归式</h3><h3 id="主方法求解递归式"><a href="#主方法求解递归式" class="headerlink" title="主方法求解递归式"></a>主方法求解递归式</h3><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><a href="https://jasonxqh.github.io/2020/05/07/%E5%A0%86%E6%8E%92%E5%BA%8F/">https://jasonxqh.github.io/2020/05/07/%E5%A0%86%E6%8E%92%E5%BA%8F/</a></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><a href="https://jasonxqh.github.io/2020/05/06/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/">https://jasonxqh.github.io/2020/05/06/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</a></p>
<h2 id="线性时间排序"><a href="#线性时间排序" class="headerlink" title="线性时间排序*"></a>线性时间排序*</h2><h3 id="排序算法的下界"><a href="#排序算法的下界" class="headerlink" title="排序算法的下界"></a>排序算法的下界</h3><h3 id="记数排序与基数排序"><a href="#记数排序与基数排序" class="headerlink" title="记数排序与基数排序"></a>记数排序与基数排序</h3><h2 id="中位数和顺序统计量"><a href="#中位数和顺序统计量" class="headerlink" title="中位数和顺序统计量*"></a>中位数和顺序统计量*</h2><h3 id="期望为线性的时间"><a href="#期望为线性的时间" class="headerlink" title="期望为线性的时间"></a>期望为线性的时间</h3><h3 id="最坏为线性的时间"><a href="#最坏为线性的时间" class="headerlink" title="最坏为线性的时间"></a>最坏为线性的时间</h3><h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><h3 id="散列表-1"><a href="#散列表-1" class="headerlink" title="散列表"></a>散列表</h3><p><a href="https://jasonxqh.github.io/2020/05/09/hashtable/">https://jasonxqh.github.io/2020/05/09/hashtable/</a></p>
<h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><h4 id="线性探查"><a href="#线性探查" class="headerlink" title="线性探查"></a>线性探查</h4><p>给定一个普通的散列函数 <code>h&#39;</code>,称之为辅助散列函数，线性探查采用的散列函数为： $h(k,i)=(h’(k)+i)\mod~m$</p>
<h4 id="二次探查"><a href="#二次探查" class="headerlink" title="二次探查"></a>二次探查</h4><p>二次探查采用这种散列函数 $h(k,i)=(h’(k)+c_1i+c_2i^2)\mod m$ </p>
<p>其中 $h’$ 是一个辅助散列函数，$c_1,c_2$为正的辅助常数</p>
<h4 id="双重散列"><a href="#双重散列" class="headerlink" title="双重散列"></a>双重散列</h4><p>双重散列是用于开放寻址法最好的方法之一，因为它所产生的排列具有随机选择排列的许多特性。双重散列采用如喜爱形式的散列函数</p>
<p>$h(k,i)=(h_1(k)+ih_2(k)) \mod m$</p>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p><a href="https://jasonxqh.github.io/2020/06/17/BSTandAVL/">https://jasonxqh.github.io/2020/06/17/BSTandAVL/</a></p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h3 id="查询、插入、删除"><a href="#查询、插入、删除" class="headerlink" title="查询、插入、删除"></a>查询、插入、删除</h3><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p><a href="https://jasonxqh.github.io/2020/11/03/%E7%BA%A2%E9%BB%91%E6%A0%91/">https://jasonxqh.github.io/2020/11/03/%E7%BA%A2%E9%BB%91%E6%A0%91/</a></p>
<h3 id="性质、旋转、插入"><a href="#性质、旋转、插入" class="headerlink" title="性质、旋转、插入"></a>性质、旋转、插入</h3><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h3 id="钢条切割"><a href="#钢条切割" class="headerlink" title="钢条切割"></a>钢条切割</h3><h3 id="矩阵链乘法"><a href="#矩阵链乘法" class="headerlink" title="矩阵链乘法"></a>矩阵链乘法</h3><p><a href="https://jasonxqh.github.io/2020/11/17/%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%E6%B3%95/">https://jasonxqh.github.io/2020/11/17/%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%E6%B3%95/</a></p>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><h3 id="活动选择"><a href="#活动选择" class="headerlink" title="活动选择"></a>活动选择</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1500</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> beginTime;</span><br><span class="line">    <span class="keyword">int</span> endTime;</span><br><span class="line">    node()</span><br><span class="line">    &#123;</span><br><span class="line">        beginTime=<span class="number">0</span>;</span><br><span class="line">        endTime=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.endTime!=b.endTime)    <span class="comment">/*如果两个活动的结束时间不相等*/</span></span><br><span class="line">        <span class="keyword">return</span> a.endTime&lt;b.endTime;</span><br><span class="line">    <span class="keyword">if</span>(a.endTime==b.endTime)</span><br><span class="line">        <span class="keyword">return</span> a.beginTime&lt;b.beginTime;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,i;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i].beginTime&gt;&gt;a[i].endTime;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);<span class="comment">//按照结束时间从早到晚开始排队</span></span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp=<span class="number">-1</span>;<span class="comment">/*用于进行贪心选择的变量*/</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)<span class="comment">/*进行活动选择 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].beginTime &gt;= tmp)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp=a[i].endTime;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h3><p><a href="https://jasonxqh.github.io/2021/01/17/哈夫曼编码/">哈夫曼编码</a></p>
<h2 id="摊还分析"><a href="#摊还分析" class="headerlink" title="摊还分析*"></a>摊还分析*</h2><h3 id="聚合分析"><a href="#聚合分析" class="headerlink" title="聚合分析"></a>聚合分析</h3><h3 id="核算法"><a href="#核算法" class="headerlink" title="核算法"></a>核算法</h3><h3 id="势能法"><a href="#势能法" class="headerlink" title="势能法"></a>势能法</h3><h3 id="动态表"><a href="#动态表" class="headerlink" title="动态表"></a>动态表</h3><h2 id="图算法"><a href="#图算法" class="headerlink" title="图算法"></a>图算法</h2><h3 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h3><h3 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h3><p><a href="https://jasonxqh.github.io/2020/08/30/BFSandDFS/">https://jasonxqh.github.io/2020/08/30/BFSandDFS/</a></p>
<h3 id="深度优先"><a href="#深度优先" class="headerlink" title="深度优先"></a>深度优先</h3><p><a href="https://jasonxqh.github.io/2020/08/30/BFSandDFS/">https://jasonxqh.github.io/2020/08/30/BFSandDFS/</a></p>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="最小生成树的形成"><a href="#最小生成树的形成" class="headerlink" title="最小生成树的形成"></a>最小生成树的形成</h3><h3 id="Kruskal和Prim"><a href="#Kruskal和Prim" class="headerlink" title="Kruskal和Prim"></a>Kruskal和Prim</h3><p><a href="https://jasonxqh.github.io/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/">https://jasonxqh.github.io/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</a></p>
<h2 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h2><h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><p><a href="https://jasonxqh.github.io/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/">https://jasonxqh.github.io/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</a></p>
<h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><h3 id="流网络"><a href="#流网络" class="headerlink" title="流网络"></a>流网络</h3><h3 id="Ford-fulkerson方法"><a href="#Ford-fulkerson方法" class="headerlink" title="Ford-fulkerson方法"></a>Ford-fulkerson方法</h3><h2 id="NP完全性"><a href="#NP完全性" class="headerlink" title="NP完全性"></a>NP完全性</h2><h3 id="多项式时间、多项式时间的验证"><a href="#多项式时间、多项式时间的验证" class="headerlink" title="多项式时间、多项式时间的验证"></a>多项式时间、多项式时间的验证</h3><h3 id="NP完全性与可规约性"><a href="#NP完全性与可规约性" class="headerlink" title="NP完全性与可规约性"></a>NP完全性与可规约性</h3><h3 id="典型的NP完全问题"><a href="#典型的NP完全问题" class="headerlink" title="典型的NP完全问题"></a>典型的NP完全问题</h3><h3 id="团问题、顶点覆盖问题、哈密顿回路问题等"><a href="#团问题、顶点覆盖问题、哈密顿回路问题等" class="headerlink" title="团问题、顶点覆盖问题、哈密顿回路问题等"></a>团问题、顶点覆盖问题、哈密顿回路问题等</h3><h2 id="近似算法"><a href="#近似算法" class="headerlink" title="近似算法"></a>近似算法</h2><h3 id="顶点覆盖问题"><a href="#顶点覆盖问题" class="headerlink" title="顶点覆盖问题"></a>顶点覆盖问题</h3><h3 id="旅行商问题"><a href="#旅行商问题" class="headerlink" title="旅行商问题"></a>旅行商问题</h3><h3 id="集合覆盖问题"><a href="#集合覆盖问题" class="headerlink" title="集合覆盖问题"></a>集合覆盖问题</h3>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/01/06/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%892/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/06/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%892/" itemprop="url">异常控制流（ECF）2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-06T21:13:24+08:00">
                2021-01-06
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-06-25T22:41:08+08:00">
                2022-06-25
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Shells"><a href="#Shells" class="headerlink" title="Shells"></a>Shells</h1><p><img src="/2021/01/06/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%892/2.png" style="zoom:80%;"></p>
<h1 id="Signals"><a href="#Signals" class="headerlink" title="Signals"></a>Signals</h1><p><img src="/2021/01/06/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%892/1.png" style="zoom:80%;"></p>
<p>在 <a href="https://jasonxqh.github.io/2020/12/24/异常控制流（ECF）1/">异常控制流（ECF）1</a> 中，我们介绍了Interrupts，Traps，Faults和Aborts，这是硬件和软件合作以提供基本的底层异常机制。接下来我们要研究一种更高层的软件形式异常，称为 Linux信号，它允许<strong>进程和内核</strong> 中断其他进程。</p>
<p>一个信号(signal)就是一条小消息，它通知进程系统中发生了一个某种类型的事件。如下图</p>
<p><img src="/2021/01/06/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%892/3.png" style="zoom:80%;"></p>
<p>如果是低层的硬件异常，是由内核异常处理程序处理的，一般对用户不可见。但信号不同，信号提供了一种机制来通知用户进程发生了这 些异常。比如，一个进程试图除以0，那么内核就会发送给它一个SIGFPE信号(号码8);如果一个进程执行一条非法指令，那么内核就会发送给它一个SIGSEGV信号(号码11). Kernel是通过 kill这一个系统调用来发送指令的，发送的指令可以是 SIGKILL也可以是 其他指令<br>此外，一个进程可以通过向另一个进程发送一个 SIGKILL 信号(号码9)强制终止它。当一个子进程终止或者停止的时候，内核会发送一个SIGCHILD的信号来给父进程</p>
<h2 id="信号术语"><a href="#信号术语" class="headerlink" title="信号术语"></a>信号术语</h2><p>下面我们来简单看一下发送信号的过程：是由两个不同步骤组成的：</p>
<ul>
<li>发送信号。内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程。发送信号可以有两个原因 ：<ul>
<li>内核检测到一个系统时间，比如除零错误或者子进程终止</li>
<li>一个进程调用了kill函数，显示地要求内核发送一个信号给目的进程。一个进程也可以发送信号给它自己</li>
</ul>
</li>
</ul>
<p><img src="/2021/01/06/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%892/4.png" style="zoom: 67%;"></p>
<p>一个发出的，而没有被接手的信号叫做待处理信号(pending signal)，在任何时刻，一种类型最多只会有一个待处理信号。如果一个进程有一个类型为k的待处理信号，那么任何接下来发送到这个进程的类型为k的信号都不会排队等待，只是被简单的丢弃。我们可以理解为是一个“状态”而非一个队列。<br>一个进程可以选择性的阻塞接收某种信号，当一种信号被阻塞的时候，它仍然可以被发送但是产生的待处理信号不会被接收，直到进程取消对这种信号的阻塞。</p>
<p><img src="/2021/01/06/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%892/5.png" style="zoom: 67%;"></p>
<ul>
<li>接收信号。当目的进程被内核强迫以某种方式对信号的发送做出反应的时候，他就接受了信号，进程可以忽略这个信号，终止或者捕获这个信号。如下图所示</li>
</ul>
<p><img src="/2021/01/06/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%892/8.png" style="zoom:80%;"></p>
<p>一个待处理的信号只能被接收一次。内核为每个进程在<strong>pending位向量</strong>中维护<strong>待处理信号</strong>的集合。而在<strong>blocked向量</strong>中维护<strong>被阻塞的信号</strong>集合。只要传送了一个类型为k的信号，内核就会设置pending中的第k位，而只要接收了一个类型为k的信号，内核就会清除pending中的第k位</p>
<p><img src="/2021/01/06/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%892/7.png" style="zoom:80%;"></p>
<h2 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h2><p>Unix系统提供了大量向进程发送信号的机制，所有这些机制都是基于进程组这个概念的</p>
<h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p>每个进程都<strong>只</strong>属于一个进程组，进程组是由一个正整数进程组ID来标识的。getpgrp函数返回当前进程的进程组ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpgrp</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>默认的，一个子进程和他的父进程同属于一个进程组。一个进程可以通过使用<code>setpgid</code> 函数来改变自己或者其他进程的进程组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inlcude <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">pid_t</span> pgid)</span></span>;<span class="comment">//若成功则返回0，否则返回-1</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/01/06/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%892/9.png" style="zoom:80%;"></p>
<p><code>setpgid</code> 函数将进程<code>pid</code>组改为<code>pgid</code>。如果<code>pid</code>是0，那么就使用当前进程的PID。如果<code>pgid</code>为0，那么就用<code>pid</code>指定的进程的PID作为进程组ID。例如，如果进程15213是调用进程，那么 <code>setpgid(0,0);</code> 会创建一个新的进程组，其进程组ID是15213，并且把进程15213加入到这个新的进程组中</p>
<h3 id="用-bin-kill程序发送信号"><a href="#用-bin-kill程序发送信号" class="headerlink" title="用 /bin/kill程序发送信号"></a>用 /bin/kill程序发送信号</h3><p>/bin/kill 程序可以向另外的进程发送任意的信号。</p>
<p>例如，命令 <code>linux&gt;/bin/kill -9 15213</code> 发送信号9(SIGKILL)给进程15213. </p>
<p>一个为负的PID会导致i信号被发送到进程组PID中的<strong>每个进程</strong></p>
<p>例如：<code>linux&gt;/bin/kill -9 -15213</code> 会发送一个SIGKILL信号给进程组15213中的每个进程。</p>
<h3 id="从键盘发送信号"><a href="#从键盘发送信号" class="headerlink" title="从键盘发送信号"></a>从键盘发送信号</h3><p>下图展示了一个有一个前台作业和两个后台作业的shell，前台作业中的父进程PID为20，进程组也为20.父进程创建两个子进程，每个也都是进程组20的成员。</p>
<p><img src="/2021/01/06/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%892/10.png" style="zoom:80%;"></p>
<p>在键盘上输入 <code>Ctrl+C</code>会导致内核发送一个 SIGINT 信号到前台进程组中的每一个进程，默认情况下，结果是<strong>终止前台作业</strong>。</p>
<p>输入<code>Ctrl+Z</code>会发送一个SIGTSTP信号到前台进程组中的每个进程。默认情况下，结果是<strong>停止(挂起suspend)前台作业</strong>。</p>
<h3 id="用kill-函数发送信号"><a href="#用kill-函数发送信号" class="headerlink" title="用kill 函数发送信号"></a>用kill 函数发送信号</h3><p>进程可以通过调用kill 函数发送信号给其他进程(包括他们自己)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> sig)</span></span></span><br></pre></td></tr></table></figure>
<p>这里有三种不同的发送情况</p>
<ul>
<li>如果 $pid&gt;0$ ，那么<code>kill</code>函数就会发送信号号码 <code>sig</code>给进程 <code>pid</code>. </li>
<li>如果 $pid=0$ ，那么<code>kill</code> 发送信号<code>sig</code>给<strong>调用进程所在进程组</strong>中的<strong>每一个进程</strong>，包括调用进程自己</li>
<li>如果 $pid&lt;0$ ，那么<code>kill</code> 发送信号<code>sig</code> 给进程组 $|pid|$ <code>pid</code>的绝对值中的每一个进程。</li>
</ul>
<p>下面是一个例子</p>
<p>首先我们创建N个子进程，每一个子进程都是无限循环。然后在对每一个子进程发送SIGINT信号，终止进程运行。</p>
<p>接下来我们对每一个子进程进行回收，看到底是哪个进程退出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fork12</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid[N];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> child_status;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    <span class="keyword">if</span> ((pid[i] = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Child: Infinite Loop */</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Killing process %d\n"</span>, pid[i]);</span><br><span class="line">        kill(pid[i], SIGINT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">pid_t</span> wpid = wait(&amp;child_status);</span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(child_status))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Child %d terminated with exit status %d\n"</span>,wpid, WEXITSTATUS(child_status));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">	        <span class="built_in">printf</span>(<span class="string">"Child %d terminated abnormally\n"</span>, wpid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用alarm函数发送信号"><a href="#用alarm函数发送信号" class="headerlink" title="用alarm函数发送信号"></a>用alarm函数发送信号</h3><p>进程可以通过调用alarm函数向它自己发送SIGALRM信号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> secs)</span></span>;</span><br><span class="line"><span class="comment">//返回: 前一次alarm剩余的秒数，若以前没有设定alarm，则为0</span></span><br></pre></td></tr></table></figure>
<p>alarm函数安排kernel在<code>secs</code>秒之后发送一个 SIGALRM信号给调用进程。</p>
<h2 id="接收信号"><a href="#接收信号" class="headerlink" title="接收信号"></a>接收信号</h2><p>当内核把进程p从内核模式切换到用户模式的时候(例如上下文切换) 如下图：</p>
<p><img src="/2021/01/06/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%892/11.png" style="zoom:80%;"></p>
<p>它会检查进程p的未被阻塞的待处理信号的集合，这个集合就是 <code>pending&amp;~blocked</code>,因为pending的是合法的信号，blocked维护的是被阻塞的信号</p>
<p>如果集合为空，意味着要么信号没到，要么信号被屏蔽了 ，那么kernel将控制传递到p的逻辑控制流中的下一条指令($I_{next}$) </p>
<p>如果集合非空，那么内核选择集合中的某个信号k(通常是最小的k)，然后强制p接收信号k，并做出相应的触发。接着会对<code>pnb</code>中所有的信号做此操作。做完之后再把控制权返回给 ($I_{next}$) </p>
<h3 id="Installing-Signal-Handlers"><a href="#Installing-Signal-Handlers" class="headerlink" title="Installing Signal Handlers"></a>Installing Signal Handlers</h3><p>之前我们给出每个信号类型相关联的默认行为。例如，收到SIGKILL的默认行为是终止接收进程。但是其实我们可以通过使用<code>signal</code>函数修改和信号相关联的默认行为。唯一的例外是 <code>SIGSTOP</code> 和 <code>SIGKILL</code>，他们的默认行为是不能被修改的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum,<span class="keyword">sighandler_t</span> handler)</span></span>;</span><br><span class="line"><span class="comment">//返回：若成功则为指向前次处理程序的指针，若出错则为 SIG_ERR(不设置errno)</span></span><br></pre></td></tr></table></figure>
<p>通过这个函数我们可以用<strong>三种方法</strong>之一来改变与信号signum相关联的行为</p>
<ul>
<li>如果 handler参数 是 <strong>SIG_IGN</strong> ，那么<strong>忽略类型为 signum 的信号</strong></li>
<li>如果 handler参数 是<strong>SIG_DFL</strong> ，那么<strong>类型为 signum的信号行为恢复为默认行为</strong></li>
<li>否则，handler就是<strong>用户自定义的函数的地址</strong>，这个函数被称为<strong>信号处理程序</strong>，只要进程接收到一个类型为 signum的信号，就会调用这个程序。<ul>
<li>通过把处理程序的地址传递到 signal函数从而改变默认行为叫做 <strong>设置信号处理程序(installing the handler)</strong>。</li>
<li>调用信号处理程序被称为捕获信号。执行信号处理程序被称为处理信号</li>
</ul>
</li>
</ul>
<p>下面是一个 Signal Handling Example</p>
<p>在main函数当中，我们首先 <code>handler</code>,就是将 SIGINT这个信号和我自己写的 <code>sigint_handler</code>函数关联，然后手动终止掉。这样当我们按下 <code>Ctrl+C</code>之后，就不只是简单的退出而已，而是会说一段废话……</p>
<p>所以现在我们知道一些流氓软件的套路了，它就是不停地弹出弹框不让人退出程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigint_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> <span class="comment">/* SIGINT handler */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"So you think you can stop the bomb with ctrl-c, do you?\n"</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Well..."</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"OK. :-)\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Install the SIGINT handler */</span></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGINT, sigint_handler) == SIG_ERR)</span><br><span class="line">    	unix_error(<span class="string">"signal error"</span>);</span><br><span class="line">    <span class="comment">/* Wait for the receipt of a signal */</span></span><br><span class="line">    pause();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>信号处理程序可以被其他信号处理程序中断掉，这也被称为 Nested Signal Handlers 如下图所示。</p>
<p>在这个例子当中，主程序捕获到信号s，该信号会中断主程序，并将控制转移到处理程序S。S在运行的时候，程序捕获到信号t($t\neq s$)，该信号会中断S,控制转移到处理程序T。 当T返回的时候，S从它被中断地地方继续执行，最后，S返回，控制传送回主程序，主程序从它被中断的地方继续执行</p>
<p><img src="/2021/01/06/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%892/12.png" style="zoom:80%;"></p>
<h2 id="阻塞和解除阻塞信号"><a href="#阻塞和解除阻塞信号" class="headerlink" title="阻塞和解除阻塞信号"></a>阻塞和解除阻塞信号</h2><h3 id="隐式阻塞机制"><a href="#隐式阻塞机制" class="headerlink" title="隐式阻塞机制"></a>隐式阻塞机制</h3><p>内核会默认阻塞任何当前处理程序正在处理信号类型的待处理信号。</p>
<p>比如说在这张图中，假设程序捕捉到了信号s，当前正在运行处理程序S。如果发送给该进程另外一个信号s，那么直到处理程序S返回，s会变成待处理而没有被接受。</p>
<p><img src="/2021/01/06/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%892/12.png" style="zoom:80%;"></p>
<h3 id="显式阻塞机制"><a href="#显式阻塞机制" class="headerlink" title="显式阻塞机制"></a>显式阻塞机制</h3><p>我们可以使用 <code>sigprocmask</code>函数和它的<strong>辅助函数</strong>，明确的阻塞和解除阻塞选定的信号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">sigset_t</span> *oldset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;<span class="comment">//把某一个特定的为加上去</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;<span class="comment">//成功则返回0，否则返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>,<span class="keyword">int</span> signum)</span></span>;</span><br><span class="line"><span class="comment">//若signum是set的成员则为1，如果不是则为0，若出错则为-1</span></span><br></pre></td></tr></table></figure>
<p><code>sigprocmask</code> 函数改变的是 blocked 位向量。具体的行为依赖于how的值:how有三个值</p>
<ul>
<li>SIG_BLOCK: 函数把set中的信号添加到blocked当中($blocked = blocked~|set$)</li>
<li>SIG_UNBLOCK: 函数从block中删除set中的信号 ($blocked=blocked$&amp;~$set$)</li>
<li>SIG_SETMASK: block=set</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sigset_t</span> mask, prev_mask;<span class="comment">//prev是保留原来的mask</span></span><br><span class="line">Sigemptyset(&amp;mask);<span class="comment">//创建一个空的mask</span></span><br><span class="line">Sigaddset(femask, SIGINT);<span class="comment">//将SIGINT位设置为1</span></span><br><span class="line"><span class="comment">/* Block SIGINT and	and save previous blocked set */</span></span><br><span class="line">Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev_mask);<span class="comment">// 注册这个mask，将pre_mask保存下来，把新的信号添加到blocked当中</span></span><br><span class="line"><span class="comment">// Code region that will not be interrupted by SIGINT</span></span><br><span class="line"><span class="comment">/* Restore previous blocked set, unblocking SIGINT */</span></span><br><span class="line">Sigprocmask(SIG_SETMASK, &amp;prev_mask, <span class="literal">NULL</span>);<span class="comment">//结束以后我们要回归原样</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/01/02/CSAPP%E4%BA%91%E8%AE%A1%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/01/02/CSAPP%E4%BA%91%E8%AE%A1%E7%AE%97/" itemprop="url">CSAPP云计算</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-01-02T21:15:27+08:00">
                2021-01-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2021-01-06T17:06:42+08:00">
                2021-01-06
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="CSAPP云计算"><a href="#CSAPP云计算" class="headerlink" title="CSAPP云计算"></a>CSAPP云计算</h1><h2 id="What-is-distributed-computing"><a href="#What-is-distributed-computing" class="headerlink" title="What is distributed computing"></a>What is distributed computing</h2><p>简单来说，分布式计算就是说我们可以利用多台计算机而不是一台计算机来获取某些东西并能做的很好。分布式在当今最大的应用就是建立一些大型网站，比如 eBay，Google ，Amazon等。我们使用的几乎所有的大型网站都是分布式建立的，它们正在使用数十万台可以为数百万用户提供服务的现成计算机。</p>
<p>现在我们来回答一个问题：</p>
<p><strong>The first demonstration of how to build really large Internet sites out  of clusters of computers was done by: </strong></p>
<p>A. Stanford</p>
<p>B. Berkeley</p>
<p>C. Yahoo!</p>
<p>D. Google</p>
<p>E. IBM</p>
<p>答案是Berkeley</p>
<p>在1996年的时候，如果要建造一个大型的网站(如eBay或者Yahoo),我们可以用一台”超级计算机”,我们可以来看一下超级计算机和我们的PC之间的配置差别。 </p>
<p><img src="/2021/01/02/CSAPP%E4%BA%91%E8%AE%A1%E7%AE%97/1.png" style="zoom:80%;"></p>
<p>这样一台超级微机在当时的售价是100万美金，是一个不便宜的价格。但是eBay和其他一些非常迅速发展的大型网站，就必须使用这些设备。但是问题是，当网站不断地在发展、客流量在不断增长，有时候会超出这台机器的承受能力，这时候公司必须使用新的更大更先进的计算机来替换掉老的计算机。这样的操作模式非常烧钱，因为对于公司来说它们没有一个巨大的市场值得花数百万美元购置新的更大的计算机，但是老的计算机又不够用。</p>
<p>这时，伯克利大学有一个项目，就是说我们可以用很多很多台批量生产的PC电脑，它们虽然个体的计算能力比不上超级计算机，但是它们加起来的计算能力就有可能超过一台昂贵的超级计算机。</p>
<p><img src="/2021/01/02/CSAPP%E4%BA%91%E8%AE%A1%E7%AE%97/2.png" style="zoom:80%;"></p>
<p>就如同上图所示，我们用很多台PC组合起来，就可能拥有吞噬”大鲨鱼“的能力。这是一种更节省成本、增加效益的方式，不仅是因为各个零件都更便宜写，而且我们可以通过将它们聚集起来达到一个惊人的计算量</p>
<p> 于是，这就是分布式计算的雏形，这是1994年造出来的，没有显示器键盘和鼠标，只有四台 HP-735型号的机器</p>
<p><img src="/2021/01/02/CSAPP%E4%BA%91%E8%AE%A1%E7%AE%97/3.png" style="zoom:80%;"></p>
<p>一年以后，已经从4台变到了32台 Sun SPARC-stations，都是由Sun公司捐赠的，而且理线也正常了许多。</p>
<p><img src="/2021/01/02/CSAPP%E4%BA%91%E8%AE%A1%E7%AE%97/4.png" style="zoom:80%;"></p>
<p>从这之后，它变得越来越整齐有序了，在97年，由原来的32台变为了60台 Sun主机</p>
<p><img src="/2021/01/02/CSAPP%E4%BA%91%E8%AE%A1%E7%AE%97/5.png" style="zoom:80%;"></p>
<p>分布式系统发展的越来越大之后，挑战也越来越大：<strong>How do you program a NOW?(or: what is it good-for)</strong></p>
<p>之前在大型计算机或者是在supermini上编写程序非常方便，因为只要让一台计算机成功运行即可。这是程序员熟悉的体系，程序有变量、 内存分配云云。但是在分布式系统上，我们无法在其他计算机上命名数据，我必须明确向其发送消息并接收反馈。这种体系对于程序员来说是新颖且陌生的。</p>
<p>还有一件很难的事情，就是当这些计算机中的某一台或者某几台出现了故障该怎么办。之前在supermini上我们可以尝试重启，但现在我们不能将正在工作的好的计算机也重启了，因此我们必须合理的编写程序来让剩下的没有故障的计算机继续运行，但当时并没有这样一个model来实现这个功能</p>
<p>因此，在1990‘s中期，我们必须挑战在不同的计算机上的内存中运行程序，并进行故障管理。随着机器数量的增加，管理面临的挑战也就越多。 </p>
<h3 id="Palm设备"><a href="#Palm设备" class="headerlink" title="Palm设备"></a>Palm设备</h3><p>如果我们对移动计算机有所了解，可能会记得一个叫做Palm的设备。当时这个机器设计出来就是想要在小型设备上获取Web内容，这比智能手机要早很多很多。</p>
<p>假设现在所有的数据和服务都已经在网络上了 ，那么我就可以随时利用这个工具获得我想知道的东西，而不是必须坐在PC前面。</p>
<p><img src="/2021/01/02/CSAPP%E4%BA%91%E8%AE%A1%E7%AE%97/6.png" style="zoom:80%;"></p>
<p>这是伯克利第一次演示了具有自动扩展功能的Internet服务器架构，如果更多的人使用该系统，它将自动添加更多的计算机。如果一些人不再使用，那么系统将自动释放多余的机器并让他们返回池中，以便其他人可以使用它们。这个思想虽然一开始的目标并不是建立一个搜索引擎，而是为了展示网络服务编程的通用技术，但是却造出了一第一个以这种方式架构的搜索引擎</p>
<p><img src="/2021/01/02/CSAPP%E4%BA%91%E8%AE%A1%E7%AE%97/7.png" style="zoom:80%;"></p>
<p><strong>小练习：</strong> A Google datacenter built c.2005 would be designed to house approximately ____ computers.</p>
<p>A. 1000</p>
<p>B. 5000</p>
<p>C. 10000</p>
<p>D. 50000</p>
<p>E. 100000</p>
<p>答案是 在D和E之间的某一个数</p>
<h2 id="What-is-warehouse-scale-computing"><a href="#What-is-warehouse-scale-computing" class="headerlink" title="What is warehouse-scale computing"></a>What is warehouse-scale computing</h2><p><img src="/2021/01/02/CSAPP%E4%BA%91%E8%AE%A1%E7%AE%97/8.png" style="zoom:80%;"></p>
<p>现在我们要建造仓库级别的服务站，能容纳数以千计的电脑、存储和被和网络。来提供如搜索、邮件、GIS等软件的功能</p>
<p>中间的图是Sun公司的“黑匣子“，里面装满了可以容纳250台计算机以及超过1PB的存储空间以及7TB的RAM。像这样的集装箱，又会像叶子一样被装到右边这张图中的数据中心里面。一排中有数百辆这样的拖车。</p>
<p>现在集群已经成为了主流，但是构建这些庞大服务的唯一问题是对这些计算机集群进行变成仍然是一件非常麻烦的事。需要大公司大资本的帮助才能完成。因此这就是 RAD lab建立的初衷。</p>
<p>要拥有这样一个大数据中心，首先你必须是一家大公司。因此 Amazon首先提出了 Elastic Compute Cloud(EC2) 的概念，所以他们可能是第一个用”云“一词的公司。它们的想法是：我们公司由这些数据中心，但有时候我们不需要这么多台计算机所有的能力：比如说在圣诞节和黑五，Amazon对服务器的需求巨大，而在平常它们并不需要用这么多服务器。因此我们为什么不能将这些闲置的计算机租出去呢？而且我们可以让人们按小时租用，且基本没有最低限度的购买，因此他们的价格一开始是10美分，现在是8美分/小时。</p>
<p>对于消费者，我们只要租我们需要的计算机数量并按照时间付钱就行了，用完后计算机就会被释放回池当中，并不用再继续为其付费了。</p>
<p><img src="/2021/01/02/CSAPP%E4%BA%91%E8%AE%A1%E7%AE%97/9.png" style="zoom:80%;"></p>
<p>但是我们还没有仔细来讲怎么对这么多台计算机进行故障排查和管理。我们可以从这么多计算机中搜集信息并发现从中有趣的模式，因为这些数据可能会告诉我们一些信息。 比如说一旦一台计算机坏了，我们可以查看来自检测我们计算机的仪器的数据(在发生故障之前的那几分钟)；又或者说我们的系统速度变慢了，那么我们可以通过比较不同的计算机来找出哪个或者哪些是”罪魁祸首”——因为我们不可能手动来调试几万台计算机并找出原因</p>
<p>RAD lab在做的就是一个”机器学习”的工作，只不过这个机器学习没有像谷歌一样用在搜索引擎当中，而是用于数据中心中正在运行的任何程序上。</p>
<p>对于Amazon对”云“这一概念的提出，甲骨文的CEO拉里表示不屑。随后 RAD lab就发表了一篇论文，这篇论文提出了关于云计算的新观点，有超过六万的下载量，并对许多公司在云计算方面的战略布局产生了非常大的影响力。这也改变了 拉里对云计算的看法</p>
<p><img src="/2021/01/02/CSAPP%E4%BA%91%E8%AE%A1%E7%AE%97/10.png" style="zoom:80%;"></p>
<p> 过去的云计算的观点就是将软件服务放在云上还是放在本地上。但是新的观点就是我们可以按照时间租赁计算机，只要我们愿意付钱，我们可以向Amazon这样的公司索要上百台计算机都可以。并且我们不用计算机的时候可以直接将他们释放，也不需要再付钱了。 之前也有公司（如Sun）做过类似的云服务，但是它们没有Amazon这样的专业技术，单价也更贵。这样一个Idea，在当时给Amazon带来了数百万美元的收益，而这是接近零成本的，因为Amazon只是在出租他们空闲的计算机而已。</p>
<p> <img src="/2021/01/02/CSAPP%E4%BA%91%E8%AE%A1%E7%AE%97/11.png" style="zoom:80%;"></p>
<p>问题是，云服务从上个世纪末就开始了，为什么只有Amazon到08年才开始着手做呢？因为一开始大公司都是被迫建属于自己的数据中心的。他们的计算机基本都是为自己的客户服务的。Amazon最初也没想到会从事这项业务，这并不是他们最初的目标——Amazon买那么多计算机只是为了能让他们的线上购物平台能容纳更多的流量而已。Google买那么多计算机只是为了用户对Gmail和Google地图等需求再不断增长。</p>
<p>我们发现如果公司能数以千计地购买计算机，那么所有的硬件设备都能比单价便宜5-7倍。之前之所以不买如此大批量的计算机是因为需求跟不上。但是 在过去的十几二十年中，互联网飞速发展，个人上网的成本也越来越低，因此对互联网的服务需求也越来越多。</p>
<p>还有，随着开源软件的数量越来越多，很多用户没有必要在自己的电脑上装很多开源软件，他们只需要租一台或者几台计算机并在上面运算就行了，更不用为运行的软件付钱，只需要付租金即可。</p>
<p><img src="/2021/01/02/CSAPP%E4%BA%91%E8%AE%A1%E7%AE%97/12.png" style="zoom:80%;"></p>
<p>那么如果我们现在是一家网络创业公司，为什么我们会偏向使用云计算服务呢？因为使用云服务能节省能源和资金。当我们第一次将我们的产品上线的时候，我们很可能会高估了软件的受欢迎的程度。如左图所示，对于蓝色的需求曲线，如果我们卖如红色直线那么多的计算机的话，会发现在低谷的时候，大部分计算机都是空闲的，我们不得不为这些空闲的计算机付费(维护、电力等)。但是如果使用云服务，那么从理论上来讲，我们就可以根据产品的客流量来调整我租赁的计算机服务——在白天增加计算机，在晚上释放空闲的计算机。哦只需要为我使用的东西付款而并不需要购买固定数量的计算机。</p>
<p><img src="/2021/01/02/CSAPP%E4%BA%91%E8%AE%A1%E7%AE%97/13.png" style="zoom:80%;"></p>
<p>或者，当我的产品爆火的时候，如果购买固定数量的计算机，很有可能是带不动这么大的客流量的：久而久之，哪些觉得体验很差的客户就会因此流失。比如当时比Facebook更早的社交软件 Friendster,活跃于2005年前后，他们公司就是因为供应赶不上爆发式的需求量，从而让很多用户感到恼火，最后被抛弃。但云计算却能很好的规避这一限制。</p>
<h2 id="What-can-you-do-with-this"><a href="#What-can-you-do-with-this" class="headerlink" title="What can you do with this"></a>What can you do with this</h2><p>在没有云计算之前，我们是不能想象1000台电脑用1个小时需要花多少钱的，因为我们必须花钱买下1000台电脑才能运行。但是有了云计算之后，1000台电脑运行1小时的价格和1台电脑运行1000小时的价格是一样的，这是具有革命意义的。</p>
<p>举个例子来说吧，华盛顿邮报搜集并在网上披露了希拉里克林顿的旅行文件。这在没有云计算的时候，只有一台电脑可能需要几周的时间来完成这些工作。但是有了云计算之后，他们可以利用大约200台计算机去做文件识别等工作，他们在不到一天的时间内就完成了整个工作，而且只花了不到200美元，这就是云计算的强大之处——在短时间内能以较低的成本使用大量计算机。</p>
<p>RAD Lab的一些研究生在演示提升MapReduce的运行速度的时候，借助云计算利用了1000台服务器，这在没有云计算的情况下是不能想象的。因此云计算也给一些软件能向业界证明自己的实力和性能创造了实实在在的机会。</p>
<p><img src="/2021/01/02/CSAPP%E4%BA%91%E8%AE%A1%E7%AE%97/15.png" style="zoom:80%;"></p>
<p>这是另外一个例子，当2001年911事件发生的时候，CNN网站的访问量在十五分钟内暴增10倍，这直接导致了他们使用的 minisuper超级计算机的宕机。而在2008年，当Animoto这个软件以插件的形式出现在Facebook当中的时候，在3天内每12个小时用户就翻一倍，但这个软件却能继续运行，因为它使用了云计算，只是从50台服务器增长到了3500台服务器，等到了使用高峰期过了以后，他们又削尖了服务器的规模。</p>
<p><img src="/2021/01/02/CSAPP%E4%BA%91%E8%AE%A1%E7%AE%97/16.png" style="zoom:80%;"></p>
<p>这是另外一个例子，我们可以用机器学习算法来分类Twitter上的垃圾推文或者邮件。对于640GB的数据，在一台电脑上可能要运行270个小时，但是如果我们使用Amazon的云计算服务，我们可能只需要3小时就能训练完成，只是需要花费255美金。</p>
<p>云计算还应用于遗传学中的基因组测序</p>
<p><img src="/2021/01/02/CSAPP%E4%BA%91%E8%AE%A1%E7%AE%97/17.png" style="zoom:80%;"></p>
<p>同时我们应该也注意到云计算所面临的挑战：</p>
<p>第一个就是cloud programming,也就是云编程。如果Mapreduce能在云上运行的话，那将是一件很好的事情。但这可能会非常棘手，因为Mapreduce依赖的是 令人尴尬的<strong>并行性</strong>。</p>
<p> 在这里我们要了解以下并行计算的两种方式：1. 分布式计算机，电脑和电脑是通过网络相连接的；2. 并行式计算机，电脑和电脑是通过总线相连接的。不管怎么样，我将计算机连接起来的目的是为了增加并行度，然后我们希望编写的程序能将各台计算机的CPU都能有效地利用起来。</p>
<p>对于我们来说，大多数情况下我们的程序仅在一颗CPU上运行，但是给我32颗CPU，我能通过什么办法将这32台计算机为我服务呢？有专门做并行计算的程序员，他们会写好相关的API，对于要编写天气预测软件的专业人士来说，他们只需要调用API就行了。这就叫做“透明”，也就是说我们并不需要了解内部的具体运作原理，只需要调用API即可。</p>
<p>Mapreduce 是处于调包和自己写程序中间的一种工具，它要比自己用python写并行程序要方便很多，又有较强的自由性，能决定数据和计算机的分配。Mapreduce对程序员的要求比较高，因为并不存在一个通用的方法来讲一个普通的程序转换成Mapreduce的程序。有些程序甚至根本不能转换成Mapreduce程序。所以Mapreduce对程序员来说是一个比较大的挑战，需要对并行计算有很深入的理解才能将程序写的高效，没有经过足够多的训练是很难写的。因此，现在云计算还没有到达一个足够友好、足够易用、足够高效的一个水平，虽然已经有一些很有用的框架。</p>
<p><img src="/2021/01/02/CSAPP%E4%BA%91%E8%AE%A1%E7%AE%97/18.png" style="zoom:80%;"></p>
<p><img src="/2021/01/02/CSAPP%E4%BA%91%E8%AE%A1%E7%AE%97/19.png" style="zoom:80%;"></p>
<h3 id="Big-Data"><a href="#Big-Data" class="headerlink" title="Big Data"></a>Big Data</h3><p>另一个挑战是关于大数据的。因为建造大量的光缆网络来搭建远程传输网络是非常贵的，而且发展得也很慢。 比如说，我向复制8TB的数据到Amazon的云上，使用20Mbps的光宽带，那么就要耗时35天并支付800多美元。而事实上，如果我们使用快递将8TB的磁盘插入Amazon的电脑，进行数据传输，只要一天的时间并只要支付150的运输费即可(事实上Amazon确实在提供这样的服务)。</p>
<p><img src="/2021/01/02/CSAPP%E4%BA%91%E8%AE%A1%E7%AE%97/20.png" style="zoom:80%;"></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ol>
<li>云计算能让更多人用得起”超级电脑”的计算力，我们只需要一张信用卡就行了</li>
<li>让学生和学术界在更平民化的竞争环境中对产业产生更大的影响</li>
<li>也许下一个如同Google，eBay，Amazon的大公司可能来自一个小的企业家团队，即使没有大量的资金。</li>
</ol>
<p><img src="/2021/01/02/CSAPP%E4%BA%91%E8%AE%A1%E7%AE%97/21.png" style="zoom:80%;"> </p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/12/29/%E6%9C%80%E5%A4%A7%E6%B5%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/29/%E6%9C%80%E5%A4%A7%E6%B5%81/" itemprop="url">最大流</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-12-29T12:45:30+08:00">
                2020-12-29
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-12-29T21:20:48+08:00">
                2020-12-29
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h1><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>无论是电网、水管网、还是其他地一些网络，他们都有一个共同点：网络传输都有<strong>方向</strong> 和 <strong>容量</strong>。设有带权图 $G=(V,E) , V={s,v_1,v_2,v_3,\cdots,t}$ 。 在图G中有两个特殊的点s和t，s称为源点，t称为汇点。图中各边地方向表示允许的流向，边上地权值表示该边允许通过的最大可能流量cap，且$cap\geq 0$ 称为边地容量。而且如果边集合E含有一条边$(u,v)$,必然不存在反向的平行边$(v,u)$,称这样的有向带权图为网络。 因为如果存在可以直接合并掉。</p>
<p>现在有一家公司想要从工厂s运往仓库t，找到一家代理公司。代理公司安排了若干货车和运输线路，中间要经过若干城市，边上的数值代表两个城市之间每天最多运送产品的数量。</p>
<p><img src="/2020/12/29/%E6%9C%80%E5%A4%A7%E6%B5%81/1.png" style="zoom:80%;"></p>
<p>这就类似一个地下水管网络，我们看不到水在地下管道内是怎么流动的，但是直到从进水口流进多少水，就会从出水口流出来多少水。</p>
<h4 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h4><p>网络流即网络上的流，是定义在网络边集E上的一个非负函数$flow={flow(u,v)}$, flow(u,v)是边上的流量</p>
<h4 id="可行流："><a href="#可行流：" class="headerlink" title="可行流："></a><strong>可行流</strong>：</h4><p>满足以下两个性质的网络流flow称为可行流</p>
<p>我们要从s将货物运送到t，需要满足几个条件</p>
<ol>
<li>容量约束，每个管道的实际流量 flow 不能超过该管道的最大容量 cap</li>
<li>流量守恒，除了源点是全部汇出没有汇入、汇点是全部汇入没有汇出的，其他中间节点<strong>流入和流出的量</strong>都是一模一样的，不允许中间节点有存货</li>
</ol>
<h4 id="源点s："><a href="#源点s：" class="headerlink" title="源点s："></a>源点s：</h4><p>源点主要是流出，但也有可能流入，例如货物运出后检测出的一些不合格产品需要返厂，这对源点来说就是流入量。因此，源点的净流出值f=流出量之和-流入量之和。即： $f=\sum<em>{(s,x)\in E}flow(s,x)-\sum</em>{(y,s)\in E}flow(y,s)$</p>
<p>从下图也可以反映出流量守恒和容量约束</p>
<p><img src="/2020/12/29/%E6%9C%80%E5%A4%A7%E6%B5%81/2.png" style="zoom:80%;"></p>
<p>现在我们提出网络最大流问题：在满足容量约束和流量守恒的前提下，在流网络中找到一个净输出最大的网络流。</p>
<p>我们先来学习 Ford&amp;Fullkerson提出的<strong>方法</strong>。该方法的基本思想是在残余网络中找可增广路，然后在实流网络中沿可增广路增流，直到不存在可增广路为止。这里要注意，找可增广路的方法有很多。</p>
<h4 id="残余网络："><a href="#残余网络：" class="headerlink" title="残余网络："></a>残余网络：</h4><p>每个网络G及其上的一个流flow，都对应一个残余网络G*.G* 和 G结点集相同，而网络G中的每条边对应G*中的一条边或者两条边。在残余网络中，与网络边对应的同向边是可增量(即<strong>还可以增加多少流量</strong>)，反向边是实际流量</p>
<p><img src="/2020/12/29/%E6%9C%80%E5%A4%A7%E6%B5%81/3.png" style="zoom:80%;"></p>
<p>那么我们可以根据原来的图来画出残余网络</p>
<p><img src="/2020/12/29/%E6%9C%80%E5%A4%A7%E6%B5%81/4.png" style="zoom:80%;"></p>
<h4 id="可增广路："><a href="#可增广路：" class="headerlink" title="可增广路："></a>可增广路：</h4><p>是残余网络G* 中一条从源点s到汇点t的简单路径。例如：$s-v_1-v_3-t$ 就是一条可增广路。如下图</p>
<p><img src="/2020/12/29/%E6%9C%80%E5%A4%A7%E6%B5%81/5.png" style="zoom:80%;"></p>
<p> 然后我们可以沿着增广路径来增加我们的货物数量。但是注意这里增加的量是路径上数值最小的路段。比如说这里能增加的量是5。在增加了货物数量之后，我们还需要修改增广路上的值。比如说这$s-v_1$从9改成4，$v_1-v_3$的线路被抹去，$v_3-t$的线路从12改为7.</p>
<h4 id="可增广量"><a href="#可增广量" class="headerlink" title="可增广量"></a>可增广量</h4><p>可增广量是指在可增广路p上每条边可以增加的流量最小值。求网络G的最大流，首先在残余网络中找可增广路，然后再实流网络G‘中沿可增广路增流，直到不存在可增广路为止。这是实流网络G’就是最大流网络。</p>
<h3 id="可增广路增流"><a href="#可增广路增流" class="headerlink" title="可增广路增流"></a>可增广路增流</h3><p>增流操作可以分为两个过程：一是在实流网络中增流，二是在残余网络中减流。因为残余网络中可增广路上的边值表示可增量，在实流网络中流量增加了，那么可增量就少了。</p>
<p>直接拿给我们一个残余网络，我们是不能判断哪一条是可增量哪一条是实际流量的</p>
<h4 id="实流网络增流"><a href="#实流网络增流" class="headerlink" title="实流网络增流"></a>实流网络增流</h4><p>在实流网络中沿着可增广路增流: 可增广路上同向边增加流量d，反向边减少流量d。</p>
<h4 id="残余网络减流"><a href="#残余网络减流" class="headerlink" title="残余网络减流"></a>残余网络减流</h4><p>在残余网络中沿着可增广路减流：可增广路上的同向边减少流量d，反向边增加流量d</p>
<h3 id="增广路算法"><a href="#增广路算法" class="headerlink" title="增广路算法"></a>增广路算法</h3><p><strong>增广路定理</strong> ：设flow是网络G的一个可行流，如果不存在从源点s到汇点t关于flow的可增广路p，则flow是G的一个最大流</p>
<p><strong>增广路算法</strong>： 增广路算法的基本思想是在残余网络中找到可增广路，然后在实流网络中沿着可增广路增流，在残余网络中沿可增广路减流；继续在残余网络中找可增广路，知道不存在可增广路为止。此时实流网络中的可行流就是所求的最大流。</p>
<h3 id="最短增广路算法"><a href="#最短增广路算法" class="headerlink" title="最短增广路算法"></a>最短增广路算法</h3><p>如何找到一条可增广路呢？我们可以设置最大容量优先，也可以是最短路径(广度优先)优先。 Edmonds-Karp算法就是以广度优先的增广路算法，又称为最短增广路算法(Shortest Augument Path, SAP)</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>初始化可行流 flow为零流，$vis[]$数组为$false$，$pre[]$数组为-1,vis数组代表该节点是否已经访问过，pre数组代表该节点的前驱结点 </li>
<li>令$vis[s] = true$,并将s加入队列q</li>
<li>如果队列不空，就继续下一步，否则算法结束，并返回最大流</li>
<li>队头元素new出队，在残余网络中检查new的所有邻接结点i。 如果i未被访问，那么就访问i结点并令 $vis[i]=true,pre[i] = new$。 如果 $i=t$ ，说明已经到达汇点，找到一条可增广路，转向第（5） 步；否则结点i加入队列q，转向第3步。</li>
<li>从汇点开始，通过前驱数组$pre[]$ ，逆向找可增广路上每条边值的最小值，即可增量d。</li>
<li>在实流网络中增流，在残余网络中减流，$Maxflow+=d$ ，并转向第(2)步</li>
</ol>
<p><img src="/2020/12/29/%E6%9C%80%E5%A4%A7%E6%B5%81/1.png" style="zoom:80%;"></p>
<p>比如说这个图，我们可以先来手工计算改图的最大流。</p>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>从算法的描述中可以看出，找到一条可增广路的时间是 $O(E)$,最多会执行 $O(VE)$次，因为关键边的总数为$O(VE)$.因此总的时间复杂度为 $O(VE^2)$ ，其中 V为结点个数，E为边的数量</p>
<h4 id="空间复杂度："><a href="#空间复杂度：" class="headerlink" title="空间复杂度："></a>空间复杂度：</h4><p>使用了一个二维数组表示实流网络，因此空间复杂度为 $O(V^2)$</p>
<h3 id="代码剖析"><a href="#代码剖析" class="headerlink" title="代码剖析"></a>代码剖析</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*首先我们定义一些常量，N代表结点数，M代表边数*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">int</span> cnt,d;</span><br><span class="line"><span class="comment">/*然后我们定义head数组(链式前向星需要)，前驱数组，和是否已访问的标志数组*/</span></span><br><span class="line"><span class="keyword">int</span> head[N],pre[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="comment">/*接下来我们定义链式前向星，并对head数组初始化为-1，但是这个链式前向星还需要包含两个数据</span></span><br><span class="line"><span class="comment">分别是边的容量和流量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,next;<span class="comment">// v代表除了head之外的另一个结点，next指的是下一条边的序号</span></span><br><span class="line">    <span class="keyword">int</span> cap,flow; 	</span><br><span class="line">&#125;E[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在建图的时候，假设cap=10，flow=3，但这只是正向边。我们我们还需要录入反向边，也就是将cap设置为0，flow设置为-3这种网络叫做混合网络，将残余网络和实流网络混合在一起了：flow为正数的就是实流网络，负数为残余网络。<br>这样也能达到残余网络的效果，因为在增广路径上查找的时候是根据cap&gt;flow走的，走反向边可以重新调整流量。</p>
<p>下面是在链式前向星中插入边的函数，这里一开始需要将flow设置为零流</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    E[cnt].v = v;</span><br><span class="line">    E[cnt].cap = c;</span><br><span class="line">    E[cnt].flow = <span class="number">0</span>;</span><br><span class="line">    E[cnt].next = head[u];</span><br><span class="line">    head[u] = cnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是广搜的算法</p>
<p>首先每次广搜之前都需要对前驱数组和标志数组进行一个重置</p>
<p>然后是对链式前向星进行广搜。</p>
<p>在这里我们pop掉队列里的头节点后，我们遍历它的周围节点，符合条件的就将它加入到队列当中。条件是头结点到该结点的这条边的 cap必须大于flow，而且是未被访问过的结点。同时我们维护一个最小值d，始终记录着这条增广路的可增广量</p>
<p>如果v等于t，就说明找到了一条从s到t的增广路径，那么我们就可以进入下一步骤，即增流减流</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(pre,<span class="number">-1</span>,<span class="keyword">sizeof</span>(pre));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    d = inf;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u];~i<span class="comment">/*i!=-1*/</span>;i=E[i].next)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = E[i].v;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v]&amp;&amp;E[i].cap&gt;E[i].flow)&#123;</span><br><span class="line">                d = <span class="built_in">min</span>(d,E[i].cap-E[i].flow);</span><br><span class="line">                vis[v] = <span class="number">1</span>;</span><br><span class="line">                pre[v] = i;<span class="comment">//边的下标，而不是结点</span></span><br><span class="line">                q.push(v);</span><br><span class="line">                <span class="keyword">if</span>(v==t)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是EK方法，我们用while循环将所有的增广路径找出。然后通过第二个while循环对增广路径进行输出，并对实流网络增流和残余网络减流。这里有一个小技巧，对于链式前向星的对应边，只需要 $E[i\wedge1]$ 即可，因为我们录入的时候都是成对成对的。一直到输出s为止。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EK</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxflow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(bfs(s,t))&#123;<span class="comment">//可以增广</span></span><br><span class="line">        maxflow +=d;</span><br><span class="line">        <span class="keyword">int</span> v = t;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"增广路径为："</span>&lt;&lt;t;</span><br><span class="line">        <span class="keyword">while</span> (v!=s)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = pre[v];</span><br><span class="line">            E[i].flow +=d;</span><br><span class="line">            E[i^<span class="number">1</span>].flow -=d;</span><br><span class="line">            v=E[i^<span class="number">1</span>].v;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"--"</span>&lt;&lt;v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"\t 增流："</span>&lt;&lt;d&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"网络的最大流值: "</span>&lt;&lt;maxflow&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出网络函数，这里我们输出了链式前向星的结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printg</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"----------网络(链式前向星):-------------"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"v"</span>&lt;&lt;i&lt;&lt;<span class="string">" ["</span>&lt;&lt;head[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = head[j];~j;j=E[j].next)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"]--["</span>&lt;&lt;E[j].v&lt;&lt;<span class="string">"\t"</span>&lt;&lt;E[j].cap&lt;&lt;<span class="string">"\t"</span>&lt;&lt;E[j].flow&lt;&lt;<span class="string">"\t"</span>&lt;&lt;E[j].next;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"]"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一个输出实流边的函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printflow</span><span class="params">()</span></span>&#123;<span class="comment">//输出实流边</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"----------实流边：----------"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=head[i];~j;j=E[j].next)</span><br><span class="line">            <span class="keyword">if</span>(E[j].flow&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"v"</span>&lt;&lt;i&lt;&lt;<span class="string">"--"</span>&lt;&lt;<span class="string">"v"</span>&lt;&lt;E[j].v&lt;&lt;<span class="string">"\t"</span>&lt;&lt;E[j].flow;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/12/29/%E6%9C%80%E5%A4%A7%E6%B5%81/6.png" style="zoom:80%;"></p>
<p><img src="/2020/12/29/%E6%9C%80%E5%A4%A7%E6%B5%81/7.png" style="zoom:80%;"></p>
<h2 id="Dinic算法"><a href="#Dinic算法" class="headerlink" title="Dinic算法"></a>Dinic算法</h2>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/" itemprop="url">异常控制流（ECF）1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-12-24T13:02:24+08:00">
                2020-12-24
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-06-25T22:39:22+08:00">
                2022-06-25
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="异常控制流（ECF）1"><a href="#异常控制流（ECF）1" class="headerlink" title="异常控制流（ECF）1"></a>异常控制流（ECF）1</h1><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p>首先我们要了解控制流的概念,从给处理器加点到断电为止，程序计数器假设一个值得序列如下：</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/2.png" style="zoom:100%;"></p>
<p>其中  $inst_k$ 代表着一条条指令。每次从 $inst_1$ 到 $inst_2$ 的过渡被称为控制转移。这样的控制转移序列叫做处理器的控制流。</p>
<h3 id="更改控制流"><a href="#更改控制流" class="headerlink" title="更改控制流"></a>更改控制流</h3><p>我们知道，进程有三个状态，running(拿到CPU并运行)，waiting(在等一个事件发生，在这个事件没有发生之前即使拿到了CPU也做不了事)，ready(已就绪，但是还没拿到CPU，等拿到了立即可以执行)</p>
<p>当哪些事件发生的时候系统会更改控制流呢？</p>
<h4 id="two-mechanisms-for-changing-control-flow"><a href="#two-mechanisms-for-changing-control-flow" class="headerlink" title="two mechanisms for changing control flow"></a>two mechanisms for changing control flow</h4><ul>
<li>Jump and branches</li>
<li>Call and return</li>
</ul>
<h4 id="Insufficient-for-a-useful-system"><a href="#Insufficient-for-a-useful-system" class="headerlink" title="Insufficient for a useful system"></a>Insufficient for a useful system</h4><ul>
<li>Data arrives from a disk or a network adapter <ul>
<li>当磁盘或者网络的数据到达的时候，系统会发出一个事件，代表数据传输完成。这时候从waiting进入到ready状态。这时候就需要操作系统中的代码来做。操作系统会把一个队列移动到另一个队列去，特别是这个进程优先级很高，我们甚至要直接把现在在running的进程拉下来然后把这个进程直接拿到CPU去运行</li>
</ul>
</li>
<li>Instruction divides by zero<ul>
<li>代码除以0了。这也需要操作系统来做。</li>
</ul>
</li>
<li>User hits Ctrl-C at the key board<ul>
<li>按Ctrl-C 退出程序。这时候也是操作系统来执行的</li>
</ul>
</li>
<li>System timer expires                    <ul>
<li>如果一个操作系统很多人在运行，那么操作系统会让每个人轮流运行一段时长。时间一到操作系统会把当前执行的挂起，状态设置为ready，然后把下一个进程放到CPU当中去</li>
</ul>
</li>
</ul>
<p>因此，系统需要一个 ECF的机制，也就是异常控制流来对这些变化做出反应。</p>
<h2 id="异常控制流"><a href="#异常控制流" class="headerlink" title="异常控制流"></a>异常控制流</h2><p>在异常发生的时候，很多时候要执行的代码并不是用户写的，而是操作系统写的。这些操作系统执行的代码块就放置在地址空间中的Kernel code and data 层里面，如下图所示：</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/1.png" style="zoom:80%;"></p>
<p>异常控制流在计算机系统的各个层级都有涉及。</p>
<h3 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h3><ul>
<li><p>Exceptions</p>
<ul>
<li><p>Change in control flow in response to a system event</p>
</li>
<li><p>implemented using combination of hardware and OS software</p>
</li>
</ul>
</li>
</ul>
<p>在操作系统层面是比较底层的Exception(也叫interruption)，这时候需要硬件和软件来共同完成。</p>
<h3 id="高层"><a href="#高层" class="headerlink" title="高层"></a>高层</h3><p>在操作系统层面以上的，一共有三种</p>
<ul>
<li>Process context switch</li>
</ul>
<p>一个进程在运行过程中的状态被称为context。 那么当状态切换的时候，就是context switch。再说得简单一点，就是进程切换</p>
<p>context switch要做这样一些工作：</p>
<ol>
<li>保留寄存器(包括栈顶指针)</li>
<li>状态字需要保留</li>
<li>pc要保留，并指向新的进程开始的第一条指令</li>
</ol>
<ul>
<li>Signals  - Implemented by OS software</li>
</ul>
<p>一个进程可以主动的发一个signal，比如说 kill 指令可以杀死一个进程；或者yield指令，可以将CPU让出来让别人用；sleep指令可以先睡眠，过一会再回来运行</p>
<ul>
<li>Nonlocal jumps：setjump() 和 longjmp()</li>
</ul>
<p>跳到很远的地方去执行</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常(exception)就是控制流中的突变，用来响应处理器状态中的某些变化。</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/3.png" style="zoom:120%;"></p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>在这张图中，当处理器状态中发生一个重要变化的时候，处理器正在处理 $I_{current}$ 。在处理器中，状态被编码为不同的位和信号。状态变化称为 event(事件)。</p>
<p>事件可能和当前指令的执行直接相关。比如发生内存缺页、算术溢出、或者一条指令试图除以0等等。<br>另一方面，事件也可能和当前指令的执行没有关系，比如一个系统定时器产生信号或者一个I/O请求完成</p>
<p>在任何情况下，当处理器检测到有事件发生的时候，它就会通过一张  异常表 的跳转表来跳到一个专门设计用来处理这类事件的操作系统子程序。</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/4.png" style="zoom:120%;"></p>
<p>当异常处理程序完成处理后，根据引起的异常的事件的类型，会发生一下三种情况：</p>
<ol>
<li>处理程序将控制返回给当前指令 $I_{curr}$ ，即当事件发生的时候正在执行的指令。比如说缺页 page fault</li>
<li>处理程序将控制返回给 $I_{next}$，如果没有异常将会执行下一条指令。比如说 arithmetic overflow 溢出了</li>
<li>处理程序终止被中断的程序。比如说 ctrl+c</li>
</ol>
<h3 id="异常类别"><a href="#异常类别" class="headerlink" title="异常类别"></a>异常类别</h3><p>首先我们要了解同步和异步的概念。</p>
<p>同步代表着我必须马上回应出现的异常，处理完才能进行下一步操作。异步则代表我可以先执行其他操作，让系统去处理这个异常，等处理完后再回来也可以。</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/5.png"></p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/10.png"></p>
<h4 id="Interrupts-中断"><a href="#Interrupts-中断" class="headerlink" title="Interrupts(中断)"></a>Interrupts(中断)</h4><p>中断时异步发生的，这是来自处理器<strong>外部</strong> 的I/O设备信号的结果。硬件中断<strong>并不是由任何一条专门的指令造成的</strong>，从这个意义上说他是异步的。</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/6.png"></p>
<p>当处理程序返回时，它就将控制返回给下一条指令(也即如果没有发生中断，在控制流中会在当前指令之后的那条指令)。结果是程序继续执行，就好像没有发生过一样</p>
<p>比如说：Timer interrupt，这个意思是说我的时钟周期到了，不给我用了，系统强制把我的进程中断，执行其他进程。</p>
<p>又比如说外部的I/O设备中断，比如我按下 Ctrl-C，直接退出进程；网络或者磁盘上的数据到了，那么这个时候就会去执行其他进程</p>
<h4 id="Trap-陷阱"><a href="#Trap-陷阱" class="headerlink" title="Trap(陷阱)"></a>Trap(陷阱)</h4><p>陷阱是有意的异常，是执行一条指令的结果。就像中断处理程序一样，陷阱处理程序将控制返回到下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做<strong>系统调用</strong>。</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/7.png"></p>
<p>用户程序经常需要向内核请求服务，比如读一个文件（read)、创建一个新的进程(fork) 加载一个新的程序（execve)，或者终止当前进程（exit)。为了允许对这些内核服务的受控的访问，处理器提供了一条特殊的<code>syscall n</code>指令，当用户程序想要请求服务n时，可以执行这条指令。执行<code>syscall</code>指令会导致一个到异常处理程序的陷阱, 这个处理程序解析参数，并调用适当的内核程序。</p>
<p>比如说我们在用 gdb调试的时候设置的breakpoints</p>
<h4 id="Fault"><a href="#Fault" class="headerlink" title="Fault"></a>Fault</h4><p>故障由错误情况引起，它可能能够被故障处理程序<strong>修正</strong>。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而<strong>重新执行它</strong>。否则，处理程序返回到内核中的abort 例程，abort 例程会终止引起故障的应用程序</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/8.png"></p>
<h4 id="Aborts-终止"><a href="#Aborts-终止" class="headerlink" title="Aborts(终止)"></a>Aborts(终止)</h4><p>终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如DRAM 或者 SRAM 位被损坏时发生的奇偶错误。终止处理程序从不将控制返回给应用程序。</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/9.png"></p>
<h4 id="Linux-x86-64-系统中的异常"><a href="#Linux-x86-64-系统中的异常" class="headerlink" title="Linux/x86-64 系统中的异常"></a>Linux/x86-64 系统中的异常</h4><p>x86-64 系统定义了256种不同的异常类型。</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/10.png"></p>
<h4 id="x86-64-的故障与终止"><a href="#x86-64-的故障与终止" class="headerlink" title="x86-64 的故障与终止"></a>x86-64 的故障与终止</h4><p><strong>除法错误</strong>。当应用试图除以零时，或者当一个除法指令的结果对于目标操作数来说太大了的时候，就会发生除法错误（异常0)。Unix 不会试图从除法错误中恢复，而是选择终止程序。Linux shell 通常会把除法错误报告为“浮点异常(Floatmg exception)”</p>
<p><strong>一般保护故障</strong>。许多原因都会导致不为人知的一般保护故障（异常13)，通常是因为一个程序引用了一个未定义的虚拟内存区域，或者因为程序试图写一个只读的文本段。Linux 不会尝试恢复这类故障。Linux shell 通常会把这种一般保护故障报告为“段故障(Segmentation fault)”</p>
<p><strong>缺页</strong>(异常14)是会重新执行产生故障的指令的一个异常示例。处理程序将适当的磁盘上虚拟内存的一个页面映射到物理内存的一个页面，然后重新执行这条产生故障的指令。我们将在第9 章中看到缺页是如何工作的细节。</p>
<p><strong>机器检查</strong>。机器检査（异常18)是在导致故障的指令执行中检测到致命的硬件错误时发生的。机器检査处理程序从不返回控制给应用程序。</p>
<h4 id="x86-64-的系统调用"><a href="#x86-64-的系统调用" class="headerlink" title="x86-64 的系统调用"></a>x86-64 的系统调用</h4><p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/12.png"></p>
<p>当我们system call的时候，汇编指令用的是 syscall，注意，这时候rsp并不是在用户栈里面，而会把栈指针指导Kernel里面去</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><p>进程：进程就是在运行中的程序。CPU在使用的时候都是以进程为单位的。</p>
<p>线程：随着我们的应用程序越来越复杂，我们希望CPU能处理一个程序的并行任务。也就是一个进程里面有多个指令执行的序列，这些序列可以是异步的。比如说把一个人比作一个进程，那么他可以学算法、可以学CSAPP、可以学音乐，这些科目就是线程，它们共享人的大脑、书包、宿舍(cache,memory等资源)</p>
<p>注意，当有多个线程的时候，每个线程的stack是不共享的，因为他们有不同的指令序列。</p>
<p>上下文：上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的<strong>栈</strong>、<strong>通用目的寄存器的内容</strong>、<strong>程序计数器</strong>、<strong>环境变量</strong>以及 <strong>打开文件描述符的集合</strong></p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/13.png" style="zoom:67%;"></p>
<p>每次用户通过向shell 输人一个可执行目标文件的名字，运行程序时，shell 就会创建一个新的进程，然后在这个新进程的上下文中运行这个可执行目标文件。应用程序也能够创建新进程，并且在这个新进程的上下文中运行它们自己的代码或其他应用程序。</p>
<p>在这一节，我们将关注进程提供给应用程序的关键抽象：</p>
<ul>
<li>Logical control flow：一个独立的逻辑控制流，它提供了一个假象，好像我们程序独占地使用处理器</li>
<li>Private address space：一个私有的地址空间，它提供了一个假象，好像我们的程序独占地使用内存系统</li>
</ul>
<h3 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h3><p>multi-programming 多道程序，也就是是多个进程的意思。</p>
<p>multi-threading: 多线程</p>
<p>multi-tasking: 多任务，机器进行多项任务批处理，交互性差</p>
<p>multi-processing ： 多任务处理</p>
<p>Time sharing(分时)：将时间划分成时间片，进程按时间片轮流执行</p>
<p>Multi-programming(多道)：系统中存在多个程序同时执行，增加CP的利用率。</p>
<p>区别：分时主要针对提高系统的响应速度，改善用户体验；多道主要针对增加系统的利用</p>
<p>multi-threading 和 multi-tasking 是一回事。</p>
<p>我们刚才说了进程会向每个人提供一种假象，好像它在独占地使用处理器。那么我们如果这时候去看PC(程序计数器)的值，就会发现这些值唯一地对应于包含在程序的可执行目标文件中的指令。这个PC值得序列就叫做逻辑控制流(简称逻辑流)</p>
<p>比如说下图，一个运行着三个进程的系统。处理器的一个物理控制流被分成了三个逻辑流，每个进程一个。 每个竖直的条表示一个进程的逻辑流的一部分。</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/14.png"></p>
<p>在这个例子中，三个逻辑流的执行是交错的。进程A运行了一会儿，然后是进程B开始运行到完成。然后，进程C运行了一会，进程A接着运行直到完成。最后进程C可以运行到结束了。</p>
<p>上图的关键点在于进程是轮流使用处理器的。每个进程执行它的流的一部分，然后被抢占(暂时挂起)，然后轮到其他进程。对于一个运行在这些进程之一的上下文中的程序，它看上去就像是在独占地使用处理器。</p>
<p>但是如果我们精确地测量每条指令使用的时间，会发现在程序中一些指令的执行之间，CPU好像会周期性地停顿。但是这并不会改变程序内存位置或者寄存器的内容。</p>
<h3 id="并发流"><a href="#并发流" class="headerlink" title="并发流"></a>并发流</h3><p>一个逻辑流的执行在时间上与另一个流重叠，称为并发流(concurrent flow)，这两个流被称为并发地运行。</p>
<p>比如说流X和Y互相并发，当且仅当 (X在Y开始之后和Y结束之前开始|Y在X开始之后和X结束之前开始)</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/15.png"></p>
<p>在这张图中，进程A和B并发地运行，A和C也是并发运行，但是B和C不是并发运行，因为B的最后一条指令在C的第一条指令之前执行</p>
<p>多个流并发地执行的一般现象被称为并发（concurrency)。一个进程和其他进程轮流运行的概念称为多任务（multitasking)。一个进程执行它的控制流的一部分的每一时间段叫做时间片（time slicing) 因此，多任务也叫做时间分片（time slicing).比如说上图，进程A的流是由两个时间片组成的。</p>
<p>但是在真正的执行过程中间，它们是不相交的，分离的。不过从用户的角度来看，并发地进程是相交的。因此在用户看来，三个进程是这样运行的。</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/16.png"></p>
<h3 id="私有地址空间"><a href="#私有地址空间" class="headerlink" title="私有地址空间"></a>私有地址空间</h3><p>进程会为每个程序提供它自己的私有地址空间。一般而言，和这个空间中某个地址相关联的那个内存字节是不能被其他进程读或者写的，因此说这个地址空间是私有的。</p>
<p>每一个地址空间的组织结构都是类似的。</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/17.png"></p>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>内核为每一个进程都维持一个上下文。上下文就是内核重新启动一个被抢占的进程所需的状态。</p>
<p>它由一些对象的值组成，这些对象包括<strong>通用目的寄存器</strong>、<strong>浮点寄存器</strong>、<strong>程序计数器</strong>、<strong>用户栈</strong>、<strong>状态寄存器</strong>、<strong>内核栈</strong>、<strong>各种内核数据结构(页表、进程表、文件表等)</strong></p>
<p>在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫<strong>调度</strong>，是由内核中称为调度器的代码处理的。</p>
<p>在内核调度了一个新的进程运行后，它就抢占当前的进程，并使用一种称为上下文切换的机制来将控制转移到新的进程</p>
<p>上下文切换有三个步骤：</p>
<ol>
<li>保存当前进程的上下文</li>
<li>恢复某个先前被抢占的进程被保存的上下文</li>
<li>将控制传递给这个新恢复的进程</li>
</ol>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/18.png"></p>
<p>如上图所示，进程A进行了read的系统调用，此时内核不会只等待读取的完成而什么都不做，而是切换到进程B继续执行。磁盘发出中断信号表面数据以及存入内存中，此时内核又会切换回进程A，继续执行read后的指令。</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="System-Call-Error-Handling"><a href="#System-Call-Error-Handling" class="headerlink" title="System Call Error Handling"></a>System Call Error Handling</h3><p>在出现错误时，Linux系统级函数通常返回-1和设置全局变量errno来指示原因</p>
<p>比如说fork()函数，它是用来创建一个新进程的。如果它的pid小于0，就说明创建新进程失败了，因此我们需要报告并打印这个错误信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"fork error: %s\n"</span>, strerror(errno));</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是我们对每个错误都这样写的话，会非常麻烦而且容易出错，因此我们可以把这个函数封装一下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unix_error</span><span class="params">(<span class="keyword">char</span> *msg)</span> <span class="comment">/* Unix-style error */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s: %s\n"</span>, msg, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">	unix_error(<span class="string">"fork error"</span>);</span><br></pre></td></tr></table></figure>
<p>这样以后，我只要 写一个<code>unix_error</code>函数,然后调用即可</p>
<h4 id="Wrappers"><a href="#Wrappers" class="headerlink" title="Wrappers"></a>Wrappers</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">Fork</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">    	unix_error(<span class="string">"Fork error"</span>);</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br><span class="line">/..../</span><br><span class="line">pid = Fork();</span><br></pre></td></tr></table></figure>
<p>我们可以写得更有层次一点，将fork()函数封装在Fork()函数当中</p>
<p>这里我们再关注一下fork()函数，fork()是仅有的调用一次返回两次的函数。return的数值有两种情况，一种是return自己的 <code>pid</code>，另一种是return 子进程的 <code>pid</code></p>
<h4 id="Obtaining-Process-IDs"><a href="#Obtaining-Process-IDs" class="headerlink" title="Obtaining Process IDs"></a>Obtaining Process IDs</h4><p><code>pid_t getpid(void)</code> 这个函数返回当前进程的PID</p>
<p><code>pid_t getppid(void)</code>这个函数返回父进程的PID</p>
<h3 id="创建和终止进程"><a href="#创建和终止进程" class="headerlink" title="创建和终止进程"></a>创建和终止进程</h3><p>从一个程序员的角度，我们可以认为一个进程一定是这三个状态中的一个</p>
<p><strong>Running:</strong></p>
<p>Running 状态就是拿到CPU直接可以运行；也可以说是Ready，即现在还没拿到CPU,但是拿到CPU之后可以马上运行</p>
<p><strong>Stopping:</strong></p>
<p>进程的执行被挂起，处于等待状态。当收到 SIGSTOP、SIGTSTP、SIGTTIN或者SIGTTOU信号时，进程就会停止，并且保持停止到它收到一个SIGCONT信号，在这个时刻，进程再次开始运行</p>
<p><strong>Terminated:</strong></p>
<p>结束状态，但是分配给进程的资源还没有回收。这种状态也叫做Zombie ，也就是我们常说的僵尸进程。</p>
<h4 id="Terminating"><a href="#Terminating" class="headerlink" title="Terminating"></a>Terminating</h4><p>当发生以下三个情况的时候，进程就会被终止</p>
<ul>
<li>Receiving a signal whose default action is to terminate </li>
<li>Returning from the main routine</li>
<li>Calling the exit function</li>
</ul>
<p>exit 函数 <code>void exit(int status)</code></p>
<ul>
<li>Terminates with an <em>exit status</em> of status </li>
<li>Convention: normal return status is 0,nonzero on error</li>
<li>Another way to explicitly set the exit status is to return an integer value from the main routine</li>
</ul>
<p>exit没有return，只有call。因此在exit()后面写代码是毫无意义的。</p>
<h4 id="Creating-Processes"><a href="#Creating-Processes" class="headerlink" title="Creating Processes"></a>Creating Processes</h4><p>当我们调用fork函数的时候，父进程会创造一个新的子进程</p>
<p><code>int fork(void)</code> 的一些注意点</p>
<ul>
<li><p>Returns 0 to the child process,child’s PID to parent process</p>
<ul>
<li>即如果我拿到了一个PID，就说明我是父进程；如果我拿到了一个0，就说明我是一个子进程</li>
</ul>
</li>
<li><p>子进程和父进程基本是一样的：</p>
<ul>
<li>子进程得到了一个和父进程一模一样的虚拟地址空间，连页表都是相等的。但是请注意，只是长得一样，他们的地址空间还是相互独立的，并不会因为子进程修改了某个值从而影响父进程中的值</li>
<li>子进程拿到的资源、打开文件的列表，也是和父进程一样的</li>
<li>只有PID和父进程是不一样的。</li>
</ul>
</li>
</ul>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/19.png"></p>
<p>下面是一段fork的例子，当pid\=\=0,代表这是一个子进程，并++x; 否则就说明这是一个父进程,并—x。</p>
<p>请注意</p>
<ul>
<li>父进程和子进程是并发运行的==父进程和子进程谁先拿到CPU是没有规定的==, 因此不能预测谁先回来谁后回来。</li>
<li>Duplicate but separate address space.也就是我上面所说，修改父进程中的x是不会对子进程中的x造成影响的，反之亦然</li>
<li>Shared open files，父进程打开的文件，子进程看到的话也是打开着的</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    pid = Fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">/* Child */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child : x=%d\n"</span>, ++x);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Parent */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent: x=%d\n"</span>, --x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/20.png"></p>
<p>如果我们一定要某一个进程在另一个进程之后，我们可以这样来设计我们的程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fork wrapper function */</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    initialize();</span><br><span class="line">    <span class="keyword">int</span> parent_delay = choose_delay();</span><br><span class="line">    <span class="keyword">int</span> child_delay = choose_delay();</span><br><span class="line">    <span class="keyword">pid_t</span> parent_pid = getpid();</span><br><span class="line">    <span class="keyword">pid_t</span> child_pid_or_zero = real_fork();</span><br><span class="line">    <span class="comment">//如果大于0，就说明这是个父进程，那么我们就打印子进程、要等多少；父进程，要等多少时间</span></span><br><span class="line">    <span class="keyword">if</span> (child_pid_or_zero &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Parent */</span></span><br><span class="line">        <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(</span><br><span class="line">            <span class="string">"Fork. Child pid=%d, delay = %dms. Parent pid=%d, delay = %dms\n"</span>,</span><br><span class="line">                child_pid_or_zero, child_delay,</span><br><span class="line">                parent_pid, parent_delay);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ms_sleep(parent_delay);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Child，那么子进程就等待一段时间*/</span></span><br><span class="line">        ms_sleep(child_delay);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> child_pid_or_zero;<span class="comment">//返回子进程的PID</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Modeling-fork-with-Process-Graphs"><a href="#Modeling-fork-with-Process-Graphs" class="headerlink" title="Modeling fork with Process Graphs"></a>Modeling fork with Process Graphs</h3><p>我们可以针对fork之后的进程画一张进程图。流程图是捕获并发程序中语句的偏序关系的有用工具。</p>
<ul>
<li>在这张图中每一个结点是我代码中的一条指令。</li>
<li>$a\rightarrow b$ 代表着 a在b之前发生</li>
<li>边能够打标签，表示某一个变量的值</li>
<li><code>printf</code>  结点可以被标为 输出</li>
<li>每张图最早的是由一个没有入读的结点开始的。</li>
</ul>
<p>对于这张图，我们做拓扑排序。并且图的任何拓扑类型都对应于一个可行的总体排序</p>
<p>下面是一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    pid = Fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">/* Child */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child : x=%d\n"</span>, ++x);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Parent */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent: x=%d\n"</span>, --x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于之前那个例子，我们画出流程图如下</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/21.png"></p>
<p>此外，我们还可以画出更加抽象的 Relabled Graph , Feasible total ordering </p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/22.png"></p>
<h4 id="小练习1"><a href="#小练习1" class="headerlink" title="小练习1"></a>小练习1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"L0\n"</span>);</span><br><span class="line">    fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"L1\n"</span>);</span><br><span class="line">    fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Bye\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们对这个程序画流程图，如下：</p>
<p>第一次是乘2，第二次对子进程和父进程同时乘2.因此会出来两个L1，4个Bye</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/23.png"></p>
<p>根据这幅图 我们可以得到一个可行的输出</p>
<p>$L0\rightarrow L1\rightarrow Bye\rightarrow Bye\rightarrow L1\rightarrow Bye\rightarrow Bye$</p>
<p>我们知道L1必定在两个Bye之前，但是这两个分支输出的顺序是不知道的。</p>
<h4 id="小练习2"><a href="#小练习2" class="headerlink" title="小练习2"></a>小练习2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fork4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"L0\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (Fork() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"L1\n"</span>);</span><br><span class="line">        <span class="keyword">if</span> (Fork() != <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="built_in">printf</span>(<span class="string">"L2\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Bye\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当代码中存在if 判断的时候，那么流程图又该怎么画？</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/24.png"></p>
<p>我们看到if的条件是 <code>Fork()!=0</code> ，也就是必须是父进程才能进行L1和L2的输出，如果是子进程，那么会直接输出Bye</p>
<p>一个可能的答案是： $L0\rightarrow L1\rightarrow Bye\rightarrow Bye\rightarrow L2\rightarrow Bye$ </p>
<h4 id="小练习3"><a href="#小练习3" class="headerlink" title="小练习3"></a>小练习3</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fork5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"L0\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"L1\n"</span>);</span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="built_in">printf</span>(<span class="string">"L2\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Bye\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和练习2不同，这里是只有子进程能输出L1、L2，父进程是只能输出Bye的</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/25.png"></p>
<p>我们可以通过拓扑排序输出一个可行的序列</p>
<p>$L0\rightarrow Bye\rightarrow L1\rightarrow L2\rightarrow Bye\rightarrow Bye$ </p>
<h3 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h3><p>当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收（reaped)。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程，从此时开始,该进程就不存在了。一个<strong>终止了</strong>但还<strong>未被回收</strong>的进程称为 僵尸进程</p>
<p>如果一个父进程先于子进程终止，那么Kernel会安排init进程(PID=1,在系统启动时由内核创建)作为孤儿进程的养父。然后由init进程来回收他们。然而长时间运行的程序(shell/服务器)，总是应该回收他们的僵尸子进程，因为即使它们没有运行，也会消耗系统的内存资源。</p>
<p>父进程可以通过<code>wait</code>或者<code>waitpid</code>函数来等待 它的子进程终止或者停止</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pit_t</span> pid,<span class="keyword">int</span> *statusp,<span class="keyword">int</span> options)</span></span>;</span><br><span class="line"><span class="comment">/*返回值：如果成功，则为子进程的PID;如果WNOHANG,则为0;如果是其他错误,则为-1*/</span></span><br></pre></td></tr></table></figure>
<p>父进程得到返回值之后，Kernel需要将僵尸子进程删除。</p>
<h4 id="例子1：Zombie-Example"><a href="#例子1：Zombie-Example" class="headerlink" title="例子1：Zombie Example"></a>例子1：Zombie Example</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fork7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Child */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Terminating Child, PID = %d\n"</span>, getpid());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Running Parent, PID = %d\n"</span>, getpid());</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">            <span class="comment">/* Infinite loop */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父进程是6639，子进程是6640</p>
<p>因为子进程先exit(0)了，但是父进程没有收回子进程，所以子进程现在是 defunct的，说明这个进程是僵尸进程。</p>
<p>这时候我们如果 <code>kill 6639</code> ，那么会同时回收父进程和子进程。</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/26.png">     </p>
<h4 id="例子2-Non-terminating-Child-Example"><a href="#例子2-Non-terminating-Child-Example" class="headerlink" title="例子2: Non-terminating Child Example"></a>例子2: Non-terminating Child Example</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fork8</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* Child */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Running Child, PID = %d\n"</span>,getpid());</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>); <span class="comment">/* Infinite loop */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Terminating Parent, PID = %d\n"</span>,getpid());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，如果我们先终止的是父进程，我们发现即使父进程已经被终止了，但是子进程还是在运行当中。我们一定要显式地Kill 子进程才能终止。</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/27.png"></p>
<h3 id="wait-Synchronizing-with-Children"><a href="#wait-Synchronizing-with-Children" class="headerlink" title="wait: Synchronizing with Children"></a>wait: Synchronizing with Children</h3><p>如果我不去杀掉父进程，如何仍能在子进程 $exit(0)$ 的时候收回子进程？我们可以用wait函数。wait函数可以通过系统调用和子进程的状态进行同步。</p>
<p><code>int wait (int *child_status)</code> 这是wait函数的用法，后面跟的时子进程的状态</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/28.png"></p>
<p>调用wait之后，父进程就会进入一个suspended状态，等到子进程的特定的状态产生，才会做后面的事情。也就是做一个同步的工作。wait函数的返回值就是这个被终止掉的子进程的 <code>pid</code>，如果<code>child_status!=NULL</code>,那么它所指向的整数将被设置为一个值，该值指示子进程终止的原因和退出状态:</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/29.png"></p>
<h4 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fork9</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> child_status;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"HC: hello from child\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"HP: hello from parent\n"</span>);</span><br><span class="line">        wait(&amp;child_status);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"CT: child has terminated\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Bye\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请画出这个例子的流程图：</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/30.png"></p>
<p>我们看到，在fork之后，子进程会打印<code>HC: hello from child</code> ；而父进程会打印 <code>HP: hello from parent</code> 打印完之后父进程并不会直接打印 <code>CT</code> ，因为这时候他在等待子进程结束，等子进程结束之后，父进程才会打印<code>CT: child has terminated</code> 最后打印Bye</p>
<p>所以 <code>Feasible output</code> 可以为 HC HF CT Bye 或者 HP HC CT Bye</p>
<h4 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h4><p>如果多个子进程结束了，这时候该怎么办？ 这时候wait会接收任何一个子进程发出的信号。这时候对于父进程，需要得到终止的到底是哪个子进程，然后将终止的子进程的pid和子进程终止的状态显示出来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fork10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid[N];</span><br><span class="line">    <span class="keyword">int</span> i, child_status;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    <span class="keyword">if</span> ((pid[i] = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">100</span>+i); <span class="comment">/* Child */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123; <span class="comment">/* Parent */</span></span><br><span class="line">        <span class="keyword">pid_t</span> wpid = wait(&amp;child_status);</span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(child_status))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Child %d terminated with exit status %d\n"</span>,wpid, WEXITSTATUS(child_status));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line"> 		    <span class="built_in">printf</span>(<span class="string">"Child %d terminate abnormally\n"</span>, wpid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我有很多的子进程，但我只关心某一个特定的子进程，那么我可以使用<code>waitpid</code>这个函数。通过这个函数，我们可以按照顺序依次回收进程。如果前面一个进程没有结束，那么后面一个进程也不能提前被回收。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fork11</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid[N];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> child_status;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="keyword">if</span> ((pid[i] = fork()) == <span class="number">0</span>)</span><br><span class="line">        	<span class="built_in">exit</span>(<span class="number">100</span>+i); <span class="comment">/* Child */</span></span><br><span class="line">    <span class="keyword">for</span> (i = N<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">pid_t</span> wpid = waitpid(pid[i], &amp;child_status, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(child_status))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Child %d terminated with exit status %d\n"</span>,wpid, WEXITSTATUS(child_status));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">	        <span class="built_in">printf</span>(<span class="string">"Child %d terminate abnormally\n"</span>, wpid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="execve"><a href="#execve" class="headerlink" title="execve"></a>execve</h3><p>Fork是创建一个进程，但是这个进程所有的东西都是和父亲共享的。但是有时候我们想要一个进程运行一个新的程序。这时候我们就需要构建一个程序的代码并加载程序，这时候就需要<code>execve</code> 来帮助我们完成</p>
<p><code>int execve(char *filename,char *argv[],char *envp[])</code></p>
<p><code>filename</code> 表明了文件在哪个地方，<code>*argv[]</code>是一个指针数组 <code>argv[0]</code>就是指这个filename ，没有<code>*argc[]</code> 的原因是因为 <code>argc</code> 代表了参数的个数，但是<code>execve</code>并不需要这个量 </p>
<p>作用就是 Overwrites code, data, and stack . 保留了 PID, open files and signal context</p>
<ul>
<li><code>execve</code> 函数仅调用一次，(成功的话)并且不会返回，这是因为函数将栈清除了，也就是说return地址没了，所以不会返回。<code>fork</code>是调用则会返回两次</li>
<li>但是如果<code>execve</code>调用不成功，那么就会返回-1</li>
</ul>
<p>比如说这样一段代码，首先创建一个子进程，然后对其执行 <code>/bin/ls -lt /usr/include</code> 命令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>) &#123; <span class="comment">/* Child runs program */</span></span><br><span class="line">    <span class="keyword">if</span> (execve(myargv[<span class="number">0</span>], myargv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s: Command not found.\n"</span>, myargv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/31.png"></p>
<p>在<code>execve</code> 加载了 filename之后，它调用了启动代码。启动代码设置栈，并将控制传递给了新程序的主函数，该主函数有如下形式的原型：<code>int main(int argc,char **argv,char **envp);</code> </p>
<p>当main开始执行的时候，用户栈的组织结构如下图所示 。让我们从栈底(高地址)往栈顶(低地址)依次看一看。首先是参数和环境字符串。全局变量<code>environ</code>指向这些指针中的第一个 <code>envp[0]</code>.紧随环境变量数组之后的是以null 结尾的argv[]数组，其中每个元素都指向栈中的一个参数字符串.</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/32.png" style="zoom:67%;"></p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/33.png" style="zoom:67%;"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" itemprop="url">CSAPP动态内存分配</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-12-01T21:22:38+08:00">
                2020-12-01
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-06-25T16:21:54+08:00">
                2022-06-25
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="CSAPP动态内存分配"><a href="#CSAPP动态内存分配" class="headerlink" title="CSAPP动态内存分配"></a>CSAPP动态内存分配</h1><p>动态内存分配器维护着一个进程的虚拟内存区域，称为<strong>堆</strong>。 比如说 malloc，我们用malloc来申请一段虚拟内存的时候，操作系统分配给我们的是一段 block ，但这个block和之前提到的page、cache中的block是不一样的，这边每个block的<strong>大小是不一样</strong>的。</p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/1.png" style="zoom:80%;"></p>
<p>分配过来的blocks，有两种。</p>
<ul>
<li>一种是allocated也就是被分配的，已分配的块显式地保留 <strong>供应用程序使用</strong><ul>
<li>一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用<strong>程序显式执行的</strong>，要么是内<strong>存分配器自身隐式执行</strong>的。</li>
</ul>
</li>
<li>还有一种是free，也就是没有被分配的，因此可以用来分配。</li>
</ul>
<p>分配器也有两种：显式的分配器和隐式的分配器</p>
<ul>
<li>显式分配器：比如说 C语言中的malloc和free，C++当中的new和delete</li>
<li>隐式分配器：比如说 Java语言中的垃圾回收系统。</li>
</ul>
<h2 id="显式分配器"><a href="#显式分配器" class="headerlink" title="显式分配器"></a>显式分配器</h2><p>现在我们主要讨论显式分配器的设计与实现。</p>
<h3 id="malloc和free函数"><a href="#malloc和free函数" class="headerlink" title="malloc和free函数"></a>malloc和free函数</h3><h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>malloc</code>函数返回一个指针。执行完需要进行判断，因为不一定每次申请分配内存都能成功。如果申请不成功就返回一个空指针，并设置一个errno；若申请成功就返回一个大小至少为size字节的内存块，还有可能比size更大,因为给我们的块会为可能包含在这个块内的任何数据对象类型做对齐。在64位模式中，malloc返回的块的地址总是16的倍数。</p>
<h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br></pre></td></tr></table></figure>
<p>free适合malloc对应的，我们可以利用这个函数来回收之前分配的内存。注意，这个 * p 一定要是 malloc，calloc和realloc这三个函数的返回值，否则会报错。</p>
<h4 id="sbrk"><a href="#sbrk" class="headerlink" title="sbrk"></a>sbrk</h4><p>sbrk 函数通过将内核的brk 指针增加incr 来扩展和收缩堆。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sbrk</span><span class="params">(<span class="keyword">intptr_t</span> incr)</span></span></span><br></pre></td></tr></table></figure>
<p>下面是malloc和free函数实际使用例子：</p>
<p>首先我们用malloc申请一个长度为n的数值类型为long的数组。然后对数组进行一个赋值以及后续操作。最后在程序结束时将其free</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> i, *p;</span><br><span class="line">	<span class="comment">/* Allocate a block of n longs */</span></span><br><span class="line">	p = (<span class="keyword">long</span> *) <span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">long</span>)); </span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		perror(<span class="string">"malloc"</span>); </span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* Initialize allocated block */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">   		p[i] = i;</span><br><span class="line">    <span class="comment">/* Do something with p */</span></span><br><span class="line">    . . .</span><br><span class="line">    <span class="comment">/* Return allocated block to the heap */</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="malloc-和free-实现管理堆"><a href="#malloc-和free-实现管理堆" class="headerlink" title="malloc 和free 实现管理堆"></a>malloc 和free 实现管理堆</h4><p>假设下面是一个堆的模型，我们定义两条规则：</p>
<ul>
<li><p>Show 8-byte words as squares 没一格子代表了一个 word</p>
</li>
<li><p>Allocations are double-word aligned. 双字对齐</p>
</li>
</ul>
<p><code>#define SIZ sizeof(size_t)</code></p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/2.png" style="zoom:80%;"></p>
<ul>
<li>我们一开始申请4倍的SIZ ,于是就有了黄色的4个格子</li>
<li>紧接着我们申请5倍的SIZ，因为要<strong>双字对齐</strong>，因此我们要划出6个格子来。</li>
<li>我们申请6倍的SIZ,malloc 就从空闲块的前部切出一个6字的块</li>
<li>调用free后，会释放掉第二部申请的5*SIZ 的块。</li>
<li>程序请求一个2字的块。在这种情况中，malloc分配在前一步中被释放的那个块的一部分并返回一个指向这个新块的指针。</li>
</ul>
<p><strong>一些分配和回收时的约束</strong></p>
<ul>
<li>处理任意请求序列。一个应用可以有任意的分配请求和释放请求序列，只要满足约束条件：每个释放请求必须对应于一个当前已分配块，这个块是由一个以前的分配请求获得的。因此，<strong>分配器不可以假设分配和释放请求的顺序</strong>。例如，分配器不能假设<strong>所有</strong>的分配请求<strong>都有</strong>相匹配的释放请求，或者有相匹配的分配和空闲请求是嵌套的。</li>
<li>立即响应请求。分配器<strong>必须立即响应</strong>分配请求。因此，<strong>不允许</strong>分配器为了提髙性能<strong>重新排列或者缓冲</strong>请求。不能是异步的</li>
<li>只使用堆。为了使分配器是可扩展的，分配器使用的任何非标量数据结构都必须保存在堆里。</li>
<li>对齐块（对齐要求）。分配器必须对齐块，使得它们可以保存任何类型的数据对象。</li>
<li>不修改已分配的块。分配器只能操作或者改变空闲块。特别是，一旦块被分配了，就不允许修改或者移动它了。因此，诸如压缩已分配块这样的技术是不允许使用的。(就是把中间的空的blocks压出来，这种是不可以的)</li>
</ul>
<h3 id="衡量分配器性能的一些指数："><a href="#衡量分配器性能的一些指数：" class="headerlink" title="衡量分配器性能的一些指数："></a>衡量分配器性能的一些指数：</h3><h4 id="吞吐率"><a href="#吞吐率" class="headerlink" title="吞吐率"></a>吞吐率</h4><p>现在我们假设 假定n 个分配和释放请求的某种序列 $R<em>0,R_1,\cdots,R_k,\cdots ,R</em>{n-1}$；我们希望一个分配器的吞吐率最大化,吞吐率的定义就是每个单位时间里完成的请求数。</p>
<p>例如，如果一个分配器在1 秒内完成500 个分配请求和500 个释放请求，那么它的吞吐率就是每秒1000 次操作</p>
<h4 id="内存利用率"><a href="#内存利用率" class="headerlink" title="内存利用率"></a>内存利用率</h4><p>我们要知道内存虚拟内存是一个有限的空间，我们不能一直向他申请blocks，因此我们必须高效地使用虚拟内存。对于可能被要求分配和释放大块内存的动态内存分配器来说，尤其如此。</p>
<h4 id="峰值利用率"><a href="#峰值利用率" class="headerlink" title="峰值利用率"></a>峰值利用率</h4><p>对于n 个分配和释放请求的某种序列 $R<em>0,R_1,\cdots,R_k,\cdots ,R</em>{n-1}$</p>
<p>如果说一个应用程序请求一个 p 字节的块，那么得到的已分配块地<strong>payload</strong> 是 p字节。</p>
<p>在请求 $R_k$ 完成之后，aggregate payload(聚集有效载荷) 表示为 $P_k$,即当前已分配的块地有效载荷之和。</p>
<p>$H_k$表示堆地当前的大小(单调非递减)</p>
<p>那么，前面 k+1 个请求得峰值利用率，表示为 $U<em>k$, $U_k = \frac{max</em>{i\leq k}P_i}{H_k}$ </p>
<p>我们看到，分配器的目标就是在整个序列中使 $U_{n-1}$ 最大化。但是最大化吞吐率和最大化利用率之间是相互牵制的。</p>
<p>当我们以<strong>堆利用率为代价时</strong> ，很容易编写出<strong>吞吐率最大化的</strong>分配器。</p>
<h3 id="Fragmentation"><a href="#Fragmentation" class="headerlink" title="Fragmentation"></a>Fragmentation</h3><p>碎片即分配内存时产生的额外开销，它也是造成堆利用率很低的主要原因</p>
<p>有两种形式的碎片：内部碎片(internal fragmentation)和外部碎片（external fragmentation)</p>
<h4 id="internal-fragmentation"><a href="#internal-fragmentation" class="headerlink" title="internal fragmentation"></a>internal fragmentation</h4><p>内部碎片就是<strong>已经被分配</strong>出去（能明确指出属于哪个进程）<strong>却不能被利用</strong>的内存空间</p>
<p>占有这些区域或页面的<strong>进程并不使用这个存储块</strong>。而在进程占有这块存储块时，<strong>系统无法利用</strong>它。直到进程释放它，或进程结束时，系统才有可能利用这个存储块。</p>
<p>当一个已分配块(allocated block) 比有效载荷(payload) 大的时候，内部碎片就会发生</p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/3.png" style="zoom:80%;"></p>
<h4 id="external-fragmentation"><a href="#external-fragmentation" class="headerlink" title="external fragmentation"></a>external fragmentation</h4><p>外部碎片是位于任何两个 <strong>操作系统分配的用于装载进程的内存区域</strong> 或<strong>页面之间</strong>的空闲区域</p>
<p>外部碎片指的是还没有被分配出去（不属于任何进程），但由于<strong>太小了</strong>无法分配给申请内存空间的新进程的内存空闲区域。</p>
<p>外部碎片是处于任何两个已分配区域或页面之间的空闲存储块。这些存储块的<strong>总和可以满足当前申请</strong>的长度要求，但是由于它们的<strong>地址不连续</strong>或其他原因，使得系统无法满足当前申请。</p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/4.png" style="zoom:80%;"></p>
<p>比如说对于第五个请求，heap中明明有8个格子，但是却无法给7*SIZ分配空间</p>
<h3 id="实现一个分配器"><a href="#实现一个分配器" class="headerlink" title="实现一个分配器"></a>实现一个分配器</h3><p>要实现一个分配器，我们必须要解决这样几个问题</p>
<ul>
<li><p>How do we know how much memory to free given just a pointer?</p>
<ul>
<li>给free一个指针，那么分配器要怎么知道释放多少大小的内存空间？</li>
</ul>
</li>
<li><p>空闲块组织：How do we keep track of the free blocks? </p>
<ul>
<li>我们怎么知道那些blocks是空的呢？怎么知道这一块空的区域的大小呢？</li>
</ul>
</li>
<li>分割：What do we do with the extra space when allocating a structure that is smaller than the free block it is placed in?<ul>
<li>当分配一个比它所在的空闲块还小的结构时，我们如何处理额外的空间 (比如说6块空的分配掉4块，那么剩下两块怎么标记？)</li>
</ul>
</li>
<li>放置：How do we pick a block to use for allocation — many might fit?<ul>
<li>如果我有多个满足条件的空间，我应该选择哪一个进行分配</li>
</ul>
</li>
<li>合并：How do we reuse a block that has been freed?<ul>
<li>释放出来后的内存空间我怎么重新利用？比如前面也是空的，后面也是空的，我要不要将他们合并在一起？</li>
</ul>
</li>
</ul>
<h3 id="隐式空闲链表"><a href="#隐式空闲链表" class="headerlink" title="隐式空闲链表"></a>隐式空闲链表</h3><p>因为像放置、分割以及合并这样的基本技术贯穿在许多不同的空闲块组织中，所以我们将在一种叫做隐式空闲链表的简单空闲块组织结构中来介绍它们。</p>
<p>隐式分配器：会自动回收用户使用的存储空间，简单来说就是带GC功能，如Java使用的就是隐式的堆分配器</p>
<p>显式分配器：要求用户显示的分配/释放堆空间，如C/C++用的就是显式的堆分配器</p>
<h4 id="释放多少大小的内存空间"><a href="#释放多少大小的内存空间" class="headerlink" title="释放多少大小的内存空间"></a>释放多少大小的内存空间</h4><p>如果我们要知道在释放时应该是放多少空间，那么我们可以在每一块block的前面放一个word来记录这个block的大小。比如说我这里申请了4个SIZ，分配了6个SIZ，那么就在一个word中记录这个block的大小：即48.</p>
<p>前面的word是这个block的header；后面的多余的空格即这个block的Padding(填充物)</p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/5.png" style="zoom:80%;"></p>
<h4 id="1-0-Keeping-Track-of-Free-Blocks"><a href="#1-0-Keeping-Track-of-Free-Blocks" class="headerlink" title="1.0 Keeping Track of Free Blocks"></a>1.0 Keeping Track of Free Blocks</h4><p>对于隐式的链表来说：</p>
<p>我们知道，每一个payload开始的位置必须是偶数个word，但是上面说了，每一个block的第一个word记录了这个block的大小。因此在堆的一开始我们必须空出来一个word。</p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/7.png" style="zoom:80%;"></p>
<p> 此外还有三种方法：</p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/9.png" style="zoom:80%;"></p>
<p>将一个block放大，我们可以看到这样的结构：</p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/6.png" style="zoom:80%;"></p>
<p>也就是说一个block 是由一个字的header、payload 以及一些padding组成的。header编码了这个块的大小，以及这个块是已分配的还是空闲的。如果我们强加一个双字的对齐约束条件，那么块大小就总是8 的倍数，且块大小的最低3 位总是零。(因为这是一个二进制数，因此只要满足后三位总是0，那么<strong>前面29位所表达的块的大小</strong> 就始终是8的倍数)因此，我们只需要内存大小的29 个高位，释放剩余的3 位来编码其他信息。</p>
<p>我们用3位中的最低位a来指明这个块是分配的还是空闲的。那么这个头部的大小计算公式就是：</p>
<p><code>block-&gt;header = size|alloc;</code></p>
<p>比如说一个分配的块的大小是24字节，那么它的头部就等于 </p>
<p><code>0x00000018|0x1 = 0x00000019</code></p>
<p>一个块大小为40(0x28) 字节的<strong>空闲块</strong>具有如下的头部</p>
<p><code>0x00000028|0x0 = 0x00000028</code></p>
<p>假设块的格式如上图所示，我们可以将堆组织为一个连续的已分配块和空闲块的序列</p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/8.png" style="zoom:80%;"></p>
<p>我们称这种结构为隐式空闲链表，是因为空闲块是通过头部中的大小字段隐含地连接着的。分配器可以通过遍历堆中所有的块，从而间接地遍历整个空闲块的集合。</p>
<p>注意，我们需要某种特殊标记的结束块，在这个示例中，就是一个设置了<strong>已分配位而大小为零</strong>的<strong>终止头部</strong>(end block)</p>
<p><strong>隐式空闲链表的优点是简单。显著的缺点是任何操作的开销，例如放置分配的块，要求对空闲链表进行搜索，该搜索所需时间与堆中已分配块和空闲块的总数呈线性关系。</strong></p>
<p>很重要的一点就是意识到系统<strong>对齐要求</strong>和<strong>分配器对块格式的选择</strong>会对分配器上的<strong>最小块大小</strong>有<strong>强制的要求</strong>。没有已分配块或者空闲块可以比这个最小值还小。例如，如果我们假设一个双字的对齐要求，那么每个块的大小都必须是双字（8 字节）的倍数。因此,9-35的块格式就导致<strong>最小的块大小为两个字</strong>：一个字作头，另一个字维持对齐要求。即使应用只请求一字节，分配器也仍然需要创建一个两字的块。</p>
<h4 id="放置策略-placement-policy"><a href="#放置策略-placement-policy" class="headerlink" title="放置策略(placement policy)"></a>放置策略(placement policy)</h4><p>当一个应用请求一个k字节的块的时候，分配器就会搜索空闲列表来查找一个足够大的可以放置所请求块的空闲块。我们有很多种放置策略：</p>
<h5 id="首次适配"><a href="#首次适配" class="headerlink" title="首次适配"></a>首次适配</h5><p>首次适配即从链表头开始查找，选择第一个合适的空闲块。</p>
<p>优点就是它趋向于将大的空闲块保留在链表后面</p>
<p>缺点是它趋向于在靠近链表起始处留下小空闲块的“碎片”，这就增加了对较大块的搜索时间</p>
<h5 id="下一次适配"><a href="#下一次适配" class="headerlink" title="下一次适配"></a>下一次适配</h5><p>下一次适配和首次适配相似，只不过不是从链表的起始处开始搜索，而是<strong>从上一次查询结束的地方开始</strong></p>
<p>下一次适配比首次适配运行起来明显要快一些。但是内存利用率要比首次适配低得多。</p>
<h5 id="最佳适配"><a href="#最佳适配" class="headerlink" title="最佳适配"></a>最佳适配</h5><p>最佳适配是检査每个空闲块，选择适合所需请求大小的最小空闲块</p>
<p>最佳适配比首次是配合下一次适配的利用率都要高一点，但在<strong>简单空闲链表组织结构(如隐式空闲链表)当中</strong>，使用最佳适配的缺点就是它要求对堆进行彻底的搜索。</p>
<h4 id="分割空闲块"><a href="#分割空闲块" class="headerlink" title="分割空闲块"></a>分割空闲块</h4><p>当我们找到一个匹配的空闲块之后，我们就需要分配这个空闲块中的空间。</p>
<p>我们自然可以选用整个空闲块，但是这样就会造成很多内部碎片。但如果放置策略趋向于产生较好的匹配，那么额外的内部碎片也是可以接受的。</p>
<p>但是如果匹配得不太好，那么分配器就通常会选择将这个空闲块分割为两部分。第一部分变成分配块，剩下的空间形成一个新的空闲块。</p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/10.png" style="zoom:80%;"></p>
<p>比如说上图，我们在size = 48的空闲块中插入一个size = 32的block，这时候空间块就会被拆成一个长为32的分配块、一个长为16的空闲块</p>
<h4 id="释放、合并空闲块"><a href="#释放、合并空闲块" class="headerlink" title="释放、合并空闲块"></a>释放、合并空闲块</h4><p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/11.png" style="zoom:80%;"></p>
<p>在释放块是时，我们不需要对被释放的块的header进行修改。我们只需要跳过这个block，将前一个header指向下下个block的header即可。</p>
<p>上面所说的是和后面的block相连，但是如果想要和<strong>前一个block相连</strong>，那么事情就变得复杂起来了。因为如果我们的模型只是一个带头部的隐式空闲链表，就没有一个指针指向前面一个block。那么我们只能是搜索整个链表，同时记住前面块的位置。那么如果这样操作，我们会发现每次调用free所需要的时间都和堆的大小成线性关系。即使使用更复杂更精细的空闲链表，搜索时间也不会是常数。</p>
<h4 id="2-0-带边界标记的合并"><a href="#2-0-带边界标记的合并" class="headerlink" title="2.0 带边界标记的合并"></a>2.0 带边界标记的合并</h4><p>于是我们可以将刚才提出的模型进行一个修改。这个修改是knuth提出来的。对于一个free block(空闲的块)，我们可以把这个块的结尾处改成一个footer。其中，<strong>footer是header的一个副本</strong>。这个设计十分巧妙，如果每个块都包括这样一个footer，那么分配器就可以通过检查它的footer，来判断前面一个块的起始位置和状态。</p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/12.png" style="zoom:80%;"> </p>
<p>那么当分配器释放当前块的时候，可能存在有以下四种情况</p>
<p><strong>1) 前面的块和后面的块都是已分配的</strong></p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/14.png" style="zoom:80%;"></p>
<p>对于这种情况，我们只要将中间这个空闲块的header和footer的占用位从1改成0即可。</p>
<p><strong>2) 前面的块是已分配的，后面的块是空闲的</strong></p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/15.png" style="zoom:80%;"></p>
<p>对于这种情况，新的header的和就等于释放的这一块的header+它后面那块free block的header，然后对footer也进行相应的修改。并将二者的占用位改成0</p>
<p><strong>3) 前面的块是空闲的，后面的块是已分配的</strong></p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/16.png" style="zoom:80%;"></p>
<p>这种情况和2一样。</p>
<p><strong>4) 前面的和后面的块都是空闲的</strong></p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/17.png" style="zoom:80%;"></p>
<p>对于前面的块和后面的块都是free block的情况，我们需要修改前面的块的header和后面的块的footer。其大小就是将三个块的大小相加。对于中间这些数据，都被跳过了，不用去修改它们。</p>
<p>于是整个模型如下图所示：</p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/13.png" style="zoom:80%;"></p>
<p>我们发现<strong>最前面和最后面的两块空间是利用不起来的</strong>。因为malloc返回的地址并不是header的起始地址，而是<strong>payload的起始地址</strong>。而payload的起始地址必须是偶数对齐的，因此必须要有一个word空出来的。</p>
<p>因为heap是自底向上生长的，因此我们定义Dummy footer是在第一个block之前的；Dummy header是在最后一个block之后的。而且他们都要被标记成已分配，这是因为他们不能和block进行合并操作。</p>
<h4 id="3-0-No-Boundary-Tag-for-Allocated-Blocks"><a href="#3-0-No-Boundary-Tag-for-Allocated-Blocks" class="headerlink" title="3.0 No Boundary Tag for Allocated Blocks"></a>3.0 No Boundary Tag for Allocated Blocks</h4><p>对于已经分配了的blocks来说，如果要有footer，由于对齐的原因，有可能要多两个字节来存放。因此，我们可以对分配了的block进行一些修改：</p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/19.png" style="zoom:80%;"></p>
<p>我们可以进一步地用2位来表示状态，多出来的一位可以用来表示前一个block是满的还是空的。这样，我们仅仅用一位就能节省额外地footer，分配了的block仅保留一个header。但是对于payload为空的块，我们还是保留footer。</p>
<p>那么上面所说的4种情况就要发生一些细小的改变了：</p>
<p><strong>1) 前面的块和后面的块都是已分配的</strong></p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/20.png" style="zoom:80%;"></p>
<p><strong>2) 前面的块是已分配的，后面的块是空闲的</strong></p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/21.png" style="zoom:80%;"></p>
<p><strong>3) 前面的块是空闲的，后面的块是已分配的</strong></p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/22.png" style="zoom:80%;"></p>
<p><strong>4) 前面的和后面的块都是空闲的</strong></p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/23.png" style="zoom:80%;"></p>
<h3 id="隐式空闲链表总结"><a href="#隐式空闲链表总结" class="headerlink" title="隐式空闲链表总结"></a>隐式空闲链表总结</h3><ul>
<li>Implementation 实现是比较简单的</li>
<li>Allocate cost：<ul>
<li>Linear time worst case 最差情况下分配时间是线性的</li>
</ul>
</li>
<li>Free cost：<ul>
<li>constant time worst case 最差情况下也是常数时间</li>
<li>even with coalescing   </li>
</ul>
</li>
<li>Memory overhead<ul>
<li>will depend on placement policy 时间复杂的决定于放置策略</li>
<li>First-fit ,next-fit ,best-fit 有三种放置策略</li>
</ul>
</li>
<li>Not used in practice for malloc/free because of linear time allocation <ul>
<li>used in many special purpose applications</li>
</ul>
</li>
<li>However ,the concepts of splitting and boundary tag coalescing are general to all allocators</li>
</ul>
<h3 id="显式空闲链表"><a href="#显式空闲链表" class="headerlink" title="显式空闲链表"></a>显式空闲链表</h3><p>显示链表是说我并不需要管理分配的空间，而是要管好那些空闲的空间. 因为块分配与堆块的总数呈线性关系，所以对于通用的分配器，隐式空闲链表是不适合的。</p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/24.png" style="zoom:80%;"></p>
<p>一种更好的方法是将空闲块组织为某种形式的显式数据结构。因为根据定义，程序不需要一个空闲块的主体，所以实现这个数据结构的指针可以存放在这些空闲块的主体里面。例如，堆可以组织成一个双向空闲链表，在每个空闲块中，都包含一个pred(前驱）和succ(后继指针)</p>
<p>使用双向链表而不是隐式空闲链表，使首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。不过，释放一个块的时间可以是线性的，也可能是个常数，这取决于我们所选择的空闲链表中块的排序策略。</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/11/26/OptimalBST/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/26/OptimalBST/" itemprop="url">OptimalBST</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-26T15:30:07+08:00">
                2020-11-26
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-11-26T22:20:58+08:00">
                2020-11-26
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DP/" itemprop="url" rel="index">
                    <span itemprop="name">DP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Optimal-BST"><a href="#Optimal-BST" class="headerlink" title="Optimal BST"></a>Optimal BST</h1><h2 id="什么是最优二叉搜索树？"><a href="#什么是最优二叉搜索树？" class="headerlink" title="什么是最优二叉搜索树？"></a>什么是最优二叉搜索树？</h2><p>假设我们在设计一个实现英语到法语的翻译，对英语文本中出现的每个单词查找对应的法语单词。</p>
<p>为了实现这个操作，我们可以创建一颗二叉搜索树，将n个英语单词作为关键词，对应的法语单词作为关联数据。</p>
<p>于对文本中的每个单词都要进行搜索， 我们希望花费在搜索上的总时间尽量少</p>
<p>我们知道平衡二叉搜索树或者红黑树的搜索时间是 $O(logn)$ 。但是，单词出现的频率是不同的。</p>
<p>像 “the” 这种频繁使用的单词有可能位于搜索树中远离根的位置上，搜索一次可能需要花费很多时间；而像 “machicolation” 这种很少使用的单词可能位于靠近根的位置上，搜索一次只要花很少的时间。</p>
<p>这样的结构会减慢翻译的速度， 因为在二叉树搜索树中<strong>搜索一个关键字需要访问的结点数</strong>等于<strong>包含关键字的结点的深度加1</strong> , 我们希望文本中频繁出现的单词被置于靠近根的位置。更甚者，文本中的一些单词可能没有对应的法语单词，这些单词根本不应该出现在二叉搜索树中中。</p>
<p>于是我们定义：<strong>在给定单词出现频率的前提下，我们应该如何组织一颗二叉搜索树，使得所有搜索操作访问的结点总数最少</strong>，就是一个最优二叉搜索树问题。</p>
<p>抽象总结一下这个问题：</p>
<p>给定一个n个不同关键字已排序的序列$K=<k_1,k_2,\cdots,k_n>$ 我们希望用这些关键字构造一棵二叉搜索树。对于每个关键字 $k<em>i$ ，都有一个概率 $p_i$ 表示其搜索频率。<br>有些要搜索的值可能不在k当中，因此我们还需要有n+1个”伪关键字” $d_0,d_1,\cdots d_n$ 表示<strong>不在K中的值</strong>：其中 $d_0$ 表示所有小于 $k_1$ 的值，$d_n$ 表示所有大于$k_n$ 的值，对 $i = 1,2,\cdots,n-1$ ，伪关键字 $d_i $ 表示所有在 $k_i$ 和 $k</em>{i+1}$ 之间的值。对每个伪关键字 $d_i$ ，也都有一个概率p表示对应的搜索频率。这些结点是整个二叉树的叶子结点</k_1,k_2,\cdots,k_n></p>
<p>下图是对一个 n=5 个关键字的集合构造的两颗二叉搜索树。 每次搜索要么成功(找到关键字$k_i$)，要么失败(找到某个伪关键字$d_i$) </p>
<p>因此 我们可以得到如下公式： $\sum<em>{i=1}^n p_i+\sum</em>{i=0}^n q_i = 1$ </p>
<p><img src="/2020/11/26/OptimalBST/1.png" style="zoom: 120%;"></p>
<p>对于 $p_i$ 和$q_i$ 的搜索概率如下：</p>
<p><img src="/2020/11/26/OptimalBST/2.png" style="zoom: 120%;"></p>
<p>由于我们知道每个关键字和伪关键字的搜索概率，因而可以确定一颗给定的二叉搜索树T中进行一次搜索的期望代价</p>
<p>假定一次搜索的代价等于访问的节点数，即此次搜索找到的结点在T中的深度再加1，那么计算公式如下：</p>
<p>$E[T中搜索代价] = \sum<em>{i=1}^n(depth_T(k_i)+1)*p_i+\sum</em>{i=0}^n(depth_T(d_i)+1)*q_i$ </p>
<p>从这个公式我们可以算出，上图(a)树的期望搜索代价为2.80，而(b)树的期望搜索代价为2.75</p>
<p>那么对于一个给定的概率集合，我们希望构造一棵期望搜索代价最小的二叉树，称之为最优二叉搜索树。对于上面这组概率来说，最优二叉搜索树是 (b)树。</p>
<p>因此可见最优二叉搜索树并不一定是最矮的(b比a高)，而且概率最高的关键字也并不一定出现在二叉搜索树的根节点(概率最高应该是k5而最优二叉搜索树的根节点是$k_2$)。 </p>
<p>关于这个问题，我们如果通过穷举法，肯定是不行的，因此我们采用动态规划的方法来求解：</p>
<h2 id="动态规划方法求解"><a href="#动态规划方法求解" class="headerlink" title="动态规划方法求解"></a>动态规划方法求解</h2><h3 id="最优二叉搜索树的最优解"><a href="#最优二叉搜索树的最优解" class="headerlink" title="最优二叉搜索树的最优解"></a>最优二叉搜索树的最优解</h3><p>给定关键字序列 $k<em>i,\cdots,k_j$,其中某个关键字，比如说 $k_r(i\leq r\leq j)$, 是这些关键字的最优子树的<strong>根节点</strong>。那么 $k_r$ 的左子树就包含关键字 $k_i,\cdots,k</em>{r-1}$和伪关键字($d<em>{i-1},\cdots,d</em>{r-1}$) ；同理右子树包含关键字 $k<em>{r+1},\cdots ,k_j$ 和伪关键字 ($d_r,\cdots,d_j$). 只要我们检查所有可能的根节点 $k_r(i\leq r\leq j)$,并对每种情况分别求包含 $k_i,\cdots,k</em>{r-1}$ 以及包含$k_{r+1},\cdots ,k_j$ 的最优二叉搜索树，即可保证找到原问题的最优解。</p>
<h3 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h3><p>我们定义 $e[i,j]$ 为在包含关键字 $k_i,\cdots,k_j$ 的最优二叉搜索树中进行一次搜索的期望代价。最终我们希望计算出 $e[1,n]$</p>
<p>当 $j\geq i$ 的时候，我们需要从 $k<em>i,\cdots,k_j$中选择一个根节点 $k_r$ ，然后构造一颗包含关键字 $k_i,\cdots,k</em>{r-1}$ 的最优二叉搜索树作为其左子树，以及一颗包含关键字 $k_{r+1},\cdots,k_j$ 的二叉搜索树作为其右子树。</p>
<p>由于当一颗子树成为一个结点的字数时，期望搜索代价的增加值应为所有的概率之和，因此对于包含关键字 $k<em>i,\cdots,k_j$ 的子树，所有概率之和为 $w(i,j) = \sum</em>{l=i}^jp<em>l+\sum</em>{l=i-1}^jq_l$ </p>
<p>因此，若 $k_r$ 为包含关键字 $k_i,\cdots,k_j$ 的最优二叉搜索树的根节点，我们有如下公式</p>
<p>$e[i,j] = p_r+(e[i,r-1]+w(i,r-1))+(e[r+1,j]+w(r+1,j))$ </p>
<p>又因为 $w(i,j) = w(i,r-1)+p_r+w(r+1,j)$</p>
<p>因此$e[i,j]$ 可以重写为 $e[i,j]=e[i,r-1]+e[r+1,j]+w(i,j)$ </p>
<p>我们可以选取期望搜索代价最低者作为根节点，可以得到最终的递归公式</p>
<p><img src="/2020/11/26/OptimalBST/3.png" style="zoom: 120%;"></p>
<p>$e[i,j]$ 的值给出了最优二叉搜索树的期望搜索代价。为了记录最优二叉搜索树的结构，对于包含关键字 $k_i,\cdots,k_j(i\leq i\leq j\leq n)$ 的最优二叉搜索树，我们定义 $root[i,j]$ 保存根结点 $k_r$ 的下标r。</p>
<h3 id="计算最优二叉搜索树的期望搜索代价"><a href="#计算最优二叉搜索树的期望搜索代价" class="headerlink" title="计算最优二叉搜索树的期望搜索代价"></a>计算最优二叉搜索树的期望搜索代价</h3><p>​                                                                </p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/" itemprop="url">卷积神经网路理论</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-24T21:37:52+08:00">
                2020-11-24
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2021-12-02T13:04:50+08:00">
                2021-12-02
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="卷积神经网路理论"><a href="#卷积神经网路理论" class="headerlink" title="卷积神经网路理论"></a>卷积神经网路理论</h1><h2 id="Convolutional-Neural-Networks"><a href="#Convolutional-Neural-Networks" class="headerlink" title="Convolutional Neural Networks"></a>Convolutional Neural Networks</h2><p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/1.png" style="zoom:120%;"></p>
<p>对于这张图片，我们会产生一种错觉：图片中的人是向右看的还是向前看的。我们发现如果我们观察这个人的右轮廓，就会觉得这个人是向右看的。如果我们直视这个人的眼睛和耳朵，那么就会觉得这个人是向前看的。因此我们可以推断出我们看见什么取决于大脑看见的特征.</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/1.jpg" style="zoom:60%;"></p>
<p>又比如说这一张图，我们如果看红色的轮廓，那我们会认为这是一个年轻的小孩正在侧脸注视前方。但是如果我们看蓝笔画出的轮廓，就会观察到一个老婆婆低下头打着盹。</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/3.png" style="zoom:100%;"></p>
<p>最后一张图片，让我们的大脑变得无所适从——我们会在两张脸的特征上跳来跳去，导致一开始这张图片会有些眼花缭乱的感觉。</p>
<p>这三个例子都在告诉我们我们的大脑是怎么运作的：大脑分析处理现实生活中看到的东西的特征然后经过处理得到我们认知的图像。这就导致了我们会出现很多错觉。</p>
<p>在卷积神经网络当中，机器处理分析图像的方式和我们的大脑非常类似。</p>
<p>现在我们来看一些例子：下面三张图片是神经网络预测的图片</p>
<p>前两幅图计算机都非常准确得预测了照片中的物体，但是对于第三张图片的预测却出现了偏差。这是因为第三张图片本身拍摄的就不是非常清晰，特征也不是很明显，下面几个选项的描述也有点模糊。因此机器预测这个图片中的物品是剪刀而不是放大镜  </p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/4.png" style="zoom:100%;"></p>
<p>这是CNN(卷积神经网络) 的简易模型：</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/5.png" style="zoom:100%;"></p>
<p>比如说：</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/6.png" style="zoom:100%;"></p>
<p>卷积神经网络并不会给出一个100%的概率，这就好像有时候我们会对别人的表情神态判断错误一样</p>
<p>对于一幅图片，我们知道它是由像素组成的。在电脑里，一张图片就表现为一个矩阵。比如说一张2x2像素的灰白图，在电脑里就是一个2x2的矩阵，每个元素的取值范围是 (0,255)</p>
<p>如果是一张彩色的照片，那么我们就需要3个2x2的矩阵来对其进行存储，因为色彩是由3个维度的数据RGB组成的。</p>
<h3 id="计算机怎么读取图片"><a href="#计算机怎么读取图片" class="headerlink" title="计算机怎么读取图片"></a>计算机怎么读取图片</h3><p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/7.png" style="zoom:100%;"></p>
<p>比如说一个笑脸的照片，我们可以用01矩阵来存储：0代表白，1代表黑</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/8.png" style="zoom:100%;"></p>
<h3 id="卷积网络的步骤"><a href="#卷积网络的步骤" class="headerlink" title="卷积网络的步骤"></a>卷积网络的步骤</h3><p>STEP1: Convolution 卷积</p>
<p>STEP2: Max Pooling 最大池化</p>
<p>STEP3: Flattening 平坦化</p>
<p>STEP4: Full Connection 全连接</p>
<h2 id="Convolution"><a href="#Convolution" class="headerlink" title="Convolution"></a>Convolution</h2><p>这是卷积的公式,但是这里我们并不会过多的解释数学层面的，因此其内部的原理可以参考这篇文章：</p>
<p><a href="http://cs.nju.edu.cn/wujx/paper/CNN.pdf" target="_blank" rel="noopener">http://cs.nju.edu.cn/wujx/paper/CNN.pdf</a></p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/10.png" style="zoom:100%;"></p>
<p>那么，卷积的直观含义是什么呢？</p>
<p>假设左边的矩阵是输入的图片，为了简化像素用01表示。中间的3x3矩阵叫做特征探测器，大多数卷积神经网络中用的都是3x3的矩阵，但是也有用5x5和7x7的。特征探测器和输入的图像矩阵做一个运算: 将特征探测器覆盖在图像矩阵的一片区域上，然后将这九个数相对应的一个值乘以一个值，计算过后特征探测器会向右移动，移动的距离叫做步长。最后计算九个数对应相乘的和</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/12.png" style="zoom:100%;"></p>
<p>计算过后的矩阵如下：我们可以叫它 特征图或者Convolved Feature, 显然这个输入的矩阵被压缩了一点。这里我们用的步长是1(当步长为2的时候，得到的Feature Map就会进一步变小，通常2的效果更好)。</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/11.png" style="zoom:100%;"></p>
<p>卷积过后，虽然矩阵中存储的数据变少了，但是特征探测器的目的是探测某些特征，也就是探测图像的某些完整部分。特征探测器具有某些特定的模式，而Feature map中数字最大的地方就是与探测器模式相匹配的地方。</p>
<p>这和我们大脑的工作模式相似，我们并不会一个一个像素看，而是看一些局部的特征。卷积也是这样，通过特征探测器在特征图中保留下有用的信息。</p>
<p>卷积过程中仅仅创建一张特征图是远远不够的。因为我们需要用到多个不同种类的特征探测器，所以需要创建多个特征图来保留图像中的信息。 然后，通过神经网络的训练，来决定哪个特征对于某个分类特别重要。</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/13.png" style="zoom:100%;"></p>
<p>特征探测在滤镜/美化图片当中有广泛的应用，比如说对于这张泰姬陵的照片</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/14.png" style="zoom:100%;"></p>
<h4 id="锐化"><a href="#锐化" class="headerlink" title="锐化"></a>锐化</h4><p>如果特征探测器是这样的，那么会对图像产生锐化的效果，照片会更加清晰：</p>
<p>因为这个探测器中间的数值是5，周围是-1，这个目的就是突触主体元素，而减少边缘周围的像素。</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/15.png" style="zoom:100%;"></p>
<h4 id="模糊"><a href="#模糊" class="headerlink" title="模糊"></a>模糊</h4><p>同样，模糊操作是一个 全部都是1的 探测器，这就说明了中间的像素和周围像素有着同等的重要性。他们合在一起就像是图片变模糊了一样</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/16.png" style="zoom:100%;"></p>
<h4 id="边界增强滤镜"><a href="#边界增强滤镜" class="headerlink" title="边界增强滤镜:"></a>边界增强滤镜:</h4><p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/17.png" style="zoom:100%;"></p>
<p>这个探测器只有-1和1，也就是说我们去掉了围绕中间主要元素周围的像素，只在左边保留一个-1。但是这个探测器的原理比较难以理解</p>
<h4 id="边界探测滤镜："><a href="#边界探测滤镜：" class="headerlink" title="边界探测滤镜："></a>边界探测滤镜：</h4><p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/18.png" style="zoom:100%;"></p>
<p>中间是4而上下左右是1，因此这个探测器削弱了中间主要元素的重要性，而提升了周围元素的重要性。这就期限了探测边框的效果</p>
<h4 id="Emboss浮雕滤镜"><a href="#Emboss浮雕滤镜" class="headerlink" title="Emboss浮雕滤镜"></a>Emboss浮雕滤镜</h4><p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/19.png" style="zoom:100%;"></p>
<p>这个探测器，我们发现它是左右不对成的，因此体现在图片上也感觉到这个图片朝左凸出</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/20.png" style="zoom:100%;"></p>
<h3 id="ReLU-Layer-线性整流函数"><a href="#ReLU-Layer-线性整流函数" class="headerlink" title="ReLU Layer 线性整流函数"></a>ReLU Layer 线性整流函数</h3><p>现在我们来介绍 ReLU，这是在卷积的基础上再添加的一个步骤</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/21.png" style="zoom:100%;"></p>
<p>数据通过ReLU后，过滤掉负值，只会保留非负值，比如下面这幅图的效果：</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/25.png" style="zoom:100%;"></p>
<p>使用 ReLU的原因是它类似于一个过滤器，能打破神经网络的线性，并提高图像里或者神经网络模型中的 非线性。那么为什么要提高非线性呢？因为图像通常是高度非线性的，当我们在识别相邻不同物体时，有不同的边界、不同的颜色，因此图像可能具有很多非线性的元素。但是当我们进行卷积操作去建立我们的特征图的时候，有可能会引进一些线性的东西。</p>
<p>下面是一个例子：</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/22.png" style="zoom:100%;"></p>
<p>这张建筑物的图片，通过探测器处理之后变成了这样一张图片：</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/23.png" style="zoom:100%;"></p>
<p>其中，黑色是负值而白色是正值。我们看到这幅图片中，白色到黑色之间是类似于线性变化的。但是我们再通过ReLU处理一下，就会得到这样一幅图片：</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/24.png" style="zoom:100%;"></p>
<p>我们发现这样子的话这张图片就只有非负值了，白色和灰色之间没有一个渐变的阶段。</p>
<p>虽然我们现在还不能解释这样处理的好处，但是起码能给我们一个主观上的感受。</p>
<p>运用ReLU而不是Sigmoid函数，因为ReLU能有效解决梯度爆炸的问题，计算速度非常快（之所以计算快，因为relu函数公式的原因）<br>而之前的sigmoid函数的缺点：计算量相对大（公式$1/(1+e^{-z})$复杂），sigmoid函数反向传播时，很容易就会出现梯度爆炸现象</p>
<p>拓展阅读资料：</p>
<p> <a href="https://arxiv.org/pdf/1609.04112.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1609.04112.pdf</a></p>
<p><a href="https://arxiv.org/pdf/1502.01852.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1502.01852.pdf</a></p>
<h2 id="Max-Pooling-最大池化"><a href="#Max-Pooling-最大池化" class="headerlink" title="Max Pooling  最大池化"></a>Max Pooling  最大池化</h2><p> 现在我们有好几张不同角度拍摄的猎豹的照片，我们怎么能让电脑在这几张不同的照片中识别出猎豹呢？</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/26.png" style="zoom:100%;"></p>
<p>我们知道猎豹眼睛下方的“黑色泪痕”是一个辨别猎豹最明显的标志。但是如果电脑说必须在特定的位置，有特定的形状纹理才能识别到这个特征，那恐怕连一张照片都识别不了。所以我们必须确定我们的神经网络拥有一个空间不变性(spatial invariance’)的特性，这代表着电脑不用关心这个特征位于哪里，在图像的哪个位置。因为我们在制作特征图和制作卷积层的时候已经将这种情况考虑进去了。电脑也不需要关心采集到的特征是否有一些倾斜是否在纹理上有不同。所以我们的神经网络必须要有一些弹性，能够找到这种特征，这就是池化的作用</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/27.png" style="zoom:100%;"></p>
<p>这就是最大池化的操作了。我们用一个 2x2的矩阵框在特征图上移动，然后每次选取矩阵框中最大的数字放在Pooled Feature Map当中，我们采用的步长是2.当然也可以选择1，只不过这样方框的位置和原来的位置就出现了重叠。这里超过了矩阵的边框也不要紧，只要记录下每个框中最大的数值即可。</p>
<p>经过最大池化，我们还是能够保留特征——那些最大值就是非常明显的特征，同时我们删除了75%不是明显特征的信息，减少了数据规模，防止出现信息过度拟合。更重要的是，我们保留了明显的特征，因此我们的算法可以允许一些图片的失真或者扭曲。</p>
<p>比如说对猎豹的泪痕花纹，假设这个花纹在特征探测是获得的数字是4. 那么，如果图像扭曲了，4出现了移位，只要和之前在同一个矩阵框之下，在池化后都能被记录下来。</p>
<p>问题： 池化有很多种，还有最小池化、平均池化 ，对于不同的池化方法，我们可以读者一篇论文</p>
<p><a href="http://ais.uni-bonn.de/papers/icann2010_maxpool.pdf" target="_blank" rel="noopener">http://ais.uni-bonn.de/papers/icann2010_maxpool.pdf</a></p>
<p>经过最大池化，现在的模型如下：</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/28.png" style="zoom:100%;"></p>
<p>我们可以在这个网站上 <a href="http://scs.ryerson.ca/~aharley/vis/conv/flat.html" target="_blank" rel="noopener">http://scs.ryerson.ca/~aharley/vis/conv/flat.html</a> 感受到池化带给我们的直观感受</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/29.png" style="zoom:100%;"></p>
<p>当我在左边输入8的时候，整个输入、卷积、池化、全连接的过程就在右边可视化了出来</p>
<p>最底下一层是我们的输入层</p>
<p>倒数第二层是第一次的卷积操作</p>
<p>倒数第三层是第一次的池化操作，我们发现经过了池化操作，图画变小了但是基本的特征还是保留了下来。</p>
<p>接着两层是第二次的卷积和池化，最上面是两次的全连接层，最后输出预测结果。</p>
<p>我们将8稍稍向右倾斜，发现得到的池化结果还是相似的。这就说明池化能让神经网络的弹性更大。</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/30.png" style="zoom:100%;"></p>
<p>但是当我们画一个笑脸，我们会发现这个神经网络是识别不出这是一个笑脸的。因为显然它只被0-9训练过，对其他的输入是一无所知的。这就好比我们看到了一件我们从来没看到过的东西，我们会说：这个东西比较像XXX(一个我们认识的东西)</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/31.png" style="zoom:100%;"></p>
<h2 id="Flattening"><a href="#Flattening" class="headerlink" title="Flattening"></a>Flattening</h2><p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/32.png" style="zoom:100%;"></p>
<p>Flattening 操作非常简单，对于池化后的矩阵，我们只需要将其压平成一列即可。</p>
<p>那么，生成多个特征图放进卷积层，再通过ReLU函数来生成池化层，最后压平放入一个长向量里，这个长向量就是神经网络的一个输入层。</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/33.png" style="zoom:100%;"></p>
<h2 id="Full-Connection"><a href="#Full-Connection" class="headerlink" title="Full Connection"></a>Full Connection</h2><p>这一步我们将把整个ANN加到CNN一系列操作之后，如图所示：</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/34.png" style="zoom:100%;"></p>
<p>我们看到之前ANN中的隐藏层现在变成了一个全连接层。全连接层是一种特别的隐藏层，因为它和输入层还有输出层是全连接的。而一般的隐藏层并不这么干。</p>
<p>这里神经网络的主要目的是：它能把我们得到的特征加入更多的属性，以得到更好的预测结果。我们之前已经有了平坦化之后的输出向量，在那个向量里已经蕴含了一些特征，比如对照片进行一个分类操作，但与此同时我们知道ANN能够对特征进行一个推理和分析并发现新的属性，那我们为何不利用ANN这种功能来优化这些特征呢？</p>
<p>下面是一个更加复杂的例子，通过对这个例子的分析，我们会对CNN有更加深刻的理解：</p>
<p>在这个模型当中我们有两层全连接层，并且有两个输出神经元(狗和猫)。我们知道在ANN当中只有一个输出神经元，那在CNN中为什么要有两个神经元呢？事实上，如果分成两类的话，我们可以用一个二元的输出神经元：0代表狗，1代表猫。但是如果要分类的东西较多，比如说还有鸟，大象之类的动物，那就必须给每一个动物都分配一个输出神经元。这是CNN 的特性。</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/35.png" style="zoom:100%;"></p>
<p>图像经过卷积池化平坦化后的数据被输入到ANN当中，然后通过一个损失函数(交叉熵函数)计算误差，这个误差是用来衡量神经网络的性能的。计算出误差以后我们将误差往回传播并调整一些参数：比如说这些神经网络中的权重和卷积过程中的特征探测器。因为很可能一开始的特征探测器是错误的，因此调整特征探测器能提高预测的准确性。经过调整后，再将信息传递到ANN当中，并计算误差，返回调整。以此进行多轮学习，最终我们的神经网络会得到优化。</p>
<p>这个过程和ANN是一样的，只是需要的时间更长一点，因为多了之前的三个步骤(卷积池化压平)</p>
<p>那么这两个输出神经元是如何工作的呢？</p>
<p>我们先从狗开始，我们首先要做的就是找到哪些权重杯赋予与“狗”神经元相连接的突触。这样我们就可以知道那个神经元对”狗”重要。为了方便，我们把值设置为0-1之间，如果这个神经元是0.9、1，那么就说明这个神经元被激活了，它认为它找到了某个特征；0就代表这个神经元没有找到特征。这些神经元的值将会传给Dog和Cat这两个输出神经元，然后由Dog和Cat神经元负责去判断这个特征是否符合它的要求。</p>
<p>比如说这里，第一、二、六个神经元被激活了，它们分别代表狗的耳朵，鼻子和舌头。那么在训练的时候狗神经元就知道这些特征是属于狗的，经过多次迭代，狗神经元在预测的时候就会认为如果这些神经元都激活了，那么这张图片就应该属于狗，因此狗神经元就会被激活。而猫神经元就会认为这些隐藏层的神经元被激活时，图像中的动物并不是猫，久而久之，猫神经元就会忽略这些神经元的信号。</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/36.png" style="zoom:100%;"></p>
<p>同理，对猫来说也有“属于”它的神经元，而狗神经元就会选择忽视那些属于猫特征的神经元。</p>
<p>经过成千上百次的训练，CNN就会自己判断这张图片是属于猫还是属于狗了，如下图所示</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/37.png" style="zoom:100%;"></p>
<p>这时候我输入一张狗的照片，要CNN帮我们预测分类。他们会通过倾听全连接层传递的信息而进行判断并给出可能是狗的概率和可能是猫的概率。概率是由全连接层的神经元根据他们的值 “投票”产生的 ，这就是全连接网络的工作原理。</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/38.png" style="zoom:100%;"></p>
<p>整一个CNN的过程可以用下图总结</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/39.png" style="zoom:100%;"></p>
<p>学习博客：</p>
<p><a href="https://adeshpande3.github.io/adeshpande3.github.io/The-9-Deep-Learning-Papers-You-Need-To-Know-About.html" target="_blank" rel="noopener">https://adeshpande3.github.io/adeshpande3.github.io/The-9-Deep-Learning-Papers-You-Need-To-Know-About.html</a></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/15/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/17/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/%5Bobject%20Object%5D"
                alt="Jason" />
            
              <p class="site-author-name" itemprop="name">Jason</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20fa%20fa-archive">
              
                  <span class="site-state-item-count">435</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">61</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="true"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
 <!--
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>







-->
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>




















  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v="></script>

  <script type="text/javascript" src="/js/src/motion.js?v="></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v="></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
