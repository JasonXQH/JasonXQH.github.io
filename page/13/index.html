<!DOCTYPE html>
<html lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jasonxqh.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jason‘s Blog">
<meta property="og:url" content="https://jasonxqh.github.io/page/13/index.html">
<meta property="og:site_name" content="Jason‘s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jasonxqh.github.io/page/13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jason‘s Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jason‘s Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A-week11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A-week11/" class="post-title-link" itemprop="url">计算机网络报告-week11</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-13 23:44:57" itemprop="dateCreated datePublished" datetime="2021-05-13T23:44:57+08:00">2021-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-23 22:25:20" itemprop="dateModified" datetime="2022-08-23T22:25:20+08:00">2022-08-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机网络报告-week11"><a href="#计算机网络报告-week11" class="headerlink" title="计算机网络报告-week11"></a>计算机网络报告-week11</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ul>
<li>深入掌握RPC编程</li>
<li>深入理解运输层协议</li>
</ul>
<h2 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h2><ul>
<li>利用gRPC实现跨语言调用</li>
<li>完成课本195页编程作业：实现一个可靠传输协议</li>
</ul>
<h2 id="任务1：利用gRPC实现跨语言调用"><a href="#任务1：利用gRPC实现跨语言调用" class="headerlink" title="任务1：利用gRPC实现跨语言调用"></a>任务1：利用gRPC实现跨语言调用</h2><p>利用gRPC框架，采用两种不同语言（比如C++和Java或Go和Java）实现客户端和服务端。</p>
<p>服务端提供getStuNo（）函数，该函数以自己的姓名为参数，返回自己的学号。客户端以自己的姓名为参数远程调用该函数，返回拿到自己的学号。</p>
<p><strong>将实现思路和关键代码以及实验截图写到实验报告中。</strong></p>
<p>这里，我使用Java和Python 两种语言来实现 grpc 的客户端与服务端。既可以是 Java client + Python server也可以是Java server + Python client</p>
<h3 id="Java客户端-python服务端"><a href="#Java客户端-python服务端" class="headerlink" title="Java客户端+python服务端:"></a>Java客户端+python服务端:</h3><h4 id="Java客户端"><a href="#Java客户端" class="headerlink" title="Java客户端"></a>Java客户端</h4><p>这次Java实现grpc，我是在week10的task2的基础上修改得来的,因此环境的搭建这里按下不表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.grpc.ManagedChannel;</span><br><span class="line"><span class="keyword">import</span> io.grpc.ManagedChannelBuilder;</span><br><span class="line"><span class="keyword">import</span> io.grpc.StatusRuntimeException;</span><br><span class="line"><span class="keyword">import</span> io.grpc.examples.helloworld.GreeterGrpc;</span><br><span class="line"><span class="keyword">import</span> io.grpc.examples.helloworld.HelloReply;</span><br><span class="line"><span class="keyword">import</span> io.grpc.examples.helloworld.HelloRequest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先创建一个final类型的不能被改变的参数用来获取类名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(HelloWorldClient<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">	<span class="comment">// 这边也同时定义两个</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ManagedChannel channel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> GreeterGrpc.GreeterBlockingStub blockingStub;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Construct client connecting to HelloWorld server at &#123;<span class="doctag">@code</span> host:port&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//接下来是定义一个方法，用来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorldClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        channel = ManagedChannelBuilder.forAddress(host, port)</span><br><span class="line">                .usePlaintext(<span class="keyword">true</span>)</span><br><span class="line">                .build();</span><br><span class="line">        blockingStub = GreeterGrpc.newBlockingStub(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        channel.shutdown().awaitTermination(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     greet函数是建立连接之后客户端的一些操作，比如说先模拟一个logger在尝试访问服务端。</span></span><br><span class="line"><span class="comment">     然后向服务端发送请求，调用sayHello()</span></span><br><span class="line"><span class="comment">     最后打印返回信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Will try to greet "</span> + name + <span class="string">" ..."</span>);</span><br><span class="line">        HelloRequest request = HelloRequest.newBuilder().setName(name).build();</span><br><span class="line">        HelloReply response;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response = blockingStub.sayHello(request);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (StatusRuntimeException e) &#123;</span><br><span class="line">            logger.log(Level.WARNING, <span class="string">"RPC failed: &#123;0&#125;"</span>, e.getStatus());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">"Greeting: "</span> + response.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    启动client的main函数，首先建立一个和端口50051的连接，然后开启greet()函数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HelloWorldClient client = <span class="keyword">new</span> HelloWorldClient(<span class="string">"localhost"</span>, <span class="number">50051</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            String user = <span class="string">"徐啟航"</span>;</span><br><span class="line">            <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                user = args[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            client.greet(user);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            client.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="python服务端："><a href="#python服务端：" class="headerlink" title="python服务端："></a>python服务端：</h4><p>在讲解python服务端之前，我们首先来搭建python的grpc环境：</p>
<p>首先我们要下载几个包：</p>
<p>安装grpc：<code>pip install grcpio</code></p>
<p>安装编译工具：<code>pip install grpcio-tools</code></p>
<p>然后在项目中新建helloworld 文件夹用于存放proto文件：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"><span class="keyword">package</span> helloworld;</span><br><span class="line"><span class="comment">// The greeting service definition.</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Sends a greeting</span></span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloReply) &#123;&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function">// The request message containing the user's name.</span></span><br><span class="line"><span class="function">message HelloRequest &#123;</span></span><br><span class="line"><span class="function">    string name = 1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// The response message containing the greetings</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloReply</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> <span class="class"><span class="keyword">message</span> = 1;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>
<p>注意，这里写的package helloworld要和java中的proto文件一致。</p>
<p>接下来我们要在helloworld文件夹中编译proto文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m grpc_tools.protoc -I. --python_out&#x3D;. --grpc_python_out&#x3D;. .&#x2F;helloworld.proto</span><br></pre></td></tr></table></figure>
<p>编译完成后，helloworld文件夹下会出现<code>helloworld_pb2.py</code>以及<code>helloworld_pb2_grpc.py</code>两个文件.我们要修改一下<code>helloworld_pb2_grpc.py</code>中的依赖，否则在运行时会出错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"><span class="comment">#原来是 import helloworld_pb2 as helloworld__pb2</span></span><br><span class="line"><span class="keyword">from</span> helloworld <span class="keyword">import</span> helloworld_pb2 <span class="keyword">as</span> helloworld__pb2</span><br></pre></td></tr></table></figure>
<p>接下来开始写服务端的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"><span class="keyword">from</span> helloworld <span class="keyword">import</span> helloworld_pb2, helloworld_pb2_grpc</span><br><span class="line"></span><br><span class="line">_ONE_DAY_IN_SECONDS = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#首先定义处理请求的函数，打印请求者信息之后，返回他想要的信息</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span><span class="params">(helloworld_pb2_grpc.GreeterServicer)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">SayHello</span><span class="params">(self, request, context)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 发来请求~"</span> % request.name)</span><br><span class="line">        <span class="keyword">return</span> helloworld_pb2.HelloReply(message=<span class="string">'Your ID is 10195501423, %s!'</span> % request.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是启动服务器的代码，规定了在那个端口开启服务以及错误处理等，这里使用了一个线程池来处理并发任务</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">serve</span><span class="params">()</span>:</span></span><br><span class="line">    server = grpc.server(futures.ThreadPoolExecutor(max_workers=<span class="number">10</span>))</span><br><span class="line">    helloworld_pb2_grpc.add_GreeterServicer_to_server(Greeter(), server)</span><br><span class="line">    server.add_insecure_port(<span class="string">'[::]:50051'</span>)</span><br><span class="line">    server.start()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            time.sleep(_ONE_DAY_IN_SECONDS)</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        server.stop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    serve()</span><br></pre></td></tr></table></figure>
<p>运行结果如下图所示：</p>
<p><img src="/2021/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A-week11/4.png"></p>
<h3 id="Java-服务端和-python客户端"><a href="#Java-服务端和-python客户端" class="headerlink" title="Java 服务端和 python客户端"></a>Java 服务端和 python客户端</h3><h4 id="python客户端"><a href="#python客户端" class="headerlink" title="python客户端"></a>python客户端</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"><span class="keyword">from</span> helloworld <span class="keyword">import</span> helloworld_pb2, helloworld_pb2_grpc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line"><span class="comment"># 客户端向50051端口发送请求，并打印返回结果</span></span><br><span class="line">    <span class="keyword">with</span> grpc.insecure_channel(<span class="string">'localhost:50051'</span>) <span class="keyword">as</span> channel:</span><br><span class="line">        stub = helloworld_pb2_grpc.GreeterStub(channel)</span><br><span class="line">        response = stub.SayHello(helloworld_pb2.HelloRequest(name=<span class="string">'徐啟航'</span>))</span><br><span class="line">    print(<span class="string">"Greeter client received: "</span> + response.message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure>
<h4 id="Java服务端"><a href="#Java服务端" class="headerlink" title="Java服务端"></a>Java服务端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.grpc.Server;</span><br><span class="line"><span class="keyword">import</span> io.grpc.ServerBuilder;</span><br><span class="line"><span class="keyword">import</span> io.grpc.examples.helloworld.GreeterGrpc;</span><br><span class="line"><span class="keyword">import</span> io.grpc.examples.helloworld.HelloReply;</span><br><span class="line"><span class="keyword">import</span> io.grpc.examples.helloworld.HelloRequest;</span><br><span class="line"><span class="keyword">import</span> io.grpc.stub.StreamObserver;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Server that manages startup/shutdown of a &#123;<span class="doctag">@code</span> Greeter&#125; server.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(HelloWorldServer<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The port on which the server should run */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port = <span class="number">50051</span>;</span><br><span class="line">    <span class="keyword">private</span> Server server;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        server = ServerBuilder.forPort(port)</span><br><span class="line">                .addService( <span class="keyword">new</span> GreeterImpl())</span><br><span class="line">                .build()</span><br><span class="line">                .start();</span><br><span class="line">        logger.info(<span class="string">"Server started, listening on "</span> + port);</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// Use stderr here since the logger may have been reset by its JVM shutdown hook.</span></span><br><span class="line">                System.err.println(<span class="string">"*** shutting down gRPC server since JVM is shutting down"</span>);</span><br><span class="line">                HelloWorldServer.<span class="keyword">this</span>.stop();</span><br><span class="line">                System.err.println(<span class="string">"*** server shut down"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</span><br><span class="line">            server.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *这个函数是用来阻止java server自动终止的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">blockUntilShutdown</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</span><br><span class="line">            server.awaitTermination();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//启动sever的main函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HelloWorldServer server = <span class="keyword">new</span> HelloWorldServer();</span><br><span class="line">        server.start();</span><br><span class="line">        server.blockUntilShutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">GreeterImpl</span> <span class="keyword">extends</span> <span class="title">GreeterGrpc</span>.<span class="title">GreeterImplBase</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 原子Integer */</span></span><br><span class="line">        <span class="comment">//    public AtomicInteger count = new AtomicInteger(0);</span></span><br><span class="line">		<span class="comment">// 处理请求的函数，返回学号</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(HelloRequest req, StreamObserver&lt;HelloReply&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">            HelloReply reply = HelloReply.newBuilder().setMessage(<span class="string">"Hello "</span> + req.getName()+<span class="string">"Your ID is 10195501423"</span>).build();</span><br><span class="line">            responseObserver.onNext(reply);</span><br><span class="line">            responseObserver.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下图所示，虽然python客户端收到了来自java服务端的反馈信息，但是服务端却报错退出了。还没有找到原因。</p>
<p><img src="/2021/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A-week11/5.png"></p>
<h2 id="任务2：实现一个可靠传输协议"><a href="#任务2：实现一个可靠传输协议" class="headerlink" title="任务2：实现一个可靠传输协议"></a>任务2：实现一个可靠传输协议</h2><p>在这个编程作业实验中，你将要编写发送和接收运输层的代码，以实现一个简单的可靠数据运输协议。这个实验有两个版本，即比特交替协议版本和GBN版本。</p>
<p><strong>任务：基于比特交替协议以及GBN实现模拟实现客户端和服务端的可靠的数据传输协议。</strong></p>
<h3 id="实现要求"><a href="#实现要求" class="headerlink" title="实现要求"></a>实现要求</h3><p><img src="/2021/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A-week11/1.png"></p>
<ul>
<li>应用层消息（message）数据结构：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> &#123;</span></span><br><span class="line">		<span class="keyword">char</span> data[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>传输层消息（packet）数据结构：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pkt</span> &#123;</span></span><br><span class="line">          <span class="keyword">int</span> seqnum;</span><br><span class="line">          <span class="keyword">int</span> acknum;</span><br><span class="line">          <span class="keyword">int</span> checksum;</span><br><span class="line">          <span class="keyword">char</span> payload[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Hint：</strong>传输层消息中的payload字段即为应用层消息中的data字段，传输层消息中的其他字段为辅助字段（用于实现可靠传输，其中checksum部分自己选取合适的算法实现）。</p>
<p>1）. 需要实现的部分关键方法：</p>
<p>A_output(message)：A处理应用层发送的message，参数是要发送给B的数据。你要实现的协议就是要保证message的可靠传输；</p>
<p>A_input(packet)：A处理B发送过来的传输层packet；</p>
<p>A_timeinterrupt()：A的定时器，用于超时重传；</p>
<p>A_init()：用于A的一些初始化工作；</p>
<p>B_input(packet)：B处理A发送过来的传输层packet；</p>
<p>B_init()：用于B的一些初始化工作。</p>
<p><strong>2）. 部分需要实现的软件接口：</strong></p>
<p>starttimer(calling_entity,increment)：开始计时，calling_entity代表调用实体，这里为A或B；</p>
<p>stoptimer(calling_entity)：停止calling_entity计时；</p>
<p>tolayer3(calling_entity,packet)：calling_entity将消息转发到传输层；</p>
<p>tolayer5(calling_entity,message)：calling_entity将消息转发到应用层。</p>
<p><strong>3) 模拟的网络环境</strong></p>
<ul>
<li>消息有序接收：有多条message乱序发送，接收端需要保证按序接收；</li>
<li>消息丢失：设置消息丢失率，即消息有一定的概率会被丢失，但要保证接收端能够完整接收；</li>
<li>应用层平均延时：记录应用层从发出message请求到接收响应的平均延时。</li>
</ul>
<h3 id="基于Alternating-Bit-Protocol（ABP，rdt3-0）实现"><a href="#基于Alternating-Bit-Protocol（ABP，rdt3-0）实现" class="headerlink" title="基于Alternating-Bit-Protocol（ABP，rdt3.0）实现"></a>基于Alternating-Bit-Protocol（ABP，rdt3.0）实现</h3><p>ABP协议具体内容可参照课本P140-P142</p>
<p><img src="/2021/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A-week11/2.png"></p>
<p>图 2 ABP协议流程</p>
<h2 id="基于Go-Back-N实现"><a href="#基于Go-Back-N实现" class="headerlink" title="基于Go-Back-N实现"></a>基于Go-Back-N实现</h2><p><img src="/2021/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A-week11/3.png"></p>
<p>图 3 窗口长度为4个分组的GBN协议运行流程</p>
<p> 要求:窗口大小固定为8，如果A从应用层接受的包在窗口外面，直接简单的舍弃；不用太过考虑缓冲区溢出的问题</p>
<p>Hint：先实现ABP协议，在ABP协议的基础上实现GBN协议。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/05/11/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E5%BA%A6%E9%87%8F%E4%B8%8E%E6%8A%95%E5%BD%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/11/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E5%BA%A6%E9%87%8F%E4%B8%8E%E6%8A%95%E5%BD%B1/" class="post-title-link" itemprop="url">数学基础-度量与投影</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-05-11 15:35:08 / Modified: 15:37:12" itemprop="dateCreated datePublished" datetime="2021-05-11T15:35:08+08:00">2021-05-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="内积与范数"><a href="#内积与范数" class="headerlink" title="内积与范数"></a>内积与范数</h1><h2 id="正交与投影"><a href="#正交与投影" class="headerlink" title="正交与投影"></a>正交与投影</h2><h2 id="正交基与Gram-Schmidt-正交化"><a href="#正交基与Gram-Schmidt-正交化" class="headerlink" title="正交基与Gram-Schmidt 正交化"></a>正交基与Gram-Schmidt 正交化</h2><h2 id="具有特殊结构和性质的矩阵"><a href="#具有特殊结构和性质的矩阵" class="headerlink" title="具有特殊结构和性质的矩阵"></a>具有特殊结构和性质的矩阵</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek10/" class="post-title-link" itemprop="url">计算机网络报告week10</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-07 15:18:06" itemprop="dateCreated datePublished" datetime="2021-05-07T15:18:06+08:00">2021-05-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-25 04:32:34" itemprop="dateModified" datetime="2022-08-25T04:32:34+08:00">2022-08-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="RPC-协议"><a href="#RPC-协议" class="headerlink" title="RPC 协议"></a>RPC 协议</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ul>
<li>掌握RPC的工作原理</li>
<li>会写RPC程序 </li>
</ul>
<h2 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h2><ul>
<li><p>学习并理解RPC的工作原理</p>
</li>
<li><p>熟悉并掌握gRPC框架使用</p>
</li>
</ul>
<h2 id="协议简介"><a href="#协议简介" class="headerlink" title="协议简介"></a>协议简介</h2><h3 id="RPC协议"><a href="#RPC协议" class="headerlink" title="RPC协议"></a>RPC协议</h3><p>RPC（Remote Procedure Call Protocol）远程过程调用协议，一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。通俗的描述是：客户端在不知道调用细节的情况下，调用存在于远程计算机上的某个对象，就像调用本地应用程序中的对象一样。</p>
<h3 id="RPC协议要点"><a href="#RPC协议要点" class="headerlink" title="RPC协议要点"></a>RPC协议要点</h3><p>RPC是协议：既然是协议就只是一套规范，那么就需要有人遵循这套规范来进行实现。目前典型的RPC实现包括：Dubbo、Thrift、GRPC、Hetty等。这里要说明一下，目前技术的发展趋势来看，实现了RPC协议的应用工具往往都会附加其他重要功能，例如Dubbo还包括了服务治等功能。</p>
<p>网络协议和网络IO模型对其透明：既然RPC的客户端认为自己是在调用本地对象。那么传输层使用的是TCP/UDP还是HTTP协议，又或者是一些其他的网络协议它就不需要关心了。既然网络协议对其透明，那么调用过程中，使用的是哪一种网络IO模型调用者也不需要关心。</p>
<p>信息格式对其透明：我们知道在本地应用程序中，对于某个对象的调用需要传递一些参数，并且会返回一个调用结果。至于被调用的对象内部是如何使用这些参数，并计算出处理结果的，调用方是不需要关心的。那么对于远程调用来说，这些参数会以某种信息格式传递给网络上的另外一台计算机，这个信息格式是怎样构成的，调用方是不需要关心的。</p>
<p>应该有跨语言能力：调用方实际上不清楚远程服务器的应用程序是使用什么语言运行的。那么对于调用方来说，无论服务器方使用的是什么语言，本次调用都应该成功，并且返回值也应该按照调用方程序语言所能理解的形式进行描述。</p>
<h4 id="Client："><a href="#Client：" class="headerlink" title="Client："></a>Client：</h4><p>RPC协议的调用方。就像上文所描述的那样，最理想的情况是RPC Client在完全不知道有RPC框架存在的情况下发起对远程服务的调用。但实际情况来说Client或多或少的都需要指定RPC框架的一些细节。</p>
<h4 id="Server："><a href="#Server：" class="headerlink" title="Server："></a>Server：</h4><p>在RPC规范中，这个Server并不是提供RPC服务器IP、端口监听的模块。而是远程服务方法的具体实现（在JAVA中就是RPC服务接口的具体实现）。其中的代码是最普通的和业务相关的代码，甚至其接口实现类本身都不知道将被某一个RPC远程客户端调用。</p>
<h4 id="Stub-Proxy："><a href="#Stub-Proxy：" class="headerlink" title="Stub/Proxy："></a>Stub/Proxy：</h4><p>RPC代理存在于客户端，因为要实现客户端对RPC框架“透明”调用，那么客户端不可能自行去管理消息格式、不可能自己去管理网络传输协议，也不可能自己去判断调用过程是否有异常。这一切工作在客户端都是交给RPC框架中的“代理”层来处理的。</p>
<h4 id="Message-Protocol："><a href="#Message-Protocol：" class="headerlink" title="Message Protocol："></a>Message Protocol：</h4><p>在上文我们已经说到，一次完整的client-server的交互肯定是携带某种两端都能识别的，共同约定的消息格式。RPC的消息管理层专门对网络传输所承载的消息信息进行编码和解码操作。目前流行的技术趋势是不同的RPC实现，为了加强自身框架的效率都有一套（或者几套）私有的消息格式。</p>
<h4 id="Transfer-Network-Protocol："><a href="#Transfer-Network-Protocol：" class="headerlink" title="Transfer/Network Protocol："></a>Transfer/Network Protocol：</h4><p>传输协议层负责管理RPC框架所使用的网络协议、网络IO模型。例如Hessian的传输协议基于HTTP（应用层协议）；而Thrift的传输协议基于TCP（传输层协议）。传输层还需要统一RPC客户端和RPC服务端所使用的IO模型；</p>
<h4 id="Selector-Processor："><a href="#Selector-Processor：" class="headerlink" title="Selector/Processor："></a>Selector/Processor：</h4><p>存在于RPC服务端，用于服务器端某一个RPC接口的实现的特性（它并不知道自己是一个将要被RPC提供给第三方系统调用的服务）。所以在RPC框架中应该有一种“负责执行RPC接口实现”的角色。包括：管理RPC接口的注册、判断客户端的请求权限、控制接口实现类的执行在内的各种工作。</p>
<h4 id="IDL："><a href="#IDL：" class="headerlink" title="IDL："></a>IDL：</h4><p>实际上IDL（接口定义语言）并不是RPC实现中所必须的。但是需要跨语言的RPC框架一定会有IDL部分的存在。这是因为要找到一个各种语言能够理解的消息结构、接口定义的描述形式。如果您的RPC实现没有考虑跨语言性，那么IDL部分就不需要包括，例如JAVA RMI因为就是为了在JAVA语言间进行使用，所以JAVA RMI就没有相应的IDL。</p>
<h2 id="Task1：运行项目"><a href="#Task1：运行项目" class="headerlink" title="Task1：运行项目"></a>Task1：运行项目</h2><p>结合代码分析rpc流程和其中涉及的关键组件。</p>
<h4 id="新知识-annotation"><a href="#新知识-annotation" class="headerlink" title="新知识 annotation"></a>新知识 annotation</h4><p>在anno这个文件夹下存放的是Java注解</p>
<p>Annotation其实是代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取，并执行相应的处理。通过使用Annotation，程序开发人员可以在不改变原有逻辑的情况下，在源文件嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。</p>
<p>Annotation提供了一条为程序元素设置元数据的方法，从某些方面来看，Annotation就像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明，这些信息被存储在Annotation的“name=value”对中。</p>
<ul>
<li>使用@Retention</li>
</ul>
<p>　　@Retention只能用于修饰一个Annotation定义，用于指定<strong>该Annotation可以保留多长时间</strong>，如果未设置<code>@Retention</code>Annotation的有效范围为枚举常量Class表示的范围@Retention包含一个RetentionPolicy类型的value成员变量，所以使用@Retention时必须为该value成员变量指定值。</p>
<p>value成员变量的值只能是如下三个：</p>
<ol>
<li>RetentionPolicy.CLASS: 编译器将把注释记录在class文件中。当运行Java程序时，JVM不在保留注释，这是默认值。</li>
<li>RetentionPolicy.RUNTIME: 编译器将把注释记录在class文件中。当运行Java程序时，JVM也会保留注释，程序可以通过反射获取该注释。</li>
<li>RetentionPolicy.SOURCE: 注解仅存在于源码中，在class字节码文件中不包含。</li>
</ol>
<ul>
<li>使用@Target </li>
</ul>
<p>　　@Target也是用于修饰一个Annotation定义，它用于指定被修饰Annotation能<strong>用于修饰哪些程序元素</strong>。如果未设置<code>@target</code>,说明annotation适用于所有程序元素。@Target Annotation也包含一个名为value的成员变量，该成员变量只能是如下几个：</p>
<ol>
<li>ElementType.ANNOTATION_TYPE: 指定该策略的Annotation只能修饰Annotation。</li>
<li>ElementType.CONSTRUCTOR: 指定该策略的Annotation能修饰构造器。</li>
<li>ElementType.FIELD: 指定该策略的Annotation只能修饰成员变量。</li>
<li>ElementType.LOCAL_VARIABLE: 指定该策略的Annotation只能修饰局部变量。</li>
<li>ElementType.METHOD: 指定该策略的Annotation只能修饰方法。</li>
<li>ElementType.PACKAGE: 指定该策略的Annotation只能修饰包定义。</li>
<li>ElementType.PARAMETER: 指定该策略的Annotation可以修饰参数。</li>
<li>ElementType.TYPE: 指定该策略的Annotation可以修饰类、接口（包括注释类型）或枚举定义。</li>
</ol>
<p>在这里，我们使用了 @Retention 中的 <code>RetentionPolicy.RUNTIME</code> 和 @Target 中的 <code>ElementType.TYPE</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> qjm.rpc.anno;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * rpc服务类注解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> QJM</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)<span class="comment">//适用于类、接口、枚举</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="comment">//运行时加载到JVM中</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcService &#123;</span><br><span class="line">   <span class="comment">//实现接口</span></span><br><span class="line">   Class&lt;?&gt; value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在定义 Annotation 类型时，需要用关键字 <code>@interface</code> ,这个关键字的隐含意思是继承了 <code>java.lang.annotation.Annotation</code>接口。上面这个Annotation类型只包含一个泛型类型的成员<code>Class&lt;?&gt; value()</code> (如果在所定义的Annotation类型中只包含一个成员，通常将成员名称命名为value)</p>
<h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><p>流程如下所示：</p>
<p><img src="/2021/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek10/2.png" style="zoom:67%;"></p>
<p>根据上面的流程示意图，我们依次拆分这个项目：因为 <code>ServerTest</code> 代码很简单，就是启动一个<code>RpcServer</code> 实例，因此我们从ClientTest出发，用<strong>递归</strong>思路来剖析一下</p>
<p><img src="/2021/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek10/3.png" style="zoom:67%;"></p>
<p>ServerTest和ClientTest两个文件模拟的是本地的客户端，在不知道调用细节的情况下，调用存在于远程计算机上的某个对象也就是PersonService中的两个方法，就像调用本地应用程序中的对象一样。</p>
<p>首先，rpc-demo 项目是一个maven项目。其主体架构如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>根目录</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>pom.xml</td>
<td>Maven的pom文件</td>
</tr>
<tr>
<td>src/</td>
<td></td>
</tr>
<tr>
<td>main/</td>
<td>项目主体目录根</td>
</tr>
<tr>
<td>java</td>
<td>源代码目录</td>
</tr>
<tr>
<td>test/</td>
<td>项目测试目录根</td>
</tr>
<tr>
<td>java</td>
<td>测试代码目录</td>
</tr>
<tr>
<td>target/</td>
<td>输出目录根</td>
</tr>
</tbody>
</table>
</div>
<h3 id="从ClientTest出发"><a href="#从ClientTest出发" class="headerlink" title="从ClientTest出发"></a>从ClientTest出发</h3><p>首先我们来看 <code>test/java/qjm.rpc.test/ClientTest.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTest</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      RpcClientProxy proxy = <span class="keyword">new</span> RpcClientProxy(<span class="string">"127.0.0.1"</span>,<span class="number">9998</span>);</span><br><span class="line">      PersonService service = proxy.getProxy(PersonService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      </span><br><span class="line">      System.out.println(service.getInfo());</span><br><span class="line">      </span><br><span class="line">      Person person = <span class="keyword">new</span> Person();</span><br><span class="line">      person.setAge(<span class="number">23</span>);</span><br><span class="line">      person.setName(<span class="string">"Qjm"</span>);</span><br><span class="line">      person.setSex(<span class="string">"男"</span>);</span><br><span class="line">      System.out.println(service.printInfo(person));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个测试文件中，首先调用了<code>RpcClientProxy</code> 的构造方法，创建一个<code>RpcClientProxy</code>对象。然后当<code>proxy</code>对象调用<code>getProxy</code>方法的时候, 会被 <code>invoke</code> 方法拦截，并执行 <code>invoke</code> 方法。</p>
<h4 id="PrcClientProxy"><a href="#PrcClientProxy" class="headerlink" title="PrcClientProxy"></a>PrcClientProxy</h4><p>首先， <code>getProxy</code> 会接收一个泛型，然后返回一个代理对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt;<span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span></span>&#123;</span><br><span class="line">   <span class="comment">// clazz不是接口不能使用JDK动态代理</span></span><br><span class="line">   <span class="keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;clazz&#125;, RpcClientProxy.<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，传入的是 <code>PersonService.class</code>也就是获得这个接口所对应的Class实例，这个实例中提供了两个方法：<code>Person getInfo(),printInfo(Person person)</code> </p>
<p>接下来，当 <code>ClientTest</code> 调用 <code>service.getInfo()</code> 时，代理对象的方法被调用时会被invoke方法拦截，执行<code>invoke</code>方法</p>
<ul>
<li>封装参数，用于发送到服务器，定位服务、执行服务</li>
<li>链接服务器调用服务</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Method method, Object[] params)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">   <span class="comment">//封装参数</span></span><br><span class="line">   RpcRequest request = <span class="keyword">new</span> RpcRequest();</span><br><span class="line">   request.setClassName(method.getDeclaringClass().getName());</span><br><span class="line">   request.setMethodName(method.getName());</span><br><span class="line">   request.setParamTypes(method.getParameterTypes());</span><br><span class="line">   request.setParams(params);</span><br><span class="line">   <span class="comment">//链接服务器调用服务</span></span><br><span class="line">   RpcClient client = <span class="keyword">new</span> RpcClient();</span><br><span class="line">   <span class="keyword">return</span> client.start(request, host, port);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在封装参数阶段，首先，会创建一个<code>RpcRequest</code> 对象来标准化参数。关于<code>RpcRequest</code>我们之后再介绍。然后，我们给<code>request</code>设置完整的类名、方法名和参数类型，为调用服务做准备。这里，</p>
<ul>
<li>类名：<code>qjm.rpc.test.imp.PersonService</code></li>
<li>方法名：<code>getInfo</code></li>
<li>参数类型: <code>[]</code>，因为 <code>getinfo()</code> 是没有参数的</li>
<li>参数：null</li>
</ul>
<p>封装完毕之后，会新建一个<code>RpcClient</code> 对象，传入刚刚封装好的 <code>Rpcrequest</code>对象，本地ip和端口作为参数，并启动它。</p>
<h4 id="RpcClient"><a href="#RpcClient" class="headerlink" title="RpcClient"></a>RpcClient</h4><p>RpcClient对象的作用就是会把传入的请求对象通过socket发送给RpcServer,收到server传回来的数据之后，经过处理并返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">start</span><span class="params">(RpcRequest request, String host, <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">     <span class="comment">// 首先，用传入的ip和端口 创建一个 socket对象</span></span><br><span class="line">      Socket server = <span class="keyword">new</span> Socket(host, port);</span><br><span class="line">      </span><br><span class="line">      InputStream in = <span class="keyword">null</span>;</span><br><span class="line">      ObjectInputStream oin = <span class="keyword">null</span>;</span><br><span class="line">      OutputStream out = <span class="keyword">null</span>;</span><br><span class="line">      ObjectOutputStream oout = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 1. 发送请求数据</span></span><br><span class="line">         out = server.getOutputStream(); </span><br><span class="line">         oout = <span class="keyword">new</span> ObjectOutputStream(out);</span><br><span class="line">         oout.writeObject(request);<span class="comment">//把请求体通过socket推出</span></span><br><span class="line">         oout.flush();</span><br><span class="line">         </span><br><span class="line">         <span class="comment">// 2. 获取返回数据，强转参数类型</span></span><br><span class="line">         in = server.getInputStream();</span><br><span class="line">         oin = <span class="keyword">new</span> ObjectInputStream(in);</span><br><span class="line">         Object res = oin.readObject(); <span class="comment">//从返回流中读取返回的对象</span></span><br><span class="line">         RpcResponse response = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">if</span>(!(res <span class="keyword">instanceof</span> RpcResponse))&#123; <span class="comment">//如果返回的对象不是RpcResponse实例，报错</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"返回参数不正确"</span>);</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123; <span class="comment">// 如果是，那么进行一个显式类型转换</span></span><br><span class="line">            response = (RpcResponse) res;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">// 3. 返回结果</span></span><br><span class="line">         <span class="keyword">if</span>(response.getError() != <span class="keyword">null</span>)&#123; <span class="comment">//服务器产生异常</span></span><br><span class="line">            <span class="keyword">throw</span> response.getError();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> response.getResult();</span><br><span class="line">      &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;  <span class="comment">//关闭流</span></span><br><span class="line">            <span class="keyword">if</span>(in != <span class="keyword">null</span>) in.close();</span><br><span class="line">            <span class="keyword">if</span>(oin != <span class="keyword">null</span>) oin.close();</span><br><span class="line">            <span class="keyword">if</span>(out != <span class="keyword">null</span>) out.close();</span><br><span class="line">            <span class="keyword">if</span>(oout != <span class="keyword">null</span>) oout.close();</span><br><span class="line">            <span class="keyword">if</span>(server != <span class="keyword">null</span>) server.close();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="RpcRequest"><a href="#RpcRequest" class="headerlink" title="RpcRequest"></a>RpcRequest</h5><p>在<code>invoke</code>方法和<code>RpcClient</code>中已经提到了多次<code>RpcRequest</code>，现在我们来分析一下这个类</p>
<p>这个类实现了一个<code>Serializable</code> 接口，也就是将一个类序列化。一个类的对象要想序列化成功，必须满足两个条件：</p>
<ul>
<li>该类必须实现 java.io.Serializable 接口。</li>
<li>该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。</li>
</ul>
<p>Java的序列化机制中，一个对象可以表示为一个字节序列，该字节序列包括该对象的数据、有关对象类型的信息和存储在对象中的数据的类型。将序列化对象写入文件之后，可以从文件中读取出来，并对其进行反序列化。</p>
<p>因为<code>RpcRequest,RpcResponse</code>的实例化对象是要通过socket在client和server之间传递的，因此我们这里需要将其序列化。</p>
<p><code>RpcRequest</code> 的实例化对象是 <code>RpcClient</code> 发出的 ，是<code>RpcServer</code> 接收的</p>
<p>我们来看看<code>RpcRequest</code> 方法中的变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcRequest</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  serialVersionUID作用：</span></span><br><span class="line"><span class="comment">	序列化时为了保持版本的兼容性，即在版本升级时反序列化仍保持对象的唯一性。	</span></span><br><span class="line"><span class="comment">	默认的1L，比如：private static final long serialVersionUID = 1L;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">  <span class="comment">// 存放当前请求方法所在的类的名字</span></span><br><span class="line">	<span class="keyword">private</span> String className;</span><br><span class="line">  <span class="comment">// 存放当前请求方法的名字</span></span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">  <span class="comment">// 存放当前请求方法的参数的数据类型,因为参数的类型各不相同，这里需要使用泛型</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] paramTypes;</span><br><span class="line">  <span class="comment">// 存放请求方法的参数</span></span><br><span class="line">    <span class="keyword">private</span> Object[] params;</span><br><span class="line">	<span class="comment">// 剩下的方法都是上面变量的 getter和setter，这里略去不讲</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> className;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClassName</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.className = className;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getMethodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> methodName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMethodName</span><span class="params">(String methodName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.methodName = methodName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> Class&lt;?&gt;[] getParamTypes() &#123;</span><br><span class="line">		<span class="keyword">return</span> paramTypes;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParamTypes</span><span class="params">(Class&lt;?&gt;[] paramTypes)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.paramTypes = paramTypes;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> Object[] getParams() &#123;</span><br><span class="line">		<span class="keyword">return</span> params;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParams</span><span class="params">(Object[] params)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.params = params;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="RpcResponse"><a href="#RpcResponse" class="headerlink" title="RpcResponse"></a>RpcResponse</h5><p><code>RpcResponse</code>类，是<code>RpcServer</code> 处理并发出的，是<code>RpcClient</code>接收的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcResponse</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="comment">//serialVersionUID 和 RpcRequest 一样</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">  <span class="comment">// 当参数错误时，用来存放错误</span></span><br><span class="line">   <span class="keyword">private</span> Throwable error;</span><br><span class="line">  <span class="comment">// 存放RpcServer处理 RpcRequest后的结果</span></span><br><span class="line">   <span class="keyword">private</span> Object result;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 下面是参数的getter和setter</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Throwable <span class="title">getError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> error;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setError</span><span class="params">(Throwable error)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.error = error;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResult</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.result = result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RpcServer"><a href="#RpcServer" class="headerlink" title="RpcServer"></a>RpcServer</h4><p>现在我们来讲一下 <code>RpcServer</code>类，这个类比较复杂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 启动rpc服务</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> port 监听端口</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> clazz 服务类所在包名，多个用英文逗号隔开</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="comment">// 这里有两个参数，第一个是端口，第二个是</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> port, String clazz)</span> </span>&#123;</span><br><span class="line">      ServerSocket server = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 1. 创建socket连接</span></span><br><span class="line">         server = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">         <span class="comment">// 2. 获取所有rpc服务类，即发布服务。services 是 键值对类型的</span></span><br><span class="line">         Map&lt;String, Object&gt; services = getService(clazz);</span><br><span class="line">         <span class="comment">// 3. 创建线程池</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        ThreadPoolExecutor 的参数：</span></span><br><span class="line"><span class="comment">        int corePoolSize, 线程池中的线程数量</span></span><br><span class="line"><span class="comment">        int maximumPoolSize, 线程池中最大允许存放的线程数量</span></span><br><span class="line"><span class="comment">        long keepAliveTime, 当线程数大于核心数时，这是多余的空闲线程在终止之前等待新任务的最大时间。</span></span><br><span class="line"><span class="comment">        TimeUnit unit,保持活动时间参数的时间单位，这里设为 秒</span></span><br><span class="line"><span class="comment">        BlockingQueue&lt;Runnable&gt; workQueue,在执行任务之前用于保存任务的队列。这个队列将只保存execute方法提交的Runnable任务。 </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">         Executor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">10</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">         <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 4. 获取客户端连接</span></span><br><span class="line">            Socket client = server.accept();</span><br><span class="line">            <span class="comment">// 5. 查找并执行服务</span></span><br><span class="line">            RpcService service = <span class="keyword">new</span> RpcService(client, services);</span><br><span class="line">           <span class="comment">//利用线程池，来执这个RpcService,这里 execute方法的对象一定要是Runnable的</span></span><br><span class="line">            executor.execute(service);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">         <span class="comment">//关闭监听</span></span><br><span class="line">         <span class="keyword">if</span>(server != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               server.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 实例化所有rpc服务类，并返回键值对</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> clazz 服务类所在包名，多个用英文逗号隔开</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">getService</span><span class="params">(String clazz)</span></span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         Map&lt;String, Object&gt; services = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        <span class="comment">// 这里是将传入的字符串数组用 , 依次分割其中的元素。但是我们传入的只有一个元素：qjm.rpc.test</span></span><br><span class="line">       	<span class="comment">// 因此：clazzes: [qjm.rpc.test]</span></span><br><span class="line">         String[] clazzes = clazz.split(<span class="string">","</span>);</span><br><span class="line">         List&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> ArrayList&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">         <span class="keyword">for</span>(String cl:clazzes)&#123;</span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; classList = getClasses(cl);</span><br><span class="line">            classes.addAll(classList);</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="comment">//对每一个文件夹进行查找，并找出有 @RpcService 注解的类，放入classes列表中</span></span><br><span class="line">        <span class="comment">//classes: [class qjm.rpc.test.imp.PersonServiceImpl]</span></span><br><span class="line">         <span class="comment">//对classes中的类进行循环实例化</span></span><br><span class="line">         <span class="keyword">for</span>(Class&lt;?&gt; cla:classes)&#123;</span><br><span class="line">            Object obj = cla.newInstance();</span><br><span class="line">           <span class="comment">// key 值 是该类的名字，value值是该类的一个实例化对象</span></span><br><span class="line">            services.put(cla.getAnnotation(qjm.rpc.anno.RpcService<span class="class">.<span class="keyword">class</span>).<span class="title">value</span>().<span class="title">getName</span>(), <span class="title">obj</span>)</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="comment">//此时的services: &#123;qjm.rpc.test.imp.PersonService=qjm.rpc.test.imp.PersonServiceImpl@d716361&#125;</span></span><br><span class="line">         <span class="keyword">return</span> services;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取包下所有有<span class="doctag">@RpcSercive</span>注解的类</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> pckgname</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Class&lt;?&gt;&gt; getClasses(String pckgname) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">      List&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> ArrayList&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">      File directory = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         ClassLoader cld = Thread.currentThread().getContextClassLoader();</span><br><span class="line">         <span class="keyword">if</span> (cld == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">"Can't get class loader."</span>);</span><br><span class="line">         String path = pckgname.replace(<span class="string">'.'</span>, <span class="string">'/'</span>);</span><br><span class="line">         URL resource = cld.getResource(path);</span><br><span class="line">         <span class="keyword">if</span> (resource == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">"No resource for "</span> + path);</span><br><span class="line">         directory = <span class="keyword">new</span> File(resource.getFile());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (NullPointerException x) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(pckgname + <span class="string">" ("</span> + directory + <span class="string">") does not appear to be a valid package a"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (directory.exists()) &#123;</span><br><span class="line">         <span class="comment">//获取所有文件</span></span><br><span class="line">         String[] files = directory.list();</span><br><span class="line">         File[] fileList = directory.listFiles();</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;fileList != <span class="keyword">null</span> &amp;&amp; i &lt; fileList.length; i++) &#123;</span><br><span class="line">            File file = fileList[i];</span><br><span class="line">            <span class="comment">//判断是否是Class文件</span></span><br><span class="line">            <span class="keyword">if</span> (file.isFile() &amp;&amp; file.getName().endsWith(<span class="string">".class"</span>)) &#123;</span><br><span class="line">               Class&lt;?&gt; clazz = Class.forName(pckgname + <span class="string">'.'</span> + files[i].substring(<span class="number">0</span>, files[i].length() - <span class="number">6</span>));</span><br><span class="line">               <span class="keyword">if</span>(clazz.getAnnotation(qjm.rpc.anno.RpcService<span class="class">.<span class="keyword">class</span>) !</span>= <span class="keyword">null</span>)&#123;</span><br><span class="line">                  classes.add(clazz);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(file.isDirectory())&#123; <span class="comment">//如果是目录，递归查找</span></span><br><span class="line">               List&lt;Class&lt;?&gt;&gt; result = getClasses(pckgname+<span class="string">"."</span>+file.getName());</span><br><span class="line">               <span class="keyword">if</span>(result != <span class="keyword">null</span> &amp;&amp; result.size() != <span class="number">0</span>)&#123;</span><br><span class="line">                  classes.addAll(result);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(pckgname + <span class="string">" does not appear to be a valid package b"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> classes;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="imp文件夹"><a href="#imp文件夹" class="headerlink" title="imp文件夹"></a>imp文件夹</h5><p>我们在RpcServer中实例化了这个文件夹中的<code>PersonServiceImpl</code>类，现在来看看这个类长啥样：</p>
<p>这个类继承自 PersonService 接口，接口中定义了 <code>getInfo()</code>方法和<code>printInfo()</code>方法</p>
<p>此外，之前说的 Annotation在这里被派上了用场，因为这个类被标记了，所以能被<code>RpcServer</code>快速地找出并标记、实例化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> qjm.rpc.test.imp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> qjm.rpc.anno.RpcService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RpcService</span>(PersonService<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">PersonServiceImpl</span> <span class="keyword">implements</span> <span class="title">PersonService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Person <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Person person = <span class="keyword">new</span> Person();</span><br><span class="line">      person.setAge(<span class="number">22</span>);</span><br><span class="line">      person.setName(<span class="string">"qjm"</span>);</span><br><span class="line">      person.setSex(<span class="string">"男"</span>);</span><br><span class="line">      <span class="keyword">return</span> person;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">printInfo</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(person != <span class="keyword">null</span>)&#123;</span><br><span class="line">         System.out.println(person);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用<code>getInfo()</code>时，会返回一个person对象，当调用<code>printInfo()</code>时，会返回一个布尔值</p>
<p>Person类的定义如下：</p>
<p>定义了名字、年龄和性别以及它们的getter和setter，此外，还重写了<code>toString</code>函数,也就是当我们打印一个Person对象时，会按照我们定义的格式输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> String sex;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sex;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.sex = sex;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", sex="</span> + sex + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RpcService"><a href="#RpcService" class="headerlink" title="RpcService"></a>RpcService</h4><p><code>RpcServer</code>在与<code>RpcClient</code> 建立连接后，会新建一个 <code>RpcService</code> 对象，传入参数为：<code>client</code> 连接以及键值对类型的<code>services</code></p>
<p>在这个类中，首先会读取流中的 <code>RpcRequest</code>, 然后在services中查找并执行<code>RpcRequest</code>中包含着的本地客户端要请求的方法，最后返回执行后的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcService</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Socket client;</span><br><span class="line">	<span class="keyword">private</span> Map&lt;String,Object&gt; services;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> client 客户端</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> services 所有服务</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">  <span class="comment">// 这是一个构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RpcService</span><span class="params">(Socket client, Map&lt;String, Object&gt; services)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.client = client;</span><br><span class="line">		<span class="keyword">this</span>.services = services;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		InputStream in = <span class="keyword">null</span>;</span><br><span class="line">		ObjectInputStream oin = <span class="keyword">null</span>;</span><br><span class="line">		OutputStream out = <span class="keyword">null</span>;</span><br><span class="line">		ObjectOutputStream oout = <span class="keyword">null</span>;</span><br><span class="line">		RpcResponse response = <span class="keyword">new</span> RpcResponse();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 1. 获取流</span></span><br><span class="line">			in = client.getInputStream();</span><br><span class="line">			oin = <span class="keyword">new</span> ObjectInputStream(in);</span><br><span class="line">			out = client.getOutputStream();</span><br><span class="line">			oout = <span class="keyword">new</span> ObjectOutputStream(out);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 2. 获取RpcRequest中的请求数据，强转参数类型</span></span><br><span class="line">			Object param = oin.readObject();</span><br><span class="line">			RpcRequest  request = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">if</span>(!(param <span class="keyword">instanceof</span> RpcRequest))&#123;</span><br><span class="line">				response.setError(<span class="keyword">new</span> Exception(<span class="string">"参数错误"</span>));</span><br><span class="line">				oout.writeObject(response);</span><br><span class="line">				oout.flush();</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				request = (RpcRequest) param;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 3. 查找并执行服务方法</span></span><br><span class="line">      <span class="comment">// 首先用request.getClassName()获取类名，然后再键值对中用类名查找得到实例化的对象</span></span><br><span class="line">			Object service = services.get(request.getClassName());</span><br><span class="line">      <span class="comment">// 已经获取了实例化的对象，接下来要根据方法名称、方法的参数的数据类型来获得具体的方法</span></span><br><span class="line">			Class&lt;?&gt; clazz= service.getClass();</span><br><span class="line">			Method method = clazz.getMethod(request.getMethodName(), request.getParamTypes());</span><br><span class="line">      <span class="comment">// 最后，调用该方法，并返回结果</span></span><br><span class="line">			Object result = method.invoke(service, request.getParams());</span><br><span class="line">			<span class="comment">// 4. 将结果存放到 RpcResponse 实例化对象中，并通过socket 传回。</span></span><br><span class="line">			response.setResult(result);</span><br><span class="line">			oout.writeObject(response);</span><br><span class="line">			oout.flush();</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;	<span class="comment">//异常处理</span></span><br><span class="line">				<span class="keyword">if</span>(oout != <span class="keyword">null</span>)&#123;</span><br><span class="line">					response.setError(e);</span><br><span class="line">					oout.writeObject(response);</span><br><span class="line">					oout.flush();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">				e1.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;	<span class="comment">// 关闭流</span></span><br><span class="line">				<span class="keyword">if</span>(in != <span class="keyword">null</span>) in.close();</span><br><span class="line">				<span class="keyword">if</span>(oin != <span class="keyword">null</span>) oin.close();</span><br><span class="line">				<span class="keyword">if</span>(out != <span class="keyword">null</span>) out.close();</span><br><span class="line">				<span class="keyword">if</span>(oout != <span class="keyword">null</span>) oout.close();</span><br><span class="line">				<span class="keyword">if</span>(client != <span class="keyword">null</span>) client.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是回到<code>ClientTest</code>的这行代码： <code>System.out.println(service.getInfo());</code> </p>
<p>通过这样绕一大圈，最后是在 <code>RpcService</code>中通过<code>method.invoke(service, request.getParams());</code> 实现的。返回一个<code>Person</code>对象，这个对象放在<code>RpcResponse</code>中传回<code>RpcClient</code>, <code>RpcClient</code>收到之后再返回客户端 <code>response.getResult();</code> </p>
<p>我们再将其输出，就得到了 <code>Person [name=qjm, age=22, sex=男]</code> 这个结果。</p>
<p>同理，对于<code>System.out.println(service.printInfo(person));</code> 这行代码，传入了一个我们定义的Person对象。然后，<code>RpcService</code>会调用放在<code>PersonServicelmpl</code> 中的<code>printInfo(person)</code>方法。在这个方法中，如果 <code>person</code>对象不为空，那么就会在客户的serviceTest端输出person的信息，然后返回true。这个true通过socket 传给<code>RpcClient</code>并经其返回给客户的clientTest端，打印为True。</p>
<p>这样，一个基于rpc协议的项目就被我们分析完了。</p>
<h3 id="gRPC框架使用"><a href="#gRPC框架使用" class="headerlink" title="gRPC框架使用"></a>gRPC框架使用</h3><p><strong>Task2</strong>：按照下面步骤完成gRPC使用，并将其中关键步骤和实验结果写到实验报告中。</p>
<p>gRPC：在 gRPC 里客户端应用可以像调用本地对象一样直接调用另一台不同的机器上服务端应用的方法，使得您能够更容易地创建分布式应用和服务。与许多 RPC 系统类似，gRPC 也是基于以下理念：定义一个服务，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口，并运行一个 gRPC 服务器来处理客户端调用。在客户端拥有一个存根能够像服务端一样的方法。</p>
<h4 id="新建一个普通的Maven项目"><a href="#新建一个普通的Maven项目" class="headerlink" title="新建一个普通的Maven项目"></a>新建一个普通的Maven项目</h4><h4 id="配置pom文件，导入grpc的依赖和插件"><a href="#配置pom文件，导入grpc的依赖和插件" class="headerlink" title="配置pom文件，导入grpc的依赖和插件"></a>配置pom文件，导入grpc的依赖和插件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.grpcprojects<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpcExercise3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">grpc-version</span>&gt;</span>1.20.0<span class="tag">&lt;/<span class="name">grpc-version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;grpc-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-netty-shaded<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;grpc-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-protobuf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;grpc-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-stub<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;grpc-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">extensions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">extension</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>kr.motd.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>os-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>          <span class="tag">&lt;<span class="name">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:3.7.1:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="name">protocArtifact</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">pluginId</span>&gt;</span>grpc-java<span class="tag">&lt;/<span class="name">pluginId</span>&gt;</span>                      <span class="tag">&lt;<span class="name">pluginArtifact</span>&gt;</span>io.grpc:protoc-gen-grpc-java:1.9.1:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="name">pluginArtifact</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">protoSourceRoot</span>&gt;</span>src/main/proto<span class="tag">&lt;/<span class="name">protoSourceRoot</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile-custom<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="编写proto文件"><a href="#编写proto文件" class="headerlink" title="编写proto文件"></a>编写proto文件</h4><p>在项目main目录下新建一个proto文件夹，再在此文件夹下创建一个helloworld.proto文件</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">syntax</span> = <span class="string">"proto3";</span></span><br><span class="line"><span class="attr">option</span> <span class="string">java_multiple_files = true;</span></span><br><span class="line"><span class="attr">option</span> <span class="string">java_package = "io.grpc.examples.helloworld";</span></span><br><span class="line"><span class="attr">option</span> <span class="string">java_outer_classname = "HelloWorldProto";</span></span><br><span class="line"><span class="attr">option</span> <span class="string">objc_class_prefix = "HLW";</span></span><br><span class="line"><span class="attr">package</span> <span class="string">helloworld;</span></span><br><span class="line"><span class="meta">//</span> <span class="string">The greeting service definition.</span></span><br><span class="line"><span class="attr">service</span> <span class="string">Greeter &#123;</span></span><br><span class="line">    <span class="meta">//</span> <span class="string">Sends a greeting</span></span><br><span class="line">    <span class="attr">rpc</span> <span class="string">SayHello (HelloRequest) returns (HelloReply) &#123;&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="meta">//</span> <span class="string">The request message containing the user's name.</span></span><br><span class="line"><span class="attr">message</span> <span class="string">HelloRequest &#123;</span></span><br><span class="line">    <span class="attr">string</span> <span class="string">name = 1;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="meta">//</span> <span class="string">The response message containing the greetings</span></span><br><span class="line"><span class="attr">message</span> <span class="string">HelloReply &#123;</span></span><br><span class="line">    <span class="attr">string</span> <span class="string">message = 1;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="编译proto文件"><a href="#编译proto文件" class="headerlink" title="编译proto文件"></a>编译proto文件</h4><ul>
<li>右击Maven.Projects\protobuf\protobuf:compile ，选择run，生成用于序列化的java文件。</li>
<li>再右击Maven.Projects\protobuf\protobuf:compile-custom，选择run，生成用于rpc的java代码。</li>
</ul>
<h4 id="添加客户端和服务端代码"><a href="#添加客户端和服务端代码" class="headerlink" title="添加客户端和服务端代码"></a>添加客户端和服务端代码</h4><p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> helloworld;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> io.grpc.ManagedChannel;</span><br><span class="line"><span class="keyword">import</span> io.grpc.ManagedChannelBuilder;</span><br><span class="line"><span class="keyword">import</span> io.grpc.StatusRuntimeException;</span><br><span class="line"><span class="keyword">import</span> io.grpc.examples.helloworld.GreeterGrpc;</span><br><span class="line"><span class="keyword">import</span> io.grpc.examples.helloworld.HelloReply;</span><br><span class="line"><span class="keyword">import</span> io.grpc.examples.helloworld.HelloRequest;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A simple client that requests a greeting from the &#123;<span class="doctag">@link</span> HelloWorldServer&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldClient</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(HelloWorldClient<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ManagedChannel channel;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> GreeterGrpc.GreeterBlockingStub blockingStub;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/** Construct client connecting to HelloWorld server at &#123;<span class="doctag">@code</span> host:port&#125;. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HelloWorldClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(ManagedChannelBuilder.forAddress(host, port)</span><br><span class="line">        <span class="comment">// Channels are secure by default (via SSL/TLS). For the example we disable TLS to avoid</span></span><br><span class="line">        <span class="comment">// needing certificates.</span></span><br><span class="line">        .usePlaintext()</span><br><span class="line">        .build());</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/** Construct client for accessing HelloWorld server using the existing channel. */</span></span><br><span class="line">  HelloWorldClient(ManagedChannel channel) &#123;</span><br><span class="line">    <span class="keyword">this</span>.channel = channel;</span><br><span class="line">    blockingStub = GreeterGrpc.newBlockingStub(channel);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    channel.shutdown().awaitTermination(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/** Say hello to server. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"Will try to greet "</span> + name + <span class="string">" ..."</span>);</span><br><span class="line">    HelloRequest request = HelloRequest.newBuilder().setName(name).build();</span><br><span class="line">    HelloReply response;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      response = blockingStub.sayHello(request);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (StatusRuntimeException e) &#123;</span><br><span class="line">      logger.log(Level.WARNING, <span class="string">"RPC failed: &#123;0&#125;"</span>, e.getStatus());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    logger.info(<span class="string">"Greeting: "</span> + response.getMessage());</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Greet server. If provided, the first element of &#123;<span class="doctag">@code</span> args&#125; is the name to use in the</span></span><br><span class="line"><span class="comment">   * greeting.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HelloWorldClient client = <span class="keyword">new</span> HelloWorldClient(<span class="string">"localhost"</span>, <span class="number">50051</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">/* Access a service running on the local machine on port 50051 */</span></span><br><span class="line">      String user = <span class="string">"world"</span>;</span><br><span class="line">      <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        user = args[<span class="number">0</span>]; <span class="comment">/* Use the arg as the name to greet if provided */</span></span><br><span class="line">     &#125;</span><br><span class="line">      client.greet(user);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      client.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> helloworld;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">import</span> io.grpc.Server;</span><br><span class="line">  <span class="keyword">import</span> io.grpc.ServerBuilder;</span><br><span class="line">  <span class="keyword">import</span> io.grpc.examples.helloworld.GreeterGrpc;</span><br><span class="line">  <span class="keyword">import</span> io.grpc.examples.helloworld.HelloReply;</span><br><span class="line">  <span class="keyword">import</span> io.grpc.examples.helloworld.HelloRequest;</span><br><span class="line">  <span class="keyword">import</span> io.grpc.stub.StreamObserver;</span><br><span class="line">  <span class="keyword">import</span> java.io.IOException;</span><br><span class="line">  <span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Server that manages startup/shutdown of a &#123;<span class="doctag">@code</span> Greeter&#125; server.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(HelloWorldServer<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> Server server;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">/* The port on which the server should run */</span></span><br><span class="line">      <span class="keyword">int</span> port = <span class="number">50051</span>;</span><br><span class="line">      server = ServerBuilder.forPort(port)</span><br><span class="line">          .addService(<span class="keyword">new</span> GreeterImpl())</span><br><span class="line">          .build()</span><br><span class="line">          .start();</span><br><span class="line">      logger.info(<span class="string">"Server started, listening on "</span> + port);</span><br><span class="line">      Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// Use stderr here since the logger may have been reset by its JVM shutdown hook.</span></span><br><span class="line">          System.err.println(<span class="string">"*** shutting down gRPC server since JVM is shutting down"</span>);</span><br><span class="line">          HelloWorldServer.<span class="keyword">this</span>.stop();</span><br><span class="line">          System.err.println(<span class="string">"*** server shut down"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</span><br><span class="line">       server.shutdown();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Await termination on the main thread since the grpc library uses daemon threads.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">blockUntilShutdown</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</span><br><span class="line">        server.awaitTermination();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Main launches the server from the command line.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> HelloWorldServer server = <span class="keyword">new</span> HelloWorldServer();</span><br><span class="line">      server.start();</span><br><span class="line">      server.blockUntilShutdown();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">GreeterImpl</span> <span class="keyword">extends</span> <span class="title">GreeterGrpc</span>.<span class="title">GreeterImplBase</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(HelloRequest req, StreamObserver&lt;HelloReply&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        HelloReply reply = HelloReply.newBuilder().setMessage(<span class="string">"Hello "</span> + req.getName()).build();</span><br><span class="line">        responseObserver.onNext(reply);</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>一开始，会报错：</p>
<p><img src="/2021/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek10/4.png" style="zoom:67%;"></p>
<p>但事实上这是因为还没有把proto文件更新到项目中去，点击Maven上菜单栏中的文件夹图标即可修复。运行结果如下：</p>
<p><img src="/2021/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek10/6.png" style="zoom:67%;"></p>
<p><img src="/2021/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek10/7.png" style="zoom:67%;"></p>
<p>项目结构如下：</p>
<p><img src="/2021/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek10/8.png" style="zoom:67%;"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/" class="post-title-link" itemprop="url">操作系统-进程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-05 11:19:43" itemprop="dateCreated datePublished" datetime="2021-05-05T11:19:43+08:00">2021-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-24 11:40:06" itemprop="dateModified" datetime="2022-08-24T11:40:06+08:00">2022-08-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="操作系统-进程"><a href="#操作系统-进程" class="headerlink" title="操作系统-进程"></a>操作系统-进程</h1><p>搬运学习博客：<a href="https://www.cnblogs.com/cxuanBlog/p/12402424.html" target="_blank" rel="noopener">https://www.cnblogs.com/cxuanBlog/p/12402424.html</a></p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/1.png" style="zoom:67%;"></p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>操作系统中最核心的概念就是 <code>进程</code>，进程是对正在运行中的程序的一个抽象。操作系统的其他所有内容都是围绕着进程展开的。进程是操作系统提供的最古老也是最重要的概念之一。即使可以使用的 CPU 只有一个，它们也支持<code>（伪）并发</code>操作。它们会将一个单独的 CPU 抽象为多个虚拟机的 CPU。可以说：没有进程的抽象，现代操作系统将不复存在。</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/2.png" style="zoom:67%;"></p>
<p>所有现代的计算机会在同一时刻做很多事情，过去使用计算机的人（单 CPU）可能完全无法理解现在这种变化，举个例子更能说明这一点：首先考虑一个 Web 服务器，请求都来自于 Web 网页。当一个请求到达时，服务器会检查当前页是否在缓存中，如果是在缓存中，就直接把缓存中的内容返回。如果缓存中没有的话，那么请求就会交给磁盘来处理。但是，从 CPU 的角度来看，磁盘请求需要更长的时间，因为磁盘请求会很慢。当硬盘请求完成时，更多其他请求才会进入。如果有多个磁盘的话，可以在第一个请求完成前就可以连续的对其他磁盘发出部分或全部请求。很显然，这是一种并发现象，需要有并发控制条件来控制并发现象。</p>
<p>现在考虑只有一个用户的 PC。当系统启动时，许多进程也在后台启动，用户通常不知道这些进程的启动，试想一下，当你自己的计算机启动的时候，你能知道哪些进程是需要启动的么？这些后台进程可能是一个需要输入电子邮件的电子邮件进程，或者是一个计算机病毒查杀进程来周期性的更新病毒库。某个用户进程可能会在所有用户上网的时候打印文件以及刻录 CD-ROM，这些活动都需要管理。于是一个支持多进程的多道程序系统就会显得很有必要了。</p>
<p>在许多多道程序系统中，CPU 会在<code>进程</code>间快速切换，使每个程序运行几十或者几百毫秒。然而，严格意义来说，在某一个瞬间，CPU 只能运行一个进程，然而我们如果把时间定位为 1 秒内的话，它可能运行多个进程。这样就会让我们产生<code>并行</code>的错觉。有时候人们说的 <code>伪并行(pseudoparallelism)</code> 就是这种情况，以此来区分多处理器系统(该系统由两个或多个 CPU 来共享同一个物理内存)</p>
<blockquote>
<p>再来详细解释一下伪并行：<code>伪并行</code>是指单核或多核处理器同时执行多个进程，从而使程序更快。 通过以非常有限的时间间隔在程序之间快速切换CPU，因此会产生并行感。 缺点是 CPU 时间可能分配给下一个进程，也可能不分配给下一个进程。</p>
</blockquote>
<p>因为 CPU 执行速度很快，进程间的换进换出也非常迅速，因此我们很难对多个并行进程进行跟踪，所以，在经过多年的努力后，操作系统的设计者开发了用于描述并行的一种概念模型（顺序进程），使得并行更加容易理解和分析，对该模型的探讨，也是本篇文章的主题。下面我们就来探讨一下进程模型</p>
<h3 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h3><p>在进程模型中，所有计算机上运行的软件，通常也包括操作系统，被组织为若干<code>顺序进程(sequential processes)</code>，简称为 <code>进程(process)</code> 。一个进程就是一个正在执行的程序的实例，进程也包括程序计数器、寄存器和变量的当前值。从概念上来说，每个进程都有各自的虚拟 CPU，但是实际情况是 CPU 会在各个进程之间进行来回切换。</p>
<p> <img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/5.png" alt="5" style="zoom:67%;"></p>
<p>如上图所示，这是一个具有 4 个程序的多道处理程序，在进程不断切换的过程中，程序计数器也在不同的变化。</p>
<p> <img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/4.png" style="zoom:67%;"></p>
<p>在上图中，这 4 道程序被抽象为 4 个拥有各自控制流程（即每个自己的程序计数器）的进程，并且每个程序都独立的运行。当然，实际上只有一个物理程序计数器，每个程序要运行时，其逻辑程序计数器会装载到物理程序计数器中。当程序运行结束后，其物理程序计数器就会是真正的程序计数器，然后再把它放回进程的逻辑计数器中。</p>
<p>从下图我们可以看到，在观察足够长的一段时间后，所有的进程都运行了，<strong>但在任何一个给定的瞬间仅有一个进程真正运行</strong>。</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/6.png" style="zoom:67%;"></p>
<p>因此，当我们说一个 CPU 只能真正一次运行一个进程的时候，即使有 2 个核（或 CPU），<strong>每一个核也只能一次运行一个线程</strong>。</p>
<p>由于 CPU 会在各个进程之间来回快速切换，所以每个进程在 CPU 中的运行时间是无法确定的。并且当同一个进程再次在 CPU 中运行时，其在 CPU 内部的运行时间往往也是不固定的。进程和程序之间的区别是非常微妙的，但是通过一个例子可以让你加以区分：想想一位会做饭的计算机科学家正在为他的女儿制作生日蛋糕。他有做生日蛋糕的食谱，厨房里有所需的原料：面粉、鸡蛋、糖、香草汁等。在这个比喻中，做蛋糕的食谱就是程序、计算机科学家就是 CPU、而做蛋糕的各种原谅都是输入数据。进程就是科学家阅读食谱、取来各种原料以及烘焙蛋糕等一系例了动作的总和。</p>
<p>现在假设科学家的儿子跑过来告诉他，说他的头被蜜蜂蜇了一下，那么此时科学家会记录出来他做蛋糕这个过程到了哪一步，然后拿出急救手册，按照上面的步骤给他儿子实施救助。这里，会涉及到进程之间的切换，科学家（CPU）会从做蛋糕（进程）切换到实施医疗救助（另一个进程）。等待伤口处理完毕后，科学家会回到刚刚记录做蛋糕的那一步，继续制作。</p>
<p>这里的关键思想是<code>认识到一个进程所需的条件</code>，进程是某一类特定活动的总和，它有程序、输入输出以及状态。单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另外一个进程提供服务。另外需要注意的是，如果一个进程运行了两遍，则被认为是两个进程。那么我们了解到进程模型后，那么进程是如何创建的呢？</p>
<h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>操作系统需要一些方式来创建进程。下面是一些创建进程的方式</p>
<ul>
<li>系统初始化（init）</li>
<li>正在运行的程序执行了创建进程的系统调用（比如 fork）</li>
<li>用户请求创建一个新进程</li>
<li>初始化一个批处理工作</li>
</ul>
<h4 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h4><p>启动操作系统时，通常会创建若干个进程。其中有些是<code>前台进程(numerous processes)</code>，也就是同用户进行交互并替他们完成工作的进程。一些运行在后台，并不与特定的用户进行交互，例如，设计一个进程来接收发来的电子邮件，这个进程大部分的时间都在休眠，但是只要邮件到来后这个进程就会被唤醒。还可以设计一个进程来接收对该计算机上网页的传入请求，在请求到达的进程唤醒来处理网页的传入请求。进程运行在后台用来处理一些活动像是 e-mail，web 网页，新闻，打印等等被称为 <code>守护进程(daemons)</code>。大型系统会有很多守护进程。在 UNIX 中，<code>ps</code> 程序可以列出正在运行的进程， 在 Windows 中，可以使用任务管理器。</p>
<h4 id="系统调用创建"><a href="#系统调用创建" class="headerlink" title="系统调用创建"></a>系统调用创建</h4><p>除了在启动阶段创建进程之外，一些新的进程也可以在后面创建。通常，一个正在运行的进程会发出<code>系统调用</code>用来创建一个或多个新进程来帮助其完成工作。例如，如果有大量的数据需要经过网络调取并进行顺序处理，那么创建一个进程读数据，并把数据放到共享缓冲区中，而让第二个进程取走并正确处理会比较容易些。在多处理器中，让每个进程运行在不同的 CPU 上也可以使工作做的更快。</p>
<h4 id="用户请求创建"><a href="#用户请求创建" class="headerlink" title="用户请求创建"></a>用户请求创建</h4><p>在许多交互式系统中，输入一个命令或者双击图标就可以启动程序，以上任意一种操作都可以选择开启一个新的进程，在基本的 UNIX 系统中运行 X，新进程将接管启动它的窗口。在 Windows 中启动进程时，它一般没有窗口，但是它可以创建一个或多个窗口。每个窗口都可以运行进程。通过鼠标或者命令就可以切换窗口并与进程进行交互。</p>
<blockquote>
<p>交互式系统是以人与计算机之间大量交互为特征的计算机系统，比如游戏、web浏览器，IDE 等集成开发环境。</p>
</blockquote>
<h4 id="批处理创建"><a href="#批处理创建" class="headerlink" title="批处理创建"></a>批处理创建</h4><p>最后一种创建进程的情形会在<code>大型机的批处理系统</code>中应用。用户在这种系统中提交批处理作业。当操作系统决定它有资源来运行另一个任务时，它将创建一个新进程并从其中的输入队列中运行下一个作业。</p>
<p>从技术上讲，在所有这些情况下，让现有流程执行流程是通过创建系统调用来创建新流程的。该进程可能是正在运行的用户进程，是从键盘或鼠标调用的系统进程或批处理程序。这些就是系统调用创建新进程的过程。该系统调用告诉操作系统创建一个新进程，并直接或间接指示在其中运行哪个程序。</p>
<p>在 UNIX 中，仅有一个系统调用来创建一个新的进程，这个系统调用就是 <code>fork</code>。这个调用会创建一个与调用进程相关的副本。在 fork 后，一个父进程和子进程会有相同的内存映像，相同的环境字符串和相同的打开文件。通常，子进程会执行 <code>execve</code> 或者一个简单的系统调用来改变内存映像并运行一个新的程序。例如，当一个用户在 shell 中输出 sort 命令时，shell 会 fork 一个子进程然后子进程去执行 sort 命令。这两步过程的原因是允许子进程在 fork 之后但在 execve 之前操作其文件描述符，以完成标准输入，标准输出和标准错误的重定向。</p>
<p>在 Windows 中，情况正相反，一个简单的 Win32 功能调用 <code>CreateProcess</code>，会处理流程创建并将正确的程序加载到新的进程中。这个调用会有 10 个参数，包括了需要执行的程序、输入给程序的命令行参数、各种安全属性、有关打开的文件是否继承控制位、优先级信息、进程所需要创建的窗口规格以及指向一个结构的指针，在该结构中新创建进程的信息被返回给调用者。除了 <code>CreateProcess</code> Win 32 中大概有 100 个其他的函数用于处理进程的管理，同步以及相关的事务。下面是 UNIX 操作系统和 Windows 操作系统系统调用的对比</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>UNIX</th>
<th>Win32</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>fork</td>
<td>CreateProcess</td>
<td>创建一个新进程</td>
</tr>
<tr>
<td>waitpid</td>
<td>WaitForSingleObject</td>
<td>等待一个进程退出</td>
</tr>
<tr>
<td>execve</td>
<td>none</td>
<td>CraeteProcess = fork + servvice</td>
</tr>
<tr>
<td>exit</td>
<td>ExitProcess</td>
<td>终止执行</td>
</tr>
<tr>
<td>open</td>
<td>CreateFile</td>
<td>创建一个文件或打开一个已有的文件</td>
</tr>
<tr>
<td>close</td>
<td>CloseHandle</td>
<td>关闭文件</td>
</tr>
<tr>
<td>read</td>
<td>ReadFile</td>
<td>从单个文件中读取数据</td>
</tr>
<tr>
<td>write</td>
<td>WriteFile</td>
<td>向单个文件写数据</td>
</tr>
<tr>
<td>lseek</td>
<td>SetFilePointer</td>
<td>移动文件指针</td>
</tr>
<tr>
<td>stat</td>
<td>GetFileAttributesEx</td>
<td>获得不同的文件属性</td>
</tr>
<tr>
<td>mkdir</td>
<td>CreateDirectory</td>
<td>创建一个新的目录</td>
</tr>
<tr>
<td>rmdir</td>
<td>RemoveDirectory</td>
<td>移除一个空的目录</td>
</tr>
<tr>
<td>link</td>
<td>none</td>
<td>Win32 不支持 link</td>
</tr>
<tr>
<td>unlink</td>
<td>DeleteFile</td>
<td>销毁一个已有的文件</td>
</tr>
<tr>
<td>mount</td>
<td>none</td>
<td>Win32 不支持 mount</td>
</tr>
<tr>
<td>umount</td>
<td>none</td>
<td>Win32 不支持 mount，所以也不支持mount</td>
</tr>
<tr>
<td>chdir</td>
<td>SetCurrentDirectory</td>
<td>切换当前工作目录</td>
</tr>
<tr>
<td>chmod</td>
<td>none</td>
<td>Win32 不支持安全</td>
</tr>
<tr>
<td>kill</td>
<td>none</td>
<td>Win32 不支持信号</td>
</tr>
<tr>
<td>time</td>
<td>GetLocalTime</td>
<td>获取当前时间</td>
</tr>
</tbody>
</table>
</div>
<p>在 UNIX 和 Windows 中，进程创建之后，父进程和子进程有各自不同的地址空间。如果其中某个进程在其地址空间中修改了一个词，这个修改将对另一个进程不可见。</p>
<p>在 UNIX 中，子进程的地址空间是父进程的一个拷贝，但是是两个<strong>不同的地址空间</strong>；不可写的内存区域是共享的。某些 UNIX 实现是正是在两者之间共享，因为它不能被修改。或者，子进程共享父进程的所有内存，但是这种情况下内存通过 <code>写时复制(copy-on-write)</code> 共享，这意味着一旦两者之一想要修改部分内存，则这块内存首先被明确的复制，以确保修改发生在私有内存区域。再次强调，<strong>可写的内存是不能被共享的</strong>。但是，对于一个新创建的进程来说，确实有可能共享创建者的资源，比如可以<strong>共享打开的文件</strong>。</p>
<p><strong>在 Windows 中，从一开始父进程的地址空间和子进程的地址空间就是不同的</strong>。</p>
<h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><p>进程在创建之后，它就开始运行并做完成任务。然而，没有什么事是永不停歇的，包括进程也一样。进程早晚会发生终止，但是通常是由于以下情况触发的</p>
<ul>
<li><code>正常退出(自愿的)</code></li>
<li><code>错误退出(自愿的)</code></li>
<li><code>严重错误(非自愿的)</code></li>
<li><code>被其他进程杀死(非自愿的)</code></li>
</ul>
<h4 id="正常退出"><a href="#正常退出" class="headerlink" title="正常退出"></a>正常退出</h4><p>多数进程是由于完成了工作而终止。当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用告诉操作系统它完成了工作。这个调用在 UNIX 中是 <code>exit</code> ，在 Windows 中是 <code>ExitProcess</code>。面向屏幕中的软件也支持自愿终止操作。字处理软件、Internet 浏览器和类似的程序中总有一个供用户点击的图标或菜单项，用来通知进程删除它锁打开的任何临时文件，然后终止。</p>
<h4 id="错误退出"><a href="#错误退出" class="headerlink" title="错误退出"></a>错误退出</h4><p>进程发生终止的第二个原因是发现严重错误，例如，如果用户执行如下命令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc foo.c</span><br></pre></td></tr></table></figure>
<p>为了能够编译 foo.c 但是该文件不存在，于是编译器就会发出声明并退出。在给出了错误参数时，面向屏幕的交互式进程通常并不会直接退出，因为这从用户的角度来说并不合理，用户需要知道发生了什么并想要进行重试，所以这时候应用程序通常会弹出一个对话框告知用户发生了系统错误，是需要重试还是退出。</p>
<h4 id="严重错误"><a href="#严重错误" class="headerlink" title="严重错误"></a>严重错误</h4><p>进程终止的第三个原因是由进程引起的错误，通常是由于程序中的错误所导致的。例如，执行了一条非法指令，引用不存在的内存，或者除数是 0 等。在有些系统比如 UNIX 中，进程可以通知操作系统，它希望自行处理某种类型的错误，在这类错误中，进程会收到信号（中断），而不是在这类错误出现时直接终止进程。</p>
<h4 id="被其他进程杀死"><a href="#被其他进程杀死" class="headerlink" title="被其他进程杀死"></a>被其他进程杀死</h4><p>第四个终止进程的原因是，某个进程执行系统调用告诉操作系统杀死某个进程。在 UNIX 中，这个系统调用是 kill。在 Win32 中对应的函数是 <code>TerminateProcess</code>（注意不是系统调用）。</p>
<h3 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h3><p>在一些系统中，当一个进程创建了其他进程后，父进程和子进程就会以某种方式进行关联。子进程它自己就会创建更多进程，从而形成一个进程层次结构。</p>
<h4 id="UNIX-进程体系"><a href="#UNIX-进程体系" class="headerlink" title="UNIX 进程体系"></a>UNIX 进程体系</h4><p>在 UNIX 中，进程和它的所有子进程以及子进程的子进程共同组成一个<strong>进程组</strong>。当用户从键盘中发出一个信号后，该信号被发送给当前与键盘相关的进程组中的所有成员（它们通常是在当前窗口创建的所有活动进程）。每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被信号 kill 掉。</p>
<p>这里有另一个例子，可以用来说明层次的作用，考虑 <code>UNIX</code> 在启动时如何初始化自己。一个称为 <code>init</code> 的特殊进程出现在启动映像中 。当 init 进程开始运行时，它会读取一个文件，文件会告诉它有多少个终端。然后为每个终端创建一个新进程。这些进程等待用户登录。如果登录成功，该登录进程就执行一个 shell 来等待接收用户输入指令，这些命令可能会启动更多的进程，以此类推。因此，整个操作系统中所有的进程都隶属于一个单个以 init 为根的进程树。</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/7.png" style="zoom:67%;"></p>
<h4 id="Windows-进程体系"><a href="#Windows-进程体系" class="headerlink" title="Windows 进程体系"></a>Windows 进程体系</h4><p>相反，Windows 中没有进程层次的概念，Windows 中所有进程都是平等的，唯一类似于层次结构的是在创建进程的时候，父进程得到一个特别的令牌（称为句柄），该句柄可以用来控制子进程。然而，这个令牌可能也会移交给别的操作系统，这样就不存在层次结构了。而在 UNIX 中，进程不能剥夺其子进程的 <code>进程权</code>。（这样看来，还是 Windows 比较<code>渣</code>）。</p>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>尽管每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但是，进程之间仍然需要相互帮助。例如，一个进程的结果可以作为另一个进程的输入，在 shell 命令中</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat chapter1 chapter2 chapter3 | grep tree</span><br></pre></td></tr></table></figure>
<p>第一个进程是 <code>cat</code>，将三个文件级联并输出。第二个进程是 <code>grep</code>，它从输入中选择具有包含关键字 <code>tree</code> 的内容，根据这两个进程的相对速度（这取决于两个程序的相对复杂度和各自所分配到的 CPU 时间片），可能会发生下面这种情况，<code>grep</code> 准备就绪开始运行，但是输入进程还没有完成，于是必须阻塞 grep 进程，直到输入完毕。</p>
<p>当一个进程开始运行时，它可能会经历下面这几种状态</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/0.png" style="zoom:67%;"></p>
<p>图中会涉及三种状态</p>
<ol>
<li><code>运行态</code>，运行态指的就是进程实际占用 CPU 时间片运行时</li>
<li><code>就绪态</code>，就绪态指的是可运行，但因为其他进程正在运行而处于就绪状态</li>
<li><code>阻塞态</code>，除非某种外部事件发生，否则进程不能运行</li>
</ol>
<p>逻辑上来说，运行态和就绪态是很相似的。这两种情况下都表示进程<code>可运行</code>，但是第二种情况没有获得 CPU 时间分片。第三种状态与前两种状态不同的原因是这个进程不能运行，CPU 空闲时也不能运行。</p>
<p>三种状态会涉及四种状态间的切换，在操作系统发现进程<strong>不能继续执行时</strong>会发生<code>状态1</code>的轮转，在某些系统中进程执行系统调用，例如 <code>pause</code>，来获取一个阻塞的状态。在其他系统中包括 UNIX，当进程从管道或特殊文件（例如终端）中读取没有可用的输入时，该进程会被自动终止。</p>
<p>转换 2 和转换 3 都是由进程调度程序（操作系统的一部分）引起的，进程本身不知道调度程序的存在。转换 2 的出现说明进程调度器认定当前进程已经运行了足够长的时间，是时候让其他进程运行 CPU 时间片了。当所有其他进程都运行过后，这时候该是让第一个进程重新获得 CPU 时间片的时候了，就会发生转换 3。</p>
<blockquote>
<p><strong>程序调度指的是，决定哪个进程优先被运行和运行多久，这是很重要的一点</strong>。已经设计出许多算法来尝试平衡系统整体效率与各个流程之间的竞争需求。</p>
</blockquote>
<p>当进程等待的一个外部事件发生时（如从外部输入一些数据后），则发生转换 4。如果此时没有其他进程在运行，则立刻触发转换 3，该进程便开始运行，否则该进程会处于就绪阶段，等待 CPU 空闲后再轮到它运行。</p>
<p>从上面的观点引入了下面的模型</p>
<p> <img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/3.png" style="zoom:67%;"></p>
<p><strong>操作系统最底层的就是调度程序</strong>，在它上面有许多进程。所有关于中断处理、启动进程和停止进程的具体细节都隐藏在调度程序中。事实上，调度程序只是一段非常小的程序。</p>
<h3 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h3><p>操作系统为了执行进程间的切换，会维护着一张表格，这张表就是 <code>进程表(process table)</code>。每个进程占用一个进程表项。该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时所必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样。</p>
<p>下面展示了一个典型系统中的关键字段</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/10.png" style="zoom:67%;"></p>
<p>第一列内容与<code>进程管理</code>有关，第二列内容与 <code>存储管理</code>有关，第三列内容与<code>文件管理</code>有关。</p>
<p>存储管理的 text segment 、 data segment、stack segment 更多了解见下面这篇文章</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&amp;mid=2247484788&amp;idx=1&amp;sn=8a17224cabe09d3bd564dfdf22e2ff5d&amp;chksm=fc45f887cb3271914f0e688a3cce4d7e3ce9077cdde199648e72aa92ad08fba2047b4483b7e8&amp;token=504034995&amp;lang=zh_CN#rd" target="_blank" rel="noopener">程序员需要了解的硬核知识之汇编语言(全)</a></p>
<p>现在我们应该对进程表有个大致的了解了，就可以在对单个 CPU 上如何运行多个顺序进程的错觉做更多的解释。与每一 I/O 类相关联的是一个称作 <code>中断向量(interrupt vector)</code> 的位置（靠近内存底部的固定区域）。它包含中断服务程序的入口地址。假设当一个磁盘中断发生时，用户进程正在运行，则中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器<strong>压入堆栈</strong>，计算机随即<strong>跳转到中断向量所指示的地址</strong>。这就是硬件所做的事情。然后软件就随即接管一切剩余的工作。</p>
<p>当中断结束后，操作系统会调用一个 C 程序来处理中断剩下的工作。在完成剩下的工作后，会使某些进程就绪，接着调用调度程序，决定随后运行哪个进程。然后将控制权转移给一段汇编语言代码，<strong>为当前的进程装入寄存器值以及内存映射并启动该进程运行</strong>，下面显示了中断处理和调度的过程。</p>
<ol>
<li>硬件压入堆栈程序计数器等</li>
<li>硬件从中断向量装入新的程序计数器</li>
<li>汇编语言过程保存寄存器的值</li>
<li>汇编语言过程设置新的堆栈</li>
<li>C 中断服务器运行（典型的读和缓存写入）</li>
<li>调度器决定下面哪个程序先运行</li>
<li>C 过程返回至汇编代码</li>
<li>汇编语言过程开始运行新的当前进程</li>
</ol>
<p>一个进程在执行过程中可能被中断数千次，但关键每次中断后，被中断的进程都返回到与中断发生前完全相同的状态。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>在传统的操作系统中，每个进程都有一个地址空间和一个控制线程。事实上，这是大部分进程的定义。不过，在许多情况下，经常存在同一地址空间中运行多个控制线程的情形，这些线程就像是分离的进程。下面我们就着重探讨一下什么是线程</p>
<h3 id="线程的使用"><a href="#线程的使用" class="headerlink" title="线程的使用"></a>线程的使用</h3><p>或许这个疑问也是你的疑问，为什么要在进程的基础上再创建一个线程的概念，准确的说，这其实是进程模型和线程模型的讨论，回答这个问题，可能需要分三步来回答</p>
<ul>
<li>多线程之间会<strong>共享同一块地址空间</strong>和所有可用数据的能力，这是进程所不具备的</li>
<li>线程要比进程<code>更轻量级</code>，由于线程更轻，所以它比进程更容易创建，也更容易撤销。在许多系统中，创建一个线程要比创建一个进程快 10 - 100 倍。</li>
<li>第三个原因可能是性能方面的探讨，如果多个线程都是 CPU 密集型的，那么并不能获得性能上的增强，但是如果存在着大量的计算和大量的 I/O 处理，拥有多个线程能在这些活动中彼此重叠进行，从而会加快应用程序的执行速度</li>
</ul>
<h4 id="多线程解决方案"><a href="#多线程解决方案" class="headerlink" title="多线程解决方案"></a>多线程解决方案</h4><p>现在考虑一个线程使用的例子：一个万维网服务器，对页面的请求发送给服务器，而所请求的页面发送回客户端。在多数 web 站点上，某些页面较其他页面相比有更多的访问。例如，索尼的主页比任何一个照相机详情介绍页面具有更多的访问，Web 服务器可以把获得大量访问的页面集合<strong>保存在内存中</strong>，避免到磁盘去调入这些页面，从而改善性能。这种页面的集合称为 <code>高速缓存(cache)</code>，高速缓存也应用在许多场合中，比如说 CPU 缓存。</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/11.png" style="zoom:67%;"></p>
<p>上面是一个 web 服务器的组织方式，一个叫做 <code>调度线程(dispatcher thread)</code> 的线程从网络中读入工作请求，在调度线程检查完请求后，它会选择一个空闲的（阻塞的）工作线程来处理请求，通常是将消息的指针写入到每个线程关联的特殊字中。然后调度线程会唤醒正在睡眠中的工作线程，把工作线程的状态从阻塞态变为就绪态。</p>
<p>当工作线程启动后，它会检查请求是否在 web 页面的高速缓存中存在，这个高速缓存是所有线程都可以访问的。如果高速缓存不存在这个 web 页面的话，它会调用一个 <code>read</code> 操作从磁盘中获取页面并且阻塞线程直到磁盘操作完成。当线程阻塞在硬盘操作的期间，为了完成更多的工作，调度线程可能挑选另一个线程运行，也可能把另一个当前就绪的工作线程投入运行。</p>
<p>这种模型允许将服务器编写为顺序线程的集合，在分派线程的程序中<strong>包含一个死循环</strong>，该循环用来获得工作请求并且把请求派给工作线程。每个<strong>工作线程的代码包含一个从调度线程接收的请求</strong>，并且检查 web 高速缓存中是否存在所需页面，如果有，<strong>直接把该页面返回给客户</strong>，接着工作线程阻塞，等待一个新请求的到达;如果没有，工作线程就<strong>从磁盘调入该页面</strong>，将该页面返回给客户机，然后工作线程阻塞，等待一个新请求。</p>
<p>下面是调度线程和工作线程的代码，这里假设 TRUE 为常数 1 ，buf 和 page 分别是保存工作请求和 Web 页面的相应结构。</p>
<p><strong>调度线程的大致逻辑</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">  <span class="comment">// 一个死循环，始终在等待请求，然后处理请求</span></span><br><span class="line">  get_next_request(&amp;buf);</span><br><span class="line">  handoff_work(&amp;buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>工作线程的大致逻辑</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">  wait_for_work(&amp;buf);</span><br><span class="line">  look_for_page_in_cache(&amp;buf,&amp;page);</span><br><span class="line">  <span class="comment">// 如果 page 不在高速缓存当中的话，就从磁盘中读取</span></span><br><span class="line">  <span class="keyword">if</span>(page_not_in_cache(&amp;page))&#123;</span><br><span class="line">    read_page_from_disk(&amp;buf,&amp;page);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _page(&amp;page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单线程解决方案"><a href="#单线程解决方案" class="headerlink" title="单线程解决方案"></a>单线程解决方案</h4><p>现在考虑没有多线程的情况下，如何编写 Web 服务器。我们很容易的就想象为单个线程了，Web 服务器的主循环获取请求并检查请求，并争取在下一个请求之前完成工作。在等待磁盘操作时，服务器空转，并且不处理任何到来的其他请求。结果会导致每秒中只有很少的请求被处理，所以这个例子能够说明<strong>多线程提高了程序的并行性</strong>并提高了程序的性能。</p>
<h4 id="状态机解决方案"><a href="#状态机解决方案" class="headerlink" title="状态机解决方案"></a>状态机解决方案</h4><p>到现在为止，我们已经有了两种解决方案，单线程解决方案和多线程解决方案，其实还有一种解决方案就是 <code>状态机解决方案</code>，它的流程如下</p>
<p>如果目前只有一个非阻塞版本的 read 系统调用可以使用，那么当请求到达服务器时，这个唯一的 read 调用的线程会进行检查，如果能够从高速缓存中得到响应，那么直接返回，如果不能，则启动一个<strong>非阻塞的磁盘操作</strong></p>
<p>服务器在表中<strong>记录当前请求的状态</strong>，然后进入并获取下一个事件，紧接着下一个事件可能就是一个新工作的请求或是磁盘对先前操作的回答。如果是新工作的请求，那么就开始处理请求；如果是磁盘的响应，就从表中取出对应的状态信息进行处理。对于非阻塞式磁盘 I/O 而言，这种响应一般都是信号中断响应。</p>
<p>每次服务器从某个请求工作的状态切换到另一个状态时，都必须显式地保存或者重新装入相应的计算状态。这里，每个计算都有一个被保存的状态，存在一个会发生且使得相关状态发生改变的事件集合，我们把这类设计称为<code>有限状态机(finite-state machine)</code>，有限状态机广泛的应用在计算机科学中。</p>
<p>这三种解决方案各有各的特性</p>
<p>多线程使得顺序进程的思想得以保留下来，并且实现了并行性，但是<strong>顺序进程会阻塞系统调用</strong>；</p>
<p>单线程服务器保留了阻塞系统的简易性，但是却放弃了性能。</p>
<p>有限状态机的处理方法运用了非阻塞调用和中断，通过并行实现了高性能，但是给编程增加了困难。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模型</th>
<th>特性</th>
</tr>
</thead>
<tbody>
<tr>
<td>单线程</td>
<td>无并行性，性能较差，阻塞系统调用</td>
</tr>
<tr>
<td>多线程</td>
<td>有并行性，阻塞系统调用</td>
</tr>
<tr>
<td>有限状态机</td>
<td>有并行性，非阻塞系统调用、中断</td>
</tr>
</tbody>
</table>
</div>
<h3 id="经典的线程模型"><a href="#经典的线程模型" class="headerlink" title="经典的线程模型"></a>经典的线程模型</h3><p>理解进程的另一个角度是，用某种方法把相关的资源集中在一起。<strong>进程有存放程序正文和数据以及其他资源的地址空间</strong>。这些资源包括打开的文件、子进程、即将发生的定时器、信号处理程序、账号信息等。把这些信息放在进程中会比较容易管理。</p>
<p>另一个概念是，进程中拥有一个执行的线程，通常简写为 <code>线程(thread)</code>。线程会有程序<strong>计数器</strong>，用来<strong>记录接着要执行哪一条指令</strong>；线程还拥有<strong>寄存器</strong>，用来<strong>保存线程当前正在使用的变量</strong>；线程还会有<strong>堆栈</strong>，用来<strong>记录程序的执行路径</strong>。尽管线程必须在某个进程中执行，但是进程和线程完完全全是两个不同的概念，并且他们可以分开处理。进程用于把资源集中在一起，而线程则是 CPU 上调度执行的实体。</p>
<p>线程给进程模型增加了一项内容，即在同一个进程中，允许彼此之间有较大的独立性且互不干扰。在一个进程中并行运行多个线程类似于在一台计算机上运行多个进程。在多个线程中，<strong>各个线程共享同一地址空间和其他资源</strong>。在多个进程中，进程共享物理内存、磁盘、打印机和其他资源。因为线程会包含有一些进程的属性，所以线程被称为<code>轻量的进程(lightweight processes)</code>。<code>多线程(multithreading)</code>一词还用于描述在同一进程中多个线程的情况。</p>
<p>下图我们可以看到<strong>三个传统的进程</strong>，每个进程有自己的地址空间和单个控制线程。每个线程都在不同的地址空间中运行</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/12.png" style="zoom:67%;"></p>
<p>下图中，我们可以看到这个进程有三个线程的情况。每个线程都在<strong>相同的地址</strong>空间中运行。</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/13.png" style="zoom:67%;"></p>
<p>线程不像是进程那样具备较强的独立性。<strong>同一个进程中的所有线程</strong>都会<strong>有完全一样的地址空间</strong>，这意味着它们也共享同样的全局变量。由于每个线程都可以访问进程地址空间内每个内存地址，<strong>因此一个线程可以读取、写入甚至擦除另一个线程的堆栈</strong>。线程之间除了共享同一内存空间外，还具有如下不同的内容</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/14.png" style="zoom:67%;"></p>
<p>上图左边的是同一个进程中<strong>每个线程共享的内容</strong>，上图右边是<strong>每个线程中各自有的内容</strong>。也就是说左边的列表是<strong>进程的属性</strong>，右边的列表是<strong>线程的属性</strong>。</p>
<p>和进程一样，线程可以处于下面这几种状态：<strong>运行中、阻塞、就绪和终止（进程图中没有画）</strong>。</p>
<p>正在运行的线程拥有 CPU 时间片并且状态是运行中。一个被阻塞的线程会等待某个释放它的事件。例如，当一个线程执行从键盘读入数据的系统调用时，该线程就被阻塞直到有输入为止。线程通常会被阻塞，直到它等待某个外部事件的发生或者有其他线程来释放它。<strong>线程之间的状态转换和进程之间的状态转换是一样的</strong>。</p>
<p>每个线程都会有自己的堆栈，如下图所示</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/15.png" style="zoom:67%;"></p>
<h4 id="线程系统调用"><a href="#线程系统调用" class="headerlink" title="线程系统调用"></a>线程系统调用</h4><p>进程通常会从当前的某个单线程开始，然后这个线程通过调用一个库函数（比如 <code>thread_create</code>）创建新的线程。线程创建的函数会要求<strong>指定新创建线程的名称</strong>。创建的线程通常都<strong>返回一个线程标识符</strong>，该标识符就是新线程的名字。</p>
<p>当一个线程完成工作后，可以通过调用一个函数（比如 <code>thread_exit</code>）来退出。紧接着<strong>线程消失，状态变为终止</strong>，不能再进行调度。在某些线程的运行过程中，可以通过调用函数例如 <code>thread_join</code> ，表示一个线程可以等待另一个线程退出。这个过程阻塞调用线程直到等待特定的线程退出。在这种情况下，线程的创建和终止非常类似于进程的创建和终止。</p>
<p>另一个常见的线程是调用 <code>thread_yield</code>，它允许线程自动放弃 CPU 从而让另一个线程运行。这样一个调用还是很重要的，因为不同于进程，线程是无法利用时钟中断强制让线程让出 CPU 的。</p>
<h3 id="POSIX-线程"><a href="#POSIX-线程" class="headerlink" title="POSIX 线程"></a>POSIX 线程</h3><p>为了使编写可移植线程程序成为可能，IEEE 在 IEEE 标准 1003.1c 中定义了线程标准。线程包被定义为 <code>Pthreads</code>。大部分的 UNIX 系统支持它。这个标准定义了 60 多种功能调用，一一列举不太现实，下面为你列举了一些常用的系统调用。</p>
<blockquote>
<p><strong>POSIX线程</strong>（通常称为<strong>pthreads</strong>）是一种独立于语言而存在的执行模型，以及并行执行模型。它允许程序控制时间上重叠的多个不同的工作流程。每个工作流程都称为一个线程，可以通过调用POSIX Threads API来实现对这些流程的创建和控制。可以把它理解为线程的标准。</p>
<p>POSIX Threads 的实现在许多类似且符合POSIX的操作系统上可用，例如 <strong>FreeBSD、NetBSD、OpenBSD、Linux、macOS、Android、Solaris</strong>，它在现有 Windows API 之上实现了<strong>pthread</strong>。</p>
<p>IEEE 是世界上最大的技术专业组织，致力于为人类的利益而发展技术。</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>线程调用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pthread_create</td>
<td>创建一个新线程</td>
</tr>
<tr>
<td>pthread_exit</td>
<td>结束调用的线程</td>
</tr>
<tr>
<td>pthread_join</td>
<td>等待一个特定的线程退出</td>
</tr>
<tr>
<td>pthread_yield</td>
<td>释放 CPU 来运行另外一个线程</td>
</tr>
<tr>
<td>pthread_attr_init</td>
<td>创建并初始化一个线程的属性结构</td>
</tr>
<tr>
<td>pthread_attr_destory</td>
<td>删除一个线程的属性结构</td>
</tr>
</tbody>
</table>
</div>
<p>所有的 Pthreads 都有特定的属性，每一个都含有<strong>标识符</strong>、<strong>一组寄存器</strong>（包括程序计数器）和<strong>一组存储</strong>在结构中的属性。这个属性包括堆栈大小、调度参数以及其他线程需要的项目。</p>
<p>新的线程会通过 <code>pthread_create</code> 创建，新创建的线程的标识符会作为函数值返回。这个调用非常像是 UNIX 中的 <code>fork</code> 系统调用（除了参数之外），其中线程标识符起着 <code>PID</code> 的作用，这么做的目的是为了和其他线程进行区分。</p>
<p>当线程完成指派给他的工作后，会通过 <code>pthread_exit</code> 来终止。这个调用会<strong>停止线程并释放堆栈</strong>。</p>
<p>一般一个线程在继续运行前需要等待另一个线程完成它的工作并退出。可以通过 <code>pthread_join</code> 线程调用来等待别的特定线程的终止。而要等待线程的线程标识符作为一个参数给出。</p>
<p>有时会出现这种情况：一个线程逻辑上没有阻塞，但感觉上它已经运行了足够长的时间并且希望给另外一个线程机会去运行。这时候可以通过 <code>pthread_yield</code> 来完成。</p>
<p>下面两个线程调用是处理属性的。<code>pthread_attr_init</code> 建立关联一个线程的属性结构并初始化成默认值，这些值（例如优先级）可以通过修改属性结构的值来改变。</p>
<p>最后，<code>pthread_attr_destroy</code> 删除一个线程的结构，释放它占用的内存。它不会影响调用它的线程，这些线程会一直存在。</p>
<p>为了更好的理解 pthread 是如何工作的，考虑下面这个例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMBER_OF_THREADS 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">print_hello_world</span><span class="params">(vvoid *tid)</span></span>&#123;</span><br><span class="line">  <span class="comment">/* 输出线程的标识符，然后退出 */</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello World. Greetings from thread %d\n"</span>,tid);</span><br><span class="line">  pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">  <span class="comment">/* 主程序创建 10 个线程，然后退出 */</span></span><br><span class="line">  <span class="keyword">pthread_t</span> threads[NUMBER_OF_THREADS];</span><br><span class="line">  <span class="keyword">int</span> status,i;</span><br><span class="line"> 	</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; NUMBER_OF_THREADS;i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Main here. Creating thread %d\n"</span>,i);</span><br><span class="line">    status = pthread_create(&amp;threads[i], <span class="literal">NULL</span>, print_hello_world, (<span class="keyword">void</span> *)i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(status != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Oops. pthread_create returned error code %d\n"</span>,status);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主线程在宣布它的指责之后，循环 <code>NUMBER_OF_THREADS</code> 次，每次创建一个新的线程。如果线程创建失败，会打印出一条信息后退出。在创建完成所有的工作后，主程序退出。</p>
<h3 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h3><p>主要有三种实现方式</p>
<ul>
<li>在用户空间中实现线程；</li>
<li>在内核空间中实现线程；</li>
<li>在用户和内核空间中混合实现线程。</li>
</ul>
<p>下面我们分开讨论一下</p>
<h4 id="在用户空间中实现线程"><a href="#在用户空间中实现线程" class="headerlink" title="在用户空间中实现线程"></a>在用户空间中实现线程</h4><p>第一种方法是把整个线程包放在用户空间中，内核对线程一无所知，它不知道线程的存在。所有的这类实现都有<strong>同样的通用结构</strong></p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/16.png" style="zoom:67%;"></p>
<p>线程是在系统之上运行，运行时系统是管理线程过程的集合，包括前面提到的四个过程： <code>pthread_create</code>, <code>pthread_exit</code>, <code>pthread_join</code> 和 <code>pthread_yield</code>。</p>
<blockquote>
<p><code>运行时系统(Runtime System)</code> 也叫做运行时环境，该运行时系统提供了程序在其中运行的环境。此环境可能会解决许多问题，包括应用程序内存的布局，程序如何访问变量，在过程之间传递参数的机制，与操作系统的接口等等。编译器根据特定的运行时系统进行假设以生成正确的代码。通常，运行时系统将负责设置和管理堆栈，并且会包含诸如垃圾收集，线程或语言内置的其他动态的功能。</p>
</blockquote>
<p>在用户空间管理线程时，每个进程需要有其专用的<strong>线程表(thread table)</strong>，用来跟踪该进程中的线程。这些表和内核中的进程表类似，不过它<strong>仅仅记录各个线程的属性</strong>，如每个线程的程序计数器、堆栈指针、寄存器和状态。该线程标由运行时系统统一管理。当一个线程转换到就绪状态或阻塞状态时，在该<strong>线程表中存放重新启动该线程的所有信息</strong>，与内核在进程表中存放的信息完全一样。</p>
<h4 id="在用户空间实现线程的优势"><a href="#在用户空间实现线程的优势" class="headerlink" title="在用户空间实现线程的优势"></a>在用户空间实现线程的优势</h4><p>在用户空间中实现线程要比在内核空间中实现线程具有这些方面的优势：考虑如果在线程完成时或者是在调用 <code>pthread_yield</code> 时，必要时会进程线程切换，然后线程的信息会被保存在运行时环境所提供的线程表中，然后，线程调度程序来选择另外一个需要运行的线程。保存线程的状态和调度程序都是<strong>本地过程，所以启动他们比进行内核调用效率更高。因而不需要切换到内核，也就不需要上下文切换，也不需要对内存高速缓存进行刷新，因为线程调度非常便捷，因此效率比较高</strong>。</p>
<p>在用户空间实现线程还有一个优势就是<strong>它允许每个进程有自己定制的调度算法</strong>。例如在某些应用程序中，那些具有垃圾收集线程的应用程序就不用担心自己线程会不会在不合适的时候停止，这是一个优势。用户线程还具有<strong>较好的可扩展性</strong>，因为内核空间中的内核线程需要一些表空间和堆栈空间，如果内核线程数量比较大，容易造成问题。</p>
<h4 id="在用户空间实现线程的劣势"><a href="#在用户空间实现线程的劣势" class="headerlink" title="在用户空间实现线程的劣势"></a>在用户空间实现线程的劣势</h4><p>尽管在用户空间实现线程会具有一定的性能优势，但是劣势还是很明显的，你如何实现<strong>阻塞系统调用</strong>(阻塞调用是指调用结果返回之前，当前线程会被挂起)呢？假设在还没有任何键盘输入之前，一个线程读取键盘，让线程进行系统调用是不可能的，因为这会停止所有的线程。所以，<strong>使用线程的一个目标是能够让线程进行阻塞调用，并且要避免被阻塞的线程影响其他线程</strong>。</p>
<p>与阻塞调用类似的问题是<strong>缺页中断</strong>问题。实际上，计算机并不会把所有的程序都一次性的放入内存中，如果某个程序发生函数调用或者跳转指令到了一条不在内存的指令上，就会发生页面故障，而操作系统将到磁盘上取回这个丢失的指令，这就称为<strong>缺页故障</strong>。而在对所需的指令进行读入和执行时，<strong>相关的进程就会被阻塞</strong>。如果只有一个线程引起页面故障，<strong>内核由于甚至不知道有线程存在，通常会把整个进程阻塞直到磁盘 I/O 完成为止，尽管其他的线程是可以运行的</strong>。</p>
<p>另外一个问题是，<strong>如果一个线程开始运行，该线程所在进程中的其他线程都不能运行</strong>，除非第一个线程自愿的放弃 CPU，在一个单进程内部，没有时钟中断，所以不可能使用轮转调度的方式调度线程。除非其他线程能够以自己的意愿进入运行时环境，否则调度程序没有可以调度线程的机会。</p>
<h3 id="在内核中实现线程"><a href="#在内核中实现线程" class="headerlink" title="在内核中实现线程"></a>在内核中实现线程</h3><p>现在我们考虑使用内核来实现线程的情况，此时不再需要运行时环境了。另外，每个进程中也没有线程表。相反，<strong>在内核中会有用来记录系统中所有线程的线程表</strong>。当某个线程希望创建一个新线程或撤销一个已有线程时，它会进行一个<strong>系统调用</strong>，这个系统调用<strong>通过对线程表的更新来完成线程创建或销毁工作</strong></p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/17.png" style="zoom:67%;"></p>
<p><strong>内核中的线程表持有每个线程的寄存器、状态和其他信息</strong>。这些信息和用户空间中的线程信息相同，但是位置却被放在了内核中而不是用户空间中。另外，内核还<strong>维护了一张进程表用来跟踪系统状态</strong>。</p>
<p>所有能够阻塞的调用都会通过系统调用的方式来实现，当一个线程阻塞时，内核可以进行选择，是运行在同一个进程中的另一个线程（如果有就绪线程的话）还是运行一个另一个进程中的线程。但是在用户实现中，运行时系统始终运行自己的线程，直到内核剥夺它的 CPU 时间片（或者没有可运行的线程存在了）为止。</p>
<p>由于在内核中创建或者销毁线程的<strong>开销比较大</strong>，所以某些系统会采用<strong>可循环利用的方式来回收线程</strong>。当某个线程被<strong>销毁时</strong>，就把它<strong>标志为不可运行的状态</strong>，但是其内部结构没有受到影响；稍后，在必须创建一个新线程时，就会<strong>重新启用旧线程，把它标志为可用状态</strong>。</p>
<p>如果某个进程中的线程造成缺页故障后，内核很容易的就能检查出来<strong>是否有其他可运行的线程</strong>，如果有的话，在等待所需要的页面从磁盘读入时，就选择一个可运行的线程运行。这样做的<strong>缺点是系统调用的代价比较大</strong>，所以如果线程的操作（创建、终止）比较多，就<strong>会带来很大的开销</strong>。 </p>
<h3 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h3><p>结合用户空间和内核空间的优点，设计人员采用了一种<strong>内核级线程</strong>的方式，然后将用户级线程与某些或者全部内核线程多路复用起来</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/18.png" style="zoom:67%;"></p>
<p>在这种模型中，编程人员可以<strong>自由控制用户线程和内核线程的数量</strong>，具有<strong>很大的灵活度</strong>。采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。</p>
<h3 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h3><div class="table-container">
<table>
<thead>
<tr>
<th>区别</th>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody>
<tr>
<td>关系</td>
<td>进程可以有多个线程</td>
<td>线程只能属于一个进程</td>
</tr>
<tr>
<td>资源</td>
<td>进程之间具有独立的内存单元</td>
<td>多个线程共享一个进程的内存</td>
</tr>
<tr>
<td>系统开销</td>
<td>进程创建、切换的开销大</td>
<td>线程创建、切换开销小</td>
</tr>
<tr>
<td>通信</td>
<td>七种通讯</td>
<td>直接读取进程数据段(.data)</td>
</tr>
<tr>
<td>调试</td>
<td>简单、可靠信高</td>
<td>调试相对复杂</td>
</tr>
<tr>
<td>相互间影响</td>
<td>进程之间不会相互影响</td>
<td>一个线程挂掉可能导致整个进程挂掉</td>
</tr>
<tr>
<td>适用于</td>
<td>多核、多机分布</td>
<td>多核分布</td>
</tr>
</tbody>
</table>
</div>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>进程是需要频繁的和其他进程进行交流的。例如，在一个 shell 管道中，第一个进程的输出必须传递给第二个进程，这样沿着管道进行下去。因此，进程之间如果需要通信的话，必须要使用一种良好的数据结构以至于不能被中断。下面我们会一起讨论有关<strong>进程间通信(Inter Process Communication, IPC)</strong> 的问题。</p>
<p>关于进程间的通信，这里有三个问题</p>
<ul>
<li>上面提到了第一个问题，那就是<strong>一个进程如何传递消息给其他进程</strong>。</li>
<li>第二个问题是<strong>如何确保两个或多个线程之间不会相互干扰</strong>。例如，两个航空公司都试图为不同的顾客抢购飞机上的最后一个座位。</li>
<li>第三个问题是<strong>数据的先后顺序的问题</strong>，如果进程 A 产生数据并且进程 B 打印数据。则进程 B 打印数据之前需要先等 A 产生数据后才能够进行打印。</li>
</ul>
<p>需要注意的是，这三个问题中的后面两个问题同样也适用于线程</p>
<p>第一个问题在线程间比较好解决，因为它们共享一个地址空间，它们具有相同的运行时环境，可以想象你在用高级语言编写多线程代码的过程中，线程通信问题是不是比较容易解决？</p>
<p>另外两个问题也同样适用于线程，同样的问题可用同样的方法来解决。我们后面会慢慢讨论这三个问题，你现在脑子中大致有个印象即可。</p>
<h3 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h3><p>在一些操作系统中，协作的进程可能共享一些彼此都能读写的公共资源。公共资源可能在内存中也可能在一个共享文件。为了讲清楚进程间是如何通信的，这里我们举一个例子：一个后台打印程序。当一个进程需要打印某个文件时，它会将文件名放在一个特殊的<strong>后台目录(spooler directory)</strong>中。另一个进程 <strong>打印后台进程(printer daemon)</strong>  会定期的检查是否需要文件被打印，如果有的话，就打印并将该文件名从目录下删除。</p>
<p>假设我们的后台目录有非常多的 <code>槽位(slot)</code>，编号依次为 0，1，2，…，每个槽位存放一个文件名。同时假设有两个共享变量：<br><code>out</code>，指向下一个需要打印的文件<br><code>in</code>，指向目录中下个空闲的槽位<br>可以把这两个文件保存在一个所有进程都能访问的文件中，该文件的长度为两个字。在某一时刻，0 至 3 号槽位空，4 号至 6 号槽位被占用。在同一时刻，进程 A 和 进程 B 都决定将一个文件排队打印，情况如下</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/19.png" style="zoom:67%;"></p>
<p><code>墨菲法则(Murphy)</code> 中说过，任何可能出错的地方终将出错，这句话生效时，可能发生如下情况。</p>
<p>进程 A 读到 in 的值为 7，将 7 存到一个局部变量 <code>next_free_slot</code> 中。此时发生一次时钟中断，CPU 认为进程 A 已经运行了足够长的时间，决定切换到进程 B 。进程 B 也读取 in 的值，发现是 7，然后进程 B 将 7 写入到自己的局部变量 <code>next_free_slot</code> 中，在这一时刻两个进程都认为下一个可用槽位是 7 。</p>
<p>进程 B 现在继续运行，它会将打印文件名写入到 slot 7 中，然后把 in 的指针更改为 8 ，然后进程 B 离开去做其他的事情</p>
<p>现在进程 A 开始恢复运行，由于进程 A 通过检查 <code>next_free_slot</code>也发现 slot 7 的槽位是空的，于是将打印文件名存入 slot 7 中，然后把 in 的值更新为 8 ，由于 slot 7 这个槽位中已经有进程 B 写入的值，所以<strong>进程 A 的打印文件名会把进程 B 的文件覆盖</strong>，由于打印机内部是无法发现是哪个进程更新的，它的功能比较局限，所以这时候<strong>进程 B 永远无法打印输出</strong>，类似这种情况，<strong>即两个或多个线程同时对一共享数据进行修改，从而影响程序运行的正确性时，这种就被称为竞态条件(race condition)</strong>。调试竞态条件是一种非常困难的工作，因为绝大多数情况下程序运行良好，但在极少数的情况下会发生一些无法解释的奇怪现象。</p>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>不仅共享资源会造成竞态条件，事实上共享文件、共享内存也会造成竞态条件、那么该如何避免呢？或许一句话可以概括说明：<strong>禁止一个或多个进程在同一时刻对共享资源（包括共享内存、共享文件等）进行读写</strong>。换句话说，我们需要一种 <code>互斥(mutual exclusion)</code> 条件，这也就是说，如果一个进程在某种方式下使用共享变量和文件的话，除该进程之外的其他进程就禁止做这种事（访问统一资源）。上面问题的纠结点在于，在进程 A 对共享变量的使用未结束之前进程 B 就使用它。在任何操作系统中，为了实现互斥操作而选用适当的原语是一个主要的设计问题，接下来我们会着重探讨一下。</p>
<p>避免竞争问题的条件可以用一种抽象的方式去描述。大部分时间，进程都会忙于内部计算和其他不会导致竞争条件的计算。然而，有时候进程会访问共享内存或文件，或者做一些能够导致竞态条件的操作。我们把<strong>对共享内存进行访问的程序片段</strong>称作 <code>临界区域(critical region)</code> 或 <code>临界区(critical section)</code>。如果我们能够正确的操作，<strong>使两个不同进程不可能同时处于临界区</strong>，就能避免竞争条件，这也是从操作系统设计角度来进行的。</p>
<p>尽管上面这种设计避免了竞争条件，但是不能确保并发线程同时访问共享数据的正确性和高效性。一个好的解决方案，应该包含下面四种条件</p>
<ol>
<li>任何时候两个进程不能同时处于临界区</li>
<li>不应对 CPU 的速度和数量做任何假设</li>
<li>位于临界区外的进程不得阻塞其他进程</li>
<li>不能使任何进程无限等待进入临界区</li>
</ol>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/20.png" style="zoom:67%;"></p>
<p>从抽象的角度来看，我们通常希望进程的行为如上图所示</p>
<ul>
<li>在 t1 时刻，进程 A 进入临界区</li>
<li>在 t2 的时刻，进程 B 尝试进入临界区，因为此时进程 A 正在处于临界区中，所以进程 B 会阻塞</li>
<li>t3 时刻进程 A 离开临界区，此时进程 B 能够允许进入临界区。</li>
<li>在 t4 时刻，进程 B 离开临界区，系统恢复到没有进程的原始状态。</li>
</ul>
<h3 id="忙等互斥"><a href="#忙等互斥" class="headerlink" title="忙等互斥"></a>忙等互斥</h3><p>下面我们会继续探讨实现互斥的各种设计，在这些方案中，当一个进程正忙于更新其临界区的共享内存时，没有其他进程会进入其临界区，也不会造成影响。</p>
<h4 id="屏蔽中断"><a href="#屏蔽中断" class="headerlink" title="屏蔽中断"></a>屏蔽中断</h4><p>在单处理器系统上，最简单的解决方案是让每个进程在进入临界区后<strong>立即</strong><code>屏蔽所有中断</code>，并在离开临界区之前重新启用它们。屏蔽中断后，时钟中断也会被屏蔽。CPU 只有发生时钟中断或其他中断时才会进行进程切换。这样，<strong>在屏蔽中断后 CPU 不会切换到其他进程</strong>。所以，一旦某个进程屏蔽中断之后，它就可以检查和修改共享内存，而不用担心其他进程介入访问共享数据。</p>
<p>这个方案可行吗？进程进入临界区域是由谁决定的呢？不是用户进程吗？当进程进入临界区域后，用户进程关闭中断，如果经过一段较长时间后进程没有离开，那么中断不就一直启用不了，结果会如何？<strong>可能会造成整个系统的终止</strong>。而且如果是多处理器的话，屏蔽中断仅仅对执行 <code>disable</code> 指令的 CPU 有效。<strong>其他 CPU 仍将继续运行，并可以访问共享内存。</strong></p>
<p>另一方面，对内核来说，当它在执行更新变量或列表的几条指令期间将中断屏蔽是很方便的。例如，如果多个进程处理就绪列表中的时候发生中断，则可能会发生竞态条件的出现。所以，<strong>屏蔽中断对于操作系统本身来说是一项很有用的技术，但是对于用户线程来说，屏蔽中断却不是一项通用的互斥机制。</strong></p>
<h4 id="锁变量"><a href="#锁变量" class="headerlink" title="锁变量"></a>锁变量</h4><p>作为第二种尝试，可以寻找一种<strong>软件层面</strong>解决方案。考虑有单个共享的（锁）变量，初始为值为 0 。当一个线程想要进入临界区时，它首先会查看锁的值是否为 0 ，如果锁的值是 0 ，进程会把它设置为 1 并让进程进入临界区。如果锁的状态是 1，进程会等待直到锁变量的值变为 0 。因此</p>
<ul>
<li>锁变量的值是 0 则意味着没有线程进入临界区</li>
<li>如果是 1 则意味着有进程在临界区内。</li>
</ul>
<p>我们对上图修改后，如下所示</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/21.png" style="zoom:67%;"></p>
<p>这种设计方式是否正确呢？是否存在纰漏呢？</p>
<p>假设一个进程读出锁变量的值并发现它为 0 ，而恰好在它将其设置为 1 之前，另一个进程调度运行，读出锁的变量为0 ，并将锁的变量设置为 1 。然后第一个线程运行，把锁变量的值再次设置为 1，此时，临界区域就会有两个进程在同时运行。</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/22.png" style="zoom:67%;"></p>
<p>也许有的读者可以这么认为，在进入前检查一次，在要离开的临界区再检查一次不就解决了吗？实际上这种情况也是于事无补，因为在第二次检查期间其他线程仍有可能修改锁变量的值，换句话说，这种 <code>set-before-check</code> 不是一种 <code>原子性</code> 操作，所以同样还会发生竞争条件。</p>
<h4 id="严格轮询法"><a href="#严格轮询法" class="headerlink" title="严格轮询法"></a>严格轮询法</h4><p>第三种互斥的方式先抛出来一段代码，这里的程序是用 C 语言编写，之所以采用 C 是因为操作系统普遍是用 C 来编写的（偶尔会用 C++），而基本不会使用 Java 、Modula3 或 Pascal 这样的语言，Java 中的 native 关键字底层也是 C 或 C++ 编写的源码。对于编写操作系统而言，需要使用 C 语言这种强大、高效、可预知和有特性的语言，而对于 Java ，它是不可预知的，因为它在关键时刻会用完存储器，而在不合适的时候会调用垃圾回收机制回收内存。在 C 语言中，这种情况不会发生，C 语言中不会主动调用垃圾回收回收内存。</p>
<p><strong>进程 0 的代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">turn</span> != <span class="number">0</span>)&#123;</span><br><span class="line">    critical_region();<span class="comment">/* 进入临界区 */</span></span><br><span class="line">    <span class="built_in">turn</span> = <span class="number">1</span>;</span><br><span class="line">    noncritical_region();<span class="comment">/* 离开临界区 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>进程 1 的代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">turn</span> != <span class="number">1</span>)&#123;</span><br><span class="line">    critical_region();</span><br><span class="line">    <span class="built_in">turn</span> = <span class="number">0</span>;</span><br><span class="line">    noncritical_region();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面代码中，变量 <code>turn</code>，初始值为 0 ，用于记录轮到哪个进程进入临界区，并检查或更新共享内存。开始时，进程 0 检查 <code>turn</code>，发现其值为 0 ，于是进入临界区。进程 1 也发现其值为 0 ，所以在一个等待循环中不停的测试 turn，<strong>看其值何时变为 1</strong>。连续检查一个变量<strong>直到某个值出现为止</strong>，这种方法称为 <code>忙等待(busywaiting)</code>。由于这种<strong>方式浪费 CPU 时间</strong>，所以这种方式通常应该要避免。只有在有理由认为等待时间是非常短的情况下，才能够使用忙等待。用于忙等待的锁，称为 <code>自旋锁(spinlock)</code>。</p>
<p>进程 0 离开临界区时，它将 turn 的值设置为 1，以便允许进程 1 进入其临界区。假设进程 1 很快便离开了临界区，则此时两个进程都处于临界区之外，turn 的值又被设置为 0 。现在进程 0 很快就执行完了整个循环，它退出临界区，并将 turn 的值设置为 1。此时，turn 的值为 1，两个进程都在其临界区外执行。</p>
<p>突然，进程 0 结束了非临界区的操作并返回到循环的开始。但是，这时它不能进入临界区，因为 turn 的当前值为 1，此时进程 1 还忙于非临界区的操作，进程 0 只能继续 while 循环，直到进程 1 把 turn 的值改为 0 。这说明，在一个进程比另一个进程执行速度慢了很多的情况下，轮流进入临界区并不是一个好的方法。</p>
<p>这种情况违反了前面的叙述 3 ，即 <strong>位于临界区外的进程不得阻塞其他进程</strong>，进程 0 被一个临界区外的进程阻塞。由于违反了第三条，所以也不能作为一个好的方案。</p>
<h4 id="Peterson-解法"><a href="#Peterson-解法" class="headerlink" title="Peterson 解法"></a>Peterson 解法</h4><p>荷兰数学家 T.Dekker 通过将锁变量与警告变量相结合，最早提出了一个<strong>不需要严格轮换</strong>的软件互斥算法，即Dekker 算法 。后来， G.L.Peterson 发现了一种简单很多的互斥算法，它的算法如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE  1</span></span><br><span class="line"><span class="comment">/* 进程数量 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N     2													</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 现在轮到谁 */</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">turn</span>;					</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 所有值初始化为 0 (FALSE) */</span></span><br><span class="line"><span class="keyword">int</span> interested[N];											</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 进程是 0 或 1 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enter_region</span><span class="params">(<span class="keyword">int</span> <span class="built_in">process</span>)</span></span>&#123;					</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 另一个进程号 */</span></span><br><span class="line">  <span class="keyword">int</span> other;														</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 另一个进程 */</span></span><br><span class="line">  other = <span class="number">1</span> - <span class="built_in">process</span>;				</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 表示愿意进入临界区 */</span></span><br><span class="line">  interested[<span class="built_in">process</span>] = TRUE;						</span><br><span class="line">  <span class="built_in">turn</span> = <span class="built_in">process</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 当该进程希望进入临界区，但是当前另外一个进程正在临界区时，空循环 */</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">turn</span> == <span class="built_in">process</span> </span><br><span class="line">        &amp;&amp; interested[other] == <span class="literal">true</span>)&#123;&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leave_region</span><span class="params">(<span class="keyword">int</span> <span class="built_in">process</span>)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 表示离开临界区 */</span></span><br><span class="line">  interested[<span class="built_in">process</span>] == FALSE;				 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用共享变量时（即进入其临界区）之前，各个进程使用各自的进程号 0 或 1 作为参数来调用 <code>enter_region</code>，这个函数调用在需要时将使进程等待，直到能够安全的临界区。在完成对共享变量的操作之后，进程将调用 <code>leave_region</code> 表示操作完成，并且允许其他进程进入。</p>
<p>现在来看看这个办法是如何工作的。一开始，没有任何进程处于临界区中</p>
<ol>
<li>现在进程 0 调用 <code>enter_region</code>。它通过<strong>设置数组元素和将 turn 置为 0 </strong>来表示它希望进入临界区。由于进程 1 并不想进入临界区，所以 <code>enter_region</code>很快便返回。</li>
<li>如果进程1现在调用 <code>enter_region</code>，进程 1 将在此处挂起直到 <code>interested[0]</code> 变为 FALSE，这种情况只有在进程 0 调用 <code>leave_region</code> 退出临界区时才会发生。</li>
</ol>
<p>那么上面讨论的是顺序进入的情况，现在来考虑一种<strong>两个进程同时调用</strong> <code>enter_region</code> 的情况。它们都将自己的进程存入 turn，但<strong>只有最后保存进去的进程号才有效</strong>，前一个进程的进程号因为重写而丢失。假如进程 1 是最后存入的，则 turn 为 1 。</p>
<p>当两个进程都运行到 <code>while</code> 的时候，<strong>进程 0 将不会循环并进入临界区</strong>，而进程 1 将<strong>会无限循环且不会进入临界区</strong>，直到进程 0 退出临界区(不满足 <code>interested[0] = true</code>)。</p>
<h4 id="TSL-指令"><a href="#TSL-指令" class="headerlink" title="TSL 指令"></a>TSL 指令</h4><p>现在来看一种需要硬件帮助的方案。一些计算机，特别是那些设计为多处理器的计算机，都会有下面这条指令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TSL RX,LOCK</span><br></pre></td></tr></table></figure>
<p>称为 <code>测试并加锁(test and set lock)</code>，它将一个内存字 lock 读到寄存器 <code>RX</code> 中，然后在该内存地址上存储一个<strong>非零值</strong>。读写指令能保证是一体的，不可分割的，一同执行的(原子性)。在这个<strong>指令结束之前其他处理器均不允许访问内存</strong>。执行 TSL 指令的 CPU 将会<strong>锁住内存总线</strong>，用来禁止其他 CPU 在这个指令结束之前访问内存。操作系统的Mutex的加锁过程就是基于TSL指令实现的。</p>
<p>很重要的一点是锁住内存总线和禁用中断不一样。禁用中断并不能保证一个处理器在读写操作之间另一个处理器对内存的读写。也就是说，<strong>在处理器 1 上屏蔽中断对处理器 2 没有影响</strong>。让处理器 2 远离内存直到处理器 1 完成读写的最好的方式就是锁住总线。这需要一个特殊的硬件（基本上，一根总线就可以确保总线由锁住它的处理器使用，而其他的处理器不能使用）</p>
<p>为了使用 TSL 指令，要使用一个共享变量 lock 来协调对共享内存的访问。当 lock 为 0 时，任何进程都可以使用 TSL 指令将其设置为 1，并读写共享内存。当操作结束时，进程使用 <code>move</code> 指令将 lock 的值重新设置为 0 。</p>
<p>这条指令如何防止两个进程同时进入临界区呢？下面是解决方案</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">enter_region:</span><br><span class="line">		| 复制锁到寄存器并将锁设为1</span><br><span class="line">		TSL REGISTER,LOCK              </span><br><span class="line">		| 锁是 0 吗？</span><br><span class="line">  		CMP REGISTER,#0						 		</span><br><span class="line">  		| 若不是零，说明锁已被设置，所以循环</span><br><span class="line">  		JNE enter_region					 		</span><br><span class="line">  		| 返回调用者，进入临界区</span><br><span class="line">  		RET												 </span><br><span class="line">       </span><br><span class="line">leave_region:</span><br><span class="line">			| 在锁中存入 0</span><br><span class="line">			MOVE LOCK,#0			      </span><br><span class="line">      | 返回调用者</span><br><span class="line">  		RET</span><br></pre></td></tr></table></figure>
<p>我们可以看到这个解决方案的思想和 Peterson 的思想很相似。假设存在如下共 4 指令的汇编语言程序。第一条指令将 lock 原来的值复制到寄存器中并将 lock 设置为 1 ，随后这个原来的值和 0 做对比。如果它不是零，说明之前已经被加过锁，则程序返回到开始并再次测试。经过一段时间后（可长可短），该值变为 0 （当前处于临界区中的进程退出临界区时），于是过程返回，此时已加锁。要清除这个锁也比较简单，程序只需要将 0 存入 lock 即可，不需要特殊的同步指令。</p>
<p>现在有了一种很明确的做法，那就是进程在进入临界区之前会先调用 <code>enter_region</code>，判断是否进行循环，如果lock 的值是 1 ，进行无限循环；如果 lock 是 0，不进入循环并进入临界区。在进程从临界区返回时它调用 <code>leave_region</code>，这会把 lock 设置为 0 。与基于临界区问题的所有解法一样，进程必须在正确的时间调用 <code>enter_region</code> 和 <code>leave_region</code> ，解法才能奏效。</p>
<p>还有一个可以替换 TSL 的指令是 <code>XCHG</code>，它原子性的<strong>交换了两个位置的内容</strong>，例如，一个寄存器与一个内存字，代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">enter_region:</span><br><span class="line">    | 把 1 放在寄存器中</span><br><span class="line">		MOVE REGISTER,#1	</span><br><span class="line">    | 交换寄存器和锁变量的内容</span><br><span class="line">		XCHG REGISTER,LOCK			</span><br><span class="line">    | 锁是 0 吗？</span><br><span class="line">		CMP REGISTER,#0		</span><br><span class="line">    | 若不是 0 ，锁已被设置，进行循环</span><br><span class="line">		JNE enter_region					</span><br><span class="line">    | 返回调用者，进入临界区</span><br><span class="line">		RET														</span><br><span class="line">	</span><br><span class="line">leave_region:				</span><br><span class="line">		| 在锁中存入 0 </span><br><span class="line">		MOVE LOCK,#0	</span><br><span class="line">    | 返回调用者</span><br><span class="line">		RET</span><br></pre></td></tr></table></figure>
<p>XCHG 的本质上与 TSL 的解决办法一样。所有的 Intel x86 CPU 在底层同步中使用 XCHG 指令。</p>
<h3 id="睡眠与唤醒"><a href="#睡眠与唤醒" class="headerlink" title="睡眠与唤醒"></a>睡眠与唤醒</h3><p>上面解法中的 Peterson 、TSL 和 XCHG 解法都是正确的，但是它们<strong>都有忙等待的缺点</strong>。这些解法的本质上都是一样的，先检查是否能够进入临界区，若不允许，则该进程将原地等待，直到允许为止。</p>
<p>这种方式不但浪费了 CPU 时间，而且还可能引起意想不到的结果。考虑一台计算机上有两个进程，这两个进程具有不同的优先级，<code>H</code> 是属于优先级比较高的进程，<code>L</code> 是属于优先级比较低的进程。进程调度的规则是不论何时只要 H 进程处于就绪态， H 就开始运行。在某一时刻，L 处于临界区中，此时 H 变为就绪态，准备运行（例如，一条 I/O 操作结束）。现在 H 要开始忙等，但由于当 H 就绪时 L 就不会被调度，L 从来不会有机会离开临界区，所以 H 会变成死循环，有时将这种情况称为<code>优先级反转问题(priority inversion problem)</code>。</p>
<p>现在让我们看一下进程间的通信原语，这些原语在不允许它们进入临界区之前会阻塞而不是浪费 CPU 时间，最简单的是 <code>sleep</code> 和 <code>wakeup</code>。<code>sleep</code> 是一个能够造成调用者阻塞的系统调用，也就是说，这个系统调用会暂停直到其他进程唤醒它。<code>wakeup</code> 调用有一个参数，即要唤醒的进程。还有一种方式是 <code>wakeup</code> 和 <code>sleep</code> 都有一个参数，即 <code>sleep</code>和 <code>wakeup</code> 需要匹配的内存地址。</p>
<h4 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h4><p>作为这些私有原语的例子，让我们考虑<code>生产者-消费者(producer-consumer)</code> 问题，也称作 <code>有界缓冲区(bounded-buffer)</code> 问题。<strong>两个进程共享一个公共的固定大小的缓冲区</strong>。<br>其中一个是<code>生产者(producer)</code>，将信息放入缓冲区<br> 另一个是<code>消费者(consumer)</code>，会从缓冲区中取出。</p>
<p>也可以把这个问题一般化为<strong>m 个生产者</strong>和 <strong>n 个消费者</strong>的问题，但是我们这里只讨论一个生产者和一个消费者的情况，这样可以简化实现方案。</p>
<p><strong>如果缓冲队列已满</strong>，那么当生产者仍想要将数据写入缓冲区的时候，会出现问题。它的解决办法是<strong>让生产者睡眠</strong>，也就是阻塞生产者。等到消费者从缓冲区中取出一个或多个数据项时再唤醒它。<br>同样的，当消费者试图从缓冲区中取数据，但是<strong>发现缓冲区为空时</strong>，<strong>消费者也会睡眠</strong>，阻塞。直到生产者向其中放入一个新的数据。</p>
<p>这个逻辑听起来比较简单，而且这种方式也需要一种称作 <code>监听</code> 的变量，这个变量用于监视缓冲区的数据，我们暂定为 <code>count</code>，如果缓冲区最多存放 N 个数据项，生产者会每次判断 <code>count</code> 是否达到 N，否则生产者向缓冲区放入一个数据项并增量 <code>count</code> 的值。<br>消费者的逻辑也很相似：首先测试 <code>count</code> 的值是否为 0 ，如果为 0 则消费者睡眠、阻塞，否则会从缓冲区取出数据并使 count 数量递减。每个进程也会检查检查是否其他线程是否应该被唤醒，如果应该被唤醒，那么就唤醒该线程。下面是生产者消费者的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 缓冲区 slot 槽的数量 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100						</span></span><br><span class="line"><span class="comment">/* 缓冲区数据的数量 */</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>										</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="keyword">void</span> producer(<span class="keyword">void</span>)&#123;</span><br><span class="line">  <span class="keyword">int</span> item;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 无限循环 */</span></span><br><span class="line">  <span class="keyword">while</span>(TRUE)&#123;				</span><br><span class="line">    <span class="comment">/* 生成下一项数据 */</span></span><br><span class="line">    item = produce_item()				</span><br><span class="line">    <span class="comment">/* 如果缓存区是满的，就会阻塞 */</span></span><br><span class="line">    <span class="keyword">if</span>(count == N)&#123;</span><br><span class="line">      sleep();									</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 把当前数据放在缓冲区中 */</span></span><br><span class="line">    insert_item(item);</span><br><span class="line">    <span class="comment">/* 增加缓冲区 count 的数量 */</span></span><br><span class="line">    count = count + <span class="number">1</span>;					</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="comment">/* 缓冲区是否为空？ */</span></span><br><span class="line">      wakeup(consumer);					</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> item;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 无限循环 */</span></span><br><span class="line">  <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">    <span class="comment">/* 如果缓冲区是空的，就会进行阻塞 */</span></span><br><span class="line">  	<span class="keyword">if</span>(count == <span class="number">0</span>)&#123;							</span><br><span class="line">      sleep();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 从缓冲区中取出一个数据 */</span></span><br><span class="line">   	item = remove_item();			</span><br><span class="line">    <span class="comment">/* 将缓冲区的 count 数量减一 */</span></span><br><span class="line">    count = count - <span class="number">1</span></span><br><span class="line">    <span class="comment">/* 缓冲区满嘛？ */</span></span><br><span class="line">    <span class="keyword">if</span>(count == N - <span class="number">1</span>)&#123;					</span><br><span class="line">      wakeup(producer);		</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 打印数据项 */</span></span><br><span class="line">    consumer_item(item);				</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了在 C 语言中描述像是 <code>sleep</code> 和 <code>wakeup</code> 的系统调用，我们将以库函数调用的形式来表示。它们不是 C 标准库的一部分，但可以在实际具有这些系统调用的任何系统上使用。代码中未实现的 <code>insert_item</code> 和 <code>remove_item</code> 用来记录将数据项放入缓冲区和从缓冲区取出数据等。</p>
<p>现在让我们回到生产者-消费者问题上来，上面代码中会产生竞争条件，因为 count 这个变量是暴露在大众视野下的。有可能出现下面这种情况：缓冲区为空，此时消费者刚好读取 count 的值发现它为 0 。此时调度程序决定暂停消费者并启动运行生产者。刚刚好生产者生产了一条数据并把它放在缓冲区中，然后增加 count 的值，并注意到它的值是 1 。由于 count 为 0，消费者必须处于睡眠状态，因此生产者调用 <code>wakeup</code> 来唤醒消费者。<strong>但是，消费者此时在逻辑上并没有睡眠</strong>，所以 wakeup 信号会丢失。当消费者下次启动后，它会查看之前读取的 count 值，发现它的值是 0 ，然后在此进行睡眠。不久之后生产者会填满整个缓冲区，在这之后会阻塞，<strong>这样一来两个进程将永远睡眠下去。</strong></p>
<p>引起上面问题的本质是 <strong>唤醒尚未进行睡眠状态的进程会导致唤醒丢失</strong>。如果它没有丢失，则一切都很正常。一种快速解决上面问题的方式是增加一个<code>唤醒等待位(wakeup waiting bit)</code>。当一个 wakeup 信号发送给仍在清醒的进程后，该位置为 1 。之后，当进程尝试睡眠的时候，如果唤醒等待位为 1 ，则该位清除，而进程仍然保持清醒。</p>
<p>然而，当进程数量有许多的时候，这时你可以说通过增加唤醒等待位的数量来唤醒等待位，于是就有了 2、4、6、8 个唤醒等待位，<strong>但是并没有从根本上解决问题</strong></p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量是在 1965 年提出的一种方法，它使用一个<strong>整型变量来累计唤醒次数</strong>，以供之后使用。在他的观点中，有一个新的变量类型称作 <code>信号量(semaphore)</code>。一个信号量的取值可以是 0 ，或任意正数。0 表示的是不需要任何唤醒，任意的正数表示的就是唤醒次数。</p>
<p>Dijkstra 提出了信号量有两个操作，现在通常使用 <code>down</code> 和 <code>up</code>（分别可以用 sleep 和 wakeup 来表示）。<code>down</code>这个指令的操作会检查值是否大于 0 。如果大于 0 ，则将其值减 1 ；若该值为 0 ，则进程将睡眠，而且此时 <code>down</code>操作将会继续执行。检查数值、修改变量值以及可能发生的睡眠操作均为一个单一的、不可分割的 <code>原子操作(atomic action)</code> 完成。这会保证一旦信号量操作开始，没有其他的进程能够访问信号量，直到操作完成或者阻塞。<strong>这种原子性对于解决同步问题和避免竞争绝对必不可少</strong>。</p>
<blockquote>
<p>原子性操作指的是在计算机科学的许多其他领域中，一组相关操作全部执行而没有中断或根本不执行。</p>
</blockquote>
<p><code>up</code>操作会使信号量的值 + 1。如果当前信号量的值为0，且一个或者多个进程在信号量上睡眠，无法完成一个先前的 <code>down</code>操作，则由系统选择其中一个并允许该程完成 <code>down</code> 操作。因此，对一个进程在其上睡眠的信号量执行一次 <code>up</code>操作之后，该信号量的值仍然是 0 ，但在其上睡眠的进程却少了一个。信号量的值增 1 和唤醒一个进程同样也是不可分割的。不会有某个进程因执行 up 而阻塞，正如在前面的模型中不会有进程因执行 wakeup 而阻塞是一样的道理。</p>
<h4 id="用信号量解决生产者-消费者问题"><a href="#用信号量解决生产者-消费者问题" class="headerlink" title="用信号量解决生产者 - 消费者问题"></a>用信号量解决生产者 - 消费者问题</h4><p>用信号量解决丢失的 wakeup 问题，代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义缓冲区槽的数量 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="comment">/* 信号量是一种特殊的 int */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line"><span class="comment">/* 控制临界区的访问 */</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* 统计 buffer 空槽的数量 */</span></span><br><span class="line">semaphore empty = N;</span><br><span class="line"><span class="comment">/* 统计 buffer 满槽的数量 */</span></span><br><span class="line">semaphore full = <span class="number">0</span>;												</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> item;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* TRUE 的常量是 1 */</span></span><br><span class="line">  <span class="keyword">while</span>(TRUE)&#123;			</span><br><span class="line">    <span class="comment">/* 产生放在缓冲区的一些数据 */</span></span><br><span class="line">    item = producer_item();		</span><br><span class="line">    <span class="comment">/* 将空槽数量减 1  */</span></span><br><span class="line">    down(&amp;empty);	</span><br><span class="line">    <span class="comment">/* 进入临界区  */</span></span><br><span class="line">    down(&amp;mutex);	</span><br><span class="line">    <span class="comment">/* 把数据放入缓冲区中 */</span></span><br><span class="line">    insert_item(item);</span><br><span class="line">    <span class="comment">/* 离开临界区 */</span></span><br><span class="line">    up(&amp;mutex);	</span><br><span class="line">    <span class="comment">/* 将 buffer 满槽数量 + 1 */</span></span><br><span class="line">    up(&amp;full);														</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> item;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 无限循环 */</span></span><br><span class="line">  <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">    <span class="comment">/* 缓存区满槽数量 - 1 */</span></span><br><span class="line">    down(&amp;full);</span><br><span class="line">    <span class="comment">/* 进入缓冲区 */</span>	</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">/* 从缓冲区取出数据 */</span></span><br><span class="line">    item = remove_item();	</span><br><span class="line">    <span class="comment">/* 离开临界区 */</span></span><br><span class="line">    up(&amp;mutex);	</span><br><span class="line">    <span class="comment">/* 将空槽数目 + 1 */</span></span><br><span class="line">    up(&amp;empty);	</span><br><span class="line">    <span class="comment">/* 处理数据 */</span></span><br><span class="line">    consume_item(item);											</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了确保信号量能正确工作，最重要的是要采用一种不可分割的方式来实现它。通常是将 up 和 down 作为系统调用来实现。而且操作系统只需在执行以下操作时暂时屏蔽全部中断：<strong>检查信号量、更新、必要时使进程睡眠</strong>。由于这些操作仅需要非常少的指令，因此中断不会造成影响。如果使用多个 CPU，那么信号量应该被锁进行保护。使用 TSL 或者 XCHG 指令用来确保同一时刻只有一个 CPU 对信号量进行操作。</p>
<p>使用 TSL 或者 XCHG 来防止几个 CPU 同时访问一个信号量，与生产者或消费者使用忙等待来等待其他腾出或填充缓冲区是完全不一样的。前者的操作仅需要几个毫秒，而生产者或消费者可能需要任意长的时间。</p>
<p>上面这个解决方案使用了三种信号量：</p>
<ul>
<li>一个称为 <code>full</code>，用来记录充满的缓冲槽数目,初始化为 0；</li>
<li>一个称为 <code>empty</code>，记录空的缓冲槽数目,初始化为缓冲区中插槽数；</li>
<li>一个称为 <code>mutex</code>，用来确保生产者和消费者不会同时进入缓冲区,mutex 初始化为 1</li>
</ul>
<p>信号量初始化为 1 并且由两个或多个进程使用，以确保它们中同时只有一个可以进入临界区的信号被称为 <code>二进制信号量(binary semaphores)</code>。如果每个进程都在进入临界区之前执行 down 操作，而在离开临界区之后执行 up 操作，则可以确保相互互斥。</p>
<p>现在我们有了一个好的进程间原语的保证。然后我们再来看一下中断的顺序保证</p>
<ol>
<li>硬件压入堆栈程序计数器等</li>
<li>硬件从中断向量装入新的程序计数器</li>
<li>汇编语言过程保存寄存器的值</li>
<li>汇编语言过程设置新的堆栈</li>
<li>C 中断服务器运行（典型的读和缓存写入）</li>
<li>调度器决定下面哪个程序先运行</li>
<li>C 过程返回至汇编代码</li>
<li>汇编语言过程开始运行新的当前进程</li>
</ol>
<p>在使用<code>信号量</code>的系统中，隐藏中断的自然方法是让每个 I/O 设备都配备一个信号量，该信号量最初设置为0。在 I/O 设备启动后，中断处理程序立刻对相关联的信号执行一个 <code>down</code> 操作，于是进程立即被阻塞。当中断进入时，中断处理程序随后对相关的信号量执行一个 <code>up</code>操作，能够使已经阻止的进程恢复运行。在上面的中断处理步骤中，其中的第 5 步 <code>C 中断服务器运行</code> 就是中断处理程序在信号量上执行的一个 up 操作，所以在第 6 步中，操作系统能够执行设备驱动程序。当然，如果有几个进程已经处于就绪状态，调度程序可能会选择接下来运行一个更重要的进程，我们会在后面讨论调度的算法。</p>
<p>上面的代码实际上是通过两种不同的方式来使用信号量的，而这两种信号量之间的区别也是很重要的。<code>mutex</code> 信号量用于互斥。它用于确保任意时刻只有一个进程能够对缓冲区和相关变量进行读写。互斥是用于避免进程混乱所必须的一种操作。</p>
<p>另外一个信号量是关于<code>同步(synchronization)</code>的。<code>full</code> 和 <code>empty</code> 信号量用于确保事件的发生或者不发生。在这个事例中，它们确保了缓冲区满时生产者停止运行；缓冲区为空时消费者停止运行。这两个信号量的使用与 mutex 不同。</p>
<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>如果不需要信号量的计数能力时，可以使用信号量的一个简单版本，称为 <code>mutex(互斥量)</code>。互斥量的优势就在于在一些共享资源和一段代码中保持互斥。由于互斥的实现既简单又有效，这使得互斥量在实现用户空间线程包时非常有用。</p>
<p>互斥量是一个处于<strong>两种状态之一的共享变量</strong>：<code>解锁(unlocked)</code> 和 <code>加锁(locked)</code>。这样，只需要一个二进制位来表示它，不过一般情况下，通常会用一个 <code>整形(integer)</code> 来表示。0 表示解锁，其他所有的值表示加锁，比 1 大的值表示加锁的次数。</p>
<p>mutex 使用两个过程，当一个线程（或者进程）需要访问临界区时，会调用 <code>mutex_lock</code> 进行加锁。如果互斥锁当前处于解锁状态（表示临界区可用），则调用成功，并且调用线程可以自由进入临界区。</p>
<p>另一方面，如果 mutex 互斥量已经锁定的话，<strong>调用线程会阻塞</strong>直到临界区内的线程执行完毕并且调用了 <code>mutex_unlock</code> 。<strong>如果多个线程在 mutex 互斥量上阻塞，将随机选择一个线程并允许它获得锁。</strong></p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/23.png" style="zoom:67%;"></p>
<p>由于 mutex 互斥量非常简单，所以只要有 TSL 或者是 XCHG 指令，就可以很容易地在用户空间实现它们。用于用户级线程包的 <code>mutex_lock</code> 和 <code>mutex_unlock</code> 代码如下，XCHG 的本质也一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock:</span><br><span class="line">	  | 将互斥信号量复制到寄存器，并将互斥信号量置为1</span><br><span class="line">			TSL REGISTER,MUTEX</span><br><span class="line">      | 互斥信号量是 0 吗？</span><br><span class="line">			CMP REGISTER,#0	</span><br><span class="line">      | 如果互斥信号量为0，它被解锁，所以返回</span><br><span class="line">			JZE ok	</span><br><span class="line">      | 互斥信号正在使用；调度其他线程</span><br><span class="line">			CALL thread_yield	</span><br><span class="line">      | 再试一次</span><br><span class="line">			JMP mutex_lock	</span><br><span class="line">      | 返回调用者，进入临界区</span><br><span class="line">ok: 	RET														</span><br><span class="line"></span><br><span class="line">mutex_unlcok:</span><br><span class="line">	  | 将 mutex 置为 0 </span><br><span class="line">			MOVE MUTEX,#0	</span><br><span class="line">      | 返回调用者</span><br><span class="line">			RET</span><br></pre></td></tr></table></figure>
<p>mutex_lock 的代码和上面 enter_region 的代码很相似，我们可以对比着看一下</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/24.png" style="zoom:67%;"></p>
<p>上面代码最大的区别你看出来了吗？</p>
<ul>
<li>根据上面我们对 TSL 的分析，我们知道，如果 TSL 判断没有进入临界区的进程<strong>会进行无限循环获取锁</strong>，而在 TSL 处理互斥量中，如果 mutex 正在使用，那么<strong>就调度其他线程进行处理</strong>。所以上面最大的区别其实就是在判断 mutex/TSL 之后的处理。</li>
<li>在（用户）线程中，情况有所不同，因为没有时钟来停止运行时间过长的线程。结果是通过忙等待的方式来试图获得锁的线程将永远循环下去，决不会得到锁，因为这个运行的线程不会让其他线程运行从而释放锁，其他线程根本没有获得锁的机会。在后者获取锁失败时，它会调用 <code>thread_yield</code> 将 CPU 放弃给另外一个线程。结果就不会进行忙等待。在该线程下次运行时，它再一次对锁进行测试。</li>
</ul>
<p>上面就是 enter_region 和 mutex_lock 的差别所在。由于 thread_yield 仅仅是一个用户空间的线程调度，所以它的运行非常快捷。这样，<code>mutex_lock</code> 和 <code>mutex_unlock</code> 都不需要任何内核调用。通过使用这些过程，用户线程完全可以实现在用户空间中的同步，这个过程仅仅需要少量的同步。</p>
<p>我们上面描述的互斥量其实是一套调用框架中的指令。从软件角度来说，总是需要更多的特性和同步原语。例如，有时线程包提供一个调用 <code>mutex_trylock</code>，这个调用尝试获取锁或者返回错误码，但是不会进行加锁操作。这就给了调用线程一个灵活性，以决定下一步做什么，是使用替代方法还是等候下去。</p>
<h4 id="Futexes"><a href="#Futexes" class="headerlink" title="Futexes"></a>Futexes</h4><p>随着并行的增加，有效的<code>同步(synchronization)</code>和<code>锁定(locking)</code> 对于性能来说是非常重要的。如果进程等待时间很短，那么<code>自旋锁(Spin lock)</code> 是非常有效；但是如果等待时间比较长，那么这会浪费 CPU 周期。如果进程很多，那么阻塞此进程，<strong>并仅当锁被释放的时候让内核解除阻塞是更有效的方式</strong>。不幸的是，这种方式也会导致另外的问题：它可以在进程竞争频繁的时候运行良好，但是在竞争不是很激烈的情况下内核切换的消耗会非常大，而且更困难的是，预测锁的竞争数量更不容易。</p>
<p>有一种有趣的解决方案是把两者的优点结合起来，提出一种新的思想，称为 <code>futex</code>，或者是 <code>快速用户空间互斥(fast user space mutex)</code>，是不是听起来很有意思？</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/25.png" style="zoom:67%;"></p>
<p><code>futex</code>是 <code>Linux</code> 中的特性实现了<strong>基本的锁定（很像是互斥锁）而且避免了陷入内核</strong>中，因为内核的切换的开销非常大，这样做可以大大提高性能。<code>futex</code>由两部分组成：<strong>内核服务和用户库</strong>。内核服务提供了了一个 <code>等待队列(wait queue)</code> 允许多个进程在锁上排队等待。除非内核明确的对他们解除阻塞，否则它们不会运行。</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/26.png" style="zoom:67%;"></p>
<p>对于一个进程来说，把它放到等待队列需要昂贵的系统调用，这种方式应该被避免。在没有竞争的情况下，<code>futex</code>可以直接在用户空间中工作。这些进程共享一个 32 位<code>整数(integer)</code> 作为公共锁变量。假设锁的初始化为 1，我们认为这时锁已经被释放了。线程通过执行原子性的操作<code>减少并测试(decrement and test)</code> 来抢占锁。<code>decrement and set</code> 是 Linux 中的原子功能，由包裹在 C 函数中的内联汇编组成，并在头文件中进行定义。下一步，线程会检查结果来查看锁是否已经被释放。如果锁现在不是锁定状态，那么刚好我们的线程可以成功抢占该锁。然而，如果锁被其他线程持有，抢占锁的线程不得不等待。在这种情况下，<code>futex</code> 库不会<code>自旋</code>，但是会使用一个系统调用来把线程放在内核中的等待队列中。这样一来，切换到内核的开销已经是合情合理的了，因为线程可以在任何时候阻塞。当线程完成了锁的工作时，它会使用原子性的 <code>增加并测试(increment and test)</code> 释放锁，并检查结果以查看内核等待队列上是否仍阻止任何进程。如果有的话，它会通知内核可以对等待队列中的一个或多个进程解除阻塞。如果没有锁竞争，内核则不需要参与竞争。</p>
<h4 id="Pthreads中的互斥量"><a href="#Pthreads中的互斥量" class="headerlink" title="Pthreads中的互斥量"></a><code>Pthreads</code>中的互斥量</h4><p><code>Pthreads</code>提供了一些功能用来同步线程。最基本的机制是使用互斥量变量，可以锁定和解锁，用来保护每个临界区。希望进入临界区的线程首先要尝试获取 mutex。如果 mutex 没有加锁，线程能够马上进入并且互斥量能够自动锁定，从而阻止其他线程进入。如果 mutex 已经加锁，调用线程会阻塞，直到 mutex 解锁。如果多个线程在相同的互斥量上等待，当互斥量解锁时，只有一个线程能够进入并且重新加锁。这些锁并不是必须的，程序员需要正确使用它们。</p>
<p>下面是与互斥量有关的函数调用</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/27.png" style="zoom:67%;"></p>
<p>向我们想象中的一样，<code>mutex</code>能够被创建和销毁，扮演这两个角色的分别是 <code>Phread_mutex_init</code> 和 <code>Pthread_mutex_destroy</code>。<code>mutex</code>也可以通过 <code>Pthread_mutex_lock</code> 来进行加锁，如果互斥量已经加锁，则会阻塞调用者。还有一个调用<code>Pthread_mutex_trylock</code> 用来尝试对线程加锁，当 <code>mutex</code>已经被加锁时，会返回一个错误代码而不是阻塞调用者。这个调用允许线程有效的进行忙等。最后，<code>Pthread_mutex_unlock</code> 会对 <code>mutex</code> 解锁并且释放一个正在等待的线程。</p>
<p>除了互斥量以外，<code>Pthreads</code> 还提供了第二种同步机制： <code>条件变量(condition variables)</code> 。<code>mutex</code> 可以很好的允许或阻止对临界区的访问。条件变量允许线程由于未满足某些条件而阻塞。绝大多数情况下这两种方法是一起使用的。下面我们进一步来研究线程、互斥量、条件变量之间的关联。</p>
<p>下面再来重新认识一下生产者和消费者问题：一个线程将东西放在一个缓冲区内，由另一个线程将它们取出。如果生产者发现缓冲区没有空槽可以使用了，生产者线程会阻塞起来直到有一个线程可以使用。生产者使用 mutex 来进行原子性检查从而不受其他线程干扰。</p>
<p>但是当发现缓冲区已经满了以后，生产者需要一种方法来<strong>阻塞自己并在以后被唤醒</strong>。这便是条件变量做的工作。</p>
<p>下面是一些与条件变量有关的最重要的 <code>pthread</code> 调用</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/28.png" style="zoom:67%;"></p>
<p>上表中给出了一些调用用来<strong>创建和销毁条件变量</strong>。条件变量上的主要属性是 <code>Pthread_cond_wait</code> 和 <code>Pthread_cond_signal</code>。前者阻塞调用线程，直到其他线程发出信号为止（使用后者调用）。阻塞的线程通常需要<strong>等待唤醒的信号</strong>以此来释放资源或者执行某些其他活动。只有这样阻塞的线程才能继续工作。条件变量允许等待与阻塞原子性的进程。<code>Pthread_cond_broadcast</code> 用来唤醒多个阻塞的、需要等待信号唤醒的线程。</p>
<blockquote>
<p>需要注意的是，条件变量（不像是信号量）不会存在于内存中。如果将一个信号量传递给一个没有线程等待的条件变量，那么这个信号就会丢失，这个需要注意</p>
</blockquote>
<p>下面是一个使用互斥量和条件变量的例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 需要生产的数量 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1000000000	</span></span><br><span class="line"><span class="comment">/* 使用互斥量 */</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> the_mutex;</span><br><span class="line"><span class="comment">/* 使用信号量 */</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> condc,condp;								</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">buffer</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生产数据 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>&#123;								</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= MAX;i++)&#123;</span><br><span class="line">    <span class="comment">/* 缓冲区独占访问，也就是使用 mutex 获取锁 */</span></span><br><span class="line">    pthread_mutex_lock(&amp;the_mutex);				</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">buffer</span> != <span class="number">0</span>)&#123;</span><br><span class="line">      pthread_cond_wait(&amp;condp,&amp;the_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 把他们放在缓冲区中 */</span></span><br><span class="line">    <span class="built_in">buffer</span> = i;			</span><br><span class="line">    <span class="comment">/* 唤醒消费者，向condc发送信号 */</span></span><br><span class="line">    pthread_cond_signal(&amp;condc);	</span><br><span class="line">    <span class="comment">/* 释放缓冲区 */</span></span><br><span class="line">    pthread_mutex_unlock(&amp;the_mutex);			</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 消费数据 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>&#123;								</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= MAX;i++)&#123;</span><br><span class="line">    <span class="comment">/* 缓冲区独占访问，也就是使用 mutex 获取锁 */</span></span><br><span class="line">    pthread_mutex_lock(&amp;the_mutex);				</span><br><span class="line">    <span class="comment">/* 如果当前生产数量为0，那么就阻塞以等待一个信号来唤醒 */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">buffer</span> == <span class="number">0</span>)&#123;</span><br><span class="line">      pthread_cond_wait(&amp;condc,&amp;the_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 把他们从缓冲区中取出 */</span></span><br><span class="line">    <span class="built_in">buffer</span> = <span class="number">0</span>;	</span><br><span class="line">    <span class="comment">/* 唤醒生产者 */</span></span><br><span class="line">    pthread_cond_signal(&amp;condp);</span><br><span class="line">    <span class="comment">/* 释放缓冲区 */</span></span><br><span class="line">    pthread_mutex_unlock(&amp;the_mutex);			</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_exit(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>为了能够编写更加准确无误的程序，Brinch Hansen 和 Hoare 提出了一个更高级的同步原语叫做 <code>管程(monitor)</code>。他们两个人的提案略有不同，通过下面的描述你就可以知道。管程是程序、变量和数据结构等组成的一个集合，它们组成一个特殊的模块或者包。进程可以在任何需要的时候调用管程中的程序，但是它们不能从管程外部访问数据结构和程序。下面展示了一种抽象的，类似 Pascal 语言展示的简洁的管程。不能用 C 语言进行描述，因为管程是语言概念而 C 语言并不支持管程。</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">monitor example</span><br><span class="line">	integer i;</span><br><span class="line">	condition c;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">procedure</span> <span class="title">producer</span><span class="params">()</span>;</span></span><br><span class="line">  ...</span><br><span class="line">	<span class="keyword">end</span>;	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">procedure</span> <span class="title">consumer</span><span class="params">()</span>;</span></span><br><span class="line">	.</span><br><span class="line">	<span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br></pre></td></tr></table></figure>
<p>管程有一个很重要的特性，即在任何时候管程中只能有一个活跃的进程，这一特性使管程能够很方便的实现互斥操作。管程是编程语言的特性，所以编译器知道它们的特殊性，因此可以采用与其他过程调用不同的方法来处理对管程的调用。通常情况下，当进程调用管程中的程序时，该程序的前几条指令会检查管程中是否有其他活跃的进程。如果有的话，调用进程将被挂起，直到另一个进程离开管程才将其唤醒。如果没有活跃进程在使用管程，那么该调用进程才可以进入。</p>
<p>进入管程中的互斥由编译器负责，但是一种通用做法是使用 <code>互斥量(mutex)</code> 和 <code>二进制信号量(binary semaphore)</code>。由于编译器而不是程序员在操作，因此出错的几率会大大降低。在任何时候，编写管程的程序员都无需关心编译器是如何处理的。他只需要知道将所有的临界区转换成为管程过程即可。绝不会有两个进程同时执行临界区中的代码。</p>
<p>即使管程提供了一种简单的方式来实现互斥，但在我们看来，这还不够。因为我们还需要一种在进程无法执行被阻塞。在生产者-消费者问题中，很容易将针对缓冲区满和缓冲区空的测试放在管程程序中，但是生产者在发现缓冲区满的时候该如何阻塞呢？</p>
<p>解决的办法是引入<code>条件变量(condition variables)</code> 以及相关的两个操作 <code>wait</code> 和 <code>signal</code>。当一个管程程序发现它不能运行时（例如，生产者发现缓冲区已满），它会在某个条件变量（如 full）上执行 <code>wait</code> 操作。这个操作造成调用进程阻塞，并且还将另一个以前等在管程之外的进程调入管程。在前面的 pthread 中我们已经探讨过条件变量的实现细节了。另一个进程，比如消费者可以通过执行 <code>signal</code> 来唤醒阻塞的调用进程。</p>
<blockquote>
<p>Brinch Hansen 和 Hoare 在对进程唤醒上有所不同，Hoare 建议让新唤醒的进程继续运行；而挂起另外的进程。而 Brinch Hansen 建议让执行 signal 的进程必须退出管程，这里我们采用 Brinch Hansen 的建议，因为它在概念上更简单，并且更容易实现。</p>
</blockquote>
<p>如果在一个条件变量上有若干进程都在等待，则在对该条件执行 signal 操作后，系统调度程序只能选择其中一个进程恢复运行。</p>
<p>顺便提一下，这里还有上面两位教授没有提出的第三种方式，它的理论是让执行 signal 的进程继续运行，等待这个进程退出管程时，其他进程才能进入管程。</p>
<p>条件变量不是计数器。条件变量也不能像信号量那样积累信号以便以后使用。所以，如果向一个条件变量发送信号，但是该条件变量上没有等待进程，那么信号将会丢失。也就是说，<strong>wait 操作必须在 signal 之前执行</strong>。</p>
<p>下面是一个使用 <code>Pascal</code> 语言通过管程实现的生产者-消费者问题的解法</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">		condition full,empty;</span><br><span class="line">		integer count;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">(item:integer)</span>;</span></span><br><span class="line">		<span class="keyword">begin</span></span><br><span class="line">				<span class="keyword">if</span> count = N <span class="keyword">then</span> wait(full);</span><br><span class="line">				insert_item(item);</span><br><span class="line">				count := count + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> count = <span class="number">1</span> <span class="keyword">then</span> signal(empty);</span><br><span class="line">		<span class="keyword">end</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">remove</span>:</span>integer;</span><br><span class="line">		<span class="keyword">begin</span></span><br><span class="line">				<span class="keyword">if</span> count = <span class="number">0</span> <span class="keyword">then</span> wait(empty);</span><br><span class="line">				remove = remove_item;</span><br><span class="line">				count := count - <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> count = N - <span class="number">1</span> <span class="keyword">then</span> signal(full);</span><br><span class="line">		<span class="keyword">end</span>;</span><br><span class="line">		</span><br><span class="line">		count := <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">producer</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">			<span class="keyword">while</span> true <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">begin</span> </span><br><span class="line">      			item = produce_item;</span><br><span class="line">      			ProducerConsumer.insert(item);</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">consumer</span>;</span></span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">			<span class="keyword">while</span> true <span class="keyword">do</span></span><br><span class="line">			<span class="keyword">begin</span></span><br><span class="line">						item = ProducerConsumer.remove;</span><br><span class="line">						consume_item(item);</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p>读者可能觉得 wait 和 signal 操作看起来像是前面提到的 sleep 和 wakeup ，而且后者存在严重的竞争条件。它们确实很像，但是有个关键的区别：sleep 和 wakeup 之所以会失败是因为当一个进程想睡眠时，另一个进程试图去唤醒它。使用管程则不会发生这种情况。管程程序的自动互斥保证了这一点，如果管程过程中的生产者发现缓冲区已满，它将能够完成 wait 操作而不用担心调度程序可能会在 wait 完成之前切换到消费者。甚至，在 wait 执行完成并且把生产者标志为不可运行之前，是不会允许消费者进入管程的。</p>
<p>尽管类 Pascal 是一种想象的语言，但还是有一些真正的编程语言支持，比如 Java （终于轮到大 Java 出场了），Java 是能够支持管程的，它是一种 <code>面向对象</code>的语言，支持用户级线程，还允许将方法划分为类。只要将关键字 <code>synchronized</code> 关键字加到方法中即可。Java 能够保证一旦某个线程执行该方法，就不允许其他线程执行该对象中的任何 synchronized 方法。没有关键字 synchronized ，就不能保证没有交叉执行。</p>
<p>下面是 Java 使用管程解决的生产者-消费者问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义缓冲区大小的长度</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line">  <span class="comment">// 初始化一个新的生产者线程</span></span><br><span class="line">  <span class="keyword">static</span> Producer p = <span class="keyword">new</span> Producer();</span><br><span class="line">  <span class="comment">// 初始化一个新的消费者线程</span></span><br><span class="line">  <span class="keyword">static</span> Consumer c = <span class="keyword">new</span> Consumer();		</span><br><span class="line">  <span class="comment">// 初始化一个管程</span></span><br><span class="line">  <span class="keyword">static</span> Our_monitor mon = <span class="keyword">new</span> Our_monitor(); </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// run 包含了线程代码</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;												</span><br><span class="line">      <span class="keyword">int</span> item;</span><br><span class="line">      <span class="comment">// 生产者循环</span></span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;														</span><br><span class="line">        item = produce_item();</span><br><span class="line">        mon.insert(item);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生产代码</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">produce_item</span><span class="params">()</span></span>&#123;...&#125;						</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// run 包含了线程代码</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">( )</span> </span>&#123;											</span><br><span class="line">   		<span class="keyword">int</span> item;</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        item = mon.remove();</span><br><span class="line">				consume_item(item);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 消费代码</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">produce_item</span><span class="params">()</span></span>&#123;...&#125;						</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这是管程</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Our_monitor</span> </span>&#123;									</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> buffer[] = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="comment">// 计数器和索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>,lo = <span class="number">0</span>,hi = <span class="number">0</span>;			</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(count == N)&#123;</span><br><span class="line">        <span class="comment">// 如果缓冲区是满的，则进入休眠</span></span><br><span class="line">        go_to_sleep();												</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 向缓冲区插入内容</span></span><br><span class="line">			buffer[hi] = val;					</span><br><span class="line">      <span class="comment">// 找到下一个槽的为止</span></span><br><span class="line">      hi = (hi + <span class="number">1</span>) % N; 				</span><br><span class="line">      <span class="comment">// 缓冲区中的数目自增 1 </span></span><br><span class="line">      count = count + <span class="number">1</span>;											</span><br><span class="line">      <span class="keyword">if</span>(count == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果消费者睡眠，则唤醒</span></span><br><span class="line">        notify();															</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> val;</span><br><span class="line">      <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 缓冲区是空的，进入休眠</span></span><br><span class="line">        go_to_sleep();												</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 从缓冲区取出数据</span></span><br><span class="line">      val = buffer[lo];				</span><br><span class="line">      <span class="comment">// 设置待取出数据项的槽</span></span><br><span class="line">      lo = (lo + <span class="number">1</span>) % N;					</span><br><span class="line">      <span class="comment">// 缓冲区中的数据项数目减 1 </span></span><br><span class="line">      count = count - <span class="number">1</span>;											</span><br><span class="line">      <span class="keyword">if</span>(count = N - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果生产者睡眠，唤醒它</span></span><br><span class="line">        notify();															</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">go_to_sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        wait( );</span><br><span class="line">      &#125;<span class="keyword">catch</span>(Interr uptedExceptionexc) &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中主要设计四个类，<code>外部类(outer class)</code> ProducerConsumer 创建并启动两个线程，p 和 c。第二个类和第三个类 <code>Producer</code> 和 <code>Consumer</code> 分别包含生产者和消费者代码。最后，<code>Our_monitor</code> 是管程，它有两个同步线程，用于在共享缓冲区中插入和取出数据。</p>
<p>在前面的所有例子中，生产者和消费者线程在功能上与它们是相同的。生产者有一个无限循环，该无限循环产生数据并将数据放入公共缓冲区中；消费者也有一个等价的无限循环，该无限循环用于从缓冲区取出数据并完成一系列工作。</p>
<p>程序中比较耐人寻味的就是 <code>Our_monitor</code> 了，它包含缓冲区、管理变量以及两个同步方法。当生产者在 insert 内活动时，它保证消费者不能在 remove 方法中运行，从而保证更新变量以及缓冲区的安全性，并且不用担心竞争条件。变量 count 记录在缓冲区中数据的数量。变量 <code>lo</code> 是缓冲区槽的序号，指出将要取出的下一个数据项。类似地，<code>hi</code> 是缓冲区中下一个要放入的数据项序号。允许 lo = hi，含义是在缓冲区中有 0 个或 N 个数据。</p>
<p>Java 中的同步方法与其他经典管程有本质差别：Java 没有内嵌的条件变量。然而，Java 提供了 wait 和 notify 分别与 sleep 和 wakeup 等价。</p>
<p><strong>通过临界区自动的互斥，管程比信号量更容易保证并行编程的正确性</strong>。但是管程也有缺点，我们前面说到过管程是一个编程语言的概念，编译器必须要识别管程并用某种方式对其互斥作出保证。<strong>C、Pascal 以及大多数其他编程语言都没有管程</strong>，所以不能依靠编译器来遵守互斥规则。</p>
<p>与管程和信号量有关的另一个问题是，这些机制都是设计用来解决访问共享内存的一个或多个 CPU 上的互斥问题的。通过将信号量放在共享内存中并用 <code>TSL</code> 或 <code>XCHG</code> 指令来保护它们，可以避免竞争。但是如果是在分布式系统中，可能同时具有多个 CPU 的情况，并且每个 CPU 都有自己的私有内存呢，它们通过网络相连，那么这些原语将会失效。因为信号量太低级了，而管程在少数几种编程语言之外无法使用，所以还需要其他方法。</p>
<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p>上面提到的其他方法就是 <code>消息传递(messaage passing)</code>。这种进程间通信的方法使用两个原语 <code>send</code> 和 <code>receive</code> ，它们像信号量而不像管程，是系统调用而不是语言级别。示例如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">send(destination, &amp;message);</span><br><span class="line"></span><br><span class="line">receive(source, &amp;message);</span><br></pre></td></tr></table></figure>
<p>send 方法用于向一个给定的目标发送一条消息，receive 从一个给定的源接受一条消息。如果没有消息，接受者可能被阻塞，直到接受一条消息或者带着错误码返回。</p>
<h4 id="消息传递系统的设计要点"><a href="#消息传递系统的设计要点" class="headerlink" title="消息传递系统的设计要点"></a>消息传递系统的设计要点</h4><p>消息传递系统现在面临着许多信号量和管程所未涉及的问题和设计难点，尤其对那些在网络中不同机器上的通信状况。例如，消息有可能被网络丢失。为了防止消息丢失，发送方和接收方可以达成一致：一旦接受到消息后，接收方马上回送一条特殊的 <code>确认(acknowledgement)</code> 消息。如果发送方在一段时间间隔内未收到确认，则重发消息。</p>
<p>现在考虑消息本身被正确接收，而返回给发送着的确认消息丢失的情况。发送者将重发消息，这样接受者将收到两次相同的消息。</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/29.png" style="zoom:67%;"></p>
<p>对于接收者来说，如何区分新的消息和一条重发的老消息是非常重要的。通常采用在每条原始消息中嵌入一个连续的序号来解决此问题。如果接受者收到一条消息，它具有与前面某一条消息一样的序号，就知道这条消息是重复的，可以忽略。</p>
<p>消息系统还必须处理如何命名进程的问题，以便在发送或接收调用中清晰的指明进程。<code>身份验证(authentication)</code> 也是一个问题，比如客户端怎么知道它是在与一个真正的文件服务器通信，从发送方到接收方的信息有可能被中间人所篡改。</p>
<h4 id="用消息传递解决生产者-消费者问题"><a href="#用消息传递解决生产者-消费者问题" class="headerlink" title="用消息传递解决生产者-消费者问题"></a>用消息传递解决生产者-消费者问题</h4><p>现在我们考虑如何使用消息传递来解决生产者-消费者问题，而不是共享缓存。下面是一种解决方式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* buffer 中槽的数量 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100													</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> item;</span><br><span class="line">  <span class="comment">/* buffer 中槽的数量 */</span></span><br><span class="line">  message m;													</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">    <span class="comment">/* 生成放入缓冲区的数据 */</span></span><br><span class="line">    item = produce_item();						</span><br><span class="line">    <span class="comment">/* 等待消费者发送空缓冲区 */</span></span><br><span class="line">    receive(consumer,&amp;m);							</span><br><span class="line">    <span class="comment">/* 建立一个待发送的消息 */</span></span><br><span class="line">    build_message(&amp;m,item);						</span><br><span class="line">    <span class="comment">/* 发送给消费者 */</span></span><br><span class="line">    send(consumer,&amp;m);								</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> item,i;</span><br><span class="line">  message m;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 循环N次 */</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)&#123;						</span><br><span class="line">    <span class="comment">/* 发送N个缓冲区 */</span></span><br><span class="line">    send(producer,&amp;m);								</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">    <span class="comment">/* 接受包含数据的消息 */</span></span><br><span class="line">    receive(producer,&amp;m);							</span><br><span class="line">    <span class="comment">/* 将数据从消息中提取出来 */</span></span><br><span class="line">  	item = extract_item(&amp;m);					</span><br><span class="line">    <span class="comment">/* 将空缓冲区发送回生产者 */</span></span><br><span class="line">    send(producer,&amp;m);								</span><br><span class="line">    <span class="comment">/* 处理数据 */</span></span><br><span class="line">    consume_item(item);								</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设所有的消息都有相同的大小，并且在尚未接受到发出的消息时，由操作系统自动进行缓冲。在该解决方案中共使用 N 条消息，这就类似于一块共享内存缓冲区的 N 个槽。消费者首先将 N 条空消息发送给生产者。当生产者向消费者传递一个数据项时，它取走一条空消息并返回一条填充了内容的消息。通过这种方式，系统中总的消息数量保持不变，所以消息都可以存放在事先确定数量的内存中。</p>
<p>如果生产者的速度要比消费者快，则所有的消息最终都将被填满，等待消费者，生产者将被阻塞，等待返回一条空消息。如果消费者速度快，那么情况将正相反：所有的消息均为空，等待生产者来填充，消费者将被阻塞，以等待一条填充过的消息。</p>
<p>消息传递的方式有许多变体，下面先介绍如何对消息进行 <code>编址</code>。</p>
<ul>
<li>一种方法是为每个进程分配一个唯一的地址，让消息按进程的地址编址。</li>
<li>另一种方式是引入一个新的数据结构，称为 <code>信箱(mailbox)</code>，信箱是一个用来对一定的数据进行缓冲的数据结构，信箱中消息的设置方法也有多种，典型的方法是在信箱创建时确定消息的数量。在使用信箱时，在 send 和 receive 调用的地址参数就是信箱的地址，而不是进程的地址。当一个进程试图向一个满的信箱发送消息时，它将被挂起，直到信箱中有消息被取走，从而为新的消息腾出地址空间。</li>
</ul>
<h3 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h3><p>最后一个同步机制是准备用于进程组而不是进程间的生产者-消费者情况的。在某些应用中划分了若干阶段，并且规定，除非所有的进程都就绪准备着手下一个阶段，否则任何进程都不能进入下一个阶段，可以通过在每个阶段的结尾安装一个 <code>屏障(barrier)</code> 来实现这种行为。当一个进程到达屏障时，它会被屏障所拦截，直到所有的屏障都到达为止。屏障可用于一组进程同步，如下图所示</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/30.png" style="zoom:67%;"></p>
<p>在上图中我们可以看到，有四个进程接近屏障，这意味着每个进程都在进行运算，但是还没有到达每个阶段的结尾。过了一段时间后，A、B、D 三个进程都到达了屏障，各自的进程被挂起，但此时还不能进入下一个阶段呢，因为进程 B 还没有执行完毕。结果，当最后一个 C 到达屏障后，这个进程组才能够进入下一个阶段。</p>
<h3 id="避免锁：读-复制-更新"><a href="#避免锁：读-复制-更新" class="headerlink" title="避免锁：读-复制-更新"></a>避免锁：读-复制-更新</h3><p>最快的锁是根本没有锁。问题在于没有锁的情况下，我们是否允许对共享数据结构的并发读写进行访问。答案当然是不可以。假设进程 A 正在对一个数字数组进行排序，而进程 B 正在计算其平均值，而此时你进行 A 的移动，会导致 B 会多次读到重复值，而某些值根本没有遇到过。</p>
<p>然而，在某些情况下，我们可以允许写操作来更新数据结构，即便还有其他的进程正在使用。窍门在于确保每个读操作要么读取旧的版本，要么读取新的版本，例如下面的树</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/31.png" style="zoom:67%;"></p>
<p>上面的树中，读操作从根部到叶子遍历整个树。加入一个新节点 X 后，为了实现这一操作，我们要让这个节点在树中可见之前使它”恰好正确”：我们对节点 X 中的所有值进行初始化，包括它的子节点指针。然后通过原子写操作，使 X 称为 A 的子节点。所有的读操作都不会读到前后不一致的版本</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/32.png" style="zoom:67%;"></p>
<p>在上面的图中，我们接着移除 B 和 D。首先，将 A 的左子节点指针指向 C 。所有原本在 A 中的读操作将会后续读到节点 C ，而永远不会读到 B 和 D。也就是说，它们将只会读取到新版数据。同样，所有当前在 B 和 D 中的读操作将继续按照原始的数据结构指针并且读取旧版数据。所有操作均能正确运行，我们不需要锁住任何东西。而不需要锁住数据就能够移除 B 和 D 的主要原因就是 <code>读-复制-更新(Ready-Copy-Update,RCU)</code>，将更新过程中的移除和再分配过程分离开。</p>
<h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p>当一个计算机是多道程序设计系统时，会频繁的有很多进程或者线程来同时竞争 CPU 时间片。当两个或两个以上的进程/线程处于就绪状态时，就会发生这种情况。如果只有一个 CPU 可用，那么必须选择接下来哪个进程/线程可以运行。操作系统中有一个叫做 <code>调度程序(scheduler)</code> 的角色存在，它就是做这件事儿的，该程序使用的算法叫做 <code>调度算法(scheduling algorithm)</code> 。</p>
<p>尽管有一些不同，但许多适用于进程调度的处理方法同样也适用于线程调度。当内核管理线程的时候，调度通常会以线程级别发生，很少或者根本不会考虑线程属于哪个进程。下面我们会首先专注于进程和线程的调度问题，然后会明确的介绍线程调度以及它产生的问题。</p>
<h3 id="调度介绍"><a href="#调度介绍" class="headerlink" title="调度介绍"></a>调度介绍</h3><p>让我们回到早期以磁带上的卡片作为输入的批处理系统的时代，那时候的调度算法非常简单：依次运行磁带上的每一个作业。对于多道程序设计系统，会复杂一些，因为通常会有多个用户在等待服务。一些大型机仍然将 <code>批处理</code>和 <code>分时服务</code>结合使用，需要调度程序决定下一个运行的是一个批处理作业还是终端上的用户。由于在这些机器中 CPU 是稀缺资源，所以好的调度程序可以在提高性能和用户的满意度方面取得很大的成果。</p>
<h4 id="进程行为"><a href="#进程行为" class="headerlink" title="进程行为"></a>进程行为</h4><p>几乎所有的进程（磁盘或网络）I/O 请求和计算都是交替运行的</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/33.png" style="zoom:67%;"></p>
<p>如上图所示，CPU 不停顿的运行一段时间，然后发出一个系统调用等待 I/O 读写文件。完成系统调用后，CPU 又开始计算，直到它需要读更多的数据或者写入更多的数据为止。当一个进程等待外部设备完成工作而被阻塞时，才是 I/O 活动。</p>
<p>上面 a 是 CPU 密集型进程；b 是 I/O 密集型进程进程，a 因为在计算的时间上花费时间更长，因此称为<code>计算密集型(compute-bound)</code> 或者 <code>CPU 密集型(CPU-bound)</code>，b 因为I/O 发生频率比较快因此称为 <code>I/O 密集型(I/O-bound)</code>。计算密集型进程有较长的 CPU 集中使用和较小频度的 I/O 等待。I/O 密集型进程有较短的 CPU 使用时间和较频繁的 I/O 等待。注意到上面两种进程的区分关键在于 CPU 的时间占用而不是 I/O 的时间占用。I/O 密集型的原因是因为它们没有在 I/O 之间花费更多的计算、而不是 I/O 请求时间特别长。无论数据到达后需要花费多少时间，它们都需要花费相同的时间来发出读取磁盘块的硬件请求。</p>
<p>值得注意的是，随着 CPU 的速度越来越快，更多的进程倾向于 I/O 密集型。这种情况出现的原因是 CPU 速度的提升要远远高于硬盘。这种情况导致的结果是，未来对 I/O 密集型进程的调度处理似乎更为重要。这里的基本思想是，如果需要运行 I/O 密集型进程，那么就应该让它尽快得到机会，以便发出磁盘请求并保持磁盘始终忙碌。</p>
<h4 id="何时调度"><a href="#何时调度" class="headerlink" title="何时调度"></a>何时调度</h4><p>第一个和调度有关的问题是<code>何时进行调度决策</code>。存在着需要调度处理的各种情形。首先，在创建一个新进程后，需要决定是运行父进程还是子进程。因为二者的进程都处于就绪态下，这是正常的调度决策，可以任意选择，也就是说，调度程序可以任意的选择子进程或父进程开始运行。</p>
<p>第二，在进程退出时需要作出调度决定。因为此进程不再运行（因为它将不再存在），因此必须从就绪进程中选择其他进程运行。如果没有进程处于就绪态，系统提供的<code>空闲进程</code>通常会运行</p>
<p><strong>什么是空闲进程</strong></p>
<p><code>空闲进程(system-supplied idle process)</code> 是 Microsoft 公司 windows 操作系统带有的系统进程，该进程是在各个处理器上运行的单个线程，它唯一的任务是在系统没有处理其他线程时占用处理器时间。System Idle Process 并不是一个真正的进程，它是<code>核心虚拟</code>出来的，多任务操作系统都存在。在没有可用的进程时，系统处于空运行状态，此时就是System Idle Process 在正在运行。你可以简单的理解成，它代表的是 CPU 的空闲状态，数值越大代表处理器越空闲，可以通过 Windows 任务管理器查看 Windows 中的 CPU 利用率</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/34.png" style="zoom:67%;"></p>
<p>第三种情况是，当进程阻塞在 I/O 、信号量或其他原因时，必须选择另外一个进程来运行。有时，阻塞的原因会成为选择进程运行的关键因素。例如，如果 A 是一个重要进程，并且它正在等待 B 退出临界区，让 B 退出临界区从而使 A 得以运行。但是调度程序一般不会对这种情况进行考量。</p>
<p>第四点，当 I/O 中断发生时，可以做出调度决策。如果中断来自 I/O 设备，而 I/O 设备已经完成了其工作，那么那些等待 I/O 的进程现在可以继续运行。由调度程序来决定是否准备运行新的进程还是重新运行已经中断的进程。</p>
<p>如果硬件时钟以 50 或 60 Hz 或其他频率提供周期性中断，可以在每个时钟中断或第 k 个时钟中断处做出调度决策。根据如何处理时钟中断可以把调度算法可以分为两类。<code>非抢占式(nonpreemptive)</code> 调度算法挑选一个进程，让该进程运行直到被阻塞（阻塞在 I/O 上或等待另一个进程），或者直到该进程自动释放 CPU。即使该进程运行了若干个小时后，它也不会被强制挂起。这样会在时钟中断发生时不会进行调度。在处理完时钟中断后，如果没有更高优先级的进程等待，则被中断的进程会继续执行。</p>
<p>另外一种情况是 <code>抢占式</code> 调度算法，它会选择一个进程，并使其在最大固定时间内运行。如果在时间间隔结束后仍在运行，这个进程会被挂起，调度程序会选择其他进程来运行（前提是存在就绪进程）。进行抢占式调度需要在时间间隔结束时发生时钟中断，以将 CPU 的控制权交还给调度程序。如果没有可用的时钟，那么非抢占式就是唯一的选择。</p>
<h4 id="调度算法的分类"><a href="#调度算法的分类" class="headerlink" title="调度算法的分类"></a>调度算法的分类</h4><p>毫无疑问，不同的环境下需要不同的调度算法。之所以出现这种情况，是因为不同的应用程序和不同的操作系统有不同的目标。也就是说，在不同的系统中，调度程序的优化也是不同的。这里有必要划分出三种环境</p>
<ul>
<li><code>批处理(Batch)</code></li>
<li><code>交互式(Interactive)</code></li>
<li><code>实时(Real time)</code></li>
</ul>
<p>批处理系统广泛应用于商业领域，比如用来处理工资单、存货清单、账目收入、账目支出、利息计算、索赔处理和其他周期性作业。在批处理系统中，一般会选择使用<strong>非抢占式算法</strong>或者<strong>周期性比较长的抢占式算法</strong>。这种方法可以减少线程切换因此能够提升性能。 </p>
<p>在交互式用户环境中，为了避免一个进程霸占 CPU 拒绝为其他进程服务，所以需要<strong>抢占式算法</strong>。即使没有进程有意要一直运行下去，但是，由于某个进程出现错误也有可能无限期的排斥其他所有进程。为了避免这种情况，抢占式也是必须的。服务器也属于此类别，因为它们通常为多个（远程）用户提供服务，而这些用户都非常着急。计算机用户总是很忙。</p>
<p>在实时系统中，抢占有时是不需要的，因为进程知道自己可能运行不了很长时间，通常很快的做完自己的工作并阻塞。实时系统与交互式系统的差别是，实时系统只运行那些用来推进现有应用的程序，而交互式系统是通用的，它可以运行任意的非协作甚至是有恶意的程序。</p>
<h4 id="调度算法的目标"><a href="#调度算法的目标" class="headerlink" title="调度算法的目标"></a>调度算法的目标</h4><p>为了设计调度算法，有必要考虑一下什么是好的调度算法。有一些目标取决于环境（批处理、交互式或者实时）但大部分是适用于所有情况的，下面是一些需要考量的因素，我们会在下面一起讨论。</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/35.png" style="zoom:67%;"></p>
<p><strong>所有系统</strong></p>
<p>在所有的情况中，<code>公平</code>是很重要的。对一个进程给予相较于其他等价的进程更多的 CPU 时间片对其他进程来说是不公平的。当然，不同类型的进程可以采用不同的处理方式。</p>
<p>与公平有关的是系统的<code>强制执行</code>，什么意思呢？如果某公司的薪资发放系统计划在本月的15号，那么碰上了疫情大家生活都很拮据，此时老板说要在14号晚上发放薪资，那么调度程序必须强制使进程执行 14 号晚上发放薪资的策略。</p>
<p>另一个共同的目标是保持系统的<code>所有部分尽可能的忙碌</code>。如果 CPU 和所有的 I/O 设备能够一直运行，那么相对于让某些部件空转而言，每秒钟就可以完成更多的工作。例如，在批处理系统中，调度程序控制哪个作业调入内存运行。在内存中既有一些 CPU 密集型进程又有一些 I/O 密集型进程是一个比较好的想法，好于先调入和运行所有的 CPU 密集型作业，然后在它们完成之后再调入和运行所有 I/O 密集型作业的做法。使用后者这种方式会在 CPU 密集型进程启动后，争夺 CPU ，而磁盘却在空转，而当 I/O 密集型进程启动后，它们又要为磁盘而竞争，CPU 却又在空转。。。。。。显然，通过结合 I/O 密集型和 CPU 密集型，能够使整个系统运行更流畅，效率更高。</p>
<p><strong>批处理系统</strong></p>
<p>通常有三个指标来衡量系统工作状态：<strong>吞吐量、周转时间和 CPU 利用率</strong>，<code>吞吐量(throughout)</code> 是系统每小时完成的作业数量。综合考虑，每小时完成 50 个工作要比每小时完成 40 个工作好。<code>周转时间(Turnaround time)</code> 是一种平均时间，它指的是从一个批处理提交开始直到作业完成时刻为止平均时间。该数据度量了用户要得到输出所需的平均等待时间。周转时间越小越好。</p>
<p><code>CPU 利用率(CPU utilization)</code> 通常作为批处理系统上的指标。即使如此， CPU 利用率也不是一个好的度量指标，真正有价值的衡量指标是系统每小时可以完成多少作业（吞吐量），以及完成作业需要多长时间（周转时间）。把 CPU 利用率作为度量指标，就像是引擎每小时转动了多少次来比较汽车的性能一样。而且知道 CPU 的利用率什么时候接近 100% 要比什么什么时候要求得到更多的计算能力要有用。</p>
<p><strong>交互式系统</strong></p>
<p>对于交互式系统，则有不同的指标。最重要的是尽量<code>减少响应时间</code>。这个时间说的是从执行指令开始到得到结果的时间。再有后台进程运行（例如，从网络上读取和保存 E-mail 文件）的个人计算机上，用户请求启动一个程序或打开一个文件应该优先于后台的工作。能够让所有的交互式请求首先运行的就是一个好的服务。</p>
<p>一个相关的问题是 <code>均衡性(proportionality)</code>，用户对做一件事情需要多长时间总是有一种固定（不过通常不正确）的看法。当认为一个请求很复杂需要较多时间时，用户会认为很正常并且可以接受，但是一个很简单的程序却花费了很长的运行时间，用户就会很恼怒。可以拿彩印和复印来举出一个简单的例子，彩印可能需要1分钟的时间，但是用户觉得复杂并且愿意等待一分钟，相反，复印很简单只需要 5 秒钟，但是复印机花费 1 分钟却没有完成复印操作，用户就会很焦躁。</p>
<p><strong>实时系统</strong></p>
<p>实时系统则有着和交互式系统不同的考量因素，因此也就有不同的调度目标。实时系统的特点是<code>必须满足最后的截止时间</code>。例如，如果计算机控制着以固定速率产生数据的设备，未能按时运行的话可能会导致数据丢失。因此，实时系统中最重要的需求是满足所有（或大多数）时间期限。</p>
<p>在一些实事系统中，特别是涉及到多媒体的，<code>可预测性很重要</code>。偶尔不能满足最后的截止时间不重要，但是如果音频多媒体运行不稳定，声音质量会持续恶化。视频也会造成问题，但是耳朵要比眼睛敏感很多。为了避免这些问题，进程调度必须能够高度可预测的而且是有规律的。</p>
<h3 id="批处理中的调度"><a href="#批处理中的调度" class="headerlink" title="批处理中的调度"></a>批处理中的调度</h3><p>现在让我们把目光从一般性的调度转换为特定的调度算法。下面我们会探讨在批处理中的调度。</p>
<h4 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h4><p>也就是FIFO，可能最简单的非抢占式调度算法的设计就是 <code>先来先服务(first-come,first-serverd)</code>。使用此算法，将按照请求顺序为进程分配 CPU。最基本的，会有一个就绪进程的等待队列。当第一个任务从外部进入系统时，将会立即启动并允许运行任意长的时间。它不会因为运行时间太长而中断。当其他作业进入时，它们排到就绪队列尾部。当正在运行的进程阻塞，处于等待队列的第一个进程就开始运行。当一个阻塞的进程重新处于就绪态时，它会像一个新到达的任务，会排在队列的末尾，即排在所有进程最后。</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/36.png" style="zoom:67%;"></p>
<p>这个算法的强大之处在于<strong>易于理解和编程</strong>，在这个算法中，一个单链表记录了所有就绪进程。要选取一个进程运行，只要从该队列的头部移走一个进程即可；要添加一个新的作业或者阻塞一个进程，只要把这个作业或进程附加在队列的末尾即可。这是很简单的一种实现。</p>
<p>不过，先来先服务也是有缺点的，那就是<strong>没有优先级的关系</strong>，试想一下，如果有 100 个 I/O 进程正在排队，第 101 个是一个 CPU 密集型进程，那岂不是需要等 100 个 I/O 进程运行完毕才会等到一个 CPU 密集型进程运行，这在实际情况下根本不可能，所以需要优先级或者抢占式进程的出现来优先选择重要的进程运行。</p>
<h4 id="最短作业优先"><a href="#最短作业优先" class="headerlink" title="最短作业优先"></a>最短作业优先</h4><p>批处理中，第二种调度算法是 <code>最短作业优先(Shortest Job First)</code>，我们假设运行时间已知。例如，一家保险公司，因为每天要做类似的工作，所以人们可以相当精确地预测处理 1000 个索赔的一批作业需要多长时间。当输入队列中有若干个同等重要的作业被启动时，调度程序应使用最短优先作业算法</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/37.png" style="zoom:67%;"></p>
<p>如上图 a 所示，这里有 4 个作业 A、B、C、D ，运行时间分别为 8、4、4、4 分钟。若按图中的次序运行，则 A 的周转时间为 8 分钟，B 为 12 分钟，C 为 16 分钟，D 为 20 分钟，<strong>平均时间内为 14 分钟</strong></p>
<p>现在考虑使用最短作业优先算法运行 4 个作业，如上图 b 所示，目前的周转时间分别为 4、8、12、20，平均为 11 分钟，可以证明最短作业优先是最优的。考虑有 4 个作业的情况，其运行时间分别为 a、b、c、d。第一个作业在时间 a 结束，第二个在时间 a + b 结束，以此类推。平均周转时间为 (4a + 3b + 2c + d) / 4 。显然 a 对平均值的影响最大，所以 a 应该是最短优先作业，其次是 b，然后是 c ，最后是 d 它就只能影响自己的周转时间了。</p>
<blockquote>
<p>需要注意的是，在所有的进程都可以运行的情况下，最短作业优先的算法才是最优的。</p>
</blockquote>
<h4 id="最短剩余时间优先"><a href="#最短剩余时间优先" class="headerlink" title="最短剩余时间优先"></a>最短剩余时间优先</h4><p>最短作业优先的抢占式版本被称作为 <code>最短剩余时间优先(Shortest Remaining Time Next)</code> 算法。使用这个算法，调度程序总是选择剩余运行时间最短的那个进程运行。当一个新作业到达时，其整个时间同当前进程的剩余时间做比较。如果新的进程比当前运行进程需要更少的时间，当前进程就被挂起，而运行新的进程。这种方式能够使短期作业获得良好的服务。</p>
<h3 id="交互式系统中的调度"><a href="#交互式系统中的调度" class="headerlink" title="交互式系统中的调度"></a>交互式系统中的调度</h3><p>交互式系统中在个人计算机、服务器和其他系统中都是很常用的，所以有必要来探讨一下交互式调度</p>
<h4 id="轮询调度"><a href="#轮询调度" class="headerlink" title="轮询调度"></a>轮询调度</h4><p>一种最古老、最简单、最公平并且最广泛使用的算法就是 <code>轮询算法(round-robin)</code>。每个进程都会被分配一个时间段，称为<code>时间片(quantum)</code>，在这个时间片内允许进程运行。如果时间片结束时进程还在运行的话，则抢占一个 CPU 并将其分配给另一个进程。如果进程在时间片结束前阻塞或结束，则 CPU 立即进行切换。轮询算法比较容易实现。调度程序所做的就是维护一个可运行进程的列表，就像下图中的 a，当一个进程用完时间片后就被移到队列的末尾，就像下图的 b。</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/38.png" style="zoom:67%;"></p>
<p>时间片轮询调度中唯一有意思的一点就是<strong>时间片的长度</strong>。从一个进程切换到另一个进程需要一定的时间进行管理处理，包括保存寄存器的值和内存映射、更新不同的表格和列表、清除和重新调入内存高速缓存等。这种切换称作 <code>进程间切换(process switch)</code> 和 <code>上下文切换(context switch)</code>。如果进程间的切换时间需要 1ms，其中包括内存映射、清除和重新调入高速缓存等，再假设时间片设为 4 ms，那么 CPU 在做完 4 ms 有用的工作之后，CPU 将花费 1 ms 来进行进程间的切换。因此，CPU 的时间片会浪费 20% 的时间在管理开销上。耗费巨大。</p>
<p>为了提高 CPU 的效率，我们把时间片设置为 100 ms。现在时间的浪费只有 1%。但是考虑会发现下面的情况，如果在一个非常短的时间内到达 50 个请求，并且对 CPU 有不同的需求，此时会发生什么？50 个进程都被放在可运行进程列表中。如果 CPU 是空闲的，第一个进程会立即开始执行，第二个直到 100 ms 以后才会启动，以此类推。不幸的是最后一个进程需要等待 5 秒才能获得执行机会。大部分用户都会觉得对于一个简短的指令运行 5 秒中是很慢的。如果队列末尾的某些请求只需要几号秒钟的运行时间的话，这种设计就非常糟糕了。</p>
<p>另外一个因素是如果时间片设置长度要大于 CPU 使用长度，那么抢占就不会经常发生。相反，在时间片用完之前，大多数进程都已经阻塞了，那么就会引起进程间的切换。消除抢占可提高性能，因为进程切换仅在逻辑上必要时才发生，即流程阻塞且无法继续时才发生。</p>
<p>结论可以表述如下：<strong>将上下文切换时间设置得太短会导致过多的进程切换并降低 CPU 效率，但设置时间太长会导致一个短请求很长时间得不到响应。最好的切换时间是在 20 - 50 毫秒之间设置。</strong></p>
<h4 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h4><p>轮询调度假设了所有的进程是同等重要的。但事实情况可能不是这样。例如，在一所大学中的等级制度，首先是院长，然后是教授、秘书、后勤人员，最后是学生。这种将外部情况考虑在内就实现了<code>优先级调度(priority scheduling)</code></p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/39.png" style="zoom:67%;"></p>
<p>它的基本思想很明确，每个进程都被赋予一个优先级，优先级高的进程优先运行。</p>
<p>但是也不意味着高优先级的进程能够永远一直运行下去，调度程序会在每个时钟中断期间降低当前运行进程的优先级。如果此操作导致其优先级降低到下一个最高进程的优先级以下，则会发生进程切换。或者，可以为每个进程分配允许运行的最大时间间隔。当时间间隔用完后，下一个高优先级的进程会得到运行的机会。</p>
<p>可以静态或者动态的为进程分配优先级。在一台军用计算机上，可以把将军所启动的进程设为优先级 100，上校为 90 ，少校为 80，上尉为 70，中尉为 60，以此类推。UNIX 中有一条命令为 <code>nice</code> ，它允许用户为了照顾他人而自愿降低自己进程的优先级，但是一般没人用。</p>
<p>优先级也可以由系统动态分配，用于实现某种目的。例如，有些进程为 I/O 密集型，其多数时间用来等待 I/O 结束。当这样的进程需要 CPU 时，应立即分配 CPU，用来启动下一个 I/O 请求，这样就可以在另一个进程进行计算的同时执行 I/O 操作。这类 I/O 密集型进程长时间的等待 CPU 只会造成它长时间占用内存。使 I/O 密集型进程获得较好的服务的一种简单算法是，将其优先级设为 <code>1/f</code>，f 为该进程在上一时间片中所占的部分。一个在 50 ms 的时间片中只使用 1 ms 的进程将获得优先级 50 ，而在阻塞之前用掉 25 ms 的进程将具有优先级 2，而使用掉全部时间片的进程将得到优先级 1。</p>
<p>可以很方便的将一组进程按优先级分成若干类，并且在各个类之间采用优先级调度，而在各类进程的内部采用轮转调度。下面展示了一个四个优先级类的系统</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/40.png" style="zoom:67%;"></p>
<p>它的调度算法主要描述如下：上面存在优先级为 4 类的可运行进程，首先会<strong>按照轮转法</strong>为每个进程运行一个时间片，此时不理会较低优先级的进程。若第 4 类进程为空，则按照轮询的方式运行第三类进程。若第 4 类和第 3 类进程都为空，则按照轮转法运行第 2 类进程。如果不对优先级进行调整，则<strong>低优先级的进程很容易产生饥饿现象。</strong></p>
<h4 id="多级队列"><a href="#多级队列" class="headerlink" title="多级队列"></a>多级队列</h4><p>最早使用优先级调度的系统是 <code>CTSS(Compatible TimeSharing System)</code>。CTSS 是一种兼容分时系统，它有一个问题就是进程切换太慢，其原因是 IBM 7094 内存只能放进一个进程。</p>
<blockquote>
<p>IBM 是哥伦比亚大学计算机中心在 1964 - 1968 年的计算机</p>
</blockquote>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/41.png" style="zoom:67%;"></p>
<p>CTSS 在每次切换前都需要将当前进程换出到磁盘，并从磁盘上读入一个新进程。CTSS 的设计者很快就认识到，为 CPU 密集型进程设置较长的时间片比频繁地分给他们很短的时间要更有效（减少交换次数）。另一方面，如前所述，长时间片的进程又会影响到响应时间，解决办法是设置优先级类。属于最高优先级的进程运行一个时间片，次高优先级进程运行 2 个时间片，再下面一级运行 4 个时间片，以此类推。<strong>当一个进程用完分配的时间片后，它被移到下一类。</strong></p>
<h4 id="最短进程优先"><a href="#最短进程优先" class="headerlink" title="最短进程优先"></a>最短进程优先</h4><p>对于批处理系统而言，由于最短作业优先常常伴随着最短响应时间，所以如果能够把它用于交互式进程，那将是非常好的。在某种程度上，的确可以做到这一点。交互式进程通常遵循下列模式：等待命令、执行命令、等待命令、执行命令。。。如果我们把每个命令的执行都看作一个分离的作业，那么我们可以通过首先运行最短的作业来使响应时间最短。这里唯一的问题是如何从当前可运行进程中找出最短的那一个进程。</p>
<p>一种方式是根据进程过去的行为进行推测，并执行估计运行时间最短的那一个。假设每个终端上每条命令的预估运行时间为 <code>T0</code>，现在假设测量到其下一次运行时间为 <code>T1</code>，可以用两个值的加权来改进估计时间，即<code>aT0+ (1- 1)T1</code>。通过选择 a 的值，可以决定是尽快忘掉老的运行时间，还是在一段长时间内始终记住它们。当 a = 1/2 时，可以得到下面这个序列</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/42.png" style="zoom:67%;"></p>
<p>可以看到，在三轮过后，T0 在新的估计值中所占比重下降至 1/8。</p>
<p>有时把这种通过当前测量值和先前估计值进行加权平均从而得到下一个估计值的技术称作 <code>老化(aging)</code>。这种方法会使用很多预测值基于当前值的情况。</p>
<h4 id="保证调度"><a href="#保证调度" class="headerlink" title="保证调度"></a>保证调度</h4><p>一种完全不同的调度方法是对用户做出明确的性能保证。一种实际而且容易实现的保证是：若用户工作时有 n 个用户登录，则每个用户将获得 CPU 处理能力的 1/n。类似地，在一个有 n 个进程运行的单用户系统中，若所有的进程都等价，则每个进程将获得 1/n 的 CPU 时间。</p>
<h4 id="彩票调度"><a href="#彩票调度" class="headerlink" title="彩票调度"></a>彩票调度</h4><p>对用户进行承诺并在随后兑现承诺是一件好事，不过很难实现。但是存在着一种简单的方式，有一种既可以给出预测结果而又有一种比较简单的实现方式的算法，就是 <code>彩票调度(lottery scheduling)</code>算法。</p>
<p>其基本思想是为进程提供各种系统资源（例如 CPU 时间）的彩票。当做出一个调度决策的时候，就随机抽出一张彩票，拥有彩票的进程将获得该资源。在应用到 CPU 调度时，系统可以每秒持有 50 次抽奖，每个中奖者将获得比如 20 毫秒的 CPU 时间作为奖励。</p>
<p><code>George Orwell</code> 关于 <strong>所有的进程是平等的，但是某些进程能够更平等一些</strong>。一些重要的进程可以给它们额外的彩票，以便增加他们赢得的机会。如果出售了 100 张彩票，而且有一个进程持有了它们中的 20 张，它就会有 20% 的机会去赢得彩票中奖。在长时间的运行中，它就会获得 20% 的CPU。相反，对于优先级调度程序，很难说明拥有优先级 40 究竟是什么意思，这里的规则很清楚，拥有彩票 f 份额的进程大约得到系统资源的 f 份额。</p>
<p>如果希望进程之间协作的话可以交换它们之间的票据。例如，客户端进程给服务器进程发送了一条消息后阻塞，客户端进程可能会把自己所有的票据都交给服务器，来增加下一次服务器运行的机会。当服务完成后，它会把彩票还给客户端让其有机会再次运行。事实上，如果没有客户机，服务器也根本不需要彩票。</p>
<blockquote>
<p>可以把彩票理解为 buff，这个 buff 有 15% 的几率能让你产生 <code>速度之靴</code> 的效果。</p>
</blockquote>
<h4 id="公平分享调度"><a href="#公平分享调度" class="headerlink" title="公平分享调度"></a>公平分享调度</h4><p>到目前为止，我们假设被调度的都是各个进程自身，而不用考虑该进程的拥有者是谁。结果是，如果用户 1 启动了 9 个进程，而用户 2 启动了一个进程，使用轮转或相同优先级调度算法，那么用户 1 将得到 90 % 的 CPU 时间，而用户 2 将之得到 10 % 的 CPU 时间。</p>
<p>为了阻止这种情况的出现，一些系统在调度前会把进程的拥有者考虑在内。在这种模型下，每<strong>个用户都会分配一些CPU 时间</strong>，而调度程序会选择进程并强制执行。因此如果两个用户每个都会有 50% 的 CPU 时间片保证，那么无论一个用户有多少个进程，都将获得相同的 CPU 份额。</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/43.png" style="zoom:67%;"></p>
<h3 id="实时系统中的调度"><a href="#实时系统中的调度" class="headerlink" title="实时系统中的调度"></a>实时系统中的调度</h3><p><code>实时系统(real-time)</code> 是一个时间扮演了重要作用的系统。典型的，一种或多种外部物理设备发给计算机一个服务请求，而计算机必须在一个确定的时间范围内恰当的做出反应。例如，在 CD 播放器中的计算机会获得从驱动器过来的位流，然后必须在非常短的时间内将位流转换为音乐播放出来。如果计算时间过长，那么音乐就会听起来有异常。再比如说医院特别护理部门的病人监护装置、飞机中的自动驾驶系统、列车中的烟雾警告装置等，在这些例子中，正确但是却缓慢的响应要比没有响应甚至还糟糕。</p>
<p>实时系统可以分为两类，<code>硬实时(hard real time)</code> 和 <code>软实时(soft real time)</code> 系统，前者意味着必须要满足绝对的截止时间；后者的含义是虽然不希望偶尔错失截止时间，但是可以容忍。在这两种情形中，实时都是通过把程序划分为一组进程而实现的，其中每个进程的行为是可预测和提前可知的。这些进程一般寿命较短，并且极快的运行完成。在检测到一个外部信号时，调度程序的任务就是按照满足所有截止时间的要求调度进程。</p>
<p>实时系统中的事件可以按照响应方式进一步分类为<code>周期性(以规则的时间间隔发生)</code>事件或 <code>非周期性(发生时间不可预知)</code>事件。一个系统可能要响应多个周期性事件流，根据每个事件处理所需的时间，可能甚至无法处理所有事件。例如，如果有 m 个周期事件，事件 i 以周期 $P_i$ 发生，并需要 $C_i$ 秒 CPU 时间处理一个事件，那么可以处理负载的条件是</p>
<script type="math/tex; mode=display">
\sum_{i=1}^m \frac{C_i}{P_i}\leq 1</script><p>只有满足这个条件的实时系统称为<code>可调度的</code>，这意味着它实际上能够被实现。一个不满足此检验标准的进程不能被调度，因为这些进程共同需要的 CPU 时间总和大于 CPU 能提供的时间。</p>
<p>举一个例子，考虑一个有三个周期性事件的软实时系统，其周期分别是 100 ms、200 m 和 500 ms。如果这些事件分别需要 50 ms、30 ms 和 100 ms 的 CPU 时间，那么该系统时可调度的，因为 0.5 + 0.15 + 0.2 &lt; 1。如果此时有第四个事件加入，其周期为 1 秒，那么此时这个事件如果不超过 150 ms，那么仍然是可以调度的。忽略上下文切换的时间。</p>
<p>实时系统的调度算法可以是静态的或动态的。前者在系统开始运行之前做出调度决策；后者在运行过程中进行调度决策。只有在可以提前掌握所完成的工作以及必须满足的截止时间等信息时，静态调度才能工作，而动态调度不需要这些限制。</p>
<h3 id="调度策略和机制"><a href="#调度策略和机制" class="headerlink" title="调度策略和机制"></a>调度策略和机制</h3><p>到目前为止，我们隐含的假设系统中所有进程属于不同的分组用户并且进程间存在相互竞争 CPU 的情况。通常情况下确实如此，但有时也会发生一个进程会有很多子进程并在其控制下运行的情况。例如，一个数据库管理系统进程会有很多子进程。每一个子进程可能处理不同的请求，或者每个子进程实现不同的功能（如请求分析、磁盘访问等）。主进程完全可能掌握哪一个子进程最重要（或最紧迫），而哪一个最不重要。但是，以上讨论的调度算法中没有一个算法从用户进程接收有关的调度决策信息，这就导致了调度程序很少能够做出最优的选择。</p>
<p>解决问题的办法是将 <code>调度机制(scheduling mechanism)</code> 和 <code>调度策略(scheduling policy)</code> 分开，这是长期一贯的原则。这也就意味着调度算法在某种方式下被参数化了，但是参数可以被用户进程填写。让我们首先考虑数据库的例子。假设内核使用优先级调度算法，并提供了一条可供进程设置优先级的系统调用。这样，尽管父进程本身并不参与调度，但它可以控制如何调度子进程的细节。调度机制位于内核，而调度策略由用户进程决定，调度策略和机制分离是一种关键性思路。</p>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>当若干进程都有多个线程时，就存在两个层次的并行：进程和线程。在这样的系统中调度处理有本质的差别，这取决于所支持的是用户级线程还是内核级线程（或两者都支持）。</p>
<p>首先考虑<strong>用户级线程</strong>，由于内核并不知道有线程存在，所以内核还是和以前一样地操作，选取一个进程，假设为 A，并给予 A 以时间片控制。A 中的线程调度程序决定哪个线程运行。假设为 A1。由于多道线程并不存在时钟中断，所以这个线程可以按其意愿任意运行多长时间。如果该线程用完了进程的全部时间片，内核就会选择另一个进程继续运行。</p>
<p>在进程 A 终于又一次运行时，线程 A1 会接着运行。该线程会继续耗费 A 进程的所有时间，直到它完成工作。不过，线程运行不会影响到其他进程。其他进程会得到调度程序所分配的合适份额，不会考虑进程 A 内部发生的事情。</p>
<p>现在考虑 A 线程每次 CPU 计算的工作比较少的情况，例如：在 50 ms 的时间片中有 5 ms 的计算工作。于是，每个线程运行一会儿，然后把 CPU 交回给线程调度程序。这样在内核切换到进程 B 之前，就会有序列 A1,A2,A3,A1,A2,A3,A1,A2,A3,A1 。 如下所示</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/45.png" style="zoom:67%;"></p>
<p>运行时系统使用的调度算法可以是上面介绍算法的任意一种。<strong>从实用方面考虑，轮转调度和优先级调度更为常用</strong>。唯一的局限是，缺乏一个时钟中断运行过长的线程。但由于线程之间的合作关系，这通常也不是问题。</p>
<p>现在考虑使用<strong>内核线程的情况</strong>，内核选择一个特定的线程运行。它不用考虑线程属于哪个进程，不过如果有必要的话，也可以这么做。对被选择的线程赋予一个时间片，而且如果超过了时间片，就会强制挂起该线程。一个线程在 50 ms 的时间片内，5 ms 之后被阻塞，在 30 ms 的时间片中，线程的顺序会是 A1,B1,A2,B2,A3,B3。如下图所示</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/46.png" style="zoom:67%;"></p>
<p>用户级线程和内核级线程之间的主要差别在于<code>性能</code>。用户级线程的切换需要少量的机器指令（想象一下Java程序的线程切换），而内核线程需要完整的上下文切换，修改内存映像，使高速缓存失效，这会导致了若干数量级的延迟。另一方面，在使用内核级线程时，一旦线程阻塞在 I/O 上就不需要在用户级线程中那样将整个进程挂起。</p>
<p>从进程 A 的一个线程切换到进程 B 的一个线程，其消耗要远高于运行进程 A 的两个线程（涉及修改内存映像，修改高速缓存），内核对这种切换的消耗是了解到，可以通过这些信息作出决定。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/05/04/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/04/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/" class="post-title-link" itemprop="url">矩阵分解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-04 20:28:47" itemprop="dateCreated datePublished" datetime="2021-05-04T20:28:47+08:00">2021-05-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-06-29 22:07:20" itemprop="dateModified" datetime="2021-06-29T22:07:20+08:00">2021-06-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="矩阵分解"><a href="#矩阵分解" class="headerlink" title="矩阵分解"></a>矩阵分解</h1><h2 id="具有特殊结构和性质的矩阵"><a href="#具有特殊结构和性质的矩阵" class="headerlink" title="具有特殊结构和性质的矩阵"></a>具有特殊结构和性质的矩阵</h2><h3 id="数学中常见的具有特殊结构的矩阵"><a href="#数学中常见的具有特殊结构的矩阵" class="headerlink" title="数学中常见的具有特殊结构的矩阵"></a>数学中常见的具有特殊结构的矩阵</h3><h4 id="方阵"><a href="#方阵" class="headerlink" title="方阵"></a>方阵</h4><p>行数与列数都等于n 的叫做n阶方阵</p>
<ul>
<li>只有方阵才可以计算行列式</li>
<li>方阵才有逆矩阵，且方阵有逆矩阵当且仅当方阵满秩</li>
<li>只有方阵才有伴随矩阵</li>
<li>只有方阵才有特征值与特征向量</li>
</ul>
<h4 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h4><p>矩阵A是对称矩阵当且仅当</p>
<script type="math/tex; mode=display">
A^T = A</script><h4 id="正-半-定矩阵"><a href="#正-半-定矩阵" class="headerlink" title="正(半)定矩阵"></a>正(半)定矩阵</h4><p><img src="/2021/05/04/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/1.png" style="zoom:67%;"></p>
<h4 id="对角矩阵"><a href="#对角矩阵" class="headerlink" title="对角矩阵"></a>对角矩阵</h4><p>非对角元素都为零元素的方阵叫做对角矩阵</p>
<h4 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h4><p>三角矩阵是对角元下方或对角元上方全是0的方阵</p>
<ul>
<li>三角矩阵主对角线上元素均非零 $\Leftrightarrow$ 三角矩阵可逆</li>
<li>上三角、下三角矩阵的乘积还是上、下三角矩阵</li>
<li>上、下三角矩阵可逆则其逆矩阵也是上、下三角矩阵</li>
<li>设矩阵 A 为三角矩阵，那么 矩阵 $A^k$ 主对角线上的元素满足 $(A^k)_{ii} =(A_ii)^k,i=1,2\cdots,n$</li>
</ul>
<h4 id="正交矩阵"><a href="#正交矩阵" class="headerlink" title="正交矩阵"></a>正交矩阵</h4><p>正交矩阵指行向量和列向量是分别标准正交的方阵即</p>
<script type="math/tex; mode=display">
A^TA = AA^T = I</script><p>所以,  $A^{-1} = A^T$</p>
<ul>
<li><p>如果矩阵 $U\in \mathbb R^{m\times m},V\in\mathbb R^{n\times n} $ 是正交矩阵， $M\in \mathbb R^{m\times n},x\in \mathbb R^m$ </p>
<ul>
<li><script type="math/tex; mode=display">
||U||_2 =1, ||U||_F = \sqrt {m}</script></li>
<li><script type="math/tex; mode=display">
||Ux||_2 = ||x||_2, ||Ux||_F = ||x||_F</script></li>
<li><script type="math/tex; mode=display">
||UMV||_2 = ||M||_2,||UMV||_F = ||M||_F</script></li>
</ul>
</li>
</ul>
<h4 id="Dyads-并向量或单纯矩阵或秩1矩阵"><a href="#Dyads-并向量或单纯矩阵或秩1矩阵" class="headerlink" title="Dyads(并向量或单纯矩阵或秩1矩阵)"></a>Dyads(并向量或单纯矩阵或秩1矩阵)</h4><p>矩阵 $A\in \mathbb R^{m\times n}$ 具有如下形式：</p>
<script type="math/tex; mode=display">
 A = uv^T</script><p>其中向量 $u\in \mathbb R^m,v\in \mathbb R^n$ ，则称其为dyad，也称并向量或单纯矩阵。如果 u 和 v 不为0，则我们称其为 <strong>秩1矩阵</strong> </p>
<h2 id="LU-分解"><a href="#LU-分解" class="headerlink" title="LU 分解"></a>LU 分解</h2><p><strong>LU 分解指将</strong>$n\times n$ <strong>的矩阵A分解成两个三角矩阵的乘积</strong></p>
<p>其中， L 为 $n\times n$ 单位下三角矩阵(对角元素为1)，U 是  $n\times n$ 上三角矩阵。</p>
<p>从秩1分解的角度分析 $A=LU$ , 可以将 A 写成若干个 秩1矩阵和的形式：</p>
<script type="math/tex; mode=display">
A = l_1u_1+\cdots+l_ru_r = \sum_{i=1}^r l_iu_i</script><p>其中r为矩阵A的秩，若A是满秩，则 $r=n$ 。 $l_i$ 是 $L$ 的第$i$列；$u_i$ 是 $U$ 的第$i$行。 $l_iu_i$ 都是秩为1的矩阵，并且这个矩阵的前 $i-1$行和前$i-1$列的元素都是0</p>
<p>求矩阵A</p>
<script type="math/tex; mode=display">
A=\begin{pmatrix} 1 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 10 \end{pmatrix}</script><p>的LU分解</p>
<p>我们要像<strong>剥洋葱</strong>一样一层一层地分解矩阵A，同时要记得 L 的对角线都是1</p>
<ul>
<li>第一步</li>
</ul>
<p>令 $u<em>1$ 是 A 的第1行，$l_1$ 是A的第1列 除以 $u</em>{11}$ ,则：</p>
<script type="math/tex; mode=display">
l_1u_1 =\begin{pmatrix} 1 \\ 4 \\ 7  \end{pmatrix}\begin{pmatrix} 1 & 2 & 3\end{pmatrix} = \begin{pmatrix} 1 & 2 & 3 \\ 4 & 8 & 12 \\ 7 & 14 & 21 \end{pmatrix}\\~~\\
A-l_1u_1 = \begin{pmatrix} 1 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 10 \end{pmatrix}-\begin{pmatrix} 1 & 2 & 3 \\ 4 & 8 & 12 \\ 7 & 14 & 21 \end{pmatrix} = \begin{pmatrix} 0 & 0 & 0 \\ 0 & -3 & -6 \\ 0 & -6 & -11 \end{pmatrix}</script><ul>
<li>第二步</li>
</ul>
<p>令 $u<em>2$ 是 $A-l_1 u_1$ 的第2行，$l_2$ 是 $A-l_1u_1$ 的第二列除以$u</em>{22}$ </p>
<script type="math/tex; mode=display">
l_2u_2 =\begin{pmatrix} 0 \\ 1 \\ 2  \end{pmatrix}\begin{pmatrix} 0 & -3 & -6\end{pmatrix} = \begin{pmatrix} 0 & 0 & 0 \\ 0 & -3 & -6 \\ 0 & -6 & -12 \end{pmatrix}\\~~\\
A-l_1u_1-l_2u_2 = \begin{pmatrix} 0 & 0 & 0 \\ 0 & -3 & -6 \\ 0 & -6 & -11 \end{pmatrix}-\begin{pmatrix} 0 & 0 & 0 \\ 0 & -3 & -6 \\ 0 & -6 & -12 \end{pmatrix} = \begin{pmatrix} 0 & 0 & 0 \\ 0 & 0 & 0 \\ 0 & 0 & 1 \end{pmatrix}</script><ul>
<li>第三步</li>
</ul>
<p>令$u<em>3$ 是$A-l_1u_1-l_2u_2$  的第3行，$l_3$ 是 $A-l_1u_1-l_2u_2$ 的第3列除以$u</em>{33}$ 即</p>
<script type="math/tex; mode=display">
l_3 =\begin{pmatrix} 0 \\ 0 \\ 1  \end{pmatrix}, u_3 = \begin{pmatrix} 0 & 0 & 1 \end{pmatrix}</script><ul>
<li>第四步，我们要把$l_1,l_2,l_3$ 相加得到$L$ ,$u_1,u_2,u_3$ 相加得到$U$ </li>
</ul>
<script type="math/tex; mode=display">
A = LU = \begin{pmatrix} 1 & 0 & 0 \\ 4 & 1 & 0 \\ 7 & 2 & 1 \end{pmatrix}\begin{pmatrix} 1 & 2 & 3 \\ 0 & -3 & -6 \\ 0 & 0 & 1 \end{pmatrix}</script><h2 id="QR-分解"><a href="#QR-分解" class="headerlink" title="QR 分解"></a>QR 分解</h2><p>QR分解指将矩阵A分解成列正交矩阵和上三角矩阵的乘积，形式如下：</p>
<script type="math/tex; mode=display">
A = QR = \begin{pmatrix} q_1 & q_2 & q_3 \end{pmatrix} \begin{pmatrix} r_1 \\ r_2 \\ r_3 \end{pmatrix} = q_1r_1+q_2r_2+\cdots+q_nr_n</script><p>其中 Q 是列正交矩阵，R是上三角矩阵。 $q_i$ 是 $Q$ 的列向量，$r_i$ 是 $R$ 的行向量。 且 $q_ir_i$ 的前 $i-1$ 列都为0。</p>
<p>矩阵的QR分解可以通过 <strong>Gram-Schmidt</strong> 正交化，<strong>Household</strong> 变换，<strong>Givens</strong>变换等方法实现</p>
<h3 id="Gram-Schmidt-正交化法"><a href="#Gram-Schmidt-正交化法" class="headerlink" title="Gram-Schmidt 正交化法"></a>Gram-Schmidt 正交化法</h3><p>首先要求出单位化后的特征向量。我们定义投影操作为： $proj_u= \frac{<u,a>}{<u,u>}u$, 也就是获取<strong>a</strong>在<strong>u</strong>方向上的分量</u,u></u,a></p>
<p>对于一个满秩矩阵：$A=[a_1,\cdots,a_n]$</p>
<script type="math/tex; mode=display">
u_1 = a_1, ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~e_1=\frac{u_1}{||u_1||}\\
u_2 = a_2-proj_{u_1}a_2 ~~~~~~~~~~~~~~~~~~~~~e_2=\frac{u_2}{||u_2||}\\
u_3=a_3-proj_{u_1}a_3-proj_{u_2}a_3~~e_3=\frac{u_3}{||u_3||}\\
u_k = a_k-\sum_{j=1}^{k-1}proj_{u_j}a_k,~~~~~~~~~~~~~~e_k=\frac{u_k}{||u_k||}</script><p>矩阵A的QR分解就可以写为：</p>
<script type="math/tex; mode=display">
Q = [e_1,\cdots,e_n]</script><p>和</p>
<script type="math/tex; mode=display">
R=</script><h4 id="分解方阵"><a href="#分解方阵" class="headerlink" title="分解方阵"></a>分解方阵</h4><script type="math/tex; mode=display">
a_1 = (0,1,1)^T ,a_2=(1,1,0)^T,a_3=(1,0,1)^T</script><p>我们先用正交化方法可得：其中$q_i$代表标准化后的 $b_i$ </p>
<script type="math/tex; mode=display">
b_1 = a_1 = (0,1,1)^T,~~|b_1| = \sqrt{2}\\
b_2 = a_2-\frac{[a_2,b_1]}{[b_1,b_1]}b_1=(1,1,0)^T-\frac{1}{2}(0,1,1)^T = (1,\frac{1}{2},-\frac{1}{2})^T,|b_2| = \frac{\sqrt{6}}{2}\\
b_3 = a_3-\frac{[a_3,b_2]}{[b_2,b_2]}b_1-\frac{[a_3,b_2]}{[b_2,b_2]}b_2 = (1,0,1)^T-\frac{1}{2}(0,1,1)^T-\frac{0.5}{1.5}(1,\frac{1}{2},-\frac{1}{2})^T = (\frac{2}{3},-\frac{2}{3},\frac{2}{3})^T \\</script><p>现在来计算标准化后的矩阵：</p>
<script type="math/tex; mode=display">
q_1 = \frac{1}{\sqrt 2}(0,1,1)^T\\
q_2 = \frac{1}{\sqrt 6}(2,1,-1)^T\\
q_3 = \frac{\sqrt 3}{2}(\frac{2}{3},-\frac{2}{3},\frac{2}{3})^T\\</script><p>因此， </p>
<script type="math/tex; mode=display">
Q = (q_1,q_2,q_3) = \begin{bmatrix} 0 & \dfrac{2}{\sqrt{6}} & \dfrac{1}{\sqrt{3}} \\ \dfrac{1}{\sqrt{2}} & \dfrac{1}{\sqrt{6}} & -\dfrac{1}{\sqrt{3}} \\ \dfrac{1}{\sqrt{2}} & \dfrac{-1}{\sqrt{6}} & \dfrac{1}{\sqrt{3}} \end{bmatrix}</script><script type="math/tex; mode=display">
R =  \begin{bmatrix} |b_1| & [a_2,q_1] & [a_3,q_1] \\ 0 & |b_2| & [a_3,q_2] \\ 0 & 0 & |b_3| \end{bmatrix} =\begin{bmatrix} \sqrt{2} & \dfrac{1}{\sqrt{2}} & \dfrac{1}{\sqrt{2}} \\ 0 & \dfrac{\sqrt{6}}{2} & \dfrac{1}{\sqrt{6}} \\ 0 & 0 & \dfrac{2}{\sqrt{3}} \end{bmatrix}</script><h2 id="谱分解"><a href="#谱分解" class="headerlink" title="谱分解"></a>谱分解</h2><p>设对称矩阵A为n阶方阵，如果A可以被分解为$A=Q\Lambda Q^T$ , 其中 $Q=[q_1,q_2,\cdots,q_n]$ 是由特征向量 $q_1,q_2\cdots,q_n$ 组成的n阶方阵， $\Lambda = diag(\lambda_1,\lambda_2,\cdots,\lambda_n)$  是由特征值$\lambda_1,\lambda_2\cdots,\lambda_n$ 组成的n阶对角矩阵，则这种分解叫做对称矩阵的<strong>谱分解</strong>或者<strong>特征分解</strong></p>
<p>求解对称方程 $A\in \mathbb R^{n\times n}$ 的特征分解步骤</p>
<ul>
<li><p>计算矩阵A的特征值$\lambda_1\cdots,\lambda_n$ 即 求特征方程 $|A-\lambda I| = 0$  的n个根</p>
</li>
<li><p>求特征值对应的n个相互正交的特征向量 $q_1,\cdots,q_n$即求解方程组并单位化</p>
<script type="math/tex; mode=display">
Aq_i = \lambda_iq_i,i=1,\cdots,n</script></li>
<li><p>记矩阵 $Q=(q_1,\cdots,q_n)$ </p>
</li>
<li><p>最终得到矩阵A的特征分解为 </p>
<script type="math/tex; mode=display">
A = Q\begin{pmatrix} \lambda_1 &  &  \\  & \cdots &  \\ & & \lambda_n \end{pmatrix}Q^T</script></li>
</ul>
<p>求实对称矩阵的特征分解</p>
<script type="math/tex; mode=display">
A =\begin{bmatrix} 2& 1\\ 1 & 2 \end{bmatrix}</script><ol>
<li>首先我们计算特征向量</li>
</ol>
<script type="math/tex; mode=display">
|\lambda I-A| =\begin{bmatrix}\lambda-2& -1\\ -1 & \lambda-2 \end{bmatrix}=0\\</script><p>特征值：$\lambda_1=3,\lambda_2=1$</p>
<p>带入求解并单位化： $q_1 = (\frac{1}{\sqrt 2},\frac{1}{\sqrt 2})^T,q_2 = (-\frac{1}{\sqrt2},\frac{1}{\sqrt2})^T$ </p>
<ol>
<li>写出左特征向量方阵Q和特征值方阵 $\Lambda$ </li>
</ol>
<script type="math/tex; mode=display">
Q =[q_1,q_2] =\begin{bmatrix} \frac{1}{\sqrt2}& -\frac{1}{\sqrt 2}\\ \frac{1}{\sqrt 2} & \frac{1}{\sqrt2} \end{bmatrix},\Lambda =\begin{bmatrix} \lambda_1 & \\  & \lambda_2 \end{bmatrix} = \begin{bmatrix} 3 &\\ & 1 \end{bmatrix}</script><ol>
<li>$p=(\alpha_1,\alpha_2,\alpha_3),(p^{-1})^T=(\beta_1,\beta_2,\beta_3)$ </li>
</ol>
<script type="math/tex; mode=display">
G_1 = \alpha_1\beta_1^T+\alpha_2\beta_2^T\\~\\
G_2 = \alpha_3\beta_3^T</script><p>A和$G_1,G_2$的关系就是谱分解</p>
<h2 id="Cholesky-分解"><a href="#Cholesky-分解" class="headerlink" title="Cholesky 分解"></a>Cholesky 分解</h2><p>设 $A = (a_{ij})\in R^{n\times n}$是对称正定矩阵， $A=GG^T$称为矩阵A的Cholesky 分解。 其中，$G\in R^{n\times n}$  是一个具有正的对角线元素的下三角矩阵。</p>
<script type="math/tex; mode=display">
G =\begin{pmatrix} g_{11} &  & & \\ g_{21} & g_{22} & & \\ \cdots & \cdots & \cdots &\\g_{n1}&g_{n2}&\cdots&g_{nn} \end{pmatrix}</script><script type="math/tex; mode=display">
l_{11}=\sqrt{a_{11}}\\~\\
l_{i1} = \frac{a_{i1}}{l_{11}} ~(i=2,3,\cdots,n)</script><p>这样就得到了第一列元素</p>
<p>假设已经算出L的前 $k-1$ 列元素，通过 $a<em>{kk} = \sum</em>{i=1}^k l^2_{ki}$</p>
<p>得到：</p>
<script type="math/tex; mode=display">
l_{kk} = \sqrt{a_{kk}-\sum_{i=1}^{k-1}l_{ki}^2}</script><p>进一步再由：</p>
<script type="math/tex; mode=display">
a_{ik} = \sum_{j=1}^{k-1}l_{ij}l_{kj}+l_{ik}l_{kk}</script><p>得到：</p>
<script type="math/tex; mode=display">
l_{ik} = \frac{a_{ik}-\sum_{j=1}^{k-1}l_{ij}l_{kj}}{l_{kk}},(i = k+1,\cdots,n)</script><p>也就是可以通过L的前k-1列来求出第k列</p>
<p>一般来说只会让我们求3阶的矩阵分解，这时候要求六个元素</p>
<ol>
<li>第一阶段，求 $l<em>{11}=\sqrt{a</em>{11}}$</li>
<li>再求第一列的两个元素： $l<em>{21}=\frac{a</em>{21}}{l<em>{11}},l</em>{31}=\frac{a<em>{31}}{l</em>{11}}$</li>
<li>第二阶段，求$l<em>{22} = \sqrt{a</em>{22}-l^2_{21}}$ </li>
<li>求$l<em>{32}=\frac{a</em>{32}-l<em>{31}l</em>{21}}{l_{22}}$</li>
<li>第三阶段，求 $l<em>{33}=\sqrt{a</em>{33}-(l<em>{31}^2+l^2</em>{32})}$</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">计算机网络-运输层总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-03 00:17:00" itemprop="dateCreated datePublished" datetime="2021-05-03T00:17:00+08:00">2021-05-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-24 13:17:58" itemprop="dateModified" datetime="2022-08-24T13:17:58+08:00">2022-08-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机网络-运输层"><a href="#计算机网络-运输层" class="headerlink" title="计算机网络-运输层"></a>计算机网络-运输层</h1><h2 id="概述和运输层服务"><a href="#概述和运输层服务" class="headerlink" title="概述和运输层服务"></a>概述和运输层服务</h2><p>运输层位于应用层和网络层之间，主要为运行<strong>在不同主机上</strong>的应用进程提供了<strong>逻辑通信</strong>。 非常类似于高速公路，高速公路负责把人或者物品从一端运送到另一端，而运输层则负责把报文从一个端系统运送到另一个端系统(手机、网络媒体等)</p>
<p>在运输层运输报文的过程中，会遵循一定的协议规范。比如一次传输的数据显示、选择什么样的运输协议等。运输层实现了让两个互不相关的主机好像直接相连一样，这就是<strong>逻辑通信</strong>的意义。</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/1.png" style="zoom:67%;"></p>
<p>上面是一个数据包首部的结构，数据包经过每层后，该层协议都会在数据包附上包首部。那么，在数据传输到运输层后，如果采用的是TCP协议，那么会为其附上TCP首部，首部包含着<strong>源端口号</strong>,<strong>目的端口号</strong> 。 </p>
<p>在发送端，运输层将从发送应用程序进程 接收到的报文转化成 <strong>运输层分组</strong>， 分组在计算机网络中也称为<strong>报文段</strong>。运输层一般会把报文段进行分割，分割成为较小的块，为每一块加上运输层首部(否则不知道源端口和目的端口)并将其向目的地发送。</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>在TCP/IP 协议中能实现传输层功能的，最具代表性的就是TCP和UDP，它就好像是高速公路上的交通工具。</p>
<p>TCP 叫做 <strong>Transmission Control Protocol(传输控制协议)</strong> ，通过名称可以大致知道TCP协议有控制传输的功能。TCP为应用层提供了一种<strong>可靠、面向连接的</strong> 服务，能够将分组可靠的传输到服务端。</p>
<p>UDP 叫做<strong>User Datagram Protocol(用户数据报协议)</strong> ,UDP 为应用层提供了一种<strong>无需建立连接</strong> 就可以直接发送数据报的方法。但是传输过程是不可靠的。</p>
<blockquote>
<p>在计算机网络中，不同层对数据有不同的描述。上面讲运输层的分组称为报文段，除此之外，还会将TCP中的分组也称为报文段，但是将UDP的分组称为数据报，网络层的分组也称为数据报</p>
<p>但是为了统一，我们这边就统称为报文段</p>
</blockquote>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/2.png" style="zoom:67%;"></p>
<h3 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字(socket)"></a>套接字(socket)</h3><p>在TCP或UDP发送报文信息前，要经过一扇门，也就是<strong>套接字(socket)</strong>,向上连接着应用层，向下连接着网络层。</p>
<p>使用TCP或者UDP通信时，会广泛使用到套接字的API来设置IP地址、端口号，实现数据的发送和接收。</p>
<p>Socket和<code>TCP/IP</code>没有必然联系，但是方便了<code>TCP/IP</code>的使用.比如说:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>create()</code></td>
<td>创建一个socket</td>
</tr>
<tr>
<td><code>bind()</code></td>
<td>套接字标识，一般用于绑定端口号</td>
</tr>
<tr>
<td><code>listen()</code></td>
<td>准备接收连接</td>
</tr>
<tr>
<td><code>accept()</code></td>
<td>准备作为接收者</td>
</tr>
<tr>
<td><code>write()</code></td>
<td>发送数据</td>
</tr>
<tr>
<td><code>read()</code></td>
<td>接收数据</td>
</tr>
<tr>
<td><code>close()</code></td>
<td>关闭连接</td>
</tr>
</tbody>
</table>
</div>
<h4 id="套接字类型"><a href="#套接字类型" class="headerlink" title="套接字类型"></a>套接字类型</h4><ul>
<li><strong>Datagram sockets</strong>: 数据报套接字提供一种<strong>无连接</strong>的服务，而且不能保证数据传输的可靠性。数据有可能出现丢失或者重复，且无法保证顺序地接收到数据。数据报套接字使用<code>UDP</code> 进行数据的传输。我们需要在程序中作相应的处理才能解决有可能出现的数据丢失的情况。</li>
<li><strong>Stream sockets:</strong> 流套接字用于<strong>面向连接、可靠的</strong>数据传输服务。能够保证数据的可靠性、顺序性。 流套接字之所以能够实现可靠的数据服务。员应在于其使用了传输控制协议，即 TCP协议</li>
<li><strong>Raw sockets:</strong> 原始套接字允许直接发送和接收IP数据报，而无需任何特定于协议的传输层格式，原始套接字可以读写内核没有处理过的IP数据报。</li>
</ul>
<h3 id="套接字处理过程"><a href="#套接字处理过程" class="headerlink" title="套接字处理过程"></a>套接字处理过程</h3><p>在计算机网络中，要想实现通信，必须要<strong>两个端系统</strong>，至少需要<strong>两个套接字</strong></p>
<ol>
<li>socket 中的API用于创建通信链路中的端点，创建完成后会返回<code>套接字描述符</code>。使用套接字描述符可以用来访问套接字</li>
<li>当应用程序具有套接字描述符之后，可以将唯一的名字绑定在套接字上，服务器必须绑定一个名称才能在网络中访问</li>
<li>客户端在为服务端分配了socket 并且使用<code>bind()</code> 将名称绑定到套接字上后，会调用<code>listen()</code> ，表示愿意等待连接的意愿,<code>listen</code>必须在<code>accept</code> <strong>之前</strong>使用 </li>
<li>服务器应用程序 使用<code>accept()</code> api 接受客户端连接请求，服务器必须先成功调用 <code>bind</code> 和<code>listen</code> 之后，再调用 <code>accept()</code></li>
<li>现在，流套接字已经建立，客户端和服务器端可以发起<code>read/write</code>api调用了</li>
<li>当服务器或者客户端要停止操作时，就会调用<code>close</code>API 释放套接字获取的系统资源</li>
</ol>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>端口号可以理解为Socket 的ID。是一个<strong>16</strong>位的非负整数，介于 [0-65535] 之间，这个范围会分成3个不同的端口号段：</p>
<ul>
<li>周知/标准端口号， 范围是 0 - 1023</li>
<li>注册端口号，范围 1024-49151</li>
<li>私有端口号，范围 49152-65535</li>
</ul>
<p>当到达服务器的两条数据都是同一个端口，但是协议不同，该如何区分这个报文段的传送对象呢？互联网上一般使用<strong>源IP地址、目标IP地址、源端口号、目标端口号</strong> 来进行区分。 如果其中的某一项不同，就会被认为是不同的报文段。</p>
<h2 id="多路复用和多路分解"><a href="#多路复用和多路分解" class="headerlink" title="多路复用和多路分解"></a>多路复用和多路分解</h2><p>当报文段到达主机时，运输层会检查报文段中的目的端口号，并将其定向到相应的套接字，这叫做<strong>多路分解。</strong>然后报文段中的数据通过套接字进入其所连接的进程。(向上传递)</p>
<p>在源主机从不同的套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层，所有这些工作被称为<strong>多路复用</strong>。(向下传递)</p>
<p>多路复用和多路分解分为两种：<strong>无连接的多路复用和多路分解</strong> 和 <strong>面向连接的多路复用和多路分解</strong></p>
<h3 id="无连接的多路复用和多路分解"><a href="#无连接的多路复用和多路分解" class="headerlink" title="无连接的多路复用和多路分解"></a>无连接的多路复用和多路分解</h3><p>如下图所示，加入主机A中的端口 19157 要向服务器B端口46428 发送数据，采用UDP协议。 那么数据在应用层产生之后，会在运输层中加工处理，然后在网络层中将数据封装获得IP数据包，IP数据包通过链路层尽力而为得交付给服务器B，然后主机B会检查报文段中的<strong>端口号</strong>判断是哪个套接字的。</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/3.png"></p>
<p>所以，UDP套接字其实就是个二元组，包含目的IP地址和目的端口号、</p>
<p>所以，如果两个UDP报文段有<strong>不同的源IP地址</strong>和<strong>相同的源端口号</strong> ，但是具有<strong>相同的目的IP地址</strong>和<strong>目的端口号</strong>，那么这两个报文会通过套接字定位到<strong>相同的</strong>进程</p>
<p>在A到B的报文段中，源端口号作为 “<strong>返回地址</strong>” 的一部分，即当B需要发回一个报文段给A时，B到A的报文段中的目的端口号便从A到B的报文段的源端口号中取值。</p>
<h3 id="面向连接的多路复用与多路分解"><a href="#面向连接的多路复用与多路分解" class="headerlink" title="面向连接的多路复用与多路分解"></a>面向连接的多路复用与多路分解</h3><p>如果说无连接的多路复用和多路分解指的是UDP的话，那么面向连接的多路复用与多路分解指的是TCP了。和UDP的报文结构为一个二元组不同，TCP的报文结构时一个<strong>四元组</strong>，即<strong>源IP地址、目标IP地址、源端口号、目标端口号</strong>， 当一个TCP报文段从网络到达一台主机时，这个主机会根据这四个值拆解到对应的套接字上。</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/4.png" style="zoom:67%;"></p>
<p>上图显示了面向连接的多路复用和多路分解的过程，图中主机C向主机B发起了两个HTTP请求，主机A向主机C发起了一个HTTP请求，主机A,B,C都有自己唯一的IP地址，当主机C发出HTTP请求后，主机B能够进行分解。对于主机A和主机C来说，这<strong>两个主机有不同的IP地址</strong>，所以对于主机B来说，也能够进行分解。</p>
<h2 id="UDP-无连接运输"><a href="#UDP-无连接运输" class="headerlink" title="UDP 无连接运输"></a>UDP 无连接运输</h2><p>UDP 为应用程序提供了一种<strong>无需建立连接</strong>就可以发送分装的IP数据包的方法。如果应用程序开发人员选择的是UDP而不是TCP的话，那么该应用程序相当于就是直接和IP直接打交道的。</p>
<p>所谓的无需建立连接，就是在使用UDP协议在将数据报传递给目标主机时，发送方和接收方的运输层实体间<strong>是没有握手的</strong>。</p>
<h3 id="UDP-的特点"><a href="#UDP-的特点" class="headerlink" title="UDP 的特点"></a>UDP 的特点</h3><p>UDP协议一般是作为流媒体应用、语音交流、视频会议所使用的传输层协议，包括DNS协议的底层也是使用了UDP协议，原因主要是因为以下几点</p>
<ul>
<li><strong>速度快</strong>，采用UDP协议时，只要应用进程将数据传给UDP，UDP就会将此数据打包进UDP报文段并立刻传递给网络层。 但是TCP有拥塞控制的功能，它会在发送前判断互联网拥堵情况，如果互联网极度阻塞，那么就会抑制TCP的发送方。使用UDP的目的就是<strong>实时性</strong></li>
<li><strong>无需建立连接</strong>：TCP在数据传输前需要经过三次握手的操作，而UDP则无需任何准备可进行数据传输。我们可以做一个比喻：<ul>
<li>TCP 是一种凡事都要设计好，没设计不会进行开发的工程师，需要把一切因素考虑在内后再开干，所以非常靠谱</li>
<li>UDP是上来直接开干，也不管设计也不管技术，这种开发人员非常不靠谱，但是适合快速迭代开发，可以马上上手<ul>
<li>但是并不是所有使用UDP协议的应用层都是不可靠的，应用程序可以自己实现可靠的数据传输，通过增加确认和重传机制。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="UDP-报文结构"><a href="#UDP-报文结构" class="headerlink" title="UDP 报文结构"></a>UDP 报文结构</h3><p>下面来看一下UDP的报文结构，每个UDP报文分为UDP报头和UDP数据区两部分。报头由<strong>4个16位长</strong>(2字节) 字段组成，分别说明该报文的<strong>源端口、目的端口、报文长度、校验值</strong></p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/5.png" style="zoom:67%;"></p>
<ul>
<li><strong>源端口号(Source Port)</strong>: 这个字段占据UDP报文头的前16位，通常包含发送数据报的应用程序所使用的UDP端口。接收端的应用程序利用这个字段的值作为发送响应的目的地址。 有时候不会设置源端口号，没有端口号就默认为0， 通常用于不需要返回消息的同信中</li>
<li><strong>目标端口号(Destination Port)</strong>: 表示接收端口，字段长位16位</li>
<li><strong>长度(Length)</strong>: 字段占据16位，表示UDP数据报的长度，等于UDP报文头长度+UDP数据长度。因为报文头长度为4*2 = 8 个字节，所以这个值最小为8，最大长度为65535 字节。</li>
<li><strong>校验和(Checksum):</strong> UDP 使用校验和来保证数据安全性，UDP的校验和也提供了差错检测功能，差错检测用于校验报文段从源到目标主机的过程中，数据的完整性是否发生了改变。那么校验和是怎么被计算的？ <ul>
<li>校验和就是将前三个字段的16比特的字相加，如果有溢出，就需要<strong>回卷(将溢出的高位加到最低位上去)</strong>。最后再取反码。</li>
</ul>
</li>
</ul>
<p>比如：</p>
<script type="math/tex; mode=display">
0110011001100000\\
0101010101010101\\
1000111100001100</script><p>这三个 16比特的前两个字和是：</p>
<script type="math/tex; mode=display">
~~~~0110011001100000\\
+0101010101010101\\
=1011101110110101\\</script><p>再将上面的和与第三个字相加，得出：</p>
<script type="math/tex; mode=display">
~~~~1011101110110101\\
+1000111100001100\\
=0100101011000010</script><p>注意到，最后一次的加法是由溢出的，因此，这个溢出的1要<strong>回卷</strong>到最低位的1出，因此我们看到最低位的1因为这个1而进了一位，倒数第二为变成了1 。最后取反码得到： $1011010100111101$ ,这就是最终的校验和。</p>
<p>在接收方，全部的4个16比特字(包括检验和)加在一起，如果该分组在运输过程中没有出现差错，那么最终的和将是<code>1111111111111111</code>,如果这些比特之一是0，那么我们就知道该分组中已经出现了差错。</p>
<blockquote>
<p>为什么UDP 会提供差错检测功能？</p>
</blockquote>
<p>其实这是一种<strong>端到端</strong>的设计原则，这个原则说的是要让传输中各种错误发生的概率降低到一个可以接受的水平。UDP不可靠的原因是因为他虽然提供了差错检测的功能，但是对于差错<strong>没有恢复能力</strong>更不会有重传机制。</p>
<h3 id="错题与注意点"><a href="#错题与注意点" class="headerlink" title="错题与注意点"></a>错题与注意点</h3><ul>
<li>UDP的检验和段是可选的，如果源主机不想计算校验和，该校验和段应全为0</li>
<li>UDP数据报的伪首部包含了IP地址信息，目的是通过数据校验保证UDP数据报正确地到达目的主机。该伪首部由源和目的主机仅在校验和计算期间建立，并不发送。</li>
<li>如果数据报在传输过程中被破坏，那么就把它丢弃</li>
<li>传输层提供的是端到端服务，为进程之间提供逻辑通信。<strong>不是主机之间的通讯</strong></li>
<li>HTTP响应报文可能会具有空的报文体</li>
<li>两个不同的Web页面(例如，<a href="http://www.mit.edu/research.html" target="_blank" rel="noopener">www.mit.edu/research.html</a>及<a href="http://www.mit.edu/students.html" target="_blank" rel="noopener">www.mit.edu/students.html</a>) 可以通过同一个<strong>持续连接</strong>发送</li>
<li><strong>网络层</strong>负责将称为<strong>数据报(datagram)</strong>的网络层分组从一台主机移动到另一台主机</li>
</ul>
<h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>假定在主机C上的一个进程有一个具有端口号6789的UDP套接字。假定主机A和主机B<strong>都用目的端口号6789</strong>向主机C发送一个UDP报文段。这两台主机的这些报文段在主机C都被描述为相同的套接字吗？如果是这样的话，在主机C的该进程将怎样知道源于两台不同主机的这两个报文段？</p>
<p>答：这两台主机的这些报文段在主机C会被描述为<strong>相同的套接字</strong>。因为在传输UDP包的时候, <strong>网络层会附带上源和目的的IP地址的,</strong> 主机C的程序可以通过不同的源IP地址判别。毕竟主机A和B在选端口的时候不知道彼此具体会选什么, 肯定会有选用一样端口号的情况,<strong>主机IP能把它们区分开</strong>。</p>
<h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>考虑一个长度为L的分组从端系统A开始，经3段链路传输到目的端系统。令$d<em>i,si$和$Ri$表示链路i的长度、传播速度和传输速率$(i= 1,2,3)$。该分组交换机对每个分组的时延为$d</em>{proc}$。假定没有排队时延，用$d_i、s_i、R_i(i= 1,2,3)$和L表示，该分组<strong>总的端到端时延</strong>是什么？</p>
<p><strong>解答</strong>： 首先我们要知道，$D<em>总 = D</em>{trans}+D<em>{prop}+D</em>{proc}$</p>
<p>那么，依次来解决这些时延：</p>
<p><strong>处理时延</strong>： 题目说，分组交换机对每个分组的时延为$d<em>{proc}$ ，在这条传输路径上，一共有两个端，两个路由器，因此，处理时延应该为 $2d</em>{proc}$ </p>
<p><strong>传播时延：</strong> 传播时延指的是数据在链路上的传递时间。这里一共有三段链路，每段链路的传播时延要个计算。为：$d_1/s_1+d_2/s_2+d_3/s_3$ </p>
<p><strong>传输时延：</strong> 传输时延指的是将分组的信息发到链路的时间，也就是将数据报推出去所花的时间。时延计算公式为：$L/R$, 这里，在每一段链路上都要个自己算，因此传输时延为：$L/R_1+L/R_2+L/R_3$ </p>
<p>现在假定该分组是1500字节，在所有3条链路上的传播时延是$2.5 \times 10^8$m/s，所有3条链路的<strong>传输速率</strong>是2Mbps，分组交换机的处理时延是3ms，第一段链路的长度是5000km，第二段链路的长度是4000km，并且最后一段链路的长度是1000km。对于这些值，该端到端时延为多少？</p>
<p>只要把数据带入公式即可。</p>
<h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><p> UDP和TCP使用反码来计算它们的检验和，结合UDP检验和段的相关知识回答以下问题：</p>
<p>（1）假设你有下面3个8比特字节：$01010011, 01100110, 01110100$。这些8比特字节和的反码是多少？写岀所有计算过程。（注：UDP和TCP使用16比特的字来计算校验和，但对于本题目，考虑8比特和。）</p>
<p><strong>解答</strong>：计算字节和：</p>
<script type="math/tex; mode=display">
~~~~01010011\\
+01100110\\
=10111001\\</script><p>然后和第二个数相加：</p>
<script type="math/tex; mode=display">
~~~~10111001\\
+01110100\\
=100101101</script><p>因为溢出了，所以要抹去最高位，并回卷到最低位。最终结果是 $00101110$ </p>
<p>取反码得到： $11010001$ </p>
<p>（2）在（1）中，UDP为什么要用该和的反码，即为什么不直接使用该和呢？使用该反码方案，接收方如何检测出差错? 1 比特的差错能检测出来吗? 2比特的差错呢?</p>
<p><strong>解答</strong>：相比于原码，补码，二进制反码循环移位加法求和具有以下优点：</p>
<ul>
<li><p>不依赖系统是大端小端。即无论你是发送方计算机或者接收方检查校验和时，都可直接通过上面的算法得到正确的结果。简单来说，用反码求和时，交换16位数的字节顺序，得到的结果相同，只是字节顺序相应地也交换了；而如果使用原码或者补码求和，得到的结果可能就不同。</p>
<ul>
<li>比如：针对上面的第二个计算式子，我们将字节顺序调换为：1001 1011 + 0100 0111 = 1110 0010(大端切换成小端), 取反得0001 1101，相比上面的1101 0001只是字节顺序相应的也进行的交换。而如果采用原码的话，1011 1001 + 0111 0100 -&gt; 0010 1101，交换顺序后得：1001 1011 + 0100 0111 -&gt; 1110 0010，结果发生改变。</li>
</ul>
</li>
<li><p>在接收方，全部的4个8比特字（包括检验和）加在一起。如果该分组中没有引入差错，则显然在接收方处该和将是1111 1111；如果这些比特之一是0, 那么我们就知道该分组中已经出现了差错。</p>
</li>
<li><p>所有的1位错误都会被检测到，但是如果有2位错误就有可能发送忽略，比方说上述第一个字节的最后一位转换为0，第二个字节的最后一位转换为1，此时相加的结果可能就不会有影响（跟(3)类似）。</p>
</li>
</ul>
<p>（3）假定某UDP接收方对接收到的UDP报文段计算因特网检验和，并发现它与承载在检验和字段中的值相匹配。该接收方能够绝对确信没有出现过比特差错吗？试解释之。</p>
<p><strong>解答：</strong> 不，接收方<strong>不能完全确定没有发生任何位错误</strong>。如果<strong>包中两个16位字的对应位（相加在一起）是0和1，那么即使这些位分别翻转到1和0，所得的和仍然保持不变</strong>。因此，接收方计算的反码也将是相同的。此外，传输错误也有可能导致验证通过。</p>
<h2 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h2><p>这是这一章最难的东西了。在学习TCP之前，我们必须搞懂可靠数据传输原理。</p>
<p>下图是可靠数据传输的框架：为上层实体提供的服务可以理解为：数据可以通过一条可靠信道进行传输。借助于可靠信道，可以实现：</p>
<ul>
<li>传输数据比特就不会受到损坏或者丢失</li>
<li>所有数据都是按照其发送顺序进行交付</li>
</ul>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/6.png" style="zoom:67%;"></p>
<p>但是在可靠数据传输协议的下层也许是不可靠的，因此，如何把不可靠的变可靠的是一件比较困难的事情：首先应用层把要发送的数据交给传输层的发送端，并调用 <code>rdt_send()</code> 分组以后调用<code>udt_send()</code> 将packet 通过网络层(不可靠的) 发送给 接收方。并通过某种方法让传输的数据在中途不会有损坏或者丢失。再将packet还原成data，并向上抛给接收端的应用层。</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/1.jpg" style="zoom:67%;"></p>
<p>接下来我们要使用<strong>有限状态机</strong>来具象化发送端和接收端。也就是说，可以通过某一个时间是状态机的状态发生改变。</p>
<h3 id="rdt1-0"><a href="#rdt1-0" class="headerlink" title="rdt1.0"></a>rdt1.0</h3><p>我们首先来看最简单的情况。在这种情况下，物品，我们将数据的<strong>传输信道(也就是上图下方的管道)</strong>理想化，视为<strong>完全可靠</strong>，<strong>不丢包也不发生bit error(如比特重置)</strong> ，在这样的情况下，发送端发送数据，接收端直接接收，并不虑丢包，超时这些问题。</p>
<p><strong>发送者</strong>：</p>
<p>首先，发送者一直在等待上层应用的<code>rdt_send(data)</code>调用，当收到后会执行三个操作：</p>
<ul>
<li>调用<code>make_pkt(data)</code>,将数据放到packet中</li>
<li>调用<code>udt_send(data)</code>，将packet 加上头部信息之后通过传输信道发送给接收端，但是因为这个传输信道是理想化的，所以并不会出现任何差错。</li>
</ul>
<p>所以说，在rdt1.0的情况下，发送者只有1个状态，并处于一个无限循环当中。</p>
<p>因此，我们把这种机制叫做<strong>停等</strong>，也就是在发送packet之后一直在等待返回信息。包括在后面的rdt2.x以及rdt3.0 都是在使用停等。</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/7.png" style="zoom:67%;"></p>
<p><strong>接受者：</strong></p>
<p>在接受者方，也只有一个状态。接收端收到分组以后，将封包解开，取出data，将其发送到上层应用。</p>
<h3 id="rdt2-0"><a href="#rdt2-0" class="headerlink" title="rdt2.0"></a>rdt2.0</h3><p>但事实上，错误是不可避免的，上面我们说了有两种方法：比特被重置了或者说是丢包了。现在我们先来看简单的情况——比特被重置了</p>
<p>之前在介绍UDP的时候，谈到了可以用检验和来判断比特是否被重置。现在的问题是发现比特被重置后该怎么恢复？现在是接受者收到数据错误，然后需要发送一个反馈信息告诉发送者，这个信息就是<code>NAK</code> ；同样的，当接受者收到的信息是正确的，那么就发送<code>ACK</code>给发送者。</p>
<p>下面是发送者和接收者的有限状态机FSM</p>
<p><strong>发送者：</strong> </p>
<ul>
<li>发送端等待上层传数据传进来</li>
<li>将数据和检验和打包为分组并将其发送到信道中</li>
<li>发送端进入<strong>等待返回信号状态</strong><ul>
<li>如果收到NAK则说明发送的数据有误则进行重传。判断条件是：<code>rdt_rcv(rcvpkt)&amp;&amp;isNAK(rcvpkt)</code></li>
<li>如果接受到ACK则数据无误，回到<strong>等待上层调用状态</strong>。判断条件是：<code>rdt_rcv(rcvpkt)&amp;&amp;isACK(rcvpkt)</code></li>
</ul>
</li>
</ul>
<p>因此这时候发送者的FSM中有两个状态,要注意这两个状态的变换条件。</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/8.png" style="zoom:67%;"></p>
<p><strong>接收端：</strong></p>
<ul>
<li>接收端收到资料</li>
<li>当数据分组接收到以后确认无误(判断条件是<code>rdt_rcv(rcvpkt)&amp;&amp;corrupt(rcvpkt)</code>)，会把数据提取出来，向上传递并发送ACK给发送方已确定数据无误。</li>
<li>当收到后发现有错误时(判断条件是<code>rdt_rcv(rcvpkt)&amp;&amp;corrupt(rcvpkt)</code>)，会传回NAK通知发送端重传。</li>
</ul>
<p>因此，rdt2.0的接收方只有一个状态，并处于一个循环当中</p>
<h3 id="rdt2-1"><a href="#rdt2-1" class="headerlink" title="rdt2.1"></a>rdt2.1</h3><p>现在的新问题是：在rdt2.0 时可能我发送的NAK或者ACK在传输过程中也会发生损坏。这时候接收端就无法区分反馈的信息到底是什么了。这时需要发送端重复发送。</p>
<p>针对rdt2.0中ACK/NAK受损可能会导致重传的问题，rdt2.1加入了<strong>序列号机制(sequence number)</strong>，分组的号码可以：</p>
<ul>
<li>让发送方知道是否需要重传。</li>
<li>让接受者确认，接收到的packet是否是重新传输的分组</li>
</ul>
<p>在这里，为了节省bit，该序号在当前协议中只使用 0和1 ，交替排列就可以了。发送第一个包裹的时候编号为0，第二个包裹时编号为1，第三个包裹时编号又变回0。这样一来，发送端和接收端都有了两种序号状态， 0 和 1 </p>
<p><strong>发送者</strong></p>
<p>这时候的发送者有4个状态：发送0，停等0；发送1，停等1</p>
<p>现在可能由四种情况：</p>
<ol>
<li>什么错误都没发生。 这时候，发送者发送编号为0的包裹，接收者收到以后发现数据正确，那么就会提取数据、向上抛出并返回一个ACK。发送者收到ACK之后，跳到下一个状态，等待编号为1的调用。</li>
<li>发送过去的数据出现损坏。这时接收方通过判断，返回一个编号为0的NAK，发送端接收到NAK的返回值，落入判断<code>corrupt(rcvpkt)||isNAK(rcvpkt)</code>后面的判断条件，然后重新发送packet</li>
<li>返回的ACK信号出现损坏。接收端成功接收0号包，返回ACK的同时进入下一个状态等待1号包；这时ACK出现了比特重置——ACK变成了NAK。发送端收到NAK后，会落入判断(<code>corrupt(rcvpkt)||isNAK(rcvpkt)</code>同时满足两个条件，前面这个条件是因为ACK出现重置)，会进行编号为0的packet的重传；接收方要等的是编号为1的包，结果却等来一个编号为0的包，那么这时候接收端并不会做任何操作(知道了是上一个ACK出了错误)，仍然返回ACK；最后当发送方终于收到ACK之后，会进入状态1，这时接收方和发送发都进入了状态1</li>
<li>返回的NAK信号出现损坏。接收端收到损坏的0号包，返回NAK并保持在状态0。但是在路上NAK发生了比特翻转，是否会让发送端误判而跑到状态1去呢？<strong>这种情况基本不会出现</strong>。因为在发送者判断isACK之前还有一个<code>notcorrupt(rcvpkt)</code>,这是用校验和来判断收到的包不存在比特重置情况的。因此这时候判定为<code>corrupt(rcvpkt)||isNAK(rcvpkt)</code>的前面那个条件，并重新发送编号为0的packet.</li>
</ol>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/9.jpg" style="zoom:67%;"></p>
<p>接收端也有状态0和状态1，因为上面已经将所有情况都做了一个梳理，这里就不详细讲了。</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/10.jpg" style="zoom:67%;"></p>
<h3 id="rdt2-2"><a href="#rdt2-2" class="headerlink" title="rdt2.2"></a>rdt2.2</h3><p>对于rdt2.1需要返回 NAK , ACK 两种状态, 可能太麻烦了，就将其<strong>全部改为ACK。只是返回的时候顺便返回序号</strong>。 也就是接收端收到包，不管正确与否，都返回 ACK ，同时附上序号，<strong>这个序号就是数据包发送过来时的序号</strong>。对上一条数据的重复确认就是对当前数据的否认。</p>
<p>还是上面几种情况</p>
<ul>
<li>什么错误都没发生</li>
<li>发送者发送的数据出现了问题。<ul>
<li>接收者收到出错的包之后，落入判定<code>corrupt(rcvpkt)||has_seq1(rcvpkt)</code>的前者。就返回一个编号为1的ACK，并留在状态0；</li>
<li>发送者收到编号为1的ACK之后，落入判定<code>corrupt(rcvpkt)||isACK(rcvpkt,1)</code>的后者，并重发编号为0的包</li>
</ul>
</li>
<li>接收者收到正确的包，并返回<code>(ACK,0)</code>、进入状态1。但是过程中出现了比特重置。<ul>
<li>发送者这方收到后，落入判定<code>corrupt(rcvpkt)||has_seq1(rcvpkt)</code> 的前者，因此会重新发编号为0的包。</li>
<li>这时，ACK等待的却是编号为1的包，因此会落入判定<code>(corrupt(rcvpkt)||has_seq0(rcvpkt))</code>的后者,并重新返回一个编号为0的ACK。</li>
</ul>
</li>
<li>接收者收到错误的包，返回编号为1的ACK，但是途图中出现了差错。<ul>
<li>发送者收到编号为1的ACK之后，落入判定<code>corrupt(rcvpkt)||isACK(rcvpkt,1)</code>的前者(也有可能是前后者并中)，然后重发编号为0的包。</li>
</ul>
</li>
</ul>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/12.png" style="zoom:67%;"></p>
<p>接收方的状态都已在上面说过，因此不再展开</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/13.png" style="zoom:67%;"></p>
<h3 id="rdt3-0"><a href="#rdt3-0" class="headerlink" title="rdt3.0"></a>rdt3.0</h3><p>上面所说的情况，都是在没有<strong>丢包</strong>的情况下进行的讨论。现在我们要引入丢包的情况了。</p>
<p>如果发生了丢包，那么解决的办法就是重发。那么什么时候重发呢？网络中的延时具有非常大的不确定性, 如果等待足够大的时延才重传分组显然会降低效率 。我们可以引入一个定时器，当反馈信息超过了一定的时间还是没有到达发送者，发送者就会重新发送。</p>
<p>下面是发送者的fsm: </p>
<p>第一个状态，收到上层调用后，发送编号为0的packet的同时启动一个timer，然后变成第二个状态</p>
<p>第二个状态，当超时之后，会重发packet并重启timer、继续等待编号为0的ACK；或者当收到包后却发现包裹损坏或编号为1的ACK。只有当收到包后、包没有损坏且是编号为0的ACK，发送者才会进入下一个状态。等待发送编号为1的packet</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/11.png" style="zoom:67%;"></p>
<p>接收者的状态和rdt2.2是一样的。</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/18.png" style="zoom:67%;"></p>
<p> 下面四张图描述了四种情况：</p>
<ul>
<li>数据没有丢失</li>
</ul>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/14.png" style="zoom:67%;"></p>
<ul>
<li>发送方的packet丢失</li>
</ul>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/15.png" style="zoom:67%;"></p>
<ul>
<li>接收方返回的ACK丢失</li>
</ul>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/16.png" style="zoom:67%;"></p>
<ul>
<li>提早超时/姗姗来迟的ACK</li>
</ul>
<p>这时候问题变得稍稍复杂了些,我们来细致分析：</p>
<ol>
<li>首先发送者从第三个状态开始，接收者从第二个状态开始。</li>
<li><strong>发送者</strong>发送了编号为1的包并启动了一个timer，转化为状态4；<strong>接收者</strong>收到没有损坏的且编号为1的包，并发送一个编号为1的ACK给发送者，状态转为等待来自下层的0</li>
<li>因为<strong>发送者</strong>这里超时了，落入<code>timeout-&gt;udt_send(sndpkt)</code>逻辑，重新发送编号为1的包并重新启动一个timer</li>
<li><strong>然而</strong>，在这时<strong>发送者</strong>却受到了来自接收者的ACK1(第一次)，于是就落入<code>rdt_rcv(rcvpkt)&amp;&amp;notcorrupt(rcvpkt)&amp;&amp;isAKC(rcvpkt,1)</code>这个判定，并重新回到状态1，等待上层编号为0的调用。上层调用之后，发送编号为0的一个新的包，同时去到状态2 ；</li>
<li><strong>接收者</strong>再次收到编号为1的packet(检测到了重复包)，落入<code>corrupty(rcvpkt)||has_seq1(rcvpkt)</code> 判断，这时接收者仍然保持状态1不变，并重新发送编号为1的ACK给发送者。</li>
<li><strong>发送者</strong>这时候再次收到了接收者重新发送的ACK1(第二次)，但它现在在状态2，等待的是一个编号为0的ACK，因此，<strong>发送者什么都不会做</strong>，直到再次超时并重新发送编号为0的包(第二个)。<strong>接收者</strong>收到了第一个编号为0的新包之后也返回一个编号为0的ACK</li>
<li><strong>发送者</strong>这时候收到了编号为0的ACK了，然后跳到状态三去了，等待上层编号为1的调用。当再次收到编号为0的ACK时，发送者什么也不做就行了。</li>
</ol>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/17.png" style="zoom: 50%;"></p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/18.png" style="zoom:67%;"></p>
<p>rdt3.0虽然规避了所有出错的可能，但是还是存在不足，比如：</p>
<ul>
<li>效率太慢，由于停等方式的存在，一个包没处理好，发送端在大部分时间都是一直等着。</li>
<li>关键我们要设置重发的等待时间，太长会导致通信太慢，用户体验差；太快则会出现发送者重发之后却收到了<strong>姗姗来迟</strong>的ACK/NAK。</li>
</ul>
<p>因此我们要考虑 <code>piplined protocols</code> 也就是说能不能像UDP一样，发送端一直在发送(一次性发送多个packet)？但是一直发送的时候由如何保证丢掉的包能被正确重发且顺序一致呢？</p>
<p>因此，下面来讨论两种<code>piplining</code>方案，每次发一批packet，来提高rdt3.0的效率。一个是<strong>回退N步</strong>的方法，另一种是selective repeat的方法，两者的很大的区别在于，要不要对一些乱序的包进行缓存？</p>
<h4 id="go-Back-N"><a href="#go-Back-N" class="headerlink" title="go-Back-N"></a>go-Back-N</h4><p>GBN 的策略是只保留顺序地包裹，剩下的乱序包全部丢弃并重新接受。有以下几个特点</p>
<ul>
<li>比如发送了123456，接收方只收到了1236，那么这时候就必须从4开始重新发送456三个包。</li>
<li>接收端也只会返回累计确认(cumulative ack),也就是只ack连续的包，像上面，虽然收到了1236，但是也只返回123的ack，并不会返回6的ack</li>
<li>发送端只给最早的没有被确认的包保留一个timer，当超时以后，会重新发送所有没有被确认的包</li>
</ul>
<p>比如说下图，前面绿色的是已经被确认的了，因此，现在窗口向右移动，到第一个尚未确认的包处。这样能保证窗口左边的包是已确认且按照顺序排列的。黄色的包是发送了，但是还没有收到ack确认；蓝色的包是还没有被发送，但在窗口之内、等待发送的，我们把第一个蓝色的包所在的位置叫做 <code>nextseqnum</code>即下一次待发的序列。同时，为最老的一个未确认的包保持一个timer，当超时的时候，从这个<code>send_base</code>开始，向后重新按顺序发送黄色的包。 </p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/21.png" style="zoom:67%;"></p>
<p><strong>sender</strong> 的状态机，只有一个状态，始终在等待。</p>
<ul>
<li>接到发送请求后，开始发包，刚开始nextseqnum和base是在一个位置的，因此发送第一个包之后就会启动计时器。每发一个包之后，<code>nextseqnum</code>就要自增1。 需要发包时要判断，下一个待发的包的序号是否已经超过了窗口大小，否则就拒发</li>
<li>如果超时，那么重开一个timer，并从base开始将<strong>已发送但却没确认的所有包</strong>都重新发送</li>
<li>如果收到了包裹且没有损坏，那么窗口就要像右边移动一个位置。同时要判断base窗口右端是否已经移动到<code>nextseqnum</code>。如果移到了，说明在未超时的情况下，发送的包全部收到了ack确认，那么就可以停止老的timer了；否则，timer要重新开始计时，因为这时<strong>最老的包已被确认</strong>，倒数第二老的包变成了最老的未确认的包</li>
<li>如果收到的包是损坏的，那么什么也不用做；如果收到的包是重复的ack，因为<code>base=getacknum(rcvpkt)+1</code>所以也不会有任何变化</li>
</ul>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/19.png" style="zoom:67%;"></p>
<p><strong>receiver</strong> 的状态机</p>
<p>在收到包之后，首先判断是否损坏，其次判断是否符合序列，两者满足，才会返回ack确认</p>
<p>如果收到了乱序的包(比如之前123，突然收到了6)，那么接收者就会<strong>丢弃</strong> ，不将其放入缓存，并同时返回一个最新有序包的序号的ack确认信息(将6丢弃，并返回ack3)</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/20.png" style="zoom:67%;"></p>
<h5 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h5><p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/22.png" style="zoom:67%;"></p>
<p>这个例子可以来描述一下上面讲的状态机的操作。</p>
<ul>
<li>首先发送者发了0123一共四个包，其中3在运输图中损坏</li>
<li>接收者收到pkt0(符合序列)，返回ack0；收到pkt1(符合序列)，返回ack1；收到pkt3(不符合序列)，返回ack1</li>
<li>发送者收到ack0，窗口右移1位，同时发送pkt4；发送者受到ack1，再右移一位，同时发送pkt5。</li>
<li>接收者收到pkt4(不符合序列)，返回ack1；收到pkt5(不符合序列)，仍然返回ack1</li>
<li>发送者维持的最古老的计时器这时候超时了，将从base开始(此时是2)，连续发送，将已发送但却没确认的所有包都重新发送，这里是重发2345</li>
</ul>
<h4 id="selective-repeat"><a href="#selective-repeat" class="headerlink" title="selective repeat"></a>selective repeat</h4><p>SR 策略是在接收端对乱序包进行缓存，并告知发送端未收到、需要重传的包。有以下几个特点</p>
<ul>
<li>比如说发送了123456，接收方只收到了1236，那么接收端就会为1236各自发一个ack确认。并要求发送端重传45</li>
<li>发送端为每一个未被确认的包保留了一个timer，当特定的timer超时后，就发送特定的packet</li>
<li>效率更高但是需要更大的缓存</li>
</ul>
<p>原理如下图所示</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/23.png" style="zoom:67%;"></p>
<p>用一个具体的例子来解释：</p>
<ul>
<li>发送者发送0123，但是2在途中丢失</li>
<li>接收者收到了pkt0，返回ack0；收到pkt1，返回pkt1；收到pkt3,返回pkt3</li>
<li>发送者收到ack0，窗口右移并发送pkt4；收到ack1，继续右移并发送pkt5</li>
<li>接收者收到pkt4,返回ack4；收到pkt5，返回ack5;</li>
<li>这时候发送者这里pkt2的timer超时了，所以重发pkt2；同时收到了ack4和ack5，但是收到的ack345和ack01并不是连续的，因此窗口并不需要移动</li>
<li>等到发送者终于收到ack2的时候，因为ack345都已经收到了，因此窗口会一下子向右移4位</li>
</ul>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/24.png" style="zoom:67%;"></p>
<p><strong>问题来了</strong>，现在有一个情况，就是说在发送者和接收者之间，实际上是看不到对方的窗口的，就像隔了一层帘子一样。如下图所示</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/25.png" style="zoom: 50%;"></p>
<p>现在，发送序列为：0123012，窗口大小为3.</p>
<p><strong>发送者所看到的：</strong> 自己发送pkt012之后，却没有等来ack012，因此当超时之后，会重新发送pkt0</p>
<p><strong>接收者所看到的：</strong> 自己收到了pkt012之后，返回ack012，并且窗口向右移3位，现在接受者的窗口等待的是pkt301；但是现在接收者收到了发送者重新发送的pkt0，因此，接收者便无法判断这个pkt0到底是发送者重发的还是新的pkt0.</p>
<p>现在我们把窗口的大小调整为2，重复刚才的情况：我们发现，现在当ack01丢失的时，发送者再次发送pkt0，但是现在接收者的窗口仅仅移动到了23，因此再次收到pkt0的时候，接收者就会认为这是之前pkt0，因此什么也不用做。</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/3.jpg" style="zoom: 33%;"></p>
<p>那么，窗口大小和序号长度之间的关系是什么呢？可以发现，应该是<strong>发送者窗口大小+接收者窗口大小&lt;= 序号空间大小</strong>，又发送者和接收者的窗口大小相同，因此 <strong>窗口大小&lt;=序号空间大小/2</strong> </p>
<p>但是对于GBN，就不需要满足<strong>窗口大小&lt;=序号空间大小/2</strong> 。因为GBN的策略是，收到的如果不是我当前在等待的包，我就全都不要。那刚才SR出现错误的情况来说：当接受者收到pkt012之后，返回ack012，并将窗口移动到 301，此时接受者<strong>只要pkt3</strong>。因此当发送者因为超时重新发送pkt012时，接受者收到了也会直接丢掉，并不会发生歧义。</p>
<p>但是这并不是意味着GBN情况下窗口大小就没有限制，如果我们序列变成012012，窗口仍然为3，那么这时候也会出现上面那样的歧义了。因此在GBN情况下，需要满足<strong>窗口大小&lt;=序号空间大小-1</strong> </p>
<h2 id="面向连接的运输：-TCP"><a href="#面向连接的运输：-TCP" class="headerlink" title="面向连接的运输： TCP"></a>面向连接的运输： TCP</h2><p>UDP是一种没有复杂的控制、提供无连接通信服务的一种协议，他将部分控制部分交给应用程序去处理，自己只提供作为传输层最基本的功能。</p>
<p>但是，和UDP不同的是，TCP的协议要比UDP的功能多很多</p>
<p>TCP 被称为一种<strong>面向连接(connection-oriented)</strong> 的协议，这是因为一个应用程序在向另一个应用程序发送数据之前，这<strong>两个进程必须先进行握手</strong>，握手是一个<strong>逻辑连接</strong>。</p>
<p>一旦主机A和主机B建立了连接，那么进行通信的两个应用程序只使用虚拟的通信线路发送和接收数据就可以保证数据的传输，TCP协议负责控制连接的建立、断开、保持等工作。</p>
<ul>
<li>TCP连接<strong>全双工服务(full-duplex service)</strong>的，全双工就是指主机A与另外一个主机B存在一条TCP连接，那么应用程序的数据就可以从主机B流向主机A的同时，也从主机A流向主机B</li>
<li>TCP只能进行<strong>点对点(point-to-point)</strong>连接，那么所谓的<strong>多播</strong>，即一个主机对多个接收方发送消息的情况是<strong>不存在的</strong>，TCP连接只能连接一对主机</li>
<li>一旦TCP连接建立后，主机之间就可以相互发送应用数据了，客户进程通过套接字传送数据流。一旦数据通过套接字后，它就由客户中的TCP协议所控制</li>
</ul>
<p>TCP会将数据临时存储到连接的<strong>发送缓存</strong>中，这个send buffer是三次握手之间设置的缓存之一，然后TCP在合适的时间将发送缓存中的数据发送到目标主机的接收缓存中，实际上<strong>每一端都会有发送缓存和接收缓存</strong>，如下图所示。</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/26.png" style="zoom: 67%;"></p>
<ul>
<li>主机之间的发送是用<strong>报文段(segment) </strong>进行的，那么<strong>什么是报文段</strong>呢？<ul>
<li>TCP会将要传输的数据流分为多个<strong>块(chunk)</strong>,然后将每个chunk中添加tcp标头，这样就形成了一个报文段。每一个报文段可以传输的长度是有限的，不能超过<strong>最大数据长度(Maximum Segment Size)</strong> ，俗称<code>MSS</code> 。在报文段向下传输的过程中，会经过链路层，连路程有一个<strong>最大传输单位(Maximum Transmission Unit)</strong>,简称<code>MTU</code>,即数据链路层上所能通过最大数据包的大小(通常和通信接口有关)</li>
<li>MSS和MTU是在不同分层的不同定义。 <strong>MTU可以认为是网络层能够传输的最大IP数据包，MSS可以认为是传输层的概念，也就是TCP数据报能够传输的最大量</strong></li>
<li>从MSS的定义可以看出，MSS字段只是<strong>数据字段</strong>最大的长度，是不包含任何头部信息的！</li>
</ul>
</li>
</ul>
<h3 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h3><p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/27.png" style="zoom: 67%;"></p>
<p>TCP 报文段结构比UDP的报文段结构要多了很多内容，但是前两个16比特的字段是一样的。也就是<strong>源端口号</strong>和<strong>目标端口号</strong> ，这是用于多路复用和多路分解的。此外，和UDP一样，TCP也包含<strong>校验和</strong>，除此之外，TCP报文还有：</p>
<ul>
<li>32 比特 的<strong>序号字段(sequence number field)</strong> 和32 比特的<strong>确认号字段(acknowlegment number field)</strong>. 这些字段被TCP 发送方和接收方用来实现可靠的数据传输。</li>
<li>4比特的<strong>首部字段长度(header length field)</strong>,这个字段指示了以32比特的字为单位的TCP首部长度。TCP首部的长度是可变的，但是<strong>在通常情况下，选项字段为空</strong>，所以TCP首部字段的长度为20字节。</li>
<li>16比特的<strong>接受窗口字段(receive window field)</strong>,这个字段用于流量控制。它用于指示接收方能够/愿意接受的字节数量</li>
<li>可变的<strong>选项字段(options field)</strong>，这个字段用于发送方和接收方协商最大报文长度(MSS) 时使用</li>
<li>6 比特 的标志字段<ul>
<li><code>ACK</code>  标志用于确认字段中的值是有效的，这个报文段包括一个队已被成功接收报文段的确认</li>
<li><code>RST</code>、<code>SYN</code>、<code>FIN</code> 标志用于连接的建立和关闭</li>
<li><code>CWR</code> 和 <code>ECE</code> 用于拥塞控制</li>
<li><code>PSH</code> 用于表示立刻将数据交给上层处理</li>
<li><code>URG</code> 标志用来表示数据中存在需要被上层处理的紧急数据</li>
</ul>
</li>
<li><strong>紧急数据指针字段(urgent data point field)</strong>  用于指出紧急数据的最后一个字节。一般来说 紧急数据指针字段、PSH和URG 都是不用的</li>
</ul>
<h4 id="序号、确认号是干嘛的？"><a href="#序号、确认号是干嘛的？" class="headerlink" title="序号、确认号是干嘛的？"></a>序号、确认号是干嘛的？</h4><p>TCP 报文段首部中最重要的两个字段就是<strong>序号</strong>和<strong>确认号</strong>，这两个字段是TCP实现可靠性的基础。首先我们要来看一下这两个字段里面存放的内容：</p>
<p><strong>一个报文段的序号就是数据流的字节编号。</strong> 因为TCP会把数据流分割成为一段一段的字节流，因为字节流本身是有序的，所以每一段的字节编号就在标示是哪一段的字节流。比如说，主机A要给主机B发送一条数据，数据经过应用层之后会有一串数据流，数据流经过TCP分割(分割的依据就是MSS)。</p>
<p>假设数据是10000字节，MSS是2000字节，那么TCP就会把数据拆分成 0-1999,2000-3999 …   </p>
<p>首字节编号依次是0，2000 …..</p>
<p>然后每个序号会被填入TCP报文段首部的序号字段中，如下图所示</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/0.png" style="zoom: 67%;"></p>
<p>首先，我们要知道TCP是一种全双工的通信协议，如下图所示：</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/28.png" style="zoom: 67%;"></p>
<p>因此，主机A在向主机B发送消息的过程中，也在接收来自主机B的数据。<strong>主机A填充进报文段的确认号是期望从主机B收到的下一字节的序号</strong>(这可能会比较绕)。代表确认号以前的所有数据都正常收到了， 如下图所示：</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/33.png" style="zoom: 67%;"></p>
<p>再举一个小栗子：</p>
<p>假设主机A通过一条TCP连接向主机B发送两个紧挨着的TCP报文段. 第一个报文段的序号为90, 第二个报文段序号为110.</p>
<p>a. 第一个报文段中有多少数据?<br>答: 110 - 90 = 20个字节.</p>
<p>b. 假设第一个报文段丢失而第二个报文段到达主机B. 那么在主机B发往主机A的确认报文中, 确认号应该是多少?<br>答: 90. 因为之前主机B给主机A发送的ACK就是90，说明90以前的报文我都收到了，主机A才会发送90给主机B</p>
<h4 id="延时确认机制"><a href="#延时确认机制" class="headerlink" title="延时确认机制"></a>延时确认机制</h4><p>接收方在收到数据后，并不会立即回复ACK,而是延迟一定时间。<br>一般ACK延迟发送的时间为200ms，但这个200ms并非收到数据后需要<br>延迟的时间。系统有一个固定的定时器每隔200ms会来检查是否需要发送ACK包。这样做有两个目的。<br>1、这样做的目的是ACK是可以合并的，也就是指如果连续收到两个TCP包，并不一定需要ACK两次，只要回复最终的ACK就可以了，可以隆低网络流量。<br>2、如果接收方有数据要发送，那么就会在发送数据的TCP数据包里，带上ACK信息。这样做，可以避免大量的ACK以一个单独的丁CP包发<br>送，减少了网络流量。</p>
<h3 id="传输可靠性"><a href="#传输可靠性" class="headerlink" title="传输可靠性"></a>传输可靠性</h3><p>首先我们来看 TCP 发送者的<strong>有限状态机</strong></p>
<ul>
<li>初始状态时 ， SendBase(基础窗口)=NextSeqNum= InitialSeqNum</li>
<li>当TCP收到上层应用传来的数据时，会生成报文段，然后把报文段传给下层网络层。同时，将NextSeqNum加上<strong>这次传送数据的长度</strong>，得到一个新的NextSeqNum。 如果当前没有启动计时器的话，就启动一个计时器</li>
<li>如果计时器超时，因为是累计确认机制，那么从还没有ack的最小的序号包开始重传并重新计时。</li>
<li>如果收到了ACK，那么就需要判断ACK的值y(等于Next)是否大于SendBase。如果大于，不管是不是等于 <code>NextSeqNum+length(data)</code>(根据累计确认的机制，有可能ACK在途中丢包了，收到的ACK远远大于当前的SendBase,那也不管，说明接收者肯定收到了)，那么<strong>更新SendBase</strong>。 然后，还要判断是否还有未被确认的报文段，如果有的话就重新开一个计时器，如果没有就暂停计时器</li>
</ul>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/34.png" style="zoom: 67%;"></p>
<h4 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h4><p>什么时候回出现重传呢？</p>
<ul>
<li><p>如果Ack丢失，那么当sender保留的计时器超时的时候，就会重发原来的包</p>
</li>
<li><p>当出现早超时的情况，发出 seq=92, 8bytes of data 之后，才收到了ACK100和新的ACK120。 那么由于累计确认的机制，说明ACK120之前的所有数据都已经被接收了。因此HostB收到seq=92, 8bytes of data之后仍然返回ACK120。而主机A也并不需要再次等待ack100的信息了，且主机A的SendBase在收到ACK120的时候就已经移动到120了。</p>
<ul>
<li><blockquote>
<p>TCP 通过ACK 来实现可靠的数据传输，当主机A将数据发出之后会等待主机B的响应。如果有ACK，说明数据已经成功到达对端。反之，数据很有可能丢失。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/35.png" style="zoom: 67%;"></p>
<p>我们就拿下面这个模拟图来说一下<strong>累计确认机制(GBN所采用的)</strong>，顺便也回答一下为什么在sender收到ack后，只要判断y值大于sendBase 而不用等于 <code>NextSeqNum+length(data)</code> 这个问题。</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/36.png" style="zoom: 67%;"></p>
<p>首先主机A发送了两个packet，一个Seq=92, 8 bytes 长；一个Seq=100,20bytes长。 主机B已经收到了这两个包，并返回 ack100和ack120。 然而，这时候ack100的信息却在传输途中丢失了，只有ack120到达了主机A。所以说，如果主机A收到了 大于<code>NextSeqNum+length(data)</code> 的ACK确认信息，这说明说明ACK120之前的所有数据都已经被主机B接收了，因此主机A并不需要傻傻等着ACK=100的消息。只需直接更新sendBase即可。</p>
<p>值得注意的是，在接收端，也是有<strong>缓存机制(SR所采用的)</strong>，也就是收到不连续的包会进行缓存，而不是像GBN那样直接丢掉。因此，TCP可以看做是GBN和SR的一种结合</p>
<h5 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h5><p>除了刚才说的超时会导致重传, TCP还具有快速重传机制，这是针对 time-out 时间过长导致用户体验变差的情况而设计的。</p>
<p>快速重传就是说，发送者会通过接收到重复的ACK信息来察觉到丢包的情况——如果发送者连续收到<strong>3个</strong>相同的ack信息，那么就会直接在丢包处进行重发，而不必再等到time-out之后再重发。如下图所示：</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/37.png" style="zoom: 67%;"></p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>流量控制就是说，当发送端连续发送太多数据的时候，接收端可能来不及处理那么多的数据，导致溢出。因此我们有时候需要<strong>通过接收端来控制发送端的发送速率</strong>，来让接收者的buffer可以容纳发送来的数据而不溢出。</p>
<p>接收者的协议栈如下图所示，在IP层收到的报文段会向上传递，存放在 TCP receiver buffer中，上层应用层会从buffer中取出数据。</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/38.png" style="zoom: 67%;"></p>
<p>TCP 缓冲区的内部结构如下图所示，分为已缓存区域和空闲缓存其余。其中，空闲缓存区域可以看做是一个接受窗口<code>rwnd</code>，TCP 接收者在发给TCP发送者的报文中会有 rwnd的大小(16比特的接受窗口字段)，因此发送者就可以通过实时的rwnd大小来控制发包的速度。</p>
<p>发送者要控制已发送但还未<code>acked</code> 的 <code>pkt</code> 的数量<strong>小于等于</strong>  <code>rwnd</code> ，才能保持不因为溢出而丢包</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/39.png" style="zoom: 67%;"></p>
<h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/31.png" style="zoom: 67%;"></p>
<ol>
<li>第一步: 客户端TCP向服务器端的TCP发送一个特殊的TCP报文段, 该报文段不包含应用层数据. 报文段首部中的标志位SYN置1, 简称为SYN报文段. 同时客户端随机选取一个初始序列号x, 放置于SYN报文段的序号字段中, 最后把该报文段经下层封装发送给服务器. SYN的意思是: xxx服务器, 我想向你发起TCP连接, 我的初始序号为x.</li>
<li>第二步: 服务器收到SYN报文段后, 响应一个SYNACK报文段. SYNACK报文段的SYN标志位置1, 确认号字段设置为x + 1, 序号字段由服务器选择自己的初始序号 y. SYNACK报文段的意思是: 我收到了你的SYN报文段, 序号为x, 我同意该连接, 我自己的序号为y. 现在请求你的 x+1的报文段</li>
<li>第三步: 客户端接收到SYNACK后要告知服务器自己收到了. 于是发送最后一个报文段, SYN标志位置0, 把确认字段设置为y + 1, 并设置自己的序号为x+1. 这个报文意思是: 好的, 我知道你同意了, 我们开始传输数据吧.</li>
</ol>
<p><strong>为什么握手不能是两次呢？</strong></p>
<p>TCP连接就像男女朋友谈恋爱，如果只有两次握手，女孩子可能就不知道，她的那句我也爱你，男孩子是否收到，恋爱关系就不能愉快展开。</p>
<p><strong>为什么握手不能是四次呢？</strong></p>
<p>因为握手不能是四次呢？因为三次已经够了，三次已经能让<strong>双方都知道</strong>：你爱我，我也爱你。而四次就多余了。</p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/40.png" style="zoom: 67%;"></p>
<ol>
<li>首先客户端TCP向服务器发送一个特殊的TCP报文段, 其中FIN标志位被置1，<code>(FIN=1，seq=x)</code>, 发送完之后，客户进入 <code>FIN_WAIT_1</code> 状态，等待一个来自服务器的，带有ack的报文段</li>
<li>服务器收到该报文段后就进入CLOSE_WAIT 状态，并向发送方发送一个确认报文段,<code>(ACK=1，ack=x+1,seq =v)</code>，客户端收到后，进入 <code>FIN_WAIT_2</code>状态， 等待一个来自服务器的，FIN 被置为1 的报文段</li>
<li>然后服务器发送自己的终止报文段, 同样是把FIN位置1, <code>(FIN=1，ACK1,seq=y,ack=x+1)</code>.</li>
<li>最后客户端收到之后，进入<code>TIME_WAIT</code> 状态，并发送一个带有ACK的报文给server, <code>(ACK=1，seq=x+1,ack=y+1)</code></li>
<li>在 TIME_WAIT 状态中经过一段时间后，连接就正式关闭，客户端所有资源(包括端口号)，都将被释放</li>
</ol>
<ul>
<li>两次挥手行不行? 就是客户端提出关闭, 服务器响应后TCP就结束.</li>
<li>答: 不行, 因为客户单方面提出关闭的话, 服务器还是可以向客户端发送数据, 必须双方都提出关闭并得到确认后TCP连接才算关闭.</li>
</ul>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>有了TCP的窗口控制后，使计算机网络中两个主机之间不再是以单个数据段的形式发送了，而是能够连续发送大量的数据包。然而，大量数据包同时夜伴随着其他问题，比如说网络负载、网络拥堵等问题。TCP因此使用了<strong>拥塞控制</strong>机制，使得在面临网络拥塞时遏制发送方的数据发送。</p>
<p>拥塞控制主要有两种方法</p>
<ul>
<li><strong>端到端的拥塞控制</strong>：  因为网络层没有为运输层拥塞控制提供显示支持。所以即使网络中存在拥塞情况，端系统也要通过对网络行为的观察来推断。<strong>TCP 就是使用了端到端的拥塞控制方式</strong>。IP 层不会向端系统提供有关网络拥塞的反馈信息。那么 TCP 如何推断网络拥塞呢？<strong>如果超时或者三次冗余确认就被认为是网络拥塞，TCP 会减小窗口的大小，或者增加往返时延来避免</strong>。</li>
<li><strong>网络辅助的拥塞控制</strong>:  在网络辅助的拥塞控制中，路由器会向发送方提供关于网络中拥塞状态的反馈。这种反馈信息就是一个比特信息，它指示链路中的拥塞情况。</li>
</ul>
<h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>除了序号和确认号之外，TCP的拥塞控制也是实现TCP可靠性的基础。</p>
<p>TCP 所采用的方法是让每一个发送方根据所感知到的网络的拥塞程度来限制发出报文段的速率，如果 TCP 发送方感知到没有什么拥塞，则 TCP 发送方会增加发送速率；如果发送方感知沿着路径有阻塞，那么发送方就会降低发送速率。</p>
<blockquote>
<p>但是这种方法有三个问题</p>
<ol>
<li>TCP 发送方如何限制它向其他连接发送报文段的速率呢？</li>
<li>一个 TCP 发送方是如何感知到网络拥塞的呢？</li>
<li>当发送方感知到端到端的拥塞时，采用何种算法来改变其发送速率呢？</li>
</ol>
</blockquote>
<h5 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h5><p>我们先来讨论，TCP发送方如何限制它向其他连接发送报文段的速率呢？</p>
<p>我们知道，TCP是由接收缓存、发送缓存等组成。发送方的TCP拥塞控制机制会跟踪一个变量，即<strong>拥塞窗口</strong>的变量，拥塞窗口表示为<code>cwnd</code>, <strong>用于限制TCP在接收到ACK之前可以发送到网络的数据量</strong>，而<strong>接收窗口</strong>是用来告诉接收方能够接受的数据量</p>
<p>一般来说，发送方未确认的数据量不得超过 cwnd 和 rwnd 的最小值，也就是</p>
<script type="math/tex; mode=display">
LastByteSent - LastByteAcked <= \min(cwnd,rwnd)</script><p>由于每个数据包的往返时间是RTT，我们假设接收端有足够的缓存空间用于接收数据，我们就不用考虑rwnd了了，只用专注于cwnd，那么，该发送方的 <code>发送速率 = cwnd/RTT 字节/秒</code> . 通过调节cwnd，发送方因此能调整它向连接发送数据的速率。</p>
<h5 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h5><p><strong>一个 TCP 发送方是如何感知到网络拥塞的呢</strong>？</p>
<p>这个我们上面讨论过，是 TCP 根据<strong>超时</strong>或者 <strong>3 个冗余 ACK(丢包了)</strong> 来感知的。</p>
<h5 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h5><p><strong>当发送方感知到端到端的拥塞时，采用何种算法来改变其发送速率呢</strong> ?</p>
<p>这个问题比较复杂，一般来说，TCP 会遵循下面这几种指导性原则</p>
<ul>
<li>如果在报文段发送过程中丢失，那就意味着网络拥堵，此时需要适当降低 TCP 发送方的速率。</li>
<li>一个确认报文段指示发送方正在向接收方传递报文段，因此，当对先前未确认报文段的确认到达时，能够增加发送方的速率。为啥呢？因为未确认的报文段到达接收方也就表示着网络不拥堵，能够顺利到达<strong>，因此发送方拥塞窗口长度会变大，所以发送速率会变快.</strong> 此时发送速率就等于 <strong>cwnd/rtt</strong></li>
<li><code>带宽探测</code>，带宽探测说的是 TCP 可以通过调节传输速率来增加/减小 ACK 到达的次数，如果出现丢包事件，就会减小传输速率。因此，为了探测拥塞开始出现的频率， TCP 发送方应该增加它的传输速率。然后慢慢使传输速率降低，进而再次开始探测，看看拥塞开始速率是否发生了变化。</li>
</ul>
<p>在了解完 TCP 拥塞控制后，下面我们就该聊一下 TCP 的 <code>拥塞控制算法(TCP congestion control algorithm)</code> 了。TCP 拥塞控制算法主要包含三个部分：<strong>慢启动、拥塞避免、快速恢复</strong>，下面我们依次来看一下</p>
<h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><p>当一条 TCP 开始建立连接时，cwnd 的值就会初始化为<strong>一个 MSS</strong>的较小值。这就使得初始发送速率大概是 <code>MSS/RTT 字节/秒</code> ，比如要传输 1000 字节的数据，RTT 为 200 ms ，那么得到的初始发送速率大概是 40 kb/s 。实际情况下可用带宽要比这个 MSS/RTT 大得多，因此 TCP 想要找到最佳的发送速率，可以通过 <code>慢启动(slow-start)</code> 的方式，在慢启动的方式中，cwnd 的值会初始化为 1 个 MSS，并且每次传输报文确认后就会增加一个 MSS，cwnd 的值会变为 2 个 MSS，这两个报文段都传输成功后每个报文段 + 1，会变为 4 个 MSS，依此类推，每成功一次 cwnd 的值就会翻倍。如下图所示 </p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/41.png" style="zoom: 67%;"></p>
<p>发送速率不可能会一直增长，增长总有结束的时候，那么何时结束呢？慢启动通常会使用下面这几种方式结束发送速率的增长。</p>
<ul>
<li>如果在慢启动的发送过程出现丢包的情况，那么 TCP 会将发送方的 cwnd 设置为 1 并重新开始慢启动的过程，此时会引入一个 <code>ssthresh(慢启动阈值)</code> 的概念，它的初始值就是产生丢包的 cwnd 的值 / 2，即当检测到拥塞时，ssthresh 的值就是窗口值的一半。</li>
<li>第二种方式是直接和 ssthresh 的值相关联，因为当检测到拥塞时，ssthresh 的值就是窗口值的一半，那么当 cwnd &gt; ssthresh 时，每次翻番都可能会出现丢包，所以最好的方式就是 cwnd 的值 = ssthresh ，这样 TCP 就会转为拥塞控制模式，结束慢启动。</li>
<li>慢启动结束的最后一种方式就是如果检测到 3 个冗余 ACK，TCP 就会执行一种快速重传并进入<code>快速恢复</code>状态。</li>
</ul>
<h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><p>当 TCP 进入拥塞控制状态后，cwnd 的值就等于拥塞时值的一半，也就是 ssthresh 的值。所以，无法每次报文段到达后都将 cwnd 的值再翻倍。而是采用了一种相对<code>保守</code>的方式，每次cwnd窗口大小的报文都传输完成后只将 cwnd 的值增加<code>一个 MSS</code>，比如收到了 10 个报文段的确认，但是 cwnd 的值只增加一个 MSS。</p>
<p>因此线性增加的公式为：<code>cwnd = cwnd + MSS*(1/窗口数)</code></p>
<p>这是一种线性增长模式，它也会有增长逾值，它的增长逾值和慢启动一样，如果出现丢包，那么 cwnd 的值就是一个 MSS，ssthresh 的值就等于 cwnd 的一半；或者是收到 3 个冗余的 ACK 响应也能停止 MSS 增长。</p>
<p>如果 TCP 将 cwnd 的值减半后，仍然会收到 3 个冗余 ACK，那么就会将 ssthresh 的值记录为 cwnd 值的一半，进入 <code>快速恢复</code> 状态。</p>
<h4 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h4><p>快恢复算法，其过程有以下两个要点：</p>
<ol>
<li>当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢启动门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢启动算法，而进行快速恢复算法</li>
<li>由于发送方现在认为网络很可能没有发生拥塞，因此与慢v不同之处是现在不执行慢启动算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后+3*MSS的数值。 此后，对于使 TCP 进入快速恢复状态缺失的报文段，对于每个收到的冗余 ACK，cwnd 的值都会增加一个 MSS 。直到当丢失报文段的一个 ACK 到达时，TCP 在降低 cwnd 后进入拥塞避免状态。如果在拥塞控制状态后出现超时，那么就会迁移到慢启动状态，cwnd 的值被设置为 1 个 MSS，ssthresh 的值设置为 cwnd 的一半。</li>
</ol>
<p>这里，快速恢复把开始时的拥塞窗口cwnd值再增大一点，即等于 <strong>ssthresh + 3 X MSS</strong> 。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组<strong>不再消耗网络的资源而是停留在接收方的缓存</strong>中。可见现在网络中并不是堆积了分组而是减少了三个分组。因此可以适当把拥塞窗口扩大了些。</p>
<p>整一个TCP拥塞控制的用有限状态机如下：</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/42.png" style="zoom: 67%;"></p>
<p>当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。<br>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。<br>当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。</p>
<p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要<strong>迅速减少</strong>主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。 </p>
<p>整一个过程如下图所示：</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/43.png"></p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h3><p>考虑从主机A向主机B传输L字节的大文件，假设MSS为536字节。</p>
<ul>
<li>为了使得TCP序号不至于用完，L的最大值是多少？(TCP序号字段为4字节)</li>
<li>对于在上题中得到的L，求出传输此文件需要用多长时间？假设运输层、网络层和数据链路层首部<strong>总共为</strong>66字节，并加载每个报文段上，然后经155Mbps链路发送得到的分组。忽略流量控制和拥塞控制，使主机A能够一个接一个和连续不断得发送这些报文段</li>
</ul>
<p>答：TCP是<strong>字节流</strong>编号的，而TCP序号字一共有4字节。因此可供编码位数为32位，则$L_{\max} = 2^{32}$ byte</p>
<p>对于第二题，我们首先要求要发送的报文总数</p>
<p>$N=\lceil \frac{2^{32}}{536}\rceil = 801299$  </p>
<p>则需要发送的总长度为：$2^{32}+801299\times 66~byte = 4.824\cdot10^9$ byte</p>
<p>最后，我们要用总长除以链路传输速率，$t=4.824\cdot 10^9 bytes/155Mbps=249s$</p>
<h3 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h3><p>比较GBN、SR和TCP （无延时的ACK）。假设对所有3个协议的超时值足够长，使得5个连续的数 据报文段及其对应的ACK能够分别由接收主机（主机B）和发送主机（主机A）收到（如果在信 道中无丢失）。假设主机A向主机B发送5个数据报文段，并且第二个报文段（从A发送）丢失。 最后，所有5个数据报文段已经被主机B正确接收。</p>
<p>a. 主机A总共发送了多少报文段和主机B总共发送了多少ACK?它们的序号是什么？对所有3个 协议回答这个问题。</p>
<ul>
<li>对于GBN， A发送的报文段顺序为：123452345 (一共9个);  B发送的ACK: 11112345 (第二个包裹没收到，第345收到的时候仍然传回ack1，因为是累计确认机制，因此一共8个)</li>
<li>对于SR，A发送的报文段顺序为：123452(一共6个，选择确认)，B发送的ACK：13452(一共5个)</li>
<li>对于TCP，A发送的报文段顺序为：123452(一共6个，选择确认)，B发送的ACK: 22226(累计确认，发送ack2代表2以前的包都已接收)</li>
</ul>
<p>b. 如果对所有3个协议超时值比5RTT长得多，则哪个协议在最短的时间间隔中成功地交付所有5 个数据报文段？</p>
<p>对于GBN来说，需要等到最早的计时器(对于2)timeout时，才会重传2345，时间最长</p>
<p>对于SR来说，只有当专属于2的计时器timeout时，才会重传pkt2，因此时间必然长于5rtt</p>
<p>对于TCP来说，因为存在快速重传机制，导致发送端A在收到连续三个相同的ACK时，就会重传2. 因此采用TCP最快</p>
<h3 id="3-1"><a href="#3-1" class="headerlink" title="3"></a>3</h3><p>考虑仅有一条单一的TCP （Reno）连接使用一条10Mbps链路，且该链路没有缓存任何数据。假设 这条链路是发送主机和接收主机之间的<strong>唯一拥塞链路</strong>。假定某TCP发送方向接收方有一个大文件要 发送，而接收方的接收缓存比拥塞窗口要大得多。我们也做下列假设：每个TCP报文段长度为1500 字节；该连接的双向传播时延是150ms；并且该TCP连接<strong>总是处于拥塞避免阶段</strong>，即<strong>忽略了慢启动</strong>。</p>
<p>a.这条TCP连接能够取得的<strong>最大窗口长度</strong>（以报文段计）是多少？根据<code>发送速率 = cwnd/RTT 字节/秒</code>可知：</p>
<p>最大窗口长度可以由这个公式来计算： 最大窗口长度$\times MSS/ RTT = $链路速度</p>
<script type="math/tex; mode=display">
L_m = 10Mbps\times RTT/ MSS\\~\\
=10\times10^6 \times 0.15s/150\times 8 =125</script><p>b. 这条TCP连接的平均窗口长度（以报文段计）和平均吞吐量（以bps计）是多少？</p>
<p><strong>平均窗口长度：拥塞避免阶段所以窗口大小在W/2和W之间变化，所以平均窗口大小为0.75W=125x0.75=94[93.75的上限]</strong></p>
<p><strong>平均吞吐量：94x1500x8/0.15s=7.52Mbps</strong></p>
<p>c. 这条TCP连接在从丢包恢复后，再次到达其最大窗口要经历多长时间?</p>
<p>我们知道拥塞避免算法中cwnd是线性增长的，每次收到ack后cwnd增加一个MSS</p>
<p><strong>丢包之后窗口大小变为W/2=62，62变到125，需要125-62=63个RTT，即63x150ms=9.45s</strong></p>
<h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>考虑修改TCP的拥塞控制算法。 <strong>不使用加性增， 使用乘性增</strong>。   A TCP sender increases its window size by a small positive constant whenever it receives a valid ACK.求出<strong>丢包率L</strong> 和 <strong>最大拥塞窗口W</strong>之间的函数关系。论证： 对于这种修正的TCP,无论TCP的平均吞吐量如何， 一条TCP连接将其拥塞窗口长度从 $W/2$ 增加到 $W$ ,总是需要相同的时间</p>
<p> 也就是说，在拥塞控制之后，每次cwnd包含的分组数都传输完成后，就会乘以 $(1+a)$，假设一共收到n个ack之后，才从 $W/2$增加到 $W$,那么我可以这样求出n</p>
<script type="math/tex; mode=display">
\frac{w}{2}(1+a)^n = w</script><p>解得： $n=\log<em>{1+a}2$ 这说明，从$W/2$到$W$需要 $\log</em>{1+a}2\cdot RTT$ 秒，这与吞吐量是没有关系的。</p>
<p>现在求 <strong>丢包率L</strong> 和 <strong>最大拥塞窗口W</strong> 的函数关系：</p>
<p>首先求从 $W/2$ 到 $W$ 期间一共发送的分组数，也就是每次的拥塞窗口长度相加</p>
<script type="math/tex; mode=display">
S =\frac{w}{2}+\frac{w}{2}(1+a)+\frac{w}{2}(1+a)^2+\cdots+\frac{w}{2}(1+a)^{n}, 其中 ~~n=\log_{1+a}2\\~\\一共n+1项,则~~
=\frac{w}{2}\frac{(1-(1+a)^{\log_{1+a}2+1})}{1-(1+a)} \\~\\
=\frac{w}{2}\frac{(2a+1)}{a}</script><p>这都是因为一个丢包而导致的，因此，在这段时间的丢包率为：</p>
<script type="math/tex; mode=display">
L = \frac{1}{S} = \frac{2a}{W(2a+1)}</script><h5 id="5"><a href="#5" class="headerlink" title="5"></a>5</h5><p>考虑⼀种简化的TCP的AIMD算法(加法增大乘法减小算法)，其中拥塞窗⼝⻓度<strong>⽤报⽂段的数量</strong>来度量，⽽不是⽤字节(MSS)度量。在加性增中，每个RTT拥塞窗口长度增加一个报文段；在乘性减中，拥塞窗⼝⻓度减⼩⼀半（如果结果不是一个整数， 向下取整到最近的整数）。假设两条TCP连接C1和C2,它们共享一条速率为<strong>每秒30个报文段</strong>的单一拥塞链路。 假设C1和C2均处于拥塞避免阶段。 它们具有相同的100ms RTT。在时刻$t_0$, C1的拥塞窗口长度为15个报文段， 而C2的拥塞窗口长度是10个报文段。</p>
<p>a. 在2200ms后， 它们的拥塞窗口长度为多长？<br>b. 经长时间运行， 这两条连接将取得共享该拥塞链路的相同的带宽吗？<br>c. 如果这两条连接在相同时间达到它们的最大窗口长度， 并在相同时间达到它们的最小窗口长度,<br>我们说这两条连接是同步的。 经长时间运行， 这两条连接将最终变得同步吗？ 如果是， 它们的最<br>大窗口长度是多少？<br>d・这种同步将有助于改善共享链路的利用率吗？ 为什么？ 给出打破这种同步的某种思路</p>
<p>这里采用的是乘性减方法，也就是当网络层无法承受时，就会缩小一半。又因为每秒最多30个报文段，因此每100ms最多3个报文段。那么，当二者的cwnd都变为1时，这是能通过c1+c2的所有报文，因此会采用加性增，C1和C2都变为2，但是一旦它们变为2后，就会超出每100ms链路能承受的最多报文数量，因此又会采用乘性减。重新变为1。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>t/ms</th>
<th>C1 cwnd</th>
<th>C2 cwnd</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>15</td>
<td>10</td>
</tr>
<tr>
<td>100</td>
<td>7</td>
<td>5</td>
</tr>
<tr>
<td>200</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>300</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>400</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>500</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>600</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>700</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>800</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>900</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1000</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>1100</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1200</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>1300</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1400</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>1500</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1600</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>1700</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1800</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>1900</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2000</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>2100</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2200</td>
<td>2</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<p><strong>b.</strong><br>是的</p>
<p><strong>c.</strong><br>是的，最终都是2</p>
<p><strong>d.</strong><br>这样的同步不利于改善利用率<br>因为当 C1 C2 的窗口大小都为 1 时，这条链路无法满载。因此，我们可以增设一个缓冲区，在缓冲区溢出之前随机丢弃一些分组。主动队列管理，随机早期检测等都用到了此种方法。 </p>
<h5 id="6"><a href="#6" class="headerlink" title="6"></a>6</h5><p>假定在主机C上的一个进程有一个具有端口号6789的UDP套接字.假定主机A和主机B都用目的端口6789向主机C发送一个UDP报文段. 这两台主机的这些报文段在主机C都被描述为相同的套接字吗? 如果是这样的话, 在主机C的该进程将怎样知道源于两台不同主机的这两个报文段? </p>
<ul>
<li><strong>答:</strong> 这两台主机的这些报文段在主机C会被描述为相同的套接字. 因为在传输UDP包的时候, <strong>网络层会附带上源和目的的IP地址的</strong>, 主机C的程序可以通过不同的源IP地址判别.</li>
<li>毕竟主机A和B在选端口的时候不知道彼此具体会选什么, 肯定会有选用一样端口号的情况, 主机IP能把它们区分开.</li>
</ul>
<h5 id="7"><a href="#7" class="headerlink" title="7"></a>7</h5><p>假定在主机C端口80上运行一个Web服务器.假定这个Web服务器使用持续连接, 并且正在接收来自两台不同主机A和B的请求. 被发送的所有请求都通过位于主机C的相同套接字吗? 如果它们通过不同的套接字传递, 这两个套接字都具有端口80吗? 讨论和解释之.</p>
<p> <strong>答:</strong> 这里有个巧妙的关系为题目带来歧义.</p>
<p>A和B的请求会<strong>通过80端口找到服务器进程</strong>, 就这里而言它们通过为与C的相同套接字, 这个套接字具有端口80.</p>
<p>当它们与服务器进程建立连接的时候, 服务器进程会<strong>单独为它们分配套接字</strong>, 通过专门的套接字响应客户端的请求. 这两个套接字就不具有80端口了.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">计算机网络-应用层总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-03 00:16:44" itemprop="dateCreated datePublished" datetime="2021-05-03T00:16:44+08:00">2021-05-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-21 10:38:08" itemprop="dateModified" datetime="2022-06-21T10:38:08+08:00">2022-06-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机网络-应用层总结"><a href="#计算机网络-应用层总结" class="headerlink" title="计算机网络-应用层总结"></a>计算机网络-应用层总结</h1><h2 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h2><p>首先，我们要了解<strong>应用程序体系结构</strong>的概念。<strong>应用程序体系结构</strong>规定了如何在各种端系统上组织该应用程序。一般来说有两种体系结构：客户-服务器体系结构(client-server architecture)和对等(P2P)体系结构。</p>
<h3 id="Client-server-architecture"><a href="#Client-server-architecture" class="headerlink" title="Client-server architecture"></a>Client-server architecture</h3><p>在这个结构中，有一个总是打开的主机称为服务器，它会处理来自许多客户的主机的请求。一个典型的例子是 Web 应用程序，我们请求网页，网页处理请求，在把内容响应给我们。如下图所示：</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/1.png"></p>
<p>我们发现，客户相互之间是不直接通信的。</p>
<p>此外，客户-服务器体系结构的另一个特征是该服务器具有<strong>固定的、周知的</strong>地址，该地址称为IP地址。</p>
<p>具有客户-服务器体系结构的非常著名的应用程序包括Web、FTP、Telnet 和电子邮件。</p>
<p>配得大量主机的<strong>数据中心</strong>常被用于创建强大的虚拟服务器。最流行的因特网服务：如搜索引擎(Bing,Google) , 电商 (Amazon , e-bay ) ，基于Web的电子邮件(Gmail)等就应用了一个或者多个数据中心。</p>
<h3 id="P2P-architecture"><a href="#P2P-architecture" class="headerlink" title="P2P architecture"></a>P2P architecture</h3><p>在这个架构中，应用程序在间断连接的主机对之间使用直接通信。这些应用包括 文件共享(BitTorrent)， 下载器(迅雷)， 因特网电话和视频会议(Skype)等。</p>
<p> <img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/2.png"></p>
<h3 id="因特网提供的运输服务"><a href="#因特网提供的运输服务" class="headerlink" title="因特网提供的运输服务"></a>因特网提供的运输服务</h3><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>当某个程序调用TCP作为其运输协议时，该应用程序就能获得来自TCP的两种服务</p>
<ul>
<li>面向连接的服务： 在应用层数据报文开始流动之前，TCP让客户和服务器通过握手过程，提醒客户和服务器让它们为大量分组的到来做好准备。在握手截断后，一个TCP连接就在两个进程的套接字之间建立了。当应用程序结束发送报文时，必须拆除该连接</li>
<li>可靠的数据传送服务：通信进程能够依靠TCP，无差错，按适当顺序交付所有发送的数据。当应用程序的一端将字节流传入socket时，它能一开TCP将相同的字节流交付给接收方的socket，<strong>没有字节的丢失或者冗余</strong></li>
</ul>
<p>TCP还具有拥塞控制，当发送方和接收方之间的网络出现拥塞时，TCP的拥塞控制机制会抑制发送进程</p>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><ul>
<li>UDP 是无连接的，在两个进程通信前没有握手的过程。</li>
<li>UDP协议提供一种不可靠数据传送服务，也就是说，当进程将一个保温发送金UDP套接字时，UDP协议并不能保证该报文将到达接收进程。</li>
<li>UDP没有拥塞机制。所以UDP的发送端可以用它选定的任何速率向其下层注入数据。</li>
</ul>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/4.png"></p>
<h2 id="HTTP-Web"><a href="#HTTP-Web" class="headerlink" title="HTTP: Web"></a>HTTP: Web</h2><h3 id="HTTP概况"><a href="#HTTP概况" class="headerlink" title="HTTP概况"></a>HTTP概况</h3><p>Web的应用层协议是HTTP(超文本传输协议)，它是Web的核心。 超文本传输协议可以进行文字分割：<strong>超文本（Hypertext）、传输（Transfer）、协议（Protocol）</strong>，它们之间的关系如下</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/15.png"></p>
<p>按照范围的大小 协议 &gt; 传输 &gt; 超文本。下面就分别对这三个名次做一个解释。</p>
<h4 id="什么是超文本"><a href="#什么是超文本" class="headerlink" title="什么是超文本"></a>什么是超文本</h4><p>在互联网早期的时候，我们输入的信息只能保存在本地，无法和其他电脑进行交互。我们保存的信息通常都以<code>文本</code>即简单字符的形式存在，文本是一种能够被计算机解析的有意义的二进制数据包。而随着互联网的高速发展，两台电脑之间能够进行数据的传输后，人们不满足只能在两台电脑之间传输文字，还想要传输图片、音频、视频，甚至点击文字或图片能够进行<code>超链接</code>的跳转，那么文本的语义就被扩大了，这种语义扩大后的文本就被称为<code>超文本(Hypertext)</code>。</p>
<h4 id="什么是传输"><a href="#什么是传输" class="headerlink" title="什么是传输"></a>什么是传输</h4><p>那么我们上面说到，两台计算机之间会形成互联关系进行通信，我们存储的超文本会被解析成为二进制数据包，由传输载体（例如同轴电缆，电话线，光缆）负责把二进制数据包由计算机终端传输到另一个终端的过程称为<code>传输(transfer)</code>。</p>
<p>HTTP由两个程序实现：一个客户程序和一个服务器程序。两者运行在不同的端系统中，通过交换HTTP报文进行会话。它们之间的关系如下：</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/16.png" style="zoom:50%;"></p>
<h4 id="什么是协议"><a href="#什么是协议" class="headerlink" title="什么是协议"></a>什么是协议</h4><p>协议这个名词不仅局限于互联网范畴，也体现在日常生活中，比如情侣双方约定好在哪个地点吃饭，这个约定也是一种<code>协议</code>，比如你应聘成功了，企业会和你签订劳动合同，这种双方的雇佣关系也是一种 <code>协议</code>。注意自己一个人对自己的约定不能成为协议，协议的前提条件必须是多人约定。</p>
<p>那么网络协议是什么呢？</p>
<p>网络协议就是网络中(包括互联网)传递、管理信息的一些规范。如同人与人之间相互交流是需要遵循一定的规矩一样，计算机之间的相互通信需要共同遵守一定的规则，这些规则就称为网络协议。</p>
<p>没有网络协议的互联网是混乱的，就和人类社会一样，人不能想怎么样就怎么样，你的行为约束是受到法律的约束的；那么互联网中的端系统也不能自己想发什么发什么，也是需要受到通信协议约束的。</p>
<p>那么我们就可以总结一下，什么是 HTTP？可以用下面这个经典的总结回答一下： <strong>HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</strong></p>
<p>Web页面是由多个对象组成的，一个对象只是一个文件比如一个HTML文件，一个JPEG图形等，<strong>它们可以通过一个URL寻址</strong>。 </p>
<p>HTTP定义了Web客户向Web服务器请求Web页面的方式：</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/3.png"></p>
<p>当用户请求一个Web页面时，浏览器想服务器发出对该页面中所包含对象的<strong>HTTP请求报文</strong>，服务器接收到请求并用包含这些对象的<strong>HTTP响应报文</strong>进行响应</p>
<p>HTTP使用TCP作为支撑运输的协议，而TCP为HTTP提供可靠数据传输服务。这意味着，每一个请求报文和响应报文都能送达目的端。因此，HTTP协议不用担心数据丢失，也不关注TCP从网络的数据丢失和乱序故障中恢复的细节。</p>
<p>HTTP是一个<strong>无状态协议</strong>。其表现为：假如某个特定的客户在短短的几秒内两次请求同一个对象，服务器并不会因为刚刚为该客户提供了该对象就不在做出反应，而是重新发送该对象，就像服务器已经完全忘记不久之前做过的一样，<strong>服务器并不保存关于客户的任何信息</strong>。 </p>
<h3 id="非持续连接和持续连接"><a href="#非持续连接和持续连接" class="headerlink" title="非持续连接和持续连接"></a>非持续连接和持续连接</h3><p><strong>非持续连接</strong>： 每个请求/响应对是经一个<strong>单独的</strong>TCP连接发送的</p>
<p><strong>持续连接</strong>：每个请求/响应对是经<strong>相同的</strong>TCP连接发送的</p>
<p>现在我们来细致地讨论一下持续连接和非持续连接的优缺点。</p>
<h4 id="非持续连接"><a href="#非持续连接" class="headerlink" title="非持续连接"></a>非持续连接</h4><p>假如一个Web含有一个HTML 基本文件和10个JPEG 图形，并且这11个对象位于同一台服务器上。假设该HTML文件的URL为： <code>http://www.someSchool.edu/someDepartment/home.index</code></p>
<p>那么整个传输过程如下：</p>
<ol>
<li>HTTP Client 发起一个到服务器<code>www.someSchool.edu</code>的TCP连接。</li>
<li>HTTP Client 客户经它的套接字向该服务器发送一个HTTP请求报文，包含了路径名 <code>/someDepartment/home.index</code></li>
<li>HTTP Server 收到请求报文，检索处对象 <code>http://www.someSchool.edu/someDepartment/home.index</code> ，在一个HTTP响应报文中封装对象，并通过其Socket向客户发送响应报文</li>
<li>HTTP Server通知TCP断开TCP连接，直到TCP Client已经完整收到响应报文，才会实际中断连接</li>
<li>HTTP Client 收到响应报文，TCP连接关闭，Client 检查HTML文件，得到对10个JPEG文件的引用</li>
<li>对10个JPEG文件重复前面四个步骤。</li>
</ol>
<p>因此，Web中有几个对象，就要产生几个TCP连接。</p>
<h4 id="RTT-的概念"><a href="#RTT-的概念" class="headerlink" title="RTT 的概念"></a>RTT 的概念</h4><p>RTT(Round-Trip Time) 往返时间指的是一个段分组从客户到服务器然后再返回客户所花费的时间。我们尝试用RTT来表示客户点击超链接后页面出现的时间，如下图所示：</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/5.png"></p>
<p>粗略地讲，总的响应时间就是两个RTT 再加上服务器传输HTML文件的时间</p>
<h4 id="持续连接"><a href="#持续连接" class="headerlink" title="持续连接"></a>持续连接</h4><p>上面讲的非持续连接有一些缺点</p>
<ul>
<li>必须为每一个请求的对象建立和维护一个全新的连接。这给Web服务器带来了严重的负担</li>
<li>每一个对象经受两倍RTT的交付时延，累计起来是一个很大的数字</li>
</ul>
<p>采用持续连接，服务器在发送响应后应该保持该TCP连接打开。在相同的客户与服务器之间，后续请求和响应报文可以通过相同的连接进行传送。</p>
<h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><p>详见我的博客： <a href="https://jasonxqh.github.io/2021/04/02/计算机网络报告5/#3-1-HTTP协议">HTTP协议</a></p>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>cookie 允许站点对用户进行跟踪，把内容与用户身份联系起来。</p>
<p>cookie 技术有4个组件：</p>
<ol>
<li>在HTTP响应报文中的一个cookie首部行</li>
<li>在HTTP请求报文中的一个cookie首部行</li>
<li>在用户端系统中保留一个cookie文件，并由 客户的浏览器进行管理</li>
<li>位于Web站点的一个后端数据库</li>
</ol>
<p>原理如下图所示</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/6.png"></p>
<p>当客户端请求服务器时，如果服务器需要记录该用户状态，就在响应头中向客户端浏览器颁发一个Cookie，而客户端浏览器会把cookie保存起来。当再次请求该网站时，浏览器把请求的网站连同该cookie一起提交给服务器，服务器会检查该cookie，以此来辨认用户状态。</p>
<h3 id="Web-缓存"><a href="#Web-缓存" class="headerlink" title="Web 缓存"></a>Web 缓存</h3><p>Web缓存器也叫代理服务器，其模式如下图所示：</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/7.png"></p>
<p>代理服务器有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象的副本。这时，假设浏览器正在请求对象 <code>http://www.someschool.com/campus.gif</code>对象，将会发生一下情况：</p>
<ol>
<li>浏览器创建一个到代理服务器的TCP连接，并向代理服务器发送一个HTTP请求</li>
<li>代理服务器收到请求后，看看本地是否存储了该对象副本。如果有，<strong>Web缓存器</strong>就向客户的浏览器用HTTP响应报文返回该对象</li>
<li>如果Web缓存器没有该对象，就打开一个与该对象的初始服务器的TCP连接并发送HTTP请求。收到请求后，出事服务器向该Web缓存器发送具有该对象的HTTP响应</li>
<li>当Web缓存器接收到该对象时，他在本地存储空间存储一份副本，并向客户的浏览器发送该副本</li>
</ol>
<p>所以说，一个Web缓存器既是服务器又是客户。当他接收浏览器的请求并发回响应时，是一个服务器。它向初始服务器发送请求并接收响应时它是一个客户。</p>
<h2 id="SMTP-电子邮件"><a href="#SMTP-电子邮件" class="headerlink" title="SMTP: 电子邮件"></a>SMTP: 电子邮件</h2><p>下图给出了电子邮件系统的总体情况，我们可以看到它有3个主要的组成部分：用户代理、邮件服务器、SMTP</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/8.png"></p>
<p>用户代理比如说：Foxmail，Outlook ，Apple Mail 这类的软件</p>
<p>邮件服务器：qq邮箱，163邮箱，Gmail之类的邮件服务</p>
<p>SMTP则是<strong>简单邮件传输协议</strong>。</p>
<p>SMTP是因特网电子邮件的核心。它使用TCP可靠数据传输服务。每台邮件服务器上既运行着SMTP的客户端也运行着SMTP的服务器端。当一个邮件服务器向其他邮件服务器<strong>发送</strong>邮件时，他就是<strong>SMTP的客户</strong>；当邮件服务器从其他邮件服务器上<strong>接收</strong>邮件时，他就表现为一个<strong>SMTP的服务器</strong>。</p>
<p> 假设Alice 想给  Bob发送一份简单的报文。</p>
<ol>
<li>Alice调用它的邮件代理程序并提供Bob的邮件地址，撰写报文，然后指示用户代理发送该报文</li>
<li>Alice的用户代理把报文发给她的邮件服务器，在那里，该报文被放在报文队列中</li>
<li>运行在Alice的邮件服务器上的SMTP客户端发现了报文队列中的这个报文，他就创建一个到运行在Bob的邮件服务器上的SMTP服务器的TCP连接</li>
<li>在经过一些初始的SMTP握手后，SMTP客户通过该TCP连接发送Alice的报文。</li>
<li>在Bob的邮件服务器上，SMTP的服务器端接收该报文。Bob的邮件服务器然后将该报文放入Bob的邮箱中。</li>
<li>在Bob有时间的时候，它调用用户代理阅读该报文。</li>
</ol>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/9.png"></p>
<p>注意：SMTP 一般<strong>不适用中间邮件服务器</strong>发送邮件，如果Bob的邮件服务器没有开机，该报文会保留在ALice的邮件服务器上并等待新的尝试。</p>
<p>现在你知道了两台邮件服务器邮件发送的大体过程，那么，SMTP 是如何将邮件从 Alice 邮件服务器发送到 Bob 的邮件服务器的呢？主要分为下面三个阶段</p>
<ul>
<li><code>建立连接</code>：在这一阶段，SMTP 客户请求与服务器的25端口建立一个 TCP 连接。一旦连接建立，SMTP 服务器和客户就开始相互通告自己的域名，同时确认对方的域名。</li>
<li><code>邮件传送</code>：一旦连接建立后，就开始邮件传输。SMTP 依靠 TCP 能够将邮件准确无误地传输到接收方的邮件服务器中。SMTP 客户将邮件的源地址、目的地址和邮件的具体内容传递给 SMTP 服务器，SMTP 服务器进行相应的响应并接收邮件。</li>
<li><code>连接释放</code>：SMTP 客户发出退出命令，服务器在处理命令后进行响应，随后关闭 TCP 连接。</li>
</ul>
<h3 id="与HTTP的对比"><a href="#与HTTP的对比" class="headerlink" title="与HTTP的对比"></a>与HTTP的对比</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ul>
<li>HTTP 是从<strong>Web服务器向Web客户</strong>传送文件；SMTP事一个<strong>邮件服务器向另一个邮件服务器</strong>传送文件</li>
<li>当进行文件传送时，持续的HTTP和SMTP都采用<strong>持续连接</strong></li>
</ul>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ul>
<li>HTTP主要是 <strong>拉协议(pull protocol)</strong>，即用户使用HTTP从该服务器拉取信息;而SMTP基本上是一个<strong>推协议(push protocol)</strong>，及发送邮件服务器把文件推向接收邮件服务器</li>
<li>SMTP要求每个报文采用 <strong>7 比特的ASCII 码</strong>格式。HTTP数据则不受这些限制</li>
<li>HTTP把每个对象分装到它自己的HTTP响应报文中去，而SMTP则<strong>把所有报文对象放在一个报文之中</strong>。</li>
</ul>
<h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><p>详见我的博客 <a href="https://jasonxqh.github.io/2021/04/02/计算机网络报告5/#Task5-amp-6">WireShark 抓取SMTP 数据包</a></p>
<h3 id="因特网邮件访问协议"><a href="#因特网邮件访问协议" class="headerlink" title="因特网邮件访问协议"></a>因特网邮件访问协议</h3><p>Bob的用户代理不能使用SMTP得到报文，因为获取报文是一个拉操作，而SMTP协议是一个推协议。这就需要引入一个特殊的邮件访问协议来解决，该协议将Bob邮件服务器上的报文传送给他本地的PC。目前有一些流行的访问协议：POP3、IMAP以及HTTP</p>
<h4 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h4><p>POP3 是一个极为简单的邮件访问协议。POP3按照三个阶段进行工作：</p>
<ol>
<li>Authorization(特许)，用户代理发送用户名和口令以鉴别用户</li>
<li>事务处理阶段，用户代理取回报文。同时还能进行如下操作：对报文做删除标记，取消报文删除标记，获取邮件统计信息</li>
<li>更新阶段，出现在客户发出了quit命令之后，目的是结束该POP3会话。这时，该邮件服务器会删除那些被标记为删除的报文</li>
</ol>
<p>在POP3的事务处理过程中，用户代理的回答可能有OK(正常)和-ERR(出现差错)</p>
<p>在事务处理阶段，POP3的用户代理通常被配置为”下载并删除”或者“下载并保留”方式。</p>
<h5 id="下载并删除"><a href="#下载并删除" class="headerlink" title="下载并删除"></a>下载并删除</h5><p>这种方式存在的问题是，邮件接收方Bob可能是移动的，可能希望从多个不同的机器访问他的邮件报文，如从办公室的PC和笔记本来访问邮件。那么，如果Bob先在办公室的PC上收取了一条邮件，那么晚上当他在家里时，他便不能再通过笔记本收取该邮件</p>
<h5 id="下载并保留"><a href="#下载并保留" class="headerlink" title="下载并保留"></a>下载并保留</h5><p>用户代理下载某邮件之后该邮件仍然保留在邮件服务器上。这样Bob就能通过不同的及其重新读取这些邮件</p>
<h4 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a>IMAP</h4><p>IMAP 是另一个邮件访问协议，它比 POP3具有更多的特色，不过也比POP3复杂得多。 POP3 会对移动用户带来问题。IMAP更喜欢使用一个在远程服务器上的层次文件夹，这样他可以从任何一台机器上对所有报文进行访问，但是POP3协议并没有给用户提供任何创建远程文件夹并为报文指派文件夹的方法。</p>
<ul>
<li>IMAP服务器把每个报文与一个文件夹联系起来，当报文第一次到达服务器时，它与收件人的INBOX文件夹相关联。收件人作为能够把邮件移到一个新的用户创建的文件夹中来阅读邮件、删除邮件等。</li>
<li>IMAP协议为用户提供了创建文件夹以及将邮件从一个文件夹移动到另一个文件夹的命令</li>
<li>IMAP 还为用户提供了在远程文件夹中查询邮件的命令</li>
<li>IMAP 服务器维护了IMAP会话的用户状态信息</li>
<li>IMAP 具有允许用户代理获取报文某些部分的命令。例如，一个用户代理可以只读取一个报文的首部。</li>
</ul>
<h4 id="基于Web的电子邮件"><a href="#基于Web的电子邮件" class="headerlink" title="基于Web的电子邮件"></a>基于Web的电子邮件</h4><p>比如网页端的QQ邮箱，网易邮箱。使用这种服务，用户代理就是普通的浏览器，用户和他远程邮箱之间的通信通过HTTP进行：</p>
<ul>
<li>收件人从邮箱中访问一个报文时，该电子邮件报文从Bob的邮件服务器发送到他的浏览器，使用的是HTTP而不是POP3或者IMAP协议</li>
<li>当发件人要发送一封电子邮件报文时，该电子邮件豹纹从浏览器发送到邮件服务器使用的是HTTP报文而不是SMTP</li>
<li>但是，邮件服务器之间发送和接收邮件时，仍然使用SMTP</li>
</ul>
<h2 id="DNS-因特网的目录服务"><a href="#DNS-因特网的目录服务" class="headerlink" title="DNS: 因特网的目录服务"></a>DNS: 因特网的目录服务</h2><p>首先我们要搞清楚 主机名和IP地址的关系。</p>
<p>主机名如：facebook.com、google.com 等 但是，主机名几乎没有提供关于主机在因特网中位置的信息，这让路由器难以处理</p>
<p>IP 地址： 由4个字节组成，并有着严格的层次结构。例如 <code>121.7.106.83</code> 这样一个 IP 地址，其中的每个字节都可以用 <code>.</code> 进行分割，表示了 <code>0 - 255</code> 的十进制数字。 </p>
<p>我们需要一种进行主机名到IP地址转换的目录服务，这就是DNS的主要任务。DNS是：</p>
<ol>
<li>一个由分层的DNS服务器实现的分布式数据库</li>
<li>一个使得主机能够查询分布式数据库的应用层协议</li>
</ol>
<p>如下图所示：</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/17.png"></p>
<p>总的来说，在单一DNS服务器上运行集中式数据库完全没有可扩展能力。因此，DNS采用了分布式设计方案。</p>
<h3 id="DNS工作机理概述"><a href="#DNS工作机理概述" class="headerlink" title="DNS工作机理概述"></a>DNS工作机理概述</h3><p>DNS 是一个复杂的系统，我们在这里只是就其运行的主要方面进行学习，下面给出一个 DNS 工作过程的总体概述</p>
<p>假设运行在用户主机上的某些应用程序（如 Web 浏览器或邮件阅读器） 需要将主机名转换为 IP 地址。这些应用程序将调用 DNS 的客户端，并指明需要被转换的主机名。用户主机上的 DNS 收到后，会使用 UDP 通过 53 端口向网络上发送一个 DNS 查询报文，经过一段时间后，用户主机上的 DNS 会收到一个主机名对应的 DNS 回答报文。因此，从用户主机的角度来看，DNS 就像是一个黑盒子，其内部的操作你无法看到。但是实际上，实现 DNS 这个服务的黑盒子非常复杂，它由分布于全球的大量 DNS 服务器以及定义了 DNS 服务器与查询主机通信方式的应用层协议组成。</p>
<p>DNS 最早的一种简单设计只是在因特网上使用一个 DNS 服务器。该服务器会包含所有的映射。这是一种<code>集中式</code>的设计，这种设计并不适用于当今的互联网，因为互联网有着数量巨大并且持续增长的主机，这种集中式的设计会存在以下几个问题</p>
<ul>
<li><code>单点故障(a single point of failure)</code>，如果 DNS 服务器崩溃，那么整个网络随之瘫痪。</li>
<li><code>通信容量(traaffic volume)</code>，单个 DNS 服务器不得不处理所有的 DNS 查询，这种查询级别可能是上百万上千万级</li>
<li><code>远距离集中式数据库(distant centralized database)</code>，单个 DNS 服务器不可能 <code>邻近</code> 所有的用户，假设在美国的 DNS 服务器不可能临近让澳大利亚的查询使用，其中查询请求势必会经过低速和拥堵的链路，造成严重的时延。</li>
<li><code>维护(maintenance)</code>，维护成本巨大，而且还需要频繁更新。</li>
</ul>
<p>所以 DNS 不可能集中式设计，它完全没有可扩展能力，因此采用<code>分布式设计</code>，所以这种设计的特点如下</p>
<h4 id="分布式、层次数据库"><a href="#分布式、层次数据库" class="headerlink" title="分布式、层次数据库"></a>分布式、层次数据库</h4><p><strong>没有一台DNS服务器拥有因特网上所有主机的映射</strong>。大致来说，有3种类型的DNS服务器：根DNS服务器、顶级域DNS服务器和权威DNS服务器。</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/10.png"></p>
<h5 id="根DNS服务器"><a href="#根DNS服务器" class="headerlink" title="根DNS服务器"></a>根DNS服务器</h5><p>有400多个根服务器遍及全世界。根名字服务器提供TLD服务器的IP地址</p>
<h5 id="顶级域DNS服务器。"><a href="#顶级域DNS服务器。" class="headerlink" title="顶级域DNS服务器。"></a>顶级域DNS服务器。</h5><p>对于每个顶级域(如com、org、edu) 和所有国家的顶级域(uk,cn)等，都有TLD(Top-Level Domain)服务器. TLD服务器提供了权威DNS服务器的IP地址</p>
<h5 id="权威DNS服务器"><a href="#权威DNS服务器" class="headerlink" title="权威DNS服务器"></a>权威DNS服务器</h5><p>一个组织机构的权威DNS收藏了DNS记录。另一种方法是，该组织能够支付费用，让这些记录存储在某个服务提供商的一个权威DNS服务器中。多数大学和大公司实现和维护他们自己基本和备份的权威DNS服务器。</p>
<h4 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h4><p>第一个步骤是本机向本地域名服务器发出一个DNS请求报文，报文里携带需要查询的域名；第二个步骤是本地域名服务器向本机回应一个DNS响应报文，里面包含域名对应的IP地址或者别名等。由两种查询方法：</p>
<p><strong>递归查询：</strong>本机向本地域名服务器发出一次查询请求，<strong>就静待最终的结果</strong>。如果本地域名服务器无法解析，自己会以DNS客户机的身份向其它域名服务器查询，直到得到最终的IP地址告诉本机</p>
<p><strong>迭代查询：</strong>本地域名服务器向根域名服务器查询，根域名服务器告诉它下一步到哪里去查询，然后它再去查，<strong>每次它都是以客户机的身份去各个服务器查询</strong></p>
<p>注意：理论上，任何DNS查询机可以是迭代的也可以是递归的。 在实践中，第一个步骤从主机到本地域名服务器是<strong>递归查询</strong>；第二大步骤中采用的是<strong>迭代查询</strong>，其实是包含了很多小步骤的， 如下图所示。</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/11.png"></p>
<h3 id="DNS报文分析"><a href="#DNS报文分析" class="headerlink" title="DNS报文分析"></a>DNS报文分析</h3><p>详见博客： <a href="https://jasonxqh.github.io/2021/04/08/计算机网络报告6/#3-2-DNS协议">DNS协议 </a></p>
<h2 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h2><p>当一个单一服务器向大量主机分发一个大文件时，就必须向每个对等方发送该文件的一个副本。折让服务器承受了极大地负担，消耗了大量服务器带块。而使用P2P结构，每个对等方能够向任何其他对等方重新分发他已经收到的该文件的任何部分，从而在分发的过程中协助该服务器。</p>
<h3 id="P2P-体系结构的扩展性"><a href="#P2P-体系结构的扩展性" class="headerlink" title="P2P 体系结构的扩展性"></a>P2P 体系结构的扩展性</h3><p>如下图所示，服务器和对等方使用接入链路与因特网相连。其中 </p>
<p>$u_s$  表示服务器接入链路的上载速率</p>
<p>$u_i$表示第i对等方接入链路的上载速率</p>
<p>$d_i$ 表示第i 对等方接入链路的下载速率</p>
<p>$F$表示备份发的文件长度(bit) </p>
<p>$N$表示要获得的该文件副本的对等方数量</p>
<p>我们可以这样来定义<strong>分发时间：</strong> 是所有N个对等方得到该文件的副本所需要的时间。</p>
<p>首先我们假设因特网核心具有足够的带宽，这样所有瓶颈都在网络接入链路。还假设服务器和客户没有参与任何其他网络应用，因此他们的所有上传和下载访问贷款能被全部用于分发该文件。</p>
<h4 id="对于-客户-服务器体系结构"><a href="#对于-客户-服务器体系结构" class="headerlink" title="对于 客户-服务器体系结构"></a>对于 客户-服务器体系结构</h4><p>我们将客户服务器体系结构的分发时间记为 $D_{cs}$</p>
<ul>
<li>服务器必须向N个对等方传输该文件的一个副本。因此服务器必须传输NF 比特。因为该服务器上载的速度是 $u_s$, 分发该文件的时间必定是至少为 $NF/u_s$</li>
<li>令$d<em>{\min}$ 表示具有<strong>最小下载速率</strong>的对等方的下载速率，即 $d</em>{\min}=\min{d<em>1,\cdots,d_N }$,具有最小下载速率的对等方至少需要 $F/d</em>{\min}$ 的时间内获得F比特。因此最小分发的时间至少为 $F/d_{\min}$</li>
</ul>
<p>结合两者，我们得到： </p>
<script type="math/tex; mode=display">
D_{cs} \geq \max\{\frac{NF}{u_s},\frac{F}{d_{\min}}\}</script><p>我们可以直接取其下界。也就是$D<em>{cs} = \max{\frac{NF}{u_s},\frac{F}{d</em>{\min}}}$ </p>
<p>那么，对于足够大的N，客户-服务器 分发时间为 $\frac{NF}{u_s}$ 。这和用户的数量成线性增加的关系。</p>
<h4 id="对于P2P-体系结构"><a href="#对于P2P-体系结构" class="headerlink" title="对于P2P 体系结构"></a>对于P2P 体系结构</h4><p>在P2P体系结构中，每个对等方(用户)能够帮助服务器分发该群文件。特别的，当一个对等方接收到某些文件数据时，能够使用自己的上载能力重新将数据分发给其他对等方。</p>
<ul>
<li>在分发的开始，只有服务器具有稳健。因此该服务器必须接入链路发送该文件的每个比特1次。因此最小的分发时间为 $\frac{F}{u_s}$</li>
<li>与客户-服务器体系结构相同，具有最小下载速率的对等方至少需要 $F/d<em>{\min}$ 的时间内获得F比特。因此最小分发的时间至少为 $F/d</em>{\min}$</li>
<li>最后，观察到系统整体的总上载能力等于服务器的上载速率加上每个单独的对等方上载速率。即：$u_{total} = u_s+u_1+\cdots+u_N$ 。 系统必须总共交付NF bit。 因此，最小的分发时间最小是： $NF/(u_s+u_1+\cdots+u_N)$ </li>
</ul>
<p>将这三个观察放在一起，我们获得了对P2P的最小分发时间，表示为 $D_{P2P}$ </p>
<script type="math/tex; mode=display">
D_{P2P}\geq \max\{\frac{F}{u_s},\frac{F}{d_{\min}},\frac{NF}{u_s+u_1+\cdots+u_N}\}</script><p>同样的我们可取其下界。$D<em>{P2P}= \max{\frac{F}{u_s},\frac{F}{d</em>{\min}},\frac{NF}{u_s+u_1+\cdots+u_N}}$</p>
<p>我们假设$F/u=1h,u<em>s=10\mu,d</em>{\min}\geq u_s$ 并画出图像如下图</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/13.png"></p>
<p>我们发现具有P2P 体系结构的应用程序可以自扩展。</p>
<h2 id="视频流和内容分发网"><a href="#视频流和内容分发网" class="headerlink" title="视频流和内容分发网"></a>视频流和内容分发网</h2><h4 id="因特网视频"><a href="#因特网视频" class="headerlink" title="因特网视频"></a>因特网视频</h4><p>在流式存储视频应用中，最基础的媒体是预先录制的视频例如电影、电视节目、录制好的体育事件或者用户生成的视频。这些预先录制好的视频会放置在服务器上，用户按需向服务器发送请求来观看视频。许多因特网公司现在提供流式视频，这些公司包括 Netflix、YouTube 、亚马逊和优酷等。</p>
<p>视频式一系列的图像，通常会以一种恒定的速率（如每秒 24 或 30 张图像）来展现。一幅未压缩、数字编码的图像由像素阵列组成，其中每个像素又一些比特编码来表示亮度和颜色。视频的一个重要特征是它能够被压缩、因而可用比特率来权衡视频质量。</p>
<h4 id="HTTP-流和-DASH"><a href="#HTTP-流和-DASH" class="headerlink" title="HTTP 流和 DASH"></a>HTTP 流和 DASH</h4><p>在 HTTP 流中，视频只是存储在 HTTP 服务器中的一个文件，每个文件有特定的 URL。当用户想要看视频时，客户与服务器创建一个 TCP 连接并发送该 URL 的 HTTP GET 请求。服务器则以底层网络协议和流量条件允许的尽可能快的速率，在一个 HTTP 响应中发送该文件视频。</p>
<p>尽管 HTTP 流在实践中已经得到广泛部署，但是它由严重缺陷，即所有客户接收到相同编码的视频，但是对于客户而言，带宽时动态变化的，在不同的时间，带宽大小有很大不同。这种情况导致了一种新型 HTTP 流的研发，它常常被称为 <code>经 HTTP 的动态适应性流(Dynamic Adaptive Streaming over HTTP, DASH)</code>。在 DASH 中，视频编码为几个不同的版本，每个版本对应不同的比特率。</p>
<p>DASH 允许客户使用不同的以太网接入速率流失播放具有不同编码速率的视频。使用 3G 连接的客户能够接受一个低比特率的版本，使用光纤能够接受高比特率的版本。</p>
<p>使用 DASH 后，每个视频版本存储在 HTTP 中，每个版本都有一个不同的 URL。HTTP 服务器也会有一个 <code>告示文件(manifest file)</code>，为每个版本提供了一个 URL 及其比特率。</p>
<h4 id="内容分发网"><a href="#内容分发网" class="headerlink" title="内容分发网"></a>内容分发网</h4><p>现如今，许多因特网视频公司日复一日地向数以百万计的用户按需分发每秒数兆比特的流。对于一个因特网视频公司，或许提供流式视频服务最为直接的方法是建立一个单一的超大规模的数据中心。在数据中心内部存储所有视频，然后把视频返回到全世界范围内的客户。这种方式存在三个问题</p>
<ul>
<li>如果客户远离数据中心，服务器到客户的分组将跨越许多通信链路并可能通过很多 ISP，造成通信延迟</li>
<li>流式视频可能经过相同的链路发送了许多次，造成带宽和资源浪费。</li>
<li>单点问题，如果单一结点故障，这可能是灾难性的。</li>
</ul>
<p>为了应对向分布于全世界的用户分发巨量视频数据的挑战，几乎所有主要的视频流公司都利用 <code>内容分发网(Content Distribution Network, CDN)</code>。 CDN 管理分布在多个地理位置上的服务器，在它的服务器上存储视频副本，并且所有试图将每个用户请求定向到一个提供最好用户体验的 CDN 位置。那么<strong>服务器如何选址呢</strong>？事实上有两种服务器安置原则</p>
<ul>
<li><code>深入</code>，它的主要目标是靠近用户，通过减少端用户和 CDN 集群之间链路和路由器的数量，从而改善了用户感受的时延和吞吐量。</li>
<li><code>邀请做客</code>，这个原则是通过在少量（例如 10 个）关键位置建造大集群来邀请 ISP 来做客，这些CDN集群通常放在因特网交换结点(IXP).  与深入设计原则相比，好处是产生<strong>较低的维护和管理开销</strong>. 缺点是以对端用户的<strong>较高时延和较低吞吐量为代价</strong>.</li>
</ul>
<p>CDN 可以是<code>专用 CDN(private CDN)</code>, 即它由内容提供商自己所拥有；另一种 CDN 是 <code>第三方 CDN(third-party CDN)</code>，它代表多个内容提供商分发内容。</p>
<p>除了如时延, 丢包和带宽性能等网络相关的考虑外, 设计一种CDN服务器选择策略时还有其他重要因素. 它们是什么?</p>
<ul>
<li>还要考虑它分发的内容.</li>
</ul>
<h4 id="CDN-分发过程"><a href="#CDN-分发过程" class="headerlink" title="CDN 分发过程"></a>CDN 分发过程</h4><p>上面我们探讨了一下 CDN 的选址过程，那么 CDN 是如何工作的呢？</p>
<p>当用户主机中的一个浏览器指令检索一个特定的视频（由 URL 标识）时，CDN 必须能够截获请求，来进行下面的操作</p>
<ul>
<li>确定此时适用于该客户的 CDN 服务器集群</li>
<li>将客户的请求重定向到集群中的某台服务器上</li>
</ul>
<p>大多数 CDN 利用 <strong>DNS 协议</strong>来截获和重定向请求。</p>
<p>下面是 CDN 的具体工作流程</p>
<p>假设一个内容提供商 <code>NetCinema</code> ，雇用了第三方 CDN 公司 <code>KingCDN</code> 来向它的客户分发视频。在 NetCinema 的 Web 网页上，它的每个视频都被指派了一个 URL，该 URL 包括了字符串 <code>video</code> 以及视频本身的标识符。下面要访问 <code>http://video.netcinema.com/6Y7B23V</code> ，它的工作过程如下</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/18.png"></p>
<ol>
<li>用户访问位于 NetCinema 的 Web 网页</li>
<li>当用户点击链接 <code>http://video.netcinema.com/6Y7B23V</code> 时，该用户主机发送了对于 <code>video.netcinema.com</code>的 DNS 请求</li>
<li>用户本地 DNS 服务器(LDNS， Local DNS) 将该 DNS 请求中继到一台用于 NetCinema 的权威 DNS 服务器，该服务器观察到主机名 <code>video.netcinema.com</code> 中的字符串 <code>video</code>。为了将该 DNS 请求移交给 KingCDN，NetCinema 权威 DNS 服务器并不返回一个 IP 地址，而是向 LDNS 返回一个 KingCDN 域的主机名，如 a1105.kingcdn.com</li>
<li>从此时起，DNS 请求就会进入 KingCDN 专用 DNS 基础设施，用户的 LDNS 则发送第二个请求，此时是对 a1105.kingcdn.com 的 DNS 请求，KingCDN 的 DNS 系统最终向 LDNS 返回 KingCDN 内容服务器的 IP 地址。所以正是这里，<strong>在 KingCDN 的 DNS 系统中，指定了 CDN 服务器</strong>，客户将能够从这台服务器接收它的内容</li>
<li>LDNS 向用户主机转发内容服务 CDN 节点的 IP 地址</li>
<li>一旦客户收到 KingCDN 内容服务器的 IP 地址，它与具有该 IP 地址的服务器创建一条 TCP 连接，并且发出对该视频的 HTTP <code>GET</code> 请求。如果使用了 DASH，服务器将首先向客户发送具有 URL 列表的告示文件，每个 URL 对应视频的每个版本，并且客户将动态的选择来自不同版本的块。</li>
</ol>
<h4 id="CDN-的集群选择策略"><a href="#CDN-的集群选择策略" class="headerlink" title="CDN 的集群选择策略"></a>CDN 的集群选择策略</h4><p>任何 CDN 的部署，其核心是 <code>集群选择策略(cluster selection strategy)</code>， 即动态的将客户定向到 CDN 中某个服务器集群或数据中心的机制。一种简单的策略是指派客户到 <code>地理上最为临近(geographically closest)</code> 的集群。这种选择策略忽略了时延和可用带宽随因特网路径时间而变化，总是为特定的客户指派相同的集群；还有一种选择策略是 <code>实时测量(real-time measurement)</code>，该机制是基于集群和客户之间的时延和丢包性能执行周期性检查。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/12.png"></p>
<h3 id="应用层协议分类"><a href="#应用层协议分类" class="headerlink" title="应用层协议分类"></a>应用层协议分类</h3><ul>
<li><code>域名系统(Domain Name System, DNS)</code>：用于实现网络设备名字到 IP 地址映射的网络服务。</li>
<li><code>文件传输协议(File Transfer Protocol，FTP)</code>：用于实现交互式文件传输功能。</li>
<li><code>邮件传送协议(Simple Mail Transfer Protocol, SMTP)</code>：用于实现电子邮箱传送功能。</li>
<li><code>超文本传输协议(HyperText Transfer Protocol，HTTP)</code>：用于实现 Web 服务。</li>
<li><code>远程登录协议(Telnet)</code>：用于实现远程登录功能。</li>
</ul>
<h2 id="复习题"><a href="#复习题" class="headerlink" title="复习题"></a>复习题</h2><p>R26 2.7节中所描述的UDP服务器仅需要一个套接字, 而TCP服务器需要两个套接字. 为什么? 如果TCP服务器支持n个并行连接, 每条连接来自不同的客户主机, 那么TCP服务器需要多少个套接字.</p>
<ul>
<li>因为UDP是面向无连接的, 它的服务器只需要有一个套接字用于接收和发送, 并且可以接收来自不同地址主机的UDP包. 而TCP是面向连接的, 除了接收访问的套接字, 每和一个客户连接就要创建一个专用的套接字，称之为<strong>连接套接字</strong></li>
<li>n+1个.</li>
</ul>
<p>R27 对于2.7节所描述的运行在TCP之上的客户-服务器应用程序, 服务器程序为什么必须先于客户程序运行? 对于运行在UDP之上的客户-服务器应用程序, 客户程序为什么可以先于服务器程序运行.</p>
<ul>
<li>建立TCP连接需要经过一个3次握手的过程, 如果服务器没有启动根本无法握手, 从而无法创建连接.</li>
<li>UDP是面向无连接的, 就算服务器没有启动, 客户程序照样可以把UDP发出去, 但服务器可能就收不到了.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">计算机网络第一章总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-27 18:15:31" itemprop="dateCreated datePublished" datetime="2021-04-27T18:15:31+08:00">2021-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-21 09:27:56" itemprop="dateModified" datetime="2022-06-21T09:27:56+08:00">2022-06-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h1><p>学习博客： <a href="https://www.zhihu.com/column/p/44316491" target="_blank" rel="noopener">https://www.zhihu.com/column/p/44316491</a></p>
<p>所谓交换，就是指服务器与服务器之间的数据交换。我们介绍分组交换和电路交换</p>
<h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><p>假设A要和E打个电话，那么当A输入E的电话号码，开始拨号之后，那么服务器要做的第一件事就是根据E的电话号码找到E在哪里，由于A通往E的路径有多条，会根据某种算法找到E之后，建立一条通路，然后进行数据的传输。</p>
<p>我们假设选的路径是A—&gt;D—-&gt;E</p>
<p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E7%BB%93/1.png" style="zoom:80%;"></p>
<p>电路交换总共有3个阶段：</p>
<ol>
<li><p><strong>建立连接</strong>，就是说找到一条A通往E的路径并建立会话的过程,之后A和E在通话的过程中会始终<strong>霸占着这条路径</strong></p>
</li>
<li><p><strong>数据传输</strong>，数据沿着这条找到的路径从A直接传到E</p>
</li>
<li><p><strong>释放连接</strong>。 A和E只要有一方挂了电话，就释放连接。</p>
</li>
</ol>
<p>在这个过程中，新建连接需要花销一定的额外时间（想象你打电话的时候是不是出现<strong>正在拨号</strong>的字眼），释放连接也会花销一些额外的时间。</p>
<p><strong>那么，电话交换的过程中，数据需要分组来传送吗？</strong></p>
<p><strong>不用的</strong>，因为电路交换的过程中，A和E两个人始终霸占着一条通信电路，他们每说一句话，都会实时被对方获取，因此数据是不用分组的。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>数据不需要分组，传输速度快、高效</li>
<li>实时</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>资源利用率低</li>
<li>新建连接需要占据一定的时间，甚至比通话时间还长</li>
</ul>
<h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><p>分组的概念就是将一个数据包分成一个个更小的数据包。例如，我们把一个10Gb的数据包拆分成几个小的数据包，每个分组数据块都有文件头和数据两部分。</p>
<p>文件头一般是一些说明性数据，例如源地址和目标地址，数据类型等；数据部分就是真正要传达给对象的内容。</p>
<p>我们还是以A给E传输数据为例，这个数据包很大，假设其要分成3组更小的数据包：$p_1,p_2,p_3$  </p>
<p>这时候A给E传输数据的时候就不需要寻找一个通往E的路径了。A只要把小的数据包直接丢给附近的路由器，然后A就不管了，例如A把p1丢给了B，这个时候A就不在去管p1的，当B收到p1这个完整的小数据包之后，B再丢给E。</p>
<p>但是A不一定都会把剩下的数据包都丢给B，有可能会把其他的数据包p2丢给C,之后再把p3丢给D，然后C和D在转发丢给E。这些都是不确定的，会根据<strong>路由选择协议</strong>的选择路由器。</p>
<p><strong>路由器必须收到完整的数据包才能进行转发</strong>， 这是因为数据包中的头部包含了源地址和目标地址，必须接收到完整的数据包，路由器才能正确转发。</p>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>1、<strong>不具有实时性</strong>。因为服务器把数据包丢给路由器后就不管了，因此路由器可能会再绕几个圈子发给另外一个服务器。</p>
<p>2、<strong>存在延时</strong>。因为路由器必须收到完整的包才能继续传送这个包。在这个过程中存在<strong>传输时延</strong>。此外还存在<strong>传播时延</strong>和<strong>处理时延</strong>。</p>
<p>3、<strong>会造成通信阻塞</strong>。当路由器需要收到很多包的时候，会出现排队的状况。</p>
<p>4、<strong>存在无用的重复数据</strong>。  由于p1,p2,p3数据包都有文件头，里面都包含了A和E的一些信息，当然还有其他的信息。可以说这些文件头有很多重复的数据</p>
<p>5、<strong>会出现丢包的情况</strong>。当一个路由器收的包太多，撑满了路由器空间，就会出现丢包</p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol>
<li>相比于电路交换，更简单、更有效，实现成本更低</li>
<li>它提供了比电路交换更好的带宽共享</li>
<li>资源利用率很高。</li>
</ol>
<h3 id="应用举例："><a href="#应用举例：" class="headerlink" title="应用举例："></a>应用举例：</h3><p>假设多个用户共享一条1Mbps 链路</p>
<ul>
<li>假定每个用户活跃周期时变化的——某用户时而以100kbps很速率产生数据，时而静止不产生数据。</li>
<li>假定该用户仅有10%的时间活跃</li>
</ul>
<p>那么，对于电路交换，再所有时间内<strong>必须</strong> 为每个用户预留100kbps，因此，该电路交换电路仅能支持<strong>10个并发的用户</strong>。</p>
<p>但是，对于分组交换，如果有35个用户，根据排列组合定理，计算得到当有10个或者更少并发用户的概率为0.9996 时，到达的聚合数据速率小于等于该链路的输出速率1Mbps。</p>
<p>因此相同带宽的链路，使用分组交换可以支持更多的并发用户。</p>
<h2 id="网络的网络"><a href="#网络的网络" class="headerlink" title="网络的网络"></a>网络的网络</h2><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E7%BB%93/2.jpg" style="zoom:80%;"></p>
<p>总结一下，今天的因特网是一个<strong>网络的网络</strong>，其结构复杂，由十多个<strong>第一层ISP</strong>和<strong>数十万个较低层ISP组成</strong>。ISP覆盖的区域多种多样，有些跨越多个大洲和大洋，有些限于狭窄的地理区域。</p>
<p>较低层的ISP与较高层的ISP相连，较高层ISP<strong>彼此互联</strong>。</p>
<p>用户和内容提供商是较低层ISP的客户，较低层ISP是较高层ISP的客户。</p>
<p>近年来，主要的内容提供商也已经创建自己的网络，直接在可能的地方与较低层ISP互联。 </p>
<h1 id="分组交换网中的时延、丢包、吞吐量"><a href="#分组交换网中的时延、丢包、吞吐量" class="headerlink" title="分组交换网中的时延、丢包、吞吐量"></a>分组交换网中的时延、丢包、吞吐量</h1><h2 id="时延概述"><a href="#时延概述" class="headerlink" title="时延概述"></a>时延概述</h2><p>有很多种不同类型的时延：</p>
<ul>
<li>节点处理时延 $d_{proc}$</li>
<li>排队时延 $d_{queue}$</li>
<li>传输时延 $d_{trans}$</li>
<li>传播时延 $d_{prop}$</li>
</ul>
<p>这些时延总统累加起来是<strong>节点总时延</strong></p>
<p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E7%BB%93/3.png" style="zoom:80%;"></p>
<h3 id="处理时延"><a href="#处理时延" class="headerlink" title="处理时延"></a>处理时延</h3><p>这一部分包含了检查分组首部和决定将该分组导向何处所需要的时间。<strong>高速路由器的处理时延</strong>通常是微秒或更低的数量级。</p>
<p>上面说了是<strong>高速路由器</strong>，说明 $d_{proc}$ 只要计算有几个路由器，路由器个数 = 链路数-1</p>
<h3 id="排队时延"><a href="#排队时延" class="headerlink" title="排队时延"></a>排队时延</h3><p>在队列中，当分组在链路上等待传输时，就会出现排队时延。</p>
<ul>
<li>如果该队列是空的，并且当前没有其他分组正在传输，则该分组的排队时延为0</li>
<li>如果流量很大，并且许多其他分组也在等待传输，该排队时延会很长</li>
</ul>
<p><strong>实际的排队时延是毫秒到微秒量级</strong></p>
<h3 id="传输时延"><a href="#传输时延" class="headerlink" title="传输时延"></a>传输时延</h3><p>用L比特表示该分组的长度，用 $R bps$ 表示从路由器A到路由器B的链路<strong>传输速率</strong>。那么传输时延就是 $L/R$</p>
<p>这是将所有分组的比特推向链路所需要的时间(也可以说是发射出去)。<strong>实际的传输时延通常在毫秒到微秒量级</strong></p>
<h3 id="传播时延"><a href="#传播时延" class="headerlink" title="传播时延"></a>传播时延</h3><p>一旦一个比特被推向链路，该比特需要向路由器B传播。从该链路的起点到路由器B的传播所需要的时间就是传播时延。传播速率取决于该链路的物理媒体(光纤，铜线)等，其速率范围是$2\times 10^8 m/s \sim 3\times 10^8 m/s$ </p>
<p>传播时延的计算方法： 两台路由器之间的距离除以传播速率，$\frac{d}{s}$ </p>
<p>需要注意的是，传播时延是<strong>两台路由器之间的距离除以传播速率</strong> ，也就是说如果路上有三个路由器，实际上只走了两段路</p>
<p><strong>在广域网中，传播时延为毫秒量级</strong> </p>
<h2 id="时延和丢包"><a href="#时延和丢包" class="headerlink" title="时延和丢包"></a>时延和丢包</h2><p>我们令 $La/R$ 为流量强度，其中 $a$为分组到达的速率，L为分组的长度，R为传输速率。如果流量强度$&gt;1$, 则比特到达队列的平均速率超过从该队列出去的速率。在这种情况下，该队列趋向于无线增加，并且排队时延将趋向无穷大。</p>
<p>在现实中，一条链路前的队列只有有限的容量，尽管排队容量极大的依赖于路由器设计和成本。因为该排队容量是有限的。当到达的分组塞满整个队列的时候，路由器就会丢弃新到达的分组。这就是<strong>丢包</strong> </p>
<p><strong>分组丢失的比例随着流量强度的增加而增加</strong></p>
<h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>考虑从服务器传送一个文件到客户的吞吐量，令$R_s$表示服务器与服务器之间的链路速率；$R_c$ 表示路由器与客户之间的链路速率。那么，服务器到哭护的吞吐量是多少？显然，其吞吐量是$\min{R_c,R_s }$ ,这就是说，吞吐率是<strong>瓶颈链路</strong> 的传输速率。</p>
<p>那么拓展到服务器和客户之间有N条链路的网络，这N条链路的传输速率分别是 $R_1,R_2,\cdots,R_N$ ，我们发现从服务器到客户的文件传输吞吐量是 $\min{R_1,R_2,\cdots,R_N}$ ,这同样是<strong>瓶颈链路</strong>的传输速率。</p>
<p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E7%BB%93/5.png" style="zoom:80%;"></p>
<p>假定$R_s=2Mbps, R_c=1 Mbps, R=5Mbps$, 并且公共链路为10个下载平等划分它的传输速率。这时每个下载的瓶颈不再位于接入网中，而是位于核心中的共享链路了，该瓶颈仅能为每个下载提供 500kbps的吞吐量。因此每个下载的端到端吞吐量现在减少到500kbps.</p>
<h1 id="协议层次及其服务模型"><a href="#协议层次及其服务模型" class="headerlink" title="协议层次及其服务模型"></a>协议层次及其服务模型</h1><p>因特网的协议栈由5个层次组成：物理层、链路层、网络层、运输层和应用层。我们采用了自顶向下方法,首先处理应用层，然后向下进行处理。</p>
<p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E7%BB%93/7.png" style="zoom:80%;"></p>
<p>数据包的发送与接收如下所示</p>
<p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E7%BB%93/8.png" style="zoom:80%;"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/04/26/%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E4%B8%8E%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/26/%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E4%B8%8E%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/" class="post-title-link" itemprop="url">大数定律与中心极限定理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-26 18:10:08" itemprop="dateCreated datePublished" datetime="2021-04-26T18:10:08+08:00">2021-04-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-06-27 22:34:58" itemprop="dateModified" datetime="2021-06-27T22:34:58+08:00">2021-06-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="随机变量序列的两种收敛性"><a href="#随机变量序列的两种收敛性" class="headerlink" title="随机变量序列的两种收敛性"></a>随机变量序列的两种收敛性</h1><h2 id="依概率收敛"><a href="#依概率收敛" class="headerlink" title="依概率收敛"></a>依概率收敛</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>例子：</strong> 抛一个均匀的硬币，正面朝上和反面朝上的概率是相等的。我们把正面朝上的频率记为 $v_n=S_n/n$，其中$S_n$为正面朝上出现的次数，n为抛硬币的总次数，那么当把硬币一直抛下去，我们会发现频率序列 ${v_n}$ 会出现两个现象：</p>
<ol>
<li>频率$v_n$ 对频率p的绝对偏差$|v_n-p|$ 将随着n的增大而呈现逐渐减小的趋势，但无法说它就收敛域0</li>
<li>由于频率的随机性，绝对偏差 $|v_n-p|$ 时大时小，虽然我们无法排除大偏差发生的可能性，但随着n的不断增大，大偏差发生的可能性会越来越小。 <strong>这是一种新的极限概念</strong> </li>
</ol>
<p><img src="/2021/04/26/%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E4%B8%8E%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/1.png" style="zoom:150%;"></p>
<p>下面我们给出具体的定义：</p>
<p>设${X_n}$ 为一随机变量序列，X为一随机变量，如果对任意的 $\epsilon&gt;0$ ,有 </p>
<script type="math/tex; mode=display">
P(|X_n-X|\geq \epsilon)\rightarrow 0~~(n\rightarrow \infty)</script><p>则称${X_n}$ 依概率收敛于 $X$ ,记作  $X_p\xrightarrow{p}X$</p>
<p>依概率收敛的含义是： $X_n$ 对X 的绝对偏差不小于任意给定量的可能性将随着n的增大而越来越小。反过来说，绝对偏差$|X_n-X|$ 小于任一给定量的可能性将随着 $n$ 的增大而越来越接近与1。即上式可等价于：</p>
<script type="math/tex; mode=display">
P(|X_n-X|\leq \epsilon)\rightarrow 1 (n\rightarrow \infty)</script><p>特别的，我们要学习一种<strong>退化分布(单点分布)</strong>，这是一种最简单的离散型分布。其概率函数为：</p>
<script type="math/tex; mode=display">
p(x,y)=\begin{cases}1,  ~~x=a~\\ \\0, ~~ x\neq a \end{cases}</script><p>当$X$ 为退化分布时，即$P(X=c)=1$, 则称序列 ${X_n}$ 依概率收敛于c，即$X_n\xrightarrow{<del>~P</del>~}c$ </p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><h4 id="符合四则运算"><a href="#符合四则运算" class="headerlink" title="符合四则运算"></a>符合四则运算</h4><p>设 ${X_n},{Y_n}$ 是两个随机变量序列， $a,b$  是两个常数，如果</p>
<script type="math/tex; mode=display">
X_n\xrightarrow {~~~P~~~} a, Y_n\xrightarrow{~~~P~~~} b</script><p>则有：</p>
<script type="math/tex; mode=display">
1)~~ X_n\pm Y_n \xrightarrow{~~~P~~~} a\pm b\\
2)~~ X_n\times Y_n \xrightarrow{~~~P~~~}  a\times b\\
3)~~ X_n\div Y_n \xrightarrow{~~~P~~~} a\div b</script><p>也就是说依概率分布满足四则运算</p>
<h4 id="适用于函数"><a href="#适用于函数" class="headerlink" title="适用于函数"></a>适用于函数</h4><p>如果 $X_n\xrightarrow {~P~} X,g(x)$ 是直线上的连续函数，则： $g(X_n)\xrightarrow Pg(X)$ </p>
<p> <strong>例题：</strong></p>
<p>如果 $X_n\xrightarrow P a$, 则对任意常数c，试证： $cX_n\xrightarrow P ca$</p>
<p>我们可以令 $g(x) = cx$, 那么 $g(X_n) = cX_n\xrightarrow {~P~}g(a) = ca $ 得证。</p>
<h2 id="按分布收敛、弱收敛"><a href="#按分布收敛、弱收敛" class="headerlink" title="按分布收敛、弱收敛"></a>按分布收敛、弱收敛</h2><p>我们知道分布函数可以描述随机变量的统计规律，因此讨论一个分布函数序列${F_n(x)}$<strong>收敛到一个极限分布函数</strong>$F(x)$ 是有实际意义的。那么，如何来定义${F_n(x)}$的敛散性呢？</p>
<p>我们给出一些关于分布函数列的弱收敛定义：</p>
<p>对$F(x)$ 的<strong>任一连续点x</strong>，都有</p>
<script type="math/tex; mode=display">
\lim\limits_{n\rightarrow \infty} F_n(x)=F(x)</script><p>则称${F_n(x)}$ 弱收敛于$F(x)$, 记作：</p>
<script type="math/tex; mode=display">
F_n(x)\xrightarrow{~~~W~~~}F(x)</script><p>也称相应的随机变量序列 ${X_n}$ 按分布收敛与X，记作</p>
<script type="math/tex; mode=display">
X_n\xrightarrow{~~L~~} X</script><p>注意，这里要区分弱收敛和按分布收敛的异同，这是在两种不同场合给出的两种不同名称，其本质含义是一样的： </p>
<ul>
<li>分布函数序列${F_n(x)}$ 称为弱收敛</li>
<li>随机变量序列 ${X_n}$ 则称为按分布收敛，</li>
</ul>
<p>此外，还要注意是任一连续点，可以不包括离散点。若把离散点也囊括在内，那么这个条件就太强了，有很多反例。</p>
<h3 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h3><script type="math/tex; mode=display">
X_n\xrightarrow{~~~P~~~}X \Longrightarrow X_n\xrightarrow{~~~L~~~} X</script><p>也就是说，可以由依概率收敛推出按分部收敛。但是，这个定理的逆命题是不成立的。下面给一个反例：</p>
<h4 id="反例"><a href="#反例" class="headerlink" title="反例"></a>反例</h4><p>设随机变量X的分布列：</p>
<script type="math/tex; mode=display">
P(X=-1)=\frac{1}{2} ,P(X=1)=\frac{1}{2}</script><p>令 $X_n=-X$, 则$X_n$ 与$X$ 同分布，即$X_n$ 与 $X$，有相同的分布函数，故 $X_n\xrightarrow{<del>L</del>}X$ </p>
<p>但是对于任意的$0&lt;\epsilon&lt;2$  ，有：</p>
<script type="math/tex; mode=display">
P(|X_n-X|\geq \epsilon)=P(2|X|\geq \epsilon) =1 \nrightarrow 0</script><p> 即，一般按分部收敛与依概率收敛是不等价的</p>
<h3 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h3><p>若c为常数，则 $X_n\xrightarrow{<del>~P</del>~} c$ 的<strong>充要条件</strong>是 $X_n\xrightarrow{<del>~~L</del>~} c$</p>
<p>这个定理说明，当极限随机变量为常数(服从退化分布时)，按分布收敛与依概率收敛是等价的。</p>
<h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题:1"></a>例题:1</h4><p>设 $D(x)$ 为退化分布：</p>
<script type="math/tex; mode=display">
D(x)=\begin{cases}0, x<0 \\~\\1,x\geq 0\end{cases}</script><p>试问下列分布函数列的极限函数是否仍然为分布函数？(其中 $n=1,2\cdots$)</p>
<ol>
<li>${D(x+n)}$</li>
</ol>
<p>首先我们要求<strong>该分布函数列的极限函数</strong>F(x), 当 $n\rightarrow \infty$时候</p>
<script type="math/tex; mode=display">
D(x+n) = \begin{cases} 0, x<-\infty \\~\\ 1,x\geq -\infty \end{cases}</script><p>显然，$ D(x+n) = 0$ 是不可能出现的， 极限函数 $G(x) = 1, x\in R$ </p>
<p>这是不符合分布函数的性质：$\lim\limits_{n\rightarrow -\infty} G(x) = 0$</p>
<ol>
<li>${D(x+1/n)}$</li>
</ol>
<p>对于这个函数列，当$n\rightarrow \infty$ 时，$\frac{1}{n}\rightarrow 0$</p>
<script type="math/tex; mode=display">
D(x+n) = \begin{cases} 0, x<-\frac{1}{n} \\~\\ 1,x\geq -\frac{1}{n} \end{cases}</script><p>那么，其极限函数为</p>
<script type="math/tex; mode=display">
G(x) = \begin{cases} 0,x< 0 \\~\\1,x\geq0 \end{cases}</script><p>这符合极限函数的右连续性</p>
<ol>
<li>${D(x-1/n)}$</li>
</ol>
<p>这个函数列可写为：</p>
<script type="math/tex; mode=display">
D(x+n) = \begin{cases} 0, x< \frac{1}{n} \\~\\ 1,x\geq \frac{1}{n}    \end{cases}</script><p>那么，当 $n\rightarrow \infty$ 时，其极限函数可写为：</p>
<script type="math/tex; mode=display">
G(x) = \begin{cases} 0, x\leq 0 \\~\\ 1,x > 0 \end{cases}</script><p>这时候，极限函数<strong>不满足分布函数的右连续性</strong>，所以这不是一个分布函数。</p>
<h4 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h4><p>如果$X_n\xrightarrow L X$,且数列 $a_n\rightarrow a,b_n\rightarrow b$, 试证： $a_nX_n+b_n\xrightarrow L aX+b$ </p>
<h2 id="以概率1收敛"><a href="#以概率1收敛" class="headerlink" title="以概率1收敛"></a>以概率1收敛</h2><p>依概率1收敛亦称<strong>几乎必然收敛、几乎处处收敛、几乎肯定收敛</strong>，是随机变量列的一种<strong>较强的收敛性</strong>。若随机变量列以概率1收敛，则它必然依概率收敛，反之则未必。</p>
<h1 id="大数定律"><a href="#大数定律" class="headerlink" title="大数定律"></a>大数定律</h1><h2 id="大数定律一般形式"><a href="#大数定律一般形式" class="headerlink" title="大数定律一般形式"></a>大数定律一般形式</h2><p>设有一随机变量序列${X_n}$，加入它具有下列这个式子的性质，则称该随机变量序列${X_n}$ 服从大数定律：</p>
<p>对于任意的 $\epsilon &gt;0$, 有</p>
<script type="math/tex; mode=display">
\lim\limits_{n\rightarrow \infty} P(|\frac{1}{n}\sum_{i=1}^n X_i-\frac{1}{n}\sum_{i=1}^n E(X_i)|<\epsilon)=1</script><h2 id="常用的大数定律"><a href="#常用的大数定律" class="headerlink" title="常用的大数定律"></a>常用的大数定律</h2><p>现在已经知道了大数定律的一般形式，其实，常用的大数定律就是在不同条件下的一般情况的变形。</p>
<h3 id="伯努利大数定律"><a href="#伯努利大数定律" class="headerlink" title="伯努利大数定律"></a>伯努利大数定律</h3><p>设$S_n$ 为 n重伯努利试验中事件A出现的次数，称 $\frac{S_n}{n}$ 为事件A出现的频率。</p>
<p>那么如果记一次实验中A发生的概率为p，则$S_n$ 服从二项分布$b(n,p)$, 因此频率 $\frac{S_n}{n}$ 的数学期望与方差分别为：</p>
<script type="math/tex; mode=display">
E(\frac{S_n}{n}) = p, Var(\frac{S_n}{n})=\frac{p(1-p)}{n}</script><p>下面，给出伯努利大数定律的定义：</p>
<script type="math/tex; mode=display">
\lim\limits_{n\rightarrow\infty} P(|\frac{S_n}{n}-p|<\epsilon) = 1</script><p><strong>证明</strong>：我们可以用切比雪夫不等式$P(|X-E(X)|\geq \epsilon)\leq \frac{Var(X)}{\epsilon^2}$ 得：</p>
<script type="math/tex; mode=display">
1\geq P(|\frac{S_n}{n}-p|<\epsilon)\geq 1-\frac{Var(\frac{S_n}{n})}{\epsilon^2} =1-\frac{p(1-p)}{n\epsilon^2}</script><p>当$n\rightarrow \infty$ 时，上式右端趋于1，因此：</p>
<script type="math/tex; mode=display">
\lim\limits_{n\rightarrow \infty} P(|\frac{S_n}{n}-p|<\epsilon)=1</script><p>伯努利大数定律说明：随着 n 的增大，事件 A 发生的频率$\frac{S_n}{n}$ 与其概率p 的偏差 $|\frac{S_n}n -p|$ 大于与现给定的精度$\epsilon$ 的可能性愈来愈小。这就是<strong>频率稳定与概率的意义</strong></p>
<h3 id="切比雪夫大数定律"><a href="#切比雪夫大数定律" class="headerlink" title="切比雪夫大数定律"></a>切比雪夫大数定律</h3><p>切比雪夫大数定律也可以由切比雪夫不等式证明。</p>
<p>定义：</p>
<p>设${X_n}$为一列<strong>两两不相关</strong>的随机变量序列，若每个$X_i$ 的方差存在，且有共同的上界，即 $Var(X_i)\leq c,i=1,2\cdots,$ 则 ${X_n}$服从大数定律，即对任意的 $\epsilon &gt;0$,  满足：</p>
<script type="math/tex; mode=display">
\lim\limits_{n\rightarrow \infty} P(|\frac{1}{n}\sum_{i=1}^n X_i-\frac{1}{n}\sum_{i=1}^n E(X_i)|<\epsilon)=1</script><p>注意，切比雪夫大数定律只要求 ${X_n}$ 互不相关，<strong>并不要求他们是同分布的</strong>，因此，我们很容易推出：如果${X_n}$ 是独立同分布的随机变量数列，且方差有限，那么${X_n }$必定服从大数定律</p>
<p><strong>伯努利大数定律只是切比雪夫大数定律的特例</strong></p>
<h4 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h4><p>设 ${X_n}$ 是独立同分布的随机变量序列，$E(X_n^4)&lt;\infty$. 若令 $E(X_n)=\mu,Var(X_n)=\sigma^2$, 考察</p>
<script type="math/tex; mode=display">
Y_n = (X_n-\mu)^2,~~ n=1,2\cdots</script><p>证明随机变量序列 ${Y_n}$ 服从大数定律，即对任意的 $\epsilon &gt; 0$, 有：</p>
<script type="math/tex; mode=display">
\lim\limits_{n\rightarrow \infty} P(|\frac{1}{n}\sum_{i=1}^{n}(X_i-\mu)^2-\sigma^2|\geq \epsilon) = 0</script><p>解答思路：</p>
<p>首先，要满足大数定律，必须要让$Y_n$是独立同分布的(显然)，且<strong>方差有限(需证)</strong></p>
<p>其次，要满足上式，第一部分 $\frac{1}{n}\sum<em>{i=1}^n Y_i$ 是不用计算的，带入$Y_n$即可；第二部分$\frac{1}{n}\sum</em>{i=1}^n E(Y_i)$ 是需要计算的部分。</p>
<p>根据上面这个思路，我们先证明方差是有限的：</p>
<script type="math/tex; mode=display">
Var(Y_n) = Var(X_n-\mu)^2 =E[(X_n-\mu)^4]-E^2[(X_n-\mu)^2]\\
=E[(X_n-\mu)^4]-E^2(X-E(X))^2</script><p>已知 $E(X-E(X))^2=Var(X)$ 上式可化简为：</p>
<script type="math/tex; mode=display">
E[(X_n-\mu)^4] - Var^2(X) = E[(X_n-\mu)^4] - \sigma^4</script><p>因为 $E(X_n^4)$ 存在，故 $E(X_n^3),E(X_n^2),E[(X-\mu)^4]$ 也存在，因此$Y_n$的方差是存在的。</p>
<p>然后我们化简 $\frac{1}{n}\sum_{i=1}^nE(Y_i)$，</p>
<script type="math/tex; mode=display">
 E(Y_i)=E(X_i-\mu)^2 = E(X_i-E(X))^2 = Var(X_i)=\sigma^2</script><p>因此 </p>
<script type="math/tex; mode=display">
\frac{1}{n}\sum_{i=1}^n E(Y_i) = \frac{1}{n}\cdot n \sigma^2 = \sigma^2</script><p>得证。</p>
<h3 id="马尔科夫大数定律"><a href="#马尔科夫大数定律" class="headerlink" title="马尔科夫大数定律"></a>马尔科夫大数定律</h3><p>注意到以上大数定律的证明中，只要有</p>
<script type="math/tex; mode=display">
\frac{1}{n^2} Var(\sum_{i=1}^n X_i)\rightarrow 0</script><p>则大数定律就能成立，这个条件就被称为<strong>马尔科夫条件</strong></p>
<p>现在给出马尔科夫大数定律的定义：</p>
<p>对随机变量序列${X_n}$ ，若上面的<strong>马尔科夫条件</strong>成立，则${X_n}$服从大数定律</p>
<p><strong>马尔科夫大数定律的重要性在于</strong>：对${X_n} $ 已经没有<strong>任何</strong> <strong>同分布、独立性、不相关</strong> 的假定，切比雪夫大数定律显然可以由马尔科夫大数定律推出。</p>
<h4 id="例题：-1"><a href="#例题：-1" class="headerlink" title="例题："></a>例题：</h4><p>设 ${X<em>n}$ 为一<strong>同分布、方差存在</strong> 的随机变量序列，且$X_n$ 仅与相邻的 $X</em>{n-1}$ 和 $X_{n+1}$ 相关，而与其他的 $X_i$ 不相关。试问该随机变量序列 ${X_n}$ 是否服从大数定律？</p>
<p>要看是否服从，可以看其是否满足马尔科夫条件：</p>
<script type="math/tex; mode=display">
\frac{1}{n^2} Var(\sum_{i=1}^n X_i) =\frac{1}{n^2} [\sum_{i=1}^n Var(X_i)+2\sum_{i=1}^{n-1}Cov(X_i,X_{i-1})]</script><p>记 $Var(X_n)=\sigma^2$,则 $|Cov(X_i,X_j)|\leq \sigma^2$ 于是有：</p>
<script type="math/tex; mode=display">
\frac{1}{n^2}Var(\sum_{i=1}^n X_i)\leq \frac{1}{n^2} [n\sigma^2+2(n-1)\sigma^2]\rightarrow 0(n\rightarrow \infty)</script><p>也就是满足马尔科夫条件，则${X_n}$服从大数定律</p>
<h3 id="辛钦大数定律"><a href="#辛钦大数定律" class="headerlink" title="辛钦大数定律"></a>辛钦大数定律</h3><p>以上三个大数定律都假设随机变量序列 ${X_n}$ 的方差存在，以下的辛钦大数定律去掉了这一假设，仅设每个$X_i$ 的数学期望存在(因为数学期望存在并不能够推断数学方差存在)。但与此同时，要求${X_n}$为<strong>独立同分布的</strong>随机变量序列。因此，伯努利大数定律除了是切比雪夫不等式得特例外，也是辛钦大数定律的特例。</p>
<p>定义： 设${X_n}$ 为一<strong>独立同分布的</strong>随机变量序列，若$X_i$ 的数学期望存在，则 ${X_n}$ 符合大数定律，即对任意的$\epsilon &gt; 0$ ，</p>
<script type="math/tex; mode=display">
\lim\limits_{n\rightarrow \infty} P(|\frac{1}{n}\sum_{i=1}^n X_i-\frac{1}{n}\sum_{i=1}^n E(X_i)|<\epsilon)=1</script><p>成立。</p>
<p>所以说，像柯西分布这样的是不能用辛钦大数定律来</p>
<p>辛钦大数定律提供了求随机变量数学期望$E(X)$ 的近似值的方法： 设想对随机变量X独立重复地观察n次，第k次的观察值为$X<em>k$ , 则 $X_1,X_2,X_3\cdots,X_n$ 应该是相互独立的，且它们的分布应该与 X 的分布相同。所以，在$E(X)$ 存在的条件下，按照辛钦大数定律，当n足够大的时候，可以把平均观察值：$\frac{1}{n}\sum</em>{i=1}^n X_i$ 作为$E(X)$的近似值。这种做法的一个有点事我们可以不用去了解X的分布是什么。</p>
<p>此外，我们还要记住，如果${X<em>n}$为一独立同分布的随机变量序列，且 $E(|X_i|^k)$ 存在，其中k为正整数，则 ${X_n^k}$ 服从大数定律。也就是说我们可以用 $\frac{1}{n} \sum</em>{i=1}^n X_i^k$ 作为 $E(X_i^k)$ 的近似值。</p>
<h4 id="利用蒙特卡洛方法计算定积分"><a href="#利用蒙特卡洛方法计算定积分" class="headerlink" title="利用蒙特卡洛方法计算定积分"></a>利用蒙特卡洛方法计算定积分</h4><p>计算定积分： </p>
<script type="math/tex; mode=display">
J  = \int_0^1 f(x)dx</script><p>设随机变量X服从$(0,1)$上的均匀分布，则 $Y=f(x)$ 的数学期望是：</p>
<script type="math/tex; mode=display">
E(f(X))= \int_0^1 f(x) dx = J</script><p>所以估计J的值，就是估计$f(X)$ 数学期望的值。 由辛钦大数定律，可以用 $f(X)$的观察值的平均去估计$f(X)$的数学期望的值。</p>
<ol>
<li><p>先用计算机产生n个$(0,1)$上的均匀分布的随机数$x_i,i=1,2\cdots,n$ </p>
</li>
<li><p>然后对每个$x_i$计算$f(x_i)$</p>
</li>
<li><p>最后得J的估计值为：</p>
<script type="math/tex; mode=display">
J\approx\frac{1}{n} \sum_{i=1}^n f(x_i)</script></li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>常见的大数定律</th>
<th>需满足的条件</th>
</tr>
</thead>
<tbody>
<tr>
<td>伯努利大数定律</td>
<td>$Sn$ 服从二项分布，单个样本服从独立同分布的二点分布</td>
</tr>
<tr>
<td>切比雪夫大数定律</td>
<td>${X_n}$ 互不相关(并不是互相独立)，且有共同的方差上界</td>
</tr>
<tr>
<td>马尔科夫大数定律</td>
<td>没其他的要求，只要$\frac{1}{n^2} Var(\sum_{i=1}^n X_i)\rightarrow 0$</td>
</tr>
<tr>
<td>辛钦大数定律</td>
<td>设${X_n}$ <strong>独立同分布的</strong>，且 $X_i$ 的数学期望存在</td>
</tr>
</tbody>
</table>
</div>
<p>一般来说，都是利用马尔科夫大数定律来证明独立随机变量序列符合大数定律的</p>
<h4 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h4><ul>
<li>设 ${X_k}$ 为独立随机变量序列，且：$P(X_k = \pm \sqrt{\ln k})=\frac{1}{2}, k=1,2\cdots$   服从大数定律</li>
</ul>
<p><strong>首先: 判断使用哪种大数定律来解</strong>， 显然这不是二项分布，$X_n$ 也不是同分布的，所以我们可以利用<strong>马尔科夫大数定律或者切比雪夫大数定律</strong>来求解</p>
<p><strong>第二步：列出期望和方差</strong>: 在这题中，显然$E(X_k) = 0$, $Var(X_k) =2<em> \frac 12 </em>(\sqrt {\ln k}-0)^2 =\ln k$ （这里可以判断出来，${X_n}$ 不满足有共同的方差上界，因此不能使用切比雪夫大数定律，只能使用马尔科夫大数定律）</p>
<p><strong>第三步：判断是否满足马尔科夫条件</strong> ：由${X<em>n}$  独立可知， $Var(\sum</em>{i=1}^n X<em>i)= \sum</em>{i=1}^n Var(X_i) \leq n\ln n$ , 因此：</p>
<script type="math/tex; mode=display">
\frac{1}{n^2} Var(\sum_{i=1}^nX_i)\leq \frac{n\ln n}{n^2} \\~\\
n\rightarrow \infty ， \frac{\ln n}n\rightarrow 0</script><p>符合，所以符合大数定律</p>
<h4 id="例题2-1"><a href="#例题2-1" class="headerlink" title="例题2"></a>例题2</h4><ul>
<li><p>在伯努利试验中，事件A出现的概率为p，令</p>
<ul>
<li><script type="math/tex; mode=display">
X_n =\begin{cases}1, 若在第n次及第n+1次试验中A都出现\\ 0, 其他 \end{cases}</script></li>
<li><p>证明${X_n}$符合大数定律</p>
</li>
</ul>
</li>
</ul>
<p><strong>第一步：首先判断使用那种大数定律</strong>，显然 $X<em>n$ 不属于两点分布，不独立也不同分布($X_n$和$X</em>{n+1}$相关)。所以只能选择<strong>马尔科夫大数定律</strong></p>
<p><strong>第二步：求E(x) 和Var(x)</strong> : 可以列出</p>
<script type="math/tex; mode=display">
\begin{array}{c|cc}
X_n&1&0\\
\hline
P&p^2&{1-p^2}
\end{array}</script><p>因此$E(X_n)= p^2,Var(X_n)=p^2(1-p^2)$ </p>
<p><strong>第三步：判断是否满足马尔科夫大数定律 </strong></p>
<p>这里很重要的一点是，${X_n}$ 并不是互相独立的，因此我们在计算的时候需要加上协方差。</p>
<script type="math/tex; mode=display">
\frac1{n^2}Var(\sum_{i=1}^n X_n) = \frac{1}{n^2}[\sum_{i=1}^n Var(X_i)+2\sum_{i=1}^{n-1} Cov(X_i,X_i+1)]\\~\\</script><p>由协方差矩阵是一个非负定矩阵可得：</p>
<script type="math/tex; mode=display">
\begin{vmatrix}  cov(x_1,x_1) & cov(x_1,x_2) \\cov(x_2,x_1) &cov(x_2,x_2)   \end{vmatrix} \geq 0</script><p>这里不可能等于0，因此 </p>
<script type="math/tex; mode=display">
2\sum_{i=1}^{n-1} Cov(X_i,X_i+1)\leq 2\sqrt{Var(X_1)}\sqrt{Var(X_2)}\\~\\
\frac1{n^2}Var(\sum_{i=1}^n X_n) \leq \frac{1}{n^2}(np^2(1-p^2)+2(n-1)p^2(1-p^2))\rightarrow0</script><p>得证</p>
<h4 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h4><ul>
<li><p>设${X_n}$为独立同分布的随机变量序列，其共同分布：</p>
<ul>
<li><script type="math/tex; mode=display">
P(X_n = \frac{2^k}{k^2}) = \frac{1}{2^k}</script></li>
<li><p>试问其是否满足大数定律？</p>
</li>
</ul>
</li>
</ul>
<p><strong>第一步：判断使用哪种大数定律</strong></p>
<p>首先排除伯努利大数定律，又因为是独立同分布的，因此选择的范围很广，只要证明其期望存在就能利用辛钦大数定律证明其符合大数定律了。</p>
<p><strong>第二步: 计算期望</strong></p>
<script type="math/tex; mode=display">
E(X) = \sum_{i=1}^n(\frac{2^k}{k^2}\cdot\frac 1{2^k})=\sum_{i=1}^n \frac{1}{k^2}</script><p>根据数列的极限可以求出 $\sum_{i=1}^n\frac{1}{k^2}&lt;2$  显然是有限的，因此根据辛钦大数定律知${X_n}$ 服从大数定律。</p>
<h4 id="例题4"><a href="#例题4" class="headerlink" title="例题4"></a>例题4</h4><ul>
<li>设 ${X<em>n}$ 为独立同分布的随机变量序列，方差存在。又设 $\sum</em>{i=1}^n a<em>n$ 为绝对收敛级数。 令 $Y_n = \sum</em>{i=1}^n X_i$ 证明：${a_nY_n}$ 符合大数定律。</li>
</ul>
<p><strong>第一步：判断使用哪种大数定律</strong></p>
<p>首先排除伯努利分布定律，其次 ${a_nY_n}$ 的期望和方差都比较难判断，所以我们需要一些技巧。</p>
<p>不妨设 $E(X<em>n) = 0$, 则$Var(X_n) =E(X_n^2) = \sigma^2$ . 又因为 $\sum</em>{i=1}^na_n$ 收敛于常数，可以记为c。</p>
<p>可以尝试一下用<strong>马尔科夫大数定律</strong>来求解</p>
<p><strong>第二步：</strong></p>
<script type="math/tex; mode=display">
\sum_{i=1}^na_iY_i = \sum_{i=1}^na_i(\sum_{j=1}^i X_j) = \sum_{j=1}^nX_j(\sum_{i=j}^na_i)\\</script><p>现在，我们就可以将化简后的式子带入马尔科夫条件：</p>
<script type="math/tex; mode=display">
\frac{1}{n^2}Var(\sum_{i=1}^n a_iY_i )= \frac{1}{n^2} Var(\sum_{j=1}^n X_j\sum_{i=j}^na_j) =\frac{1}{n^2}(E(\sum_{j=1}^nX_j\sum_{i=j}^na_j)^2-0)\\~\\
=\frac{\sigma^2}{n^2}{\sum_{j=1}^n}(\sum_{i=j}^n a_i)^2 \leq \frac{c^2\sigma^2}{n} \rightarrow 0</script><p>也就是说，形如${a<em>nY_n}$，$Y_n = \sum</em>{i=1}^n$的随机变量序列我们可以将其化简为：</p>
<script type="math/tex; mode=display">
=\frac{\sigma^2}n{\sum_{i=1}^n}(\sum_{i=j}^n a_i)^2</script><p>的形式，然后，对 $a_i$ 进行放缩即可。</p>
<h4 id="例题5"><a href="#例题5" class="headerlink" title="例题5"></a>例题5</h4><p>例题5和例题4 差不多，设${X<em>n}$ 为独立同分布的随机变量序列，方差存在，令 $Y_n = \sum</em>{i=1}^n X_i$ 又设${a_n}$ 为一列常数，为一列常数，如果存在常数 $c&gt;0$ , 使得对n 有 $|na_n|\leq c$ 证明 ${a_nY_n}$ 服从大数定律。</p>
<p>同样，我们先设 $E(X_n)=0$ ，则 $Var(X_n)=E(X_n^2) = \sigma^2$对任意的$n\geq k$</p>
<script type="math/tex; mode=display">
\sum_{i=k}^n |a_i| \leq \frac{c}{n}(n-k+1)\\</script><p>因而：</p>
<script type="math/tex; mode=display">
\sum_{k=1}^n (\sum_{i=k}^n|a_i|)^2\leq \frac{c^2}{n^2}\sum_{k=1}^n(n-k+1)^2\\
=\frac{c^2}{n^2}\frac{n(n+1)(n+2)}{6}</script><p>仿照例题4，我们可以证明：</p>
<script type="math/tex; mode=display">
\frac{1}{n^2}Var(\sum_{i=1}^n a_iY_i )= \frac{1}{n^2} Var(\sum_{j=1}^n X_j\sum_{i=j}^na_j) =\frac{1}{n^2}(E\sum_{j=1}^nX_j\sum_{i=j}^na_j)^2\\~\\
=\frac{\sigma^2}{n^2}\sum_{j=1}^n\sum_{i=j}^n a_j^2\\~\\
\leq\frac{\sigma^2}{n^2} \frac{c^2}{n^2}\frac{n(n+1)(n+2)}{6}\rightarrow 0 (n\rightarrow \infty)</script><h1 id="中心极限定理"><a href="#中心极限定理" class="headerlink" title="中心极限定理"></a>中心极限定理</h1><h2 id="独立随机变量和"><a href="#独立随机变量和" class="headerlink" title="独立随机变量和"></a>独立随机变量和</h2><p>上一个part我们学的是大数定律，讨论的是在什么条件下，随机变量序列的算数平均依概率收敛到其均值的算数平均。 </p>
<p>现在，我们来讨论在<strong>什么条件</strong>下，独立的随机变量和</p>
<script type="math/tex; mode=display">
Y_n = \sum_{i=1}^n X_i</script><p>的分布函数会收敛于<strong>正态分布</strong></p>
<p>研究这个问题是很有用的，一个很大的应用场景就是误差。比如说</p>
<ul>
<li>机床方面，有机床振动与转速的影响</li>
<li>环境方面，有车间的温度，湿度、照明、工作电压的影响</li>
</ul>
<p>可以把这些误差的和记为$Y_n$ ,那么 $Y_n$是随机变量，可以将 $Y_n$看做是很多微小的随机波动之和：</p>
<script type="math/tex; mode=display">
Y_n = X_1+X_2+\cdots+X_n</script><p>当 $n\rightarrow \infty$ 时，$Y_n$的分布是什么？</p>
<p>通过卷积可以看到，当n越来越大时，其分布就越来越像一个正态分布。</p>
<p><img src="/2021/04/26/%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E4%B8%8E%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/1.jpg" style="zoom:150%;"></p>
<p>为了寻求 $Y_n$ 的极限分布有意义，有必要先研究一下问题的提法。上图可以看出：当 n 增大时，$p_n(y)$ 的中心右移，且$p_n(y)$的方差增大。这意味着，当 $n\rightarrow \infty$ 时，$Y_n$的分布中心也会趋向于 $\infty$,方差趋向 $\infty$。 说明分布是很不稳定的。</p>
<p>在中心极限定理的研究中，会对 $Y_n$ 进行标准化</p>
<script type="math/tex; mode=display">
Y_n^* = \frac{Y_n-E(Y_n)}{\sqrt{Var(Y_n)}}</script><p>由于 $E(Y_n^<em>),Var(Y_n^</em>)=1$，这就有可能看出 $Y_n^*$的极限分布是否为标准正态分布 $N(0,1)$</p>
<p><strong>中心极限定理就是研究随机变量和的极限分布在什么条件下为正态分布的问题</strong> </p>
<h2 id="独立同分布下中心极限定理"><a href="#独立同分布下中心极限定理" class="headerlink" title="独立同分布下中心极限定理"></a>独立同分布下中心极限定理</h2><h3 id="林德伯格-莱维中心极限定理"><a href="#林德伯格-莱维中心极限定理" class="headerlink" title="林德伯格-莱维中心极限定理"></a>林德伯格-莱维中心极限定理</h3><p>刚才我们给出了 $Y_n^*$ 的定义。那么当${X_n}$ 满足独立同分布的随机变量序列，且$E(X_i)=\mu,Var(X_i)=\sigma^2$ 都存在时，则对任意实数 y,</p>
<p>记</p>
<script type="math/tex; mode=display">
Y_n^* = \frac{X_1+X_2+\cdots+X_n-n\mu}{\sigma\sqrt n}</script><p>有</p>
<script type="math/tex; mode=display">
\lim\limits_{n\rightarrow \infty}P(Y_n^*\leq y) = \Phi(y) = \frac{1}{\sqrt {2\pi}} \int_{-\infty}^y e^{-\frac{t^2}{2}}dt</script><p>也就是说，当n充分大，就可以<strong>用正态分布去逼近随机变量和的分布</strong>。 </p>
<h2 id="二项分布的正态近似"><a href="#二项分布的正态近似" class="headerlink" title="二项分布的正态近似"></a>二项分布的正态近似</h2><h3 id="棣莫弗-拉布拉斯中心极限定理"><a href="#棣莫弗-拉布拉斯中心极限定理" class="headerlink" title="棣莫弗-拉布拉斯中心极限定理"></a>棣莫弗-拉布拉斯中心极限定理</h3><p>设 n 重伯努利试验中，事件A在每次试验中出现的概率为 p, 记$S_n$为n次试验中时间A出现的次数。</p>
<p>这时候， $Y_n^* = \frac{S_n - np}{\sqrt {npq}}$ </p>
<p>则对任意实数y ，有：</p>
<script type="math/tex; mode=display">
\lim\limits_{n\rightarrow \infty}P(Y_n^*\leq y) = \Phi(y) = \frac{1}{\sqrt {2\pi}} \int_{-\infty}^y e^{-\frac{t^2}{2}}dt</script><p>注： 因为二项分布是离散分布，而正态分布是连续分布，所以用正态分布作为二项分布的近似计算中，做些修正可以体高精度： 若 $k_1&lt;k_2$ 均为整数，一般先作如下修正后再用近似：</p>
<script type="math/tex; mode=display">
P(k_1\leq S_n\leq k_2) = P(k_1-0.5< S_n<k_2+0.5)</script><h4 id="例题：-2"><a href="#例题：-2" class="headerlink" title="例题："></a>例题：</h4><p>比如： $S_n\sim b(25,0.4),P(5\leq S_n\leq 15)$  的值。使用修正的正态近似之后：($E(X) = np =10,Var(X) = np(1-p) = 6$)</p>
<script type="math/tex; mode=display">
P(5\leq S_n\leq 15) = P(5-0.5<S_n<15+0.5)\\
\approx \Phi(\frac{15+0.5-10}{\sqrt 6})-\Phi(\frac{5-0.5-10}{\sqrt 6})\\
=2\Phi(2.245)-1</script><p>此外，开可以用修正的正态近似来计算 $P(S_n=k)$ </p>
<script type="math/tex; mode=display">
P(S_n=k) =P(k-0.5<S_n<k+0.5) =P(\frac{k-0.5-np}{\sqrt{npq}}<\frac{S_n-np}{\sqrt{npq}}<\frac{k+0.5-np}{\sqrt{npq}})\\</script><div class="table-container">
<table>
<thead>
<tr>
<th>中心极限定理种类</th>
<th>需要满足的条件</th>
</tr>
</thead>
<tbody>
<tr>
<td>林德伯格-莱维中心极限定理</td>
<td>$  {X_n}$独立同分布且期望方差均存在</td>
</tr>
<tr>
<td>棣莫弗-拉布拉斯中心极限定理</td>
<td>n重伯努利试验，事件A在每次试验中出现的概率为 p, 记$S_n$为n次试验中时间A出现的次数。 $Y_n^* = \frac{S_n - np}{\sqrt {npq}}$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="重要应用"><a href="#重要应用" class="headerlink" title="重要应用"></a>重要应用</h3><p>在中心极限定理的应用中，若记 $\beta =\Phi(y)$  ，则由这个中心极限定理给出的近似式：$P(Y_n^*\leq y)\approx \Phi(y) = \beta$ </p>
<p>可以用来解决三类计算问题：</p>
<h4 id="1-已知-n-beta-求-y"><a href="#1-已知-n-beta-求-y" class="headerlink" title="1. 已知$n,\beta$  求 $y$"></a>1. 已知$n,\beta$  求 $y$</h4><p>有一家珍珠奶茶店，只有两种产品，珍珠奶茶和纯奶茶。每杯珍珠奶茶里需要放<strong>5克珍珠</strong>。<strong>一天接单100笔</strong>，顾客以$\frac{1}{2}$的概率点珍珠奶茶。且假定顾客点单独立。有$95\%$ 的可能性不拒单。 问：要准备多少克珍珠？</p>
<p>解：我们设第i个顾客点珍珠奶茶记为 $X_i\sim b(1,p),p = 0.5$, </p>
<p>首先我们把已知量带入公式： 设买珍珠奶茶的顾客记为1，否则记为0，因为每一杯珍珠奶茶要放5g珍珠，因此要乘以5</p>
<script type="math/tex; mode=display">
P(5\sum_{i=1}^{100} X_i \leq x) \geq 95\%</script><p> 把 5 除到右边，留下 $\sum_{i=1}^{100}X_i\sim b(100,0.5)$ , 则 $E(\sum X) = np = 50,Var(\sum X) = 25$ 将 $X_i$  化成$X_i^*$ 用标准正态分布来计算。 </p>
<script type="math/tex; mode=display">
P(\frac{\sum X_i - E(\sum X_i)}{\sqrt{Var(\sum X_i)}}\leq \frac{\frac{x}{5}-E(\sum X_i)}{\sqrt{Var(\sum X_i)}})\geq 95\%\\</script><p>现在，已经可以用$P(Y_n^*\leq y)\approx \Phi(y) = \beta$  来计算了</p>
<script type="math/tex; mode=display">
\Phi(\frac{\frac{x}{5}-50}{25})\geq 0.95\\</script><p>解得，$x=288$ ，约等于290g 的珍珠，那么一共可以做58杯奶茶。</p>
<p><strong>注：在这里，没有使用修正，但在其他题目中一定要修正，是y修正！</strong></p>
<h4 id="2-已知-n-y-求-beta"><a href="#2-已知-n-y-求-beta" class="headerlink" title="2. 已知$n,y$  求 $\beta$"></a>2. 已知$n,y$  求 $\beta$</h4><p>还是一样的奶茶店， 现在变成顾客以0.6 的概率点珍珠奶茶，且假定顾客点单独立，那么问58杯珍珠奶茶能让店主不拒单的概率是多少？</p>
<p>首先我们要把已知量带入到公式中去：</p>
<script type="math/tex; mode=display">
P(Y_i^*\leq \frac{58-E(\sum X_i)}{\sqrt{Var(\sum X_i)}})\approx \beta</script><p>因为现在 $E(\sum X_i) = np = 60,Var(\sum X_i)=np(1-p) = 24$ ,带入得到：</p>
<script type="math/tex; mode=display">
\approx \Phi(\frac{58+\frac{1}{2}-60}{\sqrt{24}}) =0.379</script><p>我们看到，只要概率从0.5提升到0.6, 58杯奶茶的不拒单的概率从95% 降到了38%</p>
<h4 id="3-已知-y-beta-求-n"><a href="#3-已知-y-beta-求-n" class="headerlink" title="3. 已知$y,\beta$  求 $n$"></a>3. 已知$y,\beta$  求 $n$</h4><p>还是一样的奶茶店，顾客点珍珠奶茶的概率为p，通过历史流水数据估算的值为$\hat p$,   现在要保证有$95\%$ 的把握使得估算值 $\hat p$ 与真实值p之间的差异不大于$1\%$ ,问至少要有多少流水数据？</p>
<p>这就是 已知$y,\beta$  求样本数量$n$。我们令 </p>
<script type="math/tex; mode=display">
X_i = \begin{cases} 1, 第i个顾客点了珍珠奶茶 \\~\\ 0,其他 \end{cases}</script><p>那么，我们可以列出公式：</p>
<script type="math/tex; mode=display">
P(|\hat p -p|\leq 1\%)\geq 95\%\\
~\\
P(|\frac{\sum_{i=1}^n X_i}{n}-p|\leq 0.01)\geq 95\%\\
~\\</script><p>通过标准化，可以得到：</p>
<script type="math/tex; mode=display">
P(|\frac{\sum X_i - E(\sum X_i)}{\sqrt{Var(\sum X_i)}}|\leq \frac{0.01n}{\sqrt{Var(\sum X_i)}})\\
~\\
2\Phi(\frac{0.01 n}{\sqrt{np(1-p)}})-1\geq 0.95\\
n = (\frac{1.96}{0.01})^2 p(1-p)</script><p>我们看到，这个式子是有上限的，也就是当p=0.5 时，n最大约为9604</p>
<h2 id="独立不同分布下的中心极限定理"><a href="#独立不同分布下的中心极限定理" class="headerlink" title="独立不同分布下的中心极限定理"></a>独立不同分布下的中心极限定理</h2><h3 id="林德伯格中心极限定理"><a href="#林德伯格中心极限定理" class="headerlink" title="林德伯格中心极限定理"></a>林德伯格中心极限定理</h3><h3 id="李雅普诺夫中心极限定理"><a href="#李雅普诺夫中心极限定理" class="headerlink" title="李雅普诺夫中心极限定理"></a>李雅普诺夫中心极限定理</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/04/23/UDPping%E7%A8%8B%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/23/UDPping%E7%A8%8B%E5%BA%8F/" class="post-title-link" itemprop="url">UDPping程序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-23 14:13:43" itemprop="dateCreated datePublished" datetime="2021-04-23T14:13:43+08:00">2021-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-25 04:30:10" itemprop="dateModified" datetime="2022-08-25T04:30:10+08:00">2022-08-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UDPping程序"><a href="#UDPping程序" class="headerlink" title="UDPping程序"></a>UDPping程序</h1><h2 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h2><p>在这个编程作业中，你将用 <strong>Java</strong> 编写一个客户ping程序。该客户将<strong>发送一个简单的ping报文</strong>，接收一个从服务器返回的对应pong报文，并确定从该客户发送ping报文到接收到pong报文为止的<strong>时延</strong>。 该时延称为<strong>往返时延（RTT）</strong>。由该客户和服务器提供的功能类似于在现代操作系统中可用的标准ping程序。然而，标准的ping使用互联网控制报文协议（ICMP）（我们将在第5章中学习ICMP）. 此时我们将创建一个非标准（但简单）的<strong>基于UDP的ping程序</strong>。</p>
<p>你的ping程序经UDP向目标服务器发送<strong>10个</strong>ping报文。对于每个报文，当对应的pong报文返回时，你的客户要确定和打印RTT。因为UDP是一个不可靠的协议，由客户发送的分组可能会丢失。为此，客户<strong>不能无限期</strong>地等待对ping报文的回答。客户等待服务器回答的时间<strong>至多为1秒</strong>；如果没有收到回答，客户假定该分组丢失并相应地打印一条报文。</p>
<p>在此作业中，你将给出服务器的完整代码（在配套网站中可找到）。你的任务是编写客户代码，该代码与服务器代码非常类似。建议你先仔细学习服务器的代码，然后编写你的客户代码，可以随意地从服务器代码中剪贴代码行。</p>
<p>电脑内置的ping程序示例：</p>
<p><img src="/2021/04/23/UDPping%E7%A8%8B%E5%BA%8F/1.png" style="zoom:80%;"></p>
<p>梳理题目之后，结合电脑中的ping程序示例，我们给出UDPServer的功能和UDPClient的功能</p>
<h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><ul>
<li>显示用户通过客户端发送来的消息内容(包含头部和payload)</li>
<li>能够<strong>模拟分组的丢失</strong>；能够<strong>模拟分组传输延迟</strong>；</li>
<li>将Client发送来的请求在延迟一段随机选择的时间(小于1s)后返回给客户端，作为收到请求的响应reply；  </li>
</ul>
<h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><ul>
<li>启动后发送10个request。发送一个request后，<strong>最多</strong>等待1秒以便接收server返回的消息。如果在1s内没有收到服务器的reply，则认为该请求或对该请求的reply已经丢失</li>
<li>在收到reply后立即发送下一个请求。</li>
<li>请求消息的payload中包含关键字PingUDP、序号、时间戳这些内容</li>
<li>计算传包总数，收到包的总数以及丢包率</li>
<li>为每个请求计算折返时间(RTT)，统计10个请求的min/avg/maxRTT。</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>我把这个项目写成了两个project：pingserver和pingclient,分别启动，更加直观一些</p>
<h3 id="pingserver"><a href="#pingserver" class="headerlink" title="pingserver"></a>pingserver</h3><h4 id="PingServer类"><a href="#PingServer类" class="headerlink" title="PingServer类"></a>PingServer类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PingServer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> intiPort;</span><br><span class="line">    <span class="keyword">private</span> DatagramSocket serverSocket;<span class="comment">//服务器码头</span></span><br><span class="line">    <span class="keyword">private</span> DatagramPacket receivePacket;<span class="comment">//接受数据分组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] buffer=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];<span class="comment">//数据缓冲区</span></span><br><span class="line">    Scanner scanner;</span><br><span class="line">    <span class="comment">//初始化端口号</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PingServer</span><span class="params">(<span class="keyword">int</span> intiPort)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.intiPort=intiPort;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PingServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"基于udp实现ping"</span>);</span><br><span class="line">        System.out.println(<span class="string">"------PING SERVER------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"请输入监听端口号"</span>);</span><br><span class="line">        scanner=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">this</span>.intiPort=scanner.nextInt();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//根据输入的端口生成server端socket实例</span></span><br><span class="line">            serverSocket=<span class="keyword">new</span> DatagramSocket(intiPort);<span class="comment">// 默认绑定本主机</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            CloseUtil.closeAll(serverSocket,scanner);</span><br><span class="line">            System.out.println(<span class="string">"监听端口："</span>+intiPort+<span class="string">"启动失败。请从新输入端口号"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.exit(<span class="number">0</span>);<span class="comment">//终止程序</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//监听是否有请求数据</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            receivePacket=<span class="keyword">new</span> DatagramPacket(buffer, buffer.length);<span class="comment">//空的数据包接受分组</span></span><br><span class="line">            <span class="comment">//监听是否有用户请求</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                serverSocket.receive(receivePacket);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"分组异常"</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果捕捉到了client发送的请求，那就生成一个新的服务线程来处理数据包</span></span><br><span class="line">            <span class="keyword">new</span> ServerThread(serverSocket,receivePacket).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ServerThread类"><a href="#ServerThread类" class="headerlink" title="ServerThread类"></a>ServerThread类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DatagramSocket serverSocket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DatagramPacket receivePacket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerThread</span><span class="params">(DatagramSocket serverSocket,</span></span></span><br><span class="line"><span class="function"><span class="params">                        DatagramPacket receivePacket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serverSocket = serverSocket;</span><br><span class="line">        <span class="keyword">this</span>.receivePacket = receivePacket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];<span class="comment">//数据缓冲区</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> randomTime=(<span class="keyword">long</span>)(Math.random()*<span class="number">1500</span>);<span class="comment">//模拟延迟时间</span></span><br><span class="line"></span><br><span class="line">        String sentence;<span class="comment">//接受到的数据</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(randomTime);<span class="comment">//休眠，模拟延迟</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"--模拟延时错误--"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(randomTime&gt;<span class="number">1000</span>)&#123;<span class="comment">//如果延迟大于1秒，数据丢失</span></span><br><span class="line">            sentence=<span class="string">"Date lose"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sentence=<span class="keyword">new</span> String(receivePacket.getData());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        InetAddress host=receivePacket.getAddress();<span class="comment">//获取ip地址</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> port=receivePacket.getPort();<span class="comment">//端口号</span></span><br><span class="line"></span><br><span class="line">        buffer=sentence.getBytes();<span class="comment">//数据—&gt;字节数组,用于发回客户端</span></span><br><span class="line"></span><br><span class="line">        DatagramPacket sendPacket=<span class="keyword">new</span> DatagramPacket(buffer, buffer.length</span><br><span class="line">                ,host,port); <span class="comment">//生成数据包，有了目的地址和端口号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket.send(sendPacket);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            CloseUtil.closeAll(serverSocket);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sentence);<span class="comment">//显示请求结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pingclient"><a href="#pingclient" class="headerlink" title="pingclient"></a>pingclient</h3><h4 id="PingClient类"><a href="#PingClient类" class="headerlink" title="PingClient类"></a>PingClient类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PingClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"基于udp实现ping"</span>);</span><br><span class="line">        System.out.println(<span class="string">"----PING CLIENT------"</span>);</span><br><span class="line">        Scanner scanner=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入主机号"</span>);</span><br><span class="line">        String host=scanner.nextLine();</span><br><span class="line">        System.out.println(<span class="string">"请输入端口号"</span>);</span><br><span class="line">        <span class="keyword">int</span> port=scanner.nextInt();</span><br><span class="line">        <span class="keyword">byte</span>[] buffer;<span class="comment">//数据包缓冲区</span></span><br><span class="line">        <span class="keyword">long</span>[] rtt=<span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">10</span>];<span class="comment">//用于存储10个rtt</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;<span class="comment">//模拟发送10个请求</span></span><br><span class="line">            SimpleDateFormat sdf=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-ddhh:mm:ss.SS"</span>);<span class="comment">//时间格式</span></span><br><span class="line"></span><br><span class="line">            Date sendBefore=<span class="keyword">new</span> Date();<span class="comment">//当前时间</span></span><br><span class="line">            String sentence=<span class="string">"head:request "</span>+i+<span class="string">" playload:UDP-Number: "</span></span><br><span class="line">                    +i+<span class="string">" TimeStamp："</span>+sdf.format(sendBefore);<span class="comment">//请求数据</span></span><br><span class="line">            DatagramSocket clientSocket=<span class="keyword">new</span> DatagramSocket();</span><br><span class="line"></span><br><span class="line">            InetAddress IP=InetAddress.getByName(host);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            buffer=sentence.getBytes();<span class="comment">//数据打包成字节数组</span></span><br><span class="line"></span><br><span class="line">            DatagramPacket sendPacket=<span class="keyword">new</span> DatagramPacket(buffer, buffer.length,IP,port);<span class="comment">//字节数组-&gt;分组</span></span><br><span class="line"></span><br><span class="line">            clientSocket.send(sendPacket);<span class="comment">//发送分组</span></span><br><span class="line"></span><br><span class="line">            DatagramPacket receivePacket=<span class="keyword">new</span> DatagramPacket(buffer, buffer.length);<span class="comment">//接受分组</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clientSocket.receive(receivePacket);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"分组接受异常"</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//数据-&gt;字符串</span></span><br><span class="line">            String receiveSentence=<span class="keyword">new</span> String(receivePacket.getData());</span><br><span class="line"></span><br><span class="line">            Date receiveAfter=<span class="keyword">new</span> Date();<span class="comment">//接收时间</span></span><br><span class="line"></span><br><span class="line">            rtt[i-<span class="number">1</span>]=receiveAfter.getTime()-sendBefore.getTime();<span class="comment">//计算rtt</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(rtt[i-<span class="number">1</span>]&gt;=<span class="number">1000</span>)&#123;</span><br><span class="line">                rtt[i-<span class="number">1</span>]=<span class="number">1000</span>;</span><br><span class="line">                System.out.println(sentence+<span class="string">" Data Lose"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">                System.out.print(receiveSentence);<span class="comment">//显示返回的数据</span></span><br><span class="line">                System.out.println(<span class="string">" time="</span>+rtt[i-<span class="number">1</span>]+<span class="string">" ms"</span>);<span class="comment">//显示往返时间</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            clientSocket.close();</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//进行统计</span></span><br><span class="line">      	dealRtt(rtt);</span><br><span class="line">        CloseUtil.closeAll(scanner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dealRtt</span><span class="params">(<span class="keyword">long</span>[] rtt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sumRtt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> maxRtt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> minRtt=rtt[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">byte</span> loss=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(rtt[i]&gt;=<span class="number">1000</span>)</span><br><span class="line">                loss++;</span><br><span class="line">            <span class="keyword">if</span>(rtt[i]&gt;maxRtt)</span><br><span class="line">                maxRtt=rtt[i];</span><br><span class="line">            <span class="keyword">if</span>(rtt[i]&lt;minRtt)</span><br><span class="line">                minRtt=rtt[i];</span><br><span class="line">            sumRtt+=rtt[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span> received = (<span class="keyword">byte</span>) (<span class="number">10</span>-loss);</span><br><span class="line">        <span class="keyword">double</span> rate = (<span class="keyword">double</span>)loss/<span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">"--- UDPServer ping statistics ---"</span>);</span><br><span class="line">        System.out.println(<span class="string">"10 packets transimitted, "</span>+received+<span class="string">" packets received, "</span>+ rate+<span class="string">"% packet loss."</span>);</span><br><span class="line">        System.out.println(<span class="string">"round-trip min/avg/max = "</span>+minRtt+<span class="string">"/"</span>+sumRtt/<span class="number">10</span>+<span class="string">"/"</span>+maxRtt+ <span class="string">" ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CloseUtil"><a href="#CloseUtil" class="headerlink" title="CloseUtil"></a>CloseUtil</h3><p>这个小组件是两个project都的，作用是用来关闭IO流的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloseUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeAll</span><span class="params">(Closeable...io)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Closeable temp:io)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                temp.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下图所示：</p>
<p><img src="/2021/04/23/UDPping%E7%A8%8B%E5%BA%8F/3.png" style="zoom:80%;"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jason</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">439</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    

  

</body>
</html>
