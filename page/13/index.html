<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=">


  <link rel="mask-icon" href="/images/logo.svg?v=" color="#222">














<meta property="og:type" content="website">
<meta property="og:title" content="Jason‘s Blog">
<meta property="og:url" content="https://jasonxqh.github.io/page/13/index.html">
<meta property="og:site_name" content="Jason‘s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '',
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    fancybox: false,
    tabs: ,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: 'undefined',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>







  <title>Jason‘s Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', '[object Object]', 'auto');
  ga('send', 'pageview');
</script>





<meta name="generator" content="Hexo 4.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">
  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
<a href="https://github.com/JasonXQH/JasonXQH.github.io" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jason‘s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/%20" rel="section">
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/05/04/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/04/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/" itemprop="url">矩阵分解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-04T20:28:47+08:00">
                2021-05-04
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2021-06-29T22:07:20+08:00">
                2021-06-29
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="矩阵分解"><a href="#矩阵分解" class="headerlink" title="矩阵分解"></a>矩阵分解</h1><h2 id="具有特殊结构和性质的矩阵"><a href="#具有特殊结构和性质的矩阵" class="headerlink" title="具有特殊结构和性质的矩阵"></a>具有特殊结构和性质的矩阵</h2><h3 id="数学中常见的具有特殊结构的矩阵"><a href="#数学中常见的具有特殊结构的矩阵" class="headerlink" title="数学中常见的具有特殊结构的矩阵"></a>数学中常见的具有特殊结构的矩阵</h3><h4 id="方阵"><a href="#方阵" class="headerlink" title="方阵"></a>方阵</h4><p>行数与列数都等于n 的叫做n阶方阵</p>
<ul>
<li>只有方阵才可以计算行列式</li>
<li>方阵才有逆矩阵，且方阵有逆矩阵当且仅当方阵满秩</li>
<li>只有方阵才有伴随矩阵</li>
<li>只有方阵才有特征值与特征向量</li>
</ul>
<h4 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h4><p>矩阵A是对称矩阵当且仅当</p>
<script type="math/tex; mode=display">
A^T = A</script><h4 id="正-半-定矩阵"><a href="#正-半-定矩阵" class="headerlink" title="正(半)定矩阵"></a>正(半)定矩阵</h4><p><img src="/2021/05/04/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/1.png" style="zoom:67%;"></p>
<h4 id="对角矩阵"><a href="#对角矩阵" class="headerlink" title="对角矩阵"></a>对角矩阵</h4><p>非对角元素都为零元素的方阵叫做对角矩阵</p>
<h4 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h4><p>三角矩阵是对角元下方或对角元上方全是0的方阵</p>
<ul>
<li>三角矩阵主对角线上元素均非零 $\Leftrightarrow$ 三角矩阵可逆</li>
<li>上三角、下三角矩阵的乘积还是上、下三角矩阵</li>
<li>上、下三角矩阵可逆则其逆矩阵也是上、下三角矩阵</li>
<li>设矩阵 A 为三角矩阵，那么 矩阵 $A^k$ 主对角线上的元素满足 $(A^k)_{ii} =(A_ii)^k,i=1,2\cdots,n$</li>
</ul>
<h4 id="正交矩阵"><a href="#正交矩阵" class="headerlink" title="正交矩阵"></a>正交矩阵</h4><p>正交矩阵指行向量和列向量是分别标准正交的方阵即</p>
<script type="math/tex; mode=display">
A^TA = AA^T = I</script><p>所以,  $A^{-1} = A^T$</p>
<ul>
<li><p>如果矩阵 $U\in \mathbb R^{m\times m},V\in\mathbb R^{n\times n} $ 是正交矩阵， $M\in \mathbb R^{m\times n},x\in \mathbb R^m$ </p>
<ul>
<li><script type="math/tex; mode=display">
||U||_2 =1, ||U||_F = \sqrt {m}</script></li>
<li><script type="math/tex; mode=display">
||Ux||_2 = ||x||_2, ||Ux||_F = ||x||_F</script></li>
<li><script type="math/tex; mode=display">
||UMV||_2 = ||M||_2,||UMV||_F = ||M||_F</script></li>
</ul>
</li>
</ul>
<h4 id="Dyads-并向量或单纯矩阵或秩1矩阵"><a href="#Dyads-并向量或单纯矩阵或秩1矩阵" class="headerlink" title="Dyads(并向量或单纯矩阵或秩1矩阵)"></a>Dyads(并向量或单纯矩阵或秩1矩阵)</h4><p>矩阵 $A\in \mathbb R^{m\times n}$ 具有如下形式：</p>
<script type="math/tex; mode=display">
 A = uv^T</script><p>其中向量 $u\in \mathbb R^m,v\in \mathbb R^n$ ，则称其为dyad，也称并向量或单纯矩阵。如果 u 和 v 不为0，则我们称其为 <strong>秩1矩阵</strong> </p>
<h2 id="LU-分解"><a href="#LU-分解" class="headerlink" title="LU 分解"></a>LU 分解</h2><p><strong>LU 分解指将</strong>$n\times n$ <strong>的矩阵A分解成两个三角矩阵的乘积</strong></p>
<p>其中， L 为 $n\times n$ 单位下三角矩阵(对角元素为1)，U 是  $n\times n$ 上三角矩阵。</p>
<p>从秩1分解的角度分析 $A=LU$ , 可以将 A 写成若干个 秩1矩阵和的形式：</p>
<script type="math/tex; mode=display">
A = l_1u_1+\cdots+l_ru_r = \sum_{i=1}^r l_iu_i</script><p>其中r为矩阵A的秩，若A是满秩，则 $r=n$ 。 $l_i$ 是 $L$ 的第$i$列；$u_i$ 是 $U$ 的第$i$行。 $l_iu_i$ 都是秩为1的矩阵，并且这个矩阵的前 $i-1$行和前$i-1$列的元素都是0</p>
<p>求矩阵A</p>
<script type="math/tex; mode=display">
A=\begin{pmatrix} 1 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 10 \end{pmatrix}</script><p>的LU分解</p>
<p>我们要像<strong>剥洋葱</strong>一样一层一层地分解矩阵A，同时要记得 L 的对角线都是1</p>
<ul>
<li>第一步</li>
</ul>
<p>令 $u<em>1$ 是 A 的第1行，$l_1$ 是A的第1列 除以 $u</em>{11}$ ,则：</p>
<script type="math/tex; mode=display">
l_1u_1 =\begin{pmatrix} 1 \\ 4 \\ 7  \end{pmatrix}\begin{pmatrix} 1 & 2 & 3\end{pmatrix} = \begin{pmatrix} 1 & 2 & 3 \\ 4 & 8 & 12 \\ 7 & 14 & 21 \end{pmatrix}\\~~\\
A-l_1u_1 = \begin{pmatrix} 1 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 10 \end{pmatrix}-\begin{pmatrix} 1 & 2 & 3 \\ 4 & 8 & 12 \\ 7 & 14 & 21 \end{pmatrix} = \begin{pmatrix} 0 & 0 & 0 \\ 0 & -3 & -6 \\ 0 & -6 & -11 \end{pmatrix}</script><ul>
<li>第二步</li>
</ul>
<p>令 $u<em>2$ 是 $A-l_1 u_1$ 的第2行，$l_2$ 是 $A-l_1u_1$ 的第二列除以$u</em>{22}$ </p>
<script type="math/tex; mode=display">
l_2u_2 =\begin{pmatrix} 0 \\ 1 \\ 2  \end{pmatrix}\begin{pmatrix} 0 & -3 & -6\end{pmatrix} = \begin{pmatrix} 0 & 0 & 0 \\ 0 & -3 & -6 \\ 0 & -6 & -12 \end{pmatrix}\\~~\\
A-l_1u_1-l_2u_2 = \begin{pmatrix} 0 & 0 & 0 \\ 0 & -3 & -6 \\ 0 & -6 & -11 \end{pmatrix}-\begin{pmatrix} 0 & 0 & 0 \\ 0 & -3 & -6 \\ 0 & -6 & -12 \end{pmatrix} = \begin{pmatrix} 0 & 0 & 0 \\ 0 & 0 & 0 \\ 0 & 0 & 1 \end{pmatrix}</script><ul>
<li>第三步</li>
</ul>
<p>令$u<em>3$ 是$A-l_1u_1-l_2u_2$  的第3行，$l_3$ 是 $A-l_1u_1-l_2u_2$ 的第3列除以$u</em>{33}$ 即</p>
<script type="math/tex; mode=display">
l_3 =\begin{pmatrix} 0 \\ 0 \\ 1  \end{pmatrix}, u_3 = \begin{pmatrix} 0 & 0 & 1 \end{pmatrix}</script><ul>
<li>第四步，我们要把$l_1,l_2,l_3$ 相加得到$L$ ,$u_1,u_2,u_3$ 相加得到$U$ </li>
</ul>
<script type="math/tex; mode=display">
A = LU = \begin{pmatrix} 1 & 0 & 0 \\ 4 & 1 & 0 \\ 7 & 2 & 1 \end{pmatrix}\begin{pmatrix} 1 & 2 & 3 \\ 0 & -3 & -6 \\ 0 & 0 & 1 \end{pmatrix}</script><h2 id="QR-分解"><a href="#QR-分解" class="headerlink" title="QR 分解"></a>QR 分解</h2><p>QR分解指将矩阵A分解成列正交矩阵和上三角矩阵的乘积，形式如下：</p>
<script type="math/tex; mode=display">
A = QR = \begin{pmatrix} q_1 & q_2 & q_3 \end{pmatrix} \begin{pmatrix} r_1 \\ r_2 \\ r_3 \end{pmatrix} = q_1r_1+q_2r_2+\cdots+q_nr_n</script><p>其中 Q 是列正交矩阵，R是上三角矩阵。 $q_i$ 是 $Q$ 的列向量，$r_i$ 是 $R$ 的行向量。 且 $q_ir_i$ 的前 $i-1$ 列都为0。</p>
<p>矩阵的QR分解可以通过 <strong>Gram-Schmidt</strong> 正交化，<strong>Household</strong> 变换，<strong>Givens</strong>变换等方法实现</p>
<h3 id="Gram-Schmidt-正交化法"><a href="#Gram-Schmidt-正交化法" class="headerlink" title="Gram-Schmidt 正交化法"></a>Gram-Schmidt 正交化法</h3><p>首先要求出单位化后的特征向量。我们定义投影操作为： $proj_u= \frac{<u,a>}{<u,u>}u$, 也就是获取<strong>a</strong>在<strong>u</strong>方向上的分量</u,u></u,a></p>
<p>对于一个满秩矩阵：$A=[a_1,\cdots,a_n]$</p>
<script type="math/tex; mode=display">
u_1 = a_1, ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~e_1=\frac{u_1}{||u_1||}\\
u_2 = a_2-proj_{u_1}a_2 ~~~~~~~~~~~~~~~~~~~~~e_2=\frac{u_2}{||u_2||}\\
u_3=a_3-proj_{u_1}a_3-proj_{u_2}a_3~~e_3=\frac{u_3}{||u_3||}\\
u_k = a_k-\sum_{j=1}^{k-1}proj_{u_j}a_k,~~~~~~~~~~~~~~e_k=\frac{u_k}{||u_k||}</script><p>矩阵A的QR分解就可以写为：</p>
<script type="math/tex; mode=display">
Q = [e_1,\cdots,e_n]</script><p>和</p>
<script type="math/tex; mode=display">
R=</script><h4 id="分解方阵"><a href="#分解方阵" class="headerlink" title="分解方阵"></a>分解方阵</h4><script type="math/tex; mode=display">
a_1 = (0,1,1)^T ,a_2=(1,1,0)^T,a_3=(1,0,1)^T</script><p>我们先用正交化方法可得：其中$q_i$代表标准化后的 $b_i$ </p>
<script type="math/tex; mode=display">
b_1 = a_1 = (0,1,1)^T,~~|b_1| = \sqrt{2}\\
b_2 = a_2-\frac{[a_2,b_1]}{[b_1,b_1]}b_1=(1,1,0)^T-\frac{1}{2}(0,1,1)^T = (1,\frac{1}{2},-\frac{1}{2})^T,|b_2| = \frac{\sqrt{6}}{2}\\
b_3 = a_3-\frac{[a_3,b_2]}{[b_2,b_2]}b_1-\frac{[a_3,b_2]}{[b_2,b_2]}b_2 = (1,0,1)^T-\frac{1}{2}(0,1,1)^T-\frac{0.5}{1.5}(1,\frac{1}{2},-\frac{1}{2})^T = (\frac{2}{3},-\frac{2}{3},\frac{2}{3})^T \\</script><p>现在来计算标准化后的矩阵：</p>
<script type="math/tex; mode=display">
q_1 = \frac{1}{\sqrt 2}(0,1,1)^T\\
q_2 = \frac{1}{\sqrt 6}(2,1,-1)^T\\
q_3 = \frac{\sqrt 3}{2}(\frac{2}{3},-\frac{2}{3},\frac{2}{3})^T\\</script><p>因此， </p>
<script type="math/tex; mode=display">
Q = (q_1,q_2,q_3) = \begin{bmatrix} 0 & \dfrac{2}{\sqrt{6}} & \dfrac{1}{\sqrt{3}} \\ \dfrac{1}{\sqrt{2}} & \dfrac{1}{\sqrt{6}} & -\dfrac{1}{\sqrt{3}} \\ \dfrac{1}{\sqrt{2}} & \dfrac{-1}{\sqrt{6}} & \dfrac{1}{\sqrt{3}} \end{bmatrix}</script><script type="math/tex; mode=display">
R =  \begin{bmatrix} |b_1| & [a_2,q_1] & [a_3,q_1] \\ 0 & |b_2| & [a_3,q_2] \\ 0 & 0 & |b_3| \end{bmatrix} =\begin{bmatrix} \sqrt{2} & \dfrac{1}{\sqrt{2}} & \dfrac{1}{\sqrt{2}} \\ 0 & \dfrac{\sqrt{6}}{2} & \dfrac{1}{\sqrt{6}} \\ 0 & 0 & \dfrac{2}{\sqrt{3}} \end{bmatrix}</script><h2 id="谱分解"><a href="#谱分解" class="headerlink" title="谱分解"></a>谱分解</h2><p>设对称矩阵A为n阶方阵，如果A可以被分解为$A=Q\Lambda Q^T$ , 其中 $Q=[q_1,q_2,\cdots,q_n]$ 是由特征向量 $q_1,q_2\cdots,q_n$ 组成的n阶方阵， $\Lambda = diag(\lambda_1,\lambda_2,\cdots,\lambda_n)$  是由特征值$\lambda_1,\lambda_2\cdots,\lambda_n$ 组成的n阶对角矩阵，则这种分解叫做对称矩阵的<strong>谱分解</strong>或者<strong>特征分解</strong></p>
<p>求解对称方程 $A\in \mathbb R^{n\times n}$ 的特征分解步骤</p>
<ul>
<li><p>计算矩阵A的特征值$\lambda_1\cdots,\lambda_n$ 即 求特征方程 $|A-\lambda I| = 0$  的n个根</p>
</li>
<li><p>求特征值对应的n个相互正交的特征向量 $q_1,\cdots,q_n$即求解方程组并单位化</p>
<script type="math/tex; mode=display">
Aq_i = \lambda_iq_i,i=1,\cdots,n</script></li>
<li><p>记矩阵 $Q=(q_1,\cdots,q_n)$ </p>
</li>
<li><p>最终得到矩阵A的特征分解为 </p>
<script type="math/tex; mode=display">
A = Q\begin{pmatrix} \lambda_1 &  &  \\  & \cdots &  \\ & & \lambda_n \end{pmatrix}Q^T</script></li>
</ul>
<p>求实对称矩阵的特征分解</p>
<script type="math/tex; mode=display">
A =\begin{bmatrix} 2& 1\\ 1 & 2 \end{bmatrix}</script><ol>
<li>首先我们计算特征向量</li>
</ol>
<script type="math/tex; mode=display">
|\lambda I-A| =\begin{bmatrix}\lambda-2& -1\\ -1 & \lambda-2 \end{bmatrix}=0\\</script><p>特征值：$\lambda_1=3,\lambda_2=1$</p>
<p>带入求解并单位化： $q_1 = (\frac{1}{\sqrt 2},\frac{1}{\sqrt 2})^T,q_2 = (-\frac{1}{\sqrt2},\frac{1}{\sqrt2})^T$ </p>
<ol>
<li>写出左特征向量方阵Q和特征值方阵 $\Lambda$ </li>
</ol>
<script type="math/tex; mode=display">
Q =[q_1,q_2] =\begin{bmatrix} \frac{1}{\sqrt2}& -\frac{1}{\sqrt 2}\\ \frac{1}{\sqrt 2} & \frac{1}{\sqrt2} \end{bmatrix},\Lambda =\begin{bmatrix} \lambda_1 & \\  & \lambda_2 \end{bmatrix} = \begin{bmatrix} 3 &\\ & 1 \end{bmatrix}</script><ol>
<li>$p=(\alpha_1,\alpha_2,\alpha_3),(p^{-1})^T=(\beta_1,\beta_2,\beta_3)$ </li>
</ol>
<script type="math/tex; mode=display">
G_1 = \alpha_1\beta_1^T+\alpha_2\beta_2^T\\~\\
G_2 = \alpha_3\beta_3^T</script><p>A和$G_1,G_2$的关系就是谱分解</p>
<h2 id="Cholesky-分解"><a href="#Cholesky-分解" class="headerlink" title="Cholesky 分解"></a>Cholesky 分解</h2><p>设 $A = (a_{ij})\in R^{n\times n}$是对称正定矩阵， $A=GG^T$称为矩阵A的Cholesky 分解。 其中，$G\in R^{n\times n}$  是一个具有正的对角线元素的下三角矩阵。</p>
<script type="math/tex; mode=display">
G =\begin{pmatrix} g_{11} &  & & \\ g_{21} & g_{22} & & \\ \cdots & \cdots & \cdots &\\g_{n1}&g_{n2}&\cdots&g_{nn} \end{pmatrix}</script><script type="math/tex; mode=display">
l_{11}=\sqrt{a_{11}}\\~\\
l_{i1} = \frac{a_{i1}}{l_{11}} ~(i=2,3,\cdots,n)</script><p>这样就得到了第一列元素</p>
<p>假设已经算出L的前 $k-1$ 列元素，通过 $a<em>{kk} = \sum</em>{i=1}^k l^2_{ki}$</p>
<p>得到：</p>
<script type="math/tex; mode=display">
l_{kk} = \sqrt{a_{kk}-\sum_{i=1}^{k-1}l_{ki}^2}</script><p>进一步再由：</p>
<script type="math/tex; mode=display">
a_{ik} = \sum_{j=1}^{k-1}l_{ij}l_{kj}+l_{ik}l_{kk}</script><p>得到：</p>
<script type="math/tex; mode=display">
l_{ik} = \frac{a_{ik}-\sum_{j=1}^{k-1}l_{ij}l_{kj}}{l_{kk}},(i = k+1,\cdots,n)</script><p>也就是可以通过L的前k-1列来求出第k列</p>
<p>一般来说只会让我们求3阶的矩阵分解，这时候要求六个元素</p>
<ol>
<li>第一阶段，求 $l<em>{11}=\sqrt{a</em>{11}}$</li>
<li>再求第一列的两个元素： $l<em>{21}=\frac{a</em>{21}}{l<em>{11}},l</em>{31}=\frac{a<em>{31}}{l</em>{11}}$</li>
<li>第二阶段，求$l<em>{22} = \sqrt{a</em>{22}-l^2_{21}}$ </li>
<li>求$l<em>{32}=\frac{a</em>{32}-l<em>{31}l</em>{21}}{l_{22}}$</li>
<li>第三阶段，求 $l<em>{33}=\sqrt{a</em>{33}-(l<em>{31}^2+l^2</em>{32})}$</li>
</ol>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/" itemprop="url">计算机网络-运输层总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-03T00:17:00+08:00">
                2021-05-03
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-08-24T13:17:58+08:00">
                2022-08-24
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="计算机网络-运输层"><a href="#计算机网络-运输层" class="headerlink" title="计算机网络-运输层"></a>计算机网络-运输层</h1><h2 id="概述和运输层服务"><a href="#概述和运输层服务" class="headerlink" title="概述和运输层服务"></a>概述和运输层服务</h2><p>运输层位于应用层和网络层之间，主要为运行<strong>在不同主机上</strong>的应用进程提供了<strong>逻辑通信</strong>。 非常类似于高速公路，高速公路负责把人或者物品从一端运送到另一端，而运输层则负责把报文从一个端系统运送到另一个端系统(手机、网络媒体等)</p>
<p>在运输层运输报文的过程中，会遵循一定的协议规范。比如一次传输的数据显示、选择什么样的运输协议等。运输层实现了让两个互不相关的主机好像直接相连一样，这就是<strong>逻辑通信</strong>的意义。</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/1.png" style="zoom:67%;"></p>
<p>上面是一个数据包首部的结构，数据包经过每层后，该层协议都会在数据包附上包首部。那么，在数据传输到运输层后，如果采用的是TCP协议，那么会为其附上TCP首部，首部包含着<strong>源端口号</strong>,<strong>目的端口号</strong> 。 </p>
<p>在发送端，运输层将从发送应用程序进程 接收到的报文转化成 <strong>运输层分组</strong>， 分组在计算机网络中也称为<strong>报文段</strong>。运输层一般会把报文段进行分割，分割成为较小的块，为每一块加上运输层首部(否则不知道源端口和目的端口)并将其向目的地发送。</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>在TCP/IP 协议中能实现传输层功能的，最具代表性的就是TCP和UDP，它就好像是高速公路上的交通工具。</p>
<p>TCP 叫做 <strong>Transmission Control Protocol(传输控制协议)</strong> ，通过名称可以大致知道TCP协议有控制传输的功能。TCP为应用层提供了一种<strong>可靠、面向连接的</strong> 服务，能够将分组可靠的传输到服务端。</p>
<p>UDP 叫做<strong>User Datagram Protocol(用户数据报协议)</strong> ,UDP 为应用层提供了一种<strong>无需建立连接</strong> 就可以直接发送数据报的方法。但是传输过程是不可靠的。</p>
<blockquote>
<p>在计算机网络中，不同层对数据有不同的描述。上面讲运输层的分组称为报文段，除此之外，还会将TCP中的分组也称为报文段，但是将UDP的分组称为数据报，网络层的分组也称为数据报</p>
<p>但是为了统一，我们这边就统称为报文段</p>
</blockquote>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/2.png" style="zoom:67%;"></p>
<h3 id="套接字-socket"><a href="#套接字-socket" class="headerlink" title="套接字(socket)"></a>套接字(socket)</h3><p>在TCP或UDP发送报文信息前，要经过一扇门，也就是<strong>套接字(socket)</strong>,向上连接着应用层，向下连接着网络层。</p>
<p>使用TCP或者UDP通信时，会广泛使用到套接字的API来设置IP地址、端口号，实现数据的发送和接收。</p>
<p>Socket和<code>TCP/IP</code>没有必然联系，但是方便了<code>TCP/IP</code>的使用.比如说:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>create()</code></td>
<td>创建一个socket</td>
</tr>
<tr>
<td><code>bind()</code></td>
<td>套接字标识，一般用于绑定端口号</td>
</tr>
<tr>
<td><code>listen()</code></td>
<td>准备接收连接</td>
</tr>
<tr>
<td><code>accept()</code></td>
<td>准备作为接收者</td>
</tr>
<tr>
<td><code>write()</code></td>
<td>发送数据</td>
</tr>
<tr>
<td><code>read()</code></td>
<td>接收数据</td>
</tr>
<tr>
<td><code>close()</code></td>
<td>关闭连接</td>
</tr>
</tbody>
</table>
</div>
<h4 id="套接字类型"><a href="#套接字类型" class="headerlink" title="套接字类型"></a>套接字类型</h4><ul>
<li><strong>Datagram sockets</strong>: 数据报套接字提供一种<strong>无连接</strong>的服务，而且不能保证数据传输的可靠性。数据有可能出现丢失或者重复，且无法保证顺序地接收到数据。数据报套接字使用<code>UDP</code> 进行数据的传输。我们需要在程序中作相应的处理才能解决有可能出现的数据丢失的情况。</li>
<li><strong>Stream sockets:</strong> 流套接字用于<strong>面向连接、可靠的</strong>数据传输服务。能够保证数据的可靠性、顺序性。 流套接字之所以能够实现可靠的数据服务。员应在于其使用了传输控制协议，即 TCP协议</li>
<li><strong>Raw sockets:</strong> 原始套接字允许直接发送和接收IP数据报，而无需任何特定于协议的传输层格式，原始套接字可以读写内核没有处理过的IP数据报。</li>
</ul>
<h3 id="套接字处理过程"><a href="#套接字处理过程" class="headerlink" title="套接字处理过程"></a>套接字处理过程</h3><p>在计算机网络中，要想实现通信，必须要<strong>两个端系统</strong>，至少需要<strong>两个套接字</strong></p>
<ol>
<li>socket 中的API用于创建通信链路中的端点，创建完成后会返回<code>套接字描述符</code>。使用套接字描述符可以用来访问套接字</li>
<li>当应用程序具有套接字描述符之后，可以将唯一的名字绑定在套接字上，服务器必须绑定一个名称才能在网络中访问</li>
<li>客户端在为服务端分配了socket 并且使用<code>bind()</code> 将名称绑定到套接字上后，会调用<code>listen()</code> ，表示愿意等待连接的意愿,<code>listen</code>必须在<code>accept</code> <strong>之前</strong>使用 </li>
<li>服务器应用程序 使用<code>accept()</code> api 接受客户端连接请求，服务器必须先成功调用 <code>bind</code> 和<code>listen</code> 之后，再调用 <code>accept()</code></li>
<li>现在，流套接字已经建立，客户端和服务器端可以发起<code>read/write</code>api调用了</li>
<li>当服务器或者客户端要停止操作时，就会调用<code>close</code>API 释放套接字获取的系统资源</li>
</ol>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>端口号可以理解为Socket 的ID。是一个<strong>16</strong>位的非负整数，介于 [0-65535] 之间，这个范围会分成3个不同的端口号段：</p>
<ul>
<li>周知/标准端口号， 范围是 0 - 1023</li>
<li>注册端口号，范围 1024-49151</li>
<li>私有端口号，范围 49152-65535</li>
</ul>
<p>当到达服务器的两条数据都是同一个端口，但是协议不同，该如何区分这个报文段的传送对象呢？互联网上一般使用<strong>源IP地址、目标IP地址、源端口号、目标端口号</strong> 来进行区分。 如果其中的某一项不同，就会被认为是不同的报文段。</p>
<h2 id="多路复用和多路分解"><a href="#多路复用和多路分解" class="headerlink" title="多路复用和多路分解"></a>多路复用和多路分解</h2><p>当报文段到达主机时，运输层会检查报文段中的目的端口号，并将其定向到相应的套接字，这叫做<strong>多路分解。</strong>然后报文段中的数据通过套接字进入其所连接的进程。(向上传递)</p>
<p>在源主机从不同的套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层，所有这些工作被称为<strong>多路复用</strong>。(向下传递)</p>
<p>多路复用和多路分解分为两种：<strong>无连接的多路复用和多路分解</strong> 和 <strong>面向连接的多路复用和多路分解</strong></p>
<h3 id="无连接的多路复用和多路分解"><a href="#无连接的多路复用和多路分解" class="headerlink" title="无连接的多路复用和多路分解"></a>无连接的多路复用和多路分解</h3><p>如下图所示，加入主机A中的端口 19157 要向服务器B端口46428 发送数据，采用UDP协议。 那么数据在应用层产生之后，会在运输层中加工处理，然后在网络层中将数据封装获得IP数据包，IP数据包通过链路层尽力而为得交付给服务器B，然后主机B会检查报文段中的<strong>端口号</strong>判断是哪个套接字的。</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/3.png"></p>
<p>所以，UDP套接字其实就是个二元组，包含目的IP地址和目的端口号、</p>
<p>所以，如果两个UDP报文段有<strong>不同的源IP地址</strong>和<strong>相同的源端口号</strong> ，但是具有<strong>相同的目的IP地址</strong>和<strong>目的端口号</strong>，那么这两个报文会通过套接字定位到<strong>相同的</strong>进程</p>
<p>在A到B的报文段中，源端口号作为 “<strong>返回地址</strong>” 的一部分，即当B需要发回一个报文段给A时，B到A的报文段中的目的端口号便从A到B的报文段的源端口号中取值。</p>
<h3 id="面向连接的多路复用与多路分解"><a href="#面向连接的多路复用与多路分解" class="headerlink" title="面向连接的多路复用与多路分解"></a>面向连接的多路复用与多路分解</h3><p>如果说无连接的多路复用和多路分解指的是UDP的话，那么面向连接的多路复用与多路分解指的是TCP了。和UDP的报文结构为一个二元组不同，TCP的报文结构时一个<strong>四元组</strong>，即<strong>源IP地址、目标IP地址、源端口号、目标端口号</strong>， 当一个TCP报文段从网络到达一台主机时，这个主机会根据这四个值拆解到对应的套接字上。</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/4.png" style="zoom:67%;"></p>
<p>上图显示了面向连接的多路复用和多路分解的过程，图中主机C向主机B发起了两个HTTP请求，主机A向主机C发起了一个HTTP请求，主机A,B,C都有自己唯一的IP地址，当主机C发出HTTP请求后，主机B能够进行分解。对于主机A和主机C来说，这<strong>两个主机有不同的IP地址</strong>，所以对于主机B来说，也能够进行分解。</p>
<h2 id="UDP-无连接运输"><a href="#UDP-无连接运输" class="headerlink" title="UDP 无连接运输"></a>UDP 无连接运输</h2><p>UDP 为应用程序提供了一种<strong>无需建立连接</strong>就可以发送分装的IP数据包的方法。如果应用程序开发人员选择的是UDP而不是TCP的话，那么该应用程序相当于就是直接和IP直接打交道的。</p>
<p>所谓的无需建立连接，就是在使用UDP协议在将数据报传递给目标主机时，发送方和接收方的运输层实体间<strong>是没有握手的</strong>。</p>
<h3 id="UDP-的特点"><a href="#UDP-的特点" class="headerlink" title="UDP 的特点"></a>UDP 的特点</h3><p>UDP协议一般是作为流媒体应用、语音交流、视频会议所使用的传输层协议，包括DNS协议的底层也是使用了UDP协议，原因主要是因为以下几点</p>
<ul>
<li><strong>速度快</strong>，采用UDP协议时，只要应用进程将数据传给UDP，UDP就会将此数据打包进UDP报文段并立刻传递给网络层。 但是TCP有拥塞控制的功能，它会在发送前判断互联网拥堵情况，如果互联网极度阻塞，那么就会抑制TCP的发送方。使用UDP的目的就是<strong>实时性</strong></li>
<li><strong>无需建立连接</strong>：TCP在数据传输前需要经过三次握手的操作，而UDP则无需任何准备可进行数据传输。我们可以做一个比喻：<ul>
<li>TCP 是一种凡事都要设计好，没设计不会进行开发的工程师，需要把一切因素考虑在内后再开干，所以非常靠谱</li>
<li>UDP是上来直接开干，也不管设计也不管技术，这种开发人员非常不靠谱，但是适合快速迭代开发，可以马上上手<ul>
<li>但是并不是所有使用UDP协议的应用层都是不可靠的，应用程序可以自己实现可靠的数据传输，通过增加确认和重传机制。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="UDP-报文结构"><a href="#UDP-报文结构" class="headerlink" title="UDP 报文结构"></a>UDP 报文结构</h3><p>下面来看一下UDP的报文结构，每个UDP报文分为UDP报头和UDP数据区两部分。报头由<strong>4个16位长</strong>(2字节) 字段组成，分别说明该报文的<strong>源端口、目的端口、报文长度、校验值</strong></p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/5.png" style="zoom:67%;"></p>
<ul>
<li><strong>源端口号(Source Port)</strong>: 这个字段占据UDP报文头的前16位，通常包含发送数据报的应用程序所使用的UDP端口。接收端的应用程序利用这个字段的值作为发送响应的目的地址。 有时候不会设置源端口号，没有端口号就默认为0， 通常用于不需要返回消息的同信中</li>
<li><strong>目标端口号(Destination Port)</strong>: 表示接收端口，字段长位16位</li>
<li><strong>长度(Length)</strong>: 字段占据16位，表示UDP数据报的长度，等于UDP报文头长度+UDP数据长度。因为报文头长度为4*2 = 8 个字节，所以这个值最小为8，最大长度为65535 字节。</li>
<li><strong>校验和(Checksum):</strong> UDP 使用校验和来保证数据安全性，UDP的校验和也提供了差错检测功能，差错检测用于校验报文段从源到目标主机的过程中，数据的完整性是否发生了改变。那么校验和是怎么被计算的？ <ul>
<li>校验和就是将前三个字段的16比特的字相加，如果有溢出，就需要<strong>回卷(将溢出的高位加到最低位上去)</strong>。最后再取反码。</li>
</ul>
</li>
</ul>
<p>比如：</p>
<script type="math/tex; mode=display">
0110011001100000\\
0101010101010101\\
1000111100001100</script><p>这三个 16比特的前两个字和是：</p>
<script type="math/tex; mode=display">
~~~~0110011001100000\\
+0101010101010101\\
=1011101110110101\\</script><p>再将上面的和与第三个字相加，得出：</p>
<script type="math/tex; mode=display">
~~~~1011101110110101\\
+1000111100001100\\
=0100101011000010</script><p>注意到，最后一次的加法是由溢出的，因此，这个溢出的1要<strong>回卷</strong>到最低位的1出，因此我们看到最低位的1因为这个1而进了一位，倒数第二为变成了1 。最后取反码得到： $1011010100111101$ ,这就是最终的校验和。</p>
<p>在接收方，全部的4个16比特字(包括检验和)加在一起，如果该分组在运输过程中没有出现差错，那么最终的和将是<code>1111111111111111</code>,如果这些比特之一是0，那么我们就知道该分组中已经出现了差错。</p>
<blockquote>
<p>为什么UDP 会提供差错检测功能？</p>
</blockquote>
<p>其实这是一种<strong>端到端</strong>的设计原则，这个原则说的是要让传输中各种错误发生的概率降低到一个可以接受的水平。UDP不可靠的原因是因为他虽然提供了差错检测的功能，但是对于差错<strong>没有恢复能力</strong>更不会有重传机制。</p>
<h3 id="错题与注意点"><a href="#错题与注意点" class="headerlink" title="错题与注意点"></a>错题与注意点</h3><ul>
<li>UDP的检验和段是可选的，如果源主机不想计算校验和，该校验和段应全为0</li>
<li>UDP数据报的伪首部包含了IP地址信息，目的是通过数据校验保证UDP数据报正确地到达目的主机。该伪首部由源和目的主机仅在校验和计算期间建立，并不发送。</li>
<li>如果数据报在传输过程中被破坏，那么就把它丢弃</li>
<li>传输层提供的是端到端服务，为进程之间提供逻辑通信。<strong>不是主机之间的通讯</strong></li>
<li>HTTP响应报文可能会具有空的报文体</li>
<li>两个不同的Web页面(例如，<a href="http://www.mit.edu/research.html" target="_blank" rel="noopener">www.mit.edu/research.html</a>及<a href="http://www.mit.edu/students.html" target="_blank" rel="noopener">www.mit.edu/students.html</a>) 可以通过同一个<strong>持续连接</strong>发送</li>
<li><strong>网络层</strong>负责将称为<strong>数据报(datagram)</strong>的网络层分组从一台主机移动到另一台主机</li>
</ul>
<h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>假定在主机C上的一个进程有一个具有端口号6789的UDP套接字。假定主机A和主机B<strong>都用目的端口号6789</strong>向主机C发送一个UDP报文段。这两台主机的这些报文段在主机C都被描述为相同的套接字吗？如果是这样的话，在主机C的该进程将怎样知道源于两台不同主机的这两个报文段？</p>
<p>答：这两台主机的这些报文段在主机C会被描述为<strong>相同的套接字</strong>。因为在传输UDP包的时候, <strong>网络层会附带上源和目的的IP地址的,</strong> 主机C的程序可以通过不同的源IP地址判别。毕竟主机A和B在选端口的时候不知道彼此具体会选什么, 肯定会有选用一样端口号的情况,<strong>主机IP能把它们区分开</strong>。</p>
<h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>考虑一个长度为L的分组从端系统A开始，经3段链路传输到目的端系统。令$d<em>i,si$和$Ri$表示链路i的长度、传播速度和传输速率$(i= 1,2,3)$。该分组交换机对每个分组的时延为$d</em>{proc}$。假定没有排队时延，用$d_i、s_i、R_i(i= 1,2,3)$和L表示，该分组<strong>总的端到端时延</strong>是什么？</p>
<p><strong>解答</strong>： 首先我们要知道，$D<em>总 = D</em>{trans}+D<em>{prop}+D</em>{proc}$</p>
<p>那么，依次来解决这些时延：</p>
<p><strong>处理时延</strong>： 题目说，分组交换机对每个分组的时延为$d<em>{proc}$ ，在这条传输路径上，一共有两个端，两个路由器，因此，处理时延应该为 $2d</em>{proc}$ </p>
<p><strong>传播时延：</strong> 传播时延指的是数据在链路上的传递时间。这里一共有三段链路，每段链路的传播时延要个计算。为：$d_1/s_1+d_2/s_2+d_3/s_3$ </p>
<p><strong>传输时延：</strong> 传输时延指的是将分组的信息发到链路的时间，也就是将数据报推出去所花的时间。时延计算公式为：$L/R$, 这里，在每一段链路上都要个自己算，因此传输时延为：$L/R_1+L/R_2+L/R_3$ </p>
<p>现在假定该分组是1500字节，在所有3条链路上的传播时延是$2.5 \times 10^8$m/s，所有3条链路的<strong>传输速率</strong>是2Mbps，分组交换机的处理时延是3ms，第一段链路的长度是5000km，第二段链路的长度是4000km，并且最后一段链路的长度是1000km。对于这些值，该端到端时延为多少？</p>
<p>只要把数据带入公式即可。</p>
<h4 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h4><p> UDP和TCP使用反码来计算它们的检验和，结合UDP检验和段的相关知识回答以下问题：</p>
<p>（1）假设你有下面3个8比特字节：$01010011, 01100110, 01110100$。这些8比特字节和的反码是多少？写岀所有计算过程。（注：UDP和TCP使用16比特的字来计算校验和，但对于本题目，考虑8比特和。）</p>
<p><strong>解答</strong>：计算字节和：</p>
<script type="math/tex; mode=display">
~~~~01010011\\
+01100110\\
=10111001\\</script><p>然后和第二个数相加：</p>
<script type="math/tex; mode=display">
~~~~10111001\\
+01110100\\
=100101101</script><p>因为溢出了，所以要抹去最高位，并回卷到最低位。最终结果是 $00101110$ </p>
<p>取反码得到： $11010001$ </p>
<p>（2）在（1）中，UDP为什么要用该和的反码，即为什么不直接使用该和呢？使用该反码方案，接收方如何检测出差错? 1 比特的差错能检测出来吗? 2比特的差错呢?</p>
<p><strong>解答</strong>：相比于原码，补码，二进制反码循环移位加法求和具有以下优点：</p>
<ul>
<li><p>不依赖系统是大端小端。即无论你是发送方计算机或者接收方检查校验和时，都可直接通过上面的算法得到正确的结果。简单来说，用反码求和时，交换16位数的字节顺序，得到的结果相同，只是字节顺序相应地也交换了；而如果使用原码或者补码求和，得到的结果可能就不同。</p>
<ul>
<li>比如：针对上面的第二个计算式子，我们将字节顺序调换为：1001 1011 + 0100 0111 = 1110 0010(大端切换成小端), 取反得0001 1101，相比上面的1101 0001只是字节顺序相应的也进行的交换。而如果采用原码的话，1011 1001 + 0111 0100 -&gt; 0010 1101，交换顺序后得：1001 1011 + 0100 0111 -&gt; 1110 0010，结果发生改变。</li>
</ul>
</li>
<li><p>在接收方，全部的4个8比特字（包括检验和）加在一起。如果该分组中没有引入差错，则显然在接收方处该和将是1111 1111；如果这些比特之一是0, 那么我们就知道该分组中已经出现了差错。</p>
</li>
<li><p>所有的1位错误都会被检测到，但是如果有2位错误就有可能发送忽略，比方说上述第一个字节的最后一位转换为0，第二个字节的最后一位转换为1，此时相加的结果可能就不会有影响（跟(3)类似）。</p>
</li>
</ul>
<p>（3）假定某UDP接收方对接收到的UDP报文段计算因特网检验和，并发现它与承载在检验和字段中的值相匹配。该接收方能够绝对确信没有出现过比特差错吗？试解释之。</p>
<p><strong>解答：</strong> 不，接收方<strong>不能完全确定没有发生任何位错误</strong>。如果<strong>包中两个16位字的对应位（相加在一起）是0和1，那么即使这些位分别翻转到1和0，所得的和仍然保持不变</strong>。因此，接收方计算的反码也将是相同的。此外，传输错误也有可能导致验证通过。</p>
<h2 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h2><p>这是这一章最难的东西了。在学习TCP之前，我们必须搞懂可靠数据传输原理。</p>
<p>下图是可靠数据传输的框架：为上层实体提供的服务可以理解为：数据可以通过一条可靠信道进行传输。借助于可靠信道，可以实现：</p>
<ul>
<li>传输数据比特就不会受到损坏或者丢失</li>
<li>所有数据都是按照其发送顺序进行交付</li>
</ul>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/6.png" style="zoom:67%;"></p>
<p>但是在可靠数据传输协议的下层也许是不可靠的，因此，如何把不可靠的变可靠的是一件比较困难的事情：首先应用层把要发送的数据交给传输层的发送端，并调用 <code>rdt_send()</code> 分组以后调用<code>udt_send()</code> 将packet 通过网络层(不可靠的) 发送给 接收方。并通过某种方法让传输的数据在中途不会有损坏或者丢失。再将packet还原成data，并向上抛给接收端的应用层。</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/1.jpg" style="zoom:67%;"></p>
<p>接下来我们要使用<strong>有限状态机</strong>来具象化发送端和接收端。也就是说，可以通过某一个时间是状态机的状态发生改变。</p>
<h3 id="rdt1-0"><a href="#rdt1-0" class="headerlink" title="rdt1.0"></a>rdt1.0</h3><p>我们首先来看最简单的情况。在这种情况下，物品，我们将数据的<strong>传输信道(也就是上图下方的管道)</strong>理想化，视为<strong>完全可靠</strong>，<strong>不丢包也不发生bit error(如比特重置)</strong> ，在这样的情况下，发送端发送数据，接收端直接接收，并不虑丢包，超时这些问题。</p>
<p><strong>发送者</strong>：</p>
<p>首先，发送者一直在等待上层应用的<code>rdt_send(data)</code>调用，当收到后会执行三个操作：</p>
<ul>
<li>调用<code>make_pkt(data)</code>,将数据放到packet中</li>
<li>调用<code>udt_send(data)</code>，将packet 加上头部信息之后通过传输信道发送给接收端，但是因为这个传输信道是理想化的，所以并不会出现任何差错。</li>
</ul>
<p>所以说，在rdt1.0的情况下，发送者只有1个状态，并处于一个无限循环当中。</p>
<p>因此，我们把这种机制叫做<strong>停等</strong>，也就是在发送packet之后一直在等待返回信息。包括在后面的rdt2.x以及rdt3.0 都是在使用停等。</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/7.png" style="zoom:67%;"></p>
<p><strong>接受者：</strong></p>
<p>在接受者方，也只有一个状态。接收端收到分组以后，将封包解开，取出data，将其发送到上层应用。</p>
<h3 id="rdt2-0"><a href="#rdt2-0" class="headerlink" title="rdt2.0"></a>rdt2.0</h3><p>但事实上，错误是不可避免的，上面我们说了有两种方法：比特被重置了或者说是丢包了。现在我们先来看简单的情况——比特被重置了</p>
<p>之前在介绍UDP的时候，谈到了可以用检验和来判断比特是否被重置。现在的问题是发现比特被重置后该怎么恢复？现在是接受者收到数据错误，然后需要发送一个反馈信息告诉发送者，这个信息就是<code>NAK</code> ；同样的，当接受者收到的信息是正确的，那么就发送<code>ACK</code>给发送者。</p>
<p>下面是发送者和接收者的有限状态机FSM</p>
<p><strong>发送者：</strong> </p>
<ul>
<li>发送端等待上层传数据传进来</li>
<li>将数据和检验和打包为分组并将其发送到信道中</li>
<li>发送端进入<strong>等待返回信号状态</strong><ul>
<li>如果收到NAK则说明发送的数据有误则进行重传。判断条件是：<code>rdt_rcv(rcvpkt)&amp;&amp;isNAK(rcvpkt)</code></li>
<li>如果接受到ACK则数据无误，回到<strong>等待上层调用状态</strong>。判断条件是：<code>rdt_rcv(rcvpkt)&amp;&amp;isACK(rcvpkt)</code></li>
</ul>
</li>
</ul>
<p>因此这时候发送者的FSM中有两个状态,要注意这两个状态的变换条件。</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/8.png" style="zoom:67%;"></p>
<p><strong>接收端：</strong></p>
<ul>
<li>接收端收到资料</li>
<li>当数据分组接收到以后确认无误(判断条件是<code>rdt_rcv(rcvpkt)&amp;&amp;corrupt(rcvpkt)</code>)，会把数据提取出来，向上传递并发送ACK给发送方已确定数据无误。</li>
<li>当收到后发现有错误时(判断条件是<code>rdt_rcv(rcvpkt)&amp;&amp;corrupt(rcvpkt)</code>)，会传回NAK通知发送端重传。</li>
</ul>
<p>因此，rdt2.0的接收方只有一个状态，并处于一个循环当中</p>
<h3 id="rdt2-1"><a href="#rdt2-1" class="headerlink" title="rdt2.1"></a>rdt2.1</h3><p>现在的新问题是：在rdt2.0 时可能我发送的NAK或者ACK在传输过程中也会发生损坏。这时候接收端就无法区分反馈的信息到底是什么了。这时需要发送端重复发送。</p>
<p>针对rdt2.0中ACK/NAK受损可能会导致重传的问题，rdt2.1加入了<strong>序列号机制(sequence number)</strong>，分组的号码可以：</p>
<ul>
<li>让发送方知道是否需要重传。</li>
<li>让接受者确认，接收到的packet是否是重新传输的分组</li>
</ul>
<p>在这里，为了节省bit，该序号在当前协议中只使用 0和1 ，交替排列就可以了。发送第一个包裹的时候编号为0，第二个包裹时编号为1，第三个包裹时编号又变回0。这样一来，发送端和接收端都有了两种序号状态， 0 和 1 </p>
<p><strong>发送者</strong></p>
<p>这时候的发送者有4个状态：发送0，停等0；发送1，停等1</p>
<p>现在可能由四种情况：</p>
<ol>
<li>什么错误都没发生。 这时候，发送者发送编号为0的包裹，接收者收到以后发现数据正确，那么就会提取数据、向上抛出并返回一个ACK。发送者收到ACK之后，跳到下一个状态，等待编号为1的调用。</li>
<li>发送过去的数据出现损坏。这时接收方通过判断，返回一个编号为0的NAK，发送端接收到NAK的返回值，落入判断<code>corrupt(rcvpkt)||isNAK(rcvpkt)</code>后面的判断条件，然后重新发送packet</li>
<li>返回的ACK信号出现损坏。接收端成功接收0号包，返回ACK的同时进入下一个状态等待1号包；这时ACK出现了比特重置——ACK变成了NAK。发送端收到NAK后，会落入判断(<code>corrupt(rcvpkt)||isNAK(rcvpkt)</code>同时满足两个条件，前面这个条件是因为ACK出现重置)，会进行编号为0的packet的重传；接收方要等的是编号为1的包，结果却等来一个编号为0的包，那么这时候接收端并不会做任何操作(知道了是上一个ACK出了错误)，仍然返回ACK；最后当发送方终于收到ACK之后，会进入状态1，这时接收方和发送发都进入了状态1</li>
<li>返回的NAK信号出现损坏。接收端收到损坏的0号包，返回NAK并保持在状态0。但是在路上NAK发生了比特翻转，是否会让发送端误判而跑到状态1去呢？<strong>这种情况基本不会出现</strong>。因为在发送者判断isACK之前还有一个<code>notcorrupt(rcvpkt)</code>,这是用校验和来判断收到的包不存在比特重置情况的。因此这时候判定为<code>corrupt(rcvpkt)||isNAK(rcvpkt)</code>的前面那个条件，并重新发送编号为0的packet.</li>
</ol>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/9.jpg" style="zoom:67%;"></p>
<p>接收端也有状态0和状态1，因为上面已经将所有情况都做了一个梳理，这里就不详细讲了。</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/10.jpg" style="zoom:67%;"></p>
<h3 id="rdt2-2"><a href="#rdt2-2" class="headerlink" title="rdt2.2"></a>rdt2.2</h3><p>对于rdt2.1需要返回 NAK , ACK 两种状态, 可能太麻烦了，就将其<strong>全部改为ACK。只是返回的时候顺便返回序号</strong>。 也就是接收端收到包，不管正确与否，都返回 ACK ，同时附上序号，<strong>这个序号就是数据包发送过来时的序号</strong>。对上一条数据的重复确认就是对当前数据的否认。</p>
<p>还是上面几种情况</p>
<ul>
<li>什么错误都没发生</li>
<li>发送者发送的数据出现了问题。<ul>
<li>接收者收到出错的包之后，落入判定<code>corrupt(rcvpkt)||has_seq1(rcvpkt)</code>的前者。就返回一个编号为1的ACK，并留在状态0；</li>
<li>发送者收到编号为1的ACK之后，落入判定<code>corrupt(rcvpkt)||isACK(rcvpkt,1)</code>的后者，并重发编号为0的包</li>
</ul>
</li>
<li>接收者收到正确的包，并返回<code>(ACK,0)</code>、进入状态1。但是过程中出现了比特重置。<ul>
<li>发送者这方收到后，落入判定<code>corrupt(rcvpkt)||has_seq1(rcvpkt)</code> 的前者，因此会重新发编号为0的包。</li>
<li>这时，ACK等待的却是编号为1的包，因此会落入判定<code>(corrupt(rcvpkt)||has_seq0(rcvpkt))</code>的后者,并重新返回一个编号为0的ACK。</li>
</ul>
</li>
<li>接收者收到错误的包，返回编号为1的ACK，但是途图中出现了差错。<ul>
<li>发送者收到编号为1的ACK之后，落入判定<code>corrupt(rcvpkt)||isACK(rcvpkt,1)</code>的前者(也有可能是前后者并中)，然后重发编号为0的包。</li>
</ul>
</li>
</ul>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/12.png" style="zoom:67%;"></p>
<p>接收方的状态都已在上面说过，因此不再展开</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/13.png" style="zoom:67%;"></p>
<h3 id="rdt3-0"><a href="#rdt3-0" class="headerlink" title="rdt3.0"></a>rdt3.0</h3><p>上面所说的情况，都是在没有<strong>丢包</strong>的情况下进行的讨论。现在我们要引入丢包的情况了。</p>
<p>如果发生了丢包，那么解决的办法就是重发。那么什么时候重发呢？网络中的延时具有非常大的不确定性, 如果等待足够大的时延才重传分组显然会降低效率 。我们可以引入一个定时器，当反馈信息超过了一定的时间还是没有到达发送者，发送者就会重新发送。</p>
<p>下面是发送者的fsm: </p>
<p>第一个状态，收到上层调用后，发送编号为0的packet的同时启动一个timer，然后变成第二个状态</p>
<p>第二个状态，当超时之后，会重发packet并重启timer、继续等待编号为0的ACK；或者当收到包后却发现包裹损坏或编号为1的ACK。只有当收到包后、包没有损坏且是编号为0的ACK，发送者才会进入下一个状态。等待发送编号为1的packet</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/11.png" style="zoom:67%;"></p>
<p>接收者的状态和rdt2.2是一样的。</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/18.png" style="zoom:67%;"></p>
<p> 下面四张图描述了四种情况：</p>
<ul>
<li>数据没有丢失</li>
</ul>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/14.png" style="zoom:67%;"></p>
<ul>
<li>发送方的packet丢失</li>
</ul>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/15.png" style="zoom:67%;"></p>
<ul>
<li>接收方返回的ACK丢失</li>
</ul>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/16.png" style="zoom:67%;"></p>
<ul>
<li>提早超时/姗姗来迟的ACK</li>
</ul>
<p>这时候问题变得稍稍复杂了些,我们来细致分析：</p>
<ol>
<li>首先发送者从第三个状态开始，接收者从第二个状态开始。</li>
<li><strong>发送者</strong>发送了编号为1的包并启动了一个timer，转化为状态4；<strong>接收者</strong>收到没有损坏的且编号为1的包，并发送一个编号为1的ACK给发送者，状态转为等待来自下层的0</li>
<li>因为<strong>发送者</strong>这里超时了，落入<code>timeout-&gt;udt_send(sndpkt)</code>逻辑，重新发送编号为1的包并重新启动一个timer</li>
<li><strong>然而</strong>，在这时<strong>发送者</strong>却受到了来自接收者的ACK1(第一次)，于是就落入<code>rdt_rcv(rcvpkt)&amp;&amp;notcorrupt(rcvpkt)&amp;&amp;isAKC(rcvpkt,1)</code>这个判定，并重新回到状态1，等待上层编号为0的调用。上层调用之后，发送编号为0的一个新的包，同时去到状态2 ；</li>
<li><strong>接收者</strong>再次收到编号为1的packet(检测到了重复包)，落入<code>corrupty(rcvpkt)||has_seq1(rcvpkt)</code> 判断，这时接收者仍然保持状态1不变，并重新发送编号为1的ACK给发送者。</li>
<li><strong>发送者</strong>这时候再次收到了接收者重新发送的ACK1(第二次)，但它现在在状态2，等待的是一个编号为0的ACK，因此，<strong>发送者什么都不会做</strong>，直到再次超时并重新发送编号为0的包(第二个)。<strong>接收者</strong>收到了第一个编号为0的新包之后也返回一个编号为0的ACK</li>
<li><strong>发送者</strong>这时候收到了编号为0的ACK了，然后跳到状态三去了，等待上层编号为1的调用。当再次收到编号为0的ACK时，发送者什么也不做就行了。</li>
</ol>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/17.png" style="zoom: 50%;"></p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/18.png" style="zoom:67%;"></p>
<p>rdt3.0虽然规避了所有出错的可能，但是还是存在不足，比如：</p>
<ul>
<li>效率太慢，由于停等方式的存在，一个包没处理好，发送端在大部分时间都是一直等着。</li>
<li>关键我们要设置重发的等待时间，太长会导致通信太慢，用户体验差；太快则会出现发送者重发之后却收到了<strong>姗姗来迟</strong>的ACK/NAK。</li>
</ul>
<p>因此我们要考虑 <code>piplined protocols</code> 也就是说能不能像UDP一样，发送端一直在发送(一次性发送多个packet)？但是一直发送的时候由如何保证丢掉的包能被正确重发且顺序一致呢？</p>
<p>因此，下面来讨论两种<code>piplining</code>方案，每次发一批packet，来提高rdt3.0的效率。一个是<strong>回退N步</strong>的方法，另一种是selective repeat的方法，两者的很大的区别在于，要不要对一些乱序的包进行缓存？</p>
<h4 id="go-Back-N"><a href="#go-Back-N" class="headerlink" title="go-Back-N"></a>go-Back-N</h4><p>GBN 的策略是只保留顺序地包裹，剩下的乱序包全部丢弃并重新接受。有以下几个特点</p>
<ul>
<li>比如发送了123456，接收方只收到了1236，那么这时候就必须从4开始重新发送456三个包。</li>
<li>接收端也只会返回累计确认(cumulative ack),也就是只ack连续的包，像上面，虽然收到了1236，但是也只返回123的ack，并不会返回6的ack</li>
<li>发送端只给最早的没有被确认的包保留一个timer，当超时以后，会重新发送所有没有被确认的包</li>
</ul>
<p>比如说下图，前面绿色的是已经被确认的了，因此，现在窗口向右移动，到第一个尚未确认的包处。这样能保证窗口左边的包是已确认且按照顺序排列的。黄色的包是发送了，但是还没有收到ack确认；蓝色的包是还没有被发送，但在窗口之内、等待发送的，我们把第一个蓝色的包所在的位置叫做 <code>nextseqnum</code>即下一次待发的序列。同时，为最老的一个未确认的包保持一个timer，当超时的时候，从这个<code>send_base</code>开始，向后重新按顺序发送黄色的包。 </p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/21.png" style="zoom:67%;"></p>
<p><strong>sender</strong> 的状态机，只有一个状态，始终在等待。</p>
<ul>
<li>接到发送请求后，开始发包，刚开始nextseqnum和base是在一个位置的，因此发送第一个包之后就会启动计时器。每发一个包之后，<code>nextseqnum</code>就要自增1。 需要发包时要判断，下一个待发的包的序号是否已经超过了窗口大小，否则就拒发</li>
<li>如果超时，那么重开一个timer，并从base开始将<strong>已发送但却没确认的所有包</strong>都重新发送</li>
<li>如果收到了包裹且没有损坏，那么窗口就要像右边移动一个位置。同时要判断base窗口右端是否已经移动到<code>nextseqnum</code>。如果移到了，说明在未超时的情况下，发送的包全部收到了ack确认，那么就可以停止老的timer了；否则，timer要重新开始计时，因为这时<strong>最老的包已被确认</strong>，倒数第二老的包变成了最老的未确认的包</li>
<li>如果收到的包是损坏的，那么什么也不用做；如果收到的包是重复的ack，因为<code>base=getacknum(rcvpkt)+1</code>所以也不会有任何变化</li>
</ul>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/19.png" style="zoom:67%;"></p>
<p><strong>receiver</strong> 的状态机</p>
<p>在收到包之后，首先判断是否损坏，其次判断是否符合序列，两者满足，才会返回ack确认</p>
<p>如果收到了乱序的包(比如之前123，突然收到了6)，那么接收者就会<strong>丢弃</strong> ，不将其放入缓存，并同时返回一个最新有序包的序号的ack确认信息(将6丢弃，并返回ack3)</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/20.png" style="zoom:67%;"></p>
<h5 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h5><p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/22.png" style="zoom:67%;"></p>
<p>这个例子可以来描述一下上面讲的状态机的操作。</p>
<ul>
<li>首先发送者发了0123一共四个包，其中3在运输图中损坏</li>
<li>接收者收到pkt0(符合序列)，返回ack0；收到pkt1(符合序列)，返回ack1；收到pkt3(不符合序列)，返回ack1</li>
<li>发送者收到ack0，窗口右移1位，同时发送pkt4；发送者受到ack1，再右移一位，同时发送pkt5。</li>
<li>接收者收到pkt4(不符合序列)，返回ack1；收到pkt5(不符合序列)，仍然返回ack1</li>
<li>发送者维持的最古老的计时器这时候超时了，将从base开始(此时是2)，连续发送，将已发送但却没确认的所有包都重新发送，这里是重发2345</li>
</ul>
<h4 id="selective-repeat"><a href="#selective-repeat" class="headerlink" title="selective repeat"></a>selective repeat</h4><p>SR 策略是在接收端对乱序包进行缓存，并告知发送端未收到、需要重传的包。有以下几个特点</p>
<ul>
<li>比如说发送了123456，接收方只收到了1236，那么接收端就会为1236各自发一个ack确认。并要求发送端重传45</li>
<li>发送端为每一个未被确认的包保留了一个timer，当特定的timer超时后，就发送特定的packet</li>
<li>效率更高但是需要更大的缓存</li>
</ul>
<p>原理如下图所示</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/23.png" style="zoom:67%;"></p>
<p>用一个具体的例子来解释：</p>
<ul>
<li>发送者发送0123，但是2在途中丢失</li>
<li>接收者收到了pkt0，返回ack0；收到pkt1，返回pkt1；收到pkt3,返回pkt3</li>
<li>发送者收到ack0，窗口右移并发送pkt4；收到ack1，继续右移并发送pkt5</li>
<li>接收者收到pkt4,返回ack4；收到pkt5，返回ack5;</li>
<li>这时候发送者这里pkt2的timer超时了，所以重发pkt2；同时收到了ack4和ack5，但是收到的ack345和ack01并不是连续的，因此窗口并不需要移动</li>
<li>等到发送者终于收到ack2的时候，因为ack345都已经收到了，因此窗口会一下子向右移4位</li>
</ul>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/24.png" style="zoom:67%;"></p>
<p><strong>问题来了</strong>，现在有一个情况，就是说在发送者和接收者之间，实际上是看不到对方的窗口的，就像隔了一层帘子一样。如下图所示</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/25.png" style="zoom: 50%;"></p>
<p>现在，发送序列为：0123012，窗口大小为3.</p>
<p><strong>发送者所看到的：</strong> 自己发送pkt012之后，却没有等来ack012，因此当超时之后，会重新发送pkt0</p>
<p><strong>接收者所看到的：</strong> 自己收到了pkt012之后，返回ack012，并且窗口向右移3位，现在接受者的窗口等待的是pkt301；但是现在接收者收到了发送者重新发送的pkt0，因此，接收者便无法判断这个pkt0到底是发送者重发的还是新的pkt0.</p>
<p>现在我们把窗口的大小调整为2，重复刚才的情况：我们发现，现在当ack01丢失的时，发送者再次发送pkt0，但是现在接收者的窗口仅仅移动到了23，因此再次收到pkt0的时候，接收者就会认为这是之前pkt0，因此什么也不用做。</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/3.jpg" style="zoom: 33%;"></p>
<p>那么，窗口大小和序号长度之间的关系是什么呢？可以发现，应该是<strong>发送者窗口大小+接收者窗口大小&lt;= 序号空间大小</strong>，又发送者和接收者的窗口大小相同，因此 <strong>窗口大小&lt;=序号空间大小/2</strong> </p>
<p>但是对于GBN，就不需要满足<strong>窗口大小&lt;=序号空间大小/2</strong> 。因为GBN的策略是，收到的如果不是我当前在等待的包，我就全都不要。那刚才SR出现错误的情况来说：当接受者收到pkt012之后，返回ack012，并将窗口移动到 301，此时接受者<strong>只要pkt3</strong>。因此当发送者因为超时重新发送pkt012时，接受者收到了也会直接丢掉，并不会发生歧义。</p>
<p>但是这并不是意味着GBN情况下窗口大小就没有限制，如果我们序列变成012012，窗口仍然为3，那么这时候也会出现上面那样的歧义了。因此在GBN情况下，需要满足<strong>窗口大小&lt;=序号空间大小-1</strong> </p>
<h2 id="面向连接的运输：-TCP"><a href="#面向连接的运输：-TCP" class="headerlink" title="面向连接的运输： TCP"></a>面向连接的运输： TCP</h2><p>UDP是一种没有复杂的控制、提供无连接通信服务的一种协议，他将部分控制部分交给应用程序去处理，自己只提供作为传输层最基本的功能。</p>
<p>但是，和UDP不同的是，TCP的协议要比UDP的功能多很多</p>
<p>TCP 被称为一种<strong>面向连接(connection-oriented)</strong> 的协议，这是因为一个应用程序在向另一个应用程序发送数据之前，这<strong>两个进程必须先进行握手</strong>，握手是一个<strong>逻辑连接</strong>。</p>
<p>一旦主机A和主机B建立了连接，那么进行通信的两个应用程序只使用虚拟的通信线路发送和接收数据就可以保证数据的传输，TCP协议负责控制连接的建立、断开、保持等工作。</p>
<ul>
<li>TCP连接<strong>全双工服务(full-duplex service)</strong>的，全双工就是指主机A与另外一个主机B存在一条TCP连接，那么应用程序的数据就可以从主机B流向主机A的同时，也从主机A流向主机B</li>
<li>TCP只能进行<strong>点对点(point-to-point)</strong>连接，那么所谓的<strong>多播</strong>，即一个主机对多个接收方发送消息的情况是<strong>不存在的</strong>，TCP连接只能连接一对主机</li>
<li>一旦TCP连接建立后，主机之间就可以相互发送应用数据了，客户进程通过套接字传送数据流。一旦数据通过套接字后，它就由客户中的TCP协议所控制</li>
</ul>
<p>TCP会将数据临时存储到连接的<strong>发送缓存</strong>中，这个send buffer是三次握手之间设置的缓存之一，然后TCP在合适的时间将发送缓存中的数据发送到目标主机的接收缓存中，实际上<strong>每一端都会有发送缓存和接收缓存</strong>，如下图所示。</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/26.png" style="zoom: 67%;"></p>
<ul>
<li>主机之间的发送是用<strong>报文段(segment) </strong>进行的，那么<strong>什么是报文段</strong>呢？<ul>
<li>TCP会将要传输的数据流分为多个<strong>块(chunk)</strong>,然后将每个chunk中添加tcp标头，这样就形成了一个报文段。每一个报文段可以传输的长度是有限的，不能超过<strong>最大数据长度(Maximum Segment Size)</strong> ，俗称<code>MSS</code> 。在报文段向下传输的过程中，会经过链路层，连路程有一个<strong>最大传输单位(Maximum Transmission Unit)</strong>,简称<code>MTU</code>,即数据链路层上所能通过最大数据包的大小(通常和通信接口有关)</li>
<li>MSS和MTU是在不同分层的不同定义。 <strong>MTU可以认为是网络层能够传输的最大IP数据包，MSS可以认为是传输层的概念，也就是TCP数据报能够传输的最大量</strong></li>
<li>从MSS的定义可以看出，MSS字段只是<strong>数据字段</strong>最大的长度，是不包含任何头部信息的！</li>
</ul>
</li>
</ul>
<h3 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h3><p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/27.png" style="zoom: 67%;"></p>
<p>TCP 报文段结构比UDP的报文段结构要多了很多内容，但是前两个16比特的字段是一样的。也就是<strong>源端口号</strong>和<strong>目标端口号</strong> ，这是用于多路复用和多路分解的。此外，和UDP一样，TCP也包含<strong>校验和</strong>，除此之外，TCP报文还有：</p>
<ul>
<li>32 比特 的<strong>序号字段(sequence number field)</strong> 和32 比特的<strong>确认号字段(acknowlegment number field)</strong>. 这些字段被TCP 发送方和接收方用来实现可靠的数据传输。</li>
<li>4比特的<strong>首部字段长度(header length field)</strong>,这个字段指示了以32比特的字为单位的TCP首部长度。TCP首部的长度是可变的，但是<strong>在通常情况下，选项字段为空</strong>，所以TCP首部字段的长度为20字节。</li>
<li>16比特的<strong>接受窗口字段(receive window field)</strong>,这个字段用于流量控制。它用于指示接收方能够/愿意接受的字节数量</li>
<li>可变的<strong>选项字段(options field)</strong>，这个字段用于发送方和接收方协商最大报文长度(MSS) 时使用</li>
<li>6 比特 的标志字段<ul>
<li><code>ACK</code>  标志用于确认字段中的值是有效的，这个报文段包括一个队已被成功接收报文段的确认</li>
<li><code>RST</code>、<code>SYN</code>、<code>FIN</code> 标志用于连接的建立和关闭</li>
<li><code>CWR</code> 和 <code>ECE</code> 用于拥塞控制</li>
<li><code>PSH</code> 用于表示立刻将数据交给上层处理</li>
<li><code>URG</code> 标志用来表示数据中存在需要被上层处理的紧急数据</li>
</ul>
</li>
<li><strong>紧急数据指针字段(urgent data point field)</strong>  用于指出紧急数据的最后一个字节。一般来说 紧急数据指针字段、PSH和URG 都是不用的</li>
</ul>
<h4 id="序号、确认号是干嘛的？"><a href="#序号、确认号是干嘛的？" class="headerlink" title="序号、确认号是干嘛的？"></a>序号、确认号是干嘛的？</h4><p>TCP 报文段首部中最重要的两个字段就是<strong>序号</strong>和<strong>确认号</strong>，这两个字段是TCP实现可靠性的基础。首先我们要来看一下这两个字段里面存放的内容：</p>
<p><strong>一个报文段的序号就是数据流的字节编号。</strong> 因为TCP会把数据流分割成为一段一段的字节流，因为字节流本身是有序的，所以每一段的字节编号就在标示是哪一段的字节流。比如说，主机A要给主机B发送一条数据，数据经过应用层之后会有一串数据流，数据流经过TCP分割(分割的依据就是MSS)。</p>
<p>假设数据是10000字节，MSS是2000字节，那么TCP就会把数据拆分成 0-1999,2000-3999 …   </p>
<p>首字节编号依次是0，2000 …..</p>
<p>然后每个序号会被填入TCP报文段首部的序号字段中，如下图所示</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/0.png" style="zoom: 67%;"></p>
<p>首先，我们要知道TCP是一种全双工的通信协议，如下图所示：</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/28.png" style="zoom: 67%;"></p>
<p>因此，主机A在向主机B发送消息的过程中，也在接收来自主机B的数据。<strong>主机A填充进报文段的确认号是期望从主机B收到的下一字节的序号</strong>(这可能会比较绕)。代表确认号以前的所有数据都正常收到了， 如下图所示：</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/33.png" style="zoom: 67%;"></p>
<p>再举一个小栗子：</p>
<p>假设主机A通过一条TCP连接向主机B发送两个紧挨着的TCP报文段. 第一个报文段的序号为90, 第二个报文段序号为110.</p>
<p>a. 第一个报文段中有多少数据?<br>答: 110 - 90 = 20个字节.</p>
<p>b. 假设第一个报文段丢失而第二个报文段到达主机B. 那么在主机B发往主机A的确认报文中, 确认号应该是多少?<br>答: 90. 因为之前主机B给主机A发送的ACK就是90，说明90以前的报文我都收到了，主机A才会发送90给主机B</p>
<h4 id="延时确认机制"><a href="#延时确认机制" class="headerlink" title="延时确认机制"></a>延时确认机制</h4><p>接收方在收到数据后，并不会立即回复ACK,而是延迟一定时间。<br>一般ACK延迟发送的时间为200ms，但这个200ms并非收到数据后需要<br>延迟的时间。系统有一个固定的定时器每隔200ms会来检查是否需要发送ACK包。这样做有两个目的。<br>1、这样做的目的是ACK是可以合并的，也就是指如果连续收到两个TCP包，并不一定需要ACK两次，只要回复最终的ACK就可以了，可以隆低网络流量。<br>2、如果接收方有数据要发送，那么就会在发送数据的TCP数据包里，带上ACK信息。这样做，可以避免大量的ACK以一个单独的丁CP包发<br>送，减少了网络流量。</p>
<h3 id="传输可靠性"><a href="#传输可靠性" class="headerlink" title="传输可靠性"></a>传输可靠性</h3><p>首先我们来看 TCP 发送者的<strong>有限状态机</strong></p>
<ul>
<li>初始状态时 ， SendBase(基础窗口)=NextSeqNum= InitialSeqNum</li>
<li>当TCP收到上层应用传来的数据时，会生成报文段，然后把报文段传给下层网络层。同时，将NextSeqNum加上<strong>这次传送数据的长度</strong>，得到一个新的NextSeqNum。 如果当前没有启动计时器的话，就启动一个计时器</li>
<li>如果计时器超时，因为是累计确认机制，那么从还没有ack的最小的序号包开始重传并重新计时。</li>
<li>如果收到了ACK，那么就需要判断ACK的值y(等于Next)是否大于SendBase。如果大于，不管是不是等于 <code>NextSeqNum+length(data)</code>(根据累计确认的机制，有可能ACK在途中丢包了，收到的ACK远远大于当前的SendBase,那也不管，说明接收者肯定收到了)，那么<strong>更新SendBase</strong>。 然后，还要判断是否还有未被确认的报文段，如果有的话就重新开一个计时器，如果没有就暂停计时器</li>
</ul>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/34.png" style="zoom: 67%;"></p>
<h4 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h4><p>什么时候回出现重传呢？</p>
<ul>
<li><p>如果Ack丢失，那么当sender保留的计时器超时的时候，就会重发原来的包</p>
</li>
<li><p>当出现早超时的情况，发出 seq=92, 8bytes of data 之后，才收到了ACK100和新的ACK120。 那么由于累计确认的机制，说明ACK120之前的所有数据都已经被接收了。因此HostB收到seq=92, 8bytes of data之后仍然返回ACK120。而主机A也并不需要再次等待ack100的信息了，且主机A的SendBase在收到ACK120的时候就已经移动到120了。</p>
<ul>
<li><blockquote>
<p>TCP 通过ACK 来实现可靠的数据传输，当主机A将数据发出之后会等待主机B的响应。如果有ACK，说明数据已经成功到达对端。反之，数据很有可能丢失。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/35.png" style="zoom: 67%;"></p>
<p>我们就拿下面这个模拟图来说一下<strong>累计确认机制(GBN所采用的)</strong>，顺便也回答一下为什么在sender收到ack后，只要判断y值大于sendBase 而不用等于 <code>NextSeqNum+length(data)</code> 这个问题。</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/36.png" style="zoom: 67%;"></p>
<p>首先主机A发送了两个packet，一个Seq=92, 8 bytes 长；一个Seq=100,20bytes长。 主机B已经收到了这两个包，并返回 ack100和ack120。 然而，这时候ack100的信息却在传输途中丢失了，只有ack120到达了主机A。所以说，如果主机A收到了 大于<code>NextSeqNum+length(data)</code> 的ACK确认信息，这说明说明ACK120之前的所有数据都已经被主机B接收了，因此主机A并不需要傻傻等着ACK=100的消息。只需直接更新sendBase即可。</p>
<p>值得注意的是，在接收端，也是有<strong>缓存机制(SR所采用的)</strong>，也就是收到不连续的包会进行缓存，而不是像GBN那样直接丢掉。因此，TCP可以看做是GBN和SR的一种结合</p>
<h5 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h5><p>除了刚才说的超时会导致重传, TCP还具有快速重传机制，这是针对 time-out 时间过长导致用户体验变差的情况而设计的。</p>
<p>快速重传就是说，发送者会通过接收到重复的ACK信息来察觉到丢包的情况——如果发送者连续收到<strong>3个</strong>相同的ack信息，那么就会直接在丢包处进行重发，而不必再等到time-out之后再重发。如下图所示：</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/37.png" style="zoom: 67%;"></p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>流量控制就是说，当发送端连续发送太多数据的时候，接收端可能来不及处理那么多的数据，导致溢出。因此我们有时候需要<strong>通过接收端来控制发送端的发送速率</strong>，来让接收者的buffer可以容纳发送来的数据而不溢出。</p>
<p>接收者的协议栈如下图所示，在IP层收到的报文段会向上传递，存放在 TCP receiver buffer中，上层应用层会从buffer中取出数据。</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/38.png" style="zoom: 67%;"></p>
<p>TCP 缓冲区的内部结构如下图所示，分为已缓存区域和空闲缓存其余。其中，空闲缓存区域可以看做是一个接受窗口<code>rwnd</code>，TCP 接收者在发给TCP发送者的报文中会有 rwnd的大小(16比特的接受窗口字段)，因此发送者就可以通过实时的rwnd大小来控制发包的速度。</p>
<p>发送者要控制已发送但还未<code>acked</code> 的 <code>pkt</code> 的数量<strong>小于等于</strong>  <code>rwnd</code> ，才能保持不因为溢出而丢包</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/39.png" style="zoom: 67%;"></p>
<h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/31.png" style="zoom: 67%;"></p>
<ol>
<li>第一步: 客户端TCP向服务器端的TCP发送一个特殊的TCP报文段, 该报文段不包含应用层数据. 报文段首部中的标志位SYN置1, 简称为SYN报文段. 同时客户端随机选取一个初始序列号x, 放置于SYN报文段的序号字段中, 最后把该报文段经下层封装发送给服务器. SYN的意思是: xxx服务器, 我想向你发起TCP连接, 我的初始序号为x.</li>
<li>第二步: 服务器收到SYN报文段后, 响应一个SYNACK报文段. SYNACK报文段的SYN标志位置1, 确认号字段设置为x + 1, 序号字段由服务器选择自己的初始序号 y. SYNACK报文段的意思是: 我收到了你的SYN报文段, 序号为x, 我同意该连接, 我自己的序号为y. 现在请求你的 x+1的报文段</li>
<li>第三步: 客户端接收到SYNACK后要告知服务器自己收到了. 于是发送最后一个报文段, SYN标志位置0, 把确认字段设置为y + 1, 并设置自己的序号为x+1. 这个报文意思是: 好的, 我知道你同意了, 我们开始传输数据吧.</li>
</ol>
<p><strong>为什么握手不能是两次呢？</strong></p>
<p>TCP连接就像男女朋友谈恋爱，如果只有两次握手，女孩子可能就不知道，她的那句我也爱你，男孩子是否收到，恋爱关系就不能愉快展开。</p>
<p><strong>为什么握手不能是四次呢？</strong></p>
<p>因为握手不能是四次呢？因为三次已经够了，三次已经能让<strong>双方都知道</strong>：你爱我，我也爱你。而四次就多余了。</p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/40.png" style="zoom: 67%;"></p>
<ol>
<li>首先客户端TCP向服务器发送一个特殊的TCP报文段, 其中FIN标志位被置1，<code>(FIN=1，seq=x)</code>, 发送完之后，客户进入 <code>FIN_WAIT_1</code> 状态，等待一个来自服务器的，带有ack的报文段</li>
<li>服务器收到该报文段后就进入CLOSE_WAIT 状态，并向发送方发送一个确认报文段,<code>(ACK=1，ack=x+1,seq =v)</code>，客户端收到后，进入 <code>FIN_WAIT_2</code>状态， 等待一个来自服务器的，FIN 被置为1 的报文段</li>
<li>然后服务器发送自己的终止报文段, 同样是把FIN位置1, <code>(FIN=1，ACK1,seq=y,ack=x+1)</code>.</li>
<li>最后客户端收到之后，进入<code>TIME_WAIT</code> 状态，并发送一个带有ACK的报文给server, <code>(ACK=1，seq=x+1,ack=y+1)</code></li>
<li>在 TIME_WAIT 状态中经过一段时间后，连接就正式关闭，客户端所有资源(包括端口号)，都将被释放</li>
</ol>
<ul>
<li>两次挥手行不行? 就是客户端提出关闭, 服务器响应后TCP就结束.</li>
<li>答: 不行, 因为客户单方面提出关闭的话, 服务器还是可以向客户端发送数据, 必须双方都提出关闭并得到确认后TCP连接才算关闭.</li>
</ul>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>有了TCP的窗口控制后，使计算机网络中两个主机之间不再是以单个数据段的形式发送了，而是能够连续发送大量的数据包。然而，大量数据包同时夜伴随着其他问题，比如说网络负载、网络拥堵等问题。TCP因此使用了<strong>拥塞控制</strong>机制，使得在面临网络拥塞时遏制发送方的数据发送。</p>
<p>拥塞控制主要有两种方法</p>
<ul>
<li><strong>端到端的拥塞控制</strong>：  因为网络层没有为运输层拥塞控制提供显示支持。所以即使网络中存在拥塞情况，端系统也要通过对网络行为的观察来推断。<strong>TCP 就是使用了端到端的拥塞控制方式</strong>。IP 层不会向端系统提供有关网络拥塞的反馈信息。那么 TCP 如何推断网络拥塞呢？<strong>如果超时或者三次冗余确认就被认为是网络拥塞，TCP 会减小窗口的大小，或者增加往返时延来避免</strong>。</li>
<li><strong>网络辅助的拥塞控制</strong>:  在网络辅助的拥塞控制中，路由器会向发送方提供关于网络中拥塞状态的反馈。这种反馈信息就是一个比特信息，它指示链路中的拥塞情况。</li>
</ul>
<h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>除了序号和确认号之外，TCP的拥塞控制也是实现TCP可靠性的基础。</p>
<p>TCP 所采用的方法是让每一个发送方根据所感知到的网络的拥塞程度来限制发出报文段的速率，如果 TCP 发送方感知到没有什么拥塞，则 TCP 发送方会增加发送速率；如果发送方感知沿着路径有阻塞，那么发送方就会降低发送速率。</p>
<blockquote>
<p>但是这种方法有三个问题</p>
<ol>
<li>TCP 发送方如何限制它向其他连接发送报文段的速率呢？</li>
<li>一个 TCP 发送方是如何感知到网络拥塞的呢？</li>
<li>当发送方感知到端到端的拥塞时，采用何种算法来改变其发送速率呢？</li>
</ol>
</blockquote>
<h5 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h5><p>我们先来讨论，TCP发送方如何限制它向其他连接发送报文段的速率呢？</p>
<p>我们知道，TCP是由接收缓存、发送缓存等组成。发送方的TCP拥塞控制机制会跟踪一个变量，即<strong>拥塞窗口</strong>的变量，拥塞窗口表示为<code>cwnd</code>, <strong>用于限制TCP在接收到ACK之前可以发送到网络的数据量</strong>，而<strong>接收窗口</strong>是用来告诉接收方能够接受的数据量</p>
<p>一般来说，发送方未确认的数据量不得超过 cwnd 和 rwnd 的最小值，也就是</p>
<script type="math/tex; mode=display">
LastByteSent - LastByteAcked <= \min(cwnd,rwnd)</script><p>由于每个数据包的往返时间是RTT，我们假设接收端有足够的缓存空间用于接收数据，我们就不用考虑rwnd了了，只用专注于cwnd，那么，该发送方的 <code>发送速率 = cwnd/RTT 字节/秒</code> . 通过调节cwnd，发送方因此能调整它向连接发送数据的速率。</p>
<h5 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h5><p><strong>一个 TCP 发送方是如何感知到网络拥塞的呢</strong>？</p>
<p>这个我们上面讨论过，是 TCP 根据<strong>超时</strong>或者 <strong>3 个冗余 ACK(丢包了)</strong> 来感知的。</p>
<h5 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h5><p><strong>当发送方感知到端到端的拥塞时，采用何种算法来改变其发送速率呢</strong> ?</p>
<p>这个问题比较复杂，一般来说，TCP 会遵循下面这几种指导性原则</p>
<ul>
<li>如果在报文段发送过程中丢失，那就意味着网络拥堵，此时需要适当降低 TCP 发送方的速率。</li>
<li>一个确认报文段指示发送方正在向接收方传递报文段，因此，当对先前未确认报文段的确认到达时，能够增加发送方的速率。为啥呢？因为未确认的报文段到达接收方也就表示着网络不拥堵，能够顺利到达<strong>，因此发送方拥塞窗口长度会变大，所以发送速率会变快.</strong> 此时发送速率就等于 <strong>cwnd/rtt</strong></li>
<li><code>带宽探测</code>，带宽探测说的是 TCP 可以通过调节传输速率来增加/减小 ACK 到达的次数，如果出现丢包事件，就会减小传输速率。因此，为了探测拥塞开始出现的频率， TCP 发送方应该增加它的传输速率。然后慢慢使传输速率降低，进而再次开始探测，看看拥塞开始速率是否发生了变化。</li>
</ul>
<p>在了解完 TCP 拥塞控制后，下面我们就该聊一下 TCP 的 <code>拥塞控制算法(TCP congestion control algorithm)</code> 了。TCP 拥塞控制算法主要包含三个部分：<strong>慢启动、拥塞避免、快速恢复</strong>，下面我们依次来看一下</p>
<h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><p>当一条 TCP 开始建立连接时，cwnd 的值就会初始化为<strong>一个 MSS</strong>的较小值。这就使得初始发送速率大概是 <code>MSS/RTT 字节/秒</code> ，比如要传输 1000 字节的数据，RTT 为 200 ms ，那么得到的初始发送速率大概是 40 kb/s 。实际情况下可用带宽要比这个 MSS/RTT 大得多，因此 TCP 想要找到最佳的发送速率，可以通过 <code>慢启动(slow-start)</code> 的方式，在慢启动的方式中，cwnd 的值会初始化为 1 个 MSS，并且每次传输报文确认后就会增加一个 MSS，cwnd 的值会变为 2 个 MSS，这两个报文段都传输成功后每个报文段 + 1，会变为 4 个 MSS，依此类推，每成功一次 cwnd 的值就会翻倍。如下图所示 </p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/41.png" style="zoom: 67%;"></p>
<p>发送速率不可能会一直增长，增长总有结束的时候，那么何时结束呢？慢启动通常会使用下面这几种方式结束发送速率的增长。</p>
<ul>
<li>如果在慢启动的发送过程出现丢包的情况，那么 TCP 会将发送方的 cwnd 设置为 1 并重新开始慢启动的过程，此时会引入一个 <code>ssthresh(慢启动阈值)</code> 的概念，它的初始值就是产生丢包的 cwnd 的值 / 2，即当检测到拥塞时，ssthresh 的值就是窗口值的一半。</li>
<li>第二种方式是直接和 ssthresh 的值相关联，因为当检测到拥塞时，ssthresh 的值就是窗口值的一半，那么当 cwnd &gt; ssthresh 时，每次翻番都可能会出现丢包，所以最好的方式就是 cwnd 的值 = ssthresh ，这样 TCP 就会转为拥塞控制模式，结束慢启动。</li>
<li>慢启动结束的最后一种方式就是如果检测到 3 个冗余 ACK，TCP 就会执行一种快速重传并进入<code>快速恢复</code>状态。</li>
</ul>
<h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><p>当 TCP 进入拥塞控制状态后，cwnd 的值就等于拥塞时值的一半，也就是 ssthresh 的值。所以，无法每次报文段到达后都将 cwnd 的值再翻倍。而是采用了一种相对<code>保守</code>的方式，每次cwnd窗口大小的报文都传输完成后只将 cwnd 的值增加<code>一个 MSS</code>，比如收到了 10 个报文段的确认，但是 cwnd 的值只增加一个 MSS。</p>
<p>因此线性增加的公式为：<code>cwnd = cwnd + MSS*(1/窗口数)</code></p>
<p>这是一种线性增长模式，它也会有增长逾值，它的增长逾值和慢启动一样，如果出现丢包，那么 cwnd 的值就是一个 MSS，ssthresh 的值就等于 cwnd 的一半；或者是收到 3 个冗余的 ACK 响应也能停止 MSS 增长。</p>
<p>如果 TCP 将 cwnd 的值减半后，仍然会收到 3 个冗余 ACK，那么就会将 ssthresh 的值记录为 cwnd 值的一半，进入 <code>快速恢复</code> 状态。</p>
<h4 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h4><p>快恢复算法，其过程有以下两个要点：</p>
<ol>
<li>当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢启动门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢启动算法，而进行快速恢复算法</li>
<li>由于发送方现在认为网络很可能没有发生拥塞，因此与慢v不同之处是现在不执行慢启动算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后+3*MSS的数值。 此后，对于使 TCP 进入快速恢复状态缺失的报文段，对于每个收到的冗余 ACK，cwnd 的值都会增加一个 MSS 。直到当丢失报文段的一个 ACK 到达时，TCP 在降低 cwnd 后进入拥塞避免状态。如果在拥塞控制状态后出现超时，那么就会迁移到慢启动状态，cwnd 的值被设置为 1 个 MSS，ssthresh 的值设置为 cwnd 的一半。</li>
</ol>
<p>这里，快速恢复把开始时的拥塞窗口cwnd值再增大一点，即等于 <strong>ssthresh + 3 X MSS</strong> 。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组<strong>不再消耗网络的资源而是停留在接收方的缓存</strong>中。可见现在网络中并不是堆积了分组而是减少了三个分组。因此可以适当把拥塞窗口扩大了些。</p>
<p>整一个TCP拥塞控制的用有限状态机如下：</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/42.png" style="zoom: 67%;"></p>
<p>当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。<br>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。<br>当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。</p>
<p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要<strong>迅速减少</strong>主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。 </p>
<p>整一个过程如下图所示：</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82%E6%80%BB%E7%BB%93/43.png"></p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h3><p>考虑从主机A向主机B传输L字节的大文件，假设MSS为536字节。</p>
<ul>
<li>为了使得TCP序号不至于用完，L的最大值是多少？(TCP序号字段为4字节)</li>
<li>对于在上题中得到的L，求出传输此文件需要用多长时间？假设运输层、网络层和数据链路层首部<strong>总共为</strong>66字节，并加载每个报文段上，然后经155Mbps链路发送得到的分组。忽略流量控制和拥塞控制，使主机A能够一个接一个和连续不断得发送这些报文段</li>
</ul>
<p>答：TCP是<strong>字节流</strong>编号的，而TCP序号字一共有4字节。因此可供编码位数为32位，则$L_{\max} = 2^{32}$ byte</p>
<p>对于第二题，我们首先要求要发送的报文总数</p>
<p>$N=\lceil \frac{2^{32}}{536}\rceil = 801299$  </p>
<p>则需要发送的总长度为：$2^{32}+801299\times 66~byte = 4.824\cdot10^9$ byte</p>
<p>最后，我们要用总长除以链路传输速率，$t=4.824\cdot 10^9 bytes/155Mbps=249s$</p>
<h3 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h3><p>比较GBN、SR和TCP （无延时的ACK）。假设对所有3个协议的超时值足够长，使得5个连续的数 据报文段及其对应的ACK能够分别由接收主机（主机B）和发送主机（主机A）收到（如果在信 道中无丢失）。假设主机A向主机B发送5个数据报文段，并且第二个报文段（从A发送）丢失。 最后，所有5个数据报文段已经被主机B正确接收。</p>
<p>a. 主机A总共发送了多少报文段和主机B总共发送了多少ACK?它们的序号是什么？对所有3个 协议回答这个问题。</p>
<ul>
<li>对于GBN， A发送的报文段顺序为：123452345 (一共9个);  B发送的ACK: 11112345 (第二个包裹没收到，第345收到的时候仍然传回ack1，因为是累计确认机制，因此一共8个)</li>
<li>对于SR，A发送的报文段顺序为：123452(一共6个，选择确认)，B发送的ACK：13452(一共5个)</li>
<li>对于TCP，A发送的报文段顺序为：123452(一共6个，选择确认)，B发送的ACK: 22226(累计确认，发送ack2代表2以前的包都已接收)</li>
</ul>
<p>b. 如果对所有3个协议超时值比5RTT长得多，则哪个协议在最短的时间间隔中成功地交付所有5 个数据报文段？</p>
<p>对于GBN来说，需要等到最早的计时器(对于2)timeout时，才会重传2345，时间最长</p>
<p>对于SR来说，只有当专属于2的计时器timeout时，才会重传pkt2，因此时间必然长于5rtt</p>
<p>对于TCP来说，因为存在快速重传机制，导致发送端A在收到连续三个相同的ACK时，就会重传2. 因此采用TCP最快</p>
<h3 id="3-1"><a href="#3-1" class="headerlink" title="3"></a>3</h3><p>考虑仅有一条单一的TCP （Reno）连接使用一条10Mbps链路，且该链路没有缓存任何数据。假设 这条链路是发送主机和接收主机之间的<strong>唯一拥塞链路</strong>。假定某TCP发送方向接收方有一个大文件要 发送，而接收方的接收缓存比拥塞窗口要大得多。我们也做下列假设：每个TCP报文段长度为1500 字节；该连接的双向传播时延是150ms；并且该TCP连接<strong>总是处于拥塞避免阶段</strong>，即<strong>忽略了慢启动</strong>。</p>
<p>a.这条TCP连接能够取得的<strong>最大窗口长度</strong>（以报文段计）是多少？根据<code>发送速率 = cwnd/RTT 字节/秒</code>可知：</p>
<p>最大窗口长度可以由这个公式来计算： 最大窗口长度$\times MSS/ RTT = $链路速度</p>
<script type="math/tex; mode=display">
L_m = 10Mbps\times RTT/ MSS\\~\\
=10\times10^6 \times 0.15s/150\times 8 =125</script><p>b. 这条TCP连接的平均窗口长度（以报文段计）和平均吞吐量（以bps计）是多少？</p>
<p><strong>平均窗口长度：拥塞避免阶段所以窗口大小在W/2和W之间变化，所以平均窗口大小为0.75W=125x0.75=94[93.75的上限]</strong></p>
<p><strong>平均吞吐量：94x1500x8/0.15s=7.52Mbps</strong></p>
<p>c. 这条TCP连接在从丢包恢复后，再次到达其最大窗口要经历多长时间?</p>
<p>我们知道拥塞避免算法中cwnd是线性增长的，每次收到ack后cwnd增加一个MSS</p>
<p><strong>丢包之后窗口大小变为W/2=62，62变到125，需要125-62=63个RTT，即63x150ms=9.45s</strong></p>
<h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>考虑修改TCP的拥塞控制算法。 <strong>不使用加性增， 使用乘性增</strong>。   A TCP sender increases its window size by a small positive constant whenever it receives a valid ACK.求出<strong>丢包率L</strong> 和 <strong>最大拥塞窗口W</strong>之间的函数关系。论证： 对于这种修正的TCP,无论TCP的平均吞吐量如何， 一条TCP连接将其拥塞窗口长度从 $W/2$ 增加到 $W$ ,总是需要相同的时间</p>
<p> 也就是说，在拥塞控制之后，每次cwnd包含的分组数都传输完成后，就会乘以 $(1+a)$，假设一共收到n个ack之后，才从 $W/2$增加到 $W$,那么我可以这样求出n</p>
<script type="math/tex; mode=display">
\frac{w}{2}(1+a)^n = w</script><p>解得： $n=\log<em>{1+a}2$ 这说明，从$W/2$到$W$需要 $\log</em>{1+a}2\cdot RTT$ 秒，这与吞吐量是没有关系的。</p>
<p>现在求 <strong>丢包率L</strong> 和 <strong>最大拥塞窗口W</strong> 的函数关系：</p>
<p>首先求从 $W/2$ 到 $W$ 期间一共发送的分组数，也就是每次的拥塞窗口长度相加</p>
<script type="math/tex; mode=display">
S =\frac{w}{2}+\frac{w}{2}(1+a)+\frac{w}{2}(1+a)^2+\cdots+\frac{w}{2}(1+a)^{n}, 其中 ~~n=\log_{1+a}2\\~\\一共n+1项,则~~
=\frac{w}{2}\frac{(1-(1+a)^{\log_{1+a}2+1})}{1-(1+a)} \\~\\
=\frac{w}{2}\frac{(2a+1)}{a}</script><p>这都是因为一个丢包而导致的，因此，在这段时间的丢包率为：</p>
<script type="math/tex; mode=display">
L = \frac{1}{S} = \frac{2a}{W(2a+1)}</script><h5 id="5"><a href="#5" class="headerlink" title="5"></a>5</h5><p>考虑⼀种简化的TCP的AIMD算法(加法增大乘法减小算法)，其中拥塞窗⼝⻓度<strong>⽤报⽂段的数量</strong>来度量，⽽不是⽤字节(MSS)度量。在加性增中，每个RTT拥塞窗口长度增加一个报文段；在乘性减中，拥塞窗⼝⻓度减⼩⼀半（如果结果不是一个整数， 向下取整到最近的整数）。假设两条TCP连接C1和C2,它们共享一条速率为<strong>每秒30个报文段</strong>的单一拥塞链路。 假设C1和C2均处于拥塞避免阶段。 它们具有相同的100ms RTT。在时刻$t_0$, C1的拥塞窗口长度为15个报文段， 而C2的拥塞窗口长度是10个报文段。</p>
<p>a. 在2200ms后， 它们的拥塞窗口长度为多长？<br>b. 经长时间运行， 这两条连接将取得共享该拥塞链路的相同的带宽吗？<br>c. 如果这两条连接在相同时间达到它们的最大窗口长度， 并在相同时间达到它们的最小窗口长度,<br>我们说这两条连接是同步的。 经长时间运行， 这两条连接将最终变得同步吗？ 如果是， 它们的最<br>大窗口长度是多少？<br>d・这种同步将有助于改善共享链路的利用率吗？ 为什么？ 给出打破这种同步的某种思路</p>
<p>这里采用的是乘性减方法，也就是当网络层无法承受时，就会缩小一半。又因为每秒最多30个报文段，因此每100ms最多3个报文段。那么，当二者的cwnd都变为1时，这是能通过c1+c2的所有报文，因此会采用加性增，C1和C2都变为2，但是一旦它们变为2后，就会超出每100ms链路能承受的最多报文数量，因此又会采用乘性减。重新变为1。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>t/ms</th>
<th>C1 cwnd</th>
<th>C2 cwnd</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>15</td>
<td>10</td>
</tr>
<tr>
<td>100</td>
<td>7</td>
<td>5</td>
</tr>
<tr>
<td>200</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>300</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>400</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>500</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>600</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>700</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>800</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>900</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1000</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>1100</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1200</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>1300</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1400</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>1500</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1600</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>1700</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1800</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>1900</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2000</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>2100</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2200</td>
<td>2</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<p><strong>b.</strong><br>是的</p>
<p><strong>c.</strong><br>是的，最终都是2</p>
<p><strong>d.</strong><br>这样的同步不利于改善利用率<br>因为当 C1 C2 的窗口大小都为 1 时，这条链路无法满载。因此，我们可以增设一个缓冲区，在缓冲区溢出之前随机丢弃一些分组。主动队列管理，随机早期检测等都用到了此种方法。 </p>
<h5 id="6"><a href="#6" class="headerlink" title="6"></a>6</h5><p>假定在主机C上的一个进程有一个具有端口号6789的UDP套接字.假定主机A和主机B都用目的端口6789向主机C发送一个UDP报文段. 这两台主机的这些报文段在主机C都被描述为相同的套接字吗? 如果是这样的话, 在主机C的该进程将怎样知道源于两台不同主机的这两个报文段? </p>
<ul>
<li><strong>答:</strong> 这两台主机的这些报文段在主机C会被描述为相同的套接字. 因为在传输UDP包的时候, <strong>网络层会附带上源和目的的IP地址的</strong>, 主机C的程序可以通过不同的源IP地址判别.</li>
<li>毕竟主机A和B在选端口的时候不知道彼此具体会选什么, 肯定会有选用一样端口号的情况, 主机IP能把它们区分开.</li>
</ul>
<h5 id="7"><a href="#7" class="headerlink" title="7"></a>7</h5><p>假定在主机C端口80上运行一个Web服务器.假定这个Web服务器使用持续连接, 并且正在接收来自两台不同主机A和B的请求. 被发送的所有请求都通过位于主机C的相同套接字吗? 如果它们通过不同的套接字传递, 这两个套接字都具有端口80吗? 讨论和解释之.</p>
<p> <strong>答:</strong> 这里有个巧妙的关系为题目带来歧义.</p>
<p>A和B的请求会<strong>通过80端口找到服务器进程</strong>, 就这里而言它们通过为与C的相同套接字, 这个套接字具有端口80.</p>
<p>当它们与服务器进程建立连接的时候, 服务器进程会<strong>单独为它们分配套接字</strong>, 通过专门的套接字响应客户端的请求. 这两个套接字就不具有80端口了.</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/" itemprop="url">计算机网络-应用层总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-03T00:16:44+08:00">
                2021-05-03
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-06-21T10:38:08+08:00">
                2022-06-21
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="计算机网络-应用层总结"><a href="#计算机网络-应用层总结" class="headerlink" title="计算机网络-应用层总结"></a>计算机网络-应用层总结</h1><h2 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h2><p>首先，我们要了解<strong>应用程序体系结构</strong>的概念。<strong>应用程序体系结构</strong>规定了如何在各种端系统上组织该应用程序。一般来说有两种体系结构：客户-服务器体系结构(client-server architecture)和对等(P2P)体系结构。</p>
<h3 id="Client-server-architecture"><a href="#Client-server-architecture" class="headerlink" title="Client-server architecture"></a>Client-server architecture</h3><p>在这个结构中，有一个总是打开的主机称为服务器，它会处理来自许多客户的主机的请求。一个典型的例子是 Web 应用程序，我们请求网页，网页处理请求，在把内容响应给我们。如下图所示：</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/1.png"></p>
<p>我们发现，客户相互之间是不直接通信的。</p>
<p>此外，客户-服务器体系结构的另一个特征是该服务器具有<strong>固定的、周知的</strong>地址，该地址称为IP地址。</p>
<p>具有客户-服务器体系结构的非常著名的应用程序包括Web、FTP、Telnet 和电子邮件。</p>
<p>配得大量主机的<strong>数据中心</strong>常被用于创建强大的虚拟服务器。最流行的因特网服务：如搜索引擎(Bing,Google) , 电商 (Amazon , e-bay ) ，基于Web的电子邮件(Gmail)等就应用了一个或者多个数据中心。</p>
<h3 id="P2P-architecture"><a href="#P2P-architecture" class="headerlink" title="P2P architecture"></a>P2P architecture</h3><p>在这个架构中，应用程序在间断连接的主机对之间使用直接通信。这些应用包括 文件共享(BitTorrent)， 下载器(迅雷)， 因特网电话和视频会议(Skype)等。</p>
<p> <img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/2.png"></p>
<h3 id="因特网提供的运输服务"><a href="#因特网提供的运输服务" class="headerlink" title="因特网提供的运输服务"></a>因特网提供的运输服务</h3><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>当某个程序调用TCP作为其运输协议时，该应用程序就能获得来自TCP的两种服务</p>
<ul>
<li>面向连接的服务： 在应用层数据报文开始流动之前，TCP让客户和服务器通过握手过程，提醒客户和服务器让它们为大量分组的到来做好准备。在握手截断后，一个TCP连接就在两个进程的套接字之间建立了。当应用程序结束发送报文时，必须拆除该连接</li>
<li>可靠的数据传送服务：通信进程能够依靠TCP，无差错，按适当顺序交付所有发送的数据。当应用程序的一端将字节流传入socket时，它能一开TCP将相同的字节流交付给接收方的socket，<strong>没有字节的丢失或者冗余</strong></li>
</ul>
<p>TCP还具有拥塞控制，当发送方和接收方之间的网络出现拥塞时，TCP的拥塞控制机制会抑制发送进程</p>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><ul>
<li>UDP 是无连接的，在两个进程通信前没有握手的过程。</li>
<li>UDP协议提供一种不可靠数据传送服务，也就是说，当进程将一个保温发送金UDP套接字时，UDP协议并不能保证该报文将到达接收进程。</li>
<li>UDP没有拥塞机制。所以UDP的发送端可以用它选定的任何速率向其下层注入数据。</li>
</ul>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/4.png"></p>
<h2 id="HTTP-Web"><a href="#HTTP-Web" class="headerlink" title="HTTP: Web"></a>HTTP: Web</h2><h3 id="HTTP概况"><a href="#HTTP概况" class="headerlink" title="HTTP概况"></a>HTTP概况</h3><p>Web的应用层协议是HTTP(超文本传输协议)，它是Web的核心。 超文本传输协议可以进行文字分割：<strong>超文本（Hypertext）、传输（Transfer）、协议（Protocol）</strong>，它们之间的关系如下</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/15.png"></p>
<p>按照范围的大小 协议 &gt; 传输 &gt; 超文本。下面就分别对这三个名次做一个解释。</p>
<h4 id="什么是超文本"><a href="#什么是超文本" class="headerlink" title="什么是超文本"></a>什么是超文本</h4><p>在互联网早期的时候，我们输入的信息只能保存在本地，无法和其他电脑进行交互。我们保存的信息通常都以<code>文本</code>即简单字符的形式存在，文本是一种能够被计算机解析的有意义的二进制数据包。而随着互联网的高速发展，两台电脑之间能够进行数据的传输后，人们不满足只能在两台电脑之间传输文字，还想要传输图片、音频、视频，甚至点击文字或图片能够进行<code>超链接</code>的跳转，那么文本的语义就被扩大了，这种语义扩大后的文本就被称为<code>超文本(Hypertext)</code>。</p>
<h4 id="什么是传输"><a href="#什么是传输" class="headerlink" title="什么是传输"></a>什么是传输</h4><p>那么我们上面说到，两台计算机之间会形成互联关系进行通信，我们存储的超文本会被解析成为二进制数据包，由传输载体（例如同轴电缆，电话线，光缆）负责把二进制数据包由计算机终端传输到另一个终端的过程称为<code>传输(transfer)</code>。</p>
<p>HTTP由两个程序实现：一个客户程序和一个服务器程序。两者运行在不同的端系统中，通过交换HTTP报文进行会话。它们之间的关系如下：</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/16.png" style="zoom:50%;"></p>
<h4 id="什么是协议"><a href="#什么是协议" class="headerlink" title="什么是协议"></a>什么是协议</h4><p>协议这个名词不仅局限于互联网范畴，也体现在日常生活中，比如情侣双方约定好在哪个地点吃饭，这个约定也是一种<code>协议</code>，比如你应聘成功了，企业会和你签订劳动合同，这种双方的雇佣关系也是一种 <code>协议</code>。注意自己一个人对自己的约定不能成为协议，协议的前提条件必须是多人约定。</p>
<p>那么网络协议是什么呢？</p>
<p>网络协议就是网络中(包括互联网)传递、管理信息的一些规范。如同人与人之间相互交流是需要遵循一定的规矩一样，计算机之间的相互通信需要共同遵守一定的规则，这些规则就称为网络协议。</p>
<p>没有网络协议的互联网是混乱的，就和人类社会一样，人不能想怎么样就怎么样，你的行为约束是受到法律的约束的；那么互联网中的端系统也不能自己想发什么发什么，也是需要受到通信协议约束的。</p>
<p>那么我们就可以总结一下，什么是 HTTP？可以用下面这个经典的总结回答一下： <strong>HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</strong></p>
<p>Web页面是由多个对象组成的，一个对象只是一个文件比如一个HTML文件，一个JPEG图形等，<strong>它们可以通过一个URL寻址</strong>。 </p>
<p>HTTP定义了Web客户向Web服务器请求Web页面的方式：</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/3.png"></p>
<p>当用户请求一个Web页面时，浏览器想服务器发出对该页面中所包含对象的<strong>HTTP请求报文</strong>，服务器接收到请求并用包含这些对象的<strong>HTTP响应报文</strong>进行响应</p>
<p>HTTP使用TCP作为支撑运输的协议，而TCP为HTTP提供可靠数据传输服务。这意味着，每一个请求报文和响应报文都能送达目的端。因此，HTTP协议不用担心数据丢失，也不关注TCP从网络的数据丢失和乱序故障中恢复的细节。</p>
<p>HTTP是一个<strong>无状态协议</strong>。其表现为：假如某个特定的客户在短短的几秒内两次请求同一个对象，服务器并不会因为刚刚为该客户提供了该对象就不在做出反应，而是重新发送该对象，就像服务器已经完全忘记不久之前做过的一样，<strong>服务器并不保存关于客户的任何信息</strong>。 </p>
<h3 id="非持续连接和持续连接"><a href="#非持续连接和持续连接" class="headerlink" title="非持续连接和持续连接"></a>非持续连接和持续连接</h3><p><strong>非持续连接</strong>： 每个请求/响应对是经一个<strong>单独的</strong>TCP连接发送的</p>
<p><strong>持续连接</strong>：每个请求/响应对是经<strong>相同的</strong>TCP连接发送的</p>
<p>现在我们来细致地讨论一下持续连接和非持续连接的优缺点。</p>
<h4 id="非持续连接"><a href="#非持续连接" class="headerlink" title="非持续连接"></a>非持续连接</h4><p>假如一个Web含有一个HTML 基本文件和10个JPEG 图形，并且这11个对象位于同一台服务器上。假设该HTML文件的URL为： <code>http://www.someSchool.edu/someDepartment/home.index</code></p>
<p>那么整个传输过程如下：</p>
<ol>
<li>HTTP Client 发起一个到服务器<code>www.someSchool.edu</code>的TCP连接。</li>
<li>HTTP Client 客户经它的套接字向该服务器发送一个HTTP请求报文，包含了路径名 <code>/someDepartment/home.index</code></li>
<li>HTTP Server 收到请求报文，检索处对象 <code>http://www.someSchool.edu/someDepartment/home.index</code> ，在一个HTTP响应报文中封装对象，并通过其Socket向客户发送响应报文</li>
<li>HTTP Server通知TCP断开TCP连接，直到TCP Client已经完整收到响应报文，才会实际中断连接</li>
<li>HTTP Client 收到响应报文，TCP连接关闭，Client 检查HTML文件，得到对10个JPEG文件的引用</li>
<li>对10个JPEG文件重复前面四个步骤。</li>
</ol>
<p>因此，Web中有几个对象，就要产生几个TCP连接。</p>
<h4 id="RTT-的概念"><a href="#RTT-的概念" class="headerlink" title="RTT 的概念"></a>RTT 的概念</h4><p>RTT(Round-Trip Time) 往返时间指的是一个段分组从客户到服务器然后再返回客户所花费的时间。我们尝试用RTT来表示客户点击超链接后页面出现的时间，如下图所示：</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/5.png"></p>
<p>粗略地讲，总的响应时间就是两个RTT 再加上服务器传输HTML文件的时间</p>
<h4 id="持续连接"><a href="#持续连接" class="headerlink" title="持续连接"></a>持续连接</h4><p>上面讲的非持续连接有一些缺点</p>
<ul>
<li>必须为每一个请求的对象建立和维护一个全新的连接。这给Web服务器带来了严重的负担</li>
<li>每一个对象经受两倍RTT的交付时延，累计起来是一个很大的数字</li>
</ul>
<p>采用持续连接，服务器在发送响应后应该保持该TCP连接打开。在相同的客户与服务器之间，后续请求和响应报文可以通过相同的连接进行传送。</p>
<h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><p>详见我的博客： <a href="https://jasonxqh.github.io/2021/04/02/计算机网络报告5/#3-1-HTTP协议">HTTP协议</a></p>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>cookie 允许站点对用户进行跟踪，把内容与用户身份联系起来。</p>
<p>cookie 技术有4个组件：</p>
<ol>
<li>在HTTP响应报文中的一个cookie首部行</li>
<li>在HTTP请求报文中的一个cookie首部行</li>
<li>在用户端系统中保留一个cookie文件，并由 客户的浏览器进行管理</li>
<li>位于Web站点的一个后端数据库</li>
</ol>
<p>原理如下图所示</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/6.png"></p>
<p>当客户端请求服务器时，如果服务器需要记录该用户状态，就在响应头中向客户端浏览器颁发一个Cookie，而客户端浏览器会把cookie保存起来。当再次请求该网站时，浏览器把请求的网站连同该cookie一起提交给服务器，服务器会检查该cookie，以此来辨认用户状态。</p>
<h3 id="Web-缓存"><a href="#Web-缓存" class="headerlink" title="Web 缓存"></a>Web 缓存</h3><p>Web缓存器也叫代理服务器，其模式如下图所示：</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/7.png"></p>
<p>代理服务器有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象的副本。这时，假设浏览器正在请求对象 <code>http://www.someschool.com/campus.gif</code>对象，将会发生一下情况：</p>
<ol>
<li>浏览器创建一个到代理服务器的TCP连接，并向代理服务器发送一个HTTP请求</li>
<li>代理服务器收到请求后，看看本地是否存储了该对象副本。如果有，<strong>Web缓存器</strong>就向客户的浏览器用HTTP响应报文返回该对象</li>
<li>如果Web缓存器没有该对象，就打开一个与该对象的初始服务器的TCP连接并发送HTTP请求。收到请求后，出事服务器向该Web缓存器发送具有该对象的HTTP响应</li>
<li>当Web缓存器接收到该对象时，他在本地存储空间存储一份副本，并向客户的浏览器发送该副本</li>
</ol>
<p>所以说，一个Web缓存器既是服务器又是客户。当他接收浏览器的请求并发回响应时，是一个服务器。它向初始服务器发送请求并接收响应时它是一个客户。</p>
<h2 id="SMTP-电子邮件"><a href="#SMTP-电子邮件" class="headerlink" title="SMTP: 电子邮件"></a>SMTP: 电子邮件</h2><p>下图给出了电子邮件系统的总体情况，我们可以看到它有3个主要的组成部分：用户代理、邮件服务器、SMTP</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/8.png"></p>
<p>用户代理比如说：Foxmail，Outlook ，Apple Mail 这类的软件</p>
<p>邮件服务器：qq邮箱，163邮箱，Gmail之类的邮件服务</p>
<p>SMTP则是<strong>简单邮件传输协议</strong>。</p>
<p>SMTP是因特网电子邮件的核心。它使用TCP可靠数据传输服务。每台邮件服务器上既运行着SMTP的客户端也运行着SMTP的服务器端。当一个邮件服务器向其他邮件服务器<strong>发送</strong>邮件时，他就是<strong>SMTP的客户</strong>；当邮件服务器从其他邮件服务器上<strong>接收</strong>邮件时，他就表现为一个<strong>SMTP的服务器</strong>。</p>
<p> 假设Alice 想给  Bob发送一份简单的报文。</p>
<ol>
<li>Alice调用它的邮件代理程序并提供Bob的邮件地址，撰写报文，然后指示用户代理发送该报文</li>
<li>Alice的用户代理把报文发给她的邮件服务器，在那里，该报文被放在报文队列中</li>
<li>运行在Alice的邮件服务器上的SMTP客户端发现了报文队列中的这个报文，他就创建一个到运行在Bob的邮件服务器上的SMTP服务器的TCP连接</li>
<li>在经过一些初始的SMTP握手后，SMTP客户通过该TCP连接发送Alice的报文。</li>
<li>在Bob的邮件服务器上，SMTP的服务器端接收该报文。Bob的邮件服务器然后将该报文放入Bob的邮箱中。</li>
<li>在Bob有时间的时候，它调用用户代理阅读该报文。</li>
</ol>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/9.png"></p>
<p>注意：SMTP 一般<strong>不适用中间邮件服务器</strong>发送邮件，如果Bob的邮件服务器没有开机，该报文会保留在ALice的邮件服务器上并等待新的尝试。</p>
<p>现在你知道了两台邮件服务器邮件发送的大体过程，那么，SMTP 是如何将邮件从 Alice 邮件服务器发送到 Bob 的邮件服务器的呢？主要分为下面三个阶段</p>
<ul>
<li><code>建立连接</code>：在这一阶段，SMTP 客户请求与服务器的25端口建立一个 TCP 连接。一旦连接建立，SMTP 服务器和客户就开始相互通告自己的域名，同时确认对方的域名。</li>
<li><code>邮件传送</code>：一旦连接建立后，就开始邮件传输。SMTP 依靠 TCP 能够将邮件准确无误地传输到接收方的邮件服务器中。SMTP 客户将邮件的源地址、目的地址和邮件的具体内容传递给 SMTP 服务器，SMTP 服务器进行相应的响应并接收邮件。</li>
<li><code>连接释放</code>：SMTP 客户发出退出命令，服务器在处理命令后进行响应，随后关闭 TCP 连接。</li>
</ul>
<h3 id="与HTTP的对比"><a href="#与HTTP的对比" class="headerlink" title="与HTTP的对比"></a>与HTTP的对比</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ul>
<li>HTTP 是从<strong>Web服务器向Web客户</strong>传送文件；SMTP事一个<strong>邮件服务器向另一个邮件服务器</strong>传送文件</li>
<li>当进行文件传送时，持续的HTTP和SMTP都采用<strong>持续连接</strong></li>
</ul>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ul>
<li>HTTP主要是 <strong>拉协议(pull protocol)</strong>，即用户使用HTTP从该服务器拉取信息;而SMTP基本上是一个<strong>推协议(push protocol)</strong>，及发送邮件服务器把文件推向接收邮件服务器</li>
<li>SMTP要求每个报文采用 <strong>7 比特的ASCII 码</strong>格式。HTTP数据则不受这些限制</li>
<li>HTTP把每个对象分装到它自己的HTTP响应报文中去，而SMTP则<strong>把所有报文对象放在一个报文之中</strong>。</li>
</ul>
<h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><p>详见我的博客 <a href="https://jasonxqh.github.io/2021/04/02/计算机网络报告5/#Task5-amp-6">WireShark 抓取SMTP 数据包</a></p>
<h3 id="因特网邮件访问协议"><a href="#因特网邮件访问协议" class="headerlink" title="因特网邮件访问协议"></a>因特网邮件访问协议</h3><p>Bob的用户代理不能使用SMTP得到报文，因为获取报文是一个拉操作，而SMTP协议是一个推协议。这就需要引入一个特殊的邮件访问协议来解决，该协议将Bob邮件服务器上的报文传送给他本地的PC。目前有一些流行的访问协议：POP3、IMAP以及HTTP</p>
<h4 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h4><p>POP3 是一个极为简单的邮件访问协议。POP3按照三个阶段进行工作：</p>
<ol>
<li>Authorization(特许)，用户代理发送用户名和口令以鉴别用户</li>
<li>事务处理阶段，用户代理取回报文。同时还能进行如下操作：对报文做删除标记，取消报文删除标记，获取邮件统计信息</li>
<li>更新阶段，出现在客户发出了quit命令之后，目的是结束该POP3会话。这时，该邮件服务器会删除那些被标记为删除的报文</li>
</ol>
<p>在POP3的事务处理过程中，用户代理的回答可能有OK(正常)和-ERR(出现差错)</p>
<p>在事务处理阶段，POP3的用户代理通常被配置为”下载并删除”或者“下载并保留”方式。</p>
<h5 id="下载并删除"><a href="#下载并删除" class="headerlink" title="下载并删除"></a>下载并删除</h5><p>这种方式存在的问题是，邮件接收方Bob可能是移动的，可能希望从多个不同的机器访问他的邮件报文，如从办公室的PC和笔记本来访问邮件。那么，如果Bob先在办公室的PC上收取了一条邮件，那么晚上当他在家里时，他便不能再通过笔记本收取该邮件</p>
<h5 id="下载并保留"><a href="#下载并保留" class="headerlink" title="下载并保留"></a>下载并保留</h5><p>用户代理下载某邮件之后该邮件仍然保留在邮件服务器上。这样Bob就能通过不同的及其重新读取这些邮件</p>
<h4 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a>IMAP</h4><p>IMAP 是另一个邮件访问协议，它比 POP3具有更多的特色，不过也比POP3复杂得多。 POP3 会对移动用户带来问题。IMAP更喜欢使用一个在远程服务器上的层次文件夹，这样他可以从任何一台机器上对所有报文进行访问，但是POP3协议并没有给用户提供任何创建远程文件夹并为报文指派文件夹的方法。</p>
<ul>
<li>IMAP服务器把每个报文与一个文件夹联系起来，当报文第一次到达服务器时，它与收件人的INBOX文件夹相关联。收件人作为能够把邮件移到一个新的用户创建的文件夹中来阅读邮件、删除邮件等。</li>
<li>IMAP协议为用户提供了创建文件夹以及将邮件从一个文件夹移动到另一个文件夹的命令</li>
<li>IMAP 还为用户提供了在远程文件夹中查询邮件的命令</li>
<li>IMAP 服务器维护了IMAP会话的用户状态信息</li>
<li>IMAP 具有允许用户代理获取报文某些部分的命令。例如，一个用户代理可以只读取一个报文的首部。</li>
</ul>
<h4 id="基于Web的电子邮件"><a href="#基于Web的电子邮件" class="headerlink" title="基于Web的电子邮件"></a>基于Web的电子邮件</h4><p>比如网页端的QQ邮箱，网易邮箱。使用这种服务，用户代理就是普通的浏览器，用户和他远程邮箱之间的通信通过HTTP进行：</p>
<ul>
<li>收件人从邮箱中访问一个报文时，该电子邮件报文从Bob的邮件服务器发送到他的浏览器，使用的是HTTP而不是POP3或者IMAP协议</li>
<li>当发件人要发送一封电子邮件报文时，该电子邮件豹纹从浏览器发送到邮件服务器使用的是HTTP报文而不是SMTP</li>
<li>但是，邮件服务器之间发送和接收邮件时，仍然使用SMTP</li>
</ul>
<h2 id="DNS-因特网的目录服务"><a href="#DNS-因特网的目录服务" class="headerlink" title="DNS: 因特网的目录服务"></a>DNS: 因特网的目录服务</h2><p>首先我们要搞清楚 主机名和IP地址的关系。</p>
<p>主机名如：facebook.com、google.com 等 但是，主机名几乎没有提供关于主机在因特网中位置的信息，这让路由器难以处理</p>
<p>IP 地址： 由4个字节组成，并有着严格的层次结构。例如 <code>121.7.106.83</code> 这样一个 IP 地址，其中的每个字节都可以用 <code>.</code> 进行分割，表示了 <code>0 - 255</code> 的十进制数字。 </p>
<p>我们需要一种进行主机名到IP地址转换的目录服务，这就是DNS的主要任务。DNS是：</p>
<ol>
<li>一个由分层的DNS服务器实现的分布式数据库</li>
<li>一个使得主机能够查询分布式数据库的应用层协议</li>
</ol>
<p>如下图所示：</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/17.png"></p>
<p>总的来说，在单一DNS服务器上运行集中式数据库完全没有可扩展能力。因此，DNS采用了分布式设计方案。</p>
<h3 id="DNS工作机理概述"><a href="#DNS工作机理概述" class="headerlink" title="DNS工作机理概述"></a>DNS工作机理概述</h3><p>DNS 是一个复杂的系统，我们在这里只是就其运行的主要方面进行学习，下面给出一个 DNS 工作过程的总体概述</p>
<p>假设运行在用户主机上的某些应用程序（如 Web 浏览器或邮件阅读器） 需要将主机名转换为 IP 地址。这些应用程序将调用 DNS 的客户端，并指明需要被转换的主机名。用户主机上的 DNS 收到后，会使用 UDP 通过 53 端口向网络上发送一个 DNS 查询报文，经过一段时间后，用户主机上的 DNS 会收到一个主机名对应的 DNS 回答报文。因此，从用户主机的角度来看，DNS 就像是一个黑盒子，其内部的操作你无法看到。但是实际上，实现 DNS 这个服务的黑盒子非常复杂，它由分布于全球的大量 DNS 服务器以及定义了 DNS 服务器与查询主机通信方式的应用层协议组成。</p>
<p>DNS 最早的一种简单设计只是在因特网上使用一个 DNS 服务器。该服务器会包含所有的映射。这是一种<code>集中式</code>的设计，这种设计并不适用于当今的互联网，因为互联网有着数量巨大并且持续增长的主机，这种集中式的设计会存在以下几个问题</p>
<ul>
<li><code>单点故障(a single point of failure)</code>，如果 DNS 服务器崩溃，那么整个网络随之瘫痪。</li>
<li><code>通信容量(traaffic volume)</code>，单个 DNS 服务器不得不处理所有的 DNS 查询，这种查询级别可能是上百万上千万级</li>
<li><code>远距离集中式数据库(distant centralized database)</code>，单个 DNS 服务器不可能 <code>邻近</code> 所有的用户，假设在美国的 DNS 服务器不可能临近让澳大利亚的查询使用，其中查询请求势必会经过低速和拥堵的链路，造成严重的时延。</li>
<li><code>维护(maintenance)</code>，维护成本巨大，而且还需要频繁更新。</li>
</ul>
<p>所以 DNS 不可能集中式设计，它完全没有可扩展能力，因此采用<code>分布式设计</code>，所以这种设计的特点如下</p>
<h4 id="分布式、层次数据库"><a href="#分布式、层次数据库" class="headerlink" title="分布式、层次数据库"></a>分布式、层次数据库</h4><p><strong>没有一台DNS服务器拥有因特网上所有主机的映射</strong>。大致来说，有3种类型的DNS服务器：根DNS服务器、顶级域DNS服务器和权威DNS服务器。</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/10.png"></p>
<h5 id="根DNS服务器"><a href="#根DNS服务器" class="headerlink" title="根DNS服务器"></a>根DNS服务器</h5><p>有400多个根服务器遍及全世界。根名字服务器提供TLD服务器的IP地址</p>
<h5 id="顶级域DNS服务器。"><a href="#顶级域DNS服务器。" class="headerlink" title="顶级域DNS服务器。"></a>顶级域DNS服务器。</h5><p>对于每个顶级域(如com、org、edu) 和所有国家的顶级域(uk,cn)等，都有TLD(Top-Level Domain)服务器. TLD服务器提供了权威DNS服务器的IP地址</p>
<h5 id="权威DNS服务器"><a href="#权威DNS服务器" class="headerlink" title="权威DNS服务器"></a>权威DNS服务器</h5><p>一个组织机构的权威DNS收藏了DNS记录。另一种方法是，该组织能够支付费用，让这些记录存储在某个服务提供商的一个权威DNS服务器中。多数大学和大公司实现和维护他们自己基本和备份的权威DNS服务器。</p>
<h4 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h4><p>第一个步骤是本机向本地域名服务器发出一个DNS请求报文，报文里携带需要查询的域名；第二个步骤是本地域名服务器向本机回应一个DNS响应报文，里面包含域名对应的IP地址或者别名等。由两种查询方法：</p>
<p><strong>递归查询：</strong>本机向本地域名服务器发出一次查询请求，<strong>就静待最终的结果</strong>。如果本地域名服务器无法解析，自己会以DNS客户机的身份向其它域名服务器查询，直到得到最终的IP地址告诉本机</p>
<p><strong>迭代查询：</strong>本地域名服务器向根域名服务器查询，根域名服务器告诉它下一步到哪里去查询，然后它再去查，<strong>每次它都是以客户机的身份去各个服务器查询</strong></p>
<p>注意：理论上，任何DNS查询机可以是迭代的也可以是递归的。 在实践中，第一个步骤从主机到本地域名服务器是<strong>递归查询</strong>；第二大步骤中采用的是<strong>迭代查询</strong>，其实是包含了很多小步骤的， 如下图所示。</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/11.png"></p>
<h3 id="DNS报文分析"><a href="#DNS报文分析" class="headerlink" title="DNS报文分析"></a>DNS报文分析</h3><p>详见博客： <a href="https://jasonxqh.github.io/2021/04/08/计算机网络报告6/#3-2-DNS协议">DNS协议 </a></p>
<h2 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h2><p>当一个单一服务器向大量主机分发一个大文件时，就必须向每个对等方发送该文件的一个副本。折让服务器承受了极大地负担，消耗了大量服务器带块。而使用P2P结构，每个对等方能够向任何其他对等方重新分发他已经收到的该文件的任何部分，从而在分发的过程中协助该服务器。</p>
<h3 id="P2P-体系结构的扩展性"><a href="#P2P-体系结构的扩展性" class="headerlink" title="P2P 体系结构的扩展性"></a>P2P 体系结构的扩展性</h3><p>如下图所示，服务器和对等方使用接入链路与因特网相连。其中 </p>
<p>$u_s$  表示服务器接入链路的上载速率</p>
<p>$u_i$表示第i对等方接入链路的上载速率</p>
<p>$d_i$ 表示第i 对等方接入链路的下载速率</p>
<p>$F$表示备份发的文件长度(bit) </p>
<p>$N$表示要获得的该文件副本的对等方数量</p>
<p>我们可以这样来定义<strong>分发时间：</strong> 是所有N个对等方得到该文件的副本所需要的时间。</p>
<p>首先我们假设因特网核心具有足够的带宽，这样所有瓶颈都在网络接入链路。还假设服务器和客户没有参与任何其他网络应用，因此他们的所有上传和下载访问贷款能被全部用于分发该文件。</p>
<h4 id="对于-客户-服务器体系结构"><a href="#对于-客户-服务器体系结构" class="headerlink" title="对于 客户-服务器体系结构"></a>对于 客户-服务器体系结构</h4><p>我们将客户服务器体系结构的分发时间记为 $D_{cs}$</p>
<ul>
<li>服务器必须向N个对等方传输该文件的一个副本。因此服务器必须传输NF 比特。因为该服务器上载的速度是 $u_s$, 分发该文件的时间必定是至少为 $NF/u_s$</li>
<li>令$d<em>{\min}$ 表示具有<strong>最小下载速率</strong>的对等方的下载速率，即 $d</em>{\min}=\min{d<em>1,\cdots,d_N }$,具有最小下载速率的对等方至少需要 $F/d</em>{\min}$ 的时间内获得F比特。因此最小分发的时间至少为 $F/d_{\min}$</li>
</ul>
<p>结合两者，我们得到： </p>
<script type="math/tex; mode=display">
D_{cs} \geq \max\{\frac{NF}{u_s},\frac{F}{d_{\min}}\}</script><p>我们可以直接取其下界。也就是$D<em>{cs} = \max{\frac{NF}{u_s},\frac{F}{d</em>{\min}}}$ </p>
<p>那么，对于足够大的N，客户-服务器 分发时间为 $\frac{NF}{u_s}$ 。这和用户的数量成线性增加的关系。</p>
<h4 id="对于P2P-体系结构"><a href="#对于P2P-体系结构" class="headerlink" title="对于P2P 体系结构"></a>对于P2P 体系结构</h4><p>在P2P体系结构中，每个对等方(用户)能够帮助服务器分发该群文件。特别的，当一个对等方接收到某些文件数据时，能够使用自己的上载能力重新将数据分发给其他对等方。</p>
<ul>
<li>在分发的开始，只有服务器具有稳健。因此该服务器必须接入链路发送该文件的每个比特1次。因此最小的分发时间为 $\frac{F}{u_s}$</li>
<li>与客户-服务器体系结构相同，具有最小下载速率的对等方至少需要 $F/d<em>{\min}$ 的时间内获得F比特。因此最小分发的时间至少为 $F/d</em>{\min}$</li>
<li>最后，观察到系统整体的总上载能力等于服务器的上载速率加上每个单独的对等方上载速率。即：$u_{total} = u_s+u_1+\cdots+u_N$ 。 系统必须总共交付NF bit。 因此，最小的分发时间最小是： $NF/(u_s+u_1+\cdots+u_N)$ </li>
</ul>
<p>将这三个观察放在一起，我们获得了对P2P的最小分发时间，表示为 $D_{P2P}$ </p>
<script type="math/tex; mode=display">
D_{P2P}\geq \max\{\frac{F}{u_s},\frac{F}{d_{\min}},\frac{NF}{u_s+u_1+\cdots+u_N}\}</script><p>同样的我们可取其下界。$D<em>{P2P}= \max{\frac{F}{u_s},\frac{F}{d</em>{\min}},\frac{NF}{u_s+u_1+\cdots+u_N}}$</p>
<p>我们假设$F/u=1h,u<em>s=10\mu,d</em>{\min}\geq u_s$ 并画出图像如下图</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/13.png"></p>
<p>我们发现具有P2P 体系结构的应用程序可以自扩展。</p>
<h2 id="视频流和内容分发网"><a href="#视频流和内容分发网" class="headerlink" title="视频流和内容分发网"></a>视频流和内容分发网</h2><h4 id="因特网视频"><a href="#因特网视频" class="headerlink" title="因特网视频"></a>因特网视频</h4><p>在流式存储视频应用中，最基础的媒体是预先录制的视频例如电影、电视节目、录制好的体育事件或者用户生成的视频。这些预先录制好的视频会放置在服务器上，用户按需向服务器发送请求来观看视频。许多因特网公司现在提供流式视频，这些公司包括 Netflix、YouTube 、亚马逊和优酷等。</p>
<p>视频式一系列的图像，通常会以一种恒定的速率（如每秒 24 或 30 张图像）来展现。一幅未压缩、数字编码的图像由像素阵列组成，其中每个像素又一些比特编码来表示亮度和颜色。视频的一个重要特征是它能够被压缩、因而可用比特率来权衡视频质量。</p>
<h4 id="HTTP-流和-DASH"><a href="#HTTP-流和-DASH" class="headerlink" title="HTTP 流和 DASH"></a>HTTP 流和 DASH</h4><p>在 HTTP 流中，视频只是存储在 HTTP 服务器中的一个文件，每个文件有特定的 URL。当用户想要看视频时，客户与服务器创建一个 TCP 连接并发送该 URL 的 HTTP GET 请求。服务器则以底层网络协议和流量条件允许的尽可能快的速率，在一个 HTTP 响应中发送该文件视频。</p>
<p>尽管 HTTP 流在实践中已经得到广泛部署，但是它由严重缺陷，即所有客户接收到相同编码的视频，但是对于客户而言，带宽时动态变化的，在不同的时间，带宽大小有很大不同。这种情况导致了一种新型 HTTP 流的研发，它常常被称为 <code>经 HTTP 的动态适应性流(Dynamic Adaptive Streaming over HTTP, DASH)</code>。在 DASH 中，视频编码为几个不同的版本，每个版本对应不同的比特率。</p>
<p>DASH 允许客户使用不同的以太网接入速率流失播放具有不同编码速率的视频。使用 3G 连接的客户能够接受一个低比特率的版本，使用光纤能够接受高比特率的版本。</p>
<p>使用 DASH 后，每个视频版本存储在 HTTP 中，每个版本都有一个不同的 URL。HTTP 服务器也会有一个 <code>告示文件(manifest file)</code>，为每个版本提供了一个 URL 及其比特率。</p>
<h4 id="内容分发网"><a href="#内容分发网" class="headerlink" title="内容分发网"></a>内容分发网</h4><p>现如今，许多因特网视频公司日复一日地向数以百万计的用户按需分发每秒数兆比特的流。对于一个因特网视频公司，或许提供流式视频服务最为直接的方法是建立一个单一的超大规模的数据中心。在数据中心内部存储所有视频，然后把视频返回到全世界范围内的客户。这种方式存在三个问题</p>
<ul>
<li>如果客户远离数据中心，服务器到客户的分组将跨越许多通信链路并可能通过很多 ISP，造成通信延迟</li>
<li>流式视频可能经过相同的链路发送了许多次，造成带宽和资源浪费。</li>
<li>单点问题，如果单一结点故障，这可能是灾难性的。</li>
</ul>
<p>为了应对向分布于全世界的用户分发巨量视频数据的挑战，几乎所有主要的视频流公司都利用 <code>内容分发网(Content Distribution Network, CDN)</code>。 CDN 管理分布在多个地理位置上的服务器，在它的服务器上存储视频副本，并且所有试图将每个用户请求定向到一个提供最好用户体验的 CDN 位置。那么<strong>服务器如何选址呢</strong>？事实上有两种服务器安置原则</p>
<ul>
<li><code>深入</code>，它的主要目标是靠近用户，通过减少端用户和 CDN 集群之间链路和路由器的数量，从而改善了用户感受的时延和吞吐量。</li>
<li><code>邀请做客</code>，这个原则是通过在少量（例如 10 个）关键位置建造大集群来邀请 ISP 来做客，这些CDN集群通常放在因特网交换结点(IXP).  与深入设计原则相比，好处是产生<strong>较低的维护和管理开销</strong>. 缺点是以对端用户的<strong>较高时延和较低吞吐量为代价</strong>.</li>
</ul>
<p>CDN 可以是<code>专用 CDN(private CDN)</code>, 即它由内容提供商自己所拥有；另一种 CDN 是 <code>第三方 CDN(third-party CDN)</code>，它代表多个内容提供商分发内容。</p>
<p>除了如时延, 丢包和带宽性能等网络相关的考虑外, 设计一种CDN服务器选择策略时还有其他重要因素. 它们是什么?</p>
<ul>
<li>还要考虑它分发的内容.</li>
</ul>
<h4 id="CDN-分发过程"><a href="#CDN-分发过程" class="headerlink" title="CDN 分发过程"></a>CDN 分发过程</h4><p>上面我们探讨了一下 CDN 的选址过程，那么 CDN 是如何工作的呢？</p>
<p>当用户主机中的一个浏览器指令检索一个特定的视频（由 URL 标识）时，CDN 必须能够截获请求，来进行下面的操作</p>
<ul>
<li>确定此时适用于该客户的 CDN 服务器集群</li>
<li>将客户的请求重定向到集群中的某台服务器上</li>
</ul>
<p>大多数 CDN 利用 <strong>DNS 协议</strong>来截获和重定向请求。</p>
<p>下面是 CDN 的具体工作流程</p>
<p>假设一个内容提供商 <code>NetCinema</code> ，雇用了第三方 CDN 公司 <code>KingCDN</code> 来向它的客户分发视频。在 NetCinema 的 Web 网页上，它的每个视频都被指派了一个 URL，该 URL 包括了字符串 <code>video</code> 以及视频本身的标识符。下面要访问 <code>http://video.netcinema.com/6Y7B23V</code> ，它的工作过程如下</p>
<p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/18.png"></p>
<ol>
<li>用户访问位于 NetCinema 的 Web 网页</li>
<li>当用户点击链接 <code>http://video.netcinema.com/6Y7B23V</code> 时，该用户主机发送了对于 <code>video.netcinema.com</code>的 DNS 请求</li>
<li>用户本地 DNS 服务器(LDNS， Local DNS) 将该 DNS 请求中继到一台用于 NetCinema 的权威 DNS 服务器，该服务器观察到主机名 <code>video.netcinema.com</code> 中的字符串 <code>video</code>。为了将该 DNS 请求移交给 KingCDN，NetCinema 权威 DNS 服务器并不返回一个 IP 地址，而是向 LDNS 返回一个 KingCDN 域的主机名，如 a1105.kingcdn.com</li>
<li>从此时起，DNS 请求就会进入 KingCDN 专用 DNS 基础设施，用户的 LDNS 则发送第二个请求，此时是对 a1105.kingcdn.com 的 DNS 请求，KingCDN 的 DNS 系统最终向 LDNS 返回 KingCDN 内容服务器的 IP 地址。所以正是这里，<strong>在 KingCDN 的 DNS 系统中，指定了 CDN 服务器</strong>，客户将能够从这台服务器接收它的内容</li>
<li>LDNS 向用户主机转发内容服务 CDN 节点的 IP 地址</li>
<li>一旦客户收到 KingCDN 内容服务器的 IP 地址，它与具有该 IP 地址的服务器创建一条 TCP 连接，并且发出对该视频的 HTTP <code>GET</code> 请求。如果使用了 DASH，服务器将首先向客户发送具有 URL 列表的告示文件，每个 URL 对应视频的每个版本，并且客户将动态的选择来自不同版本的块。</li>
</ol>
<h4 id="CDN-的集群选择策略"><a href="#CDN-的集群选择策略" class="headerlink" title="CDN 的集群选择策略"></a>CDN 的集群选择策略</h4><p>任何 CDN 的部署，其核心是 <code>集群选择策略(cluster selection strategy)</code>， 即动态的将客户定向到 CDN 中某个服务器集群或数据中心的机制。一种简单的策略是指派客户到 <code>地理上最为临近(geographically closest)</code> 的集群。这种选择策略忽略了时延和可用带宽随因特网路径时间而变化，总是为特定的客户指派相同的集群；还有一种选择策略是 <code>实时测量(real-time measurement)</code>，该机制是基于集群和客户之间的时延和丢包性能执行周期性检查。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/2021/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%E6%80%BB%E7%BB%93/12.png"></p>
<h3 id="应用层协议分类"><a href="#应用层协议分类" class="headerlink" title="应用层协议分类"></a>应用层协议分类</h3><ul>
<li><code>域名系统(Domain Name System, DNS)</code>：用于实现网络设备名字到 IP 地址映射的网络服务。</li>
<li><code>文件传输协议(File Transfer Protocol，FTP)</code>：用于实现交互式文件传输功能。</li>
<li><code>邮件传送协议(Simple Mail Transfer Protocol, SMTP)</code>：用于实现电子邮箱传送功能。</li>
<li><code>超文本传输协议(HyperText Transfer Protocol，HTTP)</code>：用于实现 Web 服务。</li>
<li><code>远程登录协议(Telnet)</code>：用于实现远程登录功能。</li>
</ul>
<h2 id="复习题"><a href="#复习题" class="headerlink" title="复习题"></a>复习题</h2><p>R26 2.7节中所描述的UDP服务器仅需要一个套接字, 而TCP服务器需要两个套接字. 为什么? 如果TCP服务器支持n个并行连接, 每条连接来自不同的客户主机, 那么TCP服务器需要多少个套接字.</p>
<ul>
<li>因为UDP是面向无连接的, 它的服务器只需要有一个套接字用于接收和发送, 并且可以接收来自不同地址主机的UDP包. 而TCP是面向连接的, 除了接收访问的套接字, 每和一个客户连接就要创建一个专用的套接字，称之为<strong>连接套接字</strong></li>
<li>n+1个.</li>
</ul>
<p>R27 对于2.7节所描述的运行在TCP之上的客户-服务器应用程序, 服务器程序为什么必须先于客户程序运行? 对于运行在UDP之上的客户-服务器应用程序, 客户程序为什么可以先于服务器程序运行.</p>
<ul>
<li>建立TCP连接需要经过一个3次握手的过程, 如果服务器没有启动根本无法握手, 从而无法创建连接.</li>
<li>UDP是面向无连接的, 就算服务器没有启动, 客户程序照样可以把UDP发出去, 但服务器可能就收不到了.</li>
</ul>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E7%BB%93/" itemprop="url">计算机网络第一章总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-04-27T18:15:31+08:00">
                2021-04-27
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-06-21T09:27:56+08:00">
                2022-06-21
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h1><p>学习博客： <a href="https://www.zhihu.com/column/p/44316491" target="_blank" rel="noopener">https://www.zhihu.com/column/p/44316491</a></p>
<p>所谓交换，就是指服务器与服务器之间的数据交换。我们介绍分组交换和电路交换</p>
<h2 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h2><p>假设A要和E打个电话，那么当A输入E的电话号码，开始拨号之后，那么服务器要做的第一件事就是根据E的电话号码找到E在哪里，由于A通往E的路径有多条，会根据某种算法找到E之后，建立一条通路，然后进行数据的传输。</p>
<p>我们假设选的路径是A—&gt;D—-&gt;E</p>
<p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E7%BB%93/1.png" style="zoom:80%;"></p>
<p>电路交换总共有3个阶段：</p>
<ol>
<li><p><strong>建立连接</strong>，就是说找到一条A通往E的路径并建立会话的过程,之后A和E在通话的过程中会始终<strong>霸占着这条路径</strong></p>
</li>
<li><p><strong>数据传输</strong>，数据沿着这条找到的路径从A直接传到E</p>
</li>
<li><p><strong>释放连接</strong>。 A和E只要有一方挂了电话，就释放连接。</p>
</li>
</ol>
<p>在这个过程中，新建连接需要花销一定的额外时间（想象你打电话的时候是不是出现<strong>正在拨号</strong>的字眼），释放连接也会花销一些额外的时间。</p>
<p><strong>那么，电话交换的过程中，数据需要分组来传送吗？</strong></p>
<p><strong>不用的</strong>，因为电路交换的过程中，A和E两个人始终霸占着一条通信电路，他们每说一句话，都会实时被对方获取，因此数据是不用分组的。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>数据不需要分组，传输速度快、高效</li>
<li>实时</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>资源利用率低</li>
<li>新建连接需要占据一定的时间，甚至比通话时间还长</li>
</ul>
<h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><p>分组的概念就是将一个数据包分成一个个更小的数据包。例如，我们把一个10Gb的数据包拆分成几个小的数据包，每个分组数据块都有文件头和数据两部分。</p>
<p>文件头一般是一些说明性数据，例如源地址和目标地址，数据类型等；数据部分就是真正要传达给对象的内容。</p>
<p>我们还是以A给E传输数据为例，这个数据包很大，假设其要分成3组更小的数据包：$p_1,p_2,p_3$  </p>
<p>这时候A给E传输数据的时候就不需要寻找一个通往E的路径了。A只要把小的数据包直接丢给附近的路由器，然后A就不管了，例如A把p1丢给了B，这个时候A就不在去管p1的，当B收到p1这个完整的小数据包之后，B再丢给E。</p>
<p>但是A不一定都会把剩下的数据包都丢给B，有可能会把其他的数据包p2丢给C,之后再把p3丢给D，然后C和D在转发丢给E。这些都是不确定的，会根据<strong>路由选择协议</strong>的选择路由器。</p>
<p><strong>路由器必须收到完整的数据包才能进行转发</strong>， 这是因为数据包中的头部包含了源地址和目标地址，必须接收到完整的数据包，路由器才能正确转发。</p>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>1、<strong>不具有实时性</strong>。因为服务器把数据包丢给路由器后就不管了，因此路由器可能会再绕几个圈子发给另外一个服务器。</p>
<p>2、<strong>存在延时</strong>。因为路由器必须收到完整的包才能继续传送这个包。在这个过程中存在<strong>传输时延</strong>。此外还存在<strong>传播时延</strong>和<strong>处理时延</strong>。</p>
<p>3、<strong>会造成通信阻塞</strong>。当路由器需要收到很多包的时候，会出现排队的状况。</p>
<p>4、<strong>存在无用的重复数据</strong>。  由于p1,p2,p3数据包都有文件头，里面都包含了A和E的一些信息，当然还有其他的信息。可以说这些文件头有很多重复的数据</p>
<p>5、<strong>会出现丢包的情况</strong>。当一个路由器收的包太多，撑满了路由器空间，就会出现丢包</p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol>
<li>相比于电路交换，更简单、更有效，实现成本更低</li>
<li>它提供了比电路交换更好的带宽共享</li>
<li>资源利用率很高。</li>
</ol>
<h3 id="应用举例："><a href="#应用举例：" class="headerlink" title="应用举例："></a>应用举例：</h3><p>假设多个用户共享一条1Mbps 链路</p>
<ul>
<li>假定每个用户活跃周期时变化的——某用户时而以100kbps很速率产生数据，时而静止不产生数据。</li>
<li>假定该用户仅有10%的时间活跃</li>
</ul>
<p>那么，对于电路交换，再所有时间内<strong>必须</strong> 为每个用户预留100kbps，因此，该电路交换电路仅能支持<strong>10个并发的用户</strong>。</p>
<p>但是，对于分组交换，如果有35个用户，根据排列组合定理，计算得到当有10个或者更少并发用户的概率为0.9996 时，到达的聚合数据速率小于等于该链路的输出速率1Mbps。</p>
<p>因此相同带宽的链路，使用分组交换可以支持更多的并发用户。</p>
<h2 id="网络的网络"><a href="#网络的网络" class="headerlink" title="网络的网络"></a>网络的网络</h2><p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E7%BB%93/2.jpg" style="zoom:80%;"></p>
<p>总结一下，今天的因特网是一个<strong>网络的网络</strong>，其结构复杂，由十多个<strong>第一层ISP</strong>和<strong>数十万个较低层ISP组成</strong>。ISP覆盖的区域多种多样，有些跨越多个大洲和大洋，有些限于狭窄的地理区域。</p>
<p>较低层的ISP与较高层的ISP相连，较高层ISP<strong>彼此互联</strong>。</p>
<p>用户和内容提供商是较低层ISP的客户，较低层ISP是较高层ISP的客户。</p>
<p>近年来，主要的内容提供商也已经创建自己的网络，直接在可能的地方与较低层ISP互联。 </p>
<h1 id="分组交换网中的时延、丢包、吞吐量"><a href="#分组交换网中的时延、丢包、吞吐量" class="headerlink" title="分组交换网中的时延、丢包、吞吐量"></a>分组交换网中的时延、丢包、吞吐量</h1><h2 id="时延概述"><a href="#时延概述" class="headerlink" title="时延概述"></a>时延概述</h2><p>有很多种不同类型的时延：</p>
<ul>
<li>节点处理时延 $d_{proc}$</li>
<li>排队时延 $d_{queue}$</li>
<li>传输时延 $d_{trans}$</li>
<li>传播时延 $d_{prop}$</li>
</ul>
<p>这些时延总统累加起来是<strong>节点总时延</strong></p>
<p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E7%BB%93/3.png" style="zoom:80%;"></p>
<h3 id="处理时延"><a href="#处理时延" class="headerlink" title="处理时延"></a>处理时延</h3><p>这一部分包含了检查分组首部和决定将该分组导向何处所需要的时间。<strong>高速路由器的处理时延</strong>通常是微秒或更低的数量级。</p>
<p>上面说了是<strong>高速路由器</strong>，说明 $d_{proc}$ 只要计算有几个路由器，路由器个数 = 链路数-1</p>
<h3 id="排队时延"><a href="#排队时延" class="headerlink" title="排队时延"></a>排队时延</h3><p>在队列中，当分组在链路上等待传输时，就会出现排队时延。</p>
<ul>
<li>如果该队列是空的，并且当前没有其他分组正在传输，则该分组的排队时延为0</li>
<li>如果流量很大，并且许多其他分组也在等待传输，该排队时延会很长</li>
</ul>
<p><strong>实际的排队时延是毫秒到微秒量级</strong></p>
<h3 id="传输时延"><a href="#传输时延" class="headerlink" title="传输时延"></a>传输时延</h3><p>用L比特表示该分组的长度，用 $R bps$ 表示从路由器A到路由器B的链路<strong>传输速率</strong>。那么传输时延就是 $L/R$</p>
<p>这是将所有分组的比特推向链路所需要的时间(也可以说是发射出去)。<strong>实际的传输时延通常在毫秒到微秒量级</strong></p>
<h3 id="传播时延"><a href="#传播时延" class="headerlink" title="传播时延"></a>传播时延</h3><p>一旦一个比特被推向链路，该比特需要向路由器B传播。从该链路的起点到路由器B的传播所需要的时间就是传播时延。传播速率取决于该链路的物理媒体(光纤，铜线)等，其速率范围是$2\times 10^8 m/s \sim 3\times 10^8 m/s$ </p>
<p>传播时延的计算方法： 两台路由器之间的距离除以传播速率，$\frac{d}{s}$ </p>
<p>需要注意的是，传播时延是<strong>两台路由器之间的距离除以传播速率</strong> ，也就是说如果路上有三个路由器，实际上只走了两段路</p>
<p><strong>在广域网中，传播时延为毫秒量级</strong> </p>
<h2 id="时延和丢包"><a href="#时延和丢包" class="headerlink" title="时延和丢包"></a>时延和丢包</h2><p>我们令 $La/R$ 为流量强度，其中 $a$为分组到达的速率，L为分组的长度，R为传输速率。如果流量强度$&gt;1$, 则比特到达队列的平均速率超过从该队列出去的速率。在这种情况下，该队列趋向于无线增加，并且排队时延将趋向无穷大。</p>
<p>在现实中，一条链路前的队列只有有限的容量，尽管排队容量极大的依赖于路由器设计和成本。因为该排队容量是有限的。当到达的分组塞满整个队列的时候，路由器就会丢弃新到达的分组。这就是<strong>丢包</strong> </p>
<p><strong>分组丢失的比例随着流量强度的增加而增加</strong></p>
<h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>考虑从服务器传送一个文件到客户的吞吐量，令$R_s$表示服务器与服务器之间的链路速率；$R_c$ 表示路由器与客户之间的链路速率。那么，服务器到哭护的吞吐量是多少？显然，其吞吐量是$\min{R_c,R_s }$ ,这就是说，吞吐率是<strong>瓶颈链路</strong> 的传输速率。</p>
<p>那么拓展到服务器和客户之间有N条链路的网络，这N条链路的传输速率分别是 $R_1,R_2,\cdots,R_N$ ，我们发现从服务器到客户的文件传输吞吐量是 $\min{R_1,R_2,\cdots,R_N}$ ,这同样是<strong>瓶颈链路</strong>的传输速率。</p>
<p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E7%BB%93/5.png" style="zoom:80%;"></p>
<p>假定$R_s=2Mbps, R_c=1 Mbps, R=5Mbps$, 并且公共链路为10个下载平等划分它的传输速率。这时每个下载的瓶颈不再位于接入网中，而是位于核心中的共享链路了，该瓶颈仅能为每个下载提供 500kbps的吞吐量。因此每个下载的端到端吞吐量现在减少到500kbps.</p>
<h1 id="协议层次及其服务模型"><a href="#协议层次及其服务模型" class="headerlink" title="协议层次及其服务模型"></a>协议层次及其服务模型</h1><p>因特网的协议栈由5个层次组成：物理层、链路层、网络层、运输层和应用层。我们采用了自顶向下方法,首先处理应用层，然后向下进行处理。</p>
<p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E7%BB%93/7.png" style="zoom:80%;"></p>
<p>数据包的发送与接收如下所示</p>
<p><img src="/2021/04/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%80%BB%E7%BB%93/8.png" style="zoom:80%;"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/04/26/%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E4%B8%8E%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/26/%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E4%B8%8E%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/" itemprop="url">大数定律与中心极限定理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-04-26T18:10:08+08:00">
                2021-04-26
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2021-06-27T22:34:58+08:00">
                2021-06-27
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="随机变量序列的两种收敛性"><a href="#随机变量序列的两种收敛性" class="headerlink" title="随机变量序列的两种收敛性"></a>随机变量序列的两种收敛性</h1><h2 id="依概率收敛"><a href="#依概率收敛" class="headerlink" title="依概率收敛"></a>依概率收敛</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>例子：</strong> 抛一个均匀的硬币，正面朝上和反面朝上的概率是相等的。我们把正面朝上的频率记为 $v_n=S_n/n$，其中$S_n$为正面朝上出现的次数，n为抛硬币的总次数，那么当把硬币一直抛下去，我们会发现频率序列 ${v_n}$ 会出现两个现象：</p>
<ol>
<li>频率$v_n$ 对频率p的绝对偏差$|v_n-p|$ 将随着n的增大而呈现逐渐减小的趋势，但无法说它就收敛域0</li>
<li>由于频率的随机性，绝对偏差 $|v_n-p|$ 时大时小，虽然我们无法排除大偏差发生的可能性，但随着n的不断增大，大偏差发生的可能性会越来越小。 <strong>这是一种新的极限概念</strong> </li>
</ol>
<p><img src="/2021/04/26/%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E4%B8%8E%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/1.png" style="zoom:150%;"></p>
<p>下面我们给出具体的定义：</p>
<p>设${X_n}$ 为一随机变量序列，X为一随机变量，如果对任意的 $\epsilon&gt;0$ ,有 </p>
<script type="math/tex; mode=display">
P(|X_n-X|\geq \epsilon)\rightarrow 0~~(n\rightarrow \infty)</script><p>则称${X_n}$ 依概率收敛于 $X$ ,记作  $X_p\xrightarrow{p}X$</p>
<p>依概率收敛的含义是： $X_n$ 对X 的绝对偏差不小于任意给定量的可能性将随着n的增大而越来越小。反过来说，绝对偏差$|X_n-X|$ 小于任一给定量的可能性将随着 $n$ 的增大而越来越接近与1。即上式可等价于：</p>
<script type="math/tex; mode=display">
P(|X_n-X|\leq \epsilon)\rightarrow 1 (n\rightarrow \infty)</script><p>特别的，我们要学习一种<strong>退化分布(单点分布)</strong>，这是一种最简单的离散型分布。其概率函数为：</p>
<script type="math/tex; mode=display">
p(x,y)=\begin{cases}1,  ~~x=a~\\ \\0, ~~ x\neq a \end{cases}</script><p>当$X$ 为退化分布时，即$P(X=c)=1$, 则称序列 ${X_n}$ 依概率收敛于c，即$X_n\xrightarrow{<del>~P</del>~}c$ </p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><h4 id="符合四则运算"><a href="#符合四则运算" class="headerlink" title="符合四则运算"></a>符合四则运算</h4><p>设 ${X_n},{Y_n}$ 是两个随机变量序列， $a,b$  是两个常数，如果</p>
<script type="math/tex; mode=display">
X_n\xrightarrow {~~~P~~~} a, Y_n\xrightarrow{~~~P~~~} b</script><p>则有：</p>
<script type="math/tex; mode=display">
1)~~ X_n\pm Y_n \xrightarrow{~~~P~~~} a\pm b\\
2)~~ X_n\times Y_n \xrightarrow{~~~P~~~}  a\times b\\
3)~~ X_n\div Y_n \xrightarrow{~~~P~~~} a\div b</script><p>也就是说依概率分布满足四则运算</p>
<h4 id="适用于函数"><a href="#适用于函数" class="headerlink" title="适用于函数"></a>适用于函数</h4><p>如果 $X_n\xrightarrow {~P~} X,g(x)$ 是直线上的连续函数，则： $g(X_n)\xrightarrow Pg(X)$ </p>
<p> <strong>例题：</strong></p>
<p>如果 $X_n\xrightarrow P a$, 则对任意常数c，试证： $cX_n\xrightarrow P ca$</p>
<p>我们可以令 $g(x) = cx$, 那么 $g(X_n) = cX_n\xrightarrow {~P~}g(a) = ca $ 得证。</p>
<h2 id="按分布收敛、弱收敛"><a href="#按分布收敛、弱收敛" class="headerlink" title="按分布收敛、弱收敛"></a>按分布收敛、弱收敛</h2><p>我们知道分布函数可以描述随机变量的统计规律，因此讨论一个分布函数序列${F_n(x)}$<strong>收敛到一个极限分布函数</strong>$F(x)$ 是有实际意义的。那么，如何来定义${F_n(x)}$的敛散性呢？</p>
<p>我们给出一些关于分布函数列的弱收敛定义：</p>
<p>对$F(x)$ 的<strong>任一连续点x</strong>，都有</p>
<script type="math/tex; mode=display">
\lim\limits_{n\rightarrow \infty} F_n(x)=F(x)</script><p>则称${F_n(x)}$ 弱收敛于$F(x)$, 记作：</p>
<script type="math/tex; mode=display">
F_n(x)\xrightarrow{~~~W~~~}F(x)</script><p>也称相应的随机变量序列 ${X_n}$ 按分布收敛与X，记作</p>
<script type="math/tex; mode=display">
X_n\xrightarrow{~~L~~} X</script><p>注意，这里要区分弱收敛和按分布收敛的异同，这是在两种不同场合给出的两种不同名称，其本质含义是一样的： </p>
<ul>
<li>分布函数序列${F_n(x)}$ 称为弱收敛</li>
<li>随机变量序列 ${X_n}$ 则称为按分布收敛，</li>
</ul>
<p>此外，还要注意是任一连续点，可以不包括离散点。若把离散点也囊括在内，那么这个条件就太强了，有很多反例。</p>
<h3 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h3><script type="math/tex; mode=display">
X_n\xrightarrow{~~~P~~~}X \Longrightarrow X_n\xrightarrow{~~~L~~~} X</script><p>也就是说，可以由依概率收敛推出按分部收敛。但是，这个定理的逆命题是不成立的。下面给一个反例：</p>
<h4 id="反例"><a href="#反例" class="headerlink" title="反例"></a>反例</h4><p>设随机变量X的分布列：</p>
<script type="math/tex; mode=display">
P(X=-1)=\frac{1}{2} ,P(X=1)=\frac{1}{2}</script><p>令 $X_n=-X$, 则$X_n$ 与$X$ 同分布，即$X_n$ 与 $X$，有相同的分布函数，故 $X_n\xrightarrow{<del>L</del>}X$ </p>
<p>但是对于任意的$0&lt;\epsilon&lt;2$  ，有：</p>
<script type="math/tex; mode=display">
P(|X_n-X|\geq \epsilon)=P(2|X|\geq \epsilon) =1 \nrightarrow 0</script><p> 即，一般按分部收敛与依概率收敛是不等价的</p>
<h3 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h3><p>若c为常数，则 $X_n\xrightarrow{<del>~P</del>~} c$ 的<strong>充要条件</strong>是 $X_n\xrightarrow{<del>~~L</del>~} c$</p>
<p>这个定理说明，当极限随机变量为常数(服从退化分布时)，按分布收敛与依概率收敛是等价的。</p>
<h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题:1"></a>例题:1</h4><p>设 $D(x)$ 为退化分布：</p>
<script type="math/tex; mode=display">
D(x)=\begin{cases}0, x<0 \\~\\1,x\geq 0\end{cases}</script><p>试问下列分布函数列的极限函数是否仍然为分布函数？(其中 $n=1,2\cdots$)</p>
<ol>
<li>${D(x+n)}$</li>
</ol>
<p>首先我们要求<strong>该分布函数列的极限函数</strong>F(x), 当 $n\rightarrow \infty$时候</p>
<script type="math/tex; mode=display">
D(x+n) = \begin{cases} 0, x<-\infty \\~\\ 1,x\geq -\infty \end{cases}</script><p>显然，$ D(x+n) = 0$ 是不可能出现的， 极限函数 $G(x) = 1, x\in R$ </p>
<p>这是不符合分布函数的性质：$\lim\limits_{n\rightarrow -\infty} G(x) = 0$</p>
<ol>
<li>${D(x+1/n)}$</li>
</ol>
<p>对于这个函数列，当$n\rightarrow \infty$ 时，$\frac{1}{n}\rightarrow 0$</p>
<script type="math/tex; mode=display">
D(x+n) = \begin{cases} 0, x<-\frac{1}{n} \\~\\ 1,x\geq -\frac{1}{n} \end{cases}</script><p>那么，其极限函数为</p>
<script type="math/tex; mode=display">
G(x) = \begin{cases} 0,x< 0 \\~\\1,x\geq0 \end{cases}</script><p>这符合极限函数的右连续性</p>
<ol>
<li>${D(x-1/n)}$</li>
</ol>
<p>这个函数列可写为：</p>
<script type="math/tex; mode=display">
D(x+n) = \begin{cases} 0, x< \frac{1}{n} \\~\\ 1,x\geq \frac{1}{n}    \end{cases}</script><p>那么，当 $n\rightarrow \infty$ 时，其极限函数可写为：</p>
<script type="math/tex; mode=display">
G(x) = \begin{cases} 0, x\leq 0 \\~\\ 1,x > 0 \end{cases}</script><p>这时候，极限函数<strong>不满足分布函数的右连续性</strong>，所以这不是一个分布函数。</p>
<h4 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h4><p>如果$X_n\xrightarrow L X$,且数列 $a_n\rightarrow a,b_n\rightarrow b$, 试证： $a_nX_n+b_n\xrightarrow L aX+b$ </p>
<h2 id="以概率1收敛"><a href="#以概率1收敛" class="headerlink" title="以概率1收敛"></a>以概率1收敛</h2><p>依概率1收敛亦称<strong>几乎必然收敛、几乎处处收敛、几乎肯定收敛</strong>，是随机变量列的一种<strong>较强的收敛性</strong>。若随机变量列以概率1收敛，则它必然依概率收敛，反之则未必。</p>
<h1 id="大数定律"><a href="#大数定律" class="headerlink" title="大数定律"></a>大数定律</h1><h2 id="大数定律一般形式"><a href="#大数定律一般形式" class="headerlink" title="大数定律一般形式"></a>大数定律一般形式</h2><p>设有一随机变量序列${X_n}$，加入它具有下列这个式子的性质，则称该随机变量序列${X_n}$ 服从大数定律：</p>
<p>对于任意的 $\epsilon &gt;0$, 有</p>
<script type="math/tex; mode=display">
\lim\limits_{n\rightarrow \infty} P(|\frac{1}{n}\sum_{i=1}^n X_i-\frac{1}{n}\sum_{i=1}^n E(X_i)|<\epsilon)=1</script><h2 id="常用的大数定律"><a href="#常用的大数定律" class="headerlink" title="常用的大数定律"></a>常用的大数定律</h2><p>现在已经知道了大数定律的一般形式，其实，常用的大数定律就是在不同条件下的一般情况的变形。</p>
<h3 id="伯努利大数定律"><a href="#伯努利大数定律" class="headerlink" title="伯努利大数定律"></a>伯努利大数定律</h3><p>设$S_n$ 为 n重伯努利试验中事件A出现的次数，称 $\frac{S_n}{n}$ 为事件A出现的频率。</p>
<p>那么如果记一次实验中A发生的概率为p，则$S_n$ 服从二项分布$b(n,p)$, 因此频率 $\frac{S_n}{n}$ 的数学期望与方差分别为：</p>
<script type="math/tex; mode=display">
E(\frac{S_n}{n}) = p, Var(\frac{S_n}{n})=\frac{p(1-p)}{n}</script><p>下面，给出伯努利大数定律的定义：</p>
<script type="math/tex; mode=display">
\lim\limits_{n\rightarrow\infty} P(|\frac{S_n}{n}-p|<\epsilon) = 1</script><p><strong>证明</strong>：我们可以用切比雪夫不等式$P(|X-E(X)|\geq \epsilon)\leq \frac{Var(X)}{\epsilon^2}$ 得：</p>
<script type="math/tex; mode=display">
1\geq P(|\frac{S_n}{n}-p|<\epsilon)\geq 1-\frac{Var(\frac{S_n}{n})}{\epsilon^2} =1-\frac{p(1-p)}{n\epsilon^2}</script><p>当$n\rightarrow \infty$ 时，上式右端趋于1，因此：</p>
<script type="math/tex; mode=display">
\lim\limits_{n\rightarrow \infty} P(|\frac{S_n}{n}-p|<\epsilon)=1</script><p>伯努利大数定律说明：随着 n 的增大，事件 A 发生的频率$\frac{S_n}{n}$ 与其概率p 的偏差 $|\frac{S_n}n -p|$ 大于与现给定的精度$\epsilon$ 的可能性愈来愈小。这就是<strong>频率稳定与概率的意义</strong></p>
<h3 id="切比雪夫大数定律"><a href="#切比雪夫大数定律" class="headerlink" title="切比雪夫大数定律"></a>切比雪夫大数定律</h3><p>切比雪夫大数定律也可以由切比雪夫不等式证明。</p>
<p>定义：</p>
<p>设${X_n}$为一列<strong>两两不相关</strong>的随机变量序列，若每个$X_i$ 的方差存在，且有共同的上界，即 $Var(X_i)\leq c,i=1,2\cdots,$ 则 ${X_n}$服从大数定律，即对任意的 $\epsilon &gt;0$,  满足：</p>
<script type="math/tex; mode=display">
\lim\limits_{n\rightarrow \infty} P(|\frac{1}{n}\sum_{i=1}^n X_i-\frac{1}{n}\sum_{i=1}^n E(X_i)|<\epsilon)=1</script><p>注意，切比雪夫大数定律只要求 ${X_n}$ 互不相关，<strong>并不要求他们是同分布的</strong>，因此，我们很容易推出：如果${X_n}$ 是独立同分布的随机变量数列，且方差有限，那么${X_n }$必定服从大数定律</p>
<p><strong>伯努利大数定律只是切比雪夫大数定律的特例</strong></p>
<h4 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h4><p>设 ${X_n}$ 是独立同分布的随机变量序列，$E(X_n^4)&lt;\infty$. 若令 $E(X_n)=\mu,Var(X_n)=\sigma^2$, 考察</p>
<script type="math/tex; mode=display">
Y_n = (X_n-\mu)^2,~~ n=1,2\cdots</script><p>证明随机变量序列 ${Y_n}$ 服从大数定律，即对任意的 $\epsilon &gt; 0$, 有：</p>
<script type="math/tex; mode=display">
\lim\limits_{n\rightarrow \infty} P(|\frac{1}{n}\sum_{i=1}^{n}(X_i-\mu)^2-\sigma^2|\geq \epsilon) = 0</script><p>解答思路：</p>
<p>首先，要满足大数定律，必须要让$Y_n$是独立同分布的(显然)，且<strong>方差有限(需证)</strong></p>
<p>其次，要满足上式，第一部分 $\frac{1}{n}\sum<em>{i=1}^n Y_i$ 是不用计算的，带入$Y_n$即可；第二部分$\frac{1}{n}\sum</em>{i=1}^n E(Y_i)$ 是需要计算的部分。</p>
<p>根据上面这个思路，我们先证明方差是有限的：</p>
<script type="math/tex; mode=display">
Var(Y_n) = Var(X_n-\mu)^2 =E[(X_n-\mu)^4]-E^2[(X_n-\mu)^2]\\
=E[(X_n-\mu)^4]-E^2(X-E(X))^2</script><p>已知 $E(X-E(X))^2=Var(X)$ 上式可化简为：</p>
<script type="math/tex; mode=display">
E[(X_n-\mu)^4] - Var^2(X) = E[(X_n-\mu)^4] - \sigma^4</script><p>因为 $E(X_n^4)$ 存在，故 $E(X_n^3),E(X_n^2),E[(X-\mu)^4]$ 也存在，因此$Y_n$的方差是存在的。</p>
<p>然后我们化简 $\frac{1}{n}\sum_{i=1}^nE(Y_i)$，</p>
<script type="math/tex; mode=display">
 E(Y_i)=E(X_i-\mu)^2 = E(X_i-E(X))^2 = Var(X_i)=\sigma^2</script><p>因此 </p>
<script type="math/tex; mode=display">
\frac{1}{n}\sum_{i=1}^n E(Y_i) = \frac{1}{n}\cdot n \sigma^2 = \sigma^2</script><p>得证。</p>
<h3 id="马尔科夫大数定律"><a href="#马尔科夫大数定律" class="headerlink" title="马尔科夫大数定律"></a>马尔科夫大数定律</h3><p>注意到以上大数定律的证明中，只要有</p>
<script type="math/tex; mode=display">
\frac{1}{n^2} Var(\sum_{i=1}^n X_i)\rightarrow 0</script><p>则大数定律就能成立，这个条件就被称为<strong>马尔科夫条件</strong></p>
<p>现在给出马尔科夫大数定律的定义：</p>
<p>对随机变量序列${X_n}$ ，若上面的<strong>马尔科夫条件</strong>成立，则${X_n}$服从大数定律</p>
<p><strong>马尔科夫大数定律的重要性在于</strong>：对${X_n} $ 已经没有<strong>任何</strong> <strong>同分布、独立性、不相关</strong> 的假定，切比雪夫大数定律显然可以由马尔科夫大数定律推出。</p>
<h4 id="例题：-1"><a href="#例题：-1" class="headerlink" title="例题："></a>例题：</h4><p>设 ${X<em>n}$ 为一<strong>同分布、方差存在</strong> 的随机变量序列，且$X_n$ 仅与相邻的 $X</em>{n-1}$ 和 $X_{n+1}$ 相关，而与其他的 $X_i$ 不相关。试问该随机变量序列 ${X_n}$ 是否服从大数定律？</p>
<p>要看是否服从，可以看其是否满足马尔科夫条件：</p>
<script type="math/tex; mode=display">
\frac{1}{n^2} Var(\sum_{i=1}^n X_i) =\frac{1}{n^2} [\sum_{i=1}^n Var(X_i)+2\sum_{i=1}^{n-1}Cov(X_i,X_{i-1})]</script><p>记 $Var(X_n)=\sigma^2$,则 $|Cov(X_i,X_j)|\leq \sigma^2$ 于是有：</p>
<script type="math/tex; mode=display">
\frac{1}{n^2}Var(\sum_{i=1}^n X_i)\leq \frac{1}{n^2} [n\sigma^2+2(n-1)\sigma^2]\rightarrow 0(n\rightarrow \infty)</script><p>也就是满足马尔科夫条件，则${X_n}$服从大数定律</p>
<h3 id="辛钦大数定律"><a href="#辛钦大数定律" class="headerlink" title="辛钦大数定律"></a>辛钦大数定律</h3><p>以上三个大数定律都假设随机变量序列 ${X_n}$ 的方差存在，以下的辛钦大数定律去掉了这一假设，仅设每个$X_i$ 的数学期望存在(因为数学期望存在并不能够推断数学方差存在)。但与此同时，要求${X_n}$为<strong>独立同分布的</strong>随机变量序列。因此，伯努利大数定律除了是切比雪夫不等式得特例外，也是辛钦大数定律的特例。</p>
<p>定义： 设${X_n}$ 为一<strong>独立同分布的</strong>随机变量序列，若$X_i$ 的数学期望存在，则 ${X_n}$ 符合大数定律，即对任意的$\epsilon &gt; 0$ ，</p>
<script type="math/tex; mode=display">
\lim\limits_{n\rightarrow \infty} P(|\frac{1}{n}\sum_{i=1}^n X_i-\frac{1}{n}\sum_{i=1}^n E(X_i)|<\epsilon)=1</script><p>成立。</p>
<p>所以说，像柯西分布这样的是不能用辛钦大数定律来</p>
<p>辛钦大数定律提供了求随机变量数学期望$E(X)$ 的近似值的方法： 设想对随机变量X独立重复地观察n次，第k次的观察值为$X<em>k$ , 则 $X_1,X_2,X_3\cdots,X_n$ 应该是相互独立的，且它们的分布应该与 X 的分布相同。所以，在$E(X)$ 存在的条件下，按照辛钦大数定律，当n足够大的时候，可以把平均观察值：$\frac{1}{n}\sum</em>{i=1}^n X_i$ 作为$E(X)$的近似值。这种做法的一个有点事我们可以不用去了解X的分布是什么。</p>
<p>此外，我们还要记住，如果${X<em>n}$为一独立同分布的随机变量序列，且 $E(|X_i|^k)$ 存在，其中k为正整数，则 ${X_n^k}$ 服从大数定律。也就是说我们可以用 $\frac{1}{n} \sum</em>{i=1}^n X_i^k$ 作为 $E(X_i^k)$ 的近似值。</p>
<h4 id="利用蒙特卡洛方法计算定积分"><a href="#利用蒙特卡洛方法计算定积分" class="headerlink" title="利用蒙特卡洛方法计算定积分"></a>利用蒙特卡洛方法计算定积分</h4><p>计算定积分： </p>
<script type="math/tex; mode=display">
J  = \int_0^1 f(x)dx</script><p>设随机变量X服从$(0,1)$上的均匀分布，则 $Y=f(x)$ 的数学期望是：</p>
<script type="math/tex; mode=display">
E(f(X))= \int_0^1 f(x) dx = J</script><p>所以估计J的值，就是估计$f(X)$ 数学期望的值。 由辛钦大数定律，可以用 $f(X)$的观察值的平均去估计$f(X)$的数学期望的值。</p>
<ol>
<li><p>先用计算机产生n个$(0,1)$上的均匀分布的随机数$x_i,i=1,2\cdots,n$ </p>
</li>
<li><p>然后对每个$x_i$计算$f(x_i)$</p>
</li>
<li><p>最后得J的估计值为：</p>
<script type="math/tex; mode=display">
J\approx\frac{1}{n} \sum_{i=1}^n f(x_i)</script></li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>常见的大数定律</th>
<th>需满足的条件</th>
</tr>
</thead>
<tbody>
<tr>
<td>伯努利大数定律</td>
<td>$Sn$ 服从二项分布，单个样本服从独立同分布的二点分布</td>
</tr>
<tr>
<td>切比雪夫大数定律</td>
<td>${X_n}$ 互不相关(并不是互相独立)，且有共同的方差上界</td>
</tr>
<tr>
<td>马尔科夫大数定律</td>
<td>没其他的要求，只要$\frac{1}{n^2} Var(\sum_{i=1}^n X_i)\rightarrow 0$</td>
</tr>
<tr>
<td>辛钦大数定律</td>
<td>设${X_n}$ <strong>独立同分布的</strong>，且 $X_i$ 的数学期望存在</td>
</tr>
</tbody>
</table>
</div>
<p>一般来说，都是利用马尔科夫大数定律来证明独立随机变量序列符合大数定律的</p>
<h4 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h4><ul>
<li>设 ${X_k}$ 为独立随机变量序列，且：$P(X_k = \pm \sqrt{\ln k})=\frac{1}{2}, k=1,2\cdots$   服从大数定律</li>
</ul>
<p><strong>首先: 判断使用哪种大数定律来解</strong>， 显然这不是二项分布，$X_n$ 也不是同分布的，所以我们可以利用<strong>马尔科夫大数定律或者切比雪夫大数定律</strong>来求解</p>
<p><strong>第二步：列出期望和方差</strong>: 在这题中，显然$E(X_k) = 0$, $Var(X_k) =2<em> \frac 12 </em>(\sqrt {\ln k}-0)^2 =\ln k$ （这里可以判断出来，${X_n}$ 不满足有共同的方差上界，因此不能使用切比雪夫大数定律，只能使用马尔科夫大数定律）</p>
<p><strong>第三步：判断是否满足马尔科夫条件</strong> ：由${X<em>n}$  独立可知， $Var(\sum</em>{i=1}^n X<em>i)= \sum</em>{i=1}^n Var(X_i) \leq n\ln n$ , 因此：</p>
<script type="math/tex; mode=display">
\frac{1}{n^2} Var(\sum_{i=1}^nX_i)\leq \frac{n\ln n}{n^2} \\~\\
n\rightarrow \infty ， \frac{\ln n}n\rightarrow 0</script><p>符合，所以符合大数定律</p>
<h4 id="例题2-1"><a href="#例题2-1" class="headerlink" title="例题2"></a>例题2</h4><ul>
<li><p>在伯努利试验中，事件A出现的概率为p，令</p>
<ul>
<li><script type="math/tex; mode=display">
X_n =\begin{cases}1, 若在第n次及第n+1次试验中A都出现\\ 0, 其他 \end{cases}</script></li>
<li><p>证明${X_n}$符合大数定律</p>
</li>
</ul>
</li>
</ul>
<p><strong>第一步：首先判断使用那种大数定律</strong>，显然 $X<em>n$ 不属于两点分布，不独立也不同分布($X_n$和$X</em>{n+1}$相关)。所以只能选择<strong>马尔科夫大数定律</strong></p>
<p><strong>第二步：求E(x) 和Var(x)</strong> : 可以列出</p>
<script type="math/tex; mode=display">
\begin{array}{c|cc}
X_n&1&0\\
\hline
P&p^2&{1-p^2}
\end{array}</script><p>因此$E(X_n)= p^2,Var(X_n)=p^2(1-p^2)$ </p>
<p><strong>第三步：判断是否满足马尔科夫大数定律 </strong></p>
<p>这里很重要的一点是，${X_n}$ 并不是互相独立的，因此我们在计算的时候需要加上协方差。</p>
<script type="math/tex; mode=display">
\frac1{n^2}Var(\sum_{i=1}^n X_n) = \frac{1}{n^2}[\sum_{i=1}^n Var(X_i)+2\sum_{i=1}^{n-1} Cov(X_i,X_i+1)]\\~\\</script><p>由协方差矩阵是一个非负定矩阵可得：</p>
<script type="math/tex; mode=display">
\begin{vmatrix}  cov(x_1,x_1) & cov(x_1,x_2) \\cov(x_2,x_1) &cov(x_2,x_2)   \end{vmatrix} \geq 0</script><p>这里不可能等于0，因此 </p>
<script type="math/tex; mode=display">
2\sum_{i=1}^{n-1} Cov(X_i,X_i+1)\leq 2\sqrt{Var(X_1)}\sqrt{Var(X_2)}\\~\\
\frac1{n^2}Var(\sum_{i=1}^n X_n) \leq \frac{1}{n^2}(np^2(1-p^2)+2(n-1)p^2(1-p^2))\rightarrow0</script><p>得证</p>
<h4 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h4><ul>
<li><p>设${X_n}$为独立同分布的随机变量序列，其共同分布：</p>
<ul>
<li><script type="math/tex; mode=display">
P(X_n = \frac{2^k}{k^2}) = \frac{1}{2^k}</script></li>
<li><p>试问其是否满足大数定律？</p>
</li>
</ul>
</li>
</ul>
<p><strong>第一步：判断使用哪种大数定律</strong></p>
<p>首先排除伯努利大数定律，又因为是独立同分布的，因此选择的范围很广，只要证明其期望存在就能利用辛钦大数定律证明其符合大数定律了。</p>
<p><strong>第二步: 计算期望</strong></p>
<script type="math/tex; mode=display">
E(X) = \sum_{i=1}^n(\frac{2^k}{k^2}\cdot\frac 1{2^k})=\sum_{i=1}^n \frac{1}{k^2}</script><p>根据数列的极限可以求出 $\sum_{i=1}^n\frac{1}{k^2}&lt;2$  显然是有限的，因此根据辛钦大数定律知${X_n}$ 服从大数定律。</p>
<h4 id="例题4"><a href="#例题4" class="headerlink" title="例题4"></a>例题4</h4><ul>
<li>设 ${X<em>n}$ 为独立同分布的随机变量序列，方差存在。又设 $\sum</em>{i=1}^n a<em>n$ 为绝对收敛级数。 令 $Y_n = \sum</em>{i=1}^n X_i$ 证明：${a_nY_n}$ 符合大数定律。</li>
</ul>
<p><strong>第一步：判断使用哪种大数定律</strong></p>
<p>首先排除伯努利分布定律，其次 ${a_nY_n}$ 的期望和方差都比较难判断，所以我们需要一些技巧。</p>
<p>不妨设 $E(X<em>n) = 0$, 则$Var(X_n) =E(X_n^2) = \sigma^2$ . 又因为 $\sum</em>{i=1}^na_n$ 收敛于常数，可以记为c。</p>
<p>可以尝试一下用<strong>马尔科夫大数定律</strong>来求解</p>
<p><strong>第二步：</strong></p>
<script type="math/tex; mode=display">
\sum_{i=1}^na_iY_i = \sum_{i=1}^na_i(\sum_{j=1}^i X_j) = \sum_{j=1}^nX_j(\sum_{i=j}^na_i)\\</script><p>现在，我们就可以将化简后的式子带入马尔科夫条件：</p>
<script type="math/tex; mode=display">
\frac{1}{n^2}Var(\sum_{i=1}^n a_iY_i )= \frac{1}{n^2} Var(\sum_{j=1}^n X_j\sum_{i=j}^na_j) =\frac{1}{n^2}(E(\sum_{j=1}^nX_j\sum_{i=j}^na_j)^2-0)\\~\\
=\frac{\sigma^2}{n^2}{\sum_{j=1}^n}(\sum_{i=j}^n a_i)^2 \leq \frac{c^2\sigma^2}{n} \rightarrow 0</script><p>也就是说，形如${a<em>nY_n}$，$Y_n = \sum</em>{i=1}^n$的随机变量序列我们可以将其化简为：</p>
<script type="math/tex; mode=display">
=\frac{\sigma^2}n{\sum_{i=1}^n}(\sum_{i=j}^n a_i)^2</script><p>的形式，然后，对 $a_i$ 进行放缩即可。</p>
<h4 id="例题5"><a href="#例题5" class="headerlink" title="例题5"></a>例题5</h4><p>例题5和例题4 差不多，设${X<em>n}$ 为独立同分布的随机变量序列，方差存在，令 $Y_n = \sum</em>{i=1}^n X_i$ 又设${a_n}$ 为一列常数，为一列常数，如果存在常数 $c&gt;0$ , 使得对n 有 $|na_n|\leq c$ 证明 ${a_nY_n}$ 服从大数定律。</p>
<p>同样，我们先设 $E(X_n)=0$ ，则 $Var(X_n)=E(X_n^2) = \sigma^2$对任意的$n\geq k$</p>
<script type="math/tex; mode=display">
\sum_{i=k}^n |a_i| \leq \frac{c}{n}(n-k+1)\\</script><p>因而：</p>
<script type="math/tex; mode=display">
\sum_{k=1}^n (\sum_{i=k}^n|a_i|)^2\leq \frac{c^2}{n^2}\sum_{k=1}^n(n-k+1)^2\\
=\frac{c^2}{n^2}\frac{n(n+1)(n+2)}{6}</script><p>仿照例题4，我们可以证明：</p>
<script type="math/tex; mode=display">
\frac{1}{n^2}Var(\sum_{i=1}^n a_iY_i )= \frac{1}{n^2} Var(\sum_{j=1}^n X_j\sum_{i=j}^na_j) =\frac{1}{n^2}(E\sum_{j=1}^nX_j\sum_{i=j}^na_j)^2\\~\\
=\frac{\sigma^2}{n^2}\sum_{j=1}^n\sum_{i=j}^n a_j^2\\~\\
\leq\frac{\sigma^2}{n^2} \frac{c^2}{n^2}\frac{n(n+1)(n+2)}{6}\rightarrow 0 (n\rightarrow \infty)</script><h1 id="中心极限定理"><a href="#中心极限定理" class="headerlink" title="中心极限定理"></a>中心极限定理</h1><h2 id="独立随机变量和"><a href="#独立随机变量和" class="headerlink" title="独立随机变量和"></a>独立随机变量和</h2><p>上一个part我们学的是大数定律，讨论的是在什么条件下，随机变量序列的算数平均依概率收敛到其均值的算数平均。 </p>
<p>现在，我们来讨论在<strong>什么条件</strong>下，独立的随机变量和</p>
<script type="math/tex; mode=display">
Y_n = \sum_{i=1}^n X_i</script><p>的分布函数会收敛于<strong>正态分布</strong></p>
<p>研究这个问题是很有用的，一个很大的应用场景就是误差。比如说</p>
<ul>
<li>机床方面，有机床振动与转速的影响</li>
<li>环境方面，有车间的温度，湿度、照明、工作电压的影响</li>
</ul>
<p>可以把这些误差的和记为$Y_n$ ,那么 $Y_n$是随机变量，可以将 $Y_n$看做是很多微小的随机波动之和：</p>
<script type="math/tex; mode=display">
Y_n = X_1+X_2+\cdots+X_n</script><p>当 $n\rightarrow \infty$ 时，$Y_n$的分布是什么？</p>
<p>通过卷积可以看到，当n越来越大时，其分布就越来越像一个正态分布。</p>
<p><img src="/2021/04/26/%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E4%B8%8E%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/1.jpg" style="zoom:150%;"></p>
<p>为了寻求 $Y_n$ 的极限分布有意义，有必要先研究一下问题的提法。上图可以看出：当 n 增大时，$p_n(y)$ 的中心右移，且$p_n(y)$的方差增大。这意味着，当 $n\rightarrow \infty$ 时，$Y_n$的分布中心也会趋向于 $\infty$,方差趋向 $\infty$。 说明分布是很不稳定的。</p>
<p>在中心极限定理的研究中，会对 $Y_n$ 进行标准化</p>
<script type="math/tex; mode=display">
Y_n^* = \frac{Y_n-E(Y_n)}{\sqrt{Var(Y_n)}}</script><p>由于 $E(Y_n^<em>),Var(Y_n^</em>)=1$，这就有可能看出 $Y_n^*$的极限分布是否为标准正态分布 $N(0,1)$</p>
<p><strong>中心极限定理就是研究随机变量和的极限分布在什么条件下为正态分布的问题</strong> </p>
<h2 id="独立同分布下中心极限定理"><a href="#独立同分布下中心极限定理" class="headerlink" title="独立同分布下中心极限定理"></a>独立同分布下中心极限定理</h2><h3 id="林德伯格-莱维中心极限定理"><a href="#林德伯格-莱维中心极限定理" class="headerlink" title="林德伯格-莱维中心极限定理"></a>林德伯格-莱维中心极限定理</h3><p>刚才我们给出了 $Y_n^*$ 的定义。那么当${X_n}$ 满足独立同分布的随机变量序列，且$E(X_i)=\mu,Var(X_i)=\sigma^2$ 都存在时，则对任意实数 y,</p>
<p>记</p>
<script type="math/tex; mode=display">
Y_n^* = \frac{X_1+X_2+\cdots+X_n-n\mu}{\sigma\sqrt n}</script><p>有</p>
<script type="math/tex; mode=display">
\lim\limits_{n\rightarrow \infty}P(Y_n^*\leq y) = \Phi(y) = \frac{1}{\sqrt {2\pi}} \int_{-\infty}^y e^{-\frac{t^2}{2}}dt</script><p>也就是说，当n充分大，就可以<strong>用正态分布去逼近随机变量和的分布</strong>。 </p>
<h2 id="二项分布的正态近似"><a href="#二项分布的正态近似" class="headerlink" title="二项分布的正态近似"></a>二项分布的正态近似</h2><h3 id="棣莫弗-拉布拉斯中心极限定理"><a href="#棣莫弗-拉布拉斯中心极限定理" class="headerlink" title="棣莫弗-拉布拉斯中心极限定理"></a>棣莫弗-拉布拉斯中心极限定理</h3><p>设 n 重伯努利试验中，事件A在每次试验中出现的概率为 p, 记$S_n$为n次试验中时间A出现的次数。</p>
<p>这时候， $Y_n^* = \frac{S_n - np}{\sqrt {npq}}$ </p>
<p>则对任意实数y ，有：</p>
<script type="math/tex; mode=display">
\lim\limits_{n\rightarrow \infty}P(Y_n^*\leq y) = \Phi(y) = \frac{1}{\sqrt {2\pi}} \int_{-\infty}^y e^{-\frac{t^2}{2}}dt</script><p>注： 因为二项分布是离散分布，而正态分布是连续分布，所以用正态分布作为二项分布的近似计算中，做些修正可以体高精度： 若 $k_1&lt;k_2$ 均为整数，一般先作如下修正后再用近似：</p>
<script type="math/tex; mode=display">
P(k_1\leq S_n\leq k_2) = P(k_1-0.5< S_n<k_2+0.5)</script><h4 id="例题：-2"><a href="#例题：-2" class="headerlink" title="例题："></a>例题：</h4><p>比如： $S_n\sim b(25,0.4),P(5\leq S_n\leq 15)$  的值。使用修正的正态近似之后：($E(X) = np =10,Var(X) = np(1-p) = 6$)</p>
<script type="math/tex; mode=display">
P(5\leq S_n\leq 15) = P(5-0.5<S_n<15+0.5)\\
\approx \Phi(\frac{15+0.5-10}{\sqrt 6})-\Phi(\frac{5-0.5-10}{\sqrt 6})\\
=2\Phi(2.245)-1</script><p>此外，开可以用修正的正态近似来计算 $P(S_n=k)$ </p>
<script type="math/tex; mode=display">
P(S_n=k) =P(k-0.5<S_n<k+0.5) =P(\frac{k-0.5-np}{\sqrt{npq}}<\frac{S_n-np}{\sqrt{npq}}<\frac{k+0.5-np}{\sqrt{npq}})\\</script><div class="table-container">
<table>
<thead>
<tr>
<th>中心极限定理种类</th>
<th>需要满足的条件</th>
</tr>
</thead>
<tbody>
<tr>
<td>林德伯格-莱维中心极限定理</td>
<td>$  {X_n}$独立同分布且期望方差均存在</td>
</tr>
<tr>
<td>棣莫弗-拉布拉斯中心极限定理</td>
<td>n重伯努利试验，事件A在每次试验中出现的概率为 p, 记$S_n$为n次试验中时间A出现的次数。 $Y_n^* = \frac{S_n - np}{\sqrt {npq}}$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="重要应用"><a href="#重要应用" class="headerlink" title="重要应用"></a>重要应用</h3><p>在中心极限定理的应用中，若记 $\beta =\Phi(y)$  ，则由这个中心极限定理给出的近似式：$P(Y_n^*\leq y)\approx \Phi(y) = \beta$ </p>
<p>可以用来解决三类计算问题：</p>
<h4 id="1-已知-n-beta-求-y"><a href="#1-已知-n-beta-求-y" class="headerlink" title="1. 已知$n,\beta$  求 $y$"></a>1. 已知$n,\beta$  求 $y$</h4><p>有一家珍珠奶茶店，只有两种产品，珍珠奶茶和纯奶茶。每杯珍珠奶茶里需要放<strong>5克珍珠</strong>。<strong>一天接单100笔</strong>，顾客以$\frac{1}{2}$的概率点珍珠奶茶。且假定顾客点单独立。有$95\%$ 的可能性不拒单。 问：要准备多少克珍珠？</p>
<p>解：我们设第i个顾客点珍珠奶茶记为 $X_i\sim b(1,p),p = 0.5$, </p>
<p>首先我们把已知量带入公式： 设买珍珠奶茶的顾客记为1，否则记为0，因为每一杯珍珠奶茶要放5g珍珠，因此要乘以5</p>
<script type="math/tex; mode=display">
P(5\sum_{i=1}^{100} X_i \leq x) \geq 95\%</script><p> 把 5 除到右边，留下 $\sum_{i=1}^{100}X_i\sim b(100,0.5)$ , 则 $E(\sum X) = np = 50,Var(\sum X) = 25$ 将 $X_i$  化成$X_i^*$ 用标准正态分布来计算。 </p>
<script type="math/tex; mode=display">
P(\frac{\sum X_i - E(\sum X_i)}{\sqrt{Var(\sum X_i)}}\leq \frac{\frac{x}{5}-E(\sum X_i)}{\sqrt{Var(\sum X_i)}})\geq 95\%\\</script><p>现在，已经可以用$P(Y_n^*\leq y)\approx \Phi(y) = \beta$  来计算了</p>
<script type="math/tex; mode=display">
\Phi(\frac{\frac{x}{5}-50}{25})\geq 0.95\\</script><p>解得，$x=288$ ，约等于290g 的珍珠，那么一共可以做58杯奶茶。</p>
<p><strong>注：在这里，没有使用修正，但在其他题目中一定要修正，是y修正！</strong></p>
<h4 id="2-已知-n-y-求-beta"><a href="#2-已知-n-y-求-beta" class="headerlink" title="2. 已知$n,y$  求 $\beta$"></a>2. 已知$n,y$  求 $\beta$</h4><p>还是一样的奶茶店， 现在变成顾客以0.6 的概率点珍珠奶茶，且假定顾客点单独立，那么问58杯珍珠奶茶能让店主不拒单的概率是多少？</p>
<p>首先我们要把已知量带入到公式中去：</p>
<script type="math/tex; mode=display">
P(Y_i^*\leq \frac{58-E(\sum X_i)}{\sqrt{Var(\sum X_i)}})\approx \beta</script><p>因为现在 $E(\sum X_i) = np = 60,Var(\sum X_i)=np(1-p) = 24$ ,带入得到：</p>
<script type="math/tex; mode=display">
\approx \Phi(\frac{58+\frac{1}{2}-60}{\sqrt{24}}) =0.379</script><p>我们看到，只要概率从0.5提升到0.6, 58杯奶茶的不拒单的概率从95% 降到了38%</p>
<h4 id="3-已知-y-beta-求-n"><a href="#3-已知-y-beta-求-n" class="headerlink" title="3. 已知$y,\beta$  求 $n$"></a>3. 已知$y,\beta$  求 $n$</h4><p>还是一样的奶茶店，顾客点珍珠奶茶的概率为p，通过历史流水数据估算的值为$\hat p$,   现在要保证有$95\%$ 的把握使得估算值 $\hat p$ 与真实值p之间的差异不大于$1\%$ ,问至少要有多少流水数据？</p>
<p>这就是 已知$y,\beta$  求样本数量$n$。我们令 </p>
<script type="math/tex; mode=display">
X_i = \begin{cases} 1, 第i个顾客点了珍珠奶茶 \\~\\ 0,其他 \end{cases}</script><p>那么，我们可以列出公式：</p>
<script type="math/tex; mode=display">
P(|\hat p -p|\leq 1\%)\geq 95\%\\
~\\
P(|\frac{\sum_{i=1}^n X_i}{n}-p|\leq 0.01)\geq 95\%\\
~\\</script><p>通过标准化，可以得到：</p>
<script type="math/tex; mode=display">
P(|\frac{\sum X_i - E(\sum X_i)}{\sqrt{Var(\sum X_i)}}|\leq \frac{0.01n}{\sqrt{Var(\sum X_i)}})\\
~\\
2\Phi(\frac{0.01 n}{\sqrt{np(1-p)}})-1\geq 0.95\\
n = (\frac{1.96}{0.01})^2 p(1-p)</script><p>我们看到，这个式子是有上限的，也就是当p=0.5 时，n最大约为9604</p>
<h2 id="独立不同分布下的中心极限定理"><a href="#独立不同分布下的中心极限定理" class="headerlink" title="独立不同分布下的中心极限定理"></a>独立不同分布下的中心极限定理</h2><h3 id="林德伯格中心极限定理"><a href="#林德伯格中心极限定理" class="headerlink" title="林德伯格中心极限定理"></a>林德伯格中心极限定理</h3><h3 id="李雅普诺夫中心极限定理"><a href="#李雅普诺夫中心极限定理" class="headerlink" title="李雅普诺夫中心极限定理"></a>李雅普诺夫中心极限定理</h3>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/04/23/UDPping%E7%A8%8B%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/23/UDPping%E7%A8%8B%E5%BA%8F/" itemprop="url">UDPping程序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-04-23T14:13:43+08:00">
                2021-04-23
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-08-25T04:30:10+08:00">
                2022-08-25
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="UDPping程序"><a href="#UDPping程序" class="headerlink" title="UDPping程序"></a>UDPping程序</h1><h2 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h2><p>在这个编程作业中，你将用 <strong>Java</strong> 编写一个客户ping程序。该客户将<strong>发送一个简单的ping报文</strong>，接收一个从服务器返回的对应pong报文，并确定从该客户发送ping报文到接收到pong报文为止的<strong>时延</strong>。 该时延称为<strong>往返时延（RTT）</strong>。由该客户和服务器提供的功能类似于在现代操作系统中可用的标准ping程序。然而，标准的ping使用互联网控制报文协议（ICMP）（我们将在第5章中学习ICMP）. 此时我们将创建一个非标准（但简单）的<strong>基于UDP的ping程序</strong>。</p>
<p>你的ping程序经UDP向目标服务器发送<strong>10个</strong>ping报文。对于每个报文，当对应的pong报文返回时，你的客户要确定和打印RTT。因为UDP是一个不可靠的协议，由客户发送的分组可能会丢失。为此，客户<strong>不能无限期</strong>地等待对ping报文的回答。客户等待服务器回答的时间<strong>至多为1秒</strong>；如果没有收到回答，客户假定该分组丢失并相应地打印一条报文。</p>
<p>在此作业中，你将给出服务器的完整代码（在配套网站中可找到）。你的任务是编写客户代码，该代码与服务器代码非常类似。建议你先仔细学习服务器的代码，然后编写你的客户代码，可以随意地从服务器代码中剪贴代码行。</p>
<p>电脑内置的ping程序示例：</p>
<p><img src="/2021/04/23/UDPping%E7%A8%8B%E5%BA%8F/1.png" style="zoom:80%;"></p>
<p>梳理题目之后，结合电脑中的ping程序示例，我们给出UDPServer的功能和UDPClient的功能</p>
<h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><ul>
<li>显示用户通过客户端发送来的消息内容(包含头部和payload)</li>
<li>能够<strong>模拟分组的丢失</strong>；能够<strong>模拟分组传输延迟</strong>；</li>
<li>将Client发送来的请求在延迟一段随机选择的时间(小于1s)后返回给客户端，作为收到请求的响应reply；  </li>
</ul>
<h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><ul>
<li>启动后发送10个request。发送一个request后，<strong>最多</strong>等待1秒以便接收server返回的消息。如果在1s内没有收到服务器的reply，则认为该请求或对该请求的reply已经丢失</li>
<li>在收到reply后立即发送下一个请求。</li>
<li>请求消息的payload中包含关键字PingUDP、序号、时间戳这些内容</li>
<li>计算传包总数，收到包的总数以及丢包率</li>
<li>为每个请求计算折返时间(RTT)，统计10个请求的min/avg/maxRTT。</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>我把这个项目写成了两个project：pingserver和pingclient,分别启动，更加直观一些</p>
<h3 id="pingserver"><a href="#pingserver" class="headerlink" title="pingserver"></a>pingserver</h3><h4 id="PingServer类"><a href="#PingServer类" class="headerlink" title="PingServer类"></a>PingServer类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PingServer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> intiPort;</span><br><span class="line">    <span class="keyword">private</span> DatagramSocket serverSocket;<span class="comment">//服务器码头</span></span><br><span class="line">    <span class="keyword">private</span> DatagramPacket receivePacket;<span class="comment">//接受数据分组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] buffer=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];<span class="comment">//数据缓冲区</span></span><br><span class="line">    Scanner scanner;</span><br><span class="line">    <span class="comment">//初始化端口号</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PingServer</span><span class="params">(<span class="keyword">int</span> intiPort)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.intiPort=intiPort;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PingServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"基于udp实现ping"</span>);</span><br><span class="line">        System.out.println(<span class="string">"------PING SERVER------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"请输入监听端口号"</span>);</span><br><span class="line">        scanner=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">this</span>.intiPort=scanner.nextInt();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//根据输入的端口生成server端socket实例</span></span><br><span class="line">            serverSocket=<span class="keyword">new</span> DatagramSocket(intiPort);<span class="comment">// 默认绑定本主机</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            CloseUtil.closeAll(serverSocket,scanner);</span><br><span class="line">            System.out.println(<span class="string">"监听端口："</span>+intiPort+<span class="string">"启动失败。请从新输入端口号"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.exit(<span class="number">0</span>);<span class="comment">//终止程序</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//监听是否有请求数据</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            receivePacket=<span class="keyword">new</span> DatagramPacket(buffer, buffer.length);<span class="comment">//空的数据包接受分组</span></span><br><span class="line">            <span class="comment">//监听是否有用户请求</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                serverSocket.receive(receivePacket);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"分组异常"</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果捕捉到了client发送的请求，那就生成一个新的服务线程来处理数据包</span></span><br><span class="line">            <span class="keyword">new</span> ServerThread(serverSocket,receivePacket).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ServerThread类"><a href="#ServerThread类" class="headerlink" title="ServerThread类"></a>ServerThread类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DatagramSocket serverSocket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DatagramPacket receivePacket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerThread</span><span class="params">(DatagramSocket serverSocket,</span></span></span><br><span class="line"><span class="function"><span class="params">                        DatagramPacket receivePacket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serverSocket = serverSocket;</span><br><span class="line">        <span class="keyword">this</span>.receivePacket = receivePacket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];<span class="comment">//数据缓冲区</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> randomTime=(<span class="keyword">long</span>)(Math.random()*<span class="number">1500</span>);<span class="comment">//模拟延迟时间</span></span><br><span class="line"></span><br><span class="line">        String sentence;<span class="comment">//接受到的数据</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(randomTime);<span class="comment">//休眠，模拟延迟</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"--模拟延时错误--"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(randomTime&gt;<span class="number">1000</span>)&#123;<span class="comment">//如果延迟大于1秒，数据丢失</span></span><br><span class="line">            sentence=<span class="string">"Date lose"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sentence=<span class="keyword">new</span> String(receivePacket.getData());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        InetAddress host=receivePacket.getAddress();<span class="comment">//获取ip地址</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> port=receivePacket.getPort();<span class="comment">//端口号</span></span><br><span class="line"></span><br><span class="line">        buffer=sentence.getBytes();<span class="comment">//数据—&gt;字节数组,用于发回客户端</span></span><br><span class="line"></span><br><span class="line">        DatagramPacket sendPacket=<span class="keyword">new</span> DatagramPacket(buffer, buffer.length</span><br><span class="line">                ,host,port); <span class="comment">//生成数据包，有了目的地址和端口号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket.send(sendPacket);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            CloseUtil.closeAll(serverSocket);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sentence);<span class="comment">//显示请求结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pingclient"><a href="#pingclient" class="headerlink" title="pingclient"></a>pingclient</h3><h4 id="PingClient类"><a href="#PingClient类" class="headerlink" title="PingClient类"></a>PingClient类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PingClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"基于udp实现ping"</span>);</span><br><span class="line">        System.out.println(<span class="string">"----PING CLIENT------"</span>);</span><br><span class="line">        Scanner scanner=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入主机号"</span>);</span><br><span class="line">        String host=scanner.nextLine();</span><br><span class="line">        System.out.println(<span class="string">"请输入端口号"</span>);</span><br><span class="line">        <span class="keyword">int</span> port=scanner.nextInt();</span><br><span class="line">        <span class="keyword">byte</span>[] buffer;<span class="comment">//数据包缓冲区</span></span><br><span class="line">        <span class="keyword">long</span>[] rtt=<span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">10</span>];<span class="comment">//用于存储10个rtt</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;<span class="comment">//模拟发送10个请求</span></span><br><span class="line">            SimpleDateFormat sdf=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-ddhh:mm:ss.SS"</span>);<span class="comment">//时间格式</span></span><br><span class="line"></span><br><span class="line">            Date sendBefore=<span class="keyword">new</span> Date();<span class="comment">//当前时间</span></span><br><span class="line">            String sentence=<span class="string">"head:request "</span>+i+<span class="string">" playload:UDP-Number: "</span></span><br><span class="line">                    +i+<span class="string">" TimeStamp："</span>+sdf.format(sendBefore);<span class="comment">//请求数据</span></span><br><span class="line">            DatagramSocket clientSocket=<span class="keyword">new</span> DatagramSocket();</span><br><span class="line"></span><br><span class="line">            InetAddress IP=InetAddress.getByName(host);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            buffer=sentence.getBytes();<span class="comment">//数据打包成字节数组</span></span><br><span class="line"></span><br><span class="line">            DatagramPacket sendPacket=<span class="keyword">new</span> DatagramPacket(buffer, buffer.length,IP,port);<span class="comment">//字节数组-&gt;分组</span></span><br><span class="line"></span><br><span class="line">            clientSocket.send(sendPacket);<span class="comment">//发送分组</span></span><br><span class="line"></span><br><span class="line">            DatagramPacket receivePacket=<span class="keyword">new</span> DatagramPacket(buffer, buffer.length);<span class="comment">//接受分组</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clientSocket.receive(receivePacket);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"分组接受异常"</span>);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//数据-&gt;字符串</span></span><br><span class="line">            String receiveSentence=<span class="keyword">new</span> String(receivePacket.getData());</span><br><span class="line"></span><br><span class="line">            Date receiveAfter=<span class="keyword">new</span> Date();<span class="comment">//接收时间</span></span><br><span class="line"></span><br><span class="line">            rtt[i-<span class="number">1</span>]=receiveAfter.getTime()-sendBefore.getTime();<span class="comment">//计算rtt</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(rtt[i-<span class="number">1</span>]&gt;=<span class="number">1000</span>)&#123;</span><br><span class="line">                rtt[i-<span class="number">1</span>]=<span class="number">1000</span>;</span><br><span class="line">                System.out.println(sentence+<span class="string">" Data Lose"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">                System.out.print(receiveSentence);<span class="comment">//显示返回的数据</span></span><br><span class="line">                System.out.println(<span class="string">" time="</span>+rtt[i-<span class="number">1</span>]+<span class="string">" ms"</span>);<span class="comment">//显示往返时间</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            clientSocket.close();</span><br><span class="line">        &#125;</span><br><span class="line">				<span class="comment">//进行统计</span></span><br><span class="line">      	dealRtt(rtt);</span><br><span class="line">        CloseUtil.closeAll(scanner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dealRtt</span><span class="params">(<span class="keyword">long</span>[] rtt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sumRtt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> maxRtt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> minRtt=rtt[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">byte</span> loss=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(rtt[i]&gt;=<span class="number">1000</span>)</span><br><span class="line">                loss++;</span><br><span class="line">            <span class="keyword">if</span>(rtt[i]&gt;maxRtt)</span><br><span class="line">                maxRtt=rtt[i];</span><br><span class="line">            <span class="keyword">if</span>(rtt[i]&lt;minRtt)</span><br><span class="line">                minRtt=rtt[i];</span><br><span class="line">            sumRtt+=rtt[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span> received = (<span class="keyword">byte</span>) (<span class="number">10</span>-loss);</span><br><span class="line">        <span class="keyword">double</span> rate = (<span class="keyword">double</span>)loss/<span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">"--- UDPServer ping statistics ---"</span>);</span><br><span class="line">        System.out.println(<span class="string">"10 packets transimitted, "</span>+received+<span class="string">" packets received, "</span>+ rate+<span class="string">"% packet loss."</span>);</span><br><span class="line">        System.out.println(<span class="string">"round-trip min/avg/max = "</span>+minRtt+<span class="string">"/"</span>+sumRtt/<span class="number">10</span>+<span class="string">"/"</span>+maxRtt+ <span class="string">" ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CloseUtil"><a href="#CloseUtil" class="headerlink" title="CloseUtil"></a>CloseUtil</h3><p>这个小组件是两个project都的，作用是用来关闭IO流的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloseUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeAll</span><span class="params">(Closeable...io)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Closeable temp:io)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                temp.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下图所示：</p>
<p><img src="/2021/04/23/UDPping%E7%A8%8B%E5%BA%8F/3.png" style="zoom:80%;"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8AExp8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8AExp8/" itemprop="url">计算机网络实验报告Exp8</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-04-22T23:32:39+08:00">
                2021-04-22
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-08-25T04:32:24+08:00">
                2022-08-25
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Exp8-UDP报⽂分析"><a href="#Exp8-UDP报⽂分析" class="headerlink" title="Exp8: UDP报⽂分析"></a>Exp8: UDP报⽂分析</h1><h2 id="⼀、实验⽬的"><a href="#⼀、实验⽬的" class="headerlink" title="⼀、实验⽬的"></a>⼀、实验⽬的</h2><p>了解 UDP 协议的⼯作原理</p>
<h2 id="⼆、实验任务"><a href="#⼆、实验任务" class="headerlink" title="⼆、实验任务"></a>⼆、实验任务</h2><p>使⽤Wireshark快速了解UDP协议</p>
<h2 id="三、实验过程"><a href="#三、实验过程" class="headerlink" title="三、实验过程"></a>三、实验过程</h2><h3 id="3-1-UDP-协议"><a href="#3-1-UDP-协议" class="headerlink" title="3.1 UDP 协议"></a>3.1 UDP 协议</h3><p>⽤户数据报(UDP)协议是运输层提供的⼀种最低限度的复⽤/分解服务，可以在⽹络层和正确的⽤户即进程间传输数据。UDP 是⼀种不提供不必要服务的轻量级运输协议，除了复⽤/分⽤功能和简单的差错检测之外，⼏乎就是 IP 协议了，也可以说它仅提供最⼩服务。UDP 是⽆连接的，因此在两个进程通信前没有握⼿过程。UDP 协议提供⼀种不可靠数据传输服务，也就是说，当⼀个进程讲⼀个报⽂发送进 UDP套接字时，UDP 协议并不保证该报⽂将到达接收进程。也正是由于 UDP 不修复错误，因此到达接收进程的报⽂也可能是乱序到达的。UDP 是⾯向报⽂的，这是因为 UDP 并不会对应⽤层传递下来的报⽂进⾏任何处理，对于报⽂的边界信息都会保存，向下交付时交付的是完整报⽂。</p>
<p><img src="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8AExp8/0.png" style="zoom:67%;"></p>
<h3 id="3-2-UDP-报⽂结构"><a href="#3-2-UDP-报⽂结构" class="headerlink" title="3.2 UDP 报⽂结构"></a>3.2 UDP 报⽂结构</h3><p>UDP ⾸部只有 4 个字段：源端⼝号、⽬的端⼝号、⻓度、校验和，其中每个字段<strong>由 2 个字节</strong>组成。</p>
<p><img src="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8AExp8/1.png" style="zoom:67%;"></p>
<h3 id="3-3-实验操作"><a href="#3-3-实验操作" class="headerlink" title="3.3 实验操作"></a>3.3 实验操作</h3><ol>
<li><p>在 Wireshark 中捕获数据包，然后执⾏⼀些会导致主机发送和接收多个 UDP 数据包的操作。也可以什么也不做，仅执⾏ wireshark 捕获以便获取其他程序发给您的 UDP 数据包。有⼀种特殊情况：简单⽹络管理协议（SNMP）在 UDP 内部发送 SNMP 消息，因此可能会在跟踪中找到⼀些SNMP 消息（以及 UDP 数据包）。</p>
</li>
<li><p>停⽌数据包捕获后，设置数据包筛选器，以便 Wireshark 仅显示在主机上发送和接收的 UDP 数据包。 选择其中⼀个 UDP 数据包并在详细信息窗⼝中展开 UDP 字段。</p>
</li>
</ol>
<p><img src="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8AExp8/2.jpg" style="zoom:67%;"></p>
<h4 id="task1"><a href="#task1" class="headerlink" title="task1:"></a>task1:</h4><p>从跟踪中选择⼀个 UDP 数据包。从此数据包中，识别并确定 UDP ⾸部字段，请为这些字段命名并将实验结果附在实验报告中。</p>
<p>UDP首部有8个字节，由4个字段构成，每个字段都是两个字节，<br>1.<strong>源端口</strong>： 源端口号，需要对方回信时选用，不需要时全部置0.<br>2.<strong>目的端口</strong>：目的端口号，在终点交付报文的时候需要用到。<br>3.<strong>长度</strong>：UDP的数据报文的长度（包括首部和数据）其最小值为8（只有首部）<br>4.<strong>校验和</strong>：检测UDP数据报在传输中是否有错，有错则丢弃。</p>
<p>下面这段报文节选自Wireshark捕捉到的一个UDP数据包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">User Datagram Protocol, Src Port: 52355, Dst Port: 8000</span><br><span class="line">    Source Port: 52355  		# 源端口</span><br><span class="line">    Destination Port: 8000	# 目标端口</span><br><span class="line">    Length: 76							# 长度为76字节</span><br><span class="line">    Checksum: 0x1545 [unverified] # 检验和</span><br><span class="line">    [Checksum Status: Unverified]	</span><br><span class="line">    [Stream index: 4]</span><br><span class="line">    [Timestamps]</span><br><span class="line">    UDP payload (68 bytes) # 数据部分是总长度减去首部的长度</span><br></pre></td></tr></table></figure>
<h4 id="task2"><a href="#task2" class="headerlink" title="task2:"></a>task2:</h4><p>根据选择的UDP数据包，确定 UDP 报头字段的⻓度，请将实验结果附在实验报告中。</p>
<p><img src="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8AExp8/2.png" style="zoom:67%;"></p>
<p>我们发现这个UDP报头字段的长度是8个字节，因为每个字段长度为两个字节：</p>
<p>Source Port: cc 83 ， 转换成十进制就是52355，即端口号</p>
<p>Destination Port：1f 40,转换成十进制就是8000</p>
<p>Length: 00 4c,转换成十进制就是76 也就是报文长度</p>
<h4 id="task3"><a href="#task3" class="headerlink" title="task3:"></a>task3:</h4><p>UDP⾸部中的⻓度字段的值指的是什么？使⽤捕获的 UDP 数据包进⾏验证，请将实验结果附在实验报告中。</p>
<p>UDP的数据报文的长度（包括首部和数据）其最小值为8（只有首部）。</p>
<p>比如说这个UDP报文，首部的长度是8个字节，data部分如下：</p>
<p><img src="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8AExp8/3.png" style="zoom:67%;">‘</p>
<p>我们发现Data部分的长度是68个bytes，从十六进制数字中也可以看出一共有68个字节。</p>
<h4 id="task4"><a href="#task4" class="headerlink" title="task4:"></a>task4:</h4><p> UDP 有效负载中可包含的最⼤字节数是多少？请将实验结果附在实验报告中。</p>
<p>因为UDP首部中，长度的字段只有2个字节也就是16位。所以能表示的最大数为$2^{16}-1=65535$ 。又UDP首部占据了8字节，所以有效负载中可包含的最⼤字节数是 $65535-8 = 65527$ 字节。</p>
<p><strong>⾸先先认识下有效负载</strong>：</p>
<blockquote>
<p>有效负载是被传输数据中的⼀部分，⽽这部分才是数据传输的最基本的⽬的，和有效负载⼀同被传送的数据还有：数据头或称作元数据，有时候也被称为开销数据，这些数据⽤来辅助数据传输。</p>
</blockquote>
<h4 id="task5"><a href="#task5" class="headerlink" title="task5:"></a>task5:</h4><p>最⼤可能的源端⼝号是多少？请将实验结果附在实验报告中。</p>
<p>因为端口号也只有2个字节，因此最大能表达的数为65535，因此最大可能的源端口号是 65535</p>
<p>在之前我们编写的UDP Provider和UDP searcher文件当中，我们可以来验证这个结论：</p>
<p>当我们申请65535端口的时候，是可以正常利用UDP来发送数据处理数据的</p>
<p><img src="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8AExp8/4.png" style="zoom:67%;"></p>
<p>但是当我们申请65536端口的时候，Java会给我们一个报错，说 Port out of range,说明 65536接口是非法的。</p>
<p><img src="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8AExp8/5.png" style="zoom:67%;"></p>
<h4 id="task6"><a href="#task6" class="headerlink" title="task6:"></a>task6:</h4><p>根据选择的UDP数据包指出UDP的协议号是多少？请以⼗六进制和⼗进制表示法给出答案，并将实验结果附在实验报告中。</p>
<p>协议号指的是一个协议在IP包头中的一个字段,IP头中的协议号用来说明IP报文中承载的是哪种协议.目的主机收到IP包后，根据IP协议号确定送给哪个模块（TCP/UDP/ICMP…）处理，送给TCP/UDP模块的报文根据端口号确定送给哪个应用程序处理。</p>
<p><img src="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8AExp8/6.png" style="zoom:67%;"></p>
<p>我们在IPV4报文中找到了UDP的协议号，是17</p>
<p>用同样的方法可以找到</p>
<p>TCP的协议号是6</p>
<p>HTTP的协议号是80</p>
<p>DNS的协议号是53</p>
<h4 id="task7"><a href="#task7" class="headerlink" title="task7:"></a>task7:</h4><p>观察发送 UDP 数据包后接收响应的 UDP 数据包，这是对发送的 UDP 数据包的回复，请描述两个数据包中<strong>端⼝号</strong>之间的关系。(提示：对于响应 UDP ⽬的地应该为发送 UDP 包的地址。）请将实验结果附在实验报告中。</p>
<p>我们找到了这样一组发送UDP数据包和响应的UDP数据包。</p>
<p><img src="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8AExp8/7.png" style="zoom:67%;"></p>
<p>他们的编号是532493和532494。</p>
<p>532493 这个包的源地址是：192.168.31.15也就是我本地的电脑地址，目的地址是180.153.91.44 ，源端口是52355，目的端口是8000</p>
<p>532494 这个包的原地址是：180.153.91.44，而目的地之是192.168.31.15, 源端口是8000，目的端口是52355</p>
<p><img src="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8AExp8/8.png" style="zoom:67%;"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A7/" itemprop="url">计算机网络报告7</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-04-15T23:51:34+08:00">
                2021-04-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-08-25T04:32:12+08:00">
                2022-08-25
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Exp7：基于TCP的Socket编程"><a href="#Exp7：基于TCP的Socket编程" class="headerlink" title="Exp7：基于TCP的Socket编程"></a>Exp7：基于TCP的Socket编程</h1><h2 id="⼀、实验⽬的"><a href="#⼀、实验⽬的" class="headerlink" title="⼀、实验⽬的"></a>⼀、实验⽬的</h2><p>学习使⽤Stream Socket（包括ServerSocket和Socket）</p>
<p>了解粘包概念</p>
<h2 id="⼆、实验任务"><a href="#⼆、实验任务" class="headerlink" title="⼆、实验任务"></a>⼆、实验任务</h2><p>使⽤Socket和ServerSocket编写代码</p>
<p>解决粘包问题</p>
<h2 id="三、实验过程"><a href="#三、实验过程" class="headerlink" title="三、实验过程"></a>三、实验过程</h2><h3 id="3-1-基础知识"><a href="#3-1-基础知识" class="headerlink" title="3.1 基础知识"></a>3.1 基础知识</h3><h4 id="3-1-1-Socket和ServerSocket交互过程"><a href="#3-1-1-Socket和ServerSocket交互过程" class="headerlink" title="3.1.1 Socket和ServerSocket交互过程"></a>3.1.1 Socket和ServerSocket交互过程</h4><p><img src="/2021/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A7/1.png" style="zoom:67%;"> </p>
<h4 id="3-1-2-建⽴服务器端"><a href="#3-1-2-建⽴服务器端" class="headerlink" title="3.1.2 建⽴服务器端"></a>3.1.2 建⽴服务器端</h4><ul>
<li>服务器建⽴通信ServerSocket</li>
<li>服务器建⽴Socket接收客户端连接</li>
<li>建⽴IO输⼊流读取客户端发送的数据</li>
<li>建⽴IO输出流向客户端发送数据消息</li>
</ul>
<h4 id="3-1-3-建⽴客户端"><a href="#3-1-3-建⽴客户端" class="headerlink" title="3.1.3 建⽴客户端"></a>3.1.3 建⽴客户端</h4><p>创建Socket通信，设置通信服务器的IP和Port</p>
<p>建⽴IO输出流向服务器发送数据消息</p>
<p>建⽴IO输⼊流读取服务器发送来的数据消息</p>
<h3 id="3-2-⼩试⽜⼑-TCP传输案例"><a href="#3-2-⼩试⽜⼑-TCP传输案例" class="headerlink" title="3.2 ⼩试⽜⼑: TCP传输案例"></a>3.2 ⼩试⽜⼑: TCP传输案例</h3><p>在src⽂件夹下新建⼀个Package，名为exp7</p>
<ul>
<li>编写TCPServer类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">9090</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServerSocket server = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 配置⼀些参数</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server.setReuseAddress(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server.setReceiveBufferSize(<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 绑定到本地端⼝上，backlog为50（请求在socket上的最⼤待处理连接数）</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(Inet4Address.getLocalHost(),</span><br><span class="line">                    PORT), <span class="number">50</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Server: 服务器已监听端⼝："</span>);</span><br><span class="line">        System.out.println(server.getInetAddress() + <span class="string">": "</span> +</span><br><span class="line">                server.getLocalPort());</span><br><span class="line"><span class="comment">// 等待客户端连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Server: 阻塞等待客户端连接中..."</span>);</span><br><span class="line">            Socket client = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                client = server.accept();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Server: 捕获成功"</span>);</span><br><span class="line"><span class="comment">// 在连接后，启动⼀个线程接管与客户端的交互操作</span></span><br><span class="line">            ClientHandler clientHandler = <span class="keyword">new</span> ClientHandler(client);</span><br><span class="line">            clientHandler.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理与客户端交互</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Socket socket;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ClientHandler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">            System.out.println(<span class="string">"Server: 新客户端连接："</span> + socket.getInetAddress() +</span><br><span class="line">                    <span class="string">": "</span> + socket.getPort());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 得到socket的输⼊输出流</span></span><br><span class="line">                InputStream inputStream = socket.getInputStream();</span><br><span class="line">                OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">// todo: task2 replace</span></span><br><span class="line">                <span class="keyword">int</span> len = inputStream.read(bytes);</span><br><span class="line">                StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                stringBuilder.append(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line">                <span class="comment">// todo: added for task1 to test multiple clients</span></span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                 Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line">                System.out.println(<span class="string">"Server: 收到客户端消息："</span> + stringBuilder);</span><br><span class="line"><span class="comment">// 消息回写</span></span><br><span class="line">                outputStream.write(stringBuilder.toString().getBytes());</span><br><span class="line">                outputStream.close();</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Server: 连接异常断开"</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Server: 客户端已退出："</span> + socket.getInetAddress() +</span><br><span class="line">                    <span class="string">": "</span> + socket.getPort());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编写TCPClient类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Inet4Address;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">9090</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket();</span><br><span class="line"><span class="comment">// 连接本地9090端⼝，timeout为3000ms</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket.connect(<span class="keyword">new</span> InetSocketAddress(Inet4Address.getLocalHost(),</span><br><span class="line">                    PORT), <span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Client: 客户端为："</span> + socket.getLocalAddress() + <span class="string">": "</span> +</span><br><span class="line">                socket.getLocalPort());</span><br><span class="line">        System.out.println(<span class="string">"Client: 服务器为："</span> + socket.getInetAddress() + <span class="string">": "</span> +</span><br><span class="line">                socket.getPort());</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = socket.getInputStream();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            outputStream = socket.getOutputStream();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        String s = <span class="string">"test client send"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            outputStream.write(s.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">// 接收服务器返回的消息</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            len = (inputStream.read(bytes));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        stringBuilder.append(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line">        System.out.println(<span class="string">"Client: 收到服务器端消息："</span> + stringBuilder);</span><br><span class="line"><span class="comment">// 资源释放</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            outputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Client: 客户端已退出～"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="task1"><a href="#task1" class="headerlink" title="task1:"></a>task1:</h4><p>分别运⾏Server端和2个Client端，请将运⾏结果附在实验报告中。 </p>
<p>当我们不使用while(true)时，tcpserver只接受一个客户端传来的信息，如下图所示：</p>
<p><img src="/2021/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A7/3.png" style="zoom:67%;"></p>
<p>那么，当sever一直开启时：我们在main函数中创建多个client线程，向服务器发送连接请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// write your code here</span></span><br><span class="line">        Thread server = <span class="keyword">new</span> Thread(<span class="keyword">new</span> TCPServer());</span><br><span class="line">        ArrayList&lt;Thread&gt; clients = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">            Thread client = <span class="keyword">new</span> Thread(<span class="keyword">new</span> TCPClient());</span><br><span class="line">            clients.add(client);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        server.start();</span><br><span class="line">        <span class="keyword">for</span> (Thread client:clients)</span><br><span class="line">            client.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A7/4.png" style="zoom:67%;"></p>
<h4 id="task2"><a href="#task2" class="headerlink" title="task2:"></a>task2:</h4><p>⽤下段代码修改TCPServer中// todo task2：replace 后的三⾏，试运⾏Server端和Client端，观察运⾏结果，并将实验结果及产⽣的原因附在实验报告中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> len;</span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    stringBuilder.append(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A7/5.png" style="zoom:67%;"></p>
<p>我们发现TCPServer和TCPClient已经建立了连接，但是在处理客户端信息时出现了错误，导致一直卡在哪儿不能继续运行下去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> len = inputStream.read(bytes);</span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    stringBuilder.append(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line">System.out.println(<span class="string">"Server: 收到客户端消息："</span> + stringBuilder);</span><br></pre></td></tr></table></figure>
<p>经过 测试，发现当 去掉While循环，便可以正常执行。</p>
<p>但这并不是一种好方法，因为当输入的 inputStream 信息很庞大，但是我只能读取前1024个字节。</p>
<p>其实，这里while循环不结束的原因是在client里面，当送出 outputStream之后，并没有关闭socket。因此server就会误以为后面还会有信息进来，因此一直在等待。虽然在client最后关闭了outputStream，但是那是在收到了server回传的信息之后了，这就形成了一个死锁。要解决这个问题，就要将这个socket关闭。 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">      outputStream.write(s.getBytes());</span><br><span class="line">      outputStream.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关闭后，恢复正常：</p>
<p><img src="/2021/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A7/6.png" style="zoom:67%;"></p>
<h4 id="task3"><a href="#task3" class="headerlink" title="task3:"></a>task3:</h4><p>使⽤Scanner修改TCPClient类，达成如下效果，请将实验结果附在实验报告中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client reads a line of characters from its keyboard and sends data to server</span><br><span class="line">server receives the data and converts characters to uppercase</span><br><span class="line">server sends modified data to client</span><br><span class="line">client receives modified data and displays line on its screen</span><br></pre></td></tr></table></figure>
<p>只需要修改client即可；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s = scanner.nextLine();</span><br><span class="line">outputStream.write(s.getBytes());</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A7/7.png" style="zoom:67%;"></p>
<h4 id="task4"><a href="#task4" class="headerlink" title="task4:"></a>task4:</h4><p>在task3的基础上继续TCPServer类和TCPClient类，Client端能够读取多⾏从控制台输⼊的数据分别发送，Server端收到后分别回写（请测试数据为中⽂时的情况），请将实验结果附在实验报告中。</p>
<ul>
<li>Server</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">9090</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      .</span><br><span class="line">        System.out.println(<span class="string">"服务器已监听端口："</span>);</span><br><span class="line">        System.out.println(server.getInetAddress() + <span class="string">": "</span> +</span><br><span class="line">                server.getLocalPort());</span><br><span class="line"><span class="comment">// 等待客户端连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"阻塞等待客户端连接中..."</span>);</span><br><span class="line">            Socket client = server.accept();</span><br><span class="line">            System.out.println(<span class="string">"连接成功"</span>);</span><br><span class="line"><span class="comment">// 在连接后，启动⼀个线程接管与客户端的交互操作</span></span><br><span class="line">            ClientHandler clientHandler = <span class="keyword">new</span> ClientHandler(client);</span><br><span class="line">            clientHandler.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理与客户端交互</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Socket socket;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ClientHandler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">            System.out.println(<span class="string">"新客户端连接："</span> + socket.getInetAddress() +</span><br><span class="line">                    <span class="string">": "</span> + socket.getPort());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                InputStream inputStream = socket.getInputStream();</span><br><span class="line">                OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> len = inputStream.read(bytes);</span><br><span class="line">                    StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                    stringBuilder.append(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line">                    System.out.println(<span class="string">"收到客户端消息："</span> + stringBuilder);</span><br><span class="line">                    outputStream.write(stringBuilder.toString().getBytes());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"连接异常断开"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Client</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Inet4Address;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">9090</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket();</span><br><span class="line"><span class="comment">// 连接本地9090端⼝，timeout为3000ms</span></span><br><span class="line">        socket.connect(<span class="keyword">new</span> InetSocketAddress(Inet4Address.getLocalHost(),</span><br><span class="line">                PORT), <span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">"客户端为："</span> + socket.getLocalAddress() + <span class="string">": "</span> +</span><br><span class="line">                socket.getLocalPort());</span><br><span class="line">        System.out.println(<span class="string">"服务器为："</span> + socket.getInetAddress() + <span class="string">": "</span> +</span><br><span class="line">                socket.getPort());</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            String s = scanner.nextLine();</span><br><span class="line">            outputStream.write(s.getBytes());</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">// 接收服务器返回的消息</span></span><br><span class="line">            <span class="keyword">int</span> len = (inputStream.read(bytes));</span><br><span class="line">            System.out.println(<span class="string">"收到服务器端消息："</span> + <span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A7/8.png" style="zoom:67%;"></p>
<h3 id="3-3-什么是粘包"><a href="#3-3-什么是粘包" class="headerlink" title="3.3 什么是粘包"></a>3.3 什么是粘包</h3><ul>
<li>TCP本质上并不会发⽣数据层⾯的粘包</li>
<li>TCP的发送⽅和接收⽅⼀定会确保数据是以⼀种有序的⽅式到达的</li>
<li>所谓的粘包是数据处理逻辑层⾯上的粘包，即应⽤层上的</li>
</ul>
<p><img src="/2021/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A7/2.png" style="zoom:67%;"></p>
<h4 id="task5"><a href="#task5" class="headerlink" title="task5:"></a>task5:</h4><p>查阅资料，分析粘包可能产⽣的原因并搜索若⼲种解决⽅法（&gt;=3），并附在实验报告中。</p>
<p>在socket网络程序中，TCP和UDP分别是面向连接和非面向连接的。因此TCP的socket编程，收发两端（客户端和服务器端）都要有成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小、数据量小的数据，合并成一个大的数据块，然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。</p>
<p><strong>粘包出现原因</strong></p>
<ol>
<li>发送端需要等缓冲区满才发送出去，造成粘包</li>
</ol>
<p>发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一包数据。若连续几次发送的数据都很少，通常TCP会根据优化算法把这些数据合成一包后一次发送出去，这样接收方就收到了粘包数据。</p>
<ol>
<li>接收方不及时接收缓冲区的包，造成多个包接收</li>
</ol>
<p>接收方引起的粘包是由于接收方用户进程不及时接收数据，从而导致粘包现象。这是因为接收方先把收到的数据放在系统接收缓冲区，用户进程从该缓冲区取数据，若下一包数据到达时前一包数据尚未被用户进程取走，则下一包数据放到系统接收缓冲区时就接到前一包数据之后，而用户进程根据预先设定的缓冲区大小从系统接收缓冲区取数据，这样就一次取到了多包数据。 </p>
<p>为了避免粘包现象，可采取以下几种措施：</p>
<p>（1）对于发送方引起的粘包现象，用户可通过<strong>编程设置</strong>来避免，TCP提供了强制数据立即传送的操作指令push，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；<strong>但是</strong>但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。</p>
<p>（2）对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象；<strong>但是</strong>第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包</p>
<p>（3）由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。<strong>但是</strong>第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。比如说认为确定一个消息边界。</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/04/12/os-Project2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/12/os-Project2/" itemprop="url">os-Project2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-04-12T12:40:22+08:00">
                2021-04-12
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2025-04-09T23:23:53+08:00">
                2025-04-09
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Project2-进程调度"><a href="#Project2-进程调度" class="headerlink" title="Project2 进程调度"></a>Project2 进程调度</h1><h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p>在MINIX3中实现 Earlist-Deadline-First 近似实时调度功能：</p>
<ol>
<li>提供设置进程执行期限的系统调度 <code>chrt(long deadline)</code> ,用于将调用该系统调用的进程设为实时进程，其执行的期限为：从调用处开始deadline秒。例如：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//……</span></span><br><span class="line">chrt(<span class="number">10</span>);<span class="comment">/* 该程序将可以运行的最长时间为10秒，若没有运行结束，则强制结束*/</span></span><br><span class="line"><span class="comment">//……</span></span><br></pre></td></tr></table></figure>
<p><code>chrt</code>的定义：</p>
<p><code>int chrt(long deadline);</code>  deadline 是最后期限值(秒)，返回值1表示成功，返回值0表示该调用出错</p>
<ol>
<li>在内核进程表中需要增加一个条目，用于表示进程的实时属性；修改相关代码，新增一个系统调用chrt，用于设置其进程表中的实时属性。</li>
<li>修改proc.c和proc.h中相关的调度代码，实现最早deadline的用户进程相对于其它用户进程具有更高的优先级，从而被优先调度运行。</li>
<li>在用户程序中，可以在不同位置调用多次chrt系统调用，在未到deadline之前，调用chrt将会改变该程序的deadline。</li>
<li>未调用chrt的程序将以普通的用户进程(非实时进程)在系统中运行</li>
</ol>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="增加系统调用chrt"><a href="#增加系统调用chrt" class="headerlink" title="增加系统调用chrt"></a>增加系统调用<code>chrt</code></h3><p>MINIX3中的系统调用结构分成三个层次：应用层，服务层，内核层。在这三层中分别进行代码修改，实现系统调用chrt的信息传递。从应用层用<code>_syscall</code>将信息传递到服务层，在服务层用<code>_kernel_call</code>将信息传递到内核层，在内核层对进程结构体增加deadline成员。</p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>需要添加的系统调用chrt可以定义在unistd头文件中，并在libc中添加chrt函数体实现。</p>
<ul>
<li>在<code>/usr/src/include/unistd.h</code>中添加chrt函数定义</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chrt</span><span class="params">(<span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>这里我犯了一个很愚蠢的错误，一开始我写的是 <code>int char(long deadline)</code>，虽然kernel编译成功但是在编译test.c 的时候却始终找不到chrt 函数，经过修改后排除错误</p>
<ul>
<li>在<code>/usr/src/minix/lib/libc/sys/chrt.c</code>中添加chrt函数实现。可用alarm函数实现超时强制终止。参照该文件夹下fork.c文件，在实现中通过<code>_syscall</code>(调用号)向系统服务传递。例如：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span>(_syscall(PM_PROC_NR, PM_FORK, &amp;m));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>chrt.c</code>如下图所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/cdefs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"namespace.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;lib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chrt</span><span class="params">(<span class="keyword">long</span> deadline)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> <span class="title">tz</span>;</span></span><br><span class="line">    message m;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;m,<span class="number">0</span>,<span class="keyword">sizeof</span>(m));</span><br><span class="line">    <span class="comment">//设置alarm</span></span><br><span class="line">    alarm((<span class="keyword">unsigned</span> <span class="keyword">int</span>)deadline);</span><br><span class="line">    <span class="comment">//将当前时间记录下来 算deadline</span></span><br><span class="line">    <span class="keyword">if</span>(deadline&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    gettimeofday(&amp;tv,&amp;tz);</span><br><span class="line">    deadline = tv.tv_sec + deadline; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存deadline</span></span><br><span class="line">    m.m2_l1=deadline;</span><br><span class="line">  	<span class="comment">//把m传到服务层当中去</span></span><br><span class="line">    <span class="keyword">return</span>(_syscall(PM_PROC_NR,PM_CHRT,&amp;m));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>timeval</code> 使用来获得时间的</p>
<p><code>timezone</code> 是用来获得时区的</p>
<p> <code>gettimeofday</code> 用来获取当前的时间的函数，包含在头文件 <code>#include &lt;sys/time.h&gt;</code> 中</p>
<p><code>_syscall</code>函数可以用来查找系统调用。PM_PROC_NR 将会用来存放PM_CHRT的系统调用号，</p>
<ul>
<li>在<code>/usr/src/minix/lib/libc/sys</code>中 <code>Makefile.inc</code>文件添加chrt.c条目（添加C文件后，需在同目录下的Makefile/Makefile.inc中添加条目）</li>
</ul>
<p><img src="/2021/04/12/os-Project2/1.png" style="zoom:67%;"> </p>
<h4 id="服务层："><a href="#服务层：" class="headerlink" title="服务层："></a>服务层：</h4><p>需要向MINIX系统的进程管理服务中注册chrt，使得chrt服务可以向应用层提供。</p>
<ul>
<li>在<code>/usr/src/minix/servers/pm/proto.h</code>中添加<code>do_chrt</code>函数定义。</li>
</ul>
<p><img src="/2021/04/12/os-Project2/12.png"></p>
<p>因为 <code>do_chrt</code> 的功能是调用 <code>sys_chrt()</code>函数，并不需要传入参数，所以这里写<code>void</code></p>
<ul>
<li>在<code>/usr/src/minix/servers/pm/chrt.c</code>中添加<code>chrt</code>函数实现，调用<code>sys_chrt()</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"pm.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;minix/syslib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;minix/callnr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;minix/com.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;minix/vm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mproc.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;minix/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_chrt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// who_p 是用来获取进程信息的，类型是endpoint_t;m_in.m2_l1就是deadline</span></span><br><span class="line">    sys_chrt(who_p, m_in.m2_l1); </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在<code>/usr/src/minix/include/minix/callnr.h</code>中定义<code>PM_CHRT</code>编号。用来帮助应用层的系统调用能找到</li>
</ul>
<p><img src="/2021/04/12/os-Project2/2.png" style="zoom:67%;"></p>
<p>我一开始没有定义 PM_CHRT 的编号，导致 make build 的时候总是报告称<code>error: use of undeclared identifier &#39;PM_CHRT&#39;</code></p>
<ul>
<li>在<code>/usr/src/minix/servers/pm/Makefile</code>中添加<code>chrt.c</code>条目。</li>
</ul>
<p><img src="/2021/04/12/os-Project2/3.png" style="zoom:67%;"></p>
<ul>
<li>在<code>/usr/src/minix/servers/pm/table.c</code>中调用映射表。</li>
</ul>
<p><img src="/2021/04/12/os-Project2/4.png" style="zoom:67%;"></p>
<ul>
<li>在<code>/usr/src/minix/include/minix/syslib.h</code>中添加<code>sys_chrt()</code>定义。</li>
</ul>
<p><img src="/2021/04/12/os-Project2/5.png" style="zoom:67%;"></p>
<ul>
<li>在<code>/usr/src/minix/lib/libsys/sys_chrt.c</code>中添加<code>sys_chrt ()</code>实现。可参照该文件夹下的<code>sys_fork</code>文件，在实现中通过<code>_kernel_call</code> (调用号)向内核传递。例如：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_fork</span><span class="params">(parent, child, child_endpoint, flags, msgaddr)</span></span>&#123;</span><br><span class="line">	_kernel_call(SYS_FORK, &amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"syslib.h"</span></span></span><br><span class="line"><span class="comment">// 目的就是把进程和deadline提取出来，然后调用 kernel_call() 传入内核</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_chrt</span><span class="params">(proc_ep, deadline)</span></span></span><br><span class="line"><span class="function"><span class="keyword">endpoint_t</span> proc_ep</span>;</span><br><span class="line"><span class="keyword">long</span> deadline;</span><br><span class="line">&#123;</span><br><span class="line">    message m;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    m.m2_i1 = proc_ep; <span class="comment">//m2_i1 支持传送一个 int 类型的数据</span></span><br><span class="line">    m.m2_l1 = deadline; <span class="comment">// m2_l1 支持传送一个long 类型的数据</span></span><br><span class="line">  <span class="comment">//和syscall一样，这里通过SYS_CHRT和do_chrt的映射，把message传入内核层并调用do_chrt修改进程信息</span></span><br><span class="line">    r=_kernel_call(SYS_CHRT, &amp;m);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;、</span><br></pre></td></tr></table></figure>
<ul>
<li>在<code>/usr/src/minix/lib/libsys</code>中的<code>Makefile</code>中添加<code>sys_chrt.c</code>条目。</li>
</ul>
<p><img src="/2021/04/12/os-Project2/6.png"></p>
<h4 id="内核层"><a href="#内核层" class="headerlink" title="内核层"></a>内核层</h4><p>在MINIX内核中实现进程调度功能，此处可以直接修改内核信息，例如<strong>进程的截至时间</strong>。</p>
<ul>
<li>在<code>/usr/src/minix/kernel/system.h</code>中添加<code>do_chrt</code>函数定义。</li>
</ul>
<p><img src="/2021/04/12/os-Project2/8.png"></p>
<ul>
<li>在 <code>/usr/src/minix/kernel/config.h</code>中添加 <code>USE_CHRT</code></li>
</ul>
<p>踩坑：这一步虽然在实验说明中没有写，但是我们要加上去。否则在编译 测试文件的时候会报错</p>
<p><img src="/2021/04/12/os-Project2/14.png"></p>
<ul>
<li>在<code>/usr/src/minix/kernel/system/do_chrt.c</code>中添加<code>do_chrt</code>函数实现。参考该文件下的<code>do_fork</code>文件，修改调用者进程信息。例如：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span>(_syscall(PM_PROC_NR, PM_FORK, &amp;m));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="do-chrt-c"><a href="#do-chrt-c" class="headerlink" title="do_chrt.c"></a>do_chrt.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/system.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/vm.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;minix/endpoint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;minix/u64.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_CHRT</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_chrt</span><span class="params">(struct proc *caller, message *m_ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">rp</span>;</span></span><br><span class="line">    <span class="keyword">long</span> exp_time;</span><br><span class="line">    exp_time = m_ptr-&gt;m2_l1;</span><br><span class="line">    <span class="comment">//通过 proc_addr 定位内核中进程地址</span></span><br><span class="line">    rp = proc_addr(m_ptr-&gt;m2_i1);</span><br><span class="line">    <span class="comment">//将消息结构体中的deadline 赋值给该进程的 p_deadline</span></span><br><span class="line">    rp-&gt;deadline = exp_time;</span><br><span class="line">    <span class="keyword">return</span> (OK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* USE_CHRT */</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>在<code>/usr/src/minix/kernel/system/</code>中<code>Makefile.inc</code>文件添加<code>do_chrt.c</code>条目。</li>
</ul>
<p><img src="/2021/04/12/os-Project2/7.png"></p>
<ul>
<li>在<code>/usr/src/minix/include/minix/com.h</code>中定义<code>SYS_CHRT</code>编号。方便Kernel_Call找到SYS_CHRT函数。</li>
</ul>
<p><img src="/2021/04/12/os-Project2/9.png"></p>
<ul>
<li>在<code>/usr/src/minix/kernel/system.c</code>中添加<code>SYS_CHRT</code>编号到<code>do_chrt</code>的映射。</li>
</ul>
<p><img src="/2021/04/12/os-Project2/10.png"></p>
<ul>
<li>在<code>/usr/src/minix/commands/service/parse.c</code>的<code>system_tab</code>中添加名称编号对。</li>
</ul>
<p><img src="/2021/04/12/os-Project2/11.png"></p>
<p>踩坑：这个文件中有两个struct，一个都是 <code>VM_****</code>,一个都是 <code>SYS_****</code> ,不要放错，我因为这个调试了很久</p>
<h3 id="Minix3中的进程调度"><a href="#Minix3中的进程调度" class="headerlink" title="Minix3中的进程调度"></a>Minix3中的进程调度</h3><ul>
<li><p>MINIX3使用一种多级调度算法。进程优先级数字越小，优先级越高，根据优先级不同分成了16个可运行进程队列。每个队列内部采用时间片轮转调度，找到最高非空优先级队列，选取队列首部可运行的进程，当用完了时间片，则移到当前队列的队尾（详见教材P124）。</p>
</li>
<li><p><strong>将EDF添加到多级调度算法</strong>中，可控制入队实现<strong>实时调度</strong>（也可有其他新颖方式，得分更高）。入队是将当前剩余时间（终止时间-运行时间）大于0的进程添加到某个优先级队列，即设置进程优先级（需要选择合适的优先级否则执行效果不理想）。</p>
</li>
<li><p>在该队列内部将时间片轮转调度改成剩余时间最少优先调度，即将剩余时间最小的进程移到队列首部。</p>
</li>
<li><p>进程调度模块位于<code>/usr/src/minix/kernel/</code>下的<code>proc.h</code>和<code>proc.c</code>，修改影响进程调度顺序的部分。</p>
<h4 id="proc-h"><a href="#proc-h" class="headerlink" title="proc.h"></a>proc.h</h4></li>
<li><p>struct proc 维护每个进程的信息，用于调度决策。添加deadline成员。</p>
<p>利用xcode 可以很清楚得看见 proc 这个结构的内部成员：</p>
<p><img src="/2021/04/12/os-Project2/13.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc * <span class="title">pick_proc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="comment">//...	</span></span><br><span class="line">	<span class="keyword">long</span> deadline;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="proc-c"><a href="#proc-c" class="headerlink" title="proc.c"></a>proc.c</h4></li>
<li><p>switch_to_user() 选择进程进行切换。</p>
</li>
<li><p>enqueue_head() 按优先级将进程加入列队首。实验中需要将实时进程的优先级设<strong>置成合适的</strong>优先级。这里我设置成了5。也就是说，当我给进程设置了 deadline 之后，这个实时进程的优先级就会变成5。然后多级调度算法就会发现这个较高的优先级并执行入队操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(rp-&gt;deadline &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      rp-&gt;p_priority = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>enqueue() 按优先级将进程加入列队尾。同上。</p>
</li>
<li><p>pick_proc() 从队列中返回一个可调度的进程。遍历<strong>设置的</strong>优先级队列，<strong>返回剩余时间最小并可运行的进程</strong>。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc * <span class="title">pick_proc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* Decide who to run now.  A new process is selected an returned.</span></span><br><span class="line"><span class="comment"> * When a billable process is selected, record it in 'bill_ptr', so that the </span></span><br><span class="line"><span class="comment"> * clock task can tell who to bill for system time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function always uses the run queues of the local cpu!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">rp</span>;</span>			<span class="comment">/* process to run */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> **<span class="title">rdy_head</span>;</span></span><br><span class="line">  <span class="keyword">int</span> q;				<span class="comment">/* iterate over queues */</span></span><br><span class="line">	<span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">next</span>;</span> <span class="comment">// 中间变量,用来指代下一个进程</span></span><br><span class="line">  <span class="comment">/* Check each of the scheduling queues for ready processes. The number of</span></span><br><span class="line"><span class="comment">   * queues is defined in proc.h, and priorities are set in the task table.</span></span><br><span class="line"><span class="comment">   * If there are no processes ready to run, return NULL.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  rdy_head = get_cpulocal_var(run_q_head);</span><br><span class="line">  <span class="keyword">for</span> (q=<span class="number">0</span>; q &lt; NR_SCHED_QUEUES; q++) &#123;	</span><br><span class="line">      <span class="keyword">if</span>(!(rp = rdy_head[q])) &#123;</span><br><span class="line">        TRACE(VF_PICKPROC, <span class="built_in">printf</span>(<span class="string">"cpu %d queue %d empty\n"</span>, cpuid, q););</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    	<span class="comment">//这里是新加入的部分</span></span><br><span class="line">    </span><br><span class="line"> 	<span class="keyword">if</span> (q == <span class="number">5</span>) &#123; <span class="comment">/* 如果优先级等于5，说明可能是设置deadline的进程，下面要找剩余时间最小的进程*/</span></span><br><span class="line">        rp = rdy_head[q];</span><br><span class="line">        next = rp-&gt;p_nextready;</span><br><span class="line">        <span class="comment">/* 拿到当前和下一个进程 */</span></span><br><span class="line">        <span class="keyword">while</span> (next != <span class="literal">NULL</span>) &#123;<span class="comment">//遍历进程</span></span><br><span class="line">            <span class="keyword">if</span> (next-&gt;deadline &gt; <span class="number">0</span>) &#123; <span class="comment">/* 再次判断，防止原本优先级就是7的进程，留下用了chrt的 */</span></span><br><span class="line">            <span class="comment">/* 如果当前的进程deadline为0了，或者说是当前进程的剩余时间比下一个进程的剩余时间更长 </span></span><br><span class="line"><span class="comment">            * 那么，就需要交换这两个进程，最终将会筛选得到剩余时间最短的进程。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">                <span class="keyword">if</span> (rp-&gt;deadline == <span class="number">0</span> || (rp-&gt;deadline &gt; next-&gt;deadline))&#123;</span><br><span class="line">                    <span class="keyword">if</span> (proc_is_runnable(next)) &#123; <span class="comment">//判断是否在运行</span></span><br><span class="line">                        rp = next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">/* 比下一个 */</span></span><br><span class="line">          next = next-&gt;p_nextready;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      assert(proc_is_runnable(rp));</span><br><span class="line">      <span class="keyword">if</span> (priv(rp)-&gt;s_flags &amp; BILLABLE)	 	</span><br><span class="line">        get_cpulocal_var(bill_ptr) = rp; <span class="comment">/* bill for system time */</span></span><br><span class="line">      <span class="keyword">return</span> rp;</span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><p>测试用例来说明这个函数更直观：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;lib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//创建三个子进程，并赋予子进程id</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      proc(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> loop;</span><br><span class="line">  <span class="keyword">switch</span> (id)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//子进程1，设置deadline=20</span></span><br><span class="line">    chrt(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"proc1 set success\n"</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//子进程2，设置deadline=15</span></span><br><span class="line">    chrt(<span class="number">15</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"proc2 set success\n"</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">//子进程3，普通进程</span></span><br><span class="line">    chrt(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"proc3 set success\n"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (loop = <span class="number">1</span>; loop &lt; <span class="number">40</span>; loop++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//子进程1在5s后设置deadline=5</span></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">1</span> &amp;&amp; loop == <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      chrt(<span class="number">5</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Change proc1 deadline to 5s\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子进程3在10s后设置deadline=3</span></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">3</span> &amp;&amp; loop == <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      chrt(<span class="number">3</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Change proc3 deadline to 3s\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">//睡眠，否则会打印很多信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"prc%d heart beat %d\n"</span>, id, loop);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>编译完成之后，我们把测试用的 <code>test.c</code>文件放到   文件夹下，然后 <code>clang test.c -o test</code> 编译文件 <code>./test</code> 运行可执行文件，结果如下图所示：</p>
<p><img src="/2021/04/12/os-Project2/15.png"></p>
<p>显然这个答案并不是正确的，但是起码在kernel中添加了chrt 函数。第二天我调试了四五个小时(主要时间花在编译上面)，将内核层多次删改后再次尝试，这次成功了：</p>
<p><img src="/2021/04/12/os-Project2/16.png"></p>
<p>在测试中，在<code>main</code>函数中<code>fork</code>三个子进程(P1, P2, P3)，并为每个子进程设置id。</p>
<p><code>P1</code>和<code>P2</code>为实时进程，<code>deadline</code>分别设为20s和15s。</p>
<p>三个子进程会打印出子进程id和循环次数。</p>
<p>第0s时：优先级<code>P2 &gt; P1 &gt; P3</code>;</p>
<p>第5s 时：P1设置deadline为5s，P1调用chrt(5);</p>
<p>第5s后：优先级<code>P1 &gt; P2 &gt; P3</code>;</p>
<p>第10s时：P3设置deadline为3s，P3调用chrt(3);</p>
<p>第10s后：优先级<code>P3 &gt; P2</code>;</p>
<p>n 打印输出信息，观察子进程执行顺序是否正确.</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>MINIX的不同服务模块和内核都是运行在不同进程中，只能使用基于消息的进程间系统调用/内核调用，不能使用直接调用普通C函数。</li>
<li>添加调用编号，需要修改取值范围限制。</li>
<li>以源码为准（博客等资料版本落后）。</li>
<li>善用source insight高级功能（调用关系，全局搜索）。</li>
<li>善用git diff 检查代码修改。修改涉及文件较多，git diff可直观看到修改内容，避免引入无意的错误。</li>
<li>善用FileZilla功能。连接虚拟机，拉取需修改的文件，修改后上传到虚拟机。</li>
</ul>
<h3 id="编译方法"><a href="#编译方法" class="headerlink" title="编译方法"></a>编译方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ &#96;cd &#x2F;usr&#x2F;src&#96;</span><br><span class="line">+ &#96;make build&#96; #首次编译，或者修改了头文件，Makefile时使用，时间较长。</span><br><span class="line">+ &#96; Make build MKUPDATE&#x3D;yes&#96; #增量式编译，适用于少量C源代码修改时使用。</span><br><span class="line">+ &#96;reboot&#96; #重启，默认情况下自动选择latest kernel（新生成的kernel），需要原始版本时手工选择。</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>这次实验要求我们修改的东西很多，我的解决步骤是：</p>
<p>应用层$\longrightarrow$服务层$\longrightarrow$内核层$\longrightarrow$修改进程调度算法</p>
<p>在每一part做完之后，都会编译一下kernal，如果没有报错，说明修改的代码没有问题</p>
</li>
<li><p>找到效率高的工作流很重要。我的工作软件如下：</p>
<p>Typora 负责步骤查看和报告撰写</p>
<p>Terminus 负责用ssh连接虚拟机与命令操作</p>
<p>Transmit3 负责用ftp连接虚拟机的文件系统，配合xcode 修改代码</p>
<p>Chrome、Acrobat 用于博客查看与资料查阅</p>
</li>
</ul>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/04/11/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F3-4-3-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/11/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F3-4-3-5/" itemprop="url">多维随机变量3.4-3.5</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-04-11T23:26:07+08:00">
                2021-04-11
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2021-06-27T21:08:40+08:00">
                2021-06-27
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="多维随机变量的特征数"><a href="#多维随机变量的特征数" class="headerlink" title="多维随机变量的特征数"></a>多维随机变量的特征数</h1><h2 id="多维随机变量函数的数学期望"><a href="#多维随机变量函数的数学期望" class="headerlink" title="多维随机变量函数的数学期望"></a>多维随机变量函数的数学期望</h2><p>当 $y=g(x_1)$ 的时候，我们由第二章的公式可以得出 </p>
<script type="math/tex; mode=display">
E(Y)=\begin{cases}\sum_{x_i}g(x_i)P(X=x_i) ~~在离散情况下 \\ \\ \int_{-\infty}^{\infty} g(x) p(x) dx ~~在连续情况下\end{cases}</script><p>那么推广到$Y=g(x)=p(x_1,x_2,\cdots,x_n)$  时</p>
<script type="math/tex; mode=display">
E(Y) =\begin{cases}\sum\limits_{x_1}\sum\limits_{x_2}\cdots\sum\limits_{x_n}g(x_1,x_2,\cdots,x_n)P(X_1=x_1,\cdots,X_n=x_n) ~~在离散情况下 \\ \\ \int_{-\infty}^{\infty}\cdots\int_{-\infty}^{\infty} g(x_1,x_2,\cdots,x_n) p(x_1,x_2,\cdots,x_n) dx_1dx_2\cdots dx_n  ~~在连续情况下\end{cases}</script><h2 id="数学期望与方差的运算性质"><a href="#数学期望与方差的运算性质" class="headerlink" title="数学期望与方差的运算性质"></a>数学期望与方差的运算性质</h2><h3 id="性质1"><a href="#性质1" class="headerlink" title="性质1"></a>性质1</h3><p>设 $(X,Y)$ 是二维随机变量，则有 $E(X+Y)=E(X)+E(Y)$ </p>
<p>证明还是比较重要的：</p>
<script type="math/tex; mode=display">
E(X+Y)= \int_{-\infty}^{\infty}\int_{-\infty}^{\infty} (x+y)p(x,y)dxdy\\
=\int_{-\infty}^{\infty}x[\int_{-\infty}^{\infty}p(x,y)dy]dx+\int_{-\infty}^{\infty}y[\int_{-\infty}^{\infty}p(x,y)dx]dy\\
=\int_{-\infty}^\infty xp_X(x)dx+\int_{-\infty}^\infty yp_Y(y)dy\\
=E(X)+E(Y)</script><p>这个性质可以描述为：<strong>和的期望等于期望的和</strong>。这个性质还可以推广到 n维随机变量场合，即</p>
<p>$E(X_1+X_2+\cdots+X_n)=E(X_1)+E(X_2)+\cdots+E(X_n)$ </p>
<h3 id="性质2"><a href="#性质2" class="headerlink" title="性质2"></a>性质2</h3><p>若随机变量<strong>X与Y相互独立</strong>，则有 $E(XY)=E(X)E(Y)$ </p>
<p>这个性质可以描述为： 在独立场合，<strong>随机变量乘积的数学期望</strong>等于<strong>数学期望的乘积</strong>。  </p>
<p>这个性质还可以推广到n维随机变量场合，即若$X_1,X_2\cdots,X_n$ <strong>相互独立</strong>，则有</p>
<p>$E(X_1X_2\cdots X_n)=E(X_1)E(X_2)\cdots E(X_n)$ </p>
<h3 id="性质3"><a href="#性质3" class="headerlink" title="性质3"></a>性质3</h3><p>若<strong>随机变量X与Y相互独立</strong>，则有 $Var(X\pm Y)=Var(X)+Var(Y)$ </p>
<p>这个性质表明： 独立变量代数和方差等于各方差之和。但要注意次性质对标准差不成立。即$\sigma(X\pm Y)\neq \sigma(X)+\sigma(Y)$ </p>
<p>标准差只能通“先方差，后标准差”求得，即$\sigma(X\pm Y)=\sqrt{Var(X)+Var(Y)}$ </p>
<p>这个性质可以推广到<strong>n维随机变量场合</strong> ，即若$X_1,X_2,\cdots,X_n$ 相互独立，则有</p>
<p>$Var(X_1\pm X_2\pm\cdots\pm X_n) = Var(X_1)+Var(X_2)+\cdots+Var(X_n)$ </p>
<p>这表明，对<strong>独立随机变量</strong>来说，它们之间无论是相加还是相减，其方差总是逐个累计起来，只会增加，不会减少。</p>
<p><strong>特别的</strong>，当n个相互独立同分布(方差为$\sigma^2$)的随机变量$X_1,X_2,\cdots,X_n )$ 的算术平均的方差为</p>
<script type="math/tex; mode=display">
Var(\frac{1}{n}\sum\limits_{i=1}^nX_i)=\frac{\sigma^2}{n}</script><h4 id="例题：离散情况"><a href="#例题：离散情况" class="headerlink" title="例题：离散情况"></a>例题：离散情况</h4><p>从数字$0,1,\cdots,n$ 中任取两个不同的数字，求这两个数字之差的绝对值和数学期望。</p>
<p><strong>第一步：列出x,y的联合分布列</strong></p>
<p>这里面是从$0\sim n$中取2个不同的数字，那么 </p>
<script type="math/tex; mode=display">
p(x=i,y=j)=\frac{1}{n(n-1)}, 0\leq i,j\leq n,i\neq j</script><p><strong>第二步：判断是否可以利用期望的性质，如果不能就按照定义求期望，否则可以用性质简化计算</strong></p>
<p>这里是<strong>二元随机变量</strong>，因此公式可以写为： $\sum_x\sum_yg(x)p(x,y)$ </p>
<p>这里还要注意，要我们求得是差的绝对值因此要拆成两部分求和</p>
<script type="math/tex; mode=display">
E(|X-Y|)=\frac{1}{n(n-1)}\sum_{x=0}^n\{\sum_{y=0}^x(x-y)+\sum_{y=x+1}^n(y-x)\}=\frac{1}{n(n-1)}\sum_{x=0}^n\{x^2-nx+n(n+1)/2\}</script><p>注意,$\sum_{x=0}^n x^2 = \frac{n(n+1)(2n+1)}{6}$ </p>
<p>因此，原式等于：</p>
<script type="math/tex; mode=display">
\frac{1}{n(n-1)}\sum_{x=0}^n\{x^2-nx+n(n+1)/2\} = \frac{1}{n(n-1)}(\frac{n(n+1)(2n+1)}6-\frac{n(n)(n+1)}2+\frac{n(n+1)^2}{2})=\frac{n+2}3</script><h4 id="例题：连续情况"><a href="#例题：连续情况" class="headerlink" title="例题：连续情况"></a>例题：连续情况</h4><p>在长为a的线段上任取两个点 $X$ 和 $Y$ ,求此两点间的平均长度</p>
<p><strong>第一步：列出x，y的联合分布</strong></p>
<p>因为X与Y都服从$(0,a)$上的均匀分布，且 X,Y 相互独立，所以$<X,Y>$ 的联合密度函数为：</X,Y></p>
<script type="math/tex; mode=display">
p(x,y) = \begin{cases}\frac{1}{a^2} ~~0<x<a,0<y<a \\ \\ 0 ~~ 其他\end{cases}</script><p><strong>第二步，判断是否可以利用期望的性质，如果不能就按照定义求期望，否则可以用性质简化计算</strong></p>
<p>这里是二元随机变量，所以公式可写为：$E(g(x))=\int<em>{-\infty}^\infty\int</em>{-\infty}^\infty g(x)p(x,y)dxdy$ </p>
<p>要求两点间的平均长度，就是要求$E(|X-Y|)$,</p>
<script type="math/tex; mode=display">
E(|X-Y|) = \int_0^a\int_0^a|x-y|\frac{1}{a^2}dxdy</script><p>直接求绝对值不太方便，我们拆成两部分，首先将常数 $\frac{1}{a^2}$ 提出</p>
<script type="math/tex; mode=display">
=\frac{1}{a^2}\{\int_{0}^a\int_0^x(x-y)dydx+\int_0^a\int_x^a(y-x)dy dx\}\\
=\frac{1}{a^2}\{\int_0^a(x^2-ax+\frac{a^2}{2})dx\}=\frac{a}{3}</script><h4 id="例题：当随机变量是极值分布时"><a href="#例题：当随机变量是极值分布时" class="headerlink" title="例题：当随机变量是极值分布时"></a>例题：当随机变量是极值分布时</h4><p>设在区间$(0,1)$上随机取n个点，求相聚最远的两点间的距离的数学期望</p>
<p><strong>第一步，定义极值分布，列出目标期望</strong></p>
<p>分别记 n个点为 $X_1,X_2\cdots,X_n$, 那么这n个点相互独立，且都服从 区间上$(0,1)$的均匀分布$U(0,1) $</p>
<p>所以 $p_X(x)=1,0&lt;x&lt;1; F_X(x)=x$</p>
<p>我们的目的是求 $E(\max{X_1,X_2\cdots,X_n}-\min{X_1,X_2\cdots,X_n})$ </p>
<p>因此，我们可以令 $Z=\max{X_1,X_2,\cdots,X_n}, T=\min{X_1,X_2\cdots,X_n}$ </p>
<p>根据极值分布的定义，可以分别写出Z和T的分布函数和密度函数：</p>
<script type="math/tex; mode=display">
F_Z(z)=[F_x(z)]^n = z^n\\p_Z(z) = nz^{n-1} ,0<z<1\\
F_T(t)=1-[1-F_X(t)]^n = 1-[1-t]^n \\p_T(t)=n(1-t)^{n-1},0<t<1,</script><p><strong>第二步，判断是否可以利用期望的性质求解</strong></p>
<p>因为求Z和T的联合分布列是比较困难的，因为他们不是独立分布的。所以我们可以利用其性质： $E(X+Y)=E(X)+E(Y)$</p>
<p>分别求$E(Z)$和$E(T)$再相减即可</p>
<script type="math/tex; mode=display">
E(Z)=\int_0^1 z\cdot nz^{n-1}dz = \frac{n}{n+1}\\
E(T)= \int_0^1 t\cdot n(1-t)^{n-1}dt</script><p>这个$E(T)$比较难算，我们可以将其配方成一个贝塔分布$Be(2,n)$的积分：</p>
<script type="math/tex; mode=display">
\int_0^1nt(1-t)^{n-1} = \frac{1}{n+1}\int_0^1n(n+1)t(1-t)^{n-1} dt
=\frac{1}{n+1}\int_0^1\frac{\Gamma(n+2)}{\Gamma(n)\Gamma(2)} t^{2-1}(1-t)^{n-1} = \frac{1}{n+1}</script><p>综上，$E(Z-T)=\frac{n}{n+1}-\frac{1}{n+1}=\frac{n-1}{n+1}$ </p>
<p>因此，当积分区域确定，积分形状又很类似我们常见的分布的时候，我们可以凑方、配方称常见的分布求积分，会省很多力气。</p>
<h2 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h2><p>设$(X,Y)$是一个二维随机变量，若 $E[(X-E(X))(Y-E(Y))]$存在，则称此数学期望为 $X$ 与 $Y$ 的协方差，或称为$X$ 与 $Y$ 的相关(中心)矩。并记为</p>
<script type="math/tex; mode=display">
Cov(X,Y) = E[(X-E(X))(Y-E(Y))]</script><p>特别有 $Cov(X,X)=Var(X)$ </p>
<ul>
<li>当$Cov(X,Y)&gt;0$的时候，称 X与Y <strong>正相关</strong>， 这时候两个偏差 $(X-E(X))$与 $(Y-E(Y))$ 有同时增加或者同时减少的倾向。由于 $E(X)$与$E(Y)$ 都是常数，故等价于$X$ 与 $Y$ 有同增同减的倾向。</li>
<li>当$Cov(X,Y)&lt;0$时，称X与Y<strong>负相关</strong> , 这时有X增加而Y减少的倾向，或者有 $Y$增加而$X$减少的倾向。</li>
<li>当$Cov(X,X)=0$时，称X与Y<strong>不相关</strong>，这时候X与Y可能取值毫无关联，也可能是X与Y之间存在某种非线性关系。</li>
</ul>
<h3 id="性质1-1"><a href="#性质1-1" class="headerlink" title="性质1"></a>性质1</h3><p>这是常用的协方差计算公式。</p>
<p>$Cov(X,Y)=E(XY)-E(X)E(Y)$ </p>
<h3 id="性质2-1"><a href="#性质2-1" class="headerlink" title="性质2"></a>性质2</h3><p><strong>若随机变量X与Y相互独立，则$Cov(X,Y)=0$ 反之不然。</strong></p>
<p>这是因为在独立场合有 $E(XY)=E(X)E(Y)$ 在，但是如果 $Cov(X,Y)=0$，X与Y可能是不独立的。</p>
<p>比如说，设随机变量 $X\sim N(0,\sigma^2)$，且令 $Y=X^2$ ,则X与Y不独立。 此时 X 与 Y的协方差为 $Cov(X,Y)=Cov(X,X^2)=E(X\cdot X^2)-E(X)E(X^2)=0$ </p>
<p>这说明：<strong>独立必然导致不相关，而不相关则不一定导致独立。</strong>  </p>
<p><img src="/2021/04/11/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F3-4-3-5/1.jpg" style="zoom:33%;"></p>
<h3 id="性质3-1"><a href="#性质3-1" class="headerlink" title="性质3"></a>性质3</h3><p>对于任意二维随机变量$(X,Y)$有：</p>
<script type="math/tex; mode=display">
Var(X\pm Y) = Var(X)+Var(Y)\pm 2Cov(X,Y)</script><p>因此，这也证明了刚才方差的运算性质。当X，Y互相独立的时候，$Var(X\pm Y)=Var(X)+Var(Y)$ </p>
<p>以上的性质还可以推广到更多个随机变量场合，即对任意n个随机变量 $X_1,X_2,\cdots,X_n$有</p>
<script type="math/tex; mode=display">
Var(\sum\limits_{i=1}^nX_i)=\sum\limits_{i=1}^n Var(X_i)+2\sum_{i=1}^n\sum_{j=1}^{i-1} Cov(X_i,X_j)</script><p>下面几条性质可以方便协方差的计算</p>
<h3 id="性质4"><a href="#性质4" class="headerlink" title="性质4"></a>性质4</h3><p>$Cov(X,Y)=Cov(Y,X)$</p>
<p>即协方差$Cov(X,Y)$的计算与X，Y的次序无关</p>
<h3 id="性质5"><a href="#性质5" class="headerlink" title="性质5"></a>性质5</h3><p>$Cov(X,a)=0$ </p>
<p>即任意随机变量X与常数a的协方差为0</p>
<h3 id="性质6"><a href="#性质6" class="headerlink" title="性质6"></a>性质6</h3><script type="math/tex; mode=display">
Cov(aX,bY) =abCov(X,Y)</script><h3 id="性质7"><a href="#性质7" class="headerlink" title="性质7"></a>性质7</h3><p>设$X,Y,Z$ 是任意三个随机变量，则</p>
<script type="math/tex; mode=display">
Cov(X+Y,Z)=Cov(X,Z)+Cov(Y,Z)</script><h3 id="性质8"><a href="#性质8" class="headerlink" title="性质8"></a>性质8</h3><script type="math/tex; mode=display">
Cov (X,Y)\leq \sqrt {Var(X)}\sqrt{Var(y)}</script><p>因为 协方差矩阵是非负定的，其绝对值是大于等于0的，当等于的时候，说明X，Y不相关；当大于0的时候，上述式子成立</p>
<h4 id="例题：常规方法求-Var-g-x-y"><a href="#例题：常规方法求-Var-g-x-y" class="headerlink" title="例题：常规方法求 Var(g(x,y))"></a>例题：常规方法求 Var(g(x,y))</h4><p>设二维随机变量$(X,Y)$的联合密度为</p>
<script type="math/tex; mode=display">
p(x,y)=\begin{cases}\frac{1}{3}(x+y) ~~0<x<1,0<y<2 \\ \\ 0 ~~ 其他\end{cases}</script><p>试求$Var(2X-3Y+8)$</p>
<p><strong>思路</strong></p>
<ol>
<li><strong>展开</strong>，化简为独立的X方差与Y方差、协方差形式</li>
</ol>
<script type="math/tex; mode=display">
Var(2X-3Y+8)=Var(2X)+Var(3Y)-2Cov(2X,3Y)\\
=4Var(X)+9Var(Y)-12Cov(X,Y)</script><ol>
<li>分别计算 $Var(X),Var(Y)$ ，用到 $Var(X)=E(X^2)-E(X)^2$ 这个公式</li>
<li>计算 $E(X),E(X^2),E(Y),E(Y^2)$ </li>
<li>计算$E(XY)$ 可以从联合密度函数导出</li>
<li>计算协方差 $Cov(X,Y)=E(XY)-E(X)E(Y)$ </li>
</ol>
<h4 id="例题：利用常见分布求期望和方差"><a href="#例题：利用常见分布求期望和方差" class="headerlink" title="例题：利用常见分布求期望和方差"></a>例题：利用常见分布求期望和方差</h4><p>随机变量$(X,Y)$服从以点$(0,1),(1,0),(1,1)$ 为顶点的三角形区域上的均匀分布，试求$E(X+Y)$和 $Var(X+Y)$</p>
<p>刚开始我用传统方法求解$E(X+Y)$，也就是先求出$p(x,y)$ 然后利用定义求解。但是这种方法对$Var(X+Y)$ 却起不到便利。因此我们可以用一下这种方法：</p>
<p><strong>第一步，求p(x,y)联合分布</strong></p>
<script type="math/tex; mode=display">
p(x,y)=\begin{cases}2 ,0<x<1,1-x<y<1\\ \\0 其他\end{cases}</script><p><strong>第二步，求x,y的边际分布</strong> </p>
<script type="math/tex; mode=display">
p_X(x)=\int_{1-x}^1 2dy =2x \\ 
p_Y(y)= \int_{1-y}^1 2dx = 2y</script><p><strong>第三步，用常见的分布求X、Y的期望与方差</strong></p>
<p>$p_X(x)=2x$ 可以看成 $p(x)=\frac{\Gamma(2+1)}{\Gamma(2)\Gamma(1)} x^{2-1}(1-x)^{1-1}$, 因此 $X\sim Be(2,1)$   ，同理 $Y\sim Be(2,1)$ </p>
<p>因此</p>
<script type="math/tex; mode=display">
E(X)=E(Y)=\frac{a}{a+b}=\frac{2}{3}\\
Var(X)=Var(Y)=\frac{ab}{(a+b)^2(a+b+1)}=\frac{1}{18}</script><p><strong>第四步：先计算E(X+Y)</strong></p>
<p>由性质可以得到</p>
<script type="math/tex; mode=display">
E(X+Y)=E(X)+E(Y)=\frac{2}{3}+\frac{2}{3}=\frac{4}{3}</script><p><strong>第五步：计算Var(X+Y)</strong></p>
<p>首先，列出$Var(X+Y)=Var(X)+Var(Y)+2Cov(X,Y)$ </p>
<p>因此我们还要求$Cov(X,Y)=E(XY)-E(X)E(Y)$ </p>
<p>因为X,Y并不是互相独立的，因此还要计算 $E(XY)$,$E(XY)$可以用传统方法求解：</p>
<script type="math/tex; mode=display">
E(XY)=\int_{0}^1\int_{1-x}^1 (xy) 2dydx=\frac{5}{12}\\
Cov(X,Y)=\frac{5}{12}-\frac{4}{9}=-\frac{1}{36}</script><p>因此</p>
<script type="math/tex; mode=display">
Var(X+Y)=\frac{1}{18}+\frac{1}{18}+2(-\frac{1}{36}) = \frac{1}{18}</script><p>这里我们要记住，贝塔分布 $Be(2,1)=2x$ 这一个很隐蔽但是很有用的性质。</p>
<h4 id="例题3-1：极值分布的期望和方差"><a href="#例题3-1：极值分布的期望和方差" class="headerlink" title="例题3-1：极值分布的期望和方差"></a>例题3-1：极值分布的期望和方差</h4><p>设 $X_1,X_2,X_3,X_4,X_5$ 是独立同分布的随机变量，其共同的密度函数</p>
<script type="math/tex; mode=display">
p(x)=\begin{cases}2x， ~~0<x<1\\ \\0, 其他\end{cases}</script><p>试求 $Y=\max{X_1,X_2,\cdots,X_5}$ 的密度函数、数学期望、方差</p>
<p><strong>第一步：求出X的分布函数</strong></p>
<script type="math/tex; mode=display">
F_X(x) = \int_0^x 2x dx =  x^2 , 0<x<1 \\</script><p><strong>第二步： 求出Y的分布函数</strong></p>
<script type="math/tex; mode=display">
F_Y(y) = [F_X(y)]^5 = y^{10}</script><p><strong>第三步：求出密度函数、数学期望和方差</strong></p>
<script type="math/tex; mode=display">
p_Y(y) = F_Y'(y) = 10y^9\\
E(y) = \int_0^1 y\cdot 10y^9 dy = \frac{10}{11}\\
Var(y) = E(y^2)-E^2(y)=\int_0^1y^210y^9 dy - \frac{100}{121}=\frac{5}{726}</script><h4 id="例题3-2-求-E-极值分布"><a href="#例题3-2-求-E-极值分布" class="headerlink" title="例题3-2: 求 E(极值分布)"></a>例题3-2: 求 E(极值分布)</h4><p>设X,Y 独立同分布，都服从标准正态分布$N(0,1)$, 求$E(\max{X,Y})$ </p>
<p><strong>第一步: 化简 max{X,Y}</strong></p>
<script type="math/tex; mode=display">
\max\{X,Y\}=\frac{X+Y+|X-Y|}{2}\\
E[\max\{X,Y\}]=E[\frac{X+Y+|X-Y|}{2}]=\frac{E(X)+E(Y)+E|X-Y|}{2} =\frac{E|X-Y|}{2}</script><p>现在我们把 $E[\max{X,Y}] $ 转换成了 $\frac{E|X-Y|}{2}$</p>
<p><strong>第二步：写出 X-Y 的密度函数</strong></p>
<p>因为X,Y 独立，都服从 $N(0,1)$根据性质 $X-Y\sim N(0,2)$ ，这里使用了正态分布的可加性——</p>
<p>若随机变量 $X\sim N(\mu,\sigma^2)$ ,则对任意非零实数a有 $aX\sim N(a\mu,a^2\mu^2)$ 。</p>
<p>因此，我们可以得到一个<strong>重要结论</strong>， 即</p>
<script type="math/tex; mode=display">
a_1X_1+a_2X_2+\cdots+a_nX_n \sim N(\mu_0,\sigma_0^2)</script><p>若$X_i\sim N(\mu_1,\sigma_1^2),i=1,2\cdots,n$则参数 $\mu_0$与 $\sigma_0^2$ 分别为：</p>
<script type="math/tex; mode=display">
\mu_0 = \sum_{i=1}^n a_i\mu_i\\ \sigma_0^2 = \sum_{i=1}^n a_i^2\sigma_i^2</script><p>$P(X-Y)=\frac{1}{\sqrt{2\pi}\sqrt{2}}\exp{-\frac{(x-y)^2}{4}}$  </p>
<p><strong>第三步：根据定义计算期望</strong></p>
<p>令 $X-Y=t$. 则 </p>
<script type="math/tex; mode=display">
E(|t|) = \int_{-\infty}^{\infty} |t| \frac{1}{\sqrt{2\pi}\sqrt{2}}\exp\{-\frac{(t)^2}{4}\}dt\\ \\
=\frac{1}{\sqrt{2\pi}\sqrt{2}}\cdot 2 \int_0^\infty t\exp\{-\frac{t^2}4\}dt\\
=\frac{-2}{\sqrt{\pi}} \exp\{-\frac{t^2}{4}\}|_0^\infty\\
=\frac{2}{\sqrt\pi}</script><p>因此 $E[\max{X,Y}]=\frac{E|X-Y|}{2}=\frac{1}{\sqrt\pi}$ </p>
<h2 id="相关系数"><a href="#相关系数" class="headerlink" title="相关系数"></a>相关系数</h2><p>协方差是有量纲的量，譬如X表示人的身高，单位是米(m) , Y表示人的体重，单位是千克(kg) .则Cov(X,Y) 带有量纲$(m\cdot kg)$ </p>
<p>为了消除量纲的影响，现对协方差除以相同量纲的量，得到相关系数的概念</p>
<p><strong>定义：</strong></p>
<script type="math/tex; mode=display">
Corr(X,Y)=\frac{Cov(X,Y)}{\sqrt{Var(X)}{\sqrt{Var(Y)}}} = \frac{Cov(X,Y)}{\sigma_X\sigma_Y}</script><p>上式为X与Y的(线性)相关系数</p>
<p>现在我们知道二维正态分布$N(\mu_1,\mu_2,\sigma_1,\sigma_2,\rho)$ 的相关系数是 $\rho$ </p>
<h3 id="性质1-2"><a href="#性质1-2" class="headerlink" title="性质1"></a>性质1</h3><script type="math/tex; mode=display">
1\leq Corr(X,Y)\leq 1</script><p>这个性质表明：相关系数介于 -1 和 1 之间。</p>
<h3 id="性质2-2"><a href="#性质2-2" class="headerlink" title="性质2"></a>性质2</h3><p>$Corr(X,Y)=\pm 1$ 的充要条件是 X与Y 之间几乎处处有线性关系，即存在 a与b，使得 $P(Y=aX+b)=1$ </p>
<p>其中当$Corr(X,Y)=1$时，有 $a&gt;0$，称X与Y <strong>完全正相关</strong>; $Corr(X,Y)=-1$ 时，有$a&lt;0$,称X与Y <strong>完全负相关</strong></p>
<h3 id="性质3-2"><a href="#性质3-2" class="headerlink" title="性质3"></a>性质3</h3><p>在二维正态分布 $N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)$ , 不相关与独立是等价的 </p>
<p>y因为二维正态分布$N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)$ 的两个边际分布为 $N(\mu_1,\sigma_1^2)$和$N(\mu_2,\sigma_2^2)$ ,所以记其联合非密度为$p(x,y)$.边际密度函数为$p_X(x)$ 与 $p_Y(y)$</p>
<p>那么当 $\rho =0$ 时，可从正态密度函数的表达式中看出： $p(x,y)=p_X(x)p_Y(y)$ 即 $X$ 与 $Y$ 相互独立</p>
<p>反之，若X与Y相互独立，则X与Y 不相关，从而有 $\rho =0$ </p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>已知随机向量$(X,Y)$的联合密度函数为：</p>
<p>$p(x,y)=\begin{cases}\frac{3}{8}  ~~0&lt;x-y&lt;0.5,0&lt;x,y&lt;1 \ \ 0 ~~ 其他\end{cases}$</p>
<p>求 X,Y 的相关系数$Corr(X,Y)$</p>
<p><strong>思路：</strong></p>
<ul>
<li>首先相关系数的公式 ： $Corr(X,Y)= \frac{Cov(X,Y)}{\sigma_X\sigma_Y}=\frac{E(XY)-E(X)E(Y)}{\sigma_X\sigma_Y}$ </li>
<li>先求边际密度函数，即 $p<em>X(x)=\int</em>{-\infty}^\infty p(x,y)dy$和$p<em>Y(y)=\int</em>{-\infty}^{\infty}p(x,y)dx$  </li>
<li>求 $E(X),E(Y),E(X^2),E(Y^2)$</li>
<li>求$Var(X),\sigma(X),Var(Y),\sigma(Y)$ </li>
<li>带入求得</li>
</ul>
<h4 id="例题：-当相关系数结合多元函数"><a href="#例题：-当相关系数结合多元函数" class="headerlink" title="例题： 当相关系数结合多元函数"></a>例题： 当相关系数结合多元函数</h4><p>设随机变量X和Y独立同服从参数为$\lambda$ 的泊松分布，令：$U=2X+Y,V=2X-Y$ ，求U和V的相关系数 $Corr(U,V)$ </p>
<p>如果按照常规方法，可以先求出 $p(u,v)$，然后求出  $p_U(u)、p_V(v)、E(U)、E(V)、Var(U)、Var(V)$ ,再求出$Corr(U,V)$ 但是这样太麻烦了。</p>
<p>我们可以通过方差的性质和协方差的性质来求解，因为我们已经知道了 $E(X),E(Y),Var(X),Var(Y)$ 根据泊松分布的可加性，我们可以进而求出 $E(U),E(V),Var(U),Var(V)$ </p>
<p>因此，$Corr(U,V)=Cov(U,V)/\sqrt{Var(U)Var(V)}$</p>
<p>又： </p>
<script type="math/tex; mode=display">
Var(U)=Var(2X+Y) = 4Var(X)+Var(Y)=5\lambda \\
Var(V)=Var(2X-Y)=4Var(X)+Var(Y)=5\lambda \\</script><script type="math/tex; mode=display">
Cov(U,V) = Cov(2X+Y,2X-Y)=Cov(2X，2X-Y)+Cov(Y,2X-Y)=Cov(2X,2X)-Cov(2X,Y)+Cov(Y,2X)-Cov(Y,Y)\\
=E(4X^2)-4E(X)E(X)-2E(XY)+2E(X)E(Y)+2E(XY)-2E(X)E(Y)-E(Y^2)+E(Y)E(Y)\\
=4(\lambda^2+\lambda)-(\lambda^2+\lambda) -3\lambda^2=3\lambda</script><p>因此 $Corr(U,V)=\frac{3\lambda}{5\lambda}=\frac{3}{5}$ </p>
<h2 id="随机向量的数学期望向量与协方差矩阵"><a href="#随机向量的数学期望向量与协方差矩阵" class="headerlink" title="随机向量的数学期望向量与协方差矩阵"></a>随机向量的数学期望向量与协方差矩阵</h2><p>记n维随机向量为 $X=(X_1,X_2,\cdots,X_n)’$ ，若其<strong>每个分量的数学期望都存在</strong>，则称：</p>
<script type="math/tex; mode=display">
E(X)=(E(X_1),E(X_2),\cdots,E(X_n))'</script><p>为n为随机向量X的<strong>数学期望向量</strong>，简称为X的数学期望。</p>
<p>称</p>
<p><img src="/2021/04/11/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F3-4-3-5/2.jpg" style="zoom:33%;"></p>
<p>为该向量的<strong>方差-协方差</strong> 矩阵，记为$Cov(X)$ </p>
<h3 id="性质1-3"><a href="#性质1-3" class="headerlink" title="性质1"></a>性质1</h3><p>n为随机向量的协方差矩阵 $Cov(X)=(Cov(X<em>i,X_j))</em>{n\times n}$ 是一个对称的<strong>非负定矩阵</strong>，也就是说其行列式值是大于等于0的。</p>
<h1 id="条件分布与条件期望"><a href="#条件分布与条件期望" class="headerlink" title="条件分布与条件期望"></a>条件分布与条件期望</h1><h2 id="条件分布"><a href="#条件分布" class="headerlink" title="条件分布"></a>条件分布</h2><h3 id="离散随机变量的条件分布"><a href="#离散随机变量的条件分布" class="headerlink" title="离散随机变量的条件分布"></a>离散随机变量的条件分布</h3><h4 id="条件分布列"><a href="#条件分布列" class="headerlink" title="条件分布列"></a>条件分布列</h4><p><strong>现在我们给出离散随机变量的条件分布列定义：</strong></p>
<p>对于一切使 $P(Y=y<em>i)=p</em>{\cdot j}=\sum<em>{i=1}^\infty p</em>{ij}&gt;0$ , 称</p>
<script type="math/tex; mode=display">
p_{i|j}=P(X=x_i|Y=y_i)=\frac{P(X=x_i,Y=y_i)}{P(Y=y_i)}=\frac{p_{ij}}{p_{\cdot j}},i=1,2\cdots</script><p>为给定$Y=y_j$ 条件下X的分布列</p>
<p>同理，一切使得 $P(X=x<em>i)=p</em>{i\cdot}=\sum<em>{j=1}^\infty p</em>{ij}&gt;0$ 的$x_i$ ，称 </p>
<script type="math/tex; mode=display">
p_{j|i} = P(Y=y_j|X=x_i)=\frac{P(X=x_i,Y=y_j)}{P(X=x_i)}=\frac{p_{ij}}{p_i}</script><p>为给定 $X=x_i$条件下 Y 的条件分布列</p>
<h4 id="条件分布函数"><a href="#条件分布函数" class="headerlink" title="条件分布函数"></a>条件分布函数</h4><p>有了条件分布列，我们就可以给出离散随机变量的<strong>条件分布函数</strong></p>
<p>给定$Y=y_j$ 条件下 X的条件<strong>分布函数</strong>为：</p>
<script type="math/tex; mode=display">
F(x|y_j)=\sum_{x_i\leq x}P(X=x_i|Y=y_j)=\sum_{x_i\leq x} p_{i|j}</script><p> 给定$X=x_i$ 条件下 Y 的条件<strong>分布函数</strong>为：</p>
<script type="math/tex; mode=display">
F(y|x_i)=\sum_{y_j\leq y} P(Y=y_j|X=x_i)=\sum_{y_j\leq y}p_{j|i}</script><h4 id="例题1：求条件分布"><a href="#例题1：求条件分布" class="headerlink" title="例题1：求条件分布"></a>例题1：求条件分布</h4><p>设随机变量 X 与 Y互相独立，且 $X\sim P(\lambda_1),Y\sim P(\lambda_2)$ 。在已知道 $X+Y=n$ 的条件下，求 X 的条件分布。</p>
<p><strong>第一步，求P(X+Y)的分布，（先求联合分布列）</strong> </p>
<p>一般来说如果X与Y独立同分布，那么我们就要利用多元随机变量函数的性质来求，表现在：<strong>二项分布、泊松分布、正态分布、伽马分布(卡方分布) 的可加性</strong>上。</p>
<p>首先我们要知道独立泊松变量的和仍然为泊松变量。即 $X+Y\sim P(\lambda_1+\lambda_2)$ ，</p>
<p><strong>第二步，带入条件分布</strong></p>
<script type="math/tex; mode=display">
P(X=k|X+Y=n)=\frac{P(X=k,X+Y=n)}{P(X+Y=n)}\\
=\frac{P(X=k)P(Y=n-k)}{P(X+Y=n)} 
=\frac{\frac{\lambda_1^k}{k!}e^{-\lambda_1}\frac{\lambda_2^{n-k}}{(n-k)!}e^{-\lambda_2}}{\frac{(\lambda_1+\lambda_2)^n}{n!}e^{-(\lambda_1+\lambda_2)}}</script><p>消除指数之后，同分可得到： </p>
<script type="math/tex; mode=display">
=C_n^k (\frac{\lambda_1}{\lambda_1+\lambda_2})^k(\frac{\lambda_2}{\lambda_1+\lambda_2})^{n-k}</script><p>这就是一个二项分布，说明，在 $X+Y=n$的条件下，X服从二项分布 $b(n,p)$,其中$p=\frac{\lambda_1}{\lambda_1+\lambda_2}$ </p>
<h4 id="例题2："><a href="#例题2：" class="headerlink" title="例题2："></a>例题2：</h4><p>设在一段时间内进入某一商店的顾客人数X服从泊松分布$P(\lambda)$  ，每个顾客购买某种物品的概率为p，并且各个顾客是否购买该种物品相互独立，求进入商店的顾客购买这种物品的人数Y的分布列，以及$E(Y),Var(Y)$ </p>
<p>首先我们列出X的分布列：$P(X=m)=\frac{\lambda^m}{m!}e^{-\lambda}, m=0,1,2\cdots$  . 那么m就是进入商店的人数。</p>
<p>同时，我们给出购买某种物品的人数Y的条件分布。很容易理解这是<strong>一个二项分布</strong>：</p>
<script type="math/tex; mode=display">
P(Y=k|X=m) =C_m^k p^k(1-p)^{m-k} ,k = 0,1,2,\cdots,m</script><p>由<strong>全概率公式</strong>，可以得到：</p>
<script type="math/tex; mode=display">
P(Y=k)=\sum_{m=k}^\infty P(X=m)P(Y=k|X=m)\\
=\sum_{m=k}^\infty \frac{\lambda^m}{m!}e^{-\lambda} \cdot\frac{m!}{k!(m-k)!}p^k(1-p)^{m-k}
\\={e^{-\lambda}} p^k\sum_{m=k}^\infty \frac{\lambda^m}{k!(m-k)!}(1-p)^{m-k}\\
=\frac{e^{-\lambda} \lambda^k p^k}{k!}e^{\lambda(1-p)}\sum_{m=k}^\infty \frac{[\lambda(1-p)]^{m-k}}{(m-k)!}e^{-\lambda(1-p)}\\
=P(\lambda p)</script><p>显然，求和部分就像是 一个泊松分布的求和，其值为1</p>
<p>剩余的部分期望和方差都为 $\lambda p$， 标准差为 $\sqrt{\lambda p}$</p>
<p>这个例子可以告诉我们，在直接寻求Y的分布有困难时，有时借助条件分布可以把困难解决</p>
<h4 id="例题3-求条件分布列"><a href="#例题3-求条件分布列" class="headerlink" title="例题3: 求条件分布列"></a>例题3: 求条件分布列</h4><script type="math/tex; mode=display">
P(X=n,Y=m)  =\frac{e^{-14}(7.14)^m(6.86)^{n-m}}{m!(n-m)!} ~~~ n=0,1,\cdots \\</script><p>试求条件分布列 $P(Y=m|X=n)$  </p>
<p><strong>第一步： 列出公式</strong></p>
<script type="math/tex; mode=display">
P(Y=m|X=n) =\frac{P(X=m,Y=n)}{P(X=n)}</script><p><strong>第二步：根据公式，求出未知数</strong></p>
<p>我们已经有了 $P(Y=m,X=n)$, 因此要求 $P_X(x)$ 这一个边际分布</p>
<script type="math/tex; mode=display">
P_X(x)= \sum_{m=0}^n \frac{e^{-14}(7.14)^m(6.86)^{n-m}}{m!(n-m)!}</script><p>我们看这里有 $m!(n-m)!$ 可以考虑将其配方成二项分布：</p>
<script type="math/tex; mode=display">
P_X(x)=\frac{14^ne^{-14}}{n!}\sum_{m=0}^n \frac{n!}{m!(n-m)!} (\frac{7.14}{14})^m(\frac{6.86}{14})^{n-m}</script><p>求和部分是一个二项分布列的求和，其值为1， 因此$P_X(x)=\frac{14^ne^{-14}}{n!}=P(14)$ 也就是说，X服从参数为14的泊松分布</p>
<p><strong>第三步：带入求解</strong></p>
<script type="math/tex; mode=display">
P(Y=m|X=n)=\frac{e^{-14}(7.14)^m(6.86)^{n-m}}{m!(n-m)!}\cdot\frac{n!}{14^ne^{-14}} = C_n^m (\frac{7.14}{14})^m(\frac{6.86}{14})^{n-m}</script><p>这是一个二项分布 $b(n,0.51)$ </p>
<h3 id="连续随机随机变量的条件分布"><a href="#连续随机随机变量的条件分布" class="headerlink" title="连续随机随机变量的条件分布"></a>连续随机随机变量的条件分布</h3><p>对一切使$P_Y(y)&gt;0$ 的y，给定 $Y=y$  条件下X的<strong>条件密度函数</strong>和<strong>条件分布函数</strong>分别为：</p>
<script type="math/tex; mode=display">
p(x|y) = \frac{p(x,y)}{p_Y(y)} , F(x|y)=\int_{-\infty}^x p(u|y) du = \int_\infty^x\frac{p(u,y)}{p_Y(y)}du</script><p>同理，对于一切使$p_X(x)&gt;0$ 的x，给定$X=x$ 条件下Y的<strong>条件密度函数</strong>和<strong>条件分布函数</strong>分别为：</p>
<script type="math/tex; mode=display">
p(y|x) = \frac{p(x,y)}{p_X(x)} , F(y|x)=\int_{-\infty}^y p(v|x) dv =\int_\infty^y\frac{p(x,v)}{p_X(x)}dv</script><h4 id="例题1-求条件密度函数"><a href="#例题1-求条件密度函数" class="headerlink" title="例题1: 求条件密度函数"></a>例题1: 求条件密度函数</h4><p>设二维<strong>连续随机变量</strong>(X,Y) 的联合密度函数为：</p>
<script type="math/tex; mode=display">
p(x,y)=\begin{cases}3x,  ~~0<x<1,0<y<x\\ \\0,~~ 其他 \end{cases}</script><p>试求条件密度函数$p(y|x)$</p>
<p><strong>第一步: 列出条件密度函数公式</strong></p>
<script type="math/tex; mode=display">
p(y|x) = \frac{p(y，x)}{p(x)}</script><p>我们已经知道$p(x,y)$的联合密度函数，现在需要求 $p_X(x)$  即x的边际密度函数</p>
<p><strong>第二步：求p(x)</strong> </p>
<script type="math/tex; mode=display">
p_X(x)=\int_0^x 3x dy = 3x^2 , 0<x<1</script><p><strong>第三步：带入公式</strong> </p>
<p>$p(y|x)=\frac{3x}{3x^2}=\frac{1}{x}, 1&lt;y&lt;x$  </p>
<h4 id="例题2：求条件概率"><a href="#例题2：求条件概率" class="headerlink" title="例题2：求条件概率"></a>例题2：求条件概率</h4><script type="math/tex; mode=display">
p(x,y)=\begin{cases}\frac{21}{4}x^2y,  ~~x^2<y<1\\ \\0,~~ 其他 \end{cases}</script><p>求条件概率 $P(Y\geq 0.75|X=0.5)$ </p>
<p><strong>第一步：列出条件密度函数公式：</strong></p>
<script type="math/tex; mode=display">
p(y|x) = \frac{p(y，x)}{p(x)}</script><p><strong>第二步，求p(x)</strong></p>
<script type="math/tex; mode=display">
p_X(x)=\int_{x^2}^1 \frac{21}{4}x^2ydy = \frac{21}{8}x^2(1-x^4)</script><p><strong>第三步，带入公式：</strong></p>
<script type="math/tex; mode=display">
p(y|x) = \frac{21}{4}x^2y\frac{8}{21x^2(1-x^4)}=\frac{2y}{1-x^4}, 0<y<1</script><p><strong>第四步，求条件边际分布</strong></p>
<p>题目要求$P{Y\geq 0.75|X=0.5}$ ,因此，我们需要求 $P{y|x=0.5}$</p>
<script type="math/tex; mode=display">
P\{y|x=0.5\}=\frac{32}{15}y</script><p><strong>第五步：求条件概率</strong></p>
<script type="math/tex; mode=display">
P\{Y\geq 0.75|X=0.5\}=\int_{0.75}^1\frac{32}{15}y dy =\frac{7}{15}</script><h3 id="连续场合的全概率公式和贝叶斯公式"><a href="#连续场合的全概率公式和贝叶斯公式" class="headerlink" title="连续场合的全概率公式和贝叶斯公式"></a>连续场合的全概率公式和贝叶斯公式</h3><p>1) 全概率公式的密度函数形式</p>
<script type="math/tex; mode=display">
p_Y(y) = \int_{-\infty}^{\infty} p_X(x)p(y|x) dx \\~\\~ \\ p_X(x)=\int_{-\infty}^{\infty}p_Y(y)p(x|y)dy</script><p>2) 贝叶斯公式的密度函数形式：</p>
<script type="math/tex; mode=display">
p(x|y) =\frac{p_X(x)p(y|x)}{\int_{-\infty}^{\infty}p_X(x)p(y|x)}\\~\\~\\
p(y|x) = \frac{p_Y(y)p(x|y)}{\int_{-\infty}^\infty p_Y(y)p(x|y)dy}</script><h2 id="条件数学期望"><a href="#条件数学期望" class="headerlink" title="条件数学期望"></a>条件数学期望</h2><h3 id="条件期望"><a href="#条件期望" class="headerlink" title="条件期望"></a>条件期望</h3><p> 条件分布的数学期望称为<strong>条件期望</strong>，其定义如下：</p>
<script type="math/tex; mode=display">
E(X|Y=y) = \begin{cases}\sum_i x_iP(X=x_i|Y=y)~~ (X,Y)为二维离散随机变量\\ \\\int_{-\infty}^{\infty}xp(x|y) dx~~ (X,Y) 为二维连续随机变量\end{cases}</script><p>同理，</p>
<script type="math/tex; mode=display">
E(Y|X=x) = \begin{cases}\sum_j y_jP(Y=y_i|X=x)~~ (X,Y)为二维离散随机变量\\ \\\int_{-\infty}^{\infty}yp(y|x) dy ~~ (X,Y) 为二维连续随机变量\end{cases}</script><h4 id="例题：求条件期望"><a href="#例题：求条件期望" class="headerlink" title="例题：求条件期望"></a>例题：求条件期望</h4><p>设二维连续随机变量 $(X,Y)$ 的联合密度函数为：</p>
<script type="math/tex; mode=display">
p(x,y) = \begin{cases}x+y , 0<x,y<1 \\ \\ 0, 其他\end{cases}</script><p>试求 $E(X|Y=0.5)$ </p>
<p><strong>第一步：列出E(X|Y=y)的公式</strong></p>
<script type="math/tex; mode=display">
E(X|Y=0.5) =\int_0^1xp(x|Y=0.5) dx</script><p>发现 $p(X|Y=0.5)$这一个条件分布列是未知的。因此我们要求条件密度函数</p>
<p><strong>第二步：求出条件密度函数</strong></p>
<script type="math/tex; mode=display">
p(X=x|Y=y)=\frac{p(X=x,Y=y)}{p(Y=y)}</script><p>因为已知 $p(x,y)=x+y$， 现在就要求 $p_Y(y)$即y的边际分布</p>
<script type="math/tex; mode=display">
p_Y(y) = \int_0^1(x+y)dx = y+\frac12</script><p>带入得到： $p(X=x|Y=y)=\frac{x+y}{y+\frac{1}{2}}$ </p>
<p>所以 $p(X|Y=0.5)=x+0.5$ </p>
<p><strong>第三步，代入第一步公式求解</strong></p>
<script type="math/tex; mode=display">
E(X|Y=0.5)=\int_0^1 x(x+\frac{1}{2}) dx=\frac{7}{12}</script><h3 id="重期望公式"><a href="#重期望公式" class="headerlink" title="重期望公式"></a>重期望公式</h3><p>设 $(X,Y)$ 是二维随机变量，且 $E(X)$ 存在，则 $E(X)=E(E(X|Y))$</p>
<p>重期望公式的具体使用如下：</p>
<p>(1) 如果Y是一个离散随机变量，则上式可以写成</p>
<script type="math/tex; mode=display">
E(X) = \sum_j E(X|Y=y_j)P(Y=y_i)</script><p>(2) 如果Y是一个连续随机变量，则上式可写成</p>
<script type="math/tex; mode=display">
E(X) = \int_{-\infty}^{\infty} E(X|Y=y_j)P_Y(y)dy</script><h4 id="例题：求二元函数的期望"><a href="#例题：求二元函数的期望" class="headerlink" title="例题：求二元函数的期望"></a>例题：求二元函数的期望</h4><p>设随机变量X与Y独立同步，都服从参数为 $\lambda$ 的指数分布，令</p>
<script type="math/tex; mode=display">
Z=\begin{cases}3X+1 ,X\geq Y\\ \\6Y,~~ X<Y \end{cases}</script><p>求$E(Z)$ </p>
<p><strong>第一步： 先分析思路</strong></p>
<p>要求$E(Z)$,其中Z是一个二元函数，因此这道题可以从两种思路来求解：</p>
<p>第一种就是用二元函数期望公式来就算；</p>
<p>第二种就是用条件期望(重期望公式)来计算</p>
<p><strong>第二步：用第一种方法——二元函数期望</strong></p>
<p>首先我们求X，Y的联合分布 $p(x,y)$ ： $X\sim \lambda e^{-\lambda x}, Y\sim \lambda e^{-\lambda y}$  </p>
<p>$p(x,y)=p(x)p(y)=\lambda^2 e^{-\lambda x-\lambda y}$</p>
<p>我的思路是拿到题目首先考虑二元函数期望公式：</p>
<script type="math/tex; mode=display">
E(Z)=\int_{-\infty}^{\infty} zp(z)dz =\int_{X\geq Y} (3x+1)p(x,y)dxdy+\int_{X<Y} 6yp(x,y)dxdy\\
=\int_0^\infty\int_y^\infty (3x+1)\lambda^2e^{-\lambda x-\lambda y }dxdy+\int_0^\infty\int_0^y 6y\lambda^2e^{-\lambda x-\lambda y} dxdy\\
=\cdots</script><p><strong>第三步：用第二种方法——条件期望</strong></p>
<ol>
<li><p>在 $X=x$ 给定时， $Z=\begin{cases}3X+1 ,X\geq Y\ \6Y,~~ X&lt;Y \end{cases}$ 是<strong>关于Y的函数</strong>。注意，这里不要用 $E(Z|X)=\int<em>{-\infty}^{\infty} zp(z|x)dz$ 来计算。而是说，把 $Z$ 看做是 $g(Y)$, 然后通过公式 $E(g(Y))=\int</em>{-\infty}^\infty g(y)p_Y(y)dy$ 来计算。 同理，可以将其看成是$Y=y$ 条件下X的函数</p>
<script type="math/tex; mode=display">
E(Z|X=x)=\int_0^x (3x+1)\lambda e^{-\lambda y}dy+\int_x^\infty 6y\lambda e^{-\lambda y} dy \\
=(3x+1)(1-e^{-\lambda x}) +6xe^{-\lambda x} +\frac{6}{\lambda} e^{-\lambda x}\\
=3x+1+e^{-\lambda x}(3x+\frac{6}{\lambda }-1) \\</script></li>
<li><p>根据重期望公式, $E(E(Z|X))=\int_{-\infty}^\infty E(Z|X)p_X(x)$求解：</p>
</li>
</ol>
<p>$E(Z)=E(E(Z|X))=E[3X+1+e^{-\lambda X}(3X+\frac{6}{\lambda}-1)]$ </p>
<script type="math/tex; mode=display">
=3E(X)+1+\int_0^\infty \lambda e^{-2\lambda x} (3x+\frac{6}{\lambda}-1)dx\\
=\frac{3}{\lambda} +1+\frac{1}{2}\int_0^\infty 2\lambda e^{-2\lambda x}(3x+\frac{6}{\lambda}-1)dx\\
=\frac{3}{\lambda}+1+\frac{1}{2}(\frac{3}{2\lambda}+\frac{6}{\lambda}-1)=\frac{1}{2}+\frac{27}{4\lambda}</script><p>很显然，使用重期望公式来做这道题非常的方便简洁</p>
<h3 id="二维正态分布"><a href="#二维正态分布" class="headerlink" title="二维正态分布"></a>二维正态分布</h3><p>$N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)$ 的两个条件分布仍是正态分布，即</p>
<script type="math/tex; mode=display">
X|Y = y\sim N(g_1(y),\sigma_1^2(1-\rho^2))\\
其中：g_1(y)=E(X|Y=y) = \mu_1+\rho\frac{\sigma_1}{\sigma_2}(y-\mu_2)
\\~\\
Y|X = x\sim N(g_2(x),\sigma_2^2(1-\rho^2))\\
其中：g_2(x)=E(Y|X=x) =\mu_2+\rho\frac{\sigma_2}{\sigma_1}(x-\mu_1)</script><p>可见，在二维正态分布之中，一个变量的条件期望是另一个变量取值的线性函数，常称为一元线性回归方程。</p>
<h3 id="随机个随机变量和的数学期望"><a href="#随机个随机变量和的数学期望" class="headerlink" title="随机个随机变量和的数学期望"></a>随机个随机变量和的数学期望</h3><p>设 $X_1,X_2\cdots$ 为一列独立同分布的随机变量，随机变量N只取正整数值，且$N$ 与 ${X_n}$ 独立，证明它们的和的期望</p>
<script type="math/tex; mode=display">
E(\sum_{i=1}^N X_i) = E(X_1)E(N)</script><p>这里我引入一个N， 让 $N\sim p_N(n)$ </p>
<p>利用重期望公式，可以把 $E(\sum_{i=1}^N X_i)$写成：</p>
<script type="math/tex; mode=display">
E(\sum_{i=1}^N X_i) = E(E(\sum_{n=1}^N X_i| N))</script><p>进而，在N=n 的情况下，上式可写为：</p>
<script type="math/tex; mode=display">
E(E(\sum_{n=1}^N X_i| N)) =\sum_{n=1}^\infty E(\sum_{n=1}^n X_i| N=n)p_N(n)</script><p>我们又知道，$X<em>i$和$N$是独立的，所以 $\sum</em>{n=1}^n X_i $ 与N独立，所以条件期望可以转换成无条件期望</p>
<script type="math/tex; mode=display">
\sum_{n=1}^\infty E(\sum_{i=1}^n X_i) p_N(n)\\</script><p>我们知道期望和有限个求和符号是可以交换的，我们把括号中的求和提出，变成n。原式可以写成以下形式：</p>
<script type="math/tex; mode=display">
=\sum_{n=1}^\infty nE(X_1)p_N(n)=E(X_1)E(N)</script><p>将$E(X<em>1)$提出，剩下的 $\sum</em>{n=1}^\infty E(X_1)p_N(n)$可以写成是 $E(N)$ </p>
<h4 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h4><p>上面证明了和的期望，现在来证明和的方差。</p>
<p>证明 </p>
<script type="math/tex; mode=display">
Var(\sum_{i=1}^N(X_i)) = Var(N)[E(X_1)]^2+E(N)Var(X_1)</script><p>首先我们要知道一个公式： $Var(X)=E_Y(Var_X(X|Y))+Var_Y(E_X(X|Y))$</p>
<p>因此，原式 $Var(\sum_{i=1}^N(X_i))$ 可写为：</p>
<script type="math/tex; mode=display">
Var(\sum_{i=1}^N(X_i)) = Var_N(E_{X_1\cdots X_n}(\sum_{i=1}^NX_i|N))+E(Var(\sum_{i=1}^N X_i|N))</script><p> 我们将其设为 $I_1+I_2$</p>
<p>先来化简 $I_1$ ,可以将其看成是N的函数，</p>
<script type="math/tex; mode=display">
I_1=\sum_{n=1}^\infty (E)</script>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/14/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/%5Bobject%20Object%5D"
                alt="Jason" />
            
              <p class="site-author-name" itemprop="name">Jason</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20fa%20fa-archive">
              
                  <span class="site-state-item-count">435</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">61</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="true"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
 <!--
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>







-->
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>




















  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v="></script>

  <script type="text/javascript" src="/js/src/motion.js?v="></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v="></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
