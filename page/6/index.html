<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=">


  <link rel="mask-icon" href="/images/logo.svg?v=" color="#222">














<meta property="og:type" content="website">
<meta property="og:title" content="Jason‘s Blog">
<meta property="og:url" content="https://jasonxqh.github.io/page/6/index.html">
<meta property="og:site_name" content="Jason‘s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '',
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    fancybox: false,
    tabs: ,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: 'undefined',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>







  <title>Jason‘s Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', '[object Object]', 'auto');
  ga('send', 'pageview');
</script>





<meta name="generator" content="Hexo 4.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">
  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
<a href="https://github.com/JasonXQH/JasonXQH.github.io" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jason‘s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/%20" rel="section">
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/02/22/AI-agents-and-environments/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/02/22/AI-agents-and-environments/" itemprop="url">AI-agents_and_environments</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-02-22T20:26:53+08:00">
                2022-02-22
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-02-22T21:57:58+08:00">
                2022-02-22
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Agents-and-Environments"><a href="#Agents-and-Environments" class="headerlink" title="Agents and Environments"></a>Agents and Environments</h1><p>我们所学的课程主要是 CS188,那么要入门AI，首先要搞明白，什么是智能体，什么是环境。</p>
<p>举一个很简单的例子，有一个小孩子，当它伸左手的时候，给他一颗糖；伸右手的时候，打他一下，那么久而久之，他再也不会伸右手了。显然，这里小孩子是个智能体，而我们的行为就是环境。</p>
<h2 id="Agent-and-environments"><a href="#Agent-and-environments" class="headerlink" title="Agent and environments"></a>Agent and environments</h2><p><img src="/2022/02/22/AI-agents-and-environments/1.png" style="zoom:67%;"></p>
<p>对于每个智能体来说，它是如何与环境打交道的呢？——感知；当智能体感知到环境以后，会做出一定的行为。</p>
<p>因此，一个智能体中一定需要包含两个非常重要的元素——sensor(感知器) 和 actuator(致动器)</p>
<p>人类是智能体吗？——当然是，那么人类的感知器和致动器是什么？</p>
<ul>
<li>Sensors：视觉，听觉，触觉，味觉，嗅觉，本体感受</li>
<li>Actuators: 肌肉，分泌物，改变大脑的状态</li>
</ul>
<p>比如说，当人看到美丽的风景，竖起了大拇指，这时候眼睛是sensor而大脑和手上的肌肉是actuator</p>
<p>计算器是智能体吗？——也是</p>
<ul>
<li>Sensors: 计算器上的按键</li>
<li>Actuators: 电子屏</li>
</ul>
<p>AI致力于两点：</p>
<ol>
<li>Agent 可以模拟人类的行为</li>
<li>在复杂的环境中，通过AI计算可以得到一些重要的决策</li>
</ol>
<h3 id="Agent-functions"><a href="#Agent-functions" class="headerlink" title="Agent functions"></a>Agent functions</h3><p>智能体从环境中得到了一系列的感知，从这个历史感知序列做出相应的反馈，序列和行为是对应的，这就叫做<strong>Agent function(智能体函数)</strong></p>
<p>举一个例子，很好理解：我和张三一起玩剪刀石头布，他一直出剪刀，那么刚开始我可能会输几次，当我知道他在整个序列中都出了剪刀，我就会出石头。</p>
<p>再来举一个例子，我们可以感知到已经落下的方块、正在落下的方块以及将要落下的方块。基于此，我们会对方块的落下位置做一个变化。</p>
<p><img src="/2022/02/22/AI-agents-and-environments/2.png" style="zoom:67%;"></p>
<p>在现实中，要对一台及其进行训练，让其能够像人一样玩俄罗斯方块的话，就需要我们编写一个<strong>agent program</strong> ， 让机器不断去训练出一个 agent function。 </p>
<p>那么是不是所有的agent function都可以由agent program去逼近、去实现呢？显然不是的。当问题本身是一个np-hard问题，那么我们只能近似求解，无法逼近。</p>
<p>最后我们用一个真空吸尘器的例子来加深对agent function和agent program的理解。</p>
<p><img src="/2022/02/22/AI-agents-and-environments/3.png" style="zoom:67%;"></p>
<p>对于正空吸尘器感知到的序列有两个参数： 位置和该房间的状态。</p>
<p>同时有四个动作： 左移、右移、吸、不操作</p>
<p>我们可以列出其Agent function以及可以实现(逼近)该function的Agent Program。这段Agent Program的代码，很好地覆盖(实现)了左边Agent function的各种状态。</p>
<p><img src="/2022/02/22/AI-agents-and-environments/4.png" style="zoom:67%;"></p>
<p>现在我们只考虑了左移右移，那么现在如果我们给左移右移添加一些成本的话，右边这段agent program就并不能完美地实现agent function了，这就要引出我们下一节需要了解的内容——Rationality(理性)</p>
<h2 id="Rationality"><a href="#Rationality" class="headerlink" title="Rationality"></a>Rationality</h2><p>首先我们要了解 performance measure 的概念，其意思就是说，当我每次做出了一个行为，环境应该给我一个反馈(奖励或者触发)。比如说，小孩伸左手，扣10分；伸右手，加1分</p>
<p>一个理性的智能体(rational agent) ，会和环境“打交道”，从开始的一张白纸，到后面希望得到最大化的performance measure的值。也就是说，它是一个“精致利己主义者”</p>
<ul>
<li>rational agent 并不是无所不能的<ul>
<li>因为他们需要感知到环境才能做出反应。</li>
</ul>
</li>
<li>rational agent 是否能明察秋毫环境中的变化<ul>
<li>不一定，比如自动驾驶中，环境的一些变化可能不能被感知到</li>
</ul>
</li>
<li>rational agent是否应该一直在探索、学习<ul>
<li>是的</li>
</ul>
</li>
<li>rational agent是否会发生错误<ul>
<li>并不，这是比较迷惑的，对于rational agent来说，只有失败或不失败，但没有错误或不错误。</li>
</ul>
</li>
<li>所有的rational agent是否都可以自治？<ul>
<li>是的，它们在探索的过程中在不断地成长</li>
</ul>
</li>
</ul>
<h2 id="PEAS"><a href="#PEAS" class="headerlink" title="PEAS"></a>PEAS</h2><h2 id="Environment-types"><a href="#Environment-types" class="headerlink" title="Environment types"></a>Environment types</h2><h2 id="Agent-types"><a href="#Agent-types" class="headerlink" title="Agent types"></a>Agent types</h2>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/02/21/Hadoop%E6%A0%B8%E5%BF%83-HDFS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/02/21/Hadoop%E6%A0%B8%E5%BF%83-HDFS/" itemprop="url">Hadoop核心-HDFS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-02-21T22:31:03+08:00">
                2022-02-21
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-03-14T15:01:58+08:00">
                2022-03-14
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Hadoop核心-HDFS"><a href="#Hadoop核心-HDFS" class="headerlink" title="Hadoop核心-HDFS"></a>Hadoop核心-HDFS</h1><p>现在我们来详细学习一下HDFS和MR的原理</p>
<h3 id="HDFS的设计思想"><a href="#HDFS的设计思想" class="headerlink" title="HDFS的设计思想"></a>HDFS的设计思想</h3><p>HDFS的全称是 The Hadoop Distributed File System, 即Hadoop分布式文件系统。那么作为分布式数据管理系统，HDFS最主要要解决这几个问题：</p>
<ul>
<li><strong>如何存储上百GB/TB级别大文件？</strong></li>
<li><strong>如何保证文件系统的容错？</strong></li>
<li><strong>如何进行大文件的并发读写控制？</strong></li>
</ul>
<p>首先，它最大的特点就是，可以处理大数据文件。</p>
<p>那么具体是怎么处理的呢？HDFS会将大文件分割成一个一个block，每个block的大小为128MB(或者是64MB)，然后将其存放到不同的机器(节点)上面，如下图所示：</p>
<p><img src="/2022/02/21/Hadoop%E6%A0%B8%E5%BF%83-HDFS/1.png" style="zoom:67%;"></p>
<p>其次，我们可以通过<strong>分块冗余存储</strong>来保证文件系统的容错性。也就是说，将大文件分割成的小块也可以做冗余备份。这些备份会被放在不同的节点上，因此处分存放某一文件块的所有节点都发生故障，否则HDFS在部分节点故障的情况下依然可以访问到该文件块。如下图：绿色块存放在DataNode1、2、5，黑色块存放在DataNode1、3、5</p>
<p><img src="/2022/02/21/Hadoop%E6%A0%B8%E5%BF%83-HDFS/5.png"></p>
<p>最后，为了让HDFS可以进行大文件的并发读写，我们对文件的读写做了简化——采用<strong>一次写入，多次读取</strong>的方式，即可避免读写冲突。在HDFS中，只支持顺序写入，不支持随机写入。而且不允许修改上传后的文件，如果需要修改，需要先删除，再上传修改完后的文件。</p>
<p>一个很自然的问题是，HDFS把大文件切成块之后，这些块和操作系统中的块有什么区别？</p>
<ul>
<li>显然，在HDFS将大文件切成128MB的块之后，会让一些机器去存储，对于这些机器来说，128MB的块就相当于一个文件。机器会将块继续拆分成32KB的块存放在磁盘里面。因此我们可以说HDFS切成的块在上层，操作系统分块在底层。</li>
</ul>
<h3 id="HDFS的架构"><a href="#HDFS的架构" class="headerlink" title="HDFS的架构"></a>HDFS的架构</h3><p>HDFS采用master/slave架构。一个HDFS集群是由一个NameNode、一个Secondary NameNode和一定数目的DataNode组成。NameNode是一个中心服务器，负责<strong>管理文件系统的名字空间</strong>(namespace)以及<strong>客户端对文件的访问</strong>；Sencondary NameNode 所在节点是主节点的备份节点；集群中的DataNode一般是一个节点一个，负责<strong>管理它所在节点上的存储</strong>。</p>
<p><img src="/2022/02/21/Hadoop%E6%A0%B8%E5%BF%83-HDFS/2.png" style="zoom:67%;"></p>
<p>接下来，我们来详细介绍每个节点的作用。</p>
<h4 id="NameNode内部结构"><a href="#NameNode内部结构" class="headerlink" title="NameNode内部结构"></a>NameNode内部结构</h4><p>NameNode执行文件系统的名字空间操作，比如打开、关闭、重命名文件或目录。它也负责确定数据块到具体DataNode节点的映射。</p>
<p><img src="/2022/02/21/Hadoop%E6%A0%B8%E5%BF%83-HDFS/6.png" style="zoom:67%;"></p>
<p>如上图，NameNode在内存中维护了HDFS的树形结构的目录。这和Linux文件系统的目录结构时分类似。但这个目录只指示了文件块存储的位置，而不实际存储文件。HDFS将目录结构存放在磁盘上的FsImage文件中，可以看做是HDFS目录结构的一个本地快照。</p>
<p>此外，Editlog文件主要记录了对目录以及HDFS文件块的创建、删除、重命名等操作。</p>
<h4 id="Sencondary-NameNode与NameNode的交互"><a href="#Sencondary-NameNode与NameNode的交互" class="headerlink" title="Sencondary NameNode与NameNode的交互"></a>Sencondary NameNode与NameNode的交互</h4><p>Sencondary NameNode ：充当NameNode的备份，一般在另外一台物理机上运行。一旦NameNode出现故障的时候，就利用Secondary NameNode进行恢复</p>
<p><img src="/2022/02/21/Hadoop%E6%A0%B8%E5%BF%83-HDFS/7.png"></p>
<p>其中，Secondary NameNode和NameNode之间同步的过程如上图所示：</p>
<ol>
<li>当Sec NameNode 开始请求备份数据的时候，NameNode暂时将新到达的修改操作追加到新的EditLog.new 当中</li>
<li>Sec NameNode拉取NameNode中的FsImage和EditLog两个文件</li>
<li>Sec NameNode将这两个文件进行合并形成最新的文件目录结构，形成检查点文件FsImage.ckpt</li>
<li>Sec NameNode将检查点文件返回给NameNode</li>
<li>NameNode使用FsImage.ckpt 替换旧的FsImage文件，并使用EditLog.new替换旧的EditLog文件。</li>
</ol>
<ul>
<li>DataNode处理文件系统客户端的读写请求。在NameNode的统一调度下进行数据块的创建、删除和复制。</li>
</ul>
<p>NameNode和DataNode 被设计成可以在普通的商用机器上运行。这些机器一般运行着GNU/Linux操作系统(OS)。HDFS采用Java语言开发，因此任何支持Java的机器都可以部署NameNode或DataNode。由于采用了可移植性极强的Java语言，使得HDFS可以部署到多种类型的机器上。一个典型的部署场景是一台机器上只运行一个NameNode实例，而集群中的其它机器分别运行一个DataNode实例。这种架构并不排斥在一台机器上运行多个DataNode，只不过这样的情况比较少见。</p>
<h3 id="节点之间的读与写"><a href="#节点之间的读与写" class="headerlink" title="节点之间的读与写"></a>节点之间的读与写</h3><h4 id="文件的分块与备份"><a href="#文件的分块与备份" class="headerlink" title="文件的分块与备份"></a>文件的分块与备份</h4><p>一般来说，HDFS中每个文件块<strong>都有三个副本</strong>，在写入文件块时，NameNode使用以下<strong>启发式策略</strong>来决定副本放置，并不是严格最优的</p>
<ul>
<li><p>第一个副本:  如果客户端和某一DataNode位于同一个物理节点，那么HDFS将第一个副本放置在该DataNode。如果客户端不与任何DataNode放在同一物理节点，那么HDFS随机挑选一台磁盘不太满、CPU不太忙的节点。这种副本放置策略的好处就是<strong>支持快速写入</strong></p>
</li>
<li><p>第二个副本：NameNode将第二个副本放置在与第一个副本不同的机架的某一节点上。例如下图的结构：某一文件块的第一个副本在机架1，那么第二个副本就需要放在机架2上。这样一来，如果机架2上某一个节点要读取这个文件块，就可以直接读取第二个副本了。</p>
<p>因此可以有效地减少跨机架的网络流量。</p>
</li>
<li><p>第三个副本：NameNode将第三个副本放在第一个副本所在机架的不同节点上。这样，如果第一个副本所在的节点宕机了，那么该节点可以读取第三个副本。而且即便机架与交换机之间存在故障也不影响。</p>
<p>因此这种副本放置策略有利于应对故障发生时的文件块读取。</p>
</li>
<li><p>如果还有更多的副本，NameNode将随机选择节点来放置</p>
</li>
</ul>
<p><img src="/2022/02/21/Hadoop%E6%A0%B8%E5%BF%83-HDFS/8.jpeg" style="zoom: 67%;"></p>
<h4 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h4><p><img src="/2022/02/21/Hadoop%E6%A0%B8%E5%BF%83-HDFS/4.png" style="zoom:150%;"></p>
<p>首先我要将一个200M文件存到HDFS集群中。</p>
<ol>
<li>客户端通过RPC（远程服务）访问NameNode，请求写入一个文件。</li>
<li>NameNode检查客户端是否有权限写入，如果有权限返回一个响应。如果没有客户端就会抛出一个异常。</li>
<li>客户端会将文件按BlckSize大小（默认128M）将文件切分成一个一个Block块，然后请求写入第一个Block块。</li>
<li>NameNode会根据它的负载均衡机制，给客户端返回满足其副本数量（默认是3）的列表（BlockId：主机，端口号，存放的目录）。</li>
<li>客户端根据返回的列表，开始建立管道（pipeline）。客户端-&gt;第一个节点-&gt;第二个节点-&gt;第三个节点。</li>
<li>开始传输数据，Block按照Packet一次传输，当一个Packet成功传输到第一个DataNode上以后，第一个DodaNode就把这个Packet开始进行复制，并将这个Packet通过管道传输到下一个DataNode上，下一个DataNode接收到Packet后，继续进行复制，再传输到下一个DataNode上。这就是<strong>单个文件块传输的流水线方式</strong></li>
<li>当一个Block块成功传输完以后，从最后一个DataNode开始，依次从管道返回ACK队列，到客户端。最后，DataNode1会向客户端发送确认信息，表示该文件已成功写入。</li>
<li>客户端会在自己内部维护着一个ACK队列，跟返回来的ACK队列进行匹配，只要有一台DataNode写成功，就认为这次写操作是完成的。</li>
<li>开始进行下一个Block块的写入。重复3-8。 </li>
</ol>
<p>这样一来，集群中单一NameNode的结构大大简化了系统的架构。NameNode是所有HDFS元数据的仲裁者和管理者。用户数据永远不会流过NameNode。</p>
<p>如果在传输的时候，有的DataNode宕机了，这个DataNode就会从这个管道中退出。剩下的DataNode继续传输。然后，等传输完成以后，NameNode会再分发出一个节点，去写成功的DataNode上复制出一份Block块，写到新的DataNode上。</p>
<h5 id="流水线复制"><a href="#流水线复制" class="headerlink" title="流水线复制"></a>流水线复制</h5><p>当客户端向HDFS文件写入数据的时候，一开始是写到本地临时文件中。假设该文件的副本系数设置为3，当本地临时文件累积到一个数据块的大小时，客户端会从NameNode获取一个DataNode列表用于存放副本。然后客户端开始向第一个DataNode传输数据，第一个DataNode一小部分一小部分(4 KB)地接收数据，将每一部分写入本地仓库，并同时传输该部分到列表中第二个DataNode节点。第二个DataNode也是这样，一小部分一小部分地接收数据，写入本地仓库，并同时传给第三个DataNode。最后，第三个DataNode接收数据并存储在本地。因此，DataNode能流水线式地从前一个节点接收数据，并在同时转发给下一个节点，数据以流水线的方式从前一个DataNode复制到下一个。</p>
<h4 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h4><p>现在我们来学习，在这种架构下，当客户端需要读取数据的时候，系统是如何操作的。</p>
<ol>
<li>客户端回合NameNode通信，请求读取一个文件</li>
<li>NameNode会根据文件的路径等信息，判断读取请求是否合法。如果合法则向客户端返回文件所有数据块的存放地址</li>
<li>对于第一个数据块，客户端从最近的存放该数据块的DataNode读取数据</li>
<li>当第一个数据块读取完毕后，客户端从最近的存放第二个数据块的DataNode读取数据</li>
<li>以此类推，客户端读取下一个数据块，直到读取完所有数据块。</li>
</ol>
<p><img src="/2022/02/21/Hadoop%E6%A0%B8%E5%BF%83-HDFS/8.png"></p>
<p>读取和写入的不同在于，当我写入文件的时候，客户端在每次写入一个文件块的时候，都需要询问NameNode该文件块存放的位置，并不是NameNode一次性告诉客户端所有的文件块应该存放的位置；而读取的时候，客户端则可以一下子知道所有文件块应该存放的位置。这很好理解，在写入的时候节点状态时刻在发生变化。</p>
<h4 id="文件读写与一致性"><a href="#文件读写与一致性" class="headerlink" title="文件读写与一致性"></a>文件读写与一致性</h4><p>如果在HDFS上对同一个文件进行并发读写访问，那么就需要加锁来保证互斥访问。这会增加编程的复杂度。因此我们可以约定：只会有一个写文件的请求发生，文件写入之后就不会更改了，文件写入后的读取操作可以并发。</p>
<p>基于这种思想，HDFS采用了<strong>一次写入、多次读取</strong>和简化一致性模型：</p>
<ul>
<li>一个文件经过创建、写入和关闭后，就不能改变文件中已有的内容</li>
<li>已经写入到HDFS的文件，仅允许在文件末尾追加数据，即append</li>
<li>当对一个文件进行写入操作或者追加操作的时候，NameNode将拒绝其他针对该文件的读、写请求</li>
<li>当对一个文件进行读取操作时，NameNode允许其他针对该文件的读请求。</li>
</ul>
<p><strong>提问</strong>： 读取的时候可以并行读取吗？</p>
<p>如果以还原文件为目的的话，是不可以并行的，因为文件的块与块之间需要做一个拼接，如果并行读取的话，会导致文件数据混乱无法还原。</p>
<h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><p>Namespace的中文名是：文件系统的名字空间 </p>
<p>HDFS支持传统的层次型文件组织结构。用户或者应用程序可以创建目录，然后将文件保存在这些目录里。文件系统名字空间的层次结构和大多数现有的文件系统类似：用户可以创建、删除、移动或重命名文件。当前，HDFS不支持用户磁盘配额和访问权限控制，也不支持硬链接和软链接。但是HDFS架构并不妨碍实现这些特性。</p>
<p>NameNode负责<strong>维护文件系统的名字空间</strong>，任何对文件系统名字空间或属性的修改都将被NameNode记录下来。应用程序可以设置HDFS保存的文件的副本数目。文件副本的数目称为文件的副本系数，这个信息也是由NameNode保存的。</p>
<h4 id="Back-up-Metadata"><a href="#Back-up-Metadata" class="headerlink" title="Back up Metadata"></a>Back up Metadata</h4><p>HDFS被设计成能够在一个大集群中跨机器可靠地存储超大文件。它将每个文件存储成一系列的数据块，除了最后一个，所有的数据块都是同样大小的。<strong>为了容错，文件的所有数据块都会有副本。</strong>每个文件的数据块大小和副本系数都是可配置的。应用程序可以指定某个文件的副本数目。副本系数可以在文件创建的时候指定，也可以在之后改变。HDFS中的文件都是一次性写入的，并且严格要求在任何时候只能有一个写入者。</p>
<p>NameNode全权管理数据块的复制，它周期性地从集群中的每个DataNode接收心跳信号和块状态报告(Blockreport)。接收到心跳信号意味着该DataNode节点工作正常。块状态报告包含了一个该DataNode上所有数据块的列表。</p>
<p>就比如说</p>
<h4 id="副本存放-最最开始的一步"><a href="#副本存放-最最开始的一步" class="headerlink" title="副本存放: 最最开始的一步"></a>副本存放: 最最开始的一步</h4><p>副本的存放是HDFS可靠性和性能的关键。优化的副本存放策略是HDFS区分于其他大部分分布式文件系统的重要特性。这种特性需要做大量的调优，并需要经验的积累。HDFS采用一种称为机架感知(rack-aware)的策略来改进数据的可靠性、可用性和网络带宽的利用率。目前实现的副本存放策略只是在这个方向上的第一步。实现这个策略的短期目标是验证它在生产环境下的有效性，观察它的行为，为实现更先进的策略打下测试和研究的基础。</p>
<p>大型HDFS实例一般运行在跨越多个机架的计算机组成的集群上，不同机架上的两台机器之间的通讯需要经过交换机。在大多数情况下，同一个机架内的两台机器间的带宽会比不同机架的两台机器间的带宽大。</p>
<p>通过一个<a href="https://hadoop.apache.org/docs/r1.0.4/cn/cluster_setup.html#Hadoop的机架感知" target="_blank" rel="noopener">机架感知</a>的过程，NameNode可以确定每个DataNode所属的机架id。一个简单但没有优化的策略就是将副本存放在不同的机架上。这样可以有效防止当整个机架失效时数据的丢失，并且允许读数据的时候充分利用多个机架的带宽。这种策略设置可以将副本均匀分布在集群中，有利于当组件失效情况下的负载均衡。但是，因为这种策略的一个写操作需要传输数据块到多个机架，这增加了写的代价。</p>
<p>在大多数情况下，副本系数是3，HDFS的存放策略是将一个副本存放在本地机架的节点上，一个副本放在同一机架的另一个节点上，最后一个副本放在不同机架的节点上。这种策略减少了机架间的数据传输，这就提高了写操作的效率。机架的错误远远比节点的错误少，所以这个策略不会影响到数据的可靠性和可用性。于此同时，因为数据块只放在两个（不是三个）不同的机架上，所以此策略减少了读取数据时需要的网络传输总带宽。在这种策略下，副本并不是均匀分布在不同的机架上。三分之一的副本在一个节点上，三分之二的副本在一个机架上，其他副本均匀分布在剩下的机架中，<strong>这一策略在不损害数据可靠性和读取性能的情况下改进了写的性能</strong>。 </p>
<h4 id="副本选择"><a href="#副本选择" class="headerlink" title="副本选择"></a>副本选择</h4><p>为了降低整体的带宽消耗和读取延时，<strong>HDFS会尽量让读取程序读取离它最近的副本</strong>。如果在读取程序的同一个机架上有一个副本，那么就读取该副本。如果一个HDFS集群跨越多个数据中心，那么客户端也将首先读本地数据中心的副本。</p>
<h4 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h4><p>NameNode启动后会进入一个称为安全模式的特殊状态。处于安全模式的NameNode是不会进行数据块的复制的。NameNode从所有的 DataNode接收心跳信号和块状态报告。块状态报告包括了某个DataNode所有的数据块列表。每个数据块都有一个指定的最小副本数。当NameNode检测确认某个数据块的副本数目达到这个最小值，那么该数据块就会被认为是副本安全(safely replicated)的；在一定百分比（这个参数可配置）的数据块被NameNode检测确认是安全之后（加上一个额外的30秒等待时间），NameNode将退出安全模式状态。接下来它会确定还有哪些数据块的副本没有达到指定数目，并将这些数据块复制到其他DataNode上。</p>
<h3 id="文件系统元数据的持久化"><a href="#文件系统元数据的持久化" class="headerlink" title="文件系统元数据的持久化"></a>文件系统元数据的持久化</h3><p>NameNode上保存着HDFS的名字空间。对于任何对文件系统元数据产生修改的操作，NameNode都会使用一种称为EditLog的事务日志记录下来。例如，在HDFS中创建一个文件，NameNode就会在Editlog中插入一条记录来表示；同样地，修改文件的副本系数也将往Editlog插入一条记录。NameNode在本地操作系统的文件系统中存储这个Editlog。整个文件系统的名字空间，包括数据块到文件的映射、文件的属性等，都存储在一个称为FsImage的文件中，这个文件也是放在NameNode所在的本地文件系统上。</p>
<p>NameNode在内存中保存着整个文件系统的名字空间和文件数据块映射(Blockmap)的映像。这个关键的元数据结构设计得很紧凑，因而一个有4G内存的NameNode足够支撑大量的文件和目录。当NameNode启动时，它从硬盘中读取Editlog和FsImage，将所有Editlog中的事务作用在内存中的FsImage上，并将这个新版本的FsImage从内存中保存到本地磁盘上，然后删除旧的Editlog，因为这个旧的Editlog的事务都已经作用在FsImage上了。这个过程称为一个检查点(checkpoint)。在当前实现中，检查点只发生在NameNode启动时，在不久的将来将实现支持周期性的检查点。</p>
<p>DataNode将HDFS数据以文件的形式存储在本地的文件系统中，它并不知道有关HDFS文件的信息。它把每个HDFS数据块存储在本地文件系统的一个单独的文件中。DataNode并不在同一个目录创建所有的文件，实际上，它用试探的方法来确定每个目录的最佳文件数目，并且在适当的时候创建子目录。在同一个目录中创建所有的本地文件并不是最优的选择，这是因为本地文件系统可能无法高效地在单个目录中支持大量的文件。当一个DataNode启动时，它会扫描本地文件系统，产生一个这些本地文件对应的所有HDFS数据块的列表，然后作为报告发送到NameNode，这个报告就是块状态报告。</p>
<h3 id="通讯协议"><a href="#通讯协议" class="headerlink" title="通讯协议"></a>通讯协议</h3><p>所有的HDFS通讯协议都是建立在TCP/IP协议之上。客户端通过一个可配置的TCP端口连接到NameNode，通过ClientProtocol协议与NameNode交互。而DataNode使用DataNodeProtocol协议与NameNode交互。一个远程过程调用(RPC)模型被抽象出来封装ClientProtocol和DataNodeprotocol协议。在设计上，NameNode不会主动发起RPC，而是响应来自客户端或 DataNode 的RPC请求。</p>
<h3 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h3><p>HDFS的主要目标就是即使在出错的情况下也要保证数据存储的可靠性。常见的三种出错情况是：NameNode出错, DataNode出错和网络割裂(network partitions)。</p>
<h4 id="磁盘数据错误，心跳检测和重新复制"><a href="#磁盘数据错误，心跳检测和重新复制" class="headerlink" title="磁盘数据错误，心跳检测和重新复制"></a>磁盘数据错误，心跳检测和重新复制</h4><p>每个DataNode节点周期性地向NameNode发送心跳信号。网络割裂可能导致一部分DataNode跟NameNode失去联系。NameNode通过心跳信号的缺失来检测这一情况，并将这些近期不再发送心跳信号DataNode标记为宕机，不会再将新的IO请求发给它们。任何存储在宕机DataNode上的数据将不再有效。DataNode的宕机可能会引起一些数据块的副本系数低于指定值，NameNode不断地检测这些需要复制的数据块，一旦发现就启动复制操作。在下列情况下，可能需要重新复制：某个DataNode节点失效，某个副本遭到损坏，DataNode上的硬盘错误，或者文件的副本系数增大。</p>
<h4 id="集群均衡"><a href="#集群均衡" class="headerlink" title="集群均衡"></a>集群均衡</h4><p>HDFS的架构支持数据均衡策略。如果某个DataNode节点上的空闲空间低于特定的临界点，按照均衡策略系统就会自动地将数据从这个DataNode移动到其他空闲的DataNode。当对某个文件的请求突然增加，那么也可能启动一个计划创建该文件新的副本，并且同时重新平衡集群中的其他数据。这些均衡策略目前还没有实现。</p>
<h4 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h4><p>从某个DataNode获取的数据块有可能是损坏的，损坏可能是由DataNode的存储设备错误、网络错误或者软件bug造成的。HDFS客户端软件实现了对HDFS文件内容的校验和(checksum)检查。当客户端创建一个新的HDFS文件，会计算这个文件每个数据块的校验和，并将校验和作为一个单独的隐藏文件保存在同一个HDFS名字空间下。当客户端获取文件内容后，它会检验从DataNode获取的数据跟相应的校验和文件中的校验和是否匹配，如果不匹配，客户端可以选择从其他DataNode获取该数据块的副本。</p>
<h4 id="元数据磁盘错误"><a href="#元数据磁盘错误" class="headerlink" title="元数据磁盘错误"></a>元数据磁盘错误</h4><p>FsImage和Editlog是HDFS的核心数据结构。如果这些文件损坏了，整个HDFS实例都将失效。因而，NameNode可以配置成支持维护多个FsImage和Editlog的副本。任何对FsImage或者Editlog的修改，都将同步到它们的副本上。这种多副本的同步操作可能会降低NameNode每秒处理的名字空间事务数量。然而这个代价是可以接受的，因为即使HDFS的应用是数据密集的，它们也非元数据密集的。当NameNode重启的时候，它会选取最近的完整的FsImage和Editlog来使用。</p>
<p>NameNode是HDFS集群中的单点故障(single point of failure)所在。如果NameNode机器故障，是需要手工干预的。目前，自动重启或在另一台机器上做NameNode故障转移的功能还没实现。</p>
<h4 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h4><p>快照支持某一特定时刻的数据的复制备份。利用快照，可以让HDFS在数据损坏时恢复到过去一个已知正确的时间点。HDFS目前还不支持快照功能，但计划在将来的版本进行支持。</p>
<h3 id="数据组织"><a href="#数据组织" class="headerlink" title="数据组织"></a>数据组织</h3><h4 id="数据块"><a href="#数据块" class="headerlink" title="数据块"></a>数据块</h4><p>HDFS被设计成支持大文件，适用HDFS的是那些需要处理大规模的数据集的应用。这些应用都是只写入数据一次，但却读取一次或多次，并且读取速度应能满足流式读取的需要。HDFS支持文件的“一次写入多次读取”语义。一个典型的数据块大小是64MB(或128MB)。因而，HDFS中的文件总是按照64M被切分成不同的块，每个块尽可能地存储于不同的DataNode中。</p>
<h4 id="Staging"><a href="#Staging" class="headerlink" title="Staging"></a>Staging</h4><p>客户端创建文件的请求其实并没有立即发送给NameNode，事实上，在刚开始阶段HDFS客户端会先将文件数据缓存到本地的一个临时文件。应用程序的写操作被透明地重定向到这个临时文件。当这个临时文件累积的数据量超过一个数据块的大小，客户端才会联系NameNode。NameNode将文件名插入文件系统的层次结构中，并且分配一个数据块给它。然后返回DataNode的标识符和目标数据块给客户端。接着客户端将这块数据从本地临时文件上传到指定的DataNode上。当文件关闭时，在临时文件中剩余的没有上传的数据也会传输到指定的DataNode上。然后客户端告诉NameNode文件已经关闭。此时NameNode才将文件创建操作提交到日志里进行存储。如果NameNode在文件关闭前宕机了，则该文件将丢失。</p>
<p>上述方法是对在HDFS上运行的目标应用进行认真考虑后得到的结果。这些应用需要进行文件的流式写入。如果不采用客户端缓存，由于网络速度和网络堵塞会对吞估量造成比较大的影响。这种方法并不是没有先例的，早期的文件系统，比如AFS，就用客户端缓存来提高性能。为了达到更高的数据上传效率，已经放松了POSIX标准的要求。</p>
<h3 id="可访问性"><a href="#可访问性" class="headerlink" title="可访问性"></a>可访问性</h3><p>HDFS给应用提供了多种访问方式。用户可以通过<a href="https://hadoop.apache.org/docs/current/api/index.html" target="_blank" rel="noopener">Java API</a>接口访问，通过命令行访问，通过Ambari可视化界面访问，也可以通过<a href="https://hadoop.apache.org/docs/current/hadoop-project-dist/hadoop-hdfs/LibHdfs.html" target="_blank" rel="noopener">C语言的封装API</a>访问，还可以通过浏览器的方式访问HDFS中的文件。 </p>
<h4 id="DFS-Shell"><a href="#DFS-Shell" class="headerlink" title="DFS Shell"></a>DFS Shell</h4><p>HDFS以文件和目录的形式组织用户数据。它提供了一个命令行的接口(DFSShell)让用户与HDFS中的数据进行交互。命令的语法和用户熟悉的其他shell(例如 bash, csh)工具类似。下面是一些动作/命令的示例：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">动作</th>
<th style="text-align:center">命令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">创建一个名为 <code>/foodir</code>的目录</td>
<td style="text-align:center"><code>bin/hadoop dfs -mkdir /foodir</code></td>
</tr>
<tr>
<td style="text-align:center">创建一个名为 <code>/foodir</code> 的目录</td>
<td style="text-align:center"><code>bin/hadoop dfs -mkdir /foodir</code></td>
</tr>
<tr>
<td style="text-align:center">查看名为<code>/foodir/myfile.txt</code>的文件内容</td>
<td style="text-align:center"><code>bin/hadoop dfs -cat /foodir/myfile.txt</code></td>
</tr>
</tbody>
</table>
</div>
<p>DFSShell 可以用在那些通过脚本语言和文件系统进行交互的应用程序上。</p>
<h4 id="DFS-Admin"><a href="#DFS-Admin" class="headerlink" title="DFS Admin"></a>DFS Admin</h4><p>DFSAdmin 命令用来管理HDFS集群。这些命令只有HDSF的管理员才能使用。下面是一些动作/命令的示例：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">动作</th>
<th style="text-align:center">命令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">将集群置于安全模式</td>
<td style="text-align:center">bin/hadoop dfsadmin -safemode enter</td>
</tr>
<tr>
<td style="text-align:center">显示DataNode列表</td>
<td style="text-align:center">bin/hadoop dfsadmin -report</td>
</tr>
<tr>
<td style="text-align:center">使DataNode节点 DataNodename退役</td>
<td style="text-align:center">bin/hadoop dfsadmin -decommission DataNodename</td>
</tr>
</tbody>
</table>
</div>
<h4 id="浏览器接口"><a href="#浏览器接口" class="headerlink" title="浏览器接口"></a>浏览器接口</h4><p>一个典型的HDFS安装会在一个可配置的TCP端口开启一个Web服务器用于暴露HDFS的名字空间。用户可以用浏览器来浏览HDFS的名字空间和查看文件的内容。</p>
<h3 id="存储空间回收"><a href="#存储空间回收" class="headerlink" title="存储空间回收"></a>存储空间回收</h3><h4 id="文件的删除和恢复"><a href="#文件的删除和恢复" class="headerlink" title="文件的删除和恢复"></a>文件的删除和恢复</h4><p>当用户或应用程序删除某个文件时，这个文件并没有立刻从HDFS中删除。实际上，HDFS会将这个文件重命名转移到<code>/trash</code>目录。只要文件还在<code>/trash</code>目录中，该文件就可以被迅速地恢复。文件在<code>/trash</code>中保存的时间是可配置的，当超过这个时间时，NameNode就会将该文件从名字空间中删除。删除文件会使得该文件相关的数据块被释放。注意，从用户删除文件到HDFS空闲空间的增加之间会有一定时间的延迟。</p>
<p>只要被删除的文件还在<code>/trash</code>目录中，用户就可以恢复这个文件。如果用户想恢复被删除的文件，可以浏览<code>/trash</code>目录找回该文件。<code>/trash</code>目录仅仅保存被删除文件的最后副本。<code>/trash</code>目录与其他的目录没有什么区别，除了一点：在该目录上HDFS会应用一个特殊策略来自动删除文件。目前的默认策略是删除<code>/trash</code>中保留时间超过6小时的文件。将来，这个策略可以通过一个被良好定义的接口配置。</p>
<h4 id="减少副本系数"><a href="#减少副本系数" class="headerlink" title="减少副本系数"></a>减少副本系数</h4><p>当一个文件的副本系数被减小后，NameNode会选择过剩的副本删除。下次心跳检测时会将该信息传递给DataNode。DataNode遂即移除相应的数据块，集群中的空闲空间加大。同样，在调用setReplication API结束和集群中空闲空间增加间会有一定的延迟。</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/02/20/%E4%BA%86%E8%A7%A3Hadoop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/02/20/%E4%BA%86%E8%A7%A3Hadoop/" itemprop="url">了解Hadoop</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-02-20T22:48:25+08:00">
                2022-02-20
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-02-21T21:18:10+08:00">
                2022-02-21
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="了解Hadoop"><a href="#了解Hadoop" class="headerlink" title="了解Hadoop"></a>了解Hadoop</h1><p>Hadoop 可以理解为一个开源的<strong>软件平台</strong>，它的作用是在计算机集群上分布式存储和分布式处理非常大的数据集。</p>
<p>Hadoop的框架最核心的设计就是：HDFS和 MapReduce。HDFS为海量的数据提供了存储，而MapReduce则为海量的数据提供了计算 </p>
<p>那么我们为什么要用Hadoop来处理大量数据呢？当数据以 TB为单位产生的时候，使用单个数据库显然是不现实的，因此我们需要使用分布式数据库。</p>
<h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><ul>
<li><p>Hadoop最早起源于Yahoo! 的”Nutch”。Nutch的设计目标是构建一个大型的全网搜索引擎，包括网页抓取、索引、查询等功能，但随着抓取网页数量的增加，遇到了严重的可扩展性问题——如何解决数十亿网页的存储和索引问题。</p>
</li>
<li><p>2003年、2004年谷歌发表的两篇论文为该问题提供了可行的解决方案。<br>——分布式文件系统（GFS），可用于处理海量网页的存储<br>——分布式计算框架MapReduce，可用于处理海量网页的索引计算问题。</p>
</li>
<li>Nutch的开发人员完成了相应的开源实现HDFS和MapReduce，并从Nutch中剥离成为独立项目Hadoop，到2008年1月，Hadoop成为Apache顶级项目(同年，cloudera公司成立)，迎来了它的快速发展期。</li>
<li>狭义上来说，hadoop就是单独指代hadoop这个软件;</li>
<li>广义上来说，hadoop指代大数据的一个生态圈，包括很多其他的软件 </li>
</ul>
<h2 id="Hadoop的核心架构"><a href="#Hadoop的核心架构" class="headerlink" title="Hadoop的核心架构"></a>Hadoop的核心架构</h2><p><img src="/2022/02/20/%E4%BA%86%E8%A7%A3Hadoop/1.png" style="zoom:67%;"></p>
<h3 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h3><p>HDFS是Hadoop项目的一部分，项目发起者是Doug Cutting，最初Hadoop只是Hadoop Lucene的子项目Nutch（文本搜索库）的一部分。2003年和2004年，Google先后发表了GFS和MapReduce两篇论文，Doug Cutting认为GFS和MapReduce不仅可以解决超大规模的网页存储和分析处理问题，而且是一个通用处理技术。因此Doug Cutting根据GFS和MapReduce的思想创建了Hadoop项目，并从Lucene项目中独立出来。</p>
<h3 id="YARN"><a href="#YARN" class="headerlink" title="YARN"></a>YARN</h3><p>Yarn最初是为MapReduce设计的一种资源管理器，后成为通用的资源管理系统，为上层应用提供统一的资源管理和调度。Yarn的引入为集群在利用率、资源统一管理和数据共享方面带来了好处。2012年8月，Yarn成为了Apache Hadoop的一个子项目。</p>
<p>我们认为：引入Yarn之前的MapReduce为第一代MapReduce，引入Yarn之后的MapReduce为第二代MapReduce，第一代MapReduce存在局限性，其中最为显著的是资源管理和作业紧密耦合。Yarn的出现使得资源管理模块从第一代MapReduce中独立出来，成为一个通用资源管理平台，而MapReduce和Spark等则作为运行于该平台之上的框架。</p>
<p><img src="/2022/02/20/%E4%BA%86%E8%A7%A3Hadoop/2.png" style="zoom:67%;"></p>
<h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><p>通常所说的MapReduce一般是指Hadoop项目中的MapReduce，它是Google发表学术论文的一种开源实现，而Google公司内部使用的MapReduce系统并不是开源Hadoop项目中的MapReduce。</p>
<p>MapReduce用于处理大批量静态数据，MapReduce被纳入批处理系统范畴。</p>
<p><img src="/2022/02/20/%E4%BA%86%E8%A7%A3Hadoop/3.png" style="zoom:67%;"></p>
<h3 id="Pig"><a href="#Pig" class="headerlink" title="Pig"></a>Pig</h3><p>Pig是Hadoop数据操作的客户端是一个数据分析引擎，采用了一定的语法操作HDFS中的数据（Pig应该说是一种语言，有人说Pig是类SQL的语言我这里只能说它的功能类似Sql语言和数据库的关系，而且这里的Sql更像是PLSQL而不是标准SQL，Hadoop中更像标准Sql的应该是Hive或者叫HiveQL），它的语言比较像Shell脚本，可以嵌入Hadoop的JAVA程序中，从而达到简化代码的功能，Pig的脚本叫Pig Latin，之所以说Pig是一个数据分析引擎，是因为Pig相当于一个翻译器，将Pig Latin语句翻译成MapReduce程序，而Pig Latin语句是一种用于处理大规模数据的脚本语言。Pig Latin可完成排序（Order By）、过滤(Where)、求和(Sum)、分组(Group By)、关联(Join)等操作，支持自定义函数；Pig Latin是把类似Sql的语句转换成MapReduce过程进行处理，减少Java 代码的书写，Pig的运行方式有Grunt Shell方式，脚本方式和嵌入式方式。 </p>
<p>因此，运用pig 脚本我们可以避免用Java或者Python编写MapReduce程序</p>
<h3 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h3><p><a href="https://www.cnblogs.com/jinb/p/6627521.html" target="_blank" rel="noopener">https://www.cnblogs.com/jinb/p/6627521.html</a></p>
<ol>
<li><p>hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供完整的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。</p>
</li>
<li><p>Hive是建立在 Hadoop 上的数据仓库基础构架。它提供了一系列的工具，可以用来进行数据提取转化加载（ETL），这是一种可以存储、查询和分析存储在 Hadoop 中的大规模数据的机制。Hive 定义了简单的类 SQL 查询语言，称为 HQL，它允许熟悉 SQL 的用户查询数据。同时，这个语言也允许熟悉 MapReduce 开发者的开发自定义的 mapper 和 reducer 来处理内建的 mapper 和 reducer 无法完成的复杂的分析工作。</p>
</li>
</ol>
<h3 id="Ambari"><a href="#Ambari" class="headerlink" title="Ambari"></a>Ambari</h3><p>Ambari是Apache推出的一个集中管理Hadoop的集群的一个平台，可以快速帮助搭建Hadoop及相关组件的平台，管理集群方便。在 HDP中，就是用Ambari来对各类组件进行管理，大部分Hadoop组件都可以通过Ambari安装部署管理，包括HDFS、MapReduce、Hive、Pig、HBase、Zookeeper、Sqoop等。它提供一个可视的仪表盘来查看集群的状态，诊断其性能特征。</p>
<p><img src="/2022/02/20/%E4%BA%86%E8%A7%A3Hadoop/4.png" style="zoom:67%;"></p>
<p>对于Ambari的功能介绍，可以看这篇博客： <a href="https://blog.csdn.net/zhangxiongcolin/article/details/83585666" target="_blank" rel="noopener">https://blog.csdn.net/zhangxiongcolin/article/details/83585666</a></p>
<h3 id="MESOS"><a href="#MESOS" class="headerlink" title="MESOS"></a>MESOS</h3><p>Mesos是一个集群管理平台，和YARN是类似的。 可以理解为是一种分布式系统的kernel， 负责集群资源的分配， 这里的资源指的是CPU资源， 内存资源， 存储资源， 网络资源等。 在Mesos可以运行Spark， Storm， Hadoop， Marathon等多种Framework（框架）。 </p>
<p>Mesos的架构主要有Masters（主节点）， Slaves（从节点）， 和 及在Mesos上运行的Framework（框架）组成。 各个部分的分工如下：</p>
<p>Master： 负责处理Slave节点和Framework间的资源通讯， 根据指定的策略来决定分配多少资源给framework。 </p>
<p>Slave:  启动本地进程， 同时向Master报告有哪些资源可用。 </p>
<p>Framework： 接收来自Master提供的Slave节点的资源（如CPU和内存）， Framework由调度器（负责监控和管理Slave的状态）和执行器（负责在服务器执行应用程序代码）组成。 </p>
<p>Mesos本身只提供资源的分配， 并不涉及存储， 任务调度等功能， 所以它要和其它软件或者系统搭配使用才能构成完整的分布式系统。 Mesos， Docker， Marathon/Chronos,  RabbitMQ,  HDFS/Ceph构成了一个完整的分布式系统，  分别负责资源分配， 进程管理，任务调度，  进程间通信和文件系统的功能。 这里可以和Linux做一个横向的比较。 如图1所示: </p>
<p><img src="/2022/02/20/%E4%BA%86%E8%A7%A3Hadoop/5.png" style="zoom:67%;"></p>
<h3 id="TEZ"><a href="#TEZ" class="headerlink" title="TEZ"></a>TEZ</h3><p>MapReduce模型虽然很厉害，但是它不够的灵活，一个简单的join都需要很多骚操作才能完成，又是加标签又是笛卡尔积。那有人就说我就是不想这么干那怎么办呢？Tez是一种新的解决方法</p>
<p>Tez采用了DAG（有向无环图）来组织MR任务（DAG中一个节点就是一个RDD，边表示对RDD的操作）。它的核心思想是把将Map任务和Reduce任务进一步拆分，Map任务拆分为Input-Processor-Sort-Merge-Output，Reduce任务拆分为Input-Shuffer-Sort-Merge-Process-output，Tez将若干小任务灵活重组，形成一个大的DAG作业。</p>
<p><img src="/2022/02/20/%E4%BA%86%E8%A7%A3Hadoop/6.jpeg" style="zoom:67%;"></p>
<p>上图中蓝色框表示Map任务，绿色框表示Reduce任务，云图表示写动作，可以看出，Tez去除了MR中不必要的写过程和Map，形成一张大的DAG图，在数据处理过程中没有往hdfs写数据，直接向后继节点输出，从而提升了效率。</p>
<p><img src="/2022/02/20/%E4%BA%86%E8%A7%A3Hadoop/7.jpeg"></p>
<p>上图是Hadoop1到Hadoop2所做的改变，Hadoop1主要使用MapReduce引擎，到了Hadoop2，基于yarn，可以部署spark，tez等计算引擎，这里MapReduce作为一种引擎实现用的越来越少了，但是作为框架思路，tez本身也是MapReduce的改进。</p>
<h3 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h3><p>Spark是加州大学伯克利分校AMP实验室（Algorithms, Machines, and People Lab）开发的通用内存并行计算框架</p>
<p>Spark是在借鉴了MapReduce之上发展而来的，继承了其分布式并行计算的优点并改进了MapReduce明显的缺陷，具体如下：</p>
<p>首先，Spark把中间数据放到内存中，迭代运算效率高。MapReduce中计算结果需要落地，保存到磁盘上，这样势必会影响整体速度，而Spark支持DAG图的分布式并行计算的编程框架，减少了迭代过程中数据的落地，提高了处理效率。</p>
<p>其次，Spark容错性高。Spark引进了弹性分布式数据集RDD (Resilient Distributed Dataset) 的抽象，它是分布在一组节点中的只读对象集合，这些集合是弹性的，如果数据集一部分丢失，则可以根据“血统”（即充许基于数据衍生过程）对它们进行重建。另外在RDD计算时可以通过CheckPoint来实现容错，而CheckPoint有两种方式：CheckPoint Data，和Logging The Updates，用户可以控制采用哪种方式来实现容错。</p>
<p>最后，Spark更加通用。不像Hadoop只提供了Map和Reduce两种操作，Spark提供的数据集操作类型有很多种，大致分为：Transformations和Actions两大类。Transformations包括Map、Filter、FlatMap、Sample、GroupByKey、ReduceByKey、Union、Join、Cogroup、MapValues、Sort和PartionBy等多种操作类型，同时还提供Count, Actions包括Collect、Reduce、Lookup和Save等操作。另外各个处理节点之间的通信模型不再像Hadoop只有Shuffle一种模式，用户可以命名、物化，控制中间结果的存储、分区等。 </p>
<p><img src="/2022/02/20/%E4%BA%86%E8%A7%A3Hadoop/8.png"></p>
<h3 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h3><p>Apache HBase 是 Hadoop 数据库，一个分布式、可伸缩的<strong>大数据存储</strong>。</p>
<p>HBase是依赖Hadoop的。为什么HBase能存储海量的数据？<strong>因为HBase是在HDFS的基础之上构建的，HDFS是分布式文件系统</strong>。</p>
<p>HBase不同于一般的关系数据库，它是一个适合于非结构化数据存储的数据库。另一个不同的是HBase基于列的而不是基于行的模式。</p>
<p>此外，Pig和Hive还为HBase提供了高层语言支持，使得在HBase上进行数据统计处理变的非常简单。 Sqoop则为HBase提供了方便的RDBMS数据导入功能，使得传统数据库数据向HBase中迁移变的非常方便。</p>
<h3 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h3><p> ZooKeeper 顾名思义 动物园管理员，他是拿来管<a href="http://hadoop.apache.org/" target="_blank" rel="noopener">大象(Hadoop)</a> 、 <a href="http://hive.apache.org/" target="_blank" rel="noopener">蜜蜂(Hive)</a> 、<a href="http://pig.apache.org/" target="_blank" rel="noopener"> 小猪(Pig)</a> 的管理员， Apache Hbase和 Apache Solr 以及<a href="http://sna-projects.com/sensei" target="_blank" rel="noopener">LinkedIn sensei </a> 等项目中都采用到了 Zookeeper。ZooKeeper是一个分布式的，开放源码的<strong>分布式应用程序协调服务</strong>，ZooKeeper是以<a href="http://rdc.taobao.com/blog/cs/?p=261" target="_blank" rel="noopener">Fast Paxos</a>算法为基础，实现同步服务，配置维护和命名服务等分布式应用。</p>
<p>ZooKeeper可以用来跟踪各个节点的状态</p>
<h3 id="Oozie"><a href="#Oozie" class="headerlink" title="Oozie"></a>Oozie</h3><p>Oozie是一个工作流调度系统。 最初是由Cloudear公司开发，后来贡献给Apache。 它能够提供对Hadoop MapReduce和Pig Jobs的任务调度与协调。Oozie需要部署到Java Servlet容器中运行。’</p>
<p>Oozie定义了控制流节点（Control Flow Nodes）和动作节点（Action Nodes），其中控制流节点定义了流程的开始和结束，以及控制流程的执行路径（Execution Path），如decision、fork、join等；而动作节点包括Hadoop map-reduce、Hadoop文件系统、Pig、SSH、HTTP、eMail和Oozie子流程。 </p>
<h3 id="Apache-Storm"><a href="#Apache-Storm" class="headerlink" title="Apache Storm"></a>Apache Storm</h3><p>Apache  Storm是一个免费开源、分布式、高容错的<strong>实时计算系统</strong>。Storm令持续不断的<strong>流计算</strong>变得容易，弥补了Hadoop批处理所不能满足的实时要求。Storm经常用于在实时分析、在线机器学习、持续计算、分布式远程调用和ETL等领域。</p>
<p>Storm主要分为两种组件Nimbus和Supervisor。这两种组件都是快速失败的，没有状态。任务状态和心跳信息等都保存在<strong>Zookeeper</strong>上的，提交的代码资源都在本地机器的硬盘上。</p>
<ul>
<li>Nimbus 负责在集群里面发送代码，分配工作给机器，并且监控状态。全局只有一个。</li>
<li>Supervisor 会监听分配给它那台机器的工作，根据需要启动/关闭工作进程Worker。每一个要运行Storm的机器上都要部署一个，并且，按照机器的配置设定上面分配的槽位数。</li>
<li>Zookeeper是Storm重点依赖的外部资源。Nimbus和Supervisor甚至实际运行的Worker都是把心跳保存在Zookeeper上的。Nimbus也是根据Zookeerper上的心跳和任务运行状况，进行调度和任务分配的。</li>
<li>Topology 处理的最小的消息单位是一个Tuple，也就是一个任意对象的数组。Storm提交运行的程序称为Topology。</li>
<li>Topology 由Spout和Bolt构成。Spout是发出Tuple的结点。Bolt可以随意订阅某个Spout或者Bolt发出的Tuple。Spout和Bolt都统称为component。 </li>
</ul>
<p><img src="/2022/02/20/%E4%BA%86%E8%A7%A3Hadoop/9.png"></p>
<h3 id="Data-Ingestion"><a href="#Data-Ingestion" class="headerlink" title="Data Ingestion"></a>Data Ingestion</h3><h4 id="Sqoop"><a href="#Sqoop" class="headerlink" title="Sqoop"></a>Sqoop</h4><p><strong>Sqoop</strong>是Apache旗下的一款开源工具，该项目开始于2009年，最早是作为Hadoop的一个第三方模块存在，后来为了让使用者能够快速部署，也为了让开发人员能够更快速的迭代开发，并在2013年，独立成为Apache的一个顶级开源项目。</p>
<p>Sqoop主要用于在Hadoop和关系数据库或大型机之间传输数据，可以使用Sqoop工具将数据从关系数据库管理系统导入(import)到Hadoop分布式文件系统中，或者将Hadoop中的数据转换导出(export)到关系数据库管理系统，其功能如下图所示。</p>
<p><img src="/2022/02/20/%E4%BA%86%E8%A7%A3Hadoop/10.png"></p>
<h4 id="Flume"><a href="#Flume" class="headerlink" title="Flume"></a>Flume</h4><p>Flume是一种分布式，可靠且可用的服务，用于有效地<strong>收集，聚合和移动</strong>大量日志数据。Flume构建在日志流之上一个简单灵活的架构。它具有可靠的可靠性机制和许多故障转移和恢复机制，具有强大的容错性。使用Flume这套架构实现对日志流数据的实时在线分析。Flume支持在日志系统中定制各类数据发送方，用于收集数据</p>
<h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><p>  Apache Kafka是一个分布式发布 - 订阅消息系统和一个强大的队列，可以处理大量的数据，并使你能够将消息从一个端点传递到另一个端点。 Kafka适合离线和在线消息消费。 Kafka消息保留在磁盘上，并在群集内复制以防止数据丢失。 Kafka构建在ZooKeeper同步服务之上。 它与Apache Storm和Spark非常好地集成，用于实时流式数据分析。</p>
<p>  Kafka 是一个分布式消息队列，具有高性能、持久化、多副本备份、横向扩展能力。生产者往队列里写消息，消费者从队列里取消息进行业务逻辑。一般在架构设计中起到解耦、削峰、异步处理的作用。</p>
<h2 id="外部数据存储工具"><a href="#外部数据存储工具" class="headerlink" title="外部数据存储工具"></a>外部数据存储工具</h2><ul>
<li><p>MySQL</p>
</li>
<li><p>mongoDB</p>
</li>
<li><p>cassandra</p>
<ul>
<li><p>cassandra是一套开源分布式NoSQL数据库系统</p>
</li>
<li><p>cassandra的特点：</p>
<p>1、弹性可扩展。</p>
<p>2、始终基于架构，没有单点故障。</p>
<p>3、快速线性性能。</p>
<p>4、灵活的数据存储，支持结构化，半结构化和非结构化。</p>
<p>5、便捷数据分发，多数据中心间复制数据。</p>
<p>6、支持事务。</p>
<p>7、快速写入。</p>
</li>
</ul>
</li>
</ul>
<h2 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h2><h3 id="Apache-Drill"><a href="#Apache-Drill" class="headerlink" title="Apache Drill"></a>Apache Drill</h3><p>在大数据时代，对于Hadoop中的信息，越来越多的用户需要能够获得快速且互动的分析方法。大数据面临的一个很大的问题是大多数分析查询都很缓慢且非交互式。目前来看，MapReduce通常用于执行Hadoop数据上的批处理分析，但并不适合于你想快速得到结果或者重新定义查询参数。Google的Dremel能以极快的速度处理网络规模的海量数据。据谷歌的研究报告显示，Dremel能以拍字节（petabyte，PB，1PB等于1024TB）的数量级来进行查询，而且只需几秒钟时间就能完成。而其对应的开源版本就是Drill。（ps：drill其实就是一个分布式实时数据分析查询的引擎。Drill，一个专为互动分析大型数据集的分布式系统。） </p>
<h3 id="Hue"><a href="#Hue" class="headerlink" title="Hue"></a>Hue</h3><p> HUE=Hadoop User Experience</p>
<p> Hue是一个开源的Apache Hadoop UI系统，由Cloudera Desktop演化而来，最后Cloudera公司将其贡献给Apache基金会的Hadoop社区，它是基于Python Web框架Django实现的。</p>
<p>通过使用Hue，可以在浏览器端的Web控制台上与Hadoop集群进行交互，来分析处理数据，例如操作HDFS上的数据，运行MapReduce Job，执行Hive的SQL语句，浏览HBase<a href="https://cloud.tencent.com/solution/database?from=10680" target="_blank" rel="noopener">数据库</a>等等。</p>
<ul>
<li>Hue能做什么<ul>
<li>访问HDFS和文件浏览</li>
<li>通过web调试和开发hive以及数据结果展示</li>
<li>查询solr和结果展示，报表生成</li>
<li>通过web调试和开发impala交互式SQL Query</li>
<li>spark调试和开发</li>
<li>Pig开发和调试</li>
<li>oozie任务的开发，监控，和工作流协调调度</li>
<li>Hbase数据查询和修改，数据展示</li>
<li>Hive的元数据（metastore）查询</li>
<li>MapReduce任务进度查看，日志追踪</li>
<li>创建和提交MapReduce，Streaming，Java job任务</li>
<li>Sqoop2的开发和调试</li>
<li>Zookeeper的浏览和编辑</li>
</ul>
</li>
</ul>
<h3 id="Presto"><a href="#Presto" class="headerlink" title="Presto"></a>Presto</h3><p>presto是Facebook开源的，完全基于内存的并⾏计算的，分布式SQL交互式查询引擎</p>
<p>是一种Massively parallel processing (MPP)架构，多个节点管道式执⾏⽀持任意数据源（通过扩展式Connector组件），数据规模GB~PB级</p>
<p>使用的技术，如向量计算，动态编译执⾏计划，优化的ORC和Parquet Reader等</p>
<p>presto不太支持存储过程，支持部分标准sql</p>
<p>presto的查询速度比hive快5-10倍</p>
<p>和hive的对比：</p>
<p>hive是一个数据仓库，是一个交互式比较弱一点的查询引擎，交互式没有presto那么强，而且只能访问hdfs的数据</p>
<p>presto是一个交互式查询引擎，可以在很短的时间内返回查询结果，秒级，分钟级，能访问很多数据源</p>
<p>hive在查询100Gb级别的数据时，消耗时间已经是分钟级了</p>
<p>但是presto是取代不了hive的，因为p全部的数据都是在内存中，限制了在内存中的数据集大小，比如多个大表的join，这些大表是不能完全放进内存的，实际应用中，对于在presto的查询是有一定规定条件的，比比如说一个查询在presto查询超过30分钟，那就kill掉吧，说明不适合在presto上使用，主要原因是，查询过大的话，会占用整个集群的资源，这会导致你后续的查询是没有资源进行查询的，这跟presto的设计理念是冲突的，就像是你进行一个查询，但是要等个5分钟才有资源继续查询，这是很不合理的，交互式就变得弱了很多</p>
<h3 id="Phoenix"><a href="#Phoenix" class="headerlink" title="Phoenix"></a>Phoenix</h3><p>phoenix:构建在hbase上的一个SQL层，让我们可以用标准的JDBC APIs来创建表，插入数据和对HBase数据进程查询。</p>
<h3 id="Apache-Zeppelin"><a href="#Apache-Zeppelin" class="headerlink" title="Apache Zeppelin"></a>Apache Zeppelin</h3><p> <a href="http://zeppelin.incubator.apache.org/" target="_blank" rel="noopener">Apache Zeppelin</a>提供了web版的类似ipython的notebook，用于做数据分析和可视化。背后可以接入不同的数据处理引擎，包括spark, hive, tajo等，原生支持scala, java, shell, markdown等。它的整体展现和使用形式和Databricks Cloud是一样的，就是来自于当时的demo。</p>
<p>Zeppelin 提供了内置的 <a href="http://lib.csdn.net/base/spark" target="_blank" rel="noopener">Apache Spark</a> 集成。你不需要单独构建一个模块、插件或者库。<br>Zeppelin的Spark集成提供了：<br>- <strong>自动引入SparkContext 和 SQLContext</strong><br>- <strong>从本地文件系统或maven库载入运行时依赖的jar包。</strong><br>- <strong>可取消job 和 展示job进度</strong></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/01/16/Django%E5%AD%A6%E4%B9%A03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/01/16/Django%E5%AD%A6%E4%B9%A03/" itemprop="url">Django学习3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-01-16T22:27:19+08:00">
                2022-01-16
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-08-25T19:34:10+08:00">
                2022-08-25
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Django学习3"><a href="#Django学习3" class="headerlink" title="Django学习3"></a>Django学习3</h1><h2 id="Uploading-Files"><a href="#Uploading-Files" class="headerlink" title="Uploading Files"></a>Uploading Files</h2><p>在这一章，我们将学习如何搭建一个RESTFul API，能实现图片上传的操作</p>
<h3 id="Managing-Media-Files"><a href="#Managing-Media-Files" class="headerlink" title="Managing Media Files"></a>Managing Media Files</h3><p>首先我们要把用户上传的图片给存储到特定地方，然后能够被 url检索到。在这里，我们可以创建一个 media 文件夹。</p>
<p>然后，我们需要修改<code>settings.py</code>, 在<code>settings.py</code> 中有 <code>STATIC_URL = &#39;/static/&#39;</code> 它是用来检索app的静态文件的(如CSS,JAVASCRIPT,HTML) ，因为这属于前端的工作，在这个app中我们就没有创建static文件夹。</p>
<p>那么，当用户上传图片后，我们希望通过<code>/media/{图片路径}</code>来获取图片，因此我们需要创建  MEIDA_URL 和 MEDIA_ROOT 这两个值. 其中<code>MEDIA_URL = &#39;/media/&#39;</code> 代表需要去 media文件夹检索图片; 而 <code>MEDIA_ROOT = os.path.join(BASE_DIR, &#39;media&#39;)</code> 代表将 <code>localhost:9000/</code>和<code>media/</code> 连接起来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MEDIA_URL = <span class="string">'/media/'</span></span><br><span class="line"></span><br><span class="line">MEDIA_ROOT = os.path.join(BASE_DIR, <span class="string">'media'</span>)</span><br></pre></td></tr></table></figure>
<p> 现在，比如说我在media文件夹下存放了一张 <code>dog.jpg</code> 的照片，就可以通过<code>http://127.0.0.1:9000/media/dog.jpg</code> 在网页显示这张照片了</p>
<h3 id="Adding-Images-to-Products"><a href="#Adding-Images-to-Products" class="headerlink" title="Adding Images to Products"></a>Adding Images to Products</h3><p>现在我们要修改models.py, 增加一个 ProductImage的类，因为一件商品可以有多张图片，因此这里需要建立一个一对多的关系：</p>
<p>这里，用 <code>ImageField</code> 来存储一个图片对象，存放在<code>store/images</code> 文件夹当中。</p>
<p>注意，这里一定要确定<code>related_name</code> 要不然Product无法反向找到ProductImage对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductImage</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    product = models.ForeignKey(Product,</span><br><span class="line">                                on_delete = models.CASCADE,</span><br><span class="line">                                related_name=<span class="string">'images'</span>)</span><br><span class="line">    image = models.ImageField(upload_to=<span class="string">'store/images'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Building-an-API-to-Upload-Images"><a href="#Building-an-API-to-Upload-Images" class="headerlink" title="Building an API to Upload Images"></a>Building an API to Upload Images</h3><p>现在我们要创建一个API来上传图片。创建一个API的流程我们已经很熟悉了：先Serializer—View—Router构建出大致框架，再细化Serializer和View实现具体功能</p>
<h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><p>首先我们来确定Serializer中的Meta信息：我们想要呈现的是一个物品的所有图片，以及每张图片的编号和路径。因此我们可以这样来写：</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductImageSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = ProductImage</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'image'</span>]</span><br></pre></td></tr></table></figure>
<p>然后，我们创建 <code>ProductImageViewSet</code> ，在这里一开始要确定<code>serializer_class</code>和<code>queryset</code> ，由于url的模板是这样的<code>store/product/{product_pk}/images/{pk}</code> ，在检索图片的时候，我们就需要用到url中的参数 <code>product_pk</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductImageViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    serializer_class = ProductImageSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> ProductImage.objects.filter(product_id=self.kwargs[<span class="string">'product_pk'</span>])</span><br></pre></td></tr></table></figure>
<p>最后我们注册路由，由于product和images是一对多的关系，这里需要使用嵌套路由，即：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#...</span></span><br><span class="line">products_router = routers.NestedDefaultRouter(</span><br><span class="line">    router, <span class="string">'products'</span>, lookup=<span class="string">'product'</span>)</span><br><span class="line">products_router.register(<span class="string">'images'</span>, views.ProductImageViewSet,</span><br><span class="line">                         basename=<span class="string">'product-images'</span>)</span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<h4 id="具体功能"><a href="#具体功能" class="headerlink" title="具体功能"></a>具体功能</h4><p>这个API的具体功能就是希望将用户上传的图片保存在特定的文件夹当中. 因此，实现的关键就是如何保存图片。</p>
<p>我们知道serializer是无法直接获取到url中的参数的，只能获取请求体中的数据(validated_data).因此需要在views中利用<code>get_serializer_context</code> 方法将该商品的id传入。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductImageViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    serializer_class = ProductImageSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_serializer_context</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'product_id'</span>: self.kwargs[<span class="string">'product_pk'</span>]&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> ProductImage.objects.filter(product_id=self.kwargs[<span class="string">'product_pk'</span>])</span><br></pre></td></tr></table></figure>
<p>然后，我们在serializer中重写create函数，在里面通过<code>self.context[&#39;product_id&#39;]</code>获取到product_pk这个参数，并以此创建一个新的<code>ProductImage</code>对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductImageSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, validated_data)</span>:</span></span><br><span class="line">        product_id = self.context[<span class="string">'product_id'</span>]</span><br><span class="line">        <span class="keyword">return</span> ProductImage.objects.create(product_id=product_id, **validated_data)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = ProductImage</span><br><span class="line">        fields = [<span class="string">'id'</span>, <span class="string">'image'</span>]</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/01/16/Django%E5%AD%A6%E4%B9%A03/1.gif" style="zoom:67%;"></p>
<h3 id="Returning-Images-from-the-API"><a href="#Returning-Images-from-the-API" class="headerlink" title="Returning Images from the API"></a>Returning Images from the API</h3><p>现在，我们希望，在对<code>http://127.0.0.1:9000/store/products/</code> 进行 GET请求的时候，可以将每个product的图片信息显示出来：</p>
<p>怎么修改？首先我们要修改Serializer，让他把image加进来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    images = ProductImageSerializer(many=<span class="literal">True</span>, read_only=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Product</span><br><span class="line">        fields = [<span class="string">'id'</span>,  <span class="string">'title'</span>, <span class="string">'description'</span>, <span class="string">'slug'</span>,</span><br><span class="line">                  <span class="string">'inventory'</span>, <span class="string">'unit_price'</span>, <span class="string">'price_with_tax'</span>, <span class="string">'collection'</span>, <span class="string">'images'</span>]</span><br><span class="line"></span><br><span class="line">    price_with_tax = serializers.SerializerMethodField(</span><br><span class="line">        method_name=<span class="string">'calculate_tax'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate_tax</span><span class="params">(self, product: Product)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> product.unit_price * Decimal(<span class="number">1.1</span>)</span><br></pre></td></tr></table></figure>
<p>为了优化查询，我们需要对ProductViewSet进行修改，即用<code>prefetch_related</code> 将image在初次查询的时候就囊括进来，不用筛选出products以后再单独去进行反向查询</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    queryset = Product.objects.prefetch_related(<span class="string">'images'</span>).all()</span><br><span class="line">    <span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/16/Django%E5%AD%A6%E4%B9%A03/2.png" style="zoom:67%;"></p>
<h3 id="Validating-Uploaded-Files"><a href="#Validating-Uploaded-Files" class="headerlink" title="Validating Uploaded Files"></a>Validating Uploaded Files</h3><p>之前我们使用ImageField来确定上传文件的类型，在这背后其实是 Pillow 包做的底层逻辑，对文件是否为图片进行了一个判断。</p>
<p>那么，如果我们希望对图片的大小进行一个限制，比如说不能超过50kb，该怎么写？</p>
<p>我们可以单独创建一个validators.py来存放验证器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.exceptions <span class="keyword">import</span> ValidationError</span><br><span class="line"><span class="comment"># 在这里我们引入 ValidationError 模块。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validate_file_size</span><span class="params">(file)</span>:</span></span><br><span class="line">    max_size_kb = <span class="number">50</span></span><br><span class="line"><span class="comment"># 如果文件大小(以B为单位)，大于规定大小，我们就会返回一个错误。    </span></span><br><span class="line">    <span class="keyword">if</span> file.size &gt; max_size_kb*<span class="number">1024</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValidationError(<span class="string">f'Files cannot be larger than <span class="subst">&#123;max_size_kb&#125;</span> KB!'</span>)</span><br></pre></td></tr></table></figure>
<p>然后，在models.py中引入这个验证器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductImage</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    product = models.ForeignKey(Product,</span><br><span class="line">                                on_delete=models.CASCADE,</span><br><span class="line">                                related_name=<span class="string">'images'</span>)</span><br><span class="line">    image = models.ImageField(upload_to=<span class="string">'store/images'</span>,</span><br><span class="line">                              validators=[validate_file_size])</span><br></pre></td></tr></table></figure>
<p>此外，如果该属性是 <code>FileField</code> ,我们只希望接收特定格式的文件，比如jpg ，怎么办？ 我们可以使用<code>FileExtensionValidator</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.validators <span class="keyword">import</span> MinValueValidator,FileExtensionValidator</span><br><span class="line"></span><br><span class="line"><span class="comment">#...</span></span><br><span class="line">image = models.FileField(upload_to=<span class="string">'store/images'</span>,</span><br><span class="line">                         validators=[FileExitensionValidator(allowed_extensions=[<span class="string">'jpg'</span>])])</span><br></pre></td></tr></table></figure>
<h3 id="Setting-Up-the-Client-App"><a href="#Setting-Up-the-Client-App" class="headerlink" title="Setting Up the Client App"></a>Setting Up the Client App</h3><p>我们打开part3 中的storefront3_client文件夹，把它复制到电脑硬盘中(直接在移动硬盘中操作会出现奇奇怪怪的问题)，然后运行<code>npm install</code> 安装依赖，接着运行<code>npm start</code> 启动前端项目</p>
<p>结果如下：</p>
<p><img src="/2022/01/16/Django%E5%AD%A6%E4%B9%A03/3.png" style="zoom:67%;"></p>
<h3 id="Enabling-CORS"><a href="#Enabling-CORS" class="headerlink" title="Enabling CORS"></a>Enabling CORS</h3><p>但是，上面这个前端是没有办法向后端去传递消息的，因为没有进行跨域.什么是跨域呢？ 因为前端是运行在8001端口的，而后端是运行在9001 端口的，这两者之间如果不进行跨域的话，是没有办法进行信息传输的。</p>
<p>CORS 即 Cross-origin Resource Sharing 中文名是跨源资源共享，即跨域。它的作用就是将在一个域名接收到的请求转发到另外一个域名，然后将另外一个域名的返回的结果在转发到这个域名上来。类似一个中转服务器</p>
<p>为了在Django中实现CORS，我们需要用到<code>django-cors-headers</code> 这个Github项目，地址：<a href="https://github.com/adamchainz/django-cors-headers" target="_blank" rel="noopener">https://github.com/adamchainz/django-cors-headers</a> 。 里面有细致的安装步骤。</p>
<p>首先，我们运行 <code>pipenv install django-cors-headers</code> 安装 corsheaders APP</p>
<p>然后，我们在 <code>settings.py</code> 中注册 corsheaders</p>
<p>接着，将<code>&#39;corsheaders.middleware.CorsMiddleware&#39;</code> 复制到中间件列表的最前面</p>
<p>最后，注册允许跨域的前端域名，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CORS_ALLOWED_ORIGINS = [</span><br><span class="line">    <span class="string">'http://localhost:8001'</span>,</span><br><span class="line">    <span class="string">'http://127.0.0.1:8001'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>然后，因为我们的后端试监听在9000端口的，因此需要修改前端中的<code>uploadFile</code>函数(默认是8000)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const uploadFile &#x3D; (file) &#x3D;&gt; &#123;</span><br><span class="line">  const apiUrl &#x3D; &#39;http:&#x2F;&#x2F;127.0.0.1:9000&#x2F;store&#x2F;products&#x2F;1&#x2F;images&#x2F;&#39;;</span><br><span class="line">#...</span><br></pre></td></tr></table></figure>
<p>我们可以尝试上传一张图片：</p>
<p><img src="/2022/01/16/Django%E5%AD%A6%E4%B9%A03/4.png" style="zoom:67%;"></p>
<p>然后我们查看请求的url信息：</p>
<p><img src="/2022/01/16/Django%E5%AD%A6%E4%B9%A03/5.png" style="zoom:67%;"></p>
<h3 id="Managing-Images-in-the-Admin"><a href="#Managing-Images-in-the-Admin" class="headerlink" title="Managing Images in the Admin"></a>Managing Images in the Admin</h3><p>现在我们想给以Admin管理图片的功能，能让他在后台可以直接查看到图片，添加\删除图片，怎么办？</p>
<p>由于 图片和商品是一个多对一的关系，想要在特定的商品界面显示与其关联的图片，可以使用inline的方式嵌入：</p>
<p>那么首先我们要到<code>store&gt;admin.py</code> 中创建 <code>ProductImageInline</code> 类：</p>
<p>在这个类中，我们首先规定 models 属性，让其等于 ProductImage</p>
<p>此外，为了显示图片，我们需要额外创建一个字段，暂且称其为 <code>thumnail</code>，然后，我们要使用<code>format_html</code>方法将图片转换成html语言显示出来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductImageInline</span><span class="params">(admin.TabularInline)</span>:</span></span><br><span class="line">    model = models.ProductImage</span><br><span class="line">    readonly_fields = [<span class="string">'thumnail'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">thumnail</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> instance.image.name != <span class="string">''</span>:</span><br><span class="line">            <span class="keyword">return</span> format_html(<span class="string">f'&lt;img src="<span class="subst">&#123;instance.image.url&#125;</span>" class = "thumnail"/&gt;'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br></pre></td></tr></table></figure>
<p>然后，我们要在product中将<code>ProductImageInline</code>类导入进去，之前我们在<code>core&gt;admin.py</code> 中为了实现Generic Model Tag的内联实现，我们重新定义了inline字段，因此要在<code>core&gt;admin.py</code>中导入<code>ProductImageInline</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomProductAdmin</span><span class="params">(ProductAdmin)</span>:</span></span><br><span class="line">    inlines = [TagInline, ProductImageInline]</span><br><span class="line"></span><br><span class="line">admin.site.unregister(Product)</span><br><span class="line">admin.site.register(Product, CustomProductAdmin)</span><br></pre></td></tr></table></figure>
<p>但这还是不够的，虽然能在admin界面显示图片，但是是以原大小显示的，很不美观，因此我们需要用css来调节一下。</p>
<p>为了项目的可维护性，我们需要在store文件夹下创建 static 文件夹，专门存放html、css之类的静态文件。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.thumnail</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">object-fit</span>: cover;<span class="comment">/*等比例缩放*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们要在 ProductAdmin中引入这个css文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@admin.register(models.Product)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line"> 		<span class="comment">#..</span></span><br><span class="line">    <span class="comment"># Media是内置的类，和Meta类似，会自动到static文件夹中找静态文件</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Media</span>:</span></span><br><span class="line">        css = &#123;</span><br><span class="line">            <span class="string">'all'</span>: [<span class="string">'store/style.css'</span>]</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/01/16/Django%E5%AD%A6%E4%B9%A03/6.png" style="zoom:67%;"></p>
<h2 id="Sending-Emails"><a href="#Sending-Emails" class="headerlink" title="Sending Emails"></a>Sending Emails</h2><h3 id="Setting-up-a-Fake-SMTP-Server"><a href="#Setting-up-a-Fake-SMTP-Server" class="headerlink" title="Setting up a Fake SMTP Server"></a>Setting up a Fake SMTP Server</h3><p>在计算机网络中，我们学过<a href="https://jasonxqh.github.io/2021/05/03/计算机网络-应用层总结/#SMTP-电子邮件">SMTP协议</a> ，也就是一个简单邮件传输协议。现在我们如果想要我们的app来发送邮件，就需要创建一个简单的SMTP服务器  </p>
<p>项目网址如下： <a href="https://github.com/rnwood/smtp4dev" target="_blank" rel="noopener">https://github.com/rnwood/smtp4dev</a></p>
<p>我们需要在Docker中安装这个项目，因此需要先安装Docker。然后运行<code>docker run --rm -it -p 3000:80 -p 2525:25 rnwood/smtp4dev</code> 安装</p>
<p>但是对于m1 mac，可能会出现找不到合适版本的问题，我们可以指定一个版本让其安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -it -p 3000:80 -p 2525:25 rnwood&#x2F;smtp4dev:3.1.3-ci20211206101</span><br></pre></td></tr></table></figure>
<p>然后，访问<code>localhost:3000</code> ，就可以打开 smtp4dev</p>
<p><img src="/2022/01/16/Django%E5%AD%A6%E4%B9%A03/7.png" style="zoom:67%;"></p>
<p>这是一个假的smtp服务器，他不会真的发送邮件，但它的作用是检测通过这个端口(2525)利用SMTP协议发送的邮件</p>
<h3 id="Configuring-the-Email-Backend"><a href="#Configuring-the-Email-Backend" class="headerlink" title="Configuring the Email Backend"></a>Configuring the Email Backend</h3><p>首先我们要在Django中对电子邮件后端进行一些配置。</p>
<p>我们</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EMAIL_BACKEND = <span class="string">'django.core.mail.backends.smtp.EmailBackend'</span></span><br><span class="line">EMAIL_HOST = <span class="string">'localhost'</span></span><br><span class="line">EMAIL_HOST_USER = <span class="string">''</span></span><br><span class="line">EMAIL_HOST_PASSWORD = <span class="string">''</span></span><br><span class="line">EMAIL_PORT = <span class="number">2525</span></span><br><span class="line">DEFAULT_FROM_EMAIL = <span class="string">''</span></span><br></pre></td></tr></table></figure>
<p><code>EMAIL_BACKEND</code> 设置邮件后台，默认为smtp，还有console(邮件显示在终端),file(将邮件显示在文件里)</p>
<p><code>EMAIL_HOST</code> 由于smtp4dev是开在本地的，因此这里写 ‘localhost’</p>
<p><code>EMAIL_HOST_USER</code> 和 <code>EMAIL_HOST_PASSWORD</code> 由于对这个邮件服务器我们没有设置用户和密码，因此直接写空串</p>
<p><code>EMAIL_PORT</code> 是邮件走的端口号，由于 smtp4dev 监听在2525，这里写2525</p>
<p><code>DEFAULT_FROM_EMAIL</code> 是默认邮箱，即从这个邮箱往其他邮箱发送邮件</p>
<h3 id="Sending-Emails-1"><a href="#Sending-Emails-1" class="headerlink" title="Sending  Emails"></a>Sending  Emails</h3><p>我们可以用 <code>django.core.mail</code> 中的 <code>send_mail</code> 函数来发送信息。由于存在发送错误的情况，我们需要用 try-except 进行错误捕捉。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> send_mail, mail_admins, BadHeaderError</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个函数第一个参数是邮件主题；第二个参数是正文；第三个参数是发送者邮箱；第四个是接收者邮箱(列表)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        send_mail(<span class="string">'subject'</span>, <span class="string">'message'</span>,</span><br><span class="line">                  <span class="string">'jason@from.com'</span>, [<span class="string">'jason@to.com'</span>])</span><br><span class="line">    <span class="keyword">except</span> BadHeaderError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'hello.html'</span>, &#123;<span class="string">'name'</span>: <span class="string">'Jason'</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>在访问 <code>http://127.0.0.1:9000/playground/hello/</code> 之后我们看到 smtp4dev服务器已经捕捉到这封邮件了</p>
<p><img src="/2022/01/16/Django%E5%AD%A6%E4%B9%A03/8.png" style="zoom:67%;"></p>
<h3 id="Attaching-Files"><a href="#Attaching-Files" class="headerlink" title="Attaching Files"></a>Attaching Files</h3><p>如果我们想发送一封带有附件的文件，该怎么办？</p>
<p>我们可以先确定邮件的内容，然后再利用<code>attach_file</code> 来加载附件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        message = EmailMessage(<span class="string">'subject'</span>, <span class="string">'message'</span>,</span><br><span class="line">                               <span class="string">'jason@from.com'</span>, [<span class="string">'jason@to.com'</span>])</span><br><span class="line">        message.attach_file(<span class="string">'playground/static/1.png'</span>)</span><br><span class="line">        message.send()</span><br><span class="line">    <span class="keyword">except</span> BadHeaderError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'hello.html'</span>, &#123;<span class="string">'name'</span>: <span class="string">'Jason'</span>&#125;)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/01/16/Django%E5%AD%A6%E4%B9%A03/9.png" style="zoom:67%;"></p>
<h3 id="Sending-Templated-Emails"><a href="#Sending-Templated-Emails" class="headerlink" title="Sending Templated Emails"></a>Sending Templated Emails</h3><p>我们可以下载<code>django-templated-mail</code> 这个app，来实现发送模板邮件的功能。</p>
<p>首先我在 <code>playground</code> 下的 <code>templates/emails</code> 文件夹下创建一个<code>hello.html</code>文件，用来存放模板</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block subject%&#125; This is a long subject &#123;% endblock %&#125;</span><br><span class="line"></span><br><span class="line">&#123;%block html_body%&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">My name is &#123;&#123;name&#125;&#125;</span><br><span class="line">&#123;%endblock%&#125;</span><br></pre></td></tr></table></figure>
<p><code>views.py</code>中，我们要用 BaseEmailMessage 去替换原来的 EmailMessage</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> django.core.mail <span class="keyword">import</span> EmailMessage, send_mail, mail_admins, BadHeaderError</span><br><span class="line"><span class="keyword">from</span> templated_mail.mail <span class="keyword">import</span> BaseEmailMessage</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        message = BaseEmailMessage(</span><br><span class="line">            template_name=<span class="string">'emails/hello.html'</span>,</span><br><span class="line">            context=&#123;<span class="string">'name'</span>: <span class="string">'Jason'</span>&#125;</span><br><span class="line">        )</span><br><span class="line">        message.send([<span class="string">'jason@to.com'</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> BadHeaderError:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'hello.html'</span>, &#123;<span class="string">'name'</span>: <span class="string">'Jason'</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2022/01/16/Django%E5%AD%A6%E4%B9%A03/10.png"></p>
<h2 id="Running-Background-Tasks"><a href="#Running-Background-Tasks" class="headerlink" title="Running Background Tasks"></a>Running Background Tasks</h2><h3 id="Introduction-to-Celery"><a href="#Introduction-to-Celery" class="headerlink" title="Introduction to Celery"></a>Introduction to Celery</h3><p>在遇到一些上传文件、发送邮件的任务时，我们希望它能够在后台运行。这时候我们就可以用到Celery：</p>
<p>Celery是一个简单，灵活，可靠的分布式系统，用于处理大量消息，同时为操作提供维护此类系统所需的工具。</p>
<p>它是一个任务队列，专注于实时处理，同时还支持任务调度。</p>
<h4 id="celery-的优点"><a href="#celery-的优点" class="headerlink" title="celery 的优点"></a>celery 的优点</h4><ul>
<li><p>简单：celery的 配置和使用还是比较简单的, 非常容易使用和维护和不需要配置文件</p>
</li>
<li><p>高可用：当任务执行失败或执行过程中发生连接中断，celery 会自动尝试重新执行任务</p>
</li>
<li><p>如果连接丢失或发生故障，worker和client 将自动重试，并且一些代理通过主/主或主/副本复制方式支持HA。</p>
</li>
<li><p>快速：一个单进程的celery每分钟可处理上百万个任务</p>
</li>
<li><p>灵活： 几乎celery的各个组件都可以被扩展及自定制 </p>
</li>
</ul>
<h4 id="celery-的5个角色"><a href="#celery-的5个角色" class="headerlink" title="celery 的5个角色"></a>celery 的5个角色</h4><ul>
<li>Task</li>
</ul>
<p>就是任务，有异步任务和定时任务</p>
<ul>
<li>Broker</li>
</ul>
<p>中间人，接收生产者发来的消息即Task，将任务存入队列。任务的消费者是Worker。</p>
<p>Celery本身不提供队列服务，推荐用Redis或RabbitMQ实现队列服务。Redis只是一个数据库，但是可以用来实现队列服务，而RabbitMQ是一个企业级的 Broker</p>
<ul>
<li>Worker</li>
</ul>
<p>执行任务的单元，它实时监控消息队列，如果有任务就获取任务并执行它。</p>
<ul>
<li>Beat</li>
</ul>
<p>定时任务调度器，根据配置定时将任务发送给Broker。</p>
<ul>
<li>Backend</li>
</ul>
<p>用于存储任务的执行结果。 </p>
<p>其结构如下所示：</p>
<p><img src="/2022/01/16/Django%E5%AD%A6%E4%B9%A03/11.png"></p>
<h3 id="Installing-Redis"><a href="#Installing-Redis" class="headerlink" title="Installing Redis"></a>Installing Redis</h3><p><code>pipenv install redis</code></p>
<p><code>docker run -d -p 6379:6379 redis</code></p>
<p><img src="/2022/01/16/Django%E5%AD%A6%E4%B9%A03/12.png"></p>
<h3 id="Setting-Up-Celery"><a href="#Setting-Up-Celery" class="headerlink" title="Setting Up Celery"></a>Setting Up Celery</h3><p>Celery与Windows系统不兼容，所以如果是windows系统请使用 wsl linux环境运行这个Django项目。</p>
<p>首先，我们要在storefront中新创建一个celery模块：先运行<code>pipenv install celery</code> 下载Celery</p>
<p>进行一个简单的配置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"><span class="comment"># 设置环境变量，将DJANGO_SETTINGS_MODULE设置为这个项目的settings.py</span></span><br><span class="line">os.environ.setdefault(<span class="string">'DJANGO_SETTINGS_MODULE'</span>, <span class="string">'storefront.settings'</span>)</span><br><span class="line"><span class="comment"># 创建一个Celery实例</span></span><br><span class="line">celery = Celery(<span class="string">'storefront'</span>)</span><br><span class="line"><span class="comment"># 确定Celery可以在那里找到配置变量，我们指向了django.conf模块中的settings对象</span></span><br><span class="line"><span class="comment"># 第二个参数代表，所有在setting对象中的变量都需要以CELERY开头</span></span><br><span class="line">celery.config_from_object(<span class="string">'django.conf:settings'</span>, namespace=<span class="string">'CELERY'</span>)</span><br><span class="line">celery.autodiscover_tasks()</span><br></pre></td></tr></table></figure>
<p>然后在<code>settings.py</code>  中 设置<code>CELERY_BROKER_URL</code>变量，6379代表redis运行的端口号，<code>/1</code>代表我们这个项目所属数据库的名字</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CELERY_BROKER_URL = <span class="string">'redis://localhost:6379/1'</span></span><br></pre></td></tr></table></figure>
<p>在 storefront中的<code>__init__.py</code> 中导入我们设置好的celery模块：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .celery <span class="keyword">import</span> celery</span><br></pre></td></tr></table></figure>
<p>最后，我们用<code>celery -A storefront worker --loglevel=info</code> 来启动celery</p>
<p><img src="/2022/01/16/Django%E5%AD%A6%E4%B9%A03/13.png"></p>
<p>我们看到，celery已经启动了，一共有8个cpu核可供我们进行并行任务处理</p>
<p>然而，现在我们的项目已经有点复杂了，一共需要3条命令，3个终端窗口才能实现</p>
<ul>
<li>一个 运行项目 ： <code>python manage.py run server</code></li>
<li>一个运行redis ： <code>docker run -p 6379:6379 redis</code></li>
<li>一个运行celery:  <code>celery -A storefront worker</code></li>
</ul>
<h3 id="Creating-and-Executing-Tasks"><a href="#Creating-and-Executing-Tasks" class="headerlink" title="Creating and Executing Tasks"></a>Creating and Executing Tasks</h3><p>我们在<code>playground</code> 中创建<code>tasks.py</code> 用来模拟需要运行的任务。这里我们模拟发送一封信件，需要消耗10s。注意，如果要让celery去执行，需要使用<code>shared_task</code>来修饰</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> shared_task</span><br><span class="line"></span><br><span class="line"><span class="meta">@shared_task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">notify_customers</span><span class="params">(message)</span>:</span></span><br><span class="line">    print(<span class="string">'Sending 10k emails...'</span>)</span><br><span class="line">    print(message)</span><br><span class="line">    sleep(<span class="number">10</span>)</span><br><span class="line">    print(<span class="string">'Emails were successfully sent!'</span>)</span><br></pre></td></tr></table></figure>
<p>然后，我们可以再<code>views.py</code>中运行这个任务：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .tasks <span class="keyword">import</span> notify_customers</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(request)</span>:</span></span><br><span class="line">  	<span class="comment">#需要用到 .delay()方法 </span></span><br><span class="line">    notify_customers.delay(<span class="string">'hello'</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'hello.html'</span>, &#123;<span class="string">'name'</span>: <span class="string">'Jason'</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>结果如下，我访问<code>http://localhost:9000/playground/hello/</code>会直接返回html文件：</p>
<p><img src="/2022/01/16/Django%E5%AD%A6%E4%B9%A03/15.gif"></p>
<p>此时，该任务在后台运行，我们发现，过了10秒以后，才显示 Email were successfully sent</p>
<p><img src="/2022/01/16/Django%E5%AD%A6%E4%B9%A03/14.png"></p>
<p>需要注意的是，这里我即使使用 ctrl+c 关闭了 Celery ，刷新界面之后也会直接返回html文件，这是因为，redis还开在后台，项目会把这个任务存放在redis(broker)当中，当celery重新启动的时候，redis会尝试重新发送这个任务给worker。</p>
<p>但是如果我关掉redis，那么程序就会报错，因为任务无法发送到6379端口</p>
<h3 id="Scheduling-Periodic-Tasks"><a href="#Scheduling-Periodic-Tasks" class="headerlink" title="Scheduling Periodic Tasks"></a>Scheduling Periodic Tasks</h3><p>如果我希望每隔特定的时间重复运行一个任务，我们可以使用 celery beat</p>
<p>要使用celery beat，需要在 <code>settings.py</code>中设置 <code>CELERY_BEAT_SCHEDULE</code> 变量，如下所示：</p>
<p>首先，我们要确定重复的任务：notify_customers，设置这个任务的位置, 即task属性，以及什么时候重复。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CELERY_BEAT_SCHEDULE = &#123;</span><br><span class="line">    <span class="string">'notify_customers'</span>: &#123;</span><br><span class="line">        <span class="string">'task'</span>: <span class="string">'playground.tasks.notify_customers'</span>,</span><br><span class="line">        <span class="string">'schedule'</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="string">'args'</span>: [<span class="string">'Hello world'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我直接使用了数字2，代表每间隔2秒进行一次重复。当然，我也可以使用<code>celery.schedules</code>中的 <code>crontab</code>模块：<code>&#39;schedule&#39;: crontab(day_of_week=1, hour=7, minute=5)</code></p>
<p>这个就代表，每一周的第一天的七点零五分运行这个任务。</p>
<p>或者<code>&#39;schedule&#39;: crontab(minute=&#39;*/15&#39;)</code> 代表每间隔15分钟运行一次，当然<code>&#39;schedule&#39;: 15*60</code> 也可以达到相同的结果。</p>
<p>最后，我们打开一个新的终端，运行<code>celery -A storefront beat</code></p>
<p><img src="/2022/01/16/Django%E5%AD%A6%E4%B9%A03/16.gif"></p>
<h3 id="Monitoring-Celery-Tasks"><a href="#Monitoring-Celery-Tasks" class="headerlink" title="Monitoring Celery Tasks"></a>Monitoring Celery Tasks</h3><p>最后，我们来讲讲怎么监控 Celery Task , 这里我们需要用到一个小工具： Flower。 我们可以用<code>pipenv install flower</code> 来下载</p>
<p>然后用<code>celery -A storefront flower</code>来启动flower：</p>
<p>然后访问<code>http://localhost:5555</code> 来监控后台任务</p>
<p><img src="/2022/01/16/Django%E5%AD%A6%E4%B9%A03/17.png"></p>
<h2 id="Automated-Testing"><a href="#Automated-Testing" class="headerlink" title="Automated Testing"></a>Automated Testing</h2><h3 id="What-is-Automated-Testing"><a href="#What-is-Automated-Testing" class="headerlink" title="What is Automated Testing"></a>What is Automated Testing</h3><p>现在我们要对项目做单元测试。单元测试是代码正确性验证的最重要的工具，也是系统测试当中最重要的环节。也是唯一需要编写代码才能进行测试的一种测试方法。在标准的开发过程中，单元测试的代码与实际程序的代码具有同等的重要性。每一个单元测试，都是用来定向测试其所对应的一个单元的数据是否正确。</p>
<p>比如说对于我们store app中的products，对它们可以进行创建、更新、删除等操作。但有些操作只有特定权限的用户才能够进行。因此我们需要手动测试这些api，是否只有特定的人才能实现特定的功能。</p>
<p>然而，单元测试的代码会随着项目的增长称指数型爆发，在后期会难以为继，因此，我们就需要更有效地工具——自动测试(Automated Testing) , 我们可以将测试集成在一起，然后统一运行，这样节省了时间，又能使测试覆盖面更广。</p>
<h3 id="Test-Behaviours-Not-Implementations"><a href="#Test-Behaviours-Not-Implementations" class="headerlink" title="Test Behaviours,Not Implementations"></a>Test Behaviours,Not Implementations</h3><p>写单元测试的时候，我们要有一个原则： 测试api的行为，不测试api的实现逻辑。就好比我们要测试电视遥控板的功能是否正常，而不是把电视遥控板拆开去测一个电阻是否正常工作</p>
<p>比如说，我们对 /collections 的POST方法进行测试，我们需要囊括以下结果：</p>
<ul>
<li>Anonymous -&gt; 401</li>
<li>Non-admin -&gt; 403</li>
<li>Admin &amp;&amp; invalid data -&gt; 401</li>
<li>Admin &amp;&amp; valid data -&gt; 401</li>
</ul>
<p>这是这个collection的behavior，而不是内部的实现逻辑</p>
<h3 id="Tooling"><a href="#Tooling" class="headerlink" title="Tooling"></a>Tooling</h3><p>在Python中，我们有不同的测试工具，主要是两个测试框架：</p>
<ul>
<li>unittest</li>
<li>pytest</li>
</ul>
<p>在这里我们使用pytest, 因为它有三个优点：</p>
<ul>
<li>More features</li>
<li>Tons of  plugins</li>
<li>Less boilerplate(代码量少)</li>
</ul>
<p>我们可以用 <code>pipenv install --dev pytest</code> 来下在pytest</p>
<p>此外，还需要下载一个插件： <code>pipenv install --dev pytest-django</code></p>
<h3 id="Your-First-Test"><a href="#Your-First-Test" class="headerlink" title="Your First Test"></a>Your First Test</h3><p>现在我们来写第一个test，首先我们在store文件夹下创建一个test文件夹，然后创建<code>test_collection.py</code> ，注意，命名规则需要一个<code>test_</code> 开始。</p>
<p>然后，为了方面组织测试函数，我们把测试一个功能的所有函数都放在一个类里，这个类叫做<code>TestCreateCollection</code> 注意，这个类也要以<code>Test</code> 开始，否则pytest不会把这个测试囊括在内。</p>
<p>在这个类中，我们可以写一个个测试函数。注意，函数命名要以<code>test_</code>开始。</p>
<p>接下来我们正式开始写测试，首先，我们需要用到APIClient，它可以模拟一个客户端向后端发送请求。</p>
<p>因为这里我们想要测试创建collection，因此需要用到<code>client.post</code></p>
<p>然后，我们判断 response的状态码是否等于预想的401，如果等于，测试就会通过，否则就会报错。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.test <span class="keyword">import</span> APIClient</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> status</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCreateCollection</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_if_user_is_anonymous_returns_401</span><span class="params">(self)</span>:</span></span><br><span class="line">        client = APIClient()</span><br><span class="line">        response = client.post(<span class="string">'/store/collections'</span>, &#123;<span class="string">'title'</span>: <span class="string">'a'</span>&#125;)</span><br><span class="line">        <span class="keyword">assert</span> response.status_code == status.HTTP_401_UNAUTHORIZED</span><br></pre></td></tr></table></figure>
<h3 id="Running-Tests"><a href="#Running-Tests" class="headerlink" title="Running Tests"></a>Running Tests</h3><p>接下来我们运行上面这个测试：</p>
<h3 id="Skipping-Tests"><a href="#Skipping-Tests" class="headerlink" title="Skipping Tests"></a>Skipping Tests</h3><h3 id="Continuous-Testing"><a href="#Continuous-Testing" class="headerlink" title="Continuous Testing"></a>Continuous Testing</h3><h3 id="Running-and-Debugging-Tests-in-VSCode"><a href="#Running-and-Debugging-Tests-in-VSCode" class="headerlink" title="Running and Debugging Tests in VSCode"></a>Running and Debugging Tests in VSCode</h3><h3 id="Authenticating-the-User"><a href="#Authenticating-the-User" class="headerlink" title="Authenticating the User"></a>Authenticating the User</h3><h3 id="Single-or-Multiple-Assertions"><a href="#Single-or-Multiple-Assertions" class="headerlink" title="Single or Multiple Assertions"></a>Single or Multiple Assertions</h3><h3 id="Fixtures"><a href="#Fixtures" class="headerlink" title="Fixtures"></a>Fixtures</h3><h3 id="Creating-Model-Instances"><a href="#Creating-Model-Instances" class="headerlink" title="Creating Model Instances"></a>Creating Model Instances</h3><h2 id="Performance-Testing"><a href="#Performance-Testing" class="headerlink" title="Performance Testing"></a>Performance Testing</h2><h3 id="Why-Performance-Testing"><a href="#Why-Performance-Testing" class="headerlink" title="Why Performance Testing"></a>Why Performance Testing</h3><h3 id="Installing-Locust"><a href="#Installing-Locust" class="headerlink" title="Installing Locust"></a>Installing Locust</h3><h3 id="Creating-a-Test-Script"><a href="#Creating-a-Test-Script" class="headerlink" title="Creating a Test Script"></a>Creating a Test Script</h3><h3 id="Running-a-Test-Script"><a href="#Running-a-Test-Script" class="headerlink" title="Running a Test Script"></a>Running a Test Script</h3><h3 id="Running-a-Performance-Test"><a href="#Running-a-Performance-Test" class="headerlink" title="Running a Performance Test"></a>Running a Performance Test</h3><h3 id="Performance-Optimization-Techniques"><a href="#Performance-Optimization-Techniques" class="headerlink" title="Performance Optimization Techniques"></a>Performance Optimization Techniques</h3><h3 id="Profiling-with-Silk"><a href="#Profiling-with-Silk" class="headerlink" title="Profiling with Silk"></a>Profiling with Silk</h3><h3 id="Verifying-Optimizations"><a href="#Verifying-Optimizations" class="headerlink" title="Verifying Optimizations"></a>Verifying Optimizations</h3><h3 id="Stress-Testing"><a href="#Stress-Testing" class="headerlink" title="Stress Testing"></a>Stress Testing</h3><h2 id="Caching"><a href="#Caching" class="headerlink" title="Caching"></a>Caching</h2><h3 id="What-is-Caching"><a href="#What-is-Caching" class="headerlink" title="What is Caching"></a>What is Caching</h3><h3 id="Cache-Backends"><a href="#Cache-Backends" class="headerlink" title="Cache Backends"></a>Cache Backends</h3><h3 id="Simulating-a-Slow-API"><a href="#Simulating-a-Slow-API" class="headerlink" title="Simulating a Slow API"></a>Simulating a Slow API</h3><h3 id="Getting-a-Baseline-Performance-Benchmark"><a href="#Getting-a-Baseline-Performance-Benchmark" class="headerlink" title="Getting a Baseline Performance Benchmark"></a>Getting a Baseline Performance Benchmark</h3><h3 id="Installing-Redis-1"><a href="#Installing-Redis-1" class="headerlink" title="Installing Redis"></a>Installing Redis</h3><h3 id="Configuring-Caching"><a href="#Configuring-Caching" class="headerlink" title="Configuring Caching"></a>Configuring Caching</h3><h3 id="Using-the-Low-level-Cache-API"><a href="#Using-the-Low-level-Cache-API" class="headerlink" title="Using the Low-level Cache API"></a>Using the Low-level Cache API</h3><h3 id="Caching-Views-mp4"><a href="#Caching-Views-mp4" class="headerlink" title="Caching Views.mp4"></a>Caching Views.mp4</h3><h3 id="Verifying-Optimizations-1"><a href="#Verifying-Optimizations-1" class="headerlink" title="Verifying Optimizations"></a>Verifying Optimizations</h3><h3 id="Managing-Redis-Cache-Content"><a href="#Managing-Redis-Cache-Content" class="headerlink" title="Managing Redis Cache Content"></a>Managing Redis Cache Content</h3><h2 id="Preparing-for-Production"><a href="#Preparing-for-Production" class="headerlink" title="Preparing for Production"></a>Preparing for Production</h2><h3 id="Adding-the-Home-Page"><a href="#Adding-the-Home-Page" class="headerlink" title="Adding the Home Page"></a>Adding the Home Page</h3><h3 id="Adding-Static-Assets"><a href="#Adding-Static-Assets" class="headerlink" title="Adding Static Assets"></a>Adding Static Assets</h3><h3 id="Collecting-Static-Assets"><a href="#Collecting-Static-Assets" class="headerlink" title="Collecting Static Assets"></a>Collecting Static Assets</h3><h3 id="Serving-Static-Assets"><a href="#Serving-Static-Assets" class="headerlink" title="Serving Static Assets"></a>Serving Static Assets</h3><h3 id="Configuring-Logging"><a href="#Configuring-Logging" class="headerlink" title="Configuring Logging"></a>Configuring Logging</h3><h3 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h3><h3 id="Managing-Development-and-Production-Settings"><a href="#Managing-Development-and-Production-Settings" class="headerlink" title="Managing Development and Production Settings"></a>Managing Development and Production Settings</h3><h3 id="Serving-the-Application-with-Gunicorn"><a href="#Serving-the-Application-with-Gunicorn" class="headerlink" title="Serving the Application with Gunicorn"></a>Serving the Application with Gunicorn</h3><h2 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h2><h3 id="Hosting-Options"><a href="#Hosting-Options" class="headerlink" title="Hosting Options"></a>Hosting Options</h3><h3 id="Adding-Project-to-Git"><a href="#Adding-Project-to-Git" class="headerlink" title="Adding Project to Git"></a>Adding Project to Git</h3><h3 id="Getting-Started-with-Heroku"><a href="#Getting-Started-with-Heroku" class="headerlink" title="Getting Started with Heroku"></a>Getting Started with Heroku</h3><h3 id="Creating-a-Heroku-App"><a href="#Creating-a-Heroku-App" class="headerlink" title="Creating a Heroku App"></a>Creating a Heroku App</h3><h3 id="Setting-Environment-Variables"><a href="#Setting-Environment-Variables" class="headerlink" title="Setting Environment Variables"></a>Setting Environment Variables</h3><h3 id="Creating-a-Procfile"><a href="#Creating-a-Procfile" class="headerlink" title="Creating a Procfile"></a>Creating a Procfile</h3><h3 id="Provisioning-a-MySQL-Database"><a href="#Provisioning-a-MySQL-Database" class="headerlink" title="Provisioning a MySQL Database"></a>Provisioning a MySQL Database</h3><h3 id="Provisioning-a-Redis-Instance"><a href="#Provisioning-a-Redis-Instance" class="headerlink" title="Provisioning a Redis Instance"></a>Provisioning a Redis Instance</h3><h3 id="Provisioning-an-SMTP-Server"><a href="#Provisioning-an-SMTP-Server" class="headerlink" title="Provisioning an SMTP Server"></a>Provisioning an SMTP Server</h3><h3 id="Deploying-the-Application"><a href="#Deploying-the-Application" class="headerlink" title="Deploying the Application"></a>Deploying the Application</h3><h3 id="Populating-the-Database"><a href="#Populating-the-Database" class="headerlink" title="Populating the Database"></a>Populating the Database</h3><h3 id="Dockerizing-the-App"><a href="#Dockerizing-the-App" class="headerlink" title="Dockerizing the App"></a>Dockerizing the App</h3><h3 id="Course-Wrap-Up"><a href="#Course-Wrap-Up" class="headerlink" title="Course Wrap Up"></a>Course Wrap Up</h3>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/01/05/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch1-%E7%AE%97%E6%B3%95%E8%AF%84%E4%BB%B7%E6%A0%87%E5%87%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/01/05/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch1-%E7%AE%97%E6%B3%95%E8%AF%84%E4%BB%B7%E6%A0%87%E5%87%86/" itemprop="url">数据科学算法ch1-算法评价标准</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-01-05T21:19:34+08:00">
                2022-01-05
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-01-05T21:58:32+08:00">
                2022-01-05
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据科学算法ch1-算法评价标准"><a href="#数据科学算法ch1-算法评价标准" class="headerlink" title="数据科学算法ch1-算法评价标准"></a>数据科学算法ch1-算法评价标准</h1><h3 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h3><p>以二分类为例，真实的样本标签有两类，分类器预测的标签也有两类，真是标签和预测标签的不同组合构成了一个<strong>混淆矩阵</strong>。其中：</p>
<ol>
<li>真阳性(true positive, TP): 正例样本被分类器预测为正例</li>
<li>假阳性(false positive, FP): 负例样本被分类器预测为正例</li>
<li>真阴性(true negative, TN): 负例样本被分类器预测为负例</li>
<li>假阴性(false negative,FN): 正例样本被分类器预测为负例</li>
</ol>
<p><img src="/2022/01/05/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch1-%E7%AE%97%E6%B3%95%E8%AF%84%E4%BB%B7%E6%A0%87%E5%87%86/1.jpeg"></p>
<ul>
<li>召回率：真阳性率(TPR), 反映模型的查全率，定义为：</li>
</ul>
<script type="math/tex; mode=display">
\text{Recall} = \frac{TP}{TP+FN}</script><p>可以这么理解，召回率是通过这个模型，有多少正例成功地被预测为正例，因为有一部分被预测称了负例。主要聚焦在正例样本上</p>
<ul>
<li>准确率：反映模型的查准率，定义为：</li>
</ul>
<script type="math/tex; mode=display">
\text{Precision } = \frac{TP}{TP+FP}</script><p>准确率用来衡量模型的精度，因为模型可能会把一些负例预测为正例，导致精度缺失</p>
<ul>
<li><strong>$F_\beta$</strong> 值：召回率或者准确率知识衡量了分类器某一方面的性能，综合召回率和准确率而定义 $F_\beta$ 值为：</li>
</ul>
<script type="math/tex; mode=display">
F_\beta = \frac{(\beta^2+1)PR}{\beta^2 P+R}</script><p>其中，$P$ 为准确率、 $R$为召回率。因此 $F_\beta$ 值是召回率把和准确率的加权调和平均数，通常取 $\beta$ 的值为1</p>
<script type="math/tex; mode=display">
F_1 = \frac{2PR}{P+R}</script><ul>
<li>ROC曲线下方的面积(AUC)：ROC所在的坐标系，其横坐标为假阳性率(FPR), 纵坐标是真阳性率(召回率) </li>
</ul>
<script type="math/tex; mode=display">
\text{假阳性率}~~FPR = \frac{FP}{FP+TN}\\</script><p>AUC值越大，代表ROC越靠近左上角，在相同假阳性率情形下，分类器可能具有更大的召回率，分类器表现更好。</p>
<p><img src="/2022/01/05/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95ch1-%E7%AE%97%E6%B3%95%E8%AF%84%E4%BB%B7%E6%A0%87%E5%87%86/2.png"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/01/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/01/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/" itemprop="url">机器学习-隐马尔可夫模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-01-04T19:49:15+08:00">
                2022-01-04
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-03-03T10:19:42+08:00">
                2022-03-03
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="隐马尔可夫模型"><a href="#隐马尔可夫模型" class="headerlink" title="隐马尔可夫模型"></a>隐马尔可夫模型</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>首先，我们要了解，什么是隐马尔科夫模型？</p>
<p>隐马尔科夫模型，是关于时序的概率模型</p>
<p>它描述一个<strong>隐藏</strong>的马尔科夫链随机生成<strong>不可观测的状态随机序列(state sequence)</strong>，再由各个状态随机生成一个观测而产生<strong>观测随机序列</strong>的过程，序列的每一个位置又可以看做是一个<strong>时刻</strong></p>
<h3 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h3><p>隐马尔科夫模型由<strong>初始概率分布</strong>，<strong>状态转移概率分布</strong>，以及<strong>观测概率分布</strong>确定，隐马尔科夫模型的形式定义如下：</p>
<ul>
<li><p>$Q$ 所有可能的状态的集合 ，记为 $Q = {q_1,    q_2\cdots,q_N}$， $N$ 是可能的状态数</p>
</li>
<li><p>$V$ 所有可能观测的集合，记为 $V= {v_1,v_2\cdots,v_m}$ ,  $M$ 是可能的观测数</p>
</li>
<li><p>$I$ 长度为$T$ 的状态序列 ，记为 $I = (i_1,i_2\cdots,i_T)$</p>
</li>
<li><p>$O$ 对应的观测序列，记为 $O= (o_1,o_2,\cdots,o_T)$</p>
</li>
<li><p>$A$ 是状态转移概率矩阵，记为 $A = [a<em>{ij}]</em>{N\times N}$</p>
<p>其中， $a<em>{ij} = P(i</em>{i+1}=q_j|i_i=q_i),i=1,2\cdots,N;j=1,2\cdots,N$ 。这代表着，在时刻t，处于状态$q_i$  的条件下，在时刻 $t+1$ 转移到状态 $q_j$ 的概率</p>
</li>
<li><p>$B$ 是观测概率矩阵，记为 $B = [b<em>j(k)]</em>{N\times M}$ </p>
<p>其中，$b_{j}(k) = P(o_t=v_k|i_t=q_j),k=1,2\cdots M;j=1,2\cdots,N$</p>
<p>这代表着，在时刻 t， 处于状态$q_j$ 的条件下，生成观测 $v_k$ 的概率</p>
</li>
<li><p>$\pi$ 是初始状态概率向量，记为 $\pi = (\pi_i)$ </p>
<p>其中，$\pi_i = P(i_i=q_i),i=1,2\cdots,N$ ,这代表着，时刻$t=1$ 时，处于状态$q_i$ 的概率</p>
<p>它们的关系是：</p>
</li>
</ul>
<p>$\pi,A$ 确定了隐藏的马尔科夫链，生成不可观测的状态序列，$B$确定了如何从状态生成观测，与状态序列总和确定了如何产生观测序列。因此，隐马尔科夫模型$\lambda$可以由三元符号来表示：$\lambda = (A,B,\pi)$</p>
<p>$A,B,\pi$ 也被称为是马尔科夫模型三要素。</p>
<h3 id="两个基本假设"><a href="#两个基本假设" class="headerlink" title="两个基本假设"></a>两个基本假设</h3><p>从定义可知，隐马尔科夫模型做出了两个基本假设</p>
<ol>
<li><p>齐次马尔科夫性假设。即设 隐藏的马尔科夫链<strong>在任意时刻 t  的状态只依赖于前一时刻的状态</strong>，与其他时刻的状态及观测无关，也与时刻t 是无关的。(可以理解为无记忆性)</p>
<script type="math/tex; mode=display">
P(i_i|i_{i-1},o_{t-1},\cdots,i_1,o_1) = P(i_i|i_{i-1}) ,t=1,2\cdots,T</script></li>
<li><p>观测独立性假设。即假设<strong>任意时刻的观测</strong>只依赖于<strong>该时刻的马尔科夫链的状态</strong>，与其他观测及状态无关</p>
<script type="math/tex; mode=display">
P(o_t|i_T,o_T,\cdots,i_1,o_1) = P(o_i|i_i)</script></li>
</ol>
<p>隐马尔科夫模型可以用于标注，这时状态对应着标记。标注问题是给定观测序列预测期对应的标记序列. 我们可以假设，标注问题的数据是由隐马尔科夫模型生成的，这样，我们可以利用隐马尔科夫的学习与预测算法进行标注</p>
<h4 id="盒球模型"><a href="#盒球模型" class="headerlink" title="盒球模型"></a>盒球模型</h4><p>假设有四个盒子，每个盒子都有红白两种颜色共10颗球，如下</p>
<p><img src="/2022/01/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/1.png" style="zoom:100%;"></p>
<p>转移的规则是：</p>
<ul>
<li>盒子1 那么下一个一定是盒子2</li>
<li>盒子2或者盒子3，那么下一个0.4 是左边那个盒子，0.6是右边那个盒子</li>
<li>盒子4 下一个0.5是自己，0.5是盒子3</li>
</ul>
<p>我们可以通过观测每次去除球的颜色来得到观测序列，但是观测不到球是从哪个盒子取出来的，也就是说，我们观测不到盒子的序列。</p>
<p>在这个例子中，盒子的序列就是<strong>状态序列 I</strong>，球颜色的观测序列就是<strong>观测序列O</strong> </p>
<p>已知： </p>
<ul>
<li><p>状态集合 $Q =$ {盒子1，盒子2，盒子3，盒子4}，$N=4$ </p>
</li>
<li><p>观测集合 $V  =$ {红，白} $M=2$</p>
</li>
<li><p>观测序列和状态序列的长度 $T=5$</p>
</li>
<li><p>现在抽取五次，得到观测序列$O = ${红，红，白，白，红}</p>
</li>
<li><p>我们的初始概率分布为： $\pi = (0.25,0.25,0.25,0.25)$ 也就是抽到每个盒子的概率都是相同的</p>
</li>
<li><p>状态概率转移矩阵 $A$: </p>
<script type="math/tex; mode=display">
A = \begin{bmatrix}0&1&0&0\\0.4&0&0.6&0\\0&0.4&0&0.6\\0&0&0.5&0.5\end{bmatrix}</script><p>我们看到，这个矩阵记录的，就是上面说的三条转移规则</p>
</li>
<li><p>观测概率举证$B$:</p>
<script type="math/tex; mode=display">
A = \begin{bmatrix}0.5&0.5\\0.3&0.7\\0.6&0.4\\0.8&0.2\end{bmatrix}</script><p>我们看到，这个矩阵记录的，就是每个状态下，观测到红球或者是白球的概率</p>
</li>
</ul>
<h4 id="观测序列如何生成"><a href="#观测序列如何生成" class="headerlink" title="观测序列如何生成"></a>观测序列如何生成</h4><p>从盒球模型中，观测序列时直接给我们的，那么，它是怎么生成的呢？</p>
<p>通过 给定隐马尔科夫模型三要素 $\lambda = {A,B,\pi}$，以及观测序列长度 T(理解为要观测几次)，我们输出观测序列$O$</p>
<ol>
<li>安装初始状态分布$\pi$ 来产生 状态i</li>
<li>令$t = 1$</li>
<li>按照状态 $i<em>t$ 的观测概率分布 $b</em>{i_t}(k)$ 来生成$o_t$</li>
<li>按照状态 $i<em>t$ 的状态转移概率分布 ${a</em>{i<em>ti</em>{t+1}}}$ 来产生状态 $i_{t+1}$ </li>
<li>令 $t=t+1$ ,若 $t&lt;T$ ，跳转至(3), 否则终止</li>
</ol>
<h3 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h3><ul>
<li><p>概率计算问题。给定模型 $\lambda = (A,B,\pi)$ 和观测序列 $O=(o_1,\cdots,o_T)$ ,计算在模型$\lambda$ 下，观测序列$O$ 出现的概率$P(O|\lambda)$</p>
</li>
<li><p>学习问题。已知观测序列$O=(o_1,\cdots,o_T)$, 估计模型 $\lambda = (A,B,\pi)$ 参数，使得在该模型下观测序列概率$P(O|\lambda)$ 最大. 即用极大似然估计的方法估计参数</p>
</li>
<li>预测问题．已知模型$\lambda = (A,B,\pi)$ 和观测序列$O=(o_1,o_2,\cdots,o_T)$，求对给定观测序列条件概率$P(I|O)$ 最大的状态序列$I=(i_1,\cdots,i_T)$。 维特比算法应用动态规划高效地求解最优路径，即概率最大的状态序列</li>
</ul>
<h2 id="概率计算算法"><a href="#概率计算算法" class="headerlink" title="概率计算算法"></a>概率计算算法</h2><p>概率计算问题。给定模型 $\lambda = (A,B,\pi)$ 和观测序列 $O=(o_1,\cdots,o_T)$ ,计算在模型$\lambda$ 下，观测序列$O$ 出现的概率$P(O|\lambda)$</p>
<h3 id="前向算法"><a href="#前向算法" class="headerlink" title="前向算法"></a>前向算法</h3><p>首先，我们给出前向概率的定义：</p>
<p>给定隐马尔科夫模型$\lambda$ , 定义到时刻 t 部分观测序列为 $o_1,\cdots,o_t$ 且状态为$q_i$ 的概率为<strong>前向概率 $\alpha_t(i)$</strong>。记作：</p>
<script type="math/tex; mode=display">
\alpha_t(i) = P(o_1,\cdots,o_t,i_t = q_i|\lambda)</script><p>由此，我们可以递推地求得前向概率$\alpha_t(i)$ 以及观测序列概率$P(O|\lambda)$ </p>
<h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><p>输入：隐马尔科夫模型 $\lambda$, 观测序列 $O$:</p>
<p>输出 ：观测序列概率 $P(O|\lambda)$</p>
<ol>
<li>初值</li>
</ol>
<script type="math/tex; mode=display">
\alpha_1(i) = \pi_ib_i(o_1),i=1,2\cdots,N</script><p>这个步骤是初始化前向概率，是初始时刻的状态$i_t = q_i$ 和观测 $o_1$ 的联合概率</p>
<ol>
<li>递推，对于$t=1,2\cdots,T-1$</li>
</ol>
<script type="math/tex; mode=display">
\alpha_{t+1}(i)=\bigg[\sum_{j=1}^N\alpha_t(j)a_{ji}\bigg]b_i(o_{t+1}),i=1,2\cdots,N</script><ol>
<li>终止</li>
</ol>
<script type="math/tex; mode=display">
P(O|\lambda) = \sum_{i=1}^N \alpha_T(i)</script><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><img src="/2022/01/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/2.png" style="zoom:100%;"></p>
<ul>
<li>步骤1，计算初值</li>
</ul>
<script type="math/tex; mode=display">
\alpha_1(1) = \pi_1\cdot b_1(o_1) = 0.10\\
\alpha_1(2) = \pi_2\cdot b_2(o_1) = 0.16\\
\alpha_1(3) = \pi_3\cdot b_3(o_1) = 0.28</script><ul>
<li>步骤2，递推</li>
</ul>
<p>我们要递推得到$\alpha_2$ 这一层的N个值(N=3)</p>
<script type="math/tex; mode=display">
\begin{align}
\alpha_2(1) = \bigg[\sum_{j=1}^3\alpha_1(j)\cdot a_{j1} \bigg]b_1(o_2)=[\alpha_1(1)\cdot a_{11}+\alpha_1(2)\cdot a_{21}+\alpha_1(3)\cdot a_{31}]\cdot b_1(o_2) = 0.154\times 0.5 = 0.077\\
\alpha_2(2) = \bigg[\sum_{j=1}^3\alpha_1(j)\cdot a_{j2} \bigg]b_2(o_2)=[\alpha_1(1)\cdot a_{12}+\alpha_1(2)\cdot a_{22}+\alpha_1(3)\cdot a_{32}]\cdot b_2(o_2) = 0.184\times 0.6 = 0.1104\\
\alpha_2(3) = \bigg[\sum_{j=1}^3\alpha_1(j)\cdot a_{j3} \bigg]b_3(o_2)=[\alpha_1(1)\cdot a_{13}+\alpha_1(2)\cdot a_{23}+\alpha_1(3)\cdot a_{33}]\cdot b_3(o_2) = 0.202\times 0.3 = 0.0606\\
\end{align}</script><p>因为 $T=3$,所以我们还要再推一层 $\alpha_3(i)$</p>
<script type="math/tex; mode=display">
\begin{align}
\alpha_3(1) = \bigg[\sum_{j=1}^3\alpha_2(j)\cdot a_{j1} \bigg]b_1(o_3)=[\alpha_3(1)\cdot a_{11}+\alpha_2(2)\cdot a_{21}+\alpha_2(3)\cdot a_{31}]\cdot b_1(o_3) = 0.154\times 0.5 = 0.04187\\
\alpha_3(2) = \bigg[\sum_{j=1}^3\alpha_2(j)\cdot a_{j2} \bigg]b_2(o_3)=[\alpha_3(1)\cdot a_{12}+\alpha_2(2)\cdot a_{22}+\alpha_2(3)\cdot a_{32}]\cdot b_2(o_3) = 0.184\times 0.6 = 0.03551\\
\alpha_3(3) = \bigg[\sum_{j=1}^3\alpha_2(j)\cdot a_{j3} \bigg]b_3(o_3)=[\alpha_3(1)\cdot a_{13}+\alpha_2(2)\cdot a_{23}+\alpha_2(3)\cdot a_{33}]\cdot b_3(o_3) = 0.202\times 0.3 = 0.05284\\
\end{align}</script><ul>
<li>步骤3，终止</li>
</ul>
<script type="math/tex; mode=display">
P(O|\lambda) = \sum_{i=1}^N\alpha_T(i) = 0.04187+0.03551+0.05284</script><h3 id="后向算法"><a href="#后向算法" class="headerlink" title="后向算法"></a>后向算法</h3><p>首先我们来定义后向概率：</p>
<p>给定隐马尔科夫模型$\lambda$ ,  定义在时刻t，状态为$q<em>i$ 的条件下，从$t+1$到$T$ 的部分观测序列为 $o</em>{t+1},\cdots,o_T$ 的概率为<strong>后向概率</strong>，记作</p>
<script type="math/tex; mode=display">
\beta_t(i) = P(o_{t+1},\cdots,o_{T}|i_t = q_i,\lambda)</script><p>由此，我们可以递推地求得后向概率$\beta_t(i)$ 以及观测序列概率$P(O|\lambda)$ </p>
<h4 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol>
<li>初值</li>
</ol>
<script type="math/tex; mode=display">
\beta_T(i) = 1,i=1,\cdots,N</script><ol>
<li>递推</li>
</ol>
<p>对于 $t=T-1,T-2,\cdots,1$， 有：</p>
<script type="math/tex; mode=display">
\beta_t(i) = \sum_{j=1}^Na_{ij}\cdot b_j(o_{t+1})\beta_{t+1}(j)&i=1,\cdots,N\\</script><ol>
<li><script type="math/tex; mode=display">
P(O|\lambda) = \sum_{i=1}^N\pi_ib_i(o_1)\beta_1(i)</script></li>
</ol>
<h3 id="一些概率与期望值的计算"><a href="#一些概率与期望值的计算" class="headerlink" title="一些概率与期望值的计算"></a>一些概率与期望值的计算</h3><p>利用前向和后向概率，我们可以得到关于单个状态和两个状态概率的计算公式</p>
<h4 id="单个状态"><a href="#单个状态" class="headerlink" title="单个状态"></a>单个状态</h4><p>给定模型$\lambda$和观测$O$, 我们可以通过前向后向概率计算求得 在时刻t 处于状态 $q_i$ 的概率：</p>
<script type="math/tex; mode=display">
\gamma_t(i) = P(i_t=q_i |O,\lambda)</script><p>由前向概率 $\alpha_t(i)$和 后向概率 $\beta_t(i)$ 的定义可知：</p>
<script type="math/tex; mode=display">
\alpha_t(i)\beta_t(i) = P(i_t=q_i,O|\lambda)</script><p>于是，我们得到</p>
<script type="math/tex; mode=display">
\gamma_t(i) = \frac{\alpha_t(i)\beta_t(i)}{P(O|\lambda)} = \frac{\alpha_t(i)\beta_t(i)}{\sum_{j=1}^N\alpha_t(j)\beta_t(j)}</script><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p><img src="/2022/01/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/3.jpg" style="zoom:100%;"></p>
<p>这就是上面所说的，求单个状态的概率值</p>
<ul>
<li>第一步，列出 $P(i_4 = q_3 |O,\lambda)$ 的式子：</li>
</ul>
<script type="math/tex; mode=display">
P(i_4=q_3|O,\lambda) = \frac{\alpha_4(3)\cdot\beta_4(3)}{\sum_{i=1}^N\alpha_4(i)\beta_4(i)} = \frac{\alpha_4(3)\cdot\beta_4(3)}{\alpha_4(1)\beta_4(1)+\alpha_4(2)\beta_4(2)+\alpha_4(3)\beta_4(3)}</script><ul>
<li>第二步，我们要求那些？</li>
</ul>
<p>首先，我们前向概率要从 $\alpha_1(i)$ 求到 $\alpha_4(i)$ 递推4次 ； 后向概率要从 $\beta_8(i)$求到 $\beta_4(i)$ ,递推5次</p>
<ul>
<li><p>第三步，前向计算</p>
<ul>
<li><p>初值: $\alpha_1(i) = \pi_ib_i(o_1)$</p>
<script type="math/tex; mode=display">
\alpha_1(1) = \pi_1\cdot b_1(o_1)=0.2\cdot0.5 = 0.10\\
\alpha_1(2) = \pi_2\cdot b_2(o_1)=0.3\cdot 0.4 = 0.12\\
\alpha_1(3) = \pi_3\cdot b_3(o_1)=0.5\cdot 0.7 = 0.35</script></li>
<li><p>递推: $\alpha<em>{t+1}(i) = \bigg[\sum</em>{j =1}^N a<em>{ji}\cdot \alpha_t(i)\bigg]\cdot b_i(o</em>{t+1})$</p>
<script type="math/tex; mode=display">
\begin{align}
&\alpha_2(1) = [\sum_{j=1}^3 a_{j1}\cdot\alpha_1(1)]\cdot b_1(o_{2}) = 0.078\\
&\alpha_2(2) = [\sum_{j=1}^3 a_{j2}\cdot\alpha_1(2)]\cdot b_2(o_{2})=0.084\\
&\alpha_2(3) = [\sum_{j=1}^3 a_{j3}\cdot\alpha_1(3)]\cdot b_3(o_{2})=0.0822\\

&\alpha_3(1) = [\sum_{j=1}^3 a_{j1}\cdot\alpha_2(1)]\cdot b_1(o_{3})=0.04032\\
&\alpha_3(2) = [\sum_{j=1}^3 a_{j2}\cdot\alpha_2(2)]\cdot b_2(o_{3})=0.026496\\
&\alpha_3(3) = [\sum_{j=1}^3 a_{j3}\cdot\alpha_2(3)]\cdot b_3(o_{3})=0.068124\\

&\alpha_4(1) = [\sum_{j=1}^3 a_{j1}\cdot\alpha_3(1)]\cdot b_1(o_{4})=0.00208668\\
&\alpha_4(2) = [\sum_{j=1}^3 a_{j2}\cdot\alpha_3(2)]\cdot b_2(o_{4})=0.01236192\\
&\alpha_4(3) = [\sum_{j=1}^3 a_{j3}\cdot\alpha_3(3)]\cdot b_3(o_{5})=0.004361112\\
\end{align}</script></li>
</ul>
</li>
<li><p>第四步，后向计算</p>
<ul>
<li><p>初值： $\beta_8(1)=\beta_8(2)=\beta_8(3) = 1$</p>
</li>
<li><p>递推 ： $\beta<em>t(i) = \sum</em>{j=1}^N a<em>{ij}\cdot b_j(o</em>{t+1})\cdot\beta_{t+1}(j) $</p>
<script type="math/tex; mode=display">
\begin{align}
&\beta_7(1) = \sum_{j=1}^3 a_{1j}\cdot b_j(o_8)\cdot\beta_8(j)=0.43\\
&\beta_7(2) = \sum_{j=1}^3 a_{2j}\cdot b_j(o_8)\cdot\beta_8(j)=0.51\\
&\beta_7(3) = \sum_{j=1}^3 a_{3j}\cdot b_j(o_8)\cdot\beta_8(j)=0.4\\
&\beta_6(1) = \sum_{j=1}^3 a_{1j}\cdot b_j(o_7)\cdot\beta_7(j)=0.1861\\
&\beta_6(2) = \sum_{j=1}^3 a_{2j}\cdot b_j(o_7)\cdot\beta_7(j)=0.2415\\
&\beta_6(3) = \sum_{j=1}^3 a_{3j}\cdot b_j(o_7)\cdot\beta_7(j)=0.1762\\
&\beta_5(1) = \sum_{j=1}^3 a_{1j}\cdot b_j(o_6)\cdot\beta_6(j)=0.105521\\
&\beta_5(2) = \sum_{j=1}^3 a_{2j}\cdot b_j(o_6)\cdot\beta_6(j)=0.100883\\
&\beta_5(3) = \sum_{j=1}^3 a_{3j}\cdot b_j(o_6)\cdot\beta_6(j)=0.111934\\
&\beta_4(1) = \sum_{j=1}^3 a_{1j}\cdot b_j(o_5)\cdot\beta_5(j)=0.04586531\\
&\beta_4(2) = \sum_{j=1}^3 a_{2j}\cdot b_j(o_5)\cdot\beta_5(j)=0.05280909\\
&\beta_4(3) = \sum_{j=1}^3 a_{3j}\cdot b_j(o_5)\cdot\beta_5(j)=0.4280618\\
\end{align}</script></li>
</ul>
<p><img src="/2022/01/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/3.png" style="zoom:100%;"></p>
<h2 id="预测算法"><a href="#预测算法" class="headerlink" title="预测算法"></a>预测算法</h2></li>
</ul>
<p>预测问题．已知模型$\lambda = (A,B,\pi)$ 和观测序列$O=(o_1,o_2,\cdots,o_T)$，求对给定观测序列条件概率$P(I|O)$ 最大的状态序列$I=(i_1,\cdots,i_T)$。 维特比算法应用动态规划高效地求解最优路径，即概率最大的状态序列</p>
<h3 id="维特比算法"><a href="#维特比算法" class="headerlink" title="维特比算法"></a>维特比算法</h3><p>维特比算法，是用动态规划来解决隐马尔科夫模型预测问题，即用动态规划求<strong>概率最大路径</strong>(最优路径)，这时一条路劲对应着一个状态序列。</p>
<p>根据动态规划原理，最优路径具有这样的特性：如果最优路径在时刻 $t$ 通过结点 $i_t^<em>$，那么这一路径从结点$i_t^</em>$ 到终点$i_T^<em>$ 的部分路径，对于从结点$i_t^</em>$ 到终点$i_T^*$ 的所有可能的部分路径来说，必须是最优的。</p>
<p>根据这一原理，我们只需要</p>
<ul>
<li>从时刻 $t=1$ 开始，递推地计算<strong>在时刻t</strong>、<strong>状态为i</strong>的各条部分路径的最大概率，直至得到时刻$t=T$ 、状态为i 的各条路径的最大概率。</li>
<li>时刻 $t=T$ 的最大概率即为最优路径的概率 $P^<em>$ ,最优路径的终结点 $i^</em>_T$ 也会同时得到。</li>
<li>之后，为了找到最优路径的各个结点，从终结点 $i^<em><em>T$ 开始，右后向前逐步求得点 $i</em>{T-1}^</em>,\cdots,i<em>{1}^<em>$ ， 得到最优路径 $I^</em> = (i_1^*,\cdots,i</em>{T}^*)$ </li>
</ul>
<p>输入：模型 $\lambda = (A,B,\pi)$ 和观测 $O=(o_1,o_2\cdots,o_T)$</p>
<p>输出：最优路径 $I^<em> = (i_1^</em> ,i^<em>_2\cdots,i_T^</em>)$</p>
<ol>
<li>初始化</li>
</ol>
<script type="math/tex; mode=display">
\begin{align}
&\delta_1(i) = \pi_ib_i(O_1)&i=1,\cdots,N\\
&\varPsi_1(i) = 0&i=1,\cdots,N\\
\end{align}</script><ol>
<li>递推</li>
</ol>
<script type="math/tex; mode=display">
\begin{align}
&\delta_t(i) = \max_{1\leq j\leq N}[\delta_{t-1}(j)a_{ji}]b_i(o_t)\\
&\varPsi_t(i) = \arg\max_{i\leq j\leq N}[\delta_{t-1}(j)a_{ji}]
\end{align}</script><ol>
<li>终止</li>
</ol>
<script type="math/tex; mode=display">
\begin{align}
&P^* = \max_{1\leq i\leq N}\delta_T(i)\\
&i_T^* = \arg\max_{1\leq i\leq N} [\delta_T(i)]
\end{align}</script><ol>
<li>最优路径回溯：对于 $t=T-1,T-2,\cdots ,1$ <script type="math/tex; mode=display">
i_t^* = \varPsi_{t+1}(i^*_{t+1})</script>求得最优路径 $I^<em> = (i_1^</em>,i_2^<em>,\cdots,i_T^</em>)$</li>
</ol>
<h4 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h4><p><img src="/2022/01/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/4.jpg" style="zoom:100%;"></p>
<ol>
<li>初始化 , 在 $t = 1$ 时，对每一个状态$i\in{1,2,3}$   ，求 <strong>状态为 i </strong>, <strong>观测</strong>$o_1$<strong>为红 </strong>的概率，记此概率为 $\delta_1(i)$.则</li>
</ol>
<script type="math/tex; mode=display">
\delta_1(i) = \pi_ib_i(o_1) =\pi_ib_i(o_1) ,~~~~ i=1,2,3</script><p>代入实际数据</p>
<script type="math/tex; mode=display">
\delta_1(1) = \pi_1b_1(o_1) = 0.2\times0.5 = 0.1\\
\delta_1(2) = \pi_2b_2(o_1) = 0.4\times0.4 = 0.16\\
\delta_1(3) = \pi_2b_2(o_1) = 0.4\times0.7 = 0.28\\
\varPhi_1(i) = 0,i=1,2,3</script><ol>
<li><p>递推</p>
<ul>
<li><p>在t = 2时</p>
<ul>
<li>对于每个状态$i\in{1,2,3}$,  记最大概率为  $\delta<em>2(i) = \max</em>{1\leq j\leq 3}[\delta<em>1(j)a</em>{ji}]b_i(o_2) $</li>
</ul>
<script type="math/tex; mode=display">
\delta_2(1) = \max\{0.1\times 0.5, 0.16\times0.3,0.28\times 0.2\} \times 0.5 = 0.028\\
\delta_2(2) = \max\{0.1\times 0.2, 0.16\times0.5,0.28\times 0.3\} \times 0.6 = 0.0504\\
\delta_2(3) = \max\{0.1\times 0.3, 0.16\times0.2,0.28\times 0.5\} \times 0.3  = 0.042</script><ul>
<li><p>同时，对于每个状态 $i\in {1,2,3}$ ，我们记录它的<strong>最大概率的前一个状态</strong> $j$. $\varPsi<em>2(i) = \arg\max</em>{1\leq j\leq 3}[\delta<em>1(j)a</em>{ji}]~~~i=1,2,3$</p>
<script type="math/tex; mode=display">
\varPsi_2(1) =\arg\max\{0.1\times0.5,0.16\times 0.3,0.28\times 0.2\} =3\\
\varPsi_2(2) =\arg\max\{0.1\times0.2,0.16\times 0.5,0.28\times 0.3\} = 3\\
\varPsi_2(3) =\arg\max\{0.1\times0.3,0.16\times 0.2,0.28\times 0.5\} = 3</script></li>
<li><p>在t = 3时</p>
<ul>
<li><p>$\delta<em>3(i) = \max</em>{1\leq j\leq3}[\delta<em>2(j)a</em>{ji}]\cdot b_i(o_3)$</p>
<script type="math/tex; mode=display">
\delta_3(1) = \max\{0.028\times 0.5, 0.0504\times0.3,0.042\times 0.2\} \times 0.5 = 0.00756\\
\delta_3(2) = \max\{0.028\times 0.2, 0.0504\times0.5,0.042\times 0.3\} \times 0.6 = 0.01008\\
\delta_3(3) = \max\{0.028\times 0.3, 0.0504\times0.2,0.042\times 0.5\} \times 0.3  = 0.0147</script></li>
<li><p>$\varPsi<em>3(i) = \arg\max</em>{1\leq j\leq 3}[\delta<em>2(j)a</em>{ji}]~~~i=1,2,3$</p>
<script type="math/tex; mode=display">
\varPsi_3(1) =\arg\max\{0.028\times 0.5, 0.0504\times0.3,0.042\times 0.2\}  =2\\
\varPsi_3(2) =\arg\max\{0.028\times 0.2, 0.0504\times0.5,0.042\times 0.3\}= 2\\
\varPsi_3(3) =\arg\max\{0.028\times 0.3, 0.0504\times0.2,0.042\times 0.5\} = 3</script></li>
</ul>
</li>
<li><p>在 t = 4 时</p>
<ul>
<li><p>$\delta<em>4(i) = \max</em>{1\leq j\leq3}[\delta<em>3(j)a</em>{ji}]\cdot b_i(o_4)$</p>
<script type="math/tex; mode=display">
\delta_4(1) = \max\{0.00756\times 0.5, 0.01008\times0.3,0.0147\times 0.2\} \times 0.5 = 0.00189\\
\delta_4(2) = \max\{0.00756\times 0.2,0.01008\times0.5,0.0147\times 0.3\} \times 0.6 = 0.003024\\
\delta_4(3) = \max\{0.00756\times 0.3, 0.01008\times0.2,0.0147\times 0.5\} \times 0.3  = 0.002205</script></li>
<li><p>$\varPsi<em>4(i) = \arg\max</em>{1\leq j\leq 3}[\delta<em>3(j)a</em>{ji}]~~~i=1,2,3$</p>
<script type="math/tex; mode=display">
\varPsi_4(1) =\arg\max\{0.00756\times 0.5, 0.01008\times0.3,0.0147\times 0.2\}  =1\\
\varPsi_4(2) =\arg\max\{0.00756\times 0.2,0.01008\times0.5,0.0147\times 0.3\}= 2\\
\varPsi_4(3) =\max\{0.00756\times 0.3, 0.01008\times0.2,0.0147\times 0.5\} = 3</script></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol>
<li>用 $P^*$ 来表示最优路径的概率，则：</li>
</ol>
<script type="math/tex; mode=display">
P^* = 3.025\times 10^{-3}</script><p>终点即 $i_4^*= \arg\max_i[\delta_4(i)] = 2$  </p>
<ol>
<li>由最优路径的终点 $i^<em>_4$ ,可以逆向找到 $i_3^</em>,i_2^<em>,i_1^</em>$</li>
</ol>
<script type="math/tex; mode=display">
\text{在t=3时},i^*_3 = \varPsi_4(i^*_4)=2\\
\text{在t=2时},i^*_2 =  \varPsi_3(i^*_3)=2\\
\text{在t=1时},i^*_1 =  \varPsi_2(i^*_2)=3\\</script><p>于是求得最优路径，即最优状态序列 $I^<em> = (i^</em>_1,i_2^<em>,i_3^</em>)= (3,2,2,2)$</p>
<p><img src="/2022/01/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/5.jpeg" style="zoom:100%;"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/01/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/01/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" itemprop="url">机器学习-支持向量机</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-01-03T15:06:24+08:00">
                2022-01-03
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-01-04T19:49:50+08:00">
                2022-01-04
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="机器学习-支持向量机"><a href="#机器学习-支持向量机" class="headerlink" title="机器学习-支持向量机"></a>机器学习-支持向量机</h1><p>学习支持向量机的时候，我们要一步一步来，从线性可分到线性不可分，一共有三种支持向量机。</p>
<ul>
<li><strong>线性可分支持向量机</strong>和<strong>线性支持向量机</strong>：输入空间和特征空间的元素一一对应，并将输入空间中的输入映射为特征空间中特特征向量</li>
<li>非线性支持向量机：利用一个从输入控件到特征空间的非线性映射将输入映射为特征向量</li>
</ul>
<p>支持向量机的学习是在<strong>特征空间</strong>进行的</p>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><h3 id="线性可分支持向量机"><a href="#线性可分支持向量机" class="headerlink" title="线性可分支持向量机"></a>线性可分支持向量机</h3><p>支持向量机最简单的情况是<strong>线性可分支持向量机</strong>，或<strong>硬间隔支持向量机</strong> , 构建它的条件是训练数据线性可分。其学习策略是<strong>最大间隔法</strong>， 可以表示为凸二次规划问题，其原始最优化问题为</p>
<script type="math/tex; mode=display">
\min_{w,b}& \frac{1}{2}||w||^2\\
s.t. & y_i(w\cdot x_i+b)-1 \geq 0,i=1,2\cdots,N</script><p>求得最优化问题的解为 $w^<em>,b^</em>$ ，得到线性可分支持向量机，分离超平面是：</p>
<script type="math/tex; mode=display">
w^*\cdot x+b^* = 0</script><p>分类决策函数是</p>
<script type="math/tex; mode=display">
f(x) = sign(w^*\cdot x+b^*)</script><h3 id="线性支持向量机-软间隔支持向量机"><a href="#线性支持向量机-软间隔支持向量机" class="headerlink" title="线性支持向量机(软间隔支持向量机 )"></a>线性支持向量机(软间隔支持向量机 )</h3><h2 id="线性可分支持向量机-1"><a href="#线性可分支持向量机-1" class="headerlink" title="线性可分支持向量机"></a>线性可分支持向量机</h2><p>现在摆在我们面前的仍然是一个二分类问题。</p>
<ul>
<li>训练数据集：</li>
</ul>
<p>假设特征空间上的数据集</p>
<script type="math/tex; mode=display">
T = \{(x_1,y_1),\cdots,(x_N,y_N) \}</script><p>输入为特征向量 $x\in\mathcal X\subseteq \boldsymbol R^n$ ，$y_i\in\mathcal Y = {+1,-1},i=1,2\cdots,N$， $x_i$ 为第i个特征向量，也称为实例。$y_i$ 为 $x_i$ 的类标记，当$y_i=+1$ 时，称x为正例；当 $ y =-1 $时，称$x_i$为负例$(x_i,y_i)$称为样本点。 再假设训练数据集是线性可分的</p>
<ul>
<li><p>学习目标: 找到分离超平面 $w\cdot x+b=0$  。分离超平面将特征空间划分为两部分， 一部分是正类，一部分是负类。法向量指向的一侧为正类，另一侧为负类</p>
</li>
<li><p>学习策略：间隔最大化。</p>
</li>
</ul>
<p>如下图，感知机可能会得到多个不同(w,b)的超平面，但是svm最终只会选择间隔最大的超平面</p>
<p><img src="/2022/01/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/1.png" style="zoom:67%;"></p>
<blockquote>
<p>注意：</p>
<p>感知机利用误分类最小的策略，求得分离超平面。但是这个解是由无穷多个的，只要分对了就好</p>
<p>但是线性可分支持向量机利用<strong>间隔最大化</strong>来求最优分离超平面，这时候解就变成唯一的了</p>
</blockquote>
<ul>
<li>决策函数：<script type="math/tex; mode=display">
f(x) = sign(w^*\cdot x+b^*)</script></li>
</ul>
<h3 id="间隔"><a href="#间隔" class="headerlink" title="间隔"></a>间隔</h3><p>既然支持向量机要求间隔最大化，那么，间隔如何定义呢？</p>
<h4 id="函数间隔"><a href="#函数间隔" class="headerlink" title="函数间隔"></a>函数间隔</h4><p>首先，我们要定义函数间隔.</p>
<p>对于给定的训练数据集T和超平面$(w,b)$，定义超平面关于<strong>样本点</strong> $(x_i,y_i)$ 的函数间隔为：</p>
<script type="math/tex; mode=display">
\hat{\mathcal Y_{i} }= y_i(w\cdot x_i+b)</script><p>然后，我们定义超平面(w,b)关于<strong>训练数据集</strong>T的函数间隔为 : 超平面$(w,b)$ 关于T中所有样本点$(x_i,y_i)$  的函数间隔中的最小值。也就是</p>
<script type="math/tex; mode=display">
\hat { \mathcal {Y }} = \min_{i=1\cdots N} \hat{\mathcal Y_i}</script><p>这相当于”感性“认识间隔，因为当成比例得改变w和b的话，超平面并没有改变，但是函数间隔却变成了原来的两倍。因此我们还需要给出几何间隔的定义</p>
<h4 id="集合间隔"><a href="#集合间隔" class="headerlink" title="集合间隔"></a>集合间隔</h4><p>对于给定的训练数据集 T 和超平面$(w,b)$ ,定义超平面 $(w,b)$ 关于样本点$(x_i,y_i)$的几何间隔为：</p>
<script type="math/tex; mode=display">
\hat{\mathcal Y_{i} }= y_i(\frac{w}{||w||}\cdot x_i+\frac{b}{||w||})</script><p>然后，我们定义超平面(w,b)关于<strong>训练数据集</strong>T的几何间隔为 : 超平面$(w,b)$ 关于T中所有样本点$(x_i,y_i)$  的几何间隔中的最小值。也就是</p>
<script type="math/tex; mode=display">
\hat { \mathcal {Y }} = \min_{i=1\cdots N} \hat{\mathcal Y_i}</script><p>函数间隔和几何间隔有如下关系：</p>
<script type="math/tex; mode=display">
{\mathcal Y_i}=\frac{\hat{\mathcal Y_i}}{||w||}\\
\mathcal Y = \frac{\hat{\mathcal Y}}{||w||}\\</script><p>如果 $||w||=1$ ,那么函数间隔和几何间隔相等。</p>
<h3 id="间隔最大化"><a href="#间隔最大化" class="headerlink" title="间隔最大化"></a>间隔最大化</h3><p>学完了间隔，我们就要学习，怎么让间隔最大化(在线性可分中又叫硬间隔最大化) </p>
<p>一个感性又直观的解释是：对训练数据集找到几何间隔最大的超平面，意味着以<strong>充分大的确信度</strong>对训练数据进行分类。也就是说，我们不仅要将正负实例点分开，而且对最难分的实例点(距离超平面最近的点)也有足够大的确信度将它们分开。这样的超平面应该对未知的新实例有很好的分类预测能力。</p>
<p>因此我们可以这样来写一个<strong>约束最优化</strong>问题：</p>
<script type="math/tex; mode=display">
\max_{w,b} & \mathcal Y\\
s.t.& y_i(\frac{w}{||w||}x_i+\frac{b}{||w||})\geq \mathcal Y,i=1,2\cdots,N</script><p>用通俗的话来说，我们希望最大化超平面关于训练数据集的几何间隔 $\mathcal Y$ 。约束条件表示的是，超平面关于每个训练样本点的几何间隔<strong>至少是</strong>$\mathcal Y$ </p>
<p>上面这个式子比较麻烦，我们运用<strong>几何间隔和函数间隔</strong> 的关系，可以将上式改写为：</p>
<script type="math/tex; mode=display">
\max_{w,b} & \frac{\hat{\mathcal Y}}{||w||}\\
s.t.& y_i({w}x_i+{b})\geq \hat{\mathcal Y},i=1,2\cdots,N</script><p>然后， 我们还是不满意，还是觉得有点复杂。因此我们可以将$\hat {\mathcal Y}=1$ ,函数间隔的这一改变对优化问题的不等式没有影响。而且我们也不喜欢分数，因为最大化 $\frac{1}{||w||}$  和最小化 $\frac{1}{2}||w||^2$ 是等价的，因此可以得到最终版本的优化问题：</p>
<script type="math/tex; mode=display">
\max_{w,b} & \frac{1}{2}{||w||}^2 \\
s.t.& y_i({w}x_i+{b})-1\geq 0,i=1,2\cdots,N</script><h4 id="算法—最大间隔法"><a href="#算法—最大间隔法" class="headerlink" title="算法—最大间隔法"></a>算法—最大间隔法</h4><ul>
<li>输入： 线性可分训练数据集 $T = {(x_1,y_1),\cdots,(x_N,y_N) }$ ,其中，$x_i\in \mathcal X = \boldsymbol R^n,y_i\in\mathcal Y = {-1,+1},i=1,2\cdots,N$ </li>
<li>输出： 最大间隔分离超平面和决策函数</li>
</ul>
<ol>
<li>构造并<strong>求解</strong> 约束最优化问题：</li>
</ol>
<script type="math/tex; mode=display">
\max_{w,b} & \frac{1}{2}{||w||}^2 \\
s.t.& y_i({w}x_i+{b})-1\geq 0,i=1,2\cdots,N</script><p>求得最优解$w^<em>,b^</em> $</p>
<ol>
<li>得到分离超平面</li>
</ol>
<script type="math/tex; mode=display">
w^*\cdot x+b^* = 0</script><p>分类决策函数：</p>
<script type="math/tex; mode=display">
f(x) = sign(w^*\cdot x+b^* )</script><h4 id="支持向量和间隔边界"><a href="#支持向量和间隔边界" class="headerlink" title="支持向量和间隔边界"></a>支持向量和间隔边界</h4><p>在线性可分的情况下，训练数据集的样本点中与分离超平面距离最近的样本点的实例，我们称其为<strong>支持向量</strong>，支持向量是使得约束条件式等号成立的点，即：</p>
<script type="math/tex; mode=display">
y_i(w\cdot x_i+b)-1 = 0</script><p>对于 $y_i = +1$ 的正例点，支持向量在超平面 $w\cdot x+b=1$上</p>
<p>对于 $y_i = -1$ 的正例点，支持向量在超平面 $w\cdot x+b= -1$上</p>
<p>如下图，$H_1,H_2$ 上的点，就是支持向量</p>
<p><img src="/2022/01/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/3.png"></p>
<p>注意到 $H_1$和$H_2$ 平行，它们中间形成一条没有点的长带。长带的宽度等于 $\frac{2}{||w||}$,称$H_1$和$H_2$ 为<strong>间隔边界</strong></p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="/2022/01/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/4.jpg"></p>
<p>第一步：列出优化问题。 这里有x是二维的，因此我们 $\boldsymbol w = (w_1,w_2)$</p>
<script type="math/tex; mode=display">
\max_{w,b} & \frac{1}{2}{||w_1+w_2||}^2 \\
s.t.& y_i({w_1}x_{1i}+w_2x_{2i}+{b})-1\geq 0,i=1,2\cdots,N</script><p>带入正例点和负例点，可得：</p>
<script type="math/tex; mode=display">
\begin{align}
&w_1+2w_2+b\geq1 &(1)\\
&2w_1+3w_2+b\geq1&(2)\\
&3w_1+3w_2+b\geq 1&(3)\\
&2w_1+w_2+b\leq -1\Leftrightarrow-2w_1-w_2-b\geq -1&(4)\\
&3w_1+2w_2+b\leq -1\Leftrightarrow-3w_1-2w_2-b\geq -1&(5)\\
\end{align}</script><p>第二步： 线性规划</p>
<p>我们要做的是尽量消去 b，然后再一个二维平面上做线性优化：</p>
<script type="math/tex; mode=display">
\begin{align}
(4)+(1)\Rightarrow&-w_1+w_2\geq 2\\
(5)+(1)\Rightarrow&-2w_1\geq 2\Rightarrow w_1\leq 1\\
(4)+(2) \Rightarrow&2w_2\geq 2\Rightarrow w_2\leq1\\
(5)+(2) \Rightarrow& -w_1+w_2\geq2\\
(4)+(3) \Rightarrow&w_1+2w_2\geq 2\\
(5)+(3) \Rightarrow&w_2\geq2\\
\end{align}</script><p>我们对上面式子做线性规划，可得：</p>
<p><img src="/2022/01/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/5.jpeg"></p>
<p>将 $(w_1,w_2)=(-1,2)$ 带入原方程，可得 $b=-2$</p>
<p>第三步：画出分离超平面，得到支持向量</p>
<p><img src="/2022/01/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/6.jpeg" style="zoom:50%;"></p>
<p>最终得到分离超平面为：</p>
<script type="math/tex; mode=display">
-x_1+2x_2-2 = 0</script><p>分类决策函数为 </p>
<script type="math/tex; mode=display">
f(x) = sign(-x_1+2x_2-2)</script><p>支持向量为：$(3,2),(1,2),(3,3)$</p>
<p>#</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/01/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/01/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/" itemprop="url">机器学习-朴素贝叶斯</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-01-02T23:21:43+08:00">
                2022-01-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-01-05T01:24:28+08:00">
                2022-01-05
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="机器学习-朴素贝叶斯"><a href="#机器学习-朴素贝叶斯" class="headerlink" title="机器学习-朴素贝叶斯"></a>机器学习-朴素贝叶斯</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><ol>
<li>朴素贝叶斯法是典型的生成学习方法生成方法由训练数据<strong>学习联合概率分布</strong>$P(X,Y)$  然后求得后验概率分布$P(Y |X)$. 具体来说, 利用训练数据学习 $P(X|Y)$ 和 $P(Y)$ 的估计，得到联合概率分布:</li>
</ol>
<script type="math/tex; mode=display">
P(X,Y)= P(Y)P(X|Y)</script><p>概率估计方法可以是<strong>极大似然估计</strong> 或者是 <strong>贝叶斯估计</strong></p>
<ol>
<li>朴素贝叶斯法的基本假设是条件独立性</li>
</ol>
<script type="math/tex; mode=display">
P(X=x|Y=c_k)=P(X^{(1)}=x^{(1)},\cdots,X^{(n)}=x^{(n)}|Y=c_k)\\
=\prod_{j=1}^nP(X^{(j)}=x^{(j)}|Y=c_k)</script><p>这是一个较强的假设.由于这一假设，模型包含的条件概率的数量大为减少，朴素贝叶斯法的学习与预测大为简化.因而朴素贝叶斯法高效，且易于实现.其缺点是分类的性能不一定很高.</p>
<ol>
<li>朴素贝叶斯法利用贝叶斯定理与学到的联合概率模型进行分类预测</li>
</ol>
<script type="math/tex; mode=display">
P(Y|X) = \frac{P(X,Y)}{P(X)} = \frac{P(Y)P(X|Y)}{\sum_YP(Y)P(X|Y)}</script><p>将输入x 分到后验概率最大的类y</p>
<script type="math/tex; mode=display">
y = \arg\max_{c_{k}} P(Y=c_k)\prod_{j=1}^nP(X_j=x^{(j)}|Y=c_k)</script><p>后验概率等价于0-1损失函数时的期望风险最小化.</p>
<h2 id="朴素贝叶斯学习与分类"><a href="#朴素贝叶斯学习与分类" class="headerlink" title="朴素贝叶斯学习与分类"></a>朴素贝叶斯学习与分类</h2><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><h4 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h4><p>对于训练数据集：输入为特征向量 $x\in\mathcal X\subseteq \boldsymbol R^n$ ，输出位类标记 $y\in \mathcal Y ={c_1,c_2\cdots,c_k}$ </p>
<script type="math/tex; mode=display">
T = \{(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N) \}</script><p>由 $P(X,Y)$ 独立同分布产生。</p>
<p>然后，朴素贝叶斯法 会通过训练数据集<strong>学习联合概率分布</strong> $P(X,Y)$ ，也就是学习<strong>先验概率分布</strong>以及<strong>条件概率分布</strong></p>
<ul>
<li><p>先验概率分布：</p>
<script type="math/tex; mode=display">
P(Y=c_k),k=1,2\cdots,K</script></li>
<li><p>条件概率分布</p>
<script type="math/tex; mode=display">
P(X=x|Y=c_k)  = P(X^{(1)}=x^{(1)},\cdots,X^{(n)}=x^{(n)}|Y=c_k),k=1,2\cdots,K</script></li>
</ul>
<p>于是，学习到联合概率分布 $P(X,Y)$</p>
<p>条件概率分布 $P(X=x|Y=c_k)$ 有着<strong>指数级数量</strong>的参数，其估计实际是不可行的。因此，朴素贝叶斯法对条件概率分布做了条件独立性假设。具体的，条件独立性假设是：</p>
<script type="math/tex; mode=display">
P(X^{(1)}=x^{(1)},\cdots,X^{(n)}=x^{(n)}|Y=c_k)\\
=\prod_{j=1}^n P(X^{(j)}=x^{(j)}|Y=c_k)</script><p>条件独立假设等于是说：用于分类的特征在类确定的条件下都是<strong>条件独立的</strong>。这一假设使得朴素贝叶斯法变得简单，但有时会牺牲一定的分类准确率。</p>
<h4 id="分类过程"><a href="#分类过程" class="headerlink" title="分类过程"></a>分类过程</h4><p>朴素贝叶斯法分类时，对给定的输入x，通过学习到的模型计算后验概率分布 $P(Y=c_k|X=x)$ ，将后验概率最大的类作为$x$ 的输出。后验概率计算根据<strong>贝叶斯定理</strong>进行：</p>
<script type="math/tex; mode=display">
P(Y=c_k|X=x) = \frac{P(X=x|Y=c_k)P(Y=c_k)}{\sum_k P(X=x|Y=c_k)P(Y=c_k)}</script><p>将独立性假设带入上式，可得：</p>
<script type="math/tex; mode=display">
P(Y=c_k|X=x) = \frac{P(Y=c_k)\prod_{j=1}^n P(X^{(j)}=x^{(j)}|Y=c_k)}{\sum_k P(X=x|Y=c_k)\prod_{j=1}^n P(X^{(j)}=x^{(j)}|Y=c_k)} ,~~~k=1,2,\cdots,K</script><p>这是朴素贝叶斯法分类的基本公式。于是，朴素贝叶斯分类器科表示为：</p>
<script type="math/tex; mode=display">
y = f(x) = \arg\max_{c_k}\frac{P(Y=c_k)\prod_{j=1}^n P(X^{(j)}=x^{(j)}|Y=c_k)}{\sum_k P(Y=c_k)\prod_{j=1}^n P(X^{(j)}=x^{(j)}|Y=c_k)}</script><p>注意到，在上式中，分母对所有 $c_k$ 都是相同的，因此直接拿掉了</p>
<script type="math/tex; mode=display">
y = \arg\max_{c_{k}} P(Y=c_k)\prod_{j=1}^nP(X_j=x^{(j)}|Y=c_k)</script><h2 id="朴素贝叶斯的学习与分类算法"><a href="#朴素贝叶斯的学习与分类算法" class="headerlink" title="朴素贝叶斯的学习与分类算法"></a>朴素贝叶斯的学习与分类算法</h2><h3 id="朴素贝叶斯算法"><a href="#朴素贝叶斯算法" class="headerlink" title="朴素贝叶斯算法"></a>朴素贝叶斯算法</h3><p>输入：训练数据 $T = {(x<em>1,y_1),(x_2,y_2),\cdots,(x_N,y_N) }$ ，其中 $x_i = (x_i^{(1)},\cdots,x_i^{(n)})^T$.  $x_i^{(j)}$ 是第i个样本的第j 个特征，$x_i^{(j)}\in{a</em>{j1},\cdots,a<em>{jS_j} }$ , $a</em>{jl}$ 是第j个特征可能取的第 l 个值。</p>
<script type="math/tex; mode=display">
j=1,2\cdots,n\\
l=1,2\cdots,S_j\\
y_i\in \{c_1,c_2,\cdots,c_k\}</script><p>以及测试数据 ：实例x</p>
<p>输入：实例x的分类</p>
<ol>
<li>计算先验概率及条件概率</li>
</ol>
<script type="math/tex; mode=display">
P(Y=c_k) = \frac{\sum_{i=1}^NI(y_i=c_k)}{N},k=1,2\cdots,K\\~\\</script><p>第一步是计算输入 $c_k$ 的训练数据占所有训练数据的比值</p>
<script type="math/tex; mode=display">
P(X^{(j)}=a_{jl}|Y=c_k)=\frac{\sum_{i=1}^N I(x_i^{(j)}=a_{jl},y=c_k)}{\sum_{i=1}^N I(y_i=c_k)}\\~\\
j=1,2\cdots,n;~l=1,2\cdots,S_j;~y_i\in \{c_1,c_2,\cdots,c_k\}</script><p>第二步是计算条件概率</p>
<ol>
<li>对于给定的实例 $x=(x^{(1)},\cdots,x^{(n)})^T$ 计算：</li>
</ol>
<script type="math/tex; mode=display">
P(Y=c_k) \prod_{j=1}^n P(X^{(j)}=x^{(j)}|Y=c_k) ,k=1,2\cdots,K</script><ol>
<li>确定实例 $x$ 的类</li>
</ol>
<script type="math/tex; mode=display">
y = \arg\max_{c_k}P(Y=c_k)\prod_{j=1}^n P(X^{(j)}=x^{(j)}|Y=c_k)</script><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>试由下表的训练数据学习一个朴素贝叶斯分类器并确定$x=(2,S)^T$的类标记 y. 表中$X^{(1)}, X^{(2)}$  为特征，取值的集合分别为，$A_1={1 , 2, 3} ,  A_2={S, M,L}$ ;  $Y$ 为类标记， $Y\in C = {1 , -1}$</p>
<p><img src="/2022/01/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/1.png" style="zoom:150%;"></p>
<ol>
<li>计算先验概率，首先统计正例和负例的个数。</li>
</ol>
<p>这里，正例有9个，负例有6个。因此:</p>
<script type="math/tex; mode=display">
P(Y=1) = 9/15\\
P(Y=-1) = 6/15</script><ol>
<li>计算条件概率，一共要计算 $2\times(3+3)=12$个概率</li>
</ol>
<script type="math/tex; mode=display">
\begin{align}
&P(X^{(1)}=1|Y=1)=\frac{2}{9},P(X^{(1)}=2|Y=1)=\frac{3}{9},P(X^{(1)}=3|Y=1)=\frac{4}{9}\\
&P(X^{(2)}=S|Y=1)=\frac{1}{9},P(X^{(2)}=M|Y=1)=\frac{4}{9},P(X^{(2)}=L|Y=1)=\frac{4}{9}\\
&P(X^{(1)}=1|Y=-1)=\frac{3}{6},P(X^{(1)}=2|Y=-1)=\frac{2}{6},P(X^{(1)}=3|Y=-1)=\frac{1}{6}\\
&P(X^{(2)}=S|Y=-1)=\frac{3}{6},P(X^{(2)}=M|Y=-1)=\frac{2}{6},P(X^{(2)}=L|Y=-1)=\frac{1}{6}\\
\end{align}</script><ol>
<li>计算后验概率，对给定的测试样本 $x=(2,S)^T$ 进行计算</li>
</ol>
<script type="math/tex; mode=display">
\begin{align}
&P(Y=1)P(X^{(1)}=2|Y=1)P(X^{(2)}=S|Y=1) =\frac{9}{15}\frac{3}{9}\frac{1}{9} = \frac{1}{45}\\
&P(Y=-1)P(X^{(1)}=2|Y=-1)P(X^{(2)}=S|Y=-1)=\frac{6}{15}\frac{2}{6}\frac{3}{6} = \frac{1}{15}
\end{align}</script><p>由于$P(Y=-1)P(X^{(1)}=2|Y=-11)P(X^{(2)}=S|Y=-1)$ 是两种情况中最大的，因此 最终的预测结果是 $y=-1$</p>
<h3 id="贝叶斯估计"><a href="#贝叶斯估计" class="headerlink" title="贝叶斯估计"></a>贝叶斯估计</h3><p>用极大似然估计可能会出现所要估计的概率值为0 的情况. 这时会影响到后验概率的计算结果(只要一个概率值为0就都为0)，使分类产生偏差解决这一问题的方法是采用贝叶斯估计</p>
<p>具体地</p>
<p>先验概率的贝叶斯估计是</p>
<script type="math/tex; mode=display">
P_\lambda (Y=c_k) = \frac{\sum_{i=1}^NI(y_i=c_k)+\lambda}{N+K\lambda}</script><p>条件概率的贝叶斯估计是</p>
<script type="math/tex; mode=display">
\begin{align}
&P_\lambda (X^{(j)}=a_{jl}|Y=c_{k}) = \frac{\sum_{i=1}^N I(x_i^{(j)}=a_{jl},y=c_k)+\lambda}{\sum_{i=1}^N I(y_i=c_k)+S_j\lambda }\\~\\
&j=1,2\cdots,n;~l=1,2\cdots,S_j;~y_i\in \{c_1,c_2,\cdots,c_k\}
\end{align}</script><p>式中 $\lambda \geq 0$, 等价于在随机变量各个取值的频数上赋予一个整数 $\lambda &gt;0$ . 当 $\lambda=0$ 时，就是极大似然估计。常常取 $\lambda = 1$ ,这称为拉普拉斯平滑 。 </p>
<p>显然，对任何 $l=1,2\cdots,S_j,k=1,2\cdots,K$ ,有条件概率大于0</p>
<script type="math/tex; mode=display">
\begin{align}
&P_\lambda (X^{j} = a_{jl}|Y=c_k) > 0\\~\\
&\sum_{l=1}^{S_j}P(X^{(j)}=a_{jl}|Y=c_k)=1\\
\end{align}</script><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p>试由下表的训练数据学习一个朴素贝叶斯分类器并确定$x=(2,S)^T$ 的类标记 $y$ 。 表中$X^{(1)}, X^{(2)}$  为特征，取值的集合分别为，$A_1={1 , 2, 3} ,  A_2={S, M,L}$  $Y$ 为类标记， $Y\in C = {1 , -1}$ </p>
<p>按照拉普拉斯平滑估计概率 ，即取  $\lambda = 1$</p>
<p><img src="/2022/01/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/1.png" style="zoom:150%;"></p>
<ol>
<li>先验概率的贝叶斯估计</li>
</ol>
<script type="math/tex; mode=display">
P(Y=1) = \frac{9+1}{15+2\times1} = \frac{10}{17}\\
P(Y=-1) = \frac{6+1}{15+2\times 1} =\frac{7}{17}\\</script><ol>
<li>计算条件概率</li>
</ol>
<script type="math/tex; mode=display">
\begin{align}
&P(X^{(1)}=1|Y=1)=\frac{2+1}{9+3*1}= \frac{3}{12},P(X^{(1)}=2|Y=1)=\frac{4}{12},P(X^{(1)}=3|Y=1)=\frac{5}{12}\\~\\
&P(X^{(2)}=S|Y=1)=\frac{2}{12},P(X^{(2)}=M|Y=1)=\frac{5}{12},P(X^{(2)}=L|Y=1)=\frac{5}{12}\\~\\
&P(X^{(1)}=1|Y=-1)=\frac{4}{9},P(X^{(1)}=2|Y=-1)=\frac{3}{9},P(X^{(1)}=3|Y=-1)=\frac{2}{9}\\~\\
&P(X^{(2)}=S|Y=-1)=\frac{4}{9},P(X^{(2)}=M|Y=-1)=\frac{3}{9},P(X^{(2)}=L|Y=-1)=\frac{2}{9}\\
\end{align}</script><p>由此我们可以看出，及时当前的条件样本数为0，条件概率也不会为0，而是 $p = \frac{\lambda}{\sum_{i=1}^N I(y_i=c_k)+S_j\lambda}$ </p>
<ol>
<li>因此，对于给定的 $x=(2,S)^T$ ，我们计算后验概率 </li>
</ol>
<script type="math/tex; mode=display">
\begin{align}
&P(Y=1)P(X^{(1)}=2|Y=1)P(X^{(2)}=S|Y=1) =\frac{10}{17}\frac{4}{12}\frac{2}{12} = \frac{5}{153}=0.0327\\
&P(Y=-1)P(X^{(1)}=2|Y=-1)P(X^{(2)}=S|Y=-1)=\frac{7}{17}\frac{3}{9}\frac{4}{9} = \frac{28}{459}=0.0610
\end{align}</script><p>由于$P(Y=-1)P(X^{(1)}=2|Y=-11)P(X^{(2)}=S|Y=-1)$ 是两种情况中最大的，因此 最终的预测结果是 $y=-1$</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/01/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%84%9F%E7%9F%A5%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/01/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%84%9F%E7%9F%A5%E6%9C%BA/" itemprop="url">机器学习-感知机</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-01-02T20:34:43+08:00">
                2022-01-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-01-05T01:28:20+08:00">
                2022-01-05
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="机器学习-感知机"><a href="#机器学习-感知机" class="headerlink" title="机器学习-感知机"></a>机器学习-感知机</h1><p>破防了，还有4天就要期末考了，现在才开始做机器学习的第一份笔记</p>
<h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p><strong>其实感知机就是一个神经元</strong>。 它有如下几个特点</p>
<ul>
<li><p>输入为实例的特征向量，输出为实例的类别，取+1和-1</p>
</li>
<li><p>感知机对应于输入空间中将实例划分为正负两类的分离超平面，属于判别模型</p>
</li>
<li><p>导入基于误分类的损失函数</p>
</li>
<li><p>利用梯度下降法对损失函数进行极小化</p>
<ul>
<li>感知机学习算法具有简单而易于实现的优点，分为原始形式和对偶形式</li>
</ul>
</li>
</ul>
<p>接下来对感知机模型进行拆解：</p>
<p>第一个：输入部分</p>
<p>第二个：权重（就是w向量）；权重是在我们进行训练期间计算的值，初始呢我们是用一些初始值来可以进行随机的初始化，然后在学习过程当中对他们进行更新，最后我们模型学习完之后，这就是我们学习到的参数向量。我们用w来表示。</p>
<p>第三个：偏置项，这个偏置对应到上图在输入里边我们有一个常量1, 实际上这个常量1就相当于乘以1, 实际上就是, 后边的计算是和输入是无关的，相当于就是一个偏置，相当于i从1开始一直到n，还加上一个，这就是一个偏置。</p>
<p>由输入空间到输出空间的函数：</p>
<script type="math/tex; mode=display">
f(x) = sign(w\cdot x+b)</script><p>符号函数：</p>
<script type="math/tex; mode=display">
sign(x) = \begin{cases}+1&x\geq 0\\-1&x<0\end{cases}</script><h4 id="几何解释"><a href="#几何解释" class="headerlink" title="几何解释"></a>几何解释</h4><p>对于线性方程：</p>
<script type="math/tex; mode=display">
w\cdot x+b = 0</script><p>相当于在平面空间中的超平面S，w 是法向量，b是截距，用来分割开正负两种类别：</p>
<p><img src="/2022/01/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%84%9F%E7%9F%A5%E6%9C%BA/1.png"></p>
<h3 id="感知机学习策略"><a href="#感知机学习策略" class="headerlink" title="感知机学习策略"></a>感知机学习策略</h3><p>如何定义损失函数？</p>
<p>自然选择：误分类点的数目，但损失函数不是w,b连续可导，不宜优化。</p>
<p>另一选择：误分类点到超平面的总距离：</p>
<p>首先，距离函数：</p>
<script type="math/tex; mode=display">
d = \frac{|w\cdot x_0+b|}{||w||}</script><p>误分类点： $-y_i(w\cdot x_i+b)&gt;0$</p>
<p>误分类点距离：</p>
<script type="math/tex; mode=display">
-\frac{1}{||w||}\sum_{x_i\in M} y_i(w\cdot x_i+b)\\
w' = \frac{w}{||w||} ,b' = \frac{b}{||w||}</script><p>损失函数：</p>
<script type="math/tex; mode=display">
L(w,b) = -\sum_{x_{i}\in M} y_i(w\cdot x_i+b)</script><p>为了优化损失函数： </p>
<script type="math/tex; mode=display">
\min_{w,b}L(w,b) = -\sum_{x_i\in M}y_i(w\cdot x_i+b)</script><p>我们使用梯度下降法来更新损失函数。</p>
<h3 id="感知机学习算法"><a href="#感知机学习算法" class="headerlink" title="感知机学习算法"></a>感知机学习算法</h3><h4 id="原始形式"><a href="#原始形式" class="headerlink" title="原始形式"></a>原始形式</h4><p>输入：训练数据集 $T =\big{(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N) \big}$, 期中 $x_i\in \mathcal X =R^n,y_i\in\mathcal y = {-1,+1}$ $i=1,2\cdots,N$ ， 学习率 $\eta(0&lt;\eta\leq1)$ </p>
<p>输出：w,b ： 感知机模型 $f(x) = sign(w\cdot x+b)$</p>
<ol>
<li><p>选取初值 $w_0,b_0$</p>
</li>
<li><p>在训练集中选取数据$(x_i,y_i)$</p>
</li>
<li><p>如果 $y_i(w\cdot x_i+b)\leq 0$, 说明分类错误:</p>
<script type="math/tex; mode=display">
\begin{align}
&w \leftarrow w+\eta ~y_ix_i\\
&b \leftarrow b+\eta y_i
\end{align}</script></li>
<li><p>转至2，直至训练集中没有误分类点</p>
</li>
</ol>
<p>比如说 正样本点是. $x_1=(3,3)^T,x_2=(4.3)^T$. 负样本点是 $x_3=(1,1)^T$. 试用感知机学习算法原始形式求感知机模型.</p>
<ol>
<li><p>取初值 $w_0 = 0,b_0= 0,\eta = 1$</p>
</li>
<li><p>对 $x_1 = (3,3)^T, y_1(w_0\cdot x_1+b_0)=0$ ，未能被正确分类，更新 $w,b$ </p>
</li>
</ol>
<script type="math/tex; mode=display">
\begin{align}
&w_1 = w_0+y_1x_1 = (3,3)^T\\
&b_1=b_0+y_1 = 1
\end{align}</script><p>​        得到新的线性模型： $w_1\cdot x+b_1 = 3x^{(1)}+3x^{(2)}+1$</p>
<ol>
<li>对于$x_1,x_2$显然模型大于0，被正确分类，对$x_3 = (1,1)^T$ 为负例 ，但计算得到$y_3(w_1\cdot x_3+b_1)&lt;0$ 被误分类, 更新$w,b$<script type="math/tex; mode=display">
\begin{align}
&w_2 = w_1+y_3x_3 = (2,2)^T\\
&b_2 = b_1+y_3 = 0
\end{align}</script></li>
</ol>
<p><img src="/2022/01/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%84%9F%E7%9F%A5%E6%9C%BA/2.png"></p>
<p>算法的收敛性：证明经过有限次迭代可以得到一个将训练数据集完全正确划分的分离超平面及感知机模型。</p>
<h4 id="对偶形式"><a href="#对偶形式" class="headerlink" title="对偶形式"></a>对偶形式</h4><p>感知机算法的对偶形式的基本想法是：</p>
<p>将w和b表示为实例$x_i$和标记 $y_i$ 的线性组会的形式，通过求解其系数而求得$w$和$b$</p>
<p>由于</p>
<script type="math/tex; mode=display">
\begin{align}
&w \leftarrow w+\eta ~y_ix_i\\
&b \leftarrow b+\eta y_i
\end{align}</script><p>最后学习到的$w,b$为：</p>
<script type="math/tex; mode=display">
\begin{align}
&w =\sum_{i=1}^N \alpha_i y_ix_i\\
&b =\sum_{i=1}^N \alpha_i y_i
\end{align}</script><p>输入：训练数据集 $T =\big{(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N) \big}$, 期中 $x_i\in \mathcal X =R^n,y_i\in\mathcal y = {-1,+1}$ $i=1,2\cdots,N$ ， 学习率 $\eta(0&lt;\eta\leq1)$ </p>
<p>输出：感知机模型 $f(x) = sign\bigg(\sum_{j=1}^N\alpha_jy_jx_j\cdot x+b\bigg)$<br>其中 $\alpha = (\alpha_1,\cdots,\alpha_N)^T$ </p>
<ol>
<li><p>$\alpha\leftarrow 0,b\leftarrow 0,\eta\leftarrow 1$</p>
</li>
<li><p>在训练集中选取数据 $(x_i,y_i)$</p>
</li>
<li><p>如果  </p>
<script type="math/tex; mode=display">
\begin{align}
&y_i\bigg(\sum_{j=1}^N \alpha_jy_j(x_j\cdot x_i)+b \bigg)\leq 0\\
&\alpha_i\leftarrow \alpha_i+ \eta\\
&b\leftarrow b+\eta y_i
\end{align}</script></li>
<li><p>转至(2) 直到没有误分类数据</p>
</li>
</ol>
<p>比如说 正样本点是. $x_1=(3,3)^T,x_2=(4,3)^T$. $y_1=y_2=1$ ; 负样本点是 $x_3=(1,1)^T, y_3 = -1$ .试用感知机学习算法对偶形式求感知机模型.</p>
<ol>
<li><p>首先$\alpha_i$ 都是0，因为每个都没有误分，因此$b=\alpha_i\cdot y_i = 0$  所以这就是表2.2的第一列</p>
</li>
<li><p>接着，就是进入迭代过程，首先计算第一个点</p>
</li>
</ol>
<script type="math/tex; mode=display">
\begin{align}
&y_i(\sum\alpha_j y_j x_j\cdot x_i+b)\\
&=1*((0*1*(3,3)^T\cdot(3,3)+0*1*(4,3)^T\cdot(3,3)+0*-1*(1,1)^T\cdot(3,3))+0)\\
&=0
\end{align}</script><p>那么就出现误分类，则此时，更新$\boldsymbol \alpha,b$ ,而这就是表2.2的第二列</p>
<script type="math/tex; mode=display">
\alpha_1 = 0,\alpha_2=0,\alpha_3 = 0\\
b = 0+1\cdot1 = 1</script><ol>
<li>接着进行判断，第二个点，发现没有误分类，进行判断第三个点</li>
</ol>
<script type="math/tex; mode=display">
\begin{align}
&y_i(\sum\alpha_j y_j x_j\cdot x_i+b)\\
&=-1*((1*1*(3,3)^T\cdot(1,1)+0*1*(4,3)^T\cdot(1,1)+0*-1*(1,1)^T\cdot(1,1))+1)\\
&=-1*(((3,3)^T\cdot(1,1))+1)\\
&=-(6+1)\\
&=-7<0
\end{align}</script><p>因此该点为误分类点，此时，更新$\boldsymbol \alpha,b$ ,而这就是表2.2的第三列</p>
<script type="math/tex; mode=display">
\alpha_1 = 1,\alpha_2=0,\alpha_3 = 1\\
b = 1+1\cdot-1 = 0</script><p>以此类推</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>k</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td>$x_1$</td>
<td>$x_3$</td>
<td>$x_3$</td>
<td>$x_3$</td>
<td>$x_1$</td>
<td>$x_3$</td>
<td>$x_3$</td>
</tr>
<tr>
<td>$\alpha_1$</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>$\alpha_2$</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>$\alpha_3$</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>b</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>-1</td>
<td>-2</td>
<td>-1</td>
<td>-2</td>
<td>3</td>
</tr>
</tbody>
</table>
</div>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>感知机因为是线性模型，所以不能表示复杂的函数，如异或(XOR) 。验证感知机为什么不能表示异或。</p>
<p>直观上，我们设正方形为True, 三角形为False</p>
<p><img src="/2022/01/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%84%9F%E7%9F%A5%E6%9C%BA/3.jpeg" style="zoom: 30%;"></p>
<p>那么，我们是没有办法找到一条直线将其分离的，如上图</p>
<p>在数学形式上：</p>
<script type="math/tex; mode=display">
\text{设}~~sign(x) = \begin{cases}1&x\geq 0\\-1&x<0 \end{cases}</script><p>我们令 $f(x) = sign(w\cdot x+b)$ $w$为权重$(w_1,w_2)$  ，b为偏置</p>
<p>设向量$\boldsymbol x = (x_1,x_2)$ ，用其表示异或问题</p>
<ul>
<li>若 $x_1=x_2=0,f(x)=-1$ 则有 $b&lt;0$</li>
<li>若 $x_1=0,x_2=1,f(x)=1$ 则有 $w_1\cdot 0+w_2\cdot1 +b &gt;0$ . 因此 $w_2&gt;-b&gt;0$</li>
<li>若 $x_1=01,x_2=0,f(x)=1$ 则有 $w_1\cdot 1+w_2\cdot0 +b &gt;0$ . 因此 $w_1&gt;-b&gt;0$</li>
<li>若 $x_1=x_2=1,f(x)=-1$ ，当前由上面三个式子，有 $w_2&gt;-b&gt;0,w_1&gt;-b&gt;0$ , 所以应该是 $w_1+w_2-(-b)&gt;0$ 。 但是这和 $f(x)=-1$   矛盾</li>
</ul>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/01/01/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%B5%81%E7%AE%97%E6%B3%95%E8%A1%A5%E5%85%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/01/01/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%B5%81%E7%AE%97%E6%B3%95%E8%A1%A5%E5%85%85/" itemprop="url">数据科学与算法-流算法补充</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2022-01-01T10:59:07+08:00">
                2022-01-01
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-01-07T11:51:38+08:00">
                2022-01-07
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="流算法补充"><a href="#流算法补充" class="headerlink" title="流算法补充"></a>流算法补充</h1><h2 id="Queries-over-a-sliding-window"><a href="#Queries-over-a-sliding-window" class="headerlink" title="Queries over a sliding window"></a>Queries over a sliding window</h2><p>在第五章流算法中，我们讲了一些数据挖掘算法：Basic Count Sketch，Count Sketch 和 Count-min Sketch。当时我们提了一嘴滑动窗口模型，但没有细讲。现在我们来对这个数据流模型做一个补充</p>
<p>比如说举一个Amazon的例子，数据流是亚马逊上的订单，数据流的值是0-1，其中，0代表数据流不包含某个商品，1代表数据流包含某个商品，我们希望统计在过去的n笔订单中，有多少订单包含商品 X(统计1的个数)</p>
<p><img src="/2022/01/01/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%B5%81%E7%AE%97%E6%B3%95%E8%A1%A5%E5%85%85/1.png" style="zoom:67%;"></p>
<h3 id="朴素方法"><a href="#朴素方法" class="headerlink" title="朴素方法"></a>朴素方法</h3><p>要计算数据流中过去 k 个bits 有多少个1(k&lt;窗口大小N)，一个朴素的想法是：<strong>维持一个计数器</strong></p>
<p>每当有一个新的bit进来，就需要抛弃一个bit</p>
<ul>
<li>如果进来或抛弃的bit 是 0，那么什么都不用做</li>
<li>如果进来的bit 是1，那么计数器+1</li>
<li>如果进来的bit 是0，那么计数器-1</li>
</ul>
<p>这个算法的空间复杂度是$O(n)$,因为我们要时刻保持窗口中的数据；时间复杂度为$(O1)$ </p>
<p>那么，如果N 等于 1 billion 会怎么样？我们肯定不能将其全部保存下来，因此我们可以采用一个近似算法。</p>
<h4 id="尝试1"><a href="#尝试1" class="headerlink" title="尝试1"></a>尝试1</h4><p>我们尝试维护两个计数器：</p>
<p>S: 维护数据流中的1的个数</p>
<p>Z: 维护数据流中的0的个数</p>
<p>因此我们可以用这两个计数器的值，结合窗口大小去估算窗口内1的数值:$ = N\cdot \frac{S}{S+Z} $</p>
<p>但是这样又不对，因为采用这种方法，随便你窗口化到哪，对1的个数的估算都是不会变的。也就是说，加入之前数据流 1和0的比值为0.8：0.2，那么相当于假设之后来的数字也是0.8:0.2，但现实生活中事件发生的概率是不停变化的，因此是不可行的。</p>
<h3 id="DGIM-算法"><a href="#DGIM-算法" class="headerlink" title="DGIM 算法"></a>DGIM 算法</h3><p>因此我们提出了一种更高效的解决方法：DGIM算法</p>
<p>在DGIM算法中，我们对于一个长度为N的数据流，我们存储 $O(\log^2 N)$ 个 bits, $O(\log_2(N))$个桶 ，相当于一个亚线性的算法，而且我们要得目标的估计偏差不能超过 50%，也就是说，假设1的出现次数是100，那么我们的估计必须落在 50~150之间</p>
<p>首先假设对于二进制流，其中每个位可以用一个时间戳（timestamp）标志该位进入流的时间（对于大小为N的滑动窗口，该时间戳可以用O(logN)位表示）。</p>
<p>DGIM算法利用桶（bucket）对滑动窗口进行划分，每个桶保存以下信息：</p>
<ul>
<li>桶的最右边位即<strong>最后进入流的位的时间戳</strong>；</li>
<li><p>桶的大小，即桶中1的个数，该数目位2的幂。 </p>
<p>对于以上信息，保存时间戳需要logN的空间，保存桶的大小需要 logN 的空间。</p>
</li>
</ul>
<p>使用桶对滑动窗口进行划分时遵循以下5条规则：</p>
<ul>
<li>桶最右边的位必须是1；</li>
<li>1个位最多属于1个桶；</li>
<li>每种大小的桶有1个或者两个（从1到最大的桶的大小）；</li>
<li>每个桶的大小是2的幂；</li>
<li>桶的大小从右到左非降序排列；</li>
</ul>
<p>DGIM算法中数据结构的更新：</p>
<ul>
<li>每一个新的位进入滑动窗口后，最左边一个位从窗口中移出（同时从桶中移出）；如果最左边的桶的时间戳是当前时间戳减去N（也就是说桶里已经没有处于窗口中的位），则放弃这个桶；</li>
<li>对于新加入的位，如果其为0，则无操作；否则建立一个包含新加入位的大小为1的桶；</li>
<li>由于新增一个大小为1的桶而出现3个桶大小为1，则合并最左边的两个桶为一个大小为2的桶；合并之后可能出现3个大小为2的桶，则合并最左边两个大小为2的桶得到一个大小为4的桶……依次类推直到到达最左边的桶。</li>
</ul>
<p>我们用一个直观的例子来展现：</p>
<ul>
<li>这是我们的初始数据流：</li>
</ul>
<p><img src="/2022/01/01/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%B5%81%E7%AE%97%E6%B3%95%E8%A1%A5%E5%85%85/2.png"></p>
<p>我们看到现在一共有长度为1的桶2个；长度为2的桶1个；长度为4的桶2个；长度为8的桶2个; 长度为16的桶1个，但是一部分在滑动窗口外，因此显示不出</p>
<ul>
<li>当到达了一个新的 1 ，如下图</li>
</ul>
<p><img src="/2022/01/01/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%B5%81%E7%AE%97%E6%B3%95%E8%A1%A5%E5%85%85/3.png"></p>
<p>我们发现现在长度为1的桶有3个，超出了2个，因此要向上合并</p>
<p><img src="/2022/01/01/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%B5%81%E7%AE%97%E6%B3%95%E8%A1%A5%E5%85%85/4.png"></p>
<ul>
<li>当到达了三个数据 101</li>
</ul>
<p><img src="/2022/01/01/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%B5%81%E7%AE%97%E6%B3%95%E8%A1%A5%E5%85%85/5.png"></p>
<p>这时候，我们发现，合并了两个长度为1的桶，有3个长度为2的桶；合并了两个长度为2的桶，就有3个长度为4的桶；合并了两个长度为4的桶，有三个长度为8的桶。</p>
<p>最终，我们得到下图：</p>
<p><img src="/2022/01/01/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%B5%81%E7%AE%97%E6%B3%95%E8%A1%A5%E5%85%85/7.png"></p>
<h4 id="估计"><a href="#估计" class="headerlink" title="估计"></a>估计</h4><p>最后，我们该怎么利用计数桶去怎么去估计1的个数？</p>
<ol>
<li>我们可以叠加滑动窗口中的桶的大小，除了最后一个桶，因为最后一个桶有一部分已经滑出窗口外了</li>
<li>因此，我们可以近似地认为最后这个桶(也是最大的桶)的大小变为原来的$\frac{1}{2}$ ,并加到结果中去</li>
</ol>
<p>用上面那个例子来估计，滑动窗口中，对1的个数的估计为：1+2+4+8+16+16/2 = 39个</p>
<p>因为一共有 $O(logn)$ 个桶，因此算法的时间复杂度也是 $O(\log n)$</p>
<h4 id="精度证明"><a href="#精度证明" class="headerlink" title="精度证明"></a>精度证明</h4><p>那么为什么DIGM算法，它的估算误差一定是小于50%的呢？</p>
<p>我们假设最后的桶的大小是 $2^r$ ，那么我们在加完前面的桶之后，最后要加上的size = $2^{r-1}$</p>
<p>如果这个桶没滑出去，刚好在窗口末尾停下了，那么我们就相当于少了了 $2^{r-1}$  </p>
<p>如果这个桶基本全滑出去了，在窗口内可能只留了1个数字，那么我们就相当于多了$2^{r-1}$  </p>
<p>但是，我们把之前的窗口全加起来： $1+2+4\cdots+2^{r-1} = 2^{r}-1$ ，他肯定是大于 等于$2^{r-1}$ 的，因此这个误差$2^{r-1}$ 肯定是小于50%的。</p>
<h4 id="Extension"><a href="#Extension" class="headerlink" title="Extension"></a>Extension</h4><p>现在，给出一个可以进一步削弱误差的方法。</p>
<p>除了第一个和最后一个桶之外，其余的桶，可以将数量维持在：r-1 个或者 r 个, (r &gt; 2)</p>
<p>这时候，这个算法的空间复杂度会变成 $O(r\log n)$ 但是误差率会从 50% 变成 $O(\frac{1}{r})$</p>
<p>此外，除了用来技术0.1，还可以用来维持一个平均值：</p>
<p><img src="/2022/01/01/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%B5%81%E7%AE%97%E6%B3%95%E8%A1%A5%E5%85%85/8.png"></p>
<p>但是，这个算法只能进行一些简单的功能计算，要求桶内的值必须有可加性，因此推广性比较差</p>
<h2 id="Counting-Distinct-Elements"><a href="#Counting-Distinct-Elements" class="headerlink" title="Counting Distinct Elements"></a>Counting Distinct Elements</h2><p>给定一个数据流，我们来统计这个数据流中一共出现过多少不同的元素。</p>
<p>比如说，现在有一个集合，然后过来一个数据流，我们要统计多少这个集合的元素在这个数据流中出现了，多少没有出现。</p>
<p>还有其他应用场景：</p>
<ul>
<li>一个网页中出现了多少个不一样的词，词典是固定的，但词的分布是不一样的</li>
<li>一周之内，用户总共访问了多少个不同的网站</li>
</ul>
<p>一个很简单的方法就是：维护一个哈希表，然后过来一个数据我们映射一个数据，最后看哈希表中有哪些数据。但问题也是类似的，哈希表的大小事$O(n)$ 级别的，当数据流非常大的时候，这个哈希表是很难维护的。</p>
<p>因此，我们要考虑一种新的数据流算法</p>
<h3 id="Flajolet-Martin-Approach"><a href="#Flajolet-Martin-Approach" class="headerlink" title="Flajolet-Martin Approach"></a>Flajolet-Martin Approach</h3><p>FM 算法设计了一种空间复杂度为$O(\log_2(N))$  的算法</p>
<p>在这个算法中，对于长度为N的数据流，我们将其映射到 长度为$\log_2(N)$ 的哈希表中。</p>
<p>举例来说，给定序列{e1, e2, e3, e2}，独立元素数目N = 3。这里哈希数组的长度为$\log_2(4) = 2$ </p>
<p>假设给定哈希函数H(e)，有：</p>
<p>H(e1) = 00，TailZero(H(e1)) = 0</p>
<p>H(e2) = 01，TailZero(H(e2)) = 0</p>
<p>H(e3) = 10 ，TailZero(H(e3)) =1</p>
<p>第1步，将Max初始化为0；</p>
<p>第2步，对于序列中第1项e1，计算TailZero(H(e1)) = 0 </p>
<p>第3步，对于序列中第2项e2，计算TailZero(H(e2)) = 0  </p>
<p>第4步，对于序列中第3项e3，计算TailZero(H(e3)) = 1&gt; Max, 更新Max；</p>
<p>第5步，对于序列中第4项e2，计算TailZero(H(e2)) =0</p>
<p>第6步，估计独立元素数目为 $\hat N = 2^{\max} = 2^1 = 2$。</p>
<p>在这个简单例子中，实际值 $N = 3$，估计值$ \hat N =2$ </p>
<p>在实际应用中，为了减小误差，提高精度，我们通常采用一系列的哈希函数$H_1(e), H_2(e), H_3(e)$，计算一系列的Max值$\max_1,\max_2,\max_3$，从而估算一系列的估计值$2^{\max_1}, 2^{\max_2}, 2^{\max_3}$，最后进行综合得到最终的估计值。具体做法是：首先设计A*B个互不相同的哈希函数，分成A组，每组B个哈希函数；然后利用每组中的B个哈希函数计算出B个估计值;接着求出B个估计值的算术平均数为该组的估计值；最后选取各组的估计值的中位数作为最终的估计值。</p>
<p>举例来说，对于序列S，使用3*4 = 12个互不相同的哈希函数H(e)，分成3组，每组4个哈希函数，使用12个H(e)估算出12个估计值： </p>
<h2 id="Computing-Moments"><a href="#Computing-Moments" class="headerlink" title="Computing Moments"></a>Computing Moments</h2><p>首先给出Moments 的概念</p>
<p>假设数据流是由一些数字构成的，$m_i$ 代表元素i 在流中出现的次数，那么</p>
<p>$k^{th}$ Moment 就是：</p>
<script type="math/tex; mode=display">
\sum_{i\in A} (m_i)^k</script><p>刚才我们做的 FM 算法，就是$k^0$ moment</p>
<p>$k^0$ moment:  不同元素的数量</p>
<p>$k^1$ moment: 元素数量的计算，也就是数据流的长度N</p>
<p>$k^2$ moment = suprise number S : 衡量分布的不均匀程度</p>
<p>这里重点考虑 $k^2$ moment</p>
<p>比如说数据流A、B的长度为100，一共出现了11个不同的元素</p>
<p>数据流A各个元素的计数：10,9,9,9 ,9,9,9, 9,9,9,9 那么  $k^2 $ moment = 910</p>
<p>数据流B各个元素的计数：90,1,1,1,1,1,1,1,1,1,1 那么  $k^2 $ moment = 8110</p>
<h3 id="AMS-Method"><a href="#AMS-Method" class="headerlink" title="AMS Method"></a>AMS Method</h3><p>AMS 方法可以对所有moment的值进行一个无偏估计，这里就只针对 $k^2$ moment</p>
<p>我们对于一个变量 $X$</p>
<ul>
<li>用 $X.{el}$ </li>
<li>用 $X.val$ </li>
</ul>
<h2 id="Counting-Itemsets"><a href="#Counting-Itemsets" class="headerlink" title="Counting Itemsets"></a>Counting Itemsets</h2>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/7/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/%5Bobject%20Object%5D"
                alt="Jason" />
            
              <p class="site-author-name" itemprop="name">Jason</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20fa%20fa-archive">
              
                  <span class="site-state-item-count">435</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">61</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="true"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
 <!--
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>







-->
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>




















  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v="></script>

  <script type="text/javascript" src="/js/src/motion.js?v="></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v="></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
