<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=">


  <link rel="mask-icon" href="/images/logo.svg?v=" color="#222">














<meta property="og:type" content="website">
<meta property="og:title" content="Jason‘s Blog">
<meta property="og:url" content="https://jasonxqh.github.io/page/27/index.html">
<meta property="og:site_name" content="Jason‘s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '',
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    fancybox: false,
    tabs: ,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: 'undefined',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>







  <title>Jason‘s Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', '[object Object]', 'auto');
  ga('send', 'pageview');
</script>





<meta name="generator" content="Hexo 4.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">
  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
<a href="https://github.com/JasonXQH/JasonXQH.github.io" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jason‘s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/%20" rel="section">
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/" itemprop="url">常数项级数的审敛法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-26T23:07:13+08:00">
                2020-05-26
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-09-07T23:01:20+08:00">
                2020-09-07
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="常数项级数的审敛法"><a href="#常数项级数的审敛法" class="headerlink" title="常数项级数的审敛法"></a>常数项级数的审敛法</h1><h2 id="正向级数及其审敛法"><a href="#正向级数及其审敛法" class="headerlink" title="正向级数及其审敛法"></a>正向级数及其审敛法</h2><p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/1.png" style="zoom:150%;"></p>
<h3 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h3><p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/2.png" style="zoom: 50%;"></p>
<h3 id="定理2（比较审敛法）"><a href="#定理2（比较审敛法）" class="headerlink" title="定理2（比较审敛法）"></a>定理2（比较审敛法）</h3><p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/3.png" style="zoom: 50%;"></p>
<p>注意判断什么是强级数，什么是弱级数</p>
<h3 id="定理3（比较审敛法的极限形式）"><a href="#定理3（比较审敛法的极限形式）" class="headerlink" title="定理3（比较审敛法的极限形式）"></a>定理3（比较审敛法的极限形式）</h3><p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/9.png" style="zoom: 50%;"></p>
<p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/10.png" style="zoom: 50%;"></p>
<p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/6.png" style="zoom: 50%;"></p>
<h3 id="定理4-（D’alembert-判别法）"><a href="#定理4-（D’alembert-判别法）" class="headerlink" title="定理4 （D’alembert 判别法）"></a>定理4 （D’alembert 判别法）</h3><p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/13.png" style="zoom: 67%;"></p>
<p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/14.png" style="zoom: 60%;"></p>
<h3 id="定理5（Cauchy判别法）"><a href="#定理5（Cauchy判别法）" class="headerlink" title="定理5（Cauchy判别法）"></a>定理5（Cauchy判别法）</h3><p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/16.png" style="zoom: 60%;"></p>
<p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/20.png" style="zoom: 60%;"></p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="例一："><a href="#例一：" class="headerlink" title="例一："></a>例一：</h4><p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/4.png" style="zoom: 50%;"></p>
<p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/5.png" style="zoom: 50%;"></p>
<h4 id="例二："><a href="#例二：" class="headerlink" title="例二："></a>例二：</h4><p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/8.png" style="zoom: 60%;"></p>
<h4 id="例三："><a href="#例三：" class="headerlink" title="例三："></a>例三：</h4><p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/11.png" style="zoom: 60%;"></p>
<h4 id="例四："><a href="#例四：" class="headerlink" title="例四："></a>例四：</h4><p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/12.png" style="zoom: 60%;"></p>
<h4 id="例五："><a href="#例五：" class="headerlink" title="例五："></a>例五：</h4><p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/15.png" style="zoom: 60%;"></p>
<h4 id="例六："><a href="#例六：" class="headerlink" title="例六："></a>例六：</h4><p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/21.png" style="zoom: 60%;"></p>
<h4 id="例七："><a href="#例七：" class="headerlink" title="例七："></a>例七：</h4><p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/33.png" style="zoom: 60%;"></p>
<h4 id="例八"><a href="#例八" class="headerlink" title="例八"></a>例八</h4><p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/34.png" style="zoom: 60%;"></p>
<h4 id="例九"><a href="#例九" class="headerlink" title="例九"></a>例九</h4><p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/35.png" style="zoom: 60%;"></p>
<h3 id="解题注意"><a href="#解题注意" class="headerlink" title="解题注意"></a>解题注意</h3><p>分母中有n，或者级数中有sinn，tann，log(1+n) (n趋向于0)这类可以等价无穷小替换</p>
<h4 id="什么时候该用比较审敛法？"><a href="#什么时候该用比较审敛法？" class="headerlink" title="什么时候该用比较审敛法？"></a>什么时候该用比较审敛法？</h4><p> 且与 调和级数，p级数相比为常数（当然存在0:0的话$v_n$收敛 $u_n$也收敛，或者无穷：无穷的话$v_n$发散，$u_n$发散)</p>
<p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/38.png" style="zoom: 80%;"></p>
<p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/40.png" style="zoom: 100%;"></p>
<h4 id="什么时候该用比值审敛法？"><a href="#什么时候该用比值审敛法？" class="headerlink" title="什么时候该用比值审敛法？"></a>什么时候该用比值审敛法？</h4><p>当级数为分子分母形式，分子分母多为阶乘，幂函数。且 $\frac{u_{n+1}}{u_n}$ 是一个不为1 的常数，那么就可以用了</p>
<p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/37.png" style="zoom: 80%;"></p>
<p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/41.png" style="zoom: 100%;"></p>
<h4 id="什么时候该用根值审敛法？"><a href="#什么时候该用根值审敛法？" class="headerlink" title="什么时候该用根值审敛法？"></a>什么时候该用根值审敛法？</h4><p>分子分母为$a^n$ 的形式，这样 $\sqrt[n] n$ 刚好就可以把这个n去掉</p>
<p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/36.png" style="zoom: 100%;"></p>
<p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/41.png" style="zoom: 100%;"></p>
<h2 id="书本例题"><a href="#书本例题" class="headerlink" title="书本例题"></a>书本例题</h2><p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/1.jpg" style="zoom: 80%;"></p>
<p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/2.jpg" style="zoom: 80%;"></p>
<p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/3.jpg" style="zoom: 80%;"></p>
<p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/4.jpg" style="zoom: 80%;"></p>
<p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/5.jpg" style="zoom: 80%;"></p>
<h2 id="交错级数及其审敛法"><a href="#交错级数及其审敛法" class="headerlink" title="交错级数及其审敛法"></a>交错级数及其审敛法</h2><p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/23.png" style="zoom: 100%;"></p>
<h3 id="定理6"><a href="#定理6" class="headerlink" title="定理6"></a>定理6</h3><p>这里的$u_n$ 是没有符号的</p>
<p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/22.png" style="zoom: 60%;"> </p>
<h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><h4 id="例一：-1"><a href="#例一：-1" class="headerlink" title="例一："></a>例一：</h4><p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/25.png" style="zoom: 60%;"></p>
<p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/24.png" style="zoom: 65%;"></p>
<h2 id="绝对收敛与条件收敛"><a href="#绝对收敛与条件收敛" class="headerlink" title="绝对收敛与条件收敛"></a>绝对收敛与条件收敛</h2><p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/26.png" style="zoom: 65%;"></p>
<p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/27.png" style="zoom: 60%;"></p>
<h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/28.png" style="zoom: 75%;"></p>
<p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/29.png" style="zoom: 60%;"></p>
<h3 id="解题技巧"><a href="#解题技巧" class="headerlink" title="解题技巧"></a>解题技巧</h3><p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/39.png" style="zoom: 80%;"></p>
<h2 id="绝对收敛级数的性质"><a href="#绝对收敛级数的性质" class="headerlink" title="*绝对收敛级数的性质"></a>*绝对收敛级数的性质</h2><p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/30.png" style="zoom: 60%;"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/31.png" style="zoom: 60%;"></p>
<p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/32.png" style="zoom: 60%;"> </p>
<h3 id="答题格式："><a href="#答题格式：" class="headerlink" title="答题格式："></a>答题格式：</h3><p>$\sum_{n=1}^{\infty}原级数$    </p>
<p>$u<em>n\geq u</em>{n+1} &gt;0$  ?  $\lim\limits<em>{n-&gt;\infty}u_n=0$ ? =&gt; <strong>根据 Leibniz 判别法</strong>，交错级数 $\sum</em>{n=1}^{\infty}原级数$   收敛</p>
<p>因为 $\sum<em>{n=1}^{\infty}|原级数|=\sum</em>{n=1}^{\infty}新级数$   </p>
<p><strong>根据比较、比值、根植判别法</strong>判别新级数是否收敛。如果收敛，那么原级数就是绝对收敛；如果发散，原级数就是条件收敛</p>
<p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/11.jpg" style="zoom: 80%;"></p>
<p><img src="/2020/05/26/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0%E7%9A%84%E5%AE%A1%E6%95%9B%E6%B3%95/12.jpg" style="zoom: 80%;"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/26/OOP-in-JavaScript/" itemprop="url">OOP-in-JavaScript</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-26T00:06:10+08:00">
                2020-05-26
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-07-07T22:27:04+08:00">
                2020-07-07
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="OOP-in-JavaScript"><a href="#OOP-in-JavaScript" class="headerlink" title="OOP-in-JavaScript"></a>OOP-in-JavaScript</h1><p>这篇博客我们来谈谈JavaScript 面向对象编程</p>
<p>这是为了给期末大作业打下基础，因为我打算用react来实现前端框架。而react是OOP的典形应用之一</p>
<p>学习资料：</p>
<p><a href="https://codewithmosh.com/p/object-oriented-programming-in-javascript" target="_blank" rel="noopener">Mosh老师的OOP in JavaScript</a></p>
<p><a href="https://www.bilibili.com/video/BV1gb411w7eW?p=1" target="_blank" rel="noopener">B站搬运视频</a></p>
<h2 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h2><h3 id="Object-Literals"><a href="#Object-Literals" class="headerlink" title="Object Literals"></a>Object Literals</h3><p>首先来看看声明一个类，可以用的关键词 var let const</p>
<ul>
<li><p><strong>var</strong>定义的变量，作用域是整个封闭函数，是全域的；<strong>let</strong>定义的变量，作用域是在块级或者字块中；</p>
</li>
<li><p>变量提升：不论通过var声明的变量处于当前作用于的第几行，都会提升到作用域的最顶部。 而let声明的变量不会在顶部初始化，凡是在let声明之前使用该变量都会报错（引用错误ReferenceError）；</p>
</li>
<li><p>只要块级作用域内存在let，它所声明的变量就会绑定在这个区域；</p>
</li>
<li><p>let不允许在相同作用域内重复声明（报错同时使用var和let，两个let）。</p>
</li>
<li><p><strong>const</strong>用来专门声明一个常量，它跟let一样作用于块级作用域，没有变量提升，重复声明会报错，不同的是<strong>const声明的常量不可改变，声明时必须初始化（赋值）</strong></p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> circle = &#123;</span><br><span class="line">    radius:<span class="number">1</span>,</span><br><span class="line">    location:&#123;</span><br><span class="line">        x: <span class="number">1</span>,</span><br><span class="line">        y: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    draw:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'draw'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//输出 draw</span></span><br></pre></td></tr></table></figure>
<h3 id="Factories-工厂模式"><a href="#Factories-工厂模式" class="headerlink" title="Factories 工厂模式"></a>Factories 工厂模式</h3><p>但是像上面那样生成一个对象的话，如果要声明很多对象（具有相同的性质），每个对象中又有很多方法的话。实在是太麻烦了，所以我们要用工厂模式创建。</p>
<p>对象定义规则：</p>
<p>冒号和属性值之间要用空格</p>
<p>我们把方法也当作一个对象的属性，所以定义方法的时候为 名字: function(){}</p>
<p>比如draw: function(){} 其实相当于function draw(){}，就是在对象直接量中定义的函数的时候要用到这个写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCircle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        radius,	<span class="comment">// es6 的新语法，如果属性名和传入变量名称一致，不需要再做赋值，直接等于即可</span></span><br><span class="line">        location: &#123;</span><br><span class="line">            x:<span class="number">1</span>,</span><br><span class="line">            y:<span class="number">1</span></span><br><span class="line">        &#125;,	<span class="comment">//属性和属性之间要用逗号断开</span></span><br><span class="line">        draw: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'draw'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> circle = createCircle(<span class="number">1</span>);</span><br><span class="line">circle.draw();</span><br></pre></td></tr></table></figure>
<h3 id="Constructors-构造函数"><a href="#Constructors-构造函数" class="headerlink" title="Constructors 构造函数"></a>Constructors 构造函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this'</span>,<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    <span class="keyword">this</span>.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'draw'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> another = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果 const another = Circle(1);</span></span><br><span class="line"><span class="comment">控制台输出：这显然变成了一个Window 对象</span></span><br><span class="line"><span class="comment">this Window &#123;parent: Window, opener: null, top: Window, length: 0, frames: Window, …&#125;</span></span><br><span class="line"><span class="comment">如果 const another = new Circle(1);</span></span><br><span class="line"><span class="comment">他就是一个Object对象</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>我们既可以用工厂模式创建对象，也可以用构造函数来创建对象，我们对两者都需要熟悉</p>
<p>对于构造函数创建对象这种方法，我们一定需要 new + 构造函数</p>
<p>对于工厂模式创建方法，直接调用创建函数即可</p>
<h3 id="Constructor-Property"><a href="#Constructor-Property" class="headerlink" title="Constructor Property"></a>Constructor Property</h3><p><img src="/2020/05/26/OOP-in-JavaScript/1.png" style="zoom:100%;"></p>
<p>我们看到由两种不同函数构造出来的两个对象的constructor也是不一样的，由构造函数构造出来的another对象是利用自己的构造函数Circle()</p>
<p>由工厂模式构造出来的circle函数，构造函数时 Object() 也就是说createCircle函数会调用new Object()并返回</p>
<h3 id="Functions-are-Objects"><a href="#Functions-are-Objects" class="headerlink" title="Functions are Objects"></a>Functions are Objects</h3><p>比较难理解的就是JavaScript中的类是通过函数的形式存在的，可以说函数即对象。</p>
<p><img src="/2020/05/26/OOP-in-JavaScript/2.png" style="zoom:100%;"></p>
<p>对上面Circle的构造函数来说 ，我们显示了他几个属性，我们同样看出来了，Circle函数是通过Function()这个构造函数构造出来的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this'</span>,<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    <span class="keyword">this</span>.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'draw'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AND</span></span><br><span class="line">    <span class="keyword">const</span> Circle1 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'radius'</span>,<span class="string">`</span></span><br><span class="line"><span class="string">       this.radius = radius;</span></span><br><span class="line"><span class="string">    this.draw = function () &#123;</span></span><br><span class="line"><span class="string">        console.log('draw')</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    `</span>);</span><br><span class="line"><span class="comment">//这两个函数表达的意思是一样的，只不过Circle自己调用了Function(),而Circle1则手动调用了Function()</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/26/OOP-in-JavaScript/3.png" style="zoom:200%;"></p>
<p>函数（类）的一些方法</p>
<h4 id="call-和-apply"><a href="#call-和-apply" class="headerlink" title="call 和 apply"></a>call 和 apply</h4><ul>
<li>call()和apply()的第一个实参都为this的值，即使传入的实参是原始值或者null或者undefined</li>
<li>call()，第一个参数之后的所有实参是要传入待调用函数的值；</li>
<li>apply()实参都放到一个数组</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this'</span>,<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    <span class="keyword">this</span>.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'draw'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Circle.call(&#123;&#125;,<span class="number">1</span>)			 	<span class="comment">//把1传给一个空对象</span></span><br><span class="line"><span class="keyword">const</span> another =<span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Value-vs-Reference-Types"><a href="#Value-vs-Reference-Types" class="headerlink" title="Value vs Reference Types"></a>Value vs Reference Types</h3><p><img src="/2020/05/26/OOP-in-JavaScript/4.png" style="zoom: 50%;"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> y = x;</span><br><span class="line">x=<span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/26/OOP-in-JavaScript/5.png" style="zoom:100%;"></p>
<p>显示如上图，我们可以看到这和python是不一样的。当我们声明两个变量x,y的时候。x和y是相互独立的</p>
<p>但是当我们这样写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = &#123;<span class="attr">value</span>: <span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> y =  x;</span><br><span class="line">x.value = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/26/OOP-in-JavaScript/8.png" style="zoom:100%;"></p>
<p>就会这样显示，这是因为什么呢？如下图</p>
<p><img src="/2020/05/26/OOP-in-JavaScript/6.png" style="zoom: 50%;"></p>
<p><img src="/2020/05/26/OOP-in-JavaScript/7.png" style="zoom: 50%;"></p>
<p>这是因为当我们声明一个对象的时候，value:10 并没有存储在这个变量x里，而是存储在一段内存当中，而变量x存储的只是那段内存的地址。所以当令y = x的时候，事实上赋值给y的是一段地址，而非值。所以导致x,y都指向了同一段内存。自然，当value的值改变的时候，x，y都跟着改变了</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>就是：Primitives(基本类型) are copied by their Value，Objects(对象) are copied by their reference</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increase</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">    number++;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">&#125;</span><br><span class="line">increase(number);</span><br><span class="line"><span class="built_in">console</span>.log(number);			<span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(increase(number));	<span class="comment">// 11</span></span><br></pre></td></tr></table></figure>
<p>从这里我们可以很清楚的看见，当调用increase(number)的时候，传入的number只是把value值赋给了函数中的number的值，但是在外面的number还是10.</p>
<p>如果把返回值输出的话，可以得到11，但这任然没有改变number = 10</p>
<p>如果我们把number换成一个对象，又会有什么变化呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> number = &#123;<span class="attr">value</span> :<span class="number">10</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increase</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    obj.value++;</span><br><span class="line">&#125;</span><br><span class="line">increase(number);</span><br><span class="line"><span class="built_in">console</span>.log(number.value)<span class="comment">// 11</span></span><br></pre></td></tr></table></figure>
<p>我们得到这样的结果，原理如下，我们传进去一个number对象，然后再这个increase函数里把这个对象的地址付给了obj，随后让obj的value属性+1，因为obj和number指向的是同一块内存，所以在外面number.value 也会相应的变化</p>
<h3 id="Adding-or-Removing-Properties"><a href="#Adding-or-Removing-Properties" class="headerlink" title="Adding or Removing Properties"></a>Adding or Removing Properties</h3><p>由构造或者工厂模式创建的对象，都是动态对象，我们可以在这个对象中添加或者删除属性。</p>
<h3 id="运用-的方法"><a href="#运用-的方法" class="headerlink" title="运用 . 的方法"></a>运用 . 的方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this'</span>,<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    <span class="keyword">this</span>.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'draw'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle = <span class="keyword">new</span> Circle(<span class="number">10</span>);		</span><br><span class="line">circle.location = &#123; <span class="attr">x</span>:<span class="number">1</span> &#125;; 		<span class="comment">//利用点的方式添加属性</span></span><br><span class="line"><span class="keyword">delete</span> circle.location;			<span class="comment">//delete+ . 来删除属性</span></span><br></pre></td></tr></table></figure>
<h3 id="运用方括号"><a href="#运用方括号" class="headerlink" title="运用方括号"></a>运用方括号</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> propertyName = <span class="string">'location'</span></span><br><span class="line">circle[propertyName] = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>方括号的操作比点要麻烦一点，但是可以动态访问</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> propertyName = <span class="string">'center location'</span></span><br><span class="line">circle.center location</span><br></pre></td></tr></table></figure>
<p>而且当遇到属性名称中间有特殊符号或者空格的时候，不能用点来访问，这时候需要用方括号来访问</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> circle[location];</span><br></pre></td></tr></table></figure>
<p>删除的时候也只需要在方括号中写上属性名称即可</p>
<h3 id="Enumerating-Properties"><a href="#Enumerating-Properties" class="headerlink" title="Enumerating Properties"></a>Enumerating Properties</h3><p>使用  for…in..遍历，可以打印出所有对象中的 属性，方法 的索引<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this'</span>,<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    <span class="keyword">this</span>.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'draw'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle = <span class="keyword">new</span> Circle(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> circle)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印 radius和draw</span></span><br></pre></td></tr></table></figure><br>如果希望直接输出索引存储的值，或者调用方法的话，可以这样写console.log(key,circle[key] );<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> circle)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key,circle[key] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="/2020/05/26/OOP-in-JavaScript/9.png" style="zoom: 90%;"></p>
<p>如果只想打印属性，需要在前面利用typeof做一个判断<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> circle)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> circle[key]!== <span class="string">'function'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(key,circle[key] );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//只打印属性，不打印方法</span></span><br></pre></td></tr></table></figure><br>如果只想输出索引，以数组的形式呈现，那么利用Object对象的key方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(circle);</span><br><span class="line"><span class="built_in">console</span>.log(keys)</span><br><span class="line"><span class="comment">// 输出["radius","draw"],无法区分是属性还是方法</span></span><br></pre></td></tr></table></figure><br>可以利用 in 操作符判断一个对象中是否有该属性或方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">'radius'</span> <span class="keyword">in</span> circle)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Circle has a radius'</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="Abstraction"><a href="#Abstraction" class="headerlink" title="Abstraction"></a>Abstraction</h3><p><strong>Hide the details, Show the essentials</strong></p>
<p>我们应该隐藏我们不想让外界访问到的比较复杂的和细节的部分，我们只要显示我们认为必要的部分。就比如说DVD，dvd含有非常复杂的线路板，但是他只给我们几个按钮（公共接口)来操作，这就是我们要对对象做的事情</p>
<p>如果不这样做，外部一直调用我们对象中的方法，那么对象中的一个小小的改变，外面很多的代码都要相应的修改，这是很麻烦的事情</p>
<h3 id="Private-Properties-and-Methods"><a href="#Private-Properties-and-Methods" class="headerlink" title="Private Properties and Methods"></a>Private Properties and Methods</h3><p>如何实现上面的目标，我们需要用私有属性和私有方法。</p>
<p>那么和C++中的直接放在private:中不同，和python中两根下划线或者@property也不一样，因为JavaScript当中函数和对象是一个定义，所以我们只要把 这个方法或者属性从对象中移走，把它变成函数当中的属性或者方法就可以了。</p>
<p>也就是说，我们只要简单的把 this.属性/方法 替换成 let 属性/方法，就能实现隐藏</p>
<p>在这里我们一定要用let，因为上文说过，let声明的变量或者方法只在这个语句块中实现。但是var声明的是全局变量。所以当我们使用let声明变量和方法的时候，出了这个函数，两者就失效了。这达到了我们Abstraction的目的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    <span class="keyword">let</span> computeOptimumlocation = <span class="function"><span class="keyword">function</span> (<span class="params">factor</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> defaultLocation= &#123;<span class="attr">x</span>:<span class="number">0</span>,<span class="attr">y</span>:<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">this</span>.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> x,y;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'draw'</span>)</span><br><span class="line">        computeOptimumlocation(<span class="number">0.1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不要把闭包和作用域混淆。作用域只是临时的，但是闭包是永恒的。 </p>
<p>就像上面在draw方法中的x,y，每次调用draw方法的时候，x,y都会重新被创建，然后当draw结束以后，两个x,y就死掉了。</p>
<p>但是闭包不一样，在调用好computeOptimumlocation之后，computeOptimumlocation任然存在在函数当中 。而且他们会保持自己的状态，因为他们是draw方法的闭包</p>
<p>现在，在外面，是没有办法访问defaultLocation和computeOptimumlocation这两个属性和方法的！</p>
<p>像上面的写法也有缺陷，因为严格意义上let声明的属性和方法并不是Circle对象的成员，他们只是Circle函数内部的局部变量而已。如果从面向对象的角度，我们仍然可以称他们为Circle对象的私有成员。因为我们没有办法去修改或者读取它</p>
<h3 id="Getters-and-Setters"><a href="#Getters-and-Setters" class="headerlink" title="Getters and Setters"></a>Getters and Setters</h3><p>那么我们怎么样能够在外面读取对象中的私有属性呢？(只读不写)</p>
<p>一般的，我们可以定义一个方法，然后方法中返回这个私有属性，但是这样在外面调用的时候，显得很麻烦，因为要调用一个方法，再返回一个属性。</p>
<p>所以我们可以用 Object.defineProperties()或者Object.defineProperty()这个方法（一个和多个属性的区别）这个方法的用处有三个参数，第一个参数是this，第二个参数是添加属性的名称，第三个参数就是一个对象，里面存放键值对， get:function(){} 和 set:function(){}</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    <span class="keyword">let</span> computeOptimumlocation = <span class="function"><span class="keyword">function</span> (<span class="params">factor</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> defaultLocation= &#123;<span class="attr">x</span>:<span class="number">0</span>,<span class="attr">y</span>:<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">this</span>.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'draw'</span>)</span><br><span class="line">        computeOptimumlocation(<span class="number">0.1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>,<span class="string">'defaultLocation'</span>,&#123;</span><br><span class="line">       <span class="keyword">get</span>: function () &#123;</span><br><span class="line">            <span class="keyword">return</span> defaultLocation;</span><br><span class="line">       &#125;,</span><br><span class="line">       <span class="keyword">set</span>: function (value) &#123;</span><br><span class="line">           <span class="keyword">if</span>(!value.x||!value.y)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Invalid location.'</span>)</span><br><span class="line">           defaultLocation = value;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle = <span class="keyword">new</span> Circle(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(circle.defaultLocation);</span><br><span class="line">circle.defaultLocation = &#123;<span class="attr">x</span>:<span class="number">2</span>,<span class="attr">y</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(circle.defaultLocation);</span><br></pre></td></tr></table></figure>
<p>get就是我们读取信息的方法，那么set就是我们设置这个私有属性的方法（我们如果不希望外界修改，就不要写set了）</p>
<p>当我们想要显示这个信息的时候呢console.log(circle.defaultLocation)</p>
<p><img src="/2020/05/26/OOP-in-JavaScript/11.png" style="zoom: 90%;"></p>
<p>如果我们输出的value是不合法的（比如说只输入了一个）那么就会报错。</p>
<h3 id="Exercise-Stopwatch"><a href="#Exercise-Stopwatch" class="headerlink" title="Exercise- Stopwatch"></a>Exercise- Stopwatch</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StopWatch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> startTime,stopTime,running,duration = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.start = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(running)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Stopwatch has already started!'</span>);</span><br><span class="line">        running= <span class="literal">true</span>;</span><br><span class="line">        startTime =<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.stop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!running)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Stopwatch has already stopped!'</span>);</span><br><span class="line">        running = <span class="literal">false</span>;</span><br><span class="line">        stopTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="keyword">const</span> seconds = (stopTime.getTime()-startTime.getTime())/<span class="number">1000</span>;</span><br><span class="line">        <span class="comment">//得到的是毫秒数，所以要除以1000</span></span><br><span class="line">        duration +=seconds;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.reset = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        startTime = <span class="literal">null</span>;</span><br><span class="line">        stopTime = <span class="literal">null</span>;</span><br><span class="line">        running = <span class="literal">false</span>;</span><br><span class="line">        duration = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>,<span class="string">'duration'</span>,&#123;</span><br><span class="line">        <span class="keyword">get</span>: function () &#123;</span><br><span class="line">            <span class="keyword">return</span> duration;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Prototypes"><a href="#Prototypes" class="headerlink" title="Prototypes"></a>Prototypes</h2><h3 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h3><p><img src="/2020/05/26/OOP-in-JavaScript/12.png" style="zoom: 67%;"></p>
<p>有两种继承方式：Classical （类继承）和prototype（原型继承）</p>
<h3 id="Prototypes-and-Prototypical-Inheritance"><a href="#Prototypes-and-Prototypical-Inheritance" class="headerlink" title="Prototypes and Prototypical Inheritance"></a>Prototypes and Prototypical Inheritance</h3><p>在JavaScript中，没有类，只有对象。那么只有对象的话如何引入继承呢？</p>
<p>我们就把原来的shape看作是原型(prototype)，然后把属性和方法都放到这个原型中去。注意，原型其实就是一个一般的对象。每个对象(除了元对象)都会有原型</p>
<p>在Javascript中创建的对象直接或间接地继承自元对象（Object） ，元对象在JavaScript中是所有对象的根对象。Object对象没有原对象 </p>
<p><img src="/2020/05/26/OOP-in-JavaScript/14.png" style="zoom: 33%;"></p>
<p>在内存中，只有一个元对象</p>
<p><img src="/2020/05/26/OOP-in-JavaScript/16.png" style="zoom: 67%;"></p>
<p>当寻找一个方法的时候，JavaScript引擎会在这个对象里找，如果找不到，就到这个对象的原型对象去找，如果还是找不到，就继续沿着原型链往上找，一直找到元对象位置。这就是原型继承的工作原理</p>
<p>可以看到__proto__属性都是由一个对象指向一个对象，即指向它们的原型对象（也可以理解为父对象），那么这个属性的作用是什么呢？它的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（可以理解为父对象）里找，如果父对象也不存在这个属性，则继续往父对象的__proto__属性所指向的那个对象（可以理解为爷爷对象）里找，如果还没找到，则继续往上找…直到原型链顶端null（可以理解为原始人。。。），再往上找就相当于在null上取值，会报错（可以理解为，再往上就已经不是“人”的范畴了，找不到了，到此结束，null为原型链的终点），由以上这种通过__proto__属性来连接对象直到null的一条链即为我们所谓的原型链。</p>
<p> 其实我们平时调用的字符串方法、数组方法、对象方法、函数方法等都是靠__proto__继承而来的。</p>
<h3 id="Multilevel-Inheritance"><a href="#Multilevel-Inheritance" class="headerlink" title="Multilevel Inheritance"></a>Multilevel Inheritance</h3><p>比如我们声明一个数组对象myArray。数组对象myArray是继承自arrayBase（数组元对象）的</p>
<p><img src="/2020/05/26/OOP-in-JavaScript/17.png" style="zoom: 67%;"></p>
<p>我们看都在最后一行，这个数组元对象的原型对象是 ObjectBase（元对象）示意图如下：</p>
<p><img src="/2020/05/26/OOP-in-JavaScript/18.png" style="zoom: 33%;"></p>
<p>我们如果自己写一个构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    <span class="keyword">this</span>.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> x,y;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'draw'</span>)</span><br><span class="line">        computeOptimumlocation(<span class="number">0.1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> circle = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>那么所有这个构造函数构造出来的对象，都具有同一个原型。比如这里的circle对象的原型对象就是CircleBase，CircleBase也有一个元对象，就是ObjectBase</p>
<p><img src="/2020/05/26/OOP-in-JavaScript/19.png" style="zoom: 33%;"></p>
<h3 id="Property-Descriptors"><a href="#Property-Descriptors" class="headerlink" title="Property Descriptors"></a>Property Descriptors</h3><p>我们虽然可以在一个对象中调用它原型对象的方法或者属性，但是我们却无法通过Objec.keys()或者 for…in…这种方法遍历 <strong>元对象</strong> 的属性。但毕竟元对象是所有对象的根对象，为什么没有办法迭代遍历呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>:<span class="string">'Jason'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> objectBase = <span class="built_in">Object</span>.getPrototypeOf(person);</span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(objectBase,<span class="string">'toString'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(descriptor);</span><br></pre></td></tr></table></figure>
<p>在console中</p>
<p><img src="/2020/05/26/OOP-in-JavaScript/20.png" style="zoom: 100%;"></p>
<p>我们发现他的enumerable属性是false，也就是说这个toString方法，是不可以被枚举的。writable说明这个方法可以被重写</p>
<p>我们可以对自己创造的对象的属性进行属性的定义</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>:<span class="string">'Jason'</span>&#125;;</span><br><span class="line"> <span class="built_in">Object</span>.defineProperty(person,<span class="string">'name'</span>,&#123;</span><br><span class="line">     writable: <span class="literal">false</span></span><br><span class="line">     enumerable: <span class="literal">true</span></span><br><span class="line">     configurable:<span class="literal">false</span></span><br><span class="line"> &#125;);</span><br><span class="line"> person.name = <span class="string">'John '</span>;</span><br><span class="line"> <span class="built_in">console</span>.log(person.name)</span><br><span class="line"><span class="comment">//我们发现名字并没有发生改变</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(person));</span><br><span class="line"><span class="comment">// ["name"],因为我们设置了这个name属性是可迭代，可枚举的</span></span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(person));</span><br><span class="line"><span class="comment">// ["name"],因为configurable 为false，是不可以被删除的</span></span><br></pre></td></tr></table></figure>
<p>在默认情况下，所有属性都是可写可枚举可配置的</p>
<h3 id="Constructor-Prototypes"><a href="#Constructor-Prototypes" class="headerlink" title="Constructor Prototypes"></a>Constructor Prototypes</h3><p><a href="https://blog.csdn.net/cc18868876837/article/details/81211729?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">在这篇博客讲的很清楚</a></p>
<p><img src="/2020/05/26/OOP-in-JavaScript/21.png" style="zoom: 60%;"></p>
<p><strong>constructor 属性</strong>的含义就是<strong>指向该对象的构造函数</strong>，所有函数（此时看成对象了）最终的构造函数都指向<strong>Function</strong>。从上图中可以看出<strong>Function</strong>这个对象比较特殊，它的构造函数就是它自己（因为Function可以看成是一个函数，也可以是一个对象）</p>
<p><strong>prototype属性</strong>，别忘了一点 , 它是函数所独有的，它是从一个<strong>函数</strong>指向一个<strong>对象</strong>。它的含义是<strong>函数的原型对象</strong>，也就是这个函数（其实所有函数都可以作为构造函数）所创建的<strong>实例的原型对象</strong>，由此可知：f1.__proto__ === Foo.prototype，它们两个完全一样。</p>
<p>获得对象原型的方法是调用Object对象的getPrototypeOf() 方法</p>
<p>Object.prototype()是所有对象的爸爸</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Circle.prototype === circle.__proto__</span><br><span class="line"><span class="built_in">Array</span>.prototype === arr.__proto__</span><br><span class="line"><span class="keyword">let</span> x = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.prototype === x.__proto__</span><br></pre></td></tr></table></figure>
<h3 id="Prototype-vs-Instance-Members"><a href="#Prototype-vs-Instance-Members" class="headerlink" title="Prototype vs Instance Members"></a>Prototype vs Instance Members</h3><p><strong>js中可以说函数就是类，类就是函数。</strong></p>
<p>①<code>__proto__</code>和<code>constructor</code>属性是<strong>对象</strong>所独有的；② <code>prototype</code>属性是<strong>函数</strong>所独有的。但是由于JS中函数也是一种对象，所以函数也拥有<code>__proto__</code>和<code>constructor</code>属性，这点是致使我们产生困惑的很大原因之一。</p>
<p>从上面我们已经知道要给MyClss类的本身增加方法，需要讲方法定义在MyClass这个函数内部，这样的话，每声明一个新的实例，就会将MyClass本身复制一遍，这显然不是最优的做法。</p>
<p>既然不能将一个类（函数）所包含的方法都定义在函数的内部，那么，如何来给一个类添加方法呢？这就需要用到函数的prototype属性了。 </p>
<p>那prototype属性的作用又是什么呢？它的作用就是<strong>包含可以由特定类型的所有实例共享的属性和方法</strong>，也就是<strong>让该函数所实例化的对象们都可以找到公用的属性和方法</strong>。<strong>任何</strong>函数在创建的时候，其实会<strong>默认同时创建该函数的prototype对象。</strong></p>
<p>所以根据prototype的属性我们知道了，虽然新创建的对象可以使用它的构造函数所指向的prototype对象的属性和方法，但不能像构造函数那样直接调用prototype对象。</p>
<p>简而言之，就是如果我们使用函数的prototype对象来给函数添加方法，那么在创建一个新的对象的时候，并不会复制这个函数的所有方法，而是指向了这函数的所有方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line">Circle.prototype.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'draw'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> c1 = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> c2 = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//如下图，我们发现 c1,c2中并没有发现draw属性，但是c1,c2却可以调用draw属性</span></span><br><span class="line"><span class="comment">//因为draw已经在他们的原型对象里了</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/26/OOP-in-JavaScript/22.png" style="zoom: 60%;"></p>
<h3 id="Iterating-Instance-and-Prototype-Members"><a href="#Iterating-Instance-and-Prototype-Members" class="headerlink" title="Iterating Instance and Prototype Members"></a>Iterating Instance and Prototype Members</h3><p>Object.keys()只返回实例对象的成员</p>
<p>for…in .. () 返回所有可迭代可枚举的成员（在原型链上的）</p>
<p>hasOwnProperty(‘成员名字’)，判断该成员是继承而来的还是实例本省就有的</p>
<h3 id="Avoid-Extending-the-Built-in-Objects"><a href="#Avoid-Extending-the-Built-in-Objects" class="headerlink" title="Avoid Extending the Built-in Objects"></a>Avoid Extending the Built-in Objects</h3><p>我们不应该修改JavaScript中的 Built-in Objects，比如说在Array.prototype 或者 Object.prototype中加入新的方法或者修改原有的方法。因为以后引入的外部库可能也有相同名称的方法但是实现起来却完全不同</p>
<p>Don‘t modify objects you don’t OWN!</p>
<h3 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StopWatch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> startTime,stopTime,running,duration = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//把这些都设置成只读属性</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>,<span class="string">'duration'</span>,&#123;</span><br><span class="line">        <span class="keyword">get</span>: function () &#123;</span><br><span class="line">            <span class="keyword">return</span> duration;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>,<span class="string">'startTime'</span>,&#123;</span><br><span class="line">        <span class="keyword">get</span>: function () &#123;</span><br><span class="line">            <span class="keyword">return</span> startTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>,<span class="string">'stopTime'</span>,&#123;</span><br><span class="line">        <span class="keyword">get</span>: function () &#123;</span><br><span class="line">            <span class="keyword">return</span> stopTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>,<span class="string">'running'</span>,&#123;</span><br><span class="line">        <span class="keyword">get</span>: function () &#123;</span><br><span class="line">            <span class="keyword">return</span> running;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StopWatch.prototype.start = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.running)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Stopwatch has already started!'</span>);</span><br><span class="line">    running = <span class="literal">true</span>;</span><br><span class="line">    startTime =<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">&#125;;</span><br><span class="line">StopWatch.prototype.stop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.running)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Stopwatch has already stopped!'</span>);</span><br><span class="line">    running = <span class="literal">false</span>;</span><br><span class="line">    stopTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">const</span> seconds = (stopTime.getTime()-startTime.getTime())/<span class="number">1000</span>;</span><br><span class="line">    <span class="comment">//得到的是毫秒数，所以要除以1000</span></span><br><span class="line">    duration +=seconds;</span><br><span class="line">&#125;;</span><br><span class="line">StopWatch.prototype.reset = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.startTime = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.stopTime = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.running = <span class="literal">false</span>;</span><br><span class="line">    duration = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//这里要注意，duration前面不要加this,因为这duration作为对象来说是可读属性</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Prototypical-Inheritance"><a href="#Prototypical-Inheritance" class="headerlink" title="Prototypical Inheritance"></a>Prototypical Inheritance</h2><h3 id="1-Creating-Your-Own-Prototypical-Inheritance"><a href="#1-Creating-Your-Own-Prototypical-Inheritance" class="headerlink" title="1- Creating Your Own Prototypical Inheritance"></a>1- Creating Your Own Prototypical Inheritance</h3><p>现在比如说我们有一个圆的构造函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line">Circle.prototype.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Draw'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Circle.prototype.duplicate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Duplicate'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么如果我又想要一个Square 构造函数。又想保留这两个方法，我们是不是要重写？</p>
<p>其实不是，我们可以新建一个Shape 构造函数，再Shape.prototype 中添加这两个属性，然后再让Circle和Square继承Shape即可</p>
<p><img src="/2020/05/26/OOP-in-JavaScript/23.png" style="zoom: 33%;"></p>
<p>所以在这里，我们需要用到这个函数Object.create(proto)</p>
<p>返回值：一个新对象，带着指定的原型对象和属性。</p>
<p>也就是说命令一个Circle的原型对象，让他去等于一个新的，指向ShapeBase的对象，达到了继承的功能</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Circle.prototype = <span class="built_in">Object</span>.create(Shape.prototype)</span><br></pre></td></tr></table></figure>
<p>这里，我们令Shape.prototype作为Circle的原型对象，否则</p>
<p>Circle.prototype = Object.create(Object.prototype)，直接从元对象继承过来</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Shape.prototype.duplicate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Duplicate'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Circle.prototype = <span class="built_in">Object</span>.create(Shape.prototype);<span class="comment">//让Circle继承自Shape</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是在Circle的原型对象中添加方法</span></span><br><span class="line">Circle.prototype.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Draw'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/26/OOP-in-JavaScript/25.png" style="zoom: 100%;"></p>
<p>c是一个实例，这个实例中有一个radius =1 的属性。这个实例的原型是CircleBase对象</p>
<p>CircleBase对象中，我们有一个draw方法。</p>
<p>CircleBase也是继承来的，继承自ShapeBase对象，在ShapeBase对象中有duplicate和constructor这两个方法</p>
<p>CircleBase也是继承来的，继承自Object对象，也就是元对象。</p>
<h3 id="2-Resetting-the-Constructor"><a href="#2-Resetting-the-Constructor" class="headerlink" title="2- Resetting the Constructor"></a>2- Resetting the Constructor</h3><p>但是向上面那样的写法，我们发现Circle.prototype 没有了 constructor方法了 我们就没有办法通过new Circle(1)来创建一个Circle对象了</p>
<p>这时候如果我们这样写 new Circle.prototype.constructor(1);的话，我们发现是这样一个情况</p>
<p><img src="/2020/05/26/OOP-in-JavaScript/26.png" style="zoom: 150%;"></p>
<p>我们看到其实是创建出了一个Shape对象来，这是因为CircleBase并没有constructor,所以他按照原型链向上去找，在ShapeBase中找到了这个constructor方法，但这个方法是Shape的构造函数。所以构造了一个Shape对象出来。</p>
<p>所以，在继承的时候，我们除了需要Object.create()之外，我们还需要Circle.prototype.constructor = Circle;</p>
<p><img src="/2020/05/26/OOP-in-JavaScript/27.png" style="zoom: 150%;"></p>
<p>那么加上这句话，我们可以看到我们利用new Circle.prototype.constructor()或者直接new Circle()构造出来的，就是一个Circle对象了</p>
<h3 id="3-Calling-the-Super-Constructor"><a href="#3-Calling-the-Super-Constructor" class="headerlink" title="3- Calling the Super Constructor"></a>3- Calling the Super Constructor</h3><p>那么我如果在Shape中传入一个color，在Circle中传入一个radius，这样的话我可以直接在Circle构造函数中调用Shape() 方法吗？</p>
<p>这是不行的，因为我们直接调用Shape()而不写new的话，传入的color参数会直接放到window对象（全局对象）当中去，那么如果我们写 new Shape()这就是新建了一个对象，不是我们要的目的。</p>
<p>所以我们的要做的就是把Shape中的color值赋给this对象</p>
<p>利用 Shape.call(this, color) ，就可以对this对象调用Shape方法，并且把color赋值给this对象</p>
<p><img src="/2020/05/26/OOP-in-JavaScript/28.png" style="zoom: 100%;"></p>
<h3 id="4-Intermediate-Function-Inheritance"><a href="#4-Intermediate-Function-Inheritance" class="headerlink" title="4- Intermediate Function Inheritance"></a>4- Intermediate Function Inheritance</h3><p>如果我们要写多级继承或者一个原型对象产生多个子对象的时候，我们会产生很多这样的代码，既不美观又容易犯错，落下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Square.prototype = <span class="built_in">Object</span>.create(Shape.prototype);</span><br><span class="line">Square.prototype.constructor = Square;</span><br></pre></td></tr></table></figure>
<p>所以我们写一个函数来封装这个继承方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">Child,Parent</span>) </span>&#123;</span><br><span class="line">    Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype);</span><br><span class="line">    Child.prototype.constructor = Child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来用这个函数代替刚才的继承代码就好了！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extend(Circle,Shape);</span><br><span class="line">extend(Square,Shape);</span><br></pre></td></tr></table></figure>
<h3 id="5-Method-Overriding"><a href="#5-Method-Overriding" class="headerlink" title="5- Method Overriding"></a>5- Method Overriding</h3><p>在子类中重写基类的方法，重写一定要放在继承代码之后</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extend(Circle,Shape);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius,color</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line">Circle.prototype.duplicate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Duplicate Circle'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果我们想重写基类中的方法的同时也想调用基类中的方法 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Circle.prototype.duplicate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//调用call，传入this</span></span><br><span class="line">    Shape.prototype.duplicate.call(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Duplicate Circle'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/26/OOP-in-JavaScript/29.png" style="zoom: 100%;"></p>
<h3 id="6-Polymorphism多态"><a href="#6-Polymorphism多态" class="headerlink" title="6- Polymorphism多态"></a>6- Polymorphism多态</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Shape.prototype.duplicate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Duplicate'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">extend(Circle,Shape);<span class="comment">//继承函数，上文已提及</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius,color</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line">Circle.prototype.duplicate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Duplicate Circle'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">extend(Square,Shape);</span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">Square</span>(<span class="params">size</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line">&#125;</span><br><span class="line">Square.prototype.duplicate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Duplicate Square'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shapes = [</span><br><span class="line">    <span class="keyword">new</span> Circle(),</span><br><span class="line">    <span class="keyword">new</span> Square()</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> shape <span class="keyword">of</span> shapes)&#123;</span><br><span class="line">    shape.duplicate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/26/OOP-in-JavaScript/30.png" style="zoom: 100%;"></p>
<p>这就是多态的作用了</p>
<h3 id="7-When-to-Use-Inheritance"><a href="#7-When-to-Use-Inheritance" class="headerlink" title="7- When to Use Inheritance"></a>7- When to Use Inheritance</h3><p>不是所有的地方都需要用继承，之后还会提到Composition方法</p>
<p><img src="/2020/05/26/OOP-in-JavaScript/31.png" style="zoom: 50%;"></p>
<p>比如这样，就发生了逻辑错误。</p>
<p><img src="/2020/05/26/OOP-in-JavaScript/32.png" style="zoom: 50%;"></p>
<p>正确的层级应该是这样的，但是如果有很多动物，这样的写法会让代码变得脆弱</p>
<p>如果要用继承，做好保存在同一级，不要多层级</p>
<p>记住 Favor Composition over Inheritance</p>
<p>我们通过组合的方式，也就是定义几个基本对象，然后拿来一个对象，我们把适用于这个对象的基本对象放加给它。</p>
<p>听起来有点像面向函数的编程思维。</p>
<h3 id="8-Mixins"><a href="#8-Mixins" class="headerlink" title="8- Mixins"></a>8- Mixins</h3><p>我们创建了三个基本对象：canEat, can Swim, can Walk;</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canEat = &#123;</span><br><span class="line">    eat : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.hunger--;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'eating'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> canWalk = &#123;</span><br><span class="line">    walk: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'walking'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> canSwim = &#123;</span><br><span class="line">    swim: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'swim'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(Person.prototype,canEat,canWalk);</span><br><span class="line"><span class="keyword">const</span>  person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Goldfish</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(Goldfish.prototype,canEat,canSwim);</span><br><span class="line"><span class="keyword">const</span> goldfish = <span class="keyword">new</span> Goldfish();</span><br><span class="line"><span class="built_in">console</span>.log(goldfish);</span><br></pre></td></tr></table></figure>
<p>但是这样我们还是不精简，我们可以定义一个mixin函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params">target,...sources</span>)</span>&#123;<span class="comment">//...sources就是说可以传入多个参数</span></span><br><span class="line">    <span class="built_in">Object</span>.assign(target,...sources);</span><br><span class="line">&#125;</span><br><span class="line">mixin(Person.prototype,canSwim,canEat);</span><br><span class="line">mixin(GoldFish.prototype,canSwim,canEat);</span><br></pre></td></tr></table></figure>
<h3 id="9-Exercise-Prototypical-Inheritance"><a href="#9-Exercise-Prototypical-Inheritance" class="headerlink" title="9- Exercise- Prototypical Inheritance"></a>9- Exercise- Prototypical Inheritance</h3><h3 id="10-Solution-Prototypical-Inheritance"><a href="#10-Solution-Prototypical-Inheritance" class="headerlink" title="10- Solution- Prototypical Inheritance"></a>10- Solution- Prototypical Inheritance</h3><h3 id="11-Exercise-Polymorphism"><a href="#11-Exercise-Polymorphism" class="headerlink" title="11- Exercise- Polymorphism"></a>11- Exercise- Polymorphism</h3><h3 id="12-Solution-Polymorphism"><a href="#12-Solution-Polymorphism" class="headerlink" title="12- Solution- Polymorphism"></a>12- Solution- Polymorphism</h3><h2 id="ES6-Classes"><a href="#ES6-Classes" class="headerlink" title="ES6 Classes"></a>ES6 Classes</h2><p><code>注:</code> 5-10小结来自React系列教程，因为是ES6的新语法，和对象也有点关系，所以我把它记录到这里，但是没有用到class</p>
<p><a href="https://www.bilibili.com/video/BV1Sb411P79t?p=17" target="_blank" rel="noopener">React教程</a></p>
<h3 id="1-ES6-Classes"><a href="#1-ES6-Classes" class="headerlink" title="1- ES6 Classes"></a>1- ES6 Classes</h3><p>在ES6中，有一种创建对象和继承关系的新方法-类</p>
<p> 但是类本质上还是函数，只是给函数披上了一层外衣</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(radius) &#123;</span><br><span class="line">        <span class="comment">//这里是在构造函数中定义的属性和方法，实例化的对象中会进行拷贝</span></span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">        <span class="keyword">this</span>.move = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里是在 Circle.prototype 中定义属性和方法</span></span><br><span class="line">    draw()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'draw'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typeof</span> Circle; <span class="comment">// function</span></span><br></pre></td></tr></table></figure>
<p>现在如果我新建一个对象，如果不写new，就会报错</p>
<h3 id="2-Hoisting置顶"><a href="#2-Hoisting置顶" class="headerlink" title="2- Hoisting置顶"></a>2- Hoisting置顶</h3><p>在JavaScript中函数的声明有两种形式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">直接函数声明，可以不写分号</span></span><br><span class="line"><span class="comment">这种声明方式，函数会自动被抬升到代码最上面</span></span><br><span class="line"><span class="comment">所以可以声明之前调用sayHello函数，因为JavaScript引擎会自动置顶</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> sayGoodbye = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数表达式声明，需要以分号结束</span></span><br><span class="line"><span class="comment">函数表达式并不会提前，它的本质是常量或者变量，我们如果在前面调用，实际上是调用了未声明的量</span></span><br><span class="line"><span class="comment">所以是非法的。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>对于类来说，我们也有两种形式，类声明和类表达式，但是和函数不同的是，类声明和类表达式都不会置顶</p>
<p>所以不可以再类声明前实例化类</p>
<p>个人建议，用类声明来创建类</p>
<h3 id="3-Static-Methods"><a href="#3-Static-Methods" class="headerlink" title="3- Static Methods"></a>3- Static Methods</h3><p>我们有两种方法，实例方法和静态方法</p>
<p>实例方法只会在实例中生效</p>
<p>实例方法实在类当中起作用的，而不是在类的实例当中</p>
<p>现成的例子，就是Math对象中的函数，就是静态函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(radius) &#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">        <span class="keyword">this</span>.move = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里的draw()就是一个实例方法</span></span><br><span class="line">    draw()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'draw'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//static method</span></span><br><span class="line">    <span class="comment">//这样之后，这个方法就不会再属于类的实例对象了，无法在示例化的对象中通过点来访问</span></span><br><span class="line">    <span class="comment">//但是可以同过类+点的方法来讨论，之作用在class本身</span></span><br><span class="line">  	<span class="keyword">static</span> parse(string)&#123;</span><br><span class="line">		<span class="keyword">const</span> radius = <span class="built_in">JSON</span>.parse(str).radius;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Circle(radius);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> circle = Circle.parse(<span class="string">'&#123;"radius" : 1&#125;'</span>);<span class="comment">//调用了类的静态方法，</span></span><br></pre></td></tr></table></figure>
<h3 id="4-The-This-Keyword"><a href="#4-The-This-Keyword" class="headerlink" title="4- The This Keyword"></a>4- The This Keyword</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Circle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle();</span><br><span class="line">c.draw();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> draw = c.draw;</span><br><span class="line">draw();</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/26/OOP-in-JavaScript/33.png" style="zoom: 80%;"></p>
<p>同样是调用，为什么一个是Circle对象，一个就是Window对象了呢？</p>
<p>因为我们从一个对象c上调用方法draw()，draw()中的this是指向对象本身的。</p>
<p>然而通过函数调用，也就是const draw = c.draw; draw();这种方法调用的draw()的时候</p>
<p>我们以一种独立的方式调用函数， 这种调用，draw()中的this指向一个默认的全局变量，也就是Window对象（或者node 中的Global)</p>
<h4 id="strict模式对this的影响"><a href="#strict模式对this的影响" class="headerlink" title="strict模式对this的影响"></a>strict模式对this的影响</h4><p>在JavaScript中有一个strict 模式，当我们开启这个模式的时候，JavaScript会做很多更严格的错误检查。</p>
<p>通过 use strict 启用</p>
<p>然后我们会发现，原来的Window对象变成了undefined对象。也就是说当独立调用draw()的时候，this将不再指向全局对象。他会被设置成undefined，这样会防止我们修改Window对象中的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">	draw()&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle();</span><br><span class="line">c.draw();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> draw = c.draw;</span><br><span class="line">draw();</span><br></pre></td></tr></table></figure>
<p>这时候我们会发现调用draw()还是出现undefined</p>
<p>因为在类的作用下，严格模式会自动启用。</p>
<h3 id="5-Binding-this"><a href="#5-Binding-this" class="headerlink" title="5- Binding this"></a>5- Binding this</h3><p>我们知道如果独立调用类中的函数，那么this会指向Window或者undefined</p>
<p>接下来我们让this无论何时都指向对象本身</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">	name: <span class="string">"Mosh"</span>,</span><br><span class="line">	walk()&#123;</span><br><span class="line">		console.<span class="built_in">log</span>(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> walk = person.walk.bind(person);</span><br><span class="line">walk();</span><br><span class="line"><span class="comment">//我们发现这时候 walk()中的this就指向了Person类</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/26/OOP-in-JavaScript/40.png" style="zoom: 80%;"></p>
<h3 id="6-Arrow-Functions"><a href="#6-Arrow-Functions" class="headerlink" title="6- Arrow Functions"></a>6- Arrow Functions</h3><p>箭头函数非常有用</p>
<p>原来我们这么写一个函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="keyword">function</span>(<span class="params">number</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> number*number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们可以这么写</p>
<p>如果没有 参数，那么直接 ()=&gt;{} 即可</p>
<p>如果有多可参数，那么需要用括号括起来；如果只有一个参数如下图，可以省略括号</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">number</span> =&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> number*number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>甚至我们如果写的是单行代码，只返回一个值，我们可以这么写，（类似于python中的lambda函数）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">number</span> =&gt;</span> number*number;<span class="comment">//理解为 number goes to  number*number</span></span><br></pre></td></tr></table></figure>
<p>再比如：利用fileter函数的时候，简直比python都要简洁。。。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jobs =[</span><br><span class="line">	&#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">isActive</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">	&#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">isActive</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">	&#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">isActive</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> activeJobs = jobs.filter(<span class="function"><span class="params">job</span>=&gt;</span> job.isActive  );</span><br></pre></td></tr></table></figure>
<h3 id="7-Arrow-Functions-and-this"><a href="#7-Arrow-Functions-and-this" class="headerlink" title="7- Arrow Functions and this"></a>7- Arrow Functions and this</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">	talk()&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"this"</span>,<span class="keyword">this</span>);</span><br><span class="line">        &#125;，<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.talk();</span><br></pre></td></tr></table></figure>
<p>我们按照上面这种写法吗，发现this指向了Window对象</p>
<p>这是因为传入的匿名回调函数，是不属于任何对象的。他和person.talk()函数没关系,是一个独立的函数，所以默认this指向了全局对象WIndow</p>
<p>那么我们怎么让回调函数中的this指向对象person呢？</p>
<p>我们可以 然后在回调函数中利用箭头符号的特性，不需要在回调函数外面声明self再让回调函数指向self</p>
<p>直接像下面这样修改即可。箭头函数中的this，是从上面定义this的地方继承下来的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">	talk()&#123;</span><br><span class="line">        setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">            console.log(&quot;this&quot;,this);</span><br><span class="line">        &#125;，1000);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.talk();</span><br></pre></td></tr></table></figure>
<h3 id="8-Array-map-Method"><a href="#8-Array-map-Method" class="headerlink" title="8- Array.map Method"></a>8- Array.map Method</h3><p>ES6中新引入了Array.map </p>
<p>当我想渲染一个列表的时候，经常要使用到map()方法</p>
<p>map()方法遍历列表中的每一个项，传入到某个函数当中，然后再返回每一个项（和python的map方法差不多）,得到一个新的列表</p>
<p>利用模板格式语法，我们可以美化代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> colors = [<span class="string">'red'</span>,<span class="string">'green'</span>,<span class="string">'blue'</span>];</span><br><span class="line"><span class="keyword">const</span> items = color.map( <span class="function"><span class="params">color</span> =&gt;</span><span class="string">`&lt;li&gt;<span class="subst">$&#123;color&#125;</span>&lt;/li&gt;`</span>);</span><br><span class="line"><span class="comment">//上面的就等于 color.map(color =&gt; "&lt;li&gt;+ color + &lt;/li&gt;")</span></span><br><span class="line"><span class="built_in">console</span>.log(items);</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/26/OOP-in-JavaScript/42.png" style="zoom: 80%;"></p>
<h3 id="9-Object-Destructuring-解构赋值"><a href="#9-Object-Destructuring-解构赋值" class="headerlink" title="9- Object Destructuring 解构赋值"></a>9- Object Destructuring 解构赋值</h3><p>解构赋值允许你使用类似数组或对象字面量的语法将数组和对象的属性赋给各种变量。这种赋值语法极度简洁，同时还比传统的属性访问方法更为清晰。</p>
<p>通常来说，你很可能这样访问数组中的前三个元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> first = someArray[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> second = someArray[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> third = someArray[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<p>如果使用解构赋值的特性，将会使等效的代码变得更加简洁并且可读性更高：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [first, second, third] = someArray;</span><br></pre></td></tr></table></figure>
<p>想要几个写几个</p>
<h3 id="10-Spread-Operator"><a href="#10-Spread-Operator" class="headerlink" title="10- Spread Operator"></a>10- Spread Operator</h3><p>就是三个点  ...</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> first = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> second = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">const</span> combined = [...first,...second];</span><br><span class="line"><span class="comment">//利用这种语法，那么我们可以随心所欲地在数组中加些别的内容比如</span></span><br><span class="line"><span class="keyword">const</span> combined = [...first,<span class="string">'a'</span>,...second,<span class="string">'b'</span>];</span><br></pre></td></tr></table></figure>
<p>有了这种语法，我们可以很容易的复制一个数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> clone = [...first];</span><br></pre></td></tr></table></figure>
<p>我们也可以对对象使用这种语法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> first = &#123;<span class="attr">name</span> : <span class="string">"Mosh"</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> second = &#123;<span class="attr">job</span>: <span class="string">"Instructor"</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> combined = &#123;...first,...second,<span class="attr">location</span>:<span class="string">"Australia"</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(combined);</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/26/OOP-in-JavaScript/43.png" style="zoom: 80%;"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> clone = &#123;...first&#125;;</span><br><span class="line"><span class="comment">//同时也可以对对象进行赋值操作</span></span><br></pre></td></tr></table></figure>
<h3 id="11-1-Private-Members-Using-Symbols"><a href="#11-1-Private-Members-Using-Symbols" class="headerlink" title="11-1 Private Members Using Symbols"></a>11-1 Private Members Using Symbols</h3><p>如果我们直接在constructor中定义方法或者属性，那么这个属性可以在实例中被访问</p>
<p>但是利用Symbol()函数来达成 私有属性这个功能(实现了一部分私有属性的功能)</p>
<p>Symbol 值可以由程序创建，并可以作为属性名，而且不用担心属性名冲突。调用 Symbol() 方法将创建一个新的 Symbol 类型的值，并且该值不与其它任何值相等。 Symbol() === Symbol() //False</p>
<p>Symbol  一旦创建后就不可更改，不能对它们设置属性（如果在严格模式下尝试这样做，你将得到一个 TypeError）。它们可以作为属性名，这时它们和字符串的属性名没有什么区别。所以我们现在就要把这个Symbol作为属性的名称</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _radius = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> _draw = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(radius) &#123;</span><br><span class="line">        <span class="comment">//因为下划线加上变量名是常见的私有属性的表达方式，但是直接通过点是没有办法访问的</span></span><br><span class="line">        <span class="comment">//所以通过中括号来访问</span></span><br><span class="line">        <span class="keyword">this</span>[_radius] = radius;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据ES6 的新特性，就是可以计算生成属性的名称</span></span><br><span class="line">    <span class="comment">//_draw 这个独立的值就会被当作这个方法的名称</span></span><br><span class="line">    [_draw]()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line">c.radius;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/26/OOP-in-JavaScript/35.png" style="zoom: 80%;"></p>
<p>这样我们就把原来的属性名称隐藏起来了（虽然外面还是显示了symbol）但是如果我们按照这种方式定义了多个变量的话，那么他们都显示为Symbol()但是在内部他们是不相同的</p>
<h3 id="11-2-Private-Members-Using-WeakMaps"><a href="#11-2-Private-Members-Using-WeakMaps" class="headerlink" title="11- 2 Private Members Using WeakMaps"></a>11- 2 Private Members Using WeakMaps</h3><p><a href="https://blog.csdn.net/weixin_33971205/article/details/87946796" target="_blank" rel="noopener">weakmap博客</a></p>
<p>利用ES6的新特性WeakMap（弱映射）,WeakMap 的键只能是对象，值可以为任意的类型</p>
<p>之所以被称为弱映射，是因为键很弱，如果键没有被引用的话，那么这个键值对就会被垃圾回收机制删除，避免了内存泄漏</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _radius = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>(radius) &#123;</span><br><span class="line">            _radius.set(<span class="keyword">this</span><span class="comment">/*对象，即键值*/</span>,radius);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/26/OOP-in-JavaScript/36.png" style="zoom: 100%;"></p>
<p>我们看到这样 radius就被隐藏起来了；如果我们想要读取这个radius的值，那么我们需要再写一个方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _radius = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>(radius) &#123;</span><br><span class="line">            _radius.set(<span class="keyword">this</span><span class="comment">/*对象，即键值*/</span>,radius);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        draw()&#123;</span><br><span class="line">		    	<span class="built_in">console</span>.log(_radius.get(<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line">c.draw();<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>那么我们怎么定义一个方法呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _radius = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="keyword">const</span> _move = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">        <span class="keyword">constructor</span>(radius) &#123;</span><br><span class="line">            _radius.set(<span class="keyword">this</span><span class="comment">/*对象，即键值*/</span>,radius);</span><br><span class="line">       <span class="comment">//上面是把变量属性radius映射到this(Circle)对象中，下面的则是把一个方法映射进去</span></span><br><span class="line">            _move.set(<span class="keyword">this</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            	<span class="built_in">console</span>.log(<span class="string">'move'</span>,<span class="keyword">this</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        draw()&#123;</span><br><span class="line">		    _move.get(<span class="keyword">this</span>)();<span class="comment">//调用私有方法</span></span><br><span class="line">            <span class="built_in">console</span>.log(_radius.get(<span class="keyword">this</span>));<span class="comment">//读取私有属性</span></span><br><span class="line">            _console.log(<span class="string">'draw'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line">c.draw(); <span class="comment">// 显示:move undefined</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为什么console.log('move',this)中的this指向了undefined(严格模式下)</span></span><br><span class="line"><span class="comment">原因还没搞懂。。。</span></span><br><span class="line"><span class="comment">那么如果我们要调用Circle对象中的某些成员该怎么办？要解决这个问题我们需要运用箭头函数</span></span><br><span class="line"><span class="comment">英文箭头函数会将this设置为包含它的函数，这时候console.log('move',this)中的this</span></span><br><span class="line"><span class="comment">将从调用它的构造函数中继承过来，也就是说，显示Circle</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">_move.set(<span class="keyword">this</span>, () =&gt; &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'move'</span>,<span class="keyword">this</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们最好对每一个属性或者方法都建立一个WeakMap</p>
<p>因为如果都放在一起，代码会变得不干净</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> privateProps = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(radius)&#123;</span><br><span class="line">		privateProps.set(<span class="keyword">this</span>,&#123;</span><br><span class="line">			radius: radius,</span><br><span class="line">			move: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	privateProps.get(<span class="keyword">this</span>).radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-Getters-and-Setters"><a href="#12-Getters-and-Setters" class="headerlink" title="12- Getters and Setters"></a>12- Getters and Setters</h3><p>如果我们想要把radius设置成只读属性，一种方法就是向上面那样写一个在prototype里的方法getRadius()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _radius = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">     <span class="keyword">constructor</span>(radius) &#123;</span><br><span class="line">         _radius.set(<span class="keyword">this</span><span class="comment">/*对象，即键值*/</span>,radius);</span><br><span class="line">     &#125; </span><br><span class="line">     getRadius()&#123;</span><br><span class="line">         <span class="keyword">return</span> _radius.get(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以用上文提到的Object.definProperty() 这样更容易操作和访问</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _radius = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">     <span class="keyword">constructor</span>(radius) &#123;</span><br><span class="line">         _radius.set(<span class="keyword">this</span><span class="comment">/*对象，即键值*/</span>,radius);</span><br><span class="line">         <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>,<span class="string">'radius'</span>,&#123;</span><br><span class="line">         	<span class="keyword">get</span>: function()&#123;</span><br><span class="line">         		<span class="keyword">return</span> _radius.get(<span class="keyword">this</span>)</span><br><span class="line">         	&#125;</span><br><span class="line">         &#125;)</span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但显然Object.definProperty() 也太麻烦了，ES6中的类有着更好的实现办法,直接把get 属性(){}加到prototype当中 ,这看起来像个方法，但实际上可以直接c.radius 来进行访问。</p>
<p>类似的，我们也可以设置set 属性(){} ;可以对radius进行赋值</p>
<p>ES6 中，getter和setter 变得简单多了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _radius = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(radius) &#123;</span><br><span class="line">        _radius.set(<span class="keyword">this</span><span class="comment">/*对象，即键值*/</span>,radius);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> radius()&#123;</span><br><span class="line">        <span class="keyword">return</span> _radius.get(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> radius(value)&#123;</span><br><span class="line">        <span class="keyword">if</span>(value&lt;=<span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Invalid radius'</span>);</span><br><span class="line">        _radius.set(<span class="keyword">this</span>,value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-Inheritance"><a href="#13-Inheritance" class="headerlink" title="13- Inheritance"></a>13- Inheritance</h3><p>在ES6中实现继承，我们只需要简简单单的extends关键词即可</p>
<p>下面的move和draw都是放在原型对象中的，而不是在constructor中的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	move()&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'move'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">	draw()&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'draw'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle();</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/26/OOP-in-JavaScript/37.png" style="zoom: 100%;"></p>
<p>我们可以在Shape中加一个constructor构造函数，让每个Shape实例都有一个color属性，但是如果在Circle中加一个constructor的话，子类的构造器中必须先调用父类的构造函数，以创建一个父类的实例。我们可以用<strong>super</strong>关键字，super()中传入父类构造函数中的属性名称</p>
<p>如果想把自己的属性也加到构造函数中去，那么直接写就行,super <strong>只管</strong>父类构造函数中的属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(color)&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">	move()&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'move'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(color,radius)&#123;</span><br><span class="line">        <span class="keyword">super</span>(color);</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">	draw()&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'draw'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle(<span class="string">'red'</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/26/OOP-in-JavaScript/38.png" style="zoom: 100%;"></p>
<h3 id="14-Method-Overriding"><a href="#14-Method-Overriding" class="headerlink" title="14- Method Overriding"></a>14- Method Overriding</h3><p>在原型继承里提过重写函数，那么在类中呢？也是直接写就行了，JavaScript编译器会从下至上寻找这个move函数</p>
<p>如果我想要在自类中调用父类的move函数，又想要有自己的改变，利用super.move()即可；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	move()&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'move'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">	move()&#123;</span><br><span class="line">        <span class="keyword">super</span>.move();</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'circle move'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle(<span class="string">'red'</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h3 id="15-Exercise"><a href="#15-Exercise" class="headerlink" title="15- Exercise"></a>15- Exercise</h3><h3 id="16-Solution"><a href="#16-Solution" class="headerlink" title="16- Solution"></a>16- Solution</h3><h2 id="ES6-Tooling"><a href="#ES6-Tooling" class="headerlink" title="ES6 Tooling"></a>ES6 Tooling</h2><h3 id="1-Modules"><a href="#1-Modules" class="headerlink" title="1- Modules"></a>1- Modules</h3><p>现实生活中我们不可能在一个文件中写成百上千行的脚本文件。所以我们把代码划分成很多独立的小文件，这些文件就是所谓的模块。</p>
<p>模块带来了很多好处。、</p>
<p><strong>Maintainability</strong></p>
<p>我们通过模块化增加了程序的可维护性，更加容易管理程序。</p>
<p><strong>Resuse</strong></p>
<p>我们通过模块化，可以在更多的程序中重用我们已经写好了的模块</p>
<p><strong>Abstract</strong></p>
<p>我们通过模块化, 可以隐藏模块中的细节，之向外提供必要的接口即可</p>
<h3 id="2-CommonJS-Modules"><a href="#2-CommonJS-Modules" class="headerlink" title="2- CommonJS Modules"></a>2- CommonJS Modules</h3><p><strong>Circle.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Implementation Detail </span></span><br><span class="line"><span class="keyword">const</span> _radius = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Public Interface</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(radius) &#123;</span><br><span class="line">    _radius.set(<span class="keyword">this</span>, radius);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  draw() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Circle with radius '</span> + _radius.get(<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Circle;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果我们想导入多个类，也想把它们公开，我们可以这么写</span></span><br><span class="line"><span class="comment">module.exports.Circle = Circle;</span></span><br><span class="line"><span class="comment">module.exports.Shape = Shape;</span></span><br><span class="line"><span class="comment">module.exports.Square = Square;</span></span><br><span class="line"><span class="comment">这里我只想导入一个类，我们可以直接简化成</span></span><br><span class="line"><span class="comment">module.exports = Circle;</span></span><br><span class="line"><span class="comment">这样我们引入Circle模块的时候，我们其实就得到了Circle类</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>index.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Circle = <span class="built_in">require</span>(<span class="string">'./circle'</span>);</span><br><span class="line"><span class="comment">// 	引用circle，其实等于引用了Circle对象,那么我们把这个返回值存放在一个常量Circle当中</span></span><br><span class="line"><span class="comment">//	就可以用Cirle来创建对象了</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle(<span class="number">10</span>);</span><br><span class="line">c.draw();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">	在这个模块中，我们只公开了Circle类</span></span><br><span class="line"><span class="comment">	所以这里的radius弱映射_radius是没有办法访问到的</span></span><br><span class="line"><span class="comment">	所以说，Circle是公共接口,而_radius 是实现细节</span></span><br><span class="line"><span class="comment">	这种方法不会破坏其他程序，因为没有任何其他模块可以访问到_radius属性。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>运行index.js, 得到了Circle with radius 10</p>
<h3 id="3-ES6-Modules"><a href="#3-ES6-Modules" class="headerlink" title="3- ES6 Modules"></a>3- ES6 Modules</h3><p><strong>Circle.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _radius = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在ES6当中，我们直接在class之前加上export即可，这样我们也可以访问Circle类但是不能访问radius</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(radius) &#123;</span><br><span class="line">    _radius.set(<span class="keyword">this</span>, radius);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  draw() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Circle with radius '</span> + _radius.get(<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>index.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Circle&#125; <span class="keyword">from</span> <span class="string">'./circle.js'</span>;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">引入的使用大括号围住Circle，Circle就是export出来的Circle，这时候一定要写上.js</span></span><br><span class="line"><span class="comment">同时在html引入的时候注type = 'module' 才不会报错</span></span><br><span class="line"><span class="comment"> &lt;script type="module" src="index.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">语法和python类似。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Circle(<span class="number">10</span>);</span><br><span class="line">c.draw();</span><br></pre></td></tr></table></figure>
<h3 id="4-ES6-Tooling"><a href="#4-ES6-Tooling" class="headerlink" title="4- ES6 Tooling"></a>4- ES6 Tooling</h3><p>前端工作者，需要了解</p>
<p>JavaScript中我们有两类工具，分别是 Transpiler 和 Bundler</p>
<p><strong>Transpiler</strong> 是 Translator+Compiler 的结合，基本上就是将我们写的JavaScript代码翻译成所有浏览器都能读懂的代码，Babel就是现代JS代码中一种非常流行的转译器</p>
<p><strong>Bundler</strong> 就是把很多的js文件合并成一个js文件，也就是我们说的打包。最受欢迎的就是WebPack。他会去掉所有的空行，注释，并且会简化一切名称。这样有助于优化客户请求文件的过程</p>
<h3 id="5-Babel"><a href="#5-Babel" class="headerlink" title="5- Babel"></a>5- Babel</h3><p>在terminal中安装 babel</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install babel-cli@6.26.0 babel-core@6.26.0 babel-preset-env@1.6.1 --save-dev</span><br></pre></td></tr></table></figure>
<p>我们在index.js中写 const x = 1;</p>
<p><img src="/2020/05/26/OOP-in-JavaScript/39.png" style="zoom: 100%;"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置好以后,需要创建一个build文件夹</span></span><br><span class="line">npm run babel;</span><br></pre></td></tr></table></figure>
<p>会出现以下结果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> x= <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="6-Webpack"><a href="#6-Webpack" class="headerlink" title="6- Webpack"></a>6- Webpack</h3><p>webpack会把所有的js文件合并</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/05/25/%E5%AE%A2%E6%88%B7%E7%AB%AFJS%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/25/%E5%AE%A2%E6%88%B7%E7%AB%AFJS%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/" itemprop="url">客户端JS第一部分</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-25T15:42:50+08:00">
                2020-05-25
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-05-25T18:54:00+08:00">
                2020-05-25
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="客户端JS第一部分"><a href="#客户端JS第一部分" class="headerlink" title="客户端JS第一部分"></a>客户端JS第一部分</h1><h2 id="Web浏览器当中的JavaScript"><a href="#Web浏览器当中的JavaScript" class="headerlink" title="Web浏览器当中的JavaScript"></a>Web浏览器当中的JavaScript</h2><p><img src="/2020/05/25/%E5%AE%A2%E6%88%B7%E7%AB%AFJS%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/1.png" style="zoom: 50%;"></p>
<h3 id="在JavaScript中嵌入JavaScript"><a href="#在JavaScript中嵌入JavaScript" class="headerlink" title="在JavaScript中嵌入JavaScript"></a>在JavaScript中嵌入JavaScript</h3><ol>
<li>内联，放置在\<script\>和\&lt;/script> 标签对之间</script\></li>
<li>放置在由\<script\>标签的src属性指定的外部文件中</script\></li>
<li>放置在HTML事件处理程序中，该事件处理程序由onclick这样的HTML属性指定</li>
<li>放在一个URL当中，这个URL使用特殊的”javaScript:”协议（较少用)</li>
</ol>
<h4 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h4><p><img src="/2020/05/25/%E5%AE%A2%E6%88%B7%E7%AB%AFJS%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/2.png" style="zoom: 70%;"></p>
<h3 id="标签的src属性"><a href="#标签的src属性" class="headerlink" title="\标签的src属性"></a>\<script\>标签的src属性</script\></h3><p>类似于导入库的概念</p>
<p><img src="/2020/05/25/%E5%AE%A2%E6%88%B7%E7%AB%AFJS%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/3.png" style="zoom: 60%;"></p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>可以把大块的JS代码从HTML文件中删除，这有助于保持内容和行为的分离，从而简化HTML文件</li>
<li>如果有多个Web页面共用相同的JavaScript代码，用src属性可以让你只管理一份diamagnetic，而不用在代码改变时编辑每个HTML文件</li>
<li>如果一个JavaScript代码由多个页面共享，就只需要下载它一次，通过使用它的一个页面，虽然有的页面可以再用浏览器缓存中检索它</li>
<li>由于src属性的值可以实任意的URL，因此来自一个Web服务器的JavaScript代码程序或者Web页面可以使用另外一个Web服务器输出的代码，很多互联网广告依赖于此</li>
<li>从其它网站注入脚本的能力可以让我们更好的利用缓存</li>
</ul>
<h4 id="HTML中的事件处理程序"><a href="#HTML中的事件处理程序" class="headerlink" title="HTML中的事件处理程序"></a>HTML中的事件处理程序</h4><p><img src="/2020/05/25/%E5%AE%A2%E6%88%B7%E7%AB%AFJS%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/4.png" style="zoom: 60%;"></p>
<h4 id="URL中的JavaScript"><a href="#URL中的JavaScript" class="headerlink" title="URL中的JavaScript"></a>URL中的JavaScript</h4><p><img src="/2020/05/25/%E5%AE%A2%E6%88%B7%E7%AB%AFJS%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/5.png" style="zoom: 60%;"></p>
<h4 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h4><p><img src="/2020/05/25/%E5%AE%A2%E6%88%B7%E7%AB%AFJS%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/5.png" style="zoom: 60%;"></p>
<h3 id="JavaScript程序的理想执行事件线"><a href="#JavaScript程序的理想执行事件线" class="headerlink" title="JavaScript程序的理想执行事件线"></a>JavaScript程序的理想执行事件线</h3><p><img src="/2020/05/25/%E5%AE%A2%E6%88%B7%E7%AB%AFJS%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/7.png" style="zoom: 60%;"></p>
<p><img src="/2020/05/25/%E5%AE%A2%E6%88%B7%E7%AB%AFJS%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/10.png" style="zoom: 60%;"></p>
<h3 id="Document-write"><a href="#Document-write" class="headerlink" title="Document.write()"></a>Document.write()</h3><p><img src="/2020/05/25/%E5%AE%A2%E6%88%B7%E7%AB%AFJS%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/8.png" style="zoom: 60%;"></p>
<h3 id="defer-async属性"><a href="#defer-async属性" class="headerlink" title="defer,async属性"></a>defer,async属性</h3><p><img src="/2020/05/25/%E5%AE%A2%E6%88%B7%E7%AB%AFJS%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/9.png" style="zoom: 60%;"></p>
<h2 id="Window对象"><a href="#Window对象" class="headerlink" title="Window对象"></a>Window对象</h2><h3 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h3><p><img src="/2020/05/25/%E5%AE%A2%E6%88%B7%E7%AB%AFJS%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/11.png" style="zoom: 60%;"></p>
<h2 id="脚本化文档"><a href="#脚本化文档" class="headerlink" title="脚本化文档"></a>脚本化文档</h2>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/05/25/94-144-145%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%89%E5%BA%8F%E9%81%8D%E5%8E%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/25/94-144-145%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%89%E5%BA%8F%E9%81%8D%E5%8E%86/" itemprop="url">94-144-145二叉树三序遍历</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-25T13:38:13+08:00">
                2020-05-25
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-05-25T14:14:34+08:00">
                2020-05-25
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="94-144-145二叉树三序遍历"><a href="#94-144-145二叉树三序遍历" class="headerlink" title="94-144-145二叉树三序遍历"></a>94-144-145二叉树三序遍历</h1><p>所谓三序遍历，就是前序遍历，中序遍历和后序遍历。那么在之前的博客<a href="https://jasonxqh.github.io/2020/05/13/二叉树/">二叉树</a>当中我已经详细的写了二叉树的基本知识，构建，遍历。在leetcode上，也有这三道题目。</p>
<h3 id="题目给出的代码"><a href="#题目给出的代码" class="headerlink" title="题目给出的代码"></a>题目给出的代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以这三道题目，不仅仅要利用递归的思路解出来（简单),还要用迭代+栈的做法解。</p>
<h3 id="递归法求解"><a href="#递归法求解" class="headerlink" title="递归法求解"></a>递归法求解</h3><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; results;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        results.push_back(node-&gt;val);</span><br><span class="line">        traverse(node-&gt;left);</span><br><span class="line">        traverse(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; results;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        traverse(node-&gt;left);</span><br><span class="line">        results.push_back(node-&gt;val);</span><br><span class="line">        traverse(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; results;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        traverse(node-&gt;left);</span><br><span class="line">        traverse(node-&gt;right);</span><br><span class="line">        results.push_back(node-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="迭代法求解"><a href="#迭代法求解" class="headerlink" title="迭代法求解"></a>迭代法求解</h3><p>迭代法求解我主要学习了<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/liang-ta-lai-liao-ta-dai-zhao-san-xiong-di-lai-lia/" target="_blank" rel="noopener">leetcode 优秀题解</a> 。我认为他的方法最简明扼要。</p>
<h4 id="先序遍历-1"><a href="#先序遍历-1" class="headerlink" title="先序遍历"></a>先序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;  <span class="comment">//保存结果</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; call;  <span class="comment">//调用栈</span></span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>) call.push(root);  <span class="comment">//首先压入root节点</span></span><br><span class="line">        <span class="keyword">while</span>(!call.empty())&#123;</span><br><span class="line">            TreeNode *t = call.top();</span><br><span class="line">            call.pop();  <span class="comment">//访问过的节点弹出</span></span><br><span class="line">            <span class="keyword">if</span>(t!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right) call.push(t-&gt;right);  <span class="comment">//右节点先压栈，最后处理</span></span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left) call.push(t-&gt;left);</span><br><span class="line">                call.push(t);  <span class="comment">//当前节点重新压栈（留着以后处理），因为先序遍历所以最后压栈</span></span><br><span class="line">                call.push(<span class="literal">nullptr</span>);  <span class="comment">//在当前节点之前加入一个空节点表示已经访问过了</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">//空节点表示之前已经访问过了，现在需要处理除了递归之外的内容</span></span><br><span class="line">                res.push_back(call.top()-&gt;val);  </span><br><span class="line">                <span class="comment">//call.top()是nullptr之前压栈的一个节点，也就是上面call.push(t)中的那个t</span></span><br><span class="line">                call.pop();  <span class="comment">//处理完了，第二次弹出节点（彻底从栈中移除）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;  <span class="comment">//保存结果</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; call;  <span class="comment">//调用栈</span></span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>) call.push(root);  <span class="comment">//首先压入root节点</span></span><br><span class="line">        <span class="keyword">while</span>(!call.empty())&#123;</span><br><span class="line">            TreeNode *t = call.top();</span><br><span class="line">            call.pop();  <span class="comment">//访问过的节点弹出</span></span><br><span class="line">            <span class="keyword">if</span>(t!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right) call.push(t-&gt;right);  <span class="comment">//右节点先压栈，最后处理</span></span><br><span class="line">                call.push(t);  </span><br><span class="line">                <span class="comment">//当前节点重新压栈（留着以后处理），因为中序遍历所以根节点摆中间</span></span><br><span class="line">                call.push(<span class="literal">nullptr</span>);  <span class="comment">//在当前节点之前加入一个空节点表示已经访问过了</span></span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left) call.push(t-&gt;left); <span class="comment">//左节点最后压栈，最先处理</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">//空节点表示之前已经访问过了，现在需要处理除了递归之外的内容</span></span><br><span class="line">                res.push_back(call.top()-&gt;val);  </span><br><span class="line">                <span class="comment">//call.top()是nullptr之前压栈的一个节点，也就是上面call.push(t)中的那个t</span></span><br><span class="line">                call.pop();  <span class="comment">//处理完了，第二次弹出节点（彻底从栈中移除）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;  <span class="comment">//保存结果</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; call;  <span class="comment">//调用栈</span></span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>) call.push(root);  <span class="comment">//首先压入root节点</span></span><br><span class="line">        <span class="keyword">while</span>(!call.empty())&#123;</span><br><span class="line">            TreeNode *t = call.top();</span><br><span class="line">            call.pop();  <span class="comment">//访问过的节点弹出</span></span><br><span class="line">            <span class="keyword">if</span>(t!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                call.push(t);  </span><br><span class="line">                <span class="comment">//当前节点重新压栈（留着以后处理），因为后序序遍历所以根节点摆最后，最先入栈</span></span><br><span class="line">                call.push(<span class="literal">nullptr</span>);  <span class="comment">//在当前节点之前加入一个空节点表示已经访问过了</span></span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right) call.push(t-&gt;right);  <span class="comment">//右节点压栈，摆在第二位处理</span></span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left) call.push(t-&gt;left);		<span class="comment">//左节点最后入栈，最先处理</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">//空节点表示之前已经访问过了，现在需要处理除了递归之外的内容</span></span><br><span class="line">                res.push_back(call.top()-&gt;val);  </span><br><span class="line">                <span class="comment">//call.top()是nullptr之前压栈的一个节点，也就是上面call.push(t)中的那个t</span></span><br><span class="line">                call.pop();  <span class="comment">//处理完了，第二次弹出节点（彻底从栈中移除）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/05/24/python%E7%BB%83%E4%B9%A0%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/24/python%E7%BB%83%E4%B9%A0%E9%A2%98/" itemprop="url">python练习题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-24T00:12:25+08:00">
                2020-05-24
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-05-25T00:03:28+08:00">
                2020-05-25
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="python练习题"><a href="#python练习题" class="headerlink" title="python练习题"></a>python练习题</h1><p><img src="/2020/05/24/python%E7%BB%83%E4%B9%A0%E9%A2%98/1.png" style="zoom:80%;"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = [random.randint(<span class="number">10</span>,<span class="number">99</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">b = []</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> a:</span><br><span class="line">    <span class="keyword">if</span>(item%<span class="number">2</span>==<span class="number">0</span>):</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        b.append(item)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/24/python%E7%BB%83%E4%B9%A0%E9%A2%98/2.png" style="zoom:80%;"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/05/22/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/22/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/" itemprop="url">更新日志</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-22T14:23:56+08:00">
                2020-05-22
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-07-20T21:57:18+08:00">
                2020-07-20
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="更新日志（五月）"><a href="#更新日志（五月）" class="headerlink" title="更新日志（五月）"></a>更新日志（五月）</h1><h2 id="5-22"><a href="#5-22" class="headerlink" title="5.22"></a>5.22</h2><ol>
<li>完善 <a href="https://jasonxqh.github.io/2020/05/13/二叉树/">二叉树</a> 细节</li>
<li>完善 <a href="https://jasonxqh.github.io/2020/05/15/离散概率part2/">离散数学part2</a> 贝叶斯定律部分</li>
<li>更新 <a href="https://jasonxqh.github.io/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/">离散数学part3</a> 期望部分(未完结)</li>
<li>完善 <a href="https://jasonxqh.github.io/2020/05/16/Mysql基础/">Mysql基础</a>的1.5汇总数据部分(已完结)</li>
<li>完善<a href="https://jasonxqh.github.io/2020/05/11/格林公式/">格林公式</a>书本作业部分</li>
</ol>
<h2 id="5-23"><a href="#5-23" class="headerlink" title="5.23"></a>5.23</h2><ol>
<li>完善 <a href="https://jasonxqh.github.io/2020/05/12/对面积的曲面积分/">对面积的曲面积分</a> 中书本作业部分</li>
<li>完善<a href="https://jasonxqh.github.io/2020/05/13/对坐标的曲面积分/">对坐标的曲面积分</a>  中书本作业部分</li>
</ol>
<h2 id="5-24"><a href="#5-24" class="headerlink" title="5.24"></a>5.24</h2><ol>
<li>完善 <a href="https://jasonxqh.github.io/2020/05/16/Mysql基础/">Mysql基础</a>的1.6编写复杂查询部分(已完结)</li>
<li>更新 <a href="https://jasonxqh.github.io/2020/05/24/python练习题/">python练习题</a> 2道</li>
<li>完善 <a href="https://jasonxqh.github.io/2020/05/13/%E9%AB%98%E6%96%AF%E5%85%AC%E5%BC%8F/">高斯公式</a> 书本作业部分</li>
<li>完善 <a href="https://jasonxqh.github.io/2020/05/15/斯托克斯公式/">斯托克斯公式</a> 书本作业部分</li>
</ol>
<h2 id="5-25"><a href="#5-25" class="headerlink" title="5.25"></a>5.25</h2><ol>
<li>完善 <a href="https://jasonxqh.github.io/2020/05/16/Mysql基础/">Mysql基础</a>的 1.7Mysql 中的基本函数(已完结)</li>
<li>更新 <a href="https://jasonxqh.github.io/2020/05/25/94-144-145二叉树三序遍历/#more">94-144-145二叉树遍历</a></li>
<li>更新 <a href="https://jasonxqh.github.io/2020/04/22/331验证二叉树的前序序列化/">验证二叉树的前序序列化</a></li>
<li>更新<a href="https://jasonxqh.github.io/2020/05/08/分治算法和主定理/">分治算法和主定理</a> 作业解答部分</li>
<li>更新 <a href="https://jasonxqh.github.io/2020/05/25/客户端JS第一部分/">客户端javascript第一部分</a>（未完结）</li>
</ol>
<h2 id="5-26"><a href="#5-26" class="headerlink" title="5.26"></a>5.26</h2><ol>
<li>更新<a href="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/#more">OOP-in-JavaScript</a>中对象的部分（未完结）</li>
<li>更新<a href="https://jasonxqh.github.io/2020/05/22/离散概率part3/">离散数学part3</a> 中的期望部分(已完结)，方差部分（未完结）</li>
<li>完善 <a href="https://jasonxqh.github.io/2020/05/16/Mysql基础/">Mysql基础</a>的 VIEW(已完结)</li>
</ol>
<h2 id="5-27"><a href="#5-27" class="headerlink" title="5.27"></a>5.27</h2><ol>
<li>更新 <a href="https://jasonxqh.github.io/2020/05/26/常数项级数的审敛法/">常数项级数的审敛法</a> （未完结）</li>
<li>更新<a href="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/#more">OOP-in-JavaScript</a> 中对象的部分 （已完结）</li>
</ol>
<h2 id="5-28"><a href="#5-28" class="headerlink" title="5.28"></a>5.28</h2><ol>
<li>更新 <a href="https://jasonxqh.github.io/2020/05/26/常数项级数的审敛法/">常数项级数的审敛法</a> （已完结）</li>
<li>更新<a href="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/#more">OOP-in-JavaScript</a>中原型的部分 （已完结），原型继承部分（已完结），类部分（未完结）</li>
</ol>
<h2 id="5-29"><a href="#5-29" class="headerlink" title="5.29"></a>5.29</h2><ol>
<li>更新<a href="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/#more">OOP-in-JavaScript</a>中类部分（已完结），ES6Tooling 部分(已完结)</li>
<li>更新<a href="https://jasonxqh.github.io/2020/05/22/离散概率part3/">离散数学part3</a> 中的 方差部分（已完结），尾概率（未完结）</li>
</ol>
<h2 id="5-30"><a href="#5-30" class="headerlink" title="5.30"></a>5.30</h2><ol>
<li>更新 数据结构 ：<a href="https://jasonxqh.github.io/2020/05/30/Trie树/#more">Trie 树</a>(已完结)</li>
<li>更新 <a href="https://jasonxqh.github.io/2020/05/30/sstream/#more">C++中的sstream</a> (已完结)</li>
<li>更新 <a href="https://jasonxqh.github.io/2020/05/30/sscanf和sprintf/#more">C中的sscanf和sprintf函数</a>(已完结)</li>
<li>完善更新<a href="https://jasonxqh.github.io/2020/05/26/OOP-in-JavaScript/#more">OOP-in-JavaScript</a>中类部分（已完结），为学习react打基础</li>
</ol>
<h2 id="5-31"><a href="#5-31" class="headerlink" title="5.31"></a>5.31</h2><ol>
<li>更新<a href="https://jasonxqh.github.io/2020/05/30/react基础/#more">react基础</a> 组件部分（已完结） 组合组键部分（未完结）</li>
</ol>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/" itemprop="url">离散概率part3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-22T11:21:05+08:00">
                2020-05-22
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-09-06T12:19:06+08:00">
                2020-09-06
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="离散概率part3"><a href="#离散概率part3" class="headerlink" title="离散概率part3"></a>离散概率part3</h1><h2 id="Outline"><a href="#Outline" class="headerlink" title="Outline"></a>Outline</h2><p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/1.png" style="zoom:80%;"></p>
<h2 id="Expectation"><a href="#Expectation" class="headerlink" title="Expectation"></a>Expectation</h2><p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/2.png" style="zoom:80%;"></p>
<h3 id="期望的两种计算方法"><a href="#期望的两种计算方法" class="headerlink" title="期望的两种计算方法"></a>期望的两种计算方法</h3><p>期望的定义：所有的随机变量可能的取值乘以对应的概率，然后再求和。</p>
<p>但是我们要知道E(X)是一个加权的平均数。E(X)不再是一个随机变量了</p>
<p>定义一个偏差(deviation)为随机变量减去期望</p>
<h4 id="基于定义求"><a href="#基于定义求" class="headerlink" title="基于定义求"></a>基于定义求</h4><p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/3.png" style="zoom:80%;"></p>
<p>比如说我抛硬币100次，我们要看正面朝上的次数为多少，向上的概率为p</p>
<p>那么如果按照普通的算法，那么就要对每一个出现情况的概率进行求和，也就是对$2^{100}$个样本求和，那么我们如果对随机变量X求和，（X对应硬币朝上的个数）那么只要对0-100求和就行了。</p>
<p>只要知道分布，就知道期望了</p>
<h4 id="基于随机变量来求"><a href="#基于随机变量来求" class="headerlink" title="基于随机变量来求"></a>基于随机变量来求</h4><p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/4.png" style="zoom:80%;"></p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h4><p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/5.png" style="zoom:80%;"></p>
<p>我们不仅仅可以算X的期望，也可以计算$X^2$ ,$X^3$的期望，直接用它的函数值带入即可 </p>
<h4 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h4><p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/6.png" style="zoom:80%;"></p>
<h3 id="贝努力分布和几何分布的期望"><a href="#贝努力分布和几何分布的期望" class="headerlink" title="贝努力分布和几何分布的期望"></a>贝努力分布和几何分布的期望</h3><h4 id="贝努力分布"><a href="#贝努力分布" class="headerlink" title="贝努力分布"></a>贝努力分布</h4><p>The expected number of successes when n mutually independent Bernoulli trials are performed, where p is the probability of success on each trial, is <strong>np</strong>.</p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/7.png" style="zoom:80%;"></p>
<h4 id="几何分布"><a href="#几何分布" class="headerlink" title="几何分布"></a>几何分布</h4><p>The expected number of successes when a r.v. X follows a Geometric distribution is 1 p , where p is the probability of success on each trial.</p>
<p>也就是说第一次成功之前，已经做了多少次</p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/8.png" style="zoom:80%;"></p>
<h2 id="Linearity-of-expectations"><a href="#Linearity-of-expectations" class="headerlink" title="Linearity of expectations"></a>Linearity of expectations</h2><h3 id="期望的线性性质"><a href="#期望的线性性质" class="headerlink" title="期望的线性性质"></a>期望的线性性质</h3><p>1.和的期望等于期望的和</p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/9.png" style="zoom:150%;"></p>
<p>2.具有线性运算的性质$E(aX_i+b) = aE(X_i)+b$</p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/10.png" style="zoom:170%;"></p>
<ol>
<li>线性可加性 ,比如</li>
</ol>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/30.png" style="zoom:170%;"></p>
<h3 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h3><p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/11.png" style="zoom:80%;"></p>
<h3 id="贝努力实验的期望"><a href="#贝努力实验的期望" class="headerlink" title="贝努力实验的期望"></a>贝努力实验的期望</h3><p>根据期望的线性性，我们很容易就能算出n次贝努力实验的期望了</p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/12.png" style="zoom:60%;"></p>
<h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><h4 id="例一："><a href="#例一：" class="headerlink" title="例一："></a>例一：</h4><p>A new employee checks the hats of n people at a restaurant, forgetting to put claim check numbers on the hats. When customers return for their hats, the checker gives them back hats chosen at random from the remaining hats. What is the expected number of hats that are returned correctly?</p>
<p>就是说这个服务员是新来的，没有给顾客发取帽码，所以只能随便拿(帽子都一样)，问这个期望拿对的概率是多少</p>
<p>如果我们按照定义来算，那么就要算出来没有人能拿对的概率，一个人拿对的概率，。。。全部拿对的概率，也就是说先找分布，再计算期望。但这显然太麻烦了</p>
<p>所以 这样考虑：0个人拿对，那么n个人错排；1个人拿对，n-1个人错排。所以我们用期望的性质来做。我们来看第i个人是否拿对，拿对的概率 1/n,拿错的概率 n-1/n。求和即可</p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/13.png" style="zoom:80%;"></p>
<h4 id="例二："><a href="#例二：" class="headerlink" title="例二："></a>例二：</h4><p>计算一个数列中逆排列的数字对，逆排列就是说a&lt;b 但是a在b的后面，如图中所举例</p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/14.png" style="zoom:80%;"></p>
<p>那么对于一个数字对来说 $I_{i,j}$来说，他要么是逆序列，要么不是。所以说他的期望是 1/2</p>
<p>然后我们只要计算有几个这样的数字对即可，C(2,n) = n(n-1)/2 相乘得答案</p>
<h3 id="独立随机变量的期望"><a href="#独立随机变量的期望" class="headerlink" title="独立随机变量的期望"></a>独立随机变量的期望</h3><p>当X，Y相互独立的时候，期望的乘积就等于乘积的期望</p>
<p>$E(XY) = E(X)E(Y)$</p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/15.png" style="zoom:80%;"></p>
<h2 id="Average-case-computational-complexity"><a href="#Average-case-computational-complexity" class="headerlink" title="Average-case computational complexity"></a>Average-case computational complexity</h2><p>通过期望来计算平均的算法复杂度，也就是一般情况下大概是什么复杂度</p>
<p>那么他的期望就是输入一个数字的 概率，乘以其对应的比较次数</p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/16.png" style="zoom:100%;"></p>
<p>Finding the average-case computational complexity of an algorithm is usually much more diffcult than nding its worst-case computational complexity, and often involves the use of sophisticated methods.</p>
<h3 id="线性搜索算法"><a href="#线性搜索算法" class="headerlink" title="线性搜索算法"></a>线性搜索算法</h3><p><strong>Question:</strong> What is the average-case computational complexity of the linear search algorithm if the probability that x is in the list is p and it is equally likely that x is any of the n elements in the list?</p>
<p><strong>Solution:</strong> 也就是说，x和$a_i$ 去比较，那么需要比较 i 是否小于等于n 和 比较 x是否等于 $a_i$也就是说要比较两次，那么如果最终找到了，然后还要跳出循环，判断i是不是小于等于n，所以一共比较2i+1次</p>
<p>那么如果没找到，那么就是比较2n+2次</p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/1.jpg" style="zoom:80%;"></p>
<p>The probability that x equals ai ,<br>the i-th element in the list, is p/n, and the probability that x is not in the list is q = 1 - p.</p>
<p>令p指的是这个x落在这n个数中的概率。因为每个数可能是均匀分布在这个序列里面的，所以如果有5个数字，那么概率就是p/5,如果有n个数字，那么就是p/n.</p>
<p>那么我们就可以进行计算了</p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/17.png" style="zoom:60%;"></p>
<h3 id="插入排序算法"><a href="#插入排序算法" class="headerlink" title="插入排序算法"></a>插入排序算法</h3><p><strong>Question：</strong>What is the average number of comparisons used by the insertion sort to sort n distinct elements?</p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/2.jpg" style="zoom:60%;"></p>
<p><strong>Solution:</strong>We first suppose that X is the r.v. equal to # comparisons used by the insertion sort to sort a list a1, a2, … ; an of n distinct elements.<br>Then E(X) is the average number of comparisons used.</p>
<p>记作$a_k$为前j个元素中最大的元素,$1\leq k \leq j$</p>
<p>所以关键是看k落在第几个位置。如果k在第一个，那么每一个后来的都比 $a_k$ 小</p>
<p>如果是落在最后一个，那么每个都要比较一下</p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/18.png" style="zoom:70%;"></p>
<h2 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>方差可以对定义求和，也可以对随机变量来求</p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/19.png" style="zoom:70%;"></p>
<h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/20.png" style="zoom:70%;"></p>
<p>也可以这样来计算：X偏离均值的平方的期望</p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/21.png" style="zoom:70%;"></p>
<h3 id="各种分布的方差"><a href="#各种分布的方差" class="headerlink" title="各种分布的方差"></a>各种分布的方差</h3><h4 id="例一：贝努力实验的方差"><a href="#例一：贝努力实验的方差" class="headerlink" title="例一：贝努力实验的方差"></a>例一：贝努力实验的方差</h4><p><strong>Question:</strong> A coin is  flipped one time. Let $\Omega$ be the sample space of the possible outcomes, and let X be r.v. that assigns to an outcome # heads in this outcome. What is the variance of X if it is a biased coin with P({H}) = p?  </p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/24.png" style="zoom:90%;"></p>
<h4 id="例二：-二项分布的方差"><a href="#例二：-二项分布的方差" class="headerlink" title="例二： 二项分布的方差"></a>例二： 二项分布的方差</h4><p><strong>Question:</strong> Let r.v. X be the number of successes of n mutually independent Bernoulli trials, where p is the probability of success on each trial. What is the variance of X?</p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/23.png" style="zoom:90%;"></p>
<h4 id="例三：几何分布的方差"><a href="#例三：几何分布的方差" class="headerlink" title="例三：几何分布的方差"></a>例三：几何分布的方差</h4><p><strong>Question: </strong>Let r.v. X be the rst occurrence of success requires n mutually independent Bernoulli trials, where p is the probability of success on each trial. What is the variance of X?</p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/25.png" style="zoom:90%;"></p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/26.png" style="zoom:90%;"></p>
<h3 id="方差的非线性性"><a href="#方差的非线性性" class="headerlink" title="方差的非线性性"></a>方差的非线性性</h3><p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/28.png" style="zoom:90%;"></p>
<p>这说明什么道理呢？</p>
<p>说明对一列数进行平移，那么不会影响我的方差，如果对一列数进行拉伸a倍，那么方差就会扩大a的平方倍。</p>
<p>如果对一列数进行压缩，那么方差就会压缩的更厉害。</p>
<h3 id="Bienayme‘s-formula"><a href="#Bienayme‘s-formula" class="headerlink" title="Bienayme‘s formula"></a>Bienayme‘s formula</h3><p>当随机变量<strong>两两之间相互独立</strong>的时候，那么这时候方差的和就等于和的方差</p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/29.png" style="zoom:90%;"></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/31.png" style="zoom:90%;"></p>
<p>因为$X_i$ 是独立的而且是同分布的随机变量（独立且分布函数相同），这意味着所有的$X_i$的期望是一样的，$X_i$ 的方差也是一样的（比如抛筛子两次，第一次X1和第二次X2）</p>
<p>这个例子告诉我们什么呢？</p>
<p>原来$X_i$的方差是 $\sigma^2$ 那么 现在我们把 所有的$X_i $加起来后取平均数的话 方差会随着数量的增加而逐渐趋向于0</p>
<p>$\lim\limits_{n-&gt;\infty}V(\overline{X_n}) = 0$</p>
<p>也就是说，随着随机变量数量的增加，当n越来越大的时候，最后随机变量会变成一个常数。均值的方差会变得很小很小。</p>
<p>举个例子，我们 利用标记重补法来估算池塘中的鱼，那么一次的话可能说明不了问题，那么我们可以做很多次，然后取一平均值，这时候根据上面的公式，方差（波动）不会很大</p>
<h2 id="Tail-probability尾概率"><a href="#Tail-probability尾概率" class="headerlink" title="Tail probability尾概率"></a>Tail probability尾概率</h2><p>比如果我抛出100次硬币，那么50是它的期望</p>
<p>那么我们如果想要计算$P_n(X&gt;90)$和$P_n(X&lt;10)$ 这两个概率，就是一种尾概率</p>
<p>如果我们硬算，会变得很麻烦，很难计算 $\sum<em>{k=91}^{100}C</em>{100}^k \frac{1}{2}^{100} $</p>
<p>所以我们给他一个上界，估计估计，但是我又让这个上界越接近越好。那么怎么计算一下呢？</p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/3.jpg" style="zoom:90%;"></p>
<p>像上面这张图片，我们可以把这个看作抛了n次的模型，我们看到最后的概率接近0.5。这是因为Xi = {0,1},那么</p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/32.png" style="zoom:150%;"></p>
<p>当n越大的时候，方差越小，方差越小，波动就越小。</p>
<p>回到上面的问题 $P<em>n(X&gt;90) = P_n(\sum</em>{1}^nX_i&gt;=90)$</p>
<h3 id="Markovs-inequality"><a href="#Markovs-inequality" class="headerlink" title="Markovs inequality"></a>Markovs inequality</h3><h4 id="Theorem"><a href="#Theorem" class="headerlink" title="Theorem"></a>Theorem</h4><p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/33.png" style="zoom:90%;"></p>
<p>也就是说刚才的尾概率可以通过这样的方法来进行计算</p>
<h4 id="Proof"><a href="#Proof" class="headerlink" title="Proof"></a>Proof</h4><p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/34.png" style="zoom:90%;"></p>
<p>就比如说，我投n次币  ，我计算正面朝上的概率大于0.9 </p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/35.png" style="zoom:150%;"></p>
<p>但这个上界有问题，放的太宽了。n=100,n=1000，n越来越大的时候，概率应该越来越稳定才对，所以偏离p=0.5的概率会越来越小，但是根据马尔可夫不等式，却发现上界始终不变。所以不科学，不太准确</p>
<h3 id="Chebyshevs-inequality"><a href="#Chebyshevs-inequality" class="headerlink" title="Chebyshevs inequality"></a>Chebyshevs inequality</h3><p>所以我们来看切比雪夫不等式。马尔科夫不等式用的是期望，切比雪夫不等式用的是方差。这个方差会随着n的增加而慢慢减小，但是期望是不会随着n的变化而变化的，所以这就导致了两者的区别，一个和n无关，一个和n有关</p>
<h4 id="Theorem-1"><a href="#Theorem-1" class="headerlink" title="Theorem"></a>Theorem</h4><p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/36.png" style="zoom:150%;"></p>
<h4 id="Proof-1"><a href="#Proof-1" class="headerlink" title="Proof"></a>Proof</h4><p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/37.png" style="zoom:150%;"></p>
<p>马尔可夫不等式，是单尾的，只能计算&gt; 某个值的上界，但是切比雪夫不等式是双尾的，</p>
<p>双尾的肯定要比单尾的概率要大，所以我们通过这个关系把单尾转化成双尾再进行计算。</p>
<p>通过下面两个例子计算出的结果，要比马尔可夫不等式更科学，当n趋向于无穷的时候，尾概率会趋向于0，符合上面方差趋向于0的判断。</p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/38.png" style="zoom:150%;"></p>
<p>比如说我要计算刚才抛硬币的例子 </p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/39.png" style="zoom:100%;"></p>
<p>但是这样虽然符合观测结果，但也不能说切比雪夫不等式给出的上界，就是一个很好的上界，所以我们需要</p>
<p>Chernoff bound</p>
<h3 id="Chernoff-bound"><a href="#Chernoff-bound" class="headerlink" title="Chernoff bound"></a>Chernoff bound</h3><h4 id="Theorem-2"><a href="#Theorem-2" class="headerlink" title="Theorem"></a>Theorem</h4><p> <img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/40.png" style="zoom:80%;"></p>
<h4 id="Proof-2"><a href="#Proof-2" class="headerlink" title="Proof"></a>Proof</h4><p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/41.png" style="zoom:82%;"></p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/42.png" style="zoom:80%;"></p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/43.png" style="zoom:80%;"></p>
<h4 id="Theorem-for-upper-tail"><a href="#Theorem-for-upper-tail" class="headerlink" title="Theorem for upper tail"></a>Theorem for upper tail</h4><p>这是另外一个尾巴</p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/49.png" style="zoom:80%;"></p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/44.png" style="zoom:80%;"></p>
<p>关于这里分母为什么是4，我一直没搞明白</p>
<p>其实这里分母可以为大于2的任何数，3，4都可以。因为我们通过泰勒展开得到的分母为2，而</p>
<p>$\frac{-\mu\delta^2}{4}$ &gt;$\frac{-\mu\delta^2}{2}$  ,所以事实上这个界比$e^{\frac{-\mu\delta^2}{2}}$ 要松</p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/0.jpg" style="zoom: 67%;"></p>
<h4 id="example"><a href="#example" class="headerlink" title="example"></a>example</h4><p>比如说我们想要计算 $P(|x-\mu|&gt;\delta\mu)$ </p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/50.png" style="zoom:100%;"></p>
<p>这里的$\delta$ 是怎么求出来的呢？凑出来的。因为知道$\mu=\frac{n}{2}$（期望） 然后 根据我们要求的尾概率，提取出$\mu$ 来看他的系数即可</p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/45.png" style="zoom:80%;"></p>
<p>像下面这个例子，对我们理解切诺夫界更有帮助</p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/46.png" style="zoom:80%;"></p>
<p>这相当于一个不均匀的硬币，有$\frac{\pi}{4}$ 的概率正面（红色圆域） ，剩下的概率为反面（绿色部分）</p>
<p>Y就相当于抛出n次后打包在一起的一个随机变量。</p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/47.png" style="zoom:80%;"></p>
<p>那么我如果要计算$Y&gt;\frac{\pi}{2}$ 的概率（事实上这个等于0）那么我们就可以按照上面的方法计算。</p>
<p>$P(Y-\frac{\pi}{4}&gt;\frac{\pi}{4})$ 的 意思，其实就是偏移方差量大于$\frac{\pi}{4}$ 的意思，概率肯定是随着n的增加而接近于0。</p>
<p>所以根据切比雪夫不等式我们可以得到了当n=100的时候，这个概率的上界是0.0025 但这还不是最准确的</p>
<p><img src="/2020/05/22/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87part3/48.png" style="zoom:80%;"></p>
<p>当我们用切诺夫界来计算的时候，那么概率变成了e^(-75/4)^  也就是小数点后10个0的概率，而事实上的概率比这个还要小。所以说切诺夫界比切比雪夫不等式更加的准确</p>
<p>所以说我们想要达到一个精度（偏移期望的概率达到足够小） 对于切比雪夫来说，需要做的次数要远高于切诺夫界所需要的次数，因为切诺夫界是按照指数缩小的</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/05/20/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/20/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/" itemprop="url">无穷级数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-20T21:14:28+08:00">
                2020-05-20
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-06-13T12:09:46+08:00">
                2020-06-13
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="无穷级数"><a href="#无穷级数" class="headerlink" title="无穷级数"></a>无穷级数</h1><h2 id="常数项级数的概念"><a href="#常数项级数的概念" class="headerlink" title="常数项级数的概念"></a>常数项级数的概念</h2><h3 id="引例1-用圆内接正多边形面积逼近圆面积"><a href="#引例1-用圆内接正多边形面积逼近圆面积" class="headerlink" title="引例1.用圆内接正多边形面积逼近圆面积"></a>引例1.用圆内接正多边形面积逼近圆面积</h3><p>依次作圆内接正$3 \cdot 2^n(n=1,2,\Lambda)$ 边形，设$a_0$表示内接正三角形的面积，$a_k$表示边数增加时增加的面积，则圆内接正$3\cdot 2^n$边形的面积为</p>
<p>$a_0+a_1+a_2+\Lambda+a_n$</p>
<p>当$n-&gt;\infty$时，这个和逼近圆的面积A，即$A=a_0+a_1+a_2+\Lambda+a_n$</p>
<h3 id="引例2"><a href="#引例2" class="headerlink" title="引例2"></a>引例2</h3><p><img src="/2020/05/20/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/2.png" style="zoom: 50%;"></p>
<h3 id="引例3"><a href="#引例3" class="headerlink" title="引例3"></a>引例3</h3><p><img src="/2020/05/20/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/1.png" style="zoom: 50%;"></p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>给定一个数列$u<em>1,u_2,u_3..\Lambda,u_n,\Lambda$将各项依次相加。记为$\sum</em>{n=1}^{\infty}u_n$</p>
<p>即$\sum_{n=1}^{\infty}u_n = u_1,u_2,u_3..\Lambda,u_n,\Lambda$</p>
<p>称上式为无穷级数，其中第n项 $u<em>n$叫做级数的一般项，级数的前n项和$S_n=\sum</em>{k=1}^{n}u_k = u_1,u_2,u_3..\Lambda,u_n$ 称作级数的部分和</p>
<p>若$\lim\limits<em>{n-&gt;\infty}S_n = S$存在，则称无穷级数收敛，并称S为级数的和记作$S=\sum</em>{n=1}^{\infty}u_n$</p>
<p>若$\lim\limits_{n-&gt;\infty}S_n = S$不存在m,则称无穷级数发散</p>
<p>那么，当级数收敛时， $r<em>n = S-S_n = u</em>{n+1}+u<em>{n+2}+\Lambda$ 为级数的余项，显然 $\lim\limits</em>{n-&gt;\infty}r_n = 0$</p>
<h3 id="例一：讨论等比级数（几何级数）"><a href="#例一：讨论等比级数（几何级数）" class="headerlink" title="例一：讨论等比级数（几何级数）"></a>例一：讨论等比级数（几何级数）</h3><p>$\sum_{n=0}^{\infty}aq^n = a+aq+aq^2+\Lambda+aq^n+\Lambda(a\neq 0)$(q称为公比)的敛散性</p>
<p><img src="/2020/05/20/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/3.png" style="zoom: 55%;"></p>
<p><img src="/2020/05/20/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/4.png" style="zoom: 50%;"></p>
<h3 id="例二：判断下列级数的敛散性"><a href="#例二：判断下列级数的敛散性" class="headerlink" title="例二：判断下列级数的敛散性"></a>例二：判断下列级数的敛散性</h3><p><img src="/2020/05/20/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/5.png" style="zoom: 50%;"></p>
<p><img src="/2020/05/20/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/6.png" style="zoom: 50%;"></p>
<p><img src="/2020/05/20/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/7.png" style="zoom: 50%;"></p>
<p>现在，我们只能通过前n项的和来进行判断</p>
<p><img src="/2020/05/20/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/8.png" style="zoom: 50%;"></p>
<h2 id="无穷级数的基本性质"><a href="#无穷级数的基本性质" class="headerlink" title="无穷级数的基本性质"></a>无穷级数的基本性质</h2><h3 id="性质1"><a href="#性质1" class="headerlink" title="性质1"></a>性质1</h3><p><img src="/2020/05/20/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/9.png" style="zoom: 50%;"></p>
<p> 级数各项乘以非零常数后其敛散性不变</p>
<h3 id="性质2"><a href="#性质2" class="headerlink" title="性质2"></a>性质2</h3><p><img src="/2020/05/20/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/10.png" style="zoom: 60%;"></p>
<p><img src="/2020/05/20/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/11.png" style="zoom: 50%;"></p>
<h3 id="性质3"><a href="#性质3" class="headerlink" title="性质3"></a>性质3</h3><p>在级数前面加上或去掉有限项，都不会影响级数的敛散性</p>
<p><img src="/2020/05/20/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/12.png" style="zoom: 50%;"> </p>
<h3 id="性质4"><a href="#性质4" class="headerlink" title="性质4"></a>性质4</h3><p>收敛级数加括弧后所成的级数仍收敛于原级数的和 </p>
<p><img src="/2020/05/20/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/13.png" style="zoom: 50%;"></p>
<h2 id="级数收敛的必要条件"><a href="#级数收敛的必要条件" class="headerlink" title="级数收敛的必要条件"></a>级数收敛的必要条件</h2><p><img src="/2020/05/20/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/14.png" style="zoom: 50%;"></p>
<p><img src="/2020/05/20/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/15.png" style="zoom: 50%;"></p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="/2020/05/20/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/16.png" style="zoom: 50%;"></p>
<h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p><img src="/2020/05/20/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/17.png" style="zoom: 50%;"></p>
<p><img src="/2020/05/20/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/18.png" style="zoom: 50%;"></p>
<p><img src="/2020/05/20/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/19.png" style="zoom: 50%;"></p>
<p><img src="/2020/05/20/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/20.png" style="zoom: 50%;"></p>
<h2 id="柯西审敛原理"><a href="#柯西审敛原理" class="headerlink" title="柯西审敛原理"></a>柯西审敛原理</h2><p><img src="/2020/05/20/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/21.png" style="zoom: 50%;"></p>
<p><img src="/2020/05/20/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/22.png" style="zoom: 50%;"></p>
<p><img src="/2020/05/20/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/23.png" style="zoom: 50%;"></p>
<h2 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h2><p>第一节的题目普遍比较简单。常常有这样的题形：</p>
<p><strong>请用级数收敛发散的性质(定义) 判别下列级数的敛散性</strong></p>
<p>那么我们可以用什么方法？</p>
<ul>
<li>首先看看是否满足必要性。 必要性就是当n趋向无穷大的时候，单项是否趋于0，如果趋于零那么再做判断，否则直接写：“不满足级数收敛的必要条件，原级数发散”<ul>
<li>这里还要注意，如果级数是周期波动的，比如 $\sin\frac{\pi}{n}$ ，是没有固定极限的，所以也发</li>
</ul>
</li>
<li>其次看看是不是可以拆分成两个级数，然后通过级数的性质判断：<ul>
<li>如果两个级数都是收敛的，其和其差一定是收敛的</li>
<li>如果两个级数有一个是收敛的有一个是发散的，那么其和其差一定是放散的</li>
<li>如果两个级数都是发散的，<strong>无法判断</strong></li>
</ul>
</li>
</ul>
<p><img src="/2020/05/20/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/1.jpg" style="zoom: 70%;"></p>
<p><img src="/2020/05/20/%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/2.jpg" style="zoom: 70%;"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/05/20/python%E5%8A%9E%E5%85%AC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/20/python%E5%8A%9E%E5%85%AC/" itemprop="url">python办公</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-20T12:38:27+08:00">
                2020-05-20
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-05-21T15:32:22+08:00">
                2020-05-21
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="python办公"><a href="#python办公" class="headerlink" title="python办公"></a>python办公</h1><h2 id="Working-with-Paths"><a href="#Working-with-Paths" class="headerlink" title="Working with Paths"></a>Working with Paths</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line">path = Path(<span class="string">"__init__.py"</span>)</span><br><span class="line">path.exists()			<span class="comment">#让文件一直打开着</span></span><br><span class="line">print(path.is_file())	<span class="comment"># 判断该路径是否为文件 true</span></span><br><span class="line">print(path.is_dir())	<span class="comment"># 判断该路径是否为目录 false</span></span><br><span class="line">print(path.name)		<span class="comment"># 输出文件名称(包括扩展名)</span></span><br><span class="line">print(path.stem)		<span class="comment"># 输出主干名称(不包括扩展名)</span></span><br><span class="line">print(path.suffix)		<span class="comment"># 输出扩展名</span></span><br><span class="line">print(path.parent)		<span class="comment"># 输出上层目录</span></span><br><span class="line">path=path.with_name(<span class="string">"file.txt"</span>)	<span class="comment"># 修改文件的名称</span></span><br><span class="line">path=path.with_suffix(<span class="string">".txt"</span>)	<span class="comment"># 修改文杰的扩展名</span></span><br><span class="line">print(path)						</span><br><span class="line">print(path.absolute())			<span class="comment"># 输出绝对路径</span></span><br></pre></td></tr></table></figure>
<h2 id="Working-with-Directories"><a href="#Working-with-Directories" class="headerlink" title="Working with Directories"></a>Working with Directories</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line">path = Path(<span class="string">"D://"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> path.iterdir():</span><br><span class="line">    print(p)	<span class="comment">#输出目录中的文件</span></span><br><span class="line">paths = [p <span class="keyword">for</span> p <span class="keyword">in</span> path.iterdir()]</span><br><span class="line">print(paths)</span><br></pre></td></tr></table></figure>
<h2 id="Working-with-Files"><a href="#Working-with-Files" class="headerlink" title="Working with Files"></a>Working with Files</h2><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>stat 系统调用时用来返回相关文件的系统状态信息的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line">path = Path(<span class="string">"D://"</span>)</span><br><span class="line"></span><br><span class="line">print(path.stat())</span><br></pre></td></tr></table></figure>
<h3 id="查看创建时间"><a href="#查看创建时间" class="headerlink" title="查看创建时间"></a>查看创建时间</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime</span><br><span class="line">path = Path(<span class="string">"D://1.TXT"</span>)</span><br><span class="line">path2 = Path(<span class="string">"D://"</span>)</span><br><span class="line">print(ctime(path2.stat().st_ctime))<span class="comment"># Fri Apr 19 08:29:08 2019</span></span><br><span class="line">print(ctime(path.stat().st_ctime)) <span class="comment"># Wed May 20 13:24:21 2020</span></span><br><span class="line">print(path.read_text())	<span class="comment">#	My name is Jason</span></span><br><span class="line">path.write_text(<span class="string">""</span>)		<span class="comment"># 写点东西</span></span><br><span class="line">path.write_bytes()</span><br></pre></td></tr></table></figure>
<h3 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h3><p>如何把一个文件中的内容拷贝到另一个文件呢</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line">source = Path(<span class="string">"D://1.TXT"</span>)</span><br><span class="line">target = Path() / <span class="string">"xixi.py"</span></span><br><span class="line">shutil.copy(source,target)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/20/python%E5%8A%9E%E5%85%AC/1.png" style="zoom:;"></p>
<h2 id="Working-with-Zip-Files"><a href="#Working-with-Zip-Files" class="headerlink" title="Working with Zip Files"></a>Working with Zip Files</h2><h3 id="使用zipfile压缩文件"><a href="#使用zipfile压缩文件" class="headerlink" title="使用zipfile压缩文件"></a>使用zipfile压缩文件</h3><p> <strong>创建一个zip文件对象，压缩是需要把mode改为‘w’</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zfile=zipfile.ZipFile(<span class="string">"test.zip"</span>,<span class="string">"w"</span>)</span><br></pre></td></tr></table></figure>
<p> <strong>将文件写入zip文件中，即将文件压缩</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zfile.write(<span class="string">r"../test.py"</span>)</span><br></pre></td></tr></table></figure>
<p> <strong>将zip文件对象关闭</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zfile.close()</span><br></pre></td></tr></table></figure>
<p><strong>使用 zipfile 解压文件</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br></pre></td></tr></table></figure>
<p> <strong>解压</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zfile=zipfile.ZipFile(<span class="string">"../test.zip"</span>,<span class="string">"r"</span>)</span><br><span class="line">zfile.extractall()</span><br></pre></td></tr></table></figure>
<h3 id="利用pathlib遍历目录Path-rglob"><a href="#利用pathlib遍历目录Path-rglob" class="headerlink" title="利用pathlib遍历目录Path().rglob"></a>利用pathlib遍历目录Path().rglob</h3><p> 因为*可以代表任何字符，所以<br>rglob(‘*.py’) 就代表后缀名为.py的所有文件<br>rglob(‘*.*‘)就代表不论什么后缀名的所有文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> zipfile <span class="keyword">import</span> ZipFile</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ZipFile(<span class="string">"files.zip"</span>,<span class="string">"w"</span>) <span class="keyword">as</span> zip:</span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> Path(<span class="string">"D://untitled"</span>).rglob(<span class="string">"*.*"</span>):</span><br><span class="line">        zip.write(path)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/20/python%E5%8A%9E%E5%85%AC/2.png" style="zoom: 67%;"></p>
<h2 id="Working-with-CSV-Files"><a href="#Working-with-CSV-Files" class="headerlink" title="Working with CSV Files"></a>Working with CSV Files</h2><h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"data.csv"</span>,<span class="string">"w"</span>,newline=<span class="string">''</span>) <span class="keyword">as</span> file:</span><br><span class="line">    writer = csv.writer(file)</span><br><span class="line">    writer.writerow ([<span class="string">"transaction_id"</span>,<span class="string">"product_id"</span>,<span class="string">"price"</span>])</span><br><span class="line">    writer.writerow ([<span class="number">1000</span>,<span class="number">1</span>,<span class="number">5</span>])</span><br><span class="line">    writer.writerow ([<span class="number">1000</span>,<span class="number">11</span>,<span class="number">52</span>])</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/20/python%E5%8A%9E%E5%85%AC/3.png" style="zoom:  %;"></p>
<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>当我们通过迭代来输出的时候，会输出三个List。上面的迭代已经成功了，那么当我们再次想输出list的时候，就发现仅仅输出一个[]。因为后面没东西了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"data.csv"</span>) <span class="keyword">as</span> file:</span><br><span class="line">    reader = csv.reader(file)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        print(row)</span><br><span class="line">    print(list(reader))    </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">['transaction_id', 'product_id', 'price']</span></span><br><span class="line"><span class="string">['1000', '1', '5']</span></span><br><span class="line"><span class="string">['1000', '11', '52']</span></span><br><span class="line"><span class="string">[]</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<p>但是，当我们先print(list(reader))的时候，再迭代输出的时候，就什么都输出不了。 输出的时候，文件已经读完了，再去读就读不到什么东西。所以只输出一个List</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"data.csv"</span>) <span class="keyword">as</span> file:</span><br><span class="line">    reader = csv.reader(file)</span><br><span class="line">    print(list(reader))</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        print(row)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[['transaction_id', 'product_id', 'price'], ['1000', '1', '5'], ['1000', '11', '52']] </span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h2 id="Working-with-JSON-Files"><a href="#Working-with-JSON-Files" class="headerlink" title="Working with JSON Files"></a>Working with JSON Files</h2><h3 id="写入json文件"><a href="#写入json文件" class="headerlink" title="写入json文件"></a>写入json文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">movies = [</span><br><span class="line">    &#123;<span class="string">"id"</span>:<span class="number">1</span>,<span class="string">"title"</span>:<span class="string">"Terminator"</span>,<span class="string">"year"</span>:<span class="number">1989</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"id"</span>:<span class="number">3</span>,<span class="string">"title"</span>:<span class="string">"Kindergarten Cop"</span>,<span class="string">"year"</span>:<span class="number">1993</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">data = json.dumps(movies)</span><br><span class="line">print(data)</span><br><span class="line"><span class="comment">#输出一个列表 [&#123;"id": 1, "title": "Terminator", "year": 1989&#125;, &#123;"id": 3, "title": "Kindergarten Cop", "year": 1993&#125;]</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/20/python%E5%8A%9E%E5%85%AC/4.png" style="zoom:80%;"></p>
<h3 id="读取json文件"><a href="#读取json文件" class="headerlink" title="读取json文件"></a>读取json文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line">data = Path(<span class="string">"movies.json"</span>).read_text()</span><br><span class="line">movies = json.loads(data)</span><br><span class="line">print(movies)</span><br><span class="line">print(movies[<span class="number">0</span>])</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">输出: </span></span><br><span class="line"><span class="string">[&#123;'id': 1, 'title': 'Terminator', 'year': 1989&#125;, &#123;'id': 3, 'title': 'Kindergarten Cop', 'year': 1993&#125;]</span></span><br><span class="line"><span class="string">&#123;'id': 1, 'title': 'Terminator', 'year': 1989&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<h2 id="Working-with-Timestamps"><a href="#Working-with-Timestamps" class="headerlink" title="Working with Timestamps"></a>Working with Timestamps</h2><p>输出秒数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_emails</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000000</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">send_emails()</span><br><span class="line">end = time.time()</span><br><span class="line">duration = end-start</span><br><span class="line">print(duration)</span><br><span class="line"><span class="comment"># 0.14830493927001953</span></span><br></pre></td></tr></table></figure>
<h2 id="Working-with-Datetimes"><a href="#Working-with-Datetimes" class="headerlink" title="Working with Datetimes"></a>Working with Datetimes</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> _datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">dt2 = datetime(<span class="number">2018</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">dt = datetime.now()</span><br><span class="line">print(datetime.strptime(<span class="string">"19/01/01"</span>,<span class="string">"%y/%m/%d"</span>))	<span class="comment"># 2019-01-01 00:00:00</span></span><br><span class="line">dt=datetime.fromtimestamp(time.time())	</span><br><span class="line">print(dt)<span class="comment"># 2020-05-20 14:55:54.447580</span></span><br><span class="line">print(<span class="string">f"<span class="subst">&#123;dt.year&#125;</span>/<span class="subst">&#123;dt.month&#125;</span>"</span>)	<span class="comment"># 2020/05</span></span><br><span class="line">print(dt.strftime(<span class="string">"%Y/%m"</span>))		<span class="comment"># 2020/05</span></span><br><span class="line">print(dt&gt;dt2)					<span class="comment"># true</span></span><br></pre></td></tr></table></figure>
<h2 id="Working-with-Time-Deltas"><a href="#Working-with-Time-Deltas" class="headerlink" title="Working with Time Deltas"></a>Working with Time Deltas</h2><p>Time delta就相当于附加在datetime上的时间</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> _datetime <span class="keyword">import</span> datetime,timedelta</span><br><span class="line"> </span><br><span class="line">dt1 = datetime(<span class="number">2018</span>,<span class="number">1</span>,<span class="number">1</span>)+timedelta(days=<span class="number">23</span>,seconds=<span class="number">1000</span>)</span><br><span class="line">print(dt1)	<span class="comment">#2018-01-24 00:16:40</span></span><br><span class="line">duration = dt2-dt1</span><br><span class="line">print(duration)<span class="comment"># 847 days, 14:53:32.316273</span></span><br><span class="line">print(<span class="string">"days"</span>,duration.days)</span><br><span class="line">print(<span class="string">"seconds"</span>,duration.seconds)	<span class="comment"># 这算的是14:53:32.316273代表的秒数</span></span><br><span class="line">print(<span class="string">"total seconds"</span>,duration.total_seconds())<span class="comment"># 这算的是847 days, 14:53:32.316273的秒数</span></span><br><span class="line">print(<span class="string">""</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Generating-Random-Values"><a href="#Generating-Random-Values" class="headerlink" title="Generating Random Values"></a>Generating Random Values</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">print(random.random())		<span class="comment"># 生成一个0-1之间的随机数</span></span><br><span class="line">print(random.randint(<span class="number">1</span>,<span class="number">10</span>))	<span class="comment"># 生成一个1-10之间的整数</span></span><br><span class="line">print(random.choice([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]))<span class="comment"># 生成列表之间的一个数</span></span><br><span class="line">print(random.choices([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],k=<span class="number">2</span>))	<span class="comment"># 生成两个从列表中选择的数字</span></span><br><span class="line">print(<span class="string">""</span>.join(random.choices( <span class="string">"abcdeusac8ui"</span>,k=<span class="number">4</span>)))<span class="comment">#生成4个，并合并成一个字符串</span></span><br><span class="line">print(<span class="string">""</span>.join(random.choices( string.ascii_letters+string.digits,k=<span class="number">4</span>)))</span><br><span class="line"><span class="comment"># ascii_letters是string类的一个属性，包含了所有大小写字母，通里digits包含了所有数字</span></span><br></pre></td></tr></table></figure>
<h2 id="Opening-the-Browser"><a href="#Opening-the-Browser" class="headerlink" title="Opening the Browser"></a>Opening the Browser</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import webbrowser</span><br><span class="line">print(&quot;Deplotment completed&quot;)</span><br><span class="line">webbrowser.open(&quot;http:&#x2F;&#x2F;google.com&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="Sending-Emails"><a href="#Sending-Emails" class="headerlink" title="Sending Emails"></a>Sending Emails</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line">message = MIMEMultipart()</span><br><span class="line">message[<span class="string">"from"</span>] = <span class="string">"Jason"</span></span><br><span class="line">message[<span class="string">"to"</span>] = <span class="string">"目标邮箱"</span></span><br><span class="line">message[<span class="string">"subject"</span>] = <span class="string">"This is a test"</span></span><br><span class="line"></span><br><span class="line">message.attach(MIMEText(<span class="string">"Body"</span>))</span><br><span class="line"><span class="keyword">with</span> smtplib.SMTP(host=<span class="string">"smtp.gmail.com"</span>,port = <span class="number">587</span>) <span class="keyword">as</span> smtp:</span><br><span class="line">    smtp.ehlo()</span><br><span class="line">    smtp.starttls()</span><br><span class="line">    smtp.login(<span class="string">"邮箱"</span>,<span class="string">"密码"</span>)</span><br><span class="line">    smtp.send_message(message)</span><br><span class="line">    print(<span class="string">"Sent..."</span>)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/05/20/82-83%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/20/82-83%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/" itemprop="url">82-83删除链表的重复元素</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-20T10:45:55+08:00">
                2020-05-20
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-05-20T10:50:04+08:00">
                2020-05-20
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a>82. 删除排序链表中的重复元素 II</h1><h2 id="下面是题目"><a href="#下面是题目" class="headerlink" title="下面是题目"></a>下面是题目</h2><p><img src="/2020/05/20/82-83%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/1.png" alt></p>
<h3 id="下面是题目给出的模板"><a href="#下面是题目给出的模板" class="headerlink" title="下面是题目给出的模板"></a>下面是题目给出的模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="这里给出两种放法，第一种是我通过模仿1171的思路通过unordered-map存储来实现的，第二种是更快的解题方法"><a href="#这里给出两种放法，第一种是我通过模仿1171的思路通过unordered-map存储来实现的，第二种是更快的解题方法" class="headerlink" title="这里给出两种放法，第一种是我通过模仿1171的思路通过unordered_map存储来实现的，第二种是更快的解题方法"></a>这里给出两种放法，第一种是我通过模仿1171的思路通过unordered_map存储来实现的，第二种是更快的解题方法</h3><h4 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 	这道题，我才用遍历两边的思路完成所有重复节点的删除</span></span><br><span class="line"><span class="comment"> 	拿123344556来做实验</span></span><br><span class="line"><span class="comment"> 	第一道遍历，将重复的节点删除，但保留重复的第一个节点，同时把3，4，5存储到set中</span></span><br><span class="line"><span class="comment">比如现在，链表已经变成123456了</span></span><br><span class="line"><span class="comment">	第二道遍历，判断节点值是否在set中出现过，如果出现，则删除，比如3，4，5已经在表中了。现在删除他们 最后的得到126</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode*dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy-&gt;next=head;</span><br><span class="line">        <span class="comment">//思路差不多，我也是利用unordered_map 来记录一个是否重复的元素</span></span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;judge;</span><br><span class="line">        <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        <span class="keyword">while</span>( p-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next-&gt;val==p-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">                judge.insert(p-&gt;val);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = dummy;</span><br><span class="line">        <span class="comment">//第二段遍历，删除存储在set中的节点</span></span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(judge.<span class="built_in">find</span>(p-&gt;next-&gt;val)!=judge.<span class="built_in">end</span>())</span><br><span class="line">              p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">               p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="第二种解法"><a href="#第二种解法" class="headerlink" title="第二种解法"></a>第二种解法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	这个方法也是遍历，但是没有依赖其他容器，而且只遍历了一遍</span></span><br><span class="line"><span class="comment">	思路：</span></span><br><span class="line"><span class="comment">		通过两个指针来实现遍历操作</span></span><br><span class="line"><span class="comment">		下面的题解以12333445为例</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* p = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        p-&gt;next = head;</span><br><span class="line">        head = p;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;next-&gt;next) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//这里把p当作第一个重复节点的前一个结点进行运算，现在p为2，但是接下来是三个相同节点345</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next-&gt;val == p-&gt;next-&gt;next-&gt;val)&#123;</span><br><span class="line">                <span class="comment">//进入if语句后，把i指向第5个节点。如果第五个节点或者后面的节点还是和第3个节点的值一样，那就移动i，直到不一样位置，再把当前的p节点指向i，完成中间所有重复节点的删除</span></span><br><span class="line">                ListNode* i = p-&gt;next-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">while</span>(i)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i-&gt;val == p-&gt;next-&gt;val)&#123;</span><br><span class="line">                        i = i-&gt;next;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//更新p后面节点的值，也就是现在p-&gt;next =  4,开始下一轮遍历！</span></span><br><span class="line">                p-&gt;next = i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//更新p的值，寻找下个重复的节点</span></span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83 删除排序链表中的重复元素"></a>83 删除排序链表中的重复元素</h1><p><img src="/2020/05/20/82-83%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/2.png" alt></p>
<h2 id="下面是题目给出的模板-1"><a href="#下面是题目给出的模板-1" class="headerlink" title="下面是题目给出的模板"></a>下面是题目给出的模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode*cur = head;</span><br><span class="line">    ListNode*toDelete = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;next-&gt;val==cur-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            toDelete = cur -&gt;next;</span><br><span class="line">            cur-&gt;next= cur-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> toDelete;</span><br><span class="line">            toDelete = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/26/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><span class="page-number current">27</span><a class="page-number" href="/page/28/">28</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/28/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/%5Bobject%20Object%5D"
                alt="Jason" />
            
              <p class="site-author-name" itemprop="name">Jason</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20fa%20fa-archive">
              
                  <span class="site-state-item-count">435</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">61</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="true"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
 <!--
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>







-->
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>




















  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v="></script>

  <script type="text/javascript" src="/js/src/motion.js?v="></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v="></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
