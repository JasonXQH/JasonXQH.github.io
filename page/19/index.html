<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=">


  <link rel="mask-icon" href="/images/logo.svg?v=" color="#222">














<meta property="og:type" content="website">
<meta property="og:title" content="Jason‘s Blog">
<meta property="og:url" content="https://jasonxqh.github.io/page/19/index.html">
<meta property="og:site_name" content="Jason‘s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '',
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    fancybox: false,
    tabs: ,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: 'undefined',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>







  <title>Jason‘s Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', '[object Object]', 'auto');
  ga('send', 'pageview');
</script>





<meta name="generator" content="Hexo 4.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">
  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
<a href="https://github.com/JasonXQH/JasonXQH.github.io" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jason‘s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/%20" rel="section">
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/" itemprop="url">CSAPP程序的机器级表示3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-10-20T16:55:46+08:00">
                2020-10-20
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-10-28T11:02:44+08:00">
                2020-10-28
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="CSAPP程序的机器级表示3"><a href="#CSAPP程序的机器级表示3" class="headerlink" title="CSAPP程序的机器级表示3"></a>CSAPP程序的机器级表示3</h1><h2 id="数组的分配和访问"><a href="#数组的分配和访问" class="headerlink" title="数组的分配和访问"></a>数组的分配和访问</h2><h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h3><p>我们首先来看看数组的声明</p>
<p><strong>T A[N]</strong> </p>
<p>其中T是数据类型，N是整形常数。</p>
<p>这个声明有两个效果</p>
<ul>
<li>在内存中分配了一个 $L\cdot N$ 字节的连续区域，这里L是数据类型T的大小（单位为字节）。</li>
<li>引入了标识符A，可以用A来做指向数组开头的指针，记为 $x_A$。然后可以用 $0\sim {N-1}$ 的整数索引来范根该数组元素。数组元素i会被存放在地址为 $x_A+L\cdot i$ 的地方</li>
</ul>
<p>下面申请了几个数组，我们可以看到数组成员在地址上的位置</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/1.png"></p>
<p>假如 E 是一个int型的数组，而我们想计算 $E[i]$ ，在此，E的地址存放在寄存器 $\%rdx$ 中，而 i 存放在寄存器 $\%rcx$ 中。然后再指令 </p>
<p>$movl~~(\%rdx,\%rcx,4),\%eax$   会执行计算 $x_E+4i$  读取这个内存位置的值，并将结果存放到寄存器 $\%eax$ 中。允许的伸缩因子 1、2、4、8 刚好能覆盖了所有基本简单数据类型的大小。 </p>
<h3 id="访问数组"><a href="#访问数组" class="headerlink" title="访问数组"></a>访问数组</h3><p>访问数组的形式非常多样</p>
<p>C语言允许对指针进行运算，而计算出来的值会<strong>根据该指针引用的数据类型大小进行伸缩</strong>。也就是说如果 p 是一个指向 类型为T 的数据的指针，那么表达式 p+i 就等于 $x_p+L\cdot i$ </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>表达式</th>
<th>类型</th>
<th>值</th>
<th>汇编代码</th>
</tr>
</thead>
<tbody>
<tr>
<td>E</td>
<td>int *</td>
<td>$x_E$</td>
<td>movq %rdx,%rax</td>
</tr>
<tr>
<td>E[0]</td>
<td>int</td>
<td>$M[x_E]$ //在$x_E$ 地址上的值</td>
<td>movl (%rdx),%rax</td>
</tr>
<tr>
<td>E[i]</td>
<td>int</td>
<td>$M[x_E+4i]$</td>
<td>movl (%rdx,%rcx,4) ,%eax</td>
</tr>
<tr>
<td>&amp;E[2]</td>
<td>int*</td>
<td>$x_E+8$</td>
<td>leaq 8(%rdx),%rax</td>
</tr>
<tr>
<td>E+i-1</td>
<td>int*</td>
<td>$x_E+4i-4$</td>
<td>leaq -4(%rdx,%rcx,4) ,%rax</td>
</tr>
<tr>
<td>*(E+i-3)</td>
<td>int</td>
<td>$M[x_E+4i-12]$</td>
<td>movl -12(%rdx,%rcx,4),%eax</td>
</tr>
<tr>
<td>&amp;E[i]-E</td>
<td>long</td>
<td>i</td>
<td>movq %rcx,%rax</td>
</tr>
</tbody>
</table>
</div>
<p>最后一个例子是两个指针之差，结果的数据类型为long</p>
<h4 id="Array-Loop-Example"><a href="#Array-Loop-Example" class="headerlink" title="Array Loop Example"></a>Array Loop Example</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zincr</span><span class="params">(zip_dig z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    z[i]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 函数的汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># %rdi &#x3D; z</span><br><span class="line">	movl 	$0, %eax 			# i &#x3D; 0</span><br><span class="line">	jmp 	.L3 				# goto middle</span><br><span class="line">.L4: 							# loop:</span><br><span class="line">	addl 	$1, (%rdi,%rax,4) 	# z[i]++</span><br><span class="line">	addq 	$1, %rax 			# i++</span><br><span class="line">.L3: 							# middle</span><br><span class="line">	cmpq 	$4, %rax 			# i:4</span><br><span class="line">	jbe 	.L4 				# if &lt;&#x3D;, goto loop	</span><br><span class="line">	rep; ret</span><br></pre></td></tr></table></figure>
<p>.L3 中，需要用 i 和 4相比，如果小于等于4，那么就跳转到 .L4</p>
<p>现在我们举几个数组和指针的例子</p>
<p>Comp: Compiles (Y/N)<br>Bad:     Possible bad pointer reference (Y/N)<br>Size:     Value returned by sizeof</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/2.png"></p>
<ul>
<li>首先 $A1[3]$  和 $*A2$ 都是 可以通过编译的，而且指针都不是非法的。</li>
<li>因为A1有3个int，所以数组大小是 12个字节，*A2 是指针，长度为8个字节</li>
<li>对于 *A1和 *A2,它们都是能通过编译的，但是对A1来说，在声明之初已经申请了地址了，只是没有初始化，所以*A1 是任意一个值，而 *A2则没有为其分配内存，输出*A2 就会出错，而对于*A1 和 *A2,声明之初是int，所以Size为4个字节</li>
</ul>
<p>现在来看看更加复杂的问题： </p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/3.png"></p>
<ul>
<li>A1[3]是一维数组, *A2[3]是指针数组 ,也就是用来存放指针的数组，这些指针会指向 int 类型的数据。  (*A3)[3]是一个数组指针，也就是指向长度为3的数组的指针 这三者都能通过编译。</li>
<li>对于 (*A3)[3] 来说，*An就是它指向的地方也就是数组，数组有3个int数据，大小为 12 size 。但这个数组的内存尚未分配，所以是 Bad Reference。对于 *A2[3] 来说，*An 就是指针数组中的指针，是分配过内存的，大小为8size</li>
<li>对于A1[3]来说 **An 不存在这种定义。对 *A2[3] 来说，<em>\</em>An 是指针指向的区域，但因为这些区域没有分配内存，所以是非法的。对(*A3)[3] 来说，** An 是数组中存放的数据，大小为4byte，但是因为没有分配内存，所以也是Bad Reference</li>
</ul>
<h3 id="嵌套数组-Nested"><a href="#嵌套数组-Nested" class="headerlink" title="嵌套数组(Nested)"></a>嵌套数组(Nested)</h3><p>嵌套数组这样声明：</p>
<p>T A[R][C]:</p>
<p>这是一个二维数组：数据类型为T，R行C列</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/4.png"></p>
<p>Array的大小就是 $R\cdot C\cdot sizeof(T)$ bytes</p>
<p>嵌套数组是以行为主导顺序分配内存的：Row-Major</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/5.png" style="zoom:90%;"></p>
<p>这是嵌套数组的另外一种定义方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCOUNT 4</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> zip_dig[<span class="number">5</span>];</span><br><span class="line">zip_dig pgh[PCOUNT] =</span><br><span class="line">    &#123;&#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span> &#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span> &#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span> &#125;&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/6.png" style="zoom:90%;"></p>
<h4 id="Nested-Array-Row-access"><a href="#Nested-Array-Row-access" class="headerlink" title="Nested Array Row access"></a>Nested Array Row access</h4><p>对于 嵌套数组 A[R][C] 那么我们要访问一个数组中的一行，我们该怎么办：</p>
<p>行向量的开始地址是 ：$A+i\cdot (C\cdot sizeof(T))$ </p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/7.png" style="zoom:90%;"></p>
<h4 id="Nested-Array-Element-access"><a href="#Nested-Array-Element-access" class="headerlink" title="Nested Array Element access"></a>Nested Array Element access</h4><p>A[i][j]  是一个类型为T的数据,设T有K个字节，那么其地址可以这样来写 ： $A+i\cdot(C\cdot K)+j\cdot K=A+(i\cdot C+j)\cdot K$ </p>
<p>具体用 int 举例我们可以这样表示：</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/9.png" style="zoom:90%;"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_pgh_digit</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> dig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> pgh[index][dig];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leaq 	(%rdi,%rdi,4), %rax 	# 5*index</span><br><span class="line">addl 	%rax, %rsi 				# 5*index+dig</span><br><span class="line">movl 	pgh(,%rsi,4), %eax 		# M[pgh + 4*(5*index+dig)]</span><br></pre></td></tr></table></figure>
<p>Address:  pgh + 20*index + 4*dig = pgh + 4*(5*index + dig)</p>
<h3 id="Multi-Level-Array"><a href="#Multi-Level-Array" class="headerlink" title="Multi-Level Array"></a>Multi-Level Array</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zip_dig cmu = &#123; <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span> &#125;;</span><br><span class="line">zip_dig mit = &#123; <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span> &#125;;</span><br><span class="line">zip_dig ucb = &#123; <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UCOUNT 3</span></span><br><span class="line"><span class="keyword">int</span> *univ[UCOUNT] = &#123;mit, cmu, ucb&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/10.png" style="zoom:90%;"></p>
<p>获得一个具体位置的数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_univ_digit</span><span class="params">(<span class="keyword">size_t</span> index, <span class="keyword">size_t</span> digit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> univ[index][digit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是函数的汇编代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">salq 	$2, %rsi 			# 4*digit</span><br><span class="line">addq 	univ(,%rdi,8), %rsi # p &#x3D; univ[index] + 4*digit</span><br><span class="line">movl 	(%rsi), %eax 		# return *p</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>Element access Mem[Mem[univ+8*index]+4*digit]</p>
<p>对二维数组的两种存储方法(Nested array和 Multi-level array) ，我们可以做一个对比：</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/11.png" style="zoom:90%;"></p>
<h2 id="异质的数据结构"><a href="#异质的数据结构" class="headerlink" title="异质的数据结构"></a>异质的数据结构</h2><p>C语言中有 structure(结构)，用struct声明，将多个对象集合到一个单位中</p>
<p>union(联合)，用关键字union来声明，允许用几种不同类型来引用一个对象。</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>struct结构类似于数组的实现，它将所有组成部分都存放在内存中一段连续的区域内，而只想结构的指针就是结构第一个字节的地址。</p>
<p>比如下面这个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rec</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">size_t</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rec</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/12.png" style="zoom:90%;"></p>
<p>我们看到首先声明的是 一个int类型的数组，占用 4x4 =16 个字节。然后是size_t ，在64位机器下是8个字节。 next是一个指针，至下关下一个struct，所以占用8个byte。 可以观察到 数组 a 是嵌入到这个结构当中的。</p>
<hr>
<p>现在我想计算出指向a中某个数据的指针，我们应该如何操作？</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">get_ap</span> <span class="params">(struct rec *r, <span class="keyword">size_t</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;r-&gt;a[idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在汇编代码中，编译器会这么处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># r in %rdi, idx in %rsi</span><br><span class="line">leaq 	(%rdi,%rsi,4), %rax</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<hr>
<p>现在我想计算一条链表中的长度,我们可以写一个这样的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">length</span><span class="params">(struct rec*r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> len = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">while</span> (r) &#123;</span><br><span class="line">        len ++;</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.L11: 						# loop:</span><br><span class="line">    addq 	$1, %rax 		# len ++</span><br><span class="line">    movq 	24(%rdi), %rdi	# r &#x3D; Mem[r+24]</span><br><span class="line">    testq 	%rdi, %rdi 		# Test r</span><br><span class="line">    jne 	.L11 			# If !&#x3D; 0, goto loop</span><br></pre></td></tr></table></figure>
<p>因为一个struct占用的空间为32byte，但是最后8byte指向的是下一个struct 开始的地址，所以我们只要读出 在 r+24处的地址并判断其是否为空即可判断链表是否已经到达尾端</p>
<p>r+24 是 next的地址，next地址上的值 = 下一个struct的开头地址</p>
<hr>
<p>再来看看下面这个可能会出现问题的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_val</span> <span class="params">(struct rec *r, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (r) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> i = r-&gt;i;</span><br><span class="line">        r-&gt;a[i] = val;</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先把 i 命令成 struct里面的 i，然后将 val的值赋给 a[i] ,然后再指向下一个struct</p>
<p>其汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.L11: 							# loop:</span><br><span class="line">    movq   16(%rdi), %rax	 	# i &#x3D; Mem[r+16]</span><br><span class="line">    movl   %esi, (%rdi,%rax,4) 	# Mem[r+4*i] &#x3D; val</span><br><span class="line">    movq   24(%rdi), %rdi 		# r &#x3D; Mem[r+24]</span><br><span class="line">    testq  %rdi, %rdi 			# Test r</span><br><span class="line">    jne    .L11 				# if !&#x3D;0 goto loop</span><br></pre></td></tr></table></figure>
<p>先取出 r+16 地址上的值赋给 i，然后再将$r+4\cdot i $地址上的值赋值给 $val$</p>
<p>但是这样写会出现意想不到的结果，因为a只有4个位置，如果 struct 中的 $i\geq 4$ 的话，事实上 r-&gt;a[i] = val 实际上改动的是 r-&gt;i =val甚至报错 因为struct是在内存上连续存储的，C语言也不会检查数组是否会越界。于是 a[4] 其实修改的是 r-&gt;i 的值，而如果 i继续增大的话，到了没有分配内存的区域，C语言就会报错。</p>
<h3 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h3><h3 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h3><p>在struct中，我们要进行数据对齐。</p>
<p>对于一个 struct 例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> i[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">double</span> v;</span><br><span class="line">&#125; *p;</span><br></pre></td></tr></table></figure>
<p>在真实的内存当中，它其实是这么存储的：</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/13.png" style="zoom:90%;"></p>
<p>对于一个数据类型，它在内存里的起始位置必须是它大小的倍数：</p>
<p>对于一个 character来说，它在哪里存储都可以，因为其长度只有1byte</p>
<p>对于一个 int 来说，他的起始位置必须是4的倍数</p>
<p>对以一个double来说，它的起始位置必须是8的倍数。</p>
<p>这就造成了中间空出来的空间。虽然一个struct只要17个字节，但是像这样写C语言，存储的时候却需要24的字节</p>
<p>为什么要对齐？</p>
<p>因为数据不一定放在内存里，而放在cache里面，从 cache里面取数据会比内存里取快很多。cache是很小的，一个cache line是64个byte。我们希望当取一个struct的时候，我们希望这个数据项不要跨两个cache，而放在一个 cache line里面。如果一个结构跨cache line存储，那么取了一条cache line，还有一条在外面：这样就导致即没有让速度变快，又浪费了cache line。这种情况叫做 miss,会极大的影响机器的性能。</p>
<p>所以对于struct来说，我们宁可空出一段内存，也要让cache的命中率增加，从而提升整个程序的运算速度。</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/14.png" style="zoom:90%;"></p>
<p>对于一个结构数组，我们发现，即使是把最大的数据放在前面，满打满算用完17个字节，在存储的时候仍然要在最后补上空白的一些空间。这是因为要将整个struct大小补全到8的倍数，这里是24个字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">short <span class="title">get_j</span><span class="params">(<span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a[idx].j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># %rdi &#x3D; idx</span><br><span class="line">leaq 	(%rdi,%rdi,2),%rax 	# 3*idx</span><br><span class="line">movzwl 	a+8(,%rax,4),%eax</span><br></pre></td></tr></table></figure>
<p>在某种情况下，我们可以节省空间：</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/15.png" style="zoom:90%;"></p>
<h2 id="在机器及程序中将控制和数据结合起来"><a href="#在机器及程序中将控制和数据结合起来" class="headerlink" title="在机器及程序中将控制和数据结合起来"></a>在机器及程序中将控制和数据结合起来</h2><h3 id="Memory-Layout"><a href="#Memory-Layout" class="headerlink" title="Memory Layout"></a>Memory Layout</h3><p>在CSAPP的第一篇文章中我就讲过一个程序中不同的变量等在内存中的分布。现在我们在来复习一下。</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/16.png" style="zoom:90%;"></p>
<p>这里所说的Memory是 address space之意，是虚拟内存</p>
<p>首先我们来看 Shared Libraries，这里存放的是一些库函数、头文件之类的。即不是我们自己写的代码</p>
<p>然后我们看看Stack，stack有8M的内存空间，朝着低地址伸展。Stack中主要存放的是局部变量等数据</p>
<p>Heap和Stack不同，它是向上生长的。主要存放的是动态分配出来的内存，比如C++中new出来的、C中malloc() 出来的地址空间</p>
<p>然后是Data区域，Data主要存放的是静态变量和全局变量。这里我们要再声明一下静态变量和全局变量的区别：</p>
<p>1、全局变量在整个工程文件内都有效；</p>
<p>2、静态全局变量 只在定义它的文件内有效；</p>
<p>3、<strong>静态局部变量只在定义它的函数内有效，且程序仅分配一次内存</strong>，函数返回后，该变量不会消失；局部变量在定义它的函数内有效，但是函数返回后失效。<br>4、<strong>全局变量</strong>和静态变量如果没有手工初始化，则由编译器初始化为0。局部变量的值不可知。</p>
<p>5、<strong>静态局部变量</strong>与<strong>全局变量</strong>共享全局数据区，<strong>但静态局部变量只在定义它的函数中可见</strong>。静态局部变量与局部变量在存储位置上不同，使得其存在的时限也不同，导致对这两者操作 的运行结果也不同。</p>
<p>最后一个Text区域是代码区，里面存放着我们写的这个文件的代码。</p>
<p>我们来看一个具体的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> big_array[<span class="number">1L</span>&lt;&lt;<span class="number">24</span>]; <span class="comment">/* 16 MB */</span></span><br><span class="line"><span class="keyword">char</span> huge_array[<span class="number">1L</span>&lt;&lt;<span class="number">31</span>]; <span class="comment">/* 2 GB */</span></span><br><span class="line"><span class="keyword">int</span> global = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">useless</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *phuge1, *psmall2, *phuge3, *psmall4;</span><br><span class="line">    <span class="keyword">int</span> local = <span class="number">0</span>;</span><br><span class="line">    phuge1 = <span class="built_in">malloc</span>(<span class="number">1L</span> &lt;&lt; <span class="number">28</span>); <span class="comment">/* 256 MB */</span></span><br><span class="line">    psmall2 = <span class="built_in">malloc</span>(<span class="number">1L</span> &lt;&lt; <span class="number">8</span>); <span class="comment">/* 256 B */</span></span><br><span class="line">    phuge3 = <span class="built_in">malloc</span>(<span class="number">1L</span> &lt;&lt; <span class="number">32</span>); <span class="comment">/* 4 GB */</span></span><br><span class="line">    psmall4 = <span class="built_in">malloc</span>(<span class="number">1L</span> &lt;&lt; <span class="number">8</span>); <span class="comment">/* 256 B */</span></span><br><span class="line">    <span class="comment">/* Some print statements ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">not</span> drawn to scale</span><br></pre></td></tr></table></figure>
<p>big_array 和 huge_array,global 是全局变量，应该放到Data当中</p>
<p>useless() 是一个函数，属于我们写的代码，所以放到Text当中</p>
<p>local 是局部变量，放到栈中</p>
<p>phuge1，psmall2,phuge3,psmall4 是malloc盛情的指针。所以它们会放到Heap中去</p>
<p>下面是一个让栈溢出的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recurse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">1</span>&lt;&lt;<span class="number">15</span>]; <span class="comment">// 4*2^15 = 128 KiB</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x = %d. a at %p\n"</span>, x, a);</span><br><span class="line">    a[<span class="number">0</span>] = (<span class="number">1</span>&lt;&lt;<span class="number">14</span>)<span class="number">-1</span>;</span><br><span class="line">    a[a[<span class="number">0</span>]] = x<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[a[<span class="number">0</span>]] == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> recurse(a[a[<span class="number">0</span>]]) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次递归，函数都会开一个大小为128KB的数组。</p>
<p>最后的运行结果如下，如果x等于67输入，到最后一次分配内存的时候，数组会撑满8M的栈空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;runaway 67</span><br><span class="line">x &#x3D; 67. a at 0x7ffd18aba930</span><br><span class="line">x &#x3D; 66. a at 0x7ffd18a9a920</span><br><span class="line">x &#x3D; 65. a at 0x7ffd18a7a910</span><br><span class="line">x &#x3D; 64. a at 0x7ffd18a5a900</span><br><span class="line">. . .</span><br><span class="line">x &#x3D; 4. a at 0x7ffd182da540</span><br><span class="line">x &#x3D; 3. a at 0x7ffd182ba530</span><br><span class="line">x &#x3D; 2. a at 0x7ffd1829a520</span><br></pre></td></tr></table></figure>
<h3 id="Buffer-Overflow"><a href="#Buffer-Overflow" class="headerlink" title="Buffer Overflow"></a>Buffer Overflow</h3><p>我们现在来看一个向上溢出的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">double</span> d;	</span><br><span class="line">&#125; <span class="keyword">struct_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">struct_t</span> s;</span><br><span class="line">	s.d = <span class="number">3.14</span>;</span><br><span class="line">	s.a[i] = <span class="number">1073741824</span>; <span class="comment">/* Possibly out of bounds */</span></span><br><span class="line">	<span class="keyword">return</span> s.d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，这个struct s是放在栈里面的，我们之前说栈里面的元素是按照低地址到高地址排列的，画出来就是从下到上排列的。示意图如下 ：</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/1.jpg" style="zoom:90%;"></p>
<p>现在我们调用fun(8),会出现segmentation fault,因为a[8] 已经向上冲出这个结构趋于了，因此我们将这个现象叫做 stack overflow</p>
<p>如果调用 fun(0) 或者 fun(1),返回值是3.14，很正常。</p>
<p>但是如果调用 fun(2) 返回值变成了：3.1399998665 为什么是这个答案？</p>
<p>这就要考虑到double 这个浮点数在栈里面是怎么放的：如下图</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/2.jpg" style="zoom:90%;"></p>
<p>当我们调用fun(2)，其结果就是将double d中的部分M修改成了 1073741824。也就是说我们对这个浮点数的小数部分进行了修改，但是并没有修改其符号和阶码。因此我们看到结果是仅仅影响了一些精度，并没有影响很大。</p>
<p>当我们调用 fun(3),那么就是对上面的S、E、M都进行了修改，但是如果运气足够好，事实上和原来的值相差也不是很大。这李调用fun(3) 返回的值是 2.0000006104</p>
<p>fun(4)到fun(7)我们看到栈里面放的是Critical State,这时候还不会立马报segmentation fault，而是会提醒我们 Stack smashing detected</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/17.png" style="zoom:90%;"></p>
<p>还有一种情况，是这样的:</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/18.png" style="zoom:90%;"></p>
<p>我们调用fun(8),结果反而又对了，这就好比一开始我们撞墙了(segmentation fault) ，那么我们干脆直接写到墙的另外一端去，反而对结构内的数据不影响了。</p>
<p>如果出现这样的问题，通常我们将其称为 buffer overflow。我们通过调试是很难发现的。这种错误是非常微小但在某些情况下是非常致命的。</p>
<p>接下来我们通过几个例子来看看如何攻击一个不安全的代码和如何来保护我们的代码不受他人攻击</p>
<h3 id="Vulnerability-弱点"><a href="#Vulnerability-弱点" class="headerlink" title="Vulnerability 弱点"></a>Vulnerability 弱点</h3><p>我们先举几个例子：</p>
<p>C语言标准库里有一个gets函数，这个函数的写法如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get string from stdin */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *dest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getchar();</span><br><span class="line">    <span class="keyword">char</span> *p = dest;</span><br><span class="line">    <span class="keyword">while</span> (c != EOF &amp;&amp; c != <span class="string">'\n'</span>) &#123;</span><br><span class="line">    	*p++ = c;	</span><br><span class="line">    	c = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	*p = <span class="string">'\0'</span>;</span><br><span class="line">	<span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数是说，如果没有结束或者回车的话，gets会一直读入字符。看起来没有问题，但是这个函数<strong>没有检查</strong>这个指针 *dest  指向的地址以及地址之后的一段地址是合法的还是非法的。</p>
<p>正确的应该是我们应该malloc一段地址来存放string，如果输入的string大于malloc的大小，函数就会报越界。</p>
<p>同样的：</p>
<p>strcpy, strcat: Copy strings of arbitrary length<br>scanf, fscanf, sscanf, when given %s conversion specification</p>
<p>这些函数都存在着一些问题。</p>
<p>在实际的例子中，比如这个函数，按照设想来说我们只开了一个 4个byte的字符数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Echo Line */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4</span>]; <span class="comment">/* Way too small! */</span></span><br><span class="line">    gets(buf);</span><br><span class="line">    <span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_echo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	echo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，我们这样输入，却不会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unix&gt;.&#x2F;bufdemo-nsp</span><br><span class="line">Type a string:01234567890123456789012</span><br><span class="line">01234567890123456789012</span><br></pre></td></tr></table></figure>
<p>而再多输入一个字符，函数就会报segmentation fault</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unix&gt;.&#x2F;bufdemo-nsp</span><br><span class="line">Type a string:012345678901234567890123</span><br><span class="line">012345678901234567890123</span><br><span class="line">Segmentation Fault</span><br></pre></td></tr></table></figure>
<p>前面不报错的原因是地址上可能有一部分原来就是合法的，那你读取的话也无伤大雅，关键是我们不知道程序什么时候会报segmentation fault</p>
<p>现在我们来看看这个程序运行的机制：</p>
<p>首先我们将其反编译：</p>
<p><strong>echo</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">000000000040069c &lt;echo&gt;:</span><br><span class="line">40069c: 48 83 ec 18 		sub 		$0x18,%rsp</span><br><span class="line">4006a0: 48 89 e7 			mov 		%rsp,%rdi</span><br><span class="line">4006a3: e8 a5 ff ff ff 		callq 		40064d &lt;gets&gt;</span><br><span class="line">4006a8: 48 89 e7 			mov 		%rsp,%rdi</span><br><span class="line">4006ab: e8 50 fe ff ff 		callq		400500 &lt;puts@plt&gt;</span><br><span class="line">4006b0: 48 83 c4 18 		add 		$0x18,%rsp</span><br><span class="line">4006b4: c3 					retq</span><br></pre></td></tr></table></figure>
<p><strong>call_echo</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4006b5: 48 83 ec 08 		sub 		$0x8,%rsp</span><br><span class="line">4006b9: b8 00 00 00 00 		mov 		$0x0,%eax</span><br><span class="line">4006be: e8 d9 ff ff ff 		callq 		40069c &lt;echo&gt;</span><br><span class="line">4006c3: 48 83 c4 08 		add 		$0x8,%rsp</span><br><span class="line">4006c7: c3 					retq</span><br></pre></td></tr></table></figure>
<p>再调用gets之前，这个echo函数栈帧如下：最上面的是caller也就是call_echo的栈帧。接下来是一段return address也就是返回的地址。然后是20个未被使用但是合法的bytes(这也是为什么我们之前输入了23个数字仍然没有报错的原因了) ，最后是我们申请的 buf 数组。</p>
<p>像之前我们输入了23个数字，加上\0刚好将unused 部分和buf数组全部填满。这时候是不会报错的。但是如果我输入24个数字，那么有一个数字就会冲出合法的数组，将返回地址改写。但是返回地址的内容是会收到保护的，于是整个程序就会崩溃，报return地址出错。</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/19.png" style="zoom:90%;"></p>
<p>从上面的汇编语言可以得出，call_echo在0x4006be处调用了echo，所以echo的返回地址是 0x4006c3</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/20.png" style="zoom:90%;"></p>
<p>这是我输入23个数字后，栈帧的结构，我们发现除了buf数组被填满了，20个未被使用的buf也被填满了。</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/21.png" style="zoom:90%;"></p>
<p>如果我输入了24个数进去，我们就会发现返回地址中的低位被修改了。结果就是返回到了一个非法的地址上去，程序崩溃。</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/23.png" style="zoom:90%;"></p>
<p>由此我们可以得出，如果有些别有用心的人通过查看你的代码，计算你的栈帧并将你的返回地址修改成某段他希望跳转到的地址，这样你的程序就会变得非常不安全。之后的attacklab就要求我们去攻击那些不是非常安全的代码。而在我们写程序的时候，我们要做的就是对我们的程序进行一个保护。</p>
<h3 id="Protection"><a href="#Protection" class="headerlink" title="Protection"></a>Protection</h3><h4 id="Avoid-overflow-vulnerabilities"><a href="#Avoid-overflow-vulnerabilities" class="headerlink" title="Avoid overflow vulnerabilities"></a>Avoid overflow vulnerabilities</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Echo Line */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4</span>];</span><br><span class="line">    fgets(buf, <span class="number">4</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>For example, use library routines that limit string lengths</p>
<ul>
<li>fgets instead of gets</li>
<li>strncpy instead of strcpy</li>
<li>Don’t use scanf with %s conversion specification<ul>
<li>Use fgets to read the string</li>
<li>Or use %ns where n is a suitable integer</li>
</ul>
</li>
</ul>
<h4 id="Employ-system-level-protections"><a href="#Employ-system-level-protections" class="headerlink" title="Employ system-level protections"></a>Employ system-level protections</h4><p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/24.png" style="zoom:90%;"></p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/25.png" style="zoom:90%;"></p>
<h4 id="Have-compiler-use-“stack-canaries”"><a href="#Have-compiler-use-“stack-canaries”" class="headerlink" title="Have compiler use “stack canaries”"></a>Have compiler use “stack canaries”</h4><p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/26.png" style="zoom:90%;"></p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/27.png" style="zoom:90%;"></p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/28.png" style="zoom:90%;"></p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/29.png" style="zoom:90%;"></p>
<h2 id="浮点代码"><a href="#浮点代码" class="headerlink" title="浮点代码"></a>浮点代码</h2>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/10/15/Naive-Bayes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/10/15/Naive-Bayes/" itemprop="url">Naive_Bayes</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-10-15T20:15:58+08:00">
                2020-10-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-10-15T20:16:00+08:00">
                2020-10-15
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/10/14/SVM-and-KernelSVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/10/14/SVM-and-KernelSVM/" itemprop="url">SVM_and_KernelSVM</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-10-14T21:46:11+08:00">
                2020-10-14
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-10-21T16:17:32+08:00">
                2020-10-21
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SVM-and-KernelSVM"><a href="#SVM-and-KernelSVM" class="headerlink" title="SVM and KernelSVM"></a>SVM and KernelSVM</h1><h2 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h2><p>部分文字摘自 <a href="https://www.jianshu.com/p/0b09dc432081" target="_blank" rel="noopener">https://www.jianshu.com/p/0b09dc432081</a></p>
<p>现在我们仍然有两类，一类红点一类绿点</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/1.png" style="zoom:80%;"></p>
<p>现在我们要做的是如何将这两种数据准确的分隔开来。看图像其实很简单，可以横着画一条直线或者竖着画或者斜着画都能将其分隔开来。那么svm要做的就是找到最佳的一条直线。</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/2.png" style="zoom:80%;"></p>
<p>那么这条直线要满足的特点是它和红组和绿组有最大的间隔。所谓最大间隔就是红组中离直线最近的点的距离和绿组中离直线最近的距离最大。这两个点就叫做Support Vector。这里解释下为什么叫支持向量，首先“支持”的意思，就是说这些数据点中除了两个点之外的任何一个点都不会影响到这个算法的决策边界，即这条直线实际上是由这两个点支持的，然后“向量”，在二维空间中的点实际上都可以用向量表示，但在高维中没办法用几何方式表示出来，它其实都是向量。</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/3.png" style="zoom:80%;"></p>
<p>对于这条直线，我们称作Maximum Margin Hyperplane/Classifier，即<strong>最大间隔超平面</strong>。所谓超平面就是比数据空间少一维的空间，比如这里二维的那么对应的就是一维的即一条直线。其中和这条直线平行的这两条直线，一个叫做正向超平面，一个叫负向超平面，这个正负这里只是跟法向量有关，是数学上的概念，不用太在意正负。</p>
<p>接下来看看这个SVM算法为什么这么特别(与其他的算法相比）：</p>
<p>这里假设我们需要训练一个算法来识别苹果和橘子，比如通过水果的颜色和水分来判断。那么大部分的苹果都是青色或者红色，而橘子一般是黄色。那么在图像中可以当作这个横轴代表颜色，x1越往右的就是颜色偏黄色的，那么这部分数据显然都是橘子。</p>
<p>在其他的机器学习算法中，机器只会关注特别经典的数据，比如说下图中圈出来的两部分。也就是其他算法都只关注非常红、非常绿的苹果或者非常黄的橙子。</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/4.png" style="zoom:80%;"></p>
<p>但是SVM却不一样了。SVM最特别的地方就是它可以学习到最特殊最特别的东西，比如说这个时候出现了一个黄色的苹果，很像橘子。那么这样的苹果就是SVM中的支持向量，同样如果这时有个绿色的橘子也是支持向量。因此SVM其实是由数据中比较极端的个例所实现的。这点和其他的算法有根本的不同。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>我们用的还是老的数据集,所以前面的代码都可以照抄 <a href="https://jasonxqh.github.io/2020/10/11/Logistic-Regression/">逻辑回归</a>中的代码，只需要改建模这一块即可</p>
<p>这里我们要用的还是线性的核函数，所以我们将kernel 设置为 linear</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line">classifier = SVC(kernel = <span class="string">'linear'</span>,random_state = <span class="number">0</span>)</span><br><span class="line">classifier.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>
<p>然后我们看看SVM的预测情况</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix, accuracy_score</span><br><span class="line">cm = confusion_matrix(y_test, y_pred)</span><br><span class="line">print(cm)</span><br><span class="line">accuracy_score(y_test, y_pred)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[66  2]</span><br><span class="line"> [ 8 24]]</span><br><span class="line"> 0.9</span><br></pre></td></tr></table></figure>
<p>最后来看看可视化之后的样子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line">X_set, y_set = sc.inverse_transform(X_train), y_train</span><br><span class="line">X1, X2 = np.meshgrid(np.arange(start = X_set[:, <span class="number">0</span>].min() - <span class="number">10</span>,</span><br><span class="line">                               stop = X_set[:, <span class="number">0</span>].max() + <span class="number">10</span>,</span><br><span class="line">                               step = <span class="number">0.25</span>),</span><br><span class="line">                     np.arange(start = X_set[:, <span class="number">1</span>].min() - <span class="number">1000</span>,</span><br><span class="line">                               stop = X_set[:, <span class="number">1</span>].max() + <span class="number">1000</span>,</span><br><span class="line">                               step = <span class="number">0.25</span>))</span><br><span class="line">plt.contourf(X1, </span><br><span class="line">             X2,</span><br><span class="line">             classifier.predict(sc.transform(np.array([X1.ravel(), X2.ravel()]).T)).reshape(X1.shape),</span><br><span class="line">             alpha = <span class="number">0.75</span>, cmap = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>)))</span><br><span class="line">plt.xlim(X1.min(), X1.max())</span><br><span class="line">plt.ylim(X2.min(), X2.max())</span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> enumerate(np.unique(y_set)):</span><br><span class="line">    plt.scatter(X_set[y_set == j, <span class="number">0</span>], </span><br><span class="line">                X_set[y_set == j, <span class="number">1</span>],</span><br><span class="line">                c = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>))(i), </span><br><span class="line">                label = j)</span><br><span class="line">plt.title(<span class="string">'SVM (Training set)'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Age'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Estimated Salary'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/14/SVM-and-KernelSVM/6.png" style="zoom:100%;"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line">X_set, y_set = sc.inverse_transform(X_test), y_test</span><br><span class="line">X1, X2 = np.meshgrid(np.arange(start = X_set[:, <span class="number">0</span>].min() - <span class="number">10</span>, </span><br><span class="line">					stop = X_set[:, <span class="number">0</span>].max() + <span class="number">10</span>, </span><br><span class="line">					step = <span class="number">0.25</span>),</span><br><span class="line">                    np.arange(start = X_set[:, <span class="number">1</span>].min() - <span class="number">1000</span>, </span><br><span class="line">                    stop = X_set[:, <span class="number">1</span>].max() + <span class="number">1000</span>,</span><br><span class="line">                    step = <span class="number">0.25</span>))</span><br><span class="line">plt.contourf(X1,</span><br><span class="line">             X2, </span><br><span class="line">             classifier.predict(sc.transform(np.array([X1.ravel(), X2.ravel()]).T)).reshape(X1.shape),</span><br><span class="line">             alpha = <span class="number">0.75</span>,</span><br><span class="line">             cmap = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>)))</span><br><span class="line">plt.xlim(X1.min(), X1.max())</span><br><span class="line">plt.ylim(X2.min(), X2.max())</span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> enumerate(np.unique(y_set)):</span><br><span class="line">    plt.scatter(X_set[y_set == j, <span class="number">0</span>],</span><br><span class="line">                X_set[y_set == j, <span class="number">1</span>], </span><br><span class="line">                c = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>))(i),</span><br><span class="line">                label = j)</span><br><span class="line">plt.title(<span class="string">'SVM (Test set)'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Age'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Estimated Salary'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/14/SVM-and-KernelSVM/7.png" style="zoom:100%;"></p>
<h2 id="Kernel-SVM"><a href="#Kernel-SVM" class="headerlink" title="Kernel SVM"></a>Kernel SVM</h2><p>SVM是让我们在两组数据中划出一条分界线，那么如果我们没办法再两组数据中滑出一条分界线怎么办?</p>
<p>对于非线性的数据，我们又该怎么办？因此我们须要改良SVM算法，这就是接下来的 和函数支持向量机(Kernel SVM)</p>
<h3 id="高维投射"><a href="#高维投射" class="headerlink" title="高维投射"></a>高维投射</h3><p>对于下面这些离散的非线性的数据，我们是没有办法直接画一条线将它们分割开的</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/8.png" style="zoom:100%;"></p>
<p>所以我们该怎么办？首先，我们先将线性不可分的数据从低维投射到高维，使得其在高维上线性可分，接下来再将分隔好的数据投射到原先低维的空间。</p>
<p>这里先举一个一维的问题。这里有一条直线上，有红色和绿色的点，这条直线上是否存在一个点将红点和绿点分开。显然是无法做到的，那么需要将其投射到二维空间上。</p>
<p> <img src="/2020/10/14/SVM-and-KernelSVM/9.png" style="zoom:100%;"></p>
<p>我们假设红点和绿点在左侧的分界线是5，那么就将其全部减去五然后求其平方得到一根曲线</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/10.png" style="zoom:100%;"></p>
<p>现在，我们就能用一根直线将红点和绿点分开了。</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/11.png" style="zoom:100%;"></p>
<p>那么我们也可以将这个原理运用在二维空间上：</p>
<p> 通过一个很奇怪的映射函数，我们可以将二维的点投射到三维空间上。然后我们就可以找到一个平面(Hyperplane)将两类点分开来</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/12.png" style="zoom:100%;"></p>
<p>然后我们在将其投射到二维空间上，就可以将两类点分开了</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/13.png" style="zoom:100%;"></p>
<p>但由于低维映射到高维然后再让高维投影到低维，对于计算机而言计算量很大，那么我们就需要引入核函数来解决非线性问题，可以绕过这里的繁琐的计算过程，却依然能解决问题。</p>
<h3 id="高斯核函数-RBF"><a href="#高斯核函数-RBF" class="headerlink" title="高斯核函数(RBF)"></a>高斯核函数(RBF)</h3><p>高斯核函数的公式 ：$K(\overrightarrow{x},\overrightarrow{l^i}) = e^{-\frac{||\overrightarrow{x}- \overrightarrow{l^i}||^2}{2\sigma^2}}$</p>
<p>K 代表了 Kernel，也就是对于两个向量核函数。</p>
<p>$\overrightarrow {x}$ 代表了表示点的那个向量</p>
<p>$\overrightarrow{l^i}$ 就是核函数的中心，因为核函数可能有多个中心，所以 $l$ 具有上标 i</p>
<p>$\sigma$ 为函数的宽度参数 , 控制了函数的径向作用范围。</p>
<p> 我们用一个可视化的方式来解释高斯核函数</p>
<p> <img src="/2020/10/14/SVM-and-KernelSVM/14.png" style="zoom:100%;"></p>
<p>我们设坐标(0,0,0) 为和函数的中心（只有一个）。也就是二维平面中绿色区域的中心</p>
<p>那么左边这幅图画就是这些红色和绿色的点通过高斯核函数在三维空间中的映射。</p>
<p>这里从图像也能看出来，红点距离中心点是比较远的，那么 $||\overrightarrow{x}- \overrightarrow{l^i}||^2$ 就会比较大，由于是负数，那么整个方程的结果就会趋向于0.如果x与l距离很接近，那么$||\overrightarrow{x}- \overrightarrow{l^i}||^2$就会趋向于0，加个符号依然趋向于0，那么这个函数就趋向于1.</p>
<p>那么接下来看看如何利用这个函数来寻找数据的分类边界。函数中的l我们可以当作基准点，在上述的数据中如图假设是绿色点的中心，那么很显然，所有的绿色点距离这个点的距离一定是小于某个常数，而红色的点距离它的距离一定大于这个常数。</p>
<p>那么在二维平面，在训练SVM的时候，模型里面就会对”映射出来的” 高维空间画一个圈，这个圈的纵坐标并不是0但是很接近0。在这个圈里面的，也就是z轴大于这个圈的高度的，就属于绿色的点，反之则属于红色的点。</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/15.png" style="zoom:100%;"></p>
<p>那么这个 $\sigma$ ，就决定了函数的径向作用范围。也就是这个”圈“ 的大小。$\sigma $ 是由函数通过训练自己取的。如果 $\sigma$ 增大，那么我们看到就会有更多的原本属于红色的点被划分为绿色去了.<br>反之$\sigma$ 减小，那么很多原本属于绿色的点被划分到红色去了</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/16.png" style="zoom:100%;"></p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/17.png" style="zoom:100%;"></p>
<p>假如说现在我拿到了一个更加复杂的数据集，红点和绿点的分布如下：</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/18.png" style="zoom:100%;"></p>
<p>这时候规定一个中心已经是不可能的了，我们需要确立两个中心</p>
<p>公式就变成了 $K(\overrightarrow{x},\overrightarrow{l^1})+ K(\overrightarrow{x},\overrightarrow{l^2})$</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/19.png" style="zoom:100%;"></p>
<p>对于左边那个中心来说，它只负责左边的绿色的点的核函数大于0；而对于右边绿色的点和所有的红色的点的核函数都等于0；对于右边的中心来说则刚好相反，那么我们就可以用 $K(\overrightarrow{x},\overrightarrow{l^1})+ K(\overrightarrow{x},\overrightarrow{l^2})$ 是否大于0，来判断新的点是属于红色还是属于绿色。</p>
<h3 id="Types-of-Kernel-Functions"><a href="#Types-of-Kernel-Functions" class="headerlink" title="Types of Kernel Functions"></a>Types of Kernel Functions</h3><p>我们要知道有很多种的核函数：它们的功能各不相同</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/20.png" style="zoom:100%;"></p>
<h3 id="Non-Linear-Kernel-SVR"><a href="#Non-Linear-Kernel-SVR" class="headerlink" title="Non-Linear Kernel SVR"></a>Non-Linear Kernel SVR</h3><p>我们假设现在拿到了这样一系列数据：</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/21.png" style="zoom:100%;"></p>
<p>对于这样的数据，我们显然不能用普通的线性支持向量机</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/22.png" style="zoom:100%;"></p>
<p>于是我们采用 Non-Linear SVR,也就是用高斯核来进行拟合。首先画一个二维平面和一个三维空间，并将这些点用高斯核函数映射到三维空间当中去：</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/23.png" style="zoom:100%;"></p>
<p>接着我们就可以根据三维空间中的点来画出 <strong>超平面</strong> 。超平面与核函数相交并投影到二维平面上的曲线就是非线性支持向量机模拟出来的曲线了。</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/24.png" style="zoom:100%;"></p>
<p>那么你也许会问 线性的SVM有 $\epsilon$  ，在非线性空间中是否有呢？ 答案是有的，只不过这时候 $\epsilon$ 变成了平面和平面之间的举例</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/25.png" style="zoom:100%;"></p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>现在我们利用核函数支持向量机来进行分类：</p>
<p>经过导入、特征缩放之后进行训练</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line">classifier = SVC(kernel = <span class="string">'rbf'</span>, random_state = <span class="number">0</span>)</span><br><span class="line">classifier.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>
<p>然后，我们进行预测：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y_pred = classifier.predict(X_test)</span><br><span class="line">print(np.concatenate((y_pred.reshape(len(y_pred),<span class="number">1</span>), 			</span><br><span class="line">					  y_test.reshape(len(y_test),<span class="number">1</span>)),<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>现在我们看看SVM的混淆矩阵和分数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix, accuracy_score</span><br><span class="line">cm = confusion_matrix(y_test, y_pred)</span><br><span class="line">print(cm)</span><br><span class="line">accuracy_score(y_test, y_pred)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[64  4]</span><br><span class="line"> [ 3 29]]</span><br><span class="line"> </span><br><span class="line">0.93</span><br></pre></td></tr></table></figure>
<p>最后我们来可视化结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line">X_set, y_set = sc.inverse_transform(X_train), y_train</span><br><span class="line">X1, X2 = np.meshgrid(np.arange(start = X_set[:, <span class="number">0</span>].min() - <span class="number">10</span>, </span><br><span class="line">                               stop = X_set[:, <span class="number">0</span>].max() + <span class="number">10</span>, step = <span class="number">0.25</span>),</span><br><span class="line">                     np.arange(start = X_set[:, <span class="number">1</span>].min() - <span class="number">1000</span>, </span><br><span class="line">                               stop = X_set[:, <span class="number">1</span>].max() + <span class="number">1000</span>, step = <span class="number">0.25</span>))</span><br><span class="line">plt.contourf(X1, </span><br><span class="line">             X2,</span><br><span class="line">             classifier.predict(sc.transform(np.array([X1.ravel(), </span><br><span class="line">                                 X2.ravel()]).T)).reshape(X1.shape),</span><br><span class="line">             alpha = <span class="number">0.75</span>,</span><br><span class="line">             cmap = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>)))</span><br><span class="line">plt.xlim(X1.min(), X1.max())</span><br><span class="line">plt.ylim(X2.min(), X2.max())</span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> enumerate(np.unique(y_set)):</span><br><span class="line">    plt.scatter(X_set[y_set == j, <span class="number">0</span>],</span><br><span class="line">                X_set[y_set == j, <span class="number">1</span>],</span><br><span class="line">                c = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>))(i),</span><br><span class="line">                label = j)</span><br><span class="line">plt.title(<span class="string">'Kernel SVM (Training set)'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Age'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Estimated Salary'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/14/SVM-and-KernelSVM/26.png" style="zoom:100%;"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib.colors import ListedColormap</span><br><span class="line">X_set, y_set &#x3D; sc.inverse_transform(X_test), y_test</span><br><span class="line">X1, X2 &#x3D; np.meshgrid(np.arange(start &#x3D; X_set[:, 0].min() - 10, </span><br><span class="line">							   stop &#x3D; X_set[:, 0].max() + 10,</span><br><span class="line">                               step &#x3D; 0.25),</span><br><span class="line">                     np.arange(start &#x3D; X_set[:, 1].min() - 1000,</span><br><span class="line">                     		   stop &#x3D; X_set[:, 1].max() + 1000,</span><br><span class="line">                               step &#x3D; 0.25))</span><br><span class="line">plt.contourf(X1, X2, classifier.predict(sc.transform(np.array([X1.ravel(), </span><br><span class="line">			 X2.ravel()]).T)).reshape(X1.shape),</span><br><span class="line">             alpha &#x3D; 0.75,</span><br><span class="line">             cmap &#x3D; ListedColormap((&#39;red&#39;, &#39;green&#39;)))</span><br><span class="line">plt.xlim(X1.min(), X1.max())</span><br><span class="line">plt.ylim(X2.min(), X2.max())</span><br><span class="line">for i, j in enumerate(np.unique(y_set)):</span><br><span class="line">    plt.scatter(X_set[y_set &#x3D;&#x3D; j, 0],</span><br><span class="line">    			X_set[y_set &#x3D;&#x3D; j, 1], </span><br><span class="line">    			c &#x3D; ListedColormap((&#39;red&#39;, &#39;green&#39;))(i), </span><br><span class="line">    			label &#x3D; j)</span><br><span class="line">plt.title(&#39;Kernel SVM (Test set)&#39;)</span><br><span class="line">plt.xlabel(&#39;Age&#39;)</span><br><span class="line">plt.ylabel(&#39;Estimated Salary&#39;)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/14/SVM-and-KernelSVM/27.png" style="zoom:100%;"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/10/13/K-NN%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/10/13/K-NN%E7%AE%97%E6%B3%95/" itemprop="url">K-NN算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-10-13T21:19:21+08:00">
                2020-10-13
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-10-14T15:08:20+08:00">
                2020-10-14
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="K-NN-算法"><a href="#K-NN-算法" class="headerlink" title="K-NN 算法"></a>K-NN 算法</h1><p>K-NN(K-Nearest Neighbors) 算法也是用来分类的，他直观上十分容易理解：</p>
<p><img src="/2020/10/13/K-NN%E7%AE%97%E6%B3%95/1.png" style="zoom:150%;"></p>
<p>现在有两类，分别用红色的加号和绿色的加号描出，现在我们进来了一个新的数据点，我们的目标就是将这个数据点划到哪一类里面去。</p>
<p>比如说下面这个点经过类K-NN 算法，被划归到红色的那一类取了</p>
<p><img src="/2020/10/13/K-NN%E7%AE%97%E6%B3%95/2.png" style="zoom:120%;"></p>
<p>那么K-NN 算法是怎么运作的呢？ 其实很简单</p>
<ol>
<li>STEP1: Choose the number K of neighbors</li>
<li>STEP2: Take the K nearest neighbors of the new data point , according to the Euclidean distance</li>
<li>STEP3: Among these K neighbors ,count the number of data points in each category</li>
<li>STEP4: Assign the new data point to the category where you counted the most neighbors</li>
</ol>
<p>结合上面这个写步骤，我们对刚才的例子进行剖析：</p>
<p>我们现决定要选取5个距离这个点最近的邻居</p>
<p><img src="/2020/10/13/K-NN%E7%AE%97%E6%B3%95/3.png" style="zoom:120%;"></p>
<p>然后计算他和邻居之间的 Euclidean 距离，欧几里得距离的计算公式： $d=\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}$ </p>
<p>然后计算距离这个点最近5个欧几里得距离。在这5个最近的邻居中，属于红色区域的有3个，属于绿色区域的有2个，那么这个点就会被划分到红色区域当中去。</p>
<p><img src="/2020/10/13/K-NN%E7%AE%97%E6%B3%95/4.png" style="zoom:100%;"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>我们使用的数据集：</p>
<p><img src="/2020/10/13/K-NN%E7%AE%97%E6%B3%95/5.png" style="zoom:100%;"></p>
<p>和逻辑回归的思路是一样的，只是换一个模型而已，所以这里略去重复的代码</p>
<h3 id="Training-the-K-NN-model-on-the-Training-set"><a href="#Training-the-K-NN-model-on-the-Training-set" class="headerlink" title="Training the K-NN model on the Training set"></a>Training the K-NN model on the Training set</h3><p>n_neighbors =5 比较常用当然也可以多试试别的值来取最高的准确率</p>
<p>metric = ‘minkowski’ (闵可夫斯基) 就是说距离计算公式运用闵氏距离，是欧氏空间中的一种测度，被看做是欧氏距离和曼哈顿距离的一种推广。 $(\sum_{i=1}^n |x_i-y_i|^p)^{\frac{1}{p}}$</p>
<p>p=2就是 上面这个公式的 p</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line">classifier = KNeighborsClassifier(n_neighbors = <span class="number">5</span>, </span><br><span class="line">                                  metric = <span class="string">'minkowski'</span>, </span><br><span class="line">                                  p = <span class="number">2</span>)</span><br><span class="line">classifier.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>
<p>看一下这个模型的混淆矩阵和准确分数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix, accuracy_score</span><br><span class="line">cm = confusion_matrix(y_test, y_pred)</span><br><span class="line">print(cm)</span><br><span class="line">accuracy_score(y_test, y_pred)</span><br></pre></td></tr></table></figure>
<p>混淆矩阵：</p>
<p>[[64  4]<br> [ 3 29]]<br>准确度：0.93 </p>
<h4 id="Visualising-the-Training-set-results"><a href="#Visualising-the-Training-set-results" class="headerlink" title="Visualising the Training set results"></a>Visualising the Training set results</h4><p>最后用可视化图来看一下结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line">X_set, y_set = sc.inverse_transform(X_train), y_train</span><br><span class="line">X1, X2 = np.meshgrid(np.arange(start = X_set[:, <span class="number">0</span>].min() - <span class="number">10</span>, stop = X_set[:, <span class="number">0</span>].max() + <span class="number">10</span>, step = <span class="number">1</span>),</span><br><span class="line">                     np.arange(start = X_set[:, <span class="number">1</span>].min() - <span class="number">1000</span>, stop = X_set[:, <span class="number">1</span>].max() + <span class="number">1000</span>, step = <span class="number">1</span>))</span><br><span class="line">plt.contourf(X1, X2, classifier.predict(sc.transform(np.array([X1.ravel(), X2.ravel()]).T)).reshape(X1.shape),</span><br><span class="line">             alpha = <span class="number">0.75</span>, cmap = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>)))</span><br><span class="line">plt.xlim(X1.min(), X1.max())</span><br><span class="line">plt.ylim(X2.min(), X2.max())</span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> enumerate(np.unique(y_set)):</span><br><span class="line">    plt.scatter(X_set[y_set == j, <span class="number">0</span>], X_set[y_set == j, <span class="number">1</span>], c = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>))(i), label = j)</span><br><span class="line">plt.title(<span class="string">'K-NN (Training set)'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Age'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Estimated Salary'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/13/K-NN%E7%AE%97%E6%B3%95/6.png" style="zoom:100%;"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line">X_set, y_set = sc.inverse_transform(X_test), y_test</span><br><span class="line">X1, X2 = np.meshgrid(np.arange(start = X_set[:, <span class="number">0</span>].min() - <span class="number">10</span>, stop = X_set[:, <span class="number">0</span>].max() + <span class="number">10</span>, step = <span class="number">1</span>),</span><br><span class="line">                     np.arange(start = X_set[:, <span class="number">1</span>].min() - <span class="number">1000</span>, stop = X_set[:, <span class="number">1</span>].max() + <span class="number">1000</span>, step = <span class="number">1</span>))</span><br><span class="line">plt.contourf(X1, X2, classifier.predict(sc.transform(np.array([X1.ravel(), X2.ravel()]).T)).reshape(X1.shape),</span><br><span class="line">             alpha = <span class="number">0.75</span>, cmap = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>)))</span><br><span class="line">plt.xlim(X1.min(), X1.max())</span><br><span class="line">plt.ylim(X2.min(), X2.max())</span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> enumerate(np.unique(y_set)):</span><br><span class="line">    plt.scatter(X_set[y_set == j, <span class="number">0</span>], X_set[y_set == j, <span class="number">1</span>], c = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>))(i), label = j)</span><br><span class="line">plt.title(<span class="string">'K-NN (Test set)'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Age'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Estimated Salary'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/13/K-NN%E7%AE%97%E6%B3%95/7.png" style="zoom:100%;"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/10/11/Logistic-Regression/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/10/11/Logistic-Regression/" itemprop="url">Logistic_Regression</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-10-11T15:49:37+08:00">
                2020-10-11
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-10-13T14:51:30+08:00">
                2020-10-13
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Logistic-Regression"><a href="#Logistic-Regression" class="headerlink" title="Logistic Regression"></a>Logistic Regression</h1><p>学习自：<a href="https://www.jianshu.com/p/3254560624b7" target="_blank" rel="noopener">https://www.jianshu.com/p/3254560624b7</a></p>
<p>我们之前谈论的都是线性回归问题，线性回归问题一般解决的时自变量和应变量存在线性关系的数据。比如说下面这张图。</p>
<p><img src="/2020/10/11/Logistic-Regression/1.png" style="zoom:80%;"></p>
<p>但是对于这种数据，是一些关于年龄信息和客户是否购买产品的数据 线性回归就很难满意的完成我们的任务，因为因变量只有0和1：</p>
<p><img src="/2020/10/11/Logistic-Regression/2.png" style="zoom:80%;"></p>
<p>这时候如果强制线性回归，就会出现这样的结果。</p>
<p><img src="/2020/10/11/Logistic-Regression/3.png" style="zoom:80%;"></p>
<p>这显然不是我们想要的，年龄低于某个值的时候Action变成了负数而高于某个值得时候竟然大于1. 于是，我们要引入分类器的概念，我们现在就来看看第一个分类算法：逻辑回归</p>
<p>逻辑回归可以参考高中生物的逻辑斯蒂增长曲线，公式为 $\ln(\frac{p}{1-p}) = b_0+b_1*x$ (p 代表了是否会发生的概率)</p>
<p>将其应用于上面的数据，我们就会得到一个新的图像，其中y轴的单位是 $\hat p (Probability)$ ,我们可以用这条曲线来预测中间年龄段的人是否会购买产品</p>
<p><img src="/2020/10/11/Logistic-Regression/4.png" style="zoom:150%;"></p>
<p>我们可以看看具体数据，假设当前有几个数据分别是年龄20、30、40、50。那么其在纵坐标上对应的结果也可以标记出来，得到不同的概率。</p>
<p><img src="/2020/10/11/Logistic-Regression/5.png" style="zoom:150%;"></p>
<p>关于年龄和是否会购买的预测，我们可以在 0.5 处画一条直线，在直线下的用户我们可以将其y值设置为0，直线以上的就可以预测用户会购买。</p>
<p><img src="/2020/10/11/Logistic-Regression/6.png" style="zoom:150%;"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>我们下面就对一个比较真实的数据集进行逻辑回归的分类. 其中 Feature是 Age和EstimatedSalary，需要被预测的值是 Purchased。一共有400行数据，没有缺失值，不需要进行数据清洗。</p>
<p>假设你是一家车厂的销售经理，我们拿到了一些之前顾客的年龄和预期薪资和他们的购车情况，我的任务就是去选择什么人群有更多的可能会购买我们车厂新出的车型。</p>
<p><img src="/2020/10/11/Logistic-Regression/7.png" style="zoom:150%;"></p>
<p>接下来我们会一步步进行逻辑回归。以后对于其他数据集，也可以使用这个模板：</p>
<p>首先我们进行导库、训练集测试集切割</p>
<h3 id="Importing-the-Libraries"><a href="#Importing-the-Libraries" class="headerlink" title="Importing the Libraries"></a>Importing the Libraries</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>
<h3 id="Importing-the-dataset"><a href="#Importing-the-dataset" class="headerlink" title="Importing the dataset"></a>Importing the dataset</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataset = pd.read_csv(<span class="string">'Social_Network_Ads.csv'</span>)</span><br><span class="line">X = dataset.iloc[:, :<span class="number">-1</span>].values</span><br><span class="line">y = dataset.iloc[:, <span class="number">-1</span>].values</span><br></pre></td></tr></table></figure>
<h3 id="Splitting-the-dataset"><a href="#Splitting-the-dataset" class="headerlink" title="Splitting the dataset"></a>Splitting the dataset</h3><p>我们将测试集设为整个数据集的25%，将训练集设为数据集的75%</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = <span class="number">0.25</span>, random_state = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Feature-Scaling"><a href="#Feature-Scaling" class="headerlink" title="Feature Scaling"></a>Feature Scaling</h3><p>然后我们现在要判断是否需要 Feature Scaling</p>
<p>首先我们要知道<strong>逻辑回归模型不一定都要进行特征放缩</strong>(不同于一定要进行放缩的SVM)，但是对一些特征进行放缩可能会提升整个模型的性能。我们就要看看这个数据集的特征是否需要被放缩。</p>
<p>我们这个数据集，有两个Features：年龄和收入，这两者的均值相差很大，肯定不是一个维度下的，于是需要对其进行特征放缩。而预测的是他们是否会购买，值为0或者1，所以不用对预测值进行特征放缩</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">sc = StandardScaler()</span><br><span class="line">X_train = sc.fit_transform(X_train)</span><br><span class="line">X_test = sc.transform(X_test)</span><br></pre></td></tr></table></figure>
<p>我们需要对测试集和训练集都进行特征放缩。</p>
<h3 id="Training-the-Logistic-Regression-model"><a href="#Training-the-Logistic-Regression-model" class="headerlink" title="Training the Logistic Regression model"></a>Training the Logistic Regression model</h3><p>接下来我们来训练逻辑回归模型。很简单，从 sklearn.linear_model 模块中导入LogisticRegression类。</p>
<p>因为现在我们做的是分类而不是回归，所以我们从回归器(regressor) 变成了分类器(classifier).</p>
<p>现在我们知识初步学习一下逻辑回归模型，所以对其中的参数并没有很多的要求，只要将 random_state 设置为0即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line">classifier = LogisticRegression(random_state = <span class="number">0</span>)</span><br><span class="line">classifier.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>
<h3 id="Predicting"><a href="#Predicting" class="headerlink" title="Predicting"></a>Predicting</h3><h4 id="Predicting-a-new-result"><a href="#Predicting-a-new-result" class="headerlink" title="Predicting a new result"></a>Predicting a new result</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(classifier.predict(sc.transform([[<span class="number">30</span>,<span class="number">87000</span>]])))</span><br></pre></td></tr></table></figure>
<p>打印得到 [0]，说明对于30岁，年入87000美元的人来说，他大概率不会购买这辆车。</p>
<h4 id="Predicting-the-Test-set-results"><a href="#Predicting-the-Test-set-results" class="headerlink" title="Predicting the Test set results"></a>Predicting the Test set results</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y_pred = classifier.predict(X_test)</span><br><span class="line">print(np.concatenate((y_pred.reshape(len(y_pred),<span class="number">1</span>),</span><br><span class="line">                      y_test.reshape(len(y_test),<span class="number">1</span>)),<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>然后我们对测试集进行一个预测，并将预测出来的结果和原来的结果进行一个比对。注意，这里要做一个形状转换，将他们都变成竖着排列的。</p>
<p>打印得到：</p>
<p>肉眼可见大多数情况都预测成功了，只有少数几组数据没有预测成功</p>
<p><img src="/2020/10/11/Logistic-Regression/10.png" style="zoom:120%;"></p>
<h3 id="Making-the-Confusion-Matrix"><a href="#Making-the-Confusion-Matrix" class="headerlink" title="Making the Confusion Matrix"></a>Making the Confusion Matrix</h3><p>Confusion Matrix 是混淆矩阵，是表示精度评价的一种标准格式，用n行n列的矩阵形式来表示。具体评价指标有总体精度等。</p>
<p>混淆矩阵的每一列代表了预测类别，每一列的总数表示预测为该类别的数据的数目；每一行代表了数据的真实归属类别，每一行的数据总数表示该类别的数据实例的数目。每一列中的数值表示真实数据被预测为该类的数目</p>
<p>如下图，第一行第一列中的43表示有43个实际归属第一类的实例被预测为第一类，同理，第一行第二列的2表示有2个实际归属为第一类的实例被错误预测为第二类。</p>
<p><img src="/2020/10/11/Logistic-Regression/11.png" style="zoom:120%;"></p>
<p>我们用python的confusion_matrix也可以来做这个模型的混淆矩阵，只要将y_test,y_pred传入即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix, accuracy_score</span><br><span class="line">cm = confusion_matrix(y_test, y_pred)</span><br><span class="line">print(cm)</span><br><span class="line">accuracy_score(y_test, y_pred)</span><br></pre></td></tr></table></figure>
<p>打印得到下面的数据：说明第一类(0)有65组数据预测成功，3组数据预测失败；第二类(1)有24组数据预测成功，8组数据预测失败</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[65  3]</span><br><span class="line"> [ 8 24]]</span><br></pre></td></tr></table></figure>
<p>accuracy_score: </p>
<p>一共有100组数据，11组预测失败，成功的概率为89%，于是accuracy_score = 0.89</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.89</span><br></pre></td></tr></table></figure>
<h3 id="Visualising"><a href="#Visualising" class="headerlink" title="Visualising"></a>Visualising</h3><p>现在我们做一个可视化操作，可以很直观地展现整个模型的效果。我们的图像将达到三个效果</p>
<ul>
<li>我们将用一个2维图展现，其中x轴、y轴分别是年龄和薪资两个特征。</li>
<li>我们将用每一个点表示一个顾客的信息，并用不同的颜色将他们的购买情况区分开来</li>
<li>我们将用颜色区分开两个不同的预测区域，并在中间画出分界线。</li>
</ul>
<h4 id="Visualising-the-Training-set-results"><a href="#Visualising-the-Training-set-results" class="headerlink" title="Visualising the Training set results"></a>Visualising the Training set results</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line">X_set, y_set = sc.inverse_transform(X_train), y_train</span><br><span class="line">X1, X2 = np.meshgrid(np.arange(start = X_set[:, <span class="number">0</span>].min() - <span class="number">10</span>, </span><br><span class="line">                               stop = X_set[:, <span class="number">0</span>].max() + <span class="number">10</span>, </span><br><span class="line">                               step = <span class="number">0.25</span>),</span><br><span class="line">                     np.arange(start = X_set[:, <span class="number">1</span>].min() - <span class="number">1000</span>, </span><br><span class="line">                               stop = X_set[:, <span class="number">1</span>].max() + <span class="number">1000</span>, </span><br><span class="line">                               step = <span class="number">0.25</span>)</span><br><span class="line">                    )</span><br><span class="line">plt.contourf(X1, </span><br><span class="line">             X2,</span><br><span class="line">             classifier.predict(sc.transform(np.array([X1.ravel(), X2.ravel()]).T)).reshape(X1.shape),</span><br><span class="line">             alpha = <span class="number">0.75</span>,</span><br><span class="line">             cmap = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>)))</span><br><span class="line"></span><br><span class="line">plt.xlim(X1.min(),X1.max())</span><br><span class="line">plt.ylim(X2.min(),X2.max())</span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> enumerate(np.unique(y_set)):</span><br><span class="line">    plt.scatter(X_set[y_set == j, <span class="number">0</span>],</span><br><span class="line">                X_set[y_set == j, <span class="number">1</span>],</span><br><span class="line">                c = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>))(i),</span><br><span class="line">                label = j)</span><br><span class="line">plt.title(<span class="string">'Logistic Regression (Training set)'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Age'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Estimated Salary'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/11/Logistic-Regression/8.png" style="zoom:120%;"></p>
<h4 id="Visualising-the-Test-set-results"><a href="#Visualising-the-Test-set-results" class="headerlink" title="Visualising the Test set results"></a>Visualising the Test set results</h4><p><img src="/2020/10/11/Logistic-Regression/9.png" style="zoom:120%;"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/" itemprop="url">CSAPP程序的机器即表示2（6~11节）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-10-11T09:22:59+08:00">
                2020-10-11
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2023-03-25T12:12:25+08:00">
                2023-03-25
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="CSAPP程序的机器即表示2"><a href="#CSAPP程序的机器即表示2" class="headerlink" title="CSAPP程序的机器即表示2"></a>CSAPP程序的机器即表示2</h1><h2 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h2><p>通常，C 语言中的语句和机器代码中的指令都是按照它们在程序中出现的次序，顺序执行的。用jump 指令可以改变一组机器代码指令的执行顺序，jump 指令指定控制应该被传递到程序的某个其他部分，可能是依赖于某个测试的结果。编译器必须产生构建在这种低级机制基础之上的指令序列，来实现C 语言的控制结构。</p>
<p>我们先谈谈实现条件操作的两种方式，然后描述表达循环的switch 语句的方法。</p>
<h3 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h3><p>除了整数寄存器，CPU 还维护着一组<strong>单个位(byte)</strong> 的条件码(condition code) 寄存器。我们可以检测这些寄存器来执行条件分支指令。</p>
<p>一下是最常用的条件码</p>
<p><strong>CF</strong> : 进位标志。最近的操作使高位产生了进位。可用来检查<strong>无符号操作</strong>的<strong>溢出</strong></p>
<p><strong>ZF</strong>: 零标志。最近的操作得出的结果为<strong>0</strong></p>
<p><strong>SF</strong> : 符号标志。最近的操作得到的结果为<strong>负数</strong></p>
<p><strong>OF</strong>: 溢出标志。最近的操作导致一个补码的溢出—-正\负溢出</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/24.png" style="zoom:100%;"></p>
<p>比如说，我们用一条 ADD指令完成等价于C表达式 $t=a+b$ 的功能，a、b、t都是整形的。然后根据下面的C表达式来设置条件码</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/23.png" style="zoom:100%;"></p>
<p> 有几类指令能够修改条件码：</p>
<ol>
<li>算术指令：既改变操作数，也有肯能改变条件码。</li>
<li>CMP指令：右操作数减左操作数，只可能改变条件码。</li>
<li>TEST指令：两操作数相与，只可能改变条件码。</li>
</ol>
<h3 id="访问条件码"><a href="#访问条件码" class="headerlink" title="访问条件码"></a>访问条件码</h3><p>条件码寄存器不能直接读取，有三种方法：</p>
<ul>
<li>set指令：根据条件码，设置一个字节。</li>
</ul>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/25.png" style="zoom:100%;"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">comp</span><span class="params">(<span class="keyword">data_t</span> a,<span class="keyword">data_t</span> b)</span></span></span><br><span class="line">a in %rdi,b in %rsi</span><br><span class="line">comp:</span><br><span class="line"> 	cmpq 	%rsi, 	%rdi 	<span class="comment">//Compare a:b</span></span><br><span class="line"> 	setl 	%al 			<span class="comment">//Set low-order byte of %eax to 0 or 1</span></span><br><span class="line"> 	movzbl 	%al, 	%eax 	<span class="comment">//Clear rest of %eax (and rest of %rax)</span></span><br><span class="line"> 	ret</span><br></pre></td></tr></table></figure>
<p>第二行是cmp指令，也就是通过%rdi-%rsi 的状态来设置状态码的</p>
<p>第三行是 set 指令，setl %al之后，al寄存器中的值就为比较命令 cmp执行后状态位 $SF\wedge  OF$ 的值</p>
<p>第四行是将 %al 赋值给 eax 的低8bits，然后再将eax的高位设置为0</p>
<p>我们就拿sete来举例，即 “set when equal” 指令。</p>
<p>当a = b 时，会得到 $t=0$ ,因此零标志置为就表示相等。</p>
<p>类似的我们来考虑setl,即”set when less” 指令</p>
<p>当没有发生溢出的时候，OF设置为0，那么只有当 $a-b&lt;0$ 的时候，SF会等于1；<br>如果发生了溢出，那么OF设置为1，那么要让a仍然小于b，就要让a为负、b为正，a-b 会下溢变成正数，于是 SF会等于0</p>
<p>那么只有当 SF^OF ，才能保证将每一种情况都包含在内，才能表达出 a&lt;b 是否为真。</p>
<h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><ul>
<li>jump指令：根据条件码进行跳转，即控制的条件转移。</li>
</ul>
<p>跳转指令会导致执行切换到程序中一个全新的位置。在汇编代码中，这些跳转的目的地通常用一个标号(label) 指明.比如说:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	movq $0,%rax 		Set %rax to 0</span><br><span class="line">	jmp .L1 			Goto .L1</span><br><span class="line">	movq (%rax),%rdx 	Null pointer dereference (skipped)</span><br><span class="line">.L1:</span><br><span class="line">	popq %rdx 			Jump target</span><br></pre></td></tr></table></figure>
<p>指令jmp.L1 会导致程序跳过movq 指令，而从popq 指令开始继续执行。在产生目标代码文件时，汇编器会确定所有带标号指令的地址，并将跳转目标（目的指令的地址）编码为跳转指令的一部分。</p>
<p>下面列举了不同的跳转指令：</p>
<ul>
<li>jmp 是无条件跳转，它可以是<strong>直接跳转</strong>，即<strong>跳转目标</strong>是作为指令的<strong>一部分</strong> 编码的。也可以是<strong>间接跳转</strong>，即跳转目标是从寄存器或者内存位置中读出的<ul>
<li>汇编语言中，直接跳转是给出一个标号作为跳转目标的，例如上面所示代码中的标号“.L1”。间接跳转的写法是 ”*“ 后面跟一个操作数指示符</li>
<li>例如 <code>jmp *%rax</code> 用寄存器 %rax 中的值作为跳转目标，而 <code>jmp *(%rax)</code> 是以%rax中的值作为地址，从内存中读取跳转目标。</li>
</ul>
</li>
</ul>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/26.png" style="zoom:100%;"></p>
<p>上表所示的其他跳转指令都是有条件的：它们根据条件码的某种组合，或者跳转，或者继续执行代码序列中下一条指令。这些指令的名字和跳转条件与SET指令的名字和设置条件是相匹配的。</p>
<p>同SET指令一样，一些底层的机器指令有多个名字，<strong>条件跳转只能是直接跳转</strong>。</p>
<ul>
<li>cmov条件传送指令：根据条件码决定是否进行mov操作（其性能要优于控制的条件转移P141）也就是有条件地传送数据。</li>
</ul>
<p>注意点： je 是判断 ZF的，如果ZF=1(计算结果为0) 那么就会跳转；反之，jne是判断 <code>~ZF</code> 的，如果ZF=0(计算结果不为0)，则会跳转</p>
<p>同时我们也应该了解到，<code>sub</code> 和 <code>add</code> 这类指令也会影响符号位，所以说会出现这样的汇编代码：</p>
<p>这段代码我们这么理解： 首先让rdx寄存器中的数字减去1，判断是否为0，若为0则将ZF置为1，若不为0则将ZF置为0。然后用jne进行条件跳转。最后的逻辑就是</p>
<p><code>if rdx-1 != 0</code> 则跳转，等于0则返回。     </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subq	$1, %rdx</span><br><span class="line">jne		.L10</span><br></pre></td></tr></table></figure>
<h3 id="跳转指令的编码"><a href="#跳转指令的编码" class="headerlink" title="跳转指令的编码"></a>跳转指令的编码</h3><p>在汇编代码中，跳转目标用符号标号书写。汇编器，以及后来的链接器，会产生跳转目标的适当编码。跳转指令有几种不同的编码，但是最常用都是<strong>PC-relative</strong>。也就是说它们会将<strong>目标指令的地址</strong>与<strong>紧跟在跳转指令后面那条指令的地址</strong>之间的差作为编码 这些地址偏移量可以编码为1、2 或4 个字节。</p>
<p>第二种编码方法是给出“绝对”地址，用4 个字节直接指定目标。汇编器和链接器会选择适当的跳转目的编码。</p>
<p>下面是一个PC-relative的例子，它包含两个跳转：第二行的jmp指令前向跳转到更高的地址，而第7行的jg指令后向跳转到较低的地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 	movq 	%rdi, %rax</span><br><span class="line"> 	jmp 	.L2</span><br><span class="line">.L3:</span><br><span class="line"> 	sarq 	%rax</span><br><span class="line">.L2:</span><br><span class="line"> 	testq 	%rax, %rax</span><br><span class="line"> 	jg 		.L3</span><br><span class="line"> 	rep; 	ret</span><br></pre></td></tr></table></figure>
<p>仍然是同一个函数，汇编器产生的 “.o” 格式的反汇编版本如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0: 48 89 f8 	mov 	%rdi,%rax</span><br><span class="line">3: eb 03 		jmp 	8&lt;loop+0x8&gt;</span><br><span class="line">5: 48 d1 f8 	sar 	%rax</span><br><span class="line">8: 48 85 c0 	test 	%rax,%rax</span><br><span class="line">b: 7f f8 		jg 		5&lt;loop+0x5&gt;</span><br><span class="line">d: f3 c3 		repz 	retq</span><br></pre></td></tr></table></figure>
<p>我们看到反汇编版本生成的汇编语言没有label，<code>jmp + label</code>的直接跳转也变成了 <code>jmp+地址</code> 的间接跳转。那么我们刚才说了，产生跳转目标的编码是由<strong>目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差</strong>得出的。我们现在就可以来验证这个是否正确。</p>
<p>我们观察到第2行中跳转指令的跳转目标指明为0x8,观察指令的字节编码，会看到第一条跳转指令的目标编码(在第二个字节当中)为0x03 ，然后将其加上<strong>紧跟在跳转指令后面那条指令的地址</strong>0x5 就得到了跳转目标地址0x8 也就是第4行指令的地址。</p>
<p>同样的，第二个跳转指令的目标编码是0xf8(十进制的-8) .将这个数加上<strong>紧跟在跳转指令后面那条指令的地址</strong> 0xd 即得到0x5 ，即第三行指令的地址。</p>
<p>这说明在执行，当执行PC 相对寻址时，程序计数器的值是跳转指令后面的那条指令的地址，而不是跳转指令本身的地址。</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/27.png" style="zoom:100%;"></p>
<p>A:  02+4003fc = 4003fe</p>
<p>B:  因为 0xf4 是-12的补码所以这里是 400431-12 = 400425</p>
<p>C:  根据反汇编器产生的注释，跳转目标是绝对地址 0x400547.那么根据字节编码，一定在距离pop 0x2 的地址处。减去这个值就得到地址 0x400545. 注意，ja指令的编码需要2个字节，它一定位于地址0x400543处。</p>
<p>D: jmpq 是 e9, XXXXXX = 0xffffff73(负数)+0x4005ed =0x400560</p>
<h3 id="用条件控制来实现条件分支"><a href="#用条件控制来实现条件分支" class="headerlink" title="用条件控制来实现条件分支"></a>用条件控制来实现条件分支</h3><p>其实在代码中，我们更多的是要使用控制结构(循环，if-else, switch 等)现在我们要思考怎么用刚学的条件位、comp、jump指令来实现这些控制结构。那么我们一般写的控制结构是没有goto的，因为goto会让程序变得很乱，可读性会变差。但是我们的汇编代码在实现这些控制结构的时候，用了非常类似于goto的代码。只不过goto利用jump来实现。</p>
<p>我们可以先来写一个C语言代码，然后写一个goto风格的C语言代码，最后将其汇编代码贴出。比较一下它们之间的相似于不同。这个函数是让我们求两个整数之间差的绝对值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(a) <span class="function">Original C <span class="title">code</span>								<span class="params">(b)</span> Equivalent <span class="keyword">goto</span> version</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> lt_cnt </span>= <span class="number">0</span>;								<span class="function"><span class="keyword">long</span> <span class="title">gotodiff_se</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y)</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> ge_cnt </span>= <span class="number">0</span>;								&#123;		</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">absdiff_se</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y)</span>						<span class="keyword">long</span> result</span>;</span><br><span class="line">&#123;													<span class="keyword">if</span> (x &gt;= y)</span><br><span class="line">	<span class="keyword">long</span> result;										<span class="keyword">goto</span> x_ge_y;	</span><br><span class="line">	<span class="keyword">if</span> (x &lt; y) &#123;									lt_cnt++;</span><br><span class="line">		lt_cnt++;									result = y - x;</span><br><span class="line">		result = y - x;								<span class="keyword">return</span> result;</span><br><span class="line">	&#125;											  x_ge_y:</span><br><span class="line">	<span class="keyword">else</span> &#123;											ge_cnt++;</span><br><span class="line">		ge_cnt++;									result = x - y;</span><br><span class="line">		result = x - y;								<span class="keyword">return</span> result;</span><br><span class="line">	&#125;											&#125;</span><br><span class="line">	<span class="keyword">return</span> result;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到 b)是goto风格的C语言代码，这类代码在一段语句块之前有一个标签(label) ，只要goto 后面加一个标签名字，那么整个程序就会跳转到那个标签去运行。</p>
<p>那么我们再来看看这个程序产生的汇编代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(c) Generated assembly code</span><br><span class="line"><span class="comment">//long absdiff_se(long x, long y)</span></span><br><span class="line"><span class="comment">//x in %rdi, y in %rsi</span></span><br><span class="line">absdiff_se:</span><br><span class="line">cmpq %rsi, %rdi 						Compare x:y</span><br><span class="line">jge .L2 								If &gt;= <span class="keyword">goto</span> x_ge_y</span><br><span class="line">addq $<span class="number">1</span>, lt_cnt(%rip) 					lt_cnt++</span><br><span class="line">movq %rsi, %rax</span><br><span class="line">subq %rdi, %rax 						result = y - x</span><br><span class="line">ret 									Return<span class="comment">//Return的缺省值就是%rax </span></span><br><span class="line">.L2: x_ge_y:</span><br><span class="line">addq $<span class="number">1</span>, ge_cnt(%rip) 					ge_cnt++</span><br><span class="line">movq %rdi, %rax</span><br><span class="line">subq %rsi, %rax 						result = x - y</span><br><span class="line">ret 									Return</span><br></pre></td></tr></table></figure>
<p>我们看到汇编语言和goto风格的C语言是非常相似的。其实这就是 if- else 控制流在汇编语言中的实现原理。在汇编中我们会使用 jx(jump+条件) 条件跳转命令来模拟goto, 这里的 jge就是当大于等于的时候跳转 ，</p>
<p>对于一个 if-else 语句，在C语言里的模板是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(test-expr)</span><br><span class="line">	then-statement</span><br><span class="line">else</span><br><span class="line">	else-statement</span><br></pre></td></tr></table></figure>
<p>这里的test-expr 是一个整数表达式，他的取值为0或者为非0。这两个分支语句中 (then-statement 或者else-statement) 只会执行一个。</p>
<p>在汇编语言里，通常转换成下面这个模板，我们用C语法来描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t = test-expr;</span><br><span class="line"><span class="keyword">if</span>(!t)</span><br><span class="line">	<span class="keyword">goto</span> <span class="literal">false</span>;</span><br><span class="line">then-statement</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line"><span class="literal">false</span>:</span><br><span class="line">	<span class="keyword">else</span> statement</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>
<p>也就是说，汇编器为 $then-statement$ 和 $else-statement$ 产生了各自的代码块，它会插入条件和无条件的分支，以保证执行正确的代码块</p>
<h3 id="用条件传送来实现条件分支"><a href="#用条件传送来实现条件分支" class="headerlink" title="用条件传送来实现条件分支"></a>用条件传送来实现条件分支</h3><p>现在我们再来看看 General Conditional Expression 也就是条件表达式在汇编语言中的呈现情况</p>
<p>比如下面这句条件表达式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val = x &gt; y ? x-y:y-x;</span><br></pre></td></tr></table></figure>
<p>这句和上面的if-else 的表达效果是一样的，可以被总结为这种模式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val = Tese? Then_Expr : Else_Expr;</span><br></pre></td></tr></table></figure>
<p>那么这句话用goto风格的C语言是这样表现的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	ntest &#x3D; !Test;</span><br><span class="line">	if(ntest) goto ELse;</span><br><span class="line">	val &#x3D; Then_Expr;</span><br><span class="line">	goto Done;</span><br><span class="line">Else:</span><br><span class="line">	val &#x3D; ELse_Expr;</span><br><span class="line">Done:</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>还有一种方法，而是将 Then_Expr 和 Else_Expr 表达式都算出来，然后再做一个判断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = Then_Expr;</span><br><span class="line">eval = Else_Expr;</span><br><span class="line">nt = !Test;</span><br><span class="line"><span class="keyword">if</span>(nt) result = eval;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<p>在这样一个没有goto版本的控制流中，每一步都是顺着往下执行的。</p>
<p>这和刚才的goto版本是不一样的，因为<strong>goto语句会降低程序的性能</strong>。 我们可以这样来解释：<br>        CPU在执行一条语句的时候，事实上已经将后面好几条将要被执行的语句放到cache里面了，然而这时候如果出现了goto语句，cpu就要到内存里面去找goto后面的语句，而cache中的语句这时候就没有用了。而到内存中去找语句的速度是远远慢于直接从cache里面取出语句的，所以多用goto会导致程序的效率低下。所以我们这样写，是为了减少goto语句的发生。</p>
<p>下面来看看goto风格和不用goto的代码之间的差别</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t = test-expr;							result = Then_Expr;</span><br><span class="line"><span class="keyword">if</span>(!t)									eval = Else_Expr;</span><br><span class="line">	<span class="keyword">goto</span> <span class="literal">false</span>;							nt = !Test;</span><br><span class="line">then-<span class="function">statement							<span class="title">if</span><span class="params">(nt)</span> result </span>= eval;</span><br><span class="line"><span class="keyword">goto</span> done;								<span class="keyword">return</span> result;</span><br><span class="line"><span class="literal">false</span>:		</span><br><span class="line">	<span class="keyword">else</span> statement</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>
<p>我们看到如果是 if-else 风格的代码，他只会在then_Expr 和 Else_Expr 中计算一个代码块，但是右边的条件表达式语句则是对then_Expr和Else_Expr 都进行了一个计算。</p>
<p>其实，条件表达式就是<strong>用条件传送来实现条件分支</strong>的一个例子。我们可以来看看它的汇编代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(c) Generated assembly code</span><br><span class="line">long absdiff(long x, long y)</span><br><span class="line">x in %rdi, y in %rsi</span><br><span class="line">absdiff:</span><br><span class="line">	movq %rsi, %rax</span><br><span class="line">	subq %rdi, %rax		rval &#x3D; y-x</span><br><span class="line">	movq %rdi, %rdx</span><br><span class="line">	subq %rsi, %rdx 	eval &#x3D; x-y</span><br><span class="line">	cmpq %rsi, %rdi 	Compare x:y</span><br><span class="line">	cmovge %rdx, %rax 	If &gt;&#x3D;, rval &#x3D; eval</span><br><span class="line">	ret 				Return tval</span><br></pre></td></tr></table></figure>
<p>我们来解释一下这段汇编代码，首先它计算了 y-x和x-y 并分别存储到 rval和eval之中，然后它对x、y进行了一个比较。关键在于汇编代码的第七行 cmovge 指令 实现了 cmovdiff的条件复制。只有当第六行的 cmpq指令表明一个值大于等于另一个值(cmovge最后的ge已经表明) ,才会把数据源寄存器传送到目的。</p>
<p>下图列举了 x86-64上一些可用的传送指令。每条指令都有两个操作数：<strong>源寄存器或者内存地址S </strong>, <strong>目的寄存器R</strong> ,和SET、Jump指令一样，cmov指令的结果取决于条件码的值。源值可以从内存或者源寄存器中读取，但是<strong>只有在指定的条件满足时，指令把原值S复制到目的R</strong>。</p>
<p>源和目的 的值可以是16、32、64 位场。不支持单字节的条件传送。无条件指令的操作数的长度显式地编码在指令名中，汇编器可以从目标寄存器的名字推断出条件传送指令的操作数长度。</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/2.png" style="zoom:80%;"></p>
<p>但是条件表达式也存在很多弊端，这里列出几个例子：</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/1.png" style="zoom:80%;"></p>
<p>第一个就是Else_Expr和Then_Expr 计算起来都非常复杂，导致整行语句要运行非常长的时间</p>
<p>第二个就是如果一个表达式计算起来是非法的话，整个代码就会报错。</p>
<p>最后一个就是如果对x自身进行操作，那么我们就会得到意想不到的结果。比如上图我们的意图是如果 x&gt;0 那么就x是原来的7倍，反之则是原来基础上加3。 事实上因为这两个表达式都被计算了，因此我们不管怎么样得到的答案都是原来的七倍再加上三。</p>
<p>所以在写条件表达式之前我们要想想是否有弊端，否则我们就老老实实去写If-then-else </p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>C语言中有 do-while, while ,for 三种循环结构。但是在汇编语言中没有相应的指令存在。可以通过条件测试和跳转的组合来实现循环的效果。我们先来看看do-while 循环</p>
<h4 id="do-while-循环"><a href="#do-while-循环" class="headerlink" title="do-while 循环"></a>do-while 循环</h4><p>do-while 循环的语句通用模板如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">	body-statement</span><br><span class="line">	<span class="keyword">while</span>(test=expr);</span><br></pre></td></tr></table></figure>
<p>也就是说每次循环程序都会执行循环体中的语句，然后执行测试表达式。如果测试为真，就回去再执行一次循环。我们可以看到 body-statement 至少会执行一次。</p>
<p>用 <code>goto</code> 风格的C语言可以这样改写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loop:</span><br><span class="line">	body-statement</span><br><span class="line">	t = test-expr</span><br><span class="line">	<span class="keyword">if</span>(t)</span><br><span class="line">		<span class="keyword">goto</span> loop;</span><br></pre></td></tr></table></figure>
<p>我们具体举一个例子来分析：这个函数的目的是数一数一个二进制字符串中有几个1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C code												Goto Version</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">pcount_do</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> x)</span>							<span class="keyword">long</span> <span class="title">pcount_do</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> x)</span>					</span></span><br><span class="line"><span class="function"></span>&#123;														&#123;</span><br><span class="line">	<span class="keyword">long</span> result = <span class="number">0</span>;										<span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">do</span>&#123;													  loop:</span><br><span class="line">		result+= x&amp;<span class="number">0x1</span>;										result+= x&amp;<span class="number">0x1</span>;</span><br><span class="line">		x&gt;&gt;=<span class="number">1</span>;		<span class="comment">/*x=x&gt;&gt;1*/</span>								x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;<span class="keyword">while</span>(x);												<span class="keyword">if</span>(x) <span class="keyword">goto</span> loop;</span><br><span class="line">	<span class="keyword">return</span> result;											<span class="keyword">return</span> result;</span><br><span class="line">&#125;														&#125;</span><br></pre></td></tr></table></figure>
<p>那么用汇编语言是这样来表达的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	movl 	$0  ,%eax   		# result &#x3D; 0</span><br><span class="line">.L2:							# loop:</span><br><span class="line">	movq 	%rdi,%rdx</span><br><span class="line">	andl	$1	,%eax			# t &#x3D; x&amp;0x1</span><br><span class="line">	addq 	%rdx,%rax			# result +&#x3D;t</span><br><span class="line">	shrq 	%rdi				# x&gt;&gt;&#x3D;1</span><br><span class="line">	jne		.L2					# if(x) goto loop</span><br><span class="line">	rep;ret</span><br></pre></td></tr></table></figure>
<p>​                                                                                                                                                                                                                                                                                                                                  </p>
<h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>那么while循环可以在do-while循环上修改一下即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (Test)			------&gt;							<span class="keyword">goto</span> test;</span><br><span class="line">	Body											loop:</span><br><span class="line">														Body</span><br><span class="line">													test:</span><br><span class="line">														<span class="keyword">if</span>(Test)</span><br><span class="line">															<span class="keyword">goto</span> loop;</span><br><span class="line">													done:</span><br></pre></td></tr></table></figure>
<p>我们只要一上来直接<code>goto</code> test： 即可。这种方法叫做 <strong>jump to middle</strong></p>
<p>还是一样的例子我们用while重写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C code												Goto Version</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">pcount_while</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> x)</span>						<span class="keyword">long</span> <span class="title">pcount_do</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> x)</span>					</span></span><br><span class="line"><span class="function"></span>&#123;														&#123;</span><br><span class="line">	<span class="keyword">long</span> result = <span class="number">0</span>;										<span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x)&#123;												<span class="keyword">goto</span> test;</span><br><span class="line">		result+= x&amp;<span class="number">0x1</span>;									  loop: </span><br><span class="line">		x&gt;&gt;=<span class="number">1</span>;		<span class="comment">/*x=x&gt;&gt;1*/</span>								 result += x&amp;<span class="number">0x1</span>;</span><br><span class="line">	&#125;												 		 x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> result;										  test:</span><br><span class="line">    														 <span class="keyword">if</span>(x) <span class="keyword">goto</span> loop;</span><br><span class="line">&#125;														 	 <span class="keyword">return</span> result;	</span><br><span class="line">														&#125;</span><br></pre></td></tr></table></figure>
<p>我们还有第二种翻译方法，称之为 guarded-do, 首先用条件分支，进来就判断，如果初始条件不成立就跳过循环，把代码变换为do-while 循环。当使用较高优化等级编译的时候，例如使用命令行 -O1，GCC就会采用这种策略</p>
<p> 可以用下面这种模板来表达这种方法，把通用的while循环格式翻译成 do-while 循环：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C code												go-to Style</span></span><br><span class="line">t = test-expr;											t = test-expr;</span><br><span class="line"><span class="keyword">if</span> (!t)                        							<span class="keyword">if</span> (!t)  </span><br><span class="line">	<span class="keyword">goto</span> done;												<span class="keyword">goto</span> done;</span><br><span class="line"><span class="keyword">do</span> 														loop:</span><br><span class="line">	body-statement											body-statement</span><br><span class="line">	<span class="keyword">while</span>(test-expr);										t = test-expr;</span><br><span class="line"><span class="function">done														<span class="title">if</span><span class="params">(t)</span></span></span><br><span class="line"><span class="function">    															<span class="keyword">goto</span> loop</span>;</span><br><span class="line">														done:</span><br></pre></td></tr></table></figure>
<p>思考题：<code>jump  to middle</code> 和 <code>guared-do</code> 什么时候是好的，什么时候是不好的？</p>
<p> guarded-do 是直接进行判断。这个之所以更加高效，是因为一开始进入循环时，通常不会不满足循环条件，即一开始不会跳转到后面，所以会直接顺序一直执行循环体。</p>
<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>for循环是我们很常用的一种循环体，其特点就是结束时间很明确，每一步都很标准。而while则更加自由。</p>
<p>for循环的模板：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(init;Test;Update)</span><br><span class="line">	Body</span><br></pre></td></tr></table></figure>
<p>我们需要的就是将 for 循环转换成 while循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Init;</span><br><span class="line"><span class="keyword">while</span>(Test)&#123;</span><br><span class="line">	Body</span><br><span class="line">	Update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有很多表达式 ，还是拿原来的例子说</p>
<p>初始条件 Init:  <code>i=0</code></p>
<p>测试条件 Test:  <code>i&lt;WSIZE</code></p>
<p>更新跳步 Update: <code>i++</code></p>
<p>循环主题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="built_in">bit</span> = (x&gt;&gt;i)&amp;<span class="number">0x1</span>;</span><br><span class="line">	retult += <span class="built_in">bit</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据上面的模板，我们可以对这段代码进行一个转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">pcount_for_while</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> i;</span><br><span class="line">	<span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">	i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;WSIZE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="built_in">bit</span> = (x&gt;&gt;i)&amp;<span class="number">0x1</span>;</span><br><span class="line">		result += <span class="built_in">bit</span>;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以将For循环转换成 Do-While 循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">pcount_for_goto_dw</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> i;</span><br><span class="line">	<span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">	i=<span class="number">0</span>;								<span class="comment">//Init</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	if(!(i&lt;WSIZE))						//可以删除的Test</span></span><br><span class="line"><span class="comment">		goto done;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">  loop:</span><br><span class="line">	<span class="keyword">while</span>(i&lt;WSIZE)						<span class="comment">//Body</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="built_in">bit</span> = (x&gt;&gt;i)&amp;<span class="number">0x1</span>;</span><br><span class="line">		result += <span class="built_in">bit</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	i++;								<span class="comment">//Update</span></span><br><span class="line">	<span class="keyword">if</span>(!(i&lt;WSIZE))						<span class="comment">//Test</span></span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">  done:	</span><br><span class="line">	<span class="keyword">return</span> result;						</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么可以删除第一个Test呢，因为这里for循环第一次肯定是满足条件的。</p>
<h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><p>switch 语句常常用在做命令行下的用户界面或者自动客服。当在写多分叉、较复杂的分支结构时，用if-else会导致可读性下降。</p>
<p>switch 不仅提高了C代码的可读性，而且通过使用跳转表(jump table) 这种数据结构让实现更加高效。GCC根据switch的数量和值的稀疏成都来翻译switch语句。当switch情况数量比较多,且值得范围跨度比较小的时候，就会使用跳转表。</p>
<p>下面是一个Jump Table 示意图</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/3.png" style="zoom:80%;"></p>
<p>我们将每个代码块的地址填到Jump Table里面去。当我们执行switch中的代码块的时候，我们就使用 <code>goto *JTab[x]</code> 命令  <code>*Jtab[x]</code> 就是一段地址，我们会用goto直接跳到这个地址去。</p>
<p>我们来细致得解读一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">my_switch</span><span class="params">(<span class="keyword">long</span> x,<span class="keyword">long</span> y,<span class="keyword">long</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> w=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">switch</span>(x)&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		w = y*z;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		w=y/z;</span><br><span class="line">		<span class="comment">/*Fall Through*/</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		w+=z;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">		w-=z;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		w=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码编译出来的Jump table和switch得对应关系是这样的：</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/4.png" style="zoom:80%;"></p>
<ul>
<li>当 x==1 的时候：</li>
</ul>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/5.png" style="zoom:80%;"></p>
<ul>
<li>x==2的时候，因为没有break语句，所以执行完case2会继续执行 case3。 这个过程称为 Fall Through</li>
</ul>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/6.png" style="zoom:80%;"></p>
<ul>
<li>x\=\=2 ，x\=\=3 时候的代码块如下：</li>
</ul>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/7.png" style="zoom:80%;"></p>
<ul>
<li>x\=\=5 ,x\=\= 6  和defalut的代码块如下：</li>
</ul>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/8.png" style="zoom:80%;"></p>
<h3 id="Summarizing"><a href="#Summarizing" class="headerlink" title="Summarizing"></a>Summarizing</h3><h4 id="C-Control"><a href="#C-Control" class="headerlink" title="C Control"></a>C Control</h4><p>▪    if-then-else<br>▪    do-while<br>▪    while, for<br>▪    switch</p>
<h4 id="Assembler-Control"><a href="#Assembler-Control" class="headerlink" title="Assembler Control"></a>Assembler Control</h4><p>▪    Conditional jump<br>▪    Conditional move<br>▪    Indirect jump (via jump tables)<br>▪    Compiler generates code sequence to implement more complex control</p>
<h4 id="Standard-Techniques"><a href="#Standard-Techniques" class="headerlink" title="Standard Techniques"></a>Standard Techniques</h4><p>▪    Loops converted to do-while or jump-to-middle form<br>▪    Large switch statements use jump tables<br>▪    Sparse switch statements may use decision trees (if-elseif-elseif-else)</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ul>
<li>Mechanisms</li>
<li>Stack Structure</li>
<li>Calling Conventions<ul>
<li>Passing control</li>
<li>Passing data</li>
<li>Managing local data</li>
</ul>
</li>
<li>Illustration of Recursion</li>
</ul>
<h3 id="Mechanisms-机制"><a href="#Mechanisms-机制" class="headerlink" title="Mechanisms(机制)"></a>Mechanisms(机制)</h3><p>要提供对过程的机器级支持，必须要处理许多不同的属性。为了讨论方便，假设过程P 调用过程Q， Q 执行后返回到P。 这些动作包括下面一个或多个机制：</p>
<ul>
<li>传递控制 ： 在进入过程Q的时候，程序计数器必须被设置为Q 的代码的起始地址，然后在返回时，要把程序计数器设置为p中调用Q后面那条指令的地址。</li>
<li>传递数据： P 必须能够向Q提供一个或者多个参数，Q必须能够向P返回一个值</li>
<li>内存管理：在开始时，Q可能需要为局部变量分配空间，而在返回前，又必须释放这些存储空间。</li>
</ul>
<p>可以简单地说：过程 = 传递控制 + 传递参数 + 分配和释放内存</p>
<p>接下来，我们一步步地构建起不同的机制，先描述控制，再描述数据传递，最后是内存管理。</p>
<h3 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h3><p>首先我们来看看栈结构，右侧长条是地址：</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/9.png" style="zoom:80%;"></p>
<p>我们看到，栈顶指针指向最底下，因为x86-64的栈向低地址方向增长。</p>
<p>将栈放大来看，并标出地址增长和减小的方向：</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/10.png" style="zoom:100%;"></p>
<p>我们可以用 pushq和popq指令来将数据存入栈中或者是从栈中取出。</p>
<h3 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h3><p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/11.png" style="zoom:100%;"></p>
<ul>
<li><p>首先将source中的操作数取出</p>
</li>
<li><p>然后将栈顶指针指向的地址减去8, 因为下移8个byte之后，多出来 8*8 = 64 个bit可以用来存储一个64位的地址</p>
</li>
<li>最后将这个操作数的地址写入栈顶指针</li>
</ul>
<h4 id="Pop"><a href="#Pop" class="headerlink" title="Pop"></a>Pop</h4><p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/12.png" style="zoom:100%;"></p>
<ul>
<li>首先将 %rsp 栈顶指针中的值读出</li>
<li>然后将栈顶指针加上8</li>
<li>最后将读出的值存入到寄存器当中</li>
</ul>
<p>所以不管是 Push还是Pop，都是值改变了 $\%rsp$ 的值，并没有改变内存 。</p>
<h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><p>下面我们仔细谈论栈帧的概念。</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/13.png" style="zoom:100%;"></p>
<p>当过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这个部分称为过程的栈帧(Frame)。上图就是运行时栈的通用结构。</p>
<ul>
<li>当前正在执行的过程的帧总是在栈顶。</li>
<li>当过程P调用过程Q的时候,会把返回地址压入栈中，指明Q返回时，要从p程序的哪个位置继续执行。我们会把这个返回地址当作p的栈帧的一部分，因为他存放的是于P相关的状态。</li>
</ul>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/14.png" style="zoom:100%;"></p>
<ul>
<li>Q 的代码会扩展当前栈的边界，分配它的栈帧所需的空间。在这个空间中，它可以保存寄存器的值，分配局部变量空间，为它调用的过程设置参数。</li>
<li>大多数过程的栈帧都是定长的，在过程的开始就分配好了</li>
<li>通过寄存器，过程P 可以传递最多6 个整数值(也就是指针和整数), 但是如果Q 需要更多的参数，P 可以在调用Q 之前在自己的栈帧里存储好这些参数。</li>
</ul>
<hr>
<h3 id="转移控制"><a href="#转移控制" class="headerlink" title="转移控制"></a>转移控制</h3><p>P调用Q，Q运行完之后返回P，这个函数转移的底层是<strong>用栈实现</strong>的：</p>
<ul>
<li>首先将程序计数器(PC) 设置为 Q 的代码的起始位置。</li>
<li>稍后从Q返回的时候，处理器用指令call Q 调用过程Q来记录好过程P需要继续执行的代码的位置，这个指令会把地址A压入栈中，并将PC设置为Q的起始地址。</li>
<li>压入的地址A被称为返回地址，是紧跟在 call 指令后面的那条指令的地址。对应的指令ret会从栈中弹出地址A,并把pc设置为A</li>
</ul>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/15.png" style="zoom:100%;"></p>
<p>call 指令有一个目标，<strong>即指明被调用过程起始的指令地址</strong>。 调用可以是直接的也可以是间接的。在汇编代码中，直接调用的目标是一个Label，而间接调用的目标是 *加上一个操作数指示符</p>
<p>现在我们用一个具体的例子来理解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Beginning of function multstore</span><br><span class="line">0000000000400540 &lt;multstore&gt;:</span><br><span class="line">400540: 53 					push %rbx</span><br><span class="line">400541: 48 89 d3 			mov %rdx,%rbx</span><br><span class="line">. . .</span><br><span class="line">Return from function multstore</span><br><span class="line">40054d: c3 					retq</span><br><span class="line">. . .</span><br><span class="line">Call to multstore from main</span><br><span class="line">400563: e8 d8 ff ff ff 		callq 400540 &lt;multstore&gt;</span><br><span class="line">400568: 48 8b 54 24 08 		mov 0x8(%rsp),%rdx</span><br></pre></td></tr></table></figure>
<p>从上面这段代码中我们可以看到，在main函数中，地址为 0x400563 的call指令调用函数 multstore. 此时栈中的状态如图所示：</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/16.png" style="zoom:100%;"></p>
<p>调用完call之后，栈中的状态如图：</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/17.png" style="zoom:100%;"></p>
<p>也就是说，call的小姑就是将400563的后一句400568给压入栈中，并跳转到函数multistore的第一条指令，地址为 0x400540. 然后函数multstore继续执行，一直到遇上地址 0x40054d处的ret指令。</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/18.png" style="zoom:100%;"></p>
<p>ret指令从栈中弹出值 0x400568,然后跳转到这个地址，就在call之后一句，然后继续main函数的执行。</p>
<p>再来看看上课居的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multstore</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y, <span class="keyword">long</span> *dest)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> t = mult2(x, y); </span><br><span class="line">	*dest = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">mult2</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="keyword">long</span> s = a * b; </span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将其编译成汇编语言，得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0000000000400540 &lt;multstore&gt;:</span><br><span class="line">400540: push	%rbx 			# Save %rbx </span><br><span class="line">400541: mov 	%rdx,%rbx 		# Save dest </span><br><span class="line">400544: callq 	400550 &lt;mult2&gt;	# mult2(x,y) </span><br><span class="line">400549: mov 	%rax,(%rbx)		# Save at dest</span><br><span class="line">40054c: pop 	%rbx			# Restore %rbx</span><br><span class="line">40054d: retq					# Return</span><br><span class="line">0000000000400550 &lt;mult2&gt;:</span><br><span class="line">400550: 	mov  	  %rdi,%rax   	# a </span><br><span class="line">400553:		imul 	  %rsi,%rax		# a * b </span><br><span class="line">400557: 	retq					# Return</span><br></pre></td></tr></table></figure>
<p>首先，运行到0x400544这一段，程序计数器%rip中存储的就是0x400544,他会调用 400550 地址的函数也就是 mult2</p>
<p>call运行完之后，%rip 中的地址变成了 0x400550 ，同时将call的后一句的地址压栈，并修改%rsp 的值</p>
<p>解这运行到了 400557 这行命令，就要return了，return操作是将栈顶取出放入 %rip 并退栈，最后%rip 的值为 0x400549</p>
<h3 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h3><p>当调用一个过程时，除了要把控制传递给它沐在过程返回时再传递回来之外，过程调用还可能包括把数据作为参数传递。我们大部分过程间的数据传送是通过寄存器实现的。</p>
<p>比如当过程P调用过程Q的时候，P的代码必须收i按将参数复制到合适的寄存器中。类似的，当Q返回到P的时候，P的代码可以访问寄存器 %rax 中的返回值。</p>
<p>x86-64中，可以通过寄存器<strong>最多传递6 个整型（例如整数和指针）参数</strong>(Argument)。寄存器的使用是有特殊顺序的.<strong>寄存器是按照特殊顺序来使用的，而使用的名字是根据参数的大小来确定的</strong></p>
<p>比如：可以通过64 位寄存器适当的部分访问小于64 位的参数。如果第一个参数是32 位的，那么可以用％edi 来访问它。</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/19.png" style="zoom:100%;"></p>
<p><strong>重点</strong>：如果一个函数有大于6个整形的参数，超出六个的部分就要通过栈来传递。假设过程P调用过程Q，有n个参数，且n&gt;6.那么p的代码分配的栈帧就必须要能容纳第七到第n号参数的存储空间。</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/14.png" style="zoom:100%;"></p>
<p>通过栈传递参数时，所有的数据大小都<strong>向8的倍数对齐</strong>。参数到位以后，程序就可以执行call指令间控制转移到过程Q了。<strong>过程Q可以通过寄存器访问参数，也可以通过栈来访问</strong>。</p>
<p>相应的，如果Q也调用了某个有超过6个参数的函数，他也需要在自己的栈帧中为超出6个部分的参数分配空间。也就是分配到下图中 “Argument Build Area” (参数构造区) 的区域</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/20.png" style="zoom:100%;"></p>
<p>下面是一个具体的例子：</p>
<p>有多个不同类型参数的函数示例。参数1~6 通过寄存器传递，而参数7~8 通过栈传递</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">(a) C code</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc</span><span class="params">(	<span class="keyword">long</span> a1, <span class="keyword">long</span> *a1p,</span></span></span><br><span class="line"><span class="function"><span class="params">		  	<span class="keyword">int</span> a2, <span class="keyword">int</span> *a2p,</span></span></span><br><span class="line"><span class="function"><span class="params">		  	short a3, short *a3p,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">char</span> a4, <span class="keyword">char</span> *a4p	)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	*a1p += a1;</span><br><span class="line">	*a2p += a2;</span><br><span class="line">	*a3p += a3;</span><br><span class="line">	*a4p += a4;</span><br><span class="line">&#125;</span><br><span class="line">(b) Generated assembly code</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">proc</span><span class="params">(a1, a1p, a2, a2p, a3, a3p, a4, a4p)</span></span></span><br><span class="line"><span class="function">    Arguments passed as follows:</span></span><br><span class="line">        a1 in %rdi (64 bits)</span><br><span class="line">        a1p in %rsi (<span class="number">64</span> bits)</span><br><span class="line">        a2 in %edx (<span class="number">32</span> bits)</span><br><span class="line">        a2p in %rcx (<span class="number">64</span> bits)</span><br><span class="line">        a3 in %r8w (<span class="number">16</span> bits)</span><br><span class="line">        a3p in %r9 (<span class="number">64</span> bits)</span><br><span class="line">        a4 at %rsp+<span class="number">8</span> ( <span class="number">8</span> bits)</span><br><span class="line">        a4p at %rsp+<span class="number">16</span> (<span class="number">64</span> bits)</span><br><span class="line">proc:</span><br><span class="line">	movq <span class="number">16</span>(%rsp), %<span class="function">rax 	Fetch <span class="title">a4p</span> <span class="params">(<span class="number">64</span> bits)</span></span></span><br><span class="line">	addq %rdi, (%rsi)		*a1p += a1 (64 bits)</span><br><span class="line">	addl %edx, (%rcx) 		*a2p += a2 (<span class="number">32</span> bits)</span><br><span class="line">	addw %r8w, (%r9) 		*a3p += a3 (<span class="number">16</span> bits)</span><br><span class="line">	movl <span class="number">8</span>(%rsp), %edx 		Fetch a4 ( <span class="number">8</span> bits)</span><br><span class="line">	addb %dl, (%rax) 		*a4p += a4 ( <span class="number">8</span> bits)</span><br><span class="line">	ret 				    Return</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/21.png" style="zoom:100%;"></p>
<p>可以看到，作为过程调用的一部分，返回地址被压入栈中。因而这两个参数位于相对于<strong>栈指针</strong>距离为8 和16 的位置。在这段代码中，我们可以看到根据操作数的大小，使用了ADD 指令的不同版本：</p>
<ul>
<li><code>al(long)</code>使用<code>addq</code></li>
<li><code>a2(int)</code>使用<code>addl</code></li>
<li><code>a3(short)</code>使用<code>addw</code></li>
<li><code>a4(char)</code>使用<code>addb</code></li>
<li>请注意第6行的<code>movl</code>指令从内存读人4 字节，而后面的<code>addb</code>指令只使用其中的低位一字节。</li>
</ul>
<h3 id="栈上的局部存储"><a href="#栈上的局部存储" class="headerlink" title="栈上的局部存储"></a>栈上的局部存储</h3><p>有些时候，局部数据必须存放在内存中，常见的情况包括：</p>
<ul>
<li>寄存器不足够存放所有的本地数据。</li>
<li>对一个局部变量使用地址运算符 ‘&amp;’，. 因此必须能够为它产生一个地址。</li>
</ul>
<ul>
<li>某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。</li>
</ul>
<p>一般来说，过程通过<strong>减小</strong> 栈指针在栈上分配空间。分配的结果作为栈帧的一部分，标号为”局部变量”</p>
<p>(a) Code for swap_add and calling function</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">swap_add</span><span class="params">(<span class="keyword">long</span> *xp, <span class="keyword">long</span> *yp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> x = *xp;</span><br><span class="line">	<span class="keyword">long</span> y = *yp;</span><br><span class="line">	*xp = y;</span><br><span class="line">	*yp = x;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">caller</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> arg1 = <span class="number">534</span>;</span><br><span class="line">	<span class="keyword">long</span> arg2 = <span class="number">1057</span>;</span><br><span class="line">	<span class="keyword">long</span> sum = swap_add(&amp;arg1, &amp;arg2);</span><br><span class="line">	<span class="keyword">long</span> diff = arg1 - arg2;</span><br><span class="line">	<span class="keyword">return</span> sum * diff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以从下面这段汇编语言分析出caller是如何用栈帧来实现这些局部变量的。</p>
<ul>
<li>代码开始的时候把栈指针减了16，这是在栈上分配了16个字节</li>
<li>将534，1057压栈，可以看到<code>&amp;arg2 = S+8 &amp;arg1 = S</code>.因此可以推断局部变量 arg1和arg2 存放在栈帧中的位置相对于栈顶指针的偏移量为0和8</li>
<li>add调用完成后，caller的代码会从栈上取出这两个值(因为进行过了swap操作，两个地址指向的值已经交换了)，并计算它们的差，再乘以 swap_add 在寄存器 %rax 中返回的值</li>
<li>最后，该函数将栈顶指针加上16来释放栈帧。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">long caller()</span><br><span class="line">caller:</span><br><span class="line">	subq 	$16, %rsp 				Allocate 16 bytes for stack frame</span><br><span class="line">	movq 	$534, (%rsp) 			Store 534 in arg1</span><br><span class="line">	movq 	$1057, 8(%rsp)			Store 1057 in arg2</span><br><span class="line">	leaq 	8(%rsp), %rsi 			Compute &amp;arg2 as second argument</span><br><span class="line">	movq 	%rsp, %rdi 				Compute &amp;arg1 as first argument</span><br><span class="line">	call 	swap_add 				Call swap_add(&amp;arg1, &amp;arg2)</span><br><span class="line">	movq 	(%rsp), %rdx 			Get arg1</span><br><span class="line">	subq 	8(%rsp), %rdx 			Compute diff &#x3D; arg1 - arg2</span><br><span class="line">	imulq 	%rdx, %rax 				Compute sum * diff</span><br><span class="line">	addq 	$16, %rsp 				Deallocate stack frame</span><br><span class="line">	ret 							Return</span><br></pre></td></tr></table></figure>
<p>下面是一个更复杂的例子。它给出了一个必须在栈上分配局部变量存储空间的函数，同时还要向有8个参数的proc传递值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">call_proc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> x1 = <span class="number">1</span>; <span class="keyword">int</span> x2 = <span class="number">2</span>;</span><br><span class="line">short x3 = <span class="number">3</span>; <span class="keyword">char</span> x4 = <span class="number">4</span>;</span><br><span class="line">proc(x1, &amp;x1, x2, &amp;x2, x3, &amp;x3, x4, &amp;x4);</span><br><span class="line"><span class="keyword">return</span> (x1+x2)*(x3-x4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">long call_proc()</span><br><span class="line">call_proc:</span><br><span class="line">&#x2F;&#x2F;Set up arguments to proc</span><br><span class="line">subq 	$32, %rsp 			Allocate 32-byte stack frame</span><br><span class="line">movq 	$1, 24(%rsp) 		Store 1 in &amp;x1</span><br><span class="line">movl 	$2, 20(%rsp) 		Store 2 in &amp;x2</span><br><span class="line">movw 	$3, 18(%rsp) 		Store 3 in &amp;x3</span><br><span class="line">movb 	$4, 17(%rsp) 		Store 4 in &amp;x4</span><br><span class="line">leaq 	17(%rsp), %rax 		Create &amp;x4</span><br><span class="line">movq 	%rax, 8(%rsp) 		Store &amp;x4 as argument 8</span><br><span class="line">movl 	$4, (%rsp) 			Store 4 as argument 7</span><br><span class="line">leaq 	18(%rsp), %r9 		Pass &amp;x3 as argument 6</span><br><span class="line">movl 	$3, %r8d 			Pass 3 as argument 5</span><br><span class="line">leaq 	20(%rsp), %rcx 		Pass &amp;x2 as argument 4</span><br><span class="line">movl 	$2, %edx 			Pass 2 as argument 3</span><br><span class="line">leaq 	24(%rsp), %rsi 		Pass &amp;x1 as argument 2</span><br><span class="line">movl 	$1, %edi			Pass 1 as argument 1</span><br><span class="line">&#x2F;&#x2F;Call proc</span><br><span class="line">call 	proc</span><br><span class="line">&#x2F;&#x2F;Retrieve changes to memory</span><br><span class="line">movslq 	20(%rsp), %rdx 		Get x2 and convert to long</span><br><span class="line">addq 	24(%rsp), %rdx 		Compute x1+x2</span><br><span class="line">movswl 	18(%rsp), %eax 		Get x3 and convert to int</span><br><span class="line">movsbl 	17(%rsp), %ecx 		Get x4 and convert to int</span><br><span class="line">subl 	%ecx, %eax 			Compute x3-x4</span><br><span class="line">cltq 						Convert to long</span><br><span class="line">imulq 	%rdx, %rax 			Compute (x1+x2) * (x3-x4)</span><br><span class="line">addq 	$32, %rsp 			Deallocate stack frame</span><br><span class="line">ret 						Return</span><br></pre></td></tr></table></figure>
<p>可以看到代码中一大部分是为调用proc做准备。其中包括为局部变量和参数建立栈帧，将函数参数加载至寄存器。</p>
<h3 id="寄存器中的局部存储空间"><a href="#寄存器中的局部存储空间" class="headerlink" title="寄存器中的局部存储空间"></a>寄存器中的局部存储空间</h3><h4 id="被调用者保存寄存器"><a href="#被调用者保存寄存器" class="headerlink" title="被调用者保存寄存器"></a>被调用者保存寄存器</h4><p>寄存器 %rbx 、%rbp 和 %r12~%r15 被划分为被调用者保存寄存器</p>
<p>过程P 调用过程 Q 的时候，Q必须保存这些寄存器的值，保证他们的值在Q返回到P时与Q被调用时是一样的。这时候有两种可能性，要门就是根本不去改变它，要么就是把原始值压入栈中，改变寄存器的值，然后再返回前从栈中弹出旧值。</p>
<h4 id="调用者保存寄存器"><a href="#调用者保存寄存器" class="headerlink" title="调用者保存寄存器"></a>调用者保存寄存器</h4><p>除了%rsp和被调用者保存寄存器，剩下的都是调用者保存寄存器。这就意味着任何函数都能修改它们。</p>
<p>可以这样来理解“调用者保存”这个名字：过程P 在某个此类寄存器中有局部数据，然后调用过程Q 因为Q 可以随意修改这个寄存器，所以在调用之前首先保存好这个数据是P(调用者）的责任。</p>
<p>可以看看下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">long(long x,long y)</span><br><span class="line">&#123;</span><br><span class="line">	long u &#x3D; Q(y);</span><br><span class="line">	long v &#x3D; Q(x);</span><br><span class="line">	return u+v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译成汇编代码如下</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/22.png" style="zoom:100%;"></p>
<p>可以看出来:%rbp 保存 x %rbx 保存计算出来的Q(y) 的值。</p>
<ul>
<li>在函数的开头，把两个寄存器的值保存到栈中(2~3行) 因为这两个寄存器之前可能有值</li>
<li>第一次调用之前，把参数复制到 %rbp</li>
<li>在第二次调用Q之前，把%rax(第一次计算的结果) 放到%rbx中</li>
<li>在函数的结尾，将 %rbp和%rbx 从栈中弹出，恢复这两个被调用者保存寄存器的值，注意他们的弹出顺序和压入顺序相反。</li>
</ul>
<h3 id="递归过程"><a href="#递归过程" class="headerlink" title="递归过程"></a>递归过程</h3><p>每个过程调用在栈中都有它自己的私有空间，因此多个未完成调用的局部变量不会相互影响。此外，栈的原则很自然地就提供了适当的策略，当过程被调用时分配局部存储，当返回时释放存储。</p>
<p>下面给出了递归的阶乘函数的C代码和汇编代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(a) <span class="function">C <span class="title">code</span>								<span class="params">(b)</span> Generated assembly code <span class="comment">//n in %rdi</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">rfact</span><span class="params">(<span class="keyword">long</span> n)</span>						rfact:</span></span><br><span class="line"><span class="function"></span>&#123;											pushq %rbx 			Save %rbx</span><br><span class="line">    <span class="keyword">long</span> result;							movq %rdi, %rbx		Store n in callee-saved <span class="keyword">register</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)								movl $<span class="number">1</span>, %eax		Set <span class="keyword">return</span> value = <span class="number">1</span></span><br><span class="line">    	result = <span class="number">1</span>;							cmpq $<span class="number">1</span>, %rdi		Compare n:<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>									jle .L35 			If &lt;=, <span class="keyword">goto</span> done</span><br><span class="line">	    result = n * rfact(n<span class="number">-1</span>);			leaq <span class="number">-1</span>(%rdi), %rdi Compute n<span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> result;							<span class="function">call rfact			Call <span class="title">rfact</span><span class="params">(n<span class="number">-1</span>)</span></span></span><br><span class="line">&#125;											imulq %rbx, %rax 	Multiply result by n</span><br><span class="line">										.L35:</span><br><span class="line">											popq %rbx 			Restore %rbx</span><br><span class="line">											ret 				Return</span><br></pre></td></tr></table></figure>
<p>我们可以看到，汇编代码使用寄存器 <code>%rbx</code>来保存参数n，先把已经有的值保存在栈上(2行)随后在返回前恢复该值(12行)</p>
<p>根据栈的使用特性和寄存器保存规则，可以保证当递归调用 <code>rfact(n-1)</code>返回时(第9行) 会发生：</p>
<ul>
<li>该次调用的结果会保存在寄存器 <code>%rax</code> 中</li>
<li>参数n的值仍然存在寄存器 <code>%rbx</code> 中</li>
</ul>
<p>把这两个值相乘就能得到期望的结果</p>
<p>从这个例子我们可以看到，递归调用一个函数本身与调用其他函数是一样的。栈规则提供了一种机制，每次函数调用都有它自己私有的状态信息（保存的返回位置和被调用者保存寄存器的值)存储空间。如果需要，它还可以提供局部变量的存储。栈分配和释放的规则很自然地就与函数调用-返回的顺序匹配。这种实现函数调用和返回的方法甚至对更复杂的情况也适用，包括相互递归调用（例如，过程P 调用Q，Q 再调用P)。</p>
<h2 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h2><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/28.png" style="zoom:100%;"></p>
<h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/29.png" style="zoom:100%;"></p>
<h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/30.png" style="zoom:100%;"></p>
<h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/31.png" style="zoom:100%;"></p>
<h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/32.png" style="zoom:100%;"></p>
<h4 id="6"><a href="#6" class="headerlink" title="6"></a>6</h4><p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/33.png" style="zoom:100%;"></p>
<h4 id="7"><a href="#7" class="headerlink" title="7"></a>7</h4><p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/34.png" style="zoom:100%;"></p>
<h4 id="8"><a href="#8" class="headerlink" title="8"></a>8</h4><p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/35.png" style="zoom:100%;"></p>
<h4 id="9"><a href="#9" class="headerlink" title="9"></a>9</h4><p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/36.png" style="zoom:100%;"></p>
<h4 id="10"><a href="#10" class="headerlink" title="10"></a>10</h4><p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/37.png" style="zoom:100%;"></p>
<h4 id="11"><a href="#11" class="headerlink" title="11"></a>11</h4><p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/38.png" style="zoom:100%;"></p>
<h4 id="12"><a href="#12" class="headerlink" title="12"></a>12</h4><p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/39.png" style="zoom:100%;"></p>
<h4 id="13"><a href="#13" class="headerlink" title="13"></a>13</h4><p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/40.png" style="zoom:100%;">z   </p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/10/10/%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/10/10/%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/" itemprop="url">评估与选择合适的回归模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-10-10T18:59:40+08:00">
                2020-10-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-10-10T21:50:58+08:00">
                2020-10-10
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="选择合适的回归模型"><a href="#选择合适的回归模型" class="headerlink" title="选择合适的回归模型"></a>选择合适的回归模型</h1><p>学习自： <a href="https://blog.csdn.net/zrh_CSDN/article/details/81190001" target="_blank" rel="noopener">https://blog.csdn.net/zrh_CSDN/article/details/81190001</a></p>
<h3 id="R-Squard-Intuition"><a href="#R-Squard-Intuition" class="headerlink" title="R-Squard Intuition"></a>R-Squard Intuition</h3><p>线性回归问题中，R-Squared 是用来衡量回归方程与真实样本输出之间的相似程度。其表达式如下所示：</p>
<p>$R^2 = 1-\frac{\sum(y-\hat y)^2}{\sum(y-\overline y)^2}$ </p>
<p>上式中，分子部分表示真实值与<strong>预测值</strong>的平方差之和，类似于 均方差 MSE；分母部分表示真是值与<strong>均值</strong>的平方差之和，类似于方差Var。</p>
<p><strong>根据 R-Squared 的取值，来判断模型的好坏：如果结果是 0，说明模型拟合效果很差；如果结果是 1，说明模型无错误。</strong></p>
<p>一般来说，R-Squared 越大，表示模型拟合效果越好。<strong>R-Squared 反映的是大概有多准，因为，随着特征数量的增加，R-Square必然增加，无法真正定量说明准确程度，只能大概定量。</strong></p>
<p><strong>单独看 R-Squared，并不能推断出增加的特征是否有意义</strong>。通常来说，增加一个特征，R-Squared 可能变大也可能保持不变，两者不一定呈正相关。</p>
<p><img src="/2020/10/10/%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/1.png" alt></p>
<h3 id="Adjusted-R-Squared"><a href="#Adjusted-R-Squared" class="headerlink" title="Adjusted R-Squared"></a>Adjusted R-Squared</h3><p>对于 $R-Squared$ 来说，如果加入一个新的 Feature，在回归模型下，系统会自动让 $SS<em>{res}$ 趋向于最小。那么如果这个Feature会让整个模型预测准确性下降的话，算法就会让这个Feature的系数趋于0甚至等于0，那么$R-Squared$ 值就不会变化(甚至还可能有轻微的提升);如果这个Feature 会让整个模型的预测准确性上升，那么 $SS</em>{res}$ 会变小，而$R-Squared$ 值就会变大，于是 这个值变成了一个只增不减的，是有一个局限性的。</p>
<p>所以 $R^2$ 并不能很好的让我们判断一个新的变量对整个模型的影响。</p>
<p>如果使用校正决定系数（Adjusted R-Square）：</p>
<p>$R^2_adjust = 1-(1-R^2)\frac{(n-1)}{n-p-1}$  </p>
<p>其中，n是<strong>样本数量</strong>(sample size)，p是<strong>特征数量</strong>(number of regressors)。 </p>
<p>我们看到如果我们一直增加特征数量的话， $\frac{n-1}{n-p-1}$ 就会增大，$(1-R^2)$ 会减小，所以这相当于是对增加样本做了一个补偿。</p>
<p>如果我们现在添加的特征是对整个模型基本没用的，那么 $\frac{n-1}{n-p-1}$ 对 $R^2-adjust$ 的影响就会高于其本身对$R^2$ 的影响，因此 $R^2-adjust$ 会下降。反之，如果这个变量是对整个模型特别有用的，那么其对$R^2$ 的影响就会大于 对$\frac{n-1}{n-p-1}$ 的影响，那么整个 $R^2-adjust$ 就会上升</p>
<p>$R^2-adjust$ 抵消样本数量对 R-Square 的影响，做到了真正的 $0\sim 1$ 越大越好 </p>
<h1 id="选择合适的回归模型-1"><a href="#选择合适的回归模型-1" class="headerlink" title="选择合适的回归模型"></a>选择合适的回归模型</h1><p>接下来我们通过一个实践，利用刚刚学习的$R^2$或者 $R^2-adjust$ 来选择最准确的模型。</p>
<h2 id="Preparation-of-the-Regression-Code"><a href="#Preparation-of-the-Regression-Code" class="headerlink" title="Preparation of the Regression Code"></a>Preparation of the Regression Code</h2><p>我们使用的是一个大约有10000行数据的csv文件，没有缺失数据。数据来自<a href="https://archive.ics.uci.edu/ml/index.php" target="_blank" rel="noopener">https://archive.ics.uci.edu/ml/index.php</a> 这里面有很多适合拿来练习data set。 接下来我会提供现在已经学到的五个模型的代码模板.并分别看看这些模板的准确性</p>
<h3 id="multiple-linear-regression"><a href="#multiple-linear-regression" class="headerlink" title="multiple linear regression"></a>multiple linear regression</h3><h4 id="Importing-the-libraries"><a href="#Importing-the-libraries" class="headerlink" title="Importing the libraries"></a>Importing the libraries</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>
<h4 id="Importing-the-dataset"><a href="#Importing-the-dataset" class="headerlink" title="Importing the dataset"></a>Importing the dataset</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataset = pd.read_csv(<span class="string">'ENTER_THE_NAME_OF_YOUR_DATASET_HERE.csv'</span>)</span><br><span class="line">X = dataset.iloc[:, :<span class="number">-1</span>].values</span><br><span class="line">y = dataset.iloc[:, <span class="number">-1</span>].values</span><br></pre></td></tr></table></figure>
<h4 id="Splitting-the-dataset-into-the-Training-set-and-Test-set"><a href="#Splitting-the-dataset-into-the-Training-set-and-Test-set" class="headerlink" title="Splitting the dataset into the Training set and Test set"></a>Splitting the dataset into the Training set and Test set</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = <span class="number">0.2</span>, random_state = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Training-the-Multiple-Linear-Regression-model-on-the-Training-set"><a href="#Training-the-Multiple-Linear-Regression-model-on-the-Training-set" class="headerlink" title="Training the Multiple Linear Regression model on the Training set"></a>Training the Multiple Linear Regression model on the Training set</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line">regressor = LinearRegression()</span><br><span class="line">regressor.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>
<h4 id="Predicting-the-Test-set-results"><a href="#Predicting-the-Test-set-results" class="headerlink" title="Predicting the Test set results"></a>Predicting the Test set results</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y_pred = regressor.predict(X_test)</span><br><span class="line">np.set_printoptions(precision=<span class="number">2</span>)</span><br><span class="line">print(np.concatenate((y_pred.reshape(len(y_pred),<span class="number">1</span>), y_test.reshape(len(y_test),<span class="number">1</span>)),<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<h4 id="Evaluating-the-Model-Performance"><a href="#Evaluating-the-Model-Performance" class="headerlink" title="Evaluating the Model Performance"></a>Evaluating the Model Performance</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> r2_score</span><br><span class="line">r2_score(y_test, y_pred)</span><br></pre></td></tr></table></figure>
<h3 id="Polynomial-Regression"><a href="#Polynomial-Regression" class="headerlink" title="Polynomial Regression"></a>Polynomial Regression</h3><h4 id="Importing-the-libraries-1"><a href="#Importing-the-libraries-1" class="headerlink" title="Importing the libraries"></a>Importing the libraries</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>
<h4 id="Importing-the-dataset-1"><a href="#Importing-the-dataset-1" class="headerlink" title="Importing the dataset"></a>Importing the dataset</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataset = pd.read_csv(<span class="string">'ENTER_THE_NAME_OF_YOUR_DATASET_HERE.csv'</span>)</span><br><span class="line">X = dataset.iloc[:, :<span class="number">-1</span>].values</span><br><span class="line">y = dataset.iloc[:, <span class="number">-1</span>].values</span><br></pre></td></tr></table></figure>
<h4 id="Splitting-the-dataset-into-the-Training-set-and-Test-set-1"><a href="#Splitting-the-dataset-into-the-Training-set-and-Test-set-1" class="headerlink" title="Splitting the dataset into the Training set and Test set"></a>Splitting the dataset into the Training set and Test set</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = <span class="number">0.2</span>, random_state = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Training-the-Polynomial-Regression-model-on-the-Training-set"><a href="#Training-the-Polynomial-Regression-model-on-the-Training-set" class="headerlink" title="Training the Polynomial Regression model on the Training set"></a>Training the Polynomial Regression model on the Training set</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line">poly_reg = PolynomialFeatures(degree = <span class="number">4</span>)</span><br><span class="line">X_poly = poly_reg.fit_transform(X_train)</span><br><span class="line">regressor = LinearRegression()</span><br><span class="line">regressor.fit(X_poly, y_train)</span><br></pre></td></tr></table></figure>
<h4 id="Predicting-the-Test-set-results-1"><a href="#Predicting-the-Test-set-results-1" class="headerlink" title="Predicting the Test set results"></a>Predicting the Test set results</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y_pred = regressor.predict(poly_reg.transform(X_test))</span><br><span class="line">np.set_printoptions(precision=<span class="number">2</span>)</span><br><span class="line">print(np.concatenate((y_pred.reshape(len(y_pred),<span class="number">1</span>), y_test.reshape(len(y_test),<span class="number">1</span>)),<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<h4 id="Evaluating-the-Model-Performance-1"><a href="#Evaluating-the-Model-Performance-1" class="headerlink" title="Evaluating the Model Performance"></a>Evaluating the Model Performance</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> r2_score</span><br><span class="line">r2_score(y_test, y_pred)</span><br></pre></td></tr></table></figure>
<h3 id="Support-Vector-Regression-SVR"><a href="#Support-Vector-Regression-SVR" class="headerlink" title="Support Vector Regression (SVR)"></a>Support Vector Regression (SVR)</h3><h4 id="Importing-the-libraries-2"><a href="#Importing-the-libraries-2" class="headerlink" title="Importing the libraries"></a>Importing the libraries</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>
<h4 id="Importing-the-dataset-2"><a href="#Importing-the-dataset-2" class="headerlink" title="Importing the dataset"></a>Importing the dataset</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataset = pd.read_csv(<span class="string">'ENTER_THE_NAME_OF_YOUR_DATASET_HERE.csv'</span>)</span><br><span class="line">X = dataset.iloc[:, :<span class="number">-1</span>].values</span><br><span class="line">y = dataset.iloc[:, <span class="number">-1</span>].values</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = y.reshape(len(y),<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Splitting-the-dataset-into-the-Training-set-and-Test-set-2"><a href="#Splitting-the-dataset-into-the-Training-set-and-Test-set-2" class="headerlink" title="Splitting the dataset into the Training set and Test set"></a>Splitting the dataset into the Training set and Test set</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = <span class="number">0.2</span>, random_state = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Feature-Scaling"><a href="#Feature-Scaling" class="headerlink" title="Feature Scaling"></a>Feature Scaling</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">sc_X = StandardScaler()</span><br><span class="line">sc_y = StandardScaler()</span><br><span class="line">X_train = sc_X.fit_transform(X_train)</span><br><span class="line">y_train = sc_y.fit_transform(y_train)</span><br></pre></td></tr></table></figure>
<h4 id="Training-the-SVR-model-on-the-Training-set"><a href="#Training-the-SVR-model-on-the-Training-set" class="headerlink" title="Training the SVR model on the Training set"></a>Training the SVR model on the Training set</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVR</span><br><span class="line">regressor = SVR(kernel = <span class="string">'rbf'</span>)</span><br><span class="line">regressor.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>
<h4 id="Predicting-the-Test-set-results-2"><a href="#Predicting-the-Test-set-results-2" class="headerlink" title="Predicting the Test set results"></a>Predicting the Test set results</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y_pred = sc_y.inverse_transform(regressor.predict(sc_X.transform(X_test)))</span><br><span class="line">np.set_printoptions(precision=<span class="number">2</span>)</span><br><span class="line">print(np.concatenate((y_pred.reshape(len(y_pred),<span class="number">1</span>), y_test.reshape(len(y_test),<span class="number">1</span>)),<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<h4 id="Evaluating-the-Model-Performance-2"><a href="#Evaluating-the-Model-Performance-2" class="headerlink" title="Evaluating the Model Performance"></a>Evaluating the Model Performance</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> r2_score</span><br><span class="line">r2_score(y_test, y_pred)</span><br></pre></td></tr></table></figure>
<h3 id="Decision-Tree-Regression"><a href="#Decision-Tree-Regression" class="headerlink" title="Decision Tree Regression"></a>Decision Tree Regression</h3><h4 id="Importing-the-libraries-3"><a href="#Importing-the-libraries-3" class="headerlink" title="Importing the libraries"></a>Importing the libraries</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>
<h4 id="Importing-the-dataset-3"><a href="#Importing-the-dataset-3" class="headerlink" title="Importing the dataset"></a>Importing the dataset</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataset = pd.read_csv(<span class="string">'ENTER_THE_NAME_OF_YOUR_DATASET_HERE.csv'</span>)</span><br><span class="line">X = dataset.iloc[:, :<span class="number">-1</span>].values</span><br><span class="line">y = dataset.iloc[:, <span class="number">-1</span>].values</span><br></pre></td></tr></table></figure>
<h4 id="Splitting-the-dataset-into-the-Training-set-and-Test-set-3"><a href="#Splitting-the-dataset-into-the-Training-set-and-Test-set-3" class="headerlink" title="Splitting the dataset into the Training set and Test set"></a>Splitting the dataset into the Training set and Test set</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = <span class="number">0.2</span>, random_state = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Training-the-Decision-Tree-Regression-model-on-the-Training-set"><a href="#Training-the-Decision-Tree-Regression-model-on-the-Training-set" class="headerlink" title="Training the Decision Tree Regression model on the Training set"></a>Training the Decision Tree Regression model on the Training set</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor</span><br><span class="line">regressor = DecisionTreeRegressor(random_state = <span class="number">0</span>)</span><br><span class="line">regressor.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>
<h4 id="Predicting-the-Test-set-results-3"><a href="#Predicting-the-Test-set-results-3" class="headerlink" title="Predicting the Test set results"></a>Predicting the Test set results</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y_pred = regressor.predict(X_test)</span><br><span class="line">np.set_printoptions(precision=<span class="number">2</span>)</span><br><span class="line">print(np.concatenate((y_pred.reshape(len(y_pred),<span class="number">1</span>), y_test.reshape(len(y_test),<span class="number">1</span>)),<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<h4 id="Evaluating-the-Model-Performance-3"><a href="#Evaluating-the-Model-Performance-3" class="headerlink" title="Evaluating the Model Performance"></a>Evaluating the Model Performance</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> r2_score</span><br><span class="line">r2_score(y_test, y_pred)</span><br></pre></td></tr></table></figure>
<h3 id="Random-Forest-Regression"><a href="#Random-Forest-Regression" class="headerlink" title="Random Forest Regression"></a>Random Forest Regression</h3><h4 id="Importing-the-libraries-4"><a href="#Importing-the-libraries-4" class="headerlink" title="Importing the libraries"></a>Importing the libraries</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>
<h4 id="Importing-the-dataset-4"><a href="#Importing-the-dataset-4" class="headerlink" title="Importing the dataset"></a>Importing the dataset</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataset = pd.read_csv(<span class="string">'ENTER_THE_NAME_OF_YOUR_DATASET_HERE.csv'</span>)</span><br><span class="line">X = dataset.iloc[:, :<span class="number">-1</span>].values</span><br><span class="line">y = dataset.iloc[:, <span class="number">-1</span>].values</span><br></pre></td></tr></table></figure>
<h4 id="Splitting-the-dataset-into-the-Training-set-and-Test-set-4"><a href="#Splitting-the-dataset-into-the-Training-set-and-Test-set-4" class="headerlink" title="Splitting the dataset into the Training set and Test set"></a>Splitting the dataset into the Training set and Test set</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = <span class="number">0.2</span>, random_state = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Training-the-Random-Forest-Regression-model-on-the-whole-dataset"><a href="#Training-the-Random-Forest-Regression-model-on-the-whole-dataset" class="headerlink" title="Training the Random Forest Regression model on the whole dataset"></a>Training the Random Forest Regression model on the whole dataset</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor</span><br><span class="line">regressor = RandomForestRegressor(n_estimators = <span class="number">10</span>, random_state = <span class="number">0</span>)</span><br><span class="line">regressor.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>
<h4 id="Predicting-the-Test-set-results-4"><a href="#Predicting-the-Test-set-results-4" class="headerlink" title="Predicting the Test set results"></a>Predicting the Test set results</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y_pred = regressor.predict(X_test)</span><br><span class="line">np.set_printoptions(precision=<span class="number">2</span>)</span><br><span class="line">print(np.concatenate((y_pred.reshape(len(y_pred),<span class="number">1</span>), y_test.reshape(len(y_test),<span class="number">1</span>)),<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<h4 id="Evaluating-the-Model-Performance-4"><a href="#Evaluating-the-Model-Performance-4" class="headerlink" title="Evaluating the Model Performance"></a>Evaluating the Model Performance</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> r2_score</span><br><span class="line">r2_score(y_test, y_pred)</span><br></pre></td></tr></table></figure>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>我们接下来就对上面的模型进行跑分：</p>
<ul>
<li>Multiple Linear Regression : 0.9325315554761303</li>
<li>Polynomial Regression :  0.945819297903489</li>
<li>Support Vector Regression(SVR) : 0.9480784049986258</li>
<li><p>Decision Tree Regression : 0.9226091050550043</p>
</li>
<li><p>Random Forest :  0.9615980699813017</p>
</li>
</ul>
<p>综上我们得到，Random Forest 随机森林模型对这个数据集的预测准确性在五个模型中分数最高，是最适合的回归模型。</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/10/09/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%9B%9E%E5%BD%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/10/09/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%9B%9E%E5%BD%92/" itemprop="url">决策树和随机森林回归</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-10-09T23:16:25+08:00">
                2020-10-09
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-10-11T15:51:32+08:00">
                2020-10-11
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="决策树和随机森林回归"><a href="#决策树和随机森林回归" class="headerlink" title="决策树和随机森林回归"></a>决策树和随机森林回归</h1><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p><a href="https://www.jianshu.com/p/fcbbd8f2acd5" target="_blank" rel="noopener">https://www.jianshu.com/p/fcbbd8f2acd5</a></p>
<p>首先我们来了解一下CART(Classification And Regression Tree) 的定义。它被分为两类：分类决策树(Classification Trees) 和 回归决策树 (Regression Trees). 这也是我们要用决策树解决的两类问题：分类问题和回归问题。</p>
<p><img src="/2020/10/09/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%9B%9E%E5%BD%92/1.png" style="zoom:80%;"></p>
<p>对于分类决策树，一般来说用于一些分类离散的数据，比如说人的性别是男或者女，水果的种类有苹果梨子等等都是离散的。反之回归决策树，那么对应的场景就是连续的数据，比如人的年龄或者室外的温度。当我们进行分类问题时，分类的组之间是无序的。这里首先介绍下什么是有序，可以举个例子比如年龄，又年龄大或者年龄小。那么对于性别问题，男或女，它是没有顺序的</p>
<p>对于下面这幅散点图，我们要通过其来预测一个第三个维度的独立变量y，我们在二维平面中没有办法看到</p>
<p><img src="/2020/10/09/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%9B%9E%E5%BD%92/2.png" style="zoom:80%;"></p>
<p>如果将其放到一个三维空间里，那么我们就可以将这个y变量显示出来。</p>
<p><img src="/2020/10/09/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%9B%9E%E5%BD%92/3.png" style="zoom:80%;"></p>
<p>当我们运行回归树/决策树模型的时候，上面的散点图就会被分成几个部分,就向下图一样。算法会计算信息熵并决定在那里执行划分，将这些散点分组。那么怎么停止呢？比如说当算法增加一个splits，有一个组(leaves)中的数据低于所有数据的5%，那么这个splits就不会被划分。</p>
<p><img src="/2020/10/09/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%9B%9E%E5%BD%92/4.png" style="zoom:80%;"></p>
<p>现在我们还原创建决策树的过程：</p>
<ul>
<li>首先在 $x_1 = 20$  处画一条分割线，那么决策树的第一个分支就是判断 $x_1$ 是否小于20，并分成2类。</li>
</ul>
<p><img src="/2020/10/09/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%9B%9E%E5%BD%92/5.png" style="zoom:80%;"></p>
<ul>
<li>然后我们在$x_2=170,x_1&gt;20$ 处画一条分割线，那么决策树在右孩子会生成第二个分支，判断 $x_2$ 是否大于170</li>
</ul>
<p><img src="/2020/10/09/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%9B%9E%E5%BD%92/6.png" style="zoom:80%;"></p>
<ul>
<li>接着我们在 $x_2=200,x_1&lt;20$ 画一条 分割线</li>
</ul>
<p><img src="/2020/10/09/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%9B%9E%E5%BD%92/7.png" style="zoom:80%;"></p>
<ul>
<li>最后我们在$x_1=40,x_2&lt;170$ 出画一条分割线，我们可以继续拓展一个分支。</li>
</ul>
<p><img src="/2020/10/09/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%9B%9E%E5%BD%92/8.png" style="zoom:80%;"></p>
<p>现在，我们分隔好了区域，我们怎么对一个新的数据进行预测呢？</p>
<p>其实很简单，我们把每个区域每一个散点的y值加起来求平均后，再赋值给新的、需要被预测的值。</p>
<p><img src="/2020/10/09/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%9B%9E%E5%BD%92/9.png" style="zoom:80%;"></p>
<p>现在我们已经求出了各个区域中y的平均值，现在来一个点(30,50) ，我们可以看到这个点落在中下区域，这个区域的平均值是 -64.1 那么这个我们预测(30,50) 这一个点的y值就是 -64.1</p>
<p>最后我们补全我们的决策树：</p>
<p><img src="/2020/10/09/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%9B%9E%E5%BD%92/10.png" style="zoom:80%;"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>首先还是进行数据集导入、分割</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">dataset = pd.read_csv(<span class="string">'Position_Salaries.csv'</span>)</span><br><span class="line">X = dataset.iloc[:, <span class="number">1</span>:<span class="number">-1</span>].values</span><br><span class="line">y = dataset.iloc[:, <span class="number">-1</span>].values</span><br></pre></td></tr></table></figure>
<p>然后我们训练决策树模型：</p>
<p>对于决策树模型的参数选择和设置，先不要过于纠结。对所有的机器学习模型有了一个认知和比较之后我们再来谈论参数。在这里我们设置 random_state 参数= 0。这个问题是因为，学习一个最优决策树是一个NP问题。 所以实际应用中，生成决策树是基于启发式算法的，比如贪婪算法，贪婪算法可以在每个节点进行局部最优点求解，但它无法保证返回全局最优解。不论是random forest还是decision tree，贪婪算法会随机且多次抽取<strong>部分</strong>特征和样本，这个随机抽取过程可以通过random_state来决定。让他等于零的意思是让每次建立出来的决策树都是一样的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor</span><br><span class="line">regressor = DecisionTreeRegressor(random_state = <span class="number">0</span>)</span><br><span class="line">regressor.fit(X, y)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/09/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%9B%9E%E5%BD%92/11.png" style="zoom:80%;"></p>
<p>我们可以用训练出来的模型预测新的数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regressor.predict([[<span class="number">6.5</span>]])</span><br></pre></td></tr></table></figure>
<p>打印得到： array([150000.])</p>
<p>如果我们要预测两个数据，我们可以这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regressor.predict([[<span class="number">1</span>],[<span class="number">2</span>]])</span><br></pre></td></tr></table></figure>
<p>我们可以这样理解，6.5经过了层层决策最后落到了一个区域，这个区域只有 Level=6这一个数据，那么这个数据的平均值 150000 就赋值给了6.5</p>
<p>最后进行一个可视化操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">X_grid = np.arange(min(X), max(X), <span class="number">0.01</span>)</span><br><span class="line">X_grid = X_grid.reshape((len(X_grid), <span class="number">1</span>))</span><br><span class="line">plt.scatter(X, y, color = <span class="string">'red'</span>)</span><br><span class="line">plt.plot(X_grid, regressor.predict(X_grid), color = <span class="string">'blue'</span>)</span><br><span class="line">plt.title(<span class="string">'Truth or Bluff (Decision Tree Regression)'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Position level'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Salary'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/09/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%9B%9E%E5%BD%92/12.png" style="zoom:100%;"></p>
<p>我们看到这个模型被训练成随机森林之后，因为数据量不足够，所以回归曲线呈现阶梯状。也就是说在一定范围内的所有的数都会被预测成相同的值。</p>
<h2 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h2><p>我们首先来了解一下 Ensemble Learning (集成学习)的概念。 Ensemble Learning 通俗的来说就是用多种算法或者一种算法运行多次来解决一个问题</p>
<p>那么随机森林的步骤可以概括如下：</p>
<ul>
<li><p>STEP1: Pick at random K data points from the Training set </p>
</li>
<li><p>SETP2: Build the Decision Tree associated to these K data points </p>
<ul>
<li>和决策树不同，决策树将所有的数据拿来建树而随机森林是从中选取K个数据来建树</li>
</ul>
</li>
<li><p>STEP3： Choose the number Ntree of trees you want to build and repeat STEPs 1&amp;2</p>
<ul>
<li>然后我们只要选择要建的树，重复步骤1和2就可以了</li>
</ul>
</li>
<li>STEP4: For a new data point,make each one of your Ntree trees predict the value of Y to for the data point in question,and assign the new data point the average across all of the predicted Y values<ul>
<li>对于预测的新数据，我们将其放到每一棵树里面去，分别对其预测，最后对这些预测值取平均，就得到了最终的预测值</li>
</ul>
</li>
</ul>
<p>这也是随机森林之所以叫做森林的原因了，因为我们创建了很多很多树。和决策树相比，随机森林模型会增加预测的准确性，因为我们对所有的预测值取了一个平均数。  </p>
<p>此外，随机森林相对于决策树更加稳定，因为他是一个集成算法</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>代码和决策树的差不多，但是实际效果要比决策树更好一些</p>
<p>前期准备是一模一样的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">dataset = pd.read_csv(<span class="string">'Position_Salaries.csv'</span>)</span><br><span class="line">X = dataset.iloc[:, <span class="number">1</span>:<span class="number">-1</span>].values</span><br><span class="line">y = dataset.iloc[:, <span class="number">-1</span>].values</span><br></pre></td></tr></table></figure>
<p>然后 我们从 sklearn.ensemble 中导入 RandomForestRegressor 这个类</p>
<p>n_estimators 就代表我要建几棵树</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor</span><br><span class="line">regressor = RandomForestRegressor(n_estimators = <span class="number">10</span>, random_state = <span class="number">0</span>)</span><br><span class="line">regressor.fit(X, y)</span><br></pre></td></tr></table></figure>
<p>最后我们讲建立好的模型贴出，我们可以对比一下随机森林和决策树有哪些不同</p>
<p><img src="/2020/10/09/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%9B%9E%E5%BD%92/13.png" style="zoom:100%;"></p>
<p><img src="/2020/10/09/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%9B%9E%E5%BD%92/12.png" style="zoom:100%;"></p>
<p>明显可以看到随机森林相对于决策树来说更准确，阶梯更多了</p>
<p>我们现在的重点是了解概念和初步时间，像这样一个简单的预测虽然在现实生活中是几乎不可能遇到的，但是能让我们更好的了解一些模型和对应建立模型的步骤。</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/10/07/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E5%9B%9E%E5%BD%92%EF%BC%88SVR%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/10/07/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E5%9B%9E%E5%BD%92%EF%BC%88SVR%EF%BC%89/" itemprop="url">支持向量回归（SVR）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-10-07T18:08:16+08:00">
                2020-10-07
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-10-09T23:14:16+08:00">
                2020-10-09
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="支持向量回归（SVR）"><a href="#支持向量回归（SVR）" class="headerlink" title="支持向量回归（SVR）"></a>支持向量回归（SVR）</h1><p><img src="/2020/10/07/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E5%9B%9E%E5%BD%92%EF%BC%88SVR%EF%BC%89/1.png" style="zoom:80%;"></p>
<p>左图是Linear Regression的 ,右边是svr 的loss function，右图中，$\epsilon-$ Insensitive tube描述的是黄色管道，$\epsilon$ 是管道边界到管道中心的垂直距离。我们定义这个区域内的点<strong>损失为0</strong>，这个区域以外的点的损失是点到区域边界的距离，这些区域外的点（或者有可能边界上的点）就是svr 的support vector。之所以这么称呼是因为这些点决定了我们划定的tube是否是合理的，这些点左右了tube的结构。 所以大致上来说，<strong>svr就是要找一条线，忽略它周围的点，对剩余的点进行回归</strong>。而对于Linear Regression来说，则是对每一个点都进行回归</p>
<p>Linear Regression 的计算公式是 $SUM(y-\hat y )^2 \rightarrow min$ </p>
<p>SVR 的计算公式则比较复杂， $\frac{1}{2}||w||^2+c\sum_{i=1}^{m}(\xi_i+\xi_i^*)\rightarrow min$  </p>
<p>补充资料： <a href="https://core.ac.uk/download/pdf/81523322.pdf" target="_blank" rel="noopener">https://core.ac.uk/download/pdf/81523322.pdf</a> </p>
<p>上面我们看到的是线性的支持向量回归，但是我们在接下来的例子中，却看到训练出来的模型是非线性的，这是因为我们使用了 Radial basis function kernel (<strong>径向基</strong>核函数)</p>
<p>我们可以先看看non-Linear SVR 长什么样</p>
<p><img src="/2020/10/07/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E5%9B%9E%E5%BD%92%EF%BC%88SVR%EF%BC%89/2.png" style="zoom:80%;"></p>
<p>可以看到它们长得还是非常不一样的。要了解non-Linear SVR,还是需要用到为学习过的许多知识</p>
<ul>
<li>Section on SVM:<ul>
<li>SVM Intuition</li>
</ul>
</li>
<li>Section on Kernel SVM:<ul>
<li>Kernel SVM Intuition</li>
<li>Mapping to a higher dimension</li>
<li>The kernel Trick</li>
<li>Types of Kernel Functions</li>
<li>Non-Linear Kernel SVR</li>
</ul>
</li>
</ul>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>这次我们使用的仍然是员工阶级和薪资的数据集。我们在进行试验的时候会遇到 Feature scaling (特征缩放) </p>
<p>在运用一些机器学习算法的时候不可避免地要对数据进行特征缩放（feature scaling），特征缩放可以使机器学习算法工作的更好。  如果某一列的值与其他列相比非常高，则具有更高值的列的影响将比其他低值列的影响高得多。 高强度的特征比低强度的特征重得多，即使它们在确定输出中更为关键。 因此，预测可能无法给出预期的结果，并且可能无法满足业务用例。</p>
<p>总而言之，功能缩放是必需的，因为：</p>
<ol>
<li>回归系数直接受特征范围的影响</li>
<li>具有较高比例的功能比具有较低比例的功能更重要</li>
<li>如果我们具有缩放值，则可以轻松实现渐变下降</li>
<li>如果按比例缩放，某些算法将减少执行时间。</li>
<li>一些算法基于欧几里得距离，欧几里得距离对特征尺度非常敏感。</li>
</ol>
<p>对于SVR来说，这是一个关于因变量的隐式函数，因此我们需要将数据进行特征缩放，来将员工的年龄和他的收入放到一个scale下进行建模。</p>
<p>对于简单线性、多项式线性回归，我们不需要利用特征缩放，因为可以找到能将高值和低值特征对应起来的系数。但是对于其他模型来说，在自变量x和应变量y之间他是找不到这样一个系数来对应的。这时候我们就会使用特征缩放。</p>
<p>另外，概率模型（树形模型）不需要归一化，因为它们不关心变量的值，而是关心变量的分布和变量之间的条件概率，如决策树、RF。而像Adaboost、SVM、LR、Knn、KMeans之类的最优化问题就需要归一化。</p>
<ul>
<li>当使用dummy variable的时候，没有必要再对其使用特征缩放了，因为本来就两个值0和1</li>
<li>当因变量的值是0或者1的时候，也没有必要对其使用特征缩放了</li>
</ul>
<h3 id="Processing-the-dataset"><a href="#Processing-the-dataset" class="headerlink" title="Processing the dataset"></a>Processing the dataset</h3><p>那么我们现在来看数据集</p>
<p><img src="/2020/10/07/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E5%9B%9E%E5%BD%92%EF%BC%88SVR%EF%BC%89/3.png" style="zoom:100%;"></p>
<p>因变量从1到10，Salary从4500-1000000，它们之间的差距实在是太大了。这还会导致一些数据被误认成偏离值而被模型忽略。如果不进行特征缩放的话，那么SVR将完全不会起作用。所以我们要把自变量和因变量缩放到一个唯独下进行建模。</p>
<p>在特征缩放之前，我们首先将自变量和因变量分离：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataset = pd.read_csv(<span class="string">'Position_Salaries.csv'</span>)</span><br><span class="line">X = dataset.iloc[:, <span class="number">1</span>:<span class="number">-1</span>].values</span><br><span class="line">y = dataset.iloc[:, <span class="number">-1</span>].values</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/07/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E5%9B%9E%E5%BD%92%EF%BC%88SVR%EF%BC%89/4.png" style="zoom:80%;"></p>
<p>但是现在我们看到数组y实际上是一个一维数组，我们需要将其变成二维数组。这是因为 StandardScaler在进行特征缩放的时候只接收二维数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = y.reshape(len(y),<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>运用reshape函数，可以进行这样的转换，其中第一个参数是行数，第二个参数是列数。</p>
<p><img src="/2020/10/07/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E5%9B%9E%E5%BD%92%EF%BC%88SVR%EF%BC%89/5.png" style="zoom:120%;"></p>
<h3 id="Feature-Scaling"><a href="#Feature-Scaling" class="headerlink" title="Feature Scaling"></a>Feature Scaling</h3><p>现在我们进行特征缩放</p>
<p>StandardScaler原理: 去均值和方差归一化。且是针对每一个特征维度来做的，而不是针对样本。 </p>
<p>标准差标准化（standardScale）使得经过处理的数据符合标准正态分布，即均值为0，标准差为1，其转化函数为：$x^* = \frac{x-\mu}{\sigma}$ ,其中 $\mu$ 为所有样本数据的均值， $\sigma$ 为所有样本数据的标准差</p>
<p>我们要注意，自变量和应变量应该选择不同的 StandardScaler，这是因为每列数据的均值和标准差都是不一样的</p>
<p><img src="/2020/10/07/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E5%9B%9E%E5%BD%92%EF%BC%88SVR%EF%BC%89/6.png" style="zoom:120%;"></p>
<h3 id="Training-the-SVR-model-on-the-whole-dataset"><a href="#Training-the-SVR-model-on-the-whole-dataset" class="headerlink" title="Training the SVR model on the whole dataset"></a>Training the SVR model on the whole dataset</h3><p>在训练SVR模型之前我们要了解核函数的概念。</p>
<p>对于<strong>线性不可分</strong>的数据集，可以利用<strong>核函数（kernel）</strong>将数据转换成易于分类器理解的形式。</p>
<p>如下图，如果在x轴和y轴构成的坐标系中插入直线进行分类的话， 不能得到理想的结果，或许我们可以对圆中的数据进行某种形式的转换，从而得到某些新的变量来表示数据。在这种表示情况下，我们就更容易得到大于0或者小于0的测试结果。在这个例子中，我们将数据从一个特征空间转换到另一个特征空间，在新的空间下，我们可以很容易利用已有的工具对数据进行处理，将这个过程称之为<strong>从一个特征空间到另一个特征空间的映射</strong>。在通常情况下，这种映射会<strong>将低维特征空间映射到高维空间</strong>。比如将二维空间映射到一个合适的三维空间，那么就能找到一个合适的划分超平面来分离。如果原始空间是有限维，即属性数有限，那么一定存在一个高维特征空间使样本可分。这种从某个特征空间到另一个特征空间的映射是通过核函数来实现的。</p>
<p><a href="https://www.jianshu.com/p/95e56d5126fd" target="_blank" rel="noopener">https://www.jianshu.com/p/95e56d5126fd</a></p>
<p><img src="/2020/10/07/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E5%9B%9E%E5%BD%92%EF%BC%88SVR%EF%BC%89/7.png" style="zoom:120%;"></p>
<p>径向基核函数是SVM中常用的一个<strong>核函数</strong>。<strong>径向基函数</strong>是一个<strong>采用向量作为自变量的函数</strong>，能够<strong>基于向量距离运算</strong>输出一个<strong>标量</strong>。</p>
<p>在python当中，我们从 svm中导入SVR并将其kernel参数设置为 rbf，然后再对X，y进行训练</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVR</span><br><span class="line">regressor = SVR(kernel= <span class="string">'rbf'</span>)</span><br><span class="line">regressor.fit(X,y)</span><br></pre></td></tr></table></figure>
<h3 id="Predicting-a-new-result"><a href="#Predicting-a-new-result" class="headerlink" title="Predicting a new result"></a>Predicting a new result</h3><p>现在我们通过训练好的模型来进行预测。注意了，我们传入的数据是特征放缩后的数据，我们预测出来的是特征放缩之后的结果，我们还需要用放缩尺将其还原成原来的数据</p>
<p>比如说我们要预测6.5级的员工薪水，传入一个二维数组(尽管只有一个数)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regressor.predict(sc_X.transform([[<span class="number">6.5</span>]]))</span><br></pre></td></tr></table></figure>
<p>这样返回的是在sc_y 标尺下的 薪水，打印出来得到：array([0.01150915])</p>
<p>接下来我们要做的就是将这个预测出来的数据还原回去,我们可以用 inverse_transform 来进行还原。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc_y.inverse_transform(regressor.predict(sc_X.transform([[<span class="number">6.5</span>]])))</span><br></pre></td></tr></table></figure>
<p>打印出来的数据是： array([170370.0204065])</p>
<h3 id="Visualizing-the-SVR-results"><a href="#Visualizing-the-SVR-results" class="headerlink" title="Visualizing the SVR results"></a>Visualizing the SVR results</h3><p>现在我们将SVR模型预测的结果画出来。</p>
<p>注意，这时候的X,y 是缩放后的，我们需要用 inverse_transform 来将其还原。因为x已经是二维数组了，我们就直接 regressor.predict(x) 即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(sc_X.inverse_transform(X), sc_y.inverse_transform(y), color = <span class="string">'red'</span>)</span><br><span class="line">plt.plot(sc_X.inverse_transform(X), sc_y.inverse_transform(regressor.predict(X)), color = <span class="string">'blue'</span>)</span><br><span class="line">plt.title(<span class="string">'Truth or Bluff (SVR)'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Position level'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Salary'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/07/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E5%9B%9E%E5%BD%92%EF%BC%88SVR%EF%BC%89/8.png"></p>
<h4 id="for-higher-resolution-and-smoother-curve"><a href="#for-higher-resolution-and-smoother-curve" class="headerlink" title="for higher resolution and smoother curve"></a>for higher resolution and smoother curve</h4><p>我们将预测出来的曲线变得更加光滑：</p>
<p>原理就是将1-10 从原来的间隔1到现在的间隔0.1 ，然后再将其变成一个新的二维数组进行预测画图。这样曲线就会变得更加光滑。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">X_grid = np.arange(min(sc_X.inverse_transform(X)), max(sc_X.inverse_transform(X)), <span class="number">0.1</span>)</span><br><span class="line">X_grid = X_grid.reshape((len(X_grid), <span class="number">1</span>))</span><br><span class="line">plt.scatter(sc_X.inverse_transform(X), sc_y.inverse_transform(y), color = <span class="string">'red'</span>)</span><br><span class="line">plt.plot(X_grid,</span><br><span class="line">         sc_y.inverse_transform(regressor.predict(sc_X.transform(X_grid))), color = <span class="string">'blue'</span>)</span><br><span class="line">plt.title(<span class="string">'Truth or Bluff (SVR)'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Position level'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Salary'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/07/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E5%9B%9E%E5%BD%92%EF%BC%88SVR%EF%BC%89/9.png"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/09/30/git%E5%9F%BA%E7%A1%803/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/30/git%E5%9F%BA%E7%A1%803/" itemprop="url">git基础3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-30T16:56:17+08:00">
                2020-09-30
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-07-05T20:01:46+08:00">
                2022-07-05
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="git-基础3"><a href="#git-基础3" class="headerlink" title="git 基础3"></a>git 基础3</h1><h2 id="Collaboration-合作"><a href="#Collaboration-合作" class="headerlink" title="Collaboration 合作"></a>Collaboration 合作</h2><ul>
<li>Collaboration workflows</li>
<li>Pushing,fetching and pulling</li>
<li>Pull requests,issues and milestones</li>
<li>Contributing to open-source projects</li>
</ul>
<h3 id="Workflows"><a href="#Workflows" class="headerlink" title="Workflows"></a>Workflows</h3><h4 id="Centralized-Workflow"><a href="#Centralized-Workflow" class="headerlink" title="Centralized Workflow"></a>Centralized Workflow</h4><p>示意图如下：</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/1.png" style="zoom:80%;"></p>
<p>当John想要给Amy传代码的时候，他首先会将文件push到云上的repository，Amy看见之后，会从云上拉去John的代码到本地进行浏览或者修改。如果John和Amy的代码冲突了，那么Amy经过修改之后再将代码Push到云上。在大多数小团队中，都用这种工作流。</p>
<h4 id="Intergration-Manager"><a href="#Intergration-Manager" class="headerlink" title="Intergration-Manager"></a>Intergration-Manager</h4><p>对于一些开源项目，有很多contributors，他们的代码并不是完全安全的，所以它们递交的代码并不能直接放到云里。</p>
<p>当有一个contributor想要commit的时候，会从云上的repository中Fork一个新的Repository，然后再从这个新的Repository 中克隆代码。当修改完成递交后，也是递交到这个新的Repository</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/2.png" style="zoom:80%;"></p>
<p>然后，Contributor会给Maintainer发一个Pull request.当Maintainer收到请求之后，会从新的Repository中拉取Contributor修改后的代码，检查是合格。如果合格，他们就会将代码Push到原本的云端上去</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/3.png" style="zoom:80%;"></p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/25.jpg" style="zoom:80%;"></p>
<h3 id="Adding-Collaborators"><a href="#Adding-Collaborators" class="headerlink" title="Adding Collaborators"></a>Adding Collaborators</h3><p>自我们创建了新的Repository 之后，只有我一个人拥有push的权限。我们可以点击绿色的 Invite a collaborator 来给我们伙伴push的权限。</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/4.png" style="zoom:80%;"></p>
<h3 id="Fetching"><a href="#Fetching" class="headerlink" title="Fetching"></a>Fetching</h3><p>因为我们不能时刻和云上的repository保持同步，那么当云上的repository出现了新的commit的时候，本地暂时还没有，我们可以用 <code>git fetch</code> 命令将本地repository与云上的repository保持同步。 </p>
<p>但是当我们同步之后，我们本地的状态是这样的：</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/5.png" style="zoom:80%;"></p>
<p>也就是说现在有两个Master指针，一个是云上的Master指针。我们可以用 <code>git merge origin/master</code> 来将两个指针合并。</p>
<p>我们 <code>git fetch</code> 之后，发现 本地的master和origin/master指向的commit是不同的。</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/6.png" style="zoom:80%;"></p>
<p>然后我们用 <code>git merge origin/master</code> 将两个master指针合并</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/7.png" style="zoom:80%;"></p>
<p>结果如下</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/8.png" style="zoom:80%;"></p>
<h3 id="Pulling"><a href="#Pulling" class="headerlink" title="Pulling"></a>Pulling</h3><ul>
<li><strong>Pull = fetch + merge </strong></li>
</ul>
<p>git pull 命令，默认会使用 Three-Way Merge, 但是我们可以通过 git pull —rebase 把merge形式换成rebase</p>
<p>如果本地有一个commit B,云上有一个commit C，那么运行git pull 之后，在本地的 A之后又会跟上commit C，这时候出现了分支。然后再进行Three-Way Merge合并到一起。</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/9.png" style="zoom:80%;"></p>
<ul>
<li>git pull -rebase</li>
</ul>
<p>git pull -rebase 就是<strong>将 本地的MASTER移动到云端 origin/MASTER 之后</strong></p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/10.png" style="zoom:80%;"></p>
<p>我们在github上对readme文件进行一下修改，然后在本地使用rebase操作</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/11.png" style="zoom:140%;"></p>
<p>直接 <code>git pull</code> 之后，我们得到的 log 信息如下：</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/12.png" style="zoom:120%;"></p>
<p><code>git pull --rebase</code> 之后，log 信息如下：</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/13.png" style="zoom:140%;"></p>
<h3 id="Pushing"><a href="#Pushing" class="headerlink" title="Pushing"></a>Pushing</h3><p>一般我们利用 <code>git push</code> 就可以将本地的commit推送到云端去。但是遇到这种情况该怎么办？</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/14.png" style="zoom:100%;"></p>
<p>这里在确定之前，千万别用 <code>git push -f</code> 因为这个命令会让本地的 C commit 覆盖掉云端上的 D commit，这可能会酿成大祸。</p>
<p>所以遇到本地和云端当前的状态不一样的时候，最好的方法就是先将云端的D commit pull下来，和本地的C commit 合并，然后再用 <code>git push</code> 推送上去，最后的结果如下图：</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/15.png" style="zoom:100%;"></p>
<h3 id="Sharing-Tags"><a href="#Sharing-Tags" class="headerlink" title="Sharing Tags"></a>Sharing Tags</h3><p>在本地创建一个 tag  <code>git tag 1.0</code> </p>
<p>在本地删除一个tag <code>git tag -d v1.0</code></p>
<p>将tag push到云端去：<code>git push origin v1.0</code></p>
<p>将tag 从云端中删除： <code>git push origin --delete v1.0</code> </p>
<h3 id="Releases"><a href="#Releases" class="headerlink" title="Releases"></a>Releases</h3><p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/16.png" style="zoom:100%;"></p>
<p>如果这个版本只是先行版、测试版，可以在下面勾选 This is a pre-release </p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/17.png" style="zoom:100%;"></p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/18.png" style="zoom:100%;"></p>
<p>Release 不是git的特性，而是github特有的，比tag的层级更高</p>
<h3 id="Sharing-Branches"><a href="#Sharing-Branches" class="headerlink" title="Sharing Branches"></a>Sharing Branches</h3><p>如果我们要和其他队友在分支上进行合作，那么就要对分支进行分享。</p>
<p>首先我们新建一个分支：<code>git switch -C feature/change-password</code></p>
<p>然后我么用 <code>git push -u origin feature/change-password</code> 将这个分支push到云上。</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/20.png" style="zoom:100%;"></p>
<p>我们可以用 <code>git push -d origin feature/change-password</code> 将分支删除。</p>
<p>使用 <code>git -vv</code> 就能够看到本地分支跟踪的远程分支。</p>
<p>左边的是本地的分支，右边蓝色的的是远程的分支。在没有push上去之前，我们发现 本地有 feature/change-password 分支但远程没有</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/21.png" style="zoom:100%;"></p>
<p>在git push之后我们发现本地分支追踪到了远程的分支。</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/22.png" style="zoom:100%;"></p>
<p>使用 <code>git branch -r</code> 能看到远程所有的分支：</p>
<p>在没有push上去之间，云端只有HEAD和main</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/23.png" style="zoom:110%;"></p>
<p>在push 上去之后，云端有了一个新的 feature/change-password</p>
<p><img src="/2020/09/30/git%E5%9F%BA%E7%A1%803/24.png" style="zoom:100%;"></p>
<h3 id="Collaboration-Workflow"><a href="#Collaboration-Workflow" class="headerlink" title="Collaboration Workflow"></a>Collaboration Workflow</h3><h3 id="Pull-Requests"><a href="#Pull-Requests" class="headerlink" title="Pull Requests"></a>Pull Requests</h3><h3 id="Resolving-Conflicts"><a href="#Resolving-Conflicts" class="headerlink" title="Resolving Conflicts"></a>Resolving Conflicts</h3><h3 id="Issues"><a href="#Issues" class="headerlink" title="Issues"></a>Issues</h3><h3 id="Labels"><a href="#Labels" class="headerlink" title="Labels"></a>Labels</h3><h3 id="Milestones"><a href="#Milestones" class="headerlink" title="Milestones"></a>Milestones</h3><h3 id="Contributing-to-Open-source-Projects"><a href="#Contributing-to-Open-source-Projects" class="headerlink" title="Contributing to Open-source Projects"></a>Contributing to Open-source Projects</h3><h3 id="Keeping-a-Forked-Repository-Up-to-Date"><a href="#Keeping-a-Forked-Repository-Up-to-Date" class="headerlink" title="Keeping a Forked Repository Up to Date"></a>Keeping a Forked Repository Up to Date</h3><h3 id="Collaboration-Using-VSCode"><a href="#Collaboration-Using-VSCode" class="headerlink" title="Collaboration Using VSCode"></a>Collaboration Using VSCode</h3><h3 id="Collaboration-Using-GitKraken"><a href="#Collaboration-Using-GitKraken" class="headerlink" title="Collaboration Using GitKraken"></a>Collaboration Using GitKraken</h3><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><h3 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h3><h2 id="Rewriting-History"><a href="#Rewriting-History" class="headerlink" title="Rewriting History"></a>Rewriting History</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><h3 id="Why-Rewrite-History"><a href="#Why-Rewrite-History" class="headerlink" title="Why Rewrite History"></a>Why Rewrite History</h3><h3 id="The-Golden-Rule-of-Rewriting-History"><a href="#The-Golden-Rule-of-Rewriting-History" class="headerlink" title="The Golden Rule of Rewriting History"></a>The Golden Rule of Rewriting History</h3><h3 id="Example-of-a-Bad-History"><a href="#Example-of-a-Bad-History" class="headerlink" title="Example of a Bad History"></a>Example of a Bad History</h3><h3 id="Undoing-Commits"><a href="#Undoing-Commits" class="headerlink" title="Undoing Commits"></a>Undoing Commits</h3><h3 id="Reverting-Commits"><a href="#Reverting-Commits" class="headerlink" title="Reverting Commits"></a>Reverting Commits</h3><h3 id="Recovering-Lost-Commits"><a href="#Recovering-Lost-Commits" class="headerlink" title="Recovering Lost Commits"></a>Recovering Lost Commits</h3><h3 id="Amending-the-Last-Commit"><a href="#Amending-the-Last-Commit" class="headerlink" title="Amending the Last Commit"></a>Amending the Last Commit</h3><h3 id="Amending-an-Earlier-Commit"><a href="#Amending-an-Earlier-Commit" class="headerlink" title="Amending an Earlier Commit"></a>Amending an Earlier Commit</h3><h3 id="Dropping-Commits"><a href="#Dropping-Commits" class="headerlink" title="Dropping Commits"></a>Dropping Commits</h3><h3 id="Rewording-Commit-Messages"><a href="#Rewording-Commit-Messages" class="headerlink" title="Rewording Commit Messages"></a>Rewording Commit Messages</h3><h3 id="Reordering-Commits"><a href="#Reordering-Commits" class="headerlink" title="Reordering Commits"></a>Reordering Commits</h3><h3 id="Squashing-Commits"><a href="#Squashing-Commits" class="headerlink" title="Squashing Commits"></a>Squashing Commits</h3><h3 id="Splitting-a-Commit"><a href="#Splitting-a-Commit" class="headerlink" title="Splitting a Commit"></a>Splitting a Commit</h3><h3 id="Rewriting-History-Using-GitKraken"><a href="#Rewriting-History-Using-GitKraken" class="headerlink" title="Rewriting History Using GitKraken"></a>Rewriting History Using GitKraken</h3><h3 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h3>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/18/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><span class="page-number current">19</span><a class="page-number" href="/page/20/">20</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/20/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/%5Bobject%20Object%5D"
                alt="Jason" />
            
              <p class="site-author-name" itemprop="name">Jason</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20fa%20fa-archive">
              
                  <span class="site-state-item-count">435</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">61</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="true"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
 <!--
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>







-->
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>




















  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v="></script>

  <script type="text/javascript" src="/js/src/motion.js?v="></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v="></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
