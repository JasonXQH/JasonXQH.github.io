<!DOCTYPE html>
<html lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jasonxqh.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jason‘s Blog">
<meta property="og:url" content="https://jasonxqh.github.io/page/19/index.html">
<meta property="og:site_name" content="Jason‘s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jasonxqh.github.io/page/19/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jason‘s Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jason‘s Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/10/25/Hierarchical-Clustering/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/25/Hierarchical-Clustering/" class="post-title-link" itemprop="url">Hierarchical_Clustering</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-25 12:42:25" itemprop="dateCreated datePublished" datetime="2020-10-25T12:42:25+08:00">2020-10-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-02 23:14:14" itemprop="dateModified" datetime="2020-11-02T23:14:14+08:00">2020-11-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Hierarchical-Clustering-层次聚类"><a href="#Hierarchical-Clustering-层次聚类" class="headerlink" title="Hierarchical Clustering 层次聚类"></a>Hierarchical Clustering 层次聚类</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>层次聚类的功能和K-Means 一样，也是将数据点进行聚类。有时候它们的结果是非常接近甚至完全相同的。</p>
<p><img src="/2020/10/25/Hierarchical-Clustering/1.png" style="zoom:80%;"></p>
<p>层次聚类分为： Agglomerative 和Divisive 两种。这篇博客要着重介绍的是 Agglomerative Hierarchical  Clustering</p>
<p>一下是层次聚类的步骤:</p>
<ul>
<li>Step1: Make each data point a single-point cluster :初始情况下，包含N个数据点的数据集就有N个类</li>
<li>Step2: Take the two closest data points and make them one cluster : 将距离最近的两个数据点合并成一个类，现在只有N-1个类了</li>
<li>Step3: Take the two closest clusters and make them one cluster :将两个距离最近的类合并成一个类，现在只有N-2个类了</li>
<li>Step4: 重复步骤3.直到只剩下一个类位置，得到最终聚类成果</li>
</ul>
<p>现在很重要的一点是怎么来计算 cluster之间的距离？</p>
<p>在点和点之间我们可以用欧几里得距离，在两个类之间我们有4种不同的距离可以选择：</p>
<p><strong>第一种：选择两个类中最近的点的距离</strong></p>
<p><img src="/2020/10/25/Hierarchical-Clustering/3.png"></p>
<p><strong>第二种：选择两个类中最远的点的距离</strong></p>
<p><img src="/2020/10/25/Hierarchical-Clustering/4.png"></p>
<p><strong>第三种：计算两个类中所有的点之间距离后取平均数</strong></p>
<p><strong>第四种： 先计算两个类的中心点，然后求中心点之间的距离：</strong></p>
<p><img src="/2020/10/25/Hierarchical-Clustering/5.png"></p>
<p>具体选择哪一种需要根据具体情况进行分析</p>
<p>现在我们对一个具体的数据集进行简单的层级聚类：</p>
<p><img src="/2020/10/25/Hierarchical-Clustering/6.png"></p>
<p>第一步，我们要将6个数据点分成6类：</p>
<p><img src="/2020/10/25/Hierarchical-Clustering/7.png"></p>
<p>第二步，选择两个最近的点，合并成一个类，现在还有5个类：</p>
<p><img src="/2020/10/25/Hierarchical-Clustering/8.png"></p>
<p>第三步，将两个最近的类合并成一个类，现在还有4 个类:</p>
<p><img src="/2020/10/25/Hierarchical-Clustering/9.png"></p>
<p>第四步，重复第三步直到只剩下一个类为止：</p>
<p><img src="/2020/10/25/Hierarchical-Clustering/10.png"></p>
<p><img src="/2020/10/25/Hierarchical-Clustering/11.png"></p>
<h2 id="Dendrograms-树枝型结构联系图"><a href="#Dendrograms-树枝型结构联系图" class="headerlink" title="Dendrograms 树枝型结构联系图"></a>Dendrograms 树枝型结构联系图</h2><p>我们可以用 树枝型结构联系图来将聚类过程形象的表示出来。</p>
<p>如下图，左边是数据点的分布，右边是树枝型结构联系图。右图的x轴是离散的类，y轴是类与类之间的距离。</p>
<p><img src="/2020/10/25/Hierarchical-Clustering/12.png"></p>
<p>比如说首先是 P2和P3 是先聚合的，那么首先在P2和P3之间建立联系：</p>
<p><img src="/2020/10/25/Hierarchical-Clustering/13.png"></p>
<p>其次是在P5和P6之间进行联系，在图上可以这样反应：</p>
<p><img src="/2020/10/25/Hierarchical-Clustering/14.png"></p>
<p>那么我们怎么利用这个 Dengrograms？我们可以划分一个距离的最大值，高于这个距离的聚类就舍弃，低于这个距离的聚类就保留：</p>
<p><img src="/2020/10/25/Hierarchical-Clustering/15.png"></p>
<p>比如上图，我在1.75的地方画了一根线，那么就说明我们不要最终的那一类了，但是我们要保留1.75以下聚合的那两类。</p>
<p><strong>简单来说，只要看看这根线穿过了多少竖线，那么就说明分成几类。</strong>比如说下面，穿过了4根竖线，那么就说明分成4类</p>
<p><img src="/2020/10/25/Hierarchical-Clustering/16.png"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>我们用的数据集和K-Means数据集一样</p>
<h3 id="Importing-the-libraries"><a href="#Importing-the-libraries" class="headerlink" title="Importing the libraries"></a>Importing the libraries</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>
<h3 id="Importing-the-dataset"><a href="#Importing-the-dataset" class="headerlink" title="Importing the dataset"></a>Importing the dataset</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataset = pd.read_csv(<span class="string">'Mall_Customers.csv'</span>)</span><br><span class="line">X = dataset.iloc[:, [<span class="number">3</span>, <span class="number">4</span>]].values</span><br></pre></td></tr></table></figure>
<h3 id="Using-the-dendrogram-to-find-the-optimal-number-of-clusters"><a href="#Using-the-dendrogram-to-find-the-optimal-number-of-clusters" class="headerlink" title="Using the dendrogram to find the optimal number of clusters"></a>Using the dendrogram to find the optimal number of clusters</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scipy.cluster.hierarchy <span class="keyword">as</span> sch</span><br><span class="line">dendrogram = sch.dendrogram(sch.linkage(X, method = <span class="string">'ward'</span>))</span><br><span class="line">plt.title(<span class="string">'Dendrogram'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Customers'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Euclidean distances'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/25/Hierarchical-Clustering/17.png"></p>
<p>根据上图，我们可以看出选择3-5个 cluster是比较合适的</p>
<h3 id="Training-the-Hierarchical-Clustering-model-on-the-dataset"><a href="#Training-the-Hierarchical-Clustering-model-on-the-dataset" class="headerlink" title="Training the Hierarchical Clustering model on the dataset"></a>Training the Hierarchical Clustering model on the dataset</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> AgglomerativeClustering</span><br><span class="line">hc = AgglomerativeClustering(n_clusters = <span class="number">5</span>, </span><br><span class="line">							affinity = <span class="string">'euclidean'</span>,</span><br><span class="line">                            linkage = <span class="string">'ward'</span>)</span><br><span class="line">y_hc = hc.fit_predict(X)</span><br></pre></td></tr></table></figure>
<p>n_clusters 代表话分类的个数</p>
<p>affinity 是以什么关系来聚合，这里选的是欧氏距离</p>
<p>linkage 是指定的算法计算生成聚类树，有好几种取值方法，推荐使用 Ward</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字符串</th>
<th>含  义</th>
</tr>
</thead>
<tbody>
<tr>
<td>single</td>
<td>最短距离（缺省）</td>
</tr>
<tr>
<td>complete</td>
<td>最大距离</td>
</tr>
<tr>
<td>average</td>
<td>平均距离</td>
</tr>
<tr>
<td>centroid</td>
<td>重心距离</td>
</tr>
<tr>
<td>ward</td>
<td>离差平方和方法（Ward方法）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Visualising-the-clusters"><a href="#Visualising-the-clusters" class="headerlink" title="Visualising the clusters"></a>Visualising the clusters</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(X[y_hc == <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">			X[y_hc == <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">            s = <span class="number">100</span>, </span><br><span class="line">            c = <span class="string">'red'</span>, </span><br><span class="line">            label = <span class="string">'Cluster 1'</span>)</span><br><span class="line">plt.scatter(X[y_hc == <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">			X[y_hc == <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">            s = <span class="number">100</span>, c = <span class="string">'blue'</span>,</span><br><span class="line">            label = <span class="string">'Cluster 2'</span>)</span><br><span class="line">plt.scatter(X[y_hc == <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">			X[y_hc == <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">            s = <span class="number">100</span>, </span><br><span class="line">            c = <span class="string">'green'</span>,</span><br><span class="line">            label = <span class="string">'Cluster 3'</span>)</span><br><span class="line">plt.scatter(X[y_hc == <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line">			X[y_hc == <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">            s = <span class="number">100</span>,</span><br><span class="line">            c = <span class="string">'cyan'</span>,</span><br><span class="line">            label = <span class="string">'Cluster 4'</span>)</span><br><span class="line">plt.scatter(X[y_hc == <span class="number">4</span>, <span class="number">0</span>],</span><br><span class="line">			X[y_hc == <span class="number">4</span>, <span class="number">1</span>],</span><br><span class="line">            s = <span class="number">100</span>, </span><br><span class="line">            c = <span class="string">'magenta'</span>, </span><br><span class="line">            label = <span class="string">'Cluster 5'</span>)</span><br><span class="line">plt.title(<span class="string">'Clusters of customers'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Annual Income (k$)'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Spending Score (1-100)'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/25/Hierarchical-Clustering/18.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/10/22/K-Means%E8%81%9A%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/22/K-Means%E8%81%9A%E7%B1%BB/" class="post-title-link" itemprop="url">K-Means聚类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-10-22 19:23:59 / Modified: 22:30:34" itemprop="dateCreated datePublished" datetime="2020-10-22T19:23:59+08:00">2020-10-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="K-Means聚类"><a href="#K-Means聚类" class="headerlink" title="K-Means聚类"></a>K-Means聚类</h1><p>首先我们要来看聚类(clustering) 和 分类(classification) 的区别：</p>
<p>参考博客： <a href="https://blog.csdn.net/gdp12315_gu/article/details/49777797" target="_blank" rel="noopener">https://blog.csdn.net/gdp12315_gu/article/details/49777797</a></p>
<p><a href="https://www.jianshu.com/p/1e7ddfddf14a" target="_blank" rel="noopener">https://www.jianshu.com/p/1e7ddfddf14a</a></p>
<h4 id="聚类："><a href="#聚类：" class="headerlink" title="聚类："></a>聚类：</h4><p><strong>将</strong>物理或抽象对象的<strong>集合分成</strong>由类似的对象组成的<strong>多个类</strong>的过程被称为聚类。聚类分析的一般做法是，先确定聚类统计量，然后利用统计量对样品或者变量进行聚类。对N个样品进行聚类的方法称为Q型聚类，常用的统计量称为“距离”；对于m个变量进行聚类的方法称为R型聚类，常用的统计量称为“相似系数”。       </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Method name</th>
<th>Parameters</th>
<th>Scalability</th>
<th>Use case</th>
<th>Geometry (metric used)</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://scikit-learn.org/stable/modules/clustering.html#k-means" target="_blank" rel="noopener">K-Means</a></td>
<td>number of clusters</td>
<td>Very large <code>n_samples</code>, medium <code>n_clusters</code> with <a href="https://scikit-learn.org/stable/modules/clustering.html#mini-batch-kmeans" target="_blank" rel="noopener">MiniBatch code</a></td>
<td>General-purpose, even cluster size, flat geometry, not too many clusters</td>
<td>Distances between points</td>
</tr>
<tr>
<td><a href="https://scikit-learn.org/stable/modules/clustering.html#affinity-propagation" target="_blank" rel="noopener">Affinity propagation</a></td>
<td>damping, sample preference</td>
<td>Not scalable with n_samples</td>
<td>Many clusters, uneven cluster size, non-flat geometry</td>
<td>Graph distance (e.g. nearest-neighbor graph)</td>
</tr>
<tr>
<td><a href="https://scikit-learn.org/stable/modules/clustering.html#mean-shift" target="_blank" rel="noopener">Mean-shift</a></td>
<td>bandwidth</td>
<td>Not scalable with <code>n_samples</code></td>
<td>Many clusters, uneven cluster size, non-flat geometry</td>
<td>Distances between points</td>
</tr>
<tr>
<td><a href="https://scikit-learn.org/stable/modules/clustering.html#spectral-clustering" target="_blank" rel="noopener">Spectral clustering</a></td>
<td>number of clusters</td>
<td>Medium <code>n_samples</code>, small <code>n_clusters</code></td>
<td>Few clusters, even cluster size, non-flat geometry</td>
<td>Graph distance (e.g. nearest-neighbor graph)</td>
</tr>
<tr>
<td><a href="https://scikit-learn.org/stable/modules/clustering.html#hierarchical-clustering" target="_blank" rel="noopener">Ward hierarchical clustering</a></td>
<td>number of clusters or distance threshold</td>
<td>Large <code>n_samples</code> and <code>n_clusters</code></td>
<td>Many clusters, possibly connectivity constraints</td>
<td>Distances between points</td>
</tr>
<tr>
<td><a href="https://scikit-learn.org/stable/modules/clustering.html#hierarchical-clustering" target="_blank" rel="noopener">Agglomerative clustering</a></td>
<td>number of clusters or distance threshold, linkage type, distance</td>
<td>Large <code>n_samples</code> and <code>n_clusters</code></td>
<td>Many clusters, possibly connectivity constraints, non Euclidean distances</td>
<td>Any pairwise distance</td>
</tr>
<tr>
<td><a href="https://scikit-learn.org/stable/modules/clustering.html#dbscan" target="_blank" rel="noopener">DBSCAN</a></td>
<td>neighborhood size</td>
<td>Very large <code>n_samples</code>, medium <code>n_clusters</code></td>
<td>Non-flat geometry, uneven cluster sizes</td>
<td>Distances between nearest points</td>
</tr>
<tr>
<td><a href="https://scikit-learn.org/stable/modules/clustering.html#optics" target="_blank" rel="noopener">OPTICS</a></td>
<td>minimum cluster membership</td>
<td>Very large <code>n_samples</code>, large <code>n_clusters</code></td>
<td>Non-flat geometry, uneven cluster sizes, variable cluster density</td>
<td>Distances between points</td>
</tr>
<tr>
<td><a href="https://scikit-learn.org/stable/modules/mixture.html#mixture" target="_blank" rel="noopener">Gaussian mixtures</a></td>
<td>many</td>
<td>Not scalable</td>
<td>Flat geometry, good for density estimation</td>
<td>Mahalanobis distances to  centers</td>
</tr>
<tr>
<td><a href="https://scikit-learn.org/stable/modules/clustering.html#birch" target="_blank" rel="noopener">Birch</a></td>
<td>branching factor, threshold, optional global clusterer.</td>
<td>Large <code>n_clusters</code> and <code>n_samples</code></td>
<td>Large dataset, outlier removal, data reduction.</td>
<td>Euclidean distance between points</td>
</tr>
</tbody>
</table>
</div>
<h4 id="分类（Classification）："><a href="#分类（Classification）：" class="headerlink" title="分类（Classification）："></a>分类（Classification）：</h4><p>在已有分类标准下，对新数据进行划分，分类。</p>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>假设有一批人的年龄的数据，大致知道其中有一堆少年儿童，一堆青年人，一堆老年人。</p>
<p><strong>聚类</strong>就是自动发现这三堆数据，并把相似的数据聚合到同一堆中。所以对于这个例子，如果要聚成3堆的话，那么输入就是一堆年龄数据，注意，此时的年龄数据并不带有类标号，也就是说我只知道里面大致有三堆人，至于谁是哪一堆，现在是不知道的，而输出就是每个数据所属的类标号，聚类完成之后，就知道谁和谁是一堆了。</p>
<p><strong>分类</strong>就是，我事先告诉你，少年儿童、青年人及老年人的年龄是什么样的，现在新来了一个年龄，输出它的类标号，就是它是属于少年儿童、青年人、老年人的哪个类。一般来说，分类器是需要训练的，也就是要告诉你的算法，每个类的特征是什么样子，它才能识别新的数据。</p>
<p> 刚才举的是一个超级简单的例子，方便大家理解。下面再举一个实际的例子。</p>
<p>对于聚类，比如有些搜索引擎有“查看相似网页”的功能，这个就可以用聚类来做，把网页就行聚类，在聚类的结果中，每一个类中的网页看成是相似的。</p>
<p>对于分类，比如手写识别就可以看到是分类问题，比如我写了10个“我”字，然后对这10个“我”字进行特征提取，就可以告诉算法，“我”字具有什么样的特征，于是来了一个新的“我”字，虽然笔画和之前的10个“我”字不完全一样，但是特征高度相似，于是就把这个手写的字分类到“我”这个类，就识别出来了。</p>
<h2 id="K-Means-聚类算法"><a href="#K-Means-聚类算法" class="headerlink" title="K-Means 聚类算法"></a>K-Means 聚类算法</h2><p>对于这样一个二维数据集，我们可以对其进行 K-Means 聚类，结果就是原数据集被分成3类：</p>
<p><img src="/2020/10/22/K-Means%E8%81%9A%E7%B1%BB/2.png" style="zoom:80%;"></p>
<p>但是二维只是为了比较直观的展现K-Means 的功能，数据集可能是更高维度的，我们现在来看看K-Means 的内部逻辑</p>
<ul>
<li>选择我们想要的类的个数K；</li>
<li>在平面上随机选择K个点，作为初始化类的中心点，不一定在原先数据当中；</li>
<li>对于数据集中的每个点，要判断它属于我们之前K个中心点的哪一类。依据数据中的每个点对这K个点的距离的大小，找到最短的距离，那么就是每个数据点对应的类别，这一步可以称作是分配；</li>
<li>重新计算一些新的中心点，就是应用之前分配的结果重新计算分配好的每个类当中的中心点；</li>
<li><p>重新分配，如果重新分配的结果和之前分配的结果相同，则说明找到最佳的K-Means算法的结果，如果不同，那继续去第四步进行分配计算，直到找到最佳算法结果</p>
<p><img src="/2020/10/22/K-Means%E8%81%9A%E7%B1%BB/3.png" style="zoom:80%;"></p>
</li>
</ul>
<p>接下来我们具体拿一个例子来说明这些过程:</p>
<p><img src="/2020/10/22/K-Means%E8%81%9A%E7%B1%BB/4.png" style="zoom:80%;"></p>
<p>接下来我们要随机选择K=2 个点作为中心，并分别计算每个点距离这两个点的距离并进行分类。这里可以有个比较简单的计算方式，我们作出这两个点的垂直平分线，那么这个绿线上方的点都是离蓝色点比较近，下面的离红色比较近。</p>
<p>经过第一次分类，我们得到的分类如下：</p>
<p><img src="/2020/10/22/K-Means%E8%81%9A%E7%B1%BB/5.png" style="zoom:80%;"></p>
<p>然后我们要计算一些新的中心点，也就是分配好的每个类当中的中心点。找到中心点之后我们又可以去重新分配数据。一直到重新分配的结果和未分配的结果相同时，完成聚类。</p>
<p><img src="/2020/10/22/K-Means%E8%81%9A%E7%B1%BB/6.png" style="zoom:80%;"></p>
<p>再次分类之后，我们得到：</p>
<p><img src="/2020/10/22/K-Means%E8%81%9A%E7%B1%BB/7.png" style="zoom:80%;"></p>
<p>对中心点进行更新：</p>
<p><img src="/2020/10/22/K-Means%E8%81%9A%E7%B1%BB/8.png" style="zoom:80%;"></p>
<p>对数据进行分配：</p>
<p><img src="/2020/10/22/K-Means%E8%81%9A%E7%B1%BB/9.png" style="zoom:80%;"></p>
<p>对中心点进行更新：</p>
<p><img src="/2020/10/22/K-Means%E8%81%9A%E7%B1%BB/10.png" style="zoom:80%;"></p>
<p>对数据进行分类，发现和之前的一样，说明聚类已经完成了：</p>
<p><img src="/2020/10/22/K-Means%E8%81%9A%E7%B1%BB/11.png" style="zoom:80%;"></p>
<h3 id="随机初始化陷阱"><a href="#随机初始化陷阱" class="headerlink" title="随机初始化陷阱"></a>随机初始化陷阱</h3><p>现在看看初始点的选择对最终K-Means聚类结果的影响。下面有一个例子，我们需要用K-Means算法对这组数据进行聚类，选择K=3。这里很明显有三类，我们这里就直接选择最佳的中心点并标记出这三类数据。</p>
<p><img src="/2020/10/22/K-Means%E8%81%9A%E7%B1%BB/12.png" style="zoom:100%;"></p>
<p><img src="/2020/10/22/K-Means%E8%81%9A%E7%B1%BB/13.png" style="zoom:100%;"></p>
<p>但是这里是我们肉眼看出来的三个中心点，但如果我们选择的不是最佳的中心点，则需要重复上述的45步，比如选的是下面这三个中心点。</p>
<p><img src="/2020/10/22/K-Means%E8%81%9A%E7%B1%BB/14.png" style="zoom:100%;"></p>
<p>这样得到的分类结果和之前那个显然是不同的。但这样就发生了同一组数据，却产生了两个不同的分类结果。区别就在于选择了不同的初始中心点。我们不好直接说哪一个分类算法更好，需要有一个方法来判断如何选择初始中心点。也就是说初始中心点不能随机进行选择了。现在有一个K-Means算法的更新版本，叫做K-Means++，它完美的解决了初始化中心点的陷阱，数学上来讲叫做局部最小值的一个陷阱。无论在R还是Python中，这个K-Means++都已经加入了算法当中，因此不用担心之后的代码实现会不会掉入这个陷阱。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><h3 id="Selecting-The-Number-Of-Cluster"><a href="#Selecting-The-Number-Of-Cluster" class="headerlink" title="Selecting The Number Of Cluster"></a>Selecting The Number Of Cluster</h3><p>上文讲到的是选择中心点的陷阱，那么现在在谈谈如何选择类的个数。从直观上，上文中的图像大部分人应该很容易想到分为3组，也有的人可能想分为2组，但怎样选择才是最佳的分组方式是个需要好好研究的问题。首先来定义一个数学的量，组内平方和(WCSS)。</p>
<p><img src="/2020/10/22/K-Means%E8%81%9A%E7%B1%BB/15.png" style="zoom:100%;"></p>
<p>来看这个表达式，一共有3项，每一项代表对于每一组的平方和。比如第一项，就是对所有数据点对这一组中心点距离的平方。很显然，如果每一组的数据蜷缩的越紧，那么这个平方和就越小。</p>
<p>那么如果将这组数据分为1组，那么这个组内平方和只有一项，那么这个结果很显然会很大。如果分为2组，那么结果比1组的肯定要小，当分为3组时，得到的结果会更小。也就是说，随着分组的个数增加，这个组内平方和会逐渐变小。那么现在的问题来了，如何选择最合适的分组的个数？</p>
<p>这里要介绍一个法则，叫做手肘法则(The Elbow Method)。我们把随着分组个数的增加，WCSS的结果的图像画出来</p>
<p><img src="/2020/10/22/K-Means%E8%81%9A%E7%B1%BB/16.png" style="zoom:100%;"></p>
<p>找到最像手肘的这个点，这里就是3，那么这个点，就是最佳的分组的个数。这个曲线上可以看到，从1到2，和2到3时，下降的速率都是比较快的，但从3往后，下降的速率都是非常小的，那么我们要找的就是这样一个点，在到达这个点之前和从这个点开始的下降，速率的变化时最大的。</p>
<h3 id="Clustering"><a href="#Clustering" class="headerlink" title="Clustering"></a>Clustering</h3><p>我们这次要用到的数据集部分如下，反映的是一个购物商场的购物信息。最后一列Spending Score是购物商场根据客户的信息打出的客户的评分，分数越低意味着客户花的钱越少，越高以为着客户花的越多。商场希望通过对客户的年收入和购物指数来进行分群</p>
<p><img src="/2020/10/22/K-Means%E8%81%9A%E7%B1%BB/17.png" style="zoom:120%;"></p>
<p>首先我们进行导库和导数据集</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">dataset = pd.read_csv(<span class="string">'Mall_Customers.csv'</span>)</span><br><span class="line">X = dataset.iloc[:, [<span class="number">3</span>, <span class="number">4</span>]].values</span><br></pre></td></tr></table></figure>
<h4 id="Using-the-elbow-method-to-find-the-optimal-number-of-clusters"><a href="#Using-the-elbow-method-to-find-the-optimal-number-of-clusters" class="headerlink" title="Using the elbow method to find the optimal number of clusters"></a>Using the elbow method to find the optimal number of clusters</h4><p>那么这个问题的自变量就是第四五列，年收入和购物指数。但它是个<strong>无监督学习</strong>，因此<strong>没有因变量</strong>。我们要将其最终分为几类。这里我们要用到的工具是<code>sklearn.cluster</code>中的<code>KMeans</code>类。首先要计算各个分组的WCSS。这里我们计算组数从1到10的情况。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line">wcss = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">    kmeans = KMeans(n_clusters = i, init = <span class="string">'k-means++'</span>, random_state = <span class="number">42</span>)</span><br><span class="line">    kmeans.fit(X)</span><br><span class="line">    wcss.append(kmeans.inertia_)</span><br><span class="line">plt.plot(range(<span class="number">1</span>, <span class="number">11</span>), wcss)</span><br><span class="line">plt.title(<span class="string">'The Elbow Method'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Number of clusters'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'WCSS'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>这里的<code>KMeans</code>中的参数也解释下，<code>n_clusters</code>指的是分组数，<code>max_iter</code>指的是每一次计算时最大的循环个数，这里使用默认值300，<code>n_init</code>代表每一个做K平均算法时，会对多少组不同的中心值进行计算。<code>init</code>这个参数非常重要，指的是我们如何选择初始值，最简单的是<code>random</code>，即随机，但为了避免掉入随机初始值陷阱，这里使用<code>k-means++</code>。</p>
<p>拟合好后得到组间距离就是<code>kmeans.inertia_</code>。这样我们就可以画出对于不同的分组数，<code>wcss</code>的图像。</p>
<p><img src="/2020/10/22/K-Means%E8%81%9A%E7%B1%BB/18.png" style="zoom:120%;"></p>
<p>那么通过手肘法则，可以得到最佳的分组个数是5组，则可以开始拟合数据。</p>
<h4 id="Training-the-K-Means-model-on-the-dataset"><a href="#Training-the-K-Means-model-on-the-dataset" class="headerlink" title="Training the K-Means model on the dataset"></a>Training the K-Means model on the dataset</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kmeans = KMeans(n_clusters = <span class="number">5</span>, init = <span class="string">'k-means++'</span>, random_state = <span class="number">42</span>)</span><br><span class="line">y_kmeans = kmeans.fit_predict(X)</span><br></pre></td></tr></table></figure>
<h4 id="Visualizing-the-clusters"><a href="#Visualizing-the-clusters" class="headerlink" title="Visualizing the clusters"></a>Visualizing the clusters</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(X[y_kmeans == <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">            X[y_kmeans == <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">            s = <span class="number">100</span>, </span><br><span class="line">            c = <span class="string">'red'</span>, </span><br><span class="line">            label = <span class="string">'Cluster 1'</span>)</span><br><span class="line">plt.scatter(X[y_kmeans == <span class="number">1</span>, <span class="number">0</span>], </span><br><span class="line">            X[y_kmeans == <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">            s = <span class="number">100</span>,</span><br><span class="line">            c = <span class="string">'blue'</span>,</span><br><span class="line">            label = <span class="string">'Cluster 2'</span>)</span><br><span class="line">plt.scatter(X[y_kmeans == <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">            X[y_kmeans == <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">            s = <span class="number">100</span>, c = <span class="string">'green'</span>,</span><br><span class="line">            label = <span class="string">'Cluster 3'</span>)</span><br><span class="line">plt.scatter(X[y_kmeans == <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line">            X[y_kmeans == <span class="number">3</span>, <span class="number">1</span>], </span><br><span class="line">            s = <span class="number">100</span>, c = <span class="string">'cyan'</span>,</span><br><span class="line">            label = <span class="string">'Cluster 4'</span>)</span><br><span class="line">plt.scatter(X[y_kmeans == <span class="number">4</span>, <span class="number">0</span>],</span><br><span class="line">            X[y_kmeans == <span class="number">4</span>, <span class="number">1</span>],</span><br><span class="line">            s = <span class="number">100</span>, </span><br><span class="line">            c = <span class="string">'magenta'</span>,</span><br><span class="line">            label = <span class="string">'Cluster 5'</span>)</span><br><span class="line">plt.scatter(kmeans.cluster_centers_[:, <span class="number">0</span>],</span><br><span class="line">            kmeans.cluster_centers_[:, <span class="number">1</span>],</span><br><span class="line">            s = <span class="number">300</span>, </span><br><span class="line">            c = <span class="string">'yellow'</span>,</span><br><span class="line">            label = <span class="string">'Centroids'</span>)</span><br><span class="line">plt.title(<span class="string">'Clusters of customers'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Annual Income (k$)'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Spending Score (1-100)'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/22/K-Means%E8%81%9A%E7%B1%BB/19.png" style="zoom:120%;"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/10/22/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%88%86%E7%B1%BB%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/22/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%88%86%E7%B1%BB%E5%99%A8/" class="post-title-link" itemprop="url">决策树和随机森林分类器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-10-22 18:29:56 / Modified: 19:19:18" itemprop="dateCreated datePublished" datetime="2020-10-22T18:29:56+08:00">2020-10-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="决策树和随机森林分类器"><a href="#决策树和随机森林分类器" class="headerlink" title="决策树和随机森林分类器"></a>决策树和随机森林分类器</h1><h2 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h2><p>在之前，我们介绍了<a href="https://jasonxqh.github.io/2020/10/09/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%9B%9E%E5%BD%92/"> 回归树和随机森林回归</a> 现在我们来看看分类树</p>
<p>分类树和和回归树不同，它处理的数据都是离散的，且有分类的, 对于一个新数据的预测，我们是将其划归为哪一类中去。而回归树处理的数据则是连续的数字，对于一个新数据的预测，我们是赋给它一个值。</p>
<p>比如说下面这个例子，用分类树将其划分为几个区：</p>
<p><img src="/2020/10/22/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%88%86%E7%B1%BB%E5%99%A8/1.png" style="zoom:100%;"></p>
<p><img src="/2020/10/22/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%88%86%E7%B1%BB%E5%99%A8/2.png" style="zoom:100%;"></p>
<p>然后再对其进行决策：</p>
<p><img src="/2020/10/22/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%88%86%E7%B1%BB%E5%99%A8/3.png" style="zoom:100%;"></p>
<p>决策树和其他的分类器一样，也可以对多个维度进行训练。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>我们同样使用之前的 年龄-薪资-购买与否 的数据集：</p>
<p>和之前的代码几乎一样，这里展示一下训练集、混淆矩阵以及可视化结果</p>
<h3 id="Training-the-Decision-Tree-Classification-model-on-the-Training-set"><a href="#Training-the-Decision-Tree-Classification-model-on-the-Training-set" class="headerlink" title="Training the Decision Tree Classification model on the Training set"></a>Training the Decision Tree Classification model on the Training set</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line">classifier = DecisionTreeClassifier(criterion = <span class="string">'entropy'</span>, random_state = <span class="number">0</span>)</span><br><span class="line">classifier.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>
<h3 id="Making-the-Confusion-Matrix"><a href="#Making-the-Confusion-Matrix" class="headerlink" title="Making the Confusion Matrix"></a>Making the Confusion Matrix</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix, accuracy_score</span><br><span class="line">cm = confusion_matrix(y_test, y_pred)</span><br><span class="line">print(cm)</span><br><span class="line">accuracy_score(y_test, y_pred)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[62  6]</span><br><span class="line"> [ 3 29]]</span><br><span class="line"> 0.91</span><br></pre></td></tr></table></figure>
<h3 id="Visualizing-the-Training-set-results"><a href="#Visualizing-the-Training-set-results" class="headerlink" title="Visualizing the Training set results"></a>Visualizing the Training set results</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line">X_set, y_set = sc.inverse_transform(X_train), y_train</span><br><span class="line">X1, X2 = np.meshgrid(np.arange(start = X_set[:, <span class="number">0</span>].min() - <span class="number">10</span>, </span><br><span class="line">							   stop = X_set[:, <span class="number">0</span>].max() + <span class="number">10</span>,</span><br><span class="line">                               step = <span class="number">0.25</span>),</span><br><span class="line">                     np.arange(start = X_set[:, <span class="number">1</span>].min() - <span class="number">1000</span>, </span><br><span class="line">                     			stop = X_set[:, <span class="number">1</span>].max() + <span class="number">1000</span>, </span><br><span class="line">                     			step = <span class="number">0.25</span>))</span><br><span class="line">plt.contourf(X1, X2, </span><br><span class="line">classifier.predict(sc.transform(np.array([X1.ravel(), X2.ravel()]).T)).reshape(X1.shape),</span><br><span class="line">             alpha = <span class="number">0.75</span>,</span><br><span class="line">             cmap = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>)))</span><br><span class="line">plt.xlim(X1.min(), X1.max())</span><br><span class="line">plt.ylim(X2.min(), X2.max())</span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> enumerate(np.unique(y_set)):</span><br><span class="line">    plt.scatter(X_set[y_set == j, <span class="number">0</span>],</span><br><span class="line">    			X_set[y_set == j, <span class="number">1</span>],</span><br><span class="line">                c = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>))(i),</span><br><span class="line">                label = j)</span><br><span class="line">plt.title(<span class="string">'Decision Tree Classification (Training set)'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Age'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Estimated Salary'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/22/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%88%86%E7%B1%BB%E5%99%A8/4.png" style="zoom:100%;"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line">X_set, y_set = sc.inverse_transform(X_test), y_test</span><br><span class="line">X1, X2 = np.meshgrid(np.arange(start = X_set[:, <span class="number">0</span>].min() - <span class="number">10</span>,</span><br><span class="line">								stop = X_set[:, <span class="number">0</span>].max() + <span class="number">10</span>,</span><br><span class="line">                                step = <span class="number">0.25</span>),</span><br><span class="line">                     np.arange(start = X_set[:, <span class="number">1</span>].min() - <span class="number">1000</span>, </span><br><span class="line">                     			stop = X_set[:, <span class="number">1</span>].max() + <span class="number">1000</span>,</span><br><span class="line">                                step = <span class="number">0.25</span>))</span><br><span class="line">plt.contourf(X1, X2, </span><br><span class="line">classifier.predict(sc.transform(np.array([X1.ravel(), X2.ravel()]).T)).reshape(X1.shape),</span><br><span class="line">             alpha = <span class="number">0.75</span>, </span><br><span class="line">             cmap = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>)))</span><br><span class="line">plt.xlim(X1.min(), X1.max())</span><br><span class="line">plt.ylim(X2.min(), X2.max())</span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> enumerate(np.unique(y_set)):</span><br><span class="line">    plt.scatter(X_set[y_set == j, <span class="number">0</span>], </span><br><span class="line">    			X_set[y_set == j, <span class="number">1</span>],</span><br><span class="line">                c = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>))(i), </span><br><span class="line">                label = j)</span><br><span class="line">plt.title(<span class="string">'Decision Tree Classification (Test set)'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Age'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Estimated Salary'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/22/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%88%86%E7%B1%BB%E5%99%A8/5.png" style="zoom:100%;"></p>
<h2 id="随机森林分类器"><a href="#随机森林分类器" class="headerlink" title="随机森林分类器"></a>随机森林分类器</h2><ul>
<li>Step 1: Pick at random K data points from the Training set</li>
<li>Step 2: Build the Decision Tree associated to these K data points</li>
<li>Step 3: Choose the number Ntree of trees you want to build and repeat STEPS 1&amp;2</li>
<li>Step 4: For a new data point, make each one of your Ntree trees predict the category to which the data points belongs, and assign the new data point to the category that wins the majority vote</li>
</ul>
<h3 id="Training-the-Random-Forest-Classification-model-on-the-Training-set"><a href="#Training-the-Random-Forest-Classification-model-on-the-Training-set" class="headerlink" title="Training the Random Forest Classification model on the Training set"></a>Training the Random Forest Classification model on the Training set</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line">classifier = RandomForestClassifier(n_estimators = <span class="number">10</span>, criterion = <span class="string">'entropy'</span>, random_state = <span class="number">0</span>)</span><br><span class="line">classifier.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>
<h3 id="Making-the-Confusion-Matrix-1"><a href="#Making-the-Confusion-Matrix-1" class="headerlink" title="Making the Confusion Matrix"></a>Making the Confusion Matrix</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix, accuracy_score</span><br><span class="line">cm = confusion_matrix(y_test, y_pred)</span><br><span class="line">print(cm)</span><br><span class="line">accuracy_score(y_test, y_pred)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[63  5]</span><br><span class="line"> [ 4 28]]</span><br><span class="line"> 0.91</span><br></pre></td></tr></table></figure>
<h3 id="Visualizing-the-Training-set-results-1"><a href="#Visualizing-the-Training-set-results-1" class="headerlink" title="Visualizing the Training set results"></a>Visualizing the Training set results</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line">X_set, y_set = sc.inverse_transform(X_train), y_train</span><br><span class="line">X1, X2 = np.meshgrid(np.arange(start = X_set[:, <span class="number">0</span>].min() - <span class="number">10</span>,</span><br><span class="line">								stop = X_set[:, <span class="number">0</span>].max() + <span class="number">10</span>, </span><br><span class="line">								step = <span class="number">0.25</span>),</span><br><span class="line">                     np.arange(start = X_set[:, <span class="number">1</span>].min() - <span class="number">1000</span>,</span><br><span class="line">                     			stop = X_set[:, <span class="number">1</span>].max() + <span class="number">1000</span>,</span><br><span class="line">                                step = <span class="number">0.25</span>))</span><br><span class="line">plt.contourf(X1, X2, </span><br><span class="line">classifier.predict(sc.transform(np.array([X1.ravel(), X2.ravel()]).T)).reshape(X1.shape),</span><br><span class="line">             alpha = <span class="number">0.75</span>,</span><br><span class="line">             cmap = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>)))</span><br><span class="line">plt.xlim(X1.min(), X1.max())</span><br><span class="line">plt.ylim(X2.min(), X2.max())</span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> enumerate(np.unique(y_set)):</span><br><span class="line">    plt.scatter(X_set[y_set == j, <span class="number">0</span>],</span><br><span class="line">    			X_set[y_set == j, <span class="number">1</span>], </span><br><span class="line">    			c = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>))(i), </span><br><span class="line">    			label = j)</span><br><span class="line">plt.title(<span class="string">'Random Forest Classification (Training set)'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Age'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Estimated Salary'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/22/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%88%86%E7%B1%BB%E5%99%A8/6.png" style="zoom:100%;"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line">X_set, y_set = sc.inverse_transform(X_test), y_test</span><br><span class="line">X1, X2 = np.meshgrid(np.arange(start = X_set[:, <span class="number">0</span>].min() - <span class="number">10</span>, </span><br><span class="line">                               	stop = X_set[:, <span class="number">0</span>].max() + <span class="number">10</span>, </span><br><span class="line">                               	step = <span class="number">0.25</span>),</span><br><span class="line">                     np.arange(start = X_set[:, <span class="number">1</span>].min() - <span class="number">1000</span>, </span><br><span class="line">                               stop = X_set[:, <span class="number">1</span>].max() + <span class="number">1000</span>,</span><br><span class="line">                               step = <span class="number">0.25</span>))</span><br><span class="line">plt.contourf(X1, X2, </span><br><span class="line">             classifier.predict(sc.transform(np.array([X1.ravel(), X2.ravel()]).T)).reshape(X1.shape),</span><br><span class="line">             alpha = <span class="number">0.75</span>, </span><br><span class="line">             cmap = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>)))</span><br><span class="line">plt.xlim(X1.min(), X1.max())</span><br><span class="line">plt.ylim(X2.min(), X2.max())</span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> enumerate(np.unique(y_set)):</span><br><span class="line">    plt.scatter(X_set[y_set == j, <span class="number">0</span>],</span><br><span class="line">                X_set[y_set == j, <span class="number">1</span>],</span><br><span class="line">                c = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>))(i), </span><br><span class="line">                label = j)</span><br><span class="line">plt.title(<span class="string">'Random Forest Classification (Test set)'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Age'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Estimated Salary'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/22/%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E5%88%86%E7%B1%BB%E5%99%A8/7.png" style="zoom:100%;"></p>
<p>随机森林可以用来进行体感游戏中对人体动作的检测，判断人生上的区域的运动等等。</p>
<p><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/BodyPartRecognition.pdf" target="_blank" rel="noopener">https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/BodyPartRecognition.pdf</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/10/21/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/21/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/" class="post-title-link" itemprop="url">朴素贝叶斯</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-21 21:17:28" itemprop="dateCreated datePublished" datetime="2020-10-21T21:17:28+08:00">2020-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-22 18:25:58" itemprop="dateModified" datetime="2020-10-22T18:25:58+08:00">2020-10-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h1><p>参考博客： <a href="https://www.jianshu.com/p/456782eff870" target="_blank" rel="noopener">https://www.jianshu.com/p/456782eff870</a></p>
<p>我在离散数学的概率博客中提到了Bayes 定理，可以参考这篇博客进行学习： <a href="https://jasonxqh.github.io/2020/05/15/离散概率part2/#Bayes&#39;-Therem">Bayes‘ Therem</a></p>
<h3 id="Naive-Bayes"><a href="#Naive-Bayes" class="headerlink" title="Naïve Bayes"></a>Naïve Bayes</h3><p>现在我们着重介绍一些朴素贝叶斯分类器。  </p>
<p><img src="/2020/10/21/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/1.png" style="zoom:80%;"></p>
<p>这是一个年龄薪水关于上班方式的数据集，绿色代表了了开车去上班，红色代表了走路去上班。现在有一个新的点进来了，我们该怎么预测它是属于哪一类的呢？</p>
<p>我们需要用到 $P(A|B) = \frac{P(B|A)\cdot P(A)}{P(B)}$  其中P(A|B)被称作后验概率，P(B|A)和P(B)这两个概率并不完全是概率，因为朴素贝叶斯分类器中，<strong>B代表特征</strong>，所以说这两个概率我们称作<strong>似然</strong>。</p>
<h4 id="Step1"><a href="#Step1" class="headerlink" title="Step1"></a>Step1</h4><p>应用到上面这个数据集，我们就会求 $P(Walk|X)=\frac{P(X|Walk)*P(Walks)}{P(X)}$ </p>
<p>这里的X就是它的特征。对于新的点，它有对应的年纪和收入就是这个新用户的特征，我们要求的就是已知这些特征，要得到它分到红组或者绿组的概率。这里的P(Walks)就是随机抽一个人，它是走路上班的概率，这个也被称作先验概率，对应的就是后验。P(X)指的是随机抽一个人，他所显示的特征和新用户的特征的似然或者可能性。这里的似然也是个概率，它是对数据特征的概率，因此我们把它叫做似然。再然后，这里的P(X)指的是对这个数据特征的概率，因此叫做似然。接下来第三部要求的也是个似然P(X|Walks)，或者叫做边际的似然，边际的可能性。这样我们就能求出后验概率P(Walks|X)。</p>
<p><img src="/2020/10/21/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/2.png" style="zoom:80%;"></p>
<h4 id="Step2"><a href="#Step2" class="headerlink" title="Step2"></a>Step2</h4><p><img src="/2020/10/21/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/3.png" style="zoom:80%;"></p>
<p>分别计算出 Drives和Walks的概率之后，我们要比较 $P(Walks|X) ~v.s. P(Drives|X)$  谁大谁小，哪个大这个X就属于哪里</p>
<p>我们来一步一步实现这些步骤</p>
<p>首先 P(Walks) = (Number of Walkers)/ (Total Observations) = 10/30</p>
<p>接下来，计算P(X)，也就是似然。这个是朴素贝叶斯中核心的一步。这里的X指的是新用户他所代表的特征，即年纪和收入。我们可以围绕这个新用户画一个圈，那么这个圈就代表着在这个二维数据空间中的所有用户，他们的特征和新用户非常相似。要求的P(X)就是我们原先数据空间中的所有数据，它的特征坐落在这个圈中的概率。那么我们要计算的就是原先数据中与新用户拥有相似特征的个数除以总的人数。 P(X) = Number of Similar Observations/ Total Observations = 4/30</p>
<p><img src="/2020/10/21/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/4.png" style="zoom:90%;"></p>
<p>再然后求P(X}Walks)，也就是边际似然，那么就是如果一个人是步行上班，那么它坐落在这个圈中的概率。P(X|Walks) = Number of Similar Observations Among those who Walk / Total number of Walkers =  3/10</p>
<p><img src="/2020/10/21/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/5.png" style="zoom:90%;"></p>
<p>根据上面几个数据，我们可以计算出 P(Walks|X)</p>
<p><img src="/2020/10/21/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/6.png" style="zoom:90%;"></p>
<p>同理，我们可以得出 P(Drives|X) = 0.25</p>
<p>因为 0.75 &gt; 0.25 所以这一点应该被划分到红色，也就是走路的一边去</p>
<h2 id="朴素贝叶斯的一些补充说明"><a href="#朴素贝叶斯的一些补充说明" class="headerlink" title="朴素贝叶斯的一些补充说明"></a>朴素贝叶斯的一些补充说明</h2><p>接下来我们来看看几个问题，<strong>首先第一个</strong>，为什么把它做朴素贝叶斯？或者为什么朴素？当我们使用朴素贝叶斯方法的时候已经做过一个假设，这个假设就是数据的<strong>所有特征都是独立的</strong>。在上述的例子里的两个特征，年龄和薪水，实际上这两者是可能有关系的，一般来说年龄越大可能薪水就越大。但这里假设年龄和薪水两者没有相关性。因此在一个机器学习的问题中，我们经常会做一些假设，这些假设并不一定都是对的，但这些假设可以帮助我们更高效快捷的解决问题。我们允许有一点误差，因为我们的终极问题是解决问题。</p>
<p><strong>第二个问题</strong>，似然函数P(X)，上面计算这个函数的方法是先在新数据周围画了个圈，表示在这个圈里的数据点，都表示和这个新数据点有相似的特征，那么接下来这个似然就是指如果有一个新的点，那么它坐落在这个圈中的概率。那么这个P(X)你会发现，它跟我们想要计算的后验概率是和红组相关还是绿组相关是没有关系的。我们最后要计算的两个后验概率的公式中的分母都是P(X)，那么我们比较这两者实际上可以把这个P(X)个消掉，也就是说可以直接比较两者的分子P(X|Walks)*P(Walks)和P(X|Drives)*P(Drives)。</p>
<p><strong>最后一个问题</strong>，若我们已知的组超过两组怎么办？目前已经有两组的情况下，比较两者的后验概率，那么我们将新数据分配到更大的概率的分组中。那么同理如果有三组的话，就是比较三者的后验概率，哪个更大就分配到其分组中。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="Importing-the-libraries"><a href="#Importing-the-libraries" class="headerlink" title="Importing the libraries"></a>Importing the libraries</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>
<h3 id="Importing-the-dataset"><a href="#Importing-the-dataset" class="headerlink" title="Importing the dataset"></a>Importing the dataset</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataset = pd.read_csv(<span class="string">'Social_Network_Ads.csv'</span>)</span><br><span class="line">X = dataset.iloc[:, :<span class="number">-1</span>].values</span><br><span class="line">y = dataset.iloc[:, <span class="number">-1</span>].values</span><br></pre></td></tr></table></figure>
<h3 id="Splitting-the-dataset-into-the-Training-set-and-Test-set"><a href="#Splitting-the-dataset-into-the-Training-set-and-Test-set" class="headerlink" title="Splitting the dataset into the Training set and Test set"></a>Splitting the dataset into the Training set and Test set</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">                                    X, </span><br><span class="line">                                    y,</span><br><span class="line">                                    test_size = <span class="number">0.25</span>,</span><br><span class="line">                                    random_state = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Feature-Scaling"><a href="#Feature-Scaling" class="headerlink" title="Feature Scaling"></a>Feature Scaling</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">sc = StandardScaler()</span><br><span class="line">X_train = sc.fit_transform(X_train)</span><br><span class="line">X_test = sc.transform(X_test)</span><br></pre></td></tr></table></figure>
<h3 id="Training-the-Naive-Bayes-model-on-the-Training-set"><a href="#Training-the-Naive-Bayes-model-on-the-Training-set" class="headerlink" title="Training the Naive Bayes model on the Training set"></a>Training the Naive Bayes model on the Training set</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</span><br><span class="line">classifier = GaussianNB()</span><br><span class="line">classifier.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>
<h3 id="Predicting-the-Test-set-results"><a href="#Predicting-the-Test-set-results" class="headerlink" title="Predicting the Test set results"></a>Predicting the Test set results</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y_pred = classifier.predict(X_test)</span><br><span class="line">print(np.concatenate((y_pred.reshape(len(y_pred),<span class="number">1</span>), </span><br><span class="line">						y_test.reshape(len(y_test),<span class="number">1</span>)),<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<h3 id="Making-the-Confusion-Matrix"><a href="#Making-the-Confusion-Matrix" class="headerlink" title="Making the Confusion Matrix"></a>Making the Confusion Matrix</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix, accuracy_score</span><br><span class="line">cm = confusion_matrix(y_test, y_pred)</span><br><span class="line">print(cm)</span><br><span class="line">accuracy_score(y_test, y_pred)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[65  3]</span><br><span class="line"> [ 7 25]]</span><br><span class="line">0.9</span><br></pre></td></tr></table></figure>
<h3 id="Visualising-the-Training-set-results"><a href="#Visualising-the-Training-set-results" class="headerlink" title="Visualising the Training set results"></a>Visualising the Training set results</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line">X_set, y_set = sc.inverse_transform(X_train), y_train</span><br><span class="line">X1, X2 = np.meshgrid(np.arange( start = X_set[:, <span class="number">0</span>].min() - <span class="number">10</span>,</span><br><span class="line">								stop = X_set[:, <span class="number">0</span>].max() + <span class="number">10</span>,</span><br><span class="line">								step = <span class="number">0.25</span>),</span><br><span class="line">                     np.arange(start = X_set[:, <span class="number">1</span>].min() - <span class="number">1000</span>, </span><br><span class="line">                     			stop = X_set[:, <span class="number">1</span>].max() + <span class="number">1000</span>,</span><br><span class="line">                                step = <span class="number">0.25</span>))</span><br><span class="line">plt.contourf(X1,</span><br><span class="line">			X2,</span><br><span class="line">            classifier.predict(sc.transform(np.array([X1.ravel(), 	X2.ravel()]).T)).reshape(X1.shape),</span><br><span class="line">             alpha = <span class="number">0.75</span>, </span><br><span class="line">             cmap = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>)))</span><br><span class="line">plt.xlim(X1.min(), X1.max())</span><br><span class="line">plt.ylim(X2.min(), X2.max())</span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> enumerate(np.unique(y_set)):</span><br><span class="line">    plt.scatter(X_set[y_set == j, <span class="number">0</span>],</span><br><span class="line">    			X_set[y_set == j, <span class="number">1</span>], </span><br><span class="line">    			c = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>))(i), label = j)</span><br><span class="line">plt.title(<span class="string">'Naive Bayes (Training set)'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Age'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Estimated Salary'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/21/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/7.png" style="zoom:100%;"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line">X_set, y_set = sc.inverse_transform(X_test), y_test</span><br><span class="line">X1, X2 = np.meshgrid(np.arange(start = X_set[:, <span class="number">0</span>].min() - <span class="number">10</span>,</span><br><span class="line">								stop = X_set[:, <span class="number">0</span>].max() + <span class="number">10</span>,</span><br><span class="line">                                step = <span class="number">0.25</span>),</span><br><span class="line">                     np.arange(start = X_set[:, <span class="number">1</span>].min() - <span class="number">1000</span>,</span><br><span class="line">                     			stop = X_set[:, <span class="number">1</span>].max() + <span class="number">1000</span>,</span><br><span class="line">                                step = <span class="number">0.25</span>))</span><br><span class="line">plt.contourf(X1, X2,</span><br><span class="line">			classifier.predict(sc.transform(np.array([X1.ravel(), X2.ravel()]).T)).reshape(X1.shape),</span><br><span class="line">             alpha = <span class="number">0.75</span>,</span><br><span class="line">             cmap = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>)))</span><br><span class="line">plt.xlim(X1.min(), X1.max())</span><br><span class="line">plt.ylim(X2.min(), X2.max())</span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> enumerate(np.unique(y_set)):</span><br><span class="line">    plt.scatter(X_set[y_set == j, <span class="number">0</span>],</span><br><span class="line">                X_set[y_set == j, <span class="number">1</span>], </span><br><span class="line">                c = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>))(i), label = j)</span><br><span class="line">plt.title(<span class="string">'Naive Bayes (Test set)'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Age'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Estimated Salary'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/21/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/8.png" style="zoom:100%;"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/" class="post-title-link" itemprop="url">CSAPP程序的机器级表示3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-20 16:55:46" itemprop="dateCreated datePublished" datetime="2020-10-20T16:55:46+08:00">2020-10-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-28 11:02:44" itemprop="dateModified" datetime="2020-10-28T11:02:44+08:00">2020-10-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CSAPP程序的机器级表示3"><a href="#CSAPP程序的机器级表示3" class="headerlink" title="CSAPP程序的机器级表示3"></a>CSAPP程序的机器级表示3</h1><h2 id="数组的分配和访问"><a href="#数组的分配和访问" class="headerlink" title="数组的分配和访问"></a>数组的分配和访问</h2><h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h3><p>我们首先来看看数组的声明</p>
<p><strong>T A[N]</strong> </p>
<p>其中T是数据类型，N是整形常数。</p>
<p>这个声明有两个效果</p>
<ul>
<li>在内存中分配了一个 $L\cdot N$ 字节的连续区域，这里L是数据类型T的大小（单位为字节）。</li>
<li>引入了标识符A，可以用A来做指向数组开头的指针，记为 $x_A$。然后可以用 $0\sim {N-1}$ 的整数索引来范根该数组元素。数组元素i会被存放在地址为 $x_A+L\cdot i$ 的地方</li>
</ul>
<p>下面申请了几个数组，我们可以看到数组成员在地址上的位置</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/1.png"></p>
<p>假如 E 是一个int型的数组，而我们想计算 $E[i]$ ，在此，E的地址存放在寄存器 $\%rdx$ 中，而 i 存放在寄存器 $\%rcx$ 中。然后再指令 </p>
<p>$movl~~(\%rdx,\%rcx,4),\%eax$   会执行计算 $x_E+4i$  读取这个内存位置的值，并将结果存放到寄存器 $\%eax$ 中。允许的伸缩因子 1、2、4、8 刚好能覆盖了所有基本简单数据类型的大小。 </p>
<h3 id="访问数组"><a href="#访问数组" class="headerlink" title="访问数组"></a>访问数组</h3><p>访问数组的形式非常多样</p>
<p>C语言允许对指针进行运算，而计算出来的值会<strong>根据该指针引用的数据类型大小进行伸缩</strong>。也就是说如果 p 是一个指向 类型为T 的数据的指针，那么表达式 p+i 就等于 $x_p+L\cdot i$ </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>表达式</th>
<th>类型</th>
<th>值</th>
<th>汇编代码</th>
</tr>
</thead>
<tbody>
<tr>
<td>E</td>
<td>int *</td>
<td>$x_E$</td>
<td>movq %rdx,%rax</td>
</tr>
<tr>
<td>E[0]</td>
<td>int</td>
<td>$M[x_E]$ //在$x_E$ 地址上的值</td>
<td>movl (%rdx),%rax</td>
</tr>
<tr>
<td>E[i]</td>
<td>int</td>
<td>$M[x_E+4i]$</td>
<td>movl (%rdx,%rcx,4) ,%eax</td>
</tr>
<tr>
<td>&amp;E[2]</td>
<td>int*</td>
<td>$x_E+8$</td>
<td>leaq 8(%rdx),%rax</td>
</tr>
<tr>
<td>E+i-1</td>
<td>int*</td>
<td>$x_E+4i-4$</td>
<td>leaq -4(%rdx,%rcx,4) ,%rax</td>
</tr>
<tr>
<td>*(E+i-3)</td>
<td>int</td>
<td>$M[x_E+4i-12]$</td>
<td>movl -12(%rdx,%rcx,4),%eax</td>
</tr>
<tr>
<td>&amp;E[i]-E</td>
<td>long</td>
<td>i</td>
<td>movq %rcx,%rax</td>
</tr>
</tbody>
</table>
</div>
<p>最后一个例子是两个指针之差，结果的数据类型为long</p>
<h4 id="Array-Loop-Example"><a href="#Array-Loop-Example" class="headerlink" title="Array Loop Example"></a>Array Loop Example</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zincr</span><span class="params">(zip_dig z)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    z[i]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 函数的汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># %rdi &#x3D; z</span><br><span class="line">	movl 	$0, %eax 			# i &#x3D; 0</span><br><span class="line">	jmp 	.L3 				# goto middle</span><br><span class="line">.L4: 							# loop:</span><br><span class="line">	addl 	$1, (%rdi,%rax,4) 	# z[i]++</span><br><span class="line">	addq 	$1, %rax 			# i++</span><br><span class="line">.L3: 							# middle</span><br><span class="line">	cmpq 	$4, %rax 			# i:4</span><br><span class="line">	jbe 	.L4 				# if &lt;&#x3D;, goto loop	</span><br><span class="line">	rep; ret</span><br></pre></td></tr></table></figure>
<p>.L3 中，需要用 i 和 4相比，如果小于等于4，那么就跳转到 .L4</p>
<p>现在我们举几个数组和指针的例子</p>
<p>Comp: Compiles (Y/N)<br>Bad:     Possible bad pointer reference (Y/N)<br>Size:     Value returned by sizeof</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/2.png"></p>
<ul>
<li>首先 $A1[3]$  和 $*A2$ 都是 可以通过编译的，而且指针都不是非法的。</li>
<li>因为A1有3个int，所以数组大小是 12个字节，*A2 是指针，长度为8个字节</li>
<li>对于 *A1和 *A2,它们都是能通过编译的，但是对A1来说，在声明之初已经申请了地址了，只是没有初始化，所以*A1 是任意一个值，而 *A2则没有为其分配内存，输出*A2 就会出错，而对于*A1 和 *A2,声明之初是int，所以Size为4个字节</li>
</ul>
<p>现在来看看更加复杂的问题： </p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/3.png"></p>
<ul>
<li>A1[3]是一维数组, *A2[3]是指针数组 ,也就是用来存放指针的数组，这些指针会指向 int 类型的数据。  (*A3)[3]是一个数组指针，也就是指向长度为3的数组的指针 这三者都能通过编译。</li>
<li>对于 (*A3)[3] 来说，*An就是它指向的地方也就是数组，数组有3个int数据，大小为 12 size 。但这个数组的内存尚未分配，所以是 Bad Reference。对于 *A2[3] 来说，*An 就是指针数组中的指针，是分配过内存的，大小为8size</li>
<li>对于A1[3]来说 **An 不存在这种定义。对 *A2[3] 来说，<em>\</em>An 是指针指向的区域，但因为这些区域没有分配内存，所以是非法的。对(*A3)[3] 来说，** An 是数组中存放的数据，大小为4byte，但是因为没有分配内存，所以也是Bad Reference</li>
</ul>
<h3 id="嵌套数组-Nested"><a href="#嵌套数组-Nested" class="headerlink" title="嵌套数组(Nested)"></a>嵌套数组(Nested)</h3><p>嵌套数组这样声明：</p>
<p>T A[R][C]:</p>
<p>这是一个二维数组：数据类型为T，R行C列</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/4.png"></p>
<p>Array的大小就是 $R\cdot C\cdot sizeof(T)$ bytes</p>
<p>嵌套数组是以行为主导顺序分配内存的：Row-Major</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/5.png" style="zoom:90%;"></p>
<p>这是嵌套数组的另外一种定义方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCOUNT 4</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> zip_dig[<span class="number">5</span>];</span><br><span class="line">zip_dig pgh[PCOUNT] =</span><br><span class="line">    &#123;&#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>&#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span> &#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span> &#125;,</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span> &#125;&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/6.png" style="zoom:90%;"></p>
<h4 id="Nested-Array-Row-access"><a href="#Nested-Array-Row-access" class="headerlink" title="Nested Array Row access"></a>Nested Array Row access</h4><p>对于 嵌套数组 A[R][C] 那么我们要访问一个数组中的一行，我们该怎么办：</p>
<p>行向量的开始地址是 ：$A+i\cdot (C\cdot sizeof(T))$ </p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/7.png" style="zoom:90%;"></p>
<h4 id="Nested-Array-Element-access"><a href="#Nested-Array-Element-access" class="headerlink" title="Nested Array Element access"></a>Nested Array Element access</h4><p>A[i][j]  是一个类型为T的数据,设T有K个字节，那么其地址可以这样来写 ： $A+i\cdot(C\cdot K)+j\cdot K=A+(i\cdot C+j)\cdot K$ </p>
<p>具体用 int 举例我们可以这样表示：</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/9.png" style="zoom:90%;"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_pgh_digit</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> dig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> pgh[index][dig];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leaq 	(%rdi,%rdi,4), %rax 	# 5*index</span><br><span class="line">addl 	%rax, %rsi 				# 5*index+dig</span><br><span class="line">movl 	pgh(,%rsi,4), %eax 		# M[pgh + 4*(5*index+dig)]</span><br></pre></td></tr></table></figure>
<p>Address:  pgh + 20*index + 4*dig = pgh + 4*(5*index + dig)</p>
<h3 id="Multi-Level-Array"><a href="#Multi-Level-Array" class="headerlink" title="Multi-Level Array"></a>Multi-Level Array</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zip_dig cmu = &#123; <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span> &#125;;</span><br><span class="line">zip_dig mit = &#123; <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span> &#125;;</span><br><span class="line">zip_dig ucb = &#123; <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UCOUNT 3</span></span><br><span class="line"><span class="keyword">int</span> *univ[UCOUNT] = &#123;mit, cmu, ucb&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/10.png" style="zoom:90%;"></p>
<p>获得一个具体位置的数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_univ_digit</span><span class="params">(<span class="keyword">size_t</span> index, <span class="keyword">size_t</span> digit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> univ[index][digit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是函数的汇编代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">salq 	$2, %rsi 			# 4*digit</span><br><span class="line">addq 	univ(,%rdi,8), %rsi # p &#x3D; univ[index] + 4*digit</span><br><span class="line">movl 	(%rsi), %eax 		# return *p</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>Element access Mem[Mem[univ+8*index]+4*digit]</p>
<p>对二维数组的两种存储方法(Nested array和 Multi-level array) ，我们可以做一个对比：</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/11.png" style="zoom:90%;"></p>
<h2 id="异质的数据结构"><a href="#异质的数据结构" class="headerlink" title="异质的数据结构"></a>异质的数据结构</h2><p>C语言中有 structure(结构)，用struct声明，将多个对象集合到一个单位中</p>
<p>union(联合)，用关键字union来声明，允许用几种不同类型来引用一个对象。</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>struct结构类似于数组的实现，它将所有组成部分都存放在内存中一段连续的区域内，而只想结构的指针就是结构第一个字节的地址。</p>
<p>比如下面这个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rec</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">size_t</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rec</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/12.png" style="zoom:90%;"></p>
<p>我们看到首先声明的是 一个int类型的数组，占用 4x4 =16 个字节。然后是size_t ，在64位机器下是8个字节。 next是一个指针，至下关下一个struct，所以占用8个byte。 可以观察到 数组 a 是嵌入到这个结构当中的。</p>
<hr>
<p>现在我想计算出指向a中某个数据的指针，我们应该如何操作？</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">get_ap</span> <span class="params">(struct rec *r, <span class="keyword">size_t</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;r-&gt;a[idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在汇编代码中，编译器会这么处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># r in %rdi, idx in %rsi</span><br><span class="line">leaq 	(%rdi,%rsi,4), %rax</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<hr>
<p>现在我想计算一条链表中的长度,我们可以写一个这样的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">length</span><span class="params">(struct rec*r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> len = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">while</span> (r) &#123;</span><br><span class="line">        len ++;</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.L11: 						# loop:</span><br><span class="line">    addq 	$1, %rax 		# len ++</span><br><span class="line">    movq 	24(%rdi), %rdi	# r &#x3D; Mem[r+24]</span><br><span class="line">    testq 	%rdi, %rdi 		# Test r</span><br><span class="line">    jne 	.L11 			# If !&#x3D; 0, goto loop</span><br></pre></td></tr></table></figure>
<p>因为一个struct占用的空间为32byte，但是最后8byte指向的是下一个struct 开始的地址，所以我们只要读出 在 r+24处的地址并判断其是否为空即可判断链表是否已经到达尾端</p>
<p>r+24 是 next的地址，next地址上的值 = 下一个struct的开头地址</p>
<hr>
<p>再来看看下面这个可能会出现问题的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_val</span> <span class="params">(struct rec *r, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (r) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> i = r-&gt;i;</span><br><span class="line">        r-&gt;a[i] = val;</span><br><span class="line">        r = r-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先把 i 命令成 struct里面的 i，然后将 val的值赋给 a[i] ,然后再指向下一个struct</p>
<p>其汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.L11: 							# loop:</span><br><span class="line">    movq   16(%rdi), %rax	 	# i &#x3D; Mem[r+16]</span><br><span class="line">    movl   %esi, (%rdi,%rax,4) 	# Mem[r+4*i] &#x3D; val</span><br><span class="line">    movq   24(%rdi), %rdi 		# r &#x3D; Mem[r+24]</span><br><span class="line">    testq  %rdi, %rdi 			# Test r</span><br><span class="line">    jne    .L11 				# if !&#x3D;0 goto loop</span><br></pre></td></tr></table></figure>
<p>先取出 r+16 地址上的值赋给 i，然后再将$r+4\cdot i $地址上的值赋值给 $val$</p>
<p>但是这样写会出现意想不到的结果，因为a只有4个位置，如果 struct 中的 $i\geq 4$ 的话，事实上 r-&gt;a[i] = val 实际上改动的是 r-&gt;i =val甚至报错 因为struct是在内存上连续存储的，C语言也不会检查数组是否会越界。于是 a[4] 其实修改的是 r-&gt;i 的值，而如果 i继续增大的话，到了没有分配内存的区域，C语言就会报错。</p>
<h3 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h3><h3 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h3><p>在struct中，我们要进行数据对齐。</p>
<p>对于一个 struct 例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> i[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">double</span> v;</span><br><span class="line">&#125; *p;</span><br></pre></td></tr></table></figure>
<p>在真实的内存当中，它其实是这么存储的：</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/13.png" style="zoom:90%;"></p>
<p>对于一个数据类型，它在内存里的起始位置必须是它大小的倍数：</p>
<p>对于一个 character来说，它在哪里存储都可以，因为其长度只有1byte</p>
<p>对于一个 int 来说，他的起始位置必须是4的倍数</p>
<p>对以一个double来说，它的起始位置必须是8的倍数。</p>
<p>这就造成了中间空出来的空间。虽然一个struct只要17个字节，但是像这样写C语言，存储的时候却需要24的字节</p>
<p>为什么要对齐？</p>
<p>因为数据不一定放在内存里，而放在cache里面，从 cache里面取数据会比内存里取快很多。cache是很小的，一个cache line是64个byte。我们希望当取一个struct的时候，我们希望这个数据项不要跨两个cache，而放在一个 cache line里面。如果一个结构跨cache line存储，那么取了一条cache line，还有一条在外面：这样就导致即没有让速度变快，又浪费了cache line。这种情况叫做 miss,会极大的影响机器的性能。</p>
<p>所以对于struct来说，我们宁可空出一段内存，也要让cache的命中率增加，从而提升整个程序的运算速度。</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/14.png" style="zoom:90%;"></p>
<p>对于一个结构数组，我们发现，即使是把最大的数据放在前面，满打满算用完17个字节，在存储的时候仍然要在最后补上空白的一些空间。这是因为要将整个struct大小补全到8的倍数，这里是24个字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">short <span class="title">get_j</span><span class="params">(<span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a[idx].j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># %rdi &#x3D; idx</span><br><span class="line">leaq 	(%rdi,%rdi,2),%rax 	# 3*idx</span><br><span class="line">movzwl 	a+8(,%rax,4),%eax</span><br></pre></td></tr></table></figure>
<p>在某种情况下，我们可以节省空间：</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/15.png" style="zoom:90%;"></p>
<h2 id="在机器及程序中将控制和数据结合起来"><a href="#在机器及程序中将控制和数据结合起来" class="headerlink" title="在机器及程序中将控制和数据结合起来"></a>在机器及程序中将控制和数据结合起来</h2><h3 id="Memory-Layout"><a href="#Memory-Layout" class="headerlink" title="Memory Layout"></a>Memory Layout</h3><p>在CSAPP的第一篇文章中我就讲过一个程序中不同的变量等在内存中的分布。现在我们在来复习一下。</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/16.png" style="zoom:90%;"></p>
<p>这里所说的Memory是 address space之意，是虚拟内存</p>
<p>首先我们来看 Shared Libraries，这里存放的是一些库函数、头文件之类的。即不是我们自己写的代码</p>
<p>然后我们看看Stack，stack有8M的内存空间，朝着低地址伸展。Stack中主要存放的是局部变量等数据</p>
<p>Heap和Stack不同，它是向上生长的。主要存放的是动态分配出来的内存，比如C++中new出来的、C中malloc() 出来的地址空间</p>
<p>然后是Data区域，Data主要存放的是静态变量和全局变量。这里我们要再声明一下静态变量和全局变量的区别：</p>
<p>1、全局变量在整个工程文件内都有效；</p>
<p>2、静态全局变量 只在定义它的文件内有效；</p>
<p>3、<strong>静态局部变量只在定义它的函数内有效，且程序仅分配一次内存</strong>，函数返回后，该变量不会消失；局部变量在定义它的函数内有效，但是函数返回后失效。<br>4、<strong>全局变量</strong>和静态变量如果没有手工初始化，则由编译器初始化为0。局部变量的值不可知。</p>
<p>5、<strong>静态局部变量</strong>与<strong>全局变量</strong>共享全局数据区，<strong>但静态局部变量只在定义它的函数中可见</strong>。静态局部变量与局部变量在存储位置上不同，使得其存在的时限也不同，导致对这两者操作 的运行结果也不同。</p>
<p>最后一个Text区域是代码区，里面存放着我们写的这个文件的代码。</p>
<p>我们来看一个具体的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> big_array[<span class="number">1L</span>&lt;&lt;<span class="number">24</span>]; <span class="comment">/* 16 MB */</span></span><br><span class="line"><span class="keyword">char</span> huge_array[<span class="number">1L</span>&lt;&lt;<span class="number">31</span>]; <span class="comment">/* 2 GB */</span></span><br><span class="line"><span class="keyword">int</span> global = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">useless</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *phuge1, *psmall2, *phuge3, *psmall4;</span><br><span class="line">    <span class="keyword">int</span> local = <span class="number">0</span>;</span><br><span class="line">    phuge1 = <span class="built_in">malloc</span>(<span class="number">1L</span> &lt;&lt; <span class="number">28</span>); <span class="comment">/* 256 MB */</span></span><br><span class="line">    psmall2 = <span class="built_in">malloc</span>(<span class="number">1L</span> &lt;&lt; <span class="number">8</span>); <span class="comment">/* 256 B */</span></span><br><span class="line">    phuge3 = <span class="built_in">malloc</span>(<span class="number">1L</span> &lt;&lt; <span class="number">32</span>); <span class="comment">/* 4 GB */</span></span><br><span class="line">    psmall4 = <span class="built_in">malloc</span>(<span class="number">1L</span> &lt;&lt; <span class="number">8</span>); <span class="comment">/* 256 B */</span></span><br><span class="line">    <span class="comment">/* Some print statements ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">not</span> drawn to scale</span><br></pre></td></tr></table></figure>
<p>big_array 和 huge_array,global 是全局变量，应该放到Data当中</p>
<p>useless() 是一个函数，属于我们写的代码，所以放到Text当中</p>
<p>local 是局部变量，放到栈中</p>
<p>phuge1，psmall2,phuge3,psmall4 是malloc盛情的指针。所以它们会放到Heap中去</p>
<p>下面是一个让栈溢出的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recurse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">1</span>&lt;&lt;<span class="number">15</span>]; <span class="comment">// 4*2^15 = 128 KiB</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x = %d. a at %p\n"</span>, x, a);</span><br><span class="line">    a[<span class="number">0</span>] = (<span class="number">1</span>&lt;&lt;<span class="number">14</span>)<span class="number">-1</span>;</span><br><span class="line">    a[a[<span class="number">0</span>]] = x<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[a[<span class="number">0</span>]] == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> recurse(a[a[<span class="number">0</span>]]) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次递归，函数都会开一个大小为128KB的数组。</p>
<p>最后的运行结果如下，如果x等于67输入，到最后一次分配内存的时候，数组会撑满8M的栈空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;runaway 67</span><br><span class="line">x &#x3D; 67. a at 0x7ffd18aba930</span><br><span class="line">x &#x3D; 66. a at 0x7ffd18a9a920</span><br><span class="line">x &#x3D; 65. a at 0x7ffd18a7a910</span><br><span class="line">x &#x3D; 64. a at 0x7ffd18a5a900</span><br><span class="line">. . .</span><br><span class="line">x &#x3D; 4. a at 0x7ffd182da540</span><br><span class="line">x &#x3D; 3. a at 0x7ffd182ba530</span><br><span class="line">x &#x3D; 2. a at 0x7ffd1829a520</span><br></pre></td></tr></table></figure>
<h3 id="Buffer-Overflow"><a href="#Buffer-Overflow" class="headerlink" title="Buffer Overflow"></a>Buffer Overflow</h3><p>我们现在来看一个向上溢出的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">double</span> d;	</span><br><span class="line">&#125; <span class="keyword">struct_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">struct_t</span> s;</span><br><span class="line">	s.d = <span class="number">3.14</span>;</span><br><span class="line">	s.a[i] = <span class="number">1073741824</span>; <span class="comment">/* Possibly out of bounds */</span></span><br><span class="line">	<span class="keyword">return</span> s.d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，这个struct s是放在栈里面的，我们之前说栈里面的元素是按照低地址到高地址排列的，画出来就是从下到上排列的。示意图如下 ：</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/1.jpg" style="zoom:90%;"></p>
<p>现在我们调用fun(8),会出现segmentation fault,因为a[8] 已经向上冲出这个结构趋于了，因此我们将这个现象叫做 stack overflow</p>
<p>如果调用 fun(0) 或者 fun(1),返回值是3.14，很正常。</p>
<p>但是如果调用 fun(2) 返回值变成了：3.1399998665 为什么是这个答案？</p>
<p>这就要考虑到double 这个浮点数在栈里面是怎么放的：如下图</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/2.jpg" style="zoom:90%;"></p>
<p>当我们调用fun(2)，其结果就是将double d中的部分M修改成了 1073741824。也就是说我们对这个浮点数的小数部分进行了修改，但是并没有修改其符号和阶码。因此我们看到结果是仅仅影响了一些精度，并没有影响很大。</p>
<p>当我们调用 fun(3),那么就是对上面的S、E、M都进行了修改，但是如果运气足够好，事实上和原来的值相差也不是很大。这李调用fun(3) 返回的值是 2.0000006104</p>
<p>fun(4)到fun(7)我们看到栈里面放的是Critical State,这时候还不会立马报segmentation fault，而是会提醒我们 Stack smashing detected</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/17.png" style="zoom:90%;"></p>
<p>还有一种情况，是这样的:</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/18.png" style="zoom:90%;"></p>
<p>我们调用fun(8),结果反而又对了，这就好比一开始我们撞墙了(segmentation fault) ，那么我们干脆直接写到墙的另外一端去，反而对结构内的数据不影响了。</p>
<p>如果出现这样的问题，通常我们将其称为 buffer overflow。我们通过调试是很难发现的。这种错误是非常微小但在某些情况下是非常致命的。</p>
<p>接下来我们通过几个例子来看看如何攻击一个不安全的代码和如何来保护我们的代码不受他人攻击</p>
<h3 id="Vulnerability-弱点"><a href="#Vulnerability-弱点" class="headerlink" title="Vulnerability 弱点"></a>Vulnerability 弱点</h3><p>我们先举几个例子：</p>
<p>C语言标准库里有一个gets函数，这个函数的写法如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get string from stdin */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *dest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getchar();</span><br><span class="line">    <span class="keyword">char</span> *p = dest;</span><br><span class="line">    <span class="keyword">while</span> (c != EOF &amp;&amp; c != <span class="string">'\n'</span>) &#123;</span><br><span class="line">    	*p++ = c;	</span><br><span class="line">    	c = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	*p = <span class="string">'\0'</span>;</span><br><span class="line">	<span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数是说，如果没有结束或者回车的话，gets会一直读入字符。看起来没有问题，但是这个函数<strong>没有检查</strong>这个指针 *dest  指向的地址以及地址之后的一段地址是合法的还是非法的。</p>
<p>正确的应该是我们应该malloc一段地址来存放string，如果输入的string大于malloc的大小，函数就会报越界。</p>
<p>同样的：</p>
<p>strcpy, strcat: Copy strings of arbitrary length<br>scanf, fscanf, sscanf, when given %s conversion specification</p>
<p>这些函数都存在着一些问题。</p>
<p>在实际的例子中，比如这个函数，按照设想来说我们只开了一个 4个byte的字符数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Echo Line */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4</span>]; <span class="comment">/* Way too small! */</span></span><br><span class="line">    gets(buf);</span><br><span class="line">    <span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_echo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	echo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，我们这样输入，却不会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unix&gt;.&#x2F;bufdemo-nsp</span><br><span class="line">Type a string:01234567890123456789012</span><br><span class="line">01234567890123456789012</span><br></pre></td></tr></table></figure>
<p>而再多输入一个字符，函数就会报segmentation fault</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unix&gt;.&#x2F;bufdemo-nsp</span><br><span class="line">Type a string:012345678901234567890123</span><br><span class="line">012345678901234567890123</span><br><span class="line">Segmentation Fault</span><br></pre></td></tr></table></figure>
<p>前面不报错的原因是地址上可能有一部分原来就是合法的，那你读取的话也无伤大雅，关键是我们不知道程序什么时候会报segmentation fault</p>
<p>现在我们来看看这个程序运行的机制：</p>
<p>首先我们将其反编译：</p>
<p><strong>echo</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">000000000040069c &lt;echo&gt;:</span><br><span class="line">40069c: 48 83 ec 18 		sub 		$0x18,%rsp</span><br><span class="line">4006a0: 48 89 e7 			mov 		%rsp,%rdi</span><br><span class="line">4006a3: e8 a5 ff ff ff 		callq 		40064d &lt;gets&gt;</span><br><span class="line">4006a8: 48 89 e7 			mov 		%rsp,%rdi</span><br><span class="line">4006ab: e8 50 fe ff ff 		callq		400500 &lt;puts@plt&gt;</span><br><span class="line">4006b0: 48 83 c4 18 		add 		$0x18,%rsp</span><br><span class="line">4006b4: c3 					retq</span><br></pre></td></tr></table></figure>
<p><strong>call_echo</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4006b5: 48 83 ec 08 		sub 		$0x8,%rsp</span><br><span class="line">4006b9: b8 00 00 00 00 		mov 		$0x0,%eax</span><br><span class="line">4006be: e8 d9 ff ff ff 		callq 		40069c &lt;echo&gt;</span><br><span class="line">4006c3: 48 83 c4 08 		add 		$0x8,%rsp</span><br><span class="line">4006c7: c3 					retq</span><br></pre></td></tr></table></figure>
<p>再调用gets之前，这个echo函数栈帧如下：最上面的是caller也就是call_echo的栈帧。接下来是一段return address也就是返回的地址。然后是20个未被使用但是合法的bytes(这也是为什么我们之前输入了23个数字仍然没有报错的原因了) ，最后是我们申请的 buf 数组。</p>
<p>像之前我们输入了23个数字，加上\0刚好将unused 部分和buf数组全部填满。这时候是不会报错的。但是如果我输入24个数字，那么有一个数字就会冲出合法的数组，将返回地址改写。但是返回地址的内容是会收到保护的，于是整个程序就会崩溃，报return地址出错。</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/19.png" style="zoom:90%;"></p>
<p>从上面的汇编语言可以得出，call_echo在0x4006be处调用了echo，所以echo的返回地址是 0x4006c3</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/20.png" style="zoom:90%;"></p>
<p>这是我输入23个数字后，栈帧的结构，我们发现除了buf数组被填满了，20个未被使用的buf也被填满了。</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/21.png" style="zoom:90%;"></p>
<p>如果我输入了24个数进去，我们就会发现返回地址中的低位被修改了。结果就是返回到了一个非法的地址上去，程序崩溃。</p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/23.png" style="zoom:90%;"></p>
<p>由此我们可以得出，如果有些别有用心的人通过查看你的代码，计算你的栈帧并将你的返回地址修改成某段他希望跳转到的地址，这样你的程序就会变得非常不安全。之后的attacklab就要求我们去攻击那些不是非常安全的代码。而在我们写程序的时候，我们要做的就是对我们的程序进行一个保护。</p>
<h3 id="Protection"><a href="#Protection" class="headerlink" title="Protection"></a>Protection</h3><h4 id="Avoid-overflow-vulnerabilities"><a href="#Avoid-overflow-vulnerabilities" class="headerlink" title="Avoid overflow vulnerabilities"></a>Avoid overflow vulnerabilities</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Echo Line */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">4</span>];</span><br><span class="line">    fgets(buf, <span class="number">4</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>For example, use library routines that limit string lengths</p>
<ul>
<li>fgets instead of gets</li>
<li>strncpy instead of strcpy</li>
<li>Don’t use scanf with %s conversion specification<ul>
<li>Use fgets to read the string</li>
<li>Or use %ns where n is a suitable integer</li>
</ul>
</li>
</ul>
<h4 id="Employ-system-level-protections"><a href="#Employ-system-level-protections" class="headerlink" title="Employ system-level protections"></a>Employ system-level protections</h4><p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/24.png" style="zoom:90%;"></p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/25.png" style="zoom:90%;"></p>
<h4 id="Have-compiler-use-“stack-canaries”"><a href="#Have-compiler-use-“stack-canaries”" class="headerlink" title="Have compiler use “stack canaries”"></a>Have compiler use “stack canaries”</h4><p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/26.png" style="zoom:90%;"></p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/27.png" style="zoom:90%;"></p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/28.png" style="zoom:90%;"></p>
<p><img src="/2020/10/20/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA3/29.png" style="zoom:90%;"></p>
<h2 id="浮点代码"><a href="#浮点代码" class="headerlink" title="浮点代码"></a>浮点代码</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/10/15/Naive-Bayes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/15/Naive-Bayes/" class="post-title-link" itemprop="url">Naive_Bayes</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-10-15 20:15:58 / Modified: 20:16:00" itemprop="dateCreated datePublished" datetime="2020-10-15T20:15:58+08:00">2020-10-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/10/14/SVM-and-KernelSVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/14/SVM-and-KernelSVM/" class="post-title-link" itemprop="url">SVM_and_KernelSVM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-14 21:46:11" itemprop="dateCreated datePublished" datetime="2020-10-14T21:46:11+08:00">2020-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-21 16:17:32" itemprop="dateModified" datetime="2020-10-21T16:17:32+08:00">2020-10-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="SVM-and-KernelSVM"><a href="#SVM-and-KernelSVM" class="headerlink" title="SVM and KernelSVM"></a>SVM and KernelSVM</h1><h2 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h2><p>部分文字摘自 <a href="https://www.jianshu.com/p/0b09dc432081" target="_blank" rel="noopener">https://www.jianshu.com/p/0b09dc432081</a></p>
<p>现在我们仍然有两类，一类红点一类绿点</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/1.png" style="zoom:80%;"></p>
<p>现在我们要做的是如何将这两种数据准确的分隔开来。看图像其实很简单，可以横着画一条直线或者竖着画或者斜着画都能将其分隔开来。那么svm要做的就是找到最佳的一条直线。</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/2.png" style="zoom:80%;"></p>
<p>那么这条直线要满足的特点是它和红组和绿组有最大的间隔。所谓最大间隔就是红组中离直线最近的点的距离和绿组中离直线最近的距离最大。这两个点就叫做Support Vector。这里解释下为什么叫支持向量，首先“支持”的意思，就是说这些数据点中除了两个点之外的任何一个点都不会影响到这个算法的决策边界，即这条直线实际上是由这两个点支持的，然后“向量”，在二维空间中的点实际上都可以用向量表示，但在高维中没办法用几何方式表示出来，它其实都是向量。</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/3.png" style="zoom:80%;"></p>
<p>对于这条直线，我们称作Maximum Margin Hyperplane/Classifier，即<strong>最大间隔超平面</strong>。所谓超平面就是比数据空间少一维的空间，比如这里二维的那么对应的就是一维的即一条直线。其中和这条直线平行的这两条直线，一个叫做正向超平面，一个叫负向超平面，这个正负这里只是跟法向量有关，是数学上的概念，不用太在意正负。</p>
<p>接下来看看这个SVM算法为什么这么特别(与其他的算法相比）：</p>
<p>这里假设我们需要训练一个算法来识别苹果和橘子，比如通过水果的颜色和水分来判断。那么大部分的苹果都是青色或者红色，而橘子一般是黄色。那么在图像中可以当作这个横轴代表颜色，x1越往右的就是颜色偏黄色的，那么这部分数据显然都是橘子。</p>
<p>在其他的机器学习算法中，机器只会关注特别经典的数据，比如说下图中圈出来的两部分。也就是其他算法都只关注非常红、非常绿的苹果或者非常黄的橙子。</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/4.png" style="zoom:80%;"></p>
<p>但是SVM却不一样了。SVM最特别的地方就是它可以学习到最特殊最特别的东西，比如说这个时候出现了一个黄色的苹果，很像橘子。那么这样的苹果就是SVM中的支持向量，同样如果这时有个绿色的橘子也是支持向量。因此SVM其实是由数据中比较极端的个例所实现的。这点和其他的算法有根本的不同。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>我们用的还是老的数据集,所以前面的代码都可以照抄 <a href="https://jasonxqh.github.io/2020/10/11/Logistic-Regression/">逻辑回归</a>中的代码，只需要改建模这一块即可</p>
<p>这里我们要用的还是线性的核函数，所以我们将kernel 设置为 linear</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line">classifier = SVC(kernel = <span class="string">'linear'</span>,random_state = <span class="number">0</span>)</span><br><span class="line">classifier.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>
<p>然后我们看看SVM的预测情况</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix, accuracy_score</span><br><span class="line">cm = confusion_matrix(y_test, y_pred)</span><br><span class="line">print(cm)</span><br><span class="line">accuracy_score(y_test, y_pred)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[66  2]</span><br><span class="line"> [ 8 24]]</span><br><span class="line"> 0.9</span><br></pre></td></tr></table></figure>
<p>最后来看看可视化之后的样子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line">X_set, y_set = sc.inverse_transform(X_train), y_train</span><br><span class="line">X1, X2 = np.meshgrid(np.arange(start = X_set[:, <span class="number">0</span>].min() - <span class="number">10</span>,</span><br><span class="line">                               stop = X_set[:, <span class="number">0</span>].max() + <span class="number">10</span>,</span><br><span class="line">                               step = <span class="number">0.25</span>),</span><br><span class="line">                     np.arange(start = X_set[:, <span class="number">1</span>].min() - <span class="number">1000</span>,</span><br><span class="line">                               stop = X_set[:, <span class="number">1</span>].max() + <span class="number">1000</span>,</span><br><span class="line">                               step = <span class="number">0.25</span>))</span><br><span class="line">plt.contourf(X1, </span><br><span class="line">             X2,</span><br><span class="line">             classifier.predict(sc.transform(np.array([X1.ravel(), X2.ravel()]).T)).reshape(X1.shape),</span><br><span class="line">             alpha = <span class="number">0.75</span>, cmap = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>)))</span><br><span class="line">plt.xlim(X1.min(), X1.max())</span><br><span class="line">plt.ylim(X2.min(), X2.max())</span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> enumerate(np.unique(y_set)):</span><br><span class="line">    plt.scatter(X_set[y_set == j, <span class="number">0</span>], </span><br><span class="line">                X_set[y_set == j, <span class="number">1</span>],</span><br><span class="line">                c = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>))(i), </span><br><span class="line">                label = j)</span><br><span class="line">plt.title(<span class="string">'SVM (Training set)'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Age'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Estimated Salary'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/14/SVM-and-KernelSVM/6.png" style="zoom:100%;"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line">X_set, y_set = sc.inverse_transform(X_test), y_test</span><br><span class="line">X1, X2 = np.meshgrid(np.arange(start = X_set[:, <span class="number">0</span>].min() - <span class="number">10</span>, </span><br><span class="line">					stop = X_set[:, <span class="number">0</span>].max() + <span class="number">10</span>, </span><br><span class="line">					step = <span class="number">0.25</span>),</span><br><span class="line">                    np.arange(start = X_set[:, <span class="number">1</span>].min() - <span class="number">1000</span>, </span><br><span class="line">                    stop = X_set[:, <span class="number">1</span>].max() + <span class="number">1000</span>,</span><br><span class="line">                    step = <span class="number">0.25</span>))</span><br><span class="line">plt.contourf(X1,</span><br><span class="line">             X2, </span><br><span class="line">             classifier.predict(sc.transform(np.array([X1.ravel(), X2.ravel()]).T)).reshape(X1.shape),</span><br><span class="line">             alpha = <span class="number">0.75</span>,</span><br><span class="line">             cmap = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>)))</span><br><span class="line">plt.xlim(X1.min(), X1.max())</span><br><span class="line">plt.ylim(X2.min(), X2.max())</span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> enumerate(np.unique(y_set)):</span><br><span class="line">    plt.scatter(X_set[y_set == j, <span class="number">0</span>],</span><br><span class="line">                X_set[y_set == j, <span class="number">1</span>], </span><br><span class="line">                c = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>))(i),</span><br><span class="line">                label = j)</span><br><span class="line">plt.title(<span class="string">'SVM (Test set)'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Age'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Estimated Salary'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/14/SVM-and-KernelSVM/7.png" style="zoom:100%;"></p>
<h2 id="Kernel-SVM"><a href="#Kernel-SVM" class="headerlink" title="Kernel SVM"></a>Kernel SVM</h2><p>SVM是让我们在两组数据中划出一条分界线，那么如果我们没办法再两组数据中滑出一条分界线怎么办?</p>
<p>对于非线性的数据，我们又该怎么办？因此我们须要改良SVM算法，这就是接下来的 和函数支持向量机(Kernel SVM)</p>
<h3 id="高维投射"><a href="#高维投射" class="headerlink" title="高维投射"></a>高维投射</h3><p>对于下面这些离散的非线性的数据，我们是没有办法直接画一条线将它们分割开的</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/8.png" style="zoom:100%;"></p>
<p>所以我们该怎么办？首先，我们先将线性不可分的数据从低维投射到高维，使得其在高维上线性可分，接下来再将分隔好的数据投射到原先低维的空间。</p>
<p>这里先举一个一维的问题。这里有一条直线上，有红色和绿色的点，这条直线上是否存在一个点将红点和绿点分开。显然是无法做到的，那么需要将其投射到二维空间上。</p>
<p> <img src="/2020/10/14/SVM-and-KernelSVM/9.png" style="zoom:100%;"></p>
<p>我们假设红点和绿点在左侧的分界线是5，那么就将其全部减去五然后求其平方得到一根曲线</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/10.png" style="zoom:100%;"></p>
<p>现在，我们就能用一根直线将红点和绿点分开了。</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/11.png" style="zoom:100%;"></p>
<p>那么我们也可以将这个原理运用在二维空间上：</p>
<p> 通过一个很奇怪的映射函数，我们可以将二维的点投射到三维空间上。然后我们就可以找到一个平面(Hyperplane)将两类点分开来</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/12.png" style="zoom:100%;"></p>
<p>然后我们在将其投射到二维空间上，就可以将两类点分开了</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/13.png" style="zoom:100%;"></p>
<p>但由于低维映射到高维然后再让高维投影到低维，对于计算机而言计算量很大，那么我们就需要引入核函数来解决非线性问题，可以绕过这里的繁琐的计算过程，却依然能解决问题。</p>
<h3 id="高斯核函数-RBF"><a href="#高斯核函数-RBF" class="headerlink" title="高斯核函数(RBF)"></a>高斯核函数(RBF)</h3><p>高斯核函数的公式 ：$K(\overrightarrow{x},\overrightarrow{l^i}) = e^{-\frac{||\overrightarrow{x}- \overrightarrow{l^i}||^2}{2\sigma^2}}$</p>
<p>K 代表了 Kernel，也就是对于两个向量核函数。</p>
<p>$\overrightarrow {x}$ 代表了表示点的那个向量</p>
<p>$\overrightarrow{l^i}$ 就是核函数的中心，因为核函数可能有多个中心，所以 $l$ 具有上标 i</p>
<p>$\sigma$ 为函数的宽度参数 , 控制了函数的径向作用范围。</p>
<p> 我们用一个可视化的方式来解释高斯核函数</p>
<p> <img src="/2020/10/14/SVM-and-KernelSVM/14.png" style="zoom:100%;"></p>
<p>我们设坐标(0,0,0) 为和函数的中心（只有一个）。也就是二维平面中绿色区域的中心</p>
<p>那么左边这幅图画就是这些红色和绿色的点通过高斯核函数在三维空间中的映射。</p>
<p>这里从图像也能看出来，红点距离中心点是比较远的，那么 $||\overrightarrow{x}- \overrightarrow{l^i}||^2$ 就会比较大，由于是负数，那么整个方程的结果就会趋向于0.如果x与l距离很接近，那么$||\overrightarrow{x}- \overrightarrow{l^i}||^2$就会趋向于0，加个符号依然趋向于0，那么这个函数就趋向于1.</p>
<p>那么接下来看看如何利用这个函数来寻找数据的分类边界。函数中的l我们可以当作基准点，在上述的数据中如图假设是绿色点的中心，那么很显然，所有的绿色点距离这个点的距离一定是小于某个常数，而红色的点距离它的距离一定大于这个常数。</p>
<p>那么在二维平面，在训练SVM的时候，模型里面就会对”映射出来的” 高维空间画一个圈，这个圈的纵坐标并不是0但是很接近0。在这个圈里面的，也就是z轴大于这个圈的高度的，就属于绿色的点，反之则属于红色的点。</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/15.png" style="zoom:100%;"></p>
<p>那么这个 $\sigma$ ，就决定了函数的径向作用范围。也就是这个”圈“ 的大小。$\sigma $ 是由函数通过训练自己取的。如果 $\sigma$ 增大，那么我们看到就会有更多的原本属于红色的点被划分为绿色去了.<br>反之$\sigma$ 减小，那么很多原本属于绿色的点被划分到红色去了</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/16.png" style="zoom:100%;"></p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/17.png" style="zoom:100%;"></p>
<p>假如说现在我拿到了一个更加复杂的数据集，红点和绿点的分布如下：</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/18.png" style="zoom:100%;"></p>
<p>这时候规定一个中心已经是不可能的了，我们需要确立两个中心</p>
<p>公式就变成了 $K(\overrightarrow{x},\overrightarrow{l^1})+ K(\overrightarrow{x},\overrightarrow{l^2})$</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/19.png" style="zoom:100%;"></p>
<p>对于左边那个中心来说，它只负责左边的绿色的点的核函数大于0；而对于右边绿色的点和所有的红色的点的核函数都等于0；对于右边的中心来说则刚好相反，那么我们就可以用 $K(\overrightarrow{x},\overrightarrow{l^1})+ K(\overrightarrow{x},\overrightarrow{l^2})$ 是否大于0，来判断新的点是属于红色还是属于绿色。</p>
<h3 id="Types-of-Kernel-Functions"><a href="#Types-of-Kernel-Functions" class="headerlink" title="Types of Kernel Functions"></a>Types of Kernel Functions</h3><p>我们要知道有很多种的核函数：它们的功能各不相同</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/20.png" style="zoom:100%;"></p>
<h3 id="Non-Linear-Kernel-SVR"><a href="#Non-Linear-Kernel-SVR" class="headerlink" title="Non-Linear Kernel SVR"></a>Non-Linear Kernel SVR</h3><p>我们假设现在拿到了这样一系列数据：</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/21.png" style="zoom:100%;"></p>
<p>对于这样的数据，我们显然不能用普通的线性支持向量机</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/22.png" style="zoom:100%;"></p>
<p>于是我们采用 Non-Linear SVR,也就是用高斯核来进行拟合。首先画一个二维平面和一个三维空间，并将这些点用高斯核函数映射到三维空间当中去：</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/23.png" style="zoom:100%;"></p>
<p>接着我们就可以根据三维空间中的点来画出 <strong>超平面</strong> 。超平面与核函数相交并投影到二维平面上的曲线就是非线性支持向量机模拟出来的曲线了。</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/24.png" style="zoom:100%;"></p>
<p>那么你也许会问 线性的SVM有 $\epsilon$  ，在非线性空间中是否有呢？ 答案是有的，只不过这时候 $\epsilon$ 变成了平面和平面之间的举例</p>
<p><img src="/2020/10/14/SVM-and-KernelSVM/25.png" style="zoom:100%;"></p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>现在我们利用核函数支持向量机来进行分类：</p>
<p>经过导入、特征缩放之后进行训练</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line">classifier = SVC(kernel = <span class="string">'rbf'</span>, random_state = <span class="number">0</span>)</span><br><span class="line">classifier.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>
<p>然后，我们进行预测：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y_pred = classifier.predict(X_test)</span><br><span class="line">print(np.concatenate((y_pred.reshape(len(y_pred),<span class="number">1</span>), 			</span><br><span class="line">					  y_test.reshape(len(y_test),<span class="number">1</span>)),<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>现在我们看看SVM的混淆矩阵和分数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix, accuracy_score</span><br><span class="line">cm = confusion_matrix(y_test, y_pred)</span><br><span class="line">print(cm)</span><br><span class="line">accuracy_score(y_test, y_pred)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[64  4]</span><br><span class="line"> [ 3 29]]</span><br><span class="line"> </span><br><span class="line">0.93</span><br></pre></td></tr></table></figure>
<p>最后我们来可视化结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line">X_set, y_set = sc.inverse_transform(X_train), y_train</span><br><span class="line">X1, X2 = np.meshgrid(np.arange(start = X_set[:, <span class="number">0</span>].min() - <span class="number">10</span>, </span><br><span class="line">                               stop = X_set[:, <span class="number">0</span>].max() + <span class="number">10</span>, step = <span class="number">0.25</span>),</span><br><span class="line">                     np.arange(start = X_set[:, <span class="number">1</span>].min() - <span class="number">1000</span>, </span><br><span class="line">                               stop = X_set[:, <span class="number">1</span>].max() + <span class="number">1000</span>, step = <span class="number">0.25</span>))</span><br><span class="line">plt.contourf(X1, </span><br><span class="line">             X2,</span><br><span class="line">             classifier.predict(sc.transform(np.array([X1.ravel(), </span><br><span class="line">                                 X2.ravel()]).T)).reshape(X1.shape),</span><br><span class="line">             alpha = <span class="number">0.75</span>,</span><br><span class="line">             cmap = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>)))</span><br><span class="line">plt.xlim(X1.min(), X1.max())</span><br><span class="line">plt.ylim(X2.min(), X2.max())</span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> enumerate(np.unique(y_set)):</span><br><span class="line">    plt.scatter(X_set[y_set == j, <span class="number">0</span>],</span><br><span class="line">                X_set[y_set == j, <span class="number">1</span>],</span><br><span class="line">                c = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>))(i),</span><br><span class="line">                label = j)</span><br><span class="line">plt.title(<span class="string">'Kernel SVM (Training set)'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Age'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Estimated Salary'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/14/SVM-and-KernelSVM/26.png" style="zoom:100%;"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from matplotlib.colors import ListedColormap</span><br><span class="line">X_set, y_set &#x3D; sc.inverse_transform(X_test), y_test</span><br><span class="line">X1, X2 &#x3D; np.meshgrid(np.arange(start &#x3D; X_set[:, 0].min() - 10, </span><br><span class="line">							   stop &#x3D; X_set[:, 0].max() + 10,</span><br><span class="line">                               step &#x3D; 0.25),</span><br><span class="line">                     np.arange(start &#x3D; X_set[:, 1].min() - 1000,</span><br><span class="line">                     		   stop &#x3D; X_set[:, 1].max() + 1000,</span><br><span class="line">                               step &#x3D; 0.25))</span><br><span class="line">plt.contourf(X1, X2, classifier.predict(sc.transform(np.array([X1.ravel(), </span><br><span class="line">			 X2.ravel()]).T)).reshape(X1.shape),</span><br><span class="line">             alpha &#x3D; 0.75,</span><br><span class="line">             cmap &#x3D; ListedColormap((&#39;red&#39;, &#39;green&#39;)))</span><br><span class="line">plt.xlim(X1.min(), X1.max())</span><br><span class="line">plt.ylim(X2.min(), X2.max())</span><br><span class="line">for i, j in enumerate(np.unique(y_set)):</span><br><span class="line">    plt.scatter(X_set[y_set &#x3D;&#x3D; j, 0],</span><br><span class="line">    			X_set[y_set &#x3D;&#x3D; j, 1], </span><br><span class="line">    			c &#x3D; ListedColormap((&#39;red&#39;, &#39;green&#39;))(i), </span><br><span class="line">    			label &#x3D; j)</span><br><span class="line">plt.title(&#39;Kernel SVM (Test set)&#39;)</span><br><span class="line">plt.xlabel(&#39;Age&#39;)</span><br><span class="line">plt.ylabel(&#39;Estimated Salary&#39;)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/14/SVM-and-KernelSVM/27.png" style="zoom:100%;"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/10/13/K-NN%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/13/K-NN%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">K-NN算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-13 21:19:21" itemprop="dateCreated datePublished" datetime="2020-10-13T21:19:21+08:00">2020-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-14 15:08:20" itemprop="dateModified" datetime="2020-10-14T15:08:20+08:00">2020-10-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="K-NN-算法"><a href="#K-NN-算法" class="headerlink" title="K-NN 算法"></a>K-NN 算法</h1><p>K-NN(K-Nearest Neighbors) 算法也是用来分类的，他直观上十分容易理解：</p>
<p><img src="/2020/10/13/K-NN%E7%AE%97%E6%B3%95/1.png" style="zoom:150%;"></p>
<p>现在有两类，分别用红色的加号和绿色的加号描出，现在我们进来了一个新的数据点，我们的目标就是将这个数据点划到哪一类里面去。</p>
<p>比如说下面这个点经过类K-NN 算法，被划归到红色的那一类取了</p>
<p><img src="/2020/10/13/K-NN%E7%AE%97%E6%B3%95/2.png" style="zoom:120%;"></p>
<p>那么K-NN 算法是怎么运作的呢？ 其实很简单</p>
<ol>
<li>STEP1: Choose the number K of neighbors</li>
<li>STEP2: Take the K nearest neighbors of the new data point , according to the Euclidean distance</li>
<li>STEP3: Among these K neighbors ,count the number of data points in each category</li>
<li>STEP4: Assign the new data point to the category where you counted the most neighbors</li>
</ol>
<p>结合上面这个写步骤，我们对刚才的例子进行剖析：</p>
<p>我们现决定要选取5个距离这个点最近的邻居</p>
<p><img src="/2020/10/13/K-NN%E7%AE%97%E6%B3%95/3.png" style="zoom:120%;"></p>
<p>然后计算他和邻居之间的 Euclidean 距离，欧几里得距离的计算公式： $d=\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}$ </p>
<p>然后计算距离这个点最近5个欧几里得距离。在这5个最近的邻居中，属于红色区域的有3个，属于绿色区域的有2个，那么这个点就会被划分到红色区域当中去。</p>
<p><img src="/2020/10/13/K-NN%E7%AE%97%E6%B3%95/4.png" style="zoom:100%;"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>我们使用的数据集：</p>
<p><img src="/2020/10/13/K-NN%E7%AE%97%E6%B3%95/5.png" style="zoom:100%;"></p>
<p>和逻辑回归的思路是一样的，只是换一个模型而已，所以这里略去重复的代码</p>
<h3 id="Training-the-K-NN-model-on-the-Training-set"><a href="#Training-the-K-NN-model-on-the-Training-set" class="headerlink" title="Training the K-NN model on the Training set"></a>Training the K-NN model on the Training set</h3><p>n_neighbors =5 比较常用当然也可以多试试别的值来取最高的准确率</p>
<p>metric = ‘minkowski’ (闵可夫斯基) 就是说距离计算公式运用闵氏距离，是欧氏空间中的一种测度，被看做是欧氏距离和曼哈顿距离的一种推广。 $(\sum_{i=1}^n |x_i-y_i|^p)^{\frac{1}{p}}$</p>
<p>p=2就是 上面这个公式的 p</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line">classifier = KNeighborsClassifier(n_neighbors = <span class="number">5</span>, </span><br><span class="line">                                  metric = <span class="string">'minkowski'</span>, </span><br><span class="line">                                  p = <span class="number">2</span>)</span><br><span class="line">classifier.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>
<p>看一下这个模型的混淆矩阵和准确分数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix, accuracy_score</span><br><span class="line">cm = confusion_matrix(y_test, y_pred)</span><br><span class="line">print(cm)</span><br><span class="line">accuracy_score(y_test, y_pred)</span><br></pre></td></tr></table></figure>
<p>混淆矩阵：</p>
<p>[[64  4]<br> [ 3 29]]<br>准确度：0.93 </p>
<h4 id="Visualising-the-Training-set-results"><a href="#Visualising-the-Training-set-results" class="headerlink" title="Visualising the Training set results"></a>Visualising the Training set results</h4><p>最后用可视化图来看一下结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line">X_set, y_set = sc.inverse_transform(X_train), y_train</span><br><span class="line">X1, X2 = np.meshgrid(np.arange(start = X_set[:, <span class="number">0</span>].min() - <span class="number">10</span>, stop = X_set[:, <span class="number">0</span>].max() + <span class="number">10</span>, step = <span class="number">1</span>),</span><br><span class="line">                     np.arange(start = X_set[:, <span class="number">1</span>].min() - <span class="number">1000</span>, stop = X_set[:, <span class="number">1</span>].max() + <span class="number">1000</span>, step = <span class="number">1</span>))</span><br><span class="line">plt.contourf(X1, X2, classifier.predict(sc.transform(np.array([X1.ravel(), X2.ravel()]).T)).reshape(X1.shape),</span><br><span class="line">             alpha = <span class="number">0.75</span>, cmap = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>)))</span><br><span class="line">plt.xlim(X1.min(), X1.max())</span><br><span class="line">plt.ylim(X2.min(), X2.max())</span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> enumerate(np.unique(y_set)):</span><br><span class="line">    plt.scatter(X_set[y_set == j, <span class="number">0</span>], X_set[y_set == j, <span class="number">1</span>], c = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>))(i), label = j)</span><br><span class="line">plt.title(<span class="string">'K-NN (Training set)'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Age'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Estimated Salary'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/13/K-NN%E7%AE%97%E6%B3%95/6.png" style="zoom:100%;"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line">X_set, y_set = sc.inverse_transform(X_test), y_test</span><br><span class="line">X1, X2 = np.meshgrid(np.arange(start = X_set[:, <span class="number">0</span>].min() - <span class="number">10</span>, stop = X_set[:, <span class="number">0</span>].max() + <span class="number">10</span>, step = <span class="number">1</span>),</span><br><span class="line">                     np.arange(start = X_set[:, <span class="number">1</span>].min() - <span class="number">1000</span>, stop = X_set[:, <span class="number">1</span>].max() + <span class="number">1000</span>, step = <span class="number">1</span>))</span><br><span class="line">plt.contourf(X1, X2, classifier.predict(sc.transform(np.array([X1.ravel(), X2.ravel()]).T)).reshape(X1.shape),</span><br><span class="line">             alpha = <span class="number">0.75</span>, cmap = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>)))</span><br><span class="line">plt.xlim(X1.min(), X1.max())</span><br><span class="line">plt.ylim(X2.min(), X2.max())</span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> enumerate(np.unique(y_set)):</span><br><span class="line">    plt.scatter(X_set[y_set == j, <span class="number">0</span>], X_set[y_set == j, <span class="number">1</span>], c = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>))(i), label = j)</span><br><span class="line">plt.title(<span class="string">'K-NN (Test set)'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Age'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Estimated Salary'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/13/K-NN%E7%AE%97%E6%B3%95/7.png" style="zoom:100%;"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/10/11/Logistic-Regression/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/11/Logistic-Regression/" class="post-title-link" itemprop="url">Logistic_Regression</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-11 15:49:37" itemprop="dateCreated datePublished" datetime="2020-10-11T15:49:37+08:00">2020-10-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-13 14:51:30" itemprop="dateModified" datetime="2020-10-13T14:51:30+08:00">2020-10-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Logistic-Regression"><a href="#Logistic-Regression" class="headerlink" title="Logistic Regression"></a>Logistic Regression</h1><p>学习自：<a href="https://www.jianshu.com/p/3254560624b7" target="_blank" rel="noopener">https://www.jianshu.com/p/3254560624b7</a></p>
<p>我们之前谈论的都是线性回归问题，线性回归问题一般解决的时自变量和应变量存在线性关系的数据。比如说下面这张图。</p>
<p><img src="/2020/10/11/Logistic-Regression/1.png" style="zoom:80%;"></p>
<p>但是对于这种数据，是一些关于年龄信息和客户是否购买产品的数据 线性回归就很难满意的完成我们的任务，因为因变量只有0和1：</p>
<p><img src="/2020/10/11/Logistic-Regression/2.png" style="zoom:80%;"></p>
<p>这时候如果强制线性回归，就会出现这样的结果。</p>
<p><img src="/2020/10/11/Logistic-Regression/3.png" style="zoom:80%;"></p>
<p>这显然不是我们想要的，年龄低于某个值的时候Action变成了负数而高于某个值得时候竟然大于1. 于是，我们要引入分类器的概念，我们现在就来看看第一个分类算法：逻辑回归</p>
<p>逻辑回归可以参考高中生物的逻辑斯蒂增长曲线，公式为 $\ln(\frac{p}{1-p}) = b_0+b_1*x$ (p 代表了是否会发生的概率)</p>
<p>将其应用于上面的数据，我们就会得到一个新的图像，其中y轴的单位是 $\hat p (Probability)$ ,我们可以用这条曲线来预测中间年龄段的人是否会购买产品</p>
<p><img src="/2020/10/11/Logistic-Regression/4.png" style="zoom:150%;"></p>
<p>我们可以看看具体数据，假设当前有几个数据分别是年龄20、30、40、50。那么其在纵坐标上对应的结果也可以标记出来，得到不同的概率。</p>
<p><img src="/2020/10/11/Logistic-Regression/5.png" style="zoom:150%;"></p>
<p>关于年龄和是否会购买的预测，我们可以在 0.5 处画一条直线，在直线下的用户我们可以将其y值设置为0，直线以上的就可以预测用户会购买。</p>
<p><img src="/2020/10/11/Logistic-Regression/6.png" style="zoom:150%;"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>我们下面就对一个比较真实的数据集进行逻辑回归的分类. 其中 Feature是 Age和EstimatedSalary，需要被预测的值是 Purchased。一共有400行数据，没有缺失值，不需要进行数据清洗。</p>
<p>假设你是一家车厂的销售经理，我们拿到了一些之前顾客的年龄和预期薪资和他们的购车情况，我的任务就是去选择什么人群有更多的可能会购买我们车厂新出的车型。</p>
<p><img src="/2020/10/11/Logistic-Regression/7.png" style="zoom:150%;"></p>
<p>接下来我们会一步步进行逻辑回归。以后对于其他数据集，也可以使用这个模板：</p>
<p>首先我们进行导库、训练集测试集切割</p>
<h3 id="Importing-the-Libraries"><a href="#Importing-the-Libraries" class="headerlink" title="Importing the Libraries"></a>Importing the Libraries</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure>
<h3 id="Importing-the-dataset"><a href="#Importing-the-dataset" class="headerlink" title="Importing the dataset"></a>Importing the dataset</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataset = pd.read_csv(<span class="string">'Social_Network_Ads.csv'</span>)</span><br><span class="line">X = dataset.iloc[:, :<span class="number">-1</span>].values</span><br><span class="line">y = dataset.iloc[:, <span class="number">-1</span>].values</span><br></pre></td></tr></table></figure>
<h3 id="Splitting-the-dataset"><a href="#Splitting-the-dataset" class="headerlink" title="Splitting the dataset"></a>Splitting the dataset</h3><p>我们将测试集设为整个数据集的25%，将训练集设为数据集的75%</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = <span class="number">0.25</span>, random_state = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Feature-Scaling"><a href="#Feature-Scaling" class="headerlink" title="Feature Scaling"></a>Feature Scaling</h3><p>然后我们现在要判断是否需要 Feature Scaling</p>
<p>首先我们要知道<strong>逻辑回归模型不一定都要进行特征放缩</strong>(不同于一定要进行放缩的SVM)，但是对一些特征进行放缩可能会提升整个模型的性能。我们就要看看这个数据集的特征是否需要被放缩。</p>
<p>我们这个数据集，有两个Features：年龄和收入，这两者的均值相差很大，肯定不是一个维度下的，于是需要对其进行特征放缩。而预测的是他们是否会购买，值为0或者1，所以不用对预测值进行特征放缩</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">sc = StandardScaler()</span><br><span class="line">X_train = sc.fit_transform(X_train)</span><br><span class="line">X_test = sc.transform(X_test)</span><br></pre></td></tr></table></figure>
<p>我们需要对测试集和训练集都进行特征放缩。</p>
<h3 id="Training-the-Logistic-Regression-model"><a href="#Training-the-Logistic-Regression-model" class="headerlink" title="Training the Logistic Regression model"></a>Training the Logistic Regression model</h3><p>接下来我们来训练逻辑回归模型。很简单，从 sklearn.linear_model 模块中导入LogisticRegression类。</p>
<p>因为现在我们做的是分类而不是回归，所以我们从回归器(regressor) 变成了分类器(classifier).</p>
<p>现在我们知识初步学习一下逻辑回归模型，所以对其中的参数并没有很多的要求，只要将 random_state 设置为0即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line">classifier = LogisticRegression(random_state = <span class="number">0</span>)</span><br><span class="line">classifier.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>
<h3 id="Predicting"><a href="#Predicting" class="headerlink" title="Predicting"></a>Predicting</h3><h4 id="Predicting-a-new-result"><a href="#Predicting-a-new-result" class="headerlink" title="Predicting a new result"></a>Predicting a new result</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(classifier.predict(sc.transform([[<span class="number">30</span>,<span class="number">87000</span>]])))</span><br></pre></td></tr></table></figure>
<p>打印得到 [0]，说明对于30岁，年入87000美元的人来说，他大概率不会购买这辆车。</p>
<h4 id="Predicting-the-Test-set-results"><a href="#Predicting-the-Test-set-results" class="headerlink" title="Predicting the Test set results"></a>Predicting the Test set results</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y_pred = classifier.predict(X_test)</span><br><span class="line">print(np.concatenate((y_pred.reshape(len(y_pred),<span class="number">1</span>),</span><br><span class="line">                      y_test.reshape(len(y_test),<span class="number">1</span>)),<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>然后我们对测试集进行一个预测，并将预测出来的结果和原来的结果进行一个比对。注意，这里要做一个形状转换，将他们都变成竖着排列的。</p>
<p>打印得到：</p>
<p>肉眼可见大多数情况都预测成功了，只有少数几组数据没有预测成功</p>
<p><img src="/2020/10/11/Logistic-Regression/10.png" style="zoom:120%;"></p>
<h3 id="Making-the-Confusion-Matrix"><a href="#Making-the-Confusion-Matrix" class="headerlink" title="Making the Confusion Matrix"></a>Making the Confusion Matrix</h3><p>Confusion Matrix 是混淆矩阵，是表示精度评价的一种标准格式，用n行n列的矩阵形式来表示。具体评价指标有总体精度等。</p>
<p>混淆矩阵的每一列代表了预测类别，每一列的总数表示预测为该类别的数据的数目；每一行代表了数据的真实归属类别，每一行的数据总数表示该类别的数据实例的数目。每一列中的数值表示真实数据被预测为该类的数目</p>
<p>如下图，第一行第一列中的43表示有43个实际归属第一类的实例被预测为第一类，同理，第一行第二列的2表示有2个实际归属为第一类的实例被错误预测为第二类。</p>
<p><img src="/2020/10/11/Logistic-Regression/11.png" style="zoom:120%;"></p>
<p>我们用python的confusion_matrix也可以来做这个模型的混淆矩阵，只要将y_test,y_pred传入即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix, accuracy_score</span><br><span class="line">cm = confusion_matrix(y_test, y_pred)</span><br><span class="line">print(cm)</span><br><span class="line">accuracy_score(y_test, y_pred)</span><br></pre></td></tr></table></figure>
<p>打印得到下面的数据：说明第一类(0)有65组数据预测成功，3组数据预测失败；第二类(1)有24组数据预测成功，8组数据预测失败</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[65  3]</span><br><span class="line"> [ 8 24]]</span><br></pre></td></tr></table></figure>
<p>accuracy_score: </p>
<p>一共有100组数据，11组预测失败，成功的概率为89%，于是accuracy_score = 0.89</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.89</span><br></pre></td></tr></table></figure>
<h3 id="Visualising"><a href="#Visualising" class="headerlink" title="Visualising"></a>Visualising</h3><p>现在我们做一个可视化操作，可以很直观地展现整个模型的效果。我们的图像将达到三个效果</p>
<ul>
<li>我们将用一个2维图展现，其中x轴、y轴分别是年龄和薪资两个特征。</li>
<li>我们将用每一个点表示一个顾客的信息，并用不同的颜色将他们的购买情况区分开来</li>
<li>我们将用颜色区分开两个不同的预测区域，并在中间画出分界线。</li>
</ul>
<h4 id="Visualising-the-Training-set-results"><a href="#Visualising-the-Training-set-results" class="headerlink" title="Visualising the Training set results"></a>Visualising the Training set results</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line">X_set, y_set = sc.inverse_transform(X_train), y_train</span><br><span class="line">X1, X2 = np.meshgrid(np.arange(start = X_set[:, <span class="number">0</span>].min() - <span class="number">10</span>, </span><br><span class="line">                               stop = X_set[:, <span class="number">0</span>].max() + <span class="number">10</span>, </span><br><span class="line">                               step = <span class="number">0.25</span>),</span><br><span class="line">                     np.arange(start = X_set[:, <span class="number">1</span>].min() - <span class="number">1000</span>, </span><br><span class="line">                               stop = X_set[:, <span class="number">1</span>].max() + <span class="number">1000</span>, </span><br><span class="line">                               step = <span class="number">0.25</span>)</span><br><span class="line">                    )</span><br><span class="line">plt.contourf(X1, </span><br><span class="line">             X2,</span><br><span class="line">             classifier.predict(sc.transform(np.array([X1.ravel(), X2.ravel()]).T)).reshape(X1.shape),</span><br><span class="line">             alpha = <span class="number">0.75</span>,</span><br><span class="line">             cmap = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>)))</span><br><span class="line"></span><br><span class="line">plt.xlim(X1.min(),X1.max())</span><br><span class="line">plt.ylim(X2.min(),X2.max())</span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> enumerate(np.unique(y_set)):</span><br><span class="line">    plt.scatter(X_set[y_set == j, <span class="number">0</span>],</span><br><span class="line">                X_set[y_set == j, <span class="number">1</span>],</span><br><span class="line">                c = ListedColormap((<span class="string">'red'</span>, <span class="string">'green'</span>))(i),</span><br><span class="line">                label = j)</span><br><span class="line">plt.title(<span class="string">'Logistic Regression (Training set)'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Age'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Estimated Salary'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/11/Logistic-Regression/8.png" style="zoom:120%;"></p>
<h4 id="Visualising-the-Test-set-results"><a href="#Visualising-the-Test-set-results" class="headerlink" title="Visualising the Test set results"></a>Visualising the Test set results</h4><p><img src="/2020/10/11/Logistic-Regression/9.png" style="zoom:120%;"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/" class="post-title-link" itemprop="url">CSAPP程序的机器即表示2（6~11节）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-11 09:22:59" itemprop="dateCreated datePublished" datetime="2020-10-11T09:22:59+08:00">2020-10-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-25 12:12:25" itemprop="dateModified" datetime="2023-03-25T12:12:25+08:00">2023-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CSAPP程序的机器即表示2"><a href="#CSAPP程序的机器即表示2" class="headerlink" title="CSAPP程序的机器即表示2"></a>CSAPP程序的机器即表示2</h1><h2 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h2><p>通常，C 语言中的语句和机器代码中的指令都是按照它们在程序中出现的次序，顺序执行的。用jump 指令可以改变一组机器代码指令的执行顺序，jump 指令指定控制应该被传递到程序的某个其他部分，可能是依赖于某个测试的结果。编译器必须产生构建在这种低级机制基础之上的指令序列，来实现C 语言的控制结构。</p>
<p>我们先谈谈实现条件操作的两种方式，然后描述表达循环的switch 语句的方法。</p>
<h3 id="条件码"><a href="#条件码" class="headerlink" title="条件码"></a>条件码</h3><p>除了整数寄存器，CPU 还维护着一组<strong>单个位(byte)</strong> 的条件码(condition code) 寄存器。我们可以检测这些寄存器来执行条件分支指令。</p>
<p>一下是最常用的条件码</p>
<p><strong>CF</strong> : 进位标志。最近的操作使高位产生了进位。可用来检查<strong>无符号操作</strong>的<strong>溢出</strong></p>
<p><strong>ZF</strong>: 零标志。最近的操作得出的结果为<strong>0</strong></p>
<p><strong>SF</strong> : 符号标志。最近的操作得到的结果为<strong>负数</strong></p>
<p><strong>OF</strong>: 溢出标志。最近的操作导致一个补码的溢出—-正\负溢出</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/24.png" style="zoom:100%;"></p>
<p>比如说，我们用一条 ADD指令完成等价于C表达式 $t=a+b$ 的功能，a、b、t都是整形的。然后根据下面的C表达式来设置条件码</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/23.png" style="zoom:100%;"></p>
<p> 有几类指令能够修改条件码：</p>
<ol>
<li>算术指令：既改变操作数，也有肯能改变条件码。</li>
<li>CMP指令：右操作数减左操作数，只可能改变条件码。</li>
<li>TEST指令：两操作数相与，只可能改变条件码。</li>
</ol>
<h3 id="访问条件码"><a href="#访问条件码" class="headerlink" title="访问条件码"></a>访问条件码</h3><p>条件码寄存器不能直接读取，有三种方法：</p>
<ul>
<li>set指令：根据条件码，设置一个字节。</li>
</ul>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/25.png" style="zoom:100%;"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">comp</span><span class="params">(<span class="keyword">data_t</span> a,<span class="keyword">data_t</span> b)</span></span></span><br><span class="line">a in %rdi,b in %rsi</span><br><span class="line">comp:</span><br><span class="line"> 	cmpq 	%rsi, 	%rdi 	<span class="comment">//Compare a:b</span></span><br><span class="line"> 	setl 	%al 			<span class="comment">//Set low-order byte of %eax to 0 or 1</span></span><br><span class="line"> 	movzbl 	%al, 	%eax 	<span class="comment">//Clear rest of %eax (and rest of %rax)</span></span><br><span class="line"> 	ret</span><br></pre></td></tr></table></figure>
<p>第二行是cmp指令，也就是通过%rdi-%rsi 的状态来设置状态码的</p>
<p>第三行是 set 指令，setl %al之后，al寄存器中的值就为比较命令 cmp执行后状态位 $SF\wedge  OF$ 的值</p>
<p>第四行是将 %al 赋值给 eax 的低8bits，然后再将eax的高位设置为0</p>
<p>我们就拿sete来举例，即 “set when equal” 指令。</p>
<p>当a = b 时，会得到 $t=0$ ,因此零标志置为就表示相等。</p>
<p>类似的我们来考虑setl,即”set when less” 指令</p>
<p>当没有发生溢出的时候，OF设置为0，那么只有当 $a-b&lt;0$ 的时候，SF会等于1；<br>如果发生了溢出，那么OF设置为1，那么要让a仍然小于b，就要让a为负、b为正，a-b 会下溢变成正数，于是 SF会等于0</p>
<p>那么只有当 SF^OF ，才能保证将每一种情况都包含在内，才能表达出 a&lt;b 是否为真。</p>
<h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><ul>
<li>jump指令：根据条件码进行跳转，即控制的条件转移。</li>
</ul>
<p>跳转指令会导致执行切换到程序中一个全新的位置。在汇编代码中，这些跳转的目的地通常用一个标号(label) 指明.比如说:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	movq $0,%rax 		Set %rax to 0</span><br><span class="line">	jmp .L1 			Goto .L1</span><br><span class="line">	movq (%rax),%rdx 	Null pointer dereference (skipped)</span><br><span class="line">.L1:</span><br><span class="line">	popq %rdx 			Jump target</span><br></pre></td></tr></table></figure>
<p>指令jmp.L1 会导致程序跳过movq 指令，而从popq 指令开始继续执行。在产生目标代码文件时，汇编器会确定所有带标号指令的地址，并将跳转目标（目的指令的地址）编码为跳转指令的一部分。</p>
<p>下面列举了不同的跳转指令：</p>
<ul>
<li>jmp 是无条件跳转，它可以是<strong>直接跳转</strong>，即<strong>跳转目标</strong>是作为指令的<strong>一部分</strong> 编码的。也可以是<strong>间接跳转</strong>，即跳转目标是从寄存器或者内存位置中读出的<ul>
<li>汇编语言中，直接跳转是给出一个标号作为跳转目标的，例如上面所示代码中的标号“.L1”。间接跳转的写法是 ”*“ 后面跟一个操作数指示符</li>
<li>例如 <code>jmp *%rax</code> 用寄存器 %rax 中的值作为跳转目标，而 <code>jmp *(%rax)</code> 是以%rax中的值作为地址，从内存中读取跳转目标。</li>
</ul>
</li>
</ul>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/26.png" style="zoom:100%;"></p>
<p>上表所示的其他跳转指令都是有条件的：它们根据条件码的某种组合，或者跳转，或者继续执行代码序列中下一条指令。这些指令的名字和跳转条件与SET指令的名字和设置条件是相匹配的。</p>
<p>同SET指令一样，一些底层的机器指令有多个名字，<strong>条件跳转只能是直接跳转</strong>。</p>
<ul>
<li>cmov条件传送指令：根据条件码决定是否进行mov操作（其性能要优于控制的条件转移P141）也就是有条件地传送数据。</li>
</ul>
<p>注意点： je 是判断 ZF的，如果ZF=1(计算结果为0) 那么就会跳转；反之，jne是判断 <code>~ZF</code> 的，如果ZF=0(计算结果不为0)，则会跳转</p>
<p>同时我们也应该了解到，<code>sub</code> 和 <code>add</code> 这类指令也会影响符号位，所以说会出现这样的汇编代码：</p>
<p>这段代码我们这么理解： 首先让rdx寄存器中的数字减去1，判断是否为0，若为0则将ZF置为1，若不为0则将ZF置为0。然后用jne进行条件跳转。最后的逻辑就是</p>
<p><code>if rdx-1 != 0</code> 则跳转，等于0则返回。     </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subq	$1, %rdx</span><br><span class="line">jne		.L10</span><br></pre></td></tr></table></figure>
<h3 id="跳转指令的编码"><a href="#跳转指令的编码" class="headerlink" title="跳转指令的编码"></a>跳转指令的编码</h3><p>在汇编代码中，跳转目标用符号标号书写。汇编器，以及后来的链接器，会产生跳转目标的适当编码。跳转指令有几种不同的编码，但是最常用都是<strong>PC-relative</strong>。也就是说它们会将<strong>目标指令的地址</strong>与<strong>紧跟在跳转指令后面那条指令的地址</strong>之间的差作为编码 这些地址偏移量可以编码为1、2 或4 个字节。</p>
<p>第二种编码方法是给出“绝对”地址，用4 个字节直接指定目标。汇编器和链接器会选择适当的跳转目的编码。</p>
<p>下面是一个PC-relative的例子，它包含两个跳转：第二行的jmp指令前向跳转到更高的地址，而第7行的jg指令后向跳转到较低的地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 	movq 	%rdi, %rax</span><br><span class="line"> 	jmp 	.L2</span><br><span class="line">.L3:</span><br><span class="line"> 	sarq 	%rax</span><br><span class="line">.L2:</span><br><span class="line"> 	testq 	%rax, %rax</span><br><span class="line"> 	jg 		.L3</span><br><span class="line"> 	rep; 	ret</span><br></pre></td></tr></table></figure>
<p>仍然是同一个函数，汇编器产生的 “.o” 格式的反汇编版本如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0: 48 89 f8 	mov 	%rdi,%rax</span><br><span class="line">3: eb 03 		jmp 	8&lt;loop+0x8&gt;</span><br><span class="line">5: 48 d1 f8 	sar 	%rax</span><br><span class="line">8: 48 85 c0 	test 	%rax,%rax</span><br><span class="line">b: 7f f8 		jg 		5&lt;loop+0x5&gt;</span><br><span class="line">d: f3 c3 		repz 	retq</span><br></pre></td></tr></table></figure>
<p>我们看到反汇编版本生成的汇编语言没有label，<code>jmp + label</code>的直接跳转也变成了 <code>jmp+地址</code> 的间接跳转。那么我们刚才说了，产生跳转目标的编码是由<strong>目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差</strong>得出的。我们现在就可以来验证这个是否正确。</p>
<p>我们观察到第2行中跳转指令的跳转目标指明为0x8,观察指令的字节编码，会看到第一条跳转指令的目标编码(在第二个字节当中)为0x03 ，然后将其加上<strong>紧跟在跳转指令后面那条指令的地址</strong>0x5 就得到了跳转目标地址0x8 也就是第4行指令的地址。</p>
<p>同样的，第二个跳转指令的目标编码是0xf8(十进制的-8) .将这个数加上<strong>紧跟在跳转指令后面那条指令的地址</strong> 0xd 即得到0x5 ，即第三行指令的地址。</p>
<p>这说明在执行，当执行PC 相对寻址时，程序计数器的值是跳转指令后面的那条指令的地址，而不是跳转指令本身的地址。</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/27.png" style="zoom:100%;"></p>
<p>A:  02+4003fc = 4003fe</p>
<p>B:  因为 0xf4 是-12的补码所以这里是 400431-12 = 400425</p>
<p>C:  根据反汇编器产生的注释，跳转目标是绝对地址 0x400547.那么根据字节编码，一定在距离pop 0x2 的地址处。减去这个值就得到地址 0x400545. 注意，ja指令的编码需要2个字节，它一定位于地址0x400543处。</p>
<p>D: jmpq 是 e9, XXXXXX = 0xffffff73(负数)+0x4005ed =0x400560</p>
<h3 id="用条件控制来实现条件分支"><a href="#用条件控制来实现条件分支" class="headerlink" title="用条件控制来实现条件分支"></a>用条件控制来实现条件分支</h3><p>其实在代码中，我们更多的是要使用控制结构(循环，if-else, switch 等)现在我们要思考怎么用刚学的条件位、comp、jump指令来实现这些控制结构。那么我们一般写的控制结构是没有goto的，因为goto会让程序变得很乱，可读性会变差。但是我们的汇编代码在实现这些控制结构的时候，用了非常类似于goto的代码。只不过goto利用jump来实现。</p>
<p>我们可以先来写一个C语言代码，然后写一个goto风格的C语言代码，最后将其汇编代码贴出。比较一下它们之间的相似于不同。这个函数是让我们求两个整数之间差的绝对值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(a) <span class="function">Original C <span class="title">code</span>								<span class="params">(b)</span> Equivalent <span class="keyword">goto</span> version</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> lt_cnt </span>= <span class="number">0</span>;								<span class="function"><span class="keyword">long</span> <span class="title">gotodiff_se</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y)</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> ge_cnt </span>= <span class="number">0</span>;								&#123;		</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">absdiff_se</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y)</span>						<span class="keyword">long</span> result</span>;</span><br><span class="line">&#123;													<span class="keyword">if</span> (x &gt;= y)</span><br><span class="line">	<span class="keyword">long</span> result;										<span class="keyword">goto</span> x_ge_y;	</span><br><span class="line">	<span class="keyword">if</span> (x &lt; y) &#123;									lt_cnt++;</span><br><span class="line">		lt_cnt++;									result = y - x;</span><br><span class="line">		result = y - x;								<span class="keyword">return</span> result;</span><br><span class="line">	&#125;											  x_ge_y:</span><br><span class="line">	<span class="keyword">else</span> &#123;											ge_cnt++;</span><br><span class="line">		ge_cnt++;									result = x - y;</span><br><span class="line">		result = x - y;								<span class="keyword">return</span> result;</span><br><span class="line">	&#125;											&#125;</span><br><span class="line">	<span class="keyword">return</span> result;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到 b)是goto风格的C语言代码，这类代码在一段语句块之前有一个标签(label) ，只要goto 后面加一个标签名字，那么整个程序就会跳转到那个标签去运行。</p>
<p>那么我们再来看看这个程序产生的汇编代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(c) Generated assembly code</span><br><span class="line"><span class="comment">//long absdiff_se(long x, long y)</span></span><br><span class="line"><span class="comment">//x in %rdi, y in %rsi</span></span><br><span class="line">absdiff_se:</span><br><span class="line">cmpq %rsi, %rdi 						Compare x:y</span><br><span class="line">jge .L2 								If &gt;= <span class="keyword">goto</span> x_ge_y</span><br><span class="line">addq $<span class="number">1</span>, lt_cnt(%rip) 					lt_cnt++</span><br><span class="line">movq %rsi, %rax</span><br><span class="line">subq %rdi, %rax 						result = y - x</span><br><span class="line">ret 									Return<span class="comment">//Return的缺省值就是%rax </span></span><br><span class="line">.L2: x_ge_y:</span><br><span class="line">addq $<span class="number">1</span>, ge_cnt(%rip) 					ge_cnt++</span><br><span class="line">movq %rdi, %rax</span><br><span class="line">subq %rsi, %rax 						result = x - y</span><br><span class="line">ret 									Return</span><br></pre></td></tr></table></figure>
<p>我们看到汇编语言和goto风格的C语言是非常相似的。其实这就是 if- else 控制流在汇编语言中的实现原理。在汇编中我们会使用 jx(jump+条件) 条件跳转命令来模拟goto, 这里的 jge就是当大于等于的时候跳转 ，</p>
<p>对于一个 if-else 语句，在C语言里的模板是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(test-expr)</span><br><span class="line">	then-statement</span><br><span class="line">else</span><br><span class="line">	else-statement</span><br></pre></td></tr></table></figure>
<p>这里的test-expr 是一个整数表达式，他的取值为0或者为非0。这两个分支语句中 (then-statement 或者else-statement) 只会执行一个。</p>
<p>在汇编语言里，通常转换成下面这个模板，我们用C语法来描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t = test-expr;</span><br><span class="line"><span class="keyword">if</span>(!t)</span><br><span class="line">	<span class="keyword">goto</span> <span class="literal">false</span>;</span><br><span class="line">then-statement</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line"><span class="literal">false</span>:</span><br><span class="line">	<span class="keyword">else</span> statement</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>
<p>也就是说，汇编器为 $then-statement$ 和 $else-statement$ 产生了各自的代码块，它会插入条件和无条件的分支，以保证执行正确的代码块</p>
<h3 id="用条件传送来实现条件分支"><a href="#用条件传送来实现条件分支" class="headerlink" title="用条件传送来实现条件分支"></a>用条件传送来实现条件分支</h3><p>现在我们再来看看 General Conditional Expression 也就是条件表达式在汇编语言中的呈现情况</p>
<p>比如下面这句条件表达式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val = x &gt; y ? x-y:y-x;</span><br></pre></td></tr></table></figure>
<p>这句和上面的if-else 的表达效果是一样的，可以被总结为这种模式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val = Tese? Then_Expr : Else_Expr;</span><br></pre></td></tr></table></figure>
<p>那么这句话用goto风格的C语言是这样表现的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	ntest &#x3D; !Test;</span><br><span class="line">	if(ntest) goto ELse;</span><br><span class="line">	val &#x3D; Then_Expr;</span><br><span class="line">	goto Done;</span><br><span class="line">Else:</span><br><span class="line">	val &#x3D; ELse_Expr;</span><br><span class="line">Done:</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>还有一种方法，而是将 Then_Expr 和 Else_Expr 表达式都算出来，然后再做一个判断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = Then_Expr;</span><br><span class="line">eval = Else_Expr;</span><br><span class="line">nt = !Test;</span><br><span class="line"><span class="keyword">if</span>(nt) result = eval;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<p>在这样一个没有goto版本的控制流中，每一步都是顺着往下执行的。</p>
<p>这和刚才的goto版本是不一样的，因为<strong>goto语句会降低程序的性能</strong>。 我们可以这样来解释：<br>        CPU在执行一条语句的时候，事实上已经将后面好几条将要被执行的语句放到cache里面了，然而这时候如果出现了goto语句，cpu就要到内存里面去找goto后面的语句，而cache中的语句这时候就没有用了。而到内存中去找语句的速度是远远慢于直接从cache里面取出语句的，所以多用goto会导致程序的效率低下。所以我们这样写，是为了减少goto语句的发生。</p>
<p>下面来看看goto风格和不用goto的代码之间的差别</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t = test-expr;							result = Then_Expr;</span><br><span class="line"><span class="keyword">if</span>(!t)									eval = Else_Expr;</span><br><span class="line">	<span class="keyword">goto</span> <span class="literal">false</span>;							nt = !Test;</span><br><span class="line">then-<span class="function">statement							<span class="title">if</span><span class="params">(nt)</span> result </span>= eval;</span><br><span class="line"><span class="keyword">goto</span> done;								<span class="keyword">return</span> result;</span><br><span class="line"><span class="literal">false</span>:		</span><br><span class="line">	<span class="keyword">else</span> statement</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>
<p>我们看到如果是 if-else 风格的代码，他只会在then_Expr 和 Else_Expr 中计算一个代码块，但是右边的条件表达式语句则是对then_Expr和Else_Expr 都进行了一个计算。</p>
<p>其实，条件表达式就是<strong>用条件传送来实现条件分支</strong>的一个例子。我们可以来看看它的汇编代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(c) Generated assembly code</span><br><span class="line">long absdiff(long x, long y)</span><br><span class="line">x in %rdi, y in %rsi</span><br><span class="line">absdiff:</span><br><span class="line">	movq %rsi, %rax</span><br><span class="line">	subq %rdi, %rax		rval &#x3D; y-x</span><br><span class="line">	movq %rdi, %rdx</span><br><span class="line">	subq %rsi, %rdx 	eval &#x3D; x-y</span><br><span class="line">	cmpq %rsi, %rdi 	Compare x:y</span><br><span class="line">	cmovge %rdx, %rax 	If &gt;&#x3D;, rval &#x3D; eval</span><br><span class="line">	ret 				Return tval</span><br></pre></td></tr></table></figure>
<p>我们来解释一下这段汇编代码，首先它计算了 y-x和x-y 并分别存储到 rval和eval之中，然后它对x、y进行了一个比较。关键在于汇编代码的第七行 cmovge 指令 实现了 cmovdiff的条件复制。只有当第六行的 cmpq指令表明一个值大于等于另一个值(cmovge最后的ge已经表明) ,才会把数据源寄存器传送到目的。</p>
<p>下图列举了 x86-64上一些可用的传送指令。每条指令都有两个操作数：<strong>源寄存器或者内存地址S </strong>, <strong>目的寄存器R</strong> ,和SET、Jump指令一样，cmov指令的结果取决于条件码的值。源值可以从内存或者源寄存器中读取，但是<strong>只有在指定的条件满足时，指令把原值S复制到目的R</strong>。</p>
<p>源和目的 的值可以是16、32、64 位场。不支持单字节的条件传送。无条件指令的操作数的长度显式地编码在指令名中，汇编器可以从目标寄存器的名字推断出条件传送指令的操作数长度。</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/2.png" style="zoom:80%;"></p>
<p>但是条件表达式也存在很多弊端，这里列出几个例子：</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/1.png" style="zoom:80%;"></p>
<p>第一个就是Else_Expr和Then_Expr 计算起来都非常复杂，导致整行语句要运行非常长的时间</p>
<p>第二个就是如果一个表达式计算起来是非法的话，整个代码就会报错。</p>
<p>最后一个就是如果对x自身进行操作，那么我们就会得到意想不到的结果。比如上图我们的意图是如果 x&gt;0 那么就x是原来的7倍，反之则是原来基础上加3。 事实上因为这两个表达式都被计算了，因此我们不管怎么样得到的答案都是原来的七倍再加上三。</p>
<p>所以在写条件表达式之前我们要想想是否有弊端，否则我们就老老实实去写If-then-else </p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>C语言中有 do-while, while ,for 三种循环结构。但是在汇编语言中没有相应的指令存在。可以通过条件测试和跳转的组合来实现循环的效果。我们先来看看do-while 循环</p>
<h4 id="do-while-循环"><a href="#do-while-循环" class="headerlink" title="do-while 循环"></a>do-while 循环</h4><p>do-while 循环的语句通用模板如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">	body-statement</span><br><span class="line">	<span class="keyword">while</span>(test=expr);</span><br></pre></td></tr></table></figure>
<p>也就是说每次循环程序都会执行循环体中的语句，然后执行测试表达式。如果测试为真，就回去再执行一次循环。我们可以看到 body-statement 至少会执行一次。</p>
<p>用 <code>goto</code> 风格的C语言可以这样改写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loop:</span><br><span class="line">	body-statement</span><br><span class="line">	t = test-expr</span><br><span class="line">	<span class="keyword">if</span>(t)</span><br><span class="line">		<span class="keyword">goto</span> loop;</span><br></pre></td></tr></table></figure>
<p>我们具体举一个例子来分析：这个函数的目的是数一数一个二进制字符串中有几个1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C code												Goto Version</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">pcount_do</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> x)</span>							<span class="keyword">long</span> <span class="title">pcount_do</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> x)</span>					</span></span><br><span class="line"><span class="function"></span>&#123;														&#123;</span><br><span class="line">	<span class="keyword">long</span> result = <span class="number">0</span>;										<span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">do</span>&#123;													  loop:</span><br><span class="line">		result+= x&amp;<span class="number">0x1</span>;										result+= x&amp;<span class="number">0x1</span>;</span><br><span class="line">		x&gt;&gt;=<span class="number">1</span>;		<span class="comment">/*x=x&gt;&gt;1*/</span>								x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;<span class="keyword">while</span>(x);												<span class="keyword">if</span>(x) <span class="keyword">goto</span> loop;</span><br><span class="line">	<span class="keyword">return</span> result;											<span class="keyword">return</span> result;</span><br><span class="line">&#125;														&#125;</span><br></pre></td></tr></table></figure>
<p>那么用汇编语言是这样来表达的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	movl 	$0  ,%eax   		# result &#x3D; 0</span><br><span class="line">.L2:							# loop:</span><br><span class="line">	movq 	%rdi,%rdx</span><br><span class="line">	andl	$1	,%eax			# t &#x3D; x&amp;0x1</span><br><span class="line">	addq 	%rdx,%rax			# result +&#x3D;t</span><br><span class="line">	shrq 	%rdi				# x&gt;&gt;&#x3D;1</span><br><span class="line">	jne		.L2					# if(x) goto loop</span><br><span class="line">	rep;ret</span><br></pre></td></tr></table></figure>
<p>​                                                                                                                                                                                                                                                                                                                                  </p>
<h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>那么while循环可以在do-while循环上修改一下即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (Test)			------&gt;							<span class="keyword">goto</span> test;</span><br><span class="line">	Body											loop:</span><br><span class="line">														Body</span><br><span class="line">													test:</span><br><span class="line">														<span class="keyword">if</span>(Test)</span><br><span class="line">															<span class="keyword">goto</span> loop;</span><br><span class="line">													done:</span><br></pre></td></tr></table></figure>
<p>我们只要一上来直接<code>goto</code> test： 即可。这种方法叫做 <strong>jump to middle</strong></p>
<p>还是一样的例子我们用while重写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C code												Goto Version</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">pcount_while</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> x)</span>						<span class="keyword">long</span> <span class="title">pcount_do</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> x)</span>					</span></span><br><span class="line"><span class="function"></span>&#123;														&#123;</span><br><span class="line">	<span class="keyword">long</span> result = <span class="number">0</span>;										<span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(x)&#123;												<span class="keyword">goto</span> test;</span><br><span class="line">		result+= x&amp;<span class="number">0x1</span>;									  loop: </span><br><span class="line">		x&gt;&gt;=<span class="number">1</span>;		<span class="comment">/*x=x&gt;&gt;1*/</span>								 result += x&amp;<span class="number">0x1</span>;</span><br><span class="line">	&#125;												 		 x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> result;										  test:</span><br><span class="line">    														 <span class="keyword">if</span>(x) <span class="keyword">goto</span> loop;</span><br><span class="line">&#125;														 	 <span class="keyword">return</span> result;	</span><br><span class="line">														&#125;</span><br></pre></td></tr></table></figure>
<p>我们还有第二种翻译方法，称之为 guarded-do, 首先用条件分支，进来就判断，如果初始条件不成立就跳过循环，把代码变换为do-while 循环。当使用较高优化等级编译的时候，例如使用命令行 -O1，GCC就会采用这种策略</p>
<p> 可以用下面这种模板来表达这种方法，把通用的while循环格式翻译成 do-while 循环：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C code												go-to Style</span></span><br><span class="line">t = test-expr;											t = test-expr;</span><br><span class="line"><span class="keyword">if</span> (!t)                        							<span class="keyword">if</span> (!t)  </span><br><span class="line">	<span class="keyword">goto</span> done;												<span class="keyword">goto</span> done;</span><br><span class="line"><span class="keyword">do</span> 														loop:</span><br><span class="line">	body-statement											body-statement</span><br><span class="line">	<span class="keyword">while</span>(test-expr);										t = test-expr;</span><br><span class="line"><span class="function">done														<span class="title">if</span><span class="params">(t)</span></span></span><br><span class="line"><span class="function">    															<span class="keyword">goto</span> loop</span>;</span><br><span class="line">														done:</span><br></pre></td></tr></table></figure>
<p>思考题：<code>jump  to middle</code> 和 <code>guared-do</code> 什么时候是好的，什么时候是不好的？</p>
<p> guarded-do 是直接进行判断。这个之所以更加高效，是因为一开始进入循环时，通常不会不满足循环条件，即一开始不会跳转到后面，所以会直接顺序一直执行循环体。</p>
<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>for循环是我们很常用的一种循环体，其特点就是结束时间很明确，每一步都很标准。而while则更加自由。</p>
<p>for循环的模板：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(init;Test;Update)</span><br><span class="line">	Body</span><br></pre></td></tr></table></figure>
<p>我们需要的就是将 for 循环转换成 while循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Init;</span><br><span class="line"><span class="keyword">while</span>(Test)&#123;</span><br><span class="line">	Body</span><br><span class="line">	Update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有很多表达式 ，还是拿原来的例子说</p>
<p>初始条件 Init:  <code>i=0</code></p>
<p>测试条件 Test:  <code>i&lt;WSIZE</code></p>
<p>更新跳步 Update: <code>i++</code></p>
<p>循环主题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="built_in">bit</span> = (x&gt;&gt;i)&amp;<span class="number">0x1</span>;</span><br><span class="line">	retult += <span class="built_in">bit</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据上面的模板，我们可以对这段代码进行一个转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">pcount_for_while</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> i;</span><br><span class="line">	<span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">	i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;WSIZE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="built_in">bit</span> = (x&gt;&gt;i)&amp;<span class="number">0x1</span>;</span><br><span class="line">		result += <span class="built_in">bit</span>;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以将For循环转换成 Do-While 循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">pcount_for_goto_dw</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> i;</span><br><span class="line">	<span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">	i=<span class="number">0</span>;								<span class="comment">//Init</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	if(!(i&lt;WSIZE))						//可以删除的Test</span></span><br><span class="line"><span class="comment">		goto done;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">  loop:</span><br><span class="line">	<span class="keyword">while</span>(i&lt;WSIZE)						<span class="comment">//Body</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="built_in">bit</span> = (x&gt;&gt;i)&amp;<span class="number">0x1</span>;</span><br><span class="line">		result += <span class="built_in">bit</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	i++;								<span class="comment">//Update</span></span><br><span class="line">	<span class="keyword">if</span>(!(i&lt;WSIZE))						<span class="comment">//Test</span></span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">  done:	</span><br><span class="line">	<span class="keyword">return</span> result;						</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么可以删除第一个Test呢，因为这里for循环第一次肯定是满足条件的。</p>
<h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><p>switch 语句常常用在做命令行下的用户界面或者自动客服。当在写多分叉、较复杂的分支结构时，用if-else会导致可读性下降。</p>
<p>switch 不仅提高了C代码的可读性，而且通过使用跳转表(jump table) 这种数据结构让实现更加高效。GCC根据switch的数量和值的稀疏成都来翻译switch语句。当switch情况数量比较多,且值得范围跨度比较小的时候，就会使用跳转表。</p>
<p>下面是一个Jump Table 示意图</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/3.png" style="zoom:80%;"></p>
<p>我们将每个代码块的地址填到Jump Table里面去。当我们执行switch中的代码块的时候，我们就使用 <code>goto *JTab[x]</code> 命令  <code>*Jtab[x]</code> 就是一段地址，我们会用goto直接跳到这个地址去。</p>
<p>我们来细致得解读一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">my_switch</span><span class="params">(<span class="keyword">long</span> x,<span class="keyword">long</span> y,<span class="keyword">long</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> w=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">switch</span>(x)&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		w = y*z;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		w=y/z;</span><br><span class="line">		<span class="comment">/*Fall Through*/</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		w+=z;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">	<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">		w-=z;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		w=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码编译出来的Jump table和switch得对应关系是这样的：</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/4.png" style="zoom:80%;"></p>
<ul>
<li>当 x==1 的时候：</li>
</ul>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/5.png" style="zoom:80%;"></p>
<ul>
<li>x==2的时候，因为没有break语句，所以执行完case2会继续执行 case3。 这个过程称为 Fall Through</li>
</ul>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/6.png" style="zoom:80%;"></p>
<ul>
<li>x\=\=2 ，x\=\=3 时候的代码块如下：</li>
</ul>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/7.png" style="zoom:80%;"></p>
<ul>
<li>x\=\=5 ,x\=\= 6  和defalut的代码块如下：</li>
</ul>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/8.png" style="zoom:80%;"></p>
<h3 id="Summarizing"><a href="#Summarizing" class="headerlink" title="Summarizing"></a>Summarizing</h3><h4 id="C-Control"><a href="#C-Control" class="headerlink" title="C Control"></a>C Control</h4><p>▪    if-then-else<br>▪    do-while<br>▪    while, for<br>▪    switch</p>
<h4 id="Assembler-Control"><a href="#Assembler-Control" class="headerlink" title="Assembler Control"></a>Assembler Control</h4><p>▪    Conditional jump<br>▪    Conditional move<br>▪    Indirect jump (via jump tables)<br>▪    Compiler generates code sequence to implement more complex control</p>
<h4 id="Standard-Techniques"><a href="#Standard-Techniques" class="headerlink" title="Standard Techniques"></a>Standard Techniques</h4><p>▪    Loops converted to do-while or jump-to-middle form<br>▪    Large switch statements use jump tables<br>▪    Sparse switch statements may use decision trees (if-elseif-elseif-else)</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ul>
<li>Mechanisms</li>
<li>Stack Structure</li>
<li>Calling Conventions<ul>
<li>Passing control</li>
<li>Passing data</li>
<li>Managing local data</li>
</ul>
</li>
<li>Illustration of Recursion</li>
</ul>
<h3 id="Mechanisms-机制"><a href="#Mechanisms-机制" class="headerlink" title="Mechanisms(机制)"></a>Mechanisms(机制)</h3><p>要提供对过程的机器级支持，必须要处理许多不同的属性。为了讨论方便，假设过程P 调用过程Q， Q 执行后返回到P。 这些动作包括下面一个或多个机制：</p>
<ul>
<li>传递控制 ： 在进入过程Q的时候，程序计数器必须被设置为Q 的代码的起始地址，然后在返回时，要把程序计数器设置为p中调用Q后面那条指令的地址。</li>
<li>传递数据： P 必须能够向Q提供一个或者多个参数，Q必须能够向P返回一个值</li>
<li>内存管理：在开始时，Q可能需要为局部变量分配空间，而在返回前，又必须释放这些存储空间。</li>
</ul>
<p>可以简单地说：过程 = 传递控制 + 传递参数 + 分配和释放内存</p>
<p>接下来，我们一步步地构建起不同的机制，先描述控制，再描述数据传递，最后是内存管理。</p>
<h3 id="运行时栈"><a href="#运行时栈" class="headerlink" title="运行时栈"></a>运行时栈</h3><p>首先我们来看看栈结构，右侧长条是地址：</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/9.png" style="zoom:80%;"></p>
<p>我们看到，栈顶指针指向最底下，因为x86-64的栈向低地址方向增长。</p>
<p>将栈放大来看，并标出地址增长和减小的方向：</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/10.png" style="zoom:100%;"></p>
<p>我们可以用 pushq和popq指令来将数据存入栈中或者是从栈中取出。</p>
<h3 id="Push"><a href="#Push" class="headerlink" title="Push"></a>Push</h3><p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/11.png" style="zoom:100%;"></p>
<ul>
<li><p>首先将source中的操作数取出</p>
</li>
<li><p>然后将栈顶指针指向的地址减去8, 因为下移8个byte之后，多出来 8*8 = 64 个bit可以用来存储一个64位的地址</p>
</li>
<li>最后将这个操作数的地址写入栈顶指针</li>
</ul>
<h4 id="Pop"><a href="#Pop" class="headerlink" title="Pop"></a>Pop</h4><p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/12.png" style="zoom:100%;"></p>
<ul>
<li>首先将 %rsp 栈顶指针中的值读出</li>
<li>然后将栈顶指针加上8</li>
<li>最后将读出的值存入到寄存器当中</li>
</ul>
<p>所以不管是 Push还是Pop，都是值改变了 $\%rsp$ 的值，并没有改变内存 。</p>
<h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><p>下面我们仔细谈论栈帧的概念。</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/13.png" style="zoom:100%;"></p>
<p>当过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这个部分称为过程的栈帧(Frame)。上图就是运行时栈的通用结构。</p>
<ul>
<li>当前正在执行的过程的帧总是在栈顶。</li>
<li>当过程P调用过程Q的时候,会把返回地址压入栈中，指明Q返回时，要从p程序的哪个位置继续执行。我们会把这个返回地址当作p的栈帧的一部分，因为他存放的是于P相关的状态。</li>
</ul>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/14.png" style="zoom:100%;"></p>
<ul>
<li>Q 的代码会扩展当前栈的边界，分配它的栈帧所需的空间。在这个空间中，它可以保存寄存器的值，分配局部变量空间，为它调用的过程设置参数。</li>
<li>大多数过程的栈帧都是定长的，在过程的开始就分配好了</li>
<li>通过寄存器，过程P 可以传递最多6 个整数值(也就是指针和整数), 但是如果Q 需要更多的参数，P 可以在调用Q 之前在自己的栈帧里存储好这些参数。</li>
</ul>
<hr>
<h3 id="转移控制"><a href="#转移控制" class="headerlink" title="转移控制"></a>转移控制</h3><p>P调用Q，Q运行完之后返回P，这个函数转移的底层是<strong>用栈实现</strong>的：</p>
<ul>
<li>首先将程序计数器(PC) 设置为 Q 的代码的起始位置。</li>
<li>稍后从Q返回的时候，处理器用指令call Q 调用过程Q来记录好过程P需要继续执行的代码的位置，这个指令会把地址A压入栈中，并将PC设置为Q的起始地址。</li>
<li>压入的地址A被称为返回地址，是紧跟在 call 指令后面的那条指令的地址。对应的指令ret会从栈中弹出地址A,并把pc设置为A</li>
</ul>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/15.png" style="zoom:100%;"></p>
<p>call 指令有一个目标，<strong>即指明被调用过程起始的指令地址</strong>。 调用可以是直接的也可以是间接的。在汇编代码中，直接调用的目标是一个Label，而间接调用的目标是 *加上一个操作数指示符</p>
<p>现在我们用一个具体的例子来理解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Beginning of function multstore</span><br><span class="line">0000000000400540 &lt;multstore&gt;:</span><br><span class="line">400540: 53 					push %rbx</span><br><span class="line">400541: 48 89 d3 			mov %rdx,%rbx</span><br><span class="line">. . .</span><br><span class="line">Return from function multstore</span><br><span class="line">40054d: c3 					retq</span><br><span class="line">. . .</span><br><span class="line">Call to multstore from main</span><br><span class="line">400563: e8 d8 ff ff ff 		callq 400540 &lt;multstore&gt;</span><br><span class="line">400568: 48 8b 54 24 08 		mov 0x8(%rsp),%rdx</span><br></pre></td></tr></table></figure>
<p>从上面这段代码中我们可以看到，在main函数中，地址为 0x400563 的call指令调用函数 multstore. 此时栈中的状态如图所示：</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/16.png" style="zoom:100%;"></p>
<p>调用完call之后，栈中的状态如图：</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/17.png" style="zoom:100%;"></p>
<p>也就是说，call的小姑就是将400563的后一句400568给压入栈中，并跳转到函数multistore的第一条指令，地址为 0x400540. 然后函数multstore继续执行，一直到遇上地址 0x40054d处的ret指令。</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/18.png" style="zoom:100%;"></p>
<p>ret指令从栈中弹出值 0x400568,然后跳转到这个地址，就在call之后一句，然后继续main函数的执行。</p>
<p>再来看看上课居的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multstore</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">long</span> y, <span class="keyword">long</span> *dest)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> t = mult2(x, y); </span><br><span class="line">	*dest = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">mult2</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="keyword">long</span> s = a * b; </span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将其编译成汇编语言，得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0000000000400540 &lt;multstore&gt;:</span><br><span class="line">400540: push	%rbx 			# Save %rbx </span><br><span class="line">400541: mov 	%rdx,%rbx 		# Save dest </span><br><span class="line">400544: callq 	400550 &lt;mult2&gt;	# mult2(x,y) </span><br><span class="line">400549: mov 	%rax,(%rbx)		# Save at dest</span><br><span class="line">40054c: pop 	%rbx			# Restore %rbx</span><br><span class="line">40054d: retq					# Return</span><br><span class="line">0000000000400550 &lt;mult2&gt;:</span><br><span class="line">400550: 	mov  	  %rdi,%rax   	# a </span><br><span class="line">400553:		imul 	  %rsi,%rax		# a * b </span><br><span class="line">400557: 	retq					# Return</span><br></pre></td></tr></table></figure>
<p>首先，运行到0x400544这一段，程序计数器%rip中存储的就是0x400544,他会调用 400550 地址的函数也就是 mult2</p>
<p>call运行完之后，%rip 中的地址变成了 0x400550 ，同时将call的后一句的地址压栈，并修改%rsp 的值</p>
<p>解这运行到了 400557 这行命令，就要return了，return操作是将栈顶取出放入 %rip 并退栈，最后%rip 的值为 0x400549</p>
<h3 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h3><p>当调用一个过程时，除了要把控制传递给它沐在过程返回时再传递回来之外，过程调用还可能包括把数据作为参数传递。我们大部分过程间的数据传送是通过寄存器实现的。</p>
<p>比如当过程P调用过程Q的时候，P的代码必须收i按将参数复制到合适的寄存器中。类似的，当Q返回到P的时候，P的代码可以访问寄存器 %rax 中的返回值。</p>
<p>x86-64中，可以通过寄存器<strong>最多传递6 个整型（例如整数和指针）参数</strong>(Argument)。寄存器的使用是有特殊顺序的.<strong>寄存器是按照特殊顺序来使用的，而使用的名字是根据参数的大小来确定的</strong></p>
<p>比如：可以通过64 位寄存器适当的部分访问小于64 位的参数。如果第一个参数是32 位的，那么可以用％edi 来访问它。</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/19.png" style="zoom:100%;"></p>
<p><strong>重点</strong>：如果一个函数有大于6个整形的参数，超出六个的部分就要通过栈来传递。假设过程P调用过程Q，有n个参数，且n&gt;6.那么p的代码分配的栈帧就必须要能容纳第七到第n号参数的存储空间。</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/14.png" style="zoom:100%;"></p>
<p>通过栈传递参数时，所有的数据大小都<strong>向8的倍数对齐</strong>。参数到位以后，程序就可以执行call指令间控制转移到过程Q了。<strong>过程Q可以通过寄存器访问参数，也可以通过栈来访问</strong>。</p>
<p>相应的，如果Q也调用了某个有超过6个参数的函数，他也需要在自己的栈帧中为超出6个部分的参数分配空间。也就是分配到下图中 “Argument Build Area” (参数构造区) 的区域</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/20.png" style="zoom:100%;"></p>
<p>下面是一个具体的例子：</p>
<p>有多个不同类型参数的函数示例。参数1~6 通过寄存器传递，而参数7~8 通过栈传递</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">(a) C code</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc</span><span class="params">(	<span class="keyword">long</span> a1, <span class="keyword">long</span> *a1p,</span></span></span><br><span class="line"><span class="function"><span class="params">		  	<span class="keyword">int</span> a2, <span class="keyword">int</span> *a2p,</span></span></span><br><span class="line"><span class="function"><span class="params">		  	short a3, short *a3p,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">char</span> a4, <span class="keyword">char</span> *a4p	)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	*a1p += a1;</span><br><span class="line">	*a2p += a2;</span><br><span class="line">	*a3p += a3;</span><br><span class="line">	*a4p += a4;</span><br><span class="line">&#125;</span><br><span class="line">(b) Generated assembly code</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">proc</span><span class="params">(a1, a1p, a2, a2p, a3, a3p, a4, a4p)</span></span></span><br><span class="line"><span class="function">    Arguments passed as follows:</span></span><br><span class="line">        a1 in %rdi (64 bits)</span><br><span class="line">        a1p in %rsi (<span class="number">64</span> bits)</span><br><span class="line">        a2 in %edx (<span class="number">32</span> bits)</span><br><span class="line">        a2p in %rcx (<span class="number">64</span> bits)</span><br><span class="line">        a3 in %r8w (<span class="number">16</span> bits)</span><br><span class="line">        a3p in %r9 (<span class="number">64</span> bits)</span><br><span class="line">        a4 at %rsp+<span class="number">8</span> ( <span class="number">8</span> bits)</span><br><span class="line">        a4p at %rsp+<span class="number">16</span> (<span class="number">64</span> bits)</span><br><span class="line">proc:</span><br><span class="line">	movq <span class="number">16</span>(%rsp), %<span class="function">rax 	Fetch <span class="title">a4p</span> <span class="params">(<span class="number">64</span> bits)</span></span></span><br><span class="line">	addq %rdi, (%rsi)		*a1p += a1 (64 bits)</span><br><span class="line">	addl %edx, (%rcx) 		*a2p += a2 (<span class="number">32</span> bits)</span><br><span class="line">	addw %r8w, (%r9) 		*a3p += a3 (<span class="number">16</span> bits)</span><br><span class="line">	movl <span class="number">8</span>(%rsp), %edx 		Fetch a4 ( <span class="number">8</span> bits)</span><br><span class="line">	addb %dl, (%rax) 		*a4p += a4 ( <span class="number">8</span> bits)</span><br><span class="line">	ret 				    Return</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/21.png" style="zoom:100%;"></p>
<p>可以看到，作为过程调用的一部分，返回地址被压入栈中。因而这两个参数位于相对于<strong>栈指针</strong>距离为8 和16 的位置。在这段代码中，我们可以看到根据操作数的大小，使用了ADD 指令的不同版本：</p>
<ul>
<li><code>al(long)</code>使用<code>addq</code></li>
<li><code>a2(int)</code>使用<code>addl</code></li>
<li><code>a3(short)</code>使用<code>addw</code></li>
<li><code>a4(char)</code>使用<code>addb</code></li>
<li>请注意第6行的<code>movl</code>指令从内存读人4 字节，而后面的<code>addb</code>指令只使用其中的低位一字节。</li>
</ul>
<h3 id="栈上的局部存储"><a href="#栈上的局部存储" class="headerlink" title="栈上的局部存储"></a>栈上的局部存储</h3><p>有些时候，局部数据必须存放在内存中，常见的情况包括：</p>
<ul>
<li>寄存器不足够存放所有的本地数据。</li>
<li>对一个局部变量使用地址运算符 ‘&amp;’，. 因此必须能够为它产生一个地址。</li>
</ul>
<ul>
<li>某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。</li>
</ul>
<p>一般来说，过程通过<strong>减小</strong> 栈指针在栈上分配空间。分配的结果作为栈帧的一部分，标号为”局部变量”</p>
<p>(a) Code for swap_add and calling function</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">swap_add</span><span class="params">(<span class="keyword">long</span> *xp, <span class="keyword">long</span> *yp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> x = *xp;</span><br><span class="line">	<span class="keyword">long</span> y = *yp;</span><br><span class="line">	*xp = y;</span><br><span class="line">	*yp = x;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">caller</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> arg1 = <span class="number">534</span>;</span><br><span class="line">	<span class="keyword">long</span> arg2 = <span class="number">1057</span>;</span><br><span class="line">	<span class="keyword">long</span> sum = swap_add(&amp;arg1, &amp;arg2);</span><br><span class="line">	<span class="keyword">long</span> diff = arg1 - arg2;</span><br><span class="line">	<span class="keyword">return</span> sum * diff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以从下面这段汇编语言分析出caller是如何用栈帧来实现这些局部变量的。</p>
<ul>
<li>代码开始的时候把栈指针减了16，这是在栈上分配了16个字节</li>
<li>将534，1057压栈，可以看到<code>&amp;arg2 = S+8 &amp;arg1 = S</code>.因此可以推断局部变量 arg1和arg2 存放在栈帧中的位置相对于栈顶指针的偏移量为0和8</li>
<li>add调用完成后，caller的代码会从栈上取出这两个值(因为进行过了swap操作，两个地址指向的值已经交换了)，并计算它们的差，再乘以 swap_add 在寄存器 %rax 中返回的值</li>
<li>最后，该函数将栈顶指针加上16来释放栈帧。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">long caller()</span><br><span class="line">caller:</span><br><span class="line">	subq 	$16, %rsp 				Allocate 16 bytes for stack frame</span><br><span class="line">	movq 	$534, (%rsp) 			Store 534 in arg1</span><br><span class="line">	movq 	$1057, 8(%rsp)			Store 1057 in arg2</span><br><span class="line">	leaq 	8(%rsp), %rsi 			Compute &amp;arg2 as second argument</span><br><span class="line">	movq 	%rsp, %rdi 				Compute &amp;arg1 as first argument</span><br><span class="line">	call 	swap_add 				Call swap_add(&amp;arg1, &amp;arg2)</span><br><span class="line">	movq 	(%rsp), %rdx 			Get arg1</span><br><span class="line">	subq 	8(%rsp), %rdx 			Compute diff &#x3D; arg1 - arg2</span><br><span class="line">	imulq 	%rdx, %rax 				Compute sum * diff</span><br><span class="line">	addq 	$16, %rsp 				Deallocate stack frame</span><br><span class="line">	ret 							Return</span><br></pre></td></tr></table></figure>
<p>下面是一个更复杂的例子。它给出了一个必须在栈上分配局部变量存储空间的函数，同时还要向有8个参数的proc传递值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">call_proc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> x1 = <span class="number">1</span>; <span class="keyword">int</span> x2 = <span class="number">2</span>;</span><br><span class="line">short x3 = <span class="number">3</span>; <span class="keyword">char</span> x4 = <span class="number">4</span>;</span><br><span class="line">proc(x1, &amp;x1, x2, &amp;x2, x3, &amp;x3, x4, &amp;x4);</span><br><span class="line"><span class="keyword">return</span> (x1+x2)*(x3-x4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">long call_proc()</span><br><span class="line">call_proc:</span><br><span class="line">&#x2F;&#x2F;Set up arguments to proc</span><br><span class="line">subq 	$32, %rsp 			Allocate 32-byte stack frame</span><br><span class="line">movq 	$1, 24(%rsp) 		Store 1 in &amp;x1</span><br><span class="line">movl 	$2, 20(%rsp) 		Store 2 in &amp;x2</span><br><span class="line">movw 	$3, 18(%rsp) 		Store 3 in &amp;x3</span><br><span class="line">movb 	$4, 17(%rsp) 		Store 4 in &amp;x4</span><br><span class="line">leaq 	17(%rsp), %rax 		Create &amp;x4</span><br><span class="line">movq 	%rax, 8(%rsp) 		Store &amp;x4 as argument 8</span><br><span class="line">movl 	$4, (%rsp) 			Store 4 as argument 7</span><br><span class="line">leaq 	18(%rsp), %r9 		Pass &amp;x3 as argument 6</span><br><span class="line">movl 	$3, %r8d 			Pass 3 as argument 5</span><br><span class="line">leaq 	20(%rsp), %rcx 		Pass &amp;x2 as argument 4</span><br><span class="line">movl 	$2, %edx 			Pass 2 as argument 3</span><br><span class="line">leaq 	24(%rsp), %rsi 		Pass &amp;x1 as argument 2</span><br><span class="line">movl 	$1, %edi			Pass 1 as argument 1</span><br><span class="line">&#x2F;&#x2F;Call proc</span><br><span class="line">call 	proc</span><br><span class="line">&#x2F;&#x2F;Retrieve changes to memory</span><br><span class="line">movslq 	20(%rsp), %rdx 		Get x2 and convert to long</span><br><span class="line">addq 	24(%rsp), %rdx 		Compute x1+x2</span><br><span class="line">movswl 	18(%rsp), %eax 		Get x3 and convert to int</span><br><span class="line">movsbl 	17(%rsp), %ecx 		Get x4 and convert to int</span><br><span class="line">subl 	%ecx, %eax 			Compute x3-x4</span><br><span class="line">cltq 						Convert to long</span><br><span class="line">imulq 	%rdx, %rax 			Compute (x1+x2) * (x3-x4)</span><br><span class="line">addq 	$32, %rsp 			Deallocate stack frame</span><br><span class="line">ret 						Return</span><br></pre></td></tr></table></figure>
<p>可以看到代码中一大部分是为调用proc做准备。其中包括为局部变量和参数建立栈帧，将函数参数加载至寄存器。</p>
<h3 id="寄存器中的局部存储空间"><a href="#寄存器中的局部存储空间" class="headerlink" title="寄存器中的局部存储空间"></a>寄存器中的局部存储空间</h3><h4 id="被调用者保存寄存器"><a href="#被调用者保存寄存器" class="headerlink" title="被调用者保存寄存器"></a>被调用者保存寄存器</h4><p>寄存器 %rbx 、%rbp 和 %r12~%r15 被划分为被调用者保存寄存器</p>
<p>过程P 调用过程 Q 的时候，Q必须保存这些寄存器的值，保证他们的值在Q返回到P时与Q被调用时是一样的。这时候有两种可能性，要门就是根本不去改变它，要么就是把原始值压入栈中，改变寄存器的值，然后再返回前从栈中弹出旧值。</p>
<h4 id="调用者保存寄存器"><a href="#调用者保存寄存器" class="headerlink" title="调用者保存寄存器"></a>调用者保存寄存器</h4><p>除了%rsp和被调用者保存寄存器，剩下的都是调用者保存寄存器。这就意味着任何函数都能修改它们。</p>
<p>可以这样来理解“调用者保存”这个名字：过程P 在某个此类寄存器中有局部数据，然后调用过程Q 因为Q 可以随意修改这个寄存器，所以在调用之前首先保存好这个数据是P(调用者）的责任。</p>
<p>可以看看下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">long(long x,long y)</span><br><span class="line">&#123;</span><br><span class="line">	long u &#x3D; Q(y);</span><br><span class="line">	long v &#x3D; Q(x);</span><br><span class="line">	return u+v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译成汇编代码如下</p>
<p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/22.png" style="zoom:100%;"></p>
<p>可以看出来:%rbp 保存 x %rbx 保存计算出来的Q(y) 的值。</p>
<ul>
<li>在函数的开头，把两个寄存器的值保存到栈中(2~3行) 因为这两个寄存器之前可能有值</li>
<li>第一次调用之前，把参数复制到 %rbp</li>
<li>在第二次调用Q之前，把%rax(第一次计算的结果) 放到%rbx中</li>
<li>在函数的结尾，将 %rbp和%rbx 从栈中弹出，恢复这两个被调用者保存寄存器的值，注意他们的弹出顺序和压入顺序相反。</li>
</ul>
<h3 id="递归过程"><a href="#递归过程" class="headerlink" title="递归过程"></a>递归过程</h3><p>每个过程调用在栈中都有它自己的私有空间，因此多个未完成调用的局部变量不会相互影响。此外，栈的原则很自然地就提供了适当的策略，当过程被调用时分配局部存储，当返回时释放存储。</p>
<p>下面给出了递归的阶乘函数的C代码和汇编代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(a) <span class="function">C <span class="title">code</span>								<span class="params">(b)</span> Generated assembly code <span class="comment">//n in %rdi</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">rfact</span><span class="params">(<span class="keyword">long</span> n)</span>						rfact:</span></span><br><span class="line"><span class="function"></span>&#123;											pushq %rbx 			Save %rbx</span><br><span class="line">    <span class="keyword">long</span> result;							movq %rdi, %rbx		Store n in callee-saved <span class="keyword">register</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)								movl $<span class="number">1</span>, %eax		Set <span class="keyword">return</span> value = <span class="number">1</span></span><br><span class="line">    	result = <span class="number">1</span>;							cmpq $<span class="number">1</span>, %rdi		Compare n:<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>									jle .L35 			If &lt;=, <span class="keyword">goto</span> done</span><br><span class="line">	    result = n * rfact(n<span class="number">-1</span>);			leaq <span class="number">-1</span>(%rdi), %rdi Compute n<span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> result;							<span class="function">call rfact			Call <span class="title">rfact</span><span class="params">(n<span class="number">-1</span>)</span></span></span><br><span class="line">&#125;											imulq %rbx, %rax 	Multiply result by n</span><br><span class="line">										.L35:</span><br><span class="line">											popq %rbx 			Restore %rbx</span><br><span class="line">											ret 				Return</span><br></pre></td></tr></table></figure>
<p>我们可以看到，汇编代码使用寄存器 <code>%rbx</code>来保存参数n，先把已经有的值保存在栈上(2行)随后在返回前恢复该值(12行)</p>
<p>根据栈的使用特性和寄存器保存规则，可以保证当递归调用 <code>rfact(n-1)</code>返回时(第9行) 会发生：</p>
<ul>
<li>该次调用的结果会保存在寄存器 <code>%rax</code> 中</li>
<li>参数n的值仍然存在寄存器 <code>%rbx</code> 中</li>
</ul>
<p>把这两个值相乘就能得到期望的结果</p>
<p>从这个例子我们可以看到，递归调用一个函数本身与调用其他函数是一样的。栈规则提供了一种机制，每次函数调用都有它自己私有的状态信息（保存的返回位置和被调用者保存寄存器的值)存储空间。如果需要，它还可以提供局部变量的存储。栈分配和释放的规则很自然地就与函数调用-返回的顺序匹配。这种实现函数调用和返回的方法甚至对更复杂的情况也适用，包括相互递归调用（例如，过程P 调用Q，Q 再调用P)。</p>
<h2 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h2><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/28.png" style="zoom:100%;"></p>
<h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/29.png" style="zoom:100%;"></p>
<h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/30.png" style="zoom:100%;"></p>
<h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/31.png" style="zoom:100%;"></p>
<h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/32.png" style="zoom:100%;"></p>
<h4 id="6"><a href="#6" class="headerlink" title="6"></a>6</h4><p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/33.png" style="zoom:100%;"></p>
<h4 id="7"><a href="#7" class="headerlink" title="7"></a>7</h4><p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/34.png" style="zoom:100%;"></p>
<h4 id="8"><a href="#8" class="headerlink" title="8"></a>8</h4><p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/35.png" style="zoom:100%;"></p>
<h4 id="9"><a href="#9" class="headerlink" title="9"></a>9</h4><p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/36.png" style="zoom:100%;"></p>
<h4 id="10"><a href="#10" class="headerlink" title="10"></a>10</h4><p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/37.png" style="zoom:100%;"></p>
<h4 id="11"><a href="#11" class="headerlink" title="11"></a>11</h4><p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/38.png" style="zoom:100%;"></p>
<h4 id="12"><a href="#12" class="headerlink" title="12"></a>12</h4><p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/39.png" style="zoom:100%;"></p>
<h4 id="13"><a href="#13" class="headerlink" title="13"></a>13</h4><p><img src="/2020/10/11/CSAPP%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E5%8D%B3%E8%A1%A8%E7%A4%BA2%EF%BC%886-11%E8%8A%82%EF%BC%89/40.png" style="zoom:100%;">z   </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/18/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><span class="page-number current">19</span><a class="page-number" href="/page/20/">20</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/20/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jason</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">439</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    

  

</body>
</html>
