<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=">


  <link rel="mask-icon" href="/images/logo.svg?v=" color="#222">














<meta property="og:type" content="website">
<meta property="og:title" content="Jason‘s Blog">
<meta property="og:url" content="https://jasonxqh.github.io/page/2/index.html">
<meta property="og:site_name" content="Jason‘s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '',
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    fancybox: false,
    tabs: ,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: 'undefined',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>







  <title>Jason‘s Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', '[object Object]', 'auto');
  ga('send', 'pageview');
</script>





<meta name="generator" content="Hexo 4.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">
  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
<a href="https://github.com/JasonXQH/JasonXQH.github.io" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jason‘s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/%20" rel="section">
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2024/11/18/%E5%A4%A7%E8%90%A5%E9%94%80%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84bug%E4%B8%8E%E5%BF%83%E5%BE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/11/18/%E5%A4%A7%E8%90%A5%E9%94%80%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84bug%E4%B8%8E%E5%BF%83%E5%BE%97/" itemprop="url">大营销项目中遇到的bug与心得</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-11-18T13:19:03+08:00">
                2024-11-18
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2025-04-11T10:15:40+08:00">
                2025-04-11
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="大营销项目中遇到的bug与心得"><a href="#大营销项目中遇到的bug与心得" class="headerlink" title="大营销项目中遇到的bug与心得"></a>大营销项目中遇到的bug与心得</h1><h2 id="营销服务第11节-API实现"><a href="#营销服务第11节-API实现" class="headerlink" title="营销服务第11节: API实现"></a>营销服务第11节: API实现</h2><p>这一节先自己实现了API，然后和视频中的对了一下，感觉还可以，就开始测试。</p>
<h3 id="bug1-404-Not-Found"><a href="#bug1-404-Not-Found" class="headerlink" title="bug1: 404 Not Found"></a>bug1: 404 Not Found</h3><p>首先遇到的问题就是怎么也找不到Endpoint，curl，apiPost等工具都是404 Not Found。其实我是没写错的，有时候真是玄学问题，maven重新载入一下项目就可以了。</p>
<h3 id="bug2-redis-DelayedQueue"><a href="#bug2-redis-DelayedQueue" class="headerlink" title="bug2: redis DelayedQueue"></a>bug2: redis DelayedQueue</h3><p>我们要用redisson中的RBlockQueue和RDelayedQueue的话，存入和取出的逻辑是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">awardStockConsumeSendQueue</span><span class="params">(StrategyAwardStockKeyVO strategyAwardStockKeyVO)</span> </span>&#123;</span><br><span class="line">       String cacheKey = Constants.RedisKey.STRATEGY_AWARD_COUNT_QUERY_KEY;</span><br><span class="line">       RBlockingQueue&lt;Object&gt; blockingQueue = redisService.getBlockingQueue(cacheKey);</span><br><span class="line">       RDelayedQueue&lt;Object&gt; delayedQueue = redisService.getDelayedQueue(blockingQueue);</span><br><span class="line">       delayedQueue.offer(strategyAwardStockKeyVO,<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> StrategyAwardStockKeyVO <span class="title">takeQueueValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       String cacheKey = Constants.RedisKey.STRATEGY_AWARD_COUNT_QUERY_KEY;</span><br><span class="line">       RBlockingQueue&lt;StrategyAwardStockKeyVO&gt; destinationQueue = redisService.getBlockingQueue(cacheKey);</span><br><span class="line">       <span class="keyword">return</span> destinationQueue.poll();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在存入的时候，要先获取<code>RBlockingQueue</code>根据这个阻塞队列再构建<code>RDelayedQueue</code>，最后把对象存入延时队列。等到过期以后，延时队列中的对象会被存到<code>RBlockingQueue</code>中去，因此在取对象的时候，只需要根据key获得<code>RBlockingQueue</code>即可，不需要再获取<code>RDelayedQueue</code>了</p>
<h3 id="bug3-redis-setValue-和-setAtomicLong"><a href="#bug3-redis-setValue-和-setAtomicLong" class="headerlink" title="bug3: redis setValue 和 setAtomicLong"></a>bug3: redis setValue 和 setAtomicLong</h3><p>在扣减库存的时候有如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">subtractAwardStock</span><span class="params">(String cacheKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> surplus = redisService.decr(cacheKey);</span><br><span class="line">    <span class="keyword">if</span>(surplus &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        redisService.setAtomicLong(cacheKey, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1. 按照cacheKey decr 后的值，如 99、98、97 和 key 组成为库存锁的key进行使用。</span></span><br><span class="line">    <span class="comment">// 2. 加锁为了兜底，如果后续有恢复库存，手动处理等，也不会超卖。因为所有的可用库存key，都被加锁了</span></span><br><span class="line">    String lockKey = cacheKey + Constants.UNDERLINE + surplus;</span><br><span class="line">    Boolean lock = redisService.setNx(lockKey);</span><br><span class="line">    <span class="keyword">if</span>(!lock) log.info(<span class="string">"策略奖品库存加锁失败 &#123;&#125;"</span>,lockKey);</span><br><span class="line">    <span class="keyword">return</span> lock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我一开始写的是 <code>setValue(cacheKey,0)</code> 但是在压测的时候：如果多个线程几乎同时判断 <code>surplus &lt; 0</code>，多个线程可能依次执行 <code>setValue(cacheKey, 0)</code>，而 Redis 键的值可能会被覆盖或被其他逻辑清空。在这种情况下，某些线程在 <code>setValue</code> 操作完成后，其他并发线程可能又对该键进行了操作，导致值被意外清空。</p>
<p>因此我们要使用原子性操作<code>setAtomicLong</code></p>
<h2 id="前端第3节：对接抽奖页面"><a href="#前端第3节：对接抽奖页面" class="headerlink" title="前端第3节：对接抽奖页面"></a>前端第3节：对接抽奖页面</h2><h3 id="bug1"><a href="#bug1" class="headerlink" title="bug1"></a>bug1</h3><p>我想在页面中加一个<code>&lt;div&gt;</code> 里面包装了抽奖逻辑：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> strategyArmoryHandle = <span class="keyword">async</span> () =&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> queryParams = <span class="keyword">new</span> URLSearchParams(<span class="built_in">window</span>.location.search);</span><br><span class="line">    <span class="keyword">const</span> strategyId = <span class="built_in">Number</span>(queryParams.get(<span class="string">"strategyId"</span>));</span><br><span class="line">    <span class="keyword">if</span>(!strategyId)&#123;</span><br><span class="line">        <span class="built_in">window</span>.alert(<span class="string">"在请求地址中配置 strategyId的值"</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> strategyArmory(strategyId);</span><br><span class="line">    <span class="keyword">const</span> &#123;code,info&#125; = <span class="keyword">await</span> res.json();</span><br><span class="line">    <span class="keyword">if</span>(code != <span class="string">"0000"</span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.alert(<span class="string">"抽奖策略装配失败 code: "</span>+code + <span class="string">" info:"</span> + info)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">"flex flex-col items-center justify-center min-h-screen bg-gray-100"</span>&gt;</span><br><span class="line">            &#123;<span class="comment">/* 头部文案 */</span>&#125;</span><br><span class="line">            &lt;header className=<span class="string">"text-3xl font-bold text-center text-gray-800 my-8"</span>&gt;</span><br><span class="line">                大营销平台 - 抽奖展示</span><br><span class="line">            &lt;<span class="regexp">/header&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div className=&#123;"px-6 py-2 mb-8 text-white bg-blue-500 rounded-fuLl shadow-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-300"&#125; onClick=&#123;strategyArmoryHandle&#125;&gt;</span></span><br><span class="line"><span class="regexp">                装配抽奖</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">					<span class="comment">//..</span></span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>结果遇到报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Unhandled Runtime Error</span><br><span class="line"></span><br><span class="line">[ Server ] Error: Event handlers cannot be passed to Client Component props.</span><br><span class="line">  &lt;div className&#x3D;... onClick&#x3D;&#123;function strategyArmoryHandle&#125; children&#x3D;...&gt;</span><br></pre></td></tr></table></figure></p>
<p>这个错误是因为 <strong>Next.js 15 的新架构</strong>中，<code>onClick</code> 等事件处理器不能直接传递给 <strong>Server Components</strong>，而你定义的组件 <code>Home</code> 默认是 <strong>Server Component</strong>。解决方案是将需要交互的部分（如按钮和 <code>onClick</code> 逻辑）改为 <strong>Client Component</strong>。</p>
<p>新建一个 <code>StrategyArmoryButton</code> 组件：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'use client'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;strategyArmory&#125; <span class="keyword">from</span> <span class="string">"@/apis"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">StrategyArmoryButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> handleClick = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> queryParams = <span class="keyword">new</span> URLSearchParams(<span class="built_in">window</span>.location.search);</span><br><span class="line">        <span class="keyword">const</span> strategyId = <span class="built_in">Number</span>(queryParams.get(<span class="string">"strategyId"</span>));</span><br><span class="line">        <span class="keyword">if</span> (!strategyId) &#123;</span><br><span class="line">            <span class="built_in">window</span>.alert(<span class="string">"在请求地址中配置 strategyId 的值"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">await</span> strategyArmory(strategyId);</span><br><span class="line">        <span class="keyword">const</span> &#123;code, info&#125; = <span class="keyword">await</span> res.json();</span><br><span class="line">        <span class="keyword">if</span> (code !== <span class="string">"0000"</span>) &#123;</span><br><span class="line">            <span class="built_in">window</span>.alert(<span class="string">"抽奖策略装配失败 code: "</span> + code + <span class="string">" info: "</span> + info);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">window</span>.alert(<span class="string">"抽奖策略装配成功！"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div</span><br><span class="line">            className=<span class="string">"px-6 py-2 mb-8 text-white bg-blue-500 rounded-full shadow-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-300"</span></span><br><span class="line">            onClick=&#123;handleClick&#125;</span><br><span class="line">        &gt;</span><br><span class="line">            装配抽奖</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>修改 <code>Home</code> 组件，使用 <code>StrategyArmoryButton</code>：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"flex flex-col items-center justify-center min-h-screen bg-gray-100"</span>&gt;</span><br><span class="line">        &lt;header className=<span class="string">"text-3xl font-bold text-center text-gray-800 my-8"</span>&gt;</span><br><span class="line">          大营销平台 - 抽奖展示</span><br><span class="line">        &lt;<span class="regexp">/header&gt;</span></span><br><span class="line"><span class="regexp">        </span></span><br><span class="line"><span class="regexp">        &lt;StrategyArmoryButton /</span>&gt;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">     &lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="营销服务-第13节：引入分库分表路由组件"><a href="#营销服务-第13节：引入分库分表路由组件" class="headerlink" title="营销服务 第13节：引入分库分表路由组件"></a>营销服务 第13节：引入分库分表路由组件</h2><h3 id="bug1-1"><a href="#bug1-1" class="headerlink" title="bug1"></a>bug1</h3><p>因为mybatis中的mapper文件比较多，所以我将其按照domain分类成了两个子文件夹，但是做测试的时候一直找不到对应的mapper，这是因为配置问题：</p>
<p>之前在application-dev中关于<code>mapper-locations</code> 的配置是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:&#x2F;mybatis&#x2F;mapper&#x2F;*.xml</span><br></pre></td></tr></table></figure>
<p>这样就导致子文件夹中的mapper不能被扫描到，改成这样即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">  mapper-locations: classpath:&#x2F;mybatis&#x2F;mapper&#x2F;**&#x2F;*.xml</span><br></pre></td></tr></table></figure>
<h2 id="营销服务第16节：引入mq"><a href="#营销服务第16节：引入mq" class="headerlink" title="营销服务第16节：引入mq"></a>营销服务第16节：引入mq</h2><h3 id="心德1：流程中为什么要引入MQ"><a href="#心德1：流程中为什么要引入MQ" class="headerlink" title="心德1：流程中为什么要引入MQ"></a>心德1：流程中为什么要引入MQ</h3><p><img src="/2024/11/18/%E5%A4%A7%E8%90%A5%E9%94%80%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84bug%E4%B8%8E%E5%BF%83%E5%BE%97/1.png" style="zoom:67%;"></p>
<p>这是营销活动中，下抽奖单的逻辑：</p>
<ol>
<li>第一步；完成责任链的活动校验，时间、状态、库存。</li>
<li>第二步；对库存的扣减，使用 decr + lock 锁的方式（兜底）进行处理。（和策略部分抽奖扣减库存的逻辑一样）</li>
<li>第三步；做完库存扣减后，发送延迟队列，由任务调度更新趋势库存，满足最终一致。</li>
<li>第四步；库存消耗为0后，发送MQ消息，驱动变更数据库库存为0</li>
</ol>
<p>这里为什么要引入MQ？为什么只在sku库存扣减到0的时候引入MQ？</p>
<p>答：如果扣减完库存，直接发送mq去更新库，和直接操作库扣减库存不用缓存是一样的了。数据库是扛不住大量的数据同时更新一条记录的，所有的请求会进入等待前面的处理释放行级锁。那么其他查询的操作，也没法获取到数据库连接，直至拖垮数据库。 所以要做异步的，延迟的，缓慢的更新，降低集中操作数据库的处理。</p>
<p>因此redis缓存扣减策略是必要的，那么为什么还要引入MQ呢？因为可能一瞬间有几千条抽奖单将库存消耗为0，如果一条一条去更新数据库，确实比较慢，造成开销浪费。因此，用MQ一步到位，将库存变为0，同时清空延迟队列，减少数据库更新次数。</p>
<h2 id="营销服务第19节：中奖记录写入MQ和任务扫描补偿"><a href="#营销服务第19节：中奖记录写入MQ和任务扫描补偿" class="headerlink" title="营销服务第19节：中奖记录写入MQ和任务扫描补偿"></a>营销服务第19节：中奖记录写入MQ和任务扫描补偿</h2><p>这里我遇到了一个很坑的bug：</p>
<p>在我查询数据库中的Task表的时候，我的xml是这么定义的：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryNoSendMessageTaskList"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>&gt;</span></span><br><span class="line">  select user_id,topic,message_id,message,state</span><br><span class="line">  from task</span><br><span class="line">  where state = 'fail' or (state = 'create' and now() - update_time &gt; 6)</span><br><span class="line">  limit 10</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>但是，运行的时候却和我报如下错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.executor.result.ResultMapException: Error attempting to get column &#39;user_id&#39; from result set.  Cause: java.lang.NumberFormatException: For input string: &quot;xiaofuge&quot;</span><br></pre></td></tr></table></figure>
<p>也就是说，在表中读取<code>user_id</code>这列，却没有办法将其转换成数字类型。</p>
<p>这就很奇怪，因为我<code>Task</code>PO对象和xml中，从来就没有定义过user_id是数字类型的。为什么会自动转换并报错？</p>
<p>答案出于一个偷懒的想法：</p>
<p><img src="/2024/11/18/%E5%A4%A7%E8%90%A5%E9%94%80%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84bug%E4%B8%8E%E5%BF%83%E5%BE%97/2.png" style="zoom:67%;"></p>
<p>就是我在定义Task持久化对象的时候，使用了@Builder注释，但没有加上<code>@AllArgsConstructor</code> 和<code>@NoArgsConstructor</code>，这就导致了这导致了构造器的缺失，进而影响了 MyBatis 的工作方式。</p>
<p><strong><code>@Builder</code> 只生成了一个带有所有字段的构造器</strong>，并没有自动生成无参构造器和全参构造器。</p>
<ul>
<li><p><strong><code>@AllArgsConstructor</code></strong> 注解会自动生成一个包含所有字段的构造器（包含 <code>Task</code> 类中的所有字段）。</p>
</li>
<li><p><strong><code>@NoArgsConstructor</code></strong> 注解会自动生成一个无参构造器。</p>
</li>
</ul>
<p>而<code>MyBatis</code> 在进行字段映射时，通常会使用无参构造器来实例化对象，然后通过 setter 方法来设置字段的值。而这里Task没有一个无参构造器，因此 MyBatis 就无法使用反射实例化对象，也就无法正确填充属性值。</p>
<p>所以，我们对于一个对象来说，要么老老实实用<code>@Data</code>修饰，然后用<code>setXXX</code>来填入参数，如果要用<code>@Builder</code>构造,就一定要再加上<code>@AllArgsConstructor</code> 和 <code>@NoArgsConstructor</code></p>
<h2 id="营销服务第20节"><a href="#营销服务第20节" class="headerlink" title="营销服务第20节"></a>营销服务第20节</h2><h3 id="写API-controller的时候，如何定义API？"><a href="#写API-controller的时候，如何定义API？" class="headerlink" title="写API controller的时候，如何定义API？"></a>写API controller的时候，如何定义API？</h3><p>当请求方法是GET的时候，传入参数是放在url里面的，此时需要使用@RequestParam注解</p>
<p>当请求方法是POST的时候，传入参数是放在请求体里面的，此时需要用@RequestBody注解获取参数 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"armory"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response&lt;Boolean&gt; <span class="title">activityArmory</span><span class="params">(@RequestParam Long activityId)</span> </span>&#123;<span class="comment">/**/&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"><span class="doctag">@RequestMapping</span>(value = "draw", method = RequestMethod.POST)</span></span><br><span class="line"><span class="comment"><span class="doctag">@Override</span></span></span><br><span class="line"><span class="comment">public Response&lt;ActivityDrawResponseDTO&gt; draw(<span class="doctag">@RequestBody</span> ActivityDrawRequestDTO requestDTO) &#123;/**/</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="营销服务第26节：积分领域调额服务"><a href="#营销服务第26节：积分领域调额服务" class="headerlink" title="营销服务第26节：积分领域调额服务"></a>营销服务第26节：积分领域调额服务</h2><p>在这一部分中，我们除了实现逻辑之外，还增加了查询判断和 redis lock 加锁增强代码健壮性。另外完善工程日志。</p>
<p><img src="/2024/11/18/%E5%A4%A7%E8%90%A5%E9%94%80%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84bug%E4%B8%8E%E5%BF%83%E5%BE%97/3.png" style="zoom:67%;"></p>
<p><img src="/2024/11/18/%E5%A4%A7%E8%90%A5%E9%94%80%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84bug%E4%B8%8E%E5%BF%83%E5%BE%97/4.png" style="zoom:67%;"></p>
<p>这样做的目的是什么？</p>
<ul>
<li><p><strong>确保并发安全</strong></p>
<ul>
<li><strong>优势：</strong> 通过在方法开始时获取基于 Redis 的分布式锁，确保同一用户在同一活动下的订单保存操作不会被多个线程或进程同时执行。这有效防止了并发导致的数据不一致或重复插入的问题。</li>
<li><strong>应用场景：</strong> 特别适用于高并发环境下，多个请求可能同时尝试为同一用户和活动创建订单的情况。</li>
</ul>
</li>
<li><p><strong>减少竞争条件</strong></p>
<ul>
<li><strong>优势：</strong> 分布式锁确保了“查询再操作”逻辑中的一致性。由于锁的存在，多个线程不会同时执行 <code>queryAccountByUserId</code> 和后续的插入或更新操作，从而避免了第一版本中可能出现的重复键异常 (<code>DuplicateKeyException</code>)。</li>
</ul>
</li>
<li><p><strong>锁的超时机制</strong></p>
</li>
</ul>
<ul>
<li><strong>优势：</strong> <code>lock.lock(3, TimeUnit.SECONDS);</code> 设置了锁的持有时间为3秒，防止因异常或错误导致的死锁。这确保了系统的健壮性，即使某个线程未能正常释放锁，锁也会在超时后自动释放，避免资源被永久占用。</li>
</ul>
<p>原来的做法，是仅依赖于数据库级别的并发控制和事务管理来处理并发操作。</p>
<h3 id="Redis-锁的特点"><a href="#Redis-锁的特点" class="headerlink" title="Redis 锁的特点"></a>Redis 锁的特点</h3><h3 id="1-分布式锁"><a href="#1-分布式锁" class="headerlink" title="1. 分布式锁"></a><strong>1. 分布式锁</strong></h3><ul>
<li><strong>目的：</strong> 确保在分布式系统中，某一关键代码段在任何给定时间内只能被一个实例执行。</li>
<li><strong>使用场景：</strong> 防止竞争条件、管理资源访问、确保数据一致性。</li>
</ul>
<h3 id="2-实现细节"><a href="#2-实现细节" class="headerlink" title="2. 实现细节"></a><strong>2. 实现细节</strong></h3><ul>
<li><strong>原子性：</strong> Redis 提供原子操作（如 <code>SETNX</code>），确保锁的获取是原子的，避免竞争条件。</li>
<li><strong>超时机制（TTL）：</strong> 锁通常设置有过期时间，以防止持有锁的进程在失败或未能释放锁时导致死锁。</li>
<li><strong>锁键的唯一性：</strong> 锁的键通常基于特定的标识符（如用户ID和活动ID）构建，以确保锁的范围和粒度。</li>
</ul>
<h3 id="3-优势"><a href="#3-优势" class="headerlink" title="3. 优势"></a><strong>3. 优势</strong></h3><ul>
<li><strong>性能高效：</strong> Redis 作为内存数据库，提供快速的锁获取和释放操作。</li>
<li><strong>实现简单：</strong> 通过 Redis 命令和诸如 Redisson 等库，可以轻松实现分布式锁。</li>
<li><strong>可扩展性强：</strong> 适用于大规模分布式系统，能够在多个实例间同步访问共享资源。</li>
</ul>
<h3 id="4-潜在缺点"><a href="#4-潜在缺点" class="headerlink" title="4. 潜在缺点"></a><strong>4. 潜在缺点</strong></h3><ul>
<li><strong>单点故障风险：</strong> 如果 Redis 服务不可用，锁机制将失效。可以通过 Redis 集群或哨兵机制来提高可用性。</li>
<li><strong>复杂的失败场景处理：</strong> 需要处理进程在获取锁后崩溃但未释放锁的情况，通常需要结合唯一锁值和合理的超时设置。</li>
<li><strong>额外的开销：</strong> 引入分布式锁会增加网络开销，如果滥用可能成为性能瓶颈。</li>
</ul>
<h3 id="5-最佳实践"><a href="#5-最佳实践" class="headerlink" title="5. 最佳实践"></a><strong>5. 最佳实践</strong></h3><ul>
<li><strong>使用成熟的库：</strong> 采用经过验证的库（如 Redisson）来处理边界情况，并提供高级功能，如锁租约和可重入性。</li>
<li><strong>设置合理的超时：</strong> 确保锁的超时时间足够完成关键代码段的执行，但不至于过长导致不必要的阻塞。</li>
<li><strong>优雅地处理锁获取失败：</strong> 实现重试机制和回退策略，以应对锁获取失败的情况。</li>
<li><strong>避免长时间持有锁：</strong> 将关键代码段保持尽可能短，减少锁的持有时间，降低竞争和阻塞的风险。</li>
</ul>
<h2 id="营销服务第27节：串联case"><a href="#营销服务第27节：串联case" class="headerlink" title="营销服务第27节：串联case"></a>营销服务第27节：串联case</h2><h3 id="RequestBody注解问题"><a href="#RequestBody注解问题" class="headerlink" title="@RequestBody注解问题"></a>@RequestBody注解问题</h3><p>在这一节我们新暴露了几个API，直到此时我才发现原来在controller里面，根据客户端发送的消息格式的不同，也需要匹配不同的写法。</p>
<h4 id="第一个方法：creditPayExchangeSku"><a href="#第一个方法：creditPayExchangeSku" class="headerlink" title="第一个方法：creditPayExchangeSku"></a><strong>第一个方法：<code>creditPayExchangeSku</code></strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response&lt;Boolean&gt; <span class="title">creditPayExchangeSku</span><span class="params">(@RequestBody SkuProductShopCartRequestDTO request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>参数类型：</strong> <code>SkuProductShopCartRequestDTO</code> 是一个复杂的对象，通常包含多个字段，可能对应于前端发送的 JSON 结构。</li>
<li><strong>注解使用：</strong> <code>@RequestBody</code> 注解用于将整个 HTTP 请求体中的内容（例如 JSON、XML）反序列化为 <code>SkuProductShopCartRequestDTO</code> 对象。</li>
</ul>
<h4 id="第二个方法：queryUserCreditAccount"><a href="#第二个方法：queryUserCreditAccount" class="headerlink" title="第二个方法：queryUserCreditAccount"></a><strong>第二个方法：<code>queryUserCreditAccount</code></strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"query_user_credit"</span>, method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Response&lt;BigDecimal&gt; <span class="title">queryUserCreditAccount</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>参数类型：</strong> <code>userId</code> 是一个简单的字符串类型参数。</li>
<li><strong>注解使用：</strong> 没有使用 <code>@RequestBody</code> 注解，而是直接将 <code>userId</code> 作为方法参数。</li>
</ul>
<h3 id="为什么一个方法使用-RequestBody，另一个不使用"><a href="#为什么一个方法使用-RequestBody，另一个不使用" class="headerlink" title="为什么一个方法使用 @RequestBody，另一个不使用"></a><strong>为什么一个方法使用 <code>@RequestBody</code>，另一个不使用</strong></h3><h4 id="a-参数的复杂度和结构"><a href="#a-参数的复杂度和结构" class="headerlink" title="a. 参数的复杂度和结构"></a><strong>a. 参数的复杂度和结构</strong></h4><ul>
<li>复杂对象 vs 简单类型：<ul>
<li><strong>复杂对象（如 <code>SkuProductShopCartRequestDTO</code>）：</strong> 通常包含多个字段和嵌套结构，适合通过 <code>@RequestBody</code> 将整个请求体映射为一个 Java 对象。这种方式适用于客户端以 JSON 或 XML 等格式发送复杂数据的情况。</li>
<li><strong>简单类型（如 <code>String userId</code>）：</strong> 仅包含单一值，通常通过 URL 参数、表单参数或查询参数传递。这种情况下，不需要 <code>@RequestBody</code>，因为数据不在请求体的复杂结构中。</li>
</ul>
</li>
</ul>
<h4 id="b-客户端发送数据的方式"><a href="#b-客户端发送数据的方式" class="headerlink" title="b. 客户端发送数据的方式"></a><strong>b. 客户端发送数据的方式</strong></h4><ul>
<li><p>使用 <code>@RequestBody</code> 的场景：</p>
<ul>
<li>客户端通过 HTTP 请求体（如 POST 请求的 JSON 数据）发送复杂的对象。</li>
<li>需要将整个请求体内容反序列化为一个 Java 对象进行处理。</li>
</ul>
<p>如：客户端发送一个 POST 请求，内容类型为 <code>application/json</code>，请求体包含一个 JSON 对象：</p>
<ul>
<li><p>```<br>{</p>
<pre><code>&quot;userId&quot;: &quot;user123&quot;,
&quot;sku&quot;: 456789,
&quot;其他字段&quot;: &quot;值&quot;
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  + Spring 使用 @RequestBody 将整个 JSON 对象反序列化为 &#96;SkuProductShopCartRequestDTO&#96; 实例，并传递给 &#96;creditPayExchangeSku&#96; 方法。</span><br><span class="line">  </span><br><span class="line">- 不使用 &#96;@RequestBody&#96; 的场景：</span><br><span class="line"></span><br><span class="line">  - 客户端通过 URL 参数或表单数据发送简单的键值对。</span><br><span class="line">  </span><br><span class="line">  - 参数可以直接作为方法的参数进行绑定，无需反序列化整个请求体。</span><br><span class="line">  </span><br><span class="line">  - 如：表单数据</span><br><span class="line">  </span><br><span class="line">    -</span><br></pre></td></tr></table></figure>
<p>  POST /query_user_credit<br>  Content-Type: application/x-www-form-urlencoded</p>
<p>  userId=user123</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  - URL 参数：</span><br><span class="line">  </span><br><span class="line">    - &#96;POST &#x2F;query_user_credit?userId&#x3D;user123&#96;</span><br><span class="line">  </span><br><span class="line">  - Spring 将 &#96;userId&#96; 参数直接绑定到 &#96;queryUserCreditAccount&#96; 方法的 &#96;userId&#96; 参数上，无需 &#96;@RequestBody&#96;。</span><br><span class="line"></span><br><span class="line">#### **c. 注解的具体作用**</span><br><span class="line"></span><br><span class="line">- &#96;@RequestBody&#96;：</span><br><span class="line">  - 告诉 Spring MVC 将 HTTP 请求体中的数据绑定到方法参数上。</span><br><span class="line">  - 适用于需要从请求体中读取和解析数据的情况，尤其是复杂对象。</span><br><span class="line">- 无注解或使用其他注解（如 &#96;@RequestParam&#96;）：</span><br><span class="line">  - 适用于从 URL 参数、查询参数或表单数据中获取简单值。</span><br><span class="line">  - 默认情况下，如果没有使用特定注解，Spring 会根据参数名称和请求中的参数进行匹配和绑定。</span><br><span class="line">- 虽然在功能上，对于简单参数，省略 &#96;@RequestParam&#96; 可能不会引发问题，但为了代码的清晰性、可维护性以及更好的配置灵活性，**建议显式地使用 &#96;@RequestParam&#96; 注解**。这样不仅有助于代码的自解释性，还能在需要时轻松进行参数的详细配置</span><br><span class="line"></span><br><span class="line">## Dubbo配置流程以及踩坑情况</span><br><span class="line"></span><br><span class="line">### 引入dubbo和nacos</span><br><span class="line"></span><br><span class="line">1. 在项目根pom文件中引入nacos：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;xml</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.dubbo&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;dubbo&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.0.9&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.dubbo&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;dubbo-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.0.9&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.nacos&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;nacos-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ol>
<li>配置<code>application-dev.xml</code></li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dubbo:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">big-market</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">1.0</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">id:</span> <span class="string">nacos-registry</span></span><br><span class="line">    <span class="attr">address:</span> <span class="string">nacos://127.0.0.1:8848</span></span><br><span class="line">  <span class="attr">protocol:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dubbo</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">-1</span></span><br><span class="line">  <span class="attr">scan:</span></span><br><span class="line">    <span class="attr">base-packages:</span> <span class="string">io.github.jasonxqh.api</span></span><br></pre></td></tr></table></figure>
<h4 id="dubbo-application"><a href="#dubbo-application" class="headerlink" title="dubbo.application"></a>dubbo.application</h4><p><strong><code>name</code></strong>:</p>
<ul>
<li><strong>作用</strong>：定义 Dubbo 应用的名称。这个名称在服务注册中心（如 Nacos）中用于标识该应用。</li>
<li><strong>意义</strong>：便于在注册中心中区分不同的 Dubbo 应用，尤其在微服务架构中有多个应用时。</li>
</ul>
<p><strong><code>version</code></strong>:</p>
<ul>
<li><strong>作用</strong>：指定应用的版本号。</li>
<li><strong>意义</strong>：用于服务版本管理，可以在同一个接口的不同版本之间进行区分和兼容。例如，不同版本的服务可以同时存在，消费者可以选择调用特定版本的服务。</li>
</ul>
<h4 id="dubbo-registry"><a href="#dubbo-registry" class="headerlink" title="dubbo.registry"></a>dubbo.registry</h4><p><strong><code>id</code></strong>:</p>
<ul>
<li><strong>作用</strong>：给注册中心实例指定一个唯一标识符。</li>
<li><strong>意义</strong>：在配置多个注册中心时，通过 <code>id</code> 区分不同的注册中心实例。</li>
</ul>
<p><strong><code>address</code></strong>:</p>
<ul>
<li><strong>作用</strong>：指定注册中心的地址和协议。</li>
<li><strong>值</strong>： <code>nacos://127.0.0.1:8848</code><ul>
<li><strong><code>nacos</code></strong>：表示使用 <strong>Nacos</strong> 作为注册中心。</li>
<li><strong><code>127.0.0.1:8848</code></strong>：Nacos 注册中心的地址和端口。</li>
</ul>
</li>
<li><strong>意义</strong>：Dubbo 服务提供者和消费者通过这个地址与 Nacos 进行通信，实现服务的注册与发现。</li>
</ul>
<h4 id="dubbo-protocol"><a href="#dubbo-protocol" class="headerlink" title="dubbo.protocol"></a>dubbo.protocol</h4><ul>
<li><strong><code>name</code></strong>:<ul>
<li><strong>作用</strong>：指定使用的通信协议。</li>
<li><strong>值</strong>：<code>dubbo</code>，表示使用 <strong>Dubbo</strong> 协议。</li>
<li><strong>意义</strong>：Dubbo 支持多种协议（如 <code>dubbo</code>、<code>rmi</code>、<code>http</code> 等），选择合适的协议以满足不同的性能和兼容性需求。</li>
</ul>
</li>
<li><strong><code>port</code></strong>:<ul>
<li><strong>作用</strong>：指定服务提供者监听的端口号。</li>
<li><strong>值</strong>：<code>-1</code> 表示自动分配端口。</li>
<li><strong>意义</strong>：<ul>
<li><strong>自动分配</strong>：在开发或测试环境中，使用自动分配端口可以避免端口冲突，简化配置。</li>
<li><strong>固定端口</strong>：在生产环境中，建议指定固定端口，便于服务的管理和监控。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="dubbo-scan"><a href="#dubbo-scan" class="headerlink" title="dubbo.scan"></a>dubbo.scan</h4><p><strong><code>base-packages</code></strong>:</p>
<ul>
<li><strong>作用</strong>：指定 Dubbo 扫描注解的基础包路径。</li>
<li><strong>值</strong>：<code>io.github.jasonxqh.api</code></li>
<li><strong>意义</strong>：<ul>
<li><strong>自动扫描</strong>：Dubbo 会自动扫描指定包及其子包下的类，查找并注册带有 Dubbo 注解（如 <code>@DubboService</code>、<code>@DubboReference</code>）的服务提供者和消费者。</li>
<li><strong>简化配置</strong>：无需在每个类上单独配置注册信息，提升开发效率。</li>
</ul>
</li>
</ul>
<h3 id="启动nacos"><a href="#启动nacos" class="headerlink" title="启动nacos"></a>启动nacos</h3><p>首先，要在</p>
<p>在<code>docker-compose-environment</code>中配置nacos信息，运行后 拉取镜像，即可启动</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># http://127.0.0.1:8848/nacos 【账号：nacos 密码：nacos】</span></span><br><span class="line"><span class="attr">nacos:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">nacos/nacos-server:v2.2.3-slim</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">nacos</span></span><br><span class="line">  <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"8848:8848"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"9848:9848"</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">PREFER_HOST_MODE=hostname</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">MODE=standalone</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_PLATFORM=mysql</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_HOST=mysql</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_DB_NAME=nacos_config</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_PORT=3306</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_USER=root</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_PASSWORD=123456</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">MYSQL_SERVICE_DB_PARAM=characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useSSL=false&amp;allowPublicKeyRetrieval=true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">NACOS_AUTH_IDENTITY_KEY=2222</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">NACOS_AUTH_IDENTITY_VALUE=2xxx</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">NACOS_AUTH_TOKEN=SecretKey012345678901234567890123456789012345678901234567890123456789</span></span><br><span class="line">  <span class="attr">networks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">my-network</span></span><br><span class="line">  <span class="attr">depends_on:</span></span><br><span class="line">    <span class="attr">mysql:</span></span><br><span class="line">      <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br></pre></td></tr></table></figure>
<p><strong><code>MYSQL_SERVICE_HOST=mysql</code></strong>：</p>
<ul>
<li><strong>含义</strong>：指定 MySQL 服务的主机名为 <code>mysql</code>。在 Docker Compose 中，服务之间可以通过服务名互相通信。因此，<code>mysql</code> 指的是同一 Docker Compose 文件中定义的名为 <code>mysql</code> 的服务。</li>
</ul>
<p><strong><code>networks: - my-network</code></strong>：</p>
<ul>
<li><strong>含义</strong>：将 Nacos 容器加入到名为 <code>my-network</code> 的 Docker 网络中。</li>
</ul>
<p><strong><code>depends_on: mysql</code></strong>：</p>
<ul>
<li><strong>含义</strong>：Nacos 服务依赖于名为 <code>mysql</code> 的服务，并且在 MySQL 服务健康（<code>service_healthy</code>）后才启动。</li>
</ul>
<p><strong><code>MYSQL_SERVICE_PORT=3306</code></strong>：</p>
<ul>
<li><strong>含义</strong>：指定 MySQL 服务的端口为 <code>3306</code>，这是 MySQL 的默认端口。</li>
</ul>
<h3 id="Dubbo-服务提供者-DubboService"><a href="#Dubbo-服务提供者-DubboService" class="headerlink" title="Dubbo 服务提供者(@DubboService)"></a>Dubbo 服务提供者(<code>@DubboService</code>)</h3><p>  <code>@DubboService</code> 是 <strong>Dubbo</strong> 提供的注解，用于标识一个类为 <strong>Dubbo 服务提供者</strong>。它相当于 <strong>Spring</strong> 中的 <code>@Service</code> 注解，但专门用于 <strong>Dubbo 服务的发布和注册</strong>。</p>
<h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a><strong>主要功能</strong></h4><ul>
<li><strong>服务发布</strong>：将标注的类作为 Dubbo 服务提供者，自动将其注册到注册中心（如 Nacos、Zookeeper）。</li>
<li><strong>配置服务属性</strong>：通过注解属性配置服务的版本、分组、超时、重试次数等参数。</li>
<li><strong>支持多协议和多注册中心</strong>：允许在不同的协议和注册中心下发布服务实例。</li>
</ul>
<h4 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a><strong>常用属性</strong></h4><ul>
<li><strong><code>version</code></strong>：指定服务的版本号，用于区分不同版本的服务。</li>
<li><strong><code>group</code></strong>：指定服务的分组，便于在同一个注册中心中管理不同组的服务。</li>
<li><strong><code>interfaceName</code></strong>：指定服务接口的全限定名（不常用，通常通过接口类自动推断）。</li>
<li><strong><code>timeout</code></strong>：调用超时时间，单位毫秒。</li>
<li><strong><code>retries</code></strong>：失败重试次数。</li>
<li><strong><code>protocol</code></strong>：指定服务使用的协议</li>
</ul>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RestController</span>()</span><br><span class="line"><span class="meta">@CrossOrigin</span>(<span class="string">"*"</span>)</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/api/v1/raffle/activity"</span>)</span><br><span class="line"><span class="meta">@DubboService</span>(</span><br><span class="line">    version = <span class="string">"1.0"</span>,</span><br><span class="line">    group = <span class="string">"user-group"</span>,</span><br><span class="line">    timeout = <span class="number">5000</span>,</span><br><span class="line">    retries = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RaffleActivityController</span> <span class="keyword">implements</span> <span class="title">IRaffleActivityService</span> </span>&#123;</span><br><span class="line"> 		 <span class="comment">/**/</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>自动注册</strong>：<code>@DubboService</code> 注解会自动将 <code>RaffleActivityController</code> 类注册为 Dubbo 服务，Dubbo 会根据配置将其信息发布到注册中心。</li>
<li><strong>版本与分组</strong>：通过 <code>version</code> 和 <code>group</code> 属性，可以在同一注册中心中管理不同版本和不同组的服务，避免冲突和提高灵活性。</li>
<li><strong>超时与重试</strong>：通过 <code>timeout</code> 和 <code>retries</code> 属性，控制服务调用的容错行为，提升系统的鲁棒性。</li>
</ul>
<h4 id="bug1-2"><a href="#bug1-2" class="headerlink" title="bug1"></a>bug1</h4><p>在我正确在<code>application-dev.yml</code> 中配置dubbo时，一开始出现了这个问题，spring无法扫描到我的配置信息。</p>
<p><img src="/2024/11/18/%E5%A4%A7%E8%90%A5%E9%94%80%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84bug%E4%B8%8E%E5%BF%83%E5%BE%97/5.jpg" style="zoom:67%;"></p>
<p>解决：这种问题很坑，一般不是我们的代码问题，单纯是idea没有刷新配置文件。我们清理缓存并重启即可。</p>
<h3 id="Dubbo-服务消费者-DubboReference"><a href="#Dubbo-服务消费者-DubboReference" class="headerlink" title="Dubbo 服务消费者(@DubboReference)"></a>Dubbo 服务消费者(<code>@DubboReference</code>)</h3><p><code>@DubboReference</code> 是 <strong>Dubbo</strong> 提供的注解，用于注入 <strong>Dubbo 服务消费者</strong>，即引用远程的 Dubbo 服务。它相当于 <strong>Spring</strong> 中的 <code>@Autowired</code> 注解，但专门用于引用远程服务。</p>
<ol>
<li>在 测试项目中，引入注册到nacos中的包,然后编写测试类：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ApiTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DubboReference</span>(interfaceClass = IRaffleActivityService<span class="class">.<span class="keyword">class</span>, <span class="title">version</span> </span>= <span class="string">"1.0"</span>)</span><br><span class="line">    <span class="keyword">private</span> IRaffleActivityService raffleActivityService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_rpc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ActivityDrawRequestDTO request = <span class="keyword">new</span> ActivityDrawRequestDTO();</span><br><span class="line">        request.setActivityId(<span class="number">100301L</span>);</span><br><span class="line">        request.setUserId(<span class="string">"xiaofuge"</span>);</span><br><span class="line">        Response&lt;ActivityDrawResponseDTO&gt; response = raffleActivityService.draw(request);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"请求参数：&#123;&#125;"</span>, JSON.toJSONString(request));</span><br><span class="line">        log.info(<span class="string">"测试结果：&#123;&#125;"</span>, JSON.toJSONString(response));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>@DubboReference</code>：<ul>
<li><strong>作用</strong>：这是 <strong>Dubbo</strong> 提供的注解，用于注入远程服务的引用（即消费者）。</li>
<li>属性说明：<ul>
<li><strong><code>interfaceClass</code></strong>：指定要引用的远程服务接口类。</li>
<li><strong><code>version</code></strong>：指定服务的版本，用于区分不同版本的服务实例。</li>
</ul>
</li>
<li>优势：<ul>
<li><strong>简化配置</strong>：通过注解方式注入远程服务，无需手动配置服务地址。</li>
<li><strong>动态代理</strong>：Dubbo 自动生成代理对象，简化服务调用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>注意</strong>：确保 <strong>Dubbo</strong> 已正确配置，且 <code>IRaffleActivityService</code> 接口在服务提供者和消费者中版本一致，且接口类在两端保持同步。</p>
</blockquote>
<h4 id="bug2"><a href="#bug2" class="headerlink" title="bug2"></a>bug2</h4><p>在大营销项目中，需要先 <code>mvn clean install</code>重新构建项目所有的包，这样测试项目中才能引入最新版本的包。否则会出现引用到过去没有serialize的DTO的报错<img src="/2024/11/18/%E5%A4%A7%E8%90%A5%E9%94%80%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84bug%E4%B8%8E%E5%BF%83%E5%BE%97/5.jpg" style="zoom:67%;"></p>
<h2 id="运营上踩得坑"><a href="#运营上踩得坑" class="headerlink" title="运营上踩得坑"></a>运营上踩得坑</h2><h3 id="本地构建docker-镜像的时候，消耗过多本地空间"><a href="#本地构建docker-镜像的时候，消耗过多本地空间" class="headerlink" title="本地构建docker 镜像的时候，消耗过多本地空间"></a>本地构建docker 镜像的时候，消耗过多本地空间</h3><p>可以通过❯<code>docker system df</code>查看docker占用了那些资源，一般来说，build cache可能会占用大量空间</p>
<p>TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE<br>Images          4         2         771.4MB   287.5MB (37%)<br>Containers      2         2         0B        0B<br>Local Volumes   4         2         197.1MB   196.8MB (99%)<br>Build Cache     80        0         15.25GB   15.25GB</p>
<p>可以使用 <code>docker system prune -a</code> 来删除缓存内容</p>
<h3 id="构建不同平台的镜像"><a href="#构建不同平台的镜像" class="headerlink" title="构建不同平台的镜像"></a>构建不同平台的镜像</h3><p>我们写完Dockerfile之后，可以运行一个脚本来构建，比如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">普通镜像构建，随系统版本构建 amd/arm</span></span><br><span class="line">docker build -t jasonxqh/big-market-xqh-app:1.0 -f ./Dockerfile .</span><br></pre></td></tr></table></figure></p>
<p>如果要部署到云服务器，那么就要构建云服务器段的版本，我因为本地是mac，云端是amd64, 导致不兼容。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">只构建linux/amd64</span></span><br><span class="line">docker build --platform linux/amd64 -t jasonxqh/big-market-xqh-app:1.0 -f ./Dockerfile .</span><br></pre></td></tr></table></figure>
<h3 id="1-运行dockerfile前的构建准备"><a href="#1-运行dockerfile前的构建准备" class="headerlink" title="1. 运行dockerfile前的构建准备"></a>1. 运行dockerfile前的构建准备</h3><h4 id="流程1-使用dockerhub"><a href="#流程1-使用dockerhub" class="headerlink" title="流程1:使用dockerhub"></a>流程1:使用dockerhub</h4><p>我们第一阶段的部署策略，是在我们的本地部署，然后利用docker把构建好的images推送到dockerhub上，然后在云主机上，运行docker compose文件将images拉取下来。这样做的缺点就是每次要迭代版本的时候，需要在本地构建、推送、云端拉取，时间会很长，而且有时候网络不好。</p>
<h4 id="流程2：云主机端构建"><a href="#流程2：云主机端构建" class="headerlink" title="流程2：云主机端构建"></a>流程2：云主机端构建</h4><p>现在我们可以先用git把前后端项目都拉取到云主机，直接在云主机端构建images，可以方便得制定版本号，自由度更高，构建速度更快。</p>
<h3 id="前端后端调用情况"><a href="#前端后端调用情况" class="headerlink" title="前端后端调用情况"></a>前端后端调用情况</h3><p>在云服务器上，前端调用后端时，不能再用<code>localhost:8091</code>了，而是要用公网IP</p>
<h3 id="前端DockerFile模版"><a href="#前端DockerFile模版" class="headerlink" title="前端DockerFile模版"></a>前端DockerFile模版</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --platform linux/amd64 -t jasonxqh/big-market-frontend-xqh-app:1.0 .</span><br></pre></td></tr></table></figure>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">18</span>-alpine AS base</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> base AS deps</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk add --no-cache libc6-compat</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> package.json yarn.lock* package-lock.json* pnpm-lock.yaml* ./</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yarn config <span class="built_in">set</span> registry <span class="string">'https://registry.npmmirror.com/'</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yarn install</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> base AS builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=deps /app/node_modules ./node_modules</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yarn build:no-lint</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> base AS runner</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /app/public ./public</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /app/.next/standalone ./</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /app/.next/static ./.next/static</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /app/.next/server ./.next/server</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br><span class="line"><span class="keyword">ENV</span> PORT <span class="number">3000</span></span><br><span class="line"><span class="keyword">ENV</span> HOSTNAME <span class="string">"0.0.0.0"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"node"</span>, <span class="string">"server.js"</span>]</span></span><br></pre></td></tr></table></figure>
<h3 id="Dockerfile-解析"><a href="#Dockerfile-解析" class="headerlink" title="Dockerfile 解析"></a><strong>Dockerfile 解析</strong></h3><h4 id="1-第一阶段：base（基础镜像）"><a href="#1-第一阶段：base（基础镜像）" class="headerlink" title="1. 第一阶段：base（基础镜像）"></a><strong>1. 第一阶段：<code>base</code>（基础镜像）</strong></h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">18</span>-alpine AS base</span><br></pre></td></tr></table></figure>
<ul>
<li>使用轻量级的 Node.js 18 Alpine 镜像作为基础镜像。</li>
<li>该镜像体积小，适合生产环境使用。</li>
</ul>
<h4 id="2-第二阶段：deps（依赖安装阶段）"><a href="#2-第二阶段：deps（依赖安装阶段）" class="headerlink" title="2. 第二阶段：deps（依赖安装阶段）"></a><strong>2. 第二阶段：<code>deps</code>（依赖安装阶段）</strong></h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">FROM</span> base AS deps</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk add --no-cache libc6-compat</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> package.json yarn.lock* package-lock.json* pnpm-lock.yaml* ./</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yarn config <span class="built_in">set</span> registry <span class="string">'https://registry.npmmirror.com/'</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yarn install</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>继承基础镜像</strong>：<ul>
<li>在 <code>base</code> 基础上创建一个新的构建阶段 <code>deps</code>，用于安装依赖。</li>
</ul>
</li>
<li><strong>安装兼容库</strong>：<ul>
<li><code>apk add --no-cache libc6-compat</code>：安装 <code>glibc</code> 兼容库，用于运行某些需要特定依赖的 Node.js 程序。</li>
</ul>
</li>
<li><strong>设置工作目录</strong>：<ul>
<li><code>WORKDIR /app</code>：设置工作目录为 <code>/app</code>，之后的所有操作都在此目录下执行。</li>
</ul>
</li>
<li><strong>复制依赖文件</strong>：<ul>
<li><code>COPY package.json yarn.lock* package-lock.json* pnpm-lock.yaml* ./</code>：将依赖文件复制到容器中。如果某些文件不存在，这一命令不会报错。</li>
</ul>
</li>
<li><strong>设置 npm 镜像源</strong>：<ul>
<li>使用 <code>https://registry.npmmirror.com/</code> 镜像源，加快依赖安装速度。</li>
</ul>
</li>
<li><strong>安装依赖</strong>：<ul>
<li><code>yarn install</code>：安装依赖。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-第三阶段：builder（构建阶段）"><a href="#3-第三阶段：builder（构建阶段）" class="headerlink" title="3. 第三阶段：builder（构建阶段）"></a><strong>3. 第三阶段：<code>builder</code>（构建阶段）</strong></h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">FROM</span> base AS builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=deps /app/node_modules ./node_modules</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yarn build:no-lint</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>继承基础镜像</strong>：<ul>
<li>在 <code>base</code> 基础上创建一个新的构建阶段 <code>builder</code>，用于构建应用程序。</li>
</ul>
</li>
<li><strong>复制依赖</strong>：<ul>
<li><code>COPY --from=deps /app/node_modules ./node_modules</code>：从 <code>deps</code> 阶段复制 <code>node_modules</code> 目录到当前工作目录，避免重复安装依赖。</li>
</ul>
</li>
<li><strong>复制应用代码</strong>：<ul>
<li><code>COPY . .</code>：将当前目录的所有文件复制到容器中。</li>
</ul>
</li>
<li><strong>构建应用</strong>：<ul>
<li><code>RUN yarn build:no-lint</code>：运行构建命令（假设 <code>build:no-lint</code> 是 <code>package.json</code> 中定义的一个构建脚本）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-第四阶段：runner（运行阶段）"><a href="#4-第四阶段：runner（运行阶段）" class="headerlink" title="4. 第四阶段：runner（运行阶段）"></a><strong>4. 第四阶段：<code>runner</code>（运行阶段）</strong></h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> base AS runner</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /app/public ./public</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /app/.next/standalone ./</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /app/.next/static ./.next/static</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=builder /app/.next/server ./.next/server</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br><span class="line"><span class="keyword">ENV</span> PORT <span class="number">3000</span></span><br><span class="line"><span class="keyword">ENV</span> HOSTNAME <span class="string">"0.0.0.0"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"node"</span>, <span class="string">"server.js"</span>]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>继承基础镜像</strong>：<ul>
<li>在 <code>base</code> 基础上创建一个运行阶段 <code>runner</code>，只包含运行所需的内容，确保最终镜像尽量小。</li>
</ul>
</li>
<li><strong>设置工作目录</strong>：<ul>
<li><code>WORKDIR /app</code>：设置工作目录为 <code>/app</code>。</li>
</ul>
</li>
<li><strong>复制构建输出</strong>：<ul>
<li><code>COPY --from=builder /app/public ./public</code>：复制 <code>public</code> 文件夹。</li>
<li><code>COPY --from=builder /app/.next/standalone ./</code>：复制 <code>standalone</code> 文件夹（Next.js 独立运行模式的输出）。</li>
<li><code>COPY --from=builder /app/.next/static ./.next/static</code>：复制静态文件。</li>
<li><code>COPY --from=builder /app/.next/server ./.next/server</code>：复制服务器端文件。</li>
</ul>
</li>
<li><strong>开放端口</strong>：<ul>
<li><code>EXPOSE 3000</code>：声明服务运行在容器的 3000 端口。</li>
</ul>
</li>
<li><strong>环境变量</strong>：<ul>
<li><code>ENV PORT 3000</code>：设置服务的运行端口为 3000。</li>
<li><code>ENV HOSTNAME &quot;0.0.0.0&quot;</code>：服务监听所有网络接口。</li>
</ul>
</li>
<li><strong>启动命令</strong>：<ul>
<li><code>CMD [&quot;node&quot;, &quot;server.js&quot;]</code>：运行应用服务器，启动 Next.js 应用。</li>
</ul>
</li>
</ul>
<h4 id="需注意"><a href="#需注意" class="headerlink" title="需注意"></a>需注意</h4><p>此外，还需要配置<code>next.config.ts</code>:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; NextConfig &#125; <span class="keyword">from</span> <span class="string">"next"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nextConfig: NextConfig = &#123;</span><br><span class="line">    <span class="comment">// 输出为 standalone 模式，支持 Docker 部署</span></span><br><span class="line">    output: <span class="string">"standalone"</span>,</span><br><span class="line">    target: <span class="string">'server'</span>,</span><br><span class="line">    <span class="comment">// 启用 SWC 编译器以提升构建速度</span></span><br><span class="line">    swcMinify: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 环境变量配置（示例）</span></span><br><span class="line">    env: &#123;</span><br><span class="line">        NEXT_PUBLIC_API_BASE_URL: process.env.NEXT_PUBLIC_API_BASE_URL || <span class="string">"http://localhost:3000"</span>,</span><br><span class="line">        API_HOST_URL: process.env.API_HOST_URL</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> nextConfig;</span><br></pre></td></tr></table></figure>
<p>以及<code>.eslintrc.json</code>来忽略一些typescript的报错信息：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"extends"</span>: [<span class="string">"next/core-web-vitals"</span>, <span class="string">"next/typescript"</span>],</span><br><span class="line">  <span class="attr">"rules"</span>: &#123;</span><br><span class="line">    <span class="attr">"@typescript-eslint/ban-ts-comment"</span>: [</span><br><span class="line">      <span class="string">"error"</span>, <span class="comment">// 或 "warn"，如果你想只显示警告</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"ts-ignore"</span>: <span class="literal">false</span>, <span class="comment">// 允许使用 @ts-ignore</span></span><br><span class="line">        <span class="attr">"ts-nocheck"</span>: <span class="literal">true</span>, <span class="comment">// 根据需要决定是否允许 @ts-nocheck</span></span><br><span class="line">        <span class="attr">"ts-check"</span>: <span class="literal">true</span>,   <span class="comment">// 根据需要决定是否允许 @ts-check</span></span><br><span class="line">        <span class="attr">"ts-expect-error"</span>: <span class="literal">true</span> <span class="comment">// 保留 @ts-expect-error（如果你需要它）</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重构MyBatis时遇到错误"><a href="#重构MyBatis时遇到错误" class="headerlink" title="重构MyBatis时遇到错误"></a>重构MyBatis时遇到错误</h3><p>首先，如果在resource/mybatis文件夹下，如果我们的Mapper放在多个子文件夹中，我们需要再yml中冲顶定义mybatis的扫描路径：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">classpath:/mybatis/mapper/**/*.xml</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">classpath:/mybatis/mapper/*.xml</span></span><br><span class="line">  <span class="attr">config-location:</span>  <span class="string">classpath:/mybatis/config/mybatis-config.xml</span></span><br></pre></td></tr></table></figure>
<p>否则会出现找不到mapper的错误</p>
<p>当我移动了某个mybatis中的某个mapper到新文件夹的时候（原本在其他子文件夹中)，此时运行项目汇报如下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cause: java.lang.IllegalArgumentException: Result Maps collection already contains value for io.github.jasonxqh.infrastructure.dao.IUserAwardRecordDao.BaseResultMap</span><br></pre></td></tr></table></figure></p>
<p>这是因为我们之前构建的时候，在已经把这个mapper放在了<code>target/classes/mybatis/mapper</code> 中的某个子文件夹中了，现在我们将其移动到新的文件夹的话，再次构建就会导致重复构建的错误。</p>
<p>遇到这种情况我们可以用<code>mvn clean install</code> 来重新构建项目。</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2024/11/14/redis%E5%AE%9E%E7%8E%B0%E9%98%B2%E8%B6%85%E5%8D%96%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/11/14/redis%E5%AE%9E%E7%8E%B0%E9%98%B2%E8%B6%85%E5%8D%96%E7%AD%96%E7%95%A5/" itemprop="url">redis实现防超卖策略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-11-14T13:22:55+08:00">
                2024-11-14
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2025-04-10T13:37:15+08:00">
                2025-04-10
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="redis实现防超卖策略"><a href="#redis实现防超卖策略" class="headerlink" title="redis实现防超卖策略"></a>redis实现防超卖策略</h1><p>在高并发的场景下，尤其是电商等需要控制库存的系统，<strong>超卖</strong>是一个常见的问题。超卖指的是用户在高并发情况下能够购买已经售完的商品。通过 Redis 实现防止超卖的策略，通常包括以下几个关键部分：</p>
<h3 id="1-库存控制的基本思路"><a href="#1-库存控制的基本思路" class="headerlink" title="1. 库存控制的基本思路"></a>1. <strong>库存控制的基本思路</strong></h3><ul>
<li>使用 Redis 存储商品的库存信息。Redis 提供的高并发支持和高性能，可以帮助快速响应并发请求。</li>
<li>通过 Redis 的原子性操作（如 <code>DECR</code>）来实现库存的扣减，并利用<strong>非独占锁机制</strong>来避免并发请求导致的库存超卖。</li>
</ul>
<h3 id="2-非独占锁与消息队列的协同作用"><a href="#2-非独占锁与消息队列的协同作用" class="headerlink" title="2. 非独占锁与消息队列的协同作用"></a>2. 非独占锁与消息队列的协同作用</h3><h4 id="2-1-非独占锁的作用：扣减标识-流水"><a href="#2-1-非独占锁的作用：扣减标识-流水" class="headerlink" title="2.1 非独占锁的作用：扣减标识(流水)"></a>2.1 非独占锁的作用：扣减标识(流水)</h4><ul>
<li><strong>防止超卖</strong>：在高并发场景中，库存扣减操作需要确保每个扣减请求是唯一的，这样才能避免库存被误扣。通过 <code>setNx</code> 实现的<strong>非独占锁</strong>，可以确保每个扣减操作是独立的，并且通过锁的存在来标识每个扣减请求。</li>
<li><strong>库存扣减的标识作用</strong>：每次库存扣减都会创建一个与当前库存数（例如 <code>cacheKey_99</code> 或 <code>cacheKey_98</code>）相关联的锁。这个锁并不是用来控制其他请求对资源的访问，而是作为一个 <strong>操作标识</strong>，确保每个操作在进行时被唯一标识，从而确保库存的唯一性。</li>
<li><strong>与库存数绑定</strong>：锁的粒度是与库存数紧密绑定的，而不是共享一个通用的库存锁。例如，当线程1将库存从100扣减到99时，生成的锁是 <code>cacheKey_99</code>，而当线程2将库存从99扣减到98时，生成的锁是 <code>cacheKey_98</code>。虽然它们的操作是并行的，但每个操作都会确保 <strong>独立性</strong>，因此不会产生竞争。</li>
</ul>
<h4 id="2-2-为什么需要非独占锁？"><a href="#2-2-为什么需要非独占锁？" class="headerlink" title="2.2 为什么需要非独占锁？"></a>2.2 为什么需要非独占锁？</h4><ul>
<li><strong>处理网络异常与集群抖动</strong>：在高并发的情况下，尤其是像秒杀这样的场景中，网络延迟或 Redis 集群的主从切换可能导致请求失败或者网络超时，从而导致一些错误。比如说：库存扣减10w次，可能不一定真的扣减了10w次，那么我们就需要每次扣减的时候，保存一个扣减的证明，这个证明就是锁。通过 <code>setNx</code> 锁的机制，即使出现网络异常或 Redis 重试，仍然能够保证一个库存对应一把锁，不会超卖。</li>
<li><strong>认为调整库存后的拦截: </strong> 另外就是出现问题时候，运营可能会调整库存。比如说：原来只有200个库存，抽奖的过程中添加锁，已经将库存减少到了100，这个时候人为添加100的库存的话，如果装配了的话，需要重新开始减，300-200范围内的锁还能获取，但是200-100范围内的锁已经都有了，就会被已经存在的锁拦截。防止一个商品多次被抽奖或者购买。</li>
</ul>
<h4 id="2-4-消息队列的作用-削峰保护数据库"><a href="#2-4-消息队列的作用-削峰保护数据库" class="headerlink" title="2.4 消息队列的作用: 削峰保护数据库"></a>2.4 消息队列的作用: 削峰保护数据库</h4><ul>
<li><strong>削峰填谷</strong>：在秒杀、抢购等高并发场景中，直接操作数据库会造成极大的压力，特别是对库存的持久化操作。因此，使用消息队列来异步处理库存扣减操作，能够有效减轻数据库的瞬时压力，避免系统因并发访问而崩溃。</li>
<li><strong>延迟消费与批处理</strong>：消息队列能够将库存扣减的任务延迟消费并批量处理。这种设计使得数据库更新操作不再直接依赖于每个扣减请求的实时响应，而是通过异步的方式集中更新，避免数据库因并发请求造成瓶颈。</li>
<li><strong>确保最终一致性</strong>：消息队列的使用不仅有助于减轻数据库压力，还确保了库存扣减的 <strong>最终一致性</strong>。尽管存在异步处理，但通过消息队列的消费机制，最终会确保数据库中的库存数会正确更新，而不会出现超卖。</li>
<li><strong>异步执行与顺序执行</strong>：通过消息队列，库存更新的操作可以按照队列中的顺序进行，这样即使有多个扣减请求，也能保证最终库存的一致性。队列消费时，会按顺序进行库存更新，避免并发处理中的错误和数据不一致。</li>
</ul>
<h2 id="扣减库存的执行流程"><a href="#扣减库存的执行流程" class="headerlink" title="扣减库存的执行流程"></a>扣减库存的执行流程</h2><h4 id="0-装配策略时一并装配库存信息"><a href="#0-装配策略时一并装配库存信息" class="headerlink" title="0. 装配策略时一并装配库存信息"></a>0. 装配策略时一并装配库存信息</h4><p>当在装配抽奖策略的时候，我们可以将奖品信息一并存放到Redis中，其键为strategyId和awardId，值为awardCount</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">assembleLotteryStrategy</span><span class="params">(Long strategyId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 查询策略配置</span></span><br><span class="line">   ...</span><br><span class="line">    <span class="comment">//2. 缓存奖品库存，用于decr扣减库存使用</span></span><br><span class="line">    <span class="keyword">for</span>(StrategyAwardEntity strategyAwardEntity : strategyAwardEntities) &#123;</span><br><span class="line">        Integer awardId = strategyAwardEntity.getAwardId();</span><br><span class="line">        Integer awardCount = strategyAwardEntity.getAwardCount();</span><br><span class="line">        cacheStrategyCount(strategyId,awardId,awardCount);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.1 默认装配配置[全量抽奖概率]</span></span><br><span class="line">    <span class="comment">//3.2 权重策略配置，适用于rule_weight权重规则配置</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-扣减库存请求的触发"><a href="#1-扣减库存请求的触发" class="headerlink" title="1. 扣减库存请求的触发"></a>1. <strong>扣减库存请求的触发</strong></h4><p>用户发起购买请求或参与活动时，后台系统会接收到一个请求，需要检查和扣减库存。这时，可能会出现大量并发请求。我们需要通过 Redis 控制库存的扣减，防止超卖。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在规则树的库存规则节点上，需要执行库存扣减操作</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> DefaultTreeFactory.<span class="function">TreeActionEntity <span class="title">logic</span><span class="params">(String userId, Long strategyId, Integer awardId,String ruleValue)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"规则过滤-库存扣减 userId:&#123;&#125; strategyId:&#123;&#125; awardId:&#123;&#125;"</span>, userId, strategyId, awardId);</span><br><span class="line">    Boolean status = strategyDispatch.subtractionAwardStock(strategyId, awardId);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-库存扣减（Redis-DECR）"><a href="#2-库存扣减（Redis-DECR）" class="headerlink" title="2. 库存扣减（Redis DECR）"></a>2. <strong>库存扣减（Redis <code>DECR</code>）</strong></h4><ul>
<li>每次请求都会尝试通过 Redis 扣减库存，Redis 提供的 <code>DECR</code> 命令是原子性的，这意味着它可以确保库存减少的操作是线程安全的。</li>
<li>比如，如果库存为 100，当第一次请求到来时，库存会通过 <code>DECR</code> 命令减到 99；第二次请求到来时，库存再减到 98，依此类推。</li>
<li>通过 <code>DECR</code> 执行库存减少操作，确保每次库存减少时，只有一个线程能操作该库存。</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>如果 <code>DECR</code> 返回负数，说明库存已经为 0 或不足。这时需要采取补偿措施，如返回库存不足的错误信息。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Repository层的操作，先decr扣减redis中的库存，再返回锁</span></span><br><span class="line"><span class="comment">//具体为什么要返回锁，上文已有讨论：</span></span><br><span class="line"><span class="comment">//即使decr是原子性的,扣减10w次也不一定真的减了10w次库存，因此要一个凭证，即lock</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">subtractAwardStock</span><span class="params">(String cacheKey)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> surplus = redisService.decr(cacheKey);</span><br><span class="line">    <span class="keyword">if</span>(surplus &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        redisService.setAtomicLong(cacheKey, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String lockKey = cacheKey + Constants.UNDERLINE + surplus;</span><br><span class="line">    Boolean lock = redisService.setNx(lockKey);</span><br><span class="line">    <span class="keyword">if</span>(!lock) log.info(<span class="string">"策略奖品库存加锁失败 &#123;&#125;"</span>,lockKey);</span><br><span class="line">    <span class="keyword">return</span> lock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAtomicLong</span><span class="params">(String key, Integer awardCount)</span> </span>&#123;</span><br><span class="line">        redissonClient.getAtomicLong(key).set(awardCount);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注意，这里必须使用原子性设置，否则可能会出现对应的库存为空的错误。因为如果多个线程几乎同时判断 <code>surplus &lt; 0</code>，多个线程可能依次执行 <code>setValue(cacheKey, 0)</code>，而 Redis 键的值可能会被覆盖或被其他逻辑清空。在这种情况下，某些线程在 <code>setValue</code> 操作完成后，其他并发线程可能又对该键进行了操作，导致值被意外清空。</p>
<h4 id="3-加锁机制（SETNX）"><a href="#3-加锁机制（SETNX）" class="headerlink" title="3. 加锁机制（SETNX）"></a>3. <strong>加锁机制（<code>SETNX</code>）</strong></h4><ul>
<li>对于库存的每个减少操作，我们需要设置一个锁来确保在库存减少后，其他线程不能立即进行修改操作。</li>
<li><code>SETNX</code> 是 Redis 的一种原子操作，它确保只有在锁不存在的情况下，才能成功创建锁。</li>
<li>每次库存减少后，我们创建一个基于库存数（<code>surplus</code>）的锁，如 <code>cacheKey:98</code>，<strong>确保每个库存值有唯一的锁</strong>。</li>
</ul>
<h4 id="4-库存扣减成功后的消息队列"><a href="#4-库存扣减成功后的消息队列" class="headerlink" title="4. 库存扣减成功后的消息队列"></a>4. <strong>库存扣减成功后的消息队列</strong></h4><ul>
<li>为了延迟执行库存更新（比如数据库操作），我们通过将库存更新任务加入到消息队列中，由消费者异步处理。</li>
<li>这样，库存的扣减和数据库更新分离开，避免了在高并发下直接修改数据库的压力。</li>
<li>消息队列可以用如 Kafka 或 RabbitMQ 等工具来实现。但这里使用的是redis中的阻塞队列和延迟队列，每个扣减成功的请求都会把相关的信息（如策略ID、奖品ID、剩余库存）发送到队列中，消费者会异步消费消息并执行数据库更新。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> DefaultTreeFactory.<span class="function">TreeActionEntity <span class="title">logic</span><span class="params">(String userId, Long strategyId, Integer awardId,String ruleValue)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"规则过滤-库存扣减 userId:&#123;&#125; strategyId:&#123;&#125; awardId:&#123;&#125;"</span>, userId, strategyId, awardId);</span><br><span class="line">    Boolean status = strategyDispatch.subtractionAwardStock(strategyId, awardId);</span><br><span class="line">    <span class="comment">// status 为true，库存扣减成功，否则失败</span></span><br><span class="line">    <span class="comment">//成功，则发送队列消息</span></span><br><span class="line">    <span class="keyword">if</span>(status)&#123;</span><br><span class="line">        <span class="comment">//写入延迟队列，延迟消费更新数据库记录</span></span><br><span class="line">        log.info(<span class="string">"规则过滤-库存扣减成功，向队列发送消息 "</span>);</span><br><span class="line">        strategyRepository.awardStockConsumeSendQueue( StrategyAwardStockKeyVO.builder()</span><br><span class="line">                        .strategyId(strategyId)</span><br><span class="line">                        .awardId(awardId)</span><br><span class="line">                        .build());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> DefaultTreeFactory.TreeActionEntity.builder()</span><br><span class="line">                .ruleLogicCheckTypeVO(RuleLogicCheckTypeVO.TAKE_OVER)</span><br><span class="line">                .strategyAwardVO(DefaultTreeFactory.StrategyAwardVO.builder()</span><br><span class="line">                        .awardId(awardId)</span><br><span class="line">                        .awardRuleValue(<span class="string">""</span>)</span><br><span class="line">                        .build())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">"规则过滤-库存扣减失败，走兜底"</span>);</span><br><span class="line">    <span class="keyword">return</span> DefaultTreeFactory.TreeActionEntity.builder()</span><br><span class="line">            .ruleLogicCheckTypeVO(RuleLogicCheckTypeVO.TAKE_OVER)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>awardStockConsumeSendQueue()</code></strong> 方法：</p>
<ul>
<li>该方法的作用是将一个 <code>StrategyAwardStockKeyVO</code> 对象推送到 Redis 的延迟队列 <code>RDelayedQueue</code> 中。</li>
<li><code>RDelayedQueue</code> 是基于 <code>RBlockingQueue</code> 实现的，可以在指定的延迟时间后异步消费队列中的元素。在这里，元素将在 3 秒后被消费。</li>
<li>延迟队列主要用于解耦和异步处理某些操作，比如更新库存数据库时，减少对数据库的瞬时压力。</li>
<li>通过 <code>delayedQueue.offer()</code> 方法将 <code>strategyAwardStockKeyVO</code> 放入延迟队列，3 秒后，队列中的元素会被消费。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">awardStockConsumeSendQueue</span><span class="params">(StrategyAwardStockKeyVO strategyAwardStockKeyVO)</span> </span>&#123;</span><br><span class="line">    String cacheKey = Constants.RedisKey.STRATEGY_AWARD_COUNT_QUERY_KEY;</span><br><span class="line">    RBlockingQueue&lt;Object&gt; blockingQueue = redisService.getBlockingQueue(cacheKey);</span><br><span class="line">    RDelayedQueue&lt;Object&gt; delayedQueue = redisService.getDelayedQueue(blockingQueue);</span><br><span class="line">    delayedQueue.offer(strategyAwardStockKeyVO,<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-定时任务的消费"><a href="#8-定时任务的消费" class="headerlink" title="8. 定时任务的消费"></a>8. <strong>定时任务的消费</strong></h4><ul>
<li>消费者从消息队列中获取库存扣减的任务后，执行延迟更新数据库的操作。例如，可以使用定时任务每隔一段时间从队列中取出消息，处理库存更新。</li>
<li><strong>延迟消费</strong> 可以帮助平衡系统负载，避免直接在请求时进行库存的数据库更新。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span>()</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UpdateAwardStockJob</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IRaffleStock raffleStock;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"0/5 * * * * ?"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">"定时任务，更新奖品消耗库存[延迟队列获取，降低对数据库的更新频次， 不要产生竞争"</span>);</span><br><span class="line">            StrategyAwardStockKeyVO strategyAwardStockKeyVO = raffleStock.takeQueueValue();</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> == strategyAwardStockKeyVO)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">"定时任务，更新奖品消耗库存 strategyId:&#123;&#125; awardId:&#123;&#125; "</span>,strategyAwardStockKeyVO.getStrategyId(), strategyAwardStockKeyVO.getAwardId());</span><br><span class="line">            raffleStock.updateStrategyAwardStock(strategyAwardStockKeyVO.getStrategyId(), strategyAwardStockKeyVO.getAwardId());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            log.error(<span class="string">"定时任务，更新奖品消耗库存失败"</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>takeQueueValue()</code></strong> 方法：</p>
<ul>
<li>从 Redis 阻塞队列中获取一个 <code>StrategyAwardStockKeyVO</code> 类型的对象。</li>
<li>如果队列为空，调用 <code>poll()</code> 方法会使当前线程阻塞，直到有新数据可供消费。</li>
<li><code>poll()</code> 会在有数据时返回一个元素，如果队列为空，则返回 <code>null</code>。</li>
</ul>
<p><strong><code>updateStrategyAwardStock()</code></strong> 方法：</p>
<ul>
<li>根据 <code>strategyId</code> 和 <code>awardId</code> 参数，创建一个 <code>StrategyAward</code> 实体，并设置这两个属性。</li>
<li>调用 DAO 层的方法 <code>updateStrategyAwardStock()</code> 来更新数据库中的库存数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StrategyAwardStockKeyVO <span class="title">takeQueueValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String cacheKey = Constants.RedisKey.STRATEGY_AWARD_COUNT_QUERY_KEY;</span><br><span class="line">    RBlockingQueue&lt;StrategyAwardStockKeyVO&gt; destinationQueue = redisService.getBlockingQueue(cacheKey);</span><br><span class="line">    <span class="keyword">return</span> destinationQueue.poll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateStrategyAwardStock</span><span class="params">(Long strategyId, Integer awardId)</span> </span>&#123;</span><br><span class="line">    StrategyAward strategyAward = <span class="keyword">new</span> StrategyAward();</span><br><span class="line">    strategyAward.setStrategyId(strategyId);</span><br><span class="line">    strategyAward.setAwardId(awardId);</span><br><span class="line">    strategyAwardDao.updateStrategyAwardStock(strategyAward);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateStrategyAwardStock"</span> &gt;</span></span><br><span class="line">    UPDATE strategy_award</span><br><span class="line">    SET award_count_surplus = award_count_surplus -1</span><br><span class="line">    WHERE strategy_id = #&#123;strategyId&#125;</span><br><span class="line">      AND award_id = #&#123;awardId&#125;</span><br><span class="line">      AND award_count_surplus &gt; 0</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Redis底层原理"><a href="#Redis底层原理" class="headerlink" title="Redis底层原理"></a>Redis底层原理</h2><h3 id="非独占锁的实现"><a href="#非独占锁的实现" class="headerlink" title="非独占锁的实现"></a>非独占锁的实现</h3><h4 id="getBucket-key-trySet-quot-lock-quot"><a href="#getBucket-key-trySet-quot-lock-quot" class="headerlink" title="getBucket(key).trySet(&quot;lock&quot;)"></a><code>getBucket(key).trySet(&quot;lock&quot;)</code></h4><p>在这个项目中我们实际上是这样来实现setNx的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在redissonService中包装了一层</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">setNx</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> redissonClient.getBucket(key).trySet(<span class="string">"lock"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>底层实现</strong>：<code>getBucket(key).trySet(&quot;lock&quot;)</code> 其实是对 Redis 中 <code>SETNX</code> 命令的封装。在 Redis 中，<code>SETNX</code> 的作用是：如果指定的 key 不存在，则设置它的值为指定的内容，并返回 <code>true</code>；如果 key 已经存在，则返回 <code>false</code>，表示锁已经被占用。</p>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>非可重入</strong>：一旦一个线程获得了锁，其他线程不能重复获取。</li>
<li><strong>没有自动释放</strong>：<code>trySet</code> 本身没有为锁设置过期时间，必须由客户端来手动管理锁的释放，否则可能会导致死锁。</li>
<li><strong>简洁性</strong>：这是一个比较简单、轻量的分布式锁实现，适用于对锁的功能要求不高的场景。</li>
</ul>
<p>然而，使用 <code>trySet</code> 只能确保锁的 <strong>唯一性</strong>，但并没有处理锁的 <strong>过期时间</strong>、<strong>可重入性</strong>、<strong>锁的安全性</strong>、<strong>自动续期</strong> 等功能，这些功能是分布式锁中非常关键的部分，尤其是在高并发的分布式场景中。</p>
<h4 id="getLock-锁（RLock）"><a href="#getLock-锁（RLock）" class="headerlink" title="getLock 锁（RLock）"></a><code>getLock</code> 锁（<code>RLock</code>）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RLock lock = redissonClient.getLock(key);</span><br></pre></td></tr></table></figure>
<p><code>getLock</code> 是 Redisson 提供的分布式锁 API，它背后是基于 Redis 实现的一个 <strong>可重入</strong>、<strong>可过期</strong>、<strong>高可用</strong> 的分布式锁。通过 <code>getLock(key)</code> 获取的锁会被封装为 <code>RLock</code> 对象，该锁提供了更多的功能和控制，尤其在复杂的分布式环境中，能够有效避免死锁和保证锁的释放。</p>
<ul>
<li><strong>底层实现</strong>：<code>getLock(key)</code> 返回的是一个 <code>RLock</code> 对象，它是基于 Redis 的原子命令（如 <code>SETNX</code>、<code>EXPIRE</code> 等）实现的分布式锁。<code>RLock</code> 提供了许多高级功能，如 <strong>可重入性</strong>、<strong>锁超时</strong>、<strong>自动释放</strong>、<strong>重试机制</strong> 等。</li>
<li><strong>特点</strong>：<ul>
<li><strong>重入性</strong>：同一线程可以多次获取同一把锁，而不会导致死锁。</li>
<li><strong>锁过期</strong>：可以指定锁的过期时间，确保锁不会因为线程崩溃或异常释放导致死锁。</li>
<li><strong>高并发安全性</strong>：通过 <code>lock()</code>、<code>tryLock()</code> 等方法，确保锁的可靠性。</li>
<li><strong>操作简便性</strong>：通过 <code>RLock</code> 对象，可以使用锁的操作方法来直接控制锁的行为，如 <code>lock()</code>, <code>unlock()</code>, <code>tryLock()</code> 等。</li>
</ul>
</li>
</ul>
<h3 id="RDelayedQueue"><a href="#RDelayedQueue" class="headerlink" title="RDelayedQueue"></a>RDelayedQueue</h3><p>在 Redisson 中，<code>RDelayedQueue</code> 是基于 Redis 的 <strong>延迟队列</strong> 实现的，它允许你将任务延迟一段时间后再执行。在你的代码中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delayedQueue.offer(strategyAwardStockKeyVO, <span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p>这行代码的意思是将 <code>strategyAwardStockKeyVO</code> 对象放入一个延迟队列中，并设置延迟时间为 3 秒。底层实现的核心原理如下：</p>
<h4 id="1-RDelayedQueue-的工作原理"><a href="#1-RDelayedQueue-的工作原理" class="headerlink" title="1. RDelayedQueue 的工作原理"></a>1. <strong>RDelayedQueue 的工作原理</strong></h4><p><img src="/2024/11/14/redis%E5%AE%9E%E7%8E%B0%E9%98%B2%E8%B6%85%E5%8D%96%E7%AD%96%E7%95%A5/4.jpg" style="zoom:67%;"></p>
<ul>
<li><strong>redisson_delay_queue_timeout:xxx</strong>，sorted set数据类型，存放所有延迟任务，按照延迟任务的到期时间戳（提交任务时的时间戳 + 延迟时间）来排序的，所以列表的最前面的第一个元素就是整个延迟队列中最早要被执行的任务，这个概念很重要</li>
<li><strong>redisson_delay_queue:xxx</strong>，list数据类型，暂时没发现什么用，只是在提交任务时会写入这里面，队列转移时又会删除里面的元素。如果直接对 DelayedQueue执行poll()操作，不管有没有过期，都会删除list和sorted set中的元素。</li>
<li><strong>xxx</strong>：list数据类型，被称为目标队列，这个里面存放的任务都是已经到了延迟时间的，可以被消费者获取的任务，所以上面demo中的RBlockingQueue的take方法是从这个目标队列中获取到任务的</li>
<li><strong>redisson_delay_queue_channel:xxx</strong>，是一个channel，用来通知客户端开启一个延迟任务</li>
</ul>
<h4 id="2-底层流程"><a href="#2-底层流程" class="headerlink" title="2. 底层流程"></a>2. <strong>底层流程</strong></h4><ul>
<li><strong>设置延迟时间</strong>：<ul>
<li>当你调用 <code>offer(strategyAwardStockKeyVO, 3, TimeUnit.SECONDS)</code> 时，Redisson 会计算出当前时间加上 3 秒钟的时间戳（例如，假设当前时间是 <code>T</code>，那么延迟时间戳为 <code>T + 3秒</code>）。</li>
<li>然后，Redisson 会将 <code>strategyAwardStockKeyVO</code> 对象存储到 Redis 的 Sorted Set 中，<code>score</code> 为 <code>T + 3秒</code>，并且 <code>value</code> 为 <code>strategyAwardStockKeyVO</code>。</li>
</ul>
</li>
<li><strong>等待时间到达</strong>：<ul>
<li><code>RDelayedQueue</code> 并不会阻塞执行线程，而是会周期性地检查 Redis 中的元素的 <code>score</code>（即延迟时间）。</li>
<li>直到当前时间大于或等于元素的延迟时间，Redisson 才会将该元素从 Sorted Set 中移除，并放入到 <strong><code>RBlockingQueue</code></strong> 中。</li>
<li>由于 <code>RBlockingQueue</code> 是一个阻塞队列，一旦元素被添加到该队列中，消费者就可以从中获取到元素。</li>
</ul>
</li>
</ul>
<p><img src="/2024/11/14/redis%E5%AE%9E%E7%8E%B0%E9%98%B2%E8%B6%85%E5%8D%96%E7%AD%96%E7%95%A5/5.jpg" style="zoom:67%;"></p>
<h4 id="RBlockingQueue-和-RDelayedQueue-的协作"><a href="#RBlockingQueue-和-RDelayedQueue-的协作" class="headerlink" title="RBlockingQueue 和 RDelayedQueue 的协作"></a><strong><code>RBlockingQueue</code> 和 <code>RDelayedQueue</code> 的协作</strong></h4><p><strong>协作流程</strong>：<code>RDelayedQueue</code> 的底层实现依赖于 <code>RBlockingQueue</code>，因此在使用 <code>RDelayedQueue</code> 时，需要传入一个 <code>RBlockingQueue</code> 作为参数。这是因为 <code>RDelayedQueue</code> 的设计目的在于实现带延迟的队列，它的核心功能是允许元素被延迟消费。 而延迟的元素需要在最终消费时，依赖于 <code>RBlockingQueue</code> 的阻塞队列特性。</p>
<p>为了实现这一点，<code>RDelayedQueue</code> 需要借助 <code>RBlockingQueue</code> 的阻塞队列功能，即：</p>
<ol>
<li><strong>延迟入队：</strong><ul>
<li>当元素被放入 <code>RDelayedQueue</code> 时，它并不会立即被消费，而是根据延迟时间来计算何时能被消费。</li>
</ul>
</li>
<li><strong>延迟消费：</strong><ul>
<li>一旦延迟时间到了，元素会被消费，但消费过程需要阻塞等待。这个阻塞等待过程正是通过 <code>RBlockingQueue</code> 来实现的。</li>
<li><code>RBlockingQueue</code> 提供了 <code>take()</code>、<code>poll()</code> 等阻塞方法，直到元素满足延迟消费条件后，才会从队列中取出并消费。</li>
</ul>
</li>
</ol>
<h3 id="set-和-setNX"><a href="#set-和-setNX" class="headerlink" title="set 和 setNX"></a>set 和 setNX</h3><p>Redis 底层是单线程的，所有命令执行都是顺序的，所以 <code>SET</code> 和 <code>SETNX</code> 命令在 Redis 的单线程环境下都会按顺序执行，不会出现并发执行的问题。但它们之间有一些重要的区别，尤其在 <strong>命令的行为</strong> 和 <strong>用法场景</strong> 上。</p>
<h3 id="命令的区别"><a href="#命令的区别" class="headerlink" title="命令的区别"></a>命令的区别</h3><ul>
<li><p><strong><code>SET</code> 命令</strong>：用于设置一个键值对。如果指定的 <code>key</code> 已经存在，它会覆盖原有的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key value</span><br></pre></td></tr></table></figure>
<ul>
<li>如果 <code>key</code> 已经存在，<code>SET</code> 会直接更新该 <code>key</code> 的值。</li>
<li>如果 <code>key</code> 不存在，则会插入新的 <code>key-value</code> 对。</li>
</ul>
</li>
<li><p><strong><code>SETNX</code> 命令</strong>：用于在 <code>key</code> 不存在时，设置该 <code>key</code> 的值。如果 <code>key</code> 已经存在，则 <strong>不执行任何操作</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETNX key value</span><br></pre></td></tr></table></figure>
<ul>
<li>如果 <code>key</code> 已经存在，<code>SETNX</code> 不会对该 <code>key</code> 进行任何修改，返回 <code>0</code>。</li>
<li>如果 <code>key</code> 不存在，则设置 <code>key</code> 的值，并返回 <code>1</code>。</li>
</ul>
</li>
</ul>
<p><strong><code>SETNX</code> 的用途</strong>：由于它只有在 <code>key</code> 不存在时才设置 <code>key</code>，这使得它成为实现分布式锁的一种非常有效的方式。你可以通过 <code>SETNX</code> 来尝试获取一个锁（设置一个 <code>key</code>），如果锁已存在，其他请求就无法获取到这个锁，从而避免了竞争条件。</p>
<p>例如，执行 <code>SETNX</code> 命令时，如果某个资源已经被占用（<code>key</code> 已存在），则其他线程或进程就无法再占用这个资源。这种特性使得它成为分布式系统中控制资源争用的一种常用手段。</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2024/11/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/11/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-java/" itemprop="url">设计模式-java</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-11-11T14:14:41+08:00">
                2024-11-11
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2024-11-18T11:57:54+08:00">
                2024-11-18
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p><strong>应用场景</strong>：</p>
<ul>
<li>在 <code>DefaultLogicFactory</code> 类中，实现了一个典型的工厂模式。在Spring框架下非常实用，工厂模式用于创建对象，不直接使用 <code>new</code> 操作符实例化对象，而是通过调用一个工厂方法来获取新对象的实例。在这种情况下，工厂方法（构造函数）负责从一组 <code>ILogicFilter</code> 实例中读取元数据并创建一个管理这些过滤器实例的映射。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>工厂模式支持编程的抽象层级，并允许系统在不修改现有代码的情况下引入新的逻辑过滤器类型，符合开闭原则</li>
</ul>
<p>参考资料：<a href="https://bugstack.cn/md/develop/design-pattern/2020-05-20-%E9%87%8D%E5%AD%A6Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8A%E5%AE%9E%E6%88%98%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E3%80%8B.html" target="_blank" rel="noopener">https://bugstack.cn/md/develop/design-pattern/2020-05-20-%E9%87%8D%E5%AD%A6Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8A%E5%AE%9E%E6%88%98%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E3%80%8B.html</a></p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>最近在跟大营销项目，里面的一些设计还是慢巧妙地。这边也梳理一下并加强对系统的理解.</p>
<p><img src="/2024/11/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-java/1.png" style="zoom:67%;"></p>
<p>当前在strategy 领域中，结构如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── adapter</span><br><span class="line">│   └── repository</span><br><span class="line">│       └── IStrategyRepository.java</span><br><span class="line">├── model</span><br><span class="line">│   ├── entity</span><br><span class="line">│   │   ├── RaffleAwardEntity.java</span><br><span class="line">│   │   ├── RaffleFactorEntity.java</span><br><span class="line">│   │   ├── RuleActionEntity.java</span><br><span class="line">│   │   ├── RuleMatterEntity.java</span><br><span class="line">│   │   ├── StrategyAwardEntity.java</span><br><span class="line">│   │   ├── StrategyEntity.java</span><br><span class="line">│   │   └── StrategyRuleEntity.java</span><br><span class="line">│   └── vo</span><br><span class="line">│       └── RuleLogicCheckTypeVO.java</span><br><span class="line">└── service</span><br><span class="line">    ├── IRaffleStrategy.java</span><br><span class="line">    ├── annotation</span><br><span class="line">    │   └── LogicStrategy.java</span><br><span class="line">    ├── armory</span><br><span class="line">    │   ├── IStrategyArmory.java</span><br><span class="line">    │   ├── IStrategyDispatch.java</span><br><span class="line">    │   └── StrategyArmoryDispatch.java</span><br><span class="line">    ├── raffle</span><br><span class="line">    │   ├── AbstractRaffleStrategy.java</span><br><span class="line">    │   └── DefaultRaffleStrategy.java</span><br><span class="line">    └── rule</span><br><span class="line">        ├── ILogicFilter.java</span><br><span class="line">        ├── factory</span><br><span class="line">        │   └── DefaultLogicFactory.java</span><br><span class="line">        └── impl</span><br><span class="line">            ├── RuleBlackListLogicFilter.java</span><br><span class="line">            └── RuleWeightLogicFilter.java</span><br></pre></td></tr></table></figure>
<p>整个抽奖的逻辑是这样的：</p>
<ol>
<li>首先，传入一个<code>RaffleFactorEntity</code> ,包含用户ID和策略ID，然后调用<code>RaffleStrategy</code>来执行查询。</li>
<li>在执行查询前，需要根据策略ID获取规则模型，再根据规则模型前置过滤，以实现黑名单功能和权重匹配功能</li>
<li>执行查询，用户的积分不同，奖品范围也不同；如果是黑名单，那么只会返回一个最低档的积分。</li>
</ol>
<p>在这里我们重点关注以下2部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">├── annotation</span><br><span class="line">    │   └── LogicStrategy.java</span><br><span class="line">└── rule</span><br><span class="line">    ├── ILogicFilter.java</span><br><span class="line">    ├── factory</span><br><span class="line">    │   └── DefaultLogicFactory.java</span><br><span class="line">    └── impl</span><br><span class="line">        ├── RuleBlackListLogicFilter.java</span><br><span class="line">        └── RuleWeightLogicFilter.java</span><br></pre></td></tr></table></figure>
<p>其中，annotation中的LogicStrategy是一个自定义的注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LogicStrategy &#123;</span><br><span class="line">    DefaultLogicFactory.<span class="function">LogicModel <span class="title">logicMode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>@Target({ElementType.TYPE})</strong>：这表明 <code>LogicStrategy</code> 注解可以被用于类、接口或枚举声明。这意味着不能将此注解用于方法、字段等，只能标注在类等类型上。</p>
</li>
<li><p><strong>@Retention(RetentionPolicy.RUNTIME)</strong>：这表明 <code>LogicStrategy</code> 注解不仅会被编译器记录在类文件中，而且在运行时通过反射仍然可见。这是实现动态逻辑处理中关键的部分，因为它允许程序在运行时查询这些注解信息。</p>
</li>
</ul>
<p>因此，只要在我实现的过滤器类上，应用了 <code>LogicStrategy</code>注解，就需要指定一个特定的策略模式。此外我还用@Component注解，Spring 容器会在应用启动时自动识别并实例化该类的对象，将其注册为 Spring 管理的 Bean。并注入到需要这个Bean的地方去。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@LogicStrategy</span>(logicMode = DefaultLogicFactory.LogicModel.RULE_BLACKLIST)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleBlackListLogicFilter</span> <span class="keyword">implements</span> <span class="title">ILogicFilter</span>&lt;<span class="title">RuleActionEntity</span>.<span class="title">RaffleBeforeEntity</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 实现细节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@LogicStrategy</span>(logicMode = DefaultLogicFactory.LogicModel.RULE_WEIGHT)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleWeightLogicFilter</span> <span class="keyword">implements</span> <span class="title">ILogicFilter</span>&lt;<span class="title">RuleActionEntity</span>.<span class="title">RaffleBeforeEntity</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 实现细节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 factory中的DefaultLogicFactory是一个工厂类，实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultLogicFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, ILogicFilter&lt;?&gt;&gt; logicFilterMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultLogicFactory</span><span class="params">(List&lt;ILogicFilter&lt;?&gt;&gt; logicFilters)</span> </span>&#123;</span><br><span class="line">        logicFilters.forEach(logic -&gt; &#123;</span><br><span class="line">            LogicStrategy strategy = AnnotationUtils.findAnnotation(logic.getClass(), LogicStrategy<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != strategy) &#123;</span><br><span class="line">                logicFilterMap.put(strategy.logicMode().getCode(), logic);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">public</span> &lt;T extends RuleActionEntity.RaffleEntity&gt; Map&lt;String, ILogicFilter&lt;T&gt;&gt; openLogicFilter() &#123;</span><br><span class="line">        <span class="keyword">return</span> (Map&lt;String, ILogicFilter&lt;T&gt;&gt;) (Map&lt;?, ?&gt;) logicFilterMap;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@AllArgsConstructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> LogicModel &#123;</span><br><span class="line"></span><br><span class="line">        RULE_WIGHT(<span class="string">"rule_weight"</span>,<span class="string">"【抽奖前规则】根据抽奖权重返回可抽奖范围KEY"</span>),</span><br><span class="line">        RULE_BLACKLIST(<span class="string">"rule_blacklist"</span>,<span class="string">"【抽奖前规则】黑名单规则过滤，命中黑名单则直接返回"</span>),</span><br><span class="line">        ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String code;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String info;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>依赖注入</strong>：在 <code>DefaultLogicFactory</code> 的构造函数中，我指定了一个 <code>List&lt;ILogicFilter&lt;?&gt;&gt;</code> 类型的参数。这告诉 Spring，这个构造函数需要注入所有匹配 <code>ILogicFilter&lt;?&gt;</code> 类型的 Beans。</li>
<li><strong>集合注入</strong>：Spring 支持集合类型的依赖注入。当我在构造函数中使用如 <code>List&lt;ILogicFilter&lt;?&gt;&gt;</code> 这样的集合类型时，Spring 会自动收集<strong>所有可用的</strong> <code>ILogicFilter&lt;?&gt;</code> 实例并作为列表注入。这包括所有单独声明的实现了 <code>ILogicFilter&lt;?&gt;</code> 接口的类，例如<code>RuleBlackListLogicFilter</code>。</li>
<li><strong>在构造函数中处理逻辑</strong>：一旦 <code>DefaultLogicFactory</code> 获得所有逻辑过滤器的实例，它会遍历这些实例，使用 <code>AnnotationUtils.findAnnotation</code> 检查每个实例是否有 <code>@LogicStrategy</code> 注解。</li>
<li><strong>根据注解分类存储</strong>：如果发现 <code>@LogicStrategy</code> 注解，就会根据注解中指定的策略模式代码将对应的过滤器存储在 <code>logicFilterMap</code> 中。</li>
</ul>
<h2 id="工厂模式-责任链模式"><a href="#工厂模式-责任链模式" class="headerlink" title="工厂模式+责任链模式"></a>工厂模式+责任链模式</h2><h3 id="未优化的代码"><a href="#未优化的代码" class="headerlink" title="未优化的代码"></a>未优化的代码</h3><p>原来的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. 抽奖前 - 规则过滤</span></span><br><span class="line">RuleActionEntity&lt;RuleActionEntity.RaffleBeforeEntity&gt; ruleActionBeforeEntity = <span class="keyword">this</span>.doCheckRaffleBeforeLogic(RaffleFactorEntity.builder()</span><br><span class="line">        .userId(userId)</span><br><span class="line">        .strategyId(strategyId)</span><br><span class="line">        .build(), strategy.ruleModels());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (RuleLogicCheckTypeVO.TAKE_OVER.getCode().equals(ruleActionBeforeEntity.getCode())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (DefaultLogicFactory.LogicModel.RULE_BLACKLIST.getCode().equals(ruleActionBeforeEntity.getRuleModel())) &#123;</span><br><span class="line">        <span class="comment">// 黑名单返回固定的奖品ID</span></span><br><span class="line">        <span class="keyword">return</span> RaffleAwardEntity.builder()</span><br><span class="line">                .awardId(ruleActionBeforeEntity.getData().getAwardId())</span><br><span class="line">                .build();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DefaultLogicFactory.LogicModel.RULE_WIGHT.getCode().equals(ruleActionBeforeEntity.getRuleModel())) &#123;</span><br><span class="line">        <span class="comment">// 权重根据返回的信息进行抽奖</span></span><br><span class="line">        RuleActionEntity.RaffleBeforeEntity raffleBeforeEntity = ruleActionBeforeEntity.getData();</span><br><span class="line">        String ruleWeightValueKey = raffleBeforeEntity.getRuleWeightValueKey();</span><br><span class="line">        Integer awardId = strategyDispatch.getRandomAwardId(strategyId, ruleWeightValueKey);</span><br><span class="line">        <span class="keyword">return</span> RaffleAwardEntity.builder()</span><br><span class="line">                .awardId(awardId)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 默认抽奖流程</span></span><br><span class="line">Integer awardId = strategyDispatch.getRandomAwardId(strategyId);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> RuleActionEntity&lt;RuleActionEntity.RaffleBeforeEntity&gt; doCheckRaffleBeforeLogic(RaffleFactorEntity raffleFactorEntity, String... logics) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logics == <span class="keyword">null</span> || <span class="number">0</span> == logics.length) <span class="keyword">return</span> RuleActionEntity.&lt;RuleActionEntity.RaffleBeforeEntity&gt;builder()</span><br><span class="line">            .code(RuleLogicCheckTypeVO.ALLOW.getCode())</span><br><span class="line">            .info(RuleLogicCheckTypeVO.ALLOW.getInfo())</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    Map&lt;String, ILogicFilter&lt;RuleActionEntity.RaffleBeforeEntity&gt;&gt; logicFilterGroup = logicFactory.openLogicFilter();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 黑名单规则优先过滤</span></span><br><span class="line">    String ruleBackList = Arrays.stream(logics)</span><br><span class="line">            .filter(str -&gt; str.contains(DefaultLogicFactory.LogicModel.RULE_BLACKLIST.getCode()))</span><br><span class="line">            .findFirst()</span><br><span class="line">            .orElse(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotBlank(ruleBackList)) &#123;</span><br><span class="line">        ILogicFilter&lt;RuleActionEntity.RaffleBeforeEntity&gt; logicFilter = logicFilterGroup.get(DefaultLogicFactory.LogicModel.RULE_BLACKLIST.getCode());</span><br><span class="line">        RuleMatterEntity ruleMatterEntity = <span class="keyword">new</span> RuleMatterEntity();</span><br><span class="line">        ruleMatterEntity.setUserId(raffleFactorEntity.getUserId());</span><br><span class="line">        ruleMatterEntity.setAwardId(ruleMatterEntity.getAwardId());</span><br><span class="line">        ruleMatterEntity.setStrategyId(raffleFactorEntity.getStrategyId());</span><br><span class="line">        ruleMatterEntity.setRuleModel(DefaultLogicFactory.LogicModel.RULE_BLACKLIST.getCode());</span><br><span class="line">        RuleActionEntity&lt;RuleActionEntity.RaffleBeforeEntity&gt; ruleActionEntity = logicFilter.filter(ruleMatterEntity);</span><br><span class="line">        <span class="keyword">if</span> (!RuleLogicCheckTypeVO.ALLOW.getCode().equals(ruleActionEntity.getCode())) &#123;</span><br><span class="line">            <span class="keyword">return</span> ruleActionEntity;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 顺序过滤剩余规则</span></span><br><span class="line">    List&lt;String&gt; ruleList = Arrays.stream(logics)</span><br><span class="line">            .filter(s -&gt; !s.equals(DefaultLogicFactory.LogicModel.RULE_BLACKLIST.getCode()))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    RuleActionEntity&lt;RuleActionEntity.RaffleBeforeEntity&gt; ruleActionEntity = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (String ruleModel : ruleList) &#123;</span><br><span class="line">        ILogicFilter&lt;RuleActionEntity.RaffleBeforeEntity&gt; logicFilter = logicFilterGroup.get(ruleModel);</span><br><span class="line">        RuleMatterEntity ruleMatterEntity = <span class="keyword">new</span> RuleMatterEntity();</span><br><span class="line">        ruleMatterEntity.setUserId(raffleFactorEntity.getUserId());</span><br><span class="line">        ruleMatterEntity.setAwardId(raffleFactorEntity.getAwardId());</span><br><span class="line">        ruleMatterEntity.setStrategyId(raffleFactorEntity.getStrategyId());</span><br><span class="line">        ruleMatterEntity.setRuleModel(ruleModel);</span><br><span class="line">        ruleActionEntity = logicFilter.filter(ruleMatterEntity);</span><br><span class="line">        <span class="comment">// 非放行结果则顺序过滤</span></span><br><span class="line">        log.info(<span class="string">"抽奖前规则过滤 userId: &#123;&#125; ruleModel: &#123;&#125; code: &#123;&#125; info: &#123;&#125;"</span>, raffleFactorEntity.getUserId(), ruleModel, ruleActionEntity.getCode(), ruleActionEntity.getInfo());</span><br><span class="line">        <span class="keyword">if</span> (!RuleLogicCheckTypeVO.ALLOW.getCode().equals(ruleActionEntity.getCode())) <span class="keyword">return</span> ruleActionEntity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ruleActionEntity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们需要思考，在 <code>doCheckRaffleBeforeLogic</code> 方法中，所有规则的逻辑集中在一个方法内。虽然代码结构相对清晰，但它依然耦合了不同规则的判断逻辑（如黑名单和权重规则），使得方法臃肿且难以单独维护。比如，我们还要实现一个白名单规则，那么就要在这个<code>doCheckRaffleBeforeLogic</code> 方法中确定其位置，这会使得方法不断增大、复杂，切不容易理解各个规则的优先级。</p>
<p>因此，我们可以将每个规则处理器作为一个独立的类，各自实现独立的logic方法。不同规则的逻辑和判断被分离到不同的责任链节点中，代码更加模块化。比如，我们想要创建一个新的责任链节点 <code>WhiteListLogicChain</code>, 我们只需要在工厂中将其加入链条，而不是像原来那样修改<code>doCheckRaffleBeforeLogic</code> 方法。 极大地降低了代码的耦合性和维护成本。</p>
<p>示意图如下所示：</p>
<p><img src="/2024/11/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-java/2.png" style="zoom:67%;"></p>
<h3 id="重构-链节点"><a href="#重构-链节点" class="headerlink" title="重构-链节点"></a>重构-链节点</h3><p>对于原来的Filter，现在我们将其变成责任链上的一个节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILogicChainArmory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">ILogicChain <span class="title">appendNext</span><span class="params">(ILogicChain next)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ILogicChain <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILogicChain</span>  <span class="keyword">extends</span> <span class="title">ILogicChainArmory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 责任链接口</span></span><br><span class="line"><span class="comment">     * @param userId        用户ID</span></span><br><span class="line"><span class="comment">     * @param strategyId    策略ID</span></span><br><span class="line"><span class="comment">     * @return 奖品ID</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function">Integer <span class="title">logic</span><span class="params">(String userId, Long Strategy)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractLogicChain</span> <span class="keyword">implements</span> <span class="title">ILogicChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ILogicChain next;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ILogicChain <span class="title">appendNext</span><span class="params">(ILogicChain next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ILogicChain <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">ruleModel</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>这是类似于一个链表的数据结构，每个ILogicChain节点都会指向下一节点。</p>
</li>
<li><p>此外，如果一个节点继承了这个抽象节点类<code>AbstractLogicChain</code>, 那么他还需要实现<code>logic()</code>方法,里面具体实现规则过滤逻辑。</p>
</li>
</ul>
<p>比如，这个责任链上有一个黑名单过滤节点：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"rule_blacklist"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackListLogicChain</span> <span class="keyword">extends</span> <span class="title">AbstractLogicChain</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IStrategyRepository strategyRepository;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">logic</span><span class="params">(String userId, Long strategyId)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"抽奖责任链-黑名单开始 userId:&#123;&#125; strategyId:&#123;&#125; ruleModel:&#123;&#125; "</span>, userId, strategyId,ruleModel());</span><br><span class="line">        String ruleValue = strategyRepository.queryStrategyRuleValue(strategyId, ruleModel());</span><br><span class="line"></span><br><span class="line">        String[] splitRuleValue = ruleValue.split(Constants.COLON);</span><br><span class="line">        Integer awardId = Integer.valueOf(splitRuleValue[<span class="number">0</span>]);</span><br><span class="line">        String[] userNames = splitRuleValue[<span class="number">1</span>].split(Constants.SPLIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 100:user001,user002,user003 判断ruleMatterEntity.getUserId()是否在黑名单中</span></span><br><span class="line">        <span class="keyword">boolean</span> isBlackListed = Arrays.asList(userNames).contains(userId);</span><br><span class="line">        <span class="keyword">if</span>(isBlackListed)&#123;</span><br><span class="line">            log.info(<span class="string">"抽奖责任链-黑名单接管 userId:&#123;&#125; strategyId:&#123;&#125; ruleModel:&#123;&#125; "</span>, userId, strategyId,ruleModel());</span><br><span class="line">            <span class="keyword">return</span> awardId;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"抽奖责任链-黑名单放行 userId:&#123;&#125; strategyId:&#123;&#125; ruleModel:&#123;&#125; "</span>, userId, strategyId,ruleModel());</span><br><span class="line">        <span class="keyword">return</span> next().logic(userId, strategyId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">ruleModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"rule_blacklist"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该节点根据<code>userId</code>和<code>strategyId</code> 获取<code>ruleValue</code>,判断当前用户是否在黑名单中。</p>
<ul>
<li>如果是，那么就接管，并返回一个特定的低保奖品</li>
<li>如果否，就放行，然后调用责任链的下一个节点，交给别人去判断</li>
</ul>
<p>此外，我们还需要一个默认节点，如果规则对这个用户都不适用，那么就返回一个默认值。在抽奖系统中，就是随便抽。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"default"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultLogicChain</span> <span class="keyword">extends</span> <span class="title">AbstractLogicChain</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">protected</span> IStrategyDispatch strategyDispatch;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">logic</span><span class="params">(String userId, Long strategyId)</span> </span>&#123;</span><br><span class="line">        Integer awardId = strategyDispatch.getRandomAwardId(strategyId);</span><br><span class="line">        log.info(<span class="string">"抽奖责任链-默认处理 userId: &#123;&#125;, strategyId: &#123;&#125; ruleModel: &#123;&#125; awardId: &#123;&#125;"</span>, userId, strategyId,ruleModel(), awardId);</span><br><span class="line">        <span class="keyword">return</span> awardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">ruleModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"default"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重构-链工厂"><a href="#重构-链工厂" class="headerlink" title="重构-链工厂"></a>重构-链工厂</h3><p>构建了节点之后，相当于我们有了很多乐高碎片，那么需要一个工厂类，将它们组装成一个链，于是需要：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultChainFactory</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ILogicChain&gt; logicChainGroup;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IStrategyRepository strategyRepository;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultChainFactory</span><span class="params">(Map&lt;String, ILogicChain&gt; logicChainGroup, IStrategyRepository strategyRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.logicChainGroup = logicChainGroup;</span><br><span class="line">        <span class="keyword">this</span>.strategyRepository = strategyRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ILogicChain <span class="title">openLogicChain</span><span class="params">(Long strategyId)</span></span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      获取规则列表：openLogicChain 方法根据传入的 strategyId </span></span><br><span class="line"><span class="comment">			从 strategyRepository 获取该策略对应的规则列表 ruleModels。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">        StrategyEntity strategy = strategyRepository.queryStrategyEntityByStrategyId(strategyId);</span><br><span class="line">        String[] ruleModels = strategy.ruleModels();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == ruleModels || ruleModels.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> logicChainGroup.get(<span class="string">"default"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">			</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      动态构建链条：根据 ruleModels 中的规则顺序，</span></span><br><span class="line"><span class="comment">      从 logicChainGroup 中获取对应的 ILogicChain 实例。</span></span><br><span class="line"><span class="comment">      以链条的方式将每个规则节点按顺序连接起来，最终形成一条完整的责任链。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">			通过先提取 ruleModels[0] 并将其赋值给 logicChain（作为链条的起始节点）</span></span><br><span class="line"><span class="comment">			可以避免在循环中处理第一个节点的特殊逻辑。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">        ILogicChain logicChain = logicChainGroup.get(ruleModels[<span class="number">0</span>]);</span><br><span class="line">        ILogicChain current = logicChain;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ruleModels.length; i++) &#123;</span><br><span class="line">            ILogicChain nextChain = logicChainGroup.get(ruleModels[i]);</span><br><span class="line">            current = current.appendNext(nextChain);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      默认节点：在链条末尾追加一个默认节点（"default"），</span></span><br><span class="line"><span class="comment">      以保证在规则链中没有匹配规则时，责任链可以安全结束。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">        current.appendNext(logicChainGroup.get(<span class="string">"default"</span>));</span><br><span class="line">        <span class="keyword">return</span> logicChain;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个工厂类基于 <strong>责任链模式</strong> 和 <strong>工厂模式</strong> 的组合，通过动态组合链条节点来生成完整的责任链，具体实现策略模式的行为选择。以下是该工厂类的关键设计思路：</p>
<ol>
<li><strong>工厂模式</strong>：<code>DefaultChainFactory</code> 是一个工厂类，用于构建 <code>ILogicChain</code> 的责任链。它根据输入的<code>strategyId</code> 查询策略对应的规则，然后按顺序从 <code>logicChainGroup</code> 中取出这些规则节点，将它们组装成一条链。</li>
<li><strong>责任链模式</strong>：工厂类生成的 <code>ILogicChain</code> 实例是由多个链式节点组成的责任链。每个链节点都可以在链条中处理请求或将请求传递给下一个节点。这样，规则在链条中按顺序依次处理，每个规则的逻辑独立且具有优先级（顺序）。</li>
<li><strong>基于规则的动态链式构建</strong>：<code>openLogicChain</code> 方法根据策略查询到的规则列表动态构建责任链。这种设计确保了链条的灵活性：可以根据不同的规则列表动态生成不同的链条，而不是依赖固定的逻辑顺序。</li>
</ol>
<p>最后，我们需要修改一开始的抽奖操作，那一大段规则过滤的代码可以简化为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2. 责任链抽奖</span></span><br><span class="line">ILogicChain logicChain = chainFactory.openLogicChain(strategyId);</span><br><span class="line">Integer randomAwardId = logicChain.logic(userId, strategyId);</span><br></pre></td></tr></table></figure>
<p><strong>构造责任链</strong>：比如该策略的ruleModels为<code>rule_blacklist,rule_weight</code>。 那么责任链就是 <code>rule_blacklist -&gt; rule_weight -&gt; default</code> 先过滤黑名单，再过滤权重，如果都放行，那么执行默认抽奖。</p>
<h2 id="规则树构建"><a href="#规则树构建" class="headerlink" title="规则树构建"></a>规则树构建</h2><p>解决了前置规则过滤，现在我们来看看抽奖中规则过滤。逻辑是这样的：</p>
<p><img src="/2024/11/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-java/3.png" style="zoom:80%;"></p>
<p>这是一个非多分支情况的规则过滤。单独的责任链是不能满足的，如果是拆分开抽奖中规则和抽奖后规则分阶段处理，中间单独写逻辑处理库存操作。那么是可以实现的。但这样的方式始终不够优雅，配置化的内容较低，后续的规则开发仍需要在代码上改造。所以这里可以使用规则树的结构，实现规则过滤。</p>
<p>因此，我们需要把库存处理也当做是一种规则，库存足够，说明满足规则，放行；库存不够，说明不满足规则，接管—&gt;给兜底奖励。流程如下：</p>
<p><img src="/2024/11/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-java/4.png" style="zoom:67%;"></p>
<h3 id="规则树结构"><a href="#规则树结构" class="headerlink" title="规则树结构"></a>规则树结构</h3><ol>
<li><strong>接口 <code>ILogicTreeNode</code></strong>：<ul>
<li>定义了树节点的基础操作，即 <code>logic</code> 方法。每个节点都有 <code>logic</code> 方法来判断当前节点是否符合条件，并返回相应的决策状态。</li>
</ul>
</li>
<li><strong>具体实现节点 <code>RuleStockLogicTreeNode</code>、<code>RuleLuckAwardLogicTreeNode</code>、<code>RuleLockLogicTreeNode</code></strong>：<ul>
<li>每个节点实现了 <code>ILogicTreeNode</code>，并定义了各自的逻辑。例如，<code>RuleStockLogicTreeNode</code> 和 <code>RuleLuckAwardLogicTreeNode</code> 返回 <code>TAKE_OVER</code>，表示节点接管；<code>RuleLockLogicTreeNode</code> 返回 <code>ALLOW</code>，表示放行到下一个节点。</li>
</ul>
</li>
<li><strong>工厂类 <code>DefaultTreeFactory</code></strong>：<ul>
<li>负责管理不同的 <code>ILogicTreeNode</code> 实例。通过构造器注入 <code>Map&lt;String, ILogicTreeNode&gt;</code>，在运行时动态决定使用哪种节点逻辑。</li>
<li>提供 <code>openLogicTree</code> 方法生成决策树引擎 <code>DecisionTreeEngine</code>，并传入节点实例映射和规则树配置（<code>RuleTreeVO</code>）。</li>
</ul>
</li>
<li><strong>规则树引擎 <code>DecisionTreeEngine</code></strong>：<ul>
<li>核心逻辑处理类，用于遍历规则树，按顺序检查节点并作出决策。</li>
<li><code>process</code> 方法：从根节点开始，根据每个节点的决策结果决定下一步的执行节点。如果判断为接管，那么返回兜底奖励，如果判断为放行，则执行下一个节点。</li>
<li><code>nextNode</code> 方法：负责判断下一节点的路径，依据 <code>RuleTreeNodeLineVO</code> 中的条件是接管还是放行，决定进入的下一个节点。</li>
</ul>
</li>
<li><strong>规则数据对象（<code>RuleTreeNodeVO</code>、<code>RuleTreeNodeLineVO</code>、<code>RuleTreeVO</code>）</strong>：<ul>
<li><code>RuleTreeVO</code> 表示整个决策树结构，包括根节点、各个节点和连线。</li>
<li><code>RuleTreeNodeVO</code> 表示树中的单个节点，包含规则标识、描述、下一步连线等信息。</li>
<li><code>RuleTreeNodeLineVO</code> 表示节点之间的连线条件，包括条件类型（如等于、大于等）、下一节点等信息。</li>
</ul>
</li>
<li><strong>枚举 <code>RuleLimitTypeVO</code> 和 <code>RuleLogicCheckTypeVO</code></strong>：<ul>
<li><code>RuleLimitTypeVO</code>：定义了节点连线的判断条件（如等于、大于、枚举等），用于 <code>nextNode</code> 判断逻辑。</li>
<li><code>RuleLogicCheckTypeVO</code>：用于标识逻辑节点的检查结果，如 <code>TAKE_OVER</code> 表示节点接管、<code>ALLOW</code> 表示允许通过等。</li>
</ul>
</li>
</ol>
<p>测试如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * rule_lock --左--&gt; rule_luck_award</span></span><br><span class="line"><span class="comment"> *           --右--&gt; rule_stock --右--&gt; rule_luck_award</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_tree_rule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建参数</span></span><br><span class="line">    RuleTreeNodeVO rule_lock = RuleTreeNodeVO.builder()</span><br><span class="line">            .treeId(<span class="number">100000001</span>)</span><br><span class="line">            .ruleKey(<span class="string">"rule_lock"</span>)</span><br><span class="line">            .ruleDesc(<span class="string">"限定用户已完成N次抽奖后解锁"</span>)</span><br><span class="line">            .ruleValue(<span class="string">"1"</span>)</span><br><span class="line">            .treeNodeLineVOList(<span class="keyword">new</span> ArrayList&lt;RuleTreeNodeLineVO&gt;() &#123;&#123;</span><br><span class="line">                add(RuleTreeNodeLineVO.builder()</span><br><span class="line">                        .treeId(<span class="number">100000001</span>)</span><br><span class="line">                        .ruleNodeFrom(<span class="string">"rule_lock"</span>)</span><br><span class="line">                        .ruleNodeTo(<span class="string">"rule_luck_award"</span>)</span><br><span class="line">                        .ruleLimitType(RuleLimitTypeVO.EQUAL)</span><br><span class="line">                        .ruleLimitValue(RuleLogicCheckTypeVO.TAKE_OVER)</span><br><span class="line">                        .build());</span><br><span class="line"></span><br><span class="line">                add(RuleTreeNodeLineVO.builder()</span><br><span class="line">                        .treeId(<span class="number">100000001</span>)</span><br><span class="line">                        .ruleNodeFrom(<span class="string">"rule_lock"</span>)</span><br><span class="line">                        .ruleNodeTo(<span class="string">"rule_stock"</span>)</span><br><span class="line">                        .ruleLimitType(RuleLimitTypeVO.EQUAL)</span><br><span class="line">                        .ruleLimitValue(RuleLogicCheckTypeVO.ALLOW)</span><br><span class="line">                        .build());</span><br><span class="line">            &#125;&#125;)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    RuleTreeNodeVO rule_luck_award = RuleTreeNodeVO.builder()</span><br><span class="line">            .treeId(<span class="number">100000001</span>)</span><br><span class="line">            .ruleKey(<span class="string">"rule_luck_award"</span>)</span><br><span class="line">            .ruleDesc(<span class="string">"限定用户已完成N次抽奖后解锁"</span>)</span><br><span class="line">            .ruleValue(<span class="string">"1"</span>)</span><br><span class="line">            .treeNodeLineVOList(<span class="keyword">null</span>)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    RuleTreeNodeVO rule_stock = RuleTreeNodeVO.builder()</span><br><span class="line">            .treeId(<span class="number">100000001</span>)</span><br><span class="line">            .ruleKey(<span class="string">"rule_stock"</span>)</span><br><span class="line">            .ruleDesc(<span class="string">"库存处理规则"</span>)</span><br><span class="line">            .ruleValue(<span class="keyword">null</span>)</span><br><span class="line">            .treeNodeLineVOList(<span class="keyword">new</span> ArrayList&lt;RuleTreeNodeLineVO&gt;() &#123;&#123;</span><br><span class="line">                add(RuleTreeNodeLineVO.builder()</span><br><span class="line">                        .treeId(<span class="number">100000001</span>)</span><br><span class="line">                        .ruleNodeFrom(<span class="string">"rule_lock"</span>)</span><br><span class="line">                        .ruleNodeTo(<span class="string">"rule_luck_award"</span>)</span><br><span class="line">                        .ruleLimitType(RuleLimitTypeVO.EQUAL)</span><br><span class="line">                        .ruleLimitValue(RuleLogicCheckTypeVO.TAKE_OVER)</span><br><span class="line">                        .build());</span><br><span class="line">            &#125;&#125;)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    RuleTreeVO ruleTreeVO = <span class="keyword">new</span> RuleTreeVO();</span><br><span class="line">    ruleTreeVO.setTreeId(<span class="number">100000001</span>);</span><br><span class="line">    ruleTreeVO.setTreeName(<span class="string">"决策树规则；增加dall-e-3画图模型"</span>);</span><br><span class="line">    ruleTreeVO.setTreeDesc(<span class="string">"决策树规则；增加dall-e-3画图模型"</span>);</span><br><span class="line">    ruleTreeVO.setTreeRootRuleNode(<span class="string">"rule_lock"</span>);</span><br><span class="line"></span><br><span class="line">    ruleTreeVO.setTreeNodeMap(<span class="keyword">new</span> HashMap&lt;String, RuleTreeNodeVO&gt;() &#123;&#123;</span><br><span class="line">        put(<span class="string">"rule_lock"</span>, rule_lock);</span><br><span class="line">        put(<span class="string">"rule_stock"</span>, rule_stock);</span><br><span class="line">        put(<span class="string">"rule_luck_award"</span>, rule_luck_award);</span><br><span class="line">    &#125;&#125;);</span><br><span class="line"></span><br><span class="line">    IDecisionTreeEngine treeEngine = defaultTreeFactory.openLogicTree(ruleTreeVO);</span><br><span class="line"></span><br><span class="line">    DefaultTreeFactory.StrategyAwardData data = treeEngine.process(<span class="string">"xiaofuge"</span>, <span class="number">100001L</span>, <span class="number">100</span>);</span><br><span class="line">    log.info(<span class="string">"测试结果：&#123;&#125;"</span>, JSON.toJSONString(data));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行时的流程"><a href="#运行时的流程" class="headerlink" title="运行时的流程"></a>运行时的流程</h3><ol>
<li><strong>初始化决策树引擎</strong>：<ul>
<li><code>DefaultTreeFactory</code> 接收配置对象 <code>RuleTreeVO</code>，并调用 <code>openLogicTree</code> 方法生成 <code>DecisionTreeEngine</code>。</li>
</ul>
</li>
<li><strong>调用 <code>process</code> 方法</strong>：<ul>
<li>决策树引擎的 <code>process</code> 方法接收 <code>userId</code>、<code>strategyId</code>、<code>awardId</code>，并从 <code>RuleTreeVO</code> 中提取根节点开始执行。</li>
</ul>
</li>
<li><strong>遍历节点执行逻辑</strong>：<ul>
<li><code>process</code> 方法根据当前节点的 <code>ruleKey</code> 获取相应的 <code>ILogicTreeNode</code> 实现类。</li>
<li>调用节点的 <code>logic</code> 方法执行规则逻辑，返回 <code>TreeActionEntity</code>（包含 <code>ruleLogicCheckTypeVO</code> 和 <code>strategyAwardData</code>）。</li>
<li>通过<code>ruleLogicCheckTypeVO</code> 检查当前节点的执行结果：<ul>
<li><code>TAKE_OVER</code>：表示当前节点已经做出决策，直接返回 <code>strategyAwardData</code>，结束决策流程。</li>
<li><code>ALLOW</code>：表示允许继续执行，根据 <code>nextNode</code> 方法判断下一个节点。</li>
</ul>
</li>
</ul>
</li>
<li><strong>判断下一节点</strong>：<ul>
<li><code>nextNode</code> 方法根据 <code>RuleTreeNodeLineVO</code> 中的条件值和当前节点返回的状态判断下一步要执行的节点。</li>
<li>遍历 <code>treeNodeLineVOList</code>，调用 <code>decisionLogic</code> 方法根据连线条件决定是否满足要求。</li>
<li>如果满足要求，返回下一个节点的标识 <code>ruleNodeTo</code>，并将该节点作为下一步的处理节点。</li>
</ul>
</li>
<li><strong>返回决策结果</strong>：<ul>
<li>当流程到达某个 <code>TAKE_OVER</code> 节点或遍历完所有节点时，<code>process</code> 方法返回最终的 <code>StrategyAwardData</code>，包含最终的决策结果，如 <code>awardId</code> 和 <code>awardRuleValue</code>。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> DefaultTreeFactory.<span class="function">StrategyAwardVO <span class="title">process</span><span class="params">(String userId, Long strategyId, Integer awardId)</span> </span>&#123;</span><br><span class="line">    DefaultTreeFactory.StrategyAwardVO strategyAwardData = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    String nextNode = ruleTreeVO.getTreeRootRuleNode();</span><br><span class="line">    Map&lt;String, RuleTreeNodeVO&gt; treeNodeMap = ruleTreeVO.getTreeNodeMap();</span><br><span class="line"></span><br><span class="line">    RuleTreeNodeVO ruleTreeNodeVO = treeNodeMap.get(nextNode);</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">null</span> != nextNode) &#123;</span><br><span class="line">        ILogicTreeNode logicTreeNode = logicTreeNodeGroup.get(ruleTreeNodeVO.getRuleKey());</span><br><span class="line">        String ruleValue = ruleTreeNodeVO.getRuleValue();</span><br><span class="line">        DefaultTreeFactory.TreeActionEntity logicEntity = logicTreeNode.logic(userId, strategyId, awardId,ruleValue);</span><br><span class="line"></span><br><span class="line">        RuleLogicCheckTypeVO ruleLogicCheckTypeVO = logicEntity.getRuleLogicCheckTypeVO();</span><br><span class="line"></span><br><span class="line">        strategyAwardData = logicEntity.getStrategyAwardVO();</span><br><span class="line">        log.info(<span class="string">"决策树引擎【&#123;&#125;】treeId:&#123;&#125; node:&#123;&#125; code:&#123;&#125;"</span>, ruleTreeVO.getTreeName(), ruleTreeVO.getTreeId(), nextNode, ruleLogicCheckTypeVO.getCode());</span><br><span class="line">        <span class="comment">//判断下一个节点，matterValue是TAKE_OVER还是ALLOW</span></span><br><span class="line">        nextNode = nextNode(ruleLogicCheckTypeVO.getCode(), ruleTreeNodeVO.getTreeNodeLineVOList());</span><br><span class="line">        ruleTreeNodeVO = treeNodeMap.get(nextNode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回最终结果</span></span><br><span class="line">    <span class="keyword">return</span> strategyAwardData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">nextNode</span><span class="params">(String matterValue, List&lt;RuleTreeNodeLineVO&gt; treeNodeLineVOList)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == treeNodeLineVOList || treeNodeLineVOList.isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (RuleTreeNodeLineVO nodeLine : treeNodeLineVOList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (decisionLogic(matterValue, nodeLine)) &#123;</span><br><span class="line">            <span class="keyword">return</span> nodeLine.getRuleNodeTo();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2024/01/31/Springboot-Hibernate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2024/01/31/Springboot-Hibernate/" itemprop="url">Springboot-Hibernate</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2024-01-31T16:11:47+08:00">
                2024-01-31
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2024-02-03T13:59:15+08:00">
                2024-02-03
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JPA-Hibenate-CRUD-App"><a href="#JPA-Hibenate-CRUD-App" class="headerlink" title="JPA/Hibenate CRUD App"></a>JPA/Hibenate CRUD App</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Hibernate 和 JPA 是 Java 编程语言中用于数据库操作和持久化数据管理的两个相关技术。</p>
<p><strong>Hibernate</strong>: Hibernate 是一个开源的对象关系映射（ORM）框架，它提供了一个映射 Java 对象到数据库表的框架，并自动处理 Java 应用程序和数据库之间的数据查询和交换。Hibernate 旨在解决对象模型和关系数据库之间的不匹配问题，也称为”对象-关系阻抗不匹配”。通过 Hibernate，开发者可以写面向对象的代码而不必担心底层的 SQL 语句，因为 Hibernate 会负责生成和执行 SQL。Hibernate 还提供了数据查询和检索的高级优化功能，如缓存和懒加载。</p>
<p><strong>JPA (Java Persistence API)</strong>: JPA 是 Java EE 平台提供的一套持久化API，它定义了 ORM 系统应遵循的规范，以便开发者可以使用一致的方式访问关系数据库。JPA 设计为多个 ORM 提供者的通用接口，Hibernate 就是这些提供者之一，其他提供者还包括 EclipseLink、OpenJPA 等。JPA 允许开发者定义实体和实体之间关系，并通过 EntityManager API 管理数据库操作。</p>
<p><img src="/2024/01/31/Springboot-Hibernate/1.png"></p>
<p>简而言之，<strong>Hibernate 是 JPA 规范的一个实现</strong>，而 JPA 是一组接口和概念的集合。使用 JPA 的好处是，你可以在不同的 ORM 提供者之间切换，而不需要改变太多代码。而 Hibernate 提供了 JPA 规范之外的一些额外特性，这些特性在 JPA 中并不是必需的，但可能在某些复杂的应用场景中很有用。</p>
<h3 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h3><p><img src="/2024/01/31/Springboot-Hibernate/2.png"></p>
<h3 id="Hibernate-JPA-和-JDBC之间的关系"><a href="#Hibernate-JPA-和-JDBC之间的关系" class="headerlink" title="Hibernate/JPA 和 JDBC之间的关系"></a>Hibernate/JPA 和 JDBC之间的关系</h3><ol>
<li><strong>JDBC (Java Database Connectivity)</strong>: JDBC 是一个 Java API，它定义了客户端如何连接到数据库，如何发送 SQL 或 SQL 数据库调用，以及如何处理来自数据库的结果。它是 Java 用于与数据库交云的低级 API，提供了执行查询和更新数据的方法。</li>
<li><strong>Hibernate/JPA 作为 ORM 层</strong>: Hibernate 是 JPA 规范的一个实现，并且作为一个 ORM（对象关系映射）框架，它坐落在应用程序和 JDBC 之间。Hibernate 使用 JDBC API 与数据库通信，但它允许开发者以面向对象的方式工作，而不是直接使用 SQL 语句。开发者可以使用 Java 类和对象来表示和操作数据库中的数据。</li>
<li><strong>抽象层</strong>: Hibernate/JPA 提供了比 JDBC 更高层次的抽象。它管理了对象到数据库表记录的映射（反之亦然），自动将对象属性转换为数据库列，提供了更复杂的事务管理和缓存机制，以及对懒加载和关联对象的支持。</li>
<li><strong>简化数据库交互</strong>: 使用 Hibernate/JPA，开发者通常不需要写大量的 JDBC 代码和手动处理结果集。相反，他们可以专注于业务对象和逻辑。</li>
<li><strong>性能优化</strong>: Hibernate/JPA 提供了比直接使用 JDBC 更多的性能优化选项，比如一级和二级缓存，以及延迟加载（懒加载）</li>
</ol>
<h3 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h3><ol>
<li><strong>自动配置</strong>:<ul>
<li>Spring Boot 会自动配置数据源，这是基于类路径中的库和提供的配置属性完成的。</li>
</ul>
</li>
<li><strong>Maven 依赖</strong>:<ul>
<li>通过在 Maven 的 <code>pom.xml</code> 文件中包含相关的依赖，比如 <code>mysql-connector-java</code>（MySQL 的 JDBC 驱动）和 <code>spring-boot-starter-data-jpa</code>（包含了 JPA 相关的依赖和 Hibernate），Spring Boot 能够识别需要配置哪种类型的数据源。</li>
</ul>
</li>
<li><strong><code>application.properties</code></strong>:<ul>
<li>数据库的连接信息（如 URL、用户名和密码）在 <code>application.properties</code> 文件中提供。Spring Boot 根据这些属性来设置和配置数据源。</li>
</ul>
</li>
</ol>
<p>例如，在 <code>application.properties</code> 文件中添加属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;student_tracker</span><br><span class="line">spring.datasource.username&#x3D;springstudent</span><br><span class="line">spring.datasource.password&#x3D;springstudent</span><br></pre></td></tr></table></figure>
<ol>
<li><strong><code>DataSource</code> 和 <code>EntityManager</code> 的创建</strong>:<ul>
<li>Spring Boot 将根据上述配置自动创建和配置 <code>DataSource</code> 和 <code>EntityManager</code> bean。这些 bean 随后可以被注入到您的应用程序中，比如 DAO（数据访问对象）或仓库。</li>
</ul>
</li>
</ol>
<h2 id="如何连接到数据库？"><a href="#如何连接到数据库？" class="headerlink" title="如何连接到数据库？"></a>如何连接到数据库？</h2><h3 id="Java-Annotation"><a href="#Java-Annotation" class="headerlink" title="Java Annotation"></a>Java Annotation</h3><p>让 Java 类连接到数据库并映射为数据库表通常涉及到以下几个步骤，结合您提供的图片，这个过程使用 JPA （Java Persistence API）来完成：</p>
<ol>
<li><strong>定义 Entity 类</strong>:<ul>
<li>在 Java 中，您需要创建一个实体类（Entity Class），这个类的实例代表数据库中表的行。实体类需要用 <code>@Entity</code> 注解标记，这告诉 JPA 这个类是一个实体，并且它将映射到数据库的一个表。</li>
<li>实体类必须有一个无参构造函数，它可以是 public 或 protected。这是 JPA 规范的要求，以便 JPA 实现（如 Hibernate）可以实例化实体类并填充其属性。</li>
<li>实体类还可以有其他构造函数。</li>
</ul>
</li>
<li><strong>映射类到数据库表</strong>:<ul>
<li>实体类通常通过 <code>@Table</code> 注解映射到数据库的特定表。如果省略这个注解，JPA 默认使用类名作为表名。</li>
</ul>
</li>
<li><strong>映射字段到数据库列</strong>:<ul>
<li>实体类的每个属性通常通过 <code>@Column</code> 注解映射到表的列。如果省略，JPA 会使用字段名作为列名。</li>
<li>特殊属性（如主键）需要使用 <code>@Id</code> 注解来标记。</li>
</ul>
</li>
</ol>
<h3 id="Primary-Key"><a href="#Primary-Key" class="headerlink" title="Primary Key"></a>Primary Key</h3><p>在 JPA 中，主键（Primary Key）的设置是通过在实体类中指定一个或多个字段作为唯一标识符来完成的。以下是根据您提供的图片所描述的关于如何在 JPA 中设置和使用主键的知识点：</p>
<ol>
<li><p><strong>主键字段</strong>:</p>
<ul>
<li>您需要在实体类中使用 <code>@Id</code> 注解来标记一个字段作为实体的主键。这告诉 JPA，该字段的值将用来唯一标识实体的每个实例。</li>
</ul>
</li>
<li><p><strong>主键生成策略</strong>:</p>
<ul>
<li><p>使用 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@GeneratedValue</span><br></pre></td></tr></table></figure>
<p> 注解来指定主键的生成策略。这个注解定义了如何为主键字段生成值。JPA 提供了几种不同的策略，如图所示：</p>
<ul>
<li><code>GenerationType.AUTO</code>: JPA 自动选择最适合底层数据库的策略。</li>
<li><code>GenerationType.IDENTITY</code>: 使用数据库的 identity column 特性进行主键值的自增。这意味着数据库在新行插入时自动分配下一个值。</li>
<li><code>GenerationType.SEQUENCE</code>: 使用数据库中定义的序列来生成主键值。</li>
<li><code>GenerationType.TABLE</code>: 使用特定的数据库表来模拟序列，维护主键值。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>字段与数据库列的映射</strong>:</p>
<ul>
<li>通过 <code>@Column</code> 注解将实体类的字段映射到数据库表的特定列。如果您希望列名与字段名不同，可以在注解中指定。</li>
</ul>
</li>
</ol>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><code>Student</code> 实体类中的 <code>id</code> 字段被标记为主键，并且使用了 <code>GenerationType.IDENTITY</code> 策略，它通常与 <code>auto_increment</code> 字段在 MySQL 或 <code>serial</code> 字段在 PostgreSQL 这样的数据库中使用。当插入新的 <code>Student</code> 实例时，数据库会自动为 <code>id</code> 字段分配一个唯一的值。</p>
<p>下面是一个 <code>Student</code> 实体类的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table</span>(name=<span class="string">"student"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"id"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"fisrt_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"last_name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"email"</span>)</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，实体类 <code>Student</code> 映射到数据库表 <code>student</code>，字段 <code>id</code> 映射到列 <code>id</code>，并且它是自动生成的主键。当您通过 JPA 框架保存 <code>Student</code> 对象时，不需要手动设置 <code>id</code> 字段的值；数据库将为您自动增长。</p>
<p><img src="/2024/01/31/Springboot-Hibernate/3.png"></p>
<p>我们看到，java class中的filed和Database中的字段一一对应。这里@Column后面跟着的name即数据库中的字段名。</p>
<p>此外，我们还需要为字段添加Constructor、getter和setter</p>
<h2 id="如何进行CRUD？"><a href="#如何进行CRUD？" class="headerlink" title="如何进行CRUD？"></a>如何进行CRUD？</h2><h3 id="CREATE"><a href="#CREATE" class="headerlink" title="CREATE"></a>CREATE</h3><p>要将一个 <code>Student</code> 实体保存到数据库中，通常需要以下步骤</p>
<ol>
<li><p><strong>创建实体类</strong>:</p>
<ul>
<li>定义一个 <code>Student</code> 实体类，并使用 <code>@Entity</code> 和 <code>@Table</code> 注解标注。这个类将映射到数据库中的 <code>student</code> 表。</li>
</ul>
</li>
<li><p><strong>定义数据访问对象（DAO）接口</strong>:</p>
<ul>
<li>创建一个数据访问对象（DAO），这是一个设计模式，用于封装对数据库的访问。</li>
<li>DAO 应包含用于与数据库交互的方法，如 <code>save()</code>、<code>findById()</code>、<code>findAll()</code>、<code>update()</code>、<code>delete()</code> 等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentDAO</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(Student theStudent)</span></span>;</span><br><span class="line">    <span class="comment">// ... 其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><strong>实现 DAO</strong>:</p>
<ul>
<li>在 DAO 实现中，注入 <code>EntityManager</code>。<code>EntityManager</code> 是 JPA 中用于管理实体类和数据库交互的接口。Spring Boot 会根据 <code>application.properties</code> 中的配置自动创建并配置 <code>EntityManager</code> 和数据源（<code>DataSource</code>）。</li>
<li>使用 <code>EntityManager</code> 提供的方法来实现 DAO 接口中定义的操作。例如，使用 <code>entityManager.persist(student)</code> 来保存一个 <code>Student</code> 实体到数据库。</li>
<li><code>@Transactional</code> 注解提供了声明式事务管理的能力。这意味着你可以在方法或者类上添加这个注解，Spring会自动为你的JPA代码开始和结束一个事务，无需手动编写代码来控制事务的开始和提交或回滚。这样的处理通常是在幕后进行的，借助Spring框架的AOP（面向切面编程）能力。</li>
<li><code>@Repository</code> 注解是一个特化的 <code>@Component</code> 注解，它用于标记数据访问对象（DAO），表明这个类是用于数据访问层的组件，具有将数据库异常转换为Spring的数据访问异常的能力。<code>@Repository</code> 注解的类也会被组件扫描自动检测到，这意味着Spring会自动注册这些类为Spring应用上下文中的bean，并且为这些bean提供如数据源和事务管理器的依赖注入。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDAOImpl</span> <span class="keyword">implements</span> <span class="title">StudentDAO</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">private</span> EntityManager entityManager;</span><br><span class="line">		</span><br><span class="line">  	<span class="comment">//注入 Entity Manager</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentDAOImpl</span><span class="params">(EntityManager theEntityManager)</span> 		</span>&#123;</span><br><span class="line">        entityManager = theEntityManager;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">//实现接口</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  	<span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Student theStudent)</span> </span>&#123;</span><br><span class="line">        entityManager.persist(theStudent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><strong>配置 Spring Boot 应用程序</strong>:</p>
<ul>
<li>确保 <code>application.properties</code> 文件中包含正确的数据库连接信息，如 JDBC URL、用户名和密码。</li>
<li>在应用程序的启动类或配置类中声明 DAO 作为 Spring 管理的 bean。</li>
</ul>
</li>
<li><p><strong>保存实体</strong>:</p>
<ul>
<li>在应用程序的某个地方，注入 <code>StudentDAO</code> 并调用它的 <code>save()</code> 方法来保存 <code>Student</code> 实体。</li>
</ul>
</li>
</ol>
<p><img src="/2024/01/31/Springboot-Hibernate/5.png"></p>
<p><img src="/2024/01/31/Springboot-Hibernate/4.png"></p>
<h3 id="READ"><a href="#READ" class="headerlink" title="READ"></a>READ</h3><p>要通过DAO从数据库中读取一个条目，可以遵循以下步骤：</p>
<ol>
<li><p><strong>定义DAO接口</strong>：首先需要定义一个DAO接口，这个接口包含了需要执行的数据库操作的方法，比如<code>findById(Integer id)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StudentDAO接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentDAO</span> </span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">findById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><strong>实现DAO接口</strong>：然后需要一个实现了DAO接口的类。这个实现类会具体定义如何使用<code>EntityManager</code>来访问数据库。例如，<code>findById</code>方法会使用<code>EntityManager</code>的<code>find</code>方法来检索数据库中的对象。参数是：Entity class和Primary Key。这里不许要加<code>@Transational</code> 因为并不会修改状态。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StudentDAO实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDAOImpl</span> <span class="keyword">implements</span> <span class="title">StudentDAO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EntityManager entityManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentDAOImpl</span><span class="params">(EntityManager theEntityManager)</span> </span>&#123;</span><br><span class="line">        entityManager = theEntityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">findById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> entityManager.find(Student<span class="class">.<span class="keyword">class</span>, <span class="title">id</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>更新主应用程序</strong>：最后，在主应用程序中，你可以通过调用DAO实现类的方法来实现数据的读取。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主应用程序中的使用</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrudDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(DemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> CommandLineRunner <span class="title">commandLineRunner</span><span class="params">(StudentDAO studentDAO)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> runner -&gt; &#123;</span><br><span class="line">			readStudent(studentDAO);</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readStudent</span><span class="params">(StudentDAO studentDAO)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// create a student object</span></span><br><span class="line">		System.out.println(<span class="string">"Creating new student object..."</span>);</span><br><span class="line">		Student tempStudent = <span class="keyword">new</span> Student(<span class="string">"Daffy"</span>, <span class="string">"Duck"</span>, <span class="string">"daffy@luv2code.com"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// save the student object</span></span><br><span class="line">		System.out.println(<span class="string">"Saving the student..."</span>);</span><br><span class="line">		studentDAO.save(tempStudent);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// display id of the saved student</span></span><br><span class="line">		System.out.println(<span class="string">"Saved student. Generated id: "</span> + tempStudent.getId());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// retrieve student based on the id primary key</span></span><br><span class="line">		System.out.println(<span class="string">"\nRetrieving student with id: "</span> + tempStudent.getId());</span><br><span class="line">		Student myStudent = studentDAO.findById(tempStudent.getId());</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"Found the student: "</span> + myStudent);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多个对象读取-JPQL"><a href="#多个对象读取-JPQL" class="headerlink" title="多个对象读取-JPQL"></a>多个对象读取-JPQL</h4><p> 要利用Java Persistence Query Language (JPQL) 实现对多个数据的查询，你可以在DAO中定义查询方法，然后在实现类中使用<code>EntityManager</code>来创建和执行JPQL查询。以下是根据你提供的信息，实现<code>findAll</code>和<code>findByLastName</code>两个接口的示例代码：</p>
<ol>
<li><p>首先，我们需要在DAO接口中定义这两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentDAO</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...其他方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Student&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Student&gt; <span class="title">findByLastName</span><span class="params">(String lastName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，在实现类中使用<code>EntityManager</code>和JPQL来实现这些方法</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDAOImpl</span> <span class="keyword">implements</span> <span class="title">StudentDAO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> EntityManager entityManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentDAOImpl</span><span class="params">(EntityManager theEntityManager)</span> </span>&#123;</span><br><span class="line">        entityManager = theEntityManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...其他方法的实现</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个查询所有Student对象的JPQL查询</span></span><br><span class="line">        TypedQuery&lt;Student&gt; theQuery = </span><br><span class="line">          </span><br><span class="line">            entityManager.createQuery(<span class="string">"FROM Student"</span>, Student<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 执行查询并获取结果列表</span></span><br><span class="line">        <span class="keyword">return</span> theQuery.getResultList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">findByLastName</span><span class="params">(String lastName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个根据lastName查询Student对象的JPQL查询</span></span><br><span class="line">        TypedQuery&lt;Student&gt; theQuery = </span><br><span class="line">            entityManager.createQuery(<span class="string">"FROM Student s WHERE s.lastName = :lastName"</span>, Student<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 设置参数lastName的值</span></span><br><span class="line">        theQuery.setParameter(<span class="string">"lastName"</span>, lastName);</span><br><span class="line">        <span class="comment">// 执行查询并获取结果列表</span></span><br><span class="line">        <span class="keyword">return</span> theQuery.getResultList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>findAll</code>方法使用了一个简单的JPQL查询来检索所有<code>Student</code>实体，其中FROM Student 中 Student是Entity的名字，并不是表名。</p>
<p>而<code>findByLastName</code>方法则使用了一个带有参数的JPQL查询来检索所有具有特定姓氏的<code>Student</code>实体。我们使用<code>:lastName</code>来指定一个参数，然后使用<code>theQuery.setParameter</code>方法来绑定具体的值。</p>
<p>在你的Spring Boot主应用程序中，你可以注入这个DAO并调用这些方法来执行实际的查询操作。这里的<code>@Transactional</code>注解表明每个方法的执行都会在一个事务的上下文中运行，确保操作的原子性。</p>
<h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><p>使用JPQL实现数据库中某条数据的更新涉及以下步骤：</p>
<ol>
<li><strong>在DAO接口中添加新方法：</strong> 这是你定义与数据库交互所需要的方法的地方。例如，你可以添加一个<code>update</code>方法来更新学生信息。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentDAO</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...其他方法...</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Student student)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>在DAO实现类中添加新方法的实现：</strong> 在这里，你将实现接口中定义的方法。你需要使用<code>EntityManager</code>来访问数据库，并执行更新操作。通常，你会使用<code>merge</code>方法来更新现有的实体或者编写一个JPQL更新查询。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDAOImpl</span> <span class="keyword">implements</span> <span class="title">StudentDAO</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...其他成员变量和方法...</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        entityManager.merge(student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>@Transactional</code>注解确保更新操作在一个事务中执行。如果更新过程中出现异常，那么事务会被回滚，确保数据库状态的一致性。</p>
<ol>
<li><strong>在主应用程序中调用更新方法：</strong> 最后一步是在你的应用程序的逻辑中调用更新方法。通常，这会在一个服务层中完成，或者直接在<code>@SpringBootApplication</code>类中</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateStudent</span><span class="params">(StudentDAO studentDAO)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// retrieve student based on the id: primary key</span></span><br><span class="line">    <span class="keyword">int</span> studentId = <span class="number">1</span>;</span><br><span class="line">    System.out.println(<span class="string">"Getting student with id: "</span> + studentId);</span><br><span class="line">    Student myStudent = studentDAO.findById(studentId);</span><br><span class="line">    System.out.println(<span class="string">"Updating student..."</span>);</span><br><span class="line">    <span class="comment">// change first name to “Scooby”</span></span><br><span class="line">    myStudent.setFirstName(<span class="string">"Scooby"</span>);</span><br><span class="line">    studentDAO.update(myStudent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// display updated student</span></span><br><span class="line">    System.out.println(<span class="string">"Updated student: "</span> + myStudent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>要删除对象可以遵循下列开发流程：</p>
<ol>
<li><strong>添加新方法到DAO接口</strong>：在你的DAO接口中定义一个删除对象的方法。例如，如果你有一个<code>StudentDAO</code>接口，你可以添加一个方法<code>deleteById(int id)</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentDAO</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... 其他方法 ...</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>添加新方法到DAO实现类</strong>：在你的DAO实现类中实现这个删除方法。使用<code>EntityManager</code>来完成删除操作。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDAOImpl</span> <span class="keyword">implements</span> <span class="title">StudentDAO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EntityManager entityManager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他方法 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        Student student = entityManager.find(Student<span class="class">.<span class="keyword">class</span>, <span class="title">id</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (student != <span class="keyword">null</span>) &#123;</span><br><span class="line">            entityManager.remove(student);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中，我们首先使用<code>EntityManager.find()</code>方法检索实体。如果实体存在，我们调用<code>EntityManager.remove()</code>方法来删除它</p>
<ol>
<li><strong>更新主应用</strong>：最后，在你的主应用程序中，你需要调用这个新方法来执行删除操作。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteStudent</span><span class="params">(StudentDAO studentDAO)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> studentId = <span class="number">3</span>;</span><br><span class="line">    System.out.println(<span class="string">"Deleting student id: "</span>+studentId);</span><br><span class="line">    studentDAO.deleteById(studentId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除多个对象"><a href="#删除多个对象" class="headerlink" title="删除多个对象"></a>删除多个对象</h4><ol>
<li><strong>添加新方法到DAO接口</strong>：定义一个方法来删除所有对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentDAO</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... 其他方法 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>添加新方法到DAO实现类</strong>：在你的DAO实现类中实现删除所有对象的方法。你可以使用<code>EntityManager</code>配合JPQL来执行批量删除。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDAOImpl</span> <span class="keyword">implements</span> <span class="title">StudentDAO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EntityManager entityManager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他方法 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        entityManager.createQuery(<span class="string">"DELETE FROM Student"</span>).executeUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中，我们创建了一个JPQL查询来删除所有<code>Student</code>实体。注意<code>DELETE FROM Student</code>中的<code>Student</code>是实体类的名称，而不是数据库表的名称。</p>
<ol>
<li><strong>更新主应用</strong>：在主应用程序中调用新的<code>deleteAll</code>方法来执行删除操作。</li>
</ol>
<h2 id="自动生成数据表"><a href="#自动生成数据表" class="headerlink" title="自动生成数据表"></a>自动生成数据表</h2><p>使用 Java 代码自动生成数据库表的过程中，可以通过配置 JPA 或 Hibernate 来实现。这里是一个基本的过程</p>
<ol>
<li><strong>编写实体类（Entity Class）</strong>：首先，您需要创建一个 Java 实体类，使用 JPA 或 Hibernate 注解来定义其映射到数据库表的结构。比如，您的 <code>Student</code> 类将包含 <code>@Entity</code> 注解，并且有诸如 <code>@Id</code>, <code>@Column</code> 等注解来标记实体的属性。</li>
<li><strong>配置 <code>application.properties</code> 文件</strong>：在 Spring Boot 应用程序中，需要在 <code>application.properties</code> 文件中设置 Hibernate 的 <code>ddl-auto</code> 属性。例如</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jpa.hibernate.ddl-auto&#x3D;create</span><br></pre></td></tr></table></figure>
<p>这个配置指示 Hibernate 在应用程序启动时创建数据库表，这些表基于您的 Java 实体类。</p>
<ol>
<li><strong>运行应用程序</strong>：当您启动 Spring Boot 应用程序时，配置为 <code>create</code> 的 <code>ddl-auto</code> 属性将会指导 Hibernate 自动创建数据库表，如果这些表还不存在的话。这个过程是基于您的 Java 实体类的注解来执行的。</li>
</ol>
<p>在 <code>application.properties</code> 文件中，<code>ddl-auto</code> 属性可以有几个不同的值：</p>
<ul>
<li><code>none</code>：不自动创建、更新或验证数据库表。</li>
<li><code>create-only</code>：仅创建数据库表，不进行删除操作。</li>
<li><code>drop</code>：启动时删除数据库表。</li>
<li><code>create</code>：启动时删除数据库表，然后重新创建。</li>
<li><code>create-drop</code>：在应用程序启动时创建，关闭时删除数据库表。</li>
<li><code>validate</code>：验证现有数据库表结构是否与实体类匹配。</li>
<li><code>update</code>：更新数据库表结构，以匹配实体类的变更。</li>
</ul>
<p>例如，如果您想在每次应用程序启动时创建新的表并在关闭时删除，您可以设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jpa.hibernate.ddl-auto&#x3D;create-drop</span><br></pre></td></tr></table></figure>
<p>不应该在生产环境中使用 <code>create</code> 或 <code>create-drop</code>，因为这会导致现有的数据丢失。如果您想在生产环境中创建表格并保留数据，应该使用 <code>update</code> 选项。但是，需要格外小心，因为这可能会根据代码的最新更改修改数据库架构。只有在基本项目中，且能够承担相关风险时，才建议使用这种方法。在生产环境中，通常推荐手动管理数据库迁移，以避免数据丢失和不可预见的更改。</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2023/12/11/SpringBoot%E5%AD%A6%E4%B9%A0-SpringCore/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/12/11/SpringBoot%E5%AD%A6%E4%B9%A0-SpringCore/" itemprop="url">SpringBoot学习-SpringCore</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2023-12-11T20:30:20+08:00">
                2023-12-11
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2025-01-07T16:38:23+08:00">
                2025-01-07
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SpringBoot学习-SpringCore"><a href="#SpringBoot学习-SpringCore" class="headerlink" title="SpringBoot学习-SpringCore"></a>SpringBoot学习-SpringCore</h1><h2 id="IoC和DI"><a href="#IoC和DI" class="headerlink" title="IoC和DI"></a>IoC和DI</h2><p>Spring Container 是 Spring 框架的核心部分，主要负责管理对象的生命周期和依赖关系。它的两个主要功能是控制反转（Inversion of Control, IoC）和依赖注入（Dependency Injection, DI）。这两个概念是紧密相关且经常一起使用的。</p>
<p>配置：</p>
<p><img src="/2023/12/11/SpringBoot%E5%AD%A6%E4%B9%A0-SpringCore/0.png" style="zoom:100%;"></p>
<h3 id="控制反转（Inversion-of-Control-IoC）"><a href="#控制反转（Inversion-of-Control-IoC）" class="headerlink" title="控制反转（Inversion of Control, IoC）:"></a><strong>控制反转（Inversion of Control, IoC）</strong>:</h3><ul>
<li><strong>意义</strong>: IoC 是一种设计原则，用于减少代码间的耦合。传统的程序设计中，组件间的依赖关系通常由组件自身在内部管理和控制，这会导致代码之间的强耦合和难以维护。在 IoC 中，这种控制被反转了，即不是由组件自身控制依赖关系，而是将这种控制权交给了外部容器（比如 Spring Container）。</li>
<li><strong>作用</strong>: IoC 使得组件间的依赖关系更加灵活，容易管理和解耦。它使得组件更加独立，易于测试和维护。</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>我们来举一个例子，比如 A 对象中需要使用 B 对象的某个方法，那么我们通常的实现方法是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用 B 类中的 init 方法</span></span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        b.init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"你好，世界。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而此时对象 A 和对象 B 是存在耦合的，因为一旦修改了 B 对象构造方法的参数之后，那么 A 对象里面的写法也要跟着改变，比如当我们将构造方法改为以下代码时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"姓名："</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"你好，世界。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时构造方法已经从原本无参构造方法变成了有参的构造方法，这里不考虑构造方法重载的情况，因为实际业务中，很可能是 B 类的构造方法写错了，忘记加参数了，于是后面又补充了一个参数，此时是不需要对构造方法进行重载的，那么此时，之前对象 A 里面的调用就会报错.</p>
<p>这就是开发中经常遇到的一个问题，那怎么解决呢？</p>
<p>我们可以通过将对象传递而并 new 对象的方式来解决，如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先定义一个需要依赖的 B 对象</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    <span class="comment">// 通过构造方法实现赋值（初始化）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用 B 类中的 init 方法</span></span><br><span class="line">        b.init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"姓名："</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"你好，世界。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样改造之后，无论构造方法怎么修改，即使需要加更多的参数，而调用它的 A 类都无需做任何修改，这样就实现了对象的解耦。</p>
<p>那这个解耦的示例和 IoC 有什么关系呢？</p>
<p>IoC 实现的思路和上述示例一样，就是通过将对象交给 Spring 中 IoC 容器管理，在其他类中不直接 new 对象，而是通过将对象传递到当前类的方式来实现解耦的。</p>
<h3 id="依赖注入（Dependency-Injection-DI）"><a href="#依赖注入（Dependency-Injection-DI）" class="headerlink" title="依赖注入（Dependency Injection, DI）:"></a><strong>依赖注入（Dependency Injection, DI）</strong>:</h3><ul>
<li><strong>意义</strong>: DI 是实现 IoC 的一种方法。在这种模式下，组件的依赖不是由组件本身在内部创建或查找，而是由外部容器（比如 Spring Container）在创建组件的时候，将依赖项“注入”到组件中。这种依赖可以是对象、资源或者其他必需的元素。</li>
<li><strong>作用</strong>: DI 降低了组件之间的耦合度，增加了代码的可重用性和可测试性。通过 DI，组件不需要知道如何创建它们的依赖，这些依赖可以通过配置文件或注解来动态指定，从而使得组件更加灵活和模块化。</li>
</ul>
<p>Spring 框架中两种常用的依赖注入方式：构造器注入和设值注入，以及在何种情况下推荐使用它们。</p>
<ol>
<li><strong>构造器注入（Constructor Injection）</strong>:<ul>
<li>使用场景: 当你有必需的依赖时，也就是说，你的类不能在没有这些依赖的情况下正常工作。</li>
<li>推荐使用: Spring 开发团队通常推荐使用构造器注入作为首选，因为它可以确保所需的依赖在类实例化时被提供，这有助于保证实例的不变性和依赖对象的不可变性。</li>
</ul>
</li>
<li><strong>设值注入（Setter Injection）</strong>:<ul>
<li>使用场景: 当你有可选的依赖时，即使这些依赖没有被提供，你的类也能通过一些合理的默认逻辑来正常工作。</li>
<li>特点: 设值注入允许在类实例化后某个时间点设置依赖，这提供了更大的灵活性，但也可能导致对象进入一个没有正确设置依赖的不完整状态。</li>
</ul>
</li>
</ol>
<h4 id="Autowiring"><a href="#Autowiring" class="headerlink" title="Autowiring"></a>Autowiring</h4><p>什么是 Spring Autowiring：</p>
<ul>
<li>Spring Autowiring 是依赖注入的一个功能，它允许 Spring 容器自动注入依赖关系。</li>
<li>Spring 容器会查找和需要被注入的属性匹配的类，匹配可以根据类型，即类或接口来完成。</li>
<li>一旦找到匹配的类，Spring 将自动将其注入到需要的组件中，这就是为什么它被称为“自动装配”。</li>
</ul>
<p><strong>举例</strong></p>
<ul>
<li>假设我们要注入一个实现了 <code>Coach</code> 接口的类的实例。</li>
<li>Spring 会扫描带有 <code>@Component</code> 注解的类，这些类会被标记为 Spring 管理的组件。</li>
<li>如果找到任何实现了 <code>Coach</code> 接口的类，Spring 将选择一个来注入。例如，如果 <code>CricketCoach</code> 类实现了 <code>Coach</code> 掌握并且被标记为 <code>@Component</code>，Spring 就会创建 <code>CricketCoach</code> 的一个实例，并将其注入到 <code>DemoController</code> 中。</li>
</ul>
<p>这里的关键点是，使用 Autowiring，开发者不需要在配置文件中手动指定依赖关系，Spring 会自动处理这些依赖关系。这简化了配置过程，也减少了配置错误的可能性。</p>
<p>自动装配可以通过不同的方式进行，例如：</p>
<ul>
<li>使用 <code>@Autowired</code> 注解在构造器、设值方法或字段上。</li>
<li>在 XML 配置文件中使用 <code>autowire</code> 属性。</li>
</ul>
<p>这两种方法都可以达到同样的目的，即让 Spring 自动解析依赖关系并进行注入，但注解方式是目前最常用和推荐的方式，因为它提供了更清晰、更简洁的依赖关系声明。</p>
<h3 id="Constructor-Injection"><a href="#Constructor-Injection" class="headerlink" title="Constructor Injection"></a>Constructor Injection</h3><p>现在我们来实现一个Constructor Injecton的例子</p>
<ol>
<li><strong>定义依赖接口和类</strong>:<ul>
<li>这一步要求开发者定义一个接口，以及实现该接口的类。接口定义了需要的方法，而类提供了这些方法的具体实现。在 Spring 中，这通常意味着创建一个或多个类，并用 <code>@Component</code> 注解标记它们，以便 Spring 容器可以在运行时创建和管理它们的实例。</li>
</ul>
</li>
</ol>
<p><img src="/2023/12/11/SpringBoot%E5%AD%A6%E4%B9%A0-SpringCore/1.png" style="zoom:100%;"></p>
<ol>
<li><strong>创建 Demo REST 控制器</strong>:<ul>
<li>接下来，创建一个 REST 控制器类，并用 <code>@RestController</code> 注解标记。这个控制器将处理入站的 HTTP 请求，并返回相应的 HTTP 响应。</li>
</ul>
</li>
</ol>
<p><img src="/2023/12/11/SpringBoot%E5%AD%A6%E4%B9%A0-SpringCore/2.png" style="zoom:100%;"></p>
<ol>
<li><strong>为注入创建一个构造器</strong>:<ul>
<li>在控制器类中，创建一个构造器，并使用 <code>@Autowired</code> 注解（如果使用 Spring 4.3 以上版本，这个注解可以省略，只要该类只有一个构造器）。构造器的参数应该是需要注入的依赖的接口类型。Spring 容器将使用这个构造器来自动注入所需的依赖。</li>
</ul>
</li>
</ol>
<p><img src="/2023/12/11/SpringBoot%E5%AD%A6%E4%B9%A0-SpringCore/3.png" style="zoom:100%;"></p>
<ol>
<li><strong>添加 <code>@GetMapping</code> 为 <code>/dailyworkout</code></strong>:<ul>
<li>最后，定义一个方法来处理特定的 HTTP GET 请求。使用 <code>@GetMapping</code> 注解和请求的路径（在本例中为 <code>/dailyworkout</code>）。这个方法将调用注入的依赖的方法，并返回一个结果，通常是一个字符串或一个对象，后者将被自动转换为 JSON。</li>
</ul>
</li>
</ol>
<p><img src="/2023/12/11/SpringBoot%E5%AD%A6%E4%B9%A0-SpringCore/4.png" style="zoom:100%;"></p>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ol>
<li>在 Spring 容器启动时，它会创建 <code>DemoController</code> 类的一个实例。</li>
<li>如果 <code>DemoController</code> 类的构造器需要一个 <code>Coach</code> 类型的参数，Spring 容器会查找实现了 <code>Coach</code> 接口的类的实例。</li>
<li>一旦找到匹配的 <code>Coach</code> 实现，Spring 容器会创建这个实现类的实例（比如 <code>CricketCoach</code>），如果它还未被创建。<ol>
<li>接着，Spring 容器会通过 <code>DemoController</code> 的构造器将 <code>CricketCoach</code> 的实例（或其他 <code>Coach</code> 实现）注入到 <code>DemoController</code> 中。这通常是在构造器参数上使用 <code>@Autowired</code> 注解（在 Spring 4.3 之后，如果构造器只有一个参数，可以省略 <code>@Autowired</code> 注解）。</li>
</ol>
</li>
<li>当请求 <code>/dailyworkout</code> 路径时，Spring MVC 框架会调用 <code>getDailyWorkout()</code> 方法。</li>
<li>在 <code>getDailyWorkout()</code> 方法中，你会调用 <code>myCoach.getDailyWorkout()</code>。因为 <code>myCoach</code> 已经是注入的 <code>Coach</code> 实现类的实例，所以它会调用这个实例的 <code>getDailyWorkout()</code> 方法，并返回结果。</li>
</ol>
<p><img src="/2023/12/11/SpringBoot%E5%AD%A6%E4%B9%A0-SpringCore/5.png" style="zoom:100%;"></p>
<p>所以，<code>myCoach</code> 对象是在控制器被创建时通过构造器注入进来的，而不是在调用 <code>getDailyWorkout()</code> 方法时创建的。</p>
<h3 id="Setter-Injection"><a href="#Setter-Injection" class="headerlink" title="Setter Injection"></a>Setter Injection</h3><p>通过 Setter 方法实现依赖注入的编程步骤和工作流程：</p>
<p><strong>编程步骤</strong>:</p>
<ol>
<li><strong>创建 Setter 方法</strong>:<ul>
<li>在你的类中，创建一个公共的 setter 方法，这个方法将用来注入依赖。例如，在 <code>DemoController</code> 类中创建一个名为 <code>setCoach</code> 的方法，该方法接受一个 <code>Coach</code> 类型的参数。</li>
<li>事实上，只要这个方法背 autoWired注释，那么它可以是任何名字</li>
</ul>
</li>
<li><strong>使用 <code>@Autowired</code> 注解</strong>:<ul>
<li>在 setter 方法上使用 <code>@Autowired</code> 注解，以指示 Spring 自动装配依赖。这个注解告诉 Spring，当创建 <code>DemoController</code> 类的实例时，需要自动注入一个 <code>Coach</code> 类型的对象。</li>
</ul>
</li>
</ol>
<h4 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h4><ol>
<li><strong>Spring 启动并创建容器</strong>:<ul>
<li>当 Spring 应用程序启动时，它会创建一个 Spring 容器，并开始组件扫描过程。</li>
</ul>
</li>
<li><strong>组件扫描</strong>:<ul>
<li>Spring 会扫描注解了 <code>@Component</code>（及其特殊化版本如 <code>@Service</code>、<code>@Repository</code>、<code>@Controller</code>）的类，并为这些类创建 bean 定义。</li>
</ul>
</li>
<li><strong>创建 <code>CricketCoach</code> 实例</strong>:<ul>
<li>例如，<code>CricketCoach</code> 类实现了 <code>Coach</code> 接口，并且使用 <code>@Component</code> 注解标记，因此 Spring 会创建这个类的实例。</li>
</ul>
</li>
<li><strong>创建 <code>DemoController</code> 实例</strong>:<ul>
<li><code>DemoController</code> 类使用 <code>@RestController</code> 注解标记，Spring 会创建这个类的实例。</li>
</ul>
</li>
<li><strong>依赖注入</strong>:<ul>
<li>因为 <code>DemoController</code> 有一个使用 <code>@Autowired</code> 注解的 <code>setCoach</code> 方法，Spring 会调用这个方法，并将步骤 3 中创建的 <code>CricketCoach</code> 实例注入到 <code>DemoController</code> 实例中。</li>
</ul>
</li>
<li><strong>使用注入的依赖</strong>:<ul>
<li>一旦依赖注入完成，<code>DemoController</code> 就可以使用 <code>myCoach</code> 实例来调用 <code>getDailyWorkout</code> 方法，并返回相应的训练信息。</li>
</ul>
</li>
</ol>
<p>通过 setter 注入，Spring 允许开发者在不改变类构造器的情况下注入依赖，这提供了更多的灵活性。例如，如果你想要在运行时通过某种方式改变依赖，setter 方法可以很容易地重新注入一个新的依赖实例。这种方式在需要重新配置组件或是可选依赖的场景下特别有用。</p>
<h3 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h3><p>当有多个实现同一接口的组件时，Spring 的自动装配（Autowiring）机制需要更多的信息来决定注入哪一个实现。在默认情况下，如果没有其他指示，Spring 将无法选择多个匹配候选中的一个，这将导致 <code>NoUniqueBeanDefinitionException</code>。</p>
<p>为了解决这个问题，可以使用 <code>@Qualifier</code> 注解来指定应该注入哪个实现。<code>@Qualifier</code> 注解与 <code>@Autowired</code> 注解一起使用，提供了一种方式来进一步细化自动装配过程。</p>
<p>假设你有两个实现了 <code>Coach</code> 接口的组件，<code>CricketCoach</code> 和 <code>FootballCoach</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class CricketCoach implements Coach &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class FootballCoach implements Coach &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在你的 <code>DemoController</code> 中，如果你想要注入 <code>CricketCoach</code> 的实例，你需要如下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class DemoController &#123;</span><br><span class="line"></span><br><span class="line">    private Coach myCoach;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setCoach(@Qualifier(&quot;cricketCoach&quot;) Coach theCoach) &#123;</span><br><span class="line">        myCoach &#x3D; theCoach;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>@Qualifier</code> 注解的值必须与你想要注入的 <code>Coach</code> 实现的 bean 名称相匹配。默认情况下，bean 的名称是其类名的首字母小写，除非你在 <code>@Component</code> 注解中明确指定了不同的名字。因此，<code>@Qualifier(&quot;cricketCoach&quot;)</code> 告诉 Spring 要注入 <code>CricketCoach</code> 的实例。</p>
<p>如果不使用 <code>@Qualifier</code> 注解，Spring 将不知道应该选择哪个 <code>Coach</code> 实现，这将导致上述的异常。通过使用 <code>@Qualifier</code>，开发者可以明确指示 Spring 使用哪个特定的 bean，解决了多个符合条件组件的歧义性问题。</p>
<h3 id="Primary"><a href="#Primary" class="headerlink" title="@Primary"></a>@Primary</h3><p><code>@Primary</code> 注解在 Spring 中用于给多个相同类型的 bean 中的一个标记为首选的 bean。当自动装配一个特定类型的 bean 时，如果存在多个候选者，并且其中一个候选者被标记为 <code>@Primary</code>，Spring 将优先选择这个被标记的 bean 进行注入。</p>
<p>例如，如果你有两个实现了 <code>Coach</code> 接口的类 <code>CricketCoach</code> 和 <code>FootballCoach</code>，并且你想要 <code>FootballCoach</code> 作为主要的 <code>Coach</code> 实现被注入，你可以这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CricketCoach</span> <span class="keyword">implements</span> <span class="title">Coach</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FootballCoach</span> <span class="keyword">implements</span> <span class="title">Coach</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，即使 <code>CricketCoach</code> 也是一个有效的 <code>Coach</code> 类型的 bean，<code>FootballCoach</code> 会被作为首选注入，因为它被标记了 <code>@Primary</code>。</p>
<p>当在一个组件中自动装配 <code>Coach</code> 类型的 bean 时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Coach myCoach;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，由于 <code>FootballCoach</code> 被标记为 <code>@Primary</code>，<code>myCoach</code> 将会引用 <code>FootballCoach</code> 的实例，即使没有使用 <code>@Qualifier</code> 注解。</p>
<p>但是，即使一个组件被标记为 <code>@Primary</code>，仍然可以使用 <code>@Qualifier</code> 注解。实际上，<code>@Qualifier</code> 注解优先级高于 <code>@Primary</code>，这意味着 <code>@Qualifier</code> 提供了一种方式来覆盖 <code>@Primary</code> 的首选项。</p>
<p>关于多个组件同时使用 <code>@Primary</code> 的问题，如果在同一类型的多个bean上使用了 <code>@Primary</code>，这将导致冲突，因为 Spring 不会知道在不使用 <code>@Qualifier</code> 注解的情况下应该选择哪一个。这通常会导致 Spring 在启动时抛出异常，因为它不能解决多个 <code>@Primary</code> bean 之间的歧义。</p>
<p><code>@Primary</code> 注解非常有用，特别是当我们正在编写不能修改的代码（比如，正在使用一个第三方库），或者想要在大部分情况下使用一个默认实现，但在某些特定情况下覆盖这个默认实现。通过结合 <code>@Primary</code> 和 <code>@Qualifier</code> 注解，我们可以获得灵活而强大的依赖注入能力。</p>
<h3 id="Lazy"><a href="#Lazy" class="headerlink" title="@Lazy"></a>@Lazy</h3><p><code>@Lazy</code> 注解在 Spring 框架中用于控制 bean 的加载行为。当在一个 bean 上标注 <code>@Lazy</code> 注解时，这个 bean 不会在启动时立即创建，而是在第一次请求这个 bean 时才创建。这可以加快应用程序启动的速度，尤其是在有很多单例 bean 时，因为它们不会在启动时全部初始化。</p>
<p><strong>作用</strong>:</p>
<ul>
<li><strong>提高启动性能</strong>：延迟加载bean可以减少应用程序启动时的初始化负载，特别是当某些bean的创建非常耗时，或者依赖于启动后才可用的资源时。</li>
<li><strong>按需使用资源</strong>：如果应用中有些bean用得不多，使用 <code>@Lazy</code> 可以确保只有在实际需要时才创建这些bean，从而节省资源。</li>
</ul>
<p><strong>使用示例</strong>:</p>
<p>在单个 bean 上使用 <code>@Lazy</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">javaCopy code</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyBean</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>LazyBean</code> 只有在首次被注入或检索时才会被创建和初始化。</p>
<p>在依赖注入时使用 <code>@Lazy</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">javaCopy code</span><br><span class="line">public class SomeClass &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @Lazy</span><br><span class="line">    private LazyBean lazyBean;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，<code>lazyBean</code> 的实例化将会延迟到 <code>SomeClass</code> 首次使用 <code>lazyBean</code> 时。</p>
<p>全局的 Lazy 初始化可以通过在 <code>application.properties</code> 文件中设置一个属性来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arduinoCopy code</span><br><span class="line">spring.main.lazy-initialization&#x3D;true</span><br></pre></td></tr></table></figure>
<p>当这个属性设置为 <code>true</code> 时，它会影响 Spring 应用程序上下文中所有 bean 的默认行为，使得所有的 bean 都采用懒加载策略。这意味着 Spring 容器在启动时不会创建任何 bean 的实例，除非它们被显式地请求，例如，一个 REST 控制器的端点被访问时。</p>
<h2 id="应用启动流程"><a href="#应用启动流程" class="headerlink" title="应用启动流程"></a>应用启动流程</h2><h3 id="启动-Spring-应用程序"><a href="#启动-Spring-应用程序" class="headerlink" title="启动 Spring 应用程序:"></a><strong>启动 Spring 应用程序</strong>:</h3><ul>
<li><code>main</code> 方法调用 <code>SpringApplication.run(SpringcoredemoApplication.class, args);</code>，这是启动 Spring 应用程序的标准方式。它启动了 Spring 的上下文。</li>
</ul>
<h3 id="处理-SpringBootApplication-注解"><a href="#处理-SpringBootApplication-注解" class="headerlink" title="处理 @SpringBootApplication 注解:"></a><strong>处理 <code>@SpringBootApplication</code> 注解</strong>:</h3><ul>
<li><code>@SpringBootApplication</code> 是一个方便的注解，它包含了 <code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 和 <code>@Configuration</code> 这三个注解。Spring Boot 会处理这个复合注解，并激活它包含的三个注解的功能。</li>
</ul>
<h4 id="1-自动配置-EnableAutoConfiguration"><a href="#1-自动配置-EnableAutoConfiguration" class="headerlink" title="1. 自动配置 (@EnableAutoConfiguration):"></a>1. <strong>自动配置 (<code>@EnableAutoConfiguration</code>)</strong>:</h4><p><code>@EnableAutoConfiguration</code>的主要作用是通过<strong>自动配置类</strong>来为应用程序提供自动化的配置。它是Spring Boot自动配置机制的入口，开启了基于约定的配置，而不是手动指定所有的配置项。这个注解的核心是通过条件化的配置来自动配置Spring应用程序。</p>
<p><code>@EnableAutoConfiguration</code>是一个组合注解，实际上，它包含了以下的注解：</p>
<ul>
<li><code>@Import(AutoConfigurationImportSelector.class)</code>：该注解会引导Spring Boot去扫描自动配置类。</li>
<li><code>@EnableAspectJAutoProxy(proxyTargetClass = false)</code>：启用AspectJ自动代理（用于支持<code>@Aspect</code>）。</li>
<li><code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code>等条件化注解：这些注解帮助自动配置类根据具体的条件进行启用或禁用。</li>
</ul>
<h5 id="①-步骤一：-Import-AutoConfigurationImportSelector-class"><a href="#①-步骤一：-Import-AutoConfigurationImportSelector-class" class="headerlink" title="① 步骤一：@Import(AutoConfigurationImportSelector.class)"></a>① 步骤一：<code>@Import(AutoConfigurationImportSelector.class)</code></h5><ul>
<li><code>@EnableAutoConfiguration</code>的最核心部分是通过<code>@Import(AutoConfigurationImportSelector.class)</code>来实现的。<code>AutoConfigurationImportSelector</code>是一个<code>ImportSelector</code>，它的任务是决定哪些自动配置类应该被加载到Spring应用上下文中。<ul>
<li><code>AutoConfigurationImportSelector</code>会调用<code>SpringFactoriesLoader</code>来加载<code>META-INF/spring.factories</code>文件，查找和<code>EnableAutoConfiguration</code>相关的配置类。这些类一般都有<code>@Configuration</code>注解</li>
<li>这些配置类会根据条件化注解（如<code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code>等）来判断是否应该加载。</li>
</ul>
</li>
</ul>
<h5 id="②-步骤二：扫描META-INF-spring-factories文件"><a href="#②-步骤二：扫描META-INF-spring-factories文件" class="headerlink" title="② 步骤二：扫描META-INF/spring.factories文件"></a>② 步骤二：扫描<code>META-INF/spring.factories</code>文件</h5><ul>
<li><p>Spring Boot通过<code>SpringFactoriesLoader</code>加载所有模块中的<code>META-INF/spring.factories</code>文件。<code>spring.factories</code>文件中定义了自动配置类的列表，这些类被注册到Spring的上下文中。</p>
<p>例如，<code>spring.factories</code>文件中可能包含如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration</span><br></pre></td></tr></table></figure>
<p>这意味着，当启用自动配置时，Spring Boot会加载<code>ServletWebServerFactoryAutoConfiguration</code>和<code>DataSourceAutoConfiguration</code>等类，并尝试根据项目的依赖和条件来自动配置Web服务器和数据源。</p>
</li>
</ul>
<h5 id="③-步骤三：条件化自动配置类"><a href="#③-步骤三：条件化自动配置类" class="headerlink" title="③ 步骤三：条件化自动配置类"></a>③ 步骤三：条件化自动配置类</h5><ul>
<li><p>自动配置类通常使用Spring的条件注解来控制它们是否应该被启用。常见的条件注解包括：</p>
<ul>
<li><code>@ConditionalOnClass</code>：如果类路径中存在指定的类，才会加载该自动配置类。例如，<code>@ConditionalOnClass(DataSource.class)</code>表示当类路径中存在<code>DataSource</code>时才会加载数据源相关的配置。</li>
<li><code>@ConditionalOnMissingBean</code>：如果上下文中没有某个类型的bean，才会加载该自动配置类。例如，<code>@ConditionalOnMissingBean(DataSource.class)</code>表示只有当没有<code>DataSource</code>类型的bean时，才会创建并注入一个<code>DataSource</code> bean。</li>
<li><code>@ConditionalOnProperty</code>：只有在某个配置项的属性值满足条件时才会加载配置类。例如，<code>@ConditionalOnProperty(prefix = &quot;spring.datasource&quot;, name = &quot;url&quot;)</code>表示只有当<code>spring.datasource.url</code>属性存在时才会加载数据源配置。</li>
</ul>
<p>这些条件化注解使得自动配置变得灵活，能够根据具体的项目需求动态启用或禁用某些配置。</p>
</li>
</ul>
<h5 id="④-步骤四：注册自动配置类到上下文"><a href="#④-步骤四：注册自动配置类到上下文" class="headerlink" title="④ 步骤四：注册自动配置类到上下文"></a>④ 步骤四：注册自动配置类到上下文</h5><ul>
<li><p>根据<code>AutoConfigurationImportSelector</code>的选择，符合条件的自动配置类会被加载到Spring应用上下文中。这些类通常是带有<code>@Configuration</code>注解的Java类，意味着它们会被作为Spring Bean注册到应用上下文中。</p>
<p>例如，<code>ServletWebServerFactoryAutoConfiguration</code>会配置嵌入式Web服务器，<code>DataSourceAutoConfiguration</code>会配置数据库连接池等。</p>
</li>
</ul>
<h5 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h5><p>我在<code>starter</code>module的resouces文件夹下，新建了一个META-INF文件夹，里面定义了<code>spring.factories</code>文件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=io.github.jasonxqh.dynamic.thread.pool.sdk.config.DynamicThreadPoolAutoConfig</span><br></pre></td></tr></table></figure></p>
<p>告知扫描器，这里有个需要自动配置的类，路径是<code>io.github.jasonxqh.dynamic.thread.pool.sdk.config.DynamicThreadPoolAutoConfig</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicThreadPoolAutoConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个服务，可以注入进来</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(DynamicThreadPoolAutoConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"dynamicThreadPoolService"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dynamicThreadPoolService</span><span class="params">(ApplicationContext applicationContext, Map&lt;String,ThreadPoolExecutor&gt; threadPoolExecutorMap)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String applicationName = applicationContext.getEnvironment().getProperty(<span class="string">"spring.application.name"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(StringUtil.isBlank(applicationName)) &#123;</span><br><span class="line">            applicationName = <span class="string">"default app"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"dynamicThreadPoolService applicationName: &#123;&#125;"</span>, applicationName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，当我启动 application的时候，就会扫描到这里有个<code>@Configuration</code>注解的类需要自动配置了。</p>
<h5 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h5><p>如果这个类，不用<code>@Configuration</code>注解的话，还会被自动注册吗？</p>
<p>如果我们在<code>spring.factories</code>中定义了自动配置类的路径，那么不管这个类是否被<code>@Configuratino</code>注解，都会被自动注册。</p>
<p><strong><code>@Configuration</code> 和 <code>@Bean</code></strong>:</p>
<ul>
<li><code>@Configuration</code> 注解是用于告诉 Spring 容器该类是一个配置类，并且可以定义 <code>@Bean</code> 方法。实际上，<code>@Configuration</code> 会触发 Spring 的代理机制，确保方法返回的对象会被正确地注册到 Spring 上下文中。</li>
<li><strong>重要</strong>：如果你删除了 <code>@Configuration</code> 注解，但方法仍然标注了 <code>@Bean</code>，这个方法仍然可以注册为 Spring Bean，但类本身<strong>不再作为配置类</strong>处理。这意味着 <code>@Bean</code> 方法还是会执行并注册 Bean，但不会被 Spring 视为全局配置类。</li>
</ul>
<h4 id="组件扫描-ComponentScan"><a href="#组件扫描-ComponentScan" class="headerlink" title="组件扫描 (@ComponentScan):"></a><strong>组件扫描 (<code>@ComponentScan</code>)</strong>:</h4><ul>
<li>Spring Boot 会扫描启动类 <code>SpringcoredemoApplication</code> 所在的包以及子包，默认情况下不扫描其他包。并查找带有 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code>、<code>@Controller</code> 等注解的类，并将它们注册为 Spring 应用程序上下文中的 bean。</li>
<li>如果你的<code>Application.java</code>在一个模块（例如<code>moduleA</code>）中，那么Spring Boot会扫描<code>moduleA</code>中所有的类和资源。如果其他模块（例如<code>moduleB</code>）通过<code>依赖关系</code>添加到<code>moduleA</code>中，这些模块中的类也会被扫描到。</li>
<li>如果<code>Application.java</code>的包路径是<code>com.example.app</code>，那么默认情况下，Spring会扫描<code>com.example.app</code>包及其子包中的所有类。如果需要扫描其他模块的类，可以通过调整<code>@ComponentScan</code>注解的<code>basePackages</code>属性来指定需要扫描的包。</li>
</ul>
<h4 id="额外的配置-Configuration"><a href="#额外的配置-Configuration" class="headerlink" title="额外的配置 (@Configuration):"></a><strong>额外的配置 (<code>@Configuration</code>)</strong>:</h4><ul>
<li>这允许在应用程序中定义额外的配置类。这些类中可以使用 <code>@Bean</code> 注解来注册更多的 bean 到 Spring 应用程序上下文中，或者使用 <code>@Import</code> 注解来引入其他配置类。</li>
</ul>
<ol>
<li><strong>创建和注册 Bean</strong>:<ul>
<li>在自动配置和组件扫描的基础上，Spring Boot 会创建和注册所有识别出的 bean，包括从配置类中定义的 bean。</li>
</ul>
</li>
<li><strong>解决 Bean 之间的依赖关系</strong>:<ul>
<li>在所有的 bean 都被创建和注册后，Spring 容器会解决它们之间的依赖关系，并通过构造器、设值方法或字段注入完成自动装配。</li>
</ul>
</li>
<li><strong>应用程序准备就绪</strong>:<ul>
<li>一旦上下文被创建并且所有的 bean 都被正确装配，应用程序就准备好可以接受请求了。对于 web 应用程序，这通常意味着内嵌的 Tomcat、Jetty 或 Undertow 服务器已经启动并且开始监听 HTTP 请求。</li>
</ul>
</li>
</ol>
<h3 id="扫描非启动类所在包"><a href="#扫描非启动类所在包" class="headerlink" title="扫描非启动类所在包"></a>扫描非启动类所在包</h3><p>当应用程序的组件不仅仅位于启动类所在的包和其子包时，会出错，如下所示：</p>
<p><img src="/2023/12/11/SpringBoot%E5%AD%A6%E4%B9%A0-SpringCore/6.png" style="zoom:100%;"></p>
<p>此时，我们需要告诉 Spring Boot 去扫描其他的包。图片中展示了如何使用 <code>@SpringBootApplication</code> 注解的 <code>scanBasePackages</code> 属性来明确列出 Spring Boot 在启动时应该扫描的基础包。</p>
<p>如果有组件分布在不同的包中，例如 <code>com.luv2code.util</code>，<code>org.acme.cart</code>，和 <code>edu.cmu.srs</code>，您可以按如下方式配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>(scanBasePackages=&#123;</span><br><span class="line">    <span class="string">"com.luv2code.springcoredemo"</span>, </span><br><span class="line">    <span class="string">"com.luv2code.util"</span>, </span><br><span class="line">    <span class="string">"org.acme.cart"</span>, </span><br><span class="line">    <span class="string">"edu.cmu.srs"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringcoredemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringcoredemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>scanBasePackages</code> 属性包含了一个数组，列出了所有需要被 Spring Boot 组件扫描过程所考虑的包。这样，Spring Boot 就会在启动时扫描这些包以及它们的子包，查找带有 <code>@Component</code>、<code>@Service</code>、<code>@Repository</code>、<code>@Controller</code> 等注解的类，并自动注册为 Spring 应用程序上下文中的 bean。</p>
<p>这使得您可以组织和管理位于不同包中的 Spring 组件，无论它们是否位于启动类所在的包的外部。</p>
<h2 id="Bean-Scope"><a href="#Bean-Scope" class="headerlink" title="Bean Scope"></a>Bean Scope</h2><p>Bean Scope 在 Spring 框架中定义了一个 bean 的生命周期和可见性。它决定了一个 bean 实例是如何被创建、复用以及管理。</p>
<p>不同类型的 Spring Bean Scopes：</p>
<ol>
<li><p><strong>singleton</strong>:</p>
<ul>
<li>这是 Spring 默认的 scope。当一个 bean 定义为 singleton，Spring IoC 容器将只为这个 bean 定义创建一个共享的实例。无论给定的 bean 被注入多少次，或者从容器中多少次检索，总是返回相同的对象实例。</li>
</ul>
<p><img src="/2023/12/11/SpringBoot%E5%AD%A6%E4%B9%A0-SpringCore/7.png" style="zoom:100%;"></p>
</li>
<li><p><strong>prototype</strong>:</p>
<ul>
<li><p>如果一个 bean 定义为 prototype，Spring IoC 容器每次请求都会创建一个新的 bean 实例。方法如下所示，即11目标bean用<code>@Scope(ConfigurbleBeanFactory.SCOPE_PROTOTYPE)</code>修饰</p>
<p><img src="/2023/12/11/SpringBoot%E5%AD%A6%E4%B9%A0-SpringCore/9.png" style="zoom:100%;"></p>
</li>
<li><p>这意味着如果你对同一个 bean 进行了多次请求，每次都会得到一个新创建的对象。</p>
<p><img src="/2023/12/11/SpringBoot%E5%AD%A6%E4%B9%A0-SpringCore/8.png" style="zoom:100%;"></p>
</li>
</ul>
</li>
<li><p><strong>request</strong>:</p>
<ul>
<li>这个 scope 仅适用于 web 应用程序。在 request scope 中，每个 HTTP 请求都会创建一个新的 bean 实例。这意味着在同一个请求内部，相同的 bean 将返回相同的实例，但不同请求会导致创建新的实例。</li>
</ul>
</li>
<li><p><strong>session</strong>:</p>
<ul>
<li>session scope 也是专门为 web 应用程序设计的。在 session scope 中，每个 HTTP session 都会创建一个新的 bean 实例。这个 bean 与用户的 HTTP session 相关联，并在 session 的生命周期内共享。</li>
</ul>
</li>
<li><p><strong>global-session</strong>:</p>
<ul>
<li>global-session scope 用于 portlet 应用程序，并且通常用于 Spring 的 Portlet framework。它类似于 session scope，但是它提供了跨多个 servlet context 的全局 HTTP session（通常在 Portlet 环境中使用）。</li>
</ul>
</li>
</ol>
<p>理解不同的 bean scopes 对于设计合适的 Spring 应用程序是非常重要的，因为不同的 scope 影响了应用程序的行为和性能。例如，使用 singleton scope 可以减少内存的使用，因为它限制了实例的数量；而使用 prototype scope 可以确保每个组件使用一个全新的实例，这在某些特定的业务场景下可能是必需的。对于 web 应用程序来说，request 和 session scopes 允许 bean 的状态和生命周期与用户的交互周期相匹配。</p>
<h2 id="Bean-LifeCycle"><a href="#Bean-LifeCycle" class="headerlink" title="Bean LifeCycle"></a>Bean LifeCycle</h2><p>在 Spring 框架中，Bean 生命周期指的是从创建 Bean 到 Bean 被销毁的整个过程。在这个过程中，可以通过定义特定的方法来钩入生命周期的特定点，这些方法可以在 Bean 的初始化和销毁时执行自定义的逻辑。</p>
<p>Bean 生命周期及其自定义的钩子方法（即生命周期回调方法）可以如下描述：</p>
<ol>
<li><strong>Bean 定义</strong>:<ul>
<li>Bean 的定义由 Spring 容器通过读取配置文件、注解或 Java 配置类进行加载。</li>
</ul>
</li>
<li><strong>Bean 实例化</strong>:<ul>
<li>Spring 容器创建 Bean 的实例，通常是通过调用构造函数来完成。</li>
</ul>
</li>
<li><strong>依赖注入</strong>:<ul>
<li>如果 Bean 依赖于其他 Bean，则这些依赖关系被注入到当前 Bean 中。</li>
</ul>
</li>
<li><strong>内部 Spring 处理</strong>:<ul>
<li>Bean 可能会被 AOP 代理包装，并且可能会应用 Bean 后置处理器（<code>BeanPostProcessor</code>）。</li>
</ul>
</li>
<li><strong>初始化回调</strong>:<ul>
<li>容器调用自定义的初始化方法。这些方法可以通过实现 <code>InitializingBean</code> 接口或通过 <code>@PostConstruct</code> 注解来指定。</li>
</ul>
</li>
<li><strong>Bean 可用</strong>:<ul>
<li>此时，Bean 完全初始化，并准备好被应用程序使用。</li>
</ul>
</li>
<li><strong>容器关闭</strong>:<ul>
<li>当应用程序关闭时，Spring 容器会被关闭。</li>
</ul>
</li>
<li><strong>销毁回调</strong>:<ul>
<li>在容器关闭过程中，如果 Bean 实现了 <code>DisposableBean</code> 接口或定义了 <code>@PreDestroy</code> 注解的方法，容器将调用这些销毁方法。</li>
</ul>
</li>
</ol>
<p>通过这个生命周期，您可以在 Bean 的创建或销毁过程中执行必要的资源分配或清理。例如，可以在初始化方法中打开文件资源或网络连接，在销毁方法中释放这些资源。</p>
<h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p><img src="/2023/12/11/SpringBoot%E5%AD%A6%E4%B9%A0-SpringCore/10.png" style="zoom:100%;"></p>
<p>可以看到，在CricketCoach被初始化之后，会调用doMyStarupStuff钩子函数</p>
<p><img src="/2023/12/11/SpringBoot%E5%AD%A6%E4%B9%A0-SpringCore/11.png" style="zoom:100%;"></p>
<h2 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h2><p>在 Spring 框架中，<code>@Component</code> 注解通常用于自定义的类，它告诉 Spring 容器这个类是一个 Spring 组件，需要作为一个 bean 进行实例化和管理。使用 <code>@Component</code> 的前提是你可以修改类的源码来添加这个注解。</p>
<p>然而，在某些情况下，特别是当使用第三方库或者框架时，你没有权限去修改源代码，也就不能直接在这些类上添加 <code>@Component</code> 注解。在这种情况下，你需要使用 <code>@Bean</code> 注解来配置这些类的实例。</p>
<p>使用 Java 代码配置 beans 的步骤如下：</p>
<ol>
<li><p><strong>创建 <code>@Configuration</code> 类</strong>:</p>
<ul>
<li>创建一个类，并使用 <code>@Configuration</code> 注解标记它。这个类将作为配置信息的来源，Spring 容器将会扫描这个类以了解相关的 bean 定义。</li>
</ul>
</li>
<li><p><strong>定义 <code>@Bean</code> 方法</strong>:</p>
<ul>
<li>在这个配置类内部，定义一个或多个方法，并使用 <code>@Bean</code> 注解。每个方法都将创建一个 bean，并且<strong>方法名默认为 bean 的名称</strong>。这些方法应该返回你想要由 Spring 容器管理的对象的实例。每个这样的方法实质上都是一个工厂方法，它告诉 Spring 容器如何创建这个 bean。</li>
</ul>
<p><img src="/2023/12/11/SpringBoot%E5%AD%A6%E4%B9%A0-SpringCore/13.png" style="zoom:100%;"></p>
<p>在这个例子中，<code>@Bean</code> 注解使用 <code>&quot;aquatic&quot;</code> 作为 bean 的名字，这意味着你可以使用这个名字来引用创建的 bean 实例。</p>
</li>
<li><p><strong>将 bean 注入控制器</strong>:</p>
<ul>
<li>在你的控制器（或其他需要这些 beans 的组件）中，你可以通过自动装配（使用 <code>@Autowired</code>）来注入步骤 2 中创建的 beans。Spring 容器会在运行时自动处理这些依赖关系。在需要依赖注入的类中，比如 <code>DemoController</code>，可以使用 <code>@Autowired</code> 和 <code>@Qualifier</code> 注解来注入特定的 <code>Coach</code> 实例。<code>@Qualifier</code> 注解的值应该与 <code>@Bean</code> 方法中定义的名称相匹配。</li>
</ul>
</li>
</ol>
<p><img src="/2023/12/11/SpringBoot%E5%AD%A6%E4%B9%A0-SpringCore/14.png" style="zoom:100%;"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2023/11/28/springboot%E5%AD%A6%E4%B9%A0-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/11/28/springboot%E5%AD%A6%E4%B9%A0-1/" itemprop="url">springboot学习-1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2023-11-28T16:06:27+08:00">
                2023-11-28
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2024-01-31T16:13:30+08:00">
                2024-01-31
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="springboot学习-1"><a href="#springboot学习-1" class="headerlink" title="springboot学习-1"></a>springboot学习-1</h1><h2 id="Spring-Framework-Overview"><a href="#Spring-Framework-Overview" class="headerlink" title="Spring Framework Overview"></a>Spring Framework Overview</h2><h3 id="Core-Container"><a href="#Core-Container" class="headerlink" title="Core Container"></a>Core Container</h3><p>在 Spring 中，核心容器包括 Beans、Core、SpEL（Spring Expression Language）、Context。这些模块构成了 Spring 框架的核心，并提供了关键的功能来管理对象、处理依赖、执行表达式以及创建应用程序上下文。</p>
<h4 id="Beans"><a href="#Beans" class="headerlink" title="Beans:"></a><strong>Beans</strong>:</h4><p>Beans 模块是 Spring 框架的核心部分，负责管理对象（即 “bean”）。它包含了 IoC（Inverse of Control，控制反转）和 DI（Dependency Injection，依赖注入）的实现。通过 Beans 模块，Spring 能够实例化、装配和管理应用程序中的各种对象，这些对象通常被称为 bean。使用 Beans 模块，开发者可以通过 XML 配置文件或基于注解的方式定义 bean，并让 Spring 容器来管理这些 bean 的生命周期和依赖关系。</p>
<h4 id="Core"><a href="#Core" class="headerlink" title="Core:"></a>Core:</h4><p> Core 模块提供了 Spring 框架的核心功能和工具类。它包括了核心的工具类和辅助功能，用于处理常用的任务，例如资源加载、类型转换、事件发布等。Core 模块也包含了 Spring 框架中许多基本的类和接口，为其他模块提供基础支持。</p>
<h4 id="SpEL-Spring-Expression-Language"><a href="#SpEL-Spring-Expression-Language" class="headerlink" title="SpEL (Spring Expression Language)"></a>SpEL (Spring Expression Language)</h4><p>SpEL 是一种表达式语言，允许在运行时对 Spring 应用程序上下文中的对象执行评估和操作。它提供了一种强大的方式来引用 bean、调用方法、进行条件判断、进行算术运算等。SpEL 可以用于 XML 配置文件、注解、Spring Security 等各个方面，为开发者提供了灵活且强大的表达式语言功能。</p>
<h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p> Context 模块是 Spring 框架中最重要的模块之一。它构建在 Beans 和 Core 模块的基础上，提供了创建和管理 bean 的应用程序上下文的能力。ApplicationContext 是 Context 模块的核心接口，它表示整个应用程序的上下文环境。ApplicationContext 负责加载 bean 定义、对 bean 进行实例化、解析依赖、管理 bean 的生命周期等。通过 ApplicationContext，Spring Boot 应用程序能够轻松地管理 bean、处理依赖注入，并提供各种功能，如国际化、事件传播等。</p>
<h3 id="Infrustructure"><a href="#Infrustructure" class="headerlink" title="Infrustructure"></a>Infrustructure</h3><h4 id="AOP（Aspect-Oriented-Programming）"><a href="#AOP（Aspect-Oriented-Programming）" class="headerlink" title="AOP（Aspect-Oriented Programming）"></a>AOP（Aspect-Oriented Programming）</h4><p> AOP 是一种编程范式，它允许将跨越应用程序的功能模块化，例如日志记录、事务管理等，这些功能不依赖于应用程序的业务逻辑。AOP 的核心思想是通过定义横切关注点（cross-cutting concerns），将它们从主要的业务逻辑中分离出来，以便在不同的模块中重复使用。在 Spring Boot 中，AOP 允许通过特定注解或配置来创建切面，并通过 advice（通知）和 pointcut（切入点）来定义在何处执行横切逻辑。</p>
<h4 id="Aspects（切面）"><a href="#Aspects（切面）" class="headerlink" title="Aspects（切面）"></a>Aspects（切面）</h4><p>在 AOP 中，切面是横切关注点的实现。它定义了 advice 和 pointcut，用于描述在何处执行横切逻辑以及具体的操作。在 Spring Boot 中，开发者可以定义切面，将其应用于应用程序的不同部分，并在特定的连接点（例如方法执行前后、抛出异常时等）执行特定的操作，如日志记录、性能监控、事务管理等。</p>
<h4 id="Instrumentation（仪表化）"><a href="#Instrumentation（仪表化）" class="headerlink" title="Instrumentation（仪表化）"></a>Instrumentation（仪表化）</h4><p> 仪表化是指对应用程序进行监控、诊断和分析的过程。在 Spring Boot 中，Instrumentation 提供了一些工具和机制来对应用程序进行监控和分析，例如通过使用 Spring Boot Actuator（执行器）来暴露端点以获取应用程序的健康状况、度量信息、审计日志等。这使得开发者能够更好地了解应用程序的运行情况，并进行必要的优化和调整。</p>
<h4 id="Messaging（消息传递）"><a href="#Messaging（消息传递）" class="headerlink" title="Messaging（消息传递）"></a>Messaging（消息传递）</h4><p> 消息传递是指在应用程序内部或不同应用程序之间进行消息交换的机制。在 Spring Boot 中，Messaging 模块提供了丰富的消息传递功能，包括使用 Spring 的消息中间件支持（如 RabbitMQ、Apache Kafka、ActiveMQ 等），并提供了各种消息处理器、消息监听器和消息通道等组件，使得开发者可以轻松地实现消息驱动的应用程序或微服务。</p>
<h3 id="Data-Access-Layer"><a href="#Data-Access-Layer" class="headerlink" title="Data Access Layer"></a>Data Access Layer</h3><p>数据访问层（Data Access Layer）是应用程序中负责处理数据存储和检索的模块。这个层级包含了一系列技术和工具，使得应用程序可以与不同类型的数据存储进行交互，包括关系型数据库、对象数据库、消息队列等。</p>
<h4 id="JDBC（Java-Database-Connectivity）"><a href="#JDBC（Java-Database-Connectivity）" class="headerlink" title="JDBC（Java Database Connectivity）"></a>JDBC（Java Database Connectivity）</h4><p>JDBC 是 Java 用于与关系型数据库交互的标准 API。它提供了一种标准化的方式来连接、查询和更新数据库。在 Spring Boot 中，JDBC 提供了一些模板和工具类，简化了与数据库的交互，包括对连接管理、SQL 执行、事务处理的支持。Spring Boot 提供的 JdbcTemplate 和 NamedParameterJdbcTemplate 等类可以帮助开发者更轻松地执行 SQL 查询和更新。</p>
<h4 id="ORM（Object-Relational-Mapping）"><a href="#ORM（Object-Relational-Mapping）" class="headerlink" title="ORM（Object-Relational Mapping）"></a>ORM（Object-Relational Mapping）</h4><p>ORM 是一种技术，用于在关系型数据库和面向对象编程语言之间建立映射关系，使得开发者可以使用面向对象的方式操作数据库。在 Spring Boot 中，ORM 框架如 Hibernate、Spring Data JPA 等被广泛使用。这些框架简化了与数据库的交互，允许开发者使用对象来表示数据库中的表和关系，并提供了丰富的功能来执行 CRUD 操作、查询、关联映射等。</p>
<h4 id="Transactions（事务）"><a href="#Transactions（事务）" class="headerlink" title="Transactions（事务）:"></a><strong>Transactions（事务）</strong>:</h4><p>事务是一系列数据库操作的逻辑单元，要么全部成功执行，要么全部回滚到初始状态。Spring Boot 提供了对声明式事务的支持，可以通过注解或 XML 配置的方式来管理事务。这使得开发者可以更容易地控制事务的边界、隔离级别和传播行为，确保数据的完整性和一致性。</p>
<h4 id="OXM（Object-XML-Mapping）"><a href="#OXM（Object-XML-Mapping）" class="headerlink" title="OXM（Object XML Mapping）:"></a>OXM（Object XML Mapping）:</h4><p> OXM 提供了对象与 XML 之间的映射能力。在 Spring Boot 中，它允许将 Java 对象和 XML 数据进行相互转换。Spring Framework 提供了支持，使开发者能够方便地进行对象到 XML 或 XML 到对象的转换，如使用 JAXB（Java Architecture for XML Binding）或其他的 XML 映射工具。</p>
<h4 id="JMS（Java-Message-Service）"><a href="#JMS（Java-Message-Service）" class="headerlink" title="JMS（Java Message Service）"></a>JMS（Java Message Service）</h4><p> JMS 是 Java 平台上用于实现消息驱动的异步通信的 API。Spring Boot 中的 JMS 支持允许开发者利用消息队列（如 ActiveMQ、RabbitMQ 等）进行异步消息的发送和接收。通过 JMS，应用程序可以更高效地进行解耦和异步通信，从而提高系统的可伸缩性和可靠性。</p>
<h3 id="Web-Layer"><a href="#Web-Layer" class="headerlink" title="Web Layer"></a>Web Layer</h3><p>Web Layer 在 Spring 框架中起着至关重要的作用，它使得开发者能够便捷地处理来自客户端的请求和响应，并通过不同的功能模块（如 Servlet、WebSocket、Web 等）来实现各种类型的 Web 应用程序，包括传统的基于 HTTP 请求响应的网页应用、实时通信应用、RESTful API 服务等。</p>
<h4 id="Servlet："><a href="#Servlet：" class="headerlink" title="Servlet："></a>Servlet：</h4><p>Servlet 是 Java 平台上用于处理 Web 请求和响应的技术。Spring Boot 基于 Servlet 技术构建了强大的 Web 应用程序。Spring Boot 提供了 Servlet 容器（例如 Tomcat、Jetty、Undertow 等）的嵌入式支持，使得开发者能够以独立于外部容器的方式轻松创建和运行 Web 应用程序。</p>
<h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><p>WebSocket 是一种在客户端和服务器之间建立持久连接的通信协议，它允许在单个 TCP 连接上进行全双工通信。Spring Boot 提供了对 WebSocket 的支持，使得开发者能够实现实时性强、双向通信的功能。通过 Spring 的 WebSocket 支持，开发者可以轻松地构建基于 WebSocket 的应用程序，如聊天应用、实时数据更新等。</p>
<h4 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h4><p>Spring Boot 的 Web 模块提供了一系列用于构建 Web 应用程序的功能和工具。它包括了诸如控制器（Controller）、路由（Routing）、请求映射（Request Mapping）、数据绑定、视图解析、拦截器、过滤器等等。通过 Spring Boot 的 Web 支持，开发者可以使用注解（如 <code>@Controller</code>、<code>@RestController</code>）、拦截器、模板引擎（如 Thymeleaf、FreeMarker）等，快速搭建和开发 Web 应用程序。</p>
<h3 id="Test-Layer"><a href="#Test-Layer" class="headerlink" title="Test Layer"></a>Test Layer</h3><p>在 Spring 中，测试层（Test Layer）是用于编写和执行各种类型测试的关键部分，主要包括单元测试（Unit Test）、集成测试（Integration Test）和模拟测试（Mock Test）。这些测试层旨在确保应用程序的各个部分在各种情况下都能够按预期进行工作。</p>
<h4 id="单元测试（Unit-Test）"><a href="#单元测试（Unit-Test）" class="headerlink" title="单元测试（Unit Test）:"></a><strong>单元测试（Unit Test）</strong>:</h4><p>单元测试是针对应用程序中的最小单元（通常是方法或类）进行的测试。在 Spring Boot 中，使用 JUnit 或 TestNG 等单元测试框架编写单元测试是常见的做法。单元测试的目的是验证代码的各个单元是否按预期工作，通常会对方法进行测试，确保其行为符合预期，并能够正确处理各种输入。</p>
<h4 id="集成测试（Integration-Test）"><a href="#集成测试（Integration-Test）" class="headerlink" title="集成测试（Integration Test）"></a>集成测试（Integration Test）</h4><p> 集成测试是验证应用程序不同组件之间的交互是否正确的测试。在 Spring Boot 中，集成测试涉及多个模块、组件或服务的交互。这种测试可以用于确保不同层次（如控制器、服务、数据库访问层等）之间的整合是正确的，确保整个应用程序在集成的情况下能够正常工作。</p>
<h4 id="模拟测试（Mock-Test）"><a href="#模拟测试（Mock-Test）" class="headerlink" title="模拟测试（Mock Test）"></a>模拟测试（Mock Test）</h4><p> 模拟测试是一种在测试过程中模拟外部依赖或行为的测试方式。在 Spring Boot 中，使用 Mockito、EasyMock 或 PowerMock 等框架来模拟依赖、服务或对象的行为是常见的做法。模拟测试允许开发者隔离测试环境，减少对外部依赖的影响，同时专注于测试代码本身的逻辑。</p>
<h2 id="项目初配置"><a href="#项目初配置" class="headerlink" title="项目初配置"></a>项目初配置</h2><p>虽然跟着视频或者书本一步一步做下来，但还是踩了不少坑，所以记录一下。</p>
<p>Gradle和Maven都是用于构建和管理Java项目的工具。如果没有它们，我们就需要手动把一个个Jar包都下载下来，特别麻烦。有了他们我们就可以通过对某一文件进行修改，让它们管理这些Jar包。(类比于npm 和 pip)</p>
<p><img src="/2023/11/28/springboot%E5%AD%A6%E4%B9%A0-1/10.png"></p>
<h3 id="Maven："><a href="#Maven：" class="headerlink" title="Maven："></a>Maven：</h3><ul>
<li><p><strong>Maven</strong> 是一个基于项目对象模型（Project Object Model，POM）的项目管理工具。它使用 XML 格式的 POM 文件来描述项目结构、依赖关系和构建过程。</p>
</li>
<li><p>Maven 提供了一种标准化的方式来构建项目、管理依赖、运行测试、生成文档和发布项目。它有一组约定的目录结构和生命周期阶段，简化了项目的构建和管理。</p>
</li>
<li>Maven 的中心仓库存储了大量的开源库和依赖项，允许开发者通过声明依赖关系来获取所需的库。</li>
<li><strong>构建过程：</strong> 当你使用 Maven 构建（build）应用程序时，Maven会负责管理构建路径和类路径。这意味着 Maven 将自动执行以下操作：<ul>
<li><strong>依赖处理：</strong> 根据你项目配置文件（<code>pom.xml</code>）中定义的依赖，Maven将自动下载所需的 JAR 文件并将其添加到项目的构建路径中。</li>
<li><strong>编译和打包：</strong> Maven 将负责编译你的代码，并将其打包成目标文件（如 JAR、WAR 等）。</li>
</ul>
</li>
<li><strong>类路径管理：</strong> Maven会根据项目的需要自动管理类路径。当你运行（run）应用程序时，Maven会确保应用程序能够访问并使用所需的类和依赖。这包括添加所需的 JAR 文件到类路径，以便你的应用程序可以正确地加载和运行。</li>
</ul>
<h4 id="Maven运行策略"><a href="#Maven运行策略" class="headerlink" title="Maven运行策略"></a>Maven运行策略</h4><p>当 Maven 开始构建项目时，它会根据项目配置文件中的信息，检查本地仓库，如果本地仓库没有依赖包，就会检查中央仓库，获取项目所需的所有依赖，并将这些包下载到本地仓库作为缓存。然后，它将这些依赖整合到项目的构建过程中，进行编译、测试和打包等操作。</p>
<h4 id="Pom文件架构"><a href="#Pom文件架构" class="headerlink" title="Pom文件架构"></a>Pom文件架构</h4><p>POM 文件的结构通常包括以下主要部分：</p>
<ol>
<li><strong>Project Metadata</strong>（项目元数据）: <ul>
<li><code>&lt;modelVersion&gt;</code>：POM 文件的模型版本。</li>
<li><code>&lt;groupId&gt;</code>、<code>&lt;artifactId&gt;</code>、<code>&lt;version&gt;</code>：定义了项目的坐标信息，用于唯一标识和定位项目。</li>
<li><code>&lt;packaging&gt;</code>：定义项目的打包方式，如 jar、war、pom 等。</li>
<li><code>&lt;name&gt;</code>、<code>&lt;description&gt;</code>：项目名称和描述信息。</li>
<li><code>&lt;url&gt;</code>：项目主页的 URL。</li>
</ul>
</li>
</ol>
<p>示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>My Project<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>This is a sample Maven project<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://github.com/example/my-project<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ...其他配置... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li><strong>Dependencies（依赖项）</strong>: <code>&lt;dependencies&gt;</code> 部分用于声明项目所依赖的外部库、框架或模块。每个依赖都包含 <code>&lt;groupId&gt;</code>、<code>&lt;artifactId&gt;</code> 和 <code>&lt;version&gt;</code> 三个元素，指定了所需的依赖库、版本等信息。</li>
</ol>
<p>示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.26<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ...其他依赖... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li><strong>Plugins（插件）</strong>: <code>&lt;build&gt;</code> 部分可以包含 <code>&lt;plugins&gt;</code> 元素，用于配置构建过程所需的插件。这些插件可以执行编译、测试、打包、部署等各种构建任务。</li>
</ol>
<p>示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- ...其他插件... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这些部分构成了 Maven POM 文件的基本结构，通过定义项目的元数据、依赖项、插件信息，Maven 能够根据 POM 文件来管理项目的构建、依赖和发布等工作。</p>
<h5 id="Maven-Dependency-Coordinates"><a href="#Maven-Dependency-Coordinates" class="headerlink" title="Maven Dependency Coordinates"></a>Maven Dependency Coordinates</h5><p>Maven 项目中依赖坐标（Dependency Coordinates）的重要性和构成要素，以及在添加依赖时的最佳实践。</p>
<ol>
<li><strong>Dependency Coordinates（依赖坐标）</strong>：<ul>
<li>依赖坐标是 Maven 中用于唯一标识和定位项目依赖的信息。它由 Group ID、Artifact ID 和 Version 组成。</li>
<li><strong>Group ID（组织ID）</strong>：指定了依赖所属的组织或机构。</li>
<li><strong>Artifact ID（构件ID）</strong>：指定了依赖项目的名称。</li>
<li><strong>Version（版本）</strong>：可选的，用于指定依赖的版本。建议在依赖中包含版本号，这有助于实现可重复的构建（repeatable builds）。</li>
</ul>
</li>
<li><strong>添加依赖</strong>：<ul>
<li>要添加给定的依赖项目到 Maven 项目中，需要了解该依赖项目的 Group ID 和 Artifact ID。版本号是可选的，但最好也包含以实现可重复的构建。</li>
<li>最佳实践是在添加依赖时包含版本号，这有助于确保构建的一致性和可重复性，因为不同版本的依赖可能会导致不同的行为或问题。</li>
</ul>
</li>
<li><strong>DevOps（开发运维）</strong>：<ul>
<li>在 DevOps 中，强调包括依赖版本号是一个良好的实践，有助于确保构建的一致性和可重复性。</li>
<li>依赖坐标（Group ID、Artifact ID 和 Version）一起被称为 GAV。</li>
</ul>
</li>
</ol>
<h4 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h4><p><img src="/2023/11/28/springboot%E5%AD%A6%E4%B9%A0-1/1.png"></p>
<p>maven项目导入到idea之后，会自动开始下载内容。但是，可能网络超时报错，导致一些包无法下下来。此时我们需要修改maven的settings.xml文件</p>
<p>我是mac系统，用homebrew下载的maven。在idea中，默认的settings.xml文件路径找不到这个文件的如下：</p>
<p><img src="/2023/11/28/springboot%E5%AD%A6%E4%B9%A0-1/3.png"></p>
<p>因此，我们需要在终端输入<code>mvn -v</code> 来确认maven的安装路径：</p>
<p><img src="/2023/11/28/springboot%E5%AD%A6%E4%B9%A0-1/2.png"></p>
<p>然后，进入这个安装路径，settings.xml就在里面的conf文件夹中.现在，我们需要把idea中默认的路径覆盖掉。然后重新加载maven，就可以正常下载、运行文件了。</p>
<p><img src="/2023/11/28/springboot%E5%AD%A6%E4%B9%A0-1/4.png"></p>
<p><img src="/2023/11/28/springboot%E5%AD%A6%E4%B9%A0-1/8.png"></p>
<p>第二天再打开发现很多annotation都变成红色的了，可能是项目没加载完全，需要重启IDea或者重新下载Maven源文件。</p>
<h3 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h3><ul>
<li><strong>Gradle</strong> 是一个基于 Groovy 和 Kotlin 的构建工具。它使用了一种基于DSL（领域特定语言）的方式来描述项目构建。</li>
<li>Gradle 提供了灵活性和强大的定制能力，允许开发者使用 Groovy 或 Kotlin 编写脚本来定义构建过程，处理依赖关系和任务。</li>
<li>它支持增量构建，能够智能地识别需要重新构建的部分，提高了构建效率。</li>
</ul>
<p><img src="/2023/11/28/springboot%E5%AD%A6%E4%B9%A0-1/5.png"></p>
<p>在导入gradle项目之后，idea也会自动下载，但是我出现了超时无法下载的情况。此时我应该修改两处地方：</p>
<p>在gradle文件夹下的gradle-wrapper.prperties,将distributionUrl改为国内镜像</p>
<p><img src="/2023/11/28/springboot%E5%AD%A6%E4%B9%A0-1/6.png"></p>
<p>在build.gradle中，把repository改为国内镜像</p>
<p><img src="/2023/11/28/springboot%E5%AD%A6%E4%B9%A0-1/7.png"></p>
<p>改完后，重新构建gradle，就可以正常下载运行了</p>
<h3 id="添加REST-Controller"><a href="#添加REST-Controller" class="headerlink" title="添加REST Controller"></a>添加REST Controller</h3><p>我们可以新建一个rest文件夹，在里面创建RESTful API，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.jasoncode.springboot.demo.myapp.rest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunRestcontroller</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello world!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码是一个简单的Spring Boot应用程序中的REST Controller示例。在这个示例中，我们创建了一个名为 <code>FunRestController</code> 的类，并使用 <code>@RestController</code> 注解标记它，表示这是一个REST控制器。</p>
<p>其中包含一个 <code>sayHello()</code> 方法，它使用 <code>@GetMapping(&quot;/&quot;)</code> 注解，指示当收到<strong>根路径的GET请求</strong>时，将执行该方法。在这个示例中，<code>sayHello()</code> 方法返回一个简单的字符串 “Hello world!”。</p>
<p>这段代码的作用是，当你访问该应用程序的根路径时，它会响应一个 “Hello world!” 的字符串。这是一个最基本的REST端点示例，返回一个静态的问候语作为响应。</p>
<h3 id="Maven项目结构"><a href="#Maven项目结构" class="headerlink" title="Maven项目结构"></a>Maven项目结构</h3><p>一个典型的 Maven 项目结构包括以下部分：</p>
<ol>
<li><p><strong><code>pom.xml</code> 文件</strong>：</p>
<ul>
<li>Maven 项目的核心文件，称为 Project Object Model（POM）。它描述了项目的元数据信息，包括项目坐标、依赖、插件配置等。</li>
<li><code>pom.xml</code> 文件位于项目根目录下，是 Maven 构建过程的核心配置文件。</li>
</ul>
</li>
<li><p><strong><code>src</code> 目录</strong>：</p>
<ul>
<li><code>src</code> 目录是 Maven 项目的源代码和资源文件的根目录。</li>
</ul>
</li>
<li><p><strong><code>src/main</code> 目录</strong>：</p>
<ul>
<li><code>src/main</code> 目录包含主要的项目源代码和资源文件。</li>
</ul>
</li>
<li><p><strong><code>src/main/java</code> 目录</strong>：</p>
<ul>
<li><code>src/main/java</code> 目录是存放 Java 源代码的主目录。</li>
</ul>
</li>
<li><p><strong><code>src/main/resources</code> 目录</strong>：</p>
<ul>
<li><p><code>src/main/resources</code> 目录用于存放项目的资源文件，如配置文件、静态文件等。</p>
</li>
<li><p>在 Spring Boot 中，<code>application.properties</code> 文件是常用的外部配置文件，它允许开发者将各种配置信息集中在一个文件中，方便进行配置和管理。</p>
<ul>
<li><p><code>server.port=8484</code> 配置了应用程序的端口号为 8484。</p>
</li>
<li><p>有时候我们需要自定义APP的环境变量，可以借助 <code>Application Properties File</code> 来实现</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><p><strong>自定义属性</strong>：可以在 <code>application.properties</code> 文件中定义任何自定义属性。这为应用程序配置提供了灵活性。</p>
</li>
<li><p><strong>属性访问</strong>：在 Spring Boot 应用程序可以使用 <code>@Value</code> 注解直接访问这些属性。这样可以方便地获取配置值，无需额外的编码或配置。</p>
<ul>
<li><p><code>coach.name=Mickey Mouse</code> 和 <code>team.name=The Mouse Crew</code> 配置了教练名称和团队名称。</p>
</li>
<li><p><strong>注入属性值到应用程序中</strong>：</p>
<ul>
<li>Spring Boot 提供了 <code>@Value</code> 注解，允许开发者将属性值注入到应用程序中的 Java 类中。比如 <code>FunRestController</code> 类使用了 <code>@Value</code> 注解，将 <code>coach.name</code> 和 <code>team.name</code> 的值注入到 <code>coachName</code> 和 <code>teamName</code> 字段中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunRestcontroller</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;coach.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String coachName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ol>
<li><p><strong><code>src/test</code> 目录</strong>：</p>
<ul>
<li><code>src/test</code> 目录包含测试代码和资源文件。</li>
</ul>
</li>
<li><p><strong><code>src/test/java</code> 目录</strong>：</p>
<ul>
<li><code>src/test/java</code> 目录存放测试用的 Java 源代码。</li>
</ul>
</li>
<li><p><strong><code>src/test/resources</code> 目录</strong>：</p>
<ul>
<li><code>src/test/resources</code> 目录包含测试用的资源文件。</li>
</ul>
</li>
<li><p><strong><code>target</code> 目录</strong>：</p>
<ul>
<li><code>target</code> 目录是 Maven 构建过程的输出目录，包含编译后的类文件、打包后的 JAR/WAR 文件等。这是 Maven 默认的输出目录。</li>
</ul>
</li>
<li><p><strong><code>mvnw</code> 和 <code>mvnw.cmd</code> 文件</strong>：</p>
</li>
</ol>
<ul>
<li><code>mvnw</code> 和 <code>mvnw.cmd</code> 是 Maven Wrapper 的脚本文件，用于在没有全局 Maven 安装的情况下，使用项目中的 Maven 版本。这些文件能够确保项目在不同环境下使用相同的 Maven 版本，不受全局 Maven 版本的影响。</li>
</ul>
<ol>
<li>警告告诉开发者不要使用 <code>src/main/webapp</code> 目录来存放静态资源，特别是当应用程序打包为 JAR 文件时。虽然 <code>src/main/webapp</code> 是 Maven 标准目录，但它仅适用于 WAR 打包，当生成 JAR 文件时，大多数构建工具会忽略该目录。</li>
</ol>
<h3 id="Spring-Boot-starters"><a href="#Spring-Boot-starters" class="headerlink" title="Spring Boot starters"></a>Spring Boot starters</h3><p>在 Spring Boot 中，Starters（启动器）是预配置的 Maven 依赖项集合，旨在简化和加快特定功能的项目启动和配置过程。Starters 可以快速启用一组相关的库和依赖项，使得开发者能够更容易地构建特定类型的应用程序。</p>
<p>每个 Starter 都是一组预配置的依赖项，它们旨在实现特定功能或引入特定技术栈。Starters 的命名通常以 <code>spring-boot-starter-</code> 为前缀，后面跟着特定功能或技术的名称。</p>
<p>一些常见的 Spring Boot Starters 包括：</p>
<ol>
<li><strong>spring-boot-starter-web</strong>：<ul>
<li>用于构建 Web 应用程序的 Starter，包括了 Spring MVC、Tomcat（或其他嵌入式 Servlet 容器）等。</li>
</ul>
</li>
<li><strong>spring-boot-starter-data-jpa</strong>：<ul>
<li>针对使用 JPA 进行数据持久化的应用程序的 Starter，包含了 Spring Data JPA、Hibernate 等。</li>
</ul>
</li>
<li><strong>spring-boot-starter-security</strong>：<ul>
<li>用于构建安全性功能的 Starter，包括了 Spring Security、OAuth2 等。</li>
</ul>
</li>
<li><strong>spring-boot-starter-test</strong>：<ul>
<li>用于测试应用程序的 Starter，包含了 JUnit、Mockito、Spring Test 等测试框架和工具。</li>
</ul>
</li>
<li><strong>spring-boot-starter-logging</strong>：<ul>
<li>用于日志记录的 Starter，包含了 Spring Boot 默认的日志框架（如 Logback、Log4j2）。</li>
</ul>
</li>
</ol>
<p>使用 Starter 的好处在于它们提供了一种快速启用和配置特定功能的方式，而不需要开发者手动管理大量的依赖项。通过引入相应的 Starter，Spring Boot 能够自动配置应用程序所需的依赖项和功能，减少了开发者的配置工作，同时保证了一致性和可维护性。</p>
<h4 id="Springboot-starter-parent"><a href="#Springboot-starter-parent" class="headerlink" title="Springboot starter parent"></a>Springboot starter parent</h4><p><code>spring-boot-starter-parent</code> 是 Spring Boot 提供的一个特殊的 Maven 父项目（Parent Project），作为 Spring Boot 应用程序的父项目，其他 Spring Boot 项目可以继承它来获得许多默认配置和依赖项的管理。</p>
<p><code>spring-boot-starter-parent</code> 的好处包括：</p>
<ol>
<li><strong>默认配置</strong>：<ul>
<li>包含了许多常用的 Maven 插件配置和默认的依赖项管理。通过继承 <code>spring-boot-starter-parent</code>，开发者可以省去大量常用插件和依赖项的配置工作。</li>
</ul>
</li>
<li><strong>版本管理</strong>：<ul>
<li>管理了大量 Spring Boot 相关依赖库的版本。使用它作为父项目，可以确保所使用的 <code>spring-boot-starter-*</code>相关库的版本是兼容的，避免版本冲突问题。</li>
</ul>
</li>
</ol>
<h3 id="Springboot-Devtools"><a href="#Springboot-Devtools" class="headerlink" title="Springboot Devtools"></a>Springboot Devtools</h3><ol>
<li><strong>自动应用重启</strong>：<ul>
<li>当应用程序的类文件发生变化时，DevTools 可以监控并自动触发应用程序的重启，从而使开发者无需手动重启应用程序。这大大加快了开发调试过程，节省了重启应用程序的时间。</li>
</ul>
</li>
<li><strong>自动加载静态资源</strong>：<ul>
<li>在开发过程中，当静态资源（如 HTML、CSS、JavaScript 文件）发生变化时，DevTools 可以自动加载这些资源，无需手动刷新浏览器。这样可以减少刷新页面的频率，提高开发效率。</li>
</ul>
</li>
</ol>
<p>它需要在 <code>pom.xml</code> 中写入</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此外，要实现实时编译，需要在idea中开启这两个开关：<br><img src="/2023/11/28/springboot%E5%AD%A6%E4%B9%A0-1/11.png"></p>
<p><img src="/2023/11/28/springboot%E5%AD%A6%E4%B9%A0-1/12.png"></p>
<h3 id="Springboot-Actuator"><a href="#Springboot-Actuator" class="headerlink" title="Springboot Actuator"></a>Springboot Actuator</h3><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#actuator" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#actuator</a></p>
<p>Spring Boot Actuator 是 Spring Boot 框架的一个模块，用于向开发者暴露用于监控和管理应用程序的端点（endpoints）。它提供了一组 RESTful 风格的端点，可以通过 HTTP 请求来查看应用程序的运行状态、健康状况、性能指标等信息，同时也提供了对应用程序进行管理的端点，如关闭应用程序、查看线程堆栈等。</p>
<p>Spring Boot Actuator 的主要好处和解决的问题包括：</p>
<ol>
<li><strong>监控和管理应用程序</strong>：<ul>
<li>Actuator 暴露了一系列端点（endpoints），用于监控和管理应用程序。这些端点包括健康检查、信息展示、环境配置、配置属性、日志记录级别等，为开发者提供了便捷的监控和管理功能。</li>
</ul>
</li>
<li><strong>DevOps 功能</strong>：<ul>
<li>Actuator 提供了一种简便的方式来获取 DevOps 功能。通过 Actuator 的端点，可以轻松地获取有关应用程序运行状态和配置的信息，有助于 DevOps 工作的进行。</li>
</ul>
</li>
<li><strong>无需额外编码</strong>：<ul>
<li>只需将 Actuator 的依赖添加到项目的 POM 文件中，就可以获得大量监控和管理端点的功能。不需要开发者手动编写代码，这些端点会自动添加到应用程序中。</li>
</ul>
</li>
<li><strong>免费的新端点</strong>：<ul>
<li>集成 Actuator 后，开发者无需编写任何代码即可获得一系列新的端点。这些端点提供了大量有用的信息和功能，如监控指标、应用程序配置、日志级别等，而无需开发者额外投入工作来编写这些功能。</li>
<li>默认只暴露<code>/actuator/health</code> , 如果希望暴露所有端点，需要在<code>application.properties</code>中加入 <code>management.endpoints.web.exposure.include=*</code></li>
</ul>
</li>
</ol>
<h4 id="Info-Endpoint"><a href="#Info-Endpoint" class="headerlink" title="Info Endpoint"></a>Info Endpoint</h4><p>这是 Spring Boot Actuator 暴露的端点之一，用于展示应用程序的自定义信息。</p>
<ul>
<li>通过配置 <code>application.properties</code> 文件中的 <code>info</code> 前缀的属性，可以定义应用程序的一些自定义信息，如应用名称、描述和版本号。还需要在该文件中设置：<code>management.info.env.enabled=true</code></li>
</ul>
<ol>
<li><strong>配置信息示例</strong>：<ul>
<li>在 <code>src/main/resources/application.properties</code> 文件中，通过配置 <code>info.app.name</code>、<code>info.app.description</code> 和 <code>info.app.version</code> 属性，设置了应用程序的名称、描述和版本号。</li>
</ul>
</li>
<li><strong>访问 Info Endpoint</strong>：<ul>
<li>访问 Info Endpoint 的 URL 是 <code>localhost:8080/actuator/info</code>。这个端点暴露了应用程序的信息，并且展示了配置文件中以 <code>info</code> 开头的属性值。</li>
</ul>
</li>
</ol>
<h4 id="beans-Endpoint"><a href="#beans-Endpoint" class="headerlink" title="beans Endpoint"></a>beans Endpoint</h4><p><img src="/2023/11/28/springboot%E5%AD%A6%E4%B9%A0-1/13.png"></p>
<ul>
<li>端点用于展示应用程序中当前可用的 Spring Beans（Spring 容器管理的对象）信息。</li>
<li>访问该端点将返回关于 Spring 应用程序上下文中所有 Bean 的详细信息，包括 Bean 的名称、类型、作用域、是否为单例等。</li>
<li>这个端点对于开发者了解应用程序中所有注册的 Bean 非常有用，可以帮助排查 Bean 是否正确加载、是否存在冲突等问题。</li>
</ul>
<h4 id="threaddump-Endpoint"><a href="#threaddump-Endpoint" class="headerlink" title="threaddump Endpoint"></a>threaddump Endpoint</h4><p><img src="/2023/11/28/springboot%E5%AD%A6%E4%B9%A0-1/14.png"></p>
<p><code>/actuator/threaddump</code> 端点是 Spring Boot Actuator 提供的一个端点，用于获取应用程序的线程转储信息（Thread Dump）。线程转储是指在特定时间点捕获应用程序所有线程的状态信息，包括每个线程的堆栈跟踪信息，以便分析线程的运行状态和问题。</p>
<p>访问 <code>/actuator/threaddump</code> 端点将返回一个包含所有线程当前状态的文本或 JSON 格式的数据。这些信息可以帮助开发者或运维人员分析应用程序的运行情况，尤其是在处理一些复杂的并发问题或线程阻塞时非常有用。</p>
<h4 id="mappings"><a href="#mappings" class="headerlink" title="mappings"></a>mappings</h4><p><img src="/2023/11/28/springboot%E5%AD%A6%E4%B9%A0-1/15.png"></p>
<ul>
<li><code>/actuator/mappings</code> 端点用于显示应用程序中的 URL 映射信息，即展示请求 URL 与处理该 URL 的处理程序（Handler）之间的映射关系。</li>
<li>该端点返回了一个包含请求路径映射关系的 JSON 结构，包括每个 URL 路径与对应的处理方法、控制器类等信息。</li>
<li>这个端点对于开发者在调试、查看 URL 映射以及检查请求路径与处理方法的关系时非常有帮助。</li>
</ul>
<h4 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h4><p>我们可以在pom中加入：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>来保护actuator的端点，使他们需要登录才可以查看。</p>
<p>并且我们可以在<code>application.properties</code> 中加入：</p>
<p><code>management.endpoints.web.exposure.exclude=health,info</code> 来让这两个端点免于保护，所有人都能访问到</p>
<p>重新启动后在终端会自动生成一个安全密码，每次启动的密码都是不一样的：</p>
<p><img src="/2023/11/28/springboot%E5%AD%A6%E4%B9%A0-1/16.png"></p>
<p>我们用用户名user和这个密码就能访问到被保护的端点。</p>
<p><img src="/2023/11/28/springboot%E5%AD%A6%E4%B9%A0-1/17.png"></p>
<h3 id="使用命令行运行springboot项目"><a href="#使用命令行运行springboot项目" class="headerlink" title="使用命令行运行springboot项目"></a>使用命令行运行springboot项目</h3><p>Spring Boot 应用程序是自包含的，这意味着它们可以独立运行，而不需要额外的服务器或软件</p>
<p>比如打包成 <code>app.jar</code> , 这种打包方式省去了安装额外服务器（如Tomcat）的需求，因为JAR文件已经包含了所需的一切，包括应用程序代码和服务器代码。总的来说，Spring Boot 使得部署和运行应用程序变得更加简单和高效，因为所有必需的组件都被打包在一个文件中。</p>
<ul>
<li>方法1，使用<code>java -jar name.jar</code> 来运行项目</li>
<li>方法2，使用maven工具</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用 Spring Boot Maven 插件的主要点如下：</p>
<ol>
<li><strong>Maven Wrapper (mvnw)</strong>: Maven Wrapper 允许您运行 Maven 项目，即使没有在计算机上安装 Maven 或者 Maven 不在环境变量路径中。这是通过使用 <code>mvnw</code>（对于 Windows 是 <code>mvnw.cmd</code>，对于 Linux/Mac 是 <code>mvnw.sh</code>）实现的。</li>
<li><strong>便利性</strong>：使用 Maven Wrapper 的好处在于，如果您的计算机上没有找到正确版本的 Maven，它会自动下载正确的版本并运行 Maven。</li>
<li><strong>项目结构</strong>：您提到了 <code>pom.xml</code> 文件，这是 Maven 项目的核心，包含了项目配置和依赖信息。</li>
<li><strong>构建和测试命令</strong>：可以通过命令 <code>mvnw clean compile test</code> 在项目目录中执行清理、编译和测试步骤。这条命令适用于所有操作系统，只是在 Linux/Mac 系统中前缀为 <code>./</code>（如 <code>./mvnw clean compile test</code>）。</li>
<li><strong>跨平台脚本</strong>：提供了两个文件，<code>mvnw.cmd</code> 用于 Windows 系统，<code>mvnw.sh</code> 用于 Linux 或 Mac 系统，以支持不同操作系统的 Maven 项目构建。</li>
<li>可以使用<code>mvnw spring-boot:run</code> 启动maven项目</li>
</ol>
<h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><p>如果已经装好了maven，那么就可以直接用<code>mvn package</code> 打包项目，如果没有，就运行 <code>./mvnw package</code> ，它会帮我们自动下载maven</p>
<h3 id="Spring-Boot-Properties"><a href="#Spring-Boot-Properties" class="headerlink" title="Spring Boot Properties"></a>Spring Boot Properties</h3><p>Spring Boot 还有很多Properties，可以参考<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties" target="_blank" rel="noopener">这个网站</a></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2023/11/17/%E5%8F%98%E8%89%B2%E9%BE%99%E5%93%88%E5%B8%8C-%E8%B0%83%E7%A0%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/11/17/%E5%8F%98%E8%89%B2%E9%BE%99%E5%93%88%E5%B8%8C-%E8%B0%83%E7%A0%94/" itemprop="url">变色龙哈希-调研</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2023-11-17T14:22:09+08:00">
                2023-11-17
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2023-11-17T15:46:55+08:00">
                2023-11-17
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="变色龙哈希调研"><a href="#变色龙哈希调研" class="headerlink" title="变色龙哈希调研"></a>变色龙哈希调研</h1><h2 id="调研背景"><a href="#调研背景" class="headerlink" title="调研背景"></a>调研背景</h2><h4 id="哈希函数定义"><a href="#哈希函数定义" class="headerlink" title="哈希函数定义"></a>哈希函数定义</h4><p>哈希函数是一类具有以下特征的函数：将任意长度输入的字串可转换成一个固定长度的字串，通过原始字串可以很容易地算出转换后的字串，通过转换后的字串很难还原出原始字串。</p>
<h4 id="哈希函数特征"><a href="#哈希函数特征" class="headerlink" title="哈希函数特征"></a>哈希函数特征</h4><p>弱抗碰撞性：对于消息x，找到y≠x且H(x)=H(y)的y在计算上是不可行的。<br>强抗碰撞性：找到任何满足H(x)=H(y)的偶对(x,y)在计算上是不可行的。</p>
<p>已知一个消息x，去找y使得两者的哈希相等要比随便找两个消息x，y使得两个的哈希相等要更难，可能性更“弱”，所以已知一个消息x，寻找消息y使得两个哈希值相等叫做“弱碰撞”，找到x，y使得两个哈希值相等叫做强碰撞</p>
<h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><p>​       如果使用普通的哈希哈希函数，对于基于区块链的版权保护系统而言，可能会有这样一种场景：原作者创作了数字作品之后，并没有将自己的作用上链，而是以其他方式公布到了网上，Evil可能在网上或者其他地方看到这个作品，然后在未经作者的应允的情况下，将作品以自己的身份上链。如果上链成功，此后，当原作者要求改变区块链上该作品的版权的时候，由于区块链的不可篡改性，这时候就难以解决。因此，我们考虑引入变色龙哈希。</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2023/11/07/linux-traffic-control/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/11/07/linux-traffic-control/" itemprop="url">linux_traffic_control</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2023-11-07T20:02:23+08:00">
                2023-11-07
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2025-04-11T10:11:11+08:00">
                2025-04-11
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="linux-traffic-control"><a href="#linux-traffic-control" class="headerlink" title="linux traffic control"></a>linux traffic control</h1><p>Traffic Control 技术实现的基本原理就是 Queue（队列），通过在网络设备（包括：主机网卡、交换机、路由器等）的 Ingress 和 Egress 处使用一系列的 Queues 来对数据报文进行排队，继而控制它们的发送优先顺序和速率。同时，还可以针对不同的 Queues 施加相应的 Policy（策略），实现更灵活的功能特性。</p>
<p>首先，要使用tc指令，先要用<code>sudo apt-get install iproute2</code> 下载包</p>
<h3 id="Add-constant-delay"><a href="#Add-constant-delay" class="headerlink" title="Add constant delay"></a>Add constant delay</h3><p>我们可以通过tc指令为ping增加延迟。</p>
<p>首先我们可以通过<code>sudo lshw -C network | grep &#39;logical name&#39;</code> 来获得当前机器的网卡。</p>
<p><img src="/2023/11/07/linux-traffic-control/1.png" style="zoom:67%;"></p>
<p>首先我们来看没有增加延迟的时候，<code>ping baidu.com的结果</code></p>
<p><img src="/2023/11/07/linux-traffic-control/2.png" style="zoom:67%;"></p>
<p>然后我们通过指令增加延迟</p>
<p><code>sudo tc qdisc add dev ens160 root netem delay 200ms</code></p>
<p><img src="/2023/11/07/linux-traffic-control/3.png" style="zoom:67%;"></p>
<p>此时可以用<code>sudo tc qdisc show dev ens160</code>来查看当前网卡的延时</p>
<p><img src="/2023/11/07/linux-traffic-control/4.png" style="zoom:67%;"></p>
<p>同样的，可以使用 <code>sudo tc qdisc del dev ens160 root</code> 来删除这个延时</p>
<h3 id="Add-random-delay"><a href="#Add-random-delay" class="headerlink" title="Add random delay"></a>Add random delay</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tc class add dev eth0 parent 1: classid 1:20 htb rate 8mibit</span><br><span class="line">tc class add dev eth0 parent 1: classid 1:30 htb rate 8mibit</span><br><span class="line"></span><br><span class="line">tc qdisc add dev eth0 parent 1:20 handle 20: sfq perturb 10</span><br><span class="line">tc qdisc add dev eth0 parent 1:30 handle 30: sfq perturb 10</span><br><span class="line"></span><br><span class="line">tc filter add dev eth0 parent 1: protocol ip prio 1 basic match &#39;cmp(u16 at 0 layer transport eq 1081)&#39; flowid 1:20</span><br><span class="line">tc filter add dev eth0 parent 1: protocol ip prio 1 basic match &#39;cmp(u16 at 0 layer transport eq 1082)&#39; flowid 1:30</span><br></pre></td></tr></table></figure>
<h3 id="Add-packet-loss"><a href="#Add-packet-loss" class="headerlink" title="Add packet loss"></a>Add packet loss</h3><p>我们可以用<code>sudo tc qdisc add dev ens160 root netem loss 10%</code> 来设置一个丢包率</p>
<p><img src="/2023/11/07/linux-traffic-control/5.png" style="zoom:67%;"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># Define variables</span><br><span class="line">IP&#x3D;192.168.1.100&#x2F;32</span><br><span class="line">PORT&#x3D;8000</span><br><span class="line">INTERFACE&#x3D;eth0</span><br><span class="line">VIRTUAL_INTERFACE&#x3D;ifb0</span><br><span class="line"># Speed unit is Mbits&#x2F;s</span><br><span class="line">TUPLE_SPEED&#x3D;100</span><br><span class="line"></span><br><span class="line"># Add the virtual interface</span><br><span class="line">modprobe ifb numifbs&#x3D;1;</span><br><span class="line">ip link set dev &quot;$VIRTUAL_INTERFACE&quot; up;</span><br><span class="line"></span><br><span class="line"># Redirect ingress packets to egress virtual interface</span><br><span class="line">tc qdisc add dev &quot;$INTERFACE&quot; handle ffff: ingress</span><br><span class="line">tc filter add dev &quot;$INTERFACE&quot; parent ffff: protocol ip u32 match u32 0 0 action mirred egress redirect dev &quot;$VIRTUAL_INTERFACE&quot;;</span><br><span class="line"></span><br><span class="line"># Create root qdisc and class for the virtual interface</span><br><span class="line">tc qdisc add dev &quot;$VIRTUAL_INTERFACE&quot; root handle 1: htb;</span><br><span class="line">tc class add dev &quot;$VIRTUAL_INTERFACE&quot; parent 1: classid 1:10 htb rate &quot;$&#123;TUPLE_SPEED&#125;mbit&quot;;</span><br><span class="line"></span><br><span class="line"># Add a filter that match yor tuple </span><br><span class="line">tc filter add dev &quot;$VIRTUAL_INTERFACE&quot; protocol ip parent 1: prio 1 u32 match ip dst &quot;$&#123;IP&#125;&quot; match udp dst&quot;$&#123;PORT&#125;&quot; flowid 1:10;</span><br></pre></td></tr></table></figure>
<h3 id="Set-bandwidth-limit"><a href="#Set-bandwidth-limit" class="headerlink" title="Set bandwidth limit"></a>Set bandwidth limit</h3>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2023/11/03/redis%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/11/03/redis%E5%BA%94%E7%94%A8/" itemprop="url">redis应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2023-11-03T10:47:24+08:00">
                2023-11-03
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2023-11-29T19:36:17+08:00">
                2023-11-29
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="redis-应用"><a href="#redis-应用" class="headerlink" title="redis 应用"></a>redis 应用</h1><p>我们知道redis是一个内存数据库，因此我们可以将其作为一个缓存池，对应用进行加速。</p>
<p>最常见的应用就是用来缓存网页，在用户请求的时候，直接从Redis中取出网页的HTML返回给客户端即可，不需要对HTML重新渲染。</p>
<h3 id="存储考量"><a href="#存储考量" class="headerlink" title="存储考量"></a>存储考量</h3><p>但是，如果所有网页都存在redis中，对内存也是一个很大的挑战。因此，什么样的网页适合存放在Redis中呢？</p>
<p><img src="/2023/11/03/redis%E5%BA%94%E7%94%A8/1.png" style="zoom:67%;"></p>
<p>我们看到，如果我们将动态的、客制化的网页存储在Redis中，这样依赖，对于每一个用户，都要占用0.334MB的内存。这样如果客户一多，服务器内存很可能用完。</p>
<p>而仅在Redis中存储静态页面，比如关于、联系、登录注册等页面，这些对所有用户来说都是一样的。因此只需要消耗0.22MB即可满足所有用户的需求。</p>
<p>然后我们需要从几个维度来思考问题，帮助我们存储。和MySQL这类关系型数据库现将数据存入，再思考如何编写SQL不同。对于Redis来说，需要先思考如何取用，再配套存储对应的数据。</p>
<ol>
<li>首先，我们要思考存入什么类型的数据。在此方案中，我们需要存入HTML字符串</li>
<li>我们是否应该考虑数据的大小？在此方案中，我们仅存储特定的静态页面，占用空间很小。</li>
<li>这个数据是否需要设置过期时间？在此方案中，我们需要设置过期时间。</li>
<li>这些数据的键的命名方式是怎么样的？</li>
<li>是否有业务逻辑上的考虑？在这里并没有</li>
</ol>
<p><img src="/2023/11/03/redis%E5%BA%94%E7%94%A8/2.png" style="zoom:67%;"></p>
<h3 id="键的命名"><a href="#键的命名" class="headerlink" title="键的命名"></a>键的命名</h3><p><img src="/2023/11/03/redis%E5%BA%94%E7%94%A8/3.png" style="zoom:67%;"></p>
<p>在Redis中，键的命名应该是唯一的。因此，我们可以用 类别:ID 来唯一标识一个键值对。在这个例子中，我们使用#作为间隔符，前面是键要存储数据品类，即pagecache，后面是特定网页的路由。</p>
<p><img src="/2023/11/03/redis%E5%BA%94%E7%94%A8/4.png" style="zoom:67%;"></p>
<p>具体逻辑如下图所示，用户请求SvelteKit Server,server会看是否该请求页面已经被存放在Redis当中。如果是，就从Redis取出并返回；如果没有，那么就需要渲染页面，同时把这个页面缓存在Redis中。</p>
<p><img src="/2023/11/03/redis%E5%BA%94%E7%94%A8/5.png" style="zoom:67%;"></p>
<p>​                                      </p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>我们使用TypeScript进行代码编写, 首先引入redis模块</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; client &#125; <span class="keyword">from</span> <span class="string">"$services/redis"</span>;</span><br><span class="line"><span class="comment">//确定要缓存的页面路由</span></span><br><span class="line"><span class="keyword">const</span> cacheRoutes = [</span><br><span class="line">    <span class="string">'/about'</span>,<span class="string">'/privacy'</span>,<span class="string">'/auth/signin'</span>,<span class="string">'/auth/signup'</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getCachedPage = <span class="function">(<span class="params">route: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(route);</span><br><span class="line">    <span class="keyword">if</span>(cacheRoutes.includes(route))&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'getCachePage成功，返回页面'</span>);</span><br><span class="line">        <span class="keyword">return</span> client.get(<span class="string">'pagecache#'</span>+route);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> setCachedPage = <span class="function">(<span class="params">route: <span class="built_in">string</span>, page: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(route);</span><br><span class="line">    <span class="keyword">if</span>(cacheRoutes.includes(route))&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'setCachePage成功，设置页面：'</span>+route);</span><br><span class="line">        <span class="keyword">return</span> client.set(<span class="string">'pagecache#'</span>+route, page,&#123;</span><br><span class="line">            EX:<span class="number">10</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不过，这个程序还是可以优化的的，此时我们设置的键需要手打出来，但是手打容易出错，未免有些hardcode。因此我们可以写一个函数来生成键</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> pageCacheKey = <span class="function">(<span class="params">id: <span class="built_in">string</span></span>) =&gt;</span> <span class="string">`pagecache#<span class="subst">$&#123;id&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2023/04/16/ubuntu-samba%E9%83%A8%E7%BD%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/04/16/ubuntu-samba%E9%83%A8%E7%BD%B2/" itemprop="url">ubuntu_samba部署</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2023-04-16T15:27:11+08:00">
                2023-04-16
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2023-04-16T15:45:21+08:00">
                2023-04-16
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于之前装过samba但是被我稀里糊涂一顿操作给卸载了，显然也没有卸干净，于是打算重装一下。把能踩的坑基本都踩了。</p>
<p>首先我由于之前手动删除了 <code>/etc/samba</code>文件夹，导致重新下载以后这个文件夹不会自动生成。因此我需要删除samba所依赖的所有相关包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove samba*</span><br></pre></td></tr></table></figure>
<p>重新安装后还是会出现错误：<code>dpkg：处理 samba-common (--configure)时出错：</code></p>
<p>因此要这样操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo&#96; &#96;mv&#96; &#96;&#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;info&#96; &#96;&#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;info_old</span><br><span class="line">sudo&#96; &#96;mkdir&#96; &#96;&#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;info</span><br><span class="line">sudo&#96; &#96;apt-get update, apt-get -f &#96;&#96;install</span><br><span class="line">sudo&#96; &#96;mv&#96; &#96;&#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;info&#x2F;&#96;&#96;* &#96;&#96;&#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;info_old</span><br><span class="line">sudo&#96; &#96;rm&#96; &#96;-rf &#96;&#96;&#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;info</span><br><span class="line">sudo&#96; &#96;mv&#96; &#96;&#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;info_old&#96; &#96;&#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;info</span><br></pre></td></tr></table></figure>
<p>然后就有<code>/etc/samba</code> 文件夹，但是smb.conf文件仍然需要自己配置：<br>其中，[share] 是自定义的，里面的path指向我需要共享的文件夹。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># Global parameters</span><br><span class="line">[global]</span><br><span class="line">        log file &#x3D; &#x2F;var&#x2F;log&#x2F;samba&#x2F;log.%m</span><br><span class="line">        logging &#x3D; file</span><br><span class="line">        map to guest &#x3D; Bad User</span><br><span class="line">        max log size &#x3D; 1000</span><br><span class="line">        obey pam restrictions &#x3D; Yes</span><br><span class="line">        pam password change &#x3D; Yes</span><br><span class="line">        panic action &#x3D; &#x2F;usr&#x2F;share&#x2F;samba&#x2F;panic-action %d</span><br><span class="line">        passwd chat &#x3D; *Enter\snew\s*\spassword:* %n\n *Retype\snew\s*\spassword:* %n\n *password\supdated\ssuccessfully* .</span><br><span class="line">        passwd program &#x3D; &#x2F;usr&#x2F;bin&#x2F;passwd %u</span><br><span class="line">        server role &#x3D; standalone server</span><br><span class="line">        server string &#x3D; %h server (Samba, Ubuntu)</span><br><span class="line">        unix password sync &#x3D; Yes</span><br><span class="line">        usershare allow guests &#x3D; Yes</span><br><span class="line">        idmap config * : backend &#x3D; tdb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[printers]</span><br><span class="line">        browseable &#x3D; No</span><br><span class="line">        comment &#x3D; All Printers</span><br><span class="line">        create mask &#x3D; 0700</span><br><span class="line">        path &#x3D; &#x2F;var&#x2F;spool&#x2F;samba</span><br><span class="line">        printable &#x3D; Yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[print$]</span><br><span class="line">        comment &#x3D; Printer Drivers</span><br><span class="line">        path &#x3D; &#x2F;var&#x2F;lib&#x2F;samba&#x2F;printers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[share]</span><br><span class="line">        comment &#x3D; this is Linux share directory</span><br><span class="line">        guest ok &#x3D; Yes</span><br><span class="line">        path &#x3D; &#x2F;home&#x2F;jason&#x2F;sharefile</span><br></pre></td></tr></table></figure>
<p>然后，要运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smbpasswd -a root</span><br></pre></td></tr></table></figure>
<p>来设置root用户，否则samba无法启动</p>
<p>设置完以后，我尝试启动samba服务：<code>sudo system restart smbd.service</code> ，结果失败：<code>Failed to restart smbd.service: Unit smbd.service is masked</code></p>
<p>需要如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl unmask smbd.service</span><br><span class="line">sudo systemctl enable smbd.service</span><br><span class="line">sudo systemctl restart smbd.service</span><br></pre></td></tr></table></figure>
<p>成功启动samba服务</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/3/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/%5Bobject%20Object%5D"
                alt="Jason" />
            
              <p class="site-author-name" itemprop="name">Jason</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20fa%20fa-archive">
              
                  <span class="site-state-item-count">435</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">61</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="true"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
 <!--
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>







-->
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>




















  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v="></script>

  <script type="text/javascript" src="/js/src/motion.js?v="></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v="></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
