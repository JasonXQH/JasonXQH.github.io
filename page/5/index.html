<!DOCTYPE html>
<html lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jasonxqh.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jason‘s Blog">
<meta property="og:url" content="https://jasonxqh.github.io/page/5/index.html">
<meta property="og:site_name" content="Jason‘s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jasonxqh.github.io/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jason‘s Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jason‘s Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/05/08/advanced-Scala%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/08/advanced-Scala%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">advanced-Scala学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-05-08 13:37:48 / Modified: 13:37:50" itemprop="dateCreated datePublished" datetime="2022-05-08T13:37:48+08:00">2022-05-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/04/28/scala%E5%88%9D%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/28/scala%E5%88%9D%E8%AF%86/" class="post-title-link" itemprop="url">scala初识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-28 10:29:01" itemprop="dateCreated datePublished" datetime="2022-04-28T10:29:01+08:00">2022-04-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-09 14:59:58" itemprop="dateModified" datetime="2022-05-09T14:59:58+08:00">2022-05-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Scala初识"><a href="#Scala初识" class="headerlink" title="Scala初识"></a>Scala初识</h1><h2 id="The-Absolute-Scala-Basics"><a href="#The-Absolute-Scala-Basics" class="headerlink" title="The Absolute Scala Basics"></a>The Absolute Scala Basics</h2><h3 id="Values-Variables-and-Types"><a href="#Values-Variables-and-Types" class="headerlink" title="Values, Variables and Types"></a>Values, Variables and Types</h3><p>学习一门新的语言，自然要先从数值类型入手。在scala中，常量用val定义，变量用var定义。</p>
<ul>
<li>定义常量Int</li>
</ul>
<p>一个量有两种定义方式，一种是显式的定义x. 指明其为类型；另外一种则是隐式的声明，让编译器来判断的类型。推荐使用显式的定义，可读性更强一些。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x : <span class="type">Int</span> = <span class="number">62</span></span><br><span class="line"><span class="keyword">val</span> x = <span class="number">62</span></span><br></pre></td></tr></table></figure>
<ul>
<li>定义常量String，同样分显式和隐式两种。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aString : <span class="type">String</span> = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">val</span> bString = <span class="string">"goodbye"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>定义布尔值Boolean</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aBoolean: <span class="type">Boolean</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>定义字符类型 Char</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aChar: <span class="type">Char</span> = 'a'</span><br><span class="line"><span class="keyword">val</span> bChar = 'b'</span><br></pre></td></tr></table></figure>
<ul>
<li>定义Short类型整数</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aShort : <span class="type">Short</span> = <span class="number">3456</span></span><br></pre></td></tr></table></figure>
<ul>
<li>定义Long 整数, 需要在数值尾部加上L</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aLong : <span class="type">Long</span> =<span class="number">5273985273895237</span>L</span><br><span class="line"><span class="keyword">val</span> bLong = <span class="number">5273985273895237</span>L</span><br></pre></td></tr></table></figure>
<ul>
<li>定义浮点数Float, 需要在尾部加上f</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aFloat: <span class="type">Float</span> = <span class="number">2.0</span>f</span><br><span class="line"><span class="keyword">val</span> bFloat = <span class="number">2.0</span>f</span><br></pre></td></tr></table></figure>
<ul>
<li>定义双精度浮点数Double</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aDouble: <span class="type">Double</span> = <span class="number">3.14</span></span><br><span class="line"><span class="keyword">val</span> bDouble = <span class="number">2.0</span></span><br></pre></td></tr></table></figure>
<p>scala中还有一个特殊的类型：Unit类型，它表示无值，和其他语言中的void等同。用作不返回任何结果的方法的结果类型。Unit只有一个实例值，写成 <code>()</code></p>
<p>比如说：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aWeirdValue = (aVariable = <span class="number">3</span>)<span class="comment">// Unit == void</span></span><br><span class="line">println(aWeirdValue)</span><br></pre></td></tr></table></figure>
<h3 id="Expressions"><a href="#Expressions" class="headerlink" title="Expressions"></a>Expressions</h3><ul>
<li>操作符</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="number">3</span>+<span class="number">5</span></span><br><span class="line"><span class="keyword">val</span> xIsEven = x%<span class="number">2</span> == <span class="number">0</span></span><br><span class="line"><span class="keyword">val</span> xIsOdd = !xIsEven</span><br></pre></td></tr></table></figure>
<p>scala中的操作符和Java中的操作符是一样的，包括||, &amp;&amp; ， &gt;&gt;,&lt;&lt;, ^ ,+= , 但是注意，没有++，—</p>
<ul>
<li>if 表达式，if在scala中是以表达式的形式存在，而不是以指令的形式存在的，如下</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> cond: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">val</span> i = <span class="keyword">if</span>(cond) <span class="number">42</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>当然也可以写正常的 If-else  指令</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(aVariable==<span class="number">4</span>)&#123;</span><br><span class="line">  println(<span class="string">"12dsdawd"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  println(<span class="number">2112</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>while表达式，在Scala中请不要写while表达式，因为scala有更方便的方法进行遍历。 while表达式也是可以返回值的，只不过返回一个unit。</li>
</ul>
<p>在scala中,所有的代码都是以表达式的形式呈现的，因此我们在写scala的时候要尽量减少如 <code>println()</code>、 <code>while</code>、以及变量再赋值这类的命令式语言的代码。虽然他们有效，但本质上还是表达式，返回的值是Unit，且会干扰我们代码的工整</p>
<ul>
<li>code block, 此外scala还有一种特殊的表达式 ： CodeBlocks .这种表达式返回的值是代码块的最后一行得到的值，在这里 <code>aCodeBlock = &quot;goodbye&quot;</code>. 此外要记住，在CodeBlocks中定义的val定量，在块外是无法被访问到的</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aCodeBlock = &#123;</span><br><span class="line">  <span class="keyword">val</span> y = <span class="number">2</span></span><br><span class="line">  <span class="keyword">val</span> z = y+<span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span>(z &gt; <span class="number">2</span>) <span class="string">"hello"</span> <span class="keyword">else</span> <span class="string">"goodbye"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> somValue = &#123;</span><br><span class="line">	<span class="number">2</span>&lt;<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> someOtherValue = &#123;</span><br><span class="line">	<span class="keyword">if</span>(someValue) <span class="number">239</span> <span class="keyword">else</span> <span class="number">2120</span></span><br><span class="line">	<span class="number">42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请问someOtherValue的结果是什么? 因为CodeBlock的值等于最后一行代码的值，在这里someOtherValue = 42</p>
<h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><p>在Scala中，一个函数的定义如下：</p>
<p><code>aFunction</code>是函数的名字，a和b是函数的两个需要被输入的参数，String是该函数的返回值类型</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aFunction</span> </span>(a: <span class="type">String</span>,b: <span class="type">Int</span>) <span class="type">String</span> = &#123;</span><br><span class="line">	a + <span class="string">" "</span> + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果函数只有一行，那么可以不需要用<code>{}</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比如这个函数只需要返回42</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aParameterlessFunction</span></span>(): <span class="type">Int</span> = <span class="number">42</span></span><br><span class="line"><span class="comment">// 这个函数负责打印,不需要返回值，因此返回一个Unit对象</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aFunctionWithSideEffects</span></span>(aString: <span class="type">String</span>): <span class="type">Unit</span> = println(aString)</span><br></pre></td></tr></table></figure>
<p>我们可以写一个递归函数：会连续打印n遍 aString。 在scala中，当我们需要写一个for/while循环的时候，我们需要写一个等价的递归函数。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aRepeatedFunction</span></span>(aString: <span class="type">String</span>, n: <span class="type">Int</span>): <span class="type">String</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) aString</span><br><span class="line">  <span class="keyword">else</span> aString + aRepeatedFunction(aString, n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(aRepeatedFunction(<span class="string">"hello"</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<p>我们也可以在一个函数里面写另外一个函数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aBigFunction</span></span>(n: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">aSmallerFunction</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Int</span> = a + b</span><br><span class="line">  aSmallerFunction(n, n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(aBigFunction(<span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise"></a>Exercise</h4><p>写一个函数，用来判断一个数是否为素数？</p>
<p>在其他语言中，我们可能会用一个for循环，每次循环都让n除以一个不大于其自身$\frac{1}{2}$ 的数(1除外)，如果都不能整除，就说明这个数是素数。</p>
<p>在Scala中，由于我们要用递归去代替循环，那么就只能这么写：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPrime</span></span>(n: <span class="type">Int</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isPrimeUntil</span></span>(t: <span class="type">Int</span>): <span class="type">Boolean</span> =</span><br><span class="line">    <span class="keyword">if</span> (t &lt;= <span class="number">1</span>) <span class="literal">true</span></span><br><span class="line">    <span class="keyword">else</span> n % t != <span class="number">0</span> &amp;&amp; isPrimeUntil(t<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">  isPrimeUntil(n / <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Type-Inference"><a href="#Type-Inference" class="headerlink" title="Type Inference"></a>Type Inference</h3><p>Scala有隐式的类型转换，比如说：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="number">2</span></span><br><span class="line"><span class="keyword">val</span> y = x + <span class="string">"items"</span></span><br></pre></td></tr></table></figure>
<p>此时，编译器认为一个Int+一个String还是String，因此y的类型就是一个String类型的常量。</p>
<p>但是，也存在编译器推测失灵的情况，主要发生在递归函数里面。我们看到，如果n&lt;=0，会返回1，此时编译器会认为函数的返回类型为诶Int，但是第二行，返回的值类型是Int乘以一个函数调用，这就把便一起搞混了，到底是不是返回Int呢？</p>
<p>因此，在创建函数的时候最好点名函数的返回类型，如果返回类型为空，那么就将类型置为Unit</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span></span>(n: <span class="type">Int</span>): <span class="type">Int</span> =</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span> n * factorial(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">println(factorial(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<h3 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h3><p>使用递归函数的时候，很容易出现一种情况：<strong>栈溢出</strong>。就拿连乘函数来说，<code>factorial(10)</code> 还可以跑，但是<code>factorial(5000)</code> 就会报错。</p>
<p>那么怎么避免这个问题？</p>
<p>要解决问题就需要找到问题为什么会发生,<code>if (n &lt;= 0) 1 else n * factorial(n-1)</code> 这句代码中，每调用一次factorial，就会占用一行栈空间。</p>
<p>如果n=5，那么这个递归的调用过程大致如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">factorial(<span class="number">5</span>)</span><br><span class="line"><span class="number">5</span> * factorial(<span class="number">4</span>)</span><br><span class="line"><span class="number">5</span> * (<span class="number">4</span> * factorial(<span class="number">3</span>))</span><br><span class="line"><span class="number">5</span> * (<span class="number">4</span> * (<span class="number">3</span> * factorial(<span class="number">2</span>)))</span><br><span class="line"><span class="number">5</span> * (<span class="number">4</span> * (<span class="number">3</span> * (<span class="number">2</span> * factorial(<span class="number">1</span>))))</span><br><span class="line"><span class="number">5</span> * (<span class="number">4</span> * (<span class="number">3</span> * (<span class="number">2</span> * <span class="number">1</span>)))</span><br></pre></td></tr></table></figure>
<p>为了解决这个问题，需要学习“尾递归”的概念。什么是尾递归？尾递归是指递归调用是函数的最后一个语句，而且其结果被直接返回，这是一类特殊的递归调用。 由于递归结果总是直接返回，尾递归比较方便转换为循环，因此编译器容易对它进行优化。</p>
<p>以上阶乘函数不是尾递归，因为递归调用的结果有一次额外的乘法计算，这导致每一次递归调用留在堆栈中的数据都必须保留。我们可以将它修改为尾递归的方式。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">anotherFactorial</span></span>(n: <span class="type">Int</span>): <span class="type">BigInt</span> = &#123;</span><br><span class="line">  <span class="meta">@tailrec</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">factHelper</span></span>(x: <span class="type">Int</span>, accumulator: <span class="type">BigInt</span>): <span class="type">BigInt</span> =</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) accumulator</span><br><span class="line">    <span class="keyword">else</span> factHelper(x - <span class="number">1</span>, x * accumulator) </span><br><span class="line">  <span class="comment">// TAIL RECURSION = use recursive call as the LAST expression</span></span><br><span class="line">  factHelper(n, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的调用，由于调用结果都是直接返回，所以之前的递归调用留在堆栈中的数据可以丢弃，只需要保留最后一次的数据，这就是尾递归容易优化的原因所在， 而它的秘密武器就是上面的acc，它是一个累加器（accumulator，习惯上翻译为累加器，其实不一定非是“加”，任何形式的积聚都可以），用来积累之前调用的结果，这样之前调用的数据就可以被丢弃了。</p>
<p>因此，当我们需要用循环的时候，就可以用到 Tail Recursion</p>
<p>比如说我要用tail recursion来写一个判断是否为素数的函数，在这里我们的accumulator是一个布尔值的变量，用来记录在当前情况下，n是否还为素数。如果布尔值为否，那么就返回false，如果t&lt;=1了，说除到2还是素数，说明n是真的素数，因此返回true。如果t还没到1，那么就递归调用IsPrimeUntil函数，将布尔值设定为 <code>n%t != 0</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">IsPrime</span></span>(n: <span class="type">Int</span>): <span class="type">Boolean</span> =&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@tailrec</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">IsPrimeUntil</span></span>( isPrimeNow:<span class="type">Boolean</span>, t:<span class="type">Int</span>):<span class="type">Boolean</span> =&#123;</span><br><span class="line">    <span class="keyword">if</span>(!isPrimeNow) <span class="literal">false</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t&lt;=<span class="number">1</span>) <span class="literal">true</span></span><br><span class="line">    <span class="keyword">else</span> <span class="type">IsPrimeUntil</span>(n%t!=<span class="number">0</span>,t<span class="number">-1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">IsPrimeUntil</span>( <span class="literal">true</span>,n/<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如我要写一个Fibonacci的递归函数，这个比较难一些。和一般的Fibonacci思维不同，如果使用tail recursion，是从底部想上去加，而且要有两个accumulator来记录$f(n-1),f(n-2)$的值</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span></span>(n: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">   <span class="meta">@tailrec</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">fiboTailrec</span></span>(i: <span class="type">Int</span>, last: <span class="type">Int</span>, nextToLast: <span class="type">Int</span>): <span class="type">Int</span> =</span><br><span class="line">     <span class="keyword">if</span>(i &gt;= n) last</span><br><span class="line">     <span class="keyword">else</span> fiboTailrec(i + <span class="number">1</span>, last + nextToLast, last)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="number">1</span></span><br><span class="line">   <span class="keyword">else</span> fiboTailrec(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> println(fibonacci(<span class="number">8</span>)) <span class="comment">// 1 1 2 3 5 8 13, 21</span></span><br></pre></td></tr></table></figure>
<h3 id="Call-by-Name-and-Call-by-Value"><a href="#Call-by-Name-and-Call-by-Value" class="headerlink" title="Call-by-Name and Call-by-Value"></a>Call-by-Name and Call-by-Value</h3><p>scala的call by name 和call by value最大的区别就是：</p>
<p><strong>call-by-name在调用的时候会重新根据name做计算，而call-by-value预先计算，然后保留计算值后一直使用这个value。</strong></p>
<p>比如说：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calledByValue</span></span>(x: <span class="type">Long</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  println(<span class="string">"by value: "</span> + x)</span><br><span class="line">  println(<span class="string">"by value: "</span> + x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意，call by name的话，需要用到的语法不同，还要加上 =&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calledByName</span></span>(x: =&gt; <span class="type">Long</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  println(<span class="string">"by name: "</span> + x)</span><br><span class="line">  println(<span class="string">"by name: "</span> + x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">calledByValue(<span class="type">System</span>.nanoTime())</span><br><span class="line">calledByName(<span class="type">System</span>.nanoTime())</span><br></pre></td></tr></table></figure>
<p>结果如下图所示，我们看到，call by name的话，每次都会计算x的值；而call by value的话，会预计算x的值</p>
<p><img src="/2022/04/28/scala%E5%88%9D%E8%AF%86/1.png"></p>
<p>同时call by name传入的表达式是<strong>lazy</strong> 的，也就是说，只有要用到这个参数的时候，才回去计算这个参数的值。</p>
<p>比如说：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">infinite</span></span>(): <span class="type">Int</span> = <span class="number">1</span> + infinite()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printFirst</span></span>(x: <span class="type">Int</span>, y: =&gt; <span class="type">Int</span>) = println(x)</span><br><span class="line"></span><br><span class="line">printFirst(infinite(), <span class="number">34</span>) <span class="comment">// stack overflow</span></span><br><span class="line">printFirst(<span class="number">34</span>, infinite())</span><br></pre></td></tr></table></figure>
<p>如上面这几行代码，我们定义了一个无限递归的函数infinite，如果调用infinite()必会导致stackoverflow</p>
<p>然后我们有定义了一个printFirst函数，第一个参数是call by value的，第二个是call by name的。</p>
<p>如果我们调用<code>printFirst(infinite(), 34)</code>，会报错，因为x是call by value的，需要预计算，那么丢会调用<code>infinite()</code>.导致栈溢出</p>
<p>但是如果我们调用<code>printFirst(34,infinite())</code>,就不会报错，因为y是call by name的，是<strong>lazy</strong> 的，若函数体内没有关于y的调用，就不会去计算y的值。因此不会报错。</p>
<p>当然，如果输入的都是数字的话，那么call by name和call by value就是一样的了</p>
<h3 id="Default-and-Named-Arguments"><a href="#Default-and-Named-Arguments" class="headerlink" title="Default and Named Arguments"></a>Default and Named Arguments</h3><p>在写下尾递归的时候，我们常常会选择两个函数嵌套的写法，这是因为我们不想让用户手动输入accumulator的值，函数嵌套可以实现对用户的透明机制。</p>
<p>那么可不可以既实现透明，又只写一层函数的方法呢？显然，我们可以用默认参数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trFact</span></span>(n: <span class="type">Int</span>, acc: <span class="type">Int</span> = <span class="number">1</span>): <span class="type">Int</span> =</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) acc</span><br><span class="line">  <span class="keyword">else</span> trFact(n<span class="number">-1</span>, n*acc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> fact10 = trFact(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>如果一个函数有多个默认参数的话，编译器会默认输入的第一个参数对应函数中第一个place holder，因此如果我们想让第一个参数默认，其他两个参数自己设置的话，就需要我们显式得设置参数的名字。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">savePicture</span></span>(format: <span class="type">String</span> = <span class="string">"jpg"</span>, width: <span class="type">Int</span> = <span class="number">1920</span>, height: <span class="type">Int</span> = <span class="number">1080</span>): <span class="type">Unit</span> = println(<span class="string">"saving picture"</span>)</span><br><span class="line"> savePicture(<span class="string">"jpg"</span>,<span class="number">800</span>,<span class="number">600</span>)<span class="comment">// 这是可以的</span></span><br><span class="line"> savePicture(height = <span class="number">600</span>, width = <span class="number">800</span>)<span class="comment">//这也是可以的</span></span><br><span class="line">savePicture(<span class="number">800</span>,<span class="number">600</span>)<span class="comment">//这就会报错</span></span><br></pre></td></tr></table></figure>
<h3 id="Smart-Operations-on-Strings"><a href="#Smart-Operations-on-Strings" class="headerlink" title="Smart Operations on Strings"></a>Smart Operations on Strings</h3><p>现在我们来介绍一些对于字符串的操作</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> str: <span class="type">String</span> = <span class="string">"Hello, I am learning Scala"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>输出指定位置的字符</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(str.charAt(<span class="number">2</span>)) <span class="comment">// l</span></span><br></pre></td></tr></table></figure>
<ul>
<li>节选字符串</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(str.substring(<span class="number">7</span>,<span class="number">11</span>))	<span class="comment">//I am</span></span><br><span class="line">println(str.take(<span class="number">2</span>)) <span class="comment">//He</span></span><br></pre></td></tr></table></figure>
<ul>
<li>切分字符串</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(str.split(<span class="string">" "</span>).toList) <span class="comment">//List(Hello,, I, am, learning, Scala)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>判断字符串是否从某字符串开始</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(str.startsWith(<span class="string">"Hello"</span>)) <span class="comment">//True</span></span><br></pre></td></tr></table></figure>
<ul>
<li>字符串替换</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(str.replace(<span class="string">" "</span>, <span class="string">"-"</span>)) <span class="comment">//Hello,-I-am-learning-Scala</span></span><br></pre></td></tr></table></figure>
<ul>
<li>小写化</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(str.toLowerCase()) <span class="comment">//hello, i am learning scala</span></span><br></pre></td></tr></table></figure>
<ul>
<li>字符串长度</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(str.length) <span class="comment">// 26</span></span><br></pre></td></tr></table></figure>
<ul>
<li>字符串反转</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(str.reverse) <span class="comment">// alacS gninrael ma I ,olleH</span></span><br></pre></td></tr></table></figure>
<ul>
<li>字符串转为数字</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aNumberString = <span class="string">"2"</span></span><br><span class="line"><span class="keyword">val</span> aNumber = aNumberString.toInt</span><br></pre></td></tr></table></figure>
<ul>
<li><p>字符串和数字拼接，需要用到特殊的拼接符号。</p>
<ul>
<li>+: 用于在list的头部添加元素</li>
<li>:+ 用于在list尾部追加元素; </li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println('a' +: aNumberString :+ 'z')</span><br></pre></td></tr></table></figure>
</li>
<li><p>S-插值器</p>
</li>
</ul>
<p>S-插值器的语法有点类似于CSS、PHP中的变量。也就是说，利用S-插值器可以往字符串中插入变量，比如说”</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name = <span class="string">"David"</span></span><br><span class="line"><span class="keyword">val</span> age = <span class="number">12</span></span><br><span class="line"><span class="keyword">val</span> greeting = <span class="string">s"Hello, my name is <span class="subst">$name</span> and I am <span class="subst">$age</span> years old"</span></span><br><span class="line"><span class="keyword">val</span> anotherGreeting = <span class="string">s"Hello, my name is <span class="subst">$name</span> and I will be turning <span class="subst">$&#123;age + 1&#125;</span> years old."</span></span><br><span class="line">println(anotherGreeting) <span class="comment">//Hello, my name is David and I will be turning 13 years old.</span></span><br></pre></td></tr></table></figure>
<ul>
<li>F-插值器</li>
</ul>
<p>F-插值器的作用是用来格式化的</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> speed = <span class="number">1.2</span>f</span><br><span class="line"><span class="keyword">val</span> myth = <span class="string">f"<span class="subst">$name</span> can eat <span class="subst">$speed</span>%2.2f burgers per minute"</span></span><br><span class="line">println(myth) <span class="comment">// David can eat 1.20 burgers per minute</span></span><br></pre></td></tr></table></figure>
<ul>
<li>raw-插值器</li>
</ul>
<p>raw插值器则是让字符串中的转义符失效 。 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> str2 = <span class="string">"a\nb"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> str3 = <span class="string">raw"a\nb"</span></span><br><span class="line"></span><br><span class="line">println(str2) <span class="comment">// \n 生效，a和b之间换行</span></span><br><span class="line"></span><br><span class="line">println(str3)	<span class="comment">// a\nb , \n失效</span></span><br></pre></td></tr></table></figure>
<p>但是我如果把string当做一个插入的参数打印，那么转义符就不会失效，比如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> escaped = <span class="string">"This is a \n newline"</span></span><br><span class="line">println(<span class="string">raw"<span class="subst">$escaped</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">This is a </span></span><br><span class="line"><span class="comment"> newline</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="Object-Oriented-Programming-in-Scala"><a href="#Object-Oriented-Programming-in-Scala" class="headerlink" title="Object Oriented Programming in Scala"></a>Object Oriented Programming in Scala</h2><h3 id="Object-Oriented-Basics"><a href="#Object-Oriented-Basics" class="headerlink" title="Object-Oriented Basics"></a>Object-Oriented Basics</h3><p>现在我们来创建一个最简单的类</p>
<p>我们首先从构造类的参数说起。这个Person类需要两个构造参数：name和age，其中，age用val来修饰，说明age变成了类中的一个成员，我们可以用<code>person.age</code>来访问；但是name只是一个参数，我们无法用<code>person.name</code> 来获取这个参数。</p>
<p>然后我们来看类中的body部分，这一部分类似于CodeBlock，一些逻辑会直接运行。如果在里面定义了常量或者定量，他们都会变成<strong>fields</strong>我们都可以通过点运算符对其进行访问</p>
<p>接着我们来看两个函数，函数名都是greet，因此会发生函数重载。第一个greet函数接收一个String类型的参数，并打印字符串，这个字符串里面如果需要引用这个传参，需要用<code>${this.name}</code> ，而不能单纯的用<code>$name</code></p>
<p>第二个函数没有任何输入参数，直接打印字符串，这里调用的参数是 <code>$name</code> ,是类里面的成员变量</p>
<p>和C++一样，scala也支持在类里面写多个构造函数，可以是没有参数的构造函数，也可以是有参数的</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, val age: <span class="type">Int</span> = 0</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body</span></span><br><span class="line">  <span class="keyword">val</span> x = <span class="number">2</span></span><br><span class="line">  println(<span class="number">1</span> + <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// method</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">greet</span></span>(name: <span class="type">String</span>): <span class="type">Unit</span> = println(<span class="string">s"<span class="subst">$&#123;this.name&#125;</span> says: Hi, <span class="subst">$name</span>"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// overloading</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">greet</span></span>(): <span class="type">Unit</span> = println(<span class="string">s"Hi, I am <span class="subst">$name</span>"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// multiple constructors</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(name: <span class="type">String</span>) = <span class="keyword">this</span>(name, <span class="number">0</span>) <span class="comment">//如果只有一个string参数的构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>() = <span class="keyword">this</span>(<span class="string">"John Doe"</span>)		<span class="comment">//如果没有参数，其构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> person = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"John"</span>, <span class="number">26</span>) <span class="comment">//在创建对象时就会打印 4</span></span><br><span class="line">  println(person.x)			 <span class="comment">// 2</span></span><br><span class="line">  person.greet(<span class="string">"Daniel"</span>) <span class="comment">//John says: Hi, Daniel</span></span><br><span class="line">  person.greet() 				 <span class="comment">//Hi, I am John</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">val</span> person2 = <span class="keyword">new</span> <span class="type">Person</span>()</span><br><span class="line">  person2.greet()					<span class="comment">//Hi, I am John Doe</span></span><br></pre></td></tr></table></figure>
<h4 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise"></a>Exercise</h4><ol>
<li><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Novel and a Writer</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Writer: first name, surname, year(出生年)</span></span><br><span class="line"><span class="comment">    - method fullname 返回全名</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Novel: name, year of release, author</span></span><br><span class="line"><span class="comment">  - authorAge 返回作者的年龄</span></span><br><span class="line"><span class="comment">  - isWrittenBy(author) 返回作者对象</span></span><br><span class="line"><span class="comment">  - copy (new year of release) = new instance of Novel 返回一个新实例</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Writer</span>(<span class="params">firstName: <span class="type">String</span>, surname: <span class="type">String</span>, val year: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fullName</span></span>: <span class="type">String</span> = firstName + <span class="string">" "</span> + surname</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Novel</span>(<span class="params">name: <span class="type">String</span>, year: <span class="type">Int</span>, author: <span class="type">Writer</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">authorAge</span> </span>= year - author.year</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isWrittenBy</span></span>(author: <span class="type">Writer</span>) = author == <span class="keyword">this</span>.author</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">copy</span></span>(newYear: <span class="type">Int</span>): <span class="type">Novel</span> = <span class="keyword">new</span> <span class="type">Novel</span>(name, newYear, author)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Counter class</span></span><br><span class="line"><span class="comment">    - receives an int value</span></span><br><span class="line"><span class="comment">    - method current count </span></span><br><span class="line"><span class="comment">    // 需要实现两个方法，一个增1，一个减1</span></span><br><span class="line"><span class="comment">    - method to increment/decrement =&gt; new Counter</span></span><br><span class="line"><span class="comment">    // 还要实现函数重载，输入一个n，要增加n次</span></span><br><span class="line"><span class="comment">    - overload inc/dec to receive an amount</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span>(<span class="params">val count: <span class="type">Int</span> = 0</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inc</span> </span>= &#123;</span><br><span class="line">    println(<span class="string">"incrementing"</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Counter</span>(count + <span class="number">1</span>)  <span class="comment">// immutability</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//	def dec():Counter =&#123;&#125;</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dec</span> </span>= &#123;</span><br><span class="line">    println(<span class="string">"decrementing"</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Counter</span>(count - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 这是一个递归函数，但是不是下尾递归</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inc</span></span>(n: <span class="type">Int</span>): <span class="type">Counter</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">else</span> inc.inc(n<span class="number">-1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">dec</span></span>(n: <span class="type">Int</span>): <span class="type">Counter</span> =</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">else</span> dec.dec(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">print</span> </span>= println(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于函数返回一个Counter，所以可以在调用inc之后继续调用inc，如果调用了三次，那么会让count+3 = 3</p>
<p>但是如果重新调用inc，那么之前的inc并不会累加，对于counter来说，其count值始终为零。 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">调用: counter.inc.print</span><br><span class="line">incrementing</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line">调用: counter.inc.inc.inc.print</span><br><span class="line">incrementing</span><br><span class="line">incrementing</span><br><span class="line">incrementing</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">调用: counter.inc(<span class="number">10</span>).print</span><br><span class="line">incrementing</span><br><span class="line">incrementing</span><br><span class="line">incrementing</span><br><span class="line">incrementing</span><br><span class="line">incrementing</span><br><span class="line">incrementing</span><br><span class="line">incrementing</span><br><span class="line">incrementing</span><br><span class="line">incrementing</span><br><span class="line">incrementing</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<h3 id="Syntactic-Sugar-Method-Notations"><a href="#Syntactic-Sugar-Method-Notations" class="headerlink" title="Syntactic Sugar: Method Notations"></a>Syntactic Sugar: Method Notations</h3><p>现在来介绍一些语法糖。scala是一个很”自然语言化”的语言，里面有很多特殊的语法，我觉得很像是C++中的运算符重载。</p>
<ul>
<li>infix notation/ operator notation ，这种语法只适用于<strong>只有一个参数的函数</strong>中 。 在scala中，我们要理解一个概念：所有的操作符，同时也是一个函数。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val name: <span class="type">String</span>, favoriteMovie: <span class="type">String</span>,val age: <span class="type">Int</span> = 0</span>)</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">likes</span></span>(movie:<span class="type">String</span>): <span class="type">Boolean</span> = movie == favourite</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hangOutWith</span></span>(person: <span class="type">Person</span>): <span class="type">String</span> = <span class="string">s"<span class="subst">$&#123;this.name&#125;</span> is hanging out with <span class="subst">$&#123;person.name&#125;</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> mary = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"Mary"</span>,<span class="string">"Inception"</span>)</span><br><span class="line"><span class="keyword">val</span> tom - <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"Tom"</span>,<span class="string">"Fight Club"</span>)</span><br></pre></td></tr></table></figure>
<p>我们要调用Person中的likes函数,正常的写法如下：<code>mary.likes(&quot;Inception&quot;)</code></p>
<p>但我们可以直接这样写： <code>mary likes &quot;Inception&quot;</code>， 也就是将其他特殊符号全部略去，只留下最重要的三个部分。又比如说，可以直接写  <code>mary hangOutWith tom</code></p>
<p>甚至我可以重命名hangOutWith函数为 <code>def +(person: Person): String = s&quot;${this.name} is hanging out with ${person.name}&quot;</code>， 那么就可以这么写： <code>mary + tom</code></p>
<p>而<code>+</code> 和<code>.+</code> 是相等的，所以我们还可以这么写： <code>mary.+(tom)</code></p>
<ul>
<li>prefix notation，主要是 <code>unary_</code> 前缀，它只<strong>适用于单目运算符</strong><code>-,+,~,!</code> </li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = <span class="number">-1</span>  <span class="comment">// equivalent with 1.unary_-</span></span><br><span class="line"><span class="keyword">val</span> y = <span class="number">1.</span>unary_- <span class="comment">// x和y是相等的</span></span><br></pre></td></tr></table></figure>
<p>同样的，我们也可以在Person类中定义 名为<code>unary_!</code>的函数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val name: <span class="type">String</span>, favoriteMovie: <span class="type">String</span>,val age: <span class="type">Int</span> = 0</span>)</span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">unary_!</span> </span>: <span class="type">String</span> = <span class="string">s"<span class="subst">$name</span>, what the heck?!"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unary_+</span> </span>: <span class="type">Person</span> = <span class="keyword">new</span> <span class="type">Person</span>(name, favoriteMovie, age + <span class="number">1</span>)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面两个表达式是等价的 打印值： Hi, my name is Mary and I like Inception</span></span><br><span class="line">println(!mary)				</span><br><span class="line">println(mary.unary_!)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面两个表达式也是等价的，打印值： 1</span></span><br><span class="line">println(+mary.age)</span><br><span class="line">println(mary.unary_+.age)</span><br></pre></td></tr></table></figure>
<ul>
<li>Postfix notation 适用于<strong>没有任何参数的函数</strong></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val name: <span class="type">String</span>, favoriteMovie: <span class="type">String</span>, val age: <span class="type">Int</span> = 0</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isAlive</span></span>: <span class="type">Boolean</span> = <span class="literal">true</span> <span class="comment">//直接返回true</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(): <span class="type">String</span> = <span class="string">s"Hi, my name is <span class="subst">$name</span> and I like <span class="subst">$favoriteMovie</span>"</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(n: <span class="type">Int</span>): <span class="type">String</span> = <span class="string">s"<span class="subst">$name</span> watched <span class="subst">$favoriteMovie</span> <span class="subst">$n</span> times"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.language.postfixOps</span><br><span class="line"></span><br><span class="line">println(mary.isAlive)</span><br><span class="line"><span class="comment">//用这种写法也可以，只不过需要导入一个包，不建议使用</span></span><br><span class="line">println(mary isAlive)</span><br></pre></td></tr></table></figure>
<ul>
<li>apply () 函数</li>
</ul>
<p>当我们直接在一个对象后面加上<code>()</code>,编译器就会自动调用该类中的apply函数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val name: <span class="type">String</span>, favoriteMovie: <span class="type">String</span>, val age: <span class="type">Int</span> = 0</span>) </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(): <span class="type">String</span> = <span class="string">s"Hi, my name is <span class="subst">$name</span> and I like <span class="subst">$favoriteMovie</span>"</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(n: <span class="type">Int</span>): <span class="type">String</span> = <span class="string">s"<span class="subst">$name</span> watched <span class="subst">$favoriteMovie</span> <span class="subst">$n</span> times"</span></span><br><span class="line">&#125;</span><br><span class="line">println(mary.apply())</span><br><span class="line">println(mary()) <span class="comment">// equivalent</span></span><br></pre></td></tr></table></figure>
<h4 id="Method-Notations-Exercises"><a href="#Method-Notations-Exercises" class="headerlink" title="Method Notations (Exercises)"></a>Method Notations (Exercises)</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  1.  Overload the + operator</span></span><br><span class="line"><span class="comment">      mary + "the rockstar" =&gt; new person "Mary (the rockstar)"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">+</span></span>(nickname:<span class="type">String</span>) = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">s"name(<span class="subst">$nickname</span>)"</span>,favoriteMovie)</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  2.  Add an age to the Person class</span></span><br><span class="line"><span class="comment">      Add a unary + operator =&gt; new person with the age + 1</span></span><br><span class="line"><span class="comment">      +mary =&gt; mary with the age incrementer</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unary_+</span> </span>: <span class="type">Person</span> = <span class="keyword">new</span> <span class="type">Person</span>(name,favoriteMovie,age+<span class="number">1</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  3.  Add a "learns" method in the Person class =&gt; "Mary learns Scala"</span></span><br><span class="line"><span class="comment">      Add a learnsScala method, calls learns method with "Scala".</span></span><br><span class="line"><span class="comment">      Use it in postfix notation.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">learns</span></span>(lessons:<span class="type">String</span>) = <span class="string">s"<span class="subst">$name</span> learns <span class="subst">$lessons</span>"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">learnScala</span> </span>= <span class="keyword">this</span> learns <span class="string">"Scala"</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  4.  Overload the apply method</span></span><br><span class="line"><span class="comment">      mary.apply(2) =&gt; "Mary watched Inception 2 times"</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(n: <span class="type">Int</span>): <span class="type">String</span> = <span class="string">s"<span class="subst">$name</span> watched <span class="subst">$favoriteMovie</span> <span class="subst">$n</span> times"</span></span><br></pre></td></tr></table></figure>
<h3 id="Scala-Objects"><a href="#Scala-Objects" class="headerlink" title="Scala Objects"></a>Scala Objects</h3><p>Scala既然可以当做面向对象的语言来写，那么就必须具备面向对象语言的特征。那么其中一个特征就是：类内静态方法、静态成员变量。静态方法我们在Java中学过，就是只能被类调用，而不能被实例调用。比如说：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    public static <span class="keyword">final</span> int <span class="type">N_EYES</span> = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么在scala中，如何实现类内静态成员呢？ 答案就是Object</p>
<p>比如我创建一个名为Person的Object，里面的所有成员都是静态的，如果要调用，只能这样来写<code>Person.N_EYES</code>,<code>Person.canFlay</code>, <code>Person.apply</code> </p>
<p>此外，Object只有唯一一个实例，就是他自己，如果我令 <code>mary = Person(&quot;Mary&quot;)</code> ，又令 <code>john = Person(&quot;John&quot;)</code> 。那么事实上，mary和john是相等的，它们都是同一个实例。 专业一点叫做singleton instance</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123; <span class="comment">// type + its only instance</span></span><br><span class="line">  <span class="comment">// "static"/"class" - level functionality</span></span><br><span class="line">  <span class="keyword">val</span> <span class="type">N_EYES</span> = <span class="number">2</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">canFly</span></span>: <span class="type">Boolean</span> = <span class="literal">false</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> mary = <span class="type">Person</span></span><br><span class="line">    <span class="keyword">val</span> john = <span class="type">Person</span></span><br><span class="line">    println(mary == john) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>那么如果要创建一个实例的的话，就需要另外创建一个<code>class Person</code>, 这里object 和 class后面的名字必须相同。可以这么说，<strong>Scala中的Object和Class共同构成了Java中的类</strong>。</p>
<p>如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123; <span class="comment">// type + its only instance</span></span><br><span class="line">  <span class="comment">// "static"/"class" - level functionality</span></span><br><span class="line">  <span class="keyword">val</span> <span class="type">N_EYES</span> = <span class="number">2</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">canFly</span></span>: <span class="type">Boolean</span> = <span class="literal">false</span></span><br><span class="line">	<span class="comment">// 静态方法，只能通过Person.apply调用</span></span><br><span class="line">  <span class="comment">// factory method</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(mother: <span class="type">Person</span>, father: <span class="type">Person</span>): <span class="type">Person</span> = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"Bobbie"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val name: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// instance-level functionality</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意，如果既写了 object，又写了 class. 那么如果我们用new的话，一定是新建一个实例。</span></span><br><span class="line"><span class="keyword">val</span> mary = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"Mary"</span>) <span class="comment">// 新实例 mary</span></span><br><span class="line"><span class="keyword">val</span> john = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"John"</span>) <span class="comment">// 新实例 John</span></span><br><span class="line">println(mary == john)					<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如果我想调用类内静态方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> bobbie = <span class="type">Person</span>(mary,john)</span><br></pre></td></tr></table></figure>
<p>最后，我们来说为什么我们现在都用<code>object xxx extends App</code> 来运行scala文件：</p>
<p>在Java中，要使程序能够运行，需要有一个main函数，如下所示：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123; </span><br><span class="line">    public static void main(<span class="type">String</span>[] args) &#123; </span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于scala到最后也是需要放到JVM上去运行的，因此也需要有一个main函数。scala中的main函数如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span></span><br></pre></td></tr></table></figure>
<p>但是如果我们用 <code>object xxx extends App</code> ，那么就会继承 App中的main函数，我们就不用每次都写了。</p>
<h3 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h3><p>既然上面提到了 继承，现在我们就来说说scala中的继承是怎么回事。</p>
<p>scala的继承以及一些关键字基本和Java中的类似。</p>
<h4 id="单类继承"><a href="#单类继承" class="headerlink" title="单类继承"></a>单类继承</h4><p>一个基本的单类继承如下：我创建了一个Animal类，然后有创建了一个Cat类去继承Animal，此时在Cat类中就可以继承Animal中的成员了。</p>
<p>成员默认是<strong>public</strong>,子类和外部都可以调用</p>
<p>如果成员被<strong>private</strong>修饰，那么其子类就无法调用和外部就无法调用</p>
<p>如果成员被<strong>protected</strong>修饰，那么其子类内部可以调用，但外部无法调用(实例调用)</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> creatureType = <span class="string">"wild"</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eat</span> </span>= println(<span class="string">"nomnom"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">crunch</span> </span>= &#123;</span><br><span class="line">    eat</span><br><span class="line">    println(<span class="string">"crunch crunch"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> cat = <span class="keyword">new</span> <span class="type">Cat</span></span><br><span class="line">cat.crunch</span><br></pre></td></tr></table></figure>
<p>那么如果父类和子类的参数不同，该如何写继承语法？</p>
<p>比如说，Person有两个参数，Adult有三个参数，如果我们还是直接 <code>extends Person</code> ,编译器会报错。因此这样如果新建一个Adult实例的话，Adult事实上会调用Person中的构造函数，而Person中的构造函数只接受两个参数。因此，对于子类和父类参数不同的情况下，在继承时就要调用父类的构造函数，如下</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(name: <span class="type">String</span>) = <span class="keyword">this</span>(name, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adult</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span>, idCard: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Person</span>(<span class="params">name</span>)<span class="title">//Person</span>(<span class="params">name,age</span>) <span class="title">这里父类有两个构造函数，因此传入一个或者两个都可</span></span></span><br><span class="line"><span class="class"><span class="title">/*</span></span></span><br><span class="line"><span class="class"><span class="title">当然，如果父类中有这样的</span>  <span class="title">def</span> <span class="title">this</span>(<span class="params"></span>) </span>= <span class="keyword">this</span>(<span class="string">"112"</span>,<span class="number">0</span>)构造函数</span><br><span class="line">那么子类也可以直接 <span class="keyword">extends</span> <span class="type">Person</span></span><br><span class="line"></span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h4 id="函数重写"><a href="#函数重写" class="headerlink" title="函数重写"></a>函数重写</h4><p>在子类 可以重写父类中的函数和成员变量，需要使用override关键词。</p>
<p>当然，如果重写的是父类中的成员变量，可以放在子类的构造函数中，比如：<code>Dog(override val creatureType: String)</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">override val creatureType: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//override val creatureType = "domestic" // can override in the body or directly in the constructor arguments</span></span><br><span class="line">  	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">eat</span> </span>= &#123; </span><br><span class="line">    println(<span class="string">"crunch, crunch"</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>如果想要在重写的函数中仍然运行父类中的代码，可以使用<code>super</code>，super就代表父类，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Dog(override val creatureType: String) extends Animal &#123;</span><br><span class="line">  	override def eat &#x3D; &#123; </span><br><span class="line">  	super.eat</span><br><span class="line">    println(&quot;crunch, crunch&quot;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>事实上我们要尽量避免函数继承，因为会很乱。这里提供了一些办法来避免函数的重载：</p>
<ul>
<li>对成员变量、成员函数使用 final 关键词修饰，就可以避免被重写</li>
<li>对类用final关键词修饰，就可以避免该类被继承</li>
<li>新语法：使用seal关键词，如果用seal来修饰类，那么<strong>仅在此文件中可以继承该类</strong>，但是其他文件中无法继承该类</li>
</ul>
<h3 id="Inheritance-Continued-Abstract-Classes-and-Traits"><a href="#Inheritance-Continued-Abstract-Classes-and-Traits" class="headerlink" title="Inheritance, Continued:  Abstract Classes and Traits"></a>Inheritance, Continued:  Abstract Classes and Traits</h3><h4 id="Abstract-class"><a href="#Abstract-class" class="headerlink" title="Abstract  class"></a>Abstract  class</h4><ul>
<li>抽象类的一个或者多个方法没有完整的定义</li>
<li>声明抽象方法不需要加abstract关键字，<strong>只需要不写方法体</strong>，如<code>def eat: Unit</code></li>
<li>子类重写父类的抽象方法时<strong>不需要</strong>加override</li>
<li>父类可以声明抽象字段（没有初始值的字段）</li>
<li>子类重写父类的抽象字段时不需要加override</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> creatureType: <span class="type">String</span> = <span class="string">"wild"</span> <span class="comment">// 非抽象字段</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>: <span class="type">Unit</span> <span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> creatureType: <span class="type">String</span> = <span class="string">"Canine"</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>: <span class="type">Unit</span> = println(<span class="string">"crunch crunch"</span>) <span class="comment">//重写父类抽象方法时不需要加override </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Traits"><a href="#Traits" class="headerlink" title="Traits"></a>Traits</h4><p>类似于Java中的接口，trait被用于通过所支持的方法特例化来定义对象。如Java 8中一样，<a href="https://so.csdn.net/so/search?q=Scala&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">Scala</a>允许trait被部分实现。其有以下特征：</p>
<ul>
<li>Abstract class和Traits 可以<strong>同时有抽象成员和非抽象成员</strong> </li>
<li>但是和class相比，trait 没有构造函数. </li>
<li>一个类只能继承一个抽象类，但可以混合多个traits。 比如说下面的Crocodile，继承了Animal，同时继承了两个traits: Carnivore和ColdBlooded</li>
<li>一般 抽象类是描述一种物体的，而一个traits 是用来描述该物体的行为的</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Carnivore</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>(animal: <span class="type">Animal</span>): <span class="type">Unit</span></span><br><span class="line">  <span class="keyword">val</span> preferredMeal: <span class="type">String</span> = <span class="string">"fresh meat"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ColdBlooded</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Crocodile</span> <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">with</span> <span class="title">Carnivore</span> <span class="keyword">with</span> <span class="title">ColdBlooded</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> creatureType: <span class="type">String</span> = <span class="string">"croc"</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>: <span class="type">Unit</span> = println(<span class="string">"nomnomnom"</span>) <span class="comment">//重写抽象类中的抽象方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>(animal: <span class="type">Animal</span>): <span class="type">Unit</span> = println(<span class="string">s"I'm a croc and I'm eating <span class="subst">$&#123;animal.creatureType&#125;</span>"</span>)<span class="comment">//重写traits中的抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Type-Hierarchy"><a href="#Type-Hierarchy" class="headerlink" title="Type Hierarchy"></a>Type Hierarchy</h4><p>最后提一嘴Scala中的类型结构，首先，所有类型都是继承自 <code>scala.Any</code> , 这就类似于JavaScript中的Object类， Any是整个Scala类型系统的<strong>超类</strong>。 </p>
<p><code>scala.Any</code>下面分为两个类： <code>scala.AnyVal</code>  和 <code>scala.AnyRef</code> 。</p>
<ul>
<li><code>scala.AnyVal</code>类中，主要是Int，Unit，Boolean，Float这几个数值类</li>
<li><code>scala.AnyRef</code>类中，主要是String，List, Set 这几个引用类型</li>
<li><code>scala.Noting</code>类是一切类的<strong>子类</strong>，包括我们自己创建的类</li>
</ul>
<p><img src="/2022/04/28/scala%E5%88%9D%E8%AF%86/2.jpeg"></p>
<h3 id="Inheritance-Exercises-Implementing-Our-Own-Collection"><a href="#Inheritance-Exercises-Implementing-Our-Own-Collection" class="headerlink" title="Inheritance Exercises Implementing Our Own Collection"></a>Inheritance Exercises Implementing Our Own Collection</h3><p>现在我们要实现一个Int类型的链表，链表要实现这样几个功能：</p>
<ul>
<li><code>head</code>：返回链表头部</li>
<li><code>def tail</code>: 返回除了链表头部以外的剩余部分</li>
<li><code>def isEmpty</code>: 返回链表是否为空</li>
<li><code>def add(int)</code>: 往链表中添加元素</li>
<li><code>def toString</code>: 可以打印链表中的元素</li>
</ul>
<p>根据上述要求我们写一个抽象类如下：我们要用函数式编程的思路去设计这个列表。所以添加一各元素，需要返回一个新的对象。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyList</span> </span>&#123;  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">head</span></span>: <span class="type">Int</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tail</span></span>: <span class="type">MyList</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>: <span class="type">Boolean</span></span><br><span class="line"> 	<span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(element:<span class="type">Int</span>): <span class="type">MyList</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printElements</span></span>: <span class="type">String</span></span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>: <span class="type">String</span> = <span class="string">"["</span>+printElements+<span class="string">"]"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们要实现这个列表：由于一开始新建链表的时候，肯定需要一个空链表，因此我们要创建一个Empty的对象。这里Object没必要用class, 因为我们没有创建一个Empty实例然后去调用其内部方法的需求和必要。</p>
<p>然后创建 一个Cons类，同样继承MyList，这个类需要传入两个参数，链表的头部和其他部分。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Empty</span> <span class="keyword">extends</span> <span class="title">MyList</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">head</span></span>: <span class="type">Int</span> = <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchElementException</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tail</span></span>: <span class="type">MyList</span> = <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchElementException</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(element : <span class="type">Int</span>): <span class="type">MyList</span> = <span class="keyword">new</span> <span class="type">Cons</span>(element,<span class="type">Empty</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printElements</span></span>: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cons</span>(<span class="params">head:<span class="type">Int</span>,tail:<span class="type">MyList</span></span>) <span class="keyword">extends</span> <span class="title">MyList</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">head</span></span>: <span class="type">Int</span> = head;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tail</span></span>: <span class="type">MyList</span> = tail;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>: <span class="type">Boolean</span> = <span class="literal">false</span>; </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(element:<span class="type">Int</span>):<span class="type">MyList</span> = <span class="keyword">new</span> <span class="type">Cons</span>(element,<span class="keyword">this</span>)</span><br><span class="line">  <span class="comment">//这是一个递归，每次只打印一个节点的头部</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printElements</span></span>: <span class="type">String</span> = </span><br><span class="line">  	<span class="keyword">if</span> (t.isEmpty)<span class="string">""</span>+h</span><br><span class="line">  	<span class="keyword">else</span> h+<span class="string">" "</span>+t.printElements </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">1</span>,<span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">3</span>,<span class="type">Empty</span>))) <span class="comment">// 1,2,3</span></span><br><span class="line">println(list.tail.head)			<span class="comment">// 2</span></span><br><span class="line">println(list.add(<span class="number">4</span>).head)   <span class="comment">// 4</span></span><br><span class="line">println(list.isEmpty)       <span class="comment">// false</span></span><br><span class="line">println(list.toString) 			<span class="comment">// [1 2 3]</span></span><br></pre></td></tr></table></figure>
<h3 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h3><p>现在来谈谈scala中的泛型类，这一块比较难</p>
<p>泛型类使用中括号 <code>[]</code> 接收类型参数，虽然类型参数可以是任何名字，但是一个惯例是使用字母 <code>A</code> 作为类型参数标识符。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如说我定义一个MyList的泛型类：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">	<span class="comment">// use the type A</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型类不一定只有一个参数,比如说我创建一个映射类，Key可以使一个数据类型，Value则可是另一种数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMap</span>[<span class="type">Key</span>,<span class="type">Value</span>]</span></span><br></pre></td></tr></table></figure>
<p>这个MyList泛型类使用A作为类型参数。这意味着这个 MyList[A] 只能存储类型为A的元素。因此，我可以创建一个字符串类型的列表，一个整数类型的列表：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> listOfIntegers = <span class="keyword">new</span> <span class="type">MyList</span>[<span class="type">Int</span>]</span><br><span class="line"><span class="keyword">val</span> listOfStrings = <span class="keyword">new</span> <span class="type">MyList</span>[<span class="type">String</span>]</span><br></pre></td></tr></table></figure></p>
<p> 然后我们来说说泛型方法：泛型方法就是接收了泛型参数的方法，如下</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generic methods</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MyList</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">empty</span></span>[<span class="type">A</span>]: <span class="type">MyList</span>[<span class="type">A</span>] = ??? <span class="comment">//这是一个静态方法，返回MyList[A]</span></span><br><span class="line">  <span class="comment">// ??? 是TODO的意思，这里只讲语法，因此不表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//比如我要创建一个空的存放整数类型的list，可以这样写：</span></span><br><span class="line"><span class="keyword">val</span> emptyListOfIntegers = <span class="type">MyList</span>.empty[<span class="type">Int</span>]</span><br></pre></td></tr></table></figure>
<h4 id="variance-problem"><a href="#variance-problem" class="headerlink" title="variance problem"></a>variance problem</h4><p>现在我们来讨论一下泛型中多样化的问题</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span></span><br></pre></td></tr></table></figure>
<p>我们来看，Cat是Animal的子类，Dog也是Animal的子类，那么，<code>MyList[Cat]</code>是不是<code>MyList[Animal]</code>的子类</p>
<p>我们有三种推测</p>
<ul>
<li><code>MyList[Cat]</code>是 <code>MyList[Animal]</code>的子类, 即  <code>List[Cat] extends List[Animal]</code>，二者 Covariance(协变)</li>
<li><code>MyList[Cat]</code>不是<code>MyList[Animal]</code>的子类，即 二者 Invariance(不可变)</li>
<li><code>MyList[Cat]</code>反而要比<code>MyList[Animal]</code>更高一级，是<code>MyList[Animal]</code>的父类，即二者 Contravariance(逆变)</li>
</ul>
<p>在scala中，这三种方法其实都可以实现，但是需要不同的符号：用加号表示为协变，减号表示逆变，如: </p>
<ul>
<li><p>Convariance : 参数类型前面需要有一个<code>+</code> 。如果是类型是协变的，那么我们可以用一个<code>ConvarianceList[Cat]</code> 去替换<code>ConvariantList[Animal]</code> ，说明Cat是Animal的子集</p>
<p><strong>那么这时候其实出了一个大问题</strong>：我们能不能加其他类型的动物进去？<code>animalList.add(new Dog)</code>合法吗？按照道理来说，Dog属于Animal，添加到animalList中是没有逻辑上的问题的，但是显然会污染一个cat类型的animallist。 如果我们要创建一个convariant的类，就必须解决这个问题——我们学完bounded types就知道了。</p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConvarianceList</span>[+<span class="type">A</span>]</span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">animal</span> </span>: <span class="type">Animal</span> = <span class="keyword">new</span> <span class="type">Cat</span></span><br><span class="line"><span class="keyword">val</span> animalList: <span class="type">ConvariantList</span>[<span class="type">Animal</span>] = <span class="keyword">new</span> <span class="type">ConvarianceList</span>[<span class="type">Cat</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>Invariance ：在scala中，什么符号都不加就是Invariance。在这种情况下，<code>InvariantList[Animal]</code> 只能对应 Animal类型</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invariant</span>[<span class="type">A</span>]</span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">invariantAnimalList</span></span>: <span class="type">InvariantList</span>[<span class="type">Animal</span>] = <span class="keyword">new</span> <span class="type">InvariantList</span>[<span class="type">Animal</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Contravariance: 参数类型前面需要有一个<code>-</code>， 这是最难以理解的，特别是如果我们还以列表为例的话——那么只能写成<code>InvariantList[cat] = new InvariantList[Animal]</code>，我们用Animal可以去替换Cat，说明Animal是Cat的一个子类<strong>，语法上没问题但是逻辑上有问题</strong>。为了方便理解，我们可以重新设计一个类Trainer</p>
<p>这样的话，<strong>一个动物训练师当然可以替换一个猫咪训练师，因为动物训练师可以训练所有动物</strong>，也包括猫。从这个角度上来看 逆变关系比较好理解。<strong>但是从动物训练师是猫咪训练师的一个子类来理解，就比较奇怪了。</strong></p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">contravariantTrainer</span>[-<span class="type">A</span>]</span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">contravariantTrainer</span>[cat] </span>= <span class="keyword">new</span> contravariantTrainer[<span class="type">Animal</span>]</span><br></pre></td></tr></table></figure>
<h4 id="bounded-types"><a href="#bounded-types" class="headerlink" title="bounded types"></a>bounded types</h4><p>在Scala中，类型界限是对类型参数或类型变量的限制。 通过使用类型边界，我们可以定义类型变量的限制。</p>
<ul>
<li>上界：这里<strong>T是类型参数</strong>，而<strong>S是类型</strong>。 通过将“上界”声明为“ <strong>[T &lt;：S]</strong> ”，表示此类型<strong>参数T必须与S相同或S的子类型</strong>。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里，我们要求Cage中的输入参数必须是Animal的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cage</span>[<span class="type">A</span> &lt;: <span class="type">Animal</span>](<span class="params">animal: <span class="type">A</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">因此，我们将Dog作为参数是合法的</span></span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">cage</span> </span>= <span class="keyword">new</span> <span class="type">Cage</span>(<span class="keyword">new</span> <span class="type">Dog</span>)</span><br></pre></td></tr></table></figure>
<p>我们看到，如果是另外一个不是animal的子类，我们就没有办法将其放到Cage里面，因为Cage有类型限制</p>
<p><img src="/2022/04/28/scala%E5%88%9D%E8%AF%86/3.png"></p>
<ul>
<li>下界：这里<strong>T是类型参数，而S是类型</strong>。 通过将“下界”声明为“ <strong>[T&gt;：S]</strong> ”，表示此类型<strong>参数T必须与S相同或为S的超类型</strong>。</li>
</ul>
<p>现在我们可以解决上面那个可不可以把Dog插入 <code>List[Cat]</code>的难题了,解决方法就是，如果我往一个List[Cat]里面插入Dog，就会返回一个 <code>List[Animal]</code> ，也就是说把类型更泛化一个级别</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>[+<span class="type">A</span>] </span>&#123; </span><br><span class="line">  <span class="comment">//要实现以上功能，我们可以用到下界符号，当与A同类型或者超类要加入到MyList[A]中，就会返回MyList[B]</span></span><br><span class="line">  <span class="comment">//那么如果添加一个Dog，就会返回一个MyList[Animal]</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(<span class="type">B</span> &gt;:<span class="type">A</span>)(element:<span class="type">B</span>): <span class="type">MyList</span>[<span class="type">B</span>] = ???</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们对之前写的MyList进行修改：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyList</span>[+<span class="type">A</span>] </span>&#123; <span class="comment">//将MyList改为泛型抽象类</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">head</span></span>: <span class="type">A</span>								<span class="comment">//返回的参数从Int改为A</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tail</span></span>: <span class="type">MyList</span>[<span class="type">A</span>]				<span class="comment">//同理，返回类型为A的MyList</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>: <span class="type">Boolean</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>[<span class="type">B</span> &gt;: <span class="type">A</span>](element: <span class="type">B</span>): <span class="type">MyList</span>[<span class="type">B</span>] <span class="comment">//在add设置下界</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printElements</span></span>: <span class="type">String</span></span><br><span class="line">  <span class="comment">// polymorphic call</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>: <span class="type">String</span> = <span class="string">"["</span> + printElements + <span class="string">"]"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//由于这里返回的是一个Exception,而Empty里面没有任何类型的数据，因此将Empty对象继承自MyList[Nothing]</span></span><br><span class="line"><span class="comment">//因为Nothing是任何类的子类，因此可以用Nothing来替换之前的Int</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Empty</span> <span class="keyword">extends</span> <span class="title">MyList</span>[<span class="type">Nothing</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">head</span></span>: <span class="type">Nothing</span> = <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchElementException</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tail</span></span>: <span class="type">MyList</span>[<span class="type">Nothing</span>] = <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchElementException</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line">  <span class="comment">//这里也要将函数改为下界，B &gt;: Nothing，返回一个MyList[B]</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>[<span class="type">B</span> &gt;: <span class="type">Nothing</span>](element: <span class="type">B</span>): <span class="type">MyList</span>[<span class="type">B</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(element, <span class="type">Empty</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printElements</span></span>: <span class="type">String</span> = <span class="string">""</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cons</span>[+<span class="type">A</span>](<span class="params">head: <span class="type">A</span>, tail: <span class="type">MyList</span>[<span class="type">A</span>]</span>) <span class="keyword">extends</span> <span class="title">MyList</span>[<span class="type">A</span>] <span class="title">/*注意这里只能是</span>[<span class="type">A</span>],<span class="title">不能是</span>[+<span class="type">A</span>]<span class="title">*/</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">head</span></span>: <span class="type">A</span> = h</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tail</span></span>: <span class="type">MyList</span>[<span class="type">A</span>] = t</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>: <span class="type">Boolean</span> = <span class="literal">false</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>[<span class="type">B</span> &gt;: <span class="type">A</span>](element: <span class="type">B</span>): <span class="type">MyList</span>[<span class="type">B</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(element, <span class="keyword">this</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printElements</span></span>: <span class="type">String</span> =</span><br><span class="line">    <span class="keyword">if</span>(t.isEmpty) <span class="string">""</span> + h</span><br><span class="line">    <span class="keyword">else</span> <span class="string">s"<span class="subst">$h</span> <span class="subst">$&#123;t.printElements&#125;</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试如下：</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ListTest</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> listOfIntegers: <span class="type">MyList</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">1</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">3</span>, <span class="type">Empty</span>)))</span><br><span class="line">  <span class="keyword">val</span> listOfStrings: <span class="type">MyList</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="string">"Hello"</span>,<span class="keyword">new</span> <span class="type">Cons</span>(<span class="string">"scala"</span>,<span class="type">Empty</span>)) </span><br><span class="line">  println(listOfStrings.toString) <span class="comment">//[Hello scala]</span></span><br><span class="line">  println(listOfIntegers.toString)<span class="comment">//[1 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Anonymous-Classes"><a href="#Anonymous-Classes" class="headerlink" title="Anonymous Classes"></a>Anonymous Classes</h3><p> <strong>匿名类：</strong>也就是没有命名的类. 对于一个类的子类，如果我们只需要实现其一次(创建一个实例), 我们就可以使用匿名类</p>
<p>首先我们来看不使用匿名类的写法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先创建一个抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>: <span class="type">Unit</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//然后创建抽象类的一个子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnonymousClasses$$anon$1</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>: <span class="type">Unit</span> = println(<span class="string">"ahahahahahaah"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最后为这个子类创建一个实例</span></span><br><span class="line"><span class="keyword">val</span> funnyAnimal: <span class="type">Animal</span> = <span class="keyword">new</span> <span class="type">AnonymousClasses</span>$$anon$<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>那么如果这个类的实例只会被创建一次，我们就没必要搞这么复杂，直接使用匿名类就可以：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>: <span class="type">Unit</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">val</span> funnyAnimal: <span class="type">Animal</span> = <span class="keyword">new</span> <span class="type">Animal</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">eat</span></span>: <span class="type">Unit</span> = println(<span class="string">"ahahahahahaah"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匿名类不只有抽象类能使用，正常的类中也可以使用, 但是需要显式得写 override</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sayHi</span></span>: <span class="type">Unit</span> = println(<span class="string">s"Hi, my name is <span class="subst">$name</span>, how can I help?"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> jim = <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"Jim"</span>) &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">sayHi</span></span>: <span class="type">Unit</span> = println(<span class="string">s"Hi, my name is Jim, how can I be of service?"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Object-Oriented-Exercises-Expanding-Our-Collection"><a href="#Object-Oriented-Exercises-Expanding-Our-Collection" class="headerlink" title="Object-Oriented Exercises : Expanding Our Collection"></a>Object-Oriented Exercises : Expanding Our Collection</h3><p>现在我们在来扩展一下之前写的MyLIst，往里面添加三个函数： map，filter 和flatmap，示例和要求如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Exercises:</span></span><br><span class="line"><span class="comment">  首先创建两个接口</span></span><br><span class="line"><span class="comment">  1.  Generic trait MyPredicate[-T] with a little method test(T) =&gt; Boolean</span></span><br><span class="line"><span class="comment">  2.  Generic trait MyTransformer[-A, B] with a method transform(A) =&gt; B</span></span><br><span class="line"><span class="comment">  然后创建三个函数</span></span><br><span class="line"><span class="comment">  3.  MyList:</span></span><br><span class="line"><span class="comment">      - map(transformer) =&gt; MyList</span></span><br><span class="line"><span class="comment">      - filter(predicate) =&gt; MyList</span></span><br><span class="line"><span class="comment">      - flatMap(transformer from A to MyList[B]) =&gt; MyList[B]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      class EvenPredicate extends MyPredicate[Int]</span></span><br><span class="line"><span class="comment">      class StringToIntTransformer extends MyTransformer[String, Int]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      [1,2,3].map(n * 2) = [2,4,6]</span></span><br><span class="line"><span class="comment">      [1,2,3,4].filter(n % 2) = [2,4]</span></span><br><span class="line"><span class="comment">      [1,2,3].flatMap(n =&gt; [n, n+1]) =&gt; [1,2,2,3,3,4]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//一个Predicate接口，用来判断是否符合条件</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">MyPredicate</span>[-<span class="type">T</span>] </span>&#123;</span><br><span class="line">  	<span class="function"><span class="keyword">def</span> <span class="title">test</span></span>(elem: <span class="type">T</span>) : <span class="type">Boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个MyTransfomer结构，用来进行类型转换</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">MyTransformer</span>[-<span class="type">A</span>,<span class="type">B</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">transform</span></span>(elem : <span class="type">A</span>): <span class="type">B</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyList</span>[+<span class="type">A</span>] </span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	...</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">  <span class="comment">//  higher-order functions</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](transformer: <span class="type">MyTransformer</span>[<span class="type">A</span>,<span class="type">B</span>]): <span class="type">MyList</span>[<span class="type">B</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(predicate: <span class="type">MyPredicate</span>[<span class="type">A</span>]): <span class="type">MyList</span>[<span class="type">A</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](transformer: <span class="type">MyTransformer</span>[<span class="type">A</span>,<span class="type">MyList</span>[<span class="type">B</span>]]): <span class="type">MyList</span>[<span class="type">B</span>]</span><br><span class="line">&#125;</span><br><span class="line">                                            </span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Empty</span> <span class="keyword">extends</span> <span class="title">MyList</span>[<span class="type">Noting</span>] </span>&#123;</span><br><span class="line">  <span class="comment">// 对一个Empty对象试行Map和filter操作，得到的肯定都是Empty本身</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](transformer: <span class="type">MyTransformer</span>[<span class="type">Nothing</span>,<span class="type">B</span>]):<span class="type">MyList</span>[<span class="type">B</span>] = <span class="type">Empty</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](tranformer:<span class="type">MyTransformer</span>[<span class="type">Nothing</span>,<span class="type">MyList</span>[<span class="type">B</span>]]):<span class="type">MyList</span>[<span class="type">B</span>] = <span class="type">Empty</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(predicate: <span class="type">MyPredicate</span>[<span class="type">Nothing</span>]): <span class="type">MyList</span>[<span class="type">Nothing</span>] =  <span class="type">Empty</span></span><br><span class="line">&#125;</span><br><span class="line">                                            </span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Cons</span>[+<span class="type">A</span>](<span class="params">h: <span class="type">A</span>, t: <span class="type">MyList</span>[<span class="type">A</span>]</span>) <span class="keyword">extends</span> <span class="title">MyList</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="comment">/* 对于List中的每一个元素，都进行predicate判定</span></span><br><span class="line"><span class="comment">  		+ 如果符合判定条件，就留下</span></span><br><span class="line"><span class="comment">		  + 否则就递归判定tail</span></span><br><span class="line"><span class="comment">		  </span></span><br><span class="line"><span class="comment">		 比如说 [1,2,3].filter(n%2 == 0)</span></span><br><span class="line"><span class="comment">		 = [2,3].filter(n%2 == 0)</span></span><br><span class="line"><span class="comment">		 = new Cons(2,[3].filter(n%2 == 0))</span></span><br><span class="line"><span class="comment">		 = new Cons(2,Empty.filter(n%2 == 0))</span></span><br><span class="line"><span class="comment">		 = new Cons(2,Empty)</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(predicate: <span class="type">MyPredicate</span>[<span class="type">A</span>]) : <span class="type">MyList</span>[<span class="type">A</span>] = </span><br><span class="line">  		<span class="keyword">if</span> (predicate.test(h)) <span class="keyword">new</span> <span class="type">Cons</span>(h,t.filter(predicate))</span><br><span class="line">  		<span class="keyword">else</span> t.filter(predict)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 对于map来说，原先的列表有多长，新的列表就有多长，只不过对每个元素做了一个映射</span></span><br><span class="line"><span class="comment">  	 比如说[1,2,3].map(n*2)</span></span><br><span class="line"><span class="comment">  	  =  new Cons(2,[2,3].map(n*2))</span></span><br><span class="line"><span class="comment">  	  =  new Cons(2,new Cons(4,[3].map(n*2)))</span></span><br><span class="line"><span class="comment">  	  =  new Cons(2,new Cons(4,new Cons(6,Empty)))</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](transformer: <span class="type">MyTransformer</span>[<span class="type">A</span>,<span class="type">B</span>]):<span class="type">MyList</span>[<span class="type">B</span>] = </span><br><span class="line">  		<span class="keyword">new</span> <span class="type">Cons</span>(transformer(h),t.map(transformer))</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// flatmap比较难一些，因为列表中每个元素可能会被映射为多个元素</span></span><br><span class="line">  <span class="comment">// 因此需要我们设计一个concatenation function</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//这里用到了下界，只有相等类型或超类的列表才能连接起来，比如:</span></span><br><span class="line">  <span class="comment">/* [1,2] ++ [3,4,5]</span></span><br><span class="line"><span class="comment">  =  new Cons(1,[2]++[3,4,5])</span></span><br><span class="line"><span class="comment">  =	 new Cons(1,new Cons(2,Empty++[3,4,5]))</span></span><br><span class="line"><span class="comment">  =  new Cons(1,new Cons(2, new Cons(3,new Cons(4, new Cons(5)))))</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">++</span></span>[<span class="type">B</span> &gt;: <span class="type">A</span>](list: <span class="type">MyList</span>[<span class="type">B</span>]): <span class="type">MyList</span>[<span class="type">B</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(h, t ++ list)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*然后我们就可以写flatmap函数了</span></span><br><span class="line"><span class="comment">  比如说：[1,2].flatmap(n =&gt; [3n,4n])</span></span><br><span class="line"><span class="comment">  = [3,4] ++ [2].flatMap(n =&gt; [3n,4n])</span></span><br><span class="line"><span class="comment">  = [3,4] ++ [6,8] ++ Empty.flatmap(n =&gt; [n,n+1])</span></span><br><span class="line"><span class="comment">  = [3,4,6,8]</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](transformer: <span class="type">MyTransformer</span>[<span class="type">A</span>,<span class="type">MyList</span>[<span class="type">B</span>]]): <span class="type">MyList</span>[<span class="type">B</span>] = </span><br><span class="line">      transformer.transform(h)++t.flatMap(transformer)</span><br><span class="line">&#125;</span><br><span class="line">                                            </span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ListTest</span> <span class="keyword">extends</span> <span class="title">App</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> listOfIntegers: <span class="type">MyList</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">1</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">3</span>, <span class="type">Empty</span>)))</span><br><span class="line">  <span class="keyword">val</span> anatherListOfIntegers: <span class="type">MyList</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">4</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">5</span>, <span class="type">Empty</span>))</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//[2]</span></span><br><span class="line">  println(listOfIntegers.filter(<span class="keyword">new</span> <span class="type">MyPredicate</span>[<span class="type">Int</span>]&#123;</span><br><span class="line">    	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">test</span></span>(elem : <span class="type">Int</span>): <span class="type">Boolean</span> = elem % <span class="number">2</span> == <span class="number">0</span><span class="comment">// elem % 2==0 是一个表达式</span></span><br><span class="line">  &#125;))</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//[2,4,6]</span></span><br><span class="line">  println(listOfIntegers.map(<span class="keyword">new</span> <span class="type">MyTransformer</span>[<span class="type">Int</span>,<span class="type">Int</span>]&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">transform</span></span>(elem: <span class="type">Int</span>): <span class="type">Int</span> = elem*<span class="number">2</span></span><br><span class="line">  &#125;))</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//[1,2,3,4,5]</span></span><br><span class="line">  println((listOfIntegers ++ anotherListOfIntegers).toString)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//[1,2,2,3,3,4]</span></span><br><span class="line">  println(listOfIntegers.flatMap(<span class="keyword">new</span> <span class="type">MyTransformer</span>[<span class="type">Int</span>,<span class="type">MyList</span>[<span class="type">Int</span>]]&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">transform</span></span>(elem: <span class="type">Int</span>): <span class="type">MyList</span>[<span class="type">Int</span>] = </span><br><span class="line">    				 <span class="keyword">new</span> <span class="type">Cons</span>(elem,<span class="keyword">new</span> <span class="type">Cons</span>(elem+<span class="number">1</span>,<span class="type">Empty</span>)).toString <span class="comment">//返回一个新的MyList</span></span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Case-Classes"><a href="#Case-Classes" class="headerlink" title="Case Classes"></a>Case Classes</h3><p>case class是scala中的一种更强大的创建类的方式。它不仅拥有普通class的功能，又有很多内建方法，不用我们自己去实现。</p>
<p>比如说我创建一个case class如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>,age: <span class="type">Int</span></span>)</span></span><br></pre></td></tr></table></figure>
<p>现在来一一介绍case class的一些特性</p>
<ul>
<li>类的构造参数默认是类内成员</li>
<li>初始化的时候可以不用new，也可以加上，但是普通类必须加new</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> jim = <span class="type">Person</span>(<span class="string">"Jim"</span>,<span class="number">34</span>)<span class="comment">//初始化的时候可以不用new</span></span><br><span class="line">println(jim.name)<span class="comment">//这对于case class是合法的，因为name是类内成员；而对于普通class则无法编译</span></span><br></pre></td></tr></table></figure>
<ul>
<li>toString的实现更漂亮</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">println(jim)<span class="comment">//Person(Jim,34) 我们看到直接打印case class的实例很直观的显示Person的参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果不加case的class，直接打印实例则是返回哈希字符串*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">noCasePerson</span>(<span class="params">name: <span class="type">String</span>,age:<span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">nocaseJim</span> </span>= <span class="keyword">new</span> noCasePerson(<span class="string">"Jim"</span>,<span class="number">34</span>)<span class="comment">//初始化必然要 new</span></span><br><span class="line">println(nocaseJim)<span class="comment">//lectures.part2oop.CaseClasses$noCasePerson@7a0ac6e3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>默认实现了equals 和hashCode；</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*在case class中，如果两个类参数相等，那么会默认判定这两个类是相等的(内置了equals方法)*/</span></span><br><span class="line"><span class="keyword">val</span> jim2 = <span class="type">Person</span>(<span class="string">"Jim"</span>,<span class="number">34</span>)</span><br><span class="line">println(jim = jim2)<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*但是在class中，则会返回false，因为这是两个实例*/</span></span><br><span class="line"><span class="keyword">val</span> nocaseJim2 = <span class="keyword">new</span> noCasePerson(<span class="string">"Jim"</span>,<span class="number">34</span>)</span><br><span class="line">println(nocaseJim = nocaseJim2) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>case class 实现了 copy方法</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> jim3 = jim.copy()<span class="comment">//创建一个和jim一模一样的实例</span></span><br><span class="line"><span class="keyword">val</span> jim4 = jim.copy(age = <span class="number">45</span>)<span class="comment">//创建一个除了age不同，其余都和jim一模一样的实例</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Case class 在创建时同时创建了companion object(伴生对象)，同时在里面给我们实现子apply方法，使得我们在使用的时候可以不直接显示地new对象；</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> thePerson = <span class="type">Person</span><span class="comment">//合法，这里的Person是case class Person的伴生对象</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>Case Class 可以序列化(Serializable)</p>
</li>
<li><p>Case Class  可以用于模式匹配，这是case class最重要的特性关于模式识别是什么，我们最后一章会学</p>
</li>
<li>除了Case Class之外，还有Case Object，其主要特性和Case Class相同，但不会创建伴生对象——因为他们自己就是自己的伴生对象</li>
</ul>
<h3 id="Scala-3-Enums"><a href="#Scala-3-Enums" class="headerlink" title="Scala 3: Enums"></a>Scala 3: Enums</h3><p>现在我们来说说Scala中的枚举类，枚举类是Scala3中的新语法</p>
<h4 id="基础定义"><a href="#基础定义" class="headerlink" title="基础定义"></a>基础定义</h4><p>首先我们可以给出一个最基本的枚举类的定义，我们可以将scala中的enum理解为一中数据类型，case后面的是该类型可选的值</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="type">Permissions</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">READ</span>,<span class="type">WRITE</span>,<span class="type">EXECUTE</span>,<span class="type">NONE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> somePermissions : <span class="type">Permissions</span> = <span class="type">Permissions</span>.<span class="type">READ</span></span><br></pre></td></tr></table></figure>
<h4 id="Enum中也可以有函数"><a href="#Enum中也可以有函数" class="headerlink" title="Enum中也可以有函数"></a>Enum中也可以有函数</h4><p>在Enum中也可以定义函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="type">Permissions</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">READ</span>,<span class="type">WRITE</span>,<span class="type">EXECUTE</span>,<span class="type">NONE</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">openDocument</span></span>():<span class="type">Unit</span> =</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == <span class="type">READ</span> || <span class="keyword">this</span> == <span class="type">WRITE</span>) println(<span class="string">"opening document"</span>)</span><br><span class="line">    <span class="keyword">else</span> println(<span class="string">"reading not allowed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> somePermissions: <span class="type">Permissions</span> = <span class="type">Permissions</span>.<span class="type">READ</span></span><br><span class="line">  somePermissions.openDocument()<span class="comment">// opening document</span></span><br></pre></td></tr></table></figure>
<h4 id="constructor-args"><a href="#constructor-args" class="headerlink" title="constructor args"></a>constructor args</h4><p>Enum也可以接收参数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="type">Color</span>(<span class="keyword">val</span> rgb: <span class="type">Int</span>)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Red</span>   <span class="keyword">extends</span> <span class="type">Color</span>(<span class="number">0xFF0000</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Green</span> <span class="keyword">extends</span> <span class="type">Color</span>(<span class="number">0x00FF00</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Blue</span>  <span class="keyword">extends</span> <span class="type">Color</span>(<span class="number">0x0000FF</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="type">Color</span>.<span class="type">Red</span>.rgb) <span class="comment">// 255 (即0xFF0000)</span></span><br></pre></td></tr></table></figure>
<h4 id="companion-objects"><a href="#companion-objects" class="headerlink" title="companion objects"></a>companion objects</h4><p>我们可以为Enum创建伴生对象：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Color</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">fromRGB</span></span>(<span class="keyword">val</span> rgb : <span class="type">Int</span>) :  <span class="type">Color</span> = ??? <span class="comment">//写从RGB到Color的逻辑(if-else)，这里略去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Enum的一些标准接口"><a href="#Enum的一些标准接口" class="headerlink" title="Enum的一些标准接口"></a>Enum的一些标准接口</h4><ul>
<li><code>Enum.ordinal</code>, 通过ordinal可以返回某个枚举值在类中的index，比如：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">al somePermissions: <span class="type">Permissions</span> = <span class="type">Permissions</span>.<span class="type">READ</span> </span><br><span class="line"><span class="comment">// Read在Perssions中的index 是 0 ，因此 somePermissions.ordinal = 0</span></span><br><span class="line"><span class="keyword">val</span> somPermissionsOrdinal = somePermissions.ordinal</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Enum.values</code> 可以以数组的方式返回Enums中的所有值</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">Permissions</span>.values.mkString(<span class="string">"Array("</span>, <span class="string">", "</span>, <span class="string">")"</span>))</span><br><span class="line"><span class="comment">//Array(READ, WRITE, EXECUTE, NONE)</span></span><br><span class="line">println(<span class="type">Color</span>.values.mkString(<span class="string">"Array("</span>, <span class="string">", "</span>, <span class="string">")"</span>) )</span><br><span class="line"><span class="comment">//Array(Red, Green, Blue)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>Enum.valueOf</code> 这个方法感觉有点鸡肋..</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">Color</span>.valueOf(<span class="string">"Blue"</span>)) <span class="comment">// Color.Blue </span></span><br><span class="line">println(<span class="type">Permissions</span>.valueOf(<span class="string">"READ"</span>)) <span class="comment">// Permissions.READ</span></span><br></pre></td></tr></table></figure>
<p>有了case class，我们可以让MyList的功能变得更加强大。</p>
<ul>
<li>首先有了equals方法，可以方便的比较两个List的元素是否相等</li>
<li>能序列化，使得在分布式系统中更加方便操作</li>
</ul>
<h3 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h3><p>现在来学习scala中的异常处理。首先来分辨一下Error和Exception的区别：</p>
<ul>
<li><p>Error 是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。既然是非正常情况，<strong>所以不便于也不需要捕获</strong>，常见的比如 OutOfMemoryError , StackOverFlowError, 都是 Error 的子类。</p>
</li>
<li><p>Exception 是程序正常运行中，可以预料的意外情况，<strong>可能并且应该被捕获</strong>，进行相应处理。Exception 又分为可检查（checked）异常和不检查（unchecked）异常【即运行时异常】，可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。</p>
<ul>
<li>检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li>
<li>运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常<strong>可以在编译时被忽略</strong>，类似 NullPointerException、ArrayIndexOutOfBoundsException 之类，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。</li>
</ul>
</li>
</ul>
<p>在JVM中，Exception和Error都继承了Throwable类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。</p>
<h4 id="throw-catch"><a href="#throw-catch" class="headerlink" title="throw-catch"></a>throw-catch</h4><ul>
<li>首先来说怎么抛出一个异常：</li>
</ul>
<p>要知道  <code>throw new NullPointerException</code> 也是一个表达式，返回一个Nothing, 所以我们可以用String类型接收它，因为Nothing是任何类的子类</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aWeirdValue: <span class="type">String</span> = <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NullPointerException</span> <span class="comment">// also crashes</span></span><br></pre></td></tr></table></figure>
<ul>
<li>然后我们来说怎么catch一个异常</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getInt</span></span>(withExceptions: <span class="type">Boolean</span>): <span class="type">Int</span> =</span><br><span class="line">  <span class="keyword">if</span> (withExceptions) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">"No int for you!"</span>)</span><br><span class="line">  <span class="keyword">else</span> <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> potentialFail = <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 调用getInt函数，导致其抛出一个异常</span></span><br><span class="line">  getInt(<span class="literal">true</span>) </span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="comment">// catch一个RuntimeException的异常的话，就打印</span></span><br><span class="line">  <span class="comment">// 如果getInt抛出的是一个NullPointerException的话，虽然有try-catch，还是会报错</span></span><br><span class="line">  <span class="keyword">case</span> e: <span class="type">RuntimeException</span> =&gt;  println(<span class="string">"caught a runtime exception"</span>)</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// finally和java中一样，无论怎么样都会执行，可写可不写</span></span><br><span class="line">  <span class="comment">// finally不会影响代码块的返回值类型</span></span><br><span class="line">  <span class="comment">// use finally only for side effects</span></span><br><span class="line">  println(<span class="string">"finally"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(potentialFail)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/28/scala%E5%88%9D%E8%AF%86/5.png"></p>
<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><p>scala中自定义异常也非常容易，只需要让其继承某一异常类即可</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  1.  Crash your program with an OutOfMemoryError</span></span><br><span class="line"><span class="comment">  2.  Crash with SOError</span></span><br><span class="line"><span class="comment">  3.  PocketCalculator</span></span><br><span class="line"><span class="comment">      - add(x,y)</span></span><br><span class="line"><span class="comment">      - subtract(x,y)</span></span><br><span class="line"><span class="comment">      - multiply(x,y)</span></span><br><span class="line"><span class="comment">      - divide(x,y)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Throw</span></span><br><span class="line"><span class="comment">        - OverflowException if add(x,y) exceeds Int.MAX_VALUE</span></span><br><span class="line"><span class="comment">        - UnderflowException if subtract(x,y) exceeds Int.MIN_VALUE</span></span><br><span class="line"><span class="comment">        - MathCalculationException for division by 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先我们要创建一些自定义异常类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OverflowException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span>(<span class="params">"<span class="type">Overflow</span>"</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">UnderflowException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span>(<span class="params">"<span class="type">Underflow</span>"</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">MathCalculationException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span>(<span class="params">"<span class="type">Division</span> by 0"</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">然后我们构造简易的计算器</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">object</span> <span class="title">PocketCalculator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(x: <span class="type">Int</span>,y:<span class="type">Int</span>) = &#123;</span><br><span class="line">    <span class="keyword">val</span> result = x + y</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span> &amp;&amp; x+y &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">OverFlowException</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span> &amp;&amp; x+y &gt; <span class="number">0</span> ) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UnderFlowException</span></span><br><span class="line">    <span class="keyword">else</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">substract</span></span>(x: <span class="type">Int</span>,y:<span class="type">Int</span>) = &#123;</span><br><span class="line">      <span class="keyword">val</span> result = x - y</span><br><span class="line">      <span class="keyword">if</span>(x &gt; <span class="number">0</span> &amp;&amp; y&lt;<span class="number">0</span> &amp;&amp; x-y &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">OverFlowException</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span> &amp;&amp; x-y &gt; <span class="number">0</span> ) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UnderFlowException</span></span><br><span class="line">      <span class="keyword">else</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">multiply</span></span>(x: <span class="type">Int</span>,y:<span class="type">Int</span>) = &#123;</span><br><span class="line">      <span class="keyword">val</span> result = x * y</span><br><span class="line">      <span class="keyword">if</span>(x &gt; <span class="number">0</span> &amp;&amp; y&gt; <span class="number">0</span> &amp;&amp; x*y &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">OverFlowException</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(x &gt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span> &amp;&amp; x*y &gt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UnderFlowException</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span> &amp;&amp; x*y &lt; <span class="number">0</span> ) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">OverFlowException</span></span><br><span class="line">     	<span class="keyword">else</span> <span class="keyword">if</span>(x &lt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span> &amp;&amp; x*y &gt; <span class="number">0</span> ) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UnderFlowException</span></span><br><span class="line">      <span class="keyword">else</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">divide</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>) = &#123;</span><br><span class="line">      <span class="keyword">if</span> (y == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">MathCalculationException</span></span><br><span class="line">      <span class="keyword">else</span> x / y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后我们测试</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> calculatorFail = <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="type">PocketCalculator</span>.add(<span class="type">Int</span>.<span class="type">MaxValue</span>, <span class="number">10</span>)</span><br><span class="line">  &#125;<span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> e: <span class="type">OverflowException</span> =&gt; println(<span class="string">"OverflowException"</span>)</span><br><span class="line">    <span class="keyword">case</span> e: <span class="type">UnderflowException</span> =&gt; println(<span class="string">"UnderflowException"</span>)</span><br><span class="line">    <span class="keyword">case</span> e: <span class="type">MathCalculationException</span> =&gt; println(<span class="string">"MathCalculationException"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// OverflowException</span></span><br></pre></td></tr></table></figure>
<h3 id="Packaging-and-Imports"><a href="#Packaging-and-Imports" class="headerlink" title="Packaging and Imports"></a>Packaging and Imports</h3><h2 id="Functional-Programming-in-Scala"><a href="#Functional-Programming-in-Scala" class="headerlink" title="Functional Programming in Scala"></a>Functional Programming in Scala</h2><h3 id="What’s-a-Function-Really"><a href="#What’s-a-Function-Really" class="headerlink" title="What’s a Function, Really"></a>What’s a Function, Really</h3><p>我们要学习scala中的函数式编程特性，就先要弄明白函数式编程是什么。</p>
<p>函数式编程中的函数指的并不是编程语言中的函数（或方法），它指的是数学意义上的函数，即映射关系（如：y = f(x)），就是 y 和 x 的对应关系。</p>
<h4 id="函数式编程的特性"><a href="#函数式编程的特性" class="headerlink" title="函数式编程的特性"></a>函数式编程的特性</h4><ol>
<li><p>函数是一等公民，它的意思就是函数与其他数据类型一样，可以把它们存在数组里，当做参数传递，赋值给变量，可以在任何地方定义，在函数内或函数外，可以作为函数的参数和返回值，也可以对函数进行组合。</p>
</li>
<li><p>高阶函数(Higher Order Function, HOF)，在函数式编程中， 高阶函数的定义是把其它函数当做参数，或者返回一个函数作为结果的函数。</p>
</li>
<li><p><strong>柯里化</strong>，就是把一个多参数的函数 f，转换为单参数函数 g，并且这个函数的返回值也是一个函数。</p>
</li>
<li><p>Side Effects，所谓“副作用”，指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。<br>   在像 C++ 这样的命令式语言中，函数的意义与数学函数完全不同。例如，假设我们有一个 C++ 函数，它接受一个浮点参数并返回一个浮点结果。从表面上看它可能看起来有点像数学函数意义上的映射实数成实数，但是 C++ 函数可以做的不仅仅是返回一个取决于其参数的数字，它还可以读写其他的全局变量，也可将将输出写入屏幕并接收来自用户的输入。但是，在纯函数式语言中，函数只能读取其参数提供给它的内容，并且它对世界产生影响的唯一方式就是通过它返回的值。</p>
</li>
<li><p>纯函数，纯函数编程和函数编程的区别在于：是否允许在函数内部执行一些非函数式的操作，同时这些操作是否会暴露给系统中的其他地方？也就是是否存在副作用。如果不存在副作用，或者说可以不用在意这些副作用，那么就将其称为纯粹的函数式编程。</p>
</li>
<li><p>引用透明性，函数无论在何处、何时调用，如果使用相同的输入总能持续地得到相同的结果，就具备了函数式的特征。这种不依赖外部变量或“状态”，只依赖输入的参数的特性就被称为引用透明性（referential transparency）。“没有可感知的副作用”（比如不改变对调用者可见的变量，进行I/O，不抛出异常等）的这些限制都隐含着引用透明性</p>
</li>
<li>递归和迭代，对于函数式而言，循环体有一个无法避免的副作用，就是它会修改某些对象的状态，通常这些对象又是和其他部分共享的。而且也因为变量值是不可变的，纯函数编程语言也无法实现循环。所以纯函数编程语言通常不包含像 while 和 for 这样的迭代构造器，而是采用的无需修改的递归。 </li>
</ol>
<h4 id="function-value"><a href="#function-value" class="headerlink" title="function value"></a>function value</h4><p>Scala编译后是要放到JVM上运行的，其实本质上是一个面向对象的编程语言。但是为了让他可以实现函数式编程，就需要对其方法(method)做一定的包装(变为函数)。因此，我们要理解——在scala里面，函数和方法是两个不同的概念。</p>
<ul>
<li>函数接口是 FunctionN(N可以是1,2,3…代表接收的参数个数) ，将其理解为一个<strong>实体</strong>，在实体中包装了一个<strong>行为方式</strong>，写在了其apply方法里</li>
<li>方法是 Method(在实体中用def定义)，将其理解为一种行为方式，这个行为方式可以通过转换来包装成一个FunctionN实体</li>
</ul>
<p>比如说，我想创建一个函数，它可以将字符串转移成数字，那么显然它接受1个参数，并返回一个Int类型的值。那么此时我需要用到Function1接口:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stringToIntConverter 接收String类型的参数，返回 Int类型的值</span></span><br><span class="line"><span class="keyword">val</span> stringToIntConverter = <span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">String</span>, <span class="type">Int</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(string: <span class="type">String</span>): <span class="type">Int</span> = string.toInt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(stringToIntConverter(<span class="string">"3"</span>) + <span class="number">4</span>) <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<p>Function1接口的源码如下：我们看到，其内部只有一个apply函数，之前我们学过，在一个对象后面加上<code>()</code>,编译器就会自动调用该类中的apply函数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@annotation</span>.implicitNotFound(msg = <span class="string">"No implicit view available from $&#123;T1&#125; =&gt; $&#123;R&#125;."</span>)</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Function1</span>[@specialized(<span class="type">Specializable</span>.<span class="type">Arg</span>) -<span class="type">T1</span>, @specialized(<span class="type">Specializable</span>.<span class="type">Return</span>) +<span class="type">R</span>] <span class="keyword">extends</span> <span class="title">AnyRef</span> </span>&#123; self =&gt;</span><br><span class="line">  <span class="comment">/** Apply the body of this function to the argument.</span></span><br><span class="line"><span class="comment">   *  @return   the result of function application.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(v1: <span class="type">T1</span>): <span class="type">R</span></span><br></pre></td></tr></table></figure>
<p>再比如说，我想创建一个函数，它可以实现两个Int值相加，那么此时我需要用Function2接口</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">val</span> adder = <span class="keyword">new</span> <span class="type">Function2</span>[<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>] &#123;</span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Int</span> = a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h4><p>事实上，我们在创建函数的时候，  <code>Function2[A,B,R]</code> 与 <code>(A,B) =&gt; R</code>是等价的，因此为了简介，我们也可以直接这样写：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> adder: ((<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span>) = <span class="keyword">new</span> <span class="type">Function2</span>[<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>] &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Int</span> = a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是不是感觉比原来更复杂了，我们接下来学习匿名函数的时候会对其做一个简化</p>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><ul>
<li>write  a function which takes 2 strings and concatenates them</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> concatenator:((<span class="type">String</span>,<span class="type">String</span>) =&gt; <span class="type">String</span> ) = <span class="keyword">new</span> <span class="type">Function2</span>[<span class="type">Int</span>,<span class="type">Int</span>,<span class="type">Int</span>]&#123;</span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span> </span>(a:<span class="type">String</span>, b:<span class="type">String</span>): <span class="type">String</span> = a+b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>transform the MyPredicate and MyTransformer into function types</li>
</ul>
<p>要对MyList中的MyPredicate和MyTransformer做一个改造，使其成为function types. 事实上，我们可以直接删去这两个接口</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> exercises</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyList</span>[+<span class="type">A</span>] </span>&#123; </span><br><span class="line">  <span class="comment">//主要改这三个函数</span></span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">   我们要把圈来的 Mytransformer接口和MyPredicate接口改成函数式接口，可以是 Function1[A,B]</span></span><br><span class="line"><span class="comment">   但是为了更加直观，我们可以将其直接写为 A =&gt; B</span></span><br><span class="line"><span class="comment">   higher-order functions</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](transformer: <span class="type">Function1</span>[<span class="type">A</span>,<span class="type">B</span>]): <span class="type">MyList</span>[<span class="type">B</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](transformer: <span class="type">A</span> =&gt; <span class="type">MyList</span>[<span class="type">B</span>]): <span class="type">MyList</span>[<span class="type">B</span>]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(predicate: <span class="type">A</span> =&gt; <span class="type">Boolean</span>): <span class="type">MyList</span>[<span class="type">A</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Empty</span> <span class="keyword">extends</span> <span class="title">MyList</span>[<span class="type">Nothing</span>] </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](transformer: <span class="type">Nothing</span> =&gt; <span class="type">B</span>): <span class="type">MyList</span>[<span class="type">B</span>] = <span class="type">Empty</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](transformer: <span class="type">Nothing</span> =&gt; <span class="type">MyList</span>[<span class="type">B</span>]): <span class="type">MyList</span>[<span class="type">B</span>] = <span class="type">Empty</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(predicate: <span class="type">Nothing</span> =&gt; <span class="type">Boolean</span>): <span class="type">MyList</span>[<span class="type">Nothing</span>] = <span class="type">Empty</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Cons</span>[+<span class="type">A</span>](<span class="params">h: <span class="type">A</span>, t: <span class="type">MyList</span>[<span class="type">A</span>]</span>) <span class="keyword">extends</span> <span class="title">MyList</span>[<span class="type">A</span>] </span>&#123; </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(predicate: <span class="type">A</span> =&gt; <span class="type">Boolean</span>): <span class="type">MyList</span>[<span class="type">A</span>] =</span><br><span class="line">    <span class="keyword">if</span> (predicate(h)) <span class="keyword">new</span> <span class="type">Cons</span>(h, t.filter(predicate))</span><br><span class="line">    <span class="keyword">else</span> t.filter(predicate)</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>](transformer: <span class="type">A</span> =&gt; <span class="type">B</span>): <span class="type">MyList</span>[<span class="type">B</span>] =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Cons</span>(transformer(h), t.map(transformer))</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">++</span></span>[<span class="type">B</span> &gt;: <span class="type">A</span>](list: <span class="type">MyList</span>[<span class="type">B</span>]): <span class="type">MyList</span>[<span class="type">B</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(h, t ++ list)</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>](transformer: <span class="type">A</span> =&gt; <span class="type">MyList</span>[<span class="type">B</span>]): <span class="type">MyList</span>[<span class="type">B</span>] =</span><br><span class="line">    transformer(h) ++ t.flatMap(transformer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ListTest</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> listOfIntegers: <span class="type">MyList</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">1</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">3</span>, <span class="type">Empty</span>)))</span><br><span class="line">  <span class="keyword">val</span> cloneListOfIntegers: <span class="type">MyList</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">1</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">3</span>, <span class="type">Empty</span>)))</span><br><span class="line">  <span class="keyword">val</span> anotherListOfIntegers: <span class="type">MyList</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">4</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">5</span>, <span class="type">Empty</span>))</span><br><span class="line"> </span><br><span class="line">  println(listOfIntegers.filter(<span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>,<span class="type">Boolean</span>]&#123;</span><br><span class="line">    	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(elem : <span class="type">Int</span>): <span class="type">Boolean</span> = elem % <span class="number">2</span> == <span class="number">0</span> </span><br><span class="line">  &#125;))</span><br><span class="line">   </span><br><span class="line">  println(listOfIntegers.map(<span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>,<span class="type">Int</span>]&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(elem: <span class="type">Int</span>): <span class="type">Int</span> = elem*<span class="number">2</span></span><br><span class="line">  &#125;))</span><br><span class="line">   </span><br><span class="line">  println((listOfIntegers ++ anotherListOfIntegers).toString)</span><br><span class="line">   </span><br><span class="line">  println(listOfIntegers.flatMap(<span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>,<span class="type">MyList</span>[<span class="type">Int</span>]]&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(elem: <span class="type">Int</span>): <span class="type">MyList</span>[<span class="type">Int</span>] = </span><br><span class="line">    				 <span class="keyword">new</span> <span class="type">Cons</span>(elem,<span class="keyword">new</span> <span class="type">Cons</span>(elem+<span class="number">1</span>,<span class="type">Empty</span>)).toString <span class="comment">//返回一个新的MyList</span></span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>define a function which takes an int and returns another function which takes an int and returns an int</li>
</ul>
<p>对于这个问题我们要从两个方面来思考：</p>
<ol>
<li>这个函数是什么类型的？接收一个Int，返回一个function，因此是Function1类型的</li>
<li>怎么实现？如下  </li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> superAdder: <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>]] = <span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>]] &#123;</span><br><span class="line">  <span class="comment">// 在这里实现apply函数，接收一个Int，返回一个Function type</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">Int</span>): <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>] &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(y: <span class="type">Int</span>): <span class="type">Int</span> = x + y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">val</span> adder3 = superAdder(<span class="number">3</span>)<span class="comment">// 此时adder3是外层的apply函数，仍然接收一个Int</span></span><br><span class="line">  println(adder3(<span class="number">4</span>))				<span class="comment">// 	adder3(4)其实调用的是内部的apply函数，返回值是int，结果是7</span></span><br><span class="line">  println(superAdder(<span class="number">3</span>)(<span class="number">4</span>)) <span class="comment">// curried function 7</span></span><br><span class="line"> 	<span class="comment">//superAdder就是一个Curried function，他将原来多参数的函数变为单参数的函数，</span></span><br></pre></td></tr></table></figure>
<h3 id="Anonymous-Functions"><a href="#Anonymous-Functions" class="headerlink" title="Anonymous Functions"></a>Anonymous Functions</h3><p>不知道你们有没有发现，我们利用Function  type来实现函数接口，从语法上还是遵循了 定义类、重载函数的思想，实际上还没有摆脱面向对象的编程思维。</p>
<p>因此我们可以使用 匿名函数，也就是 JavaScript中的 Lambda函数。 Scala 中定义匿名函数的语法很简单，箭头左边是参数列表，右边是函数体。</p>
<p>使用匿名函数后，我们的代码变得更简洁了。比如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> doubler = (x:<span class="type">Int</span>) =&gt; x*<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>同样我们可以在匿名函数中定义多个参数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> adder = (x: <span class="type">Int</span>, y: <span class="type">Int</span>) =&gt; x+y</span><br></pre></td></tr></table></figure>
<p>也可以不给匿名函数传入参数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> justDoSth = () =&gt; <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>需要注意，<code>println(justDoSth)</code> 和 <code>println(justDoSth())</code> 是不同的，前者是打印函数本身，后者是打印调用函数后返回的结果</p>
<h4 id="语法糖-1"><a href="#语法糖-1" class="headerlink" title="语法糖"></a>语法糖</h4><p>我们再来介绍一个匿名类中的语法糖：可以用下划线来代替传入的参数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> niceIncrementer: <span class="type">Int</span> =&gt; <span class="type">Int</span> = _ + <span class="number">1</span> <span class="comment">// equivalant to x =&gt; x+1</span></span><br><span class="line"><span class="keyword">val</span> niceAdder: (<span class="type">Int</span>,<span class="type">Int</span>) =&gt; <span class="type">Int</span> = _+_ <span class="comment">// equivalent to (a,b) =&gt; a+b</span></span><br></pre></td></tr></table></figure>
<h4 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise"></a>Exercise</h4><p>现在我们将MyList中的FunctionN接口都改为匿名函数</p>
<p>改之前：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ListTest</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> listOfIntegers: <span class="type">MyList</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">1</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">3</span>, <span class="type">Empty</span>))) </span><br><span class="line"> </span><br><span class="line">  println(listOfIntegers.filter(<span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>,<span class="type">Boolean</span>]&#123;</span><br><span class="line">    	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(elem : <span class="type">Int</span>): <span class="type">Boolean</span> = elem % <span class="number">2</span> == <span class="number">0</span> </span><br><span class="line">  &#125;)) </span><br><span class="line">  println(listOfIntegers.map(<span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>,<span class="type">Int</span>]&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(elem: <span class="type">Int</span>): <span class="type">Int</span> = elem*<span class="number">2</span></span><br><span class="line">  &#125;)) </span><br><span class="line">  println(listOfIntegers.flatMap(<span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>,<span class="type">MyList</span>[<span class="type">Int</span>]]&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(elem: <span class="type">Int</span>): <span class="type">MyList</span>[<span class="type">Int</span>] = </span><br><span class="line">    				 <span class="keyword">new</span> <span class="type">Cons</span>(elem,<span class="keyword">new</span> <span class="type">Cons</span>(elem+<span class="number">1</span>,<span class="type">Empty</span>)).toString <span class="comment">//返回一个新的MyList</span></span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改之后：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ListTest</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> listOfIntegers: <span class="type">MyList</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">1</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">3</span>, <span class="type">Empty</span>))) </span><br><span class="line"> </span><br><span class="line">  	println(listOfIntegers.filter(_%<span class="number">2</span> == <span class="number">0</span>).toString)</span><br><span class="line">  	println(listOfIntegers.map(_ * <span class="number">2</span>))</span><br><span class="line">  	println(listOfIntegers.flatmap(elem =&gt; <span class="type">Cons</span>(elem, <span class="type">Cons</span>(elem+<span class="number">1</span>,<span class="type">Empty</span>)).toString)</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们将之前的 super adder改成匿名函数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改之前</span></span><br><span class="line"><span class="keyword">val</span> superAdder: <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>]] = <span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>]] &#123; </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">Int</span>): <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>] &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(y: <span class="type">Int</span>): <span class="type">Int</span> = x + y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//改之后,接收了x参数，返回一个需要接受y的函数，然后再返回x+y</span></span><br><span class="line"><span class="keyword">val</span> superAdd = (x: <span class="type">Int</span>) =&gt; (y: <span class="type">Int</span>) =&gt; x + y</span><br></pre></td></tr></table></figure>
<h3 id="Higher-Order-Functions-and-Curries"><a href="#Higher-Order-Functions-and-Curries" class="headerlink" title="Higher-Order-Functions and Curries"></a>Higher-Order-Functions and Curries</h3><p>我们之前说过scala中的高阶函数要么接收一个函数为参数，要么返回一个函数。</p>
<p>比如说，我想设计一个可以重复将某一函数执行n次的函数，那么就需要传入一个函数f、参数n、初始值x</p>
<p>如 <code>nTimes(f,3,x) = nTimes(f,2,f(x)) = nTimes(f,1,f(f(x)))=nTimes(f,0,f(f(f(x))))</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nTimes</span></span>(f:<span class="type">Int</span> =&gt; <span class="type">Int</span>, n: <span class="type">Int</span>, x:<span class="type">Int</span>) : <span class="type">Int</span> = </span><br><span class="line">		<span class="keyword">if</span>(n &lt;= <span class="number">0</span>) x</span><br><span class="line">		<span class="keyword">else</span> nTimes(f,n<span class="number">-1</span>,f(x))</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"></span><br><span class="line">print(nTimes(plusOne,<span class="number">100000</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>但我们有没有感到一丝奇怪，就是我们说的函数式编程，是希望像数学里的那样，实现一个映射关系。每次只对一个参数x进行操作，而不是像上面的调用那样，一次要输入3个参数</p>
<p>因此我们可以对nTimes函数做一个改进：改进后的nTimes，每次返回的不再是Int，而是一个<code>(Int =&gt; Int)</code>的函数, 因此，我们可以调用返回的函数去计算</p>
<p>但是这种方法也有弊端，就是会出现栈溢出的问题，不是下尾递归</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nTimesBetter</span></span>(f: <span class="type">Int</span> =&gt; <span class="type">Int</span>, n: <span class="type">Int</span>): (<span class="type">Int</span> =&gt; <span class="type">Int</span>) = </span><br><span class="line">		<span class="keyword">if</span> (n &lt;= <span class="number">0</span>)(x: <span class="type">Int</span>) =&gt; x</span><br><span class="line">		<span class="keyword">else</span> (x: <span class="type">Int</span>) =&gt; nTimesBetter(f,n<span class="number">-1</span>)(f(x))</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用，此时，plus10变成了一个 Int=&gt;Int的函数</span></span><br><span class="line"><span class="keyword">val</span> plus10 = nTimesBetter(plusOne,<span class="number">100</span>)</span><br><span class="line">println(plus10(<span class="number">1</span>)) <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>
<h4 id="多个参数列表"><a href="#多个参数列表" class="headerlink" title="多个参数列表"></a>多个参数列表</h4><p>多个参数列表(multiple parameter lists)常常和柯里化常常一起用,比如说，我想创建一个函数，它可以将double类型的浮点数格式化成想要的样子。正常来说，需要输入两个参数，一个是需要被格式化的浮点数，另一个是String类型的格式本身。但是若要对其进行柯里化，就只能让函数每次只接收一个参数。</p>
<p>因此，我们可以使用多个参数列表的语法。也就是使用多个<code>()</code>, 注意，括号的顺序和参数输入的顺序是有关的。比如说下面这个<code>curriedFormatter</code>,需要先输入String, 然后在去处理Double，最后返回String</p>
<p>其本质上是一个<code>String =&gt; Double =&gt; String</code> 的函数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">curriedFormatter</span></span>(c: <span class="type">String</span>)(x: <span class="type">Double</span>) : <span class="type">String</span> = c.format(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试：</span></span><br><span class="line">	<span class="comment">//curriedFormatter返回一个Double=&gt;String的函数</span></span><br><span class="line">  <span class="keyword">val</span> standardFormat: (<span class="type">Double</span> =&gt; <span class="type">String</span>) = curriedFormatter(<span class="string">"%4.2f"</span>)</span><br><span class="line">  <span class="keyword">val</span> preciseFormat: (<span class="type">Double</span> =&gt; <span class="type">String</span>) = curriedFormatter(<span class="string">"%10.8f"</span>)   			   </span><br><span class="line">	</span><br><span class="line">  println(standardFormat(<span class="type">Math</span>.<span class="type">PI</span>)) <span class="comment">// 3.14</span></span><br><span class="line">  println(preciseFormat(<span class="type">Math</span>.<span class="type">PI</span>))	 <span class="comment">// 3.1415926</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果使用 多个参数列表的话，我们在定义子函数的时候(如上面的standardFormat和preciseFormat)，需要显式得注明函数接受的参数及其返回类型。</p>
<p>为了把多个参数列表讲清楚，我们在来举一个三个参数列表的例子：</p>
<ul>
<li>首先，我定义了triplefunc，它是一个<code>String =&gt; Double =&gt; Int =&gt;String</code>的函数</li>
<li>然后，我有定义了一个doubleFormatter， 它是triplefunc接收了一个参数后的返回值，类型为<code>Double =&gt; Int =&gt; String</code></li>
<li>接着，我又定义了一个IntAdder，它是doubleFormatter接收了一个参数后的返回值，类型为<code>Int=&gt;String</code></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">triplefunc</span></span>(c:<span class="type">String</span>)(x:<span class="type">Double</span>)(y:<span class="type">Int</span>):<span class="type">String</span> = c.format(x+y)</span><br><span class="line"><span class="keyword">val</span> doubleFormatter: <span class="type">Double</span> =&gt; <span class="type">Int</span> =&gt; <span class="type">String</span> = triplefunc(<span class="string">"%4.2f"</span>)</span><br><span class="line"><span class="keyword">val</span> <span class="type">IntAdder</span>: <span class="type">Int</span> =&gt; <span class="type">String</span> = doubleFormatter(<span class="number">2.33</span>)</span><br><span class="line"><span class="comment">//最后我们将三个函数全部调用，得到的结果是一样的 6.33</span></span><br><span class="line">println(triplefunc(<span class="string">"%4.2f"</span>)(<span class="number">2.33</span>)(<span class="number">4</span>))</span><br><span class="line">println(doubleFormatter(<span class="number">2.33</span>)(<span class="number">4</span>))</span><br><span class="line">println(<span class="type">IntAdder</span>(<span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<h4 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  1.  Expand MyList</span></span><br><span class="line"><span class="comment">      - foreach method A =&gt; Unit</span></span><br><span class="line"><span class="comment">        [1,2,3].foreach(x =&gt; println(x))</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      - sort function ((A, A) =&gt; Int) =&gt; MyList</span></span><br><span class="line"><span class="comment">        [1,2,3].sort((x, y) =&gt; y - x) =&gt; [3,2,1]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      - zipWith (list, (A, B) =&gt; C) =&gt; MyList[C]</span></span><br><span class="line"><span class="comment">        [1,2,3].zipWith([4,5,6], x * y) =&gt; [1 * 4, 2 * 5, 3 * 6] = [4,10,18]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      - fold(start)(function) =&gt; a value</span></span><br><span class="line"><span class="comment">        [1,2,3].fold(0)(x + y) = 6</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  2.  toCurry(f: (Int, Int) =&gt; Int) =&gt; (Int =&gt; Int =&gt; Int)</span></span><br><span class="line"><span class="comment">      fromCurry(f: (Int =&gt; Int =&gt; Int)) =&gt; (Int, Int) =&gt; Int</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  3.  compose(f,g) =&gt; x =&gt; f(g(x))</span></span><br><span class="line"><span class="comment">      andThen(f,g) =&gt; x =&gt; g(f(x))</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p><strong>Exercise1</strong></p>
<p>首先对MyList进行改进，新加入了四个高阶函数</p>
<ul>
<li>abstract class</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyList</span>[+<span class="type">A</span>]</span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">foreach</span></span>(f: <span class="type">A</span> =&gt; <span class="type">Unit</span>) : <span class="type">Unit</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">sort</span></span>(compare:(<span class="type">A</span>,<span class="type">A</span>)=&gt;<span class="type">Int</span>) =&gt; <span class="type">MyList</span></span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">zipWith</span></span>[<span class="type">B</span>,<span class="type">C</span>](list:<span class="type">MyList</span>[<span class="type">B</span>],zip:(<span class="type">A</span>,<span class="type">B</span>)=&gt;<span class="type">C</span>):<span class="type">MyList</span>[<span class="type">C</span>]</span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">fold</span></span>[<span class="type">B</span>](start:<span class="type">B</span>)(operator:(<span class="type">B</span>,<span class="type">A</span>)=&gt;<span class="type">B</span>):<span class="type">B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>object Empty </li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Empty</span> <span class="keyword">extends</span> <span class="title">MyList</span>[<span class="type">Nothing</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">foreach</span></span>(f: <span class="type">Nothing</span> =&gt; <span class="type">Unit</span>):<span class="type">Unit</span> = ()</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sort</span></span>(compare:(<span class="type">Nothing</span>,<span class="type">Nothing</span>)=&gt;<span class="type">Int</span>):<span class="type">MyList</span> = <span class="type">Empty</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">zipWith</span></span>[<span class="type">B</span>,<span class="type">C</span>](list:<span class="type">MyList</span>[<span class="type">B</span>],zip:(<span class="type">Nothing</span>,<span class="type">B</span>)=&gt;<span class="type">C</span>):<span class="type">MyList</span>[<span class="type">C</span>]=</span><br><span class="line">  	<span class="keyword">if</span>(!list.isEmpty)  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">"Lists do not have the same length"</span>)</span><br><span class="line">    <span class="keyword">else</span> <span class="type">Empty</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fold</span></span>[<span class="type">B</span>](start:<span class="type">B</span>)(operator:(<span class="type">B</span>:<span class="type">Nothing</span>)=&gt; <span class="type">B</span>):<span class="type">B</span> = start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>class Cons</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Cons</span>[+<span class="type">A</span>](<span class="params">h: <span class="type">A</span>, t: <span class="type">MyList</span>[<span class="type">A</span>]</span>) <span class="keyword">extends</span> <span class="title">MyList</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foreach</span></span>(f: <span class="type">A</span> =&gt; <span class="type">Unit</span>):<span class="type">Unit</span> = &#123;</span><br><span class="line">			f(h)</span><br><span class="line">			t.foreach(f)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">sort</span></span>(compare:(<span class="type">A</span>,<span class="type">A</span>)=&gt;<span class="type">Int</span>):<span class="type">MyList</span> = &#123;</span><br><span class="line">		<span class="function"><span class="keyword">def</span> <span class="title">insert</span></span>(x: <span class="type">A</span>, sortedList: <span class="type">MyList</span>[<span class="type">A</span>]): <span class="type">MyList</span>[<span class="type">A</span>] =</span><br><span class="line">      <span class="keyword">if</span> (sortedList.isEmpty) <span class="keyword">new</span> <span class="type">Cons</span>(x, <span class="type">Empty</span>)</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (compare(x, sortedList.head) &lt;= <span class="number">0</span>) <span class="keyword">new</span> <span class="type">Cons</span>(x, sortedList)</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">new</span> <span class="type">Cons</span>(sortedList.head, insert(x, sortedList.tail))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sortedTail = t.sort(compare)</span><br><span class="line">    insert(h, sortedTail)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">zipWith</span></span>[<span class="type">B</span>,<span class="type">C</span>](list:<span class="type">MyList</span>[<span class="type">B</span>],zip:(<span class="type">A</span>,<span class="type">B</span>)=&gt;<span class="type">C</span>):<span class="type">MyList</span>[<span class="type">C</span>] =  </span><br><span class="line">    <span class="keyword">if</span> (list.isEmpty) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">"Lists do not have the same length"</span>)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">new</span> <span class="type">Cons</span>(zip(h,list.head),t.zipWith(list.tail,zip))</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fold</span></span>[<span class="type">B</span>](start:<span class="type">B</span>)(operator:(<span class="type">B</span>,<span class="type">A</span>)=&gt;<span class="type">B</span>):<span class="type">B</span> = </span><br><span class="line">  	t.fold(operator(start,h))(operator)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="map-flatMap-filter-and-for-comprehensions"><a href="#map-flatMap-filter-and-for-comprehensions" class="headerlink" title="map, flatMap, filter and for-comprehensions"></a>map, flatMap, filter and for-comprehensions</h3><p>我们之前实现了自己的List，并在其中实现了map，flatmap和filter的相关功能，现在来介绍Scala中的内置方法。</p>
<p>首先来创建一个List：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">println(list.head)<span class="comment">// 打印头部，即1</span></span><br><span class="line">println(list.tail)<span class="comment">// 打印除了头之外的部分，List(2, 3)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>map</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(list.map(_ + <span class="number">1</span>))							<span class="comment">//List(2, 3, 4)</span></span><br><span class="line">println(list.map(_ + <span class="string">" is a number"</span>))	<span class="comment">//List(1 is a number, 2 is a number, 3 is a number)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>filter</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(list.filter(_ % <span class="number">2</span> == <span class="number">0</span>)) 	<span class="comment">//List(2)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>flatMap</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> toPair = (x: <span class="type">Int</span>) =&gt; <span class="type">List</span>(x, x+<span class="number">1</span>)</span><br><span class="line">println(list.flatMap(toPair))		<span class="comment">//List(1, 2, 2, 3, 3, 4)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>foreach </li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.foreach(println)<span class="comment">// 1,2,3</span></span><br></pre></td></tr></table></figure>
<p>我们看到这些函数和我们之前自己实现的功能是一样的。</p>
<h4 id="多重循环"><a href="#多重循环" class="headerlink" title="多重循环"></a>多重循环</h4><p>现在如果我想输出两个甚至更多个list的笛卡尔积，该如何操作？在面向对象的语言中，我们会使用双重循环for-loops，但是在scala中，我们需要用flatmap和map的组合来实现</p>
<ul>
<li>如果是双重循环，外循环中的每个值，都会产生一个list，是一对多的映射，因此使用flatMap；内循环每个值只生成一个对应的值，是一对一映射，因此使用map</li>
<li>如果是三重循环，除了最内层循环使用map，外层循环都会产生一个list，因此使用flatMap</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">val</span> numbers = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">  <span class="keyword">val</span> chars = <span class="type">List</span>('a','b','c','d')</span><br><span class="line">  <span class="keyword">val</span> colors = <span class="type">List</span>(<span class="string">"black"</span>, <span class="string">"white"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果我想做a1,a2,...d3,d4</span></span><br><span class="line">println(numbers.flatMap(n =&gt; chars.map(c =&gt; <span class="string">""</span>+c+n)))</span><br><span class="line"><span class="comment">//List(a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3, a4, b4, c4, d4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果我想对三个list做笛卡尔积：</span></span><br><span class="line">println(numbers.flatMap(n =&gt; chars.flatmap(c =&gt; colors.map(color=&gt;<span class="string">""</span>+c+n+<span class="string">"-"</span>+color))))</span><br><span class="line"><span class="comment">//List(a2-black, a2-white, b2-black, b2-white, c2-black, c2-white, d2-black, d2-white, a4-black, a4-white, b4-black, b4-white, c4-black, c4-white, d4-black, d4-white)=</span></span><br></pre></td></tr></table></figure>
<p>事实上，这种代码的可读性是比较差的，因此，scala提供了多重循环的简化版本。也就是 for循环，如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> forCombinations = <span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="comment">// guards, 也就是for循环中的if条件判断，编译器会将其翻译为filter</span></span><br><span class="line">  n &lt;- numbers <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">  c &lt;- chars</span><br><span class="line">  color &lt;- colors</span><br><span class="line">&#125; <span class="keyword">yield</span> <span class="string">""</span> + c + n + <span class="string">"-"</span> + color</span><br><span class="line">println(forCombinations)</span><br></pre></td></tr></table></figure>
<p>for 循环中的 yield 会把当前的元素记下来，保存在集合中，循环结束后将返回该集合。Scala中 for 循环是有返回值的。如果被循环的是 Map，返回的就是  Map，被循环的是 List，返回的就是 List，以此类推。</p>
<p>上面这句话的意思就是，对于numbers中的偶数、chars中的字符，colors中的颜色，都将其组合并保存在集合中</p>
<p>但是这只是一种语法糖，在编译器内部，还是将for语句转换成map和flatmap来执行的。</p>
<ul>
<li>注意，以下两种写法都是可以的，属于语法重载。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list.map &#123; x =&gt;</span><br><span class="line">  x * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list.map(_*<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h4 id="发散"><a href="#发散" class="headerlink" title="发散"></a>发散</h4><p>试问，我们之前创建的MyList对象，是不是也可以使用for语句进行循环呢？可以的，只要我们在函数内定义了逻辑正确的map、flatMap、filter函数，就可以应用for</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">val</span> listOfIntegers: <span class="type">MyList</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">1</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="number">3</span>, <span class="type">Empty</span>))) </span><br><span class="line">  <span class="keyword">val</span> listOfStrings: <span class="type">MyList</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">Cons</span>(<span class="string">"Hello"</span>, <span class="keyword">new</span> <span class="type">Cons</span>(<span class="string">"Scala"</span>, <span class="type">Empty</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> combinations = <span class="keyword">for</span> &#123;</span><br><span class="line">  n &lt;- listOfIntegers</span><br><span class="line">  string &lt;- listOfStrings</span><br><span class="line">&#125; <span class="keyword">yield</span> n + <span class="string">"-"</span> + string</span><br><span class="line">println(combinations)<span class="comment">//[1-Hello 1-Scala 2-Hello 2-Scala 3-Hello 3-Scala]</span></span><br></pre></td></tr></table></figure>
<h3 id="A-Collections-Overview"><a href="#A-Collections-Overview" class="headerlink" title="A Collections Overview"></a>A Collections Overview</h3><p>这一节我们来学习scala中的 集合类,这是一个比较大的类，包含了很多子类.</p>
<p>首先，我们要了解scala中的集合分为 mutable(可变) collection 和immutable(不可变) collection。</p>
<ul>
<li>可变集合可以在适当的地方被更新或扩展。这意味着你可以修改，添加，移除一个集合的元素。</li>
<li>不可变集合类，相比之下，永远不会改变。不过，你仍然可以模拟添加，移除或更新操作。但是这些操作将在每一种情况下都返回一个新的集合，同时使原来的集合不发生改变。</li>
</ul>
<p>之前我们自己写的MyList，List都属于immutable collection之列。</p>
<h4 id="mutable-collection架构图"><a href="#mutable-collection架构图" class="headerlink" title="mutable collection架构图"></a>mutable collection架构图</h4><p><img src="/2022/04/28/scala%E5%88%9D%E8%AF%86/7.svg"></p>
<p>在本篇文章中不会介绍mutable collection的相关内容</p>
<h4 id="immutable-collection-架构图"><a href="#immutable-collection-架构图" class="headerlink" title="immutable collection 架构图"></a>immutable collection 架构图</h4><p><img src="/2022/04/28/scala%E5%88%9D%E8%AF%86/6.svg"></p>
<p>Traversable是所有collection的母类，然后在Iterable下面主要分三大类：Set，Map, 和Seq。 Set是不包含重复数据的集合, Maps是键值对集合，Seq是适合存有序重复数据的列表集合。</p>
<p>Seq下面还是有 IndexSeq 和 LinearSeq两种， 前者可以通过 索引来快速定位元素。后者的元素则是线性的，按照某种顺序排列的。</p>
<h3 id="Sequences-List-Array-Vector"><a href="#Sequences-List-Array-Vector" class="headerlink" title="Sequences:  List, Array, Vector"></a>Sequences:  List, Array, Vector</h3><p>首先我们来看看 Seq接口提供了哪些操作：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Seq</span>[+<span class="type">A</span>] </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">head</span></span>: <span class="type">A</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">tail</span> </span>: <span class="type">Seq</span>[<span class="type">A</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Seq接口是一个很general(不知道怎么翻译了)的接口，其中的元素是按照清晰地顺序进行排列的。而且可以通过下标index进行访问。</p>
<p>Seq接口提供很多操作：</p>
<ul>
<li><p>在索引和迭代方面</p>
<ul>
<li><code>apply</code>: 可以直接通过<code>Seq(1,3,2,4)</code> 这样的方法构造Seq</li>
<li>iterator: 详细用法可以参考文档</li>
<li>length:返回seq长度</li>
<li>reverse: 倒转seq</li>
</ul>
</li>
<li><p>创建新的Seq方面</p>
<ul>
<li>concatenation: 两个seq连接</li>
<li>appending: seq之后连一个元素</li>
<li>prepending: seq之前连一个元素</li>
</ul>
</li>
<li>其他<ul>
<li>grouping</li>
<li>sorting</li>
<li>zipping</li>
<li>searching</li>
<li>slicing</li>
</ul>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aSequence = <span class="type">Seq</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">println(aSequence)		<span class="comment">// List(1, 3, 2, 4)</span></span><br><span class="line">println(aSequence.reverse)<span class="comment">// List(4, 2, 3, 1)</span></span><br><span class="line">println(aSequence(<span class="number">2</span>))	<span class="comment">// 2</span></span><br><span class="line">println(aSequence ++ <span class="type">Seq</span>(<span class="number">7</span>,<span class="number">5</span>,<span class="number">6</span>))<span class="comment">// List(1, 3, 2, 4, 7, 5, 6)</span></span><br><span class="line">println(aSequence.sorted)		<span class="comment">// List(1, 2, 3, 4)</span></span><br></pre></td></tr></table></figure>
<h4 id="Ranges"><a href="#Ranges" class="headerlink" title="Ranges"></a>Ranges</h4><p>scala中的Range也是一种类型，其本质上是一种特殊的 Array</p>
<p>range有两种定义方式：</p>
<ul>
<li>利用until / to 定义 . to代表前闭后闭区间；until代表前闭后开区间</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aRange: <span class="type">Seq</span>[<span class="type">Int</span>] = <span class="number">1</span> until <span class="number">10</span> </span><br><span class="line">aRange.foreach(println)<span class="comment">//1 2 3 4 5 6 7 8 9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> bRange: <span class="type">Seq</span>[<span class="type">Int</span>] = <span class="number">1</span> to <span class="number">10</span> </span><br><span class="line">bRange.foreach(println)<span class="comment">//1 2 3 4 5 6 7 8 9 10</span></span><br></pre></td></tr></table></figure>
<ul>
<li>利用Range(A,B) by C 定义。Range(A,B)代表A和B的前闭后开区间 ，C代表自定义步长</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//范围需要在最大值和最小值范围内即 2 &lt;= 元素 &lt;= 19</span></span><br><span class="line"><span class="keyword">val</span> res: <span class="type">Range</span> = <span class="type">Range</span>(<span class="number">2</span>, <span class="number">20</span>) by <span class="number">3</span></span><br><span class="line">println(res.foreach(println))</span><br></pre></td></tr></table></figure>
<p>利用 Ranges我们可以实现类似循环的效果：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span> to <span class="number">10</span>).foreach(x =&gt; println(<span class="string">"Hello"</span>)) <span class="comment">// 打印10遍 Hello</span></span><br></pre></td></tr></table></figure>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>List列表：不可变</p>
<p>LIst支持在头部快速添加和移除条目,意味着模式匹配很顺畅, head、tail、isEmpty操作只需要 $O(1)$的复杂度。</p>
<p>大多数List操作还是需要遍历整个列表的，需要O(n)的复杂度，如length，reverse。</p>
<p>List不支持索引直接定位，如 <code>list(2)=10</code> (非法)； 但是可以使用updated方法，但此方法也不是索引定位，而是线性复杂度的。</p>
<p>List列表跟其他语言中的数组非常像，二者都是同构的，同一个列表的所有元素必须是相同类型。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aList = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">// +: 是prepend, :+ 是 append，我们只要记住 : 都是靠近List一边的即可</span></span><br><span class="line"><span class="keyword">val</span> prepended = <span class="number">42</span> +: aList :+ <span class="number">89</span></span><br><span class="line">println(prepended) <span class="comment">// List(42, 1, 2, 3, 89)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fill函数是创建一个长度为5的数组，数组中每个元素都是 字符串 apple</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">val</span> apples5 = <span class="type">List</span>.fill(<span class="number">5</span>)(<span class="string">"apple"</span>)</span><br><span class="line">println(apples5)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将list中的元素按一定格式排列，mkString中的参数就是每个元素之间的分割符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">println(aList.mkString(<span class="string">"-|-"</span>))</span><br></pre></td></tr></table></figure>
<h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><p>Array和List不一样，它和Java中的arrays是等价的</p>
<ul>
<li>在创建的时候，可以预先其分配内存，而不对其进行赋值</li>
<li>在适当的位置可以被修改(更新)，所以是部分可变的</li>
<li>可以和 Java的 T[] arrays互相操作</li>
<li>可以通过索引访问，速度很快</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是创建一个长度为4的Array，同时赋值</span></span><br><span class="line"><span class="keyword">val</span> numbers = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">//创建一个String类型、长度为3的Array，但不赋值</span></span><br><span class="line"><span class="keyword">val</span> threeElements = <span class="type">Array</span>.ofDim[<span class="type">String</span>](<span class="number">3</span>)</span><br><span class="line">threeElements.foreach(println)<span class="comment">// 打印会得到null</span></span><br><span class="line"><span class="comment">//如果是数值类型的数组，不赋值，打印会得到0或者false(bool)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// array是部分可变的，比如我们可以将某一位置上的值更新。</span></span><br><span class="line">numbers(<span class="number">2</span>) = <span class="number">0</span>  <span class="comment">// 这种写法比较直白，其实是numbers.update(2, 0)的语法糖</span></span><br><span class="line">println(numbers.mkString(<span class="string">" "</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>seq和array之间的转化</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrays and seq</span></span><br><span class="line"><span class="keyword">val</span> numbersSeq: <span class="type">Seq</span>[<span class="type">Int</span>] = numbers  <span class="comment">// 隐式转化，将array转换为ArraySeq</span></span><br><span class="line">println(numbersSeq) <span class="comment">//ArraySeq(1 2 0 4)</span></span><br></pre></td></tr></table></figure>
<h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p>vector是另外一个独立的体系，也是 Imuutable的</p>
<ul>
<li>vector可以利用索引来进行读写，复杂度为$O(\log_{32}(n))$,因此vector的索引操作是非常快的</li>
<li>可以使用append和prepend</li>
<li>底层数据结构是fixed-branched Trie树(字典树)，</li>
<li>当vector中数据很大时，表现很好</li>
<li>可以使用prepend和append方法，也可以调用 updated 进行更新</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> vector: <span class="type">Vector</span>[<span class="type">Int</span>] = <span class="type">Vector</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">println(vector)</span><br></pre></td></tr></table></figure>
<ul>
<li>vectors和lists性能对比</li>
</ul>
<p>在数据量很大的情况下，vectors的表现要远远优于list：</p>
<p>首先我们写一个函数，对一个长度为1,000,000的Seq(vector和list都继承自seq)，随机替换seq中的某一个值，重复1,000遍。最终返回平均每次updated操作的运算时间。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> maxRuns = <span class="number">1000</span></span><br><span class="line"><span class="keyword">val</span> maxCapacity = <span class="number">1000000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getWriteTime</span></span>(collection: <span class="type">Seq</span>[<span class="type">Int</span>]): <span class="type">Double</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> r = <span class="keyword">new</span> <span class="type">Random</span></span><br><span class="line">  <span class="keyword">val</span> times = <span class="keyword">for</span> &#123;</span><br><span class="line">    it &lt;- <span class="number">1</span> to maxRuns</span><br><span class="line">  &#125; <span class="keyword">yield</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> currentTime = <span class="type">System</span>.nanoTime()</span><br><span class="line">    collection.updated(r.nextInt(maxCapacity), r.nextInt())</span><br><span class="line">    <span class="type">System</span>.nanoTime() - currentTime</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  times.sum * <span class="number">1.0</span> / maxRuns</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> numbersList = (<span class="number">1</span> to maxCapacity).toList</span><br><span class="line"><span class="keyword">val</span> numbersVector = (<span class="number">1</span> to maxCapacity).toVector</span><br><span class="line"></span><br><span class="line"><span class="comment">// keeps reference to tail</span></span><br><span class="line"><span class="comment">// updating an element in the middle takes long</span></span><br><span class="line">println(getWriteTime(numbersList)) <span class="comment">//耗费 2673515.435 纳秒</span></span><br><span class="line"><span class="comment">// depth of the tree is small</span></span><br><span class="line"><span class="comment">// needs to replace an entire 32-element chunk</span></span><br><span class="line">println(getWriteTime(numbersVector))<span class="comment">//耗费 8457.379 纳秒</span></span><br></pre></td></tr></table></figure>
<p>我们看到，list和vector在updated 操作上，有着近三百多倍的差距，而且差距会随着规模的增大而继续拉大</p>
<h3 id="Tuples-and-Maps"><a href="#Tuples-and-Maps" class="headerlink" title="Tuples and Maps"></a>Tuples and Maps</h3><p>和List一样，Tuple也是不可变的，但是和list也有不同之处：<strong>元组可以包含不同类型的元素</strong>，但是list为元素为统一中类型</p>
<h4 id="Tuples"><a href="#Tuples" class="headerlink" title="Tuples"></a>Tuples</h4><p>声明元组的语法如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aTuple = <span class="keyword">new</span> <span class="type">Tuple2</span>(<span class="number">2</span>,<span class="string">"hello scala"</span>)<span class="comment">//最正规也最复杂的定义</span></span><br><span class="line"><span class="keyword">val</span> aTuple = <span class="type">Tuple2</span>(<span class="number">2</span>,<span class="string">"hello scala"</span>)		<span class="comment">//可以把new去掉，因为Tuple2中有apple方法</span></span><br><span class="line"><span class="keyword">val</span> aTuple = (<span class="number">2</span>, <span class="string">"hello, Scala"</span>)  			<span class="comment">// 这是一种语法糖，等价于用Tuple2来定义</span></span><br></pre></td></tr></table></figure>
<p>事实上，scala会自动根据元组里面的元素类型以及个数去创建 TuplesN[]，N最大为22(因为是根据FunctionN来的)，所以说元组的最大容量只有22</p>
<ul>
<li>tuple 访问元素的方法</li>
</ul>
<p>tuple访问里面的第一个元素用<code>._1</code>; 第二个元素用<code>._2</code> ，以此类推</p>
<p>如果想要修改tuple中的元素，需要使用copy方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(aTuple._1)  <span class="comment">// 2</span></span><br><span class="line">println(aTuple.copy(_2 = <span class="string">"goodbye Java"</span>)) <span class="comment">//(2,goodbye Java)</span></span><br><span class="line">println(aTuple.swap)  <span class="comment">// ("hello, Scala", 2) 只有Tuple2有这个swap方法，其他都没有</span></span><br></pre></td></tr></table></figure>
<h4 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h4><ul>
<li>Maps是键值对集合，可以由如下定义：</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string 是key， Int 是value</span></span><br><span class="line"><span class="keyword">val</span> aMap: <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>] = <span class="type">Map</span>()</span><br><span class="line"><span class="comment">// 键值对可以使一个Tuple2，也可以是 key -&gt; value形式的(语法糖)</span></span><br><span class="line"><span class="comment">// withDefaultValue(-1)的意思是，如果查到Map中没有的键，就返回-1;若不设置，遇到的时候会报错</span></span><br><span class="line"><span class="keyword">val</span> phonebook = <span class="type">Map</span>((<span class="string">"Jim"</span>, <span class="number">555</span>), <span class="string">"Daniel"</span> -&gt; <span class="number">789</span>, (<span class="string">"JIM"</span>, <span class="number">9000</span>)).withDefaultValue(<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>判断map是否包含某个键</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(phonebook.contains(<span class="string">"Jim"</span>))<span class="comment">// true</span></span><br><span class="line">print(phonebook(<span class="string">"Mary"</span>))<span class="comment">//-1,因为 Mary这个键不存在</span></span><br></pre></td></tr></table></figure>
<ul>
<li>由于map是immutable的，因此如果要往原来的map里插入新键值对，</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> newPairing = <span class="string">"Mary"</span> -&gt; <span class="number">678</span></span><br><span class="line"><span class="keyword">val</span> newPhonebook = phonebook + newPairing</span><br><span class="line">println(newPhonebook)</span><br></pre></td></tr></table></figure>
<ul>
<li>让tuples打印得更漂亮</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(tuple.toString)</span><br></pre></td></tr></table></figure>
<h5 id="functionals-on-maps"><a href="#functionals-on-maps" class="headerlink" title="functionals on maps"></a>functionals on maps</h5><ul>
<li>map 函数</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(phonebook.map(pair =&gt; pair._1.toLowerCase -&gt; pair._2))</span><br></pre></td></tr></table></figure>
<ul>
<li>filter函数</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(phonebook.view.filterKeys(x =&gt; x.startsWith(<span class="string">"J"</span>)).toMap)</span><br></pre></td></tr></table></figure>
<ul>
<li>mapValues</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(phonebook.view.mapValues(number =&gt; <span class="string">"0245-"</span> + number).toMap)</span><br></pre></td></tr></table></figure>
<h5 id="map与其结构之间的转换"><a href="#map与其结构之间的转换" class="headerlink" title="map与其结构之间的转换"></a>map与其结构之间的转换</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// conversions to other collections</span></span><br><span class="line"><span class="comment">// map转换为List</span></span><br><span class="line">println(phonebook.toList) </span><br><span class="line"><span class="comment">// List转换为Map</span></span><br><span class="line">println(<span class="type">List</span>((<span class="string">"Daniel"</span>, <span class="number">555</span>)).toMap)</span><br></pre></td></tr></table></figure>
<h5 id="groupBy函数"><a href="#groupBy函数" class="headerlink" title="groupBy函数"></a>groupBy函数</h5><p>groupBy函数比较有用，可以将List中的元素分成组。比如说</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> names = <span class="type">List</span>(<span class="string">"Bob"</span>, <span class="string">"James"</span>, <span class="string">"Angela"</span>, <span class="string">"Mary"</span>, <span class="string">"Daniel"</span>, <span class="string">"Jim"</span>)</span><br><span class="line">println(names.groupBy(name =&gt; name.charAt(<span class="number">0</span>)))</span><br><span class="line"><span class="comment">//HashMap(J -&gt; List(James, Jim), A -&gt; List(Angela), M -&gt; List(Mary), B -&gt; List(Bob), D -&gt; List(Daniel))</span></span><br><span class="line">println(names.groupBy(name =&gt; name.charAt(<span class="number">0</span>) == '<span class="type">J</span>'))</span><br><span class="line"><span class="comment">//HashMap(false -&gt; List(Bob, Angela, Mary, Daniel), true -&gt; List(James, Jim))</span></span><br></pre></td></tr></table></figure>
<h4 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise"></a>Exercise</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  1.  What would happen if I had two original entries "Jim" -&gt; 555 and "JIM" -&gt; 900</span></span><br><span class="line"><span class="comment">      !!! careful with mapping keys.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  2.  Overly simplified social network based on maps</span></span><br><span class="line"><span class="comment">      Person = String</span></span><br><span class="line"><span class="comment">      - add a person to the network</span></span><br><span class="line"><span class="comment">      - remove</span></span><br><span class="line"><span class="comment">      - friend (mutual)</span></span><br><span class="line"><span class="comment">      - unfriend</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      - number of friends of a person</span></span><br><span class="line"><span class="comment">      - person with most friends</span></span><br><span class="line"><span class="comment">      - how many people have NO friends</span></span><br><span class="line"><span class="comment">      - if there is a social connection between two people (direct or not)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h3><p>现在来介绍一下Scala中一种特殊的类: Option</p>
<p>Option 可以看做一个容器要么有东西(Some),要么什么东西都没有。<strong>我们可将其看成一个长度为0或1的List。当Option里面有东西的时候，这个List的长度是1（也就是 Some），而当你的Option里没有东西的时候，它的长度是0（也就是 None）。</strong></p>
<p>那么Option可以应用在哪里？我们设想一个情况：打印一个还未分配内存的字符串，显然，这会导致 Null Pointer Error并使得程序崩溃。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> string: <span class="type">String</span> = <span class="literal">null</span></span><br><span class="line">println(string.length)</span><br></pre></td></tr></table></figure>
<p>为了解决这个问题，正常方法可以这样写,但是如果通篇都是这样的处理，就会显得很杂乱</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> string : <span class="type">String</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">if</span> (string != <span class="literal">null</span>) &#123;</span><br><span class="line">		println(string.length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，Option就发挥其作用了。Option可以作为一个wrapper，被它包含的值可以使存在的，也可以是Nothing。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unsafeMethod</span></span>(): <span class="type">String</span> = <span class="literal">null</span></span><br><span class="line"><span class="comment">//  val result = Some(null) // WRONG</span></span><br><span class="line"><span class="keyword">val</span> result = <span class="type">Option</span>(unsafeMethod()) <span class="comment">// Some or None</span></span><br><span class="line">println(result)	<span class="comment">//None</span></span><br></pre></td></tr></table></figure>
<p>此外，在 map 中，我们可以用Option来包裹 <code>map.get(&quot;key&quot;)</code> 如果key不存在，那么值就是 None</p>
<p>又比如，在访问一个空列表的头部的时候，也可以用Option。</p>
<p>我的理解是，option有点像植物大战僵尸中的南瓜，南瓜里面可以有植物，也可以什么都没有，但南瓜放在那边就会起一个保护作用。</p>
<h4 id="使用-getOrElse-方法"><a href="#使用-getOrElse-方法" class="headerlink" title="使用 getOrElse() 方法"></a>使用 getOrElse() 方法</h4><p>以下是示例程序，显示了如何使用<strong>getOrElse()</strong>方法访问值或不存在值时的默认值。</p>
<p>比如说：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backupMethod</span></span>(): <span class="type">String</span> = <span class="string">"A valid result"</span></span><br><span class="line"><span class="comment">// 如果前面函数的调用值是None，那么就会调用后面的函数</span></span><br><span class="line"><span class="keyword">val</span> chainedResult = <span class="type">Option</span>(unsafeMethod()).orElse(<span class="type">Option</span>(backupMethod()))</span><br></pre></td></tr></table></figure>
<p>事实上，我们可以在进行优化，在定义函数的时候，就将返回值定为 Option, 这样可读性更强，而且对用户更友好(api中已经设定了option，用户不用自己再套一层option)</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">betterUnsafeMethod</span></span>(): <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">betterBackupMethod</span></span>(): <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">Some</span>(<span class="string">"A valid result"</span>)</span><br><span class="line"><span class="keyword">val</span> betterChainedResult = betterUnsafeMethod() orElse betterBackupMethod()</span><br></pre></td></tr></table></figure>
<h4 id="functions-on-Options"><a href="#functions-on-Options" class="headerlink" title="functions on Options"></a>functions on Options</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(myFirstOption.isEmpty) <span class="comment">// 判断是否为空</span></span><br><span class="line">println(myFirstOption.get)   	<span class="comment">// 获得Option中的值，由于可能是空值，因此不安全</span></span><br></pre></td></tr></table></figure>
<p>Option也可以使用map、filter和flatMap函数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myFirstOption: <span class="type">Option</span>[<span class="type">Int</span>] = <span class="type">Some</span>(<span class="number">4</span>)</span><br><span class="line">println(myFirstOption.map(_ * <span class="number">2</span>)) 	<span class="comment">// Some(8)</span></span><br><span class="line">println(myFirstOption.filter(x =&gt; x &gt; <span class="number">10</span>))<span class="comment">// None </span></span><br><span class="line">println(myFirstOption.flatMap(x =&gt; <span class="type">Option</span>(x * <span class="number">10</span>)))<span class="comment">// Some(40)</span></span><br></pre></td></tr></table></figure>
<h4 id="for-comprehensions"><a href="#for-comprehensions" class="headerlink" title="for-comprehensions"></a>for-comprehensions</h4><p>在设计api的时候，如果返回值可能是None，我们需要在前面套一层Option使得api更加安全。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Connection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span> </span>= <span class="string">"Connected"</span> <span class="comment">// connect to some server</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">object</span> <span class="title">Connection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> random = <span class="keyword">new</span> <span class="type">Random</span>(<span class="type">System</span>.nanoTime())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(host: <span class="type">String</span>, port: <span class="type">String</span>): <span class="type">Option</span>[<span class="type">Connection</span>] =</span><br><span class="line">      <span class="keyword">if</span> (random.nextBoolean()) <span class="type">Some</span>(<span class="keyword">new</span> <span class="type">Connection</span>)</span><br><span class="line">      <span class="keyword">else</span> <span class="type">None</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> forConnectionStatus = <span class="keyword">for</span> &#123;</span><br><span class="line">  host &lt;- config.get(<span class="string">"host"</span>)</span><br><span class="line">  port &lt;- config.get(<span class="string">"port"</span>)</span><br><span class="line">  connection &lt;- <span class="type">Connection</span>(host, port)</span><br><span class="line">&#125; <span class="keyword">yield</span> connection.connect</span><br><span class="line"></span><br><span class="line">forConnectionStatus.foreach(println)</span><br></pre></td></tr></table></figure>
<h3 id="Handling-Failure"><a href="#Handling-Failure" class="headerlink" title="Handling Failure"></a>Handling Failure</h3><h2 id="Pattern-Matching"><a href="#Pattern-Matching" class="headerlink" title="Pattern Matching"></a>Pattern Matching</h2><h3 id="Pattern-Matching-1"><a href="#Pattern-Matching-1" class="headerlink" title="Pattern Matching"></a>Pattern Matching</h3><p>pattern matching是scala中很重要的一部分，它类似于switch case，可以对一个值进行条件判断，然后针对不同的条件进行不同的处理。</p>
<p>但是Scala的模式匹配的功能比Java的swich case语法的功能要强大的多，Java的swich case语法<strong>只能对值</strong>进行匹配。但是Scala的模式匹配除了可以对值进行匹配之外，还可以<strong>对类型进行匹配、对Array和List的元素情况进行匹配、对case class进行匹配、甚至对有值或没值（Option）进行匹配</strong>。 </p>
<p>一个常见的pattern match的语法如下：很容易理解，就是swich case</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> random = <span class="keyword">new</span> <span class="type">Random</span></span><br><span class="line"><span class="keyword">val</span> x = random.nextInt(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> description = x <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">"the ONE"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span> =&gt; <span class="string">"double or nothing"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span> =&gt; <span class="string">"third time is the charm"</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="string">"something else"</span>  <span class="comment">// _ = WILDCARD</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用pattern matching的时候我们要注意几点：</p>
<ul>
<li>case 要按照一定的顺序来组织，增强可读性</li>
<li>为了防止出现 MatchError的情况，一定要设置 Wildcard，也就是默认不匹配情况下的返回值。(用 <code>_</code>符号)</li>
</ul>
<p>pattern matching还有其他好用的特性</p>
<h4 id="解耦合"><a href="#解耦合" class="headerlink" title="解耦合"></a>解耦合</h4><p>模式匹配不单匹配值，甚至可以匹配类中的某个成员变量来进行条件筛选</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">bob</span> </span>= <span class="type">Person</span>(<span class="string">"Bob"</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> greeting = bob <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Person</span>(n, a) <span class="keyword">if</span> a &lt; <span class="number">21</span> =&gt; <span class="string">s"Hi, my name is <span class="subst">$n</span> and I can't drink in the US"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Person</span>(n, a) =&gt; <span class="string">s"Hi, my name is <span class="subst">$n</span> and I am <span class="subst">$a</span> years old"</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="string">"I don't know who I am"</span></span><br><span class="line">&#125;</span><br><span class="line">println(greeting)</span><br></pre></td></tr></table></figure>
<h4 id="PM在继承类中的应用"><a href="#PM在继承类中的应用" class="headerlink" title="PM在继承类中的应用"></a>PM在继承类中的应用</h4><p>Pattern Matching 甚至可以匹配子类类型。如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">  <span class="title">case</span> <span class="title">class</span> <span class="title">Dog</span>(<span class="params">breed: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">  <span class="title">case</span> <span class="title">class</span> <span class="title">Parrot</span>(<span class="params">greeting: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">  <span class="title">case</span> <span class="title">class</span> <span class="title">Cat</span>(<span class="params">meow: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">animal</span></span>: <span class="type">Animal</span> = <span class="type">Dog</span>(<span class="string">"Terra Nova"</span>)</span><br><span class="line"><span class="keyword">val</span> animal2: <span class="type">Animal</span> = <span class="type">Parrot</span>(<span class="string">"Terra Nova"</span>)</span><br><span class="line"><span class="keyword">val</span> animal3: <span class="type">Animal</span> = <span class="type">Cat</span>(<span class="string">"Meow Meow"</span>)</span><br><span class="line"></span><br><span class="line">animal3 <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Dog</span>(someBreed) =&gt; println(<span class="string">s"Matched a dog of the <span class="subst">$someBreed</span> breed"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Parrot</span>(someGreetings) =&gt; println(<span class="string">s"Match a parrot of <span class="subst">$someGreetings</span> greeting"</span>)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; println(<span class="string">"Something else"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise"></a>Exercise</h4><p>给出如下要求：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Exercise</span></span><br><span class="line"><span class="comment">  simple function uses PM</span></span><br><span class="line"><span class="comment">   takes an Expr =&gt; human readable form</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Sum(Number(2), Number(3)) =&gt; 2 + 3</span></span><br><span class="line"><span class="comment">   Sum(Number(2), Number(3), Number(4)) =&gt; 2 + 3 + 4</span></span><br><span class="line"><span class="comment">   Prod(Sum(Number(2), Number(1)), Number(3)) = (2 + 1) * 3</span></span><br><span class="line"><span class="comment">   Sum(Prod(Number(2), Number(1)), Number(3)) = 2 * 1 + 3</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>要我们用PM实现代码到数学公式的转换。这里最难想到的就是乘法的处理：</p>
<ul>
<li><code>Prod(Number(2), Number(1))</code> , 对2和1不需要改，直接变成 <code>2*1</code></li>
<li><code>Prod(Sum(Number(2),Number(1)),Number3)</code>,那么前面的<code>Sum(Number(2),Number(1))</code> 就需要额外加个括号，符合预算规则</li>
<li><code>Prod(Prod(Number(2),Number(1)),Number(3))</code> ，那么不需要括号，计算出<code>2*1</code>之后在和3计算得到<code>2*1*3</code></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Expr</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Number</span>(<span class="params">n: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Sum</span>(<span class="params">e1: <span class="type">Expr</span>, e2: <span class="type">Expr</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Prod</span>(<span class="params">e1: <span class="type">Expr</span>, e2: <span class="type">Expr</span></span>) <span class="keyword">extends</span> <span class="title">Expr</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">show</span>(<span class="params">e: <span class="type">Expr</span></span>)</span>: <span class="type">String</span> = e <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Number</span>(n) =&gt;	<span class="string">s"<span class="subst">$n</span>"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Sum</span>(e1,e2) =&gt; show(e1)+<span class="string">" + "</span>+show(e2)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Prod</span>(e1,e2) =&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">matchInProdExp</span></span>(e: <span class="type">Expr</span>): <span class="type">String</span> = e <span class="keyword">match</span> &#123;</span><br><span class="line">      	<span class="keyword">case</span> <span class="type">Number</span>(n) =&gt; show(e)</span><br><span class="line">      	<span class="keyword">case</span> <span class="type">Prod</span>(e1,e2) =&gt; show(e)</span><br><span class="line">      	<span class="keyword">case</span> _ =&gt; <span class="string">"("</span>+ show(e)+<span class="string">")"</span></span><br><span class="line">    &#125;</span><br><span class="line">    matchInProdExp(e1)+<span class="string">" * "</span>+matchInProdExp(e2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">println(show(<span class="type">Sum</span>(<span class="type">Number</span>(<span class="number">2</span>), <span class="type">Number</span>(<span class="number">3</span>))))</span><br><span class="line">println(show(<span class="type">Sum</span>(<span class="type">Sum</span>(<span class="type">Number</span>(<span class="number">2</span>), <span class="type">Number</span>(<span class="number">3</span>)), <span class="type">Number</span>(<span class="number">4</span>))))</span><br><span class="line">println(show(<span class="type">Prod</span>(<span class="type">Sum</span>(<span class="type">Number</span>(<span class="number">2</span>), <span class="type">Number</span>(<span class="number">1</span>)), <span class="type">Number</span>(<span class="number">3</span>))))</span><br><span class="line">println(show(<span class="type">Prod</span>(<span class="type">Sum</span>(<span class="type">Number</span>(<span class="number">2</span>), <span class="type">Number</span>(<span class="number">1</span>)), <span class="type">Sum</span>(<span class="type">Number</span>(<span class="number">3</span>), <span class="type">Number</span>(<span class="number">4</span>)))))</span><br><span class="line">println(show(<span class="type">Sum</span>(<span class="type">Prod</span>(<span class="type">Number</span>(<span class="number">2</span>), <span class="type">Number</span>(<span class="number">1</span>)), <span class="type">Number</span>(<span class="number">3</span>))))</span><br></pre></td></tr></table></figure>
<h3 id="ALL-the-Patterns"><a href="#ALL-the-Patterns" class="headerlink" title="ALL the Patterns"></a>ALL the Patterns</h3><p>这一节我们来系统总结一下总共有多少Patterns可以供我们去匹配</p>
<h4 id="constants"><a href="#constants" class="headerlink" title="constants"></a>constants</h4><p>case里面可以是很多类型，数字、字符串、布尔值、对象等</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x: <span class="type">Any</span> = <span class="string">"Scala"</span></span><br><span class="line"><span class="keyword">val</span> constants = x <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">"a number"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">"Scala"</span> =&gt; <span class="string">"THE Scala"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="literal">true</span> =&gt; <span class="string">"The Truth"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">AllThePatterns</span> =&gt; <span class="string">"A singleton object"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="variables"><a href="#variables" class="headerlink" title="variables"></a>variables</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> matchAVariable = x <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> something =&gt; <span class="string">s"I've found <span class="subst">$something</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="wildcard"><a href="#wildcard" class="headerlink" title="wildcard"></a>wildcard</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> matchAnything = x <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> _ =&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="tuples"><a href="#tuples" class="headerlink" title="tuples"></a>tuples</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aTuple = (<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> matchATuple = aTuple <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> (<span class="number">1</span>, <span class="number">1</span>) =&gt;</span><br><span class="line">  <span class="keyword">case</span> (something, <span class="number">2</span>) =&gt; <span class="string">s"I've found <span class="subst">$something</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>甚至可以匹配 嵌套元组：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> nestedTuple = (<span class="number">1</span>, (<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="keyword">val</span> matchANestedTuple = nestedTuple <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> (_, (<span class="number">2</span>, variable)) =&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="case-classes"><a href="#case-classes" class="headerlink" title="case classes"></a>case classes</h4><p>constructor pattern可以匹配我们自己创建的case class。比如说我创建了一个MyList[Int]类型的列表。case类型可以类似于case class的构造器，用来解构类中的成员</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aList: <span class="type">MyList</span>[<span class="type">Int</span>] = <span class="type">Cons</span>(<span class="number">1</span>, <span class="type">Cons</span>(<span class="number">2</span>, <span class="type">Empty</span>))</span><br><span class="line">  </span><br><span class="line"><span class="keyword">val</span> matchAList = aList <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Empty</span> =&gt; <span class="string">"Empty"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Cons</span>(head, <span class="type">Cons</span>(subhead, subtail)) =&gt; <span class="string">s"head is <span class="subst">$head</span>, subhead is <span class="subst">$subhead</span>, subtail is <span class="subst">$subtail</span>"</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">println(matchAList)<span class="comment">//head is 1, subhead is 2, subtail is []</span></span><br></pre></td></tr></table></figure>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>List  patterns非常有用,它可以有很多种形式的case</p>
<ul>
<li><code>case List(1, _, _, _)</code>  匹配开头为1，长度为4的List</li>
<li><code>case List(1, _*)</code> 匹配开头为1，长度不限的List</li>
<li><code>case 1 :: List(_)</code> 匹配开头为1的List</li>
<li><code>case List(1,2,_) :+ 42</code> 匹配以42结束的List</li>
<li><code>case h :: t =&gt; h + &quot;&quot; + processList(t)</code> 提取list的头元素和尾元素</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aStandardList = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">42</span>)</span><br><span class="line"><span class="keyword">val</span> standardListMatching = aStandardList <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">List</span>(<span class="number">1</span>, _, _, _) =&gt; <span class="comment">// extractor - advanced</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">List</span>(<span class="number">1</span>, _*) =&gt; <span class="comment">// list of arbitrary length - advanced</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span> :: <span class="type">List</span>(_) =&gt; <span class="comment">// infix pattern</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,_) :+ <span class="number">42</span> =&gt; <span class="string">"lala"</span><span class="comment">// infix pattern</span></span><br><span class="line">  <span class="keyword">case</span> h :: t =&gt; h + <span class="string">""</span> + processList(t) <span class="comment">//haskell-like prepending</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>scala还可以匹配输入对象的类型，如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> unknown: <span class="type">Any</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">val</span> unknownMatch = unknown <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> list: <span class="type">List</span>[<span class="type">Int</span>] =&gt; <span class="comment">// explicit type specifier</span></span><br><span class="line">  <span class="keyword">case</span> _:<span class="type">String</span> =&gt; <span class="string">"this method returns String"</span></span><br><span class="line">  <span class="keyword">case</span> _:<span class="type">Int</span> =&gt; <span class="string">"this method returns Int"</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="string">"this method returns something else"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="name-binding"><a href="#name-binding" class="headerlink" title="name binding"></a>name binding</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> nameBindingMatch = aList <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> nonEmptyList @ <span class="type">Cons</span>(_, _) =&gt; <span class="comment">// name binding =&gt; use the name later(here)</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Cons</span>(<span class="number">1</span>, rest @ <span class="type">Cons</span>(<span class="number">2</span>, _)) =&gt; <span class="comment">// name binding inside nested patterns</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="multi-patterns"><a href="#multi-patterns" class="headerlink" title="multi-patterns"></a>multi-patterns</h4><p>multiple patterns就是将两个模式用 Pipe符号连接起来——只要符合其中一个模式，就匹配成功，如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 8 - multi-patterns</span></span><br><span class="line"><span class="keyword">val</span> multipattern = aList <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Empty</span> | <span class="type">Cons</span>(<span class="number">0</span>, _) =&gt; <span class="comment">// compound pattern (multi-pattern)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="if-guards"><a href="#if-guards" class="headerlink" title="if guards"></a>if guards</h4><p>可在模式后添加 if 语句</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> secondElementSpecial = aList <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Cons</span>(_, <span class="type">Cons</span>(specialElement, _)) <span class="keyword">if</span> specialElement % <span class="number">2</span> == <span class="number">0</span> =&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注明"><a href="#注明" class="headerlink" title="注明"></a>注明</h4><p>JVM中会存在type erase的情况，如下：</p>
<p>此时打印 numbersMath，会得到 a list of strings，这是因为在 Java刚开始被创建时，是没有泛型这一概念的，泛型直到Java5才被加入。因此，JVM在做类型判断的时候，为了能让Java1的程序也能运行，在判断的时候，将泛型全部抹去了</p>
<p>因此，在java内部，事实上不会对List究竟是哪一种类型的做匹配，而是只匹配是否为List</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numbers: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"> <span class="keyword">val</span> numbersMatch = numbers <span class="keyword">match</span> &#123;</span><br><span class="line">   <span class="keyword">case</span> listOfStrings: <span class="type">List</span>[<span class="type">String</span>] =&gt; <span class="string">"a list of strings"</span></span><br><span class="line">   <span class="keyword">case</span> listOfNumbers: <span class="type">List</span>[<span class="type">Int</span>] =&gt; <span class="string">"a list of numbers"</span></span><br><span class="line">   <span class="keyword">case</span> _ =&gt; <span class="string">""</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> println(numbersMatch)</span><br></pre></td></tr></table></figure>
<h3 id="Patterns-Everywhere"><a href="#Patterns-Everywhere" class="headerlink" title="Patterns Everywhere"></a>Patterns Everywhere</h3><p>事实上，模式匹配的思想在 scala中随处可见：</p>
<h4 id="在try-catch中"><a href="#在try-catch中" class="headerlink" title="在try-catch中"></a>在try-catch中</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> e: <span class="type">RuntimeException</span> =&gt; <span class="string">"runtime"</span></span><br><span class="line">  <span class="keyword">case</span> npe: <span class="type">NullPointerException</span> =&gt; <span class="string">"npe"</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="string">"something else"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在try-catch中的case 其实是简写的形式，事实上在catch里面也有一个match，如下</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  e <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> e: <span class="type">RuntimeException</span> =&gt; <span class="string">"runtime"</span></span><br><span class="line">    <span class="keyword">case</span> npe: <span class="type">NullPointerException</span> =&gt; <span class="string">"npe"</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="string">"something else"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在-for-中"><a href="#在-for-中" class="headerlink" title="在 for 中"></a>在 for 中</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="keyword">val</span> evenOnes = <span class="keyword">for</span> &#123;</span><br><span class="line">  x &lt;- list <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="comment">//也是一种模式匹配</span></span><br><span class="line">&#125; <span class="keyword">yield</span> <span class="number">10</span> * x</span><br><span class="line"></span><br><span class="line"><span class="comment">// generators are also based on PATTERN MATCHING</span></span><br><span class="line"><span class="keyword">val</span> tuples = <span class="type">List</span>((<span class="number">1</span>,<span class="number">2</span>), (<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="keyword">val</span> filterTuples = <span class="keyword">for</span> &#123;</span><br><span class="line">  (first, second) &lt;- tuples</span><br><span class="line">&#125; <span class="keyword">yield</span> first * second</span><br></pre></td></tr></table></figure>
<h4 id="Tuple-List"><a href="#Tuple-List" class="headerlink" title="Tuple, List"></a>Tuple, List</h4><p>可以直接提取出tuple、list中的元素，这也包含了PM的思想。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> tuple = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> (a, b, c) = tuple</span><br><span class="line">println(b) </span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> head :: tail = list</span><br><span class="line">println(head)</span><br><span class="line">println(tail)</span><br></pre></td></tr></table></figure>
<h4 id="partial-function"><a href="#partial-function" class="headerlink" title="partial function"></a>partial function</h4><p>有时我们会遇到这样子的函数，可能会被搞得不知道是什么意思，其实这也是PM的简化形式</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="keyword">val</span> mappedList = list.map &#123;</span><br><span class="line">  <span class="keyword">case</span> v <span class="keyword">if</span> v % <span class="number">2</span> == <span class="number">0</span> =&gt; v + <span class="string">" is even"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">"the one"</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="string">"something else"</span></span><br><span class="line">&#125; <span class="comment">// partial function literal</span></span><br></pre></td></tr></table></figure>
<p>省去了对每一个list中的元素x做match的过程</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mappedList2 = list.map &#123; x =&gt; x <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> v <span class="keyword">if</span> v % <span class="number">2</span> == <span class="number">0</span> =&gt; v + <span class="string">" is even"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">"the one"</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="string">"something else"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/04/08/Solidity%E5%88%9D%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/" class="post-title-link" itemprop="url">Solidity初识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-08 19:05:05" itemprop="dateCreated datePublished" datetime="2022-04-08T19:05:05+08:00">2022-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-24 16:39:56" itemprop="dateModified" datetime="2022-04-24T16:39:56+08:00">2022-04-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Solidity初识"><a href="#Solidity初识" class="headerlink" title="Solidity初识"></a>Solidity初识</h1><p>Solidity是编写智能合约的语言，由于区块链课程需要我们编写Solidity智能合约，我又从来没对Solidity有过了解，因此借这篇博客了解一些有关Solidity的知识。</p>
<p>我们的IDE主要是在线的Remix：<a href="https://remix.ethereum.org/" target="_blank" rel="noopener">https://remix.ethereum.org/</a></p>
<p>我们也可以在本地安装solc编译器：brew install solidity(mac端)</p>
<h3 id="Smart-Contract-Compilation-In-Depth-ABI-and-Bytecode"><a href="#Smart-Contract-Compilation-In-Depth-ABI-and-Bytecode" class="headerlink" title="Smart Contract Compilation In Depth ABI and Bytecode"></a>Smart Contract Compilation In Depth ABI and Bytecode</h3><p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/1.png" style="zoom:60%;"></p>
<p>首先，我们来看看Solidity的编译过程。首先，我们写好智能合约文件，并交给Solidity Compiler 去编译。并得到一个ABI文件和一个Contract Bytecode文件。 </p>
<ul>
<li>ABI文件是函数描述符(Application Binary Interface)的缩写，它是智能合约的接口描述，描述了字段名称、字段类型、方法名称、参数名称、参数类型、方法返回值类型等。</li>
<li>Bytecode就是字节码，类似于Java 编译后的字节码。有了字节码就可以在任何安装了EVM的机器上运行了。</li>
</ul>
<p>比如我们编写一个最简单的 智能合约：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: GPL-3.0</span><br><span class="line"></span><br><span class="line">pragma solidity 0.8.7;</span><br><span class="line"></span><br><span class="line">contract Property &#123;</span><br><span class="line">    int public value;</span><br><span class="line"></span><br><span class="line">    function setValue(int _value) public&#123;</span><br><span class="line">        value &#x3D; _value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Remix上编译后可以得到其ABI和Bytecode：</p>
<ul>
<li>下面是一个json格式的文档，从remix上复制下来的，object的这串数字就是这个程序的Bytecode，是以16进制编写的，在本地用solc编译的话只会得Bytecode</li>
<li>opcodes是操作代码，有点像汇编。当Bytecode输入到EVM之后，会被翻译成操作码。操作码是程序的低级可读指令，所有操作码都有对应的16进制值,我们可以在<a href="https://ethereum.org/en/developers/docs/evm/opcodes/" target="_blank" rel="noopener">这个网站</a> 找到与其对应的值。比如说MUL 代表乘法操作，对应的值为<code>0x02</code>, 消耗的Gas为5。</li>
</ul>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/2.png" style="zoom:60%;"></p>
<p>事实上，我们可以在<a href="https://etherscan.io/opcode-tool" target="_blank" rel="noopener">Etherscan这个网站</a> 来解码 ByteCode，得到Opcode：</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/3.png" style="zoom:60%;"></p>
<p>现在我们来看看ABI, ABI是以json格式组织的。ABI文件中各参数如下</p>
<ul>
<li>name: 函数名称</li>
<li>type：方法类型，包括function, constructor, fallback(缺省方法)可以缺省，默认为function</li>
<li>constant：布尔值，如果为true指明方法不会修改合约字段的状态变量</li>
<li>payable：布尔值，标明方法是否可以接收ether</li>
<li>stateMutability：状态类型，包括pure (不读取区块链状态)，view (和constant类型，只能查看，不会修改合约字段)，nonpayable（和payable含义一样），payable（和payable含义一样）。其实保留payable和constant是为了向后兼容</li>
<li>inputs：数组，描述参数的名称和类型<ul>
<li>name：参数名称</li>
<li>type：参数类型</li>
</ul>
</li>
<li>outputs：和inputs一样，如果没有返回值，缺省是一个空数组</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">"inputs"</span>: [</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">"internalType"</span>: <span class="string">"int256"</span>,</span><br><span class="line">				<span class="attr">"name"</span>: <span class="string">"_value"</span>,</span><br><span class="line">				<span class="attr">"type"</span>: <span class="string">"int256"</span></span><br><span class="line">			&#125;</span><br><span class="line">		],</span><br><span class="line">		<span class="attr">"name"</span>: <span class="string">"setValue"</span>,</span><br><span class="line">		<span class="attr">"outputs"</span>: [],</span><br><span class="line">		<span class="attr">"stateMutability"</span>: <span class="string">"nonpayable"</span>,</span><br><span class="line">		<span class="attr">"type"</span>: <span class="string">"function"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">"inputs"</span>: [],</span><br><span class="line">		<span class="attr">"name"</span>: <span class="string">"value"</span>,</span><br><span class="line">		<span class="attr">"outputs"</span>: [</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">"internalType"</span>: <span class="string">"int256"</span>,</span><br><span class="line">				<span class="attr">"name"</span>: <span class="string">""</span>,</span><br><span class="line">				<span class="attr">"type"</span>: <span class="string">"int256"</span></span><br><span class="line">			&#125;</span><br><span class="line">		],</span><br><span class="line">		<span class="attr">"stateMutability"</span>: <span class="string">"view"</span>,</span><br><span class="line">		<span class="attr">"type"</span>: <span class="string">"function"</span></span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="Contract-Deployment-on-JS-VM"><a href="#Contract-Deployment-on-JS-VM" class="headerlink" title="Contract Deployment on JS VM"></a>Contract Deployment on JS VM</h3><p>我们在部署界面可以选择合约部署的环境，在这里我们有三个选择：</p>
<ul>
<li>JavaScript VM，这种方式就是在Remix网页上启动一个虚拟区块链环境，然后所有的交易都会在这个虚拟环境(沙箱)中执行。每次刷新页面，JS VM都会重置整个区块链。虽然不是永久的，但是在测试阶段还是非常有用的。</li>
<li>Injected Web3, remix会连接一个web3 provider(如MetaMask)并自动获取地址和余额，点击Deploy发布，会在测试网络中发布刚刚编译好的合约，（可能会是10s钟的时间，也可能久一些），当合约部署完毕，我们就可以在区块浏览器上查看到这条合约的详细信息了。当我们想在以太坊主网或者测试网上部署交易，可以选择这种。</li>
<li>Web3 Provider，使用这种模式Remix会连接一个远程的以太坊客户端，比如说geth。</li>
</ul>
<p>这里我们主要使用前两种方式。首先我们看看第一个 JavaScript VM，在我们编译完成之后，我们进入部署页面：</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/4.png" style="zoom:60%;"></p>
<p>看到默认会生成若干以太坊账户，每个账户中都有100个虚拟的以太币。</p>
<p>然后我们点击Deploy,发现在Deployed Contract中已经有一个合约了，里面有setValue函数接口可以供我们调试。同时我们发现，部署这个合约需要消耗一定量的以太币。</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/5.png" style="zoom:60%;"></p>
<p>现在我们看看调用setValue会怎么样：我们看到，setValue也需要消耗一定量的代价(这里是43724 gas)</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/6.png" style="zoom:60%;"></p>
<p>当然我们也可以将一个智能合约部署多次，每个合约的地址都不同，它们之间的变量是不共享、不互通的 </p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/7.png" style="zoom:60%;"></p>
<h3 id="Contract-Deployment-on-Rinkeby-Using-Remix-and-MetaMask"><a href="#Contract-Deployment-on-Rinkeby-Using-Remix-and-MetaMask" class="headerlink" title="Contract Deployment on Rinkeby Using Remix and MetaMask"></a>Contract Deployment on Rinkeby Using Remix and MetaMask</h3><p>现在我们用第二种Injected Web3方式来部署合约到Rinkeby测试网络上，这是一种更接近真实情况。首先，我们要注册MetaMask账号，然后通过一些列设置就可以让Remix获取我们的账号地址和账户余额了。</p>
<p>如果我们选择在以太坊主网上部署，是需要钱的，我们自然不可能在这上面部署。</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/8.png" style="zoom:60%;"></p>
<p>因此我们可以切换网络：</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/9.png" style="zoom:60%;"></p>
<p>但是我们看到这个账户在Ropsten测试网络一开始也是没有以太币的，我们需要到某些特殊的网站中去乞讨(水龙头网站)，比如：</p>
<ul>
<li><a href="https://faucet.egorfine.com/" target="_blank" rel="noopener">https://faucet.egorfine.com/</a> ，每次可以领0.15个以太币，间隔时长为1天，只限制Ropsten测试网络</li>
<li><a href="https://faucet.dimensions.network/" target="_blank" rel="noopener">https://faucet.dimensions.network/</a> ，每次可以领取1个以太币，间隔时长为1天，Ropsten测试网络</li>
<li><a href="https://faucets.chain.link/rinkeby" target="_blank" rel="noopener">https://faucets.chain.link/rinkeby</a> ，每次可以领0.1个以太币，不限次数，限制在Kovan和Rinkeby测试网络</li>
<li><a href="https://moonborrow.com/" target="_blank" rel="noopener">https://moonborrow.com/</a> , 每次随机，仅限Ropsten</li>
</ul>
<p>当我领完以太币以后，就可以点击部署了,我们看到部署这个比特币需要0.00029921个Ropsten测试网络上的以太币</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/10.jpg" style="zoom:60%;"></p>
<p>我们也可以在 Etherscan 上看到被我们部署上去的合约：</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/11.png" style="zoom:60%;"></p>
<p>如果我们想调用setValue, 还是需要”花钱的”, 如下所示：</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/12.png" style="zoom:60%;"></p>
<p>经过了一段时间的等待，在这个过程中需要经过提交、验证等操作，成功以后，我们在EtherScan上可以看到这个交易</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/13.png" style="zoom:60%;"></p>
<p>在交易未成功的时候，点击value仍然会返回0，但是当交易success之后，点击value就可以返回我们的当时设定的值了。</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/14.png" style="zoom:60%;"></p>
<h3 id="The-Structure-of-a-Smart-Contract"><a href="#The-Structure-of-a-Smart-Contract" class="headerlink" title="The Structure of a Smart Contract"></a>The Structure of a Smart Contract</h3><p>现在来介绍一下一个智能合约的结构</p>
<ul>
<li>SPDX版本</li>
</ul>
<p>首先，在合约的一开始一定要标明 SPDX License Identifier的版本, 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: GPL-3.0</span><br></pre></td></tr></table></figure>
<p>因为从Solidity ^ 0.6.8开始，引入了SPDX许可证。因此，你需要在代码中使用SPDX-License-Identifier，虽然它被注释掉了，但是在编译后的Bytecode中还是能被EVM识别到的。如果我们不写的话，会出现Warning。</p>
<ul>
<li>Solidity版本</li>
</ul>
<p>然后，需要写明这个智能合约用的是solidity的哪个版本。我们可以在 <a href="https://docs.soliditylang.org/en/v0.8.13/080-breaking-changes.html" target="_blank" rel="noopener">solidity文档</a> 中查看每个版本的更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity 0.8.7;</span><br></pre></td></tr></table></figure>
<p>此外，也可以划定 Solidity 版本的一个范围，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity &gt;&#x3D;0.5.0 &lt;0.9.0</span><br></pre></td></tr></table></figure>
<ul>
<li>合约本体</li>
</ul>
<p>最后就是整个合约的本体了，这就类似于一个class的概念，我们以这个合约为例，看看合约里面有哪些成员</p>
<ol>
<li>首先是两个成员变量 price和owner</li>
<li>然后是一个构造函数，构造函数只会被调用一次</li>
<li>接下来是一个Function Modifier,也就是函数修饰器。利用函数修饰器可在执行函数之前自动检查条件。比如说，这边changeOwner就调用了这个函数修饰器。是用来检查发起者是否等于当前owner的，如果不是，就会抛出错误信息。<ul>
<li>在定义onlyOwner出现的特殊符号 <code>_</code>，是使用该修饰器的函数体插入位置。 ‘_’符号可多次出现，替换成对应的函数体即可。</li>
</ul>
</li>
<li>changeOwner函数和setPrice都是 setter，即给合约的成员变量赋值的。</li>
<li>getPrice函数时getter，用来返回price，因此需要在定义函数后还要写上返回值的类型。</li>
<li><p>以上函数都是public的，也就是外部可以调用的(比如python可以就可以通过这些函数调用来获取一些值)</p>
</li>
<li><p>最后是event(事件)，事件是以太坊虚拟机(EVM)日志基础设施提供的一个便利接口。当被发送事件（调用）时，会触发参数存储到交易的日志中（一种区块链上的特殊数据结构）。这些日志与合约的地址关联，并记录到区块链中.</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: GPL-3.0</span><br><span class="line"></span><br><span class="line">pragma solidity &gt;&#x3D;0.5.0 &lt;0.9.0</span><br><span class="line">contract Property&#123;</span><br><span class="line">  uint private price;</span><br><span class="line">  address public owner;</span><br><span class="line">  </span><br><span class="line">  constructor ()&#123;</span><br><span class="line">	  price &#x3D;0;</span><br><span class="line"> 		owner &#x3D; msg. sender;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; Function Modifier</span><br><span class="line">  modifier onlyOwner()&#123;</span><br><span class="line">  		require(msg.sender &#x3D;&#x3D; owner);</span><br><span class="line">  		_;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function changeOwner (address _owner) public onlyOwner &#123;</span><br><span class="line">  		owner &#x3D;  _owner;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function setPrice(uint _price) public &#123;</span><br><span class="line">  		price &#x3D; _price;</span><br><span class="line">  &#125;</span><br><span class="line">  function getPrice() view public returns (uint) &#123;</span><br><span class="line">  		return price;</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  &#x2F;&#x2F; Event </span><br><span class="line">  event OwnerChanged(address owner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Solidity-Basic-Syntax-Rules"><a href="#Solidity-Basic-Syntax-Rules" class="headerlink" title="Solidity Basic Syntax Rules"></a>Solidity Basic Syntax Rules</h3><p>下面来介绍下solidity 的一些基本语法：</p>
<ul>
<li>Solidity是一种高级静态类型的智能合约编程语言，类似于JavaScript。sol是solidity的命令行编译器。</li>
<li>Solidity是区分大小写的。</li>
<li><p>每条语句都必须以分号结尾。</p>
</li>
<li><p>它使用大括号{}来划分代码块的界限。</p>
</li>
<li><p><code>//</code>代表一个单行注释。</p>
</li>
<li><p><code>/*... */</code>代表多行（块）注释。</p>
</li>
<li><p><code>///</code>代表单行natspec注释，<code>/**...*/</code>代表块状natspec注释。 natspec用于函数声明文档。</p>
</li>
<li>大多数控制结构都是可用的：if, else, while, for, break, continue, return。</li>
</ul>
<h3 id="State-and-Local-Variables"><a href="#State-and-Local-Variables" class="headerlink" title="State and Local Variables"></a>State and Local Variables</h3><p>solidity 是显式的语言，因此在声明变量和函数的时候都要注明其类型及其公有还是私有的。</p>
<p>但是变量也是分为 state variables(状态变量)和local variable(本地变量)两种。</p>
<ol>
<li><p>State Variale</p>
<ul>
<li><p>是在合约层面定义的</p>
</li>
<li><p>使用旧的存储在合约里面的</p>
</li>
<li><p>可以被置为常量，如<code>string constant public location=&quot;London&quot;</code></p>
</li>
<li><p>设置State Variable需要消耗 gas</p>
</li>
<li><p>在声明的时候需要初始化，后续可以使用构造函数或者setter对其进行修改。注意如下情况是不被允许的:</p>
<ul>
<li>```solidity<br>int public price ;<br>price = 1;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. Local Variable</span><br><span class="line"></span><br><span class="line">   + 在函数内部被声明</span><br><span class="line">   + 不消耗gas</span><br><span class="line"></span><br><span class="line">比如下面这个函数 ，在函数里面定义变量和直接对变量 修改都是被允许的。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;solidity</span><br><span class="line">function f1() public pure returns(uint256)&#123;</span><br><span class="line">    int x &#x3D; 5;</span><br><span class="line">    x &#x3D; x*2;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="view-amp-pure"><a href="#view-amp-pure" class="headerlink" title="view &amp; pure"></a>view &amp; pure</h4><p>在这里还要区分一下两个函数修饰符：view和pure，如上面我们就用pure来修饰f1</p>
<ol>
<li>View 表示一个函数不能修改状态，在本地执行时并不消耗gas</li>
<li>Pure 表示一个函数不读取状态，也不修改状态</li>
</ol>
<p>下面几种情况认为是修改了状态：</p>
<ul>
<li>写状态变量</li>
<li>触发时间</li>
<li>创建其他合约</li>
<li>call 调用附加了以太币</li>
<li>调用了任何没有view或pure修饰的函数</li>
<li>使用了低级别的调用(low-level calls)</li>
</ul>
<p>下面集中情况是读取了状态：</p>
<ul>
<li>读状态变量</li>
<li>访问了.balance属性</li>
<li>访问了block、tx、msg成员(msg.sig和msg.data除外)</li>
<li>调用了任何没有pure修饰的函数</li>
</ul>
<p>因此，getter一般需要用view进行修饰，因为他们通常需要读取状态变量，但不涉及写状态变量；但是setter一般不需要view和pure进行修饰，因为setter修改了状态</p>
<h4 id="storage-amp-memory-amp-stack"><a href="#storage-amp-memory-amp-stack" class="headerlink" title="storage &amp; memory &amp; stack"></a>storage &amp; memory &amp; stack</h4><p>在solidity合约内部， 函数外部声明的变量默认储存在storage里，函数内部声明的变量默认储存在memory里。那么storage和memory有什么区别呢？</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">storage</th>
<th>memory</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">储存的变量</td>
<td style="text-align:left">函数外部声明的变量，即状态变量</td>
<td>函数内部声明的变量，即局部变量</td>
</tr>
<tr>
<td style="text-align:left">存储的位置</td>
<td style="text-align:left">区块链上，永久存在</td>
<td>内存中，运行完之后销毁(与RAM类似)</td>
</tr>
<tr>
<td style="text-align:left">运行的位置</td>
<td style="text-align:left">区块链网络上</td>
<td>单个节点</td>
</tr>
</tbody>
</table>
</div>
<p>但是，比如我想在函数中声明一个字符串变量，如<code>string tmp = &quot;xxx&quot;</code> ,是会报错的。因为string 是一种比较特殊的类型，它不能隐式地转换为预期的字符串存储指针。因此，为了解决这个问题，我们需要显式地定义函数中的字符串，也就是 <code>string memory tmp = &quot;xxx&quot;</code> </p>
<p>其实，solidity 还有一部分空间被称为stack，他存储的是那些在函数中声明的，<strong>非引用类型的局部变量</strong>(比如int)</p>
<p>stack和memory的区别在于，memory存放的是在函数中声明的且用memory修饰的<strong>引用类型的 </strong>局部变量。</p>
<p>常见的引用类型有：string、array、struct 和 mapping， 在函数中声明这些类型的变量都需要用memory修饰</p>
<h3 id="Functions-Setters-and-Getters"><a href="#Functions-Setters-and-Getters" class="headerlink" title="Functions, Setters, and Getters"></a>Functions, Setters, and Getters</h3><p>Functions可以理解为是在合约内部的接口。函数类型也是值类型的一种，和C语言中的函数指针类似，用于指向一个函数，可以用于实现回调等功能。</p>
<h4 id="setter"><a href="#setter" class="headerlink" title="setter"></a>setter</h4><p>我们现在来讲讲Getter和Setter的定义规范</p>
<ul>
<li>setter：setter需要外部传入信息，因此在函数名称之后要用括号来包含传参，为了和状态变量有所区分，传参前面要加下划线。因为setter需要修改状态，所以不能用view/pure修饰；又是需要外部调用的，所以用public修饰。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function setPrice(int _price) public&#123;</span><br><span class="line">		price &#x3D; _price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function setLocation(string memory _location) public&#123;</span><br><span class="line">		localtion &#x3D; _location;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h4><ul>
<li>getter: getter需要向调用者返回信息，因此不需要传参。由于getter只需要访问状态变量，不需要改写状态变量，因此需要用view来进行修饰。同时因为要返回信息，因此在view修饰词之后还要写 <code>return(返回信息的类型)</code> </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function getPrice() public view returns(int)&#123;</span><br><span class="line">	return price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getLocation() public view returns(string memory _location) &#123;</span><br><span class="line">		localtion &#x3D; _location;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="The-Constructor"><a href="#The-Constructor" class="headerlink" title="The Constructor"></a>The Constructor</h3><p>构造函数我们已经很熟悉了，当合约被创建的时候它就会被调用，且仅被调用一次。默认是public的，我们不用显式声明。</p>
<p>我们看到下面这个构造函数中，出现了<code>owner =  msg.sender</code> ,这是什么意思</p>
<ul>
<li><strong>msg.sender</strong>，它指的是<strong>当前调用者（或智能合约）的 address</strong> <ul>
<li>在 Solidity 中，功能执行始终需要从<strong>外部调用者</strong>开始。 一个合约只会在区块链上什么也不做，除非有人调用其中的函数。所以 msg.sender总是存在的。</li>
</ul>
</li>
</ul>
<p>在这里，由于是我自己发布的合约，因此这里msg.sender就是我的address</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">contract Property&#123;</span><br><span class="line">		string public location;</span><br><span class="line">		int public price;</span><br><span class="line">		address public owner</span><br><span class="line">		</span><br><span class="line">		constructor(int _price, string memory _location)&#123;</span><br><span class="line">				price &#x3D; _price;</span><br><span class="line">				location &#x3D; _location;</span><br><span class="line">				owner &#x3D; msg.sender;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="immutable-amp-constant"><a href="#immutable-amp-constant" class="headerlink" title="immutable&amp;constant"></a>immutable&amp;constant</h4><ul>
<li>Constant</li>
</ul>
<p>当然，如果我在合约中声明的成员是一个常量，那么就不需要再constructor中对其进行赋值了，但是，在声明的时候就需要对其进行赋值，同时使用constant进行修饰</p>
<p>constant 修饰的变量需要在<strong>编译期确定值</strong>, 链上不会为这个变量分配存储空间, 它会在编译时用具体的值替代, 因此, constant常量是不支持使用运行时状态赋值的 (例如: <code>block.number</code> , <code>now</code> , <code>msg.sender</code> 等 )</p>
<p>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int constant area &#x3D; 100;</span><br></pre></td></tr></table></figure>
<ul>
<li>Immutable</li>
</ul>
<p>immutable 修饰的变量是在<strong>部署的时候确定变量的值</strong>, 它在构造函数中赋值一次之后,就不在改变, 这是一个运行时赋值, 就可以解除之前 constant 不支持使用运行时状态赋值的限制.</p>
<p>immutable不可变量同样不会占用状态变量存储空间, 在部署时,变量的值会被追加的运行时字节码中, 因此它<strong>比使用状态变量便宜的多</strong>, 同样带来了更多的安全性(确保了这个值无法在修改).</p>
<p>可以这样理解：constant是声明时候赋值，不能经constructor赋值；immutable可以不在声明时赋值，可以由constructor赋值，之后就不能再改变。</p>
<h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>Solidity是静态类型语言,也就是数据类型是在编译期间就决定的，和C++、Java是一样的。<code>solidity</code>编程语言提供了一些<code>基本类型（simple types）</code>可以用来组合成复杂类型。</p>
<h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><p>值类型包含</p>
<ul>
<li>布尔（Booleans）</li>
<li>整形（Integer）</li>
<li>地址（Address）</li>
<li>定长字节数组（fixed byte arras）</li>
<li>有理数和整形（Rational and Integer Literals，String literals）</li>
<li>枚举类型（Enums）</li>
<li>函数（Function Types）</li>
</ul>
<p>为什么会叫值类型，是因为上述这些类型在传值时，总是值传递。比如在函数传参数时，或进行变量赋值时。</p>
<h4 id="引用类型（Reference-Types）"><a href="#引用类型（Reference-Types）" class="headerlink" title="引用类型（Reference Types）"></a>引用类型（Reference Types）</h4><p>复杂类型，占用空间较大的。在拷贝时占用空间较大。所以考虑通过引用传递。常见引用类型有：</p>
<ul>
<li>不定长字节数组（bytes）</li>
<li>字符串（string）</li>
<li>数组（Array）</li>
<li>结构体（Structs）</li>
</ul>
<h4 id="布尔（Booleans）"><a href="#布尔（Booleans）" class="headerlink" title="布尔（Booleans）"></a>布尔（Booleans）</h4><p>bool：可能的取值为常量true 和 false<br>支持的运算符：</p>
<ul>
<li><code>!</code> 逻辑非</li>
<li><code>&amp;&amp;</code>逻辑与</li>
<li><code>||</code>逻辑或</li>
<li><code>==</code>等于</li>
<li><code>!=</code>不等于<br>注意：<code>&amp;&amp;</code>和 <code>||</code> 是短路运算符，他只会先执行前面的，如果无法判定结果才会执行后面的，比如 <code>f(x) || g(y)</code>，如果<code>f(x</code>)已经判定为false,则结果为false,不会再执行<code>g(y)</code>;同理 <code>f(x) &amp;&amp; g(y)</code>若<code>f(x)</code>判定为真,则 <code>g(y)</code>也不会再执行。</li>
</ul>
<p>如果声明的布尔变量未被初始化，那么其会被默认置为false</p>
<h4 id="整形（Integer）"><a href="#整形（Integer）" class="headerlink" title="整形（Integer）"></a>整形（Integer）</h4><p>int/uint: 变长的有符号或无符号整形.变量支持的步长以8递增,支持从 <code>uint8</code> 到 <code>uint256</code>,以及 <code>int8</code> 到 int256。需要<code>注意</code>的是，<code>uint</code> 和 <code>int</code> 默认代表的是 <code>uint256</code>($0\sim2^{256}$) 和 <code>int256</code>($2^{-128}\sim 2^{127}$)</p>
<p>支持的运算符:</p>
<ul>
<li>比较: <code>&lt;=</code> , <code>&lt;</code> , <code>==</code>, <code>!=</code> , <code>&gt;=</code>, <code>&gt;</code>, 返回值为bool类型。</li>
<li>位运算符： <code>&amp;</code> ， <code>|</code> ， (<code>^</code>异或) , (<code>~</code>非).</li>
<li>数学运算: <code>+</code> , <code>-</code>, <code>*</code> ,<code>/</code>, (<code>%</code>求余), ( <code>**</code>幂)</li>
</ul>
<p>整数除法总是截断的,但如果运算符是字面量,则不会截断(后面会进一步提到).另外除 0 会抛出异常.</p>
<p>如果声明了整型但不对其进行初始化，那么会被默认置为0；</p>
<h4 id="定长数组-Fixed-Size-Arrays"><a href="#定长数组-Fixed-Size-Arrays" class="headerlink" title="定长数组 Fixed-Size Arrays"></a>定长数组 Fixed-Size Arrays</h4><p>现在我们来介绍定长数组，在编译的时候它的长度已经被确定下来了。</p>
<p><strong>成员变量</strong><br><code>.length</code> 表示这个字符数组的长度（只读）</p>
<p>固定大小字节数组可以通过 <code>bytes1, bytes2, bytes3, …, bytes32</code>来进行声明。PS：<code>byte</code>的别名就是 <code>byte1</code>。</p>
<ul>
<li><code>bytes1</code>只能存储<code>一个</code>字节，也就是二进制<code>8位</code>的内容。</li>
<li><code>bytes2</code>只能存储<code>两个</code>字节，也就是二进制<code>16位</code>的内容。</li>
<li><code>bytes3</code>只能存储<code>三个</code>字节，也就是二进制<code>24位</code>的内容。<br> ……</li>
<li><p><code>bytes32</code>能存储<code>三十二个</code>字节，也就是二进制<code>32 * 8 = 256</code>位的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">contract C &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 0x6c697975656368756e</span><br><span class="line">    </span><br><span class="line">    byte public a &#x3D; 0x6c; &#x2F;&#x2F; 0110 1100</span><br><span class="line">    bytes1 public b &#x3D; 0x6c; &#x2F;&#x2F; 0110 1100</span><br><span class="line">    bytes2 public c &#x3D; 0x6c69; &#x2F;&#x2F; 0110 1100 0110 1001</span><br><span class="line">    bytes3 public d &#x3D; 0x6c6979; &#x2F;&#x2F; 0110 1100 0110 1001 0111 1001</span><br><span class="line">    bytes4 public e &#x3D; 0x6c697975; &#x2F;&#x2F; 0110 1100 0110 1001 0111 1001 0111 0101</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    </span><br><span class="line">    bytes8 public f &#x3D; 0x6c69797565636875; &#x2F;&#x2F; 0110 1100 0110 1001 0111 1001 0111 0101 0110 0101 0110 0011 0110 1000 0111 0101</span><br><span class="line">    bytes9 public g &#x3D; 0x6c697975656368756e; &#x2F;&#x2F; &#x2F;&#x2F; 0110 1100 0110 1001 0111 1001 0111 0101 0110 0101 0110 0011 0110 1000 0111 0101 0110 1110</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>使用这种方法来定义的话，无法对特定的位数进行赋值，比如<code>a[0]=&#39;a&#39;</code> 是不可以的</p>
<p>而且这样很不直观，我们可以像定义普通数组一样来声明定长数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">contract FixedSizeArrays&#123;</span><br><span class="line">		uint[3] public numbers;&#x2F;&#x2F;未初始化，就都为0</span><br><span class="line">		uint[3] public numbers3 &#x3D; [2,3,4];&#x2F;&#x2F;初始化</span><br><span class="line">		</span><br><span class="line">		&#x2F;*</span><br><span class="line">		setter 可以调用此函数为数组中的某个元素赋值</span><br><span class="line">		*&#x2F;</span><br><span class="line">		function setElement(uint index,uint value) public&#123;</span><br><span class="line">				numbers[index] &#x3D; value;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;*</span><br><span class="line">		getter 获取数组长度</span><br><span class="line">		*&#x2F;</span><br><span class="line">		function getLength() public view returns(uint) &#123;</span><br><span class="line">				return numbers.length;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们访问越界的时候，就会报错</p>
<h4 id="变长数组-Dynamically-Sized-Arrays"><a href="#变长数组-Dynamically-Sized-Arrays" class="headerlink" title="变长数组 Dynamically-Sized Arrays"></a>变长数组 Dynamically-Sized Arrays</h4><p>变长数组顾名思义可以改变是数组的长度, 类似于一个栈，后进先出。</p>
<p><strong>成员变量</strong></p>
<p><code>.length</code> 表示这个字符数组的长度</p>
<p><code>.push</code> 表示往这个数组中添加成员</p>
<p><code>.pop</code> 表示将数组中某成员删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">contract DynamicArrays&#123;</span><br><span class="line">		uint[] public numbers;</span><br><span class="line">		</span><br><span class="line">		function getLength() pubilc view returns (uint)&#123;</span><br><span class="line">				return numbers.length;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		function addElement(uint item)public &#123;</span><br><span class="line">				numbers.push(item);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		function popElement() public &#123;</span><br><span class="line">				numbers.pop();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		function getElement(uint i) public view returns (uint)&#123;</span><br><span class="line">				if(i &lt; numbers.length)&#123;</span><br><span class="line">						return numbers[i];</span><br><span class="line">				&#125; </span><br><span class="line">				return 0;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以定义局部变量数组。 需要注意的是，array属于引用类型，需要显式用memory修饰。和Storage Array不同，Memory Array无法使用pop和push，而且也无法使用.length得到长度。因此，如果要将Memory Array赋值给Storage Array的话，需要在声明时注明数组的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f() public &#123;</span><br><span class="line">		uint[] memory y &#x3D; new uint[](3);</span><br><span class="line">		y[0] &#x3D; 10;</span><br><span class="line">		y[1] &#x3D; 20;</span><br><span class="line">		y[2] &#x3D; 30;</span><br><span class="line">		numbers &#x3D; y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Bytes-and-String-Types"><a href="#Bytes-and-String-Types" class="headerlink" title="Bytes and String Types"></a>Bytes and String Types</h4><p>字符串常量是指由单引号，或双引号引起来的字符串（<code>&quot;foo&quot;</code>or <code>&#39;bar&#39;</code>）。solidity字符串并不像C语言一样包含结束符，<code>”foo“</code>这个字符串大小仅为3字节。和整数常量一样，字符串的长度类型可以是变长的。字符串可以隐式的转换为byte1…byte32如果合适，也会转为bytes 或 String。</p>
<p>字符串常量支持转义字符，比如<code>\n</code>,<code>\xNN</code>,<code>\uNNN</code>。其中<code>\xNN</code>表示16进制值,最终转换合适的字节.而<code>\uNNNN</code>表示Unicode编码值,最终会转换为UTF8的序列.</p>
<p>现在我们来看一下Bytes和String的区别，比如我都将其初始化为<code>&#39;abc&#39;</code>,但实际上bytes变量是按照ASCII码存储的，而string则是由UTF-8格式存储的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">contract DynamicArrays&#123;</span><br><span class="line">	bytes public b1 &#x3D; &#39;abc&#39;;</span><br><span class="line">  string public s1 &#x3D; &#39;abc&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Structs-and-Enums"><a href="#Structs-and-Enums" class="headerlink" title="Structs and Enums"></a>Structs and Enums</h4><ul>
<li>Struct</li>
</ul>
<p>Solidity中的Struct与C语言中的struct类似。是一个键值对的集合，类似于映射，但值可以有不同的类型。</p>
<p>struct 会被存储在<strong>storage</strong>里面。一般来说，struct是定义在contract外的。下面我定义了一个Instructor 结构，然后在智能合约中通过constructor进行初始化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">struct Instructor &#123;</span><br><span class="line">		uint age;</span><br><span class="line">		string name;</span><br><span class="line">		address addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Academy&#123;</span><br><span class="line">		Instructor public academyInstructor;</span><br><span class="line">		</span><br><span class="line">		constructor (uint _age , string memory _name)&#123;</span><br><span class="line">				academyInstructor.age &#x3D; _age;</span><br><span class="line">				academyInstructor.name &#x3D; _name;</span><br><span class="line">				academyInstructor.addr &#x3D; msg.sender;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;*</span><br><span class="line">		此外，如果我们需要修改状态变量academyInstructor，需要传入struct所需的全部参数。</span><br><span class="line">		而且，由于struct是引用变量，因此需要用memory显式修饰。</span><br><span class="line">		*&#x2F;</span><br><span class="line">		function changeInstructor(uint _age, string memory _name ,address _addr) public&#123;</span><br><span class="line">				Instructor memory myInstructor &#x3D; Instructor(&#123;</span><br><span class="line">						age: _age,</span><br><span class="line">						name: _name,</span><br><span class="line">						addr: _addr</span><br><span class="line">				&#125;);</span><br><span class="line">				academyInstructor &#x3D; myInstructor;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Enum</li>
</ul>
<p>Enum和java中的Enum类似，可以用于定义取值范围有限的类型。Solidity 中Enum可以和整形显式的相互转换，整形再转换成enum时，编译器/EVM会检查取值范围，如果范围有误则会产生一个错误。 下面是一个例子：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">contract EnumTest &#123;</span><br><span class="line">    </span><br><span class="line">    event UintValue(uint value);</span><br><span class="line">    event EnumValue(Status status);</span><br><span class="line">    </span><br><span class="line">    enum Status &#123;ACTIVE,SUSPENDED&#125;</span><br><span class="line">    </span><br><span class="line">    function enumTest() public &#123;</span><br><span class="line">        Status s1 &#x3D; Status.ACTIVE;</span><br><span class="line">        &#x2F;&#x2F;0 will be emited</span><br><span class="line">        emit UintValue(uint(s1));</span><br><span class="line">        </span><br><span class="line">        Status s2 &#x3D; Status(1);</span><br><span class="line">        &#x2F;&#x2F;1 will be emited</span><br><span class="line">        emit EnumValue(s2);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;Next line will get an compile time error for 2 is out of range</span><br><span class="line">        &#x2F;&#x2F;Status s2 &#x3D; Status(2);</span><br><span class="line">        </span><br><span class="line">        uint x &#x3D; 4 - 4;</span><br><span class="line">        Status s3 &#x3D; Status(x);</span><br><span class="line">        &#x2F;&#x2F;0 will be emited</span><br><span class="line">        emit EnumValue(s3);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; x &#x3D; 4 - 2;</span><br><span class="line">        &#x2F;&#x2F;The next line will get an run time error for x is out of range</span><br><span class="line">        &#x2F;&#x2F; Status s4 &#x3D; Status(x);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Mappings"><a href="#Mappings" class="headerlink" title="Mappings"></a>Mappings</h4><p>solidity里的映射可以理解为python里的字典，建立键－值的对应关系，可以通过键来查找值，键必须是唯一的，但值可以重复。</p>
<p>定义方式为：mapping（键类型=&gt;值类型），例如<code>mapping(address=&gt;uint)  public  balances</code>，这个映射的名字是balances，权限类型为public，键的类型是地址address，值的类型是整型uint，在solidity中这个映射的意思是将参数amount的值和msg.sender这个地址对应起来。</p>
<p>在solidity中，一般有如下性质</p>
<ul>
<li>所有的键都必须是一个类型的；所有的值也必须是同一类型的</li>
<li>Mapping永远是被存放在storage中的，它是状态变量。就算是在函数中定义的mapping也会被存放在storage里</li>
<li>Mapping的优势在于查找过程是$O(1)$的，相比与线性查找的数组，要快很多。</li>
<li>Mapping并不是可迭代的，也没有一个迭代器可以遍历mapping</li>
<li>如果我们用一个不存在的key去mapping查找，就会得到一个默认的值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contract Auction&#123;</span><br><span class="line">		mapping(address &#x3D;&gt; uint) public bids;</span><br><span class="line">		</span><br><span class="line">		function bid() payable public &#123;</span><br><span class="line">				bids[msg.sender] &#x3D; msg.value;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Overflows-and-Underflows"><a href="#Overflows-and-Underflows" class="headerlink" title="Overflows and Underflows"></a>Overflows and Underflows</h3><p>在早期的solidity版本中，整型变量是会发生上溢和下溢的，比如，我把solidity版本置为0.5.0， 然后定义一个uint8=255的变量，利用一个函数调用让其发生上溢：</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/1.gif"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">contract Property&#123;</span><br><span class="line">        uint8 public x &#x3D; 255;</span><br><span class="line">        </span><br><span class="line">        function f1() public&#123;</span><br><span class="line">            x +&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所示，我若将uint8类型的255加上1，不会报错，但是数值从255变为了0</p>
<p>在比较新的solidity版本中(比如0.8.0)，当我使用同样的代码时，调用该函数会报错，x保持255的值不变。这是因为在新版本的solidity对可运算的数值类型加入了自动检查的功能。如果我们偏要忽略运算检查，可以使用unchecked来修饰，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function f1() public&#123;</span><br><span class="line">	unchecked &#123;x +&#x3D; 1&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/16.png"></p>
<p>此外，还有一个显著的差别就是：bytes变量可以调用push函数插入字符、可以用pop弹出字符、可以用length获取长度，但是string都不行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">contract DynamicArrays&#123;</span><br><span class="line">	bytes public b1 &#x3D; &#39;abc&#39;;</span><br><span class="line">    string public s1 &#x3D; &#39;abc&#39;;</span><br><span class="line"></span><br><span class="line">    function addElement() public &#123;</span><br><span class="line">        b1.push(&#39;x&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/2.gif"></p>
<p>需要注明的是，相比于变长数组，定长数组消耗更少的gas，因此能用则用。</p>
<h3 id="Built-In-Global-Variables"><a href="#Built-In-Global-Variables" class="headerlink" title="Built-In Global Variables"></a>Built-In Global Variables</h3><p>现在我们要学习一些solidity 内建的全局变量。其实之前我们已经接触到了这些变量，比如msg系列的、block系列的</p>
<h4 id="abi"><a href="#abi" class="headerlink" title="abi"></a>abi</h4><ul>
<li><code>abi.encode(...) returns (bytes)</code>:对给定的参数进行ABI编码。</li>
<li><code>abi.encodePacked(...) returns (bytes)</code>: Performes packed encoding of the given arguments</li>
<li><code>abi.encodeWithSelector(bytes4 selector, ...) returns (bytes)</code>::对给定的参数进行ABI编码——从第二个预置给定的四字节选择器开始</li>
<li><code>abi.encodeWithSignature(string signature, ...) returns (bytes)</code>:相当于<code>abi.encodeWithSelector(bytes4(keccak256(signature), ...)</code></li>
</ul>
<h4 id="block系列"><a href="#block系列" class="headerlink" title="block系列"></a>block系列</h4><ul>
<li><code>blockhash(uint blockNumber)</code>: 给定的块的hash值, 只有最近工作的256个块的hash值 </li>
<li><code>block.coinbase</code> (<code>address</code>): 当前块的矿工的地址</li>
<li><code>block.difficulty</code> (<code>uint</code>): 当前块的难度</li>
<li><code>block.gaslimit</code> (<code>uint</code>): 当前块的gaslimit</li>
<li><code>block.number</code> (<code>uint</code>):当前块的数量</li>
<li><code>block.timestamp</code> (<code>uint</code>):当前块的时间戳，注：不要依赖于<code>block.timestamp</code>，<code>now</code>和<code>blockhash</code>用作随机性的来源，除非你知道你在做什么。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">contract Academy&#123;</span><br><span class="line">    uint public this_moment &#x3D; block.timestamp;</span><br><span class="line">    uint public block_number &#x3D; block.number;</span><br><span class="line">    uint public difficulty &#x3D; block.difficulty;</span><br><span class="line">    uint public gaslimit &#x3D; block.gaslimit;</span><br><span class="line">    address public coinbase &#x3D; block.coinbase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/17.png"></p>
<p>在这里，由于是在JS VM上跑的，所以block_number并不是真实的。</p>
<h4 id="msg系列"><a href="#msg系列" class="headerlink" title="msg系列"></a>msg系列</h4><ul>
<li><p><code>msg.data</code>(<code>bytes</code>): 完整的calldata </p>
</li>
<li><p><code>msg.sender</code> (<code>address</code>): 消息的发送者（当前调用）</p>
</li>
<li><p><code>msg.value</code> (<code>uint</code>): 和消息一起发送的wei的数量</p>
<ul>
<li>```solidity<br>function sendEther() public payable{<pre><code>    sendValue = msg.value;
</code></pre>}</li>
</ul>
</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li><p><code>now</code> (<code>uint</code>): 当前块的时间戳（<code>block.timestamp</code>的别名）</p>
</li>
<li><p><code>gasleft() returns (uint256)</code>: 剩余 gas </p>
<ul>
<li>```solidity<br>function howMuchGas() public view returns(uint){<pre><code>    uint start = gasleft();
    uint j = 1;
    for (uint i = 1;i&lt;20;i++){
            j*=1;
    }
    uint end = gasleft();
    return start-end;
</code></pre>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    通过&#96;gasleft()&#96;我们可以 获取一段代码消耗了多少gas</span><br><span class="line"></span><br><span class="line">    &lt;img src&#x3D;&quot;.&#x2F;Solidity初识&#x2F;18.png&quot;  &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">- &#96;tx.gasprice&#96; (&#96;uint&#96;):交易的gas价格</span><br><span class="line">- &#96;tx.origin&#96; (&#96;address&#96;):交易的发送者（全调用链）</span><br><span class="line">- &#96;assert(bool condition)&#96;: abort execution and revert state changes if condition is &#96;false&#96; (用于内部错误)</span><br><span class="line">- &#96;require(bool condition)&#96;: abort execution and revert state changes if condition is &#96;false&#96; (用于输入错误或外部组件的错误)</span><br><span class="line">- &#96;require(bool condition, string message)&#96;: abort execution and revert state changes if condition is &#96;false&#96; (用于输入错误或外部组件的错误). 并提供错误信息.</span><br><span class="line">- &#96;revert()&#96;: 中止执行并还原状态更改</span><br><span class="line">- &#96;revert(string message)&#96;:中止执行并还原状态更改，提供解释字符串</span><br><span class="line">- &#96;blockhash(uint blockNumber) returns (bytes32)&#96;: : 给定的块的hash值, 只有最近工作的256个块的hash值</span><br><span class="line">- &#96;keccak256(...) returns (bytes32)&#96;:计算（紧凑排列的）参数的 Ethereum-SHA3 hash值</span><br><span class="line">- &#96;sha3(...) returns (bytes32)&#96;: an alias to &#96;keccak256&#96;</span><br><span class="line">- &#96;sha256(...) returns (bytes32)&#96;: 计算（紧凑排列的）参数的SHA256 hash值</span><br><span class="line">- &#96;ripemd160(...) returns (bytes20)&#96;:计算 256个（紧凑排列的）参数的RIPEMD</span><br><span class="line">- &#96;ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)&#96;: 椭圆曲线签名公钥恢复，错误时返回0</span><br><span class="line"></span><br><span class="line">- &#96;this&#96; (current contract’s type): 当前合约，在地址上显式转换</span><br><span class="line"></span><br><span class="line">- &#96;super&#96;: 在层次关系上一层的合约</span><br><span class="line"></span><br><span class="line">- &#96;selfdestruct(address recipient)&#96;: 销毁当前的合约，将其资金发送到指定&#96;address&#96;</span><br><span class="line"></span><br><span class="line">- &#96;suicide(address recipient)&#96;: a deprecated alias to &#96;selfdestruct&#96;</span><br><span class="line"></span><br><span class="line">- &#96;&lt;address&gt;.balance&#96; (&#96;uint256&#96;): address地址中的账户余额（以wei为单位）</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;solidity</span><br><span class="line">    &#x2F;&#x2F; 当前合约的剩余额(单位是wei)</span><br><span class="line">    function getBalance() public view returns(uint) &#123;</span><br><span class="line">    		return address(this).balance</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><code>&lt;address&gt;.send(uint256 amount) returns (bool)</code>: 将一定量wei发送给address地址，若失败返回<code>false</code>。</li>
<li><code>&lt;address&gt;.transfer(uint256 amount)</code>: 将一定量wei发送给address地址，若失败抛出异常。</li>
</ul>
<h3 id="Contract’s-Address-and-Balance-Payable-Receive-and-Fallback-Functions"><a href="#Contract’s-Address-and-Balance-Payable-Receive-and-Fallback-Functions" class="headerlink" title="Contract’s Address and Balance Payable, Receive and Fallback Functions"></a>Contract’s Address and Balance Payable, Receive and Fallback Functions</h3><p>在学习以太坊的时候，我们知道账户也分为两类：外部账户和 合约账户</p>
<ul>
<li>外部账户(EOAs) 由公钥-私钥对 控制，它拥有私钥，没有相关代码，其codeHash为空。</li>
<li>合约账户由交易类型、消息类型进行创建，由代码控制，简称CA，它没有私钥，其codeHash<strong>非空</strong>。</li>
</ul>
<p>因此，我们需要去理解的是，合约也是一种账户，也有它自己的地址(在部署的时候生成)。因此，合约也可以接收以太币、支付以太币。</p>
<p>但是需要注意，有两种合约地址类型：plain和payable。前者我们无法向其发送以太币，后者我们可以向其发送以太币。</p>
<p>同时，我们也要知道 address是一种特殊的变量类型，他有很多成员可供调用：</p>
<ul>
<li><p><code>balance</code>： 余额</p>
</li>
<li><p><code>transfer()</code>: 是一种最安全的方法用于发送ETH</p>
</li>
<li><p><code>send()</code> :类似于低配版的transfer，当执行失败的时候，合约并不会停止，而且send会返回false。<code>transfer()</code> 和 <code>send()</code> 只有 payable address才可以使用</p>
</li>
</ul>
<h4 id="payable-functions-and-contract-balance"><a href="#payable-functions-and-contract-balance" class="headerlink" title="payable functions and contract balance"></a>payable functions and contract balance</h4><p>只有当payable function被定义了，这个合约才可以收取ETH并有ETH余额。</p>
<p>一个合约可以通过多种方法获取ETH:</p>
<ul>
<li>用外部账户(EOA) 向一个合约地址转ETH。在这种情况下，合约至少需要定义<code>receive()</code>或者<code>fallback()</code>函数中的一个<ul>
<li>fallback函数的性质如下：<ul>
<li><strong>三无函数</strong>。没有名字、没有参数、没有返回值。</li>
<li><strong>替补函数</strong>。如果在一个对合约调用中，没有其他函数与给定的函数标识符匹配fallback会被调用． 或者在没有 receive 函数时，而没有提供附加数据对合约调用，那么fallback 函数会被执行。</li>
<li><strong>收币函数</strong>。通过钱包向一个合约转账时，会执行Fallback函数，这一点很有用。</li>
<li>fallback　函数始终会接收数据，但为了同时接收以太币，必须标记为　<code>payable</code> 。</li>
</ul>
</li>
<li>receive函数性质如下：<ul>
<li>一个合约最多有一个 <code>receive</code> 函数, 声明函数为： <code>receive() external payable { ... }</code></li>
<li>不需要 <code>function</code> 关键字，也没有参数和返回值并且必须是　<code>external</code>　可见性和　<code>payable</code> 修饰． 它可以是 <code>virtual</code> 的，可以被重载也可以有 修改器modifier 。</li>
<li>在对合约没有任何附加数据调用（通常是对合约转账）时会执行 <code>receive</code> 函数。如果receive函数不存在，但是有fallback函数。那么在进行纯以太币转账的时候，fallback会被调用</li>
<li>如果两个函数都没有，这个合约就没法通过常规的转账交易接收以太币（会抛出异常）．</li>
</ul>
</li>
</ul>
</li>
<li>调用payable function，并在那个交易中附带着发送ETH</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">contract Deposit&#123;</span><br><span class="line">        receive() external payable&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fallback() external payable&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function getBalance() public view returns(uint)&#123;</span><br><span class="line">            return address(this).balance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了调试这个合约，我们需要将其在以太坊测试网络上进行部署：上链之后，我们看到这个合约地址已经生成了。</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/19.png"></p>
<p>在Remix上，我们可以调用getBalance来看合约账户的余额，由于没有为其转账，因此余额为零</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/20.png"></p>
<p><strong>方式1: 外部账户给合约账户直接转账</strong></p>
<p>现在，我到 <a href="https://www.myetherwallet.com/" target="_blank" rel="noopener">MEW</a> 网站上又注册了一个账号，并向这个合约地址转账了0.2个ETH，然后，我们就可以看到</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/22.png"></p>
<p><strong>调用合约内部的payable function</strong></p>
<p>当然，我们也可以采取第二种方式调用合约内部的 payable function来对合约进行转账。</p>
<p>首先我们要创建一个payable function:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function sendEther() public payable&#123;</span><br><span class="line">		uint x;</span><br><span class="line">		x++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们需要在value中设置需要转账的钱， 1Finney = 0.001ETH</p>
<p>点击sendEther按钮之后，就会转接到metamask界面进行转账操作了。</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/23.png"></p>
<h3 id="Accessing-the-Contract’s-Balance"><a href="#Accessing-the-Contract’s-Balance" class="headerlink" title="Accessing the Contract’s Balance"></a>Accessing the Contract’s Balance</h3><p>前面我们学习了如何向一个合约转账，现在我们要来学如何获取一个合约账户的余额，并向其它合约账户、外部账户转账。</p>
<p>为此，我们要设计一个transfer函数用来实现账户之间的转账。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function transferEther(address payable recipient,uint amount)public returns(bool)&#123;</span><br><span class="line">    if(amount &lt;&#x3D; getBalance())&#123;</span><br><span class="line">        recipient.transfer(amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>部署以后我们往这个账户中转一些以太币以供后续测试用。然后，我们要给上面的那个合约转账的话，我们只需在transferEther里面输入目标地址和转账数目即可。</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/25.png"></p>
<p>值得注意的是，这仅仅涉及合约与合约之间的转账，但是转账交易需要消耗一定的燃料，这仍然是需要EOA来支付的。</p>
<h3 id="Protecting-the-Contract’s-Balance"><a href="#Protecting-the-Contract’s-Balance" class="headerlink" title="Protecting the Contract’s Balance"></a>Protecting the Contract’s Balance</h3><p>现在有一个问题，就是说我们这个transferEther函数时完全公开的，外部的人只要能获取合约地址就可以调用这个函数，因此是非常不安全的。因此对一个合约我们要保护好其余额.</p>
<p>为此我们可以使用 require 函数，它可以在执行函数逻辑之前做一些检查。这里我们首先创建一个owner状态变量，然后为其创建构造函数并为其赋值。因此，当这个合约被部署的时候，owner就会被设定为部署者的账号。然后，当要调用transferEther函数的时候，会调用<code>require(owner == msg.sender)</code> 进行核查，如果调用者不是owner，那么就会直接返回false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">contract Deposit&#123;</span><br><span class="line">        address public owner;</span><br><span class="line"></span><br><span class="line">        constructor()&#123;</span><br><span class="line">            owner &#x3D; msg.sendEther;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        receive() external payable&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        fallback() external payable&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function getBalance() public view returns(uint)&#123;</span><br><span class="line">            return address(this).balance;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        function sendEther() public payable&#123;</span><br><span class="line">        		uint x;</span><br><span class="line">        		x++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        function transferEther(address payable recipient,uint amount)public returns(bool)&#123;</span><br><span class="line">            require(owner &#x3D;&#x3D; msg.sender,&quot;Transfer failed ,you are not the owner&quot;);</span><br><span class="line">            if(amount &lt;&#x3D; getBalance())&#123;</span><br><span class="line">                recipient.transfer(amount);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以来做个实验, 我们用账户1部署好合约之后，切换到账户2，然后进行转账活动</p>
<h3 id="Variables-and-Functions-Visibility-Private-Public-Internal-External"><a href="#Variables-and-Functions-Visibility-Private-Public-Internal-External" class="headerlink" title="Variables and Functions Visibility Private, Public, Internal, External"></a>Variables and Functions Visibility Private, Public, Internal, External</h3><p>函数类型分为<code>internal</code> 和<code>external</code>, 标记有<code>internal</code>函数类型只能引用当前contract中的函数，标记有<code>external</code>函数类型可以应用定义在其他contract中的函数。</p>
<p>除此之外，还有一个<code>payable</code> 修饰词 ，如果在函数中涉及到以太币的转移，需要使用到payable关键词。意味着可以在调用这笔函数的消息中附带以太币。可以参考<a href="https://blog.51cto.com/u_13784902/2321571" target="_blank" rel="noopener">这篇博客</a></p>
<p>对于函数和状态变量，有四种类型的可见性。</p>
<ul>
<li><p>public</p>
<ul>
<li>该函数可以在内部（从同一合约内）和外部（从其他合约或EOA账户）调用。</li>
<li>创建一个函数，默认为public</li>
<li>一个getter被自动创建为公共变量。它们可以很容易地从dApps中访问。</li>
</ul>
</li>
<li><p>private</p>
<ul>
<li>私有函数和变量只在它们所定义的合约中可用（不在其他合约中：派生或次生）。Private是Internal的一个子集。</li>
<li>它们只能通过getter函数在当前合约中被访问。</li>
</ul>
</li>
<li><p>internal</p>
<ul>
<li>函数只能从它们所定义的合约中和派生合约中访问。EOA是无法访问的</li>
<li>对于状态变量来说，默认是internal的,外部无法访问，但它们可以在当前合约和派生合约中被访问。</li>
</ul>
</li>
<li><p>external</p>
<ul>
<li><p>该函数是合约接口的一部分，<strong>只能</strong>从<strong>其他合约</strong>或<strong>使用交易的EOA账户</strong>访问。它也是public的。</p>
</li>
<li><p>External不适用于状态变量</p>
</li>
</ul>
</li>
</ul>
<p>现在我们来看一些例子：</p>
<p>在这里我们定义了两个状态变量，x是public的，y是默认internal的</p>
<ul>
<li>get_y函数，是public的可以返回成员变量 y</li>
<li>f1函数，是private的，只能在合约A中调用，其他账户一概不能调用</li>
<li>f2函数，是public的，但是在public函数中可以调用private函数，因为这是在合约A里面</li>
<li>f3函数，是internal的，可以在合约A中调用，也可以在合约A的派生合约中调用。但其他账户不能调用</li>
<li>f4函数，是external的，只能在外部调用，合约A内部无法调用f4，同样也无法在合约A的派生合约中调用f4</li>
<li>B合约，这里使用了类似于继承的思想，用<code>B is A</code> 表示继承，在B合约中，可以调用f2和f3，f1和f4是无法被调用的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    int public x &#x3D; 10;</span><br><span class="line">    int y &#x3D; 20;</span><br><span class="line"></span><br><span class="line">    function get_y() public view returns (int)&#123;</span><br><span class="line">        return y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function f1() private view returns(int)&#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function f2() public view returns(int)&#123;</span><br><span class="line">        int a;</span><br><span class="line">        a &#x3D; f1();</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function f3() internal view returns(int)&#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function f4() external view returns(int)&#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">contract B is A&#123;</span><br><span class="line">    int public xx &#x3D; f3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们部署以后，发现在合约外，是无法调用f1、f3的。</p>
<p><img src="/2022/04/08/Solidity%E5%88%9D%E8%AF%86/26.png"></p>
<p>最后，我们试一下在合约里面部署一个合约，然后调用内部合约的函数。在合约C中我们创建了一个新的A类型的合约。我们发现，可以调用external函数(f4)和public函数(f2)，但是无法调用private函数(f1)和internal函数(f3)</p>
<p>因此我们知道，就算在合约中创建的新合约，也是无法调用新合约中的private和internal函数的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">contract C&#123;</span><br><span class="line">    A public contract_a &#x3D; new A();</span><br><span class="line">    int public xx &#x3D; contract_a.f4();</span><br><span class="line">    int public xxx &#x3D; contract_a.f2();</span><br><span class="line">    &#x2F;&#x2F; int public y &#x3D; contract_a.f1();</span><br><span class="line">    &#x2F;&#x2F; int public yy &#x3D; contract_a.f3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/04/03/AI-Adversarial/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/03/AI-Adversarial/" class="post-title-link" itemprop="url">AI-Adversarial</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-03 15:59:44" itemprop="dateCreated datePublished" datetime="2022-04-03T15:59:44+08:00">2022-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-07 14:39:56" itemprop="dateModified" datetime="2022-04-07T14:39:56+08:00">2022-04-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="搜索树1-博弈"><a href="#搜索树1-博弈" class="headerlink" title="搜索树1:  博弈"></a>搜索树1:  博弈</h1><h3 id="博弈的类型和区分axes"><a href="#博弈的类型和区分axes" class="headerlink" title="博弈的类型和区分axes"></a>博弈的类型和区分axes</h3><ul>
<li>Deterministic or stochastic? 象棋是确定性的、足球是不确定的</li>
<li>One, two, or more players? 玩家数量</li>
<li>Zero sum? 零和、协同合作（例如王者荣耀的队友）</li>
<li>Perfect information (can you see the state)? 完整的信息（例如整个状态和棋子分布）是否都能完全观察到</li>
</ul>
<h3 id="Deterministic-Games-确定性的博弈"><a href="#Deterministic-Games-确定性的博弈" class="headerlink" title="Deterministic Games 确定性的博弈"></a>Deterministic Games 确定性的博弈</h3><ul>
<li><p>状态 States: $S$ (start at $s_0$)</p>
<p>例如下象棋中棋子的分布</p>
</li>
<li><p>玩家 Players: $P={1…N}$ (usually take turns)</p>
<p>代表玩家的个数</p>
</li>
<li><p>行为 Actions: $A$ (may depend on player / state)</p>
</li>
<li><p>转移函数 Transition Function: $S\times A \rightarrow S$</p>
<p>从状态出发经过相应的行为可以到达的一个新的状态</p>
</li>
<li><p>是否到达最终状态 Terminal Test: $S\rightarrow {\text{true},\text{false}}$</p>
<p>一个终止状态的节点，未必最优。</p>
</li>
<li><p>最终效用值 Terminal Utilities: $S\times P \rightarrow R$</p>
<p>得分或者奖励值</p>
</li>
<li><p>策略<strong>policy</strong>: 智能体处于某种状态时该发出的行为，从状态映射到行为 $S\rightarrow A$</p>
</li>
</ul>
<h3 id="Zero-Sum-Games-零和游戏"><a href="#Zero-Sum-Games-零和游戏" class="headerlink" title="Zero-Sum Games 零和游戏"></a>Zero-Sum Games 零和游戏</h3><ul>
<li><p>Zero-Sum Games：</p>
<p>Agents have opposite utilities (values on outcomes)</p>
<p>多个 agents 拥有恰巧相反的目标，例如两个agent的分别希望最大化/最小化同一个值并不完全是两方的期望的加和是0</p>
</li>
<li><p>General Games:</p>
<p>Agents have independent utilities (values on outcomes)</p>
<p>协同合作等</p>
</li>
</ul>
<h3 id="Adversarial-Search-对抗搜索、博弈搜索"><a href="#Adversarial-Search-对抗搜索、博弈搜索" class="headerlink" title="Adversarial Search 对抗搜索、博弈搜索"></a>Adversarial Search 对抗搜索、博弈搜索</h3><p><img src="/2022/04/03/AI-Adversarial/1.png" alt></p>
<p>上图是 Single-Agent Trees 一个智能体对应的搜索树。左边的状态表示往左移一步，右边的状态表示往右移</p>
<p><strong>Value of a State 状态的价值</strong>：从当前状态出发能够获得的最好效用值 The best achievable outcome (utility) from that state</p>
<p>Non-Terminal States 的状态的价值也是孩子节点状态中最好的value值</p>
<script type="math/tex; mode=display">
V(s) = \max_{s'\in\text{ children(s)}} V(s')</script><p><img src="/2022/04/03/AI-Adversarial/2.png" alt></p>
<p>Adversarial Game Trees。存在对抗，一方走完另一方走。鬼希望吃掉Pacman， Pacman希望吃掉豆子。不同层的目标不一样，轮流希望最大化各自的效用值。通过交替的方式对状态展开。</p>
<h3 id="Minimax-Values：轮流进行min和max的操作"><a href="#Minimax-Values：轮流进行min和max的操作" class="headerlink" title="Minimax Values：轮流进行min和max的操作"></a>Minimax Values：轮流进行min和max的操作</h3><ul>
<li>对Pacman来说 States Under Agent’s Control：希望最大化 Pacman 的收益 ，最大化后继节点的状态价值</li>
</ul>
<script type="math/tex; mode=display">
V(s) = \max_{s'\in\text{successors(s)}}V(s')</script><ul>
<li>对鬼来说States Under Opponent’s Control：希望最小化 Pacman 的收益，最小化后继节点的状态价值</li>
</ul>
<script type="math/tex; mode=display">
V(s) = \min_{s'\in\text{successors(s)}}V(s')</script><p><img src="/2022/04/03/AI-Adversarial/3.png" alt></p>
<h3 id="Adversarial-Search-Minimax-对抗搜索"><a href="#Adversarial-Search-Minimax-对抗搜索" class="headerlink" title="Adversarial Search (Minimax) 对抗搜索"></a>Adversarial Search (Minimax) 对抗搜索</h3><p>是在树上的搜索。计算非terminal的每一个节点对应的Minimax值，蓝色上三角表示希望最大化效用值，红色的下三角表示希望最小化效用值。由孩子节点的效用值得到。</p>
<p><img src="/2022/04/03/AI-Adversarial/4.png"></p>
<p>对每一个给定的状态，希望求它的所有后继的最大/最小值。由于是Minimax问题，对每个希望求最大/最小值的节点来说，它的后继相应的希望求最小/最大值。</p>
<p><img src="/2022/04/03/AI-Adversarial/5.png"></p>
<p>对terminal状态来说，直接返回最终的值。否则分别调用max-value或者min-value函数。</p>
<h3 id="搜索树的提速方式"><a href="#搜索树的提速方式" class="headerlink" title="搜索树的提速方式"></a>搜索树的提速方式</h3><p>我们首先来看看没有剪枝的情况下搜索树得到的结果：</p>
<p><img src="/2022/04/03/AI-Adversarial/7.png"></p>
<p>但是，我们如何减少搜索的次数呢？答：进行剪枝</p>
<p>为了提升搜索树的搜索速度，我们可以对其进行 $\alpha-\beta$ 剪枝，其中：</p>
<ul>
<li>$\alpha:$  Max’s best option on path to root , 即 $\alpha$ 是上限</li>
<li>$\beta:$  Min’s best option on path to root，即$\beta$ 是下限 </li>
</ul>
<p>和普通搜索树算法的区别就在于引入了$\alpha,\beta$ 两个值</p>
<p><img src="/2022/04/03/AI-Adversarial/8.png"></p>
<p>我们结合具体的例子来看：</p>
<p>首先，我们还是将最左边的节点的最小值3计算出来，此时根节点的值暂且为3，即$\alpha=3$；然后，我们需要计算中间节点的值, 为此我们需要遍历其子节点，当我们读取到第一个子节点为2的时候，那么不管后面的孩子节点的值是大于2还是小于2，中间这个节点的值一定是小于等于2的。而且2已经比根节点3小了，由于根节点求的是max操作，因此当我们读取到2的时候，其实已经不需要再去读取后面的孩子节点了，这棵子树相当于被废弃了。</p>
<p>也就是说，在这一层因为求得是 min值，使用的是min-value函数， 因此当看到$ 2=v&lt;\alpha=3$ 的时候，就可以直接范围 $v$ 了，完成剪枝</p>
<p>对于最右边这颗子树，首先读取到的是14，14是大于根节点3的，但我们并没法判断后面是否有比3小的数，因此我们无法进行剪枝，仍然需要读取。</p>
<p>剪枝后的搜索树如下图所示：</p>
<p><img src="/2022/04/03/AI-Adversarial/6.png"></p>
<h4 id="Quiz"><a href="#Quiz" class="headerlink" title="Quiz"></a>Quiz</h4><ol>
<li><img src="/2022/04/03/AI-Adversarial/9.png"></li>
</ol>
<p>最左边的孩子都需要遍历的，得到$\alpha=8$ ，右孩子的第一个数值是$4&lt;\alpha$ ，因此可以进行剪枝，直接返回4</p>
<ol>
<li><p><img src="/2022/04/03/AI-Adversarial/11.png"></p>
</li>
</ol>
<p>结果：</p>
<p><img src="/2022/04/03/AI-Adversarial/10.png"></p>
<ol>
<li>首先，遍历最左的这颗子树，得到10和6的最大值为10，因此设定了$\beta = 10$ ，</li>
<li>读取f节点之后，发现等于100，是大于$\beta=10$的，因此，可以直接剪枝</li>
<li>因此得到了节点B=10，同时可以得到 $\alpha = 10$</li>
<li>读取右边的子树，发现F节点的值是2，而$2\leq \alpha=10$ ，因此直接可以剪枝，G节点可以不去探索了</li>
</ol>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>$\alpha-\beta$ 剪枝的性质：</p>
<ol>
<li>中间节点的值可能是错误的。</li>
</ol>
<p>比如说下图，通过左子树，得到$\alpha=10$ , 然后扫描右边的子树，发现左孩子满足 $10\leq \alpha$ ，因此直接返回。但是，事实上左子树的根的真实值应该等于0，这里还没有读取到0就被剪枝了，因此可能是错误的</p>
<p><img src="/2022/04/03/AI-Adversarial/12.png"></p>
<ol>
<li>合适的叶子结点的顺序可以提升搜索树的速度。因为如果是按从小到大的顺序排列的话，可能读取一个叶子就可以完成剪枝操作；但是如果按照从大到小的顺序来排列，可能就需要读完所有叶子结点。 <ul>
<li>这样可以降低一点时间复杂度，但是对于象棋这种搜索空间特别大的情况，使用$\alpha-\beta$剪枝还是不够的</li>
</ul>
</li>
</ol>
<h3 id="Resource-Limits"><a href="#Resource-Limits" class="headerlink" title="Resource Limits"></a>Resource Limits</h3><p><img src="/2022/04/03/AI-Adversarial/13.png" style="zoom:50%;"></p>
<p><strong>问题</strong>：  在现实情况中，很难沿着这棵树去搜索叶子结点</p>
<p><strong>解决办法</strong>：除了$\alpha-\beta$ 剪枝之外，还可以限制搜索的深度。比如上面这颗树，我们可以只搜索到第二层后就停止。这时候就没有中间节点的效用值了。那么怎么得到第二层的值?</p>
<p>我们可以引入一个 Evaluation Function，他可以估计中间节点的效用值，如上图所示。</p>
<p>因此，我们引入的Evaluation Function的估计精度就非常重要了，如果估计完全准确，那么就不需要再增加接下来几层节点的访问开销了。</p>
<p><strong>例子</strong>：在象棋比赛中，假设我们有100秒，每秒可以探索1万个节点。因此，每回合我们可以探索 1 million 的节点。借此我们大致可以再搜索树里面探索8层，这已经可以得到很好的结果了。</p>
<p>同时我们要知道，限制层数的搜索方式，和层数的多少有着密切关系。搜索的层数越深，那么非叶子结点的估计也就会越准确，越有可能返回真实的结果。</p>
<h4 id="Evaluation-Functions"><a href="#Evaluation-Functions" class="headerlink" title="Evaluation Functions"></a>Evaluation Functions</h4><p>理想的Evaluation Function可以返回完全正确的估计</p>
<p>比如说，我们可以采用线性加和的方式对当前状态的效应值进行估计</p>
<script type="math/tex; mode=display">
Eval(s) = w_1f_1(s) + w_2f_2(s)+\cdots+w_nf_n(s)</script><p>举个例子，我们以象棋为例，我们可以把$f_1(s)$ 设置为 白色queen的数量减去黑色queen的数量，把$f_2(s)$  设置为白色马的数量减去黑色马的数量，以此类推</p>
<p><img src="/2022/04/03/AI-Adversarial/14.png" style="zoom:50%;"></p>
<p>当然，也可以用神经网络来作为Evaluation Function</p>
<h4 id="Depth-Matters"><a href="#Depth-Matters" class="headerlink" title="Depth Matters"></a>Depth Matters</h4><p>首先我们要明白，Evaluation并不是一直准确的。但是随着Evaluation所在的层数的加深，其估计的质量也就会越高。最后，Evaluation可以对特征复杂度和计算复杂度做一个推导，因为如果Evaluation很准，那么就可以剩下很多计算，但是如何构建准确的Evaluation的工作量就要上升了</p>
<h5 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h5><p>我们看到如果只探索两层的话，pacman的动作如下所示：</p>
<p><img src="/2022/04/03/AI-Adversarial/1.gif"></p>
<p>我们看到，由于pacman并不知道之后几步的行踪，因此被鬼给吃了</p>
<p>但是如果把探索层数扩大到10层，那么pacman的行动如下所示：</p>
<p><img src="/2022/04/03/AI-Adversarial/2.gif"></p>
<p>由于Pacman掌握了更多信息，因此鬼捉不到pacman，但pacman可以吃到果子。</p>
<h5 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h5><p>我们再来看一个例子，下面这个pacman一直在踱步，但是始终没有下去吃果子，这是为什么呢？这和我们设计的Evaluation有关</p>
<p><img src="/2022/04/03/AI-Adversarial/3.gif"></p>
<p>由于我们只考虑了两层，我们将搜索树全部画出来看看：</p>
<p><img src="/2022/04/03/AI-Adversarial/15.png"></p>
<p>假设吃到果子后可以加上10分那么上面搜索树的值为：</p>
<p><img src="/2022/04/03/AI-Adversarial/16.png"></p>
<p>那么对于根节点来说，往左走和往右走的Evaluation是一样的，往左往右都可以，所以一直在左右徘徊。</p>
<p>因此我们需要更准确的Evaluation，我们看到叶子结点中，最左边的情况实际上比最右边的情况更加接近果子，因此我们不妨将这个状态设置为11，那么pacman的行动轨迹就会变成先往左走吃掉果子，再往右走吃掉右边的果子，如下所示：</p>
<p><img src="/2022/04/03/AI-Adversarial/4.gif"></p>
<h1 id="搜索树-Part2-Uncertainty-and-Utilities"><a href="#搜索树-Part2-Uncertainty-and-Utilities" class="headerlink" title="搜索树 Part2: Uncertainty and Utilities"></a>搜索树 Part2: Uncertainty and Utilities</h1><p>我们要让自己赢一个游戏的话，肯定需要让自己的利益最大化，由于游戏是存在不确定性的，因此我们需要计算整个游戏的期望。</p>
<h2 id="Expectimax-Search"><a href="#Expectimax-Search" class="headerlink" title="Expectimax Search"></a>Expectimax Search</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>如下图两个游戏，对于画圈画叉来说，游戏下一步的状态是确定的，因此可以用 MinMax Tree来做搜索，但是对于掷骰子，下一步是什么状态是不确定的。</p>
<p><img src="/2022/04/03/AI-Adversarial/17.png"></p>
<p>如上图所示，因此我们把中间层的倒三角替换成圆形了，圆形代表什么？其实圆形就是引入概率的、引入随机性的博弈。比如说两条边的概率都是0.5的话，右边的节点的值就是$\frac{1}{2}\cdot (9+100)$ </p>
<p>由此，这颗搜索树从 Minmax Search 变成了 Expectimax Search。当我们考虑随机性的时候，就不去靠考虑最大值最小值了，而是考虑期望和均值。实际上，Expectimax在日常生活中很常见。比如说投色子，又比如说在pacman中鬼是随机游走的，不再是你死我亡型的鬼了。</p>
<h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><p>那么Expectimax Search是如何计算的？</p>
<p><img src="/2022/04/03/AI-Adversarial/18.png"></p>
<p>首先，对于chance节点，求的不再是最小值，而是 期望效用值。他和min的功能是一样的，只是结果是不确定的。</p>
<p>同时，max节点还是会计算chance节点的最大值，这和minimax search中的max节点功能一致</p>
<p>我们可以看一下Minimax search和 Expectimax search的区别</p>
<ul>
<li>Minimax Search</li>
</ul>
<p><img src="/2022/04/03/AI-Adversarial/5.gif"></p>
<ul>
<li>Expectimax Search</li>
</ul>
<p><img src="/2022/04/03/AI-Adversarial/6.gif"></p>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p>现在我们来看一下Expectimax Search的伪代码：</p>
<ul>
<li>value函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">value</span><span class="params">(state)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> the state <span class="keyword">is</span> a terminal state: <span class="keyword">return</span> the state’s utility</span><br><span class="line">    <span class="comment"># 子节点是max-value节点，那么调用max-value函数</span></span><br><span class="line">    <span class="keyword">if</span> the next agent <span class="keyword">is</span> MAX: <span class="keyword">return</span> max-value(state)</span><br><span class="line">    <span class="comment"># 子节点是exp-value节点，那么调用exp-value函数</span></span><br><span class="line">    <span class="keyword">if</span> the next agent <span class="keyword">is</span> EXP: <span class="keyword">return</span> exp-value(state)</span><br></pre></td></tr></table></figure>
<ul>
<li>max-value函数, 这和minimax search的max节点是类似的</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span>-<span class="title">value</span><span class="params">(state)</span>:</span></span><br><span class="line">    initialize v = -∞</span><br><span class="line">    <span class="keyword">for</span> each successor of state:</span><br><span class="line">    		v = max(v, value(successor))</span><br><span class="line">    <span class="keyword">return</span> v</span><br></pre></td></tr></table></figure>
<ul>
<li>exp-value函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>-<span class="title">value</span><span class="params">(state)</span>:</span></span><br><span class="line">    initialize v = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> each successor of state:</span><br><span class="line">      <span class="comment"># 由于chance节点的每条边都是由概率的，所以要先获取概率然后累加计算节点的值</span></span><br><span class="line">        p = probability(successor)</span><br><span class="line">    		v += p * value(successor)</span><br><span class="line">    <span class="keyword">return</span> v</span><br></pre></td></tr></table></figure>
<h3 id="Expectimax可以剪枝吗"><a href="#Expectimax可以剪枝吗" class="headerlink" title="Expectimax可以剪枝吗"></a>Expectimax可以剪枝吗</h3><p>首先，我们来看看不剪枝的情况下，Expectimax Search计算的一个例子：</p>
<p><img src="/2022/04/03/AI-Adversarial/19.png"></p>
<p>但是对于Expectimax来说，情况就变得很不一样了。假设我们遍历了最右边的子树，得到了其值为8，令$\alpha=8$，那么我们可以在遍历中间子树的第一个叶子(其值为2)之后就能对其进行剪枝吗？</p>
<p>显然是不行的，因为虽然每条边的概率是一样的，但是并不能确定叶子的值是多少，可能2后面的叶子是1亿，那么显然中间的chance节点的值是大于8的</p>
<p>因此Expectimax Search是不能做剪枝的，但如果在知道bound的情况下，还是可以做剪枝的。比如说，我知道2后面两个叶子的值都是小于10的，那么就可以做剪枝了</p>
<h3 id="Expectimax-可以做限高吗"><a href="#Expectimax-可以做限高吗" class="headerlink" title="Expectimax 可以做限高吗"></a>Expectimax 可以做限高吗</h3><p><img src="/2022/04/03/AI-Adversarial/20.png"></p>
<p>可以限高，但是比minimax更为复杂，因为其中涉及到概率相关的问题。</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>在一个游戏中，如果对手在80%的时间里采用深度为2的minimax search，剩余20%的时间在随机游走，应该用什么？Expectimax Search</p>
<p>但这时候，chance节点的两条边的权重就不一样了。在80%的情况下，是求min的操作；在20%的情况下随机进行。通过这种方式去模拟可以求得针对该问题的概率值。但这种方法速度很慢，需要访问到最底部的叶子结点。</p>
<h2 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h2><p>在设计智能体的时候，常常会对日常生活做一个建模，两个极端的方向就是：过度乐观和过度悲观</p>
<ul>
<li>乐观派是说，前面就算有鬼我也要走过去</li>
<li>悲观派是说， 前面就算是无害的小动物我也不敢走过去</li>
</ul>
<p>我们用pacman为例：下面有四种情况，博弈的鬼和随机游走的鬼与Minimax和Expectimax两两搭配，我们来看一下结果是什么样的。</p>
<p><img src="/2022/04/03/AI-Adversarial/21.png"></p>
<ul>
<li>Expectimax Pacman——Random Ghost</li>
</ul>
<p><img src="/2022/04/03/AI-Adversarial/7.gif"></p>
<ul>
<li>Adversarial Ghost —— Minimax Pacman(对抗性的鬼和对抗性的pacman)</li>
</ul>
<p><img src="/2022/04/03/AI-Adversarial/8.gif"></p>
<p>我们看到，因为鬼是对抗性的，所以一直在追着pacman跑，pacman则已知躲着鬼，然后吃到了果子</p>
<ul>
<li>Adversarial Ghost —— Expectimax Pacman(对抗性的鬼和Expectimax 的pacman)</li>
</ul>
<p><img src="/2022/04/03/AI-Adversarial/9.gif"></p>
<p>我们看到鬼是Adversarial 的，非常具有攻击性。而pacman考虑了随机性后，有一定几率躲掉鬼，但不能保证每次都可以逃脱。视频中是赢了，但不一定下次还能赢。</p>
<ul>
<li>Random Gost——Minimax Pacman</li>
</ul>
<p><img src="/2022/04/03/AI-Adversarial/10.gif"></p>
<p>我们看到在这种情况下，只要鬼还在地图的下半部分移动，上面的pacman就非常害怕不敢轻举妄动。因此，minimax其实是一种过度悲观的方式。</p>
<p>最后 我们来看一下，玩五次游戏以后，上面四种方式得到的分数：</p>
<p><img src="/2022/04/03/AI-Adversarial/22.png"></p>
<ul>
<li>我们看到，Expectimax对上Random Gost五次都能赢，因为考虑了随机性</li>
<li>Minimax对上Adversarial Ghost，由于Adversarial具有强烈的攻击性，而Minimax又是比较悲观的，因此他虽然赢了5次，但是平均得分不如Expectimax对上Random Ghost</li>
<li><p>Expectimax对上Adversarial Ghost，我们看到只赢了一次，这是因为鬼具有强烈的攻击性，但是Pacman的行动却具有随机性，因此一着不慎就可能被鬼吃掉。</p>
</li>
<li><p>MiniMax 对上Random Ghost，虽然小心翼翼地再走，但是最终还是能赢的</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/03/31/%E4%BA%86%E8%A7%A3Spark/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/31/%E4%BA%86%E8%A7%A3Spark/" class="post-title-link" itemprop="url">了解Spark</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-31 13:08:45" itemprop="dateCreated datePublished" datetime="2022-03-31T13:08:45+08:00">2022-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-09 18:22:54" itemprop="dateModified" datetime="2022-05-09T18:22:54+08:00">2022-05-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="了解Spark"><a href="#了解Spark" class="headerlink" title="了解Spark"></a>了解Spark</h1><p>Spark 最初是基于内存计算的批处理系统，逐步发展成为<strong>内外存同时使用</strong>的批处理系统，并增加了Spark Streaming支持实时流计算，以及Structured Streaming 支持批流融合。</p>
<h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><p>首先我们必须意识到，MapReduce虽然底层透明，部署简单，但是基础算子太少。比如，没有Join算子，需要自己实现。而且，Map段的结果需要先写入到本地磁盘，才能由Reduce来拉取。那么如果有多个MapReduce作业串行执行的话，就会使得数据不断在HDFS中写入读出，严重影响性能。</p>
<p>因此我们可以总结一下MapReduce的局限性：</p>
<ul>
<li>编程框架的表达能力有限，无法直接用Join操作</li>
<li>单个作业中需要Shuffle的数据以阻塞方式传输，磁盘IO开销大、延迟高。因为Shuffle数据需要先写磁盘</li>
<li>多个作业之间衔接设计IO开销，应用程序的延迟高<ul>
<li>特别是迭代计算，因为会导致迭代中间结果反复读写，使得整个应用程序的延迟非常高。</li>
</ul>
</li>
</ul>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>在学MapReduce的时候，其数据结构是简单的键值对。而在Spark里面，数据模型是<strong>RDD(Resilient Distributed Dataset)</strong></p>
<p>RDD 是一个<strong>数据集(Dataset)</strong>: 与MapReduce不同，Spark操作对象是抽象的数据集，而不是文件</p>
<p>RDD是<strong>分布式的(Distributed)</strong>：每个RDD可分成多个分区，每个分区就是一个数据集片段，一个RDD的不同分区可以存到集群中的不同的节点上。</p>
<p>RDD具有<strong>弹性(Resilient)</strong>: 具有可恢复的容错特性，就好比一个弹力球，变形了以后还能恢复。</p>
<h4 id="RDD性质"><a href="#RDD性质" class="headerlink" title="RDD性质"></a>RDD性质</h4><p>RDD是<strong>只读的</strong>记录分区的集合</p>
<ul>
<li>其本质上就是一个只读的对象集合</li>
<li>RDD经创建后，不能进行修改</li>
</ul>
<p>RDD不可变(Immutable)</p>
<ul>
<li>只能通过在其他RDD上执行确定的转换操作(如map、join、group by) 来得到新的RDD, 而不是改变原有的RDD</li>
</ul>
<p>遵循了函数式编程的特性</p>
<ul>
<li>变量的值是不可变的</li>
</ul>
<h3 id="计算模型"><a href="#计算模型" class="headerlink" title="计算模型"></a>计算模型</h3><p>在MapReduce里面其实只有两个算子：Map和Reduce。也就是一个非常简单的<strong>有向无环图</strong>。 但是在Spark中，算子比较多，大致上可以分成三大类：创建类、转换类、行动类</p>
<h4 id="创建类算子"><a href="#创建类算子" class="headerlink" title="创建类算子"></a>创建类算子</h4><p>创建(create)类算子可以从本地内存或外部数据源创建RDD，提供了数据输入的功能</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>创建操作</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>parallelize(seq,[numSlices])</code></td>
<td>从内存集合创建RDD</td>
</tr>
<tr>
<td><code>textFile(path, [minPartitions])</code></td>
<td>读取HDFS兼容的文件系统下的文件来创建RDD</td>
</tr>
<tr>
<td><code>wholeTextFile(path, [minPartitions])</code></td>
<td>读取HDFS兼容文件系统下的文件夹中的所有文件创建RDD</td>
</tr>
<tr>
<td><code>hadoopFile(path,inputFormatClass,keyClass,valueClass,[minPartitions])</code></td>
<td>读取HDFS兼容的文件系统下拥有任意inputFormat的文件来创建RDD</td>
</tr>
</tbody>
</table>
</div>
<h4 id="转换类算子"><a href="#转换类算子" class="headerlink" title="转换类算子"></a>转换类算子</h4><p>转换(Transformation)类算子描述了RDD的转换逻辑，提供对RDD进行变换的功能。现在我们列举一部分：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>转换操作</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>map(func)</code></td>
<td>和MapReduce类似，每个记录都是用func进行转换，返回一个新的RDD</td>
</tr>
<tr>
<td><code>filter(func)</code></td>
<td>对滤除对RDD中的每个记录都是用func后返回值为true的记录，类似于数据库中的过滤</td>
</tr>
<tr>
<td><code>flatMap(func)</code></td>
<td>与map相似，但是对于RDD中的每个记录可以映射0个或多个新的参数，而map是1个</td>
</tr>
<tr>
<td><code>mapPartitions(func)</code></td>
<td>与map类似，但是是对每个分区进行操作</td>
</tr>
<tr>
<td><code>union(otherRDD)</code></td>
<td>两个RDD取并集得到一个新的RDD</td>
</tr>
<tr>
<td><code>intersect(otherRDD)</code></td>
<td>两个RDD取交集得到一个新的RDD</td>
</tr>
<tr>
<td><code>groupByKey([numPartitions])</code></td>
<td>类似于Shuffle，将键值对按键分组，返回一个<code>[K,Iterable&lt;V&gt;]</code> 组成的新RDD</td>
</tr>
<tr>
<td><code>reducedByKey(func,[numPartitions])</code></td>
<td>将键值对按键聚合在一起，对每一个键的所有值使用func，类似于Reduce操作</td>
</tr>
<tr>
<td><code>sortByKey([ascending],[numPartitions])</code></td>
<td>将键值对按键进行排序，返回一个新的RDD</td>
</tr>
<tr>
<td><code>join(otherRDD,[numPartitions])</code></td>
<td>join操作</td>
</tr>
<tr>
<td><code>cogroup(otherRDD,[numPartitions])</code></td>
<td>类似于笛卡尔积的操作</td>
</tr>
</tbody>
</table>
</div>
<h4 id="行动算子Action"><a href="#行动算子Action" class="headerlink" title="行动算子Action"></a>行动算子Action</h4><p>行动算子标志着转换结束，出发DAG生成。有点类似于输出的操作。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>行动操作</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>reduce(func)</code></td>
<td>对RDD中的记录按func聚合，这个func必须满足交换律和结合律</td>
</tr>
<tr>
<td><code>collect()</code></td>
<td>收集RDD中的所有记录到driver中，返回一个Array</td>
</tr>
<tr>
<td><code>count()</code></td>
<td>返回RDD中记录的个数</td>
</tr>
<tr>
<td><code>take(n)</code></td>
<td>返回RDD中的前n个记录</td>
</tr>
<tr>
<td><code>saveAsTextFile(path)</code></td>
<td>将RDD中的记录以文本文件的额形式写入本地文件系统，HDFS等兼容的文件系统</td>
</tr>
<tr>
<td><code>countByKey()</code></td>
<td>按key统计计数，返回一个由<code>[K,long]</code>组成的Map</td>
</tr>
<tr>
<td><code>foreach(func)</code></td>
<td>对RDD中的每个记录都使用func</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Operator-DAG"><a href="#Operator-DAG" class="headerlink" title="Operator DAG"></a>Operator DAG</h4><p>在一个实际操作中，算子肯定不能像MapReduce那样组成一个非常简单的有向无环图，而是一个比较复杂的图,可能如下所示：</p>
<p><img src="/2022/03/31/%E4%BA%86%E8%A7%A3Spark/1.png"></p>
<p>DAG主要以算子的角度来描述整个操作的过程，每一个节点都是一个算子。因此DAG的核心主要是以操作算子为描述对象</p>
<h5 id="物理计算模型"><a href="#物理计算模型" class="headerlink" title="物理计算模型"></a>物理计算模型</h5><p>在分布式架构中，DAG中的操作算子实际上是由若干个实例任务(Task)来实现。</p>
<p><img src="/2022/03/31/%E4%BA%86%E8%A7%A3Spark/3.png"></p>
<p>如上图，每个全都是一个task，一共有22个task</p>
<h4 id="RDD-Lineage"><a href="#RDD-Lineage" class="headerlink" title="RDD Lineage"></a>RDD Lineage</h4><p>上面的DAG是以Operator为顶点、RDD为边的；现在我们可以将RDD作为顶点，Operator作为边，进行一个图的转换，这就是<strong>RDD Lineage</strong>，如下图所示：</p>
<p><img src="/2022/03/31/%E4%BA%86%E8%A7%A3Spark/2.png"></p>
<p>首先，RDD读取外部数据源进行创建</p>
<p>然后，RDD经过了一系列转换操作，每次都会产生不同的RDD，供给下一个转换操作使用。</p>
<p>最后一个RDD经过行动操作进行转换，并输出到外部数据源</p>
<h5 id="物理计算模型-1"><a href="#物理计算模型-1" class="headerlink" title="物理计算模型"></a>物理计算模型</h5><p>用RDD Lineage的角度来看更加清楚，每个Task通常负责处理RDD的一个分区，但事实上对于一个流水线的过程(如分区7-分区9-分区13),我们可以将其简化为一个task</p>
<p><img src="/2022/03/31/%E4%BA%86%E8%A7%A3Spark/4.png"></p>
<h2 id="体系架构"><a href="#体系架构" class="headerlink" title="体系架构"></a>体系架构</h2><h3 id="抽象架构图"><a href="#抽象架构图" class="headerlink" title="抽象架构图"></a>抽象架构图</h3><p><img src="/2022/03/31/%E4%BA%86%E8%A7%A3Spark/5.png"></p>
<p>上图是Spark的抽象架构图。我们看到里面有三种节点</p>
<h4 id="Cluster-Manager"><a href="#Cluster-Manager" class="headerlink" title="Cluster Manager"></a>Cluster Manager</h4><p>cluster manager是集群管理器，负责管理整个系统的资源、监控工作节点。就是说和MapReduce中的Job Tracker本质上是一样的。</p>
<p>Cluster Manager是一个抽象的概念，在部署完成后并没有一个进程叫做cluster manager。而且根据Spark的部署方式的不同，Cluster Manager也不一样</p>
<ul>
<li>在Standalone方式(即不适用Yarn或Mesos等其他资源管理系统)中，集群管理器包含 Master和Worker<ul>
<li>注：这个和MapReduce中的Standalone模式是不一样的，在MR中Standalone代表单机集中式部署</li>
</ul>
</li>
<li>在Yarn方式中集群管理器包括：Resource Manager和Node  Manager</li>
</ul>
<h4 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h4><p>Executor是执行器，负责任务的执行</p>
<p>Executor是运行在工作节点上的一个进程，它启动若干个线程Task或者线程组TaskSet来进行执行任务。</p>
<p>在Standalone部署方式下，Executor进程的名称为：CoarseGrainedExecutorBackend</p>
<p>这和MapReduce不一样，MapReduce中的Task是进程，因此其对资源的消耗往往要高于Spark</p>
<h4 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h4><p>Driver是驱动器，负责启动应用程序的主方法并管理作业运行</p>
<p>Spark的架构实现了资源管理和作业管理两大功能的分离</p>
<ul>
<li>Cluster Manager负责集群资源管理</li>
<li>Driver负责作业管理</li>
</ul>
<p>在MapReduce中，JobTracker既负责资源管理，又负责作业管理</p>
<h3 id="Standalone架构图"><a href="#Standalone架构图" class="headerlink" title="Standalone架构图"></a>Standalone架构图</h3><p>Standalone是不包含Yarn和Mesos的，其架构如下：</p>
<p><img src="/2022/03/31/%E4%BA%86%E8%A7%A3Spark/6.png"></p>
<p>我们将其和抽象架构图作一个比较</p>
<p><img src="/2022/03/31/%E4%BA%86%E8%A7%A3Spark/7.png"></p>
<h4 id="Standalone中的Driver"><a href="#Standalone中的Driver" class="headerlink" title="Standalone中的Driver"></a>Standalone中的Driver</h4><p>从图中我们看出，Standalone架构图中并没有出现Driver，那么Driver在哪里？</p>
<p>从逻辑上来说，Driver是独立于主节点、从节点以及客户端的</p>
<p>但是根据应用程序的Client或Cluster运行方式，Driver会以不同的形式存在</p>
<ul>
<li>Client方式：Driver和客户端以同一个进程存在</li>
<li>Cluster方式：系统将由某一Worker启动一个进程作为Driver</li>
</ul>
<p>客户端提交应用程序时可以选择Client或Cluster方式</p>
<ul>
<li>Standalone Client模式(默认)</li>
</ul>
<p><img src="/2022/03/31/%E4%BA%86%E8%A7%A3Spark/8.png"></p>
<ul>
<li>Standalone Cluster 模式</li>
</ul>
<p><img src="/2022/03/31/%E4%BA%86%E8%A7%A3Spark/9.png"></p>
<p>那么这两者有什么差别呢？</p>
<p>由于我们申请的四台虚拟机都是在同一个云平台中的， 这时候Cluster模式和Client没有什么太大的区别。</p>
<p>只有当客户端和Spark集群的物理距离非常远的时候，那么就应该使用Cluster模式，因为这样内网通信更快。如果使用Client模式，Driver管理不同设备的时候，就需要通过远程网络传输，这时候开销就很大了。</p>
<h4 id="Spark-vs-MapReduce"><a href="#Spark-vs-MapReduce" class="headerlink" title="Spark vs MapReduce"></a>Spark vs MapReduce</h4><p><img src="/2022/03/31/%E4%BA%86%E8%A7%A3Spark/10.png"></p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><img src="/2022/03/31/%E4%BA%86%E8%A7%A3Spark/11.png"></p>
<p>之前我们画的抽象结构图中，在driver部分并没有详细说。其实driver里面存在如上图的结构</p>
<p>首先RDD对象会经过解析器，然后得到一个有向无环图，然后DAG会被拆分成Stage，并交给task调度器去执行。我们可以将其和数据库查询引擎做一个对比，SQL语言经过解析器之后会变成语法树。我们可以把DAG看做是逻辑方面的模型，而Stage则是物理方面的模型</p>
<h3 id="Stage划分"><a href="#Stage划分" class="headerlink" title="Stage划分"></a>Stage划分</h3><h4 id="按依赖关系划分"><a href="#按依赖关系划分" class="headerlink" title="按依赖关系划分"></a>按依赖关系划分</h4><p><img src="/2022/03/31/%E4%BA%86%E8%A7%A3Spark/12.jpeg"></p>
<p>首先我们要搞清楚两种不同的依赖有何区别。宽依赖可以理解为多对多，类似于map reduce中的shuffle过程，窄依赖可以理解为子分区一对一、子分区一对多。</p>
<p>因此，我们可以通过分析各个RDD的偏序关系来生成DAG，再通过分析各个RDD中的分区之间的依赖关系来决定如何划分Stage。</p>
<p>具体划分方法如下：</p>
<ul>
<li>在DAG中进行反向解析，遇到宽依赖就断开</li>
<li>遇到窄依赖就把当前的RDD加入到Stage中</li>
</ul>
<p>比如：还是以展开后的DAG为例，我们看到有明显的两处宽依赖的部分，A与B之间、F与G之间。我们就根据这个将算子划分为三个stage</p>
<p><img src="/2022/03/31/%E4%BA%86%E8%A7%A3Spark/13.png" style="zoom:67%;"></p>
<p>我们把每个stage抽象出来，得到下面这张拓扑图，通过这张图可以还原出原来的DAG。</p>
<p><img src="/2022/03/31/%E4%BA%86%E8%A7%A3Spark/14.png" style="zoom:67%;"></p>
<h4 id="Stage类型"><a href="#Stage类型" class="headerlink" title="Stage类型"></a>Stage类型</h4><p><strong>ShuffleMapStage</strong></p>
<ul>
<li><p>输入/输出</p>
<ul>
<li><p>输入可以是从外部获取数据，也可以是另一个ShuffleMapStage的输出</p>
</li>
<li><p>以Shuffle为输出，作为另一个Stage开始</p>
</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li><p>不是最终的Stage，在它之后还有其他Stage</p>
</li>
<li><p>它的输出一定需要经过Shuffle过程，并作为后续Stage的输入</p>
</li>
<li><p>在一个DAG里可能有该类型的Stage，也可能没有该类型Stage</p>
</li>
</ul>
</li>
</ul>
<p><strong>ResultStage</strong></p>
<ul>
<li><p>输入/输出</p>
<ul>
<li><p>其输入可以是从外部获取数据，也可以是另一个ShuffleMapStage的输出</p>
</li>
<li><p>输出直接产生结果或存储</p>
</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li><p>最终的Stage</p>
</li>
<li><p>在一个DAG里必定有该类型Stage</p>
</li>
</ul>
</li>
</ul>
<p>判断方式也很容易，只要有输出结果的算子如saveAsTextFile，那么这个stage就是ResultStage。 因此，一个DAG含有一个或多个Stage，其中至少含有一个ResultStage</p>
<h3 id="Stage-内部数据传输"><a href="#Stage-内部数据传输" class="headerlink" title="Stage 内部数据传输"></a>Stage 内部数据传输</h3><p><strong>问题是，为什么要将窄依赖尽可能划分在同一个stage里，而在宽依赖的时候将DAG断开</strong>？接下来两节我们就来解决这个问题。</p>
<p>首先Spark和MapReduce是不一样的，他算子很多，自然不可能想MR一样每经过一个算子就将其压入文件系统，让下一个算子读取。因此Spark采用了<strong>流水线</strong>的方式,而不是阻塞方式：</p>
<p><img src="/2022/03/31/%E4%BA%86%E8%A7%A3Spark/15.png" style="zoom:67%;"></p>
<p>如上图，我们把目光聚焦到Stage1，这里有10个分区，如果按照最笨的方法，就需要开启10个task。但事实上，我们可以采用流水线的方式，这样只用开启4个ShuffleMapTask就可以了</p>
<p>那么流水线的过程是不是类似于MapReduce中的Shuffle过程呢？<strong>不同！</strong>，流水线方式不要求物化前序算子的所有计算结果</p>
<p>分区7通过map操作生成的分区9，并不需要物化分区9，而且可以不用等待分区8到分区10这个map操作的计算结束，而是继续进行union操作，得到分区13</p>
<p>如果采用MapReduce中的Shuffle方式，那么意味着分区7、8经map计算得到分区9、10并将这两个分区进行物化之后，才可以进行union</p>
<h3 id="Stage之间数据传输"><a href="#Stage之间数据传输" class="headerlink" title="Stage之间数据传输"></a>Stage之间数据传输</h3><p>这时候我们再来看stage之间的划分依据，发现窄依赖的stage之间用流水线方式很方便，但<strong>在宽依赖的stage之间，采用流水线方式就不适用</strong>了。因此我们就需要在宽依赖的时候断开DAG。</p>
<p>Stage之间的数据传输需要进行Shuffle，该过程与MapReduce中的Shuffle类。</p>
<ul>
<li><p>从Stage层面来看，Shuffle过程可能发生在两个ShuffleMapStage之间，或者ShuffleMapStage与ResultStage之间。</p>
</li>
<li><p>从Task层面来看，该过程表现为两组ShuffleMapTask之间，或一组ShuffleMapTask与一组ResultTask之间的数据传输</p>
</li>
</ul>
<p>下面是两个宽依赖的stage之间的数据传输过程，也就是spark shuffle</p>
<p><img src="/2022/03/31/%E4%BA%86%E8%A7%A3Spark/16.png" style="zoom:67%;"></p>
<p>其过程如下：</p>
<ul>
<li><p>在Shuffle Write阶段，会将数据进行Partition操作，ShuffleMapTask需要将输出RDD的记录按照partition函数划分到相应的bucket当中并<strong>物化到本地磁盘形成ShuffleblockFile</strong>，之后才可以在Shuffle Read阶段被拉取</p>
</li>
<li><p>在Shuffle Read阶段，ShuffleMapTask或ResultTask根据partiton函数读取相应的ShuffleblockFile，存入buffer并进行继续后续的计算 </p>
</li>
</ul>
<p>因此</p>
<ul>
<li>在stage内部的信息传递不需要物化，采用pipeline 的形式</li>
<li>在stage之间的信息传递是需要物化的，且是阻塞的，采用shuffle形式</li>
</ul>
<p>因此Spark相比于MapReduce，其改进也是有限的，特别是在Shuffle过程上，基本没有发生变化。因此从这一点来说，限制了Spark只能是一个批处理系统，而不能成为一个流处理系统</p>
<h3 id="应用与作业"><a href="#应用与作业" class="headerlink" title="应用与作业"></a>应用与作业</h3><p>现在我们对Spark中的应用和作业做一个梳理</p>
<p>Application:  用户编写的Spark应用程序</p>
<p>Job: 一个Job包含多个RDD及作用于响应RDD转换操作，其中最后一个为action</p>
<p>MapReduce VS Spark</p>
<ul>
<li>在MapReduce中，一个应用就是一个作业</li>
<li>Spark中，一个应用可以由多个作业来构成</li>
</ul>
<p><img src="/2022/03/31/%E4%BA%86%E8%A7%A3Spark/17.png" style="zoom:67%;"></p>
<p>那么在Spark中，应用、作业和任务的关系又是什么？</p>
<ul>
<li>从逻辑执行角度<ul>
<li>一个Application = 一个或者多个DAG</li>
<li>一个DAG = 一个或多个Stage</li>
<li>一个Stage = 若干窄依赖的RDD操作</li>
</ul>
</li>
<li>从物理执行角度<ul>
<li>一个Application = 一个或者多个Job(Job = DAG)</li>
<li>一个Job = 一个或者多个TaskSet<ul>
<li>一个Job会分为多组Task，每组Task被称为Stage，或者也被称为TaskSet</li>
</ul>
</li>
<li>一个TaskSet = 多个没有Shuffle关系的Task</li>
<li>一个Task：运行在Executor上的单元。</li>
</ul>
</li>
</ul>
<p>可总结为：</p>
<p><img src="/2022/03/31/%E4%BA%86%E8%A7%A3Spark/18.png" style="zoom:67%;"></p>
<h2 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h2><h3 id="故障类型"><a href="#故障类型" class="headerlink" title="故障类型"></a>故障类型</h3><p>首先，Spark里面每个部分都有可能出现故障。</p>
<ul>
<li>Master故障：可以利用ZooKeeper配置多个Master，但这不再讨论范围之内。</li>
<li>Worker故障</li>
<li>Executor故障</li>
<li>Driver故障： 这个无解，只能重启，因此不在讨论范围之内</li>
</ul>
<p>因此我们主要来解决Worker、Executor出现问题怎么办？主要有三种方式：RDD持久化、故障恢复、检查点</p>
<h3 id="RDD持久化"><a href="#RDD持久化" class="headerlink" title="RDD持久化"></a>RDD持久化</h3><p>由于计算过程中会不断地产生新的RDD， 所以系统不能将所有的RDD都存在内存 。因此， 一旦达到相应存储空间的阈值，Spark会使 用置换算法（例如，LRU）将部分RDD的 内存空间腾出 。如果不做任何声明，这些RDD会被直接丢弃。但是，某些RDD在后续很可能会被再次使用，那么这时候就需要让RDD持久化</p>
<p>在Spark里面提供了RDD持久化的接口</p>
<p><code>persist(StorageLevel)</code></p>
<ul>
<li>接受StorageLevel类型参数，可配置各种级别 </li>
<li>持久化后的RDD将会保留在工作节点的中，可重复使用</li>
</ul>
<p><code>cache()</code>： 缓存</p>
<ul>
<li>相当于<code>persist(MEMORY_ONLY)</code></li>
</ul>
<p>这边提供几个StorageLevel参数及其含义：</p>
<ul>
<li>MEMORY_ONLY： 在JVM中缓存Java的对象。如果内存不足，直接丢弃某些partition </li>
<li>MEMORY_AND_DISK： 在JVM中缓存Java的对象。如果内存不足，则 将某些partitions写入到磁盘中 </li>
<li><p>MEMORY_ONLY_SER： 在内存为每个partition存储一个byte数组，数组 内容为当前partition中Java对象的序列化结果</p>
<ul>
<li>序列化可以理解为对存储空间进行一个压缩</li>
</ul>
</li>
<li><p>MEMORY_AND_DISK_SER： 与MEMORY_AND_DISK类似，但每个分区存 储的是Java对象序列化后组成的byte数组 </p>
</li>
<li>DISK_ONLY: 将每个分区的数据序列化到磁盘中</li>
<li>MEMORY_ONLY_2： 与MEMORY_ONLY相同，但是每个分区备份 到两台机器上 </li>
<li>MEMORY_AND_DISK_2: 与MEMORY_AND_DISK相同，但是每个分区备份到两台机器上</li>
</ul>
<h3 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h3><p> 通常，一个Worker/Executor出了问题，常常是RDD出了问题，因此我们回到RDD Lineage，来看看出了问题后该怎么办？ </p>
<p>根据Lineage的机制， 如果是红色部分丢失，那么就需要重新计算紫色部分。这里宽依赖和窄依赖就有所不同了，对于窄依赖，只要能拿到其对应的一两个父RDD，就可以还原出来了。但是对于宽依赖，其涉及到的父RDD就很多了。</p>
<p>因此宽依赖的恢复代价高、窄依赖的恢复代价低。</p>
<p><img src="/2022/03/31/%E4%BA%86%E8%A7%A3Spark/19.png" style="zoom:67%;"></p>
<p>因此，基于RDD Lineage的恢复可被总结如下：</p>
<ul>
<li>利用RDD Lineage的故障恢复<ul>
<li>重新计算丢失分区</li>
<li>重算过程在不同节点之间可以并行 </li>
</ul>
</li>
<li>Lineage 状态存放在哪里？<ul>
<li>Lineage是存放在Driver里面的，Driver里面可以解析DAG得到Lineage。因此如果Driver出故障的话，那真的只能重启了</li>
</ul>
</li>
<li>与数据库恢复的比较 <ul>
<li>RDD Lineage：记录<strong>粗粒度</strong>的操作 ，并没有记录RDD那里做了修改，只是对RDD变化的<strong>过程</strong>做了记录</li>
<li>数据复制或者日志：记录<strong>细粒度</strong>的操作</li>
</ul>
</li>
</ul>
<h3 id="检查点机制"><a href="#检查点机制" class="headerlink" title="检查点机制"></a>检查点机制</h3><ul>
<li>前述机制的不足之处 <ul>
<li>Lineage可能非常长 </li>
<li>RDD持久化机制保存到集群内机器的磁盘，并 不完全可靠</li>
</ul>
</li>
<li>检查点机制将RDD写入外部可靠的（本身 具有容错机制）分布式文件系统，例如 HDFS，这样更加可靠<ul>
<li>在实现层面，写检查点的过程是一个独立的作业，在用户作业结束后运行</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/03/31/%E4%BA%86%E8%A7%A3%E4%BB%A5%E5%A4%AA%E5%9D%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/31/%E4%BA%86%E8%A7%A3%E4%BB%A5%E5%A4%AA%E5%9D%8A/" class="post-title-link" itemprop="url">了解以太坊</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-31 07:12:07" itemprop="dateCreated datePublished" datetime="2022-03-31T07:12:07+08:00">2022-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-18 00:14:51" itemprop="dateModified" datetime="2023-03-18T00:14:51+08:00">2023-03-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="了解以太坊"><a href="#了解以太坊" class="headerlink" title="了解以太坊"></a>了解以太坊</h1><h2 id="以太坊简介"><a href="#以太坊简介" class="headerlink" title="以太坊简介"></a>以太坊简介</h2><p>和比特币不一样，以太坊是一个<strong>可编程</strong>的区块链平台。与比特币相比，两者都属于公有链，但是以太坊侧重于<strong>可编程的智能合同</strong>即分布式应用程序。</p>
<p>也就是说，以太坊可以理解为一个<strong>永不宕机的世界计算机</strong>。 可想而知，这样的系统需要满足很多条件：其中最重要的就是它不能受平台的限制，必须实现跨平台通用，如Linux, Windows, mac等。因此，实现这个要求的最佳方案就是<strong>虚拟机</strong>——和JVM一样，以太坊也有一个自己的虚拟机环境 EVM。</p>
<p>此外，这个系统如何控制软硬件对计算机资源的消耗？因为可能存在恶意的软件不断消耗以太坊平台的资源。答案很简单，就是引入代币机制，而以太坊中的代币就是<strong>以太币</strong>。也就是说，以太币仅仅是驱动智能合约执行所需燃料的加密令牌。</p>
<h3 id="以太坊设计原则"><a href="#以太坊设计原则" class="headerlink" title="以太坊设计原则"></a>以太坊设计原则</h3><ul>
<li>简单性： 协议尽可能简单</li>
<li>普遍性： 没有“特征”</li>
<li>模块化：各个部分尽可能模块化和可分离</li>
<li>敏捷性：更改容易，允许通过硬分叉进行重大修改。硬分叉即不向前兼容，旧节点不能接收新的区块。通常在硬分叉之后，更新后的节点会得到一定的币的补偿，以激励节点更新到新的版本。</li>
<li>不歧视，不审查：<ul>
<li>协议不会限制特定类别的使用</li>
<li>监管机制不会反对具体的不可取的应用</li>
<li>能运行无限循环的脚本</li>
</ul>
</li>
</ul>
<h3 id="以太坊虚拟机"><a href="#以太坊虚拟机" class="headerlink" title="以太坊虚拟机"></a>以太坊虚拟机</h3><ul>
<li>智能合约在不同的操作系统、硬件平台都应该具有确定性和一致性的结果</li>
<li>可以执行任意算法复杂性的代码</li>
<li>开发人员可以使用基于现有熟悉的变成创建在EVM上运行的应用程序</li>
<li>每个运行EVM的节点都是共识协议的一部分，独立验证交易序列、运行交易触发的代码。</li>
</ul>
<h3 id="以太坊系统特点"><a href="#以太坊系统特点" class="headerlink" title="以太坊系统特点"></a>以太坊系统特点</h3><ul>
<li>可以部署基于分布式的大规模并行化计算</li>
<li>为DApp(去中心化的应用程序)提供了极端水平的容错能力，确保零停机时间</li>
<li>数据不可更改和可追溯</li>
</ul>
<p>所以说，对于一个DApp，我们在设计的时候只把关键的业务逻辑写到区块链上，多方面不需要共识的部分我们就放在链下。</p>
<h3 id="以太坊应用领域"><a href="#以太坊应用领域" class="headerlink" title="以太坊应用领域"></a>以太坊应用领域</h3><ol>
<li>对等实体之间的直接交互或者跨网络的组织之间组织协调。</li>
<li>基于点对点的应用领域或复杂金融合约自动化运行领域。例如：复杂的金融交流或交换；信任、 安全和持久性都很重要的环境一. 例如资产登记、投票、治理和物联网。</li>
</ol>
<h3 id="以太坊的升级和分叉"><a href="#以太坊的升级和分叉" class="headerlink" title="以太坊的升级和分叉"></a>以太坊的升级和分叉</h3><p><img src="/2022/03/31/%E4%BA%86%E8%A7%A3%E4%BB%A5%E5%A4%AA%E5%9D%8A/1.png" style="zoom:67%;"></p>
<p><img src="/2022/03/31/%E4%BA%86%E8%A7%A3%E4%BB%A5%E5%A4%AA%E5%9D%8A/2.png" style="zoom:67%;"></p>
<h2 id="以太坊框架"><a href="#以太坊框架" class="headerlink" title="以太坊框架"></a>以太坊框架</h2><h3 id="以太坊账户"><a href="#以太坊账户" class="headerlink" title="以太坊账户"></a>以太坊账户</h3><p>账户是以太坊的核心角色，以太坊中的交易就是账户之间价值和信息的转换。</p>
<p>账户的结构如下：</p>
<p><img src="/2022/03/31/%E4%BA%86%E8%A7%A3%E4%BB%A5%E5%A4%AA%E5%9D%8A/3.png" style="zoom:67%;"></p>
<p>账户也分为两类：外部账户和 合约账户</p>
<ul>
<li>外部账户(EOAs) 由公钥-私钥对 控制，没有相关代码</li>
<li>合约账户由交易类型、消息类型进行创建，由代码控制</li>
</ul>
<p>以太坊中，所有的交易发起者，只能是外部账户。但是，智能合约执行过程中，可以创建新的交易</p>
<h3 id="以太币"><a href="#以太币" class="headerlink" title="以太币"></a>以太币</h3><p>以太币是以太坊中货币的名称，它被用来支付以太坊虚拟机（EVM）计算的费用。它不是被直接消耗掉而是间接的通过购买gas 来实现的。</p>
<p>以太坊最小的面额被称为Wei，1 Eth = 1e18 Wei</p>
<p>获得以太币有三种方式：成为以太坊矿工，通过挖矿获得以太币；通过第三方担保和持有以太币的人进行交易；使用用户友好Mist以太坊钱包，用客户端API购买以太币</p>
<h3 id="交易"><a href="#交易" class="headerlink" title="交易"></a>交易</h3><p>以太坊中“交易”是指存储从外部账户发出的消息的签名数据包，数据包中包含从<strong>一个外部账户</strong>发往<strong>一个账户</strong>的消息。</p>
<p>一笔交易的组成部分如下图所示：</p>
<p><img src="/2022/03/31/%E4%BA%86%E8%A7%A3%E4%BB%A5%E5%A4%AA%E5%9D%8A/4.png" style="zoom:67%;"></p>
<p>value字段就是转账的金额，Startgas和Gasprice我们比较陌生，所依赖着重学习一下：</p>
<ul>
<li>Startgas 指该交易能消耗的最大的瓦斯使用量，如果交易完成还有得多，会将gas退回到账户</li>
<li>Gasprice 指的是一个gas的单价，这个单价是可以变化的。</li>
</ul>
<h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>消息可以理解为一种特殊的交易，是合约代码执行过程中对其他合约的功能调用（通过操作码“CALL”和“DELEGATECALL”）。</p>
<p><img src="/2022/03/31/%E4%BA%86%E8%A7%A3%E4%BB%A5%E5%A4%AA%E5%9D%8A/5.png" style="zoom:67%;"></p>
<p>消息与交易都会导致接收者的合约账户执行合约代码，区别在于交易是外部账户创建的，而消息则由合约也只能通过合约创建。</p>
<p>比如说，我要给A转10个以太币，那么我可以只发起一个交易；但是我也可以把这个操作写到一个智能合约，我可以调用这个智能合约实现转账，这时候合约发起的是一个消息。</p>
<p>但是消息不一定只用于转账，也可以用做消息传递。</p>
<h3 id="GAS"><a href="#GAS" class="headerlink" title="GAS"></a>GAS</h3><p>在以太坊中用瓦斯（GAS）作为合约代码执行成本基本单位。瓦斯由外部账户通过以太币从执行代码的矿工那里购买。矿工可以决定瓦斯价格，即设置最低价格的单价，低于该价格的交易会被矿工拒绝。</p>
<p>以太坊为每一个交易和合约的计算步骤设置费用，外部账号可以为交易设置以太币值、STARTGAS和GASPRICE等瓦斯限制，矿工也有权选择验证这个交易以获取费用或者拒绝。</p>
<p>在发送一个交易时根据预估交易费用设置相应的以太币是有必要的，其计算方法如下：</p>
<ul>
<li><p>预估交易费用 = 瓦斯使用量 * 瓦斯价格</p>
</li>
<li><p>瓦斯使用量 = 交易瓦斯使用量 + 消息瓦斯使用量</p>
</li>
<li><p>瓦斯价格 = 默认值 = 0.05e18 wei (0.05个以太币)</p>
</li>
</ul>
<h3 id="轻客户端"><a href="#轻客户端" class="headerlink" title="轻客户端"></a>轻客户端</h3><p>以太坊中的轻客户端和比特币网络中的轻节点是类似的</p>
<ul>
<li>轻客户端使用全节点作为中介，不需要直接与区块链交易</li>
<li>轻客户端只需要下载最新的区块头，速度快效率高</li>
<li>轻客户端能判断那些全节点是恶意全节点</li>
<li>轻客户端在分片技术中能够发挥重要作用。分片就是</li>
<li>轻客户端可以运行在移动设备上</li>
</ul>
<p>轻节点查询特定账户余额的过程如下，这时候就不是UTXO模型了</p>
<ul>
<li>用户连接到轻客户端，并发送查询特定账户余额的请求。</li>
<li>轻客户端调用连接的全节点转发账户查询请求 </li>
<li>验证全节点给出的答案是否与它们所拥有的“签名”相匹配</li>
<li>轻客户端返回结果给用户。</li>
</ul>
<h3 id="全节点运行网络"><a href="#全节点运行网络" class="headerlink" title="全节点运行网络"></a>全节点运行网络</h3><p>全节点最上层是DApp，就是在以太坊平台的基础上由许多开发团队所开发的各类分布式应用项目，如和以太坊基金会是独立的Augur, Digix, Maker。DApp和以太坊的关系与操作系统和应用软件的关系相似。</p>
<p>第二层是RPC，即远程调用接口，包含两个模块：智能合约和共识模块</p>
<p>第三层是区块链本体，包含事件、交易、区块、状态</p>
<p>最下面一层是区块链的基础，分为网络模块和安全模块</p>
<p><img src="/2022/03/31/%E4%BA%86%E8%A7%A3%E4%BB%A5%E5%A4%AA%E5%9D%8A/6.png" style="zoom:67%;"></p>
<h2 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li><p>以太坊中的智能合约是具有特定地址（合约账户）的代码（合约功能）和数据（合约状态）的集合。</p>
</li>
<li><p>以太坊中的智能合约通常使用Solidity等高级语言编写，编译成基于EVM的字节代码后上传到合约账户。</p>
</li>
<li><p>合约的代码以基于EVM的二进制字节码存储在账户中，当被交易或消息触发时在EVM中运行。 </p>
</li>
<li><p>合约账户之间可以相互传递消息并实现图灵完备运算。</p>
</li>
</ul>
<h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>现在我们来学习智能合约调用过程中的状态转换</p>
<ol>
<li>首先检查交易的格式是否正确</li>
<li>计算交易费用 <code>fee = STARTGAS * GASPRICE</code>, 从发送者账户减去交易费用</li>
<li>设定初值GAS =STARTGAS，根据交易中的字节数减去一定量的瓦斯值。</li>
<li>从发送者的账户转移价值到接收者账户。如果接收账户是一个合约，则运行合约的代码。</li>
<li>如果价值转移失败，则恢复原来的状态，但仍需要支付交易费用。</li>
<li>否则，将所有剩余的瓦斯归还给发送者。</li>
</ol>
<p><img src="/2022/03/31/%E4%BA%86%E8%A7%A3%E4%BB%A5%E5%A4%AA%E5%9D%8A/7.png" style="zoom:67%;"></p>
<p>我们 来看这样一个例子，假设交易中STARTGAS为2000 gas，GASPRICE为0.001以太币</p>
<ul>
<li>检查交易是否有效、格式是否正确</li>
<li><p>检查交易发送者至少有2000*0.001=2个以太币。如果有，从发送者账户中减去2个以太币。- 先按预估瓦斯费用扣款，再返款</p>
</li>
<li><p>初始设定gas=2000,假设交易长为170字节，每字节的瓦斯使用量是减去850，所以还剩1150。</p>
</li>
<li><p>从发送者账户减去10个以太币，为合约账户增加10个以太币。10个以太币为转账金额</p>
</li>
<li><p>运行代码。在这个合约中，运行代码很简单：它检查合约存储器索引为2处是否已使用，注意到它未被使用，然后将其值置为CHARLIE。假设这消耗了187单位的瓦斯，于是剩余的瓦斯为1150 - 187 = 963。</p>
</li>
</ul>
<ul>
<li>智能合约运行瓦斯使用量</li>
<li>向发送者的账户增加963*0.001=0.963个以太币，这是剩下未使用的gas，因此返还给发送者，返回最终状态。 </li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/03/25/%E4%BA%86%E8%A7%A3MapReduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/25/%E4%BA%86%E8%A7%A3MapReduce/" class="post-title-link" itemprop="url">了解MapReduce</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-25 02:46:20" itemprop="dateCreated datePublished" datetime="2022-03-25T02:46:20+08:00">2022-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-31 14:00:20" itemprop="dateModified" datetime="2022-03-31T14:00:20+08:00">2022-03-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="了解MapReduce"><a href="#了解MapReduce" class="headerlink" title="了解MapReduce"></a>了解MapReduce</h1><h2 id="MapReduce引入"><a href="#MapReduce引入" class="headerlink" title="MapReduce引入"></a>MapReduce引入</h2><p>首先，我们需要了解什么是MapReduce，它是用来做什么的？</p>
<p>比如说，我们有10TB的数据，放在一台机子上肯定是不现实的，因此需要存放在之前我们介绍的存储系统：HDFS中。但是，如果放在HDFS上，由于大文件被切成一个个小块，如果这时候要对这些文件建立倒排索引、统计词频的话，按照原来的逻辑，可能会出现一定的问题——如果按照原来的逻辑，我们可以写一个客户端，将所有DataNode上的数据读进来进行处理，但这样说到底还是一个单机程序，没有体现出分布式系统的优势。</p>
<p>这时候一个合理的逻辑是把我的程序发送到集群的每一台DataNode上去做统计，也就是<strong>把运算往数据靠近，而不是数据往运算靠近</strong>，数据在哪里我就去那里运算，最终得到了DataNode上的局部结果。因此，我们不但需要分布式存储, 还需要分布式运算.</p>
<p>但分布式运算的构想很丰满，显示却很“骨干”，这边有几个痛点问题需要解决：</p>
<ol>
<li>怎么把程序包<strong>分发</strong>到集群中的DataNode上？</li>
</ol>
<p>我们该用什么方法去保证每个节点上的环境都是相同的，该用什么系统去分发程序。总不可能用U盘一个一个拷贝过来。</p>
<ol>
<li>程序如何分发到<strong>有数据的</strong>Datanode上？</li>
</ol>
<p>假设有30个节点存放着我们要跑的数据，那么我希望我的程序就运行在这30个节点上，如果在其他节点上运行也不是不可以，只不过数据需要靠网络传输，又变成数据向计算靠拢的情况了。</p>
<ol>
<li>在DataNode上运行的结果，怎么将其汇总起来？</li>
</ol>
<p>如果只在一台机器上汇总，那么这台机器的负载肯定会很高。但如果在多台机器上汇总，逻辑就会变得异常复杂。比如说，如果要统计词频，应该如何设计那些单词分发到哪个节点上去统计。</p>
<p>这些问题是很难解决的，这时候就需要MapReduce了。对于程序员来说，我们<strong>只关心如何处理数据的逻辑</strong>，并不关心数据是如何被分配，又是如何被汇总的，因为这些我们不擅长却异常复杂。MapReduce就是将这些不擅长又必须克服的痛点给解决了，它将这些东西全部封装起来。因此，对程序员来说底层的分发、计算、汇总都是透明的。 </p>
<h3 id="MPI"><a href="#MPI" class="headerlink" title="MPI"></a>MPI</h3><p>其实在MapReduce出现以前，程序员可以使用MPI并行处理数据。但是这个接口库存在以下缺点：</p>
<ol>
<li>从用户编程角度快来看，程序员需要考虑到进程之间的并行问题，并且进程之间的通信需要用户在程序中<strong>显式表达</strong>，这增加了编程的复杂性，使得底层对用户不够透明。</li>
<li>从系统实现角度来看，MPI 以多进程的方式运行。因此除非在编写程序的时候加入了故障恢复功能，否则MPI不具备容错能力，系统鲁棒性很差。</li>
</ol>
<p>因此，分布式计算系统本身需要具备容错能力，这也是MapReduce系统与MPI的重要区别。</p>
<h3 id="MR数据模型"><a href="#MR数据模型" class="headerlink" title="MR数据模型"></a>MR数据模型</h3><p>上面可以看做是对MapReduce的抽象了解。其实，MR会将数据抽象为一系列键值对，这些键值对通常来自于存储在HDFS中的文件。如下图，我们看到MapReduce的输入是一组键值对，进行转换后的输出也是一组键值对</p>
<p><img src="/2022/03/25/%E4%BA%86%E8%A7%A3MapReduce/1.png" style="zoom:67%;"></p>
<h3 id="MR计算模型"><a href="#MR计算模型" class="headerlink" title="MR计算模型"></a>MR计算模型</h3><p>我们可以用做菜来比如MapReduce的计算过程：统合来看，MapReduce就是你有很多各种各样的蔬菜水果面包（Input），有很多厨师，不同的厨师分到了不同的蔬菜水果面包，自己主动去拿过来（Split），拿到手上以后切碎（Map），切碎以后给到不同的烤箱里，冷藏机里（Shuffle），冷藏机往往需要主动去拿，拿到这些东西存放好以后会根据不同的顾客需求拿不同的素材拼装成最终的结果，这就是Reduce，产生结果以后会放到顾客那边等待付费（Ticket），这个过程是Finalize。</p>
<p>从上图我们可以看出，Map转换前后的键值对的内容通常都会不同。MapReduce框架会将Map转换的道德键值对按照键进行分组，这就是Shuffle过程 (紫色的归为紫色，蓝色的归为蓝色)。之后，Reduce会对相同键的键值对进行计算，并可根据需要将计算结果进行一次键值对转换后输出。</p>
<p>从用户编程角度看，程序员不再需要像MPI一样关注节点之间的通信，可以像编写集中式程序那样便携MapReduce代码。</p>
<p>从系统角度看，系统可以并行启动一系列的进程去执行Map和Reduce操作，而且一旦这些进程出现故障，MapReduce框架可以自动进行容错处理，无需用户编写程序。</p>
<h2 id="MR体系架构"><a href="#MR体系架构" class="headerlink" title="MR体系架构"></a>MR体系架构</h2><p><img src="/2022/03/25/%E4%BA%86%E8%A7%A3MapReduce/2.png"></p>
<p>如上图所示，MapReduce系统采用<strong>主从</strong>架构，里面有主要工作部件：</p>
<ul>
<li><code>JobTracker</code>： 主节点运行的后台进程，负责整个系统的<strong>资源管理</strong>和<strong>作业管理</strong>。<ul>
<li>资源管理是指<code>JobTracker</code>通过监控<code>TaskTracker</code>来管理系统拥有的计算资源。</li>
<li>作业管理是指<code>JobTracker</code>负责将作业(Job)拆分成任务(Task),并进行任务调度以及跟踪任务的运行进度、资源使用量等信息。</li>
</ul>
</li>
<li><code>TaskTracker</code>: 从节点运行的后台进程，负责管理本节点的资源、执行<code>JobTracker</code>的命令并会报情况。<code>TaskTracker</code>使用slot等量划分本节点上的资源量(如CPU,RAM), 接收<code>JobTracker</code>发送过来的命令并执行，通过心跳将本节点上资源使用情况和任务运行进度汇报给<code>JobTracker</code></li>
<li><code>Task</code> : 从节点在应用程序执行过程中所启动的进程，负责任务执行。<code>JobTracker</code>根据<code>TaskTracker</code>回报的信息进行调度，命令存在空闲slot 的<code>TaskTracker</code>启动<code>Task</code>进程执行map或者reduce任务，即<code>MapTask</code>和<code>ReduceTask</code>。在Hadoop MapReduce的实现中，<code>Task</code>又被称为<code>Child</code></li>
<li>客户端：客户端所在节点为提交应用程序启动的进程，负责将用户编写的MapReduce程序提交给JobTracker。在Haddop MapReduce的实现中，客户端被称为<code>RunJar</code></li>
</ul>
<p>通常，MapReduce和HDFS会同时部署在一个节点，否则会导致MapReduce从远程DataNode中读入数据，而且需要通过网络将输出结果写入远程DataNode中，这样的代价是很高的。</p>
<p>因此，JobTracker和NameNode部署在同一个物理节点，而TaskTracker和DataNode部署在同一个物理节点。在这种方式下，可以最大程度避免远程写入的网络开销。如下图所示：</p>
<p><img src="/2022/03/25/%E4%BA%86%E8%A7%A3MapReduce/3.png"></p>
<p>这种部署方式使得MapReduce在输入输出数据的读写时，无需通过网络移动数据，体现了<strong>计算向数据靠拢</strong>的理念。</p>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><img src="/2022/03/25/%E4%BA%86%E8%A7%A3MapReduce/4.jpg" style="zoom:150%;"></p>
<p>上图是MapReduce执行应用程序的流程：</p>
<ol>
<li>客户端将用户编写的MapReduce作业的配置信息，jar包等上传到共享文件系统，通常是HDFS</li>
<li>客户端提交作业给JobTracker，并告诉JobTracker作业信息的位置</li>
<li>JobTracker读取作业的信息，生成一系列Map和Reduce任务，调度给拥有空闲slot的TaskTracker</li>
<li>TaskTracker根据JobTracker的指令启动Child进程执行Map任务，Map任务将从共享文件系统读取输入数据。</li>
<li>JobTracker从TaskTracker处获得Map任务进度信息</li>
<li>一旦Map任务完成之后，JobTracker会将Reduce任务分发给TaskTracker</li>
<li>TaskTracker根据JobTracker的指令启动Child进程执行Reduce作用，Reduce任务将从Map任务所在节点的本地磁盘中拉取Map的输出结果</li>
<li>JobTracker从TaskTracker处获取Reduce任务进度信息</li>
<li>当Reduce任务运行结束并将结果写入共享文件系统，则意味着整个作业执行完毕。</li>
</ol>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><img src="/2022/03/25/%E4%BA%86%E8%A7%A3MapReduce/5.png"></p>
<p>MapReduce 工作原理如上图所示：每个Map任务从分布式文件系统(如HDFS)读取需要处理的数据，解析出键值对。然后新生成的键值对经过Shuffle传给Reduce任务，键相同的键值对都会发送给相同的Reduce任务，Reduce任务针对这些键值对进行计算后将结果以新的键值形式写入到分布式文件系统当中。</p>
<p>在这个过程中主要有Map、Shuffle、Reduce三个阶段，如果加上输入和输出就是五个阶段</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>通常一个Map任务需要开启多个MapTask，那么我们可不就可以把存放在HDFS中的每一个Block”投喂”给一个Map任务呢？听起来这是可行的，但实际上，由于一个键值对极有可能被分在两个物理块当中，因此采用这种方法会导致Map任务读到的输入数据不完整</p>
<p>因此，MapReduce有自己的输入格式，它提供了数据逻辑划分和键值对解析功能。我们从下图可以看出，文件实际上会被划分为一个个Split(分片)，每个分片会包含一些meta data(如数据长度、起始位置、所在节点)，而且Split不会存在夸块的键值对(因为重新划分了)。因此，Map任务读取的单位是分片而不是文件块, 而且分片的数量决定了map任务的个数。</p>
<p><img src="/2022/03/25/%E4%BA%86%E8%A7%A3MapReduce/6.png"></p>
<p>简单来说，输入格式通过定义分片和键值对当解析的方法完成了从<strong>物理存储(HDFS物理文件块)</strong>到<strong>MapReduce程序可处理的逻辑数据</strong>之间的映射。</p>
<h3 id="Map阶段"><a href="#Map阶段" class="headerlink" title="Map阶段"></a>Map阶段</h3><p><strong>第一步</strong>：对于一个键值对来说，Map的过程就是将其转换为一个或者多个键值对，即$[K_1,V_1]\longrightarrow \text{List}([K_2,V_2])$ . 例如，在词频统计的例子中，$[行偏移量，An,An]$ 或转变为 $[An,1],[An,1]$ </p>
<p><strong>第二步</strong>：接着会根据partition方式，确定$[K_2,V_2]$键值对所属的分区，而总的分区数目等于Reduce任务的数量。得到$[K_2,V_2,\text{partition ID}]$ ,并将其放入缓冲区。</p>
<p><strong>第三步</strong>：当缓冲区的数据到达阈值(如80%), Map任务将会锁定当前阈值以内的缓冲区，现将缓冲区内的$[K_2,V_2,\text{partition ID}]$ 按照partition ID进行排序，再将同一个分区内的键值对按照键进行排序。这样做的目的是让发往同一个Reduce任务的键值对聚集在一起，且拥有相同键的键值对也聚集在一起。然后，Map任务将排序后的结果写到磁盘形成文件。排序和写入的过程并不阻塞新的键值对写入缓冲区，因此同一Map任务一般会产生多个磁盘文件，属于同一分区的键值对也会分布在多个磁盘文件当中。</p>
<p>值得指出的是，入股哦此时定义了combine方法，那么此时就会对相同的键值对进行Combine.例如WordCount示例中的合并操作将两个相同的键值对$[An,1],[An,1]$ ，合并得到 $[An,2]$ </p>
<p><strong>第四步</strong>：随着磁盘中溢写到达阈值，Map任务会进一步归并形成一个文件，使得数以一个分区的所有键值对连续存储。这本质上是一个多路归并排序的过程，最终会形成一个连续的大文件形式存储在磁盘中。</p>
<p>问：为什么要把结果写入到磁盘中去呢？为了<strong>容错</strong>，但为了保证容错牺牲了一定的性能。</p>
<p><img src="/2022/03/25/%E4%BA%86%E8%A7%A3MapReduce/7.png"></p>
<h3 id="Shuffle阶段"><a href="#Shuffle阶段" class="headerlink" title="Shuffle阶段"></a>Shuffle阶段</h3><p>现在，Map阶段已经将键值对分为很多分区，但是有很多Map任务，因此在不同的DataNode上会存在相同名字的分区。SHuffle过程就是将这些位于不同DataNode但是分区相同的键值对发送给<strong>同一个Reduce任务</strong>。也就是将$List([K_2,V_2])\longrightarrow [K_2,List(V_2)]$ 。仍用$[An,1],[An,1]$ 为例，Shuffle的过程就是将两个键值对发送给同一个Reduce任务并形成 $[An,{1,1}]$ 。</p>
<p>Map任务完成后，会通知所在节点的TaskTracker，并将Map输出文件所在的位置告知TaskTracker，之后，TaskTracker会进一步通知JobTracker。当系统中的Map任务完成率到达设定阈值的时候，系统就会启动Reduce任务。比如说，当阈值设定为60%的话，100个Map任务只需要完成60个，就可以qidongReduce任务，而不必等到100个Map任务全部完成</p>
<p>所以说，Shuffle阶段是一个中间阶段。</p>
<p><img src="/2022/03/25/%E4%BA%86%E8%A7%A3MapReduce/8.png"></p>
<h3 id="Reduce-阶段"><a href="#Reduce-阶段" class="headerlink" title="Reduce 阶段"></a>Reduce 阶段</h3><p>Reduce阶段启动之后，会定期想JobTracker获取各个节点已经完成的Map任务的输出位置。要记住，<strong>Reduce任务虽然不会等到所有Map任务执行结束才拉取Map任务的输出结果，但是拉取的数据必然来自于已经完成运行的Map任务</strong>。</p>
<p>对于一键值对来说，Reduce过程是将其转换为一个或者多个键值对。即 $[K_2,\text{List}(V_2)]$键值转换为 $[K_3,V_3]$ . 例如，在词频统计的例子中，Reduce过程对$[An,{1,1,1,1,1}]$进行求和操作转变为 $[An,5]$ </p>
<p>Reduce和Map阶段非常类似，Reduce任务从磁盘拉取的任务也会先放入<strong>内存缓冲区</strong> ，其中存储的是$[K_2,V_2]$的键值对，当内存缓存区中的数据占用空间到达阈值之后，Reduce任务将对缓存区中的键值按键进行归并排序。如果此时用户定义了conbine方法，则此时Reduce任务先执行合并操作然后将内存缓存区中的数据溢写到磁盘文件。注意，此时Reduce任务会继续拉取数据，因此随着数据的拉取将不断形成多个存在磁盘上的溢写文件</p>
<p>因为存在多个溢写文件，因此拥有相同键的键值对可能分在在不同文件中，因而这些文件需要再次归并。注意，并不是将所有溢写文件一次性归并，而是在达到一定数量的时候就执行归并操作。与Map端不同的是，最后一次归并操作的结果无需写入磁盘，而是直接可以执行reduce方法处理，这样可以省去一次磁盘读写操作。</p>
<p><img src="/2022/03/25/%E4%BA%86%E8%A7%A3MapReduce/9.png"></p>
<p>Reduce的结果会写入到用户指定的存储系统中，通常是HDFS</p>
<h3 id="数据输出"><a href="#数据输出" class="headerlink" title="数据输出"></a>数据输出</h3><p>事实上，每个Reduce 任务都会输出一个文件。也就是说，MapReduce的输出结果是一组文件而不是一个文件。</p>
<h2 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h2><h3 id="JobTracker故障"><a href="#JobTracker故障" class="headerlink" title="JobTracker故障"></a>JobTracker故障</h3><p>JobTracker是MapReduce框架的”首脑“，一旦它发生故障，那么正在运行的所有作业内部状态信息将会丢失。因此，重新启动JobTracker之后，所有作业需要重新执行。</p>
<p>从而，MapReduce中JobTracker的单节点故障瓶颈是该架构设计的缺陷。</p>
<h3 id="TaskTracker故障"><a href="#TaskTracker故障" class="headerlink" title="TaskTracker故障"></a>TaskTracker故障</h3><p>当TaskTracker进程故障时，JobTracker将接收不到TaskTracker发来的心跳。因此，在该TaskTracker所在节点运行过的任务都会被标记为失败。JobTracker会将这些任务调度到别的TaskTracker所在节点重新执行。这个过程对用户来说是<strong>透明的</strong>，只会感觉到该作业执行变慢了而已</p>
<h3 id="Task故障"><a href="#Task故障" class="headerlink" title="Task故障"></a>Task故障</h3><p>Task进程故障比较常见，因其错误的原因通常有代码错误、磁盘损坏等。当TaskTracker检测到一个任务故障时，TaskTracker将在下一次心跳里JobTracker报告该故障，JobTracker收到报告的消息后会重新调度该任务。</p>
<p>重新调动的额任务可以再集群的任一节点重试，但是当一个任务经过最大尝试数的尝试运行后仍然失败，那么整个作业将被标记为失败。</p>
<p>对于Map和Reduce任务来说，重试的过程有所不同：</p>
<ul>
<li>对于重试的Map任务来说，将从输入路径重新读取数据。</li>
<li>对于重试的Reduce任务来说，将重新拉取Map端的输出文件，如果读取不到该文件，那么相应的Map任务也需要重新执行。因为Reduce只会读取Map任务结束后输出的文件，因此只要磁盘不损坏，Reduce都可以重新读取。</li>
</ul>
<h2 id="编程实例"><a href="#编程实例" class="headerlink" title="编程实例"></a>编程实例</h2><h3 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h3><h4 id="map方法的框架"><a href="#map方法的框架" class="headerlink" title="map方法的框架"></a>map方法的框架</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.edu.ecnu.mapreduce.example.java.wordcount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.LongWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 步骤1：确定输入键值对[K1,V1]和 输出键值对 [K2,V2]的数据类型 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">K1</span>数据类型, <span class="title">V1</span>数据类型, <span class="title">K2</span>数据类型, <span class="title">V2</span>数据类型&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(K1数据类型 key, V1数据类型 value, Context context)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">/* 步骤2：编写处理逻辑将[K1,V1]转换为[K2,V2]并输出 */</span></span><br><span class="line">        <span class="comment">//.....逻辑.....</span></span><br><span class="line">            context.write(K2, V2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="reduce方法的框架"><a href="#reduce方法的框架" class="headerlink" title="reduce方法的框架"></a>reduce方法的框架</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.edu.ecnu.mapreduce.example.java.wordcount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 步骤1：确定输入键值对[K2,List(V2)] 和 输出键值对[K3,V3]的数据类型 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">K2</span>数据类型, <span class="title">V2</span>数据类型, <span class="title">K3</span>数据类型, <span class="title">V3</span>数据类型&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(K2数据类型 key, Iterable&lt;V2数据类型&gt; values, Context context)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">/* 步骤2：编写处理逻辑将[K2,List(V2)]转换为[K3,V3]并输出 */</span></span><br><span class="line">        <span class="comment">//....逻辑.....</span></span><br><span class="line">        <span class="comment">// 输出计数结果</span></span><br><span class="line">        context.write(K3, V3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="主方法框架"><a href="#主方法框架" class="headerlink" title="主方法框架"></a>主方法框架</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configured;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.Tool;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.util.ToolRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> <span class="keyword">extends</span> <span class="title">Configured</span> <span class="keyword">implements</span> <span class="title">Tool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">/* 步骤1：设置作业的信息 */</span></span><br><span class="line">        Job job = Job.getInstance(getConf(), getClass().getSimpleName());</span><br><span class="line">        <span class="comment">// 设置程序的类名</span></span><br><span class="line">        job.setJarByClass(getClass());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置数据的输入输出路径</span></span><br><span class="line">        FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置map和reduce方法</span></span><br><span class="line">        job.setMapperClass(自定义Map类);</span><br><span class="line">        job.setReducerClass(自定义Reduce类);</span><br><span class="line">        job.setCombinerClass(自定义Combine类);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置map方法的输出键值对数据类型 </span></span><br><span class="line">      	<span class="comment">// 如果不设置的话，默认为 TextInputFormat 和 TextOutputFormat</span></span><br><span class="line">        job.setMapOutputKeyClass(map方法的输出键数据类型);</span><br><span class="line">        job.setMapOutputValueClass(map方法的输出值数据类型);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 设置reduce方法的输出键值对数据类型</span></span><br><span class="line">        job.setOutputKeyClass(reduce方法的输出键数据类型);</span><br><span class="line">        job.setOutputValueClass(reduce方法的输出值数据类型);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> job.waitForCompletion(<span class="keyword">true</span>) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">/* 步骤2：运行作业 */</span></span><br><span class="line">        <span class="keyword">int</span> exitCode = ToolRunner.run(<span class="keyword">new</span> WordCount(), args);</span><br><span class="line">        System.exit(exitCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="词频统计"><a href="#词频统计" class="headerlink" title="词频统计"></a>词频统计</h3><p>词频统计是一个很简单但很经典的MapReduce的应用案例。</p>
<p>输入：是一个包含大量单词的文本文件</p>
<p>输出：文件中每个单词及其出现次数(频数)，每个单词和其频数占一行，单词和频数之间有间隔。</p>
<p>如下所示：</p>
<p><img src="/2022/03/25/%E4%BA%86%E8%A7%A3MapReduce/10.png"></p>
<p>总体来说，词频统计的流程如下：</p>
<p>Map过程：会把文本的每行内容转换为键值对：[单词,1]</p>
<p>Reduce过程：</p>
<ul>
<li>单词相同的键值对会被发送到同一个Reduce中(shuffle)</li>
<li>对单词相同的键值对进行计数</li>
<li>输出计数后的结果[单词, 频数]</li>
</ul>
<p><img src="/2022/03/25/%E4%BA%86%E8%A7%A3MapReduce/11.png"></p>
<p>具体的过程如下:</p>
<ol>
<li>每个Map任务通过map方法将 输入键值对$[\text{行偏移量,每行内容}]$ 转换为输出键值对 $[\text{单词,频数}]$ 。比如将$[\text{offset},An,An]$ 转换为$[An,1]$</li>
<li>Map任务在缓冲区占用量达到一定阈值的时候(这里阈值为2)将键值对溢写到本地磁盘文件中。并在溢写的过程中执行归并操作。例如，把三个$[An,1]$转换为 $[An,{1,1,1}]$</li>
<li>之后，Map任务将归并产生的键值对经过Shuffle过程发送给Reduce任务。</li>
<li>在Reduce阶段，Reduce任务会进行归并操作。例如将$[My,1],[My,1],[My,{1,1,1}]$ 转换为 $[My,{1,1,1,1,1}]$</li>
<li>在归并操作完成之后，Reduce任务会通过Reduce方法将归并产生的键值对$[\text{单词,List(频数)}]$ 转换为$[\text{单词,频数}]$ 并输出。例如：将$[My,{1,1,1,1,1}]$ 转化为 $[My,5]$</li>
</ol>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul>
<li>WordCountMapper</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">LongWritable</span>, <span class="title">Text</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(LongWritable key, Text value, Context context)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">/* 步骤2：编写处理逻辑将[K1,V1]转换为[K2,V2]并输出 */</span></span><br><span class="line">        <span class="comment">// 以空格作为分隔符拆分成单词</span></span><br><span class="line">        String[] datas = value.toString().split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span> (String data : datas) &#123;</span><br><span class="line">            <span class="comment">// 输出分词结果</span></span><br><span class="line">            context.write(<span class="keyword">new</span> Text(data), <span class="keyword">new</span> IntWritable(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>WordCountReducer</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCountReducer</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">/* 步骤2：编写处理逻辑将[K2,List(V2)]转换为[K3,V3]并输出 */</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历累加求和</span></span><br><span class="line">        <span class="keyword">for</span> (IntWritable value : values) &#123;</span><br><span class="line">            sum += value.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出计数结果</span></span><br><span class="line">        context.write(key, <span class="keyword">new</span> IntWritable(sum));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>WordCount 主方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> <span class="keyword">extends</span> <span class="title">Configured</span> <span class="keyword">implements</span> <span class="title">Tool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">/* 步骤1：设置作业的信息 */</span></span><br><span class="line">        Job job = Job.getInstance(getConf(), getClass().getSimpleName());</span><br><span class="line">        <span class="comment">// 设置程序的类名</span></span><br><span class="line">        job.setJarByClass(getClass());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置数据的输入输出路径</span></span><br><span class="line">        FileInputFormat.addInputPath(job, <span class="keyword">new</span> Path(args[<span class="number">0</span>]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> Path(args[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置map和reduce方法</span></span><br><span class="line">        job.setMapperClass(WordCountMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setReducerClass(WordCountReducer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setCombinerClass(WordCountReducer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置map方法的输出键值对数据类型</span></span><br><span class="line">        job.setMapOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setMapOutputValueClass(IntWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 设置reduce方法的输出键值对数据类型</span></span><br><span class="line">        job.setOutputKeyClass(Text<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        job.setOutputValueClass(IntWritable<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> job.waitForCompletion(<span class="keyword">true</span>) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">/* 步骤2：运行作业 */</span></span><br><span class="line">        <span class="keyword">int</span> exitCode = ToolRunner.run(<span class="keyword">new</span> WordCount(), args);</span><br><span class="line">        System.exit(exitCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关系表自然连接和优化"><a href="#关系表自然连接和优化" class="headerlink" title="关系表自然连接和优化"></a>关系表自然连接和优化</h3><h3 id="网页链接排名"><a href="#网页链接排名" class="headerlink" title="网页链接排名"></a>网页链接排名</h3><h3 id="K-Means聚类"><a href="#K-Means聚类" class="headerlink" title="K-Means聚类"></a>K-Means聚类</h3><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="MapReduce中的Merge和Combine有什么区别"><a href="#MapReduce中的Merge和Combine有什么区别" class="headerlink" title="MapReduce中的Merge和Combine有什么区别"></a>MapReduce中的Merge和Combine有什么区别</h3><p>Combine函数需要程序员显示定义，如果定义了combine方法，那么</p>
<p>而Merge和程序员是没有关系的</p>
<h3 id="MapReduce中的分布式缓存机制有什么用"><a href="#MapReduce中的分布式缓存机制有什么用" class="headerlink" title="MapReduce中的分布式缓存机制有什么用"></a>MapReduce中的分布式缓存机制有什么用</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/03/23/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E6%9F%A5%E8%AF%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/23/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E6%9F%A5%E8%AF%A2/" class="post-title-link" itemprop="url">高级数据库系统-查询</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-23 10:45:50" itemprop="dateCreated datePublished" datetime="2022-03-23T10:45:50+08:00">2022-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-25 14:21:36" itemprop="dateModified" datetime="2022-06-25T14:21:36+08:00">2022-06-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><h2 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h2><p>数据库查询可以看做是对数据集合做运算，运算的基本单位是算子。比如投影、扫描、选择、连接、排序等</p>
<p>在<a href="https://jasonxqh.github.io/2021/10/25/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">关系数据库及其基本实现原理</a> 这篇博客中，我们初步了解了几种算子的功能以及如何实现的。</p>
<p>现在我们来介绍一下在执行查询的流程：</p>
<ol>
<li>首先SQL语言会被解析，并得到好几种不同的查询方案(plan)。 SQL$\rightarrow$ Plans 的过程被称为 Interpretation</li>
<li>然后引擎会找出最佳的哪个执行方案。Plans$\rightarrow$ Best Plan 的过程被称为Query  Optimization</li>
<li>最后引擎会执行这个方案，并返回结果。Best Plans $\rightarrow$ Results 的过程为成为Query Execution</li>
</ol>
<p>过程如下：</p>
<p><img src="/2022/03/23/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E6%9F%A5%E8%AF%A2/2.png"></p>
<ul>
<li>从逻辑上讲：<ul>
<li>查询 $\rightarrow$ 语法树 $\rightarrow$ 逻辑优化$\rightarrow$ 物理优化 $\rightarrow$ 查询执行</li>
<li>逻辑优化是关系代数的等价变换</li>
<li>物理优化是访问路径的选择，算子执行路径的选择</li>
</ul>
</li>
<li>在实现中<ul>
<li>很可能发生耦合</li>
<li>查询 $\rightarrow$ 语法树和数据结构  $\rightarrow$ 逻辑优化/物理优化耦合 $\rightarrow$ 执行</li>
</ul>
</li>
</ul>
<p>下图是PostgreSQL中查询引擎的组成部分：</p>
<p><img src="/2022/03/23/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E6%9F%A5%E8%AF%A2/1.png"></p>
<p>引擎主要可以分为几个组件：</p>
<h4 id="parser"><a href="#parser" class="headerlink" title="parser"></a>parser</h4><p>首先是parser，它进行的是编译过程，对SQL进行词法和语法分析 </p>
<p>SQL被编译过程中会形成这样一棵 Parse Tree(语法树)</p>
<p><img src="/2022/03/23/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E6%9F%A5%E8%AF%A2/3.png"></p>
<h4 id="Analyzer"><a href="#Analyzer" class="headerlink" title="Analyzer"></a>Analyzer</h4><p>然后，Analyzer会对语法树做语义检查，一共是检查这几个方面：</p>
<ol>
<li>投影列是否存在与对应的关系中</li>
<li>属性是否明确？是否有歧义？是否存在？</li>
<li>类型检查(int ,double等)</li>
</ol>
<h4 id="Rewriter"><a href="#Rewriter" class="headerlink" title="Rewriter"></a>Rewriter</h4><p>Parse Tree经过 analyzer之后就变成了Query Tree, 在这里面有一个视图表 (蓝色的RTE_VIEW)。Rewriter的作用是展开视图表</p>
<p><img src="/2022/03/23/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E6%9F%A5%E8%AF%A2/4.png"></p>
<h4 id="Planner"><a href="#Planner" class="headerlink" title="Planner"></a>Planner</h4><p>Planner是对上面的完整的Query Tree进行处理，形成查询计划</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tb1_a <span class="keyword">WHERE</span> <span class="keyword">id</span> &lt; <span class="number">300</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">data</span>;</span><br></pre></td></tr></table></figure>
<p>比如说对上面这句SQL语言，会生成如下一个plan tree</p>
<p><img src="/2022/03/23/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E6%9F%A5%E8%AF%A2/5.png"></p>
<p>在这个过程之后会进行逻辑优化和物理优化，这部分我们放到最后一节去说。</p>
<p>我们可以使用EXPLAIN功能，输出物理计划：</p>
<p><img src="/2022/03/23/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E6%9F%A5%E8%AF%A2/6.png"></p>
<h4 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h4><p>最后交给执行器去执行，接下来我们就要学习查询执行过程中的火山模型</p>
<h3 id="查询引擎-火山模型"><a href="#查询引擎-火山模型" class="headerlink" title="查询引擎-火山模型"></a>查询引擎-火山模型</h3><p>我们从上面看出，物理计划是一颗树形的结构，那么以此提出了火山模型来实现查询引擎的功能。火山模型是一种通用的SQL执行引擎的实现方法，因此很多数据库都会使用。</p>
<ul>
<li>操作流：从树顶依次往孩子节点要数据，直到底层算子提供数据</li>
<li>数据流：从叶子依次往上层返回数据</li>
</ul>
<p>每个数据库操作，都会使用共同的结构：</p>
<ul>
<li>Open() ： 准备资源，准备获得第一个tuple</li>
<li>Next():  一次提供一个数据</li>
<li>Close(): 释放资源</li>
</ul>
<p><img src="/2022/03/23/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E6%9F%A5%E8%AF%A2/7.png" style="zoom:50%;"></p>
<p>比如说上面这个执行树，投影、选择、扫描算子都有这三个接口。当我的SQL语句想要得到一行结果的时候， 首先会去调用投影的next接口，然后投影的next会去调选择的next接口，而选择的next又会去调扫描的next接口，只有满足了条件的数据才能够向上传递。</p>
<p>总而言之，就是父亲节点去调用孩子节点的next接口，直到获得一条数据为止。比如说第3条数据符合age&lt;25的条件，那么，<strong>选择算子</strong>会循环调用3次扫描算子的next接口，才会拿到一条符合条件的数据，并向投影算子传递</p>
<p><img src="/2022/03/23/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E6%9F%A5%E8%AF%A2/8.png" style="zoom:50%;"></p>
<p>比如说我们要实现一个排序算子，我们可以这样来实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sqrt()&#123;</span><br><span class="line">	if(第一次)&#123; &#x2F;&#x2F; 这里需要判断是否为第一次执行，第一次执行需要将孩子节点的信息全部调用上来，后面则不用</span><br><span class="line">	  while(true)&#123;</span><br><span class="line">	    child.next</span><br><span class="line">	  &#125;</span><br><span class="line">	  store sort</span><br><span class="line">	  返回信息</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		store sort</span><br><span class="line">	 	返回信息</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="阻塞算子"><a href="#阻塞算子" class="headerlink" title="阻塞算子"></a>阻塞算子</h4><p>其实，上面的sort就是一种阻塞算子，我们也可以看到sort和扫描是完全两种不同的算子——sort需要拿到所有的数据，而扫描不需要。</p>
<p>因此，我们称 要把数据全部拿到再执行的算子称为<strong>阻塞算子</strong></p>
<p>常见的阻塞算子是：构建哈希表(哈希连接)和排序(合并连接)</p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>我们可以首先来对比批处理执行和流水线执行</p>
<p>如果是用批处理的话，我们可以写几个for循环，然后几行代码就可以搞定。虽然效率很高，但这样的可扩展性极差。</p>
<p>但是使用流水线来执行的话，虽然效率很低，但是可扩展。</p>
<p>因此我们可以做出预测：</p>
<p>火山模型的优点：</p>
<ol>
<li>实现简单易扩展</li>
<li>节省内存资源</li>
</ol>
<p>缺点：</p>
<ol>
<li>冗余的流控指令</li>
<li>效率低：虚函数嵌套，CPU的分支预测不友好</li>
</ol>
<h4 id="流水线在内存数据库中的优化"><a href="#流水线在内存数据库中的优化" class="headerlink" title="流水线在内存数据库中的优化"></a>流水线在内存数据库中的优化</h4><p>这实际上是一个并行的概念，也就是一次next并不是只取一条数据，而是取一批数据：</p>
<p><img src="/2022/03/23/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E6%9F%A5%E8%AF%A2/9.png" style="zoom: 67%;"></p>
<h2 id="Join-算子实现"><a href="#Join-算子实现" class="headerlink" title="Join 算子实现"></a>Join 算子实现</h2><p>这里我们主要学习连接算子join的实现过程。两张表的Join的效果如下</p>
<p><img src="/2022/03/23/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E6%9F%A5%E8%AF%A2/10.png"></p>
<h3 id="连接算法"><a href="#连接算法" class="headerlink" title="连接算法"></a>连接算法</h3><p>连接算法一共有三种：Nest Loop Join、 Hash   Join、 Merge Join. 目的就是将相同属性的pair给找出来</p>
<h4 id="Nest-Loop-Join"><a href="#Nest-Loop-Join" class="headerlink" title="Nest Loop Join"></a>Nest Loop Join</h4><p>Nest Loop Join就是对 R 和 S 进行双循环匹配。如果 $R\bowtie S$  的话，R为内表，S为外表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Function : nljoin (R,S,p)</span><br><span class="line">&#x2F;* outer relation S *&#x2F;</span><br><span class="line">foreach record s in S do</span><br><span class="line">		&#x2F;* inner relation R *&#x2F;</span><br><span class="line">		foreach record r in R do</span><br><span class="line">			&#x2F;* &lt;s,r&gt; denotes record concatenation *&#x2F;</span><br><span class="line">        if &lt;s,r&gt; satisfies p then</span><br><span class="line">            append &lt;s,rs&gt; to result</span><br></pre></td></tr></table></figure>
<h4 id="Hash-Join"><a href="#Hash-Join" class="headerlink" title="Hash Join"></a>Hash Join</h4><p>如果采用Hash Join方法，可以对内表(这里是R表)构建哈希表，然后用S表去做哈希探测</p>
<p><img src="/2022/03/23/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E6%9F%A5%E8%AF%A2/11.png" style="zoom: 50%;"></p>
<h4 id="Merge-Join"><a href="#Merge-Join" class="headerlink" title="Merge Join"></a>Merge Join</h4><p>如果采用Merge Join,需要分别对 R 和 S 进行排序，然后用归并算法得到Join结果</p>
<p><img src="/2022/03/23/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E6%9F%A5%E8%AF%A2/12.png" style="zoom: 50%;"></p>
<h3 id="连接算法结合火山模型"><a href="#连接算法结合火山模型" class="headerlink" title="连接算法结合火山模型"></a>连接算法结合火山模型</h3><p>现在我们来看三种算法在火山模型下该如何实现。</p>
<h4 id="Nest-Loop的火山模型"><a href="#Nest-Loop的火山模型" class="headerlink" title="Nest Loop的火山模型"></a>Nest Loop的火山模型</h4><p>我们可以简单画出 Nest Loop Join的查询计划表</p>
<p><img src="/2022/03/23/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E6%9F%A5%E8%AF%A2/15.png" style="zoom: 50%;"></p>
<p>我们看到，由于Join算子需要对两张表进行连接，那么他一定是由两个孩子算子的</p>
<p>事实上，在数据库系统中，有三种不同类型的算子：</p>
<ul>
<li>没孩子的，比如Scan算子</li>
<li>单孩子的，比如Sort算子、投影算子</li>
<li>双孩子的，比如Join算子</li>
</ul>
<p>首先我们列出比较简单的open接口和close接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function: open()</span><br><span class="line">R.open();</span><br><span class="line">S.open();</span><br><span class="line">r &lt;- R.next;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Function: close()</span><br><span class="line">R.close()</span><br><span class="line">S.close()</span><br></pre></td></tr></table></figure>
<p>接下来给出next()接口的伪代码，本质上就是两重扫描：伪代码也非常直接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">While (r !&#x3D; &lt;EOF&gt; )do</span><br><span class="line">    while ((s&lt;- S.next())!&#x3D;&lt;EOP&gt;) do</span><br><span class="line">        if p(r,s) then</span><br><span class="line">          &#x2F;*向上传递连接后的结果*&#x2F;</span><br><span class="line">          return &lt;r,s&gt;</span><br><span class="line">        &#x2F;*一遍循环完了，现在重置内表，继续循环*&#x2F;</span><br><span class="line">        S.close();</span><br><span class="line">        S.open();</span><br><span class="line">        r &lt;- R.next();</span><br><span class="line">return &lt;EOF&gt;;</span><br></pre></td></tr></table></figure>
<h4 id="Hash-Join的火山模型"><a href="#Hash-Join的火山模型" class="headerlink" title="Hash Join的火山模型"></a>Hash Join的火山模型</h4><p>Hash Join 用到了多个算子：Hash算子用来创建哈希表，Hash Join算子用来探索哈希表</p>
<p><img src="/2022/03/23/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E6%9F%A5%E8%AF%A2/14.png" style="zoom: 50%;"></p>
<p>Hash  Join的火山模型有两种实现方式：</p>
<ul>
<li>写法1</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">open()&#123;</span><br><span class="line">		R.open();</span><br><span class="line">		while((r&#x3D;R.next())!&#x3D;EOF)</span><br><span class="line">				将 r 加入哈希表h (内表构造哈表h)</span><br><span class="line">		S.open();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Next()&#123;</span><br><span class="line">		while()&#123;</span><br><span class="line">				s &#x3D; S.next();</span><br><span class="line">				用s探索哈希表h；</span><br><span class="line">				if(找到一个匹配的&lt;r,s&gt;)</span><br><span class="line">						return &lt;r,s&gt;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这中写法中，open接口其实是做一个准备工作，也就是将内表打开并将其扫入内存、构建哈希表了。这样在next接口中只需要做扫描即可。实际应用中这种方式更加常见</p>
<ul>
<li>写法2</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">open()&#123;</span><br><span class="line">		R.open();</span><br><span class="line">		r &#x3D; R.next();</span><br><span class="line">		S.open();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">next()&#123;</span><br><span class="line">		if(r是R的第一个元组)&#123;</span><br><span class="line">				将r加入哈希表h</span><br><span class="line">				while((r&#x3D;R.next())!&#x3D;EOF)</span><br><span class="line">						将r加入哈希表h</span><br><span class="line">		&#125;</span><br><span class="line">		while()&#123;</span><br><span class="line">				s &#x3D; S.next();</span><br><span class="line">				用s探索哈希表h；</span><br><span class="line">				if(找到一个匹配的&lt;r,s&gt;)</span><br><span class="line">						return &lt;r,s&gt;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果采用这种写法，需要在next的时候多加一层判断，实际上开销是差不多的。</p>
<h4 id="Merge-Join的火山模型"><a href="#Merge-Join的火山模型" class="headerlink" title="Merge Join的火山模型"></a>Merge Join的火山模型</h4><p>Merge Join 用到了多个算子：Sort、Merge Join 等，下面是其查询计划表：</p>
<p><img src="/2022/03/23/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E6%9F%A5%E8%AF%A2/13.png" style="zoom: 50%;"></p>
<p>Merge Join 下面有两个Sort算子，负责对两张表的数据进行排序。Sort算子在之前我们说过会维护一个缓冲区，用一个while循环不断地向Scan算子要数据，然后在缓冲区中进行排序。</p>
<p>两个Sort都排序完成后，进行Merge Join算子的操作，也就是会从两个Sort算子各取一条数据，比较它们是否相等，如果相等说明满足条件，return，否则就继续取下面两条数据。</p>
<p>Join算子并不是阻塞算子，Sort算子才是阻塞算子</p>
<h3 id="基于块数据的连接算法"><a href="#基于块数据的连接算法" class="headerlink" title="基于块数据的连接算法"></a>基于块数据的连接算法</h3><p>现在很多数据库的底层是LSM Tree，在那种数据库环境下谈基于块数据的算法是没有意义的，这里我们讨论的是传统数据库中的基于块数据的连接方法</p>
<p>由于在传统数据库中，数据库以Block/Page为基本存储单位，因此缓冲区可能会存在内存不足的问题，导致无法将数据全部加载到内存中进行计算。</p>
<p>假设内存有B个Block用于Join，其中一个Block用于缓存Join的结果(在火山模型中并不需要缓存所有结果)。基于上面这种情况，我们再来讨论三种算法的实现</p>
<h4 id="Nest-Loop-Join-1"><a href="#Nest-Loop-Join-1" class="headerlink" title="Nest Loop Join"></a>Nest Loop Join</h4><p>首先我们来回顾一下Nest Loop Join算法：对于 $S\bowtie R$,  $S$ 为内表，$R$ 为外表。那么需要做一个双重循环，将$<R,S>$ 一一比较后得出结果</R,S></p>
<p>当块和Next Loop Join结合起来会变成什么样？</p>
<p>我们假定 R 和 S 的blocks数量分别为$N_R$ 和 $N_S$ ，那么对于外表来说，其每一个块都需要放到内存里面一遍，对于内表来说，外表的元素每改变一次，就要将所有的块放入内存中访问一遍，因此总的块访问次数为 $N_R+|R| \cdot N_S$ </p>
<h5 id="Index-Nest-Loop-join"><a href="#Index-Nest-Loop-join" class="headerlink" title="Index Nest Loop join"></a>Index Nest Loop join</h5><p>实际上我们可以对Nest Loop做一定的优化：改进成了 Indexed Nest Loop Join</p>
<p>对R表的每个数据，直接对S表做Index Scan，以此减少磁盘访问次数和访问数据量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Function : index_nljoin(R,S,p)</span><br><span class="line">foreach record r in R do</span><br><span class="line">		scan S-index using (key value in) r </span><br><span class="line">		and concatenate r with all match tuples s;</span><br><span class="line">		</span><br><span class="line">		appand &lt;r,s&gt; to result;</span><br></pre></td></tr></table></figure>
<p>前提条件是，在S表上的那一列需要对其构建索引。然后，对于R表中的每个元素，对S表做索引的查询，这样复杂度就可以降下来了。对块的访问次数也没有之前多——不用再扫描全表的块$N_s$了</p>
<h5 id="Block-Nest-Loop-Join"><a href="#Block-Nest-Loop-Join" class="headerlink" title="Block Nest Loop Join"></a>Block Nest Loop Join</h5><p>我们可以再进行一次优化来减少磁盘的访问次数</p>
<p>假设缓冲区中 $b_r$ 和 $b_s$ 个块用于缓存R和S的数据，$b_r+b_s=B-1$(B为内存可分配的块数量), 剩下1个block是用来存放输出的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Function: block_nljoin (R, S, p)</span><br><span class="line">foreach b_r-sized block in R do</span><br><span class="line">		build an in-memory hash table H for the current R-block;</span><br><span class="line">		foreach b_s-sized block in S do</span><br><span class="line">				foreach record s in current S-block do</span><br><span class="line">						probe H and append matching (r, s) tuples to result</span><br></pre></td></tr></table></figure>
<p>也就是说，一次读入 $b_r,b_s$ 个块读入内存，对其进行比较、连接。</p>
<p>因此，总的磁盘访问次数为： $\lceil N_R/b_r\rceil\cdot\lceil N_S/b_s\rceil $ (默认块是连续的) </p>
<p>访问block数量为： $N_R\cdot N_S$</p>
<p>通常来说，我们会取 $b_r = B-2,b_s = 1$ ，内存中建立哈希表优化匹配 .(如果R表可以一次性全部放进内存，事实上和哈希连接比较相近)</p>
<p><img src="/2022/03/23/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E6%9F%A5%E8%AF%A2/16.png"></p>
<h4 id="Block-Hash-Join"><a href="#Block-Hash-Join" class="headerlink" title="Block Hash Join"></a>Block Hash Join</h4><p>如果R表可以完全放入内存，那么R和S只访问一遍，和上面我们说的Nest Loop算法相近</p>
<p>那么如果R表无法完全放入内存的话，就需要<strong>对R表进行Block Hash 算法</strong>了：</p>
<p>我们可以建 B-1 个桶， 每个桶写满一个Block就刷盘，一个桶可能占多个Block，如下所示：</p>
<p><img src="/2022/03/23/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E6%9F%A5%E8%AF%A2/17.png"></p>
<p>对S表也可以做这样一个Block Hash算法，此时，R表和S表都按照桶分配到磁盘上了。然后，对每个Partition做一趟哈希连接</p>
<p><img src="/2022/03/23/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E6%9F%A5%E8%AF%A2/18.png"></p>
<p>伪代码如下：</p>
<p><img src="/2022/03/23/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E6%9F%A5%E8%AF%A2/19.png"></p>
<p>当然，这种Block Hash Join算法存在一定的限制</p>
<p>如果每个Partition中R表的Block数量都少于B-1的话，那么算法需要对R、S表进行两趟访问：</p>
<ul>
<li>第一趟将他们读入内存然后进行 Partition, 再将它们刷盘</li>
<li>第二趟将每个Partition读入内存，进行Hash Join</li>
</ul>
<p>但是，如果有Partition中的R表的Block数量大于B-1的话，需要在此基础上继续进行Partition，因此需要多趟算法</p>
<p>如果按照正常的都小于B-1来说，Hash Join访问磁盘Block的次数为：$3N_R+3N_S$ 。 其中，第一趟算法读取和刷盘就包含了$2N_R+2N_S$ ，第二次读取包含了 $N_R+N_S$</p>
<h5 id="Hybrid-Hash-Join"><a href="#Hybrid-Hash-Join" class="headerlink" title="Hybrid Hash Join"></a>Hybrid Hash Join</h5><p>还可以对Block Hash Join做进一步优化，也就是对部分 Partition 做一趟算法，部分用两趟算法</p>
<ul>
<li>假设构建k个桶，对其中m个桶完全保留在内存中，其他k-m个桶只保留一个block</li>
</ul>
<p><img src="/2022/03/23/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E6%9F%A5%E8%AF%A2/20.png"></p>
<h3 id="基于块的排序算法"><a href="#基于块的排序算法" class="headerlink" title="基于块的排序算法"></a>基于块的排序算法</h3><p>同样的，对于另外一个阻塞算子——排序，如果是基于块的情况下，是怎么样的？</p>
<p>首先，我们有$N_R$ 个块，但内存只有 B-1 个块，$N_R&gt;B-1$ ， 此时该如何借助内存进行排序</p>
<p>我们可以从$N_R$ 个块中每次取出 $B-1$ 个块，然后对其进行排序，排序完以后将其刷回磁盘，记为部分1；这样一直记录到部分x。</p>
<p>这样一共会得到 x个排好序的部分，如果$x<B-1 $， 那么就可以继续做多路归并排序； 如果$x>B-1$ ，那么再对一些部分做归并。</B-1></p>
<p>因此可能是两趟，也可能是多趟排序</p>
<h2 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h2><p>查询优化器的目标是在众多查询计划中选择一个高效的查询执行计划。</p>
<ul>
<li>在集中式数据库中，高效的指标取决于I/O代价、CPU代价和查询的内存开销。</li>
<li>在分布式数据库中，评估的总代价=I/O代价+CPU代价+通信代价</li>
</ul>
<p>之前我们说了有两种优化分类：</p>
<ul>
<li>逻辑优化主要是关系代数表达式的等价变化</li>
<li>物理优化更加细致，主要可分三点<ul>
<li>存取路径：索引、基本表</li>
<li>底层操作算子的选择：连接算子的选择、聚合算子选择等</li>
<li>多表连接顺序选择(其实也是一种关系代数表达式的变换)</li>
</ul>
</li>
</ul>
<h3 id="逻辑优化-关系表达式转换"><a href="#逻辑优化-关系表达式转换" class="headerlink" title="逻辑优化-关系表达式转换"></a>逻辑优化-关系表达式转换</h3><p>目标：通过对关系代数表达式的等价变换来提高查询效率</p>
<p>如果两个关系代数表达式在每个合法数据库实例上生成相同的元组集，则称这两个关系代数表达式是等价的</p>
<h4 id="逻辑优化案例"><a href="#逻辑优化案例" class="headerlink" title="逻辑优化案例"></a>逻辑优化案例</h4><p>下面是一个JOIN带选择的SQL语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> S.SN</span><br><span class="line"><span class="keyword">FROM</span> S,SC</span><br><span class="line"><span class="keyword">WHERE</span> S.S =SC.S  <span class="keyword">AND</span> SC.C =‘C2’;</span><br></pre></td></tr></table></figure>
<p>假定学生－课程数据库中有1000个学生记录，10000个选课记录，其中选修C2课程的选课记录为50个。</p>
<p><img src="/2022/03/23/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E6%9F%A5%E8%AF%A2/24.png"></p>
<p>这三种方法的评估计划时间的成本差异可能很大，可能是秒级与天级的差异</p>
<p>从代价上看，第三种是最好的，也就是现在SC中做好选择，再去和S表做连接。这比前两种要快很多，几乎可以称为是一条规则了。</p>
<h4 id="常用的等价变换规则"><a href="#常用的等价变换规则" class="headerlink" title="常用的等价变换规则"></a>常用的等价变换规则</h4><ol>
<li>连接、笛卡尔积交换律</li>
</ol>
<p>设E1和E2是关系代数表达式，F 是连接运算的条件，则有</p>
<script type="math/tex; mode=display">
E_1\times E_2 ≡ E_2\times E_1\\
E_1\bowtie E_2 ≡ E_2\bowtie E_1\\
E_1\bowtie_F E_2 ≡ E_2\bowtie_F E_1</script><ol>
<li>连接、笛卡尔积的结合律，设E1，E2，E3是关系代数表达式，F1和F2是连接运算的条件，则有：</li>
</ol>
<script type="math/tex; mode=display">
(E_1\times E_2)\times E_3≡E_1\times(E_2\times E_3)\\
(E_1\bowtie E_2)\bowtie E_3 ≡ E_1\bowtie(E_2\bowtie E_3)\\

(E_1\bowtie_{F_1} E_2)\bowtie_{F_2} E_3 ≡ E_1\bowtie_{F_1}(E_2\bowtie_{F_2} E_3)\\</script><p>当然，这些只是改变表和表之间连接的顺序，可能需要放到物理优化中去，因为在逻辑优化中是看不出来哪个式子代价大的</p>
<ol>
<li>选择与笛卡尔积的交换律, 如果F中涉及的属性都是E1中的属性，则</li>
</ol>
<script type="math/tex; mode=display">
\sigma_F(E_1\times E_2)≡\sigma_F(E_1) \times E_2\\</script><p>如果$F=F_1\land F_2$ ，并且 $F_1$ 只涉及 $E_1$ 中的属性，$F_2$ 只涉及$E_2$ 中的属性，则由上面的等价变换规则可推出：</p>
<script type="math/tex; mode=display">
\sigma_F(E_1\times E_2) ≡ \sigma_{F_1}(E_1)\times \sigma_{F_2}(E_2)</script><p>若$F_1$涉及$E_1$ 中的属性，$F_2$ 涉及$E_1$和$E_2$两者的属性，则仍有下式，它使得部分选择在笛卡尔积前先做</p>
<script type="math/tex; mode=display">
\sigma_F(E_1\times E_2) ≡ \sigma_{F_2}(\sigma_{F_1}(E_1)\times E_2)</script><h4 id="实现逻辑优化—基于规则优化"><a href="#实现逻辑优化—基于规则优化" class="headerlink" title="实现逻辑优化—基于规则优化"></a>实现逻辑优化—基于规则优化</h4><p>在逻辑优化阶段，我们对查询树依次执行设置的启发式规则，如果满足，则执行规则</p>
<p>–  启发式规则。比如说，选择下推——编码时将选择操作绑定到扫描算子上</p>
<p>– 如何实现？</p>
<ul>
<li><p>通常可以调整查询树的数据结构</p>
</li>
<li><p>有些规则需要独特编码方式实现</p>
</li>
</ul>
<p>还有一些比较好用的规则，如下：</p>
<p><strong>把投影运算和其他运算结合</strong></p>
<p><strong>条件化简</strong></p>
<p>利用等式和不等式的性质，可以将WHERE、HAVING和ON条件化简</p>
<ul>
<li>常量传递：使得条件分离后有效实施“条件下推”<ul>
<li><code>Col_1 = Col_2 AND Col_2=3</code>化简为 <code>Col_1=3 AND Col2=3</code></li>
</ul>
</li>
<li>消除死码：化简条件，去除不必要的条件<ul>
<li><code>WHERE (0&gt;1 AND s1=5)</code>,条件恒假，则不必执行该SQL</li>
</ul>
</li>
<li>表达式计算：加快计算效率<ul>
<li><code>WHERE Col_1=1+2</code> 变换为 <code>WHERE Col_1=3</code></li>
</ul>
</li>
<li>不等式变换：化简条件，去除不必要的条件<ul>
<li><code>a&gt;10 AND b = 6 AND a&gt;2</code> 化简为<code>b=6 AND a&gt;10</code></li>
</ul>
</li>
<li>谓词传递闭包：加速计算，有效实施“条件下推”<ul>
<li><code>a&gt;b AND b&gt;2</code> 推导出 <code>a&gt;b AND b&gt;2 AND a&gt;2</code></li>
</ul>
</li>
</ul>
<p><strong>子查询展开</strong></p>
<p>又称子查询上拉，实质是把某些子查询重写为等价的多表连接操作</p>
<p>优势：连接方法和连接顺序选择更加灵活</p>
<p>比如说：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1,</span><br><span class="line">(<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t2 <span class="keyword">WHERE</span> t2.a2&gt;<span class="number">10</span>) v_t2</span><br><span class="line"><span class="keyword">WHERE</span> t1.a1&lt;<span class="number">10</span> <span class="keyword">AND</span> v_t2.a2&lt;<span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>可以被优化为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span></span><br><span class="line">t1,t2</span><br><span class="line"><span class="keyword">WHERE</span> t1.a1&lt;<span class="number">10</span> <span class="keyword">AND</span> t2.a2 &lt;<span class="number">20</span> <span class="keyword">AND</span> t2.a2&gt;<span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>因为第一种的方法，相当于t2表给限制了一部分，那么在选择的时候就没那么灵活。但是第二种方法就可以在WHERE中更加灵活地组织条件。</p>
<p><strong>外连接消除</strong></p>
<ul>
<li>右表存在非Null条件</li>
</ul>
<p><code>SELECT * FROM T1 LEFT JOIN T2 ON T1.c1 = T2.c1 WHERE T2.c2 &gt; 0</code></p>
<p>注意这里SQL执行顺序是先做JOIN，再做选择。通常使用外连接的话可以降低失误率,但外连接的代价比非外连接要大很多。那么在做查询优化的时候就可以消除外连接，然后把选择可以优化为：</p>
<p><code>SELECT * FROM T1,T2 WHERE T1.c1 = T2.c1 and R.c2&gt;0</code></p>
<ul>
<li>满足传递性链式非NULL条件</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> T1 </span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> T2 <span class="keyword">ON</span> T1.c1 = T2.c1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> T3 <span class="keyword">ON</span> T2.c2 = T3.c2</span><br><span class="line"><span class="keyword">WHERE</span> T3.c3 &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>可以优化为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> T1,T2,T3</span><br><span class="line"><span class="keyword">WHERE</span> T1.c1 = T2.c1 </span><br><span class="line"><span class="keyword">AND</span> T2.c2 = T3.c2</span><br><span class="line"><span class="keyword">AND</span> T3.c3 &gt; <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<h3 id="物理优化"><a href="#物理优化" class="headerlink" title="物理优化"></a>物理优化</h3><p>逻辑优化改变查询语句中操作的次序和组合，不涉及底层的存取路径</p>
<p>对于一个查询语句的算子有很多实现方案，它们的执行效率不同</p>
<p>物理优化就是要选择高效合理的操作算子、数据访问路径和查询树结构，求得相对最优的查询计划</p>
<ul>
<li><p>基于规则的优化</p>
</li>
<li><p>基于代价的优化</p>
</li>
</ul>
<h4 id="优化案例-路径选择"><a href="#优化案例-路径选择" class="headerlink" title="优化案例-路径选择"></a>优化案例-路径选择</h4><p>在查询引擎中，选择操作通常由两种实现方法：</p>
<ol>
<li>简单的全表扫描方法</li>
</ol>
<p>对查询的基本表顺序扫描，逐一检查每个元组是否满足选择条件，把满足条件的元组作为结果输出。这是和小表操作，但并不适合大表</p>
<ol>
<li>索引(或散列)扫描方法</li>
</ol>
<p>适合条件中的属性上有索引(B+树索引/哈希索引)，通过索引先找到满足条件的元组主码或者元祖指针，再通过元祖指针直接在查询的基本表中找到元组</p>
<p>现在来看最典型的SQL查询： <code>SELECT * FROM student WHERE &lt;条件表达式&gt;</code> ，通常有这几种情况</p>
<ul>
<li>C1: 无条件</li>
<li>C2: Sno=’200215121’</li>
<li>C3: Sage&gt;20;</li>
<li>C4: Sdept=’CS’ AND Sage&gt;20</li>
</ul>
<p>如果以C2为例，Sno上如果有索引，那么就可以使用索引得到Sno为’200215121‘ 元组的指针，通过元组指针在student表中检索到该学生。如果没有索引的话，就需要全表扫描了</p>
<p>以C3为例，Sage&gt;20,并且Stage有B+树索引。那么，使用B+树索引可以找到Sage=20的索引项，以此为入口点在B+树的顺序集得到Sage&gt;20的所有元组指针。通过这些元组指针到student表中检索到所有年龄大于20的学生</p>
<p>那么查询优化器该选择哪种方式呢？全表扫描还是利用索引+回表的方式进行查询</p>
<ul>
<li>如果预先知道结果比较少，就应该使用索引+回表的方式。</li>
<li>如果最后的结果很多，甚至整张表都是，那么还是全表扫描比较快。因为找那么多索引再去点查的代价非常高</li>
</ul>
<p>这两种方法如果选的不好，可能是数十倍的差距，因此，代价评估就非常重要了。</p>
<p>现在来看看更复杂的情况：以C4为例，<code>Sdept＝‘CS’ AND Sage&gt;20</code>，如果Sdept和Sage上都有索引：</p>
<p><strong>算法一</strong>：分别用上面两种方法分别找到<code>Sdept＝‘CS’</code>的一组元组指针和<code>Sage&gt;20</code>的另一组元组指针。求这2组指针的交集，将其放到student表中检索，得到计算机系年龄大于20的学生</p>
<p><strong>算法二</strong>：找到<code>Sdept＝‘CS’</code>的一组元组指针，那么通过这些元组指针到student表中检索，然后 对得到的元组检查另一些选择条件(如<code>Sage&gt;20</code>)是否满足。最后把满足条件的元组作为结果输出。</p>
<p>在数据库中，第一种方法是不会去实现的，通常<strong>只会挑选一个属性去做索引查询</strong>。因此，问题被简化为三种情况：选择Sdept做索引查询、选择Sage做索引查询、全表扫描。<strong>最终选择那一种方法还是要看选择率的高低</strong></p>
<ul>
<li>如果表中只有一个通选学了CS，那么就应该选择Sdept作为索引</li>
<li>如果表中Sage&gt;20的同学只有一两个，那么就需要选Sage做索引查询</li>
<li>如果选择率都不是很低，那么应该做全表扫描</li>
</ul>
<h4 id="路径选择操作的启发式规则"><a href="#路径选择操作的启发式规则" class="headerlink" title="路径选择操作的启发式规则"></a>路径选择操作的启发式规则</h4><ul>
<li><p>对于小关系(&lt;1000行):</p>
<ul>
<li>使用全表顺序扫描，即使选择列上有索引</li>
</ul>
</li>
<li><p>对于大关系( 对于选择条件是主码＝值的查询)：</p>
<ul>
<li>查询结果最多是一个元组，可以选择主码索引</li>
</ul>
</li>
<li><p>对于选择条件是非主属性＝值的查询，并且选择列上有索引</p>
<ul>
<li>估算查询结果的元组数目:比例较小(&lt;10%)可以使用索引扫描方法, 否则全表顺序扫描</li>
</ul>
</li>
<li><p>对于选择条件是属性上的非等值查询或者范围查询，并且选择列上有索引</p>
<ul>
<li>估算查询结果的元组数目:比例较小(&lt;10%)可以使用索引扫描方法, 否则全表顺序扫描</li>
</ul>
</li>
</ul>
<h4 id="选择操作的启发式规则"><a href="#选择操作的启发式规则" class="headerlink" title="选择操作的启发式规则"></a>选择操作的启发式规则</h4><ul>
<li><p>对于用AND连接的多路选择条件</p>
<ul>
<li><p>如果有涉及这些属性的组合索引, 优先采用组合索引扫描方法</p>
</li>
<li><p>如果某些属性上有一般的索引, 选择选择率最低的一个索引</p>
</li>
</ul>
</li>
<li><p>对于用OR连接的析取选择条件，一般使用全表顺序扫描</p>
</li>
</ul>
<h4 id="连接操作的启发式规则"><a href="#连接操作的启发式规则" class="headerlink" title="连接操作的启发式规则"></a>连接操作的启发式规则</h4><ul>
<li><p>如果2个表都已经按照连接属性排序</p>
<ul>
<li>选用排序-合并方法</li>
</ul>
</li>
<li><p>如果前表较小，后表在连接属性上有索引</p>
<ul>
<li>选用Nest Loop索引连接方法</li>
</ul>
</li>
<li><p>如果上面2个规则都不适用，其中一个表较小</p>
<ul>
<li>选用Hash join方法或内存Nest Loop Join</li>
</ul>
</li>
<li><p>否则采用Block Nest Loop Join或Grace Hash Join</p>
</li>
</ul>
<h3 id="基于代价的优化"><a href="#基于代价的优化" class="headerlink" title="基于代价的优化"></a>基于代价的优化</h3><p>必要条件</p>
<ul>
<li>实现数据统计信息，用于帮助计算代价</li>
</ul>
<p>核心代价模型</p>
<ul>
<li><p>访问路径</p>
</li>
<li><p>多表连接顺序</p>
</li>
<li><p>执行算子(很多情况下使用规则代替)</p>
</li>
<li>连接、聚集</li>
</ul>
<p>那么统计信息哪里来？我们可以列出如下几种</p>
<h4 id="统计信息"><a href="#统计信息" class="headerlink" title="统计信息"></a>统计信息</h4><ol>
<li><p>对每个基本表</p>
<ul>
<li>该表的元组总数(N)</li>
<li>元组长度(l)</li>
<li>占用的块数(B)</li>
<li>占用的溢出块数(BO)</li>
</ul>
</li>
<li><p>对基表的每个列</p>
<ul>
<li><strong>该列不同值的个数(m)</strong>(用于估算Join结果)</li>
<li><p><strong>选择率(f)</strong></p>
<ul>
<li>如果不同值的分布是均匀的，f＝1/m</li>
<li>如果不同值的分布不均匀，则每个值的选择率＝具有该值的元组数/N</li>
</ul>
</li>
<li><p>该列最大值/最小值</p>
</li>
<li><p>该列上是否已经建立了索引</p>
</li>
<li><p>索引类型(B+树索引、Hash索引)</p>
</li>
</ul>
</li>
<li><p>对索引(如B+树索引)</p>
<ul>
<li><p>索引的层数(L)</p>
</li>
<li><p>不同索引值的个数</p>
</li>
<li><p>索引的选择基数S(有S个元组具有某个索引值)</p>
</li>
<li><p>索引的叶结点数(Y)</p>
</li>
</ul>
</li>
</ol>
<h4 id="访问路径代价模型"><a href="#访问路径代价模型" class="headerlink" title="访问路径代价模型"></a>访问路径代价模型</h4><ul>
<li><p>全表扫描算法的代价估算公式</p>
<ul>
<li><p>如果基本表大小为B块，全表扫描算法的代价cost＝B</p>
</li>
<li><p>如果选择条件是码＝值，那么平均搜索代价cost＝B/2</p>
</li>
</ul>
</li>
<li><p>索引扫描算法的代价估算公式</p>
<ul>
<li><p>如果选择条件是码＝值</p>
<ul>
<li>如［例-C2］，则采用该表的主索引<ul>
<li>若为B+树，层数为L，需要存取B+树中从根结点到叶结点L块，再加上基本表中该元组所在的那一块，所以<code>cost=L+1</code></li>
</ul>
</li>
</ul>
</li>
<li><p>如果选择条件涉及非码属性</p>
<ul>
<li>如［例-C3］，若为B+树索引，选择条件是相等比较，S是索引的选择基数(有S个元组满足条件，选择率)</li>
<li>最坏的情况下，满足条件的元组可能会保存在不同的块上，此时，cost=L+S</li>
</ul>
</li>
<li><p>如果比较条件是＞，＞＝，＜，＜＝操作</p>
<ul>
<li>假设有一半的元组满足条件就要存取一半的叶结点</li>
<li>通过索引访问一半的表存储块cost=L+B/2 </li>
<li>如果可以获得更准确的选择基数，可以进一步修正B/2</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="多表连接顺序搜索策略"><a href="#多表连接顺序搜索策略" class="headerlink" title="多表连接顺序搜索策略"></a>多表连接顺序搜索策略</h4><p>常常使用启发式+基于代价的搜索，比如说枚举、DP算法等，也可以用随机算法</p>
<p>连接顺序常常是树形结构(使用左深树),它有几个好处</p>
<ul>
<li>每个连接算子的右侧输入是一个关系（基本表），而不是连接后的中间结果</li>
<li>基于成本的优化是昂贵的，但对于大型数据集的查询是有价值的（典型的查询具有较小的n，通常小于10）</li>
</ul>
<p><img src="/2022/03/23/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E6%9F%A5%E8%AF%A2/23.png"></p>
<p>左深树如上图所示，R和S做Join，然后其结果和T做Join，其结果在和U做Join</p>
<p>但是在一些比较新的数据仓库中，会让B和C分别建一个哈希表，然后用A去探索这两个哈希表，实际上用的是右深树</p>
<h3 id="几个难题"><a href="#几个难题" class="headerlink" title="几个难题"></a>几个难题</h3><p>为什么查询优化器对代价的估计可能估不准？查询优化器非常难设计。其实都集中在统计信息上。</p>
<ul>
<li>统计信息的选择自动收集与更新非常难，因为数据库在不断运行，数据在不断更新</li>
<li><p>选择条件下数据的条件分布，(满足A的条件下去选择 B),这样导致原先统计数据在这种情况下是没什么用的。而我们又无法为所有的分布创建一个直方图，因此通常导致估算不准确。</p>
</li>
<li><p>计划不准导致的查询超时无法从理论上避免</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>逻辑优化</p>
<ul>
<li>定义一些启发式规则</li>
</ul>
</li>
<li><p>物理优化</p>
<ul>
<li><p>先决定访问路径</p>
</li>
<li><p>启发式规则决定连接顺序与连接方式</p>
</li>
</ul>
</li>
</ul>
<p><img src="/2022/03/23/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-%E6%9F%A5%E8%AF%A2/25.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/03/08/AI-Searching/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/08/AI-Searching/" class="post-title-link" itemprop="url">AI-Searching</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-08 19:16:27" itemprop="dateCreated datePublished" datetime="2022-03-08T19:16:27+08:00">2022-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-03 15:25:34" itemprop="dateModified" datetime="2022-04-03T15:25:34+08:00">2022-04-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Searching"><a href="#Searching" class="headerlink" title="Searching"></a>Searching</h1><p>搜索的方法有很多种，但是大体上可以分为两个大类——盲搜和有先验知识的搜索</p>
<h2 id="Uninformed-Search-Methods"><a href="#Uninformed-Search-Methods" class="headerlink" title="Uninformed Search Methods"></a>Uninformed Search Methods</h2><h3 id="Depth-First-Search"><a href="#Depth-First-Search" class="headerlink" title="Depth-First Search"></a>Depth-First Search</h3><h3 id="Breadth-First-Search"><a href="#Breadth-First-Search" class="headerlink" title="Breadth-First Search"></a>Breadth-First Search</h3><h4 id="Interative-Deepening"><a href="#Interative-Deepening" class="headerlink" title="Interative Deepening"></a>Interative Deepening</h4><h3 id="Uniform-Cost-Search"><a href="#Uniform-Cost-Search" class="headerlink" title="Uniform-Cost Search"></a>Uniform-Cost Search</h3><p>对于深搜和广搜我们都已经十分了解了，现在我们来学习另外一种搜索方式——代价一致性搜索，即Uniform-Cost Search(UCS). 其示意图如下：</p>
<p><img src="/2022/03/08/AI-Searching/1.png" style="zoom:67%;"></p>
<p>首先，如果要使用UCS进行搜索，我们需要先定义一个 $g(n)$, 它代表了根到第n个节点的代价。UCS的代价就是，每次选择$g(n)$最小的节点进行展开，不管它它的目标状态有有多远。因此，UCS</p>
<h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><p>(1）将起始点加入到frontier中，将与frontier相连的点进行探索，每个点的代价（后面用cost替代）是从起点到该点的距离，然后将所有的点加入到frontier里面</p>
<p>(2) 从frontier里面挑出cost最小的点A，判断该点是不是终点，如果是终点算法结束。如果不是终点，探索与该点相连的所有点，每个点的cost是A点的cost加上A点到B点的路径的权重。如果B点是已经出现在frontier里面了，比较一下原来的cost与新生成的cost哪个更小，然后将最小的cost赋值给B点，并更新它的父节点。</p>
<p>(3) 如果frontier为空还没有找到终点，则没有到达终点的最短路径</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><img src="/2022/03/08/AI-Searching/2.png"></p>
<p>对于上面这张图，我们对其进行UCS搜索，找到S到G的最短路径。</p>
<ol>
<li>首先，S的邻接节点是d、e、p，他们的$g(n)$分别为： $g(d)=3,g(e)=9,g(p)=1$</li>
<li>我们选择$g(n)$最小的节点p，并把p的邻接节点q加入到队列。现在的队列为：$g(d)=3,g(e)=9,g(q)=16$ </li>
<li>选择$g(n)$最小的节点d，并把d的邻接节点b、c、e加入到队列。现在的队列为：$g(b)=4,g(c)=11,g(e)=5,g(q)=16$</li>
<li>选择$g(n)$最小的节点b，并把b的邻接节点a加入队列。现在的队列为：$g(a)=6,g(c)=11,g(e)=5,g(q)=16$</li>
<li>选择$g(n)$最小的节点e，并把e的邻接节点h、r 加入队列。现在的队列为：$g(a)=6,g(r)=7,g(c)=11,g(h)=13,g(q)=16$</li>
<li>选择$g(n)$最小的节点a,但a没有邻接节点。因此选择次小节点r，并把r的邻接节点f加入队列。现在的队列为：$g(f)=8,g(c)=11,g(h)=13,g(q)=16$</li>
<li>选择$g(n)$最小的节点f,把f的邻接节点加入队列。现在队列为$g(G)=10,g(c)=11,g(h)=13,g(q)=16$</li>
<li>找到了$S$ 到 $G$ 的道路</li>
</ol>
<p><img src="/2022/03/08/AI-Searching/3.png"></p>
<p>整个过程如上图所示。</p>
<h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><p>既然UCS算法是根据当前节点的$g(n)$去进行搜索的，那么就需要一个数据结构来帮助我们存储这些节点的代价。这里我们选择的就是Priority Queue(优先级队列)</p>
<p>由于我们的策略是选择优先队列中代价最小的节点，那么假设目标节点的代价为C*,每次搜索一条边的平均代价为$\varepsilon$.那么UCS的搜索深度就是 $C^*/\varepsilon$ .</p>
<p>由BFS的空间和空间复杂度为$O(b^s)$可推得，UCS要找到目标节点的时间复杂度为: $O(b^{C^<em>/\varepsilon})$ ，空间复杂度也为$O(b^{C^</em>/\varepsilon})$</p>
<p><img src="/2022/03/08/AI-Searching/4.png"></p>
<p>那么UCS是complete的吗?（能够找到最优解)</p>
<ul>
<li>如果$C^*$ 是有限且$\varepsilon&gt;0$的话, 那么UCS是可以找到最优解的</li>
</ul>
<p>那么UCS是optimal的吗?（能够以最小的代价找到最优解)</p>
<ul>
<li>是的，我们将在接下来的$A^*$Search中对其证明</li>
</ul>
<h2 id="Informed-Search-Methods"><a href="#Informed-Search-Methods" class="headerlink" title="Informed Search Methods"></a>Informed Search Methods</h2><p>和之前的盲搜不同，Informed Search Methods是有一些先验知识的搜索方式。在这里我们主要介绍3种方式：启发式搜索、贪心搜索和A*搜索。</p>
<h4 id="什么是启发-Heuristics"><a href="#什么是启发-Heuristics" class="headerlink" title="什么是启发(Heuristics)"></a>什么是启发(Heuristics)</h4><p>启发，是一个<strong>估计某一状态距离目标状态有多近的函数</strong>(不一定完全准确)， 它为特定的搜索问题而设计，无法保证最优性。</p>
<p>我们举一个例子：翻煎饼问题。现在有大小不同的四张煎饼，它们以一种混乱的方式排列，我们的目标是将其从小到大排列好。其中，完成目标的代价是每次翻的时候翻了多少煎饼。比如说初始的状态如下所示：</p>
<p><img src="/2022/03/08/AI-Searching/5.png"></p>
<p>从初始状态可以一步到位变成最终状态，只需要反动三张煎饼即可。</p>
<p>下图展示了在四张煎饼的情况下，各个状态互相转变所需要的代价：</p>
<p><img src="/2022/03/08/AI-Searching/6.png"></p>
<p>要找出某个状态到最终状态需花费的最小代价，可以用UCS，但是更好的方法是：告诉电脑以当前状态有多少煎饼不在正确的位置作为启发，并进行搜索。</p>
<ul>
<li><p>又比如，对于pacman小游戏来说，我要让吃豆人以最优的方法到达目标位置，可以告诉电脑当前吃豆人距离目标点的欧几里得距离或者是曼哈顿距离。</p>
</li>
<li><p>再比如，对于罗马尼亚旅行问题，我们可以以任意两个城市之间的直线距离作为启发。</p>
<p><img src="/2022/03/08/AI-Searching/7.png"></p>
</li>
</ul>
<h3 id="Greedy-Search"><a href="#Greedy-Search" class="headerlink" title="Greedy Search"></a>Greedy Search</h3><p>贪心就是一种启发式搜索，但是某些基于贪心的启发式可能会退化成dfs（如果这种贪心完全没有起效果，就等同于在dfs中任意选择下一个节点展开）</p>
<p>启发式的搜索展开节点时，选择可能离目标状态“最近”的节点展开。（例如旅行问题中，展开直线距离离目标节点最小的节点）</p>
<p>贪心法可能让我们获得一个比较好的解，但是无法保证获得的结果一定是最优的。如下图：机器人朝着一颗钻石挖去，挖到了，但是却忽视了更大的两颗钻石</p>
<p><img src="/2022/03/08/AI-Searching/8.png"></p>
<h3 id="A-Search"><a href="#A-Search" class="headerlink" title="A* Search"></a>A* Search</h3><p>A<em> 算法是UCS和贪心算法两者的结合。我们以龟兔赛跑为例，UCS是乌龟、贪心是兔子，结合两者的优点是A</em> 算法。</p>
<p><img src="/2022/03/08/AI-Searching/9.png"></p>
<p>比如说对于上面这张图，每条边都有权重。我们的目标就是，从S出发，找到一条到G的最佳路线。用树来表示，如下</p>
<p><img src="/2022/03/08/AI-Searching/10.png" style="zoom:50%;"></p>
<ul>
<li><p>如果采用UCS：每次展开的是当前已花费代价最小的节点，即<strong>回首过去</strong></p>
<ul>
<li>从s出发，首先展开a， 现在$g(b)=2,g(e)=9,g(d)=4$</li>
<li>展开$b$,现在$g(c)=3,g(d)=4,g(e)=9$ </li>
<li>展开$c$, 发现没路了，而且没到终点，现在$g(d)=4,g(e)=9$</li>
<li>展开$d$,$g(g) = 6,g(e)=9$</li>
<li>展开$g$ ,到达终点</li>
</ul>
<p>路线为：$s\rightarrow a\rightarrow b\rightarrow c \rightarrow d\rightarrow g$ , 虽然找到了最有线路，但是绕了一个弯</p>
</li>
<li><p>如果采用贪心法：每次展开启发函数最小的节点，即<strong>展望未来</strong>。</p>
<ul>
<li>从s出发，首先展开a，$h(e)=1,h(d)=2,h(b)=6$ ，注意，这里的$h(e)=1$ 是通过某种启发算出来的，这里只是举个例子。</li>
<li>展开$e$，$h(d)=2,h(b)=6$ </li>
<li>展开$d$, $h(g)=0,h(b)=6$</li>
<li>展开$g$, 到达终点</li>
</ul>
<p>路线为：$s\rightarrow a \rightarrow e \rightarrow d \rightarrow g$ ， 找错了线路</p>
</li>
<li><p>而使用A*算法，结合了ucs和greedy的优点，即回首过去+展望回来。令函数 $f(n) = g(n)+h(n)$ ,A* 算法中维护一个优先队列，按照$f(n)$ 的值从小到大进行维护。</p>
</li>
</ul>
<ul>
<li>从s出发，首先展开a，$,f(d)=4+2=6,f(b)=2+6 = 8,f(e) = 1+9=10$</li>
<li>展开d，$f(g) = 6,f(b)=8,f(e)=10$</li>
<li><p>展开g</p>
<p>路线为：$s\rightarrow a\rightarrow d\rightarrow g$, 找到了最佳线路，而且花费的时间也最短。</p>
</li>
</ul>
<h4 id="A-算法何时终止？"><a href="#A-算法何时终止？" class="headerlink" title="A*算法何时终止？"></a>A*算法何时终止？</h4><p>第一次遇见目标节点（遇见，就是指展开了目标节点的父节点，将目标节点加入队列）时不能退出（此时不一定最优）。只有把一个目标节点剔除队列的时候，才会让算法终止。</p>
<p>记忆： enqueue不止，dequeue才止</p>
<p><img src="/2022/03/08/AI-Searching/11.png" style="zoom: 100%;"></p>
<ul>
<li><p>从S出发，$f(B)=1+2=3, f(A) = 2+2=4$</p>
</li>
<li><p>展开B，如果之后选择G节点展开，但是s-b-g的代价比s-a-g的代价要大，所以不能退出</p>
</li>
<li>因为此时$f(A)&lt; f(G)$，所以这个时候展开A</li>
<li>然后从A到G，找到最优的路线</li>
<li>将G从队列中移除，停止算法</li>
</ul>
<h4 id="A-算法的最优性"><a href="#A-算法的最优性" class="headerlink" title="A*算法的最优性"></a>A*算法的最优性</h4><p>现在我们来讨论A*算法是不是最优的？</p>
<p>要考虑这个问题，首先我们要想，A*算法是不是始终是正确的？一个很朴素的想法就是，如果我们的启发函数错误地估计了节点到目标节点的距离(比真实值大了很多)，那么这时候A*算法肯定不会选择这个节点作为下个展开的节点。</p>
<p>这时候，我们要设定能使A*算法最优的一个前提：Admissible Heuristics（容许的启发）</p>
<script type="math/tex; mode=display">
0\le h\le h^*(n)</script><p>即启发式算法的估价应该在0和真实代价之间。如果h(n)大于真实代价，则可能找不到最优解，不能保证最优性。</p>
<h5 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h5><p>在满足Admissible Heuristics时，A*搜索算法的最优性是可以被证明的：</p>
<p><img src="/2022/03/08/AI-Searching/12.png"></p>
<p>假设：</p>
<ul>
<li>A是最优目标节点 optimal goal node</li>
<li>B是次优目标节点 suboptimal goal node</li>
<li>h is admissible，估值满足$0\le h\le h^*(n)$</li>
</ul>
<p>证明思路</p>
<ul>
<li>A会在B之前被弹出（fringe）</li>
<li>假设A的祖先n（n可以是A本身）、B，都在待展开的队列边缘（on the fringe），证明n会在B之前被展开</li>
</ul>
<p>证明过程：</p>
<ul>
<li>首先：我们要证明 $f(n)\leq f(A)$ 。 可以从定义入手：<ul>
<li>$f(n)=g(n)+h(n)$ </li>
<li>$g(A) = g(n)+h*(n)$ </li>
<li>$f(A)=g(A)+0 $  (因为$h(A) = 0$) </li>
<li>根据假设 $h(n)\leq h*(n)$ 可知， $f(n)\leq f(A)$ </li>
</ul>
</li>
<li>然后，我们要证明 $f(A)\leq f(B)$ <ul>
<li>$g(A)&lt;g(B)$  A是最优解，B是次优解。</li>
<li>$f(A)&lt;f(B)$ 因为对于AB来说 ，$h(A)=h(B)=0$</li>
</ul>
</li>
</ul>
<p>因此，所有A的祖先(包括A自己) 都会在B之前被展开。这可以证明，当任意目标节点被dequeue时，最优路径已经被找到了。</p>
<p>关于证明的细节：为什么不仅要证明A会在B之前被展开，还要证明A的祖先也会在B之前被展开？因为证明的假设是A和B都要在队列边缘（A和B都已经被遇见）。我们想证明的是，当B在队列边缘时，总有一个A或A的祖先也在队列边缘，并比B拥有更高的展开优先级。</p>
<p>如果只证明A自身，那么当B在队列边缘时A也在队列边缘这一前提是无法被保证的。</p>
<p>因此我们证明A或A的祖先在队列边缘的情况，应为这能保证在B弹出之前至少会有A或者A的祖先(甚至是根)在队列边缘</p>
<h4 id="A-和UCS的比较"><a href="#A-和UCS的比较" class="headerlink" title="A*和UCS的比较"></a>A*和UCS的比较</h4><p><img src="/2022/03/08/AI-Searching/13.png" style="zoom: 50%;"></p>
<p>然后我们来看一下在树形状态下，UCS和A*算法的比较。 </p>
<p><img src="/2022/03/08/AI-Searching/15.png"></p>
<p>最后我们看一下pacman游戏中，三种不同算法的查询过程比较：</p>
<p><img src="/2022/03/08/AI-Searching/14.png"></p>
<p>感性理解：A*算法避免了很多没有必要的搜索，A*算法是一种“对冲”，即基于启发式估计h对UCS算法进行“瘦身”。称之为“对冲”是因为启发式估计本身是不确定的，相信这个估计本身就是存在风险的。</p>
<h2 id="怎么设计Heuristic"><a href="#怎么设计Heuristic" class="headerlink" title="怎么设计Heuristic"></a>怎么设计Heuristic</h2><p>原始问题通过松弛 relax 来进行处理。例如把整数解问题转换成实数解问题。</p>
<p>设计heuristic的时候也可以先对原问题进行简单的松弛，例如：</p>
<ul>
<li>在旅行问题中，直接使用两点间距离</li>
<li>在迷宫问题中，不考虑阻隔，直接使用曼哈顿距离</li>
</ul>
<h3 id="是否必须admissible"><a href="#是否必须admissible" class="headerlink" title="是否必须admissible"></a>是否必须admissible</h3><p>admissible：估值小于等于真实代价</p>
<p>但如果估值比真实代价小太多，也不好。</p>
<p><strong>如果admissible不满足呢？考虑真实代价为9，估值为0.01和估值为10两种情况。</strong></p>
<p><strong>即使10不是admissible的，但起到的效果更好。</strong></p>
<h3 id="具体案例"><a href="#具体案例" class="headerlink" title="具体案例"></a>具体案例</h3><h4 id="迷宫问题中的Heuristic"><a href="#迷宫问题中的Heuristic" class="headerlink" title="迷宫问题中的Heuristic"></a>迷宫问题中的Heuristic</h4><p><img src="/2022/03/08/AI-Searching/16.png"></p>
<p>对于如何设计启发函数，我们可以提出这几个问题：</p>
<ul>
<li>状态是什么：可以当做由1-9九个数构成的向量（把灰色格子也看成一个数，比如9）。但是要考虑到每个数的位置，每个数只出现一次。</li>
<li>状态数有多少: 整个状态数是 $9!$</li>
<li>行为是什么：将一个数移动到相邻的灰色格子</li>
<li>后继状态有多少：<ul>
<li>灰色格子在角落：2</li>
<li>灰色在边界上但不在角落：3</li>
<li>灰色格子在中间：4</li>
</ul>
</li>
<li>真实cost：隔板的真实移动次数。 </li>
</ul>
<p>我们并不知道真实值是多少，但我们可以用松弛的方法去进行估计。下面介绍了两种启发式 ，每周都是admissible的，因为估计的值小于真实值。</p>
<p><strong>松弛1</strong>：想象直接把板子拆下来，再直接放到正确的位置上面，一共需要几次，<strong>也就是看有多少个隔板被错误放置</strong>。我们可以想象，这种方法是将原本需要多步移动的实际情况压缩成一步到位的估计情况。</p>
<p>我们观察下面这个表格，在同样移动4步的情况下，UCS需要展开112个节点，而用TILES启发只需要展开13个节点。这种启发式估计相较于UCS展开的节点数明显减少了。</p>
<p><img src="/2022/03/08/AI-Searching/17.png"></p>
<p><strong>松弛2</strong>：不考虑其他隔板的影响（也就是假设移动的时候不会被挡住），基于曼哈顿距离。这种松弛比第一种松弛效果更好了，因为这是一个更接近真实值的松弛。因为用曼哈顿距离估计得到的步数肯定要大于等于1步.</p>
<p>如下图，要把1移到它正确的位置，用曼哈顿距离作为启发的话，是3步，而实际上，肯定不止3步。因为先要移动6这个阻挡块。</p>
<p><img src="/2022/03/08/AI-Searching/19.png"></p>
<p><img src="/2022/03/08/AI-Searching/18.png"></p>
<p>最理想的状态是把真实代价作为启发，但问题是不知道真实代价。</p>
<p>对冲（hedge）：A*需要平衡【计算估计】和【展开节点】之间的代价，需要做一个平衡。</p>
<h2 id="Semi-Lattice-of-Heuristics"><a href="#Semi-Lattice-of-Heuristics" class="headerlink" title="Semi-Lattice of Heuristics"></a>Semi-Lattice of Heuristics</h2><p>现在我们要学习启发式函数的<strong>半格</strong>特点</p>
<p>启发式函数所满足的特点：</p>
<ul>
<li>支配性Dominance：如果</li>
<li>Trivial heuristics：有一些状态的估计值是显然的。例如，目标节点的估计值就是0。</li>
<li><strong>semi-lattice半格原理：$h(n)=\max(h_a(n),h_b(n))$，取max后依然admissible</strong></li>
</ul>
<p>我们用一个例子来说明一下这个半格原理：</p>
<p><img src="/2022/03/08/AI-Searching/20.png"></p>
<p>比如说，我现在设计了三个admissible的启发式函数$h(a),h(b),h(c)$ ，且 $h_a$ 是 Dominance $h_c$的，那么在这个情况下我们取一个新的启发式函数，即对于每个节点n，都取 $h(n) = \max(h_a(n),h_b(n))$ . 在这种情况下，$h(n)$ 依然是admissible的</p>
<h2 id="Tree-Search-和-Graph-Search-对比"><a href="#Tree-Search-和-Graph-Search-对比" class="headerlink" title="Tree Search 和 Graph Search 对比"></a>Tree Search 和 Graph Search 对比</h2><p><strong>Tree search</strong>缺点：遇到有环的状态图时，会有重复展开的情况（不知道怎么规避已经展开过的节点）。如下图，我们看到e、a、p、q都是重复访问的节点。</p>
<p><img src="/2022/03/08/AI-Searching/21.png"> </p>
<p><strong>Graph search</strong>：不会展开同一个节点两次</p>
<ul>
<li><p>实现：tree search + 状态集合（记录已展开节点的集合）</p>
<ul>
<li>用集合记录是为了O(1)查询是否被展开过。使用列表的话，会额外增加搜寻所需要的时间。</li>
</ul>
</li>
<li><p>A*用Graph search来做检索会有什么问题？</p>
<p>重复状态不再展开。因此这时候就出问题了，如下图：</p>
<p><img src="/2022/03/08/AI-Searching/22.png"></p>
<ol>
<li>因为$f(B) = 1+1=2&lt;f(A)=1+4$, 所以先展开 B</li>
<li>B后面只有一个节点C，所以展开C，此时总体代价为3</li>
<li>C后面只有一个节点G，所以展开G，此时总体代价为6</li>
<li>第一次访问 <code>G(6+0)</code> 时，由于已经访问过一次，所以 <code>G</code> 就不会再被展开。</li>
<li>然后发现，$f(a) = 1+4&lt;f(G)=6+0$ ，且A未被展开过，因此访问A</li>
<li>A后面有一个节点C，且$f(C) = 2+1&lt;f(G)$ ，因此展开C</li>
<li>现在C后面是G，但是G已经被访问过了，因此A* Graph Search在这个时候就会弹出G，算法结束，返回$g(G)=6$ ,我们发现这并不是个最优解。<ul>
<li>但是使用A*  Tree Search的话，仍然会访问G,并返回 $g(G)=5$ ,此时是最优解</li>
<li>A<em> Graph Search <em>*只保证完整性，但不保证最优性。</em></em></li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="Consistency-和Admissbility"><a href="#Consistency-和Admissbility" class="headerlink" title="Consistency 和Admissbility"></a>Consistency 和Admissbility</h2><p>我们知道Admissible可以保证A<em>树搜索方法可以得到最优解。其中心思想就是：<strong>启发函数的估计值</strong> $\leq$ <em>*真实的代价</em></em></p>
<p>如下图：$h(A) = 4$ ，它是小于等于A到G的真实代价4的。</p>
<p><img src="/2022/03/08/AI-Searching/23.png"></p>
<p> 那么为了保证A<em> Graph Search也可以保证得到最优解，我们提出Consistency。<em>*这是一个比Admissible更加严格的Heuristic</em></em>。其中心思想是：</p>
<script type="math/tex; mode=display">
h(A)-h(C)\leq \text{cost}(A\rightarrow C)</script><p>用汉语来说，就是估值的边权，需要小于等于真实的变权。我们举个例子：下图中，$h(A)=4,h(C)=1$ , 但是 ， $h(A)-h(C)=3&gt; 1$ 这就不满足 consistency的标准</p>
<p><img src="/2022/03/08/AI-Searching/24.png"></p>
<p>因此，如果要满足一致性，$h(A) $ 至少是小于等于2的。</p>
<h3 id="Consistency-的最优性证明"><a href="#Consistency-的最优性证明" class="headerlink" title="Consistency 的最优性证明"></a>Consistency 的最优性证明</h3><p>前提：Consistency</p>
<p><img src="/2022/03/08/AI-Searching/25.png"></p>
<p>情况如上图，n和n’ 对应的是同一个点的不同路径状态，n比n’更优。</p>
<p><strong>假设</strong>：p是n的祖先且p在队列中，n’已经被访问了。在n’被弹出时，p在队列但未弹出。</p>
<p><strong>目标</strong>：通过反证法 证明n要先于n’被弹出</p>
<ol>
<li>因为$f(p) = g(p)+h(p)$, $f(n)=g(n)+h(n)$    $f(n) -f(p) = g(n)-g(p)+h(n)-h(p)$ </li>
</ol>
<p>我们知道，$g(n)-g(p)$ 就是三角形上n点到p点的距离.   另外，由Consistency可知，$h(p)-h(n)\leq Cost(p\rightarrow n)=g(n)-g(p)$ 。 </p>
<p>因此$f(n)-f(p)&gt;0$ ,$f(p)&lt;f(n)$ .</p>
<p>于是，由A*算法可知，p会先于n节点展开</p>
<ol>
<li>又因为n’是次优节点，因此$f(n)&lt;f’(n)$，所以$f(p)&lt;f’(n)$</li>
</ol>
<p>这种情况有矛盾出现：$f(p)&lt;f’(n)$，说明p应该在n’前被展开。</p>
<p>这与假设里n’先于p被展开相悖，所以假设不成立。</p>
<p><strong>这证明了对于任何一个点，它的最优节点一定是最先被展开的。</strong></p>
<h2 id="A-算法总结"><a href="#A-算法总结" class="headerlink" title="A* 算法总结"></a>A* 算法总结</h2><h2 id="A-star算法总结"><a href="#A-star算法总结" class="headerlink" title="A-star算法总结"></a>A-star算法总结</h2><ul>
<li>Tree search<ul>
<li>当启发是admissible时，A*保证最优性</li>
<li>当h=0时，A*退化成UCS算法</li>
</ul>
</li>
<li>Graph search<ul>
<li>当启发是consistent时，A*保证最优性</li>
<li>当h=0时，同样A*退化成UCS算法</li>
</ul>
</li>
<li><p>Consistency 包含了admissibility</p>
</li>
<li><p>从实践经验来说，大多数admissible的估计都可以做到consistency。</p>
</li>
</ul>
<h2 id="Local-Search-algrithms"><a href="#Local-Search-algrithms" class="headerlink" title="Local Search algrithms"></a>Local Search algrithms</h2><p>在很多优化问题中，我们只要求找到目标状态，对找到目标状态的路径没有要求。比如：八皇后问题，TSP问题。</p>
<p>局部搜索(local search)是解决这类问题的一个方法：从一个初始解出发，搜索当前解的邻域，如果有更优的解则移动至该解并继续搜索，迭代这个过程直到找到局部最优解。</p>
<h3 id="Hill-climbing-爬山算法"><a href="#Hill-climbing-爬山算法" class="headerlink" title="Hill-climbing 爬山算法"></a>Hill-climbing 爬山算法</h3><p>代表性算法——爬山算法：</p>
<ul>
<li>找最好的邻居状态节点。如果比当前节点状态要大，就将其设为新的当前节点。</li>
</ul>
<p>怎么避免陷入局部最优？</p>
<ul>
<li>random restarts，多试几种起始点。</li>
<li>random sideways moves，允许平移。可以逃离shoulder，但是逃离不了local maximum, flat local maximum。</li>
<li>first choice，不一定要选择最高的邻居节点，而是随便选一个比当前状态高的。</li>
</ul>
<p><strong>总结：引入随机性</strong></p>
<p><img src="/2022/03/08/AI-Searching/26.png"></p>
<p><strong>爬山法用于八皇后问题</strong></p>
<p>举例，八皇后问题中如果用“冲突数”评价状态会存在很多shoulder（邻域状态与当前状态冲突数相同）。因此有必要引入sideway move。</p>
<h3 id="Simulated-annealing-模拟退火法"><a href="#Simulated-annealing-模拟退火法" class="headerlink" title="Simulated annealing 模拟退火法"></a>Simulated annealing 模拟退火法</h3><p>模拟退火本身的动机，在于让金属凉下来的方式达到一个low-energy的状态。</p>
<p>基本想法：在一开始的时候允许它往值更低的方向走，一开始温度高允许算法出现错误的移动，希望它能够跳出局部的最优。随着时间的推移，温度下降 ，减少允许它错误移动的机会和次数。</p>
<p>一句话总结，开始允许犯错，目的是为了跳出局部的最优，渐渐地不允许犯错了，希望找到全局的最优。</p>
<p>t指的是温度，按照指数级别的方式降低。按照某一个概率允许向下移动，该概率随t减小概率逐渐降低。</p>
<p>保证最优解，只要温度降低速度“足够慢”（按照指数级别下降exponentially slowly），就可以保证收敛到最佳状态（证明思路是模拟马尔可夫链）。</p>
<h3 id="Local-Beam-Search集束搜索"><a href="#Local-Beam-Search集束搜索" class="headerlink" title="Local Beam Search集束搜索"></a>Local Beam Search集束搜索</h3><p>对local search算法进行k次拷贝，对当前的k个状态生成状态的所有后继节点进行展开，在其中选择最好的k个后继节点。</p>
<p>与运行k次local search算法的区别在于Beam search每次只选择k个状态进行展开，选择的时候有做过对比，而退火算法是用纯粹random的方式进行选择。</p>
<h3 id="Genetic-algorithms-遗传算法"><a href="#Genetic-algorithms-遗传算法" class="headerlink" title="Genetic algorithms 遗传算法"></a>Genetic algorithms 遗传算法</h3><p>仿照基因进化原理，保留最优状态。</p>
<p>遗传算法实际上是随机束搜索的变形, 通过把两个父状态结合生成后继。</p>
<p>种群：种群中的每个个体都是潜在解 ，可以看成所求问题解的集合。</p>
<p>个体表示： 染色体， 实际就是状态的表示 ，每条染色体也可以看成所求解问题对应的一组解。</p>
<p>适应度函数fitness：表示解的好坏程度 。</p>
<p>选择selection（利用）：根据适应度选取比较好的解优先进行两两繁殖 。</p>
<p>交叉cross-over（利用为主+探索）： 选取一个杂交点， 两边染色体互相交换 。</p>
<p>变异mutation（探索）：每个位置都会小概率发生变异 。</p>
<p>类比成兔子，遗传算法是一群吃了失忆药片随机分布在地球上的某些地方的兔子们。他们不知道自己的使命是什么。但是，如果你过几年就杀死一部分海拔低的兔子，多产的兔子们自己就会找到珠穆朗玛峰。这就是遗传算法。</p>
<h3 id="在连续性的空间做局部搜索算法"><a href="#在连续性的空间做局部搜索算法" class="headerlink" title="在连续性的空间做局部搜索算法"></a>在连续性的空间做局部搜索算法</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2022/03/03/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80-%E5%93%88%E5%B8%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/03/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80-%E5%93%88%E5%B8%8C/" class="post-title-link" itemprop="url">区块链基础-哈希</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-03-03 19:43:58 / Modified: 22:53:40" itemprop="dateCreated datePublished" datetime="2022-03-03T19:43:58+08:00">2022-03-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="区块链基础-哈希"><a href="#区块链基础-哈希" class="headerlink" title="区块链基础-哈希"></a>区块链基础-哈希</h1><h2 id="区块链中常见的Hash函数"><a href="#区块链中常见的Hash函数" class="headerlink" title="区块链中常见的Hash函数"></a>区块链中常见的Hash函数</h2><p>首先，我们要给出Hash函数的定义以及特征：</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>Hash函数是一种从<strong>任何种类、任何大小的数据中创建固定大小值</strong>的方法，这个值也被称为散列值。通常，用一个短的随机字母和数字组成的字符串来代表。</p>
<p>比如说对于sha 256算法来说，不管输入的值是什么类型、值有多大，它出来的一定是一个256bits的字符串。</p>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul>
<li>Hash函数是逆向难解的。根据给定的散列值，以目前的计算资源很难在有限的时间内推出原文</li>
<li>强抗碰撞性。对于任意两个不同的明文x和y，$H(x)$ 不等于$H(y)$ </li>
<li>雪崩效应。原文的微小变更会导致散列值巨大的变化，使得通过明文来反推原文的难度是非常困难的</li>
</ul>
<h4 id="Hash函数常见算法"><a href="#Hash函数常见算法" class="headerlink" title="Hash函数常见算法"></a>Hash函数常见算法</h4><ul>
<li>MD </li>
</ul>
<p>MD系列有MD4和MD5，输出位128位。MD5比MD4更加安全，但计算速度较慢。</p>
<ul>
<li>SHA </li>
</ul>
<p>SHA是一个Hash函数族。主要有SHA-0,SHA-1,SHA-2,SHA-3 这几个版本。 SHA-2版本包括SHA-224、SHA-256、SHA-384和SHA-512，其中SHA-256是应用最广泛的Hash函数。</p>
<p>现在 MD5、SHA-0和SHA-1已经发现碰撞，存在安全问题，已经不适于商业应用。</p>
<h3 id="哈希函数在区块链中的应用"><a href="#哈希函数在区块链中的应用" class="headerlink" title="哈希函数在区块链中的应用"></a>哈希函数在区块链中的应用</h3><p>首先我们要思考在P2P网络中，如何保证数据的准确性？比如说我用P2P下载一部电影，那么这时候电影文件会被拆分成一个一个片段，由不同的用户传给我。那么怎么保证我收到的电影片段是完整的呢？答案就是利用哈希。因为哈希的雪崩效应和强抗碰撞性，只要输入的片段有所偏差，那么输出的值肯定是不对的。因此我们可以用哈希函数对数据的正确性进行验证。</p>
<p>应用在区块链上：</p>
<h4 id="区块链的地址与标识。"><a href="#区块链的地址与标识。" class="headerlink" title="区块链的地址与标识。"></a><strong>区块链的地址与标识</strong>。</h4><p>每个交易的标识、区块的标识都是一个 Hash值。区块链通过区块链头中的PrevBlockHash或ParentHash连接相邻的块，最终形成链状结构。 </p>
<h4 id="区块体相关数据的树根hash-——-交易树。"><a href="#区块体相关数据的树根hash-——-交易树。" class="headerlink" title="区块体相关数据的树根hash —— 交易树。"></a><strong>区块体相关数据的树根hash —— 交易树</strong>。</h4><p>在区块的头部存储Merkle树的根散列值，这个根散列值是由两两交易逐层生成的，因此这个根散列值也代表了区块中的所有交易数据的数字摘要。</p>
<p><img src="/2022/03/03/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80-%E5%93%88%E5%B8%8C/1.png" style="zoom:67%;"></p>
<p>比如说，我想知道L3这块数据的正确性，我只需要Hash0、Hash1-1这两个哈希值(Top Hash已知)，我们就能通过Hash函数验证L3是否正确。这就是Merkle Proof</p>
<h4 id="签名与验证"><a href="#签名与验证" class="headerlink" title="签名与验证"></a><strong>签名与验证</strong></h4><p>要理解签名和验证，首先要搞明白公钥和私钥的区别。比特币账户是以一个$2^{160}$的数字地址形式存在的，该账户能拥有、转出和转入比特币。因为地址够长，从而可以确保任意两个账户不会重复。</p>
<h5 id="公钥和私钥"><a href="#公钥和私钥" class="headerlink" title="公钥和私钥"></a>公钥和私钥</h5><p>那么为了标识一个唯一的身份，就出现了公有密钥(公钥)和私有密钥(私钥)的概念。</p>
<ul>
<li>私有密钥是随机生成的，而共有密钥根据私有密钥产生</li>
<li>公有密钥是交易方对外公布的地址，别人都可以知道。用于接收转入</li>
<li>私有密钥则用于支付，这个是不能告诉任何人的。</li>
</ul>
<h5 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h5><p>了解了公钥和私钥的概念，还需要了解<strong>对称加密</strong>和<strong>非对称加密</strong>的概念。</p>
<ul>
<li>对称加密是最快速、最简单的一种加密方式，加密（encryption）与解密（decryption）用的是同样的密钥（secret key）。但是在对称加密中，如何给别人提供密钥呢？如果广播的话，每个人都知道密钥是什么，那么会造成数据的不安全。</li>
<li>非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥，公钥（public key）和私钥（private key）。非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。比如，你向银行请求公钥，银行将公钥发给你，你使用公钥对消息加密，那么只有私钥的持有人—银行才能对你的消息解密。与对称加密不同的是，银行不需要将私钥通过网络发送出去，因此安全性大大提高。</li>
</ul>
<h5 id="数字签名与验证"><a href="#数字签名与验证" class="headerlink" title="数字签名与验证"></a>数字签名与验证</h5><ol>
<li>数字签名的签名过程</li>
</ol>
<p>数字签名的操作过程需要有发方的签名数字证书的私钥及其验证公钥。</p>
<p>具体过程如下：</p>
<ul>
<li>首先对代发文件做哈希算法<strong>形成数字摘要</strong></li>
<li>再对数字摘要用签名私钥做非对称加密形成数字签名；</li>
<li>之后将以上的签名和电子文件原文以及签名证书的公钥加在一起进行封装，形成签名结果发送给收方待收方验证。</li>
</ul>
<ol>
<li>数字签名的验证过程</li>
</ol>
<p>接收方收到发方的签名结果进行签名验证</p>
<p>具体过程如下： </p>
<ul>
<li>接收方收到数字签名的结果，其中包括数字签名、电子原文和发方公钥，即待验证的数据。</li>
<li>接收方进行签名验证：接收方首先用发方公钥解密数字签名，导出数字摘要；</li>
<li>并对电子文件原文做同样哈希算法得出一个新的数字摘要，将两个摘要的哈希值进行结果比较，相同签名得到验证，否则无效。</li>
</ul>
<p>示意图如下：</p>
<p><img src="/2022/03/03/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80-%E5%93%88%E5%B8%8C/3.jpeg" style="zoom: 150%;"></p>
<p>数字签名的意义就是，在传输一份文件的时候，除了文件本身还附带了一个我的签名，这个签名的作用就是证明，我本人发了这个文件，是赖不掉的(不可抵赖性)；而且保证了文件的安全性，因为如果被篡改会导致验证失败</p>
<ol>
<li><strong>防篡改</strong>。由哈希函数和默克尔树的特性可知，区块中的某个交易的修改会导致交易的散列值发生变化，区块头部中的根散列值也会发生变化。区块的校验方法会校验区块头部中的根散列值和区块中交易生成的新的根散列值是否一致</li>
<li><strong>数据编码</strong></li>
</ol>
<h2 id="加密解密算法"><a href="#加密解密算法" class="headerlink" title="加密解密算法"></a>加密解密算法</h2><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><h2 id="数字证书及PKI体系"><a href="#数字证书及PKI体系" class="headerlink" title="数字证书及PKI体系"></a>数字证书及PKI体系</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jason</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">439</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    

  

</body>
</html>
