<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=">


  <link rel="mask-icon" href="/images/logo.svg?v=" color="#222">














<meta property="og:type" content="website">
<meta property="og:title" content="Jason‘s Blog">
<meta property="og:url" content="https://jasonxqh.github.io/page/12/index.html">
<meta property="og:site_name" content="Jason‘s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '',
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    fancybox: false,
    tabs: ,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: 'undefined',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>







  <title>Jason‘s Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', '[object Object]', 'auto');
  ga('send', 'pageview');
</script>





<meta name="generator" content="Hexo 4.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">
  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
<a href="https://github.com/JasonXQH/JasonXQH.github.io" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jason‘s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/%20" rel="section">
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/" itemprop="url">计算机网络报告Week12</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-30T21:01:30+08:00">
                2021-05-30
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-08-23T22:25:30+08:00">
                2022-08-23
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Week12-TCP协议和IP协议分析"><a href="#Week12-TCP协议和IP协议分析" class="headerlink" title="Week12 TCP协议和IP协议分析"></a>Week12 TCP协议和IP协议分析</h1><h2 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1.实验目的"></a>1.实验目的</h2><ul>
<li>了解TCP协议的工作原理</li>
<li>学习TCP建立连接三次握手的过程</li>
<li>学习TCP断开连接四次挥手的过程</li>
<li>快速简单了解IP协议，特别是IP数据报</li>
<li>研究IP数据分片方法</li>
</ul>
<h2 id="2-实验任务"><a href="#2-实验任务" class="headerlink" title="2. 实验任务"></a>2. 实验任务</h2><ul>
<li>使用 Wireshark 快速了解TCP协议</li>
<li>使用 Wireshark 快速了解 IP 协议</li>
</ul>
<h2 id="3-实验过程"><a href="#3-实验过程" class="headerlink" title="3. 实验过程"></a>3. 实验过程</h2><h3 id="3-1-Wireshark-抓取TCP包"><a href="#3-1-Wireshark-抓取TCP包" class="headerlink" title="3.1 Wireshark 抓取TCP包"></a>3.1 Wireshark 抓取TCP包</h3><ul>
<li>TCP 协议 </li>
</ul>
<p>TCP 被称为是面向连接的(connection oriented), 这是因为在一个应用进程可以开始向另一个应用进程发送数据之前，这两个进程必须互相先”握手”, 即它们必须相互发送某些预备报文段，以建立确保数据传输的参数。</p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/1.jpg" style="zoom: 50%;"></p>
<ul>
<li>Wireshark 相关知识详见 Exp6: DNS 报文分析和基于UDP的Socket编程</li>
</ul>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/2.jpg" style="zoom: 50%;"></p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/3.jpg" style="zoom: 50%;"></p>
<h4 id="Task1"><a href="#Task1" class="headerlink" title="Task1:"></a>Task1:</h4><p>利用Wireshark 抓取一个TCP抓取数据包， 查看其具体数据结构和实际的数据 (要求根据报文结构正确标识每个部分)， 请将实验结果附在实验报告中</p>
<p>这里，注释的部分为该字段的名称以及实际数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Transmission Control Protocol, Src Port: <span class="number">50177</span>, Dst Port: <span class="number">443</span>, Seq: <span class="number">1</span>, Ack: <span class="number">2</span>, Len: <span class="number">0</span></span><br><span class="line">    Source Port: <span class="number">50177</span>   					<span class="comment"># 源端口号   C4	01</span></span><br><span class="line">    Destination Port: <span class="number">443</span>					<span class="comment"># 目的端口号 01 bb</span></span><br><span class="line">    [Stream index: <span class="number">16</span>]					</span><br><span class="line">    [TCP Segment Len: <span class="number">0</span>]</span><br><span class="line">    Sequence Number: <span class="number">1</span>    (relative sequence number)		<span class="comment"># 序号 	12 2f f1 74</span></span><br><span class="line">    Sequence Number (raw): <span class="number">305131892</span>										</span><br><span class="line">    [Next Sequence Number: <span class="number">1</span>    (relative sequence number)] </span><br><span class="line">    Acknowledgment Number: <span class="number">2</span>    (relative ack number) 	<span class="comment"># 确认号 60 c2 55 c9</span></span><br><span class="line">    Acknowledgment number (raw): <span class="number">1623348681</span></span><br><span class="line">    <span class="number">0101</span> .... = Header Length: <span class="number">20</span> bytes (<span class="number">5</span>)		<span class="comment"># 首部长度 (长8个bit) 50</span></span><br><span class="line">    Flags: <span class="number">0x010</span> (ACK)</span><br><span class="line">        <span class="number">000.</span> .... .... = Reserved: Not set <span class="comment"># 保留未用 50 10</span></span><br><span class="line">        ..<span class="number">.0</span> .... .... = Nonce: Not set</span><br><span class="line">        .... <span class="number">0.</span>.. .... = Congestion Window Reduced (CWR): Not set</span><br><span class="line">        .... <span class="number">.0</span>.. .... = ECN-Echo: Not set</span><br><span class="line">        .... .<span class="number">.0</span>. .... = Urgent: Not set</span><br><span class="line">        .... ..<span class="number">.1</span> .... = Acknowledgment: Set <span class="comment"># Flag中的ACK已经被标记</span></span><br><span class="line">        .... .... <span class="number">0.</span>.. = Push: Not set			</span><br><span class="line">        .... .... <span class="number">.0</span>.. = Reset: Not set</span><br><span class="line">        .... .... .<span class="number">.0</span>. = Syn: Not set</span><br><span class="line">        .... .... ..<span class="number">.0</span> = Fin: Not set </span><br><span class="line">        <span class="comment"># 其余Flag均未被标记</span></span><br><span class="line">        [TCP Flags: ·······A····]</span><br><span class="line">    Window: <span class="number">4096</span> 									<span class="comment"># 接收窗口大小 10 00</span></span><br><span class="line">    [Calculated window size: <span class="number">4096</span>]</span><br><span class="line">    [Window size scaling factor: <span class="number">-1</span> (unknown)]</span><br><span class="line">    Checksum: <span class="number">0x5abf</span> [unverified]	<span class="comment"># 因特网检验和 5a bf</span></span><br><span class="line">    [Checksum Status: Unverified]</span><br><span class="line">    Urgent Pointer: <span class="number">0</span>							<span class="comment"># 紧急数据指针 00 00 (未设置)</span></span><br><span class="line">    [SEQ/ACK analysis]</span><br><span class="line">    [Timestamps]</span><br></pre></td></tr></table></figure>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/1.png" style="zoom: 50%;"></p>
<h3 id="3-2-TCP-三次握手"><a href="#3-2-TCP-三次握手" class="headerlink" title="3.2 TCP 三次握手"></a>3.2 TCP 三次握手</h3><p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/4.jpg"></p>
<h4 id="Task2："><a href="#Task2：" class="headerlink" title="Task2："></a>Task2：</h4><p>根据TCP三次握手的交互图以及TCP报文段结构图逐步分析三次握手过程，请将实验结果附在实验报告中</p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/9.png"></p>
<p>这就是本地电脑和百度三次握手的过程。 每次握手的过程这里重复了两次，但内容是一样的</p>
<h5 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h5><p>首先，是从本地客户端发向百度服务器的一个数据报。在这个数据报中，Seq=0，说明一开始是从序号为0的包好事发送的。我们看到这里SYN 这一位已经被设为1了，因为还没收到来自百度的确认信息，因此这里ACK为设为0</p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/10.png"></p>
<h5 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h5><p>这是百度服务器给本地电脑发送的报文，其中 Seq=0, ACK = 1 ,因为TCP是全双工通信的，因此从百度发送来的第一个报文段也是从 seq=0 开始的。但是这个报文段中包含了对我发给百度的包的确认信息，因此这里ACK被设置了，且值为1，这说明 1 以前的包我全部都收到了，请本地发送1以后的包</p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/11.png"></p>
<h5 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h5><p>第三次握手是本地发送给百度服务器的，此时， Seq=1, 说明这是本地发送的第二个包了(第一个包Seq=0) ； ACK = 1 说明已经收到了来自服务端的 1以前的所有包。</p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/12.png"></p>
<p>至此，本地和服务端的三次握手已经结束，可以相互传递信息了</p>
<h3 id="3-3-TCP-四次挥手"><a href="#3-3-TCP-四次挥手" class="headerlink" title="3.3 TCP 四次挥手"></a>3.3 TCP 四次挥手</h3><p>当通信双方完成数据传输，需要进行TCP连接的释放，由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍然能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。因为正常关闭过程需要发送4个TCP帧，因此这个过程也叫四次挥手。</p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/5.jpg"></p>
<h4 id="Task3"><a href="#Task3" class="headerlink" title="Task3:"></a>Task3:</h4><p>根据TCP四次挥手的交互图以及TCP报文段结构图逐步分析四次挥手过程，请将实验结果附在实验报告中。</p>
<p>这是四次挥手的过程：</p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/13.png"></p>
<h5 id="第一次挥手"><a href="#第一次挥手" class="headerlink" title="第一次挥手"></a>第一次挥手</h5><p>第一次挥手是百度向本地发送的一个包， Seq=80634 Ack =6224. 同时，设定了Fin位，表示服务器单方面想和本地断开联系。</p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/14.png"></p>
<h5 id="第二次挥手"><a href="#第二次挥手" class="headerlink" title="第二次挥手"></a>第二次挥手</h5><p>第二次挥手是本地收到了百度想要结束的Fin之后，返回了一个带有ACK的包。同时告诉服务器，ACK=80635,说明80635以前的数据段都已经收到了。</p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/15.png"></p>
<h5 id="第三次挥手"><a href="#第三次挥手" class="headerlink" title="第三次挥手"></a>第三次挥手</h5><p>前两次挥手是主动关闭方断开连接，但是只是单方面关闭连接。现在要被动关闭方来断开连接，才能实现真正的断连。</p>
<p>我们看到这个是 本地向百度发送的包，设置了Fin和ACK，注意到这个包的ACK和第二次挥手发送的ACk的值是一模一样的，因为在这两次挥手之间没有收到新的来自百度的包</p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/16.png"></p>
<h5 id="第四次挥手"><a href="#第四次挥手" class="headerlink" title="第四次挥手"></a>第四次挥手</h5><p>第四次挥手，是百度收到了本地发送的带有FIN 标志的包后，返回的确认报文。</p>
<p>这个报文比较特殊，因为返回的报文只设置了RST位，没有设置 Seq，Ack。 RST位被设置以后，接收端收到之后不必发送ACK包。</p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/17.png"></p>
<h3 id="3-4-IP分片"><a href="#3-4-IP分片" class="headerlink" title="3.4 IP分片"></a>3.4 IP分片</h3><ul>
<li>IP报文格式</li>
</ul>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/6.jpg"></p>
<ul>
<li>根据上课学习知道IP报文要交给数据链路层封装后才能发送，理想状况下，每个IP报文正好能放在同一个物理帧中发送。如果一个数据包超过1500字节(以太网的帧中最多可容纳1500字节的数据). 就需要将该包进行分片发送，这个上限被称为物理网络的最大传输单元(MTU. Maxium Transfer Unit)</li>
<li>TCP/IP 协议在发送IP数据报文时，一般选择一个合适的初始长度。当这个报文要从一个MTU大的子网发送一个MTU 小的网络时，IP协议就把这个报文的数据部分分割成能被目的子网锁容纳的较小的数据分片，组成较小的报文发送。每个较小的报文被称为一个分片。 每个分片都有一个IP 报文头，分片后的数据包的IP报头和原式IP报头分片偏移、MF标志位和校验字段不同外，其他都一样。</li>
<li>下面通过使用ICMP 包，来产生IP分片数据包。使用ICMP包进行测试时，如果不指定包的大小，可能无法查看被分片的数据报。由于IP首部占用20个字节，ICMP首部占8个字节，所以捕获ICMP包大小最大为1472字节。但是在一般情况下，ping 命令默认的大小都不会唱过1472。 这样，发送的ICMP包就可以顺利通过，不需要经过分片再传输，如果想捕获到IP分片的包，需要指定发送的ICMP包必须大于1472 字节。</li>
<li>可通过下方命令指定发送包的大小，如： <code>ping -s 3005 www.ecnu.edu.cn</code></li>
</ul>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/7.jpg"></p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/8.jpg"></p>
<h4 id="Task4"><a href="#Task4" class="headerlink" title="Task4"></a>Task4</h4><p>任取一个有IP协议的ICMP数据报并根据该报文分析IP协议的报文格式(正确标注每一个部分)， 请将实验结果附在实验报告中</p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/18.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Internet Protocol Version <span class="number">4</span>, Src: <span class="number">192.168</span><span class="number">.31</span><span class="number">.15</span>, Dst: <span class="number">180.101</span><span class="number">.49</span><span class="number">.11</span> <span class="comment"># 源地址和目标地址</span></span><br><span class="line">    <span class="number">0100</span> .... = Version: <span class="number">4</span>	<span class="comment"># 版本号，一般是4   </span></span><br><span class="line">    .... <span class="number">0101</span> = Header Length: <span class="number">20</span> bytes (<span class="number">5</span>) <span class="comment"># 头部长度，为20 bytes</span></span><br><span class="line">    Differentiated Services Field: <span class="number">0x00</span> (DSCP: CS0, ECN: Not-ECT)</span><br><span class="line">    Total Length: <span class="number">84</span> <span class="comment">#总长度 16进制值为 00 54</span></span><br><span class="line">    Identification: <span class="number">0xe6a0</span> (<span class="number">59040</span>) <span class="comment"># 标志 </span></span><br><span class="line">    Flags: <span class="number">0x00</span>					<span class="comment"># 标识</span></span><br><span class="line">    Fragment Offset: <span class="number">0</span> <span class="comment"># 片偏移 和flag合起来是 0000</span></span><br><span class="line">    Time to Live: <span class="number">64</span>	 <span class="comment"># 生存时间 40</span></span><br><span class="line">    Protocol: ICMP (<span class="number">1</span>) <span class="comment"># 协议 01</span></span><br><span class="line">    Header Checksum: <span class="number">0xcee0</span> [validation disabled] <span class="comment"># 首部检验和 ce e0</span></span><br><span class="line">    [Header checksum status: Unverified]</span><br><span class="line">    Source Address: <span class="number">192.168</span><span class="number">.31</span><span class="number">.15</span>		<span class="comment"># 源地址 ce a8 1f 0f </span></span><br><span class="line">    Destination Address: <span class="number">180.101</span><span class="number">.49</span><span class="number">.11</span> <span class="comment"># 目标地址 b4 65 31 0b</span></span><br></pre></td></tr></table></figure>
<h4 id="Task5"><a href="#Task5" class="headerlink" title="Task5"></a>Task5</h4><p>对截获的报文进行分析，将属于同一个ICMP报文的分片找出来，并分析其字节长度特点(如，每个分片的大小，片偏移等)，请将实验结果附在报告中</p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/19.png"></p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/20.png"></p>
<p>我想 www.ecnu.edu.cn ping 了一段长1500的报文，发现被分割成了两段。其中一段长 1514，一段长62</p>
<p>点开第一段报文和第二段报文：</p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/21.png"></p>
<p>我们发现他们的 Identification 都是一样的，为 0x0bcd. 由此我们可以断定这两个分片属于同一个ICMP报文。</p>
<p>第一段报文是只有IP层，没有ICMP层的。总长度为1500，即一个MTU。但是因为IP层头长度为20，所以data的总长度只有1480。 因为这是第一个报文，因此并没有数据偏移量，因此这时 <strong>Fragment Offset : 0</strong> ，同时在Flags中也有注明，说有其他分片。</p>
<p>第二段报文报文的总长度为48，头长度为20，data是28，那么为什么不是20而是28呢？因为ICMP的头部占了8个字节。因为这是最后一段报文，因此Flag为0，前面只有一个满的报文，因此 <strong>Fragment Offset</strong>为1480. </p>
<p>因为说不管ping的字节有多长，一定都是填满一个报文之后再分出来，所以其Offset 一定都是1480的整数倍。</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A-rdt3-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A-rdt3-0/" itemprop="url">计算机网络报告-rdt3.0</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-23T10:29:14+08:00">
                2021-05-23
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-08-25T04:31:40+08:00">
                2022-08-25
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="计算机网络报告-rdt3-0"><a href="#计算机网络报告-rdt3-0" class="headerlink" title="计算机网络报告-rdt3.0"></a>计算机网络报告-rdt3.0</h1><p>在我的学习博客 <a href="https://jasonxqh.github.io/2021/05/03/计算机网络-运输层总结/#rdt3-0">可靠数据传输原理 rdt3.0</a> 中，我已经详细介绍了 rdt3.0 的发送方和接收方的有限状态机，并且介绍了 GBN 和 SR 的原理。</p>
<h2 id="报文类"><a href="#报文类" class="headerlink" title="报文类"></a>报文类</h2><p>我们把packet 抽象出来单独写一个类。在这个类中，我们提供了一些方法——生成包的方法生成和检验校验和的方法，解析报文的方法，模拟包报文出错的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company; </span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">packet</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 类中必须囊括序号、以及检验和</span></span><br><span class="line">   Integer seqNo;</span><br><span class="line">   Integer checksum;</span><br><span class="line">  <span class="comment">// 发送的内容</span></span><br><span class="line">   <span class="keyword">public</span> String content;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 初始化的packet 的seqNo=1, </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">packet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      seqNo = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 这个方法教给发送者调用，可以将读取的信息封装到 packet当中</span></span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createPacket</span><span class="params">(String pContent,<span class="keyword">int</span> seqNo)</span> </span>&#123;</span><br><span class="line">		content = pContent;</span><br><span class="line">   	<span class="comment">// 为内容设置校验和</span></span><br><span class="line">		checksum = generateChecksum(content);</span><br><span class="line">   	<span class="comment">// 在rdt3.0中，序号只可能是0或者1，由发送者控制序号的变化</span></span><br><span class="line">		<span class="keyword">this</span>.seqNo = seqNo;</span><br><span class="line">	&#125;</span><br><span class="line">   <span class="comment">// 帮助发送者生成统一格式的信息</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">generateMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> seqNo+ <span class="string">" "</span> + checksum + <span class="string">" "</span> + content;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 生成检验和的函数，原本算法就是将前面3个16位相加，但是这里没有源端口和目的端口</span></span><br><span class="line">  <span class="comment">// 因此，我们对发送的信息做一个处理，将其转换为ascii码作为检验和</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Integer <span class="title">generateChecksum</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> asciiInt;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">         asciiInt = (<span class="keyword">int</span>) s.charAt(i);</span><br><span class="line">         sum = sum + asciiInt;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个方法是帮助接收者解析从套接字获取的data</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseMessage</span><span class="params">(String pcontent)</span> </span>&#123;</span><br><span class="line">       String[] splited = pcontent.split(<span class="string">"\\s+"</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; splited.length; i++) &#123; </span><br><span class="line">         <span class="comment">// 依次赋值给seqNo 和 checksum</span></span><br><span class="line">          seqNo = Integer.parseInt(splited[<span class="number">0</span>]);</span><br><span class="line">          checksum = Integer.parseInt(splited[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 最后一个元素才是 要发送的内容</span></span><br><span class="line">          content = splited[<span class="number">2</span>];</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 模拟包出错，可以将checksum+1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">corruptChecksum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       checksum = checksum + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个方法是帮助接收者判断包裹的信息是否出错的，也就是将计算得到的checksum和发送来的checksum作比较</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">validateMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	Integer newChecksum = generateChecksum(content);</span><br><span class="line">    	<span class="keyword">if</span> (newChecksum.equals(checksum))</span><br><span class="line">    		<span class="keyword">return</span>  seqNo;</span><br><span class="line">    <span class="comment">//如果两者不相等，说明包损坏了，给发送者发送相反的ACK，这样发送者就知道出错了，需要重发</span></span><br><span class="line">    	<span class="keyword">else</span> &#123;</span><br><span class="line">        seqNo = <span class="number">1</span>-seqNo;</span><br><span class="line">        <span class="keyword">return</span> seqNo;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="网络层搭建"><a href="#网络层搭建" class="headerlink" title="网络层搭建"></a>网络层搭建</h2><p>要实现rdt 3.0 我们首先要搭建一个底层的网络层,作为传输信道。它的作用就是连接两个”主机端“，这里，发送者和接收者用同一主机上的两个进程来模拟。这样，发送者和接收者就可以通过”网络层”来相互传递消息了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">network</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 泛型 List用来存放要发送的所有信息</span></span><br><span class="line">	<span class="keyword">static</span> List&lt;Object&gt; allMessages = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">  <span class="comment">// 用serverSocket这个类型的套接字来接入发送者和接收者</span></span><br><span class="line">	<span class="keyword">static</span> ServerSocket serverSocket;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> portNumber;</span><br><span class="line">    </span><br><span class="line">    portNumber = <span class="number">5678</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">			serverSocket = <span class="keyword">new</span> ServerSocket(portNumber);</span><br><span class="line">			System.out.println(<span class="string">"Waiting... connect receiver"</span>);</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      服务器需随时待命，因为不知道客户端什么时候会发来请求，此时，我们需要使用ServerSocket</span></span><br><span class="line"><span class="comment">      ServerSocket与Socket不同，ServerSocket是等待客户端的请求，一旦获得一个连接请求，就创建一个Socket示例来与客户端进行通信。 </span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">				<span class="keyword">new</span> MessageThread(serverSocket.accept()).start();</span><br><span class="line">				<span class="keyword">new</span> MessageThread(serverSocket.accept()).start();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"I/O failure: "</span> + e.getMessage());</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将接收到的套接字传送给MessageThread类，为了模拟出 检验和出现错误、丢包的情况，我们这里需要分类来写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Socket socket = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACK2 = <span class="string">"ACK2"</span>;</span><br><span class="line">	MessageThread mt = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">int</span> ID = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MessageThread</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.socket = socket;</span><br><span class="line">		allMessages.add(<span class="keyword">this</span>);</span><br><span class="line">		ID = allMessages.size() - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String input = <span class="string">""</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			PrintWriter streamOut = <span class="keyword">null</span>;</span><br><span class="line">			BufferedReader readerIn = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//  给接进来的socket创建一个PrintWriter，这样就可以直接通过println来向客户端或者服务端传信息</span></span><br><span class="line">			streamOut = <span class="keyword">new</span> PrintWriter(socket.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line">      <span class="comment">// 给socket的输入流创建一个 BufferedReader,作为缓冲区，</span></span><br><span class="line">			readerIn = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">	</span><br><span class="line">			System.out.println(<span class="string">"Get connection from: "</span> + socket.getRemoteSocketAddress().toString());</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">while</span> ((input = readerIn.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果读入为空</span></span><br><span class="line">				<span class="keyword">if</span> (input.equals(<span class="string">"-1"</span>)) &#123;</span><br><span class="line">					<span class="comment">// 且这个线程为 发送者，那么就给接收者发一个-1</span></span><br><span class="line">					<span class="keyword">if</span> (ID == <span class="number">1</span>) &#123;</span><br><span class="line">						sendToOtherThread(<span class="string">"-1"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 这是一个正则表达式，用来匹配任意空白字符的，也就是按照空白处分割message</span></span><br><span class="line">				String[] splitedMsg = input.split(<span class="string">"\\s+"</span>);</span><br><span class="line">				<span class="comment">//现在开始我们要模拟 顺利发送、丢包、包损坏这些情况</span></span><br><span class="line">				<span class="keyword">double</span> x = Math.random();</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//这里我设置了有一半的几率会顺利通过。当receiver 回传ack时，长度只有1，这里也设为通过</span></span><br><span class="line">				<span class="keyword">if</span> (x &lt; <span class="number">0.5</span> || splitedMsg.length == <span class="number">1</span>) <span class="comment">// PASS</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (splitedMsg[<span class="number">0</span>].contains(<span class="string">"ACK"</span>)) &#123;</span><br><span class="line">						System.out.println(<span class="string">"Receiver: "</span> + splitedMsg[<span class="number">0</span>] + <span class="string">", to Sender"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span>  </span><br><span class="line">						System.out.println(<span class="string">"Sender: Packet"</span> + splitedMsg[<span class="number">0</span>]  +<span class="string">", PASS"</span>);</span><br><span class="line">          <span class="comment">// 将一个端的信息发送到另外一端</span></span><br><span class="line">					sendToOtherThread(input);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 如果出现了包损坏，我们的策略就是修改检验和，几率是1/4</span></span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (x &gt;= <span class="number">0.5</span> &amp;&amp; x &lt;= <span class="number">0.75</span>) <span class="comment">// CORRUPT</span></span><br><span class="line">				&#123;</span><br><span class="line">          <span class="comment">// 创建一个新的packet对象</span></span><br><span class="line">					packet p = <span class="keyword">new</span> packet();</span><br><span class="line">					p.parseMessage(input);</span><br><span class="line">					p.corruptChecksum();</span><br><span class="line">					System.out.println(<span class="string">"Sender: Packet"</span> + splitedMsg[<span class="number">0</span>]  + <span class="string">", CORRUPT"</span>);</span><br><span class="line">          <span class="comment">//将生成的数据发送给另外一端</span></span><br><span class="line">					sendToOtherThread(p.generateMessage());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 有1/4 的几率会丢包，出现丢失时，不需要使用 sendToOtherThread,这里我没有用线程，因此我只能回传给Sender一个丢包信息，并等待sender重传</span></span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					System.out.println(<span class="string">"Sender: Packet"</span> + splitedMsg[<span class="number">0</span>] + <span class="string">", DROP"</span>);</span><br><span class="line">          streamOut.println(ACK2);</span><br><span class="line">        &#125;</span><br><span class="line">		   &#125;</span><br><span class="line">		   socket.close();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 给套接字输出流创建一个 PrintWriter，然后通过 println 将pMessage传给对应的套接字</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String pMessage)</span> </span>&#123;</span><br><span class="line">		PrintWriter streamOut = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			streamOut = <span class="keyword">new</span> PrintWriter(socket.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line">			streamOut.println(pMessage);	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 这个方法是将信息从一个进程发送到另一个进程的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendToOtherThread</span><span class="params">(String pMessage)</span> </span>&#123;</span><br><span class="line">      mt = (MessageThread)allMessages.get(<span class="number">1</span>-ID);</span><br><span class="line">      <span class="comment">// 通过上面定义的方法，将文件传送给另外一端</span></span><br><span class="line">      mt.send(pMessage);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="发送者"><a href="#发送者" class="headerlink" title="发送者"></a>发送者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Thread.sleep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">sender</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> String hostName;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> portNumber;</span><br><span class="line">	<span class="keyword">static</span> String fileName;</span><br><span class="line">	<span class="keyword">int</span> SeqNo;</span><br><span class="line">  <span class="comment">// 首先设置一些必要的信息，比如端口号，主机名，需要传送的文件</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        hostName = <span class="string">"localhost"</span>;</span><br><span class="line">        portNumber = <span class="number">5678</span>;</span><br><span class="line">        fileName = <span class="string">"/Users/jasonxu/IdeaProjects/rdt3.0/src/com/company/message.txt"</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 然后开启发送者</span></span><br><span class="line">			<span class="keyword">new</span> sender().startSender(hostName, portNumber, fileName);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"Something falied: "</span> + e.getMessage());</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startSender</span><span class="params">(String hostName, <span class="keyword">int</span> portNumber, String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">		Socket socket = <span class="keyword">null</span>;</span><br><span class="line">		PrintWriter streamOut = <span class="keyword">null</span>;</span><br><span class="line">		BufferedReader streamIn = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建套接字</span></span><br><span class="line">			socket = <span class="keyword">new</span> Socket(hostName, portNumber);</span><br><span class="line">      <span class="comment">// 创建一个套接字的输出流</span></span><br><span class="line">			streamOut = <span class="keyword">new</span> PrintWriter(socket.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line">      <span class="comment">// 创建一个缓冲区，用来读取收到的信息</span></span><br><span class="line">			streamIn = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line"></span><br><span class="line">			String ACK;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 从文件读取信息流</span></span><br><span class="line">				FileInputStream fstream = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">        <span class="comment">// 将信息流转化成数据流</span></span><br><span class="line">				DataInputStream dataIn = <span class="keyword">new</span> DataInputStream(fstream);</span><br><span class="line">				BufferedReader buffReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(dataIn));</span><br><span class="line"></span><br><span class="line">				String input;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">int</span> totalSent = <span class="number">0</span>;</span><br><span class="line">				String message = <span class="string">""</span>;</span><br><span class="line">				<span class="comment">// 首先创建一个新的包</span></span><br><span class="line">				packet pak = <span class="keyword">new</span> packet();</span><br><span class="line">        <span class="comment">// 开始从 buffReader读取数据</span></span><br><span class="line">				<span class="keyword">while</span> ((input = buffReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//将信息按照空隙分开</span></span><br><span class="line">					String[] splited = input.split(<span class="string">"\\s+"</span>);</span><br><span class="line">					<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">          <span class="comment">// 对每一段文字，生成一个包，按顺序发送</span></span><br><span class="line">					<span class="keyword">while</span> (i &lt; splited.length) &#123;</span><br><span class="line">            <span class="comment">// 创建包</span></span><br><span class="line">						pak.createPacket(splited[i],<span class="keyword">this</span>.SeqNo);</span><br><span class="line">            <span class="comment">// 给包填充 data</span></span><br><span class="line">						message = pak.generateMessage();</span><br><span class="line">            <span class="comment">// 将数据推出去</span></span><br><span class="line">						streamOut.println(message);</span><br><span class="line">            <span class="comment">// 从输入缓冲区读取数据</span></span><br><span class="line">						ACK = streamIn.readLine();</span><br><span class="line">						</span><br><span class="line">						totalSent++;</span><br><span class="line">						<span class="comment">//如果ACK的数值与发送报文的序号一致，则i++,发送下一个报文</span></span><br><span class="line">						 <span class="keyword">if</span> (validateACK(ACK, pak.seqNo)) &#123;</span><br><span class="line">							i++;</span><br><span class="line">               <span class="comment">//序号0和1之间转换</span></span><br><span class="line">							<span class="keyword">this</span>.SeqNo = <span class="number">1</span>-<span class="keyword">this</span>.SeqNo;</span><br><span class="line">							System.out.println(<span class="string">"Waiting: "</span> + ACK + <span class="string">", totalsent: "</span> + totalSent + <span class="string">", "</span> + ACK + <span class="string">"Successfully sent"</span>);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 否则就说明丢失或者损坏，需要等待重传</span></span><br><span class="line">							 System.out.println(<span class="string">"Waiting: packet"</span>+ pak.seqNo + <span class="string">" CORRUPT OR LOST"</span> + <span class="string">", totalsent: "</span> + totalSent + <span class="string">", Waiting for resend"</span>);</span><br><span class="line">							 sleep(<span class="number">1000</span>);</span><br><span class="line">						 &#125;</span><br><span class="line">					&#125;</span><br><span class="line">					streamOut.println(-<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">        <span class="comment">//全部发送完成后，关闭输入流</span></span><br><span class="line">				dataIn.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				System.err.println(<span class="string">"Error: "</span> + e.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">			System.err.println(<span class="string">"Cannot find the host: "</span> + hostName);</span><br><span class="line">			System.exit(<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.err.println(<span class="string">"Couldn't read/write from the connection: "</span> + e.getMessage());</span><br><span class="line">			System.exit(<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">assert</span> streamOut != <span class="keyword">null</span>;</span><br><span class="line">			streamOut.close();</span><br><span class="line">			<span class="keyword">assert</span> streamIn != <span class="keyword">null</span>;</span><br><span class="line">			streamIn.close();</span><br><span class="line">			socket.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 这个方法帮助发送者判断ACK号是否和序列号相等</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateACK</span><span class="params">(String ACKfromNetwork, Integer seqNo)</span> </span>&#123;</span><br><span class="line">		String ACKN = <span class="string">"ACK"</span> + seqNo.toString();</span><br><span class="line">		<span class="keyword">return</span> ACKN.equals(ACKfromNetwork);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接收者"><a href="#接收者" class="headerlink" title="接收者"></a>接收者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">receiver</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> String hostName;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> portNumber;</span><br><span class="line"><span class="comment">// 首先给接收者确定一些基本信息： 主机名，端口</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        hostName = <span class="string">"localhost"</span>;</span><br><span class="line">        portNumber = <span class="number">5678</span>;</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 启动一个接收者</span></span><br><span class="line">			<span class="keyword">new</span> receiver().startReceiver(hostName, portNumber);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"Something falied: "</span> + e.getMessage());</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startReceiver</span><span class="params">(String hostName, <span class="keyword">int</span> portNumber)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> </span><br><span class="line">		Socket socket = <span class="keyword">null</span>;</span><br><span class="line">		PrintWriter streamOut = <span class="keyword">null</span>;</span><br><span class="line">		BufferedReader streamIn = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建套接字、套接字输入输出流</span></span><br><span class="line">			socket = <span class="keyword">new</span> Socket(hostName, portNumber);</span><br><span class="line">			streamOut = <span class="keyword">new</span> PrintWriter(socket.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line">			streamIn = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">					</span><br><span class="line">			String input, output;</span><br><span class="line">			<span class="keyword">int</span> totalReceived = <span class="number">0</span>;</span><br><span class="line">			StringBuilder msg = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">			System.out.println(<span class="string">"Waiting... connect sender"</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 创建一个新的包，用来返回ack信息</span></span><br><span class="line">			packet pak = <span class="keyword">new</span> packet();</span><br><span class="line">			<span class="keyword">while</span> ((input = streamIn.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// 如果输入为-1，说明包已经发送完毕，同时跳出循环</span></span><br><span class="line">				<span class="keyword">if</span> (input.equals(<span class="string">"-1"</span>)) &#123;</span><br><span class="line">					streamOut.println(-<span class="number">1</span>);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 解析收到的包中的信息</span></span><br><span class="line">				pak.parseMessage(input);</span><br><span class="line">				totalReceived++;</span><br><span class="line">        <span class="comment">// 验证包是否正确</span></span><br><span class="line">				<span class="keyword">int</span> tempNumber = pak.validateMessage();</span><br><span class="line">				output = <span class="string">"Waiting seqNo: "</span> + pak.seqNo+ <span class="string">", validateMessage: ACK"</span> + tempNumber+ <span class="string">", totalReceived: "</span> + totalReceived + <span class="string">", input"</span> + input;</span><br><span class="line">        <span class="comment">// 如果ack序号和seqNo不相等，说明包错了，等待重传</span></span><br><span class="line">				<span class="keyword">if</span>(pak.validateMessage()!=tempNumber)</span><br><span class="line">					System.out.println(<span class="string">"Waiting seqNo: "</span> + pak.seqNo+ <span class="string">", validateMessage: ACK"</span> + tempNumber+<span class="string">", Packet"</span>+pak.seqNo+<span class="string">" Corrupt,Please Resend"</span>);</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//包正确，那么打印、输出</span></span><br><span class="line">					msg.append(pak.content).append(<span class="string">" "</span>);</span><br><span class="line">					System.out.println(output);</span><br><span class="line">				&#125;</span><br><span class="line">        <span class="comment">// 返回ACK序号</span></span><br><span class="line">				streamOut.println(<span class="string">"ACK"</span>+pak.validateMessage());</span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">// 打印所有信息</span></span><br><span class="line">			System.out.println(<span class="string">"Total Message: "</span> + msg);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">			System.err.println(<span class="string">"Cannot find the host: "</span> + hostName);</span><br><span class="line">			System.exit(<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.err.println(<span class="string">"Couldn't read/write from the connection: "</span> + e.getMessage());</span><br><span class="line">			System.exit(<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			streamOut.close();</span><br><span class="line">			streamIn.close();</span><br><span class="line">			socket.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h2><h3 id="network"><a href="#network" class="headerlink" title="network"></a>network</h3><p><img src="/2021/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A-rdt3-0/1.png" style="zoom:67%;"></p>
<p>这是运输通道的打印信息，我们看到，第一个packet0是顺利通过的，第二个packet1的第一次发送出现了包错误，因此返回了一个ACK0, 重发后通过。第三个包出现了两次丢包和两次出错，最后通过。</p>
<h3 id="receiver"><a href="#receiver" class="headerlink" title="receiver"></a>receiver</h3><p><img src="/2021/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A-rdt3-0/2.png" style="zoom:67%;"></p>
<p>这是接收者的打印信息，我们看到出现丢包的话，接收者是收不到的，但是如果出现包错误，那么接收者会返回一个不同的ACK序号通知发送者重发</p>
<h3 id="sender"><a href="#sender" class="headerlink" title="sender"></a>sender</h3><p><img src="/2021/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A-rdt3-0/3.png" style="zoom:67%;"></p>
<p>这是发送者的打印信息，如果出现丢包或者包错误，会等待后重新发送，同时记录发送包的次数</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/05/21/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0%E5%A4%A7%E7%BA%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/21/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0%E5%A4%A7%E7%BA%B2/" itemprop="url">数据科学数学基础复习大纲</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-21T08:15:10+08:00">
                2021-05-21
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2021-05-21T08:39:42+08:00">
                2021-05-21
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数据科学数学基础复习大纲"><a href="#数据科学数学基础复习大纲" class="headerlink" title="数据科学数学基础复习大纲"></a>数据科学数学基础复习大纲</h1><p><img src="/2021/05/21/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0%E5%A4%A7%E7%BA%B2/1.png" style="zoom:80%;"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/05/19/os-project3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/19/os-project3/" itemprop="url">os-project3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-19T13:15:15+08:00">
                2021-05-19
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2021-06-08T23:15:26+08:00">
                2021-06-08
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="I-O-subsystem"><a href="#I-O-subsystem" class="headerlink" title="I/O subsystem"></a>I/O subsystem</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol>
<li><p>熟悉类UNIX系统的I/O设备管理</p>
</li>
<li><p>熟悉MINIX块设备驱动</p>
</li>
<li><p>熟悉MINIX RAM盘</p>
</li>
</ol>
<h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><ul>
<li><p>在MINIX3中安装一块X MB大小的RAM盘（minix中已有6块用户可用RAM盘，7块系统保留RAM盘），可以挂载并且存取文件操作。</p>
</li>
<li><p>测试RAM盘和DISK盘的文件读写速度，分析其读写速度差异原因（可用图表形式体现在实验报告中）。</p>
</li>
</ul>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="增加RAM盘："><a href="#增加RAM盘：" class="headerlink" title="增加RAM盘："></a>增加RAM盘：</h3><ul>
<li>修改<code>/usr/src/minix/drivers/storage/memory/memory.c</code>，增加默认的用户RAM盘数：<code>RAMDISKS=7</code>。</li>
</ul>
<p><img src="/2021/05/19/os-project3/2.png"></p>
<ul>
<li>重新编译内核，重启reboot。</li>
<li>创建设备<code>mknod /dev/myram b 1 13</code>，查看设备是否创建成功输入<code>ls /dev/ | grep ram</code>。</li>
</ul>
<p><img src="/2021/05/19/os-project3/3.png"></p>
<ul>
<li><p>实现<code>buildmyram</code>初始化工具（用于分配容量）。</p>
<ul>
<li>参考<code>/usr/src/minix/commands/ramdisk/ramdisk.c</code>，实现<code>buildmyram.c</code>，但是需要将KB单位修改成MB。</li>
<li><code>ramdisk.c</code> 代码如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;minix/paths.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioc_memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">signed</span> <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line">	<span class="keyword">char</span> *d;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(argc &lt; <span class="number">2</span> || argc &gt; <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;size in kB&gt; [device]\n"</span>,</span><br><span class="line">			argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	d = argc == <span class="number">2</span> ? _PATH_RAMDISK : argv[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">if</span>((fd=<span class="built_in">open</span>(d, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(d);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KFACTOR 1024</span></span><br><span class="line">	<span class="built_in">size</span> = atol(argv[<span class="number">1</span>])*KFACTOR;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">size</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"size should be non-negative.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(ioctl(fd, MIOCRAMSIZE, &amp;<span class="built_in">size</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">"MIOCRAMSIZE"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"size on %s set to %ldkB\n"</span>, d, <span class="built_in">size</span>/KFACTOR);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译<code>buildmyram.c</code>文件，然后执行命令： <code>./buildmyram &lt;size in MB&gt; /dev/myram</code>。创建一个RAM盘。</li>
</ul>
</li>
</ul>
<p>我们将KB变成MB ，可以这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;minix/paths.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioc_memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">char</span> *d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span> || argc &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;size in MB&gt; [device]\n"</span>,</span><br><span class="line">            argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    d = argc == <span class="number">2</span> ? _PATH_RAMDISK : argv[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>((fd=<span class="built_in">open</span>(d, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(d);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 需要把宏从1024改为1024*1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MFACTOR 1048576</span></span><br><span class="line">    <span class="built_in">size</span> = atol(argv[<span class="number">1</span>])*MFACTOR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"size should be non-negative.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ioctl(fd, MIOCRAMSIZE, &amp;<span class="built_in">size</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"MIOCRAMSIZE"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"size on %s set to %ldMB\n"</span>, d, <span class="built_in">size</span>/MFACTOR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/05/19/os-project3/4.png"></p>
<ul>
<li><p>在ram盘上创建内存文件系统，<code>mkfs.mfs /dev/myram</code>。</p>
</li>
<li><p>将ram盘挂载到用户目录下，<code>mount /dev/myram /root/myram</code>,(首先必须先<code>mkdir myram</code>)查看是否挂在成功：输入df，结果如下：</p>
</li>
</ul>
<p><img src="/2021/05/19/os-project3/5.png">其中,GB、MB、512-block 转换方式如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>GB</th>
<th>MB</th>
<th>512-blocks</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1024</td>
<td>2097152</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>注：重启后用户自定义的ram盘内容会丢失，需要重新设置大小，创建文件系统，并挂载。</li>
</ul>
<p><img src="/2021/05/19/os-project3/6.png"></p>
<p>重启后，我们会发现刚刚创建的ram盘就丢失了，我们就需要重复下面三条命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;buildmyram 700 &#x2F;dev&#x2F;myram 	&#x2F;&#x2F; 因为吞吐量不会大于700MB&#x2F;s 这里就把Ram盘设置为700mb</span><br><span class="line">mkfs.mfs &#x2F;dev&#x2F;myram</span><br><span class="line">mount &#x2F;dev&#x2F;myram &#x2F;root&#x2F;myram</span><br></pre></td></tr></table></figure>
<h2 id="性能测试："><a href="#性能测试：" class="headerlink" title="性能测试："></a>性能测试：</h2><p>RAM盘和Disk盘的性能测试中，需要采用多进程并发的同步读写，并发数要增加到设备接近“饱和”状态（吞吐量难以继续提升，但是I/O延时恶化）。在出现饱和前，总吞吐量随着并发数线性增长。</p>
<p>性能测试的二个变量为<strong>块大小</strong>（推荐64B/256B/1KB/4KB/16KB/64KB）和<strong>块扫描方式</strong>（顺序/随机）。可以画<strong>四张曲线图</strong>对比RAM盘和Disk盘性能（随机读，随机写，顺序读，顺序写）。实验结果预计为RAM盘性能高于DISK盘，特别是随机读写性能。<strong>对比在不同的blocksize下的性能</strong>，然后通过Excel把数据制作成图表。</p>
<h3 id="编写测试文件"><a href="#编写测试文件" class="headerlink" title="编写测试文件"></a>编写测试文件</h3><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>使用posix函数open打开文件，利用O_SYNC参数使得write/read操作为同步模式。</li>
<li>一定要检查write/read函数的返回值，以及写入的字节数目，确定是否成功。</li>
<li>为了简化实验，可以<strong>为每个进程分配一个独立的文件</strong>。为了减小主机操作系统的缓存机制造成的误差，文件总大小越大越好（例如300MB）。</li>
<li>随机读写时，可以采用<code>lseek()</code>重新定位文件指针；顺序读写时，默认文件指针自动移动，当读到文件末尾时，可以用<code>lseek()</code>返回文件头。</li>
<li>每组的读写需要反复持续一段时间，过短的时间会造成误差较大。</li>
<li>通常情况下，7~15个进程达到饱和，吞吐量不会高于700MB/s (ram盘顺序读写)。</li>
<li>如果minix虚拟机建在SSD下，会导致随机和顺序的差距减小，所以最好把虚拟机放在机械硬盘上，实验效果更明显。</li>
</ul>
<p>首先， usr文件夹是硬盘, 而myram 文件夹是内存。我们需要将一个尽可能大的文件放到这两个文件夹中去。</p>
<h4 id="写方法"><a href="#写方法" class="headerlink" title="写方法"></a>写方法</h4><p>写文件:打开文件，判断返回值，如果正常打开文件就判断是否随机写，进行写操作</p>
<p>这里要说一下打开文件的方式，<code>O_CREAT,O_RDWR,O_SYNC</code> 以及权限编码：</p>
<p><code>O_RDWR</code> 即以<strong>可读写</strong>的方式打开文件</p>
<p><code>O_SYNC</code>以同步的方式打开文件，利用<code>O_SYNC</code>参数使得<code>write/read</code>操作为同步模式</p>
<p><code>O_CREAT</code>若想要打开的文件不存在则自动建立该文件</p>
<p>后面四位数字分别代表 <strong>全部用户(all), 文件用户(user),同组用户(group),其他用户(other)</strong> 的权限</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>十进制</th>
<th>二进制</th>
<th>代表</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>000</td>
<td>无</td>
</tr>
<tr>
<td>1</td>
<td>001</td>
<td>—x(只可执行)</td>
</tr>
<tr>
<td>2</td>
<td>010</td>
<td>-w-(只可写)</td>
</tr>
<tr>
<td>3</td>
<td>011</td>
<td>-wx(可写可执行)</td>
</tr>
<tr>
<td>4</td>
<td>100</td>
<td>r—(只可读)</td>
</tr>
<tr>
<td>5</td>
<td>101</td>
<td>r-x(可读可执行)</td>
</tr>
<tr>
<td>6</td>
<td>110</td>
<td>rw-(可读可写)</td>
</tr>
<tr>
<td>7</td>
<td>111</td>
<td>rwx(可读可写可执行)</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向缓存中写入大小为blocksize的数字</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_to_buf</span><span class="params">(<span class="keyword">char</span>* buf, <span class="keyword">int</span> blocksize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; blocksize; i++)</span><br><span class="line">        buf[i] = rand() % <span class="number">94</span> + <span class="number">33</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_file</span><span class="params">(<span class="keyword">int</span> blocksize, <span class="keyword">bool</span> isrand, <span class="keyword">char</span> *filepath, <span class="keyword">int</span> fs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> total_block = fs / blocksize; <span class="comment">// 需要写入的总block数</span></span><br><span class="line">    <span class="keyword">char</span>* buf = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * blocksize); <span class="comment">// 缓存字符串，大小为一个block </span></span><br><span class="line">  	<span class="comment">//往缓存中写入数据</span></span><br><span class="line">    write_to_buf(buf, blocksize);</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 只写、同步打开文件,并处理错误</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = <span class="built_in">open</span>(filepath, O_WRONLY|O_SYNC)) &lt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Open Error!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; total_block; i++)</span><br><span class="line">    &#123;</span><br><span class="line">  <span class="comment">//write()会把缓存中的数据写到文件当中去. 当然, 文件读写位置也会随之移动.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">write</span>(fd, buf, blocksize) == <span class="number">-1</span>) <span class="comment">// 写入缓存 </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Write Error!\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isrand) <span class="comment">// 如果随机写，每次写入随机编号的block </span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">//lseek可以将读写未知移到任意未知</span></span><br><span class="line">            <span class="keyword">if</span> (lseek(fd, rand() % total_block * blocksize, SEEK_SET) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Lseek Error!\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">close</span>(fd) != <span class="number">0</span>) <span class="comment">//关闭文件 并处理错误</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Close Error!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="读方法"><a href="#读方法" class="headerlink" title="读方法"></a>读方法</h4><p>读方法和写方法的结构是一样的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_file</span><span class="params">(<span class="keyword">int</span> blocksize, <span class="keyword">bool</span> isrand, <span class="keyword">char</span> *filepath, <span class="keyword">int</span> fs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> total_block = fs / blocksize; <span class="comment">// 需要读取的总block数 </span></span><br><span class="line">    <span class="keyword">char</span>* buf = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * blocksize); <span class="comment">// 缓存字符串，大小为一个block</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = <span class="built_in">open</span>(filepath, O_CREAT | O_RDWR | O_SYNC, <span class="number">0755</span>)) &lt; <span class="number">0</span>) <span class="comment">// 只读、同步打开文件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Open Error!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; total_block ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((code = <span class="built_in">read</span>(fd, buf, blocksize)) == <span class="number">-1</span>) <span class="comment">// 将文件中的信息读取至缓存</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Read Error!\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isrand) <span class="comment">// 如果随机读，就随机跳到某个地方开始读</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (lseek(fd, rand() % total_block * blocksize, SEEK_SET) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Lseek Error!\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (code == <span class="number">0</span>) <span class="comment">// 如果顺序读，并且已经读到队尾，那么就移到文件开头继续读</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (lseek(fd, <span class="number">0</span>, SEEK_SET) == <span class="number">-1</span>)<span class="comment">//移动到文件开头</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Lseek to Head Error!\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">close</span>(fd) != <span class="number">0</span>) <span class="comment">/* 关闭文件 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Close Error!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h4><p>主函数：首先创建和命名文件，通过循环执行<code>read_file</code>和<code>write_file</code>函数测试读写差异。测试<code>blocksize</code>和<code>concurrency</code>对测试读写速度的影响，最后输出结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先写两个 utils， 第一个函数是获取当前的时间</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get_current_time</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    struct timeval tv;</span><br><span class="line">    gettimeofday(&amp;tv, NULL);</span><br><span class="line">    <span class="keyword">return</span> tv.tv_sec * <span class="number">1000</span> + tv.tv_usec / <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二个是获取运行时间</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get_run_time</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> starttime, <span class="keyword">long</span> <span class="keyword">long</span> endtime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> endtime - starttime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> io_list</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">write</span>, <span class="built_in">read</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> order_list</span><br><span class="line">    &#123;</span><br><span class="line">        sequential = <span class="literal">false</span>,  <span class="built_in">random</span> = <span class="literal">true</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> starttime, endtime, usetime;</span><br><span class="line">    <span class="keyword">char</span> filepath[MaxFileName];</span><br><span class="line">  <span class="comment">// 定义块数组，从 64到66536</span></span><br><span class="line">    <span class="keyword">int</span> blocksizelist[] = &#123;<span class="number">64</span>, <span class="number">256</span>,<span class="number">1024</span>, <span class="number">4096</span> ,<span class="number">16384</span>, <span class="number">66536</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> blocksize;</span><br><span class="line">    <span class="keyword">int</span> filesizeMB;</span><br><span class="line">    <span class="keyword">long</span> filesize = <span class="number">100</span> * MFACTOR; <span class="comment">// 1024*1024</span></span><br><span class="line">    <span class="keyword">int</span> concurrency = <span class="number">5</span>;					<span class="comment">// 并发5</span></span><br><span class="line">    <span class="keyword">bool</span> deletefile = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> RedoTime = <span class="number">3</span>;							<span class="comment">//重复次数为3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> io;</span><br><span class="line">    <span class="keyword">bool</span> order;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">4</span>) </span><br><span class="line">        help_and_quit();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(argv[<span class="number">1</span>], <span class="string">"-w"</span>, <span class="number">2</span>)) </span><br><span class="line">            io = <span class="built_in">write</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(argv[<span class="number">1</span>], <span class="string">"-r"</span>, <span class="number">2</span>))</span><br><span class="line">            io = <span class="built_in">read</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            help_and_quit();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(argv[<span class="number">2</span>], <span class="string">"-0"</span>, <span class="number">2</span>)) </span><br><span class="line">            order = sequential;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(argv[<span class="number">2</span>], <span class="string">"-1"</span>, <span class="number">2</span>))</span><br><span class="line">            order = <span class="built_in">random</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            help_and_quit();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((filesizeMB = atoi(argv[<span class="number">3</span>])) &gt;= <span class="number">1</span> &amp;&amp; filesizeMB &lt;= <span class="number">200</span>) </span><br><span class="line">            filesize = filesizeMB * MFACTOR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            help_and_quit();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;= <span class="number">6</span>; k+=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        blocksize = blocksizelist[k];</span><br><span class="line">        starttime = get_current_time();</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; concurrency; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">sprintf</span>(filepath, <span class="string">"./file%d.txt"</span>, i);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((fd = creat(filepath, <span class="number">777</span>)) == <span class="number">-1</span>) <span class="comment">/* 创建文件后关闭 */</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"Create Error!\n"</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">close</span>(fd) != <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"Close Error!\n"</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (io == <span class="built_in">read</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    write_file(blocksize, order, filepath, filesize/concurrency);</span><br><span class="line">                    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; RedoTime - <span class="number">1</span>; j++)</span><br><span class="line">                        read_file(blocksize, order, filepath, filesize/concurrency);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; RedoTime - <span class="number">1</span>; j++)</span><br><span class="line">                        write_file(blocksize, order, filepath, filesize/concurrency);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (deletefile &amp;&amp; (<span class="built_in">remove</span>(filepath) != <span class="number">0</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"Remove Error!\n"</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// printf("Parent process running\n");</span></span><br><span class="line">        <span class="keyword">while</span> (waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>) != <span class="number">-1</span>)&#123;&#125;</span><br><span class="line">        <span class="comment">// printf("All child processes finished\n");</span></span><br><span class="line"></span><br><span class="line">        endtime = get_current_time();</span><br><span class="line">        usetime = get_run_time(starttime, endtime);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"File size: %ld MB.\n"</span>, filesize / MFACTOR);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Blocksize: %d.\n"</span>, blocksize);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Redo times: %d.\n"</span>, RedoTime);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Execution time: %lld msec(s).\n"</span>, usetime);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Throughput: %f MB/S\n\n"</span>, ((<span class="keyword">double</span>)filesize / MFACTOR) * RedoTime / ((<span class="keyword">double</span>)usetime / <span class="number">1024</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>分块大小</th>
<th>ram</th>
<th>disk</th>
</tr>
</thead>
<tbody>
<tr>
<td>64</td>
<td>12.387097</td>
<td>10.858385</td>
</tr>
<tr>
<td>256</td>
<td>47.872838</td>
<td>27.863946</td>
</tr>
<tr>
<td>1024</td>
<td>157.538462</td>
<td>91.237491</td>
</tr>
<tr>
<td>4096</td>
<td>380.19802</td>
<td>180.705582</td>
</tr>
<tr>
<td>16384</td>
<td>550.044763</td>
<td>236.307692</td>
</tr>
<tr>
<td>66536</td>
<td>646.736842</td>
<td>257.826269</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>分块大小</td>
<td>ram</td>
<td>disk</td>
</tr>
<tr>
<td>64</td>
<td>17.886463</td>
<td>8.031373</td>
</tr>
<tr>
<td>256</td>
<td>71.300917</td>
<td>47.690775</td>
</tr>
<tr>
<td>1024</td>
<td>228.997391</td>
<td>110.048361</td>
</tr>
<tr>
<td>4096</td>
<td>519.357566</td>
<td>169.185606</td>
</tr>
<tr>
<td>16384</td>
<td>722.823529</td>
<td>195.047619</td>
</tr>
<tr>
<td>66536</td>
<td>783.673469</td>
<td>201.442623</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>分块大小</td>
<td>ram</td>
<td>disk</td>
</tr>
<tr>
<td>64</td>
<td>4.561823</td>
<td>5.918561</td>
</tr>
<tr>
<td>256</td>
<td>20.2999336</td>
<td>11.837121</td>
</tr>
<tr>
<td>1024</td>
<td>71.168771</td>
<td>23.674242</td>
</tr>
<tr>
<td>4096</td>
<td>297.24238</td>
<td>47.348485</td>
</tr>
<tr>
<td>16384</td>
<td>550.537634</td>
<td>94.69697</td>
</tr>
<tr>
<td>66536</td>
<td>695.022624</td>
<td>189.393939</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>分块大小</td>
<td>ram</td>
<td>disk</td>
</tr>
<tr>
<td>64</td>
<td>5.809929</td>
<td>0.610483</td>
</tr>
<tr>
<td>256</td>
<td>24.924949</td>
<td>2.032418</td>
</tr>
<tr>
<td>1024</td>
<td>96</td>
<td>8.908608</td>
</tr>
<tr>
<td>4096</td>
<td>372.353636</td>
<td>55.941</td>
</tr>
<tr>
<td>16384</td>
<td>625.025432</td>
<td>139.098936</td>
</tr>
<tr>
<td>66536</td>
<td>722.823529</td>
<td>219.428571</td>
</tr>
</tbody>
</table>
</div>
<p>结果如下图所示：</p>
<p><img src="/2021/05/19/os-project3/7.png"></p>
<p><img src="/2021/05/19/os-project3/8.png"></p>
<p><img src="/2021/05/19/os-project3/9.png"></p>
<p><img src="/2021/05/19/os-project3/10.png"></p>
<p>将随机</p>
<p><img src="/2021/05/19/os-project3/11.png"></p>
<p><img src="/2021/05/19/os-project3/12.png"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/" itemprop="url">操作系统-死锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-17T13:22:29+08:00">
                2021-05-17
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-06-24T01:05:34+08:00">
                2022-06-24
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>思维导图：</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/1.png" style="zoom:80%;"></p>
<p>计算机系统中有很多<code>独占性</code>的资源，在同一时刻只能每个资源只能由一个进程使用，我们之前经常提到过打印机，这就是一个独占性的资源，<strong>同一时刻不能有两个打印机同时输出结果，否则会引起文件系统的瘫痪</strong>。所以，操作系统具有授权一个进程单独访问资源的能力。</p>
<p>两个进程独占性的访问某个资源，从而等待另外一个资源的执行结果，会导致两个进程都被阻塞，并且两个进程都不会释放各自的资源，这种情况就是 <code>死锁(deadlock)</code>。</p>
<p>死锁可以发生在任何层面，在不同的机器之间可能会发生死锁，在数据库系统中也会导致死锁，比如进程 A 对记录 R1 加锁，进程 B 对记录 R2 加锁，然后进程 A 和 B 都试图把对象的记录加锁，这种情况下就会产生死锁。</p>
<p>下面我们就来讨论一下什么是死锁、死锁的条件是什么、死锁如何预防、活锁是什么等。</p>
<p>首先你需要先了解一个概念，那就是资源是什么</p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>大部分的死锁都和资源有关，在进程对设备、文件具有独占性（排他性）时会产生死锁。我们把这类需要排他性使用的对象称为<code>资源(resource)</code>。资源主要分为 <strong>可抢占资源和不可抢占资源</strong></p>
<h3 id="可抢占资源和不可抢占资源"><a href="#可抢占资源和不可抢占资源" class="headerlink" title="可抢占资源和不可抢占资源"></a>可抢占资源和不可抢占资源</h3><p>资源主要有可抢占资源和不可抢占资源。<code>可抢占资源(preemptable resource)</code> 可以从拥有它的进程中抢占而不会造成其他影响，内存就是一种可抢占性资源，任何进程都能够抢先获得内存的使用权。</p>
<p><code>不可抢占资源(nonpreemtable resource)</code> 指的是除非引起错误或者异常，否则进程无法抢占指定资源，这种不可抢占的资源比如有光盘，在进程执行调度的过程中，其他进程是不能得到该资源的。</p>
<p>死锁与不可抢占资源有关，虽然抢占式资源也会造成死锁，不过这种情况的解决办法通常是在进程之间重新分配资源来化解。所以，我们的重点自然就会放在了不可抢占资源上。</p>
<p>下面给出了使用资源所需事件的抽象顺序</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/2.png" style="zoom:80%;"></p>
<p>如果在请求时资源不存在，请求进程就会强制等待。在某些操作系统中，当请求资源失败时进程会自动阻塞，当自资源可以获取时进程会自动唤醒。在另外一些操作系统中，请求资源失败并显示错误代码，然后等待进程等待一会儿再继续重试。</p>
<p>请求资源失败的进程会陷入一种<strong>请求资源、休眠、再请求资源</strong>的循环中。此类进程虽然没有阻塞，但是处于从目的和结果考虑，这类进程和阻塞差不多，因为这类进程并没有做任何有用的工作。</p>
<p>请求资源的这个过程是很依赖操作系统的。在一些系统中，一个 <code>request</code> 系统调用用来允许进程访问资源。在一些系统中，操作系统对资源的认知是它是一种特殊文件，在任何同一时刻只能被一个进程打开和占用。资源通过 <code>open</code> 命令进行打开。如果文件已经正在使用，那么这个调用者会阻塞直到当前的占用文件的进程关闭文件为止。</p>
<h3 id="资源获取"><a href="#资源获取" class="headerlink" title="资源获取"></a>资源获取</h3><p>对于一些数据库系统中的记录这类资源来说，应该由用户进程来对其进行管理。有一种管理方式是使用<code>信号量(semaphore)</code> 。这些信号量会初始化为 1 。互斥锁也能够起到相同的作用。</p>
<blockquote>
<p>这里说一下什么是<code>互斥锁(Mutexes)</code>:</p>
<p>在计算机程序中，<code>互斥对象(mutex)</code> 是一个程序对象，它允许多个程序共享同一资源，例如文件访问权限，但并不是同时访问。需要锁定资源的线程都必须在使用资源时将互斥锁与其他线程绑定（进行加锁）。当不再需要数据或线程结束时，互斥锁设置为解锁。</p>
</blockquote>
<p>下面是一个伪代码，这部分代码说明了信号量的资源获取、资源释放等操作，如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore aResource;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processA</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  down(&amp;aResource);</span><br><span class="line">	useResource();</span><br><span class="line">  up(&amp;aResource);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面显示了一个进程资源获取和释放的过程，但是一般情况下会存在多个资源同时获取锁的情景，这样该如何处理？如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore aResource;</span><br><span class="line">semaphore bResource;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processA</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  down(&amp;aResource);</span><br><span class="line">  down(&amp;bResource);</span><br><span class="line">	useAResource();</span><br><span class="line">  useBResource();</span><br><span class="line">  up(&amp;aResource);</span><br><span class="line">  up(&amp;bResource);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于单个进程来说，并不需要加锁，因为不存在和这个进程的竞争条件。所以单进条件下程序能够完好运行。</p>
<p>现在让我们考虑两个进程的情况，A 和 B ，还存在两个资源。如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore aResource;</span><br><span class="line">semaphore bResource;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processA</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  down(&amp;aResource);</span><br><span class="line">  down(&amp;bResource);</span><br><span class="line">	useBothResource();</span><br><span class="line">  up(&amp;bResource);</span><br><span class="line">  up(&amp;aResource);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processB</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  down(&amp;aResource);</span><br><span class="line">  down(&amp;bResource);</span><br><span class="line">	useBothResource();</span><br><span class="line">  up(&amp;bResource);</span><br><span class="line">  up(&amp;aResource);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，两个进程以相同的顺序访问资源。一个进程在另一个进程之前获取资源，如果另外一个进程想在第一个进程释放之前获取资源，那么它会由于资源的加锁而阻塞，直到该资源可用为止。</p>
<p>在下面这段代码中，有一些变化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore aResource;</span><br><span class="line">semaphore bResource;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processA</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  down(&amp;aResource);</span><br><span class="line">  down(&amp;bResource);</span><br><span class="line">	useBothResource();</span><br><span class="line">  up(&amp;bResource);</span><br><span class="line">  up(&amp;aResource);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processB</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  down(&amp;bResource); <span class="comment">// 变化的代码 交换了A和B的位置</span></span><br><span class="line">  down(&amp;aResource); <span class="comment">// 变化的代码</span></span><br><span class="line">	useBothResource();</span><br><span class="line">  up(&amp;aResource); <span class="comment">// 变化的代码 </span></span><br><span class="line">  up(&amp;bResource); <span class="comment">// 变化的代码 </span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种情况就不同了，可能会发生同时获取两个资源并有效地阻塞另一个过程，直到完成为止。也就是说，可能会发生进程 A 获取资源 A 的同时进程 B 获取资源 B 的情况。然后每个进程在尝试获取另一个资源时被阻塞。</p>
<p>在这里我们会发现一个简单的获取资源顺序的问题就会造成<code>死锁</code>，所以死锁是很容易发生的，所以下面我们就对死锁做一个详细的认识和介绍。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>如果要对死锁进行一个定义的话，下面的定义比较贴切</p>
<p><strong>如果一组进程中的每个进程都在等待一个事件，而这个事件只能由该组中的另一个进程触发，这种情况会导致死锁</strong>。</p>
<p>简单一点来表述一下，就是每个进程都在等待其他进程释放资源，而其他资源也在等待每个进程释放资源，这样没有进程抢先释放自己的资源，这种情况会产生死锁，所有进程都会无限的等待下去。</p>
<p>换句话说，死锁进程结合中的每个进程都在等待另一个死锁进程已经占有的资源。但是由于所有进程都不能运行，它们之中任何一个资源都无法释放资源，所以没有一个进程可以被唤醒。这种死锁也被称为<code>资源死锁(resource deadlock)</code>。资源死锁是最常见的类型，但不是所有的类型，我们后面会介绍其他类型，我们先来介绍资源死锁</p>
<h3 id="资源死锁的条件"><a href="#资源死锁的条件" class="headerlink" title="资源死锁的条件"></a>资源死锁的条件</h3><p>针对我们上面的描述，资源死锁可能出现的情况主要有</p>
<ul>
<li>互斥条件：每个资源都被分配给了一个进程或者资源是可用的</li>
<li>保持和等待条件：已经获取资源的进程被认为能够获取新的资源</li>
<li>不可抢占条件：分配给一个进程的资源不能强制的从其他进程抢占资源，它只能由占有它的进程显示释放</li>
<li>循环等待：死锁发生时，系统中一定有两个或者两个以上的进程组成一个循环，循环中的每个进程都在等待下一个进程释放的资源。</li>
</ul>
<p>发生死锁时，上面的情况必须同时会发生。如果其中任意一个条件不成立，死锁就不会发生。可以通过破坏其中任意一个条件来破坏死锁，下面这些破坏条件就是我们探讨的重点</p>
<h3 id="死锁模型"><a href="#死锁模型" class="headerlink" title="死锁模型"></a>死锁模型</h3><p>Holt 在 1972 年提出对死锁进行建模，建模的标准如下：</p>
<ul>
<li>圆形表示进程</li>
<li>方形表示资源</li>
</ul>
<p>从资源节点到进程节点表示资源已经被进程占用，如下图所示</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/3.png" style="zoom:80%;"></p>
<p>在上图中表示当前资源 R 正在被 A 进程所占用</p>
<p>由进程节点到资源节点的有向图表示当前进程正在请求资源，并且该进程已经被阻塞，处于等待这个资源的状态</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/4.png" style="zoom:80%;"></p>
<p>在上图中，表示的含义是进程 B 正在请求资源 S 。Holt 认为，死锁的描述应该如下</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/5.png" style="zoom:80%;"></p>
<p>这是一个死锁的过程，进程 C 等待资源 T 的释放，资源 T 却已经被进程 D 占用，进程 D 等待请求占用资源 U ，资源 U 却已经被线程 C 占用，从而形成环。</p>
<p>总结一点：<strong>吃着碗里的看着锅里的容易死锁</strong></p>
<p>那么如何避免死锁呢？我们还是通过死锁模型来聊一聊</p>
<p>假设有三个进程 (A、B、C) 和三个资源(R、S、T) 。三个进程对资源的请求和释放序列如下图所示</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/6.png" style="zoom:80%;"></p>
<p>操作系统可以任意选择一个非阻塞的程序运行，所以它可以决定运行 A 直到 A 完成工作；它可以运行 B 直到 B 完成工作；最后运行 C。</p>
<p>这样的顺序不会导致死锁（因为不存在对资源的竞争），但是这种情况也完全没有<code>并行性</code>。进程除了在请求和释放资源外，还要做计算和输入/输出的工作。当进程按照顺序运行时，在等待一个 I/O 时，另一个进程不能使用 CPU。所以，严格按照串行的顺序执行并不是最优越的。另一方面，如果没有进程在执行任何 I/O 操作，那么最短路径优先作业会优于轮转调度，所以在这种情况下串行可能是最优越的</p>
<p>现在我们假设进程会执行计算和 I/O 操作，所以轮询调度是一种合理的<code>调度算法</code>。资源请求可能会按照下面这个顺序进行</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/7.png" style="zoom:80%;"></p>
<p>下图是针对上面这六个步骤的资源分配图。</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/8.png" style="zoom:80%;"></p>
<blockquote>
<p>这里需要注意一个问题，为什么从资源出来的有向图指向了进程却表示<strong>进程请求资源</strong>呢？笔者刚开始看也有这个疑问，但是想了一下这个意思解释为进程占用资源比较合适，而进程的有向图指向资源表示进程被阻塞的意思。</p>
</blockquote>
<p>在上面的第四个步骤，进程 A 正在等待资源 S；第五个步骤中，进程 B 在等待资源 T；第六个步骤中，进程 C 在等待资源 R，因此<strong>产生了环路</strong>并导致了死锁。</p>
<p>然而，操作系统并没有规定一定按照某种特定的顺序来执行这些进程。遇到一个可能会引起死锁的线程后，操作系统可以干脆不批准请求，并把进程挂起一直到安全状态为止。比如上图中，如果操作系统认为有死锁的可能，它可以选择不把资源 S 分配给 B ，这样 B 被挂起。这样的话操作系统会只运行 A 和 C，那么资源的请求和释放就会是下面的步骤</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/9.png" style="zoom:80%;"></p>
<p>下图是针对上面这六个步骤的资源分配图。</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/10.png" style="zoom:80%;"></p>
<p>在第六步执行完成后，可以发现并没有产生死锁，此时就可以把资源 S 分配给 B，因为 A 进程已经执行完毕，C 进程已经拿到了它想要的资源。进程 B 可以直接获得资源 S，也可以等待进程 C 释放资源 T 。</p>
<p>有四种处理死锁的策略：</p>
<ul>
<li>忽略死锁带来的影响（惊呆了）</li>
<li>检测死锁并恢复死锁，死锁发生时对其进行检测，一旦发生死锁后，采取行动解决问题</li>
<li>通过仔细分配资源来避免死锁</li>
<li>通过破坏死锁产生的四个条件之一来避免死锁</li>
</ul>
<p>下面我们分别介绍一下这四种方法</p>
<h2 id="鸵鸟算法"><a href="#鸵鸟算法" class="headerlink" title="鸵鸟算法"></a>鸵鸟算法</h2><p>最简单的解决办法就是使用<code>鸵鸟算法(ostrich algorithm)</code>，把头埋在沙子里，假装问题根本没有发生。每个人看待这个问题的反应都不同。数学家认为死锁是不可接受的，必须通过有效的策略来防止死锁的产生。工程师想要知道问题发生的频次，系统因为其他原因崩溃的次数和死锁带来的严重后果。如果死锁发生的频次很低，而经常会由于硬件故障、编译器错误等其他操作系统问题导致系统崩溃，那么大多数工程师不会修复死锁。</p>
<h2 id="死锁检测和恢复"><a href="#死锁检测和恢复" class="headerlink" title="死锁检测和恢复"></a>死锁检测和恢复</h2><p>第二种技术是死锁的检测和恢复。这种解决方式不会尝试去阻止死锁的出现。相反，这种解决方案会希望死锁尽可能的出现，在监测到死锁出现后，对其进行恢复。下面我们就来探讨一下死锁的检测和恢复的几种方式</p>
<h3 id="每种类型一个资源的死锁检测方式"><a href="#每种类型一个资源的死锁检测方式" class="headerlink" title="每种类型一个资源的死锁检测方式"></a>每种类型一个资源的死锁检测方式</h3><p>每种资源类型都有一个资源是什么意思？我们经常提到的打印机就是这样的，资源只有打印机，但是设备都不会超过一个。</p>
<p>可以通过构造一张资源分配表来检测这种错误，比如我们上面提到的</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/11.png" style="zoom:80%;"></p>
<p>的算法来检测从 $P_1$ 到 $P_n$ 这 $n$ 个进程中的死锁。假设资源类型为 $m$，$E_1$ 代表资源类型1，$E_2$ 表示资源类型 2 ，$E_i$ 代表资源类型$ i ,(1 &lt;= i &lt;= m)$。E 表示的是 <code>现有资源向量(existing resource vector)</code>，代表每种已存在的资源总数。</p>
<p>现在我们就需要构造两个数组：C 表示的是<code>当前分配矩阵(current allocation matrix)</code> ，R 表示的是 <code>请求矩阵(request matrix)</code>。$C<em>i$ 表示的是 $P_i $持有每一种类型资源的资源数。所以，$C</em>{ij} $表示 $P<em>i$ 持有资源 $j$ 的数量。$R</em>{ij}$ 表示$ P_i$ 所需要获得的资源 $j$ 的数量 </p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/12.png" style="zoom:80%;"></p>
<p>一般来说，已分配资源 j 的数量加起来再和所有可供使用的资源数相加 = 该类资源的总数。</p>
<p><strong>死锁的检测就是基于向量的比较</strong>。每个进程起初都是没有被标记过的，算法会开始对进程做标记，进程被标记后说明进程被执行了，不会进入死锁，当算法结束时，<strong>任何没有被标记过的进程都会被判定为死锁进程</strong>。</p>
<p>上面我们探讨了两种检测死锁的方式，那么现在你知道怎么检测后，你何时去做死锁检测呢？一般来说，有两个考量标准：</p>
<ul>
<li>每当有资源请求时就去检测，这种方式会占用昂贵的 CPU 时间。</li>
<li>每隔 k 分钟检测一次，或者当 CPU 使用率降低到某个标准下去检测。考虑到 CPU 效率的原因，如果死锁进程达到一定数量，就没有多少进程可以运行，所以 CPU 会经常空闲。</li>
</ul>
<h3 id="从死锁中恢复"><a href="#从死锁中恢复" class="headerlink" title="从死锁中恢复"></a>从死锁中恢复</h3><p>上面我们探讨了如何检测进程死锁，我们最终的目的肯定是想让程序能够正常的运行下去，所以针对检测出来的死锁，我们要对其进行恢复，下面我们会探讨几种死锁的恢复方式</p>
<h4 id="通过抢占进行恢复"><a href="#通过抢占进行恢复" class="headerlink" title="通过抢占进行恢复"></a>通过抢占进行恢复</h4><p>在某些情况下，可能会临时将某个资源从它的持有者转移到另一个进程。比如在不通知原进程的情况下，将某个资源从进程中强制取走给其他进程使用，使用完后又送回。这种恢复方式一般比较困难而且有些简单粗暴，<strong>并不可取</strong>。</p>
<h4 id="通过回滚进行恢复"><a href="#通过回滚进行恢复" class="headerlink" title="通过回滚进行恢复"></a>通过回滚进行恢复</h4><p>如果系统设计者和机器操作员知道有可能发生死锁，那么就可以定期检查流程。进程的检测点意味着进程的状态可以被写入到文件以便后面进行恢复。检测点不仅包含<code>存储映像(memory image)</code>，还包含<code>资源状态(resource state)</code>。一种更有效的解决方式是不要覆盖原有的检测点，而是每出现一个检测点都要把它写入到文件中，这样当进程执行时，就会有一系列的检查点文件被累积起来。</p>
<p>为了进行恢复，要从上一个较早的检查点上开始，这样所需要资源的进程会回滚到上一个时间点，在这个时间点上，死锁进程还没有获取所需要的资源，可以在此时对其进行资源分配。</p>
<h4 id="杀死进程恢复"><a href="#杀死进程恢复" class="headerlink" title="杀死进程恢复"></a>杀死进程恢复</h4><p>最简单有效的解决方案是直接杀死一个死锁进程。但是杀死一个进程可能照样行不通，这时候就需要杀死别的资源进行恢复。</p>
<p>另外一种方式是选择一个环外的进程作为牺牲品来释放进程资源。</p>
<h2 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h2><p>我们上面讨论的是如何检测出现死锁和如何恢复死锁，下面我们探讨几种规避死锁的方式</p>
<h3 id="单个资源的银行家算法"><a href="#单个资源的银行家算法" class="headerlink" title="单个资源的银行家算法"></a>单个资源的银行家算法</h3><p>银行家算法是 Dijkstra 在 1965 年提出的一种调度算法，它本身是一种死锁的调度算法。它的模型是基于一个城镇中的银行家，银行家向城镇中的客户承诺了一定数量的贷款额度。算法要做的就是判断请求是否会进入一种不安全的状态。如果是，就拒绝请求，如果请求后系统是安全的，就接受该请求。</p>
<p>比如下面的例子，银行家一共为所有城镇居民提供了 15 单位个贷款额度，一个单位表示 1k 美元，如下所示</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/13.png" style="zoom:80%;"></p>
<p>城镇居民都喜欢做生意，所以就会涉及到贷款，每个人能贷款的最大额度不一样，在某一时刻，A/B/C/D 的贷款金额如下</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/14.png" style="zoom:80%;"></p>
<p>上面每个人的贷款总额加起来是 13，马上接近 15，银行家只能给 A 和 C 进行放贷，可以拖着 B 和 D、所以，可以让 A 和 C 首先完成，释放贷款额度，以此来满足其他居民的贷款。这是一种<code>安全</code>的状态。</p>
<p>如果每个人的请求导致总额会超过甚至接近 15 ，就会处于一种不安全的状态，如下所示</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/15.png" style="zoom:80%;"></p>
<p>这样，每个人还能贷款至少 2 个单位的额度，如果其中有一个人发起最大额度的贷款请求，就会使系统处于一种死锁状态。</p>
<blockquote>
<p>这里注意一点：不安全状态并不一定引起死锁，由于客户不一定需要其最大的贷款额度，但是银行家不敢抱着这种侥幸心理。</p>
</blockquote>
<p>银行家算法就是对每个请求进行检查，检查是否请求会引起不安全状态，如果不会引起，那么就接受该请求；如果会引起，那么就推迟该请求。</p>
<p>类似的，还有多个资源的银行家算法，读者可以自行了解。</p>
<h2 id="破坏死锁"><a href="#破坏死锁" class="headerlink" title="破坏死锁"></a>破坏死锁</h2><p>死锁本质上是无法避免的，因为它需要获得未知的资源和请求，但是死锁是满足四个条件后才出现的，它们分别是</p>
<ul>
<li>互斥</li>
<li>保持和等待</li>
<li>不可抢占</li>
<li>循环等待</li>
</ul>
<p>我们分别对这四个条件进行讨论，按理说破坏其中的任意一个条件就能够破坏死锁</p>
<h3 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h3><p>我们首先考虑的就是<strong>破坏互斥使用条件</strong>。如果资源不被一个进程独占，那么死锁肯定不会产生。如果两个打印机同时使用一个资源会造成混乱，打印机的解决方式是使用 <code>假脱机打印机(spooling printer)</code> ，这项技术可以<strong>允许多个进程同时产生输出</strong>，在这种模型中，实际请求打印机的唯一进程是打印机守护进程，也称为后台进程。后台进程不会请求其他资源。我们可以消除打印机的死锁。</p>
<p>后台进程通常被编写为能够输出完整的文件后才能打印，假如两个进程都占用了假脱机空间的一半，而这两个进程都没有完成全部的输出，就会导致死锁。</p>
<p>因此，尽量做到尽可能少的进程可以请求资源。</p>
<h3 id="破坏保持等待的条件"><a href="#破坏保持等待的条件" class="headerlink" title="破坏保持等待的条件"></a>破坏保持等待的条件</h3><p>第二种方式是如果我们能阻止持有资源的进程请求其他资源，我们就能够消除死锁。一种实现方式是让所有的进程开始执行前请求全部的资源。如果所需的资源可用，进程会完成资源的分配并运行到结束。如果有任何一个资源处于频繁分配的情况，那么没有分配到资源的进程就会等待。</p>
<p>很多进程<strong>无法在执行完成前就知道到底需要多少资源</strong>，如果知道的话，就可以使用银行家算法；还有一个问题是这样<strong>无法合理有效利用资源</strong>。</p>
<p>还有一种方式是进程在请求其他资源时，先释放所占用的资源，然后再尝试一次获取全部的资源。</p>
<h3 id="破坏不可抢占条件"><a href="#破坏不可抢占条件" class="headerlink" title="破坏不可抢占条件"></a>破坏不可抢占条件</h3><p>破坏不可抢占条件也是可以的。可以通过虚拟化的方式来避免这种情况。</p>
<h3 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h3><p>现在就剩最后一个条件了，循环等待条件可以通过多种方法来破坏。一种方式是制定一个标准，一个进程在任何时候只能使用一种资源。如果需要另外一种资源，必须释放当前资源。对于需要将大文件从磁带复制到打印机的过程，此限制是不可接受的。</p>
<p>另一种方式是将所有的资源统一编号，如下图所示</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/16.png" style="zoom:80%;"></p>
<p>进程可以在任何时间提出请求，但是所有的请求都必须按照资源的顺序提出。如果按照此分配规则的话，那么资源分配之间不会出现环。</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/17.png" style="zoom:80%;"></p>
<p>尽管通过这种方式来消除死锁，但是编号的顺序不可能让每个进程都会接受。</p>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>下面我们来探讨一下其他问题，包括 <strong>通信死锁、活锁是什么、饥饿问题和两阶段加锁</strong></p>
<h3 id="两阶段加锁"><a href="#两阶段加锁" class="headerlink" title="两阶段加锁"></a>两阶段加锁</h3><p>虽然很多情况下死锁的避免和预防都能处理，但是效果并不好。随着时间的推移，提出了很多优秀的算法用来处理死锁。例如在数据库系统中，一个经常发生的操作是请求锁住一些记录，然后更新所有锁定的记录。当同时有多个进程运行时，就会有死锁的风险。</p>
<p>一种解决方式是使用 <code>两阶段锁(two-phase locking)</code>。顾名思义分为两个阶段，一阶段是进程尝试一次锁定它需要的所有记录。如果成功后，才会开始第二阶段，第二阶段是执行更新并释放锁。第一阶段并不做真正有意义的工作。</p>
<p>如果在第一阶段某个进程所需要的记录已经被加锁，那么该进程会释放所有锁定的记录并重新开始第一阶段。从某种意义上来说，这种方法类似于预先请求所有必需的资源或者是在进行一些不可逆的操作之前请求所有的资源。</p>
<p>不过在一般的应用场景中，两阶段加锁的策略并不通用。如果一个进程缺少资源就会半途中断并重新开始的方式是不可接受的。</p>
<h3 id="通信死锁"><a href="#通信死锁" class="headerlink" title="通信死锁"></a>通信死锁</h3><p>我们上面一直讨论的是资源死锁，资源死锁是一种死锁类型，但并不是唯一类型，还有通信死锁，也就是两个或多个进程在发送消息时出现的死锁。进程 A 给进程 B 发了一条消息，然后进程 A 阻塞直到进程 B 返回响应。假设请求消息丢失了，那么进程 A 在一直等着回复，进程 B 也会阻塞等待请求消息到来，这时候就产生<code>死锁</code>。</p>
<p>尽管会产生死锁，但是这并不是一个资源死锁，因为 A 并没有占据 B 的资源。事实上，通信死锁并没有完全可见的资源。根据死锁的定义来说：每个进程因为等待其他进程引起的事件而产生阻塞，这就是一种死锁。相较于最常见的通信死锁，我们把上面这种情况称为<code>通信死锁(communication deadlock)</code>。</p>
<p>通信死锁不能通过调度的方式来避免，但是可以使用通信中一个非常重要的概念来避免：<code>超时(timeout)</code>。在通信过程中，只要一个信息被发出后，发送者就会启动一个定时器，定时器会记录消息的超时时间，如果超时时间到了但是消息还没有返回，就会认为消息已经丢失并重新发送，通过这种方式，可以避免通信死锁。</p>
<p>但是并非所有网络通信发生的死锁都是通信死锁，也存在资源死锁，下面就是一个典型的资源死锁。</p>
<p>当一个数据包从主机进入路由器时，会被放入一个缓冲区，然后再传输到另外一个路由器，再到另一个，以此类推直到目的地。缓冲区都是资源并且数量有限。如下图所示，每个路由器都有 10 个缓冲区（实际上有很多）。</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/18.png" style="zoom:80%;"></p>
<p>假如路由器 A 的所有数据需要发送到 B ，B 的所有数据包需要发送到 D，然后 D 的所有数据包需要发送到 A 。没有数据包可以移动，因为在另一端没有缓冲区可用，这就是一个典型的资源死锁。</p>
<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>你会发现一个很有意思的事情，死锁就跟榆木脑袋一样，不会转弯。我看过古代的一则故事：</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/19.png" style="zoom:80%;"></p>
<p>如果说死锁很<code>痴情</code>的话，那么<code>活锁</code>用一则成语来表示就是 <code>弄巧成拙</code>。</p>
<p>某些情况下，当进程意识到它不能获取所需要的下一个锁时，就会尝试礼貌的释放已经获得的锁，然后等待非常短的时间再次尝试获取。可以想像一下这个场景：当两个人在狭路相逢的时候，都想给对方让路，相同的步调会导致双方都无法前进。</p>
<p>现在假想有一对并行的进程用到了两个资源。它们分别尝试获取另一个锁失败后，两个进程都会释放自己持有的锁，再次进行尝试，这个过程会一直进行重复。很明显，这个过程中没有进程阻塞，但是进程仍然不会向下执行，这种状况我们称之为 <code>活锁(livelock)</code>。</p>
<h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>与死锁和活锁的一个非常相似的问题是 <code>饥饿(starvvation)</code>。想象一下你什么时候会饿？一段时间不吃东西是不是会饿？对于进程来讲，最重要的就是资源，如果一段时间没有获得资源，那么进程会产生饥饿，这些进程会永远得不到服务。</p>
<p>我们假设打印机的分配方案是每次都会分配给最小文件的进程，那么要打印大文件的进程会永远得不到服务，导致进程饥饿，进程会无限制的推后，虽然它没有阻塞。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>死锁是一类通用问题，任何操作系统都会产生死锁。当每一组进程中的每个进程都因等待由该组的其他进程所占有的资源而导致阻塞，死锁就发生了。这种情况会使所有的进程都处于无限等待的状态。</p>
<p>死锁的检测和避免可以通过安全和不安全状态来判断，其中一个检测方式就是银行家算法；当然你也可以使用鸵鸟算法对死锁置之不理，但是你肯定会遭其反噬。</p>
<p>也可以在设计时通过系统结构的角度来避免死锁，这样能够预防死锁；也可以破坏死锁的四个条件来破坏死锁。资源死锁并不是唯一性的死锁，还有通信间死锁，可以设置适当的超时时间来完成。</p>
<p>活锁和死锁的问题有些相似，它们都是一种进程无法继续向下执行的状态。由于进程调度策略导致尝试获取进程的一方永远无法获得资源后，进程会导致饥饿的出现。</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/05/16/%E7%BB%9F%E8%AE%A1%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%835-1-5-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/16/%E7%BB%9F%E8%AE%A1%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%835-1-5-3/" itemprop="url">统计量及其分布5.1-5.3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-16T15:27:07+08:00">
                2021-05-16
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2023-01-16T11:56:01+08:00">
                2023-01-16
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="总体与样本"><a href="#总体与样本" class="headerlink" title="总体与样本"></a>总体与样本</h2><h3 id="总体与个体"><a href="#总体与个体" class="headerlink" title="总体与个体"></a>总体与个体</h3><p>在一个统计问题中，我们把研究对象的全体称为<strong>总体</strong>，构成总体的每个成员称为<strong>个体</strong>。比如说：</p>
<ul>
<li>某大学的全体学生构成问题的总体，每一个学生就是一个个体</li>
</ul>
<p>抛开实际背景，总体就是一堆数，这堆数中有大有小，因此用一个概率分布去描述和归纳总体是恰当的。从这个意义看，总体就是一个分布，而其数量指标就是服从这个分布的随机变量。所以<strong>从总体中抽样</strong>与<strong>从某分布中抽样</strong>是同一个意思</p>
<p>总体还有<strong>有限总体</strong>和<strong>无限总体</strong>，接下来将以无限总体作为主要研究对象。</p>
<h3 id="样本"><a href="#样本" class="headerlink" title="样本"></a>样本</h3><p>为了了解总体的分布，我们从总体中随机地抽取n个个体，记其指标值为$x_1,x_2\cdots,x_n$, 则 $x_1,x_2,\cdots,x_n$称为总体的<strong>一个样本</strong>。</p>
<h2 id="样本数据的整理与显示"><a href="#样本数据的整理与显示" class="headerlink" title="样本数据的整理与显示"></a>样本数据的整理与显示</h2><h3 id="经验分布函数"><a href="#经验分布函数" class="headerlink" title="经验分布函数"></a>经验分布函数</h3><p>设$x<em>1,x_2\cdots,x_n$ 是取自总体分布函数为$F(x)$的样本，若将样本观测值有小到大进行排列，记为$x</em>{(1)},x<em>{(2)},\cdots,x</em>{(n)}$ ,则$x<em>{(1)},x</em>{(2)},\cdots,x_{(n)}$ 称为<strong>有序样本</strong>，用有序样本定义如下函数：</p>
<script type="math/tex; mode=display">
F_n(x) =F\left( x\right) \begin{cases}0, 当x<x_{(1)} \\
k/n ~~,当x_{(k)}\leq x <x_{(k+1)} \\
1 ,当 x\geq x_{(n)} \end{cases}</script><p>则$F_n(x)$ 是一非减右连续函数，称$F_n(x)$为该样本的<strong>经验分布函数</strong></p>
<p>设$x_1,x_2,\cdots,x_n$是取自总体分布函数为$F(x)$的样本，$F_n(x)$ 是经验分布函数，当$n\rightarrow \infty$时，有：</p>
<script type="math/tex; mode=display">
P(\sup\limits_{-\infty<x<\infty}|F_n(x)-F(x)|\rightarrow 0)=1</script><p>因此，经验分布函数的pdf和cdf可以写为：</p>
<script type="math/tex; mode=display">
</script><h1 id="统计量及其分布"><a href="#统计量及其分布" class="headerlink" title="统计量及其分布"></a>统计量及其分布</h1><h2 id="统计量与抽样分布"><a href="#统计量与抽样分布" class="headerlink" title="统计量与抽样分布"></a>统计量与抽样分布</h2><p>设 $x_1,x_2\cdots,x_n$ 为取自某个总体的样本，若样本函数 $T=T(x_1,x_2\cdots,x_n)$ 中不含任何未知函数，则称T为<strong>统计量</strong>。因此，统计量是一类函数，而统计量的分布称为<strong>抽样分布</strong>。</p>
<p>按照这一定义，若$x<em>1,x_2\cdots,x_n$ 为样本，则 $\sum</em>{i=1}^n x<em>i,\sum</em>{i=1}^n x_i^2$ 都是统计量，但是当$\mu,\sigma^2$ 未知时，$x_1-\mu,x_1/\sigma$ 这类的函数就不能称之为统计量。 注意了，<strong>尽管统计量不依赖于未知参数，但是它的分布是依赖于未知参数的</strong>。</p>
<p>下面我么来介绍一些常见的统计量及其抽样分布</p>
<h2 id="样本均值及其抽样分布"><a href="#样本均值及其抽样分布" class="headerlink" title="样本均值及其抽样分布"></a>样本均值及其抽样分布</h2><p>首先我们给出样本均值的定义：</p>
<p>设 $x_1,x_2\cdots,x_n$ 为取自某总体的样本，其算数平均值称为<strong>样本均值</strong>，一般用$\overline x$ 表示，即：</p>
<script type="math/tex; mode=display">
\overline x= \frac{x_1+x_2+\cdots+x_n}{n}  = \frac{1}{n} \sum_{i=1}^n x_i</script><p>在<strong>分组样本场合</strong>，样本的<strong>近似公式</strong>为：</p>
<script type="math/tex; mode=display">
\overline x = \frac{x_1f_1+x_2f_2+\cdots+x_kf_k}{n} ~~~(n=\sum_{i=1}^n f_i)</script><p>其中，k为组数，$x_i$ 为第i组的组中值， $f_i$ 为第i组的频数</p>
<p>关于样本均值，有以下几个性质：</p>
<ul>
<li><p>若把样本中的数据与样本均值之差称为偏差，则样本<strong>所有偏差之和为0</strong>，即 $\sum_{i=1}^n(x_i-\overline n) = 0$ 这是显然的。</p>
</li>
<li><p>数据观测值与样本均值的偏差平方和最小，即 :</p>
<ul>
<li><script type="math/tex; mode=display">
\sum(x_i-c)^2\geq \sum(x_i-\overline x)^2</script></li>
<li><p>用文字描述的话，就是对任意给定的常数 c,  对于形如 $\sum(x_i-c)^2$ 的函数，$\sum(x_i-\overline x)^2$ 最小</p>
</li>
</ul>
</li>
<li><p>设 $x_1,x_2\cdots,x_n$ 是来自某个总体的样本，$\overline x$ 为样本均值</p>
<ul>
<li>若总体分布为 $N(\mu,\sigma^2)$ ， 则$\overline x$ 的精确分布为 $N(\mu,\sigma^2/n)$</li>
<li>若总体分布未知或者不是正态分布，且 $E(x)=\mu,Var(x) = \sigma^2$ 存在，则n较大时$\overline x$ 的<strong>渐进分布</strong>为$N(\mu,\sigma^2/n)$ 。<strong>这里渐近分布是指n较大的时候的近似分布</strong></li>
</ul>
</li>
</ul>
<h2 id="样本方差与样本标准差"><a href="#样本方差与样本标准差" class="headerlink" title="样本方差与样本标准差"></a>样本方差与样本标准差</h2><p>首先给出定义：</p>
<p>设 $x_1,x_2\cdots,x_n$ 为取自某总体的样本，则它关于样本均值 $\overline x$ 的<strong>平均偏差平方和</strong>就被称为<strong>样本方差</strong>：</p>
<script type="math/tex; mode=display">
s_n^2 =\frac{1}{n} \sum_{i=1}^n (x_i-\overline x)^2</script><p>其算术根 $s_n=\sqrt{s_n^2}$ 称为 <strong>样本标准差</strong>。相对样本方差而言，样本标准差通常更有实际意义，因为<strong>它与样本均值具有相同的度量单位</strong>。 </p>
<hr>
<p>在n 不大时，常用下式作为<strong>样本方差(s没有n)</strong>： </p>
<script type="math/tex; mode=display">
s^2 = \frac{1}{n-1}\sum_{i=1}^n (x_i-\overline x)^2</script><p>其算数根 $s=\sqrt{s^2}$ 也被称为样本标准差。</p>
<hr>
<p>在实际中，$s^2$ 比 $s^2_n$ 更常用，以后我们都是用 $s^2$ </p>
<p><strong>样本方差是度量样本散布大小的统计量</strong>， 在这个定义中，n 为 样本量，n-1 称为偏差平方和的自由度。其含义是： 在 $\overline x$ 确定后，n个偏差 $x_1-\overline x,x_2-\overline x,\cdots,x_n-\overline x$ 中只有 $n-1$个偏差可以自由变动(因为其和为0)</p>
<hr>
<p>样本偏差平方和有三个常用的表达式, 它们都可以用来计算样本方差：</p>
<script type="math/tex; mode=display">
\sum(x_i-\overline x)^2 = \sum x_i^2-\frac{(\sum x_i)^2}{n} = \sum x_i^2 - n\overline x^2</script><hr>
<p>在分组样本场合，样本方差的近似计算公式为：</p>
<script type="math/tex; mode=display">
s^2 = \frac{1}{n-1} \sum_{i=1}^k f_i(x_i-\overline x)^2  = \frac{1}{n-1}(\sum_{i=1}^k f_ix_i^2-n\overline x^2)</script><p>其中 $x_i,f_i$ 分别为第i个区间的组中值和频数，$\overline x = \frac{x_1f_1+x_2f_2+\cdots+x_kf_k}{n}$ 给出的均值近似值</p>
<h2 id="样本矩及其函数"><a href="#样本矩及其函数" class="headerlink" title="样本矩及其函数"></a>样本矩及其函数</h2><p>样本矩和矩一样，是样本均值和样本方差更一般的推广，是一类常见的统计量。</p>
<p>设 $x_1,x_2\cdots,x_n$ 是样本，k为正整数，则下面这个统计量被称为k阶原点矩</p>
<script type="math/tex; mode=display">
a_k = \frac{1}{n} \sum_{i=1}^n x_i^k</script><p>样本一阶原点矩就是样本均值</p>
<hr>
<p>类似的，我们给出样本的k阶 中心矩：</p>
<script type="math/tex; mode=display">
b_k = \frac{1}{n} \sum_{i=1}^n (x_i-\overline x)^k</script><p>样本二阶中心距就是样本方差</p>
<hr>
<p>现在再介绍样本偏度和样本峰度，它们都是中心矩的函数</p>
<p>设 $x_1,x_2\cdots,x_n$是样本，则称统计量 </p>
<script type="math/tex; mode=display">
\hat \beta_s = b_3/b_2^{3/2}</script><p>为<strong>样本偏度</strong></p>
<p>如果数据完全对称，那么$b_3=0$ 样本偏度就等于0；</p>
<p>如果 $\hat\beta_s$ 明显大于0，表示样本的右尾长，即样本中有几个特大的数，我们称其为正偏的右偏</p>
<p>如果 $\hat\beta_s$ 明显小于0，表示分布的左尾长，即样本中有几个特小的数，这反映了总体分布是负偏的或左偏的。</p>
<p><img src="/2021/05/16/%E7%BB%9F%E8%AE%A1%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%835-1-5-3/1.jpg" style="zoom:67%;"></p>
<hr>
<p> 设 $x_1,\cdots,x_n$ 是样本，则称统计量：</p>
<script type="math/tex; mode=display">
\hat\beta_k = \frac{b_4}{b_2^2}-3</script><p>为样本峰度</p>
<p>当 $\hat\beta_k$ 明显大于0 时，分布密度曲线在其峰值附近比正态分布来的更陡，尾部更细——称为尖顶型</p>
<p>当$\hat\beta_s$ 明显小于0时，分布密度曲线在其峰值附近比正态分布来得平坦，尾部更粗，称为平顶型</p>
<h2 id="次序统计量及其分布"><a href="#次序统计量及其分布" class="headerlink" title="次序统计量及其分布"></a>次序统计量及其分布</h2><p>设 $x<em>1\cdots,x_n$ 是取自总体X的样本，$x</em>{(i)}$ 称为该样本的第 i 个次序统计量，它的取值是将样本观测值由小到大排列后得到的第i个观测值。其中 $x<em>{(1)}$ 为该样本的最小次序统计量，$x</em>{(n)}$ 称为该样本的最大次序统计量。</p>
<p>$(x<em>{(1)},x</em>{(2)},\cdots,x_{(n)})$ 称为该样本的次序统计量</p>
<p>在一个样本中， $x<em>1,x_2\cdots x_n$ 是独立同分布的，而次序统计量 $x</em>{(1)},x<em>{(2)}\cdots,x</em>{(n)}$ 即不独立，分布也不相同。</p>
<p>接下来我们讨论次序统计量的抽样分布。</p>
<h3 id="单个次序统计量的分布"><a href="#单个次序统计量的分布" class="headerlink" title="单个次序统计量的分布"></a>单个次序统计量的分布</h3><p>设总体X的密度函数为 $p(x)$ 分布函数为$F(x)$ ，$x<em>1,x_2\cdots,x_n$为样本，则第k个次序统计量 $x</em>{(k)}$ 的密度函数为：</p>
<script type="math/tex; mode=display">
p_k(x) = \frac{n!}{(k-1)!(n-k)!}(F(x))^{k-1}(1-F(x))^{n-k}p(x)</script><p>特别的，当总体分布为 $U(0,1)$时，$x_1,\cdots,x_n$ 为样本，则其第k个次序统计量的密度函数为：</p>
<script type="math/tex; mode=display">
p_k(x)=\frac{n!}{(k-1)!(n-k)!}x^{k-1}(1-x)^{n-k}</script><p>这就是贝塔分布 $Be(k,n-k+1)$ 从而有 $E(x_{(k)})=\frac{k}{n+1}$</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>设总体目睹函数为：</p>
<script type="math/tex; mode=display">
p(x) = 3x^2~~0<x<1</script><p>现从该总体抽得一个容量为5的样本，试计算 $p(x_{2}&lt;\frac{1}{2})$ </p>
<p><strong>第一步：求出总体分布函数</strong></p>
<script type="math/tex; mode=display">
F(x) = \begin{cases}0,X\leq 0\\ x^{3},0<x<1\\ 1,x\geq 1\end{cases}</script><p><strong>第二步</strong>：求出$x_{(2 )}$ 的密度函数</p>
<script type="math/tex; mode=display">
p_2(x) = \frac{5!}{(2-1)!(5-2)!}(F(x))^{2-1}p(x)(1-F(x))^{5-2}\\
=20 x^33x^2(1-x^3)^3\\
=60x^5(1-x^3)^3 ~~~~~~ 0<x<1</script><p><strong>第三步：计算概率</strong></p>
<script type="math/tex; mode=display">
P(x_{(2)}<\frac12)= \int_0^{1/2} 60x^5(1-x^3)^3 dx\\
=\int_0^{1/8}20y(1-y)^3dy=\int_{7/8}^1 20(z^3-z^4)dz\\
=5(1-(\frac{7}{8})^4)-4(1-(\frac 78)^5) = 0.1207</script><h3 id="多个次序统计量及其函数分布"><a href="#多个次序统计量及其函数分布" class="headerlink" title="多个次序统计量及其函数分布"></a>多个次序统计量及其函数分布</h3><p>次序统计量$(x<em>{(i)},x</em>{(j)})(i&lt;j)$ 的联合分布密度函数为：</p>
<script type="math/tex; mode=display">
p_{ij}(y,z) = \frac{n!}{(i-1)!(j-i-1)!(n-j)!}[F(y)]^{i-1}[F(z)-F(y)]^{j-i-1}[1-F(z)]^{n-j}p(y)p(z),y\leq z</script><h2 id="样本分位数与样本中位数"><a href="#样本分位数与样本中位数" class="headerlink" title="样本分位数与样本中位数"></a>样本分位数与样本中位数</h2><p>样本中位数 $m_{0.5}$ 也是一个常见的统计量，它也是次序统计量的函数，当n为奇数时，取中间那个数；当n为偶数时，取中间两个数的平均数。</p>
<p>更一般的，样本p分位数$m_p$ 可如下定义：</p>
<script type="math/tex; mode=display">
F(x) = \begin{cases}x_{([np+1])},~~~~~ 若np不是整数\\~~\\ \frac12(x_{(np)}+x_{(np+1)})  ~~~~~若np是整数\end{cases}</script><h3 id="分位数的渐进分布"><a href="#分位数的渐进分布" class="headerlink" title="分位数的渐进分布"></a>分位数的渐进分布</h3><p>设总体密度函数为$p(x)$,$x_p$ 为其p分位数，$p(x)$ 在$x_p$处连续且 $p(x_p)&gt;0$ ,那么当$n\rightarrow \infty$时，样本p分位数$m_p$ 的渐进分布为：</p>
<script type="math/tex; mode=display">
m_p\sim N(x_p,\frac{p(1-p)}{np^2(x_p)})</script><p>特别的，对于样本中位数，当$n\rightarrow \infty$时，近似地有</p>
<script type="math/tex; mode=display">
m_{0.5}\sim N(x_{0.5}\frac{1}{4n\cdot p^2(x_{0.5})})</script><h4 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h4><p>在下列密度函数下分别寻求容量为n的样本中位数$m_{0.5}$的渐近分布：</p>
<ol>
<li><script type="math/tex; mode=display">
p(x) = 6x(1-x), 0<x<1</script><p>我们从这个密度函数就可以判断该分布为贝塔分布$Be(2,2)$ , 可以看出$p(x)$ 关于 0.5 对称，所以$x_{0.5}=0.5$ </p>
<p>于是可以带入公式，得到渐进分布为 $N(0.5,\frac{1}{9n})$</p>
<hr>
</li>
<li><script type="math/tex; mode=display">
p(x) = \frac{1}{\sqrt{2\pi} \sigma}\exp\{-\frac{(x-\mu)^2}{2\sigma^2}\}</script><p>显然，正态分布的中位数是 $\mu$  ,所以，$m_{0.5}$ 的渐近分布为$N(\mu,\frac{1}{4n\cdot\frac{1}{2\pi \sigma^2}}) =N(\mu,\frac{\pi\sigma^2}{2n})$</p>
<hr>
</li>
<li><script type="math/tex; mode=display">
p(x) = \begin{cases}2x, 0<x<1\\~\\0, 其他\end{cases}</script><p>该分布的分布函数为 $F(x) = \begin{cases}0,x&lt;0\~\x^2,0\leq x&lt;1\~\1 ,x\geq 1\end{cases}$ 所以相应的中位数为$\frac{\sqrt2}{2}$ ,所以$m_{0.5}$ 的渐进分布为 </p>
<script type="math/tex; mode=display">
N(\frac{\sqrt2}{2},\frac{1}{4n(2\times\frac{\sqrt2}{2})^2})=N(\frac{\sqrt2}2,\frac{1}{8n})</script></li>
</ol>
<h1 id="三大抽样分布"><a href="#三大抽样分布" class="headerlink" title="三大抽样分布"></a>三大抽样分布</h1><p>很多统计推断是基于正态分布的假设，以标准正态变量为基石而构造的三个著名的统计量在十几种有广泛的应用。</p>
<p><img src="/2021/05/16/%E7%BB%9F%E8%AE%A1%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%835-1-5-3/2.jpg" style="zoom:67%;"></p>
<p>下面我们逐个进行推导和证明</p>
<h3 id="mathcal-X-2-分布"><a href="#mathcal-X-2-分布" class="headerlink" title="$\mathcal X^2$ 分布"></a>$\mathcal X^2$ 分布</h3><p>设 $X_1,X_2\cdots,X_N$ 独立同分布于标准正态分布 $N(0,1)$ ，则 $\mathcal X^2 = \mathcal X_1^2+\cdots+\mathcal X_n^2$  的分布被称为自由度为n的$\mathcal X^2$ 分布，记为 $\mathcal X^2\sim \mathcal X^2(n)$ </p>
<p>在第三章中我们还给出了 卡方分布和伽马分布的关系，也就是$X^2(n) = Ga(\frac{n}2,\frac12)$ , 期望为 n， 方差为2n</p>
<p>$\mathcal X^2$ 分布有用的一个重要原因是下面这个定理：</p>
<h4 id="重要定理"><a href="#重要定理" class="headerlink" title="重要定理"></a>重要定理</h4><p>设 $x_1,x_2\cdots,x_n$ 是来自正态总体$N(\mu,\sigma^2)$ 的样本，其样本均值和样本方差分别为：</p>
<script type="math/tex; mode=display">
\begin{align}
&\overline x = \frac{1}{n}\sum_{i=1}^n x_i\\
&s^2 = \frac{1}{n-1} \sum_{i=1}^n(x_i-\overline x)^2
\end{align}</script><p>则有：</p>
<ol>
<li>$\overline x$ 与 $s^2$ 相互独立</li>
<li>$\overline x\sim N(\mu,\sigma^2/n)$</li>
<li>$\frac{(n-1)s^2}{\sigma^2}\sim \mathcal X^2(n-1)$ </li>
</ol>
<h3 id="F分布"><a href="#F分布" class="headerlink" title="F分布"></a>F分布</h3><p>设随机变量 $X_1\sim \mathcal X^2(m),X_2\sim\mathcal X^2(n)$，$X_1$ 与 $X_2$ 独立，则称 $F=\frac{X_1/m}{X_2/n}$ 的分布是自由度为m和n的F分布。记为 $F\sim F(m,n)$  ,其中m称为分子自由度，n称为分母自由度。</p>
<h4 id="推论："><a href="#推论：" class="headerlink" title="推论："></a>推论：</h4><p>设$x_1,x_2,\cdots,x_m$ 是来自 $N(\mu_1,\sigma_1^2)$的样本，$y_1\cdots,y_n$是来自$N(\mu_2,\sigma_2^2)$的样本，且此两样本相互独立。记：</p>
<script type="math/tex; mode=display">
s_x^2 = \frac{1}{m-1} \sum_{i=1}^m(x_i-\overline x)^2 , s_y^2 =\frac{1}{n-1}\sum_{i=1}^n(y_i-\overline y)^2</script><p>其中：</p>
<script type="math/tex; mode=display">
\overline x = \frac{1}{m} \sum_{i=1}^m x_i,\overline y = \frac{1}{n}\sum_{i=1}^n y_i</script><p>则有“</p>
<script type="math/tex; mode=display">
F=\frac{s_x^2/\sigma_1^2}{s_y^2/\sigma_2^2} \sim F(m-1,n-1) \\</script><p>特别的，若 $\sigma_1^2=\sigma_2^2$  则 $F=s_x^2/s_y^2\sim F(m-1,n-1)$</p>
<h4 id="例题：-构造F分布"><a href="#例题：-构造F分布" class="headerlink" title="例题： 构造F分布"></a>例题： 构造F分布</h4><p>设$x_1,x_2$是来自 $N(0,\sigma^2)$ 的样本，试求 $Y=(\frac{x_1+x_2}{x_1-x_2})^2$ 的分布。</p>
<p><strong>第一步：根据形态判断应该凑成哪个分布</strong></p>
<p>首先可以排除 t 分布的形式，因为没有根号出现。其次，这是一个分数的形式，因此最大的可能就是F分布。因此我们要想方设法配成F分布。</p>
<p>配成F分布的条件是：$F=\frac{X_1/m}{X_2/n}$ 其中$X_1$和$X_2$是两个卡方分布。而这里，$m=n=2$, 消去。 因此只要证明 $(x_1+x_2)^2$ 和 $(x_1-x_2)^2$ 都属于卡方分布即可。</p>
<p><strong>第二步：卡方分布怎么凑？</strong></p>
<p>凑卡方分布第一可以从 $Ga(n/2,1/2)$ 入手，或者从卡方分布：$x_1,x_2\cdots,x_n$ 独立同分布于标准正态分布, $\mathcal X^2 = x_1^2+\cdots+ x_n^2$ 的定义入手。</p>
<p>因为 $x_1,x_2$ 来自 $N(0,\sigma^2)$ , 二者又是独立同分布的，因此： $x_1+x_2\sim N(0,2\sigma^2),x_1-x_2\sim N(0,2\sigma^2)$ 把这两者看做是一个整体。标准化之后，可以获得：</p>
<script type="math/tex; mode=display">
\frac{x_1+x_2}{\sqrt{2\sigma^2}}\sim N(0,1)\\~\\
\frac{x_1-x_2}{\sqrt{2\sigma^2}}\sim N(0,1)</script><p>也就是说，一个单独的 $(\frac{x_1+x_2}{\sqrt{2\sigma^2}})^2$就可以看做是一个卡方分布;同理，$(\frac{x_1-x_2}{\sqrt{2\sigma^2}})^2$ 构成了另一个卡方分布，那么：</p>
<script type="math/tex; mode=display">
(\frac{x_1+x_2}{x_1-x_2})^2 =(\frac{(\frac{x_1+x_2}{\sqrt{2\sigma^2}})/2}{(\frac{x_1-x_2}{\sqrt{2\sigma^2}})/2})^2 \sim F(2-1,2-1)</script><hr>
<h3 id="t-分布"><a href="#t-分布" class="headerlink" title="t 分布"></a>t 分布</h3><p>设随机变量 $X_1$与$X_2$ 独立且$X_1\sim N(0,1),X_2\sim \mathcal X^2(n)$则称$t=\frac{X_1}{\sqrt{X_2/n}}$ 的分布为自由度为n的t分布，记为 $t\sim t(n)$</p>
<p>t分布的密度函数的图像是一个关于纵轴对称的分布，与标准正态分布的密度函数形状类似，只是峰比标准正态分布低一点尾部的概率比标准正态分布大一些</p>
<ul>
<li>自由度为1的t分布就是标准柯西分布，其均值不存在</li>
<li>$n&gt;1$时，t分布的数学期望存在且为0</li>
<li>$n&gt;2$时，t分布的方差存在且为$n/(n-2)$ </li>
<li>当自由度比较大时，t分布可以用$N(0,1)$分布近似</li>
</ul>
<h4 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h4><p>设 $x_1,x_2\cdots,x_n$ 是来自正态分布$N(\mu,\sigma^2)$的一个样本，$\overline x$ 与$s^2$ 分别是该样本的样本均值和样本方差则有：</p>
<script type="math/tex; mode=display">
t =\frac{\sqrt n(\overline x-\mu)}{s}\sim t(n-1)</script><h1 id="充分统计量"><a href="#充分统计量" class="headerlink" title="充分统计量"></a>充分统计量</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>我们之前谈了这么多的统计量，知道了统计量是关于样本的函数。对于一个总体来说，我们选取的样本是有限的，但是有限的样本会反映出总体的一些信息，进而可能帮助我们推断总体分布，那么我们希望某个统计量所包含的有用的信息和样本分布所包含的有用的信息是一样的，则这个统计量对将来的统计推断就非常有用——这就是充分统计量的直观含义</p>
<p>我们通过几个例子来更全面的了解充分统计量</p>
<h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><p>为研究某个运动员的打靶命中率$\theta$ ，我们对该运动员进行测试，观测其10次打靶结果，发现除了第3、6次未命中之外，其余8次都命中靶心。这样的观测结果告诉我们两点：</p>
<ol>
<li>打靶10次命中8次</li>
<li>2次不命中分别出现在第3次和第6次打靶上</li>
</ol>
<p>其实，第二点信息对我们了解这个运动员的命中率<strong>是没有帮助的</strong>。我们令每次射击要么命中要么不命中，命中为1，不命中为0. 那么命中率的计算和1出现的位置是没有关系的，而和出现1的次数有关系，比如第二轮打靶发现除了第1、2未命中其余都命中，虽然两轮样本观测值不一样，但是提供的关于命中率$\theta$的信息是一样的。因此<strong>在大多数实际问题中，试验编号信息常常对了解总体或者其参数是无关紧要的</strong></p>
<p>现在我们要想，什么统计量能反映出该选手的命中率$\theta$呢？ 很显然，令 $T = x_1+\cdots+x_n$ ，那么就可以通过T与样本数来反应命中率 $\theta$ 了。 统计上，将这种<strong>样本加工不损失信息</strong>称为<strong>充分性</strong></p>
<p>接下来，我们从概率层面分析：首先我们要搞清楚<strong>什么是有用的信息？</strong> 其实，有用的信息就和分布中的<strong>参数</strong></p>
<p>我们知道，样本$X=(x<em>1,x_2\cdots,x_n)$ 有一个样本联合分布 $F</em>\theta(X)$, 这个分布包含了样本中一切有关$\theta$的信息。 统计量$T=T(x<em>1\cdots,x_n)$也有一个抽样分布 $F</em>\theta^n(t)$ 。当我们期望用<strong>统计量T代替原始样本X并且不损失任何有关$\theta$的信息</strong> 时，说明 $F<em>\theta^T(t)$ 可以像$F</em>\theta(X)$ 一样概括了有关$ \theta$ 的一切信息。</p>
<p>换言之，我们考察统计量T的取值为t的情况下样本X的条件分布$F<em>\theta(X|T=t)$ ，当 $F</em>\theta(X|T=t)$ 不依赖于参数$\theta$ 时，说明样本所反映出来的有用的信息，都包含在统计量 T当中了。相当于我们给定了一个统计量的值之后，也就知道了样本中关于$\theta$的所有信息，剩下的其他信息就没什么价值了，这正是统计量具有充分性的含义。</p>
<h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><p>现在我们看看充分统计量和不充分的统计量之间的区别</p>
<p>设总体为二点分布 $b(1,\theta)$ ,$X<em>1,X_2\cdots,X_n$为样本，令 $T = X_1+X_2\cdots+X_n$ ，则在给定了T的取值之后，对于任意一组 $x_1,x_2\cdots,x_n$ ，$\sum</em>{i=1}^n x_i = t$ 都有：</p>
<script type="math/tex; mode=display">
P(X_1=x_1,X_2 =x_2,\cdots,X_n=x_n|T=t)\\~\\
=\frac{P(X_1=x_1,X_2 =x_2,\cdots,X_n=t-\sum_{i=1}^{n-1}x_i)}{P(\sum_{i=1}^n X_i=t)}\\~\\
=\prod_{i=1}^n P(X_i=x_i) \cdot P(X_n=t-\sum_{i=1}^{n-1}x_i)/C_n^t\theta^t(1-\theta)^n-t\\~\\</script><p>化简得到：</p>
<script type="math/tex; mode=display">
=\frac{\prod_{i=1}^{n-1}\theta^{x_i}(1-\theta)^{1-x_i}\cdot \theta^{t-\sum_{i=1}^{n-1}x_i}(1-\theta)^{1-t+\sum_{i=1}^{n-1}x_i}}{C_n^t \theta^t(1-\theta)^{n-t}}\\~\\
=\theta^{t}\cdot(1-\theta)^{n-t}/C_n^t\theta^t(1-\theta)^{n-t} \\~\\
=\frac{1}{C_n^t}</script><p>到最后，这个条件分布已经和 $\theta$没关系了。</p>
<p>但是我们现在令 $S=X_1+X_2$, 显然没有包含样本中所有关于$\theta$的信息，那么，在给定的$S=s$之后，对于任意一组$x_1,x_2\cdots,x_n,(x_1+x_2=s)$ 有：</p>
<script type="math/tex; mode=display">
P(X_1=x_1,X_2 =x_2,\cdots,X_n=x_n|S=s)\\~\\
=\frac{P(X_1=x_1,X_2=s-x_1,\cdots,X_n=x_n)}{P(X_1+X_2=s)}\\~\\
=\theta^{x_1}(1-\theta)^{1-x_1}\theta^{s-x_1}(1-\theta)^{1-s+x_1}\theta^{\sum_{i=3}^n x_i}(1-\theta)^{n-2-\sum_i^nx_i}/P(X_1+X_2=s) \\~\\
=\frac{\theta^{s+\sum_{i=3}^nx_i}(1-\theta)^{n-s-\sum_{i=3}^nx_i}}{C_2^s\theta^s(1-\theta)^{2-s}} =\frac{\theta^{\sum_{i=1}^nx_i}(1-\theta)^{n-2-\sum_{i=3}^nx_i}}{C_2^s}</script><p>这个分布最终的化简结果依赖于未知参数$\theta$，这说明样本中有关$\theta$的信息并没有完全包含在统计量S中。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>经过了上面这两个例子，其实充分统计量的定义就呼之欲出了。</p>
<p>设$x_1,x_2,\cdots,x_n$ 是来自某个总体的样本，总体分布函数为 $F(x;\theta)$ ,统计量 $T=T(x_1\cdots,x_n)$  称为$\theta$的充分统计量，如果在给定T的取值后$x_1\cdots,x_n$ 的条件分布与$\theta$无关</p>
<p>未知参数$\theta$ 可以是一维的也可以是多维的，应用中条件分布可以用条件分布列或者条件密度函数来表示。</p>
<h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p>设$x_1\cdots,x_n$ 是来自$N(\mu,1)$的样本，试证明 $T=\overline x$ 是$\mu$的充分统计量</p>
<p>总体采用<strong>配方</strong>策略</p>
<h2 id="因子分解定理"><a href="#因子分解定理" class="headerlink" title="因子分解定理"></a>因子分解定理</h2><p>在一般场合，直接由充分统计量的定义出发来验证一个统计量是充分的是困难的，因为条件分布的计算通常不那么容易。但是，我们有一个简单的办法判断一个统计量是否充分，这就是<strong>因子分解定理</strong>。 为了简便起见，我们引入一个两种分布类型通用的概念——<strong>概率函数</strong>。$f(x)$ 称为随机变量X的概率函数：在连续场合，$f(x)$表示X的概率密度函数，在离散场合，$f(x)$表示X的概率分布列。</p>
<p><strong>定理：</strong> </p>
<p>设总体概率函数为 $f(x;\theta)$ ,$x_1,\cdots,x_n$ 为样本，则 $T=T(x_1,x_2\cdots,x_n)$  为充分统计量的充分必要条件是：存在两个函数 $g(t;\theta)$ 和 $h(x_1,x_2\cdots,x_n)$ 使得对任意的 $ \theta$ 和任意一组观测值 $x_1\cdots,x_n$ 有：</p>
<script type="math/tex; mode=display">
f(x_1,x_2\cdots,x_n;\theta) = g(T(x_1,x_2\cdots,x_n),\theta) h(x_1,x_2\cdots,x_n)</script><p>其中，$g(t,\theta)$ 是通过统计量T的取值而依赖于样本的。也就是 $h(x_1,\cdots,x_n)$ 中不包含 $\theta$ 参数，$\theta$ 全部都在$g(t,\theta)$中</p>
<p>但是有时候我们在求联合分布函数的时候需要乘以一个示信函数 I， 当 x 和我们的参数之间存在关系时，比如：</p>
<p>设$x_1,x_2,\cdots,x_n$ 是取自总体 $U(0,\theta)$ 的样本，即总体的密度函数为：</p>
<script type="math/tex; mode=display">
p(x;\theta) = \begin{cases}1/\theta, 0<x<\theta\\~\\0, 其他\end{cases}</script><p>于是，样本的联合密度函数是：</p>
<script type="math/tex; mode=display">
p(x_1;\theta)p(x_2;\theta)\cdots p(x_3;\theta) = \begin{cases}(1/\theta)^n, 0 <\min\{x_i\}\leq \max\{x_i\}<\theta\\~\\
0,其他
\end{cases}</script><p>由于所有的 $x_i$都大于0， 且都小于$\theta$ 这里x的取值范围和$\theta$是有关系的，这时在写联合密度函数时就需要乘以示信函数，如下：</p>
<script type="math/tex; mode=display">
p(x_1;\theta)p(x_2;\theta)\cdots p(x_3;\theta) = (1/\theta)^n I_{\{x_{(n)}<\theta\}}</script><p>注意到这里示信函数为</p>
<script type="math/tex; mode=display">
 I_{\{x_{(n)}<\theta\}}</script><p>因为根据上面写的密度函数，最大的$x_i$ 也是小于参数$\theta$ 的</p>
<h4 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h4><p>设 $x_1\cdots,x_n\sim b(1,p)$  ，对其进行因子分解</p>
<script type="math/tex; mode=display">
f(x_1,x_2\cdots,x_n) = p^{\sum x_i}(1-p)^{n-\sum x_i}\\</script><p>令 $T=\sum x_i$ 经过配方：</p>
<script type="math/tex; mode=display">
=(1-p)^n\cdot(\frac{p}{1-p})^{\sum x_i}</script><p>那么，我们可以得到 $g(t;p)$ 和 $h(x_1,\cdots,x_n)$</p>
<script type="math/tex; mode=display">
g(t;p) = (1-p)^n(\frac{p}{1-p})^t\\
h(x_1,x_2\cdots,x_n) = 1</script><p>所以， $\sum x_i$ 是 $p$ 的充分统计量</p>
<h4 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h4><p>设 $x_1\cdots,x_n\sim N(0,\sigma^2)$ ，对其进行因子分解</p>
<script type="math/tex; mode=display">
p(x_1,x_2\cdots,x_n) = (2\pi)^{-\frac{n}{2}}(\sigma^2)^{-\frac{n}2}\exp\{-\frac{1}{2\sigma^2}\sum(x_i-0)^2\}\\~\\</script><p> 令 $T=\sum x_i^2$ ,经过配方可以得到 $g(t;\sigma^2)$和$h(x_1,x_2\cdots,x_n)$ </p>
<script type="math/tex; mode=display">
g(\sigma^2,t) = (\sigma^2)^{-\frac{n}2}\exp\{-\frac{1}{2\sigma^2}t \}\\~\\
h(x_1,x_2\cdots,x_n) = (2\pi)^{-\frac{n}2}</script><p>符合因子分解，那么 $\sum x_i^2$ 是$\sigma^2$的充分统计量</p>
<h4 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h4><p>设$x_1\cdots,x_n\sim N(\mu,\sigma^2)$  对其进行因子分解</p>
<p>这题比较特殊，因为这里 $\theta$ 是一个二维的参数： $\theta =\begin{pmatrix} n \ \sigma ^{2} \end{pmatrix}$</p>
<script type="math/tex; mode=display">
p(x_1,x_2\cdots,x_n) = (2\pi)^{-\frac n2}(\sigma^2)^{-\frac n2}\exp\{-\frac{1}{2\sigma^2}\sum_{i=1}^n(x_i-\mu)^2\}\\~\\
=(2\pi)^{-n/2}(\sigma^2)^{-n/2} \exp\{-\frac{1}{2\sigma^2}(\sum x_i^2-2n\overline x\mu+n\mu^2) \}\\~\\
 =(2\pi\sigma^2)^{-n/2}\exp\{-\frac{1}{2\sigma^2}\cdot n\mu^2\}\exp\{-\frac{1}{2\sigma^2}(\sum_{i=1}^n x_i^2-2\mu\sum_{i=1}^nx_i )\}</script><p>令$t<em>1=\sum</em>{i=1}^n x<em>i,t_2=\sum</em>{i=i}^n x_i^2$ 我们可以根据化简的结果计算$g(t;\theta)$和$h(x_1\cdots,x_n)$</p>
<script type="math/tex; mode=display">
g(t_1,t_2,\theta) = (2\pi\sigma^2)^{-n/2} exp\{-\frac{n\mu^2}{2\sigma^2}\}\exp\{-\frac{1}{2\sigma^2}(t_2-2\mu t_1)\} \\~\\
h(X) = 1</script><h4 id="例题4"><a href="#例题4" class="headerlink" title="例题4"></a>例题4</h4><p><img src="/2021/05/16/%E7%BB%9F%E8%AE%A1%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%835-1-5-3/3.jpg" style="zoom:67%;"></p>
<p>对于<strong>(a)</strong></p>
<ol>
<li>首先，观察 x的取值范围是否和参数有关系，并写出联合密度函数。</li>
</ol>
<p>显然这里，x和参数是有关系的，每一个 x 都要大于 $\mu$, 因此，最小的x也要大于$\mu$</p>
<script type="math/tex; mode=display">
p(x_1,x_2\cdots,x_n) = \prod_{i=1}^n \exp\{-(x_1-\mu)\}I(x>\mu)\\~\\
=\exp\{nu\}\prod_{i=1}^n \exp\{x_i\}I\{\mu<x_1\}</script><ol>
<li>根据因式分解定理，提取$T = x<em>{(1)}$ ，则 $g(t;\mu) = \prod</em>{i=1}^n\exp{-(x-\mu)}I{\mu&lt;x_{(1)}}$ ，$h(x)=1$</li>
</ol>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A-week11/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A-week11/" itemprop="url">计算机网络报告-week11</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-13T23:44:57+08:00">
                2021-05-13
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-08-23T22:25:20+08:00">
                2022-08-23
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="计算机网络报告-week11"><a href="#计算机网络报告-week11" class="headerlink" title="计算机网络报告-week11"></a>计算机网络报告-week11</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ul>
<li>深入掌握RPC编程</li>
<li>深入理解运输层协议</li>
</ul>
<h2 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h2><ul>
<li>利用gRPC实现跨语言调用</li>
<li>完成课本195页编程作业：实现一个可靠传输协议</li>
</ul>
<h2 id="任务1：利用gRPC实现跨语言调用"><a href="#任务1：利用gRPC实现跨语言调用" class="headerlink" title="任务1：利用gRPC实现跨语言调用"></a>任务1：利用gRPC实现跨语言调用</h2><p>利用gRPC框架，采用两种不同语言（比如C++和Java或Go和Java）实现客户端和服务端。</p>
<p>服务端提供getStuNo（）函数，该函数以自己的姓名为参数，返回自己的学号。客户端以自己的姓名为参数远程调用该函数，返回拿到自己的学号。</p>
<p><strong>将实现思路和关键代码以及实验截图写到实验报告中。</strong></p>
<p>这里，我使用Java和Python 两种语言来实现 grpc 的客户端与服务端。既可以是 Java client + Python server也可以是Java server + Python client</p>
<h3 id="Java客户端-python服务端"><a href="#Java客户端-python服务端" class="headerlink" title="Java客户端+python服务端:"></a>Java客户端+python服务端:</h3><h4 id="Java客户端"><a href="#Java客户端" class="headerlink" title="Java客户端"></a>Java客户端</h4><p>这次Java实现grpc，我是在week10的task2的基础上修改得来的,因此环境的搭建这里按下不表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.grpc.ManagedChannel;</span><br><span class="line"><span class="keyword">import</span> io.grpc.ManagedChannelBuilder;</span><br><span class="line"><span class="keyword">import</span> io.grpc.StatusRuntimeException;</span><br><span class="line"><span class="keyword">import</span> io.grpc.examples.helloworld.GreeterGrpc;</span><br><span class="line"><span class="keyword">import</span> io.grpc.examples.helloworld.HelloReply;</span><br><span class="line"><span class="keyword">import</span> io.grpc.examples.helloworld.HelloRequest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先创建一个final类型的不能被改变的参数用来获取类名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(HelloWorldClient<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">	<span class="comment">// 这边也同时定义两个</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ManagedChannel channel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> GreeterGrpc.GreeterBlockingStub blockingStub;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Construct client connecting to HelloWorld server at &#123;<span class="doctag">@code</span> host:port&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//接下来是定义一个方法，用来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorldClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        channel = ManagedChannelBuilder.forAddress(host, port)</span><br><span class="line">                .usePlaintext(<span class="keyword">true</span>)</span><br><span class="line">                .build();</span><br><span class="line">        blockingStub = GreeterGrpc.newBlockingStub(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        channel.shutdown().awaitTermination(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     greet函数是建立连接之后客户端的一些操作，比如说先模拟一个logger在尝试访问服务端。</span></span><br><span class="line"><span class="comment">     然后向服务端发送请求，调用sayHello()</span></span><br><span class="line"><span class="comment">     最后打印返回信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">"Will try to greet "</span> + name + <span class="string">" ..."</span>);</span><br><span class="line">        HelloRequest request = HelloRequest.newBuilder().setName(name).build();</span><br><span class="line">        HelloReply response;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response = blockingStub.sayHello(request);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (StatusRuntimeException e) &#123;</span><br><span class="line">            logger.log(Level.WARNING, <span class="string">"RPC failed: &#123;0&#125;"</span>, e.getStatus());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">"Greeting: "</span> + response.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    启动client的main函数，首先建立一个和端口50051的连接，然后开启greet()函数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HelloWorldClient client = <span class="keyword">new</span> HelloWorldClient(<span class="string">"localhost"</span>, <span class="number">50051</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            String user = <span class="string">"徐啟航"</span>;</span><br><span class="line">            <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                user = args[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            client.greet(user);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            client.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="python服务端："><a href="#python服务端：" class="headerlink" title="python服务端："></a>python服务端：</h4><p>在讲解python服务端之前，我们首先来搭建python的grpc环境：</p>
<p>首先我们要下载几个包：</p>
<p>安装grpc：<code>pip install grcpio</code></p>
<p>安装编译工具：<code>pip install grpcio-tools</code></p>
<p>然后在项目中新建helloworld 文件夹用于存放proto文件：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"><span class="keyword">package</span> helloworld;</span><br><span class="line"><span class="comment">// The greeting service definition.</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Sends a greeting</span></span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloReply) &#123;&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function">// The request message containing the user's name.</span></span><br><span class="line"><span class="function">message HelloRequest &#123;</span></span><br><span class="line"><span class="function">    string name = 1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// The response message containing the greetings</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">HelloReply</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> <span class="class"><span class="keyword">message</span> = 1;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>
<p>注意，这里写的package helloworld要和java中的proto文件一致。</p>
<p>接下来我们要在helloworld文件夹中编译proto文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m grpc_tools.protoc -I. --python_out&#x3D;. --grpc_python_out&#x3D;. .&#x2F;helloworld.proto</span><br></pre></td></tr></table></figure>
<p>编译完成后，helloworld文件夹下会出现<code>helloworld_pb2.py</code>以及<code>helloworld_pb2_grpc.py</code>两个文件.我们要修改一下<code>helloworld_pb2_grpc.py</code>中的依赖，否则在运行时会出错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"><span class="comment">#原来是 import helloworld_pb2 as helloworld__pb2</span></span><br><span class="line"><span class="keyword">from</span> helloworld <span class="keyword">import</span> helloworld_pb2 <span class="keyword">as</span> helloworld__pb2</span><br></pre></td></tr></table></figure>
<p>接下来开始写服务端的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"><span class="keyword">from</span> concurrent <span class="keyword">import</span> futures</span><br><span class="line"><span class="keyword">from</span> helloworld <span class="keyword">import</span> helloworld_pb2, helloworld_pb2_grpc</span><br><span class="line"></span><br><span class="line">_ONE_DAY_IN_SECONDS = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#首先定义处理请求的函数，打印请求者信息之后，返回他想要的信息</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span><span class="params">(helloworld_pb2_grpc.GreeterServicer)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">SayHello</span><span class="params">(self, request, context)</span>:</span></span><br><span class="line">        print(<span class="string">"%s 发来请求~"</span> % request.name)</span><br><span class="line">        <span class="keyword">return</span> helloworld_pb2.HelloReply(message=<span class="string">'Your ID is 10195501423, %s!'</span> % request.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是启动服务器的代码，规定了在那个端口开启服务以及错误处理等，这里使用了一个线程池来处理并发任务</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">serve</span><span class="params">()</span>:</span></span><br><span class="line">    server = grpc.server(futures.ThreadPoolExecutor(max_workers=<span class="number">10</span>))</span><br><span class="line">    helloworld_pb2_grpc.add_GreeterServicer_to_server(Greeter(), server)</span><br><span class="line">    server.add_insecure_port(<span class="string">'[::]:50051'</span>)</span><br><span class="line">    server.start()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            time.sleep(_ONE_DAY_IN_SECONDS)</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        server.stop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    serve()</span><br></pre></td></tr></table></figure>
<p>运行结果如下图所示：</p>
<p><img src="/2021/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A-week11/4.png"></p>
<h3 id="Java-服务端和-python客户端"><a href="#Java-服务端和-python客户端" class="headerlink" title="Java 服务端和 python客户端"></a>Java 服务端和 python客户端</h3><h4 id="python客户端"><a href="#python客户端" class="headerlink" title="python客户端"></a>python客户端</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"><span class="keyword">from</span> helloworld <span class="keyword">import</span> helloworld_pb2, helloworld_pb2_grpc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line"><span class="comment"># 客户端向50051端口发送请求，并打印返回结果</span></span><br><span class="line">    <span class="keyword">with</span> grpc.insecure_channel(<span class="string">'localhost:50051'</span>) <span class="keyword">as</span> channel:</span><br><span class="line">        stub = helloworld_pb2_grpc.GreeterStub(channel)</span><br><span class="line">        response = stub.SayHello(helloworld_pb2.HelloRequest(name=<span class="string">'徐啟航'</span>))</span><br><span class="line">    print(<span class="string">"Greeter client received: "</span> + response.message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure>
<h4 id="Java服务端"><a href="#Java服务端" class="headerlink" title="Java服务端"></a>Java服务端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.grpc.Server;</span><br><span class="line"><span class="keyword">import</span> io.grpc.ServerBuilder;</span><br><span class="line"><span class="keyword">import</span> io.grpc.examples.helloworld.GreeterGrpc;</span><br><span class="line"><span class="keyword">import</span> io.grpc.examples.helloworld.HelloReply;</span><br><span class="line"><span class="keyword">import</span> io.grpc.examples.helloworld.HelloRequest;</span><br><span class="line"><span class="keyword">import</span> io.grpc.stub.StreamObserver;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Server that manages startup/shutdown of a &#123;<span class="doctag">@code</span> Greeter&#125; server.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(HelloWorldServer<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The port on which the server should run */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port = <span class="number">50051</span>;</span><br><span class="line">    <span class="keyword">private</span> Server server;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        server = ServerBuilder.forPort(port)</span><br><span class="line">                .addService( <span class="keyword">new</span> GreeterImpl())</span><br><span class="line">                .build()</span><br><span class="line">                .start();</span><br><span class="line">        logger.info(<span class="string">"Server started, listening on "</span> + port);</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// Use stderr here since the logger may have been reset by its JVM shutdown hook.</span></span><br><span class="line">                System.err.println(<span class="string">"*** shutting down gRPC server since JVM is shutting down"</span>);</span><br><span class="line">                HelloWorldServer.<span class="keyword">this</span>.stop();</span><br><span class="line">                System.err.println(<span class="string">"*** server shut down"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</span><br><span class="line">            server.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *这个函数是用来阻止java server自动终止的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">blockUntilShutdown</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</span><br><span class="line">            server.awaitTermination();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//启动sever的main函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> HelloWorldServer server = <span class="keyword">new</span> HelloWorldServer();</span><br><span class="line">        server.start();</span><br><span class="line">        server.blockUntilShutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">GreeterImpl</span> <span class="keyword">extends</span> <span class="title">GreeterGrpc</span>.<span class="title">GreeterImplBase</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 原子Integer */</span></span><br><span class="line">        <span class="comment">//    public AtomicInteger count = new AtomicInteger(0);</span></span><br><span class="line">		<span class="comment">// 处理请求的函数，返回学号</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(HelloRequest req, StreamObserver&lt;HelloReply&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">            HelloReply reply = HelloReply.newBuilder().setMessage(<span class="string">"Hello "</span> + req.getName()+<span class="string">"Your ID is 10195501423"</span>).build();</span><br><span class="line">            responseObserver.onNext(reply);</span><br><span class="line">            responseObserver.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下图所示，虽然python客户端收到了来自java服务端的反馈信息，但是服务端却报错退出了。还没有找到原因。</p>
<p><img src="/2021/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A-week11/5.png"></p>
<h2 id="任务2：实现一个可靠传输协议"><a href="#任务2：实现一个可靠传输协议" class="headerlink" title="任务2：实现一个可靠传输协议"></a>任务2：实现一个可靠传输协议</h2><p>在这个编程作业实验中，你将要编写发送和接收运输层的代码，以实现一个简单的可靠数据运输协议。这个实验有两个版本，即比特交替协议版本和GBN版本。</p>
<p><strong>任务：基于比特交替协议以及GBN实现模拟实现客户端和服务端的可靠的数据传输协议。</strong></p>
<h3 id="实现要求"><a href="#实现要求" class="headerlink" title="实现要求"></a>实现要求</h3><p><img src="/2021/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A-week11/1.png"></p>
<ul>
<li>应用层消息（message）数据结构：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> &#123;</span></span><br><span class="line">		<span class="keyword">char</span> data[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>传输层消息（packet）数据结构：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pkt</span> &#123;</span></span><br><span class="line">          <span class="keyword">int</span> seqnum;</span><br><span class="line">          <span class="keyword">int</span> acknum;</span><br><span class="line">          <span class="keyword">int</span> checksum;</span><br><span class="line">          <span class="keyword">char</span> payload[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Hint：</strong>传输层消息中的payload字段即为应用层消息中的data字段，传输层消息中的其他字段为辅助字段（用于实现可靠传输，其中checksum部分自己选取合适的算法实现）。</p>
<p>1）. 需要实现的部分关键方法：</p>
<p>A_output(message)：A处理应用层发送的message，参数是要发送给B的数据。你要实现的协议就是要保证message的可靠传输；</p>
<p>A_input(packet)：A处理B发送过来的传输层packet；</p>
<p>A_timeinterrupt()：A的定时器，用于超时重传；</p>
<p>A_init()：用于A的一些初始化工作；</p>
<p>B_input(packet)：B处理A发送过来的传输层packet；</p>
<p>B_init()：用于B的一些初始化工作。</p>
<p><strong>2）. 部分需要实现的软件接口：</strong></p>
<p>starttimer(calling_entity,increment)：开始计时，calling_entity代表调用实体，这里为A或B；</p>
<p>stoptimer(calling_entity)：停止calling_entity计时；</p>
<p>tolayer3(calling_entity,packet)：calling_entity将消息转发到传输层；</p>
<p>tolayer5(calling_entity,message)：calling_entity将消息转发到应用层。</p>
<p><strong>3) 模拟的网络环境</strong></p>
<ul>
<li>消息有序接收：有多条message乱序发送，接收端需要保证按序接收；</li>
<li>消息丢失：设置消息丢失率，即消息有一定的概率会被丢失，但要保证接收端能够完整接收；</li>
<li>应用层平均延时：记录应用层从发出message请求到接收响应的平均延时。</li>
</ul>
<h3 id="基于Alternating-Bit-Protocol（ABP，rdt3-0）实现"><a href="#基于Alternating-Bit-Protocol（ABP，rdt3-0）实现" class="headerlink" title="基于Alternating-Bit-Protocol（ABP，rdt3.0）实现"></a>基于Alternating-Bit-Protocol（ABP，rdt3.0）实现</h3><p>ABP协议具体内容可参照课本P140-P142</p>
<p><img src="/2021/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A-week11/2.png"></p>
<p>图 2 ABP协议流程</p>
<h2 id="基于Go-Back-N实现"><a href="#基于Go-Back-N实现" class="headerlink" title="基于Go-Back-N实现"></a>基于Go-Back-N实现</h2><p><img src="/2021/05/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A-week11/3.png"></p>
<p>图 3 窗口长度为4个分组的GBN协议运行流程</p>
<p> 要求:窗口大小固定为8，如果A从应用层接受的包在窗口外面，直接简单的舍弃；不用太过考虑缓冲区溢出的问题</p>
<p>Hint：先实现ABP协议，在ABP协议的基础上实现GBN协议。</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/05/11/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E5%BA%A6%E9%87%8F%E4%B8%8E%E6%8A%95%E5%BD%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/11/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E5%BA%A6%E9%87%8F%E4%B8%8E%E6%8A%95%E5%BD%B1/" itemprop="url">数学基础-度量与投影</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-11T15:35:08+08:00">
                2021-05-11
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2021-05-11T15:37:12+08:00">
                2021-05-11
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="内积与范数"><a href="#内积与范数" class="headerlink" title="内积与范数"></a>内积与范数</h1><h2 id="正交与投影"><a href="#正交与投影" class="headerlink" title="正交与投影"></a>正交与投影</h2><h2 id="正交基与Gram-Schmidt-正交化"><a href="#正交基与Gram-Schmidt-正交化" class="headerlink" title="正交基与Gram-Schmidt 正交化"></a>正交基与Gram-Schmidt 正交化</h2><h2 id="具有特殊结构和性质的矩阵"><a href="#具有特殊结构和性质的矩阵" class="headerlink" title="具有特殊结构和性质的矩阵"></a>具有特殊结构和性质的矩阵</h2>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek10/" itemprop="url">计算机网络报告week10</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-07T15:18:06+08:00">
                2021-05-07
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-08-25T04:32:34+08:00">
                2022-08-25
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="RPC-协议"><a href="#RPC-协议" class="headerlink" title="RPC 协议"></a>RPC 协议</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ul>
<li>掌握RPC的工作原理</li>
<li>会写RPC程序 </li>
</ul>
<h2 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h2><ul>
<li><p>学习并理解RPC的工作原理</p>
</li>
<li><p>熟悉并掌握gRPC框架使用</p>
</li>
</ul>
<h2 id="协议简介"><a href="#协议简介" class="headerlink" title="协议简介"></a>协议简介</h2><h3 id="RPC协议"><a href="#RPC协议" class="headerlink" title="RPC协议"></a>RPC协议</h3><p>RPC（Remote Procedure Call Protocol）远程过程调用协议，一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。通俗的描述是：客户端在不知道调用细节的情况下，调用存在于远程计算机上的某个对象，就像调用本地应用程序中的对象一样。</p>
<h3 id="RPC协议要点"><a href="#RPC协议要点" class="headerlink" title="RPC协议要点"></a>RPC协议要点</h3><p>RPC是协议：既然是协议就只是一套规范，那么就需要有人遵循这套规范来进行实现。目前典型的RPC实现包括：Dubbo、Thrift、GRPC、Hetty等。这里要说明一下，目前技术的发展趋势来看，实现了RPC协议的应用工具往往都会附加其他重要功能，例如Dubbo还包括了服务治等功能。</p>
<p>网络协议和网络IO模型对其透明：既然RPC的客户端认为自己是在调用本地对象。那么传输层使用的是TCP/UDP还是HTTP协议，又或者是一些其他的网络协议它就不需要关心了。既然网络协议对其透明，那么调用过程中，使用的是哪一种网络IO模型调用者也不需要关心。</p>
<p>信息格式对其透明：我们知道在本地应用程序中，对于某个对象的调用需要传递一些参数，并且会返回一个调用结果。至于被调用的对象内部是如何使用这些参数，并计算出处理结果的，调用方是不需要关心的。那么对于远程调用来说，这些参数会以某种信息格式传递给网络上的另外一台计算机，这个信息格式是怎样构成的，调用方是不需要关心的。</p>
<p>应该有跨语言能力：调用方实际上不清楚远程服务器的应用程序是使用什么语言运行的。那么对于调用方来说，无论服务器方使用的是什么语言，本次调用都应该成功，并且返回值也应该按照调用方程序语言所能理解的形式进行描述。</p>
<h4 id="Client："><a href="#Client：" class="headerlink" title="Client："></a>Client：</h4><p>RPC协议的调用方。就像上文所描述的那样，最理想的情况是RPC Client在完全不知道有RPC框架存在的情况下发起对远程服务的调用。但实际情况来说Client或多或少的都需要指定RPC框架的一些细节。</p>
<h4 id="Server："><a href="#Server：" class="headerlink" title="Server："></a>Server：</h4><p>在RPC规范中，这个Server并不是提供RPC服务器IP、端口监听的模块。而是远程服务方法的具体实现（在JAVA中就是RPC服务接口的具体实现）。其中的代码是最普通的和业务相关的代码，甚至其接口实现类本身都不知道将被某一个RPC远程客户端调用。</p>
<h4 id="Stub-Proxy："><a href="#Stub-Proxy：" class="headerlink" title="Stub/Proxy："></a>Stub/Proxy：</h4><p>RPC代理存在于客户端，因为要实现客户端对RPC框架“透明”调用，那么客户端不可能自行去管理消息格式、不可能自己去管理网络传输协议，也不可能自己去判断调用过程是否有异常。这一切工作在客户端都是交给RPC框架中的“代理”层来处理的。</p>
<h4 id="Message-Protocol："><a href="#Message-Protocol：" class="headerlink" title="Message Protocol："></a>Message Protocol：</h4><p>在上文我们已经说到，一次完整的client-server的交互肯定是携带某种两端都能识别的，共同约定的消息格式。RPC的消息管理层专门对网络传输所承载的消息信息进行编码和解码操作。目前流行的技术趋势是不同的RPC实现，为了加强自身框架的效率都有一套（或者几套）私有的消息格式。</p>
<h4 id="Transfer-Network-Protocol："><a href="#Transfer-Network-Protocol：" class="headerlink" title="Transfer/Network Protocol："></a>Transfer/Network Protocol：</h4><p>传输协议层负责管理RPC框架所使用的网络协议、网络IO模型。例如Hessian的传输协议基于HTTP（应用层协议）；而Thrift的传输协议基于TCP（传输层协议）。传输层还需要统一RPC客户端和RPC服务端所使用的IO模型；</p>
<h4 id="Selector-Processor："><a href="#Selector-Processor：" class="headerlink" title="Selector/Processor："></a>Selector/Processor：</h4><p>存在于RPC服务端，用于服务器端某一个RPC接口的实现的特性（它并不知道自己是一个将要被RPC提供给第三方系统调用的服务）。所以在RPC框架中应该有一种“负责执行RPC接口实现”的角色。包括：管理RPC接口的注册、判断客户端的请求权限、控制接口实现类的执行在内的各种工作。</p>
<h4 id="IDL："><a href="#IDL：" class="headerlink" title="IDL："></a>IDL：</h4><p>实际上IDL（接口定义语言）并不是RPC实现中所必须的。但是需要跨语言的RPC框架一定会有IDL部分的存在。这是因为要找到一个各种语言能够理解的消息结构、接口定义的描述形式。如果您的RPC实现没有考虑跨语言性，那么IDL部分就不需要包括，例如JAVA RMI因为就是为了在JAVA语言间进行使用，所以JAVA RMI就没有相应的IDL。</p>
<h2 id="Task1：运行项目"><a href="#Task1：运行项目" class="headerlink" title="Task1：运行项目"></a>Task1：运行项目</h2><p>结合代码分析rpc流程和其中涉及的关键组件。</p>
<h4 id="新知识-annotation"><a href="#新知识-annotation" class="headerlink" title="新知识 annotation"></a>新知识 annotation</h4><p>在anno这个文件夹下存放的是Java注解</p>
<p>Annotation其实是代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取，并执行相应的处理。通过使用Annotation，程序开发人员可以在不改变原有逻辑的情况下，在源文件嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。</p>
<p>Annotation提供了一条为程序元素设置元数据的方法，从某些方面来看，Annotation就像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明，这些信息被存储在Annotation的“name=value”对中。</p>
<ul>
<li>使用@Retention</li>
</ul>
<p>　　@Retention只能用于修饰一个Annotation定义，用于指定<strong>该Annotation可以保留多长时间</strong>，如果未设置<code>@Retention</code>Annotation的有效范围为枚举常量Class表示的范围@Retention包含一个RetentionPolicy类型的value成员变量，所以使用@Retention时必须为该value成员变量指定值。</p>
<p>value成员变量的值只能是如下三个：</p>
<ol>
<li>RetentionPolicy.CLASS: 编译器将把注释记录在class文件中。当运行Java程序时，JVM不在保留注释，这是默认值。</li>
<li>RetentionPolicy.RUNTIME: 编译器将把注释记录在class文件中。当运行Java程序时，JVM也会保留注释，程序可以通过反射获取该注释。</li>
<li>RetentionPolicy.SOURCE: 注解仅存在于源码中，在class字节码文件中不包含。</li>
</ol>
<ul>
<li>使用@Target </li>
</ul>
<p>　　@Target也是用于修饰一个Annotation定义，它用于指定被修饰Annotation能<strong>用于修饰哪些程序元素</strong>。如果未设置<code>@target</code>,说明annotation适用于所有程序元素。@Target Annotation也包含一个名为value的成员变量，该成员变量只能是如下几个：</p>
<ol>
<li>ElementType.ANNOTATION_TYPE: 指定该策略的Annotation只能修饰Annotation。</li>
<li>ElementType.CONSTRUCTOR: 指定该策略的Annotation能修饰构造器。</li>
<li>ElementType.FIELD: 指定该策略的Annotation只能修饰成员变量。</li>
<li>ElementType.LOCAL_VARIABLE: 指定该策略的Annotation只能修饰局部变量。</li>
<li>ElementType.METHOD: 指定该策略的Annotation只能修饰方法。</li>
<li>ElementType.PACKAGE: 指定该策略的Annotation只能修饰包定义。</li>
<li>ElementType.PARAMETER: 指定该策略的Annotation可以修饰参数。</li>
<li>ElementType.TYPE: 指定该策略的Annotation可以修饰类、接口（包括注释类型）或枚举定义。</li>
</ol>
<p>在这里，我们使用了 @Retention 中的 <code>RetentionPolicy.RUNTIME</code> 和 @Target 中的 <code>ElementType.TYPE</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> qjm.rpc.anno;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * rpc服务类注解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> QJM</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)<span class="comment">//适用于类、接口、枚举</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="comment">//运行时加载到JVM中</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcService &#123;</span><br><span class="line">   <span class="comment">//实现接口</span></span><br><span class="line">   Class&lt;?&gt; value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在定义 Annotation 类型时，需要用关键字 <code>@interface</code> ,这个关键字的隐含意思是继承了 <code>java.lang.annotation.Annotation</code>接口。上面这个Annotation类型只包含一个泛型类型的成员<code>Class&lt;?&gt; value()</code> (如果在所定义的Annotation类型中只包含一个成员，通常将成员名称命名为value)</p>
<h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><p>流程如下所示：</p>
<p><img src="/2021/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek10/2.png" style="zoom:67%;"></p>
<p>根据上面的流程示意图，我们依次拆分这个项目：因为 <code>ServerTest</code> 代码很简单，就是启动一个<code>RpcServer</code> 实例，因此我们从ClientTest出发，用<strong>递归</strong>思路来剖析一下</p>
<p><img src="/2021/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek10/3.png" style="zoom:67%;"></p>
<p>ServerTest和ClientTest两个文件模拟的是本地的客户端，在不知道调用细节的情况下，调用存在于远程计算机上的某个对象也就是PersonService中的两个方法，就像调用本地应用程序中的对象一样。</p>
<p>首先，rpc-demo 项目是一个maven项目。其主体架构如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>根目录</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>pom.xml</td>
<td>Maven的pom文件</td>
</tr>
<tr>
<td>src/</td>
<td></td>
</tr>
<tr>
<td>main/</td>
<td>项目主体目录根</td>
</tr>
<tr>
<td>java</td>
<td>源代码目录</td>
</tr>
<tr>
<td>test/</td>
<td>项目测试目录根</td>
</tr>
<tr>
<td>java</td>
<td>测试代码目录</td>
</tr>
<tr>
<td>target/</td>
<td>输出目录根</td>
</tr>
</tbody>
</table>
</div>
<h3 id="从ClientTest出发"><a href="#从ClientTest出发" class="headerlink" title="从ClientTest出发"></a>从ClientTest出发</h3><p>首先我们来看 <code>test/java/qjm.rpc.test/ClientTest.java</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTest</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      RpcClientProxy proxy = <span class="keyword">new</span> RpcClientProxy(<span class="string">"127.0.0.1"</span>,<span class="number">9998</span>);</span><br><span class="line">      PersonService service = proxy.getProxy(PersonService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      </span><br><span class="line">      System.out.println(service.getInfo());</span><br><span class="line">      </span><br><span class="line">      Person person = <span class="keyword">new</span> Person();</span><br><span class="line">      person.setAge(<span class="number">23</span>);</span><br><span class="line">      person.setName(<span class="string">"Qjm"</span>);</span><br><span class="line">      person.setSex(<span class="string">"男"</span>);</span><br><span class="line">      System.out.println(service.printInfo(person));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个测试文件中，首先调用了<code>RpcClientProxy</code> 的构造方法，创建一个<code>RpcClientProxy</code>对象。然后当<code>proxy</code>对象调用<code>getProxy</code>方法的时候, 会被 <code>invoke</code> 方法拦截，并执行 <code>invoke</code> 方法。</p>
<h4 id="PrcClientProxy"><a href="#PrcClientProxy" class="headerlink" title="PrcClientProxy"></a>PrcClientProxy</h4><p>首先， <code>getProxy</code> 会接收一个泛型，然后返回一个代理对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt;<span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span></span>&#123;</span><br><span class="line">   <span class="comment">// clazz不是接口不能使用JDK动态代理</span></span><br><span class="line">   <span class="keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;clazz&#125;, RpcClientProxy.<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，传入的是 <code>PersonService.class</code>也就是获得这个接口所对应的Class实例，这个实例中提供了两个方法：<code>Person getInfo(),printInfo(Person person)</code> </p>
<p>接下来，当 <code>ClientTest</code> 调用 <code>service.getInfo()</code> 时，代理对象的方法被调用时会被invoke方法拦截，执行<code>invoke</code>方法</p>
<ul>
<li>封装参数，用于发送到服务器，定位服务、执行服务</li>
<li>链接服务器调用服务</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Method method, Object[] params)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">   <span class="comment">//封装参数</span></span><br><span class="line">   RpcRequest request = <span class="keyword">new</span> RpcRequest();</span><br><span class="line">   request.setClassName(method.getDeclaringClass().getName());</span><br><span class="line">   request.setMethodName(method.getName());</span><br><span class="line">   request.setParamTypes(method.getParameterTypes());</span><br><span class="line">   request.setParams(params);</span><br><span class="line">   <span class="comment">//链接服务器调用服务</span></span><br><span class="line">   RpcClient client = <span class="keyword">new</span> RpcClient();</span><br><span class="line">   <span class="keyword">return</span> client.start(request, host, port);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在封装参数阶段，首先，会创建一个<code>RpcRequest</code> 对象来标准化参数。关于<code>RpcRequest</code>我们之后再介绍。然后，我们给<code>request</code>设置完整的类名、方法名和参数类型，为调用服务做准备。这里，</p>
<ul>
<li>类名：<code>qjm.rpc.test.imp.PersonService</code></li>
<li>方法名：<code>getInfo</code></li>
<li>参数类型: <code>[]</code>，因为 <code>getinfo()</code> 是没有参数的</li>
<li>参数：null</li>
</ul>
<p>封装完毕之后，会新建一个<code>RpcClient</code> 对象，传入刚刚封装好的 <code>Rpcrequest</code>对象，本地ip和端口作为参数，并启动它。</p>
<h4 id="RpcClient"><a href="#RpcClient" class="headerlink" title="RpcClient"></a>RpcClient</h4><p>RpcClient对象的作用就是会把传入的请求对象通过socket发送给RpcServer,收到server传回来的数据之后，经过处理并返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcClient</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">start</span><span class="params">(RpcRequest request, String host, <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">     <span class="comment">// 首先，用传入的ip和端口 创建一个 socket对象</span></span><br><span class="line">      Socket server = <span class="keyword">new</span> Socket(host, port);</span><br><span class="line">      </span><br><span class="line">      InputStream in = <span class="keyword">null</span>;</span><br><span class="line">      ObjectInputStream oin = <span class="keyword">null</span>;</span><br><span class="line">      OutputStream out = <span class="keyword">null</span>;</span><br><span class="line">      ObjectOutputStream oout = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 1. 发送请求数据</span></span><br><span class="line">         out = server.getOutputStream(); </span><br><span class="line">         oout = <span class="keyword">new</span> ObjectOutputStream(out);</span><br><span class="line">         oout.writeObject(request);<span class="comment">//把请求体通过socket推出</span></span><br><span class="line">         oout.flush();</span><br><span class="line">         </span><br><span class="line">         <span class="comment">// 2. 获取返回数据，强转参数类型</span></span><br><span class="line">         in = server.getInputStream();</span><br><span class="line">         oin = <span class="keyword">new</span> ObjectInputStream(in);</span><br><span class="line">         Object res = oin.readObject(); <span class="comment">//从返回流中读取返回的对象</span></span><br><span class="line">         RpcResponse response = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">if</span>(!(res <span class="keyword">instanceof</span> RpcResponse))&#123; <span class="comment">//如果返回的对象不是RpcResponse实例，报错</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"返回参数不正确"</span>);</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123; <span class="comment">// 如果是，那么进行一个显式类型转换</span></span><br><span class="line">            response = (RpcResponse) res;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">// 3. 返回结果</span></span><br><span class="line">         <span class="keyword">if</span>(response.getError() != <span class="keyword">null</span>)&#123; <span class="comment">//服务器产生异常</span></span><br><span class="line">            <span class="keyword">throw</span> response.getError();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> response.getResult();</span><br><span class="line">      &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;  <span class="comment">//关闭流</span></span><br><span class="line">            <span class="keyword">if</span>(in != <span class="keyword">null</span>) in.close();</span><br><span class="line">            <span class="keyword">if</span>(oin != <span class="keyword">null</span>) oin.close();</span><br><span class="line">            <span class="keyword">if</span>(out != <span class="keyword">null</span>) out.close();</span><br><span class="line">            <span class="keyword">if</span>(oout != <span class="keyword">null</span>) oout.close();</span><br><span class="line">            <span class="keyword">if</span>(server != <span class="keyword">null</span>) server.close();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="RpcRequest"><a href="#RpcRequest" class="headerlink" title="RpcRequest"></a>RpcRequest</h5><p>在<code>invoke</code>方法和<code>RpcClient</code>中已经提到了多次<code>RpcRequest</code>，现在我们来分析一下这个类</p>
<p>这个类实现了一个<code>Serializable</code> 接口，也就是将一个类序列化。一个类的对象要想序列化成功，必须满足两个条件：</p>
<ul>
<li>该类必须实现 java.io.Serializable 接口。</li>
<li>该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。</li>
</ul>
<p>Java的序列化机制中，一个对象可以表示为一个字节序列，该字节序列包括该对象的数据、有关对象类型的信息和存储在对象中的数据的类型。将序列化对象写入文件之后，可以从文件中读取出来，并对其进行反序列化。</p>
<p>因为<code>RpcRequest,RpcResponse</code>的实例化对象是要通过socket在client和server之间传递的，因此我们这里需要将其序列化。</p>
<p><code>RpcRequest</code> 的实例化对象是 <code>RpcClient</code> 发出的 ，是<code>RpcServer</code> 接收的</p>
<p>我们来看看<code>RpcRequest</code> 方法中的变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcRequest</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  serialVersionUID作用：</span></span><br><span class="line"><span class="comment">	序列化时为了保持版本的兼容性，即在版本升级时反序列化仍保持对象的唯一性。	</span></span><br><span class="line"><span class="comment">	默认的1L，比如：private static final long serialVersionUID = 1L;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">  <span class="comment">// 存放当前请求方法所在的类的名字</span></span><br><span class="line">	<span class="keyword">private</span> String className;</span><br><span class="line">  <span class="comment">// 存放当前请求方法的名字</span></span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">  <span class="comment">// 存放当前请求方法的参数的数据类型,因为参数的类型各不相同，这里需要使用泛型</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] paramTypes;</span><br><span class="line">  <span class="comment">// 存放请求方法的参数</span></span><br><span class="line">    <span class="keyword">private</span> Object[] params;</span><br><span class="line">	<span class="comment">// 剩下的方法都是上面变量的 getter和setter，这里略去不讲</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> className;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClassName</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.className = className;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getMethodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> methodName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMethodName</span><span class="params">(String methodName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.methodName = methodName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> Class&lt;?&gt;[] getParamTypes() &#123;</span><br><span class="line">		<span class="keyword">return</span> paramTypes;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParamTypes</span><span class="params">(Class&lt;?&gt;[] paramTypes)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.paramTypes = paramTypes;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> Object[] getParams() &#123;</span><br><span class="line">		<span class="keyword">return</span> params;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParams</span><span class="params">(Object[] params)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.params = params;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="RpcResponse"><a href="#RpcResponse" class="headerlink" title="RpcResponse"></a>RpcResponse</h5><p><code>RpcResponse</code>类，是<code>RpcServer</code> 处理并发出的，是<code>RpcClient</code>接收的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcResponse</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="comment">//serialVersionUID 和 RpcRequest 一样</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">  <span class="comment">// 当参数错误时，用来存放错误</span></span><br><span class="line">   <span class="keyword">private</span> Throwable error;</span><br><span class="line">  <span class="comment">// 存放RpcServer处理 RpcRequest后的结果</span></span><br><span class="line">   <span class="keyword">private</span> Object result;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 下面是参数的getter和setter</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Throwable <span class="title">getError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> error;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setError</span><span class="params">(Throwable error)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.error = error;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResult</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.result = result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RpcServer"><a href="#RpcServer" class="headerlink" title="RpcServer"></a>RpcServer</h4><p>现在我们来讲一下 <code>RpcServer</code>类，这个类比较复杂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcServer</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 启动rpc服务</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> port 监听端口</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> clazz 服务类所在包名，多个用英文逗号隔开</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="comment">// 这里有两个参数，第一个是端口，第二个是</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> port, String clazz)</span> </span>&#123;</span><br><span class="line">      ServerSocket server = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 1. 创建socket连接</span></span><br><span class="line">         server = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">         <span class="comment">// 2. 获取所有rpc服务类，即发布服务。services 是 键值对类型的</span></span><br><span class="line">         Map&lt;String, Object&gt; services = getService(clazz);</span><br><span class="line">         <span class="comment">// 3. 创建线程池</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        ThreadPoolExecutor 的参数：</span></span><br><span class="line"><span class="comment">        int corePoolSize, 线程池中的线程数量</span></span><br><span class="line"><span class="comment">        int maximumPoolSize, 线程池中最大允许存放的线程数量</span></span><br><span class="line"><span class="comment">        long keepAliveTime, 当线程数大于核心数时，这是多余的空闲线程在终止之前等待新任务的最大时间。</span></span><br><span class="line"><span class="comment">        TimeUnit unit,保持活动时间参数的时间单位，这里设为 秒</span></span><br><span class="line"><span class="comment">        BlockingQueue&lt;Runnable&gt; workQueue,在执行任务之前用于保存任务的队列。这个队列将只保存execute方法提交的Runnable任务。 </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">         Executor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">10</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">         <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 4. 获取客户端连接</span></span><br><span class="line">            Socket client = server.accept();</span><br><span class="line">            <span class="comment">// 5. 查找并执行服务</span></span><br><span class="line">            RpcService service = <span class="keyword">new</span> RpcService(client, services);</span><br><span class="line">           <span class="comment">//利用线程池，来执这个RpcService,这里 execute方法的对象一定要是Runnable的</span></span><br><span class="line">            executor.execute(service);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">      &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">         <span class="comment">//关闭监听</span></span><br><span class="line">         <span class="keyword">if</span>(server != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               server.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 实例化所有rpc服务类，并返回键值对</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> clazz 服务类所在包名，多个用英文逗号隔开</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title">getService</span><span class="params">(String clazz)</span></span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         Map&lt;String, Object&gt; services = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        <span class="comment">// 这里是将传入的字符串数组用 , 依次分割其中的元素。但是我们传入的只有一个元素：qjm.rpc.test</span></span><br><span class="line">       	<span class="comment">// 因此：clazzes: [qjm.rpc.test]</span></span><br><span class="line">         String[] clazzes = clazz.split(<span class="string">","</span>);</span><br><span class="line">         List&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> ArrayList&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">         <span class="keyword">for</span>(String cl:clazzes)&#123;</span><br><span class="line">            List&lt;Class&lt;?&gt;&gt; classList = getClasses(cl);</span><br><span class="line">            classes.addAll(classList);</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="comment">//对每一个文件夹进行查找，并找出有 @RpcService 注解的类，放入classes列表中</span></span><br><span class="line">        <span class="comment">//classes: [class qjm.rpc.test.imp.PersonServiceImpl]</span></span><br><span class="line">         <span class="comment">//对classes中的类进行循环实例化</span></span><br><span class="line">         <span class="keyword">for</span>(Class&lt;?&gt; cla:classes)&#123;</span><br><span class="line">            Object obj = cla.newInstance();</span><br><span class="line">           <span class="comment">// key 值 是该类的名字，value值是该类的一个实例化对象</span></span><br><span class="line">            services.put(cla.getAnnotation(qjm.rpc.anno.RpcService<span class="class">.<span class="keyword">class</span>).<span class="title">value</span>().<span class="title">getName</span>(), <span class="title">obj</span>)</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="comment">//此时的services: &#123;qjm.rpc.test.imp.PersonService=qjm.rpc.test.imp.PersonServiceImpl@d716361&#125;</span></span><br><span class="line">         <span class="keyword">return</span> services;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取包下所有有<span class="doctag">@RpcSercive</span>注解的类</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> pckgname</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Class&lt;?&gt;&gt; getClasses(String pckgname) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">      List&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> ArrayList&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">      File directory = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         ClassLoader cld = Thread.currentThread().getContextClassLoader();</span><br><span class="line">         <span class="keyword">if</span> (cld == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">"Can't get class loader."</span>);</span><br><span class="line">         String path = pckgname.replace(<span class="string">'.'</span>, <span class="string">'/'</span>);</span><br><span class="line">         URL resource = cld.getResource(path);</span><br><span class="line">         <span class="keyword">if</span> (resource == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">"No resource for "</span> + path);</span><br><span class="line">         directory = <span class="keyword">new</span> File(resource.getFile());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (NullPointerException x) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(pckgname + <span class="string">" ("</span> + directory + <span class="string">") does not appear to be a valid package a"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (directory.exists()) &#123;</span><br><span class="line">         <span class="comment">//获取所有文件</span></span><br><span class="line">         String[] files = directory.list();</span><br><span class="line">         File[] fileList = directory.listFiles();</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;fileList != <span class="keyword">null</span> &amp;&amp; i &lt; fileList.length; i++) &#123;</span><br><span class="line">            File file = fileList[i];</span><br><span class="line">            <span class="comment">//判断是否是Class文件</span></span><br><span class="line">            <span class="keyword">if</span> (file.isFile() &amp;&amp; file.getName().endsWith(<span class="string">".class"</span>)) &#123;</span><br><span class="line">               Class&lt;?&gt; clazz = Class.forName(pckgname + <span class="string">'.'</span> + files[i].substring(<span class="number">0</span>, files[i].length() - <span class="number">6</span>));</span><br><span class="line">               <span class="keyword">if</span>(clazz.getAnnotation(qjm.rpc.anno.RpcService<span class="class">.<span class="keyword">class</span>) !</span>= <span class="keyword">null</span>)&#123;</span><br><span class="line">                  classes.add(clazz);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(file.isDirectory())&#123; <span class="comment">//如果是目录，递归查找</span></span><br><span class="line">               List&lt;Class&lt;?&gt;&gt; result = getClasses(pckgname+<span class="string">"."</span>+file.getName());</span><br><span class="line">               <span class="keyword">if</span>(result != <span class="keyword">null</span> &amp;&amp; result.size() != <span class="number">0</span>)&#123;</span><br><span class="line">                  classes.addAll(result);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(pckgname + <span class="string">" does not appear to be a valid package b"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> classes;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="imp文件夹"><a href="#imp文件夹" class="headerlink" title="imp文件夹"></a>imp文件夹</h5><p>我们在RpcServer中实例化了这个文件夹中的<code>PersonServiceImpl</code>类，现在来看看这个类长啥样：</p>
<p>这个类继承自 PersonService 接口，接口中定义了 <code>getInfo()</code>方法和<code>printInfo()</code>方法</p>
<p>此外，之前说的 Annotation在这里被派上了用场，因为这个类被标记了，所以能被<code>RpcServer</code>快速地找出并标记、实例化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> qjm.rpc.test.imp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> qjm.rpc.anno.RpcService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RpcService</span>(PersonService<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">PersonServiceImpl</span> <span class="keyword">implements</span> <span class="title">PersonService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Person <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Person person = <span class="keyword">new</span> Person();</span><br><span class="line">      person.setAge(<span class="number">22</span>);</span><br><span class="line">      person.setName(<span class="string">"qjm"</span>);</span><br><span class="line">      person.setSex(<span class="string">"男"</span>);</span><br><span class="line">      <span class="keyword">return</span> person;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">printInfo</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(person != <span class="keyword">null</span>)&#123;</span><br><span class="line">         System.out.println(person);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用<code>getInfo()</code>时，会返回一个person对象，当调用<code>printInfo()</code>时，会返回一个布尔值</p>
<p>Person类的定义如下：</p>
<p>定义了名字、年龄和性别以及它们的getter和setter，此外，还重写了<code>toString</code>函数,也就是当我们打印一个Person对象时，会按照我们定义的格式输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> String sex;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sex;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.sex = sex;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", sex="</span> + sex + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RpcService"><a href="#RpcService" class="headerlink" title="RpcService"></a>RpcService</h4><p><code>RpcServer</code>在与<code>RpcClient</code> 建立连接后，会新建一个 <code>RpcService</code> 对象，传入参数为：<code>client</code> 连接以及键值对类型的<code>services</code></p>
<p>在这个类中，首先会读取流中的 <code>RpcRequest</code>, 然后在services中查找并执行<code>RpcRequest</code>中包含着的本地客户端要请求的方法，最后返回执行后的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcService</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Socket client;</span><br><span class="line">	<span class="keyword">private</span> Map&lt;String,Object&gt; services;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> client 客户端</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> services 所有服务</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">  <span class="comment">// 这是一个构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RpcService</span><span class="params">(Socket client, Map&lt;String, Object&gt; services)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.client = client;</span><br><span class="line">		<span class="keyword">this</span>.services = services;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		InputStream in = <span class="keyword">null</span>;</span><br><span class="line">		ObjectInputStream oin = <span class="keyword">null</span>;</span><br><span class="line">		OutputStream out = <span class="keyword">null</span>;</span><br><span class="line">		ObjectOutputStream oout = <span class="keyword">null</span>;</span><br><span class="line">		RpcResponse response = <span class="keyword">new</span> RpcResponse();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 1. 获取流</span></span><br><span class="line">			in = client.getInputStream();</span><br><span class="line">			oin = <span class="keyword">new</span> ObjectInputStream(in);</span><br><span class="line">			out = client.getOutputStream();</span><br><span class="line">			oout = <span class="keyword">new</span> ObjectOutputStream(out);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 2. 获取RpcRequest中的请求数据，强转参数类型</span></span><br><span class="line">			Object param = oin.readObject();</span><br><span class="line">			RpcRequest  request = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">if</span>(!(param <span class="keyword">instanceof</span> RpcRequest))&#123;</span><br><span class="line">				response.setError(<span class="keyword">new</span> Exception(<span class="string">"参数错误"</span>));</span><br><span class="line">				oout.writeObject(response);</span><br><span class="line">				oout.flush();</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				request = (RpcRequest) param;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// 3. 查找并执行服务方法</span></span><br><span class="line">      <span class="comment">// 首先用request.getClassName()获取类名，然后再键值对中用类名查找得到实例化的对象</span></span><br><span class="line">			Object service = services.get(request.getClassName());</span><br><span class="line">      <span class="comment">// 已经获取了实例化的对象，接下来要根据方法名称、方法的参数的数据类型来获得具体的方法</span></span><br><span class="line">			Class&lt;?&gt; clazz= service.getClass();</span><br><span class="line">			Method method = clazz.getMethod(request.getMethodName(), request.getParamTypes());</span><br><span class="line">      <span class="comment">// 最后，调用该方法，并返回结果</span></span><br><span class="line">			Object result = method.invoke(service, request.getParams());</span><br><span class="line">			<span class="comment">// 4. 将结果存放到 RpcResponse 实例化对象中，并通过socket 传回。</span></span><br><span class="line">			response.setResult(result);</span><br><span class="line">			oout.writeObject(response);</span><br><span class="line">			oout.flush();</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;	<span class="comment">//异常处理</span></span><br><span class="line">				<span class="keyword">if</span>(oout != <span class="keyword">null</span>)&#123;</span><br><span class="line">					response.setError(e);</span><br><span class="line">					oout.writeObject(response);</span><br><span class="line">					oout.flush();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">				e1.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;	<span class="comment">// 关闭流</span></span><br><span class="line">				<span class="keyword">if</span>(in != <span class="keyword">null</span>) in.close();</span><br><span class="line">				<span class="keyword">if</span>(oin != <span class="keyword">null</span>) oin.close();</span><br><span class="line">				<span class="keyword">if</span>(out != <span class="keyword">null</span>) out.close();</span><br><span class="line">				<span class="keyword">if</span>(oout != <span class="keyword">null</span>) oout.close();</span><br><span class="line">				<span class="keyword">if</span>(client != <span class="keyword">null</span>) client.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是回到<code>ClientTest</code>的这行代码： <code>System.out.println(service.getInfo());</code> </p>
<p>通过这样绕一大圈，最后是在 <code>RpcService</code>中通过<code>method.invoke(service, request.getParams());</code> 实现的。返回一个<code>Person</code>对象，这个对象放在<code>RpcResponse</code>中传回<code>RpcClient</code>, <code>RpcClient</code>收到之后再返回客户端 <code>response.getResult();</code> </p>
<p>我们再将其输出，就得到了 <code>Person [name=qjm, age=22, sex=男]</code> 这个结果。</p>
<p>同理，对于<code>System.out.println(service.printInfo(person));</code> 这行代码，传入了一个我们定义的Person对象。然后，<code>RpcService</code>会调用放在<code>PersonServicelmpl</code> 中的<code>printInfo(person)</code>方法。在这个方法中，如果 <code>person</code>对象不为空，那么就会在客户的serviceTest端输出person的信息，然后返回true。这个true通过socket 传给<code>RpcClient</code>并经其返回给客户的clientTest端，打印为True。</p>
<p>这样，一个基于rpc协议的项目就被我们分析完了。</p>
<h3 id="gRPC框架使用"><a href="#gRPC框架使用" class="headerlink" title="gRPC框架使用"></a>gRPC框架使用</h3><p><strong>Task2</strong>：按照下面步骤完成gRPC使用，并将其中关键步骤和实验结果写到实验报告中。</p>
<p>gRPC：在 gRPC 里客户端应用可以像调用本地对象一样直接调用另一台不同的机器上服务端应用的方法，使得您能够更容易地创建分布式应用和服务。与许多 RPC 系统类似，gRPC 也是基于以下理念：定义一个服务，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口，并运行一个 gRPC 服务器来处理客户端调用。在客户端拥有一个存根能够像服务端一样的方法。</p>
<h4 id="新建一个普通的Maven项目"><a href="#新建一个普通的Maven项目" class="headerlink" title="新建一个普通的Maven项目"></a>新建一个普通的Maven项目</h4><h4 id="配置pom文件，导入grpc的依赖和插件"><a href="#配置pom文件，导入grpc的依赖和插件" class="headerlink" title="配置pom文件，导入grpc的依赖和插件"></a>配置pom文件，导入grpc的依赖和插件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.grpcprojects<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpcExercise3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">grpc-version</span>&gt;</span>1.20.0<span class="tag">&lt;/<span class="name">grpc-version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;grpc-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-netty-shaded<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;grpc-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-protobuf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;grpc-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.grpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>grpc-stub<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;grpc-version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">extensions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">extension</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>kr.motd.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>os-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>protobuf-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>          <span class="tag">&lt;<span class="name">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:3.7.1:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="name">protocArtifact</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">pluginId</span>&gt;</span>grpc-java<span class="tag">&lt;/<span class="name">pluginId</span>&gt;</span>                      <span class="tag">&lt;<span class="name">pluginArtifact</span>&gt;</span>io.grpc:protoc-gen-grpc-java:1.9.1:exe:$&#123;os.detected.classifier&#125;<span class="tag">&lt;/<span class="name">pluginArtifact</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">protoSourceRoot</span>&gt;</span>src/main/proto<span class="tag">&lt;/<span class="name">protoSourceRoot</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile-custom<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="编写proto文件"><a href="#编写proto文件" class="headerlink" title="编写proto文件"></a>编写proto文件</h4><p>在项目main目录下新建一个proto文件夹，再在此文件夹下创建一个helloworld.proto文件</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">syntax</span> = <span class="string">"proto3";</span></span><br><span class="line"><span class="attr">option</span> <span class="string">java_multiple_files = true;</span></span><br><span class="line"><span class="attr">option</span> <span class="string">java_package = "io.grpc.examples.helloworld";</span></span><br><span class="line"><span class="attr">option</span> <span class="string">java_outer_classname = "HelloWorldProto";</span></span><br><span class="line"><span class="attr">option</span> <span class="string">objc_class_prefix = "HLW";</span></span><br><span class="line"><span class="attr">package</span> <span class="string">helloworld;</span></span><br><span class="line"><span class="meta">//</span> <span class="string">The greeting service definition.</span></span><br><span class="line"><span class="attr">service</span> <span class="string">Greeter &#123;</span></span><br><span class="line">    <span class="meta">//</span> <span class="string">Sends a greeting</span></span><br><span class="line">    <span class="attr">rpc</span> <span class="string">SayHello (HelloRequest) returns (HelloReply) &#123;&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="meta">//</span> <span class="string">The request message containing the user's name.</span></span><br><span class="line"><span class="attr">message</span> <span class="string">HelloRequest &#123;</span></span><br><span class="line">    <span class="attr">string</span> <span class="string">name = 1;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="meta">//</span> <span class="string">The response message containing the greetings</span></span><br><span class="line"><span class="attr">message</span> <span class="string">HelloReply &#123;</span></span><br><span class="line">    <span class="attr">string</span> <span class="string">message = 1;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="编译proto文件"><a href="#编译proto文件" class="headerlink" title="编译proto文件"></a>编译proto文件</h4><ul>
<li>右击Maven.Projects\protobuf\protobuf:compile ，选择run，生成用于序列化的java文件。</li>
<li>再右击Maven.Projects\protobuf\protobuf:compile-custom，选择run，生成用于rpc的java代码。</li>
</ul>
<h4 id="添加客户端和服务端代码"><a href="#添加客户端和服务端代码" class="headerlink" title="添加客户端和服务端代码"></a>添加客户端和服务端代码</h4><p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> helloworld;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> io.grpc.ManagedChannel;</span><br><span class="line"><span class="keyword">import</span> io.grpc.ManagedChannelBuilder;</span><br><span class="line"><span class="keyword">import</span> io.grpc.StatusRuntimeException;</span><br><span class="line"><span class="keyword">import</span> io.grpc.examples.helloworld.GreeterGrpc;</span><br><span class="line"><span class="keyword">import</span> io.grpc.examples.helloworld.HelloReply;</span><br><span class="line"><span class="keyword">import</span> io.grpc.examples.helloworld.HelloRequest;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A simple client that requests a greeting from the &#123;<span class="doctag">@link</span> HelloWorldServer&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldClient</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(HelloWorldClient<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ManagedChannel channel;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> GreeterGrpc.GreeterBlockingStub blockingStub;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/** Construct client connecting to HelloWorld server at &#123;<span class="doctag">@code</span> host:port&#125;. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HelloWorldClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(ManagedChannelBuilder.forAddress(host, port)</span><br><span class="line">        <span class="comment">// Channels are secure by default (via SSL/TLS). For the example we disable TLS to avoid</span></span><br><span class="line">        <span class="comment">// needing certificates.</span></span><br><span class="line">        .usePlaintext()</span><br><span class="line">        .build());</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/** Construct client for accessing HelloWorld server using the existing channel. */</span></span><br><span class="line">  HelloWorldClient(ManagedChannel channel) &#123;</span><br><span class="line">    <span class="keyword">this</span>.channel = channel;</span><br><span class="line">    blockingStub = GreeterGrpc.newBlockingStub(channel);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    channel.shutdown().awaitTermination(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/** Say hello to server. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"Will try to greet "</span> + name + <span class="string">" ..."</span>);</span><br><span class="line">    HelloRequest request = HelloRequest.newBuilder().setName(name).build();</span><br><span class="line">    HelloReply response;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      response = blockingStub.sayHello(request);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (StatusRuntimeException e) &#123;</span><br><span class="line">      logger.log(Level.WARNING, <span class="string">"RPC failed: &#123;0&#125;"</span>, e.getStatus());</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    logger.info(<span class="string">"Greeting: "</span> + response.getMessage());</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Greet server. If provided, the first element of &#123;<span class="doctag">@code</span> args&#125; is the name to use in the</span></span><br><span class="line"><span class="comment">   * greeting.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HelloWorldClient client = <span class="keyword">new</span> HelloWorldClient(<span class="string">"localhost"</span>, <span class="number">50051</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">/* Access a service running on the local machine on port 50051 */</span></span><br><span class="line">      String user = <span class="string">"world"</span>;</span><br><span class="line">      <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        user = args[<span class="number">0</span>]; <span class="comment">/* Use the arg as the name to greet if provided */</span></span><br><span class="line">     &#125;</span><br><span class="line">      client.greet(user);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      client.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> helloworld;</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">import</span> io.grpc.Server;</span><br><span class="line">  <span class="keyword">import</span> io.grpc.ServerBuilder;</span><br><span class="line">  <span class="keyword">import</span> io.grpc.examples.helloworld.GreeterGrpc;</span><br><span class="line">  <span class="keyword">import</span> io.grpc.examples.helloworld.HelloReply;</span><br><span class="line">  <span class="keyword">import</span> io.grpc.examples.helloworld.HelloRequest;</span><br><span class="line">  <span class="keyword">import</span> io.grpc.stub.StreamObserver;</span><br><span class="line">  <span class="keyword">import</span> java.io.IOException;</span><br><span class="line">  <span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Server that manages startup/shutdown of a &#123;<span class="doctag">@code</span> Greeter&#125; server.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(HelloWorldServer<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> Server server;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">/* The port on which the server should run */</span></span><br><span class="line">      <span class="keyword">int</span> port = <span class="number">50051</span>;</span><br><span class="line">      server = ServerBuilder.forPort(port)</span><br><span class="line">          .addService(<span class="keyword">new</span> GreeterImpl())</span><br><span class="line">          .build()</span><br><span class="line">          .start();</span><br><span class="line">      logger.info(<span class="string">"Server started, listening on "</span> + port);</span><br><span class="line">      Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// Use stderr here since the logger may have been reset by its JVM shutdown hook.</span></span><br><span class="line">          System.err.println(<span class="string">"*** shutting down gRPC server since JVM is shutting down"</span>);</span><br><span class="line">          HelloWorldServer.<span class="keyword">this</span>.stop();</span><br><span class="line">          System.err.println(<span class="string">"*** server shut down"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</span><br><span class="line">       server.shutdown();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Await termination on the main thread since the grpc library uses daemon threads.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">blockUntilShutdown</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</span><br><span class="line">        server.awaitTermination();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Main launches the server from the command line.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> HelloWorldServer server = <span class="keyword">new</span> HelloWorldServer();</span><br><span class="line">      server.start();</span><br><span class="line">      server.blockUntilShutdown();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">GreeterImpl</span> <span class="keyword">extends</span> <span class="title">GreeterGrpc</span>.<span class="title">GreeterImplBase</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(HelloRequest req, StreamObserver&lt;HelloReply&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">        HelloReply reply = HelloReply.newBuilder().setMessage(<span class="string">"Hello "</span> + req.getName()).build();</span><br><span class="line">        responseObserver.onNext(reply);</span><br><span class="line">        responseObserver.onCompleted();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>一开始，会报错：</p>
<p><img src="/2021/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek10/4.png" style="zoom:67%;"></p>
<p>但事实上这是因为还没有把proto文件更新到项目中去，点击Maven上菜单栏中的文件夹图标即可修复。运行结果如下：</p>
<p><img src="/2021/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek10/6.png" style="zoom:67%;"></p>
<p><img src="/2021/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek10/7.png" style="zoom:67%;"></p>
<p>项目结构如下：</p>
<p><img src="/2021/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek10/8.png" style="zoom:67%;"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/" itemprop="url">操作系统-进程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-05-05T11:19:43+08:00">
                2021-05-05
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-08-24T11:40:06+08:00">
                2022-08-24
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="操作系统-进程"><a href="#操作系统-进程" class="headerlink" title="操作系统-进程"></a>操作系统-进程</h1><p>搬运学习博客：<a href="https://www.cnblogs.com/cxuanBlog/p/12402424.html" target="_blank" rel="noopener">https://www.cnblogs.com/cxuanBlog/p/12402424.html</a></p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/1.png" style="zoom:67%;"></p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>操作系统中最核心的概念就是 <code>进程</code>，进程是对正在运行中的程序的一个抽象。操作系统的其他所有内容都是围绕着进程展开的。进程是操作系统提供的最古老也是最重要的概念之一。即使可以使用的 CPU 只有一个，它们也支持<code>（伪）并发</code>操作。它们会将一个单独的 CPU 抽象为多个虚拟机的 CPU。可以说：没有进程的抽象，现代操作系统将不复存在。</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/2.png" style="zoom:67%;"></p>
<p>所有现代的计算机会在同一时刻做很多事情，过去使用计算机的人（单 CPU）可能完全无法理解现在这种变化，举个例子更能说明这一点：首先考虑一个 Web 服务器，请求都来自于 Web 网页。当一个请求到达时，服务器会检查当前页是否在缓存中，如果是在缓存中，就直接把缓存中的内容返回。如果缓存中没有的话，那么请求就会交给磁盘来处理。但是，从 CPU 的角度来看，磁盘请求需要更长的时间，因为磁盘请求会很慢。当硬盘请求完成时，更多其他请求才会进入。如果有多个磁盘的话，可以在第一个请求完成前就可以连续的对其他磁盘发出部分或全部请求。很显然，这是一种并发现象，需要有并发控制条件来控制并发现象。</p>
<p>现在考虑只有一个用户的 PC。当系统启动时，许多进程也在后台启动，用户通常不知道这些进程的启动，试想一下，当你自己的计算机启动的时候，你能知道哪些进程是需要启动的么？这些后台进程可能是一个需要输入电子邮件的电子邮件进程，或者是一个计算机病毒查杀进程来周期性的更新病毒库。某个用户进程可能会在所有用户上网的时候打印文件以及刻录 CD-ROM，这些活动都需要管理。于是一个支持多进程的多道程序系统就会显得很有必要了。</p>
<p>在许多多道程序系统中，CPU 会在<code>进程</code>间快速切换，使每个程序运行几十或者几百毫秒。然而，严格意义来说，在某一个瞬间，CPU 只能运行一个进程，然而我们如果把时间定位为 1 秒内的话，它可能运行多个进程。这样就会让我们产生<code>并行</code>的错觉。有时候人们说的 <code>伪并行(pseudoparallelism)</code> 就是这种情况，以此来区分多处理器系统(该系统由两个或多个 CPU 来共享同一个物理内存)</p>
<blockquote>
<p>再来详细解释一下伪并行：<code>伪并行</code>是指单核或多核处理器同时执行多个进程，从而使程序更快。 通过以非常有限的时间间隔在程序之间快速切换CPU，因此会产生并行感。 缺点是 CPU 时间可能分配给下一个进程，也可能不分配给下一个进程。</p>
</blockquote>
<p>因为 CPU 执行速度很快，进程间的换进换出也非常迅速，因此我们很难对多个并行进程进行跟踪，所以，在经过多年的努力后，操作系统的设计者开发了用于描述并行的一种概念模型（顺序进程），使得并行更加容易理解和分析，对该模型的探讨，也是本篇文章的主题。下面我们就来探讨一下进程模型</p>
<h3 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h3><p>在进程模型中，所有计算机上运行的软件，通常也包括操作系统，被组织为若干<code>顺序进程(sequential processes)</code>，简称为 <code>进程(process)</code> 。一个进程就是一个正在执行的程序的实例，进程也包括程序计数器、寄存器和变量的当前值。从概念上来说，每个进程都有各自的虚拟 CPU，但是实际情况是 CPU 会在各个进程之间进行来回切换。</p>
<p> <img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/5.png" alt="5" style="zoom:67%;"></p>
<p>如上图所示，这是一个具有 4 个程序的多道处理程序，在进程不断切换的过程中，程序计数器也在不同的变化。</p>
<p> <img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/4.png" style="zoom:67%;"></p>
<p>在上图中，这 4 道程序被抽象为 4 个拥有各自控制流程（即每个自己的程序计数器）的进程，并且每个程序都独立的运行。当然，实际上只有一个物理程序计数器，每个程序要运行时，其逻辑程序计数器会装载到物理程序计数器中。当程序运行结束后，其物理程序计数器就会是真正的程序计数器，然后再把它放回进程的逻辑计数器中。</p>
<p>从下图我们可以看到，在观察足够长的一段时间后，所有的进程都运行了，<strong>但在任何一个给定的瞬间仅有一个进程真正运行</strong>。</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/6.png" style="zoom:67%;"></p>
<p>因此，当我们说一个 CPU 只能真正一次运行一个进程的时候，即使有 2 个核（或 CPU），<strong>每一个核也只能一次运行一个线程</strong>。</p>
<p>由于 CPU 会在各个进程之间来回快速切换，所以每个进程在 CPU 中的运行时间是无法确定的。并且当同一个进程再次在 CPU 中运行时，其在 CPU 内部的运行时间往往也是不固定的。进程和程序之间的区别是非常微妙的，但是通过一个例子可以让你加以区分：想想一位会做饭的计算机科学家正在为他的女儿制作生日蛋糕。他有做生日蛋糕的食谱，厨房里有所需的原料：面粉、鸡蛋、糖、香草汁等。在这个比喻中，做蛋糕的食谱就是程序、计算机科学家就是 CPU、而做蛋糕的各种原谅都是输入数据。进程就是科学家阅读食谱、取来各种原料以及烘焙蛋糕等一系例了动作的总和。</p>
<p>现在假设科学家的儿子跑过来告诉他，说他的头被蜜蜂蜇了一下，那么此时科学家会记录出来他做蛋糕这个过程到了哪一步，然后拿出急救手册，按照上面的步骤给他儿子实施救助。这里，会涉及到进程之间的切换，科学家（CPU）会从做蛋糕（进程）切换到实施医疗救助（另一个进程）。等待伤口处理完毕后，科学家会回到刚刚记录做蛋糕的那一步，继续制作。</p>
<p>这里的关键思想是<code>认识到一个进程所需的条件</code>，进程是某一类特定活动的总和，它有程序、输入输出以及状态。单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另外一个进程提供服务。另外需要注意的是，如果一个进程运行了两遍，则被认为是两个进程。那么我们了解到进程模型后，那么进程是如何创建的呢？</p>
<h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>操作系统需要一些方式来创建进程。下面是一些创建进程的方式</p>
<ul>
<li>系统初始化（init）</li>
<li>正在运行的程序执行了创建进程的系统调用（比如 fork）</li>
<li>用户请求创建一个新进程</li>
<li>初始化一个批处理工作</li>
</ul>
<h4 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h4><p>启动操作系统时，通常会创建若干个进程。其中有些是<code>前台进程(numerous processes)</code>，也就是同用户进行交互并替他们完成工作的进程。一些运行在后台，并不与特定的用户进行交互，例如，设计一个进程来接收发来的电子邮件，这个进程大部分的时间都在休眠，但是只要邮件到来后这个进程就会被唤醒。还可以设计一个进程来接收对该计算机上网页的传入请求，在请求到达的进程唤醒来处理网页的传入请求。进程运行在后台用来处理一些活动像是 e-mail，web 网页，新闻，打印等等被称为 <code>守护进程(daemons)</code>。大型系统会有很多守护进程。在 UNIX 中，<code>ps</code> 程序可以列出正在运行的进程， 在 Windows 中，可以使用任务管理器。</p>
<h4 id="系统调用创建"><a href="#系统调用创建" class="headerlink" title="系统调用创建"></a>系统调用创建</h4><p>除了在启动阶段创建进程之外，一些新的进程也可以在后面创建。通常，一个正在运行的进程会发出<code>系统调用</code>用来创建一个或多个新进程来帮助其完成工作。例如，如果有大量的数据需要经过网络调取并进行顺序处理，那么创建一个进程读数据，并把数据放到共享缓冲区中，而让第二个进程取走并正确处理会比较容易些。在多处理器中，让每个进程运行在不同的 CPU 上也可以使工作做的更快。</p>
<h4 id="用户请求创建"><a href="#用户请求创建" class="headerlink" title="用户请求创建"></a>用户请求创建</h4><p>在许多交互式系统中，输入一个命令或者双击图标就可以启动程序，以上任意一种操作都可以选择开启一个新的进程，在基本的 UNIX 系统中运行 X，新进程将接管启动它的窗口。在 Windows 中启动进程时，它一般没有窗口，但是它可以创建一个或多个窗口。每个窗口都可以运行进程。通过鼠标或者命令就可以切换窗口并与进程进行交互。</p>
<blockquote>
<p>交互式系统是以人与计算机之间大量交互为特征的计算机系统，比如游戏、web浏览器，IDE 等集成开发环境。</p>
</blockquote>
<h4 id="批处理创建"><a href="#批处理创建" class="headerlink" title="批处理创建"></a>批处理创建</h4><p>最后一种创建进程的情形会在<code>大型机的批处理系统</code>中应用。用户在这种系统中提交批处理作业。当操作系统决定它有资源来运行另一个任务时，它将创建一个新进程并从其中的输入队列中运行下一个作业。</p>
<p>从技术上讲，在所有这些情况下，让现有流程执行流程是通过创建系统调用来创建新流程的。该进程可能是正在运行的用户进程，是从键盘或鼠标调用的系统进程或批处理程序。这些就是系统调用创建新进程的过程。该系统调用告诉操作系统创建一个新进程，并直接或间接指示在其中运行哪个程序。</p>
<p>在 UNIX 中，仅有一个系统调用来创建一个新的进程，这个系统调用就是 <code>fork</code>。这个调用会创建一个与调用进程相关的副本。在 fork 后，一个父进程和子进程会有相同的内存映像，相同的环境字符串和相同的打开文件。通常，子进程会执行 <code>execve</code> 或者一个简单的系统调用来改变内存映像并运行一个新的程序。例如，当一个用户在 shell 中输出 sort 命令时，shell 会 fork 一个子进程然后子进程去执行 sort 命令。这两步过程的原因是允许子进程在 fork 之后但在 execve 之前操作其文件描述符，以完成标准输入，标准输出和标准错误的重定向。</p>
<p>在 Windows 中，情况正相反，一个简单的 Win32 功能调用 <code>CreateProcess</code>，会处理流程创建并将正确的程序加载到新的进程中。这个调用会有 10 个参数，包括了需要执行的程序、输入给程序的命令行参数、各种安全属性、有关打开的文件是否继承控制位、优先级信息、进程所需要创建的窗口规格以及指向一个结构的指针，在该结构中新创建进程的信息被返回给调用者。除了 <code>CreateProcess</code> Win 32 中大概有 100 个其他的函数用于处理进程的管理，同步以及相关的事务。下面是 UNIX 操作系统和 Windows 操作系统系统调用的对比</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>UNIX</th>
<th>Win32</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>fork</td>
<td>CreateProcess</td>
<td>创建一个新进程</td>
</tr>
<tr>
<td>waitpid</td>
<td>WaitForSingleObject</td>
<td>等待一个进程退出</td>
</tr>
<tr>
<td>execve</td>
<td>none</td>
<td>CraeteProcess = fork + servvice</td>
</tr>
<tr>
<td>exit</td>
<td>ExitProcess</td>
<td>终止执行</td>
</tr>
<tr>
<td>open</td>
<td>CreateFile</td>
<td>创建一个文件或打开一个已有的文件</td>
</tr>
<tr>
<td>close</td>
<td>CloseHandle</td>
<td>关闭文件</td>
</tr>
<tr>
<td>read</td>
<td>ReadFile</td>
<td>从单个文件中读取数据</td>
</tr>
<tr>
<td>write</td>
<td>WriteFile</td>
<td>向单个文件写数据</td>
</tr>
<tr>
<td>lseek</td>
<td>SetFilePointer</td>
<td>移动文件指针</td>
</tr>
<tr>
<td>stat</td>
<td>GetFileAttributesEx</td>
<td>获得不同的文件属性</td>
</tr>
<tr>
<td>mkdir</td>
<td>CreateDirectory</td>
<td>创建一个新的目录</td>
</tr>
<tr>
<td>rmdir</td>
<td>RemoveDirectory</td>
<td>移除一个空的目录</td>
</tr>
<tr>
<td>link</td>
<td>none</td>
<td>Win32 不支持 link</td>
</tr>
<tr>
<td>unlink</td>
<td>DeleteFile</td>
<td>销毁一个已有的文件</td>
</tr>
<tr>
<td>mount</td>
<td>none</td>
<td>Win32 不支持 mount</td>
</tr>
<tr>
<td>umount</td>
<td>none</td>
<td>Win32 不支持 mount，所以也不支持mount</td>
</tr>
<tr>
<td>chdir</td>
<td>SetCurrentDirectory</td>
<td>切换当前工作目录</td>
</tr>
<tr>
<td>chmod</td>
<td>none</td>
<td>Win32 不支持安全</td>
</tr>
<tr>
<td>kill</td>
<td>none</td>
<td>Win32 不支持信号</td>
</tr>
<tr>
<td>time</td>
<td>GetLocalTime</td>
<td>获取当前时间</td>
</tr>
</tbody>
</table>
</div>
<p>在 UNIX 和 Windows 中，进程创建之后，父进程和子进程有各自不同的地址空间。如果其中某个进程在其地址空间中修改了一个词，这个修改将对另一个进程不可见。</p>
<p>在 UNIX 中，子进程的地址空间是父进程的一个拷贝，但是是两个<strong>不同的地址空间</strong>；不可写的内存区域是共享的。某些 UNIX 实现是正是在两者之间共享，因为它不能被修改。或者，子进程共享父进程的所有内存，但是这种情况下内存通过 <code>写时复制(copy-on-write)</code> 共享，这意味着一旦两者之一想要修改部分内存，则这块内存首先被明确的复制，以确保修改发生在私有内存区域。再次强调，<strong>可写的内存是不能被共享的</strong>。但是，对于一个新创建的进程来说，确实有可能共享创建者的资源，比如可以<strong>共享打开的文件</strong>。</p>
<p><strong>在 Windows 中，从一开始父进程的地址空间和子进程的地址空间就是不同的</strong>。</p>
<h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><p>进程在创建之后，它就开始运行并做完成任务。然而，没有什么事是永不停歇的，包括进程也一样。进程早晚会发生终止，但是通常是由于以下情况触发的</p>
<ul>
<li><code>正常退出(自愿的)</code></li>
<li><code>错误退出(自愿的)</code></li>
<li><code>严重错误(非自愿的)</code></li>
<li><code>被其他进程杀死(非自愿的)</code></li>
</ul>
<h4 id="正常退出"><a href="#正常退出" class="headerlink" title="正常退出"></a>正常退出</h4><p>多数进程是由于完成了工作而终止。当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用告诉操作系统它完成了工作。这个调用在 UNIX 中是 <code>exit</code> ，在 Windows 中是 <code>ExitProcess</code>。面向屏幕中的软件也支持自愿终止操作。字处理软件、Internet 浏览器和类似的程序中总有一个供用户点击的图标或菜单项，用来通知进程删除它锁打开的任何临时文件，然后终止。</p>
<h4 id="错误退出"><a href="#错误退出" class="headerlink" title="错误退出"></a>错误退出</h4><p>进程发生终止的第二个原因是发现严重错误，例如，如果用户执行如下命令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc foo.c</span><br></pre></td></tr></table></figure>
<p>为了能够编译 foo.c 但是该文件不存在，于是编译器就会发出声明并退出。在给出了错误参数时，面向屏幕的交互式进程通常并不会直接退出，因为这从用户的角度来说并不合理，用户需要知道发生了什么并想要进行重试，所以这时候应用程序通常会弹出一个对话框告知用户发生了系统错误，是需要重试还是退出。</p>
<h4 id="严重错误"><a href="#严重错误" class="headerlink" title="严重错误"></a>严重错误</h4><p>进程终止的第三个原因是由进程引起的错误，通常是由于程序中的错误所导致的。例如，执行了一条非法指令，引用不存在的内存，或者除数是 0 等。在有些系统比如 UNIX 中，进程可以通知操作系统，它希望自行处理某种类型的错误，在这类错误中，进程会收到信号（中断），而不是在这类错误出现时直接终止进程。</p>
<h4 id="被其他进程杀死"><a href="#被其他进程杀死" class="headerlink" title="被其他进程杀死"></a>被其他进程杀死</h4><p>第四个终止进程的原因是，某个进程执行系统调用告诉操作系统杀死某个进程。在 UNIX 中，这个系统调用是 kill。在 Win32 中对应的函数是 <code>TerminateProcess</code>（注意不是系统调用）。</p>
<h3 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h3><p>在一些系统中，当一个进程创建了其他进程后，父进程和子进程就会以某种方式进行关联。子进程它自己就会创建更多进程，从而形成一个进程层次结构。</p>
<h4 id="UNIX-进程体系"><a href="#UNIX-进程体系" class="headerlink" title="UNIX 进程体系"></a>UNIX 进程体系</h4><p>在 UNIX 中，进程和它的所有子进程以及子进程的子进程共同组成一个<strong>进程组</strong>。当用户从键盘中发出一个信号后，该信号被发送给当前与键盘相关的进程组中的所有成员（它们通常是在当前窗口创建的所有活动进程）。每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被信号 kill 掉。</p>
<p>这里有另一个例子，可以用来说明层次的作用，考虑 <code>UNIX</code> 在启动时如何初始化自己。一个称为 <code>init</code> 的特殊进程出现在启动映像中 。当 init 进程开始运行时，它会读取一个文件，文件会告诉它有多少个终端。然后为每个终端创建一个新进程。这些进程等待用户登录。如果登录成功，该登录进程就执行一个 shell 来等待接收用户输入指令，这些命令可能会启动更多的进程，以此类推。因此，整个操作系统中所有的进程都隶属于一个单个以 init 为根的进程树。</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/7.png" style="zoom:67%;"></p>
<h4 id="Windows-进程体系"><a href="#Windows-进程体系" class="headerlink" title="Windows 进程体系"></a>Windows 进程体系</h4><p>相反，Windows 中没有进程层次的概念，Windows 中所有进程都是平等的，唯一类似于层次结构的是在创建进程的时候，父进程得到一个特别的令牌（称为句柄），该句柄可以用来控制子进程。然而，这个令牌可能也会移交给别的操作系统，这样就不存在层次结构了。而在 UNIX 中，进程不能剥夺其子进程的 <code>进程权</code>。（这样看来，还是 Windows 比较<code>渣</code>）。</p>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>尽管每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但是，进程之间仍然需要相互帮助。例如，一个进程的结果可以作为另一个进程的输入，在 shell 命令中</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat chapter1 chapter2 chapter3 | grep tree</span><br></pre></td></tr></table></figure>
<p>第一个进程是 <code>cat</code>，将三个文件级联并输出。第二个进程是 <code>grep</code>，它从输入中选择具有包含关键字 <code>tree</code> 的内容，根据这两个进程的相对速度（这取决于两个程序的相对复杂度和各自所分配到的 CPU 时间片），可能会发生下面这种情况，<code>grep</code> 准备就绪开始运行，但是输入进程还没有完成，于是必须阻塞 grep 进程，直到输入完毕。</p>
<p>当一个进程开始运行时，它可能会经历下面这几种状态</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/0.png" style="zoom:67%;"></p>
<p>图中会涉及三种状态</p>
<ol>
<li><code>运行态</code>，运行态指的就是进程实际占用 CPU 时间片运行时</li>
<li><code>就绪态</code>，就绪态指的是可运行，但因为其他进程正在运行而处于就绪状态</li>
<li><code>阻塞态</code>，除非某种外部事件发生，否则进程不能运行</li>
</ol>
<p>逻辑上来说，运行态和就绪态是很相似的。这两种情况下都表示进程<code>可运行</code>，但是第二种情况没有获得 CPU 时间分片。第三种状态与前两种状态不同的原因是这个进程不能运行，CPU 空闲时也不能运行。</p>
<p>三种状态会涉及四种状态间的切换，在操作系统发现进程<strong>不能继续执行时</strong>会发生<code>状态1</code>的轮转，在某些系统中进程执行系统调用，例如 <code>pause</code>，来获取一个阻塞的状态。在其他系统中包括 UNIX，当进程从管道或特殊文件（例如终端）中读取没有可用的输入时，该进程会被自动终止。</p>
<p>转换 2 和转换 3 都是由进程调度程序（操作系统的一部分）引起的，进程本身不知道调度程序的存在。转换 2 的出现说明进程调度器认定当前进程已经运行了足够长的时间，是时候让其他进程运行 CPU 时间片了。当所有其他进程都运行过后，这时候该是让第一个进程重新获得 CPU 时间片的时候了，就会发生转换 3。</p>
<blockquote>
<p><strong>程序调度指的是，决定哪个进程优先被运行和运行多久，这是很重要的一点</strong>。已经设计出许多算法来尝试平衡系统整体效率与各个流程之间的竞争需求。</p>
</blockquote>
<p>当进程等待的一个外部事件发生时（如从外部输入一些数据后），则发生转换 4。如果此时没有其他进程在运行，则立刻触发转换 3，该进程便开始运行，否则该进程会处于就绪阶段，等待 CPU 空闲后再轮到它运行。</p>
<p>从上面的观点引入了下面的模型</p>
<p> <img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/3.png" style="zoom:67%;"></p>
<p><strong>操作系统最底层的就是调度程序</strong>，在它上面有许多进程。所有关于中断处理、启动进程和停止进程的具体细节都隐藏在调度程序中。事实上，调度程序只是一段非常小的程序。</p>
<h3 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h3><p>操作系统为了执行进程间的切换，会维护着一张表格，这张表就是 <code>进程表(process table)</code>。每个进程占用一个进程表项。该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时所必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样。</p>
<p>下面展示了一个典型系统中的关键字段</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/10.png" style="zoom:67%;"></p>
<p>第一列内容与<code>进程管理</code>有关，第二列内容与 <code>存储管理</code>有关，第三列内容与<code>文件管理</code>有关。</p>
<p>存储管理的 text segment 、 data segment、stack segment 更多了解见下面这篇文章</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&amp;mid=2247484788&amp;idx=1&amp;sn=8a17224cabe09d3bd564dfdf22e2ff5d&amp;chksm=fc45f887cb3271914f0e688a3cce4d7e3ce9077cdde199648e72aa92ad08fba2047b4483b7e8&amp;token=504034995&amp;lang=zh_CN#rd" target="_blank" rel="noopener">程序员需要了解的硬核知识之汇编语言(全)</a></p>
<p>现在我们应该对进程表有个大致的了解了，就可以在对单个 CPU 上如何运行多个顺序进程的错觉做更多的解释。与每一 I/O 类相关联的是一个称作 <code>中断向量(interrupt vector)</code> 的位置（靠近内存底部的固定区域）。它包含中断服务程序的入口地址。假设当一个磁盘中断发生时，用户进程正在运行，则中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器<strong>压入堆栈</strong>，计算机随即<strong>跳转到中断向量所指示的地址</strong>。这就是硬件所做的事情。然后软件就随即接管一切剩余的工作。</p>
<p>当中断结束后，操作系统会调用一个 C 程序来处理中断剩下的工作。在完成剩下的工作后，会使某些进程就绪，接着调用调度程序，决定随后运行哪个进程。然后将控制权转移给一段汇编语言代码，<strong>为当前的进程装入寄存器值以及内存映射并启动该进程运行</strong>，下面显示了中断处理和调度的过程。</p>
<ol>
<li>硬件压入堆栈程序计数器等</li>
<li>硬件从中断向量装入新的程序计数器</li>
<li>汇编语言过程保存寄存器的值</li>
<li>汇编语言过程设置新的堆栈</li>
<li>C 中断服务器运行（典型的读和缓存写入）</li>
<li>调度器决定下面哪个程序先运行</li>
<li>C 过程返回至汇编代码</li>
<li>汇编语言过程开始运行新的当前进程</li>
</ol>
<p>一个进程在执行过程中可能被中断数千次，但关键每次中断后，被中断的进程都返回到与中断发生前完全相同的状态。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>在传统的操作系统中，每个进程都有一个地址空间和一个控制线程。事实上，这是大部分进程的定义。不过，在许多情况下，经常存在同一地址空间中运行多个控制线程的情形，这些线程就像是分离的进程。下面我们就着重探讨一下什么是线程</p>
<h3 id="线程的使用"><a href="#线程的使用" class="headerlink" title="线程的使用"></a>线程的使用</h3><p>或许这个疑问也是你的疑问，为什么要在进程的基础上再创建一个线程的概念，准确的说，这其实是进程模型和线程模型的讨论，回答这个问题，可能需要分三步来回答</p>
<ul>
<li>多线程之间会<strong>共享同一块地址空间</strong>和所有可用数据的能力，这是进程所不具备的</li>
<li>线程要比进程<code>更轻量级</code>，由于线程更轻，所以它比进程更容易创建，也更容易撤销。在许多系统中，创建一个线程要比创建一个进程快 10 - 100 倍。</li>
<li>第三个原因可能是性能方面的探讨，如果多个线程都是 CPU 密集型的，那么并不能获得性能上的增强，但是如果存在着大量的计算和大量的 I/O 处理，拥有多个线程能在这些活动中彼此重叠进行，从而会加快应用程序的执行速度</li>
</ul>
<h4 id="多线程解决方案"><a href="#多线程解决方案" class="headerlink" title="多线程解决方案"></a>多线程解决方案</h4><p>现在考虑一个线程使用的例子：一个万维网服务器，对页面的请求发送给服务器，而所请求的页面发送回客户端。在多数 web 站点上，某些页面较其他页面相比有更多的访问。例如，索尼的主页比任何一个照相机详情介绍页面具有更多的访问，Web 服务器可以把获得大量访问的页面集合<strong>保存在内存中</strong>，避免到磁盘去调入这些页面，从而改善性能。这种页面的集合称为 <code>高速缓存(cache)</code>，高速缓存也应用在许多场合中，比如说 CPU 缓存。</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/11.png" style="zoom:67%;"></p>
<p>上面是一个 web 服务器的组织方式，一个叫做 <code>调度线程(dispatcher thread)</code> 的线程从网络中读入工作请求，在调度线程检查完请求后，它会选择一个空闲的（阻塞的）工作线程来处理请求，通常是将消息的指针写入到每个线程关联的特殊字中。然后调度线程会唤醒正在睡眠中的工作线程，把工作线程的状态从阻塞态变为就绪态。</p>
<p>当工作线程启动后，它会检查请求是否在 web 页面的高速缓存中存在，这个高速缓存是所有线程都可以访问的。如果高速缓存不存在这个 web 页面的话，它会调用一个 <code>read</code> 操作从磁盘中获取页面并且阻塞线程直到磁盘操作完成。当线程阻塞在硬盘操作的期间，为了完成更多的工作，调度线程可能挑选另一个线程运行，也可能把另一个当前就绪的工作线程投入运行。</p>
<p>这种模型允许将服务器编写为顺序线程的集合，在分派线程的程序中<strong>包含一个死循环</strong>，该循环用来获得工作请求并且把请求派给工作线程。每个<strong>工作线程的代码包含一个从调度线程接收的请求</strong>，并且检查 web 高速缓存中是否存在所需页面，如果有，<strong>直接把该页面返回给客户</strong>，接着工作线程阻塞，等待一个新请求的到达;如果没有，工作线程就<strong>从磁盘调入该页面</strong>，将该页面返回给客户机，然后工作线程阻塞，等待一个新请求。</p>
<p>下面是调度线程和工作线程的代码，这里假设 TRUE 为常数 1 ，buf 和 page 分别是保存工作请求和 Web 页面的相应结构。</p>
<p><strong>调度线程的大致逻辑</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">  <span class="comment">// 一个死循环，始终在等待请求，然后处理请求</span></span><br><span class="line">  get_next_request(&amp;buf);</span><br><span class="line">  handoff_work(&amp;buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>工作线程的大致逻辑</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">  wait_for_work(&amp;buf);</span><br><span class="line">  look_for_page_in_cache(&amp;buf,&amp;page);</span><br><span class="line">  <span class="comment">// 如果 page 不在高速缓存当中的话，就从磁盘中读取</span></span><br><span class="line">  <span class="keyword">if</span>(page_not_in_cache(&amp;page))&#123;</span><br><span class="line">    read_page_from_disk(&amp;buf,&amp;page);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _page(&amp;page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="单线程解决方案"><a href="#单线程解决方案" class="headerlink" title="单线程解决方案"></a>单线程解决方案</h4><p>现在考虑没有多线程的情况下，如何编写 Web 服务器。我们很容易的就想象为单个线程了，Web 服务器的主循环获取请求并检查请求，并争取在下一个请求之前完成工作。在等待磁盘操作时，服务器空转，并且不处理任何到来的其他请求。结果会导致每秒中只有很少的请求被处理，所以这个例子能够说明<strong>多线程提高了程序的并行性</strong>并提高了程序的性能。</p>
<h4 id="状态机解决方案"><a href="#状态机解决方案" class="headerlink" title="状态机解决方案"></a>状态机解决方案</h4><p>到现在为止，我们已经有了两种解决方案，单线程解决方案和多线程解决方案，其实还有一种解决方案就是 <code>状态机解决方案</code>，它的流程如下</p>
<p>如果目前只有一个非阻塞版本的 read 系统调用可以使用，那么当请求到达服务器时，这个唯一的 read 调用的线程会进行检查，如果能够从高速缓存中得到响应，那么直接返回，如果不能，则启动一个<strong>非阻塞的磁盘操作</strong></p>
<p>服务器在表中<strong>记录当前请求的状态</strong>，然后进入并获取下一个事件，紧接着下一个事件可能就是一个新工作的请求或是磁盘对先前操作的回答。如果是新工作的请求，那么就开始处理请求；如果是磁盘的响应，就从表中取出对应的状态信息进行处理。对于非阻塞式磁盘 I/O 而言，这种响应一般都是信号中断响应。</p>
<p>每次服务器从某个请求工作的状态切换到另一个状态时，都必须显式地保存或者重新装入相应的计算状态。这里，每个计算都有一个被保存的状态，存在一个会发生且使得相关状态发生改变的事件集合，我们把这类设计称为<code>有限状态机(finite-state machine)</code>，有限状态机广泛的应用在计算机科学中。</p>
<p>这三种解决方案各有各的特性</p>
<p>多线程使得顺序进程的思想得以保留下来，并且实现了并行性，但是<strong>顺序进程会阻塞系统调用</strong>；</p>
<p>单线程服务器保留了阻塞系统的简易性，但是却放弃了性能。</p>
<p>有限状态机的处理方法运用了非阻塞调用和中断，通过并行实现了高性能，但是给编程增加了困难。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模型</th>
<th>特性</th>
</tr>
</thead>
<tbody>
<tr>
<td>单线程</td>
<td>无并行性，性能较差，阻塞系统调用</td>
</tr>
<tr>
<td>多线程</td>
<td>有并行性，阻塞系统调用</td>
</tr>
<tr>
<td>有限状态机</td>
<td>有并行性，非阻塞系统调用、中断</td>
</tr>
</tbody>
</table>
</div>
<h3 id="经典的线程模型"><a href="#经典的线程模型" class="headerlink" title="经典的线程模型"></a>经典的线程模型</h3><p>理解进程的另一个角度是，用某种方法把相关的资源集中在一起。<strong>进程有存放程序正文和数据以及其他资源的地址空间</strong>。这些资源包括打开的文件、子进程、即将发生的定时器、信号处理程序、账号信息等。把这些信息放在进程中会比较容易管理。</p>
<p>另一个概念是，进程中拥有一个执行的线程，通常简写为 <code>线程(thread)</code>。线程会有程序<strong>计数器</strong>，用来<strong>记录接着要执行哪一条指令</strong>；线程还拥有<strong>寄存器</strong>，用来<strong>保存线程当前正在使用的变量</strong>；线程还会有<strong>堆栈</strong>，用来<strong>记录程序的执行路径</strong>。尽管线程必须在某个进程中执行，但是进程和线程完完全全是两个不同的概念，并且他们可以分开处理。进程用于把资源集中在一起，而线程则是 CPU 上调度执行的实体。</p>
<p>线程给进程模型增加了一项内容，即在同一个进程中，允许彼此之间有较大的独立性且互不干扰。在一个进程中并行运行多个线程类似于在一台计算机上运行多个进程。在多个线程中，<strong>各个线程共享同一地址空间和其他资源</strong>。在多个进程中，进程共享物理内存、磁盘、打印机和其他资源。因为线程会包含有一些进程的属性，所以线程被称为<code>轻量的进程(lightweight processes)</code>。<code>多线程(multithreading)</code>一词还用于描述在同一进程中多个线程的情况。</p>
<p>下图我们可以看到<strong>三个传统的进程</strong>，每个进程有自己的地址空间和单个控制线程。每个线程都在不同的地址空间中运行</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/12.png" style="zoom:67%;"></p>
<p>下图中，我们可以看到这个进程有三个线程的情况。每个线程都在<strong>相同的地址</strong>空间中运行。</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/13.png" style="zoom:67%;"></p>
<p>线程不像是进程那样具备较强的独立性。<strong>同一个进程中的所有线程</strong>都会<strong>有完全一样的地址空间</strong>，这意味着它们也共享同样的全局变量。由于每个线程都可以访问进程地址空间内每个内存地址，<strong>因此一个线程可以读取、写入甚至擦除另一个线程的堆栈</strong>。线程之间除了共享同一内存空间外，还具有如下不同的内容</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/14.png" style="zoom:67%;"></p>
<p>上图左边的是同一个进程中<strong>每个线程共享的内容</strong>，上图右边是<strong>每个线程中各自有的内容</strong>。也就是说左边的列表是<strong>进程的属性</strong>，右边的列表是<strong>线程的属性</strong>。</p>
<p>和进程一样，线程可以处于下面这几种状态：<strong>运行中、阻塞、就绪和终止（进程图中没有画）</strong>。</p>
<p>正在运行的线程拥有 CPU 时间片并且状态是运行中。一个被阻塞的线程会等待某个释放它的事件。例如，当一个线程执行从键盘读入数据的系统调用时，该线程就被阻塞直到有输入为止。线程通常会被阻塞，直到它等待某个外部事件的发生或者有其他线程来释放它。<strong>线程之间的状态转换和进程之间的状态转换是一样的</strong>。</p>
<p>每个线程都会有自己的堆栈，如下图所示</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/15.png" style="zoom:67%;"></p>
<h4 id="线程系统调用"><a href="#线程系统调用" class="headerlink" title="线程系统调用"></a>线程系统调用</h4><p>进程通常会从当前的某个单线程开始，然后这个线程通过调用一个库函数（比如 <code>thread_create</code>）创建新的线程。线程创建的函数会要求<strong>指定新创建线程的名称</strong>。创建的线程通常都<strong>返回一个线程标识符</strong>，该标识符就是新线程的名字。</p>
<p>当一个线程完成工作后，可以通过调用一个函数（比如 <code>thread_exit</code>）来退出。紧接着<strong>线程消失，状态变为终止</strong>，不能再进行调度。在某些线程的运行过程中，可以通过调用函数例如 <code>thread_join</code> ，表示一个线程可以等待另一个线程退出。这个过程阻塞调用线程直到等待特定的线程退出。在这种情况下，线程的创建和终止非常类似于进程的创建和终止。</p>
<p>另一个常见的线程是调用 <code>thread_yield</code>，它允许线程自动放弃 CPU 从而让另一个线程运行。这样一个调用还是很重要的，因为不同于进程，线程是无法利用时钟中断强制让线程让出 CPU 的。</p>
<h3 id="POSIX-线程"><a href="#POSIX-线程" class="headerlink" title="POSIX 线程"></a>POSIX 线程</h3><p>为了使编写可移植线程程序成为可能，IEEE 在 IEEE 标准 1003.1c 中定义了线程标准。线程包被定义为 <code>Pthreads</code>。大部分的 UNIX 系统支持它。这个标准定义了 60 多种功能调用，一一列举不太现实，下面为你列举了一些常用的系统调用。</p>
<blockquote>
<p><strong>POSIX线程</strong>（通常称为<strong>pthreads</strong>）是一种独立于语言而存在的执行模型，以及并行执行模型。它允许程序控制时间上重叠的多个不同的工作流程。每个工作流程都称为一个线程，可以通过调用POSIX Threads API来实现对这些流程的创建和控制。可以把它理解为线程的标准。</p>
<p>POSIX Threads 的实现在许多类似且符合POSIX的操作系统上可用，例如 <strong>FreeBSD、NetBSD、OpenBSD、Linux、macOS、Android、Solaris</strong>，它在现有 Windows API 之上实现了<strong>pthread</strong>。</p>
<p>IEEE 是世界上最大的技术专业组织，致力于为人类的利益而发展技术。</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>线程调用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pthread_create</td>
<td>创建一个新线程</td>
</tr>
<tr>
<td>pthread_exit</td>
<td>结束调用的线程</td>
</tr>
<tr>
<td>pthread_join</td>
<td>等待一个特定的线程退出</td>
</tr>
<tr>
<td>pthread_yield</td>
<td>释放 CPU 来运行另外一个线程</td>
</tr>
<tr>
<td>pthread_attr_init</td>
<td>创建并初始化一个线程的属性结构</td>
</tr>
<tr>
<td>pthread_attr_destory</td>
<td>删除一个线程的属性结构</td>
</tr>
</tbody>
</table>
</div>
<p>所有的 Pthreads 都有特定的属性，每一个都含有<strong>标识符</strong>、<strong>一组寄存器</strong>（包括程序计数器）和<strong>一组存储</strong>在结构中的属性。这个属性包括堆栈大小、调度参数以及其他线程需要的项目。</p>
<p>新的线程会通过 <code>pthread_create</code> 创建，新创建的线程的标识符会作为函数值返回。这个调用非常像是 UNIX 中的 <code>fork</code> 系统调用（除了参数之外），其中线程标识符起着 <code>PID</code> 的作用，这么做的目的是为了和其他线程进行区分。</p>
<p>当线程完成指派给他的工作后，会通过 <code>pthread_exit</code> 来终止。这个调用会<strong>停止线程并释放堆栈</strong>。</p>
<p>一般一个线程在继续运行前需要等待另一个线程完成它的工作并退出。可以通过 <code>pthread_join</code> 线程调用来等待别的特定线程的终止。而要等待线程的线程标识符作为一个参数给出。</p>
<p>有时会出现这种情况：一个线程逻辑上没有阻塞，但感觉上它已经运行了足够长的时间并且希望给另外一个线程机会去运行。这时候可以通过 <code>pthread_yield</code> 来完成。</p>
<p>下面两个线程调用是处理属性的。<code>pthread_attr_init</code> 建立关联一个线程的属性结构并初始化成默认值，这些值（例如优先级）可以通过修改属性结构的值来改变。</p>
<p>最后，<code>pthread_attr_destroy</code> 删除一个线程的结构，释放它占用的内存。它不会影响调用它的线程，这些线程会一直存在。</p>
<p>为了更好的理解 pthread 是如何工作的，考虑下面这个例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMBER_OF_THREADS 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">print_hello_world</span><span class="params">(vvoid *tid)</span></span>&#123;</span><br><span class="line">  <span class="comment">/* 输出线程的标识符，然后退出 */</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello World. Greetings from thread %d\n"</span>,tid);</span><br><span class="line">  pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">  <span class="comment">/* 主程序创建 10 个线程，然后退出 */</span></span><br><span class="line">  <span class="keyword">pthread_t</span> threads[NUMBER_OF_THREADS];</span><br><span class="line">  <span class="keyword">int</span> status,i;</span><br><span class="line"> 	</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; NUMBER_OF_THREADS;i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Main here. Creating thread %d\n"</span>,i);</span><br><span class="line">    status = pthread_create(&amp;threads[i], <span class="literal">NULL</span>, print_hello_world, (<span class="keyword">void</span> *)i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(status != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Oops. pthread_create returned error code %d\n"</span>,status);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主线程在宣布它的指责之后，循环 <code>NUMBER_OF_THREADS</code> 次，每次创建一个新的线程。如果线程创建失败，会打印出一条信息后退出。在创建完成所有的工作后，主程序退出。</p>
<h3 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h3><p>主要有三种实现方式</p>
<ul>
<li>在用户空间中实现线程；</li>
<li>在内核空间中实现线程；</li>
<li>在用户和内核空间中混合实现线程。</li>
</ul>
<p>下面我们分开讨论一下</p>
<h4 id="在用户空间中实现线程"><a href="#在用户空间中实现线程" class="headerlink" title="在用户空间中实现线程"></a>在用户空间中实现线程</h4><p>第一种方法是把整个线程包放在用户空间中，内核对线程一无所知，它不知道线程的存在。所有的这类实现都有<strong>同样的通用结构</strong></p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/16.png" style="zoom:67%;"></p>
<p>线程是在系统之上运行，运行时系统是管理线程过程的集合，包括前面提到的四个过程： <code>pthread_create</code>, <code>pthread_exit</code>, <code>pthread_join</code> 和 <code>pthread_yield</code>。</p>
<blockquote>
<p><code>运行时系统(Runtime System)</code> 也叫做运行时环境，该运行时系统提供了程序在其中运行的环境。此环境可能会解决许多问题，包括应用程序内存的布局，程序如何访问变量，在过程之间传递参数的机制，与操作系统的接口等等。编译器根据特定的运行时系统进行假设以生成正确的代码。通常，运行时系统将负责设置和管理堆栈，并且会包含诸如垃圾收集，线程或语言内置的其他动态的功能。</p>
</blockquote>
<p>在用户空间管理线程时，每个进程需要有其专用的<strong>线程表(thread table)</strong>，用来跟踪该进程中的线程。这些表和内核中的进程表类似，不过它<strong>仅仅记录各个线程的属性</strong>，如每个线程的程序计数器、堆栈指针、寄存器和状态。该线程标由运行时系统统一管理。当一个线程转换到就绪状态或阻塞状态时，在该<strong>线程表中存放重新启动该线程的所有信息</strong>，与内核在进程表中存放的信息完全一样。</p>
<h4 id="在用户空间实现线程的优势"><a href="#在用户空间实现线程的优势" class="headerlink" title="在用户空间实现线程的优势"></a>在用户空间实现线程的优势</h4><p>在用户空间中实现线程要比在内核空间中实现线程具有这些方面的优势：考虑如果在线程完成时或者是在调用 <code>pthread_yield</code> 时，必要时会进程线程切换，然后线程的信息会被保存在运行时环境所提供的线程表中，然后，线程调度程序来选择另外一个需要运行的线程。保存线程的状态和调度程序都是<strong>本地过程，所以启动他们比进行内核调用效率更高。因而不需要切换到内核，也就不需要上下文切换，也不需要对内存高速缓存进行刷新，因为线程调度非常便捷，因此效率比较高</strong>。</p>
<p>在用户空间实现线程还有一个优势就是<strong>它允许每个进程有自己定制的调度算法</strong>。例如在某些应用程序中，那些具有垃圾收集线程的应用程序就不用担心自己线程会不会在不合适的时候停止，这是一个优势。用户线程还具有<strong>较好的可扩展性</strong>，因为内核空间中的内核线程需要一些表空间和堆栈空间，如果内核线程数量比较大，容易造成问题。</p>
<h4 id="在用户空间实现线程的劣势"><a href="#在用户空间实现线程的劣势" class="headerlink" title="在用户空间实现线程的劣势"></a>在用户空间实现线程的劣势</h4><p>尽管在用户空间实现线程会具有一定的性能优势，但是劣势还是很明显的，你如何实现<strong>阻塞系统调用</strong>(阻塞调用是指调用结果返回之前，当前线程会被挂起)呢？假设在还没有任何键盘输入之前，一个线程读取键盘，让线程进行系统调用是不可能的，因为这会停止所有的线程。所以，<strong>使用线程的一个目标是能够让线程进行阻塞调用，并且要避免被阻塞的线程影响其他线程</strong>。</p>
<p>与阻塞调用类似的问题是<strong>缺页中断</strong>问题。实际上，计算机并不会把所有的程序都一次性的放入内存中，如果某个程序发生函数调用或者跳转指令到了一条不在内存的指令上，就会发生页面故障，而操作系统将到磁盘上取回这个丢失的指令，这就称为<strong>缺页故障</strong>。而在对所需的指令进行读入和执行时，<strong>相关的进程就会被阻塞</strong>。如果只有一个线程引起页面故障，<strong>内核由于甚至不知道有线程存在，通常会把整个进程阻塞直到磁盘 I/O 完成为止，尽管其他的线程是可以运行的</strong>。</p>
<p>另外一个问题是，<strong>如果一个线程开始运行，该线程所在进程中的其他线程都不能运行</strong>，除非第一个线程自愿的放弃 CPU，在一个单进程内部，没有时钟中断，所以不可能使用轮转调度的方式调度线程。除非其他线程能够以自己的意愿进入运行时环境，否则调度程序没有可以调度线程的机会。</p>
<h3 id="在内核中实现线程"><a href="#在内核中实现线程" class="headerlink" title="在内核中实现线程"></a>在内核中实现线程</h3><p>现在我们考虑使用内核来实现线程的情况，此时不再需要运行时环境了。另外，每个进程中也没有线程表。相反，<strong>在内核中会有用来记录系统中所有线程的线程表</strong>。当某个线程希望创建一个新线程或撤销一个已有线程时，它会进行一个<strong>系统调用</strong>，这个系统调用<strong>通过对线程表的更新来完成线程创建或销毁工作</strong></p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/17.png" style="zoom:67%;"></p>
<p><strong>内核中的线程表持有每个线程的寄存器、状态和其他信息</strong>。这些信息和用户空间中的线程信息相同，但是位置却被放在了内核中而不是用户空间中。另外，内核还<strong>维护了一张进程表用来跟踪系统状态</strong>。</p>
<p>所有能够阻塞的调用都会通过系统调用的方式来实现，当一个线程阻塞时，内核可以进行选择，是运行在同一个进程中的另一个线程（如果有就绪线程的话）还是运行一个另一个进程中的线程。但是在用户实现中，运行时系统始终运行自己的线程，直到内核剥夺它的 CPU 时间片（或者没有可运行的线程存在了）为止。</p>
<p>由于在内核中创建或者销毁线程的<strong>开销比较大</strong>，所以某些系统会采用<strong>可循环利用的方式来回收线程</strong>。当某个线程被<strong>销毁时</strong>，就把它<strong>标志为不可运行的状态</strong>，但是其内部结构没有受到影响；稍后，在必须创建一个新线程时，就会<strong>重新启用旧线程，把它标志为可用状态</strong>。</p>
<p>如果某个进程中的线程造成缺页故障后，内核很容易的就能检查出来<strong>是否有其他可运行的线程</strong>，如果有的话，在等待所需要的页面从磁盘读入时，就选择一个可运行的线程运行。这样做的<strong>缺点是系统调用的代价比较大</strong>，所以如果线程的操作（创建、终止）比较多，就<strong>会带来很大的开销</strong>。 </p>
<h3 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h3><p>结合用户空间和内核空间的优点，设计人员采用了一种<strong>内核级线程</strong>的方式，然后将用户级线程与某些或者全部内核线程多路复用起来</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/18.png" style="zoom:67%;"></p>
<p>在这种模型中，编程人员可以<strong>自由控制用户线程和内核线程的数量</strong>，具有<strong>很大的灵活度</strong>。采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。</p>
<h3 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h3><div class="table-container">
<table>
<thead>
<tr>
<th>区别</th>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody>
<tr>
<td>关系</td>
<td>进程可以有多个线程</td>
<td>线程只能属于一个进程</td>
</tr>
<tr>
<td>资源</td>
<td>进程之间具有独立的内存单元</td>
<td>多个线程共享一个进程的内存</td>
</tr>
<tr>
<td>系统开销</td>
<td>进程创建、切换的开销大</td>
<td>线程创建、切换开销小</td>
</tr>
<tr>
<td>通信</td>
<td>七种通讯</td>
<td>直接读取进程数据段(.data)</td>
</tr>
<tr>
<td>调试</td>
<td>简单、可靠信高</td>
<td>调试相对复杂</td>
</tr>
<tr>
<td>相互间影响</td>
<td>进程之间不会相互影响</td>
<td>一个线程挂掉可能导致整个进程挂掉</td>
</tr>
<tr>
<td>适用于</td>
<td>多核、多机分布</td>
<td>多核分布</td>
</tr>
</tbody>
</table>
</div>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>进程是需要频繁的和其他进程进行交流的。例如，在一个 shell 管道中，第一个进程的输出必须传递给第二个进程，这样沿着管道进行下去。因此，进程之间如果需要通信的话，必须要使用一种良好的数据结构以至于不能被中断。下面我们会一起讨论有关<strong>进程间通信(Inter Process Communication, IPC)</strong> 的问题。</p>
<p>关于进程间的通信，这里有三个问题</p>
<ul>
<li>上面提到了第一个问题，那就是<strong>一个进程如何传递消息给其他进程</strong>。</li>
<li>第二个问题是<strong>如何确保两个或多个线程之间不会相互干扰</strong>。例如，两个航空公司都试图为不同的顾客抢购飞机上的最后一个座位。</li>
<li>第三个问题是<strong>数据的先后顺序的问题</strong>，如果进程 A 产生数据并且进程 B 打印数据。则进程 B 打印数据之前需要先等 A 产生数据后才能够进行打印。</li>
</ul>
<p>需要注意的是，这三个问题中的后面两个问题同样也适用于线程</p>
<p>第一个问题在线程间比较好解决，因为它们共享一个地址空间，它们具有相同的运行时环境，可以想象你在用高级语言编写多线程代码的过程中，线程通信问题是不是比较容易解决？</p>
<p>另外两个问题也同样适用于线程，同样的问题可用同样的方法来解决。我们后面会慢慢讨论这三个问题，你现在脑子中大致有个印象即可。</p>
<h3 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h3><p>在一些操作系统中，协作的进程可能共享一些彼此都能读写的公共资源。公共资源可能在内存中也可能在一个共享文件。为了讲清楚进程间是如何通信的，这里我们举一个例子：一个后台打印程序。当一个进程需要打印某个文件时，它会将文件名放在一个特殊的<strong>后台目录(spooler directory)</strong>中。另一个进程 <strong>打印后台进程(printer daemon)</strong>  会定期的检查是否需要文件被打印，如果有的话，就打印并将该文件名从目录下删除。</p>
<p>假设我们的后台目录有非常多的 <code>槽位(slot)</code>，编号依次为 0，1，2，…，每个槽位存放一个文件名。同时假设有两个共享变量：<br><code>out</code>，指向下一个需要打印的文件<br><code>in</code>，指向目录中下个空闲的槽位<br>可以把这两个文件保存在一个所有进程都能访问的文件中，该文件的长度为两个字。在某一时刻，0 至 3 号槽位空，4 号至 6 号槽位被占用。在同一时刻，进程 A 和 进程 B 都决定将一个文件排队打印，情况如下</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/19.png" style="zoom:67%;"></p>
<p><code>墨菲法则(Murphy)</code> 中说过，任何可能出错的地方终将出错，这句话生效时，可能发生如下情况。</p>
<p>进程 A 读到 in 的值为 7，将 7 存到一个局部变量 <code>next_free_slot</code> 中。此时发生一次时钟中断，CPU 认为进程 A 已经运行了足够长的时间，决定切换到进程 B 。进程 B 也读取 in 的值，发现是 7，然后进程 B 将 7 写入到自己的局部变量 <code>next_free_slot</code> 中，在这一时刻两个进程都认为下一个可用槽位是 7 。</p>
<p>进程 B 现在继续运行，它会将打印文件名写入到 slot 7 中，然后把 in 的指针更改为 8 ，然后进程 B 离开去做其他的事情</p>
<p>现在进程 A 开始恢复运行，由于进程 A 通过检查 <code>next_free_slot</code>也发现 slot 7 的槽位是空的，于是将打印文件名存入 slot 7 中，然后把 in 的值更新为 8 ，由于 slot 7 这个槽位中已经有进程 B 写入的值，所以<strong>进程 A 的打印文件名会把进程 B 的文件覆盖</strong>，由于打印机内部是无法发现是哪个进程更新的，它的功能比较局限，所以这时候<strong>进程 B 永远无法打印输出</strong>，类似这种情况，<strong>即两个或多个线程同时对一共享数据进行修改，从而影响程序运行的正确性时，这种就被称为竞态条件(race condition)</strong>。调试竞态条件是一种非常困难的工作，因为绝大多数情况下程序运行良好，但在极少数的情况下会发生一些无法解释的奇怪现象。</p>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>不仅共享资源会造成竞态条件，事实上共享文件、共享内存也会造成竞态条件、那么该如何避免呢？或许一句话可以概括说明：<strong>禁止一个或多个进程在同一时刻对共享资源（包括共享内存、共享文件等）进行读写</strong>。换句话说，我们需要一种 <code>互斥(mutual exclusion)</code> 条件，这也就是说，如果一个进程在某种方式下使用共享变量和文件的话，除该进程之外的其他进程就禁止做这种事（访问统一资源）。上面问题的纠结点在于，在进程 A 对共享变量的使用未结束之前进程 B 就使用它。在任何操作系统中，为了实现互斥操作而选用适当的原语是一个主要的设计问题，接下来我们会着重探讨一下。</p>
<p>避免竞争问题的条件可以用一种抽象的方式去描述。大部分时间，进程都会忙于内部计算和其他不会导致竞争条件的计算。然而，有时候进程会访问共享内存或文件，或者做一些能够导致竞态条件的操作。我们把<strong>对共享内存进行访问的程序片段</strong>称作 <code>临界区域(critical region)</code> 或 <code>临界区(critical section)</code>。如果我们能够正确的操作，<strong>使两个不同进程不可能同时处于临界区</strong>，就能避免竞争条件，这也是从操作系统设计角度来进行的。</p>
<p>尽管上面这种设计避免了竞争条件，但是不能确保并发线程同时访问共享数据的正确性和高效性。一个好的解决方案，应该包含下面四种条件</p>
<ol>
<li>任何时候两个进程不能同时处于临界区</li>
<li>不应对 CPU 的速度和数量做任何假设</li>
<li>位于临界区外的进程不得阻塞其他进程</li>
<li>不能使任何进程无限等待进入临界区</li>
</ol>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/20.png" style="zoom:67%;"></p>
<p>从抽象的角度来看，我们通常希望进程的行为如上图所示</p>
<ul>
<li>在 t1 时刻，进程 A 进入临界区</li>
<li>在 t2 的时刻，进程 B 尝试进入临界区，因为此时进程 A 正在处于临界区中，所以进程 B 会阻塞</li>
<li>t3 时刻进程 A 离开临界区，此时进程 B 能够允许进入临界区。</li>
<li>在 t4 时刻，进程 B 离开临界区，系统恢复到没有进程的原始状态。</li>
</ul>
<h3 id="忙等互斥"><a href="#忙等互斥" class="headerlink" title="忙等互斥"></a>忙等互斥</h3><p>下面我们会继续探讨实现互斥的各种设计，在这些方案中，当一个进程正忙于更新其临界区的共享内存时，没有其他进程会进入其临界区，也不会造成影响。</p>
<h4 id="屏蔽中断"><a href="#屏蔽中断" class="headerlink" title="屏蔽中断"></a>屏蔽中断</h4><p>在单处理器系统上，最简单的解决方案是让每个进程在进入临界区后<strong>立即</strong><code>屏蔽所有中断</code>，并在离开临界区之前重新启用它们。屏蔽中断后，时钟中断也会被屏蔽。CPU 只有发生时钟中断或其他中断时才会进行进程切换。这样，<strong>在屏蔽中断后 CPU 不会切换到其他进程</strong>。所以，一旦某个进程屏蔽中断之后，它就可以检查和修改共享内存，而不用担心其他进程介入访问共享数据。</p>
<p>这个方案可行吗？进程进入临界区域是由谁决定的呢？不是用户进程吗？当进程进入临界区域后，用户进程关闭中断，如果经过一段较长时间后进程没有离开，那么中断不就一直启用不了，结果会如何？<strong>可能会造成整个系统的终止</strong>。而且如果是多处理器的话，屏蔽中断仅仅对执行 <code>disable</code> 指令的 CPU 有效。<strong>其他 CPU 仍将继续运行，并可以访问共享内存。</strong></p>
<p>另一方面，对内核来说，当它在执行更新变量或列表的几条指令期间将中断屏蔽是很方便的。例如，如果多个进程处理就绪列表中的时候发生中断，则可能会发生竞态条件的出现。所以，<strong>屏蔽中断对于操作系统本身来说是一项很有用的技术，但是对于用户线程来说，屏蔽中断却不是一项通用的互斥机制。</strong></p>
<h4 id="锁变量"><a href="#锁变量" class="headerlink" title="锁变量"></a>锁变量</h4><p>作为第二种尝试，可以寻找一种<strong>软件层面</strong>解决方案。考虑有单个共享的（锁）变量，初始为值为 0 。当一个线程想要进入临界区时，它首先会查看锁的值是否为 0 ，如果锁的值是 0 ，进程会把它设置为 1 并让进程进入临界区。如果锁的状态是 1，进程会等待直到锁变量的值变为 0 。因此</p>
<ul>
<li>锁变量的值是 0 则意味着没有线程进入临界区</li>
<li>如果是 1 则意味着有进程在临界区内。</li>
</ul>
<p>我们对上图修改后，如下所示</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/21.png" style="zoom:67%;"></p>
<p>这种设计方式是否正确呢？是否存在纰漏呢？</p>
<p>假设一个进程读出锁变量的值并发现它为 0 ，而恰好在它将其设置为 1 之前，另一个进程调度运行，读出锁的变量为0 ，并将锁的变量设置为 1 。然后第一个线程运行，把锁变量的值再次设置为 1，此时，临界区域就会有两个进程在同时运行。</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/22.png" style="zoom:67%;"></p>
<p>也许有的读者可以这么认为，在进入前检查一次，在要离开的临界区再检查一次不就解决了吗？实际上这种情况也是于事无补，因为在第二次检查期间其他线程仍有可能修改锁变量的值，换句话说，这种 <code>set-before-check</code> 不是一种 <code>原子性</code> 操作，所以同样还会发生竞争条件。</p>
<h4 id="严格轮询法"><a href="#严格轮询法" class="headerlink" title="严格轮询法"></a>严格轮询法</h4><p>第三种互斥的方式先抛出来一段代码，这里的程序是用 C 语言编写，之所以采用 C 是因为操作系统普遍是用 C 来编写的（偶尔会用 C++），而基本不会使用 Java 、Modula3 或 Pascal 这样的语言，Java 中的 native 关键字底层也是 C 或 C++ 编写的源码。对于编写操作系统而言，需要使用 C 语言这种强大、高效、可预知和有特性的语言，而对于 Java ，它是不可预知的，因为它在关键时刻会用完存储器，而在不合适的时候会调用垃圾回收机制回收内存。在 C 语言中，这种情况不会发生，C 语言中不会主动调用垃圾回收回收内存。</p>
<p><strong>进程 0 的代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">turn</span> != <span class="number">0</span>)&#123;</span><br><span class="line">    critical_region();<span class="comment">/* 进入临界区 */</span></span><br><span class="line">    <span class="built_in">turn</span> = <span class="number">1</span>;</span><br><span class="line">    noncritical_region();<span class="comment">/* 离开临界区 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>进程 1 的代码</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">turn</span> != <span class="number">1</span>)&#123;</span><br><span class="line">    critical_region();</span><br><span class="line">    <span class="built_in">turn</span> = <span class="number">0</span>;</span><br><span class="line">    noncritical_region();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面代码中，变量 <code>turn</code>，初始值为 0 ，用于记录轮到哪个进程进入临界区，并检查或更新共享内存。开始时，进程 0 检查 <code>turn</code>，发现其值为 0 ，于是进入临界区。进程 1 也发现其值为 0 ，所以在一个等待循环中不停的测试 turn，<strong>看其值何时变为 1</strong>。连续检查一个变量<strong>直到某个值出现为止</strong>，这种方法称为 <code>忙等待(busywaiting)</code>。由于这种<strong>方式浪费 CPU 时间</strong>，所以这种方式通常应该要避免。只有在有理由认为等待时间是非常短的情况下，才能够使用忙等待。用于忙等待的锁，称为 <code>自旋锁(spinlock)</code>。</p>
<p>进程 0 离开临界区时，它将 turn 的值设置为 1，以便允许进程 1 进入其临界区。假设进程 1 很快便离开了临界区，则此时两个进程都处于临界区之外，turn 的值又被设置为 0 。现在进程 0 很快就执行完了整个循环，它退出临界区，并将 turn 的值设置为 1。此时，turn 的值为 1，两个进程都在其临界区外执行。</p>
<p>突然，进程 0 结束了非临界区的操作并返回到循环的开始。但是，这时它不能进入临界区，因为 turn 的当前值为 1，此时进程 1 还忙于非临界区的操作，进程 0 只能继续 while 循环，直到进程 1 把 turn 的值改为 0 。这说明，在一个进程比另一个进程执行速度慢了很多的情况下，轮流进入临界区并不是一个好的方法。</p>
<p>这种情况违反了前面的叙述 3 ，即 <strong>位于临界区外的进程不得阻塞其他进程</strong>，进程 0 被一个临界区外的进程阻塞。由于违反了第三条，所以也不能作为一个好的方案。</p>
<h4 id="Peterson-解法"><a href="#Peterson-解法" class="headerlink" title="Peterson 解法"></a>Peterson 解法</h4><p>荷兰数学家 T.Dekker 通过将锁变量与警告变量相结合，最早提出了一个<strong>不需要严格轮换</strong>的软件互斥算法，即Dekker 算法 。后来， G.L.Peterson 发现了一种简单很多的互斥算法，它的算法如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE  1</span></span><br><span class="line"><span class="comment">/* 进程数量 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N     2													</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 现在轮到谁 */</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">turn</span>;					</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 所有值初始化为 0 (FALSE) */</span></span><br><span class="line"><span class="keyword">int</span> interested[N];											</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 进程是 0 或 1 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enter_region</span><span class="params">(<span class="keyword">int</span> <span class="built_in">process</span>)</span></span>&#123;					</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 另一个进程号 */</span></span><br><span class="line">  <span class="keyword">int</span> other;														</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 另一个进程 */</span></span><br><span class="line">  other = <span class="number">1</span> - <span class="built_in">process</span>;				</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 表示愿意进入临界区 */</span></span><br><span class="line">  interested[<span class="built_in">process</span>] = TRUE;						</span><br><span class="line">  <span class="built_in">turn</span> = <span class="built_in">process</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 当该进程希望进入临界区，但是当前另外一个进程正在临界区时，空循环 */</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">turn</span> == <span class="built_in">process</span> </span><br><span class="line">        &amp;&amp; interested[other] == <span class="literal">true</span>)&#123;&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leave_region</span><span class="params">(<span class="keyword">int</span> <span class="built_in">process</span>)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 表示离开临界区 */</span></span><br><span class="line">  interested[<span class="built_in">process</span>] == FALSE;				 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用共享变量时（即进入其临界区）之前，各个进程使用各自的进程号 0 或 1 作为参数来调用 <code>enter_region</code>，这个函数调用在需要时将使进程等待，直到能够安全的临界区。在完成对共享变量的操作之后，进程将调用 <code>leave_region</code> 表示操作完成，并且允许其他进程进入。</p>
<p>现在来看看这个办法是如何工作的。一开始，没有任何进程处于临界区中</p>
<ol>
<li>现在进程 0 调用 <code>enter_region</code>。它通过<strong>设置数组元素和将 turn 置为 0 </strong>来表示它希望进入临界区。由于进程 1 并不想进入临界区，所以 <code>enter_region</code>很快便返回。</li>
<li>如果进程1现在调用 <code>enter_region</code>，进程 1 将在此处挂起直到 <code>interested[0]</code> 变为 FALSE，这种情况只有在进程 0 调用 <code>leave_region</code> 退出临界区时才会发生。</li>
</ol>
<p>那么上面讨论的是顺序进入的情况，现在来考虑一种<strong>两个进程同时调用</strong> <code>enter_region</code> 的情况。它们都将自己的进程存入 turn，但<strong>只有最后保存进去的进程号才有效</strong>，前一个进程的进程号因为重写而丢失。假如进程 1 是最后存入的，则 turn 为 1 。</p>
<p>当两个进程都运行到 <code>while</code> 的时候，<strong>进程 0 将不会循环并进入临界区</strong>，而进程 1 将<strong>会无限循环且不会进入临界区</strong>，直到进程 0 退出临界区(不满足 <code>interested[0] = true</code>)。</p>
<h4 id="TSL-指令"><a href="#TSL-指令" class="headerlink" title="TSL 指令"></a>TSL 指令</h4><p>现在来看一种需要硬件帮助的方案。一些计算机，特别是那些设计为多处理器的计算机，都会有下面这条指令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TSL RX,LOCK</span><br></pre></td></tr></table></figure>
<p>称为 <code>测试并加锁(test and set lock)</code>，它将一个内存字 lock 读到寄存器 <code>RX</code> 中，然后在该内存地址上存储一个<strong>非零值</strong>。读写指令能保证是一体的，不可分割的，一同执行的(原子性)。在这个<strong>指令结束之前其他处理器均不允许访问内存</strong>。执行 TSL 指令的 CPU 将会<strong>锁住内存总线</strong>，用来禁止其他 CPU 在这个指令结束之前访问内存。操作系统的Mutex的加锁过程就是基于TSL指令实现的。</p>
<p>很重要的一点是锁住内存总线和禁用中断不一样。禁用中断并不能保证一个处理器在读写操作之间另一个处理器对内存的读写。也就是说，<strong>在处理器 1 上屏蔽中断对处理器 2 没有影响</strong>。让处理器 2 远离内存直到处理器 1 完成读写的最好的方式就是锁住总线。这需要一个特殊的硬件（基本上，一根总线就可以确保总线由锁住它的处理器使用，而其他的处理器不能使用）</p>
<p>为了使用 TSL 指令，要使用一个共享变量 lock 来协调对共享内存的访问。当 lock 为 0 时，任何进程都可以使用 TSL 指令将其设置为 1，并读写共享内存。当操作结束时，进程使用 <code>move</code> 指令将 lock 的值重新设置为 0 。</p>
<p>这条指令如何防止两个进程同时进入临界区呢？下面是解决方案</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">enter_region:</span><br><span class="line">		| 复制锁到寄存器并将锁设为1</span><br><span class="line">		TSL REGISTER,LOCK              </span><br><span class="line">		| 锁是 0 吗？</span><br><span class="line">  		CMP REGISTER,#0						 		</span><br><span class="line">  		| 若不是零，说明锁已被设置，所以循环</span><br><span class="line">  		JNE enter_region					 		</span><br><span class="line">  		| 返回调用者，进入临界区</span><br><span class="line">  		RET												 </span><br><span class="line">       </span><br><span class="line">leave_region:</span><br><span class="line">			| 在锁中存入 0</span><br><span class="line">			MOVE LOCK,#0			      </span><br><span class="line">      | 返回调用者</span><br><span class="line">  		RET</span><br></pre></td></tr></table></figure>
<p>我们可以看到这个解决方案的思想和 Peterson 的思想很相似。假设存在如下共 4 指令的汇编语言程序。第一条指令将 lock 原来的值复制到寄存器中并将 lock 设置为 1 ，随后这个原来的值和 0 做对比。如果它不是零，说明之前已经被加过锁，则程序返回到开始并再次测试。经过一段时间后（可长可短），该值变为 0 （当前处于临界区中的进程退出临界区时），于是过程返回，此时已加锁。要清除这个锁也比较简单，程序只需要将 0 存入 lock 即可，不需要特殊的同步指令。</p>
<p>现在有了一种很明确的做法，那就是进程在进入临界区之前会先调用 <code>enter_region</code>，判断是否进行循环，如果lock 的值是 1 ，进行无限循环；如果 lock 是 0，不进入循环并进入临界区。在进程从临界区返回时它调用 <code>leave_region</code>，这会把 lock 设置为 0 。与基于临界区问题的所有解法一样，进程必须在正确的时间调用 <code>enter_region</code> 和 <code>leave_region</code> ，解法才能奏效。</p>
<p>还有一个可以替换 TSL 的指令是 <code>XCHG</code>，它原子性的<strong>交换了两个位置的内容</strong>，例如，一个寄存器与一个内存字，代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">enter_region:</span><br><span class="line">    | 把 1 放在寄存器中</span><br><span class="line">		MOVE REGISTER,#1	</span><br><span class="line">    | 交换寄存器和锁变量的内容</span><br><span class="line">		XCHG REGISTER,LOCK			</span><br><span class="line">    | 锁是 0 吗？</span><br><span class="line">		CMP REGISTER,#0		</span><br><span class="line">    | 若不是 0 ，锁已被设置，进行循环</span><br><span class="line">		JNE enter_region					</span><br><span class="line">    | 返回调用者，进入临界区</span><br><span class="line">		RET														</span><br><span class="line">	</span><br><span class="line">leave_region:				</span><br><span class="line">		| 在锁中存入 0 </span><br><span class="line">		MOVE LOCK,#0	</span><br><span class="line">    | 返回调用者</span><br><span class="line">		RET</span><br></pre></td></tr></table></figure>
<p>XCHG 的本质上与 TSL 的解决办法一样。所有的 Intel x86 CPU 在底层同步中使用 XCHG 指令。</p>
<h3 id="睡眠与唤醒"><a href="#睡眠与唤醒" class="headerlink" title="睡眠与唤醒"></a>睡眠与唤醒</h3><p>上面解法中的 Peterson 、TSL 和 XCHG 解法都是正确的，但是它们<strong>都有忙等待的缺点</strong>。这些解法的本质上都是一样的，先检查是否能够进入临界区，若不允许，则该进程将原地等待，直到允许为止。</p>
<p>这种方式不但浪费了 CPU 时间，而且还可能引起意想不到的结果。考虑一台计算机上有两个进程，这两个进程具有不同的优先级，<code>H</code> 是属于优先级比较高的进程，<code>L</code> 是属于优先级比较低的进程。进程调度的规则是不论何时只要 H 进程处于就绪态， H 就开始运行。在某一时刻，L 处于临界区中，此时 H 变为就绪态，准备运行（例如，一条 I/O 操作结束）。现在 H 要开始忙等，但由于当 H 就绪时 L 就不会被调度，L 从来不会有机会离开临界区，所以 H 会变成死循环，有时将这种情况称为<code>优先级反转问题(priority inversion problem)</code>。</p>
<p>现在让我们看一下进程间的通信原语，这些原语在不允许它们进入临界区之前会阻塞而不是浪费 CPU 时间，最简单的是 <code>sleep</code> 和 <code>wakeup</code>。<code>sleep</code> 是一个能够造成调用者阻塞的系统调用，也就是说，这个系统调用会暂停直到其他进程唤醒它。<code>wakeup</code> 调用有一个参数，即要唤醒的进程。还有一种方式是 <code>wakeup</code> 和 <code>sleep</code> 都有一个参数，即 <code>sleep</code>和 <code>wakeup</code> 需要匹配的内存地址。</p>
<h4 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h4><p>作为这些私有原语的例子，让我们考虑<code>生产者-消费者(producer-consumer)</code> 问题，也称作 <code>有界缓冲区(bounded-buffer)</code> 问题。<strong>两个进程共享一个公共的固定大小的缓冲区</strong>。<br>其中一个是<code>生产者(producer)</code>，将信息放入缓冲区<br> 另一个是<code>消费者(consumer)</code>，会从缓冲区中取出。</p>
<p>也可以把这个问题一般化为<strong>m 个生产者</strong>和 <strong>n 个消费者</strong>的问题，但是我们这里只讨论一个生产者和一个消费者的情况，这样可以简化实现方案。</p>
<p><strong>如果缓冲队列已满</strong>，那么当生产者仍想要将数据写入缓冲区的时候，会出现问题。它的解决办法是<strong>让生产者睡眠</strong>，也就是阻塞生产者。等到消费者从缓冲区中取出一个或多个数据项时再唤醒它。<br>同样的，当消费者试图从缓冲区中取数据，但是<strong>发现缓冲区为空时</strong>，<strong>消费者也会睡眠</strong>，阻塞。直到生产者向其中放入一个新的数据。</p>
<p>这个逻辑听起来比较简单，而且这种方式也需要一种称作 <code>监听</code> 的变量，这个变量用于监视缓冲区的数据，我们暂定为 <code>count</code>，如果缓冲区最多存放 N 个数据项，生产者会每次判断 <code>count</code> 是否达到 N，否则生产者向缓冲区放入一个数据项并增量 <code>count</code> 的值。<br>消费者的逻辑也很相似：首先测试 <code>count</code> 的值是否为 0 ，如果为 0 则消费者睡眠、阻塞，否则会从缓冲区取出数据并使 count 数量递减。每个进程也会检查检查是否其他线程是否应该被唤醒，如果应该被唤醒，那么就唤醒该线程。下面是生产者消费者的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 缓冲区 slot 槽的数量 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100						</span></span><br><span class="line"><span class="comment">/* 缓冲区数据的数量 */</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>										</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="keyword">void</span> producer(<span class="keyword">void</span>)&#123;</span><br><span class="line">  <span class="keyword">int</span> item;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 无限循环 */</span></span><br><span class="line">  <span class="keyword">while</span>(TRUE)&#123;				</span><br><span class="line">    <span class="comment">/* 生成下一项数据 */</span></span><br><span class="line">    item = produce_item()				</span><br><span class="line">    <span class="comment">/* 如果缓存区是满的，就会阻塞 */</span></span><br><span class="line">    <span class="keyword">if</span>(count == N)&#123;</span><br><span class="line">      sleep();									</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 把当前数据放在缓冲区中 */</span></span><br><span class="line">    insert_item(item);</span><br><span class="line">    <span class="comment">/* 增加缓冲区 count 的数量 */</span></span><br><span class="line">    count = count + <span class="number">1</span>;					</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="comment">/* 缓冲区是否为空？ */</span></span><br><span class="line">      wakeup(consumer);					</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> item;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 无限循环 */</span></span><br><span class="line">  <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">    <span class="comment">/* 如果缓冲区是空的，就会进行阻塞 */</span></span><br><span class="line">  	<span class="keyword">if</span>(count == <span class="number">0</span>)&#123;							</span><br><span class="line">      sleep();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 从缓冲区中取出一个数据 */</span></span><br><span class="line">   	item = remove_item();			</span><br><span class="line">    <span class="comment">/* 将缓冲区的 count 数量减一 */</span></span><br><span class="line">    count = count - <span class="number">1</span></span><br><span class="line">    <span class="comment">/* 缓冲区满嘛？ */</span></span><br><span class="line">    <span class="keyword">if</span>(count == N - <span class="number">1</span>)&#123;					</span><br><span class="line">      wakeup(producer);		</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 打印数据项 */</span></span><br><span class="line">    consumer_item(item);				</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了在 C 语言中描述像是 <code>sleep</code> 和 <code>wakeup</code> 的系统调用，我们将以库函数调用的形式来表示。它们不是 C 标准库的一部分，但可以在实际具有这些系统调用的任何系统上使用。代码中未实现的 <code>insert_item</code> 和 <code>remove_item</code> 用来记录将数据项放入缓冲区和从缓冲区取出数据等。</p>
<p>现在让我们回到生产者-消费者问题上来，上面代码中会产生竞争条件，因为 count 这个变量是暴露在大众视野下的。有可能出现下面这种情况：缓冲区为空，此时消费者刚好读取 count 的值发现它为 0 。此时调度程序决定暂停消费者并启动运行生产者。刚刚好生产者生产了一条数据并把它放在缓冲区中，然后增加 count 的值，并注意到它的值是 1 。由于 count 为 0，消费者必须处于睡眠状态，因此生产者调用 <code>wakeup</code> 来唤醒消费者。<strong>但是，消费者此时在逻辑上并没有睡眠</strong>，所以 wakeup 信号会丢失。当消费者下次启动后，它会查看之前读取的 count 值，发现它的值是 0 ，然后在此进行睡眠。不久之后生产者会填满整个缓冲区，在这之后会阻塞，<strong>这样一来两个进程将永远睡眠下去。</strong></p>
<p>引起上面问题的本质是 <strong>唤醒尚未进行睡眠状态的进程会导致唤醒丢失</strong>。如果它没有丢失，则一切都很正常。一种快速解决上面问题的方式是增加一个<code>唤醒等待位(wakeup waiting bit)</code>。当一个 wakeup 信号发送给仍在清醒的进程后，该位置为 1 。之后，当进程尝试睡眠的时候，如果唤醒等待位为 1 ，则该位清除，而进程仍然保持清醒。</p>
<p>然而，当进程数量有许多的时候，这时你可以说通过增加唤醒等待位的数量来唤醒等待位，于是就有了 2、4、6、8 个唤醒等待位，<strong>但是并没有从根本上解决问题</strong></p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量是在 1965 年提出的一种方法，它使用一个<strong>整型变量来累计唤醒次数</strong>，以供之后使用。在他的观点中，有一个新的变量类型称作 <code>信号量(semaphore)</code>。一个信号量的取值可以是 0 ，或任意正数。0 表示的是不需要任何唤醒，任意的正数表示的就是唤醒次数。</p>
<p>Dijkstra 提出了信号量有两个操作，现在通常使用 <code>down</code> 和 <code>up</code>（分别可以用 sleep 和 wakeup 来表示）。<code>down</code>这个指令的操作会检查值是否大于 0 。如果大于 0 ，则将其值减 1 ；若该值为 0 ，则进程将睡眠，而且此时 <code>down</code>操作将会继续执行。检查数值、修改变量值以及可能发生的睡眠操作均为一个单一的、不可分割的 <code>原子操作(atomic action)</code> 完成。这会保证一旦信号量操作开始，没有其他的进程能够访问信号量，直到操作完成或者阻塞。<strong>这种原子性对于解决同步问题和避免竞争绝对必不可少</strong>。</p>
<blockquote>
<p>原子性操作指的是在计算机科学的许多其他领域中，一组相关操作全部执行而没有中断或根本不执行。</p>
</blockquote>
<p><code>up</code>操作会使信号量的值 + 1。如果当前信号量的值为0，且一个或者多个进程在信号量上睡眠，无法完成一个先前的 <code>down</code>操作，则由系统选择其中一个并允许该程完成 <code>down</code> 操作。因此，对一个进程在其上睡眠的信号量执行一次 <code>up</code>操作之后，该信号量的值仍然是 0 ，但在其上睡眠的进程却少了一个。信号量的值增 1 和唤醒一个进程同样也是不可分割的。不会有某个进程因执行 up 而阻塞，正如在前面的模型中不会有进程因执行 wakeup 而阻塞是一样的道理。</p>
<h4 id="用信号量解决生产者-消费者问题"><a href="#用信号量解决生产者-消费者问题" class="headerlink" title="用信号量解决生产者 - 消费者问题"></a>用信号量解决生产者 - 消费者问题</h4><p>用信号量解决丢失的 wakeup 问题，代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义缓冲区槽的数量 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="comment">/* 信号量是一种特殊的 int */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line"><span class="comment">/* 控制临界区的访问 */</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* 统计 buffer 空槽的数量 */</span></span><br><span class="line">semaphore empty = N;</span><br><span class="line"><span class="comment">/* 统计 buffer 满槽的数量 */</span></span><br><span class="line">semaphore full = <span class="number">0</span>;												</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123; </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> item;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* TRUE 的常量是 1 */</span></span><br><span class="line">  <span class="keyword">while</span>(TRUE)&#123;			</span><br><span class="line">    <span class="comment">/* 产生放在缓冲区的一些数据 */</span></span><br><span class="line">    item = producer_item();		</span><br><span class="line">    <span class="comment">/* 将空槽数量减 1  */</span></span><br><span class="line">    down(&amp;empty);	</span><br><span class="line">    <span class="comment">/* 进入临界区  */</span></span><br><span class="line">    down(&amp;mutex);	</span><br><span class="line">    <span class="comment">/* 把数据放入缓冲区中 */</span></span><br><span class="line">    insert_item(item);</span><br><span class="line">    <span class="comment">/* 离开临界区 */</span></span><br><span class="line">    up(&amp;mutex);	</span><br><span class="line">    <span class="comment">/* 将 buffer 满槽数量 + 1 */</span></span><br><span class="line">    up(&amp;full);														</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> item;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 无限循环 */</span></span><br><span class="line">  <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">    <span class="comment">/* 缓存区满槽数量 - 1 */</span></span><br><span class="line">    down(&amp;full);</span><br><span class="line">    <span class="comment">/* 进入缓冲区 */</span>	</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">/* 从缓冲区取出数据 */</span></span><br><span class="line">    item = remove_item();	</span><br><span class="line">    <span class="comment">/* 离开临界区 */</span></span><br><span class="line">    up(&amp;mutex);	</span><br><span class="line">    <span class="comment">/* 将空槽数目 + 1 */</span></span><br><span class="line">    up(&amp;empty);	</span><br><span class="line">    <span class="comment">/* 处理数据 */</span></span><br><span class="line">    consume_item(item);											</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了确保信号量能正确工作，最重要的是要采用一种不可分割的方式来实现它。通常是将 up 和 down 作为系统调用来实现。而且操作系统只需在执行以下操作时暂时屏蔽全部中断：<strong>检查信号量、更新、必要时使进程睡眠</strong>。由于这些操作仅需要非常少的指令，因此中断不会造成影响。如果使用多个 CPU，那么信号量应该被锁进行保护。使用 TSL 或者 XCHG 指令用来确保同一时刻只有一个 CPU 对信号量进行操作。</p>
<p>使用 TSL 或者 XCHG 来防止几个 CPU 同时访问一个信号量，与生产者或消费者使用忙等待来等待其他腾出或填充缓冲区是完全不一样的。前者的操作仅需要几个毫秒，而生产者或消费者可能需要任意长的时间。</p>
<p>上面这个解决方案使用了三种信号量：</p>
<ul>
<li>一个称为 <code>full</code>，用来记录充满的缓冲槽数目,初始化为 0；</li>
<li>一个称为 <code>empty</code>，记录空的缓冲槽数目,初始化为缓冲区中插槽数；</li>
<li>一个称为 <code>mutex</code>，用来确保生产者和消费者不会同时进入缓冲区,mutex 初始化为 1</li>
</ul>
<p>信号量初始化为 1 并且由两个或多个进程使用，以确保它们中同时只有一个可以进入临界区的信号被称为 <code>二进制信号量(binary semaphores)</code>。如果每个进程都在进入临界区之前执行 down 操作，而在离开临界区之后执行 up 操作，则可以确保相互互斥。</p>
<p>现在我们有了一个好的进程间原语的保证。然后我们再来看一下中断的顺序保证</p>
<ol>
<li>硬件压入堆栈程序计数器等</li>
<li>硬件从中断向量装入新的程序计数器</li>
<li>汇编语言过程保存寄存器的值</li>
<li>汇编语言过程设置新的堆栈</li>
<li>C 中断服务器运行（典型的读和缓存写入）</li>
<li>调度器决定下面哪个程序先运行</li>
<li>C 过程返回至汇编代码</li>
<li>汇编语言过程开始运行新的当前进程</li>
</ol>
<p>在使用<code>信号量</code>的系统中，隐藏中断的自然方法是让每个 I/O 设备都配备一个信号量，该信号量最初设置为0。在 I/O 设备启动后，中断处理程序立刻对相关联的信号执行一个 <code>down</code> 操作，于是进程立即被阻塞。当中断进入时，中断处理程序随后对相关的信号量执行一个 <code>up</code>操作，能够使已经阻止的进程恢复运行。在上面的中断处理步骤中，其中的第 5 步 <code>C 中断服务器运行</code> 就是中断处理程序在信号量上执行的一个 up 操作，所以在第 6 步中，操作系统能够执行设备驱动程序。当然，如果有几个进程已经处于就绪状态，调度程序可能会选择接下来运行一个更重要的进程，我们会在后面讨论调度的算法。</p>
<p>上面的代码实际上是通过两种不同的方式来使用信号量的，而这两种信号量之间的区别也是很重要的。<code>mutex</code> 信号量用于互斥。它用于确保任意时刻只有一个进程能够对缓冲区和相关变量进行读写。互斥是用于避免进程混乱所必须的一种操作。</p>
<p>另外一个信号量是关于<code>同步(synchronization)</code>的。<code>full</code> 和 <code>empty</code> 信号量用于确保事件的发生或者不发生。在这个事例中，它们确保了缓冲区满时生产者停止运行；缓冲区为空时消费者停止运行。这两个信号量的使用与 mutex 不同。</p>
<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>如果不需要信号量的计数能力时，可以使用信号量的一个简单版本，称为 <code>mutex(互斥量)</code>。互斥量的优势就在于在一些共享资源和一段代码中保持互斥。由于互斥的实现既简单又有效，这使得互斥量在实现用户空间线程包时非常有用。</p>
<p>互斥量是一个处于<strong>两种状态之一的共享变量</strong>：<code>解锁(unlocked)</code> 和 <code>加锁(locked)</code>。这样，只需要一个二进制位来表示它，不过一般情况下，通常会用一个 <code>整形(integer)</code> 来表示。0 表示解锁，其他所有的值表示加锁，比 1 大的值表示加锁的次数。</p>
<p>mutex 使用两个过程，当一个线程（或者进程）需要访问临界区时，会调用 <code>mutex_lock</code> 进行加锁。如果互斥锁当前处于解锁状态（表示临界区可用），则调用成功，并且调用线程可以自由进入临界区。</p>
<p>另一方面，如果 mutex 互斥量已经锁定的话，<strong>调用线程会阻塞</strong>直到临界区内的线程执行完毕并且调用了 <code>mutex_unlock</code> 。<strong>如果多个线程在 mutex 互斥量上阻塞，将随机选择一个线程并允许它获得锁。</strong></p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/23.png" style="zoom:67%;"></p>
<p>由于 mutex 互斥量非常简单，所以只要有 TSL 或者是 XCHG 指令，就可以很容易地在用户空间实现它们。用于用户级线程包的 <code>mutex_lock</code> 和 <code>mutex_unlock</code> 代码如下，XCHG 的本质也一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mutex_lock:</span><br><span class="line">	  | 将互斥信号量复制到寄存器，并将互斥信号量置为1</span><br><span class="line">			TSL REGISTER,MUTEX</span><br><span class="line">      | 互斥信号量是 0 吗？</span><br><span class="line">			CMP REGISTER,#0	</span><br><span class="line">      | 如果互斥信号量为0，它被解锁，所以返回</span><br><span class="line">			JZE ok	</span><br><span class="line">      | 互斥信号正在使用；调度其他线程</span><br><span class="line">			CALL thread_yield	</span><br><span class="line">      | 再试一次</span><br><span class="line">			JMP mutex_lock	</span><br><span class="line">      | 返回调用者，进入临界区</span><br><span class="line">ok: 	RET														</span><br><span class="line"></span><br><span class="line">mutex_unlcok:</span><br><span class="line">	  | 将 mutex 置为 0 </span><br><span class="line">			MOVE MUTEX,#0	</span><br><span class="line">      | 返回调用者</span><br><span class="line">			RET</span><br></pre></td></tr></table></figure>
<p>mutex_lock 的代码和上面 enter_region 的代码很相似，我们可以对比着看一下</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/24.png" style="zoom:67%;"></p>
<p>上面代码最大的区别你看出来了吗？</p>
<ul>
<li>根据上面我们对 TSL 的分析，我们知道，如果 TSL 判断没有进入临界区的进程<strong>会进行无限循环获取锁</strong>，而在 TSL 处理互斥量中，如果 mutex 正在使用，那么<strong>就调度其他线程进行处理</strong>。所以上面最大的区别其实就是在判断 mutex/TSL 之后的处理。</li>
<li>在（用户）线程中，情况有所不同，因为没有时钟来停止运行时间过长的线程。结果是通过忙等待的方式来试图获得锁的线程将永远循环下去，决不会得到锁，因为这个运行的线程不会让其他线程运行从而释放锁，其他线程根本没有获得锁的机会。在后者获取锁失败时，它会调用 <code>thread_yield</code> 将 CPU 放弃给另外一个线程。结果就不会进行忙等待。在该线程下次运行时，它再一次对锁进行测试。</li>
</ul>
<p>上面就是 enter_region 和 mutex_lock 的差别所在。由于 thread_yield 仅仅是一个用户空间的线程调度，所以它的运行非常快捷。这样，<code>mutex_lock</code> 和 <code>mutex_unlock</code> 都不需要任何内核调用。通过使用这些过程，用户线程完全可以实现在用户空间中的同步，这个过程仅仅需要少量的同步。</p>
<p>我们上面描述的互斥量其实是一套调用框架中的指令。从软件角度来说，总是需要更多的特性和同步原语。例如，有时线程包提供一个调用 <code>mutex_trylock</code>，这个调用尝试获取锁或者返回错误码，但是不会进行加锁操作。这就给了调用线程一个灵活性，以决定下一步做什么，是使用替代方法还是等候下去。</p>
<h4 id="Futexes"><a href="#Futexes" class="headerlink" title="Futexes"></a>Futexes</h4><p>随着并行的增加，有效的<code>同步(synchronization)</code>和<code>锁定(locking)</code> 对于性能来说是非常重要的。如果进程等待时间很短，那么<code>自旋锁(Spin lock)</code> 是非常有效；但是如果等待时间比较长，那么这会浪费 CPU 周期。如果进程很多，那么阻塞此进程，<strong>并仅当锁被释放的时候让内核解除阻塞是更有效的方式</strong>。不幸的是，这种方式也会导致另外的问题：它可以在进程竞争频繁的时候运行良好，但是在竞争不是很激烈的情况下内核切换的消耗会非常大，而且更困难的是，预测锁的竞争数量更不容易。</p>
<p>有一种有趣的解决方案是把两者的优点结合起来，提出一种新的思想，称为 <code>futex</code>，或者是 <code>快速用户空间互斥(fast user space mutex)</code>，是不是听起来很有意思？</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/25.png" style="zoom:67%;"></p>
<p><code>futex</code>是 <code>Linux</code> 中的特性实现了<strong>基本的锁定（很像是互斥锁）而且避免了陷入内核</strong>中，因为内核的切换的开销非常大，这样做可以大大提高性能。<code>futex</code>由两部分组成：<strong>内核服务和用户库</strong>。内核服务提供了了一个 <code>等待队列(wait queue)</code> 允许多个进程在锁上排队等待。除非内核明确的对他们解除阻塞，否则它们不会运行。</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/26.png" style="zoom:67%;"></p>
<p>对于一个进程来说，把它放到等待队列需要昂贵的系统调用，这种方式应该被避免。在没有竞争的情况下，<code>futex</code>可以直接在用户空间中工作。这些进程共享一个 32 位<code>整数(integer)</code> 作为公共锁变量。假设锁的初始化为 1，我们认为这时锁已经被释放了。线程通过执行原子性的操作<code>减少并测试(decrement and test)</code> 来抢占锁。<code>decrement and set</code> 是 Linux 中的原子功能，由包裹在 C 函数中的内联汇编组成，并在头文件中进行定义。下一步，线程会检查结果来查看锁是否已经被释放。如果锁现在不是锁定状态，那么刚好我们的线程可以成功抢占该锁。然而，如果锁被其他线程持有，抢占锁的线程不得不等待。在这种情况下，<code>futex</code> 库不会<code>自旋</code>，但是会使用一个系统调用来把线程放在内核中的等待队列中。这样一来，切换到内核的开销已经是合情合理的了，因为线程可以在任何时候阻塞。当线程完成了锁的工作时，它会使用原子性的 <code>增加并测试(increment and test)</code> 释放锁，并检查结果以查看内核等待队列上是否仍阻止任何进程。如果有的话，它会通知内核可以对等待队列中的一个或多个进程解除阻塞。如果没有锁竞争，内核则不需要参与竞争。</p>
<h4 id="Pthreads中的互斥量"><a href="#Pthreads中的互斥量" class="headerlink" title="Pthreads中的互斥量"></a><code>Pthreads</code>中的互斥量</h4><p><code>Pthreads</code>提供了一些功能用来同步线程。最基本的机制是使用互斥量变量，可以锁定和解锁，用来保护每个临界区。希望进入临界区的线程首先要尝试获取 mutex。如果 mutex 没有加锁，线程能够马上进入并且互斥量能够自动锁定，从而阻止其他线程进入。如果 mutex 已经加锁，调用线程会阻塞，直到 mutex 解锁。如果多个线程在相同的互斥量上等待，当互斥量解锁时，只有一个线程能够进入并且重新加锁。这些锁并不是必须的，程序员需要正确使用它们。</p>
<p>下面是与互斥量有关的函数调用</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/27.png" style="zoom:67%;"></p>
<p>向我们想象中的一样，<code>mutex</code>能够被创建和销毁，扮演这两个角色的分别是 <code>Phread_mutex_init</code> 和 <code>Pthread_mutex_destroy</code>。<code>mutex</code>也可以通过 <code>Pthread_mutex_lock</code> 来进行加锁，如果互斥量已经加锁，则会阻塞调用者。还有一个调用<code>Pthread_mutex_trylock</code> 用来尝试对线程加锁，当 <code>mutex</code>已经被加锁时，会返回一个错误代码而不是阻塞调用者。这个调用允许线程有效的进行忙等。最后，<code>Pthread_mutex_unlock</code> 会对 <code>mutex</code> 解锁并且释放一个正在等待的线程。</p>
<p>除了互斥量以外，<code>Pthreads</code> 还提供了第二种同步机制： <code>条件变量(condition variables)</code> 。<code>mutex</code> 可以很好的允许或阻止对临界区的访问。条件变量允许线程由于未满足某些条件而阻塞。绝大多数情况下这两种方法是一起使用的。下面我们进一步来研究线程、互斥量、条件变量之间的关联。</p>
<p>下面再来重新认识一下生产者和消费者问题：一个线程将东西放在一个缓冲区内，由另一个线程将它们取出。如果生产者发现缓冲区没有空槽可以使用了，生产者线程会阻塞起来直到有一个线程可以使用。生产者使用 mutex 来进行原子性检查从而不受其他线程干扰。</p>
<p>但是当发现缓冲区已经满了以后，生产者需要一种方法来<strong>阻塞自己并在以后被唤醒</strong>。这便是条件变量做的工作。</p>
<p>下面是一些与条件变量有关的最重要的 <code>pthread</code> 调用</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/28.png" style="zoom:67%;"></p>
<p>上表中给出了一些调用用来<strong>创建和销毁条件变量</strong>。条件变量上的主要属性是 <code>Pthread_cond_wait</code> 和 <code>Pthread_cond_signal</code>。前者阻塞调用线程，直到其他线程发出信号为止（使用后者调用）。阻塞的线程通常需要<strong>等待唤醒的信号</strong>以此来释放资源或者执行某些其他活动。只有这样阻塞的线程才能继续工作。条件变量允许等待与阻塞原子性的进程。<code>Pthread_cond_broadcast</code> 用来唤醒多个阻塞的、需要等待信号唤醒的线程。</p>
<blockquote>
<p>需要注意的是，条件变量（不像是信号量）不会存在于内存中。如果将一个信号量传递给一个没有线程等待的条件变量，那么这个信号就会丢失，这个需要注意</p>
</blockquote>
<p>下面是一个使用互斥量和条件变量的例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 需要生产的数量 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1000000000	</span></span><br><span class="line"><span class="comment">/* 使用互斥量 */</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> the_mutex;</span><br><span class="line"><span class="comment">/* 使用信号量 */</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> condc,condp;								</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">buffer</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 生产数据 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">producer</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>&#123;								</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= MAX;i++)&#123;</span><br><span class="line">    <span class="comment">/* 缓冲区独占访问，也就是使用 mutex 获取锁 */</span></span><br><span class="line">    pthread_mutex_lock(&amp;the_mutex);				</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">buffer</span> != <span class="number">0</span>)&#123;</span><br><span class="line">      pthread_cond_wait(&amp;condp,&amp;the_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 把他们放在缓冲区中 */</span></span><br><span class="line">    <span class="built_in">buffer</span> = i;			</span><br><span class="line">    <span class="comment">/* 唤醒消费者，向condc发送信号 */</span></span><br><span class="line">    pthread_cond_signal(&amp;condc);	</span><br><span class="line">    <span class="comment">/* 释放缓冲区 */</span></span><br><span class="line">    pthread_mutex_unlock(&amp;the_mutex);			</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 消费数据 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>&#123;								</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= MAX;i++)&#123;</span><br><span class="line">    <span class="comment">/* 缓冲区独占访问，也就是使用 mutex 获取锁 */</span></span><br><span class="line">    pthread_mutex_lock(&amp;the_mutex);				</span><br><span class="line">    <span class="comment">/* 如果当前生产数量为0，那么就阻塞以等待一个信号来唤醒 */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">buffer</span> == <span class="number">0</span>)&#123;</span><br><span class="line">      pthread_cond_wait(&amp;condc,&amp;the_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 把他们从缓冲区中取出 */</span></span><br><span class="line">    <span class="built_in">buffer</span> = <span class="number">0</span>;	</span><br><span class="line">    <span class="comment">/* 唤醒生产者 */</span></span><br><span class="line">    pthread_cond_signal(&amp;condp);</span><br><span class="line">    <span class="comment">/* 释放缓冲区 */</span></span><br><span class="line">    pthread_mutex_unlock(&amp;the_mutex);			</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_exit(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>为了能够编写更加准确无误的程序，Brinch Hansen 和 Hoare 提出了一个更高级的同步原语叫做 <code>管程(monitor)</code>。他们两个人的提案略有不同，通过下面的描述你就可以知道。管程是程序、变量和数据结构等组成的一个集合，它们组成一个特殊的模块或者包。进程可以在任何需要的时候调用管程中的程序，但是它们不能从管程外部访问数据结构和程序。下面展示了一种抽象的，类似 Pascal 语言展示的简洁的管程。不能用 C 语言进行描述，因为管程是语言概念而 C 语言并不支持管程。</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">monitor example</span><br><span class="line">	integer i;</span><br><span class="line">	condition c;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">procedure</span> <span class="title">producer</span><span class="params">()</span>;</span></span><br><span class="line">  ...</span><br><span class="line">	<span class="keyword">end</span>;	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">procedure</span> <span class="title">consumer</span><span class="params">()</span>;</span></span><br><span class="line">	.</span><br><span class="line">	<span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br></pre></td></tr></table></figure>
<p>管程有一个很重要的特性，即在任何时候管程中只能有一个活跃的进程，这一特性使管程能够很方便的实现互斥操作。管程是编程语言的特性，所以编译器知道它们的特殊性，因此可以采用与其他过程调用不同的方法来处理对管程的调用。通常情况下，当进程调用管程中的程序时，该程序的前几条指令会检查管程中是否有其他活跃的进程。如果有的话，调用进程将被挂起，直到另一个进程离开管程才将其唤醒。如果没有活跃进程在使用管程，那么该调用进程才可以进入。</p>
<p>进入管程中的互斥由编译器负责，但是一种通用做法是使用 <code>互斥量(mutex)</code> 和 <code>二进制信号量(binary semaphore)</code>。由于编译器而不是程序员在操作，因此出错的几率会大大降低。在任何时候，编写管程的程序员都无需关心编译器是如何处理的。他只需要知道将所有的临界区转换成为管程过程即可。绝不会有两个进程同时执行临界区中的代码。</p>
<p>即使管程提供了一种简单的方式来实现互斥，但在我们看来，这还不够。因为我们还需要一种在进程无法执行被阻塞。在生产者-消费者问题中，很容易将针对缓冲区满和缓冲区空的测试放在管程程序中，但是生产者在发现缓冲区满的时候该如何阻塞呢？</p>
<p>解决的办法是引入<code>条件变量(condition variables)</code> 以及相关的两个操作 <code>wait</code> 和 <code>signal</code>。当一个管程程序发现它不能运行时（例如，生产者发现缓冲区已满），它会在某个条件变量（如 full）上执行 <code>wait</code> 操作。这个操作造成调用进程阻塞，并且还将另一个以前等在管程之外的进程调入管程。在前面的 pthread 中我们已经探讨过条件变量的实现细节了。另一个进程，比如消费者可以通过执行 <code>signal</code> 来唤醒阻塞的调用进程。</p>
<blockquote>
<p>Brinch Hansen 和 Hoare 在对进程唤醒上有所不同，Hoare 建议让新唤醒的进程继续运行；而挂起另外的进程。而 Brinch Hansen 建议让执行 signal 的进程必须退出管程，这里我们采用 Brinch Hansen 的建议，因为它在概念上更简单，并且更容易实现。</p>
</blockquote>
<p>如果在一个条件变量上有若干进程都在等待，则在对该条件执行 signal 操作后，系统调度程序只能选择其中一个进程恢复运行。</p>
<p>顺便提一下，这里还有上面两位教授没有提出的第三种方式，它的理论是让执行 signal 的进程继续运行，等待这个进程退出管程时，其他进程才能进入管程。</p>
<p>条件变量不是计数器。条件变量也不能像信号量那样积累信号以便以后使用。所以，如果向一个条件变量发送信号，但是该条件变量上没有等待进程，那么信号将会丢失。也就是说，<strong>wait 操作必须在 signal 之前执行</strong>。</p>
<p>下面是一个使用 <code>Pascal</code> 语言通过管程实现的生产者-消费者问题的解法</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">		condition full,empty;</span><br><span class="line">		integer count;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">(item:integer)</span>;</span></span><br><span class="line">		<span class="keyword">begin</span></span><br><span class="line">				<span class="keyword">if</span> count = N <span class="keyword">then</span> wait(full);</span><br><span class="line">				insert_item(item);</span><br><span class="line">				count := count + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> count = <span class="number">1</span> <span class="keyword">then</span> signal(empty);</span><br><span class="line">		<span class="keyword">end</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">remove</span>:</span>integer;</span><br><span class="line">		<span class="keyword">begin</span></span><br><span class="line">				<span class="keyword">if</span> count = <span class="number">0</span> <span class="keyword">then</span> wait(empty);</span><br><span class="line">				remove = remove_item;</span><br><span class="line">				count := count - <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> count = N - <span class="number">1</span> <span class="keyword">then</span> signal(full);</span><br><span class="line">		<span class="keyword">end</span>;</span><br><span class="line">		</span><br><span class="line">		count := <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">producer</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">			<span class="keyword">while</span> true <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">begin</span> </span><br><span class="line">      			item = produce_item;</span><br><span class="line">      			ProducerConsumer.insert(item);</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">consumer</span>;</span></span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">			<span class="keyword">while</span> true <span class="keyword">do</span></span><br><span class="line">			<span class="keyword">begin</span></span><br><span class="line">						item = ProducerConsumer.remove;</span><br><span class="line">						consume_item(item);</span><br><span class="line">			<span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p>读者可能觉得 wait 和 signal 操作看起来像是前面提到的 sleep 和 wakeup ，而且后者存在严重的竞争条件。它们确实很像，但是有个关键的区别：sleep 和 wakeup 之所以会失败是因为当一个进程想睡眠时，另一个进程试图去唤醒它。使用管程则不会发生这种情况。管程程序的自动互斥保证了这一点，如果管程过程中的生产者发现缓冲区已满，它将能够完成 wait 操作而不用担心调度程序可能会在 wait 完成之前切换到消费者。甚至，在 wait 执行完成并且把生产者标志为不可运行之前，是不会允许消费者进入管程的。</p>
<p>尽管类 Pascal 是一种想象的语言，但还是有一些真正的编程语言支持，比如 Java （终于轮到大 Java 出场了），Java 是能够支持管程的，它是一种 <code>面向对象</code>的语言，支持用户级线程，还允许将方法划分为类。只要将关键字 <code>synchronized</code> 关键字加到方法中即可。Java 能够保证一旦某个线程执行该方法，就不允许其他线程执行该对象中的任何 synchronized 方法。没有关键字 synchronized ，就不能保证没有交叉执行。</p>
<p>下面是 Java 使用管程解决的生产者-消费者问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义缓冲区大小的长度</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line">  <span class="comment">// 初始化一个新的生产者线程</span></span><br><span class="line">  <span class="keyword">static</span> Producer p = <span class="keyword">new</span> Producer();</span><br><span class="line">  <span class="comment">// 初始化一个新的消费者线程</span></span><br><span class="line">  <span class="keyword">static</span> Consumer c = <span class="keyword">new</span> Consumer();		</span><br><span class="line">  <span class="comment">// 初始化一个管程</span></span><br><span class="line">  <span class="keyword">static</span> Our_monitor mon = <span class="keyword">new</span> Our_monitor(); </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// run 包含了线程代码</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;												</span><br><span class="line">      <span class="keyword">int</span> item;</span><br><span class="line">      <span class="comment">// 生产者循环</span></span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;														</span><br><span class="line">        item = produce_item();</span><br><span class="line">        mon.insert(item);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生产代码</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">produce_item</span><span class="params">()</span></span>&#123;...&#125;						</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// run 包含了线程代码</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">( )</span> </span>&#123;											</span><br><span class="line">   		<span class="keyword">int</span> item;</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        item = mon.remove();</span><br><span class="line">				consume_item(item);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 消费代码</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">produce_item</span><span class="params">()</span></span>&#123;...&#125;						</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这是管程</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Our_monitor</span> </span>&#123;									</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> buffer[] = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="comment">// 计数器和索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>,lo = <span class="number">0</span>,hi = <span class="number">0</span>;			</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(count == N)&#123;</span><br><span class="line">        <span class="comment">// 如果缓冲区是满的，则进入休眠</span></span><br><span class="line">        go_to_sleep();												</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 向缓冲区插入内容</span></span><br><span class="line">			buffer[hi] = val;					</span><br><span class="line">      <span class="comment">// 找到下一个槽的为止</span></span><br><span class="line">      hi = (hi + <span class="number">1</span>) % N; 				</span><br><span class="line">      <span class="comment">// 缓冲区中的数目自增 1 </span></span><br><span class="line">      count = count + <span class="number">1</span>;											</span><br><span class="line">      <span class="keyword">if</span>(count == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果消费者睡眠，则唤醒</span></span><br><span class="line">        notify();															</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> val;</span><br><span class="line">      <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 缓冲区是空的，进入休眠</span></span><br><span class="line">        go_to_sleep();												</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 从缓冲区取出数据</span></span><br><span class="line">      val = buffer[lo];				</span><br><span class="line">      <span class="comment">// 设置待取出数据项的槽</span></span><br><span class="line">      lo = (lo + <span class="number">1</span>) % N;					</span><br><span class="line">      <span class="comment">// 缓冲区中的数据项数目减 1 </span></span><br><span class="line">      count = count - <span class="number">1</span>;											</span><br><span class="line">      <span class="keyword">if</span>(count = N - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果生产者睡眠，唤醒它</span></span><br><span class="line">        notify();															</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">go_to_sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        wait( );</span><br><span class="line">      &#125;<span class="keyword">catch</span>(Interr uptedExceptionexc) &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中主要设计四个类，<code>外部类(outer class)</code> ProducerConsumer 创建并启动两个线程，p 和 c。第二个类和第三个类 <code>Producer</code> 和 <code>Consumer</code> 分别包含生产者和消费者代码。最后，<code>Our_monitor</code> 是管程，它有两个同步线程，用于在共享缓冲区中插入和取出数据。</p>
<p>在前面的所有例子中，生产者和消费者线程在功能上与它们是相同的。生产者有一个无限循环，该无限循环产生数据并将数据放入公共缓冲区中；消费者也有一个等价的无限循环，该无限循环用于从缓冲区取出数据并完成一系列工作。</p>
<p>程序中比较耐人寻味的就是 <code>Our_monitor</code> 了，它包含缓冲区、管理变量以及两个同步方法。当生产者在 insert 内活动时，它保证消费者不能在 remove 方法中运行，从而保证更新变量以及缓冲区的安全性，并且不用担心竞争条件。变量 count 记录在缓冲区中数据的数量。变量 <code>lo</code> 是缓冲区槽的序号，指出将要取出的下一个数据项。类似地，<code>hi</code> 是缓冲区中下一个要放入的数据项序号。允许 lo = hi，含义是在缓冲区中有 0 个或 N 个数据。</p>
<p>Java 中的同步方法与其他经典管程有本质差别：Java 没有内嵌的条件变量。然而，Java 提供了 wait 和 notify 分别与 sleep 和 wakeup 等价。</p>
<p><strong>通过临界区自动的互斥，管程比信号量更容易保证并行编程的正确性</strong>。但是管程也有缺点，我们前面说到过管程是一个编程语言的概念，编译器必须要识别管程并用某种方式对其互斥作出保证。<strong>C、Pascal 以及大多数其他编程语言都没有管程</strong>，所以不能依靠编译器来遵守互斥规则。</p>
<p>与管程和信号量有关的另一个问题是，这些机制都是设计用来解决访问共享内存的一个或多个 CPU 上的互斥问题的。通过将信号量放在共享内存中并用 <code>TSL</code> 或 <code>XCHG</code> 指令来保护它们，可以避免竞争。但是如果是在分布式系统中，可能同时具有多个 CPU 的情况，并且每个 CPU 都有自己的私有内存呢，它们通过网络相连，那么这些原语将会失效。因为信号量太低级了，而管程在少数几种编程语言之外无法使用，所以还需要其他方法。</p>
<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p>上面提到的其他方法就是 <code>消息传递(messaage passing)</code>。这种进程间通信的方法使用两个原语 <code>send</code> 和 <code>receive</code> ，它们像信号量而不像管程，是系统调用而不是语言级别。示例如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">send(destination, &amp;message);</span><br><span class="line"></span><br><span class="line">receive(source, &amp;message);</span><br></pre></td></tr></table></figure>
<p>send 方法用于向一个给定的目标发送一条消息，receive 从一个给定的源接受一条消息。如果没有消息，接受者可能被阻塞，直到接受一条消息或者带着错误码返回。</p>
<h4 id="消息传递系统的设计要点"><a href="#消息传递系统的设计要点" class="headerlink" title="消息传递系统的设计要点"></a>消息传递系统的设计要点</h4><p>消息传递系统现在面临着许多信号量和管程所未涉及的问题和设计难点，尤其对那些在网络中不同机器上的通信状况。例如，消息有可能被网络丢失。为了防止消息丢失，发送方和接收方可以达成一致：一旦接受到消息后，接收方马上回送一条特殊的 <code>确认(acknowledgement)</code> 消息。如果发送方在一段时间间隔内未收到确认，则重发消息。</p>
<p>现在考虑消息本身被正确接收，而返回给发送着的确认消息丢失的情况。发送者将重发消息，这样接受者将收到两次相同的消息。</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/29.png" style="zoom:67%;"></p>
<p>对于接收者来说，如何区分新的消息和一条重发的老消息是非常重要的。通常采用在每条原始消息中嵌入一个连续的序号来解决此问题。如果接受者收到一条消息，它具有与前面某一条消息一样的序号，就知道这条消息是重复的，可以忽略。</p>
<p>消息系统还必须处理如何命名进程的问题，以便在发送或接收调用中清晰的指明进程。<code>身份验证(authentication)</code> 也是一个问题，比如客户端怎么知道它是在与一个真正的文件服务器通信，从发送方到接收方的信息有可能被中间人所篡改。</p>
<h4 id="用消息传递解决生产者-消费者问题"><a href="#用消息传递解决生产者-消费者问题" class="headerlink" title="用消息传递解决生产者-消费者问题"></a>用消息传递解决生产者-消费者问题</h4><p>现在我们考虑如何使用消息传递来解决生产者-消费者问题，而不是共享缓存。下面是一种解决方式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* buffer 中槽的数量 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100													</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> item;</span><br><span class="line">  <span class="comment">/* buffer 中槽的数量 */</span></span><br><span class="line">  message m;													</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">    <span class="comment">/* 生成放入缓冲区的数据 */</span></span><br><span class="line">    item = produce_item();						</span><br><span class="line">    <span class="comment">/* 等待消费者发送空缓冲区 */</span></span><br><span class="line">    receive(consumer,&amp;m);							</span><br><span class="line">    <span class="comment">/* 建立一个待发送的消息 */</span></span><br><span class="line">    build_message(&amp;m,item);						</span><br><span class="line">    <span class="comment">/* 发送给消费者 */</span></span><br><span class="line">    send(consumer,&amp;m);								</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> item,i;</span><br><span class="line">  message m;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 循环N次 */</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)&#123;						</span><br><span class="line">    <span class="comment">/* 发送N个缓冲区 */</span></span><br><span class="line">    send(producer,&amp;m);								</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">    <span class="comment">/* 接受包含数据的消息 */</span></span><br><span class="line">    receive(producer,&amp;m);							</span><br><span class="line">    <span class="comment">/* 将数据从消息中提取出来 */</span></span><br><span class="line">  	item = extract_item(&amp;m);					</span><br><span class="line">    <span class="comment">/* 将空缓冲区发送回生产者 */</span></span><br><span class="line">    send(producer,&amp;m);								</span><br><span class="line">    <span class="comment">/* 处理数据 */</span></span><br><span class="line">    consume_item(item);								</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设所有的消息都有相同的大小，并且在尚未接受到发出的消息时，由操作系统自动进行缓冲。在该解决方案中共使用 N 条消息，这就类似于一块共享内存缓冲区的 N 个槽。消费者首先将 N 条空消息发送给生产者。当生产者向消费者传递一个数据项时，它取走一条空消息并返回一条填充了内容的消息。通过这种方式，系统中总的消息数量保持不变，所以消息都可以存放在事先确定数量的内存中。</p>
<p>如果生产者的速度要比消费者快，则所有的消息最终都将被填满，等待消费者，生产者将被阻塞，等待返回一条空消息。如果消费者速度快，那么情况将正相反：所有的消息均为空，等待生产者来填充，消费者将被阻塞，以等待一条填充过的消息。</p>
<p>消息传递的方式有许多变体，下面先介绍如何对消息进行 <code>编址</code>。</p>
<ul>
<li>一种方法是为每个进程分配一个唯一的地址，让消息按进程的地址编址。</li>
<li>另一种方式是引入一个新的数据结构，称为 <code>信箱(mailbox)</code>，信箱是一个用来对一定的数据进行缓冲的数据结构，信箱中消息的设置方法也有多种，典型的方法是在信箱创建时确定消息的数量。在使用信箱时，在 send 和 receive 调用的地址参数就是信箱的地址，而不是进程的地址。当一个进程试图向一个满的信箱发送消息时，它将被挂起，直到信箱中有消息被取走，从而为新的消息腾出地址空间。</li>
</ul>
<h3 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h3><p>最后一个同步机制是准备用于进程组而不是进程间的生产者-消费者情况的。在某些应用中划分了若干阶段，并且规定，除非所有的进程都就绪准备着手下一个阶段，否则任何进程都不能进入下一个阶段，可以通过在每个阶段的结尾安装一个 <code>屏障(barrier)</code> 来实现这种行为。当一个进程到达屏障时，它会被屏障所拦截，直到所有的屏障都到达为止。屏障可用于一组进程同步，如下图所示</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/30.png" style="zoom:67%;"></p>
<p>在上图中我们可以看到，有四个进程接近屏障，这意味着每个进程都在进行运算，但是还没有到达每个阶段的结尾。过了一段时间后，A、B、D 三个进程都到达了屏障，各自的进程被挂起，但此时还不能进入下一个阶段呢，因为进程 B 还没有执行完毕。结果，当最后一个 C 到达屏障后，这个进程组才能够进入下一个阶段。</p>
<h3 id="避免锁：读-复制-更新"><a href="#避免锁：读-复制-更新" class="headerlink" title="避免锁：读-复制-更新"></a>避免锁：读-复制-更新</h3><p>最快的锁是根本没有锁。问题在于没有锁的情况下，我们是否允许对共享数据结构的并发读写进行访问。答案当然是不可以。假设进程 A 正在对一个数字数组进行排序，而进程 B 正在计算其平均值，而此时你进行 A 的移动，会导致 B 会多次读到重复值，而某些值根本没有遇到过。</p>
<p>然而，在某些情况下，我们可以允许写操作来更新数据结构，即便还有其他的进程正在使用。窍门在于确保每个读操作要么读取旧的版本，要么读取新的版本，例如下面的树</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/31.png" style="zoom:67%;"></p>
<p>上面的树中，读操作从根部到叶子遍历整个树。加入一个新节点 X 后，为了实现这一操作，我们要让这个节点在树中可见之前使它”恰好正确”：我们对节点 X 中的所有值进行初始化，包括它的子节点指针。然后通过原子写操作，使 X 称为 A 的子节点。所有的读操作都不会读到前后不一致的版本</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/32.png" style="zoom:67%;"></p>
<p>在上面的图中，我们接着移除 B 和 D。首先，将 A 的左子节点指针指向 C 。所有原本在 A 中的读操作将会后续读到节点 C ，而永远不会读到 B 和 D。也就是说，它们将只会读取到新版数据。同样，所有当前在 B 和 D 中的读操作将继续按照原始的数据结构指针并且读取旧版数据。所有操作均能正确运行，我们不需要锁住任何东西。而不需要锁住数据就能够移除 B 和 D 的主要原因就是 <code>读-复制-更新(Ready-Copy-Update,RCU)</code>，将更新过程中的移除和再分配过程分离开。</p>
<h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p>当一个计算机是多道程序设计系统时，会频繁的有很多进程或者线程来同时竞争 CPU 时间片。当两个或两个以上的进程/线程处于就绪状态时，就会发生这种情况。如果只有一个 CPU 可用，那么必须选择接下来哪个进程/线程可以运行。操作系统中有一个叫做 <code>调度程序(scheduler)</code> 的角色存在，它就是做这件事儿的，该程序使用的算法叫做 <code>调度算法(scheduling algorithm)</code> 。</p>
<p>尽管有一些不同，但许多适用于进程调度的处理方法同样也适用于线程调度。当内核管理线程的时候，调度通常会以线程级别发生，很少或者根本不会考虑线程属于哪个进程。下面我们会首先专注于进程和线程的调度问题，然后会明确的介绍线程调度以及它产生的问题。</p>
<h3 id="调度介绍"><a href="#调度介绍" class="headerlink" title="调度介绍"></a>调度介绍</h3><p>让我们回到早期以磁带上的卡片作为输入的批处理系统的时代，那时候的调度算法非常简单：依次运行磁带上的每一个作业。对于多道程序设计系统，会复杂一些，因为通常会有多个用户在等待服务。一些大型机仍然将 <code>批处理</code>和 <code>分时服务</code>结合使用，需要调度程序决定下一个运行的是一个批处理作业还是终端上的用户。由于在这些机器中 CPU 是稀缺资源，所以好的调度程序可以在提高性能和用户的满意度方面取得很大的成果。</p>
<h4 id="进程行为"><a href="#进程行为" class="headerlink" title="进程行为"></a>进程行为</h4><p>几乎所有的进程（磁盘或网络）I/O 请求和计算都是交替运行的</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/33.png" style="zoom:67%;"></p>
<p>如上图所示，CPU 不停顿的运行一段时间，然后发出一个系统调用等待 I/O 读写文件。完成系统调用后，CPU 又开始计算，直到它需要读更多的数据或者写入更多的数据为止。当一个进程等待外部设备完成工作而被阻塞时，才是 I/O 活动。</p>
<p>上面 a 是 CPU 密集型进程；b 是 I/O 密集型进程进程，a 因为在计算的时间上花费时间更长，因此称为<code>计算密集型(compute-bound)</code> 或者 <code>CPU 密集型(CPU-bound)</code>，b 因为I/O 发生频率比较快因此称为 <code>I/O 密集型(I/O-bound)</code>。计算密集型进程有较长的 CPU 集中使用和较小频度的 I/O 等待。I/O 密集型进程有较短的 CPU 使用时间和较频繁的 I/O 等待。注意到上面两种进程的区分关键在于 CPU 的时间占用而不是 I/O 的时间占用。I/O 密集型的原因是因为它们没有在 I/O 之间花费更多的计算、而不是 I/O 请求时间特别长。无论数据到达后需要花费多少时间，它们都需要花费相同的时间来发出读取磁盘块的硬件请求。</p>
<p>值得注意的是，随着 CPU 的速度越来越快，更多的进程倾向于 I/O 密集型。这种情况出现的原因是 CPU 速度的提升要远远高于硬盘。这种情况导致的结果是，未来对 I/O 密集型进程的调度处理似乎更为重要。这里的基本思想是，如果需要运行 I/O 密集型进程，那么就应该让它尽快得到机会，以便发出磁盘请求并保持磁盘始终忙碌。</p>
<h4 id="何时调度"><a href="#何时调度" class="headerlink" title="何时调度"></a>何时调度</h4><p>第一个和调度有关的问题是<code>何时进行调度决策</code>。存在着需要调度处理的各种情形。首先，在创建一个新进程后，需要决定是运行父进程还是子进程。因为二者的进程都处于就绪态下，这是正常的调度决策，可以任意选择，也就是说，调度程序可以任意的选择子进程或父进程开始运行。</p>
<p>第二，在进程退出时需要作出调度决定。因为此进程不再运行（因为它将不再存在），因此必须从就绪进程中选择其他进程运行。如果没有进程处于就绪态，系统提供的<code>空闲进程</code>通常会运行</p>
<p><strong>什么是空闲进程</strong></p>
<p><code>空闲进程(system-supplied idle process)</code> 是 Microsoft 公司 windows 操作系统带有的系统进程，该进程是在各个处理器上运行的单个线程，它唯一的任务是在系统没有处理其他线程时占用处理器时间。System Idle Process 并不是一个真正的进程，它是<code>核心虚拟</code>出来的，多任务操作系统都存在。在没有可用的进程时，系统处于空运行状态，此时就是System Idle Process 在正在运行。你可以简单的理解成，它代表的是 CPU 的空闲状态，数值越大代表处理器越空闲，可以通过 Windows 任务管理器查看 Windows 中的 CPU 利用率</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/34.png" style="zoom:67%;"></p>
<p>第三种情况是，当进程阻塞在 I/O 、信号量或其他原因时，必须选择另外一个进程来运行。有时，阻塞的原因会成为选择进程运行的关键因素。例如，如果 A 是一个重要进程，并且它正在等待 B 退出临界区，让 B 退出临界区从而使 A 得以运行。但是调度程序一般不会对这种情况进行考量。</p>
<p>第四点，当 I/O 中断发生时，可以做出调度决策。如果中断来自 I/O 设备，而 I/O 设备已经完成了其工作，那么那些等待 I/O 的进程现在可以继续运行。由调度程序来决定是否准备运行新的进程还是重新运行已经中断的进程。</p>
<p>如果硬件时钟以 50 或 60 Hz 或其他频率提供周期性中断，可以在每个时钟中断或第 k 个时钟中断处做出调度决策。根据如何处理时钟中断可以把调度算法可以分为两类。<code>非抢占式(nonpreemptive)</code> 调度算法挑选一个进程，让该进程运行直到被阻塞（阻塞在 I/O 上或等待另一个进程），或者直到该进程自动释放 CPU。即使该进程运行了若干个小时后，它也不会被强制挂起。这样会在时钟中断发生时不会进行调度。在处理完时钟中断后，如果没有更高优先级的进程等待，则被中断的进程会继续执行。</p>
<p>另外一种情况是 <code>抢占式</code> 调度算法，它会选择一个进程，并使其在最大固定时间内运行。如果在时间间隔结束后仍在运行，这个进程会被挂起，调度程序会选择其他进程来运行（前提是存在就绪进程）。进行抢占式调度需要在时间间隔结束时发生时钟中断，以将 CPU 的控制权交还给调度程序。如果没有可用的时钟，那么非抢占式就是唯一的选择。</p>
<h4 id="调度算法的分类"><a href="#调度算法的分类" class="headerlink" title="调度算法的分类"></a>调度算法的分类</h4><p>毫无疑问，不同的环境下需要不同的调度算法。之所以出现这种情况，是因为不同的应用程序和不同的操作系统有不同的目标。也就是说，在不同的系统中，调度程序的优化也是不同的。这里有必要划分出三种环境</p>
<ul>
<li><code>批处理(Batch)</code></li>
<li><code>交互式(Interactive)</code></li>
<li><code>实时(Real time)</code></li>
</ul>
<p>批处理系统广泛应用于商业领域，比如用来处理工资单、存货清单、账目收入、账目支出、利息计算、索赔处理和其他周期性作业。在批处理系统中，一般会选择使用<strong>非抢占式算法</strong>或者<strong>周期性比较长的抢占式算法</strong>。这种方法可以减少线程切换因此能够提升性能。 </p>
<p>在交互式用户环境中，为了避免一个进程霸占 CPU 拒绝为其他进程服务，所以需要<strong>抢占式算法</strong>。即使没有进程有意要一直运行下去，但是，由于某个进程出现错误也有可能无限期的排斥其他所有进程。为了避免这种情况，抢占式也是必须的。服务器也属于此类别，因为它们通常为多个（远程）用户提供服务，而这些用户都非常着急。计算机用户总是很忙。</p>
<p>在实时系统中，抢占有时是不需要的，因为进程知道自己可能运行不了很长时间，通常很快的做完自己的工作并阻塞。实时系统与交互式系统的差别是，实时系统只运行那些用来推进现有应用的程序，而交互式系统是通用的，它可以运行任意的非协作甚至是有恶意的程序。</p>
<h4 id="调度算法的目标"><a href="#调度算法的目标" class="headerlink" title="调度算法的目标"></a>调度算法的目标</h4><p>为了设计调度算法，有必要考虑一下什么是好的调度算法。有一些目标取决于环境（批处理、交互式或者实时）但大部分是适用于所有情况的，下面是一些需要考量的因素，我们会在下面一起讨论。</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/35.png" style="zoom:67%;"></p>
<p><strong>所有系统</strong></p>
<p>在所有的情况中，<code>公平</code>是很重要的。对一个进程给予相较于其他等价的进程更多的 CPU 时间片对其他进程来说是不公平的。当然，不同类型的进程可以采用不同的处理方式。</p>
<p>与公平有关的是系统的<code>强制执行</code>，什么意思呢？如果某公司的薪资发放系统计划在本月的15号，那么碰上了疫情大家生活都很拮据，此时老板说要在14号晚上发放薪资，那么调度程序必须强制使进程执行 14 号晚上发放薪资的策略。</p>
<p>另一个共同的目标是保持系统的<code>所有部分尽可能的忙碌</code>。如果 CPU 和所有的 I/O 设备能够一直运行，那么相对于让某些部件空转而言，每秒钟就可以完成更多的工作。例如，在批处理系统中，调度程序控制哪个作业调入内存运行。在内存中既有一些 CPU 密集型进程又有一些 I/O 密集型进程是一个比较好的想法，好于先调入和运行所有的 CPU 密集型作业，然后在它们完成之后再调入和运行所有 I/O 密集型作业的做法。使用后者这种方式会在 CPU 密集型进程启动后，争夺 CPU ，而磁盘却在空转，而当 I/O 密集型进程启动后，它们又要为磁盘而竞争，CPU 却又在空转。。。。。。显然，通过结合 I/O 密集型和 CPU 密集型，能够使整个系统运行更流畅，效率更高。</p>
<p><strong>批处理系统</strong></p>
<p>通常有三个指标来衡量系统工作状态：<strong>吞吐量、周转时间和 CPU 利用率</strong>，<code>吞吐量(throughout)</code> 是系统每小时完成的作业数量。综合考虑，每小时完成 50 个工作要比每小时完成 40 个工作好。<code>周转时间(Turnaround time)</code> 是一种平均时间，它指的是从一个批处理提交开始直到作业完成时刻为止平均时间。该数据度量了用户要得到输出所需的平均等待时间。周转时间越小越好。</p>
<p><code>CPU 利用率(CPU utilization)</code> 通常作为批处理系统上的指标。即使如此， CPU 利用率也不是一个好的度量指标，真正有价值的衡量指标是系统每小时可以完成多少作业（吞吐量），以及完成作业需要多长时间（周转时间）。把 CPU 利用率作为度量指标，就像是引擎每小时转动了多少次来比较汽车的性能一样。而且知道 CPU 的利用率什么时候接近 100% 要比什么什么时候要求得到更多的计算能力要有用。</p>
<p><strong>交互式系统</strong></p>
<p>对于交互式系统，则有不同的指标。最重要的是尽量<code>减少响应时间</code>。这个时间说的是从执行指令开始到得到结果的时间。再有后台进程运行（例如，从网络上读取和保存 E-mail 文件）的个人计算机上，用户请求启动一个程序或打开一个文件应该优先于后台的工作。能够让所有的交互式请求首先运行的就是一个好的服务。</p>
<p>一个相关的问题是 <code>均衡性(proportionality)</code>，用户对做一件事情需要多长时间总是有一种固定（不过通常不正确）的看法。当认为一个请求很复杂需要较多时间时，用户会认为很正常并且可以接受，但是一个很简单的程序却花费了很长的运行时间，用户就会很恼怒。可以拿彩印和复印来举出一个简单的例子，彩印可能需要1分钟的时间，但是用户觉得复杂并且愿意等待一分钟，相反，复印很简单只需要 5 秒钟，但是复印机花费 1 分钟却没有完成复印操作，用户就会很焦躁。</p>
<p><strong>实时系统</strong></p>
<p>实时系统则有着和交互式系统不同的考量因素，因此也就有不同的调度目标。实时系统的特点是<code>必须满足最后的截止时间</code>。例如，如果计算机控制着以固定速率产生数据的设备，未能按时运行的话可能会导致数据丢失。因此，实时系统中最重要的需求是满足所有（或大多数）时间期限。</p>
<p>在一些实事系统中，特别是涉及到多媒体的，<code>可预测性很重要</code>。偶尔不能满足最后的截止时间不重要，但是如果音频多媒体运行不稳定，声音质量会持续恶化。视频也会造成问题，但是耳朵要比眼睛敏感很多。为了避免这些问题，进程调度必须能够高度可预测的而且是有规律的。</p>
<h3 id="批处理中的调度"><a href="#批处理中的调度" class="headerlink" title="批处理中的调度"></a>批处理中的调度</h3><p>现在让我们把目光从一般性的调度转换为特定的调度算法。下面我们会探讨在批处理中的调度。</p>
<h4 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h4><p>也就是FIFO，可能最简单的非抢占式调度算法的设计就是 <code>先来先服务(first-come,first-serverd)</code>。使用此算法，将按照请求顺序为进程分配 CPU。最基本的，会有一个就绪进程的等待队列。当第一个任务从外部进入系统时，将会立即启动并允许运行任意长的时间。它不会因为运行时间太长而中断。当其他作业进入时，它们排到就绪队列尾部。当正在运行的进程阻塞，处于等待队列的第一个进程就开始运行。当一个阻塞的进程重新处于就绪态时，它会像一个新到达的任务，会排在队列的末尾，即排在所有进程最后。</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/36.png" style="zoom:67%;"></p>
<p>这个算法的强大之处在于<strong>易于理解和编程</strong>，在这个算法中，一个单链表记录了所有就绪进程。要选取一个进程运行，只要从该队列的头部移走一个进程即可；要添加一个新的作业或者阻塞一个进程，只要把这个作业或进程附加在队列的末尾即可。这是很简单的一种实现。</p>
<p>不过，先来先服务也是有缺点的，那就是<strong>没有优先级的关系</strong>，试想一下，如果有 100 个 I/O 进程正在排队，第 101 个是一个 CPU 密集型进程，那岂不是需要等 100 个 I/O 进程运行完毕才会等到一个 CPU 密集型进程运行，这在实际情况下根本不可能，所以需要优先级或者抢占式进程的出现来优先选择重要的进程运行。</p>
<h4 id="最短作业优先"><a href="#最短作业优先" class="headerlink" title="最短作业优先"></a>最短作业优先</h4><p>批处理中，第二种调度算法是 <code>最短作业优先(Shortest Job First)</code>，我们假设运行时间已知。例如，一家保险公司，因为每天要做类似的工作，所以人们可以相当精确地预测处理 1000 个索赔的一批作业需要多长时间。当输入队列中有若干个同等重要的作业被启动时，调度程序应使用最短优先作业算法</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/37.png" style="zoom:67%;"></p>
<p>如上图 a 所示，这里有 4 个作业 A、B、C、D ，运行时间分别为 8、4、4、4 分钟。若按图中的次序运行，则 A 的周转时间为 8 分钟，B 为 12 分钟，C 为 16 分钟，D 为 20 分钟，<strong>平均时间内为 14 分钟</strong></p>
<p>现在考虑使用最短作业优先算法运行 4 个作业，如上图 b 所示，目前的周转时间分别为 4、8、12、20，平均为 11 分钟，可以证明最短作业优先是最优的。考虑有 4 个作业的情况，其运行时间分别为 a、b、c、d。第一个作业在时间 a 结束，第二个在时间 a + b 结束，以此类推。平均周转时间为 (4a + 3b + 2c + d) / 4 。显然 a 对平均值的影响最大，所以 a 应该是最短优先作业，其次是 b，然后是 c ，最后是 d 它就只能影响自己的周转时间了。</p>
<blockquote>
<p>需要注意的是，在所有的进程都可以运行的情况下，最短作业优先的算法才是最优的。</p>
</blockquote>
<h4 id="最短剩余时间优先"><a href="#最短剩余时间优先" class="headerlink" title="最短剩余时间优先"></a>最短剩余时间优先</h4><p>最短作业优先的抢占式版本被称作为 <code>最短剩余时间优先(Shortest Remaining Time Next)</code> 算法。使用这个算法，调度程序总是选择剩余运行时间最短的那个进程运行。当一个新作业到达时，其整个时间同当前进程的剩余时间做比较。如果新的进程比当前运行进程需要更少的时间，当前进程就被挂起，而运行新的进程。这种方式能够使短期作业获得良好的服务。</p>
<h3 id="交互式系统中的调度"><a href="#交互式系统中的调度" class="headerlink" title="交互式系统中的调度"></a>交互式系统中的调度</h3><p>交互式系统中在个人计算机、服务器和其他系统中都是很常用的，所以有必要来探讨一下交互式调度</p>
<h4 id="轮询调度"><a href="#轮询调度" class="headerlink" title="轮询调度"></a>轮询调度</h4><p>一种最古老、最简单、最公平并且最广泛使用的算法就是 <code>轮询算法(round-robin)</code>。每个进程都会被分配一个时间段，称为<code>时间片(quantum)</code>，在这个时间片内允许进程运行。如果时间片结束时进程还在运行的话，则抢占一个 CPU 并将其分配给另一个进程。如果进程在时间片结束前阻塞或结束，则 CPU 立即进行切换。轮询算法比较容易实现。调度程序所做的就是维护一个可运行进程的列表，就像下图中的 a，当一个进程用完时间片后就被移到队列的末尾，就像下图的 b。</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/38.png" style="zoom:67%;"></p>
<p>时间片轮询调度中唯一有意思的一点就是<strong>时间片的长度</strong>。从一个进程切换到另一个进程需要一定的时间进行管理处理，包括保存寄存器的值和内存映射、更新不同的表格和列表、清除和重新调入内存高速缓存等。这种切换称作 <code>进程间切换(process switch)</code> 和 <code>上下文切换(context switch)</code>。如果进程间的切换时间需要 1ms，其中包括内存映射、清除和重新调入高速缓存等，再假设时间片设为 4 ms，那么 CPU 在做完 4 ms 有用的工作之后，CPU 将花费 1 ms 来进行进程间的切换。因此，CPU 的时间片会浪费 20% 的时间在管理开销上。耗费巨大。</p>
<p>为了提高 CPU 的效率，我们把时间片设置为 100 ms。现在时间的浪费只有 1%。但是考虑会发现下面的情况，如果在一个非常短的时间内到达 50 个请求，并且对 CPU 有不同的需求，此时会发生什么？50 个进程都被放在可运行进程列表中。如果 CPU 是空闲的，第一个进程会立即开始执行，第二个直到 100 ms 以后才会启动，以此类推。不幸的是最后一个进程需要等待 5 秒才能获得执行机会。大部分用户都会觉得对于一个简短的指令运行 5 秒中是很慢的。如果队列末尾的某些请求只需要几号秒钟的运行时间的话，这种设计就非常糟糕了。</p>
<p>另外一个因素是如果时间片设置长度要大于 CPU 使用长度，那么抢占就不会经常发生。相反，在时间片用完之前，大多数进程都已经阻塞了，那么就会引起进程间的切换。消除抢占可提高性能，因为进程切换仅在逻辑上必要时才发生，即流程阻塞且无法继续时才发生。</p>
<p>结论可以表述如下：<strong>将上下文切换时间设置得太短会导致过多的进程切换并降低 CPU 效率，但设置时间太长会导致一个短请求很长时间得不到响应。最好的切换时间是在 20 - 50 毫秒之间设置。</strong></p>
<h4 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h4><p>轮询调度假设了所有的进程是同等重要的。但事实情况可能不是这样。例如，在一所大学中的等级制度，首先是院长，然后是教授、秘书、后勤人员，最后是学生。这种将外部情况考虑在内就实现了<code>优先级调度(priority scheduling)</code></p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/39.png" style="zoom:67%;"></p>
<p>它的基本思想很明确，每个进程都被赋予一个优先级，优先级高的进程优先运行。</p>
<p>但是也不意味着高优先级的进程能够永远一直运行下去，调度程序会在每个时钟中断期间降低当前运行进程的优先级。如果此操作导致其优先级降低到下一个最高进程的优先级以下，则会发生进程切换。或者，可以为每个进程分配允许运行的最大时间间隔。当时间间隔用完后，下一个高优先级的进程会得到运行的机会。</p>
<p>可以静态或者动态的为进程分配优先级。在一台军用计算机上，可以把将军所启动的进程设为优先级 100，上校为 90 ，少校为 80，上尉为 70，中尉为 60，以此类推。UNIX 中有一条命令为 <code>nice</code> ，它允许用户为了照顾他人而自愿降低自己进程的优先级，但是一般没人用。</p>
<p>优先级也可以由系统动态分配，用于实现某种目的。例如，有些进程为 I/O 密集型，其多数时间用来等待 I/O 结束。当这样的进程需要 CPU 时，应立即分配 CPU，用来启动下一个 I/O 请求，这样就可以在另一个进程进行计算的同时执行 I/O 操作。这类 I/O 密集型进程长时间的等待 CPU 只会造成它长时间占用内存。使 I/O 密集型进程获得较好的服务的一种简单算法是，将其优先级设为 <code>1/f</code>，f 为该进程在上一时间片中所占的部分。一个在 50 ms 的时间片中只使用 1 ms 的进程将获得优先级 50 ，而在阻塞之前用掉 25 ms 的进程将具有优先级 2，而使用掉全部时间片的进程将得到优先级 1。</p>
<p>可以很方便的将一组进程按优先级分成若干类，并且在各个类之间采用优先级调度，而在各类进程的内部采用轮转调度。下面展示了一个四个优先级类的系统</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/40.png" style="zoom:67%;"></p>
<p>它的调度算法主要描述如下：上面存在优先级为 4 类的可运行进程，首先会<strong>按照轮转法</strong>为每个进程运行一个时间片，此时不理会较低优先级的进程。若第 4 类进程为空，则按照轮询的方式运行第三类进程。若第 4 类和第 3 类进程都为空，则按照轮转法运行第 2 类进程。如果不对优先级进行调整，则<strong>低优先级的进程很容易产生饥饿现象。</strong></p>
<h4 id="多级队列"><a href="#多级队列" class="headerlink" title="多级队列"></a>多级队列</h4><p>最早使用优先级调度的系统是 <code>CTSS(Compatible TimeSharing System)</code>。CTSS 是一种兼容分时系统，它有一个问题就是进程切换太慢，其原因是 IBM 7094 内存只能放进一个进程。</p>
<blockquote>
<p>IBM 是哥伦比亚大学计算机中心在 1964 - 1968 年的计算机</p>
</blockquote>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/41.png" style="zoom:67%;"></p>
<p>CTSS 在每次切换前都需要将当前进程换出到磁盘，并从磁盘上读入一个新进程。CTSS 的设计者很快就认识到，为 CPU 密集型进程设置较长的时间片比频繁地分给他们很短的时间要更有效（减少交换次数）。另一方面，如前所述，长时间片的进程又会影响到响应时间，解决办法是设置优先级类。属于最高优先级的进程运行一个时间片，次高优先级进程运行 2 个时间片，再下面一级运行 4 个时间片，以此类推。<strong>当一个进程用完分配的时间片后，它被移到下一类。</strong></p>
<h4 id="最短进程优先"><a href="#最短进程优先" class="headerlink" title="最短进程优先"></a>最短进程优先</h4><p>对于批处理系统而言，由于最短作业优先常常伴随着最短响应时间，所以如果能够把它用于交互式进程，那将是非常好的。在某种程度上，的确可以做到这一点。交互式进程通常遵循下列模式：等待命令、执行命令、等待命令、执行命令。。。如果我们把每个命令的执行都看作一个分离的作业，那么我们可以通过首先运行最短的作业来使响应时间最短。这里唯一的问题是如何从当前可运行进程中找出最短的那一个进程。</p>
<p>一种方式是根据进程过去的行为进行推测，并执行估计运行时间最短的那一个。假设每个终端上每条命令的预估运行时间为 <code>T0</code>，现在假设测量到其下一次运行时间为 <code>T1</code>，可以用两个值的加权来改进估计时间，即<code>aT0+ (1- 1)T1</code>。通过选择 a 的值，可以决定是尽快忘掉老的运行时间，还是在一段长时间内始终记住它们。当 a = 1/2 时，可以得到下面这个序列</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/42.png" style="zoom:67%;"></p>
<p>可以看到，在三轮过后，T0 在新的估计值中所占比重下降至 1/8。</p>
<p>有时把这种通过当前测量值和先前估计值进行加权平均从而得到下一个估计值的技术称作 <code>老化(aging)</code>。这种方法会使用很多预测值基于当前值的情况。</p>
<h4 id="保证调度"><a href="#保证调度" class="headerlink" title="保证调度"></a>保证调度</h4><p>一种完全不同的调度方法是对用户做出明确的性能保证。一种实际而且容易实现的保证是：若用户工作时有 n 个用户登录，则每个用户将获得 CPU 处理能力的 1/n。类似地，在一个有 n 个进程运行的单用户系统中，若所有的进程都等价，则每个进程将获得 1/n 的 CPU 时间。</p>
<h4 id="彩票调度"><a href="#彩票调度" class="headerlink" title="彩票调度"></a>彩票调度</h4><p>对用户进行承诺并在随后兑现承诺是一件好事，不过很难实现。但是存在着一种简单的方式，有一种既可以给出预测结果而又有一种比较简单的实现方式的算法，就是 <code>彩票调度(lottery scheduling)</code>算法。</p>
<p>其基本思想是为进程提供各种系统资源（例如 CPU 时间）的彩票。当做出一个调度决策的时候，就随机抽出一张彩票，拥有彩票的进程将获得该资源。在应用到 CPU 调度时，系统可以每秒持有 50 次抽奖，每个中奖者将获得比如 20 毫秒的 CPU 时间作为奖励。</p>
<p><code>George Orwell</code> 关于 <strong>所有的进程是平等的，但是某些进程能够更平等一些</strong>。一些重要的进程可以给它们额外的彩票，以便增加他们赢得的机会。如果出售了 100 张彩票，而且有一个进程持有了它们中的 20 张，它就会有 20% 的机会去赢得彩票中奖。在长时间的运行中，它就会获得 20% 的CPU。相反，对于优先级调度程序，很难说明拥有优先级 40 究竟是什么意思，这里的规则很清楚，拥有彩票 f 份额的进程大约得到系统资源的 f 份额。</p>
<p>如果希望进程之间协作的话可以交换它们之间的票据。例如，客户端进程给服务器进程发送了一条消息后阻塞，客户端进程可能会把自己所有的票据都交给服务器，来增加下一次服务器运行的机会。当服务完成后，它会把彩票还给客户端让其有机会再次运行。事实上，如果没有客户机，服务器也根本不需要彩票。</p>
<blockquote>
<p>可以把彩票理解为 buff，这个 buff 有 15% 的几率能让你产生 <code>速度之靴</code> 的效果。</p>
</blockquote>
<h4 id="公平分享调度"><a href="#公平分享调度" class="headerlink" title="公平分享调度"></a>公平分享调度</h4><p>到目前为止，我们假设被调度的都是各个进程自身，而不用考虑该进程的拥有者是谁。结果是，如果用户 1 启动了 9 个进程，而用户 2 启动了一个进程，使用轮转或相同优先级调度算法，那么用户 1 将得到 90 % 的 CPU 时间，而用户 2 将之得到 10 % 的 CPU 时间。</p>
<p>为了阻止这种情况的出现，一些系统在调度前会把进程的拥有者考虑在内。在这种模型下，每<strong>个用户都会分配一些CPU 时间</strong>，而调度程序会选择进程并强制执行。因此如果两个用户每个都会有 50% 的 CPU 时间片保证，那么无论一个用户有多少个进程，都将获得相同的 CPU 份额。</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/43.png" style="zoom:67%;"></p>
<h3 id="实时系统中的调度"><a href="#实时系统中的调度" class="headerlink" title="实时系统中的调度"></a>实时系统中的调度</h3><p><code>实时系统(real-time)</code> 是一个时间扮演了重要作用的系统。典型的，一种或多种外部物理设备发给计算机一个服务请求，而计算机必须在一个确定的时间范围内恰当的做出反应。例如，在 CD 播放器中的计算机会获得从驱动器过来的位流，然后必须在非常短的时间内将位流转换为音乐播放出来。如果计算时间过长，那么音乐就会听起来有异常。再比如说医院特别护理部门的病人监护装置、飞机中的自动驾驶系统、列车中的烟雾警告装置等，在这些例子中，正确但是却缓慢的响应要比没有响应甚至还糟糕。</p>
<p>实时系统可以分为两类，<code>硬实时(hard real time)</code> 和 <code>软实时(soft real time)</code> 系统，前者意味着必须要满足绝对的截止时间；后者的含义是虽然不希望偶尔错失截止时间，但是可以容忍。在这两种情形中，实时都是通过把程序划分为一组进程而实现的，其中每个进程的行为是可预测和提前可知的。这些进程一般寿命较短，并且极快的运行完成。在检测到一个外部信号时，调度程序的任务就是按照满足所有截止时间的要求调度进程。</p>
<p>实时系统中的事件可以按照响应方式进一步分类为<code>周期性(以规则的时间间隔发生)</code>事件或 <code>非周期性(发生时间不可预知)</code>事件。一个系统可能要响应多个周期性事件流，根据每个事件处理所需的时间，可能甚至无法处理所有事件。例如，如果有 m 个周期事件，事件 i 以周期 $P_i$ 发生，并需要 $C_i$ 秒 CPU 时间处理一个事件，那么可以处理负载的条件是</p>
<script type="math/tex; mode=display">
\sum_{i=1}^m \frac{C_i}{P_i}\leq 1</script><p>只有满足这个条件的实时系统称为<code>可调度的</code>，这意味着它实际上能够被实现。一个不满足此检验标准的进程不能被调度，因为这些进程共同需要的 CPU 时间总和大于 CPU 能提供的时间。</p>
<p>举一个例子，考虑一个有三个周期性事件的软实时系统，其周期分别是 100 ms、200 m 和 500 ms。如果这些事件分别需要 50 ms、30 ms 和 100 ms 的 CPU 时间，那么该系统时可调度的，因为 0.5 + 0.15 + 0.2 &lt; 1。如果此时有第四个事件加入，其周期为 1 秒，那么此时这个事件如果不超过 150 ms，那么仍然是可以调度的。忽略上下文切换的时间。</p>
<p>实时系统的调度算法可以是静态的或动态的。前者在系统开始运行之前做出调度决策；后者在运行过程中进行调度决策。只有在可以提前掌握所完成的工作以及必须满足的截止时间等信息时，静态调度才能工作，而动态调度不需要这些限制。</p>
<h3 id="调度策略和机制"><a href="#调度策略和机制" class="headerlink" title="调度策略和机制"></a>调度策略和机制</h3><p>到目前为止，我们隐含的假设系统中所有进程属于不同的分组用户并且进程间存在相互竞争 CPU 的情况。通常情况下确实如此，但有时也会发生一个进程会有很多子进程并在其控制下运行的情况。例如，一个数据库管理系统进程会有很多子进程。每一个子进程可能处理不同的请求，或者每个子进程实现不同的功能（如请求分析、磁盘访问等）。主进程完全可能掌握哪一个子进程最重要（或最紧迫），而哪一个最不重要。但是，以上讨论的调度算法中没有一个算法从用户进程接收有关的调度决策信息，这就导致了调度程序很少能够做出最优的选择。</p>
<p>解决问题的办法是将 <code>调度机制(scheduling mechanism)</code> 和 <code>调度策略(scheduling policy)</code> 分开，这是长期一贯的原则。这也就意味着调度算法在某种方式下被参数化了，但是参数可以被用户进程填写。让我们首先考虑数据库的例子。假设内核使用优先级调度算法，并提供了一条可供进程设置优先级的系统调用。这样，尽管父进程本身并不参与调度，但它可以控制如何调度子进程的细节。调度机制位于内核，而调度策略由用户进程决定，调度策略和机制分离是一种关键性思路。</p>
<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>当若干进程都有多个线程时，就存在两个层次的并行：进程和线程。在这样的系统中调度处理有本质的差别，这取决于所支持的是用户级线程还是内核级线程（或两者都支持）。</p>
<p>首先考虑<strong>用户级线程</strong>，由于内核并不知道有线程存在，所以内核还是和以前一样地操作，选取一个进程，假设为 A，并给予 A 以时间片控制。A 中的线程调度程序决定哪个线程运行。假设为 A1。由于多道线程并不存在时钟中断，所以这个线程可以按其意愿任意运行多长时间。如果该线程用完了进程的全部时间片，内核就会选择另一个进程继续运行。</p>
<p>在进程 A 终于又一次运行时，线程 A1 会接着运行。该线程会继续耗费 A 进程的所有时间，直到它完成工作。不过，线程运行不会影响到其他进程。其他进程会得到调度程序所分配的合适份额，不会考虑进程 A 内部发生的事情。</p>
<p>现在考虑 A 线程每次 CPU 计算的工作比较少的情况，例如：在 50 ms 的时间片中有 5 ms 的计算工作。于是，每个线程运行一会儿，然后把 CPU 交回给线程调度程序。这样在内核切换到进程 B 之前，就会有序列 A1,A2,A3,A1,A2,A3,A1,A2,A3,A1 。 如下所示</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/45.png" style="zoom:67%;"></p>
<p>运行时系统使用的调度算法可以是上面介绍算法的任意一种。<strong>从实用方面考虑，轮转调度和优先级调度更为常用</strong>。唯一的局限是，缺乏一个时钟中断运行过长的线程。但由于线程之间的合作关系，这通常也不是问题。</p>
<p>现在考虑使用<strong>内核线程的情况</strong>，内核选择一个特定的线程运行。它不用考虑线程属于哪个进程，不过如果有必要的话，也可以这么做。对被选择的线程赋予一个时间片，而且如果超过了时间片，就会强制挂起该线程。一个线程在 50 ms 的时间片内，5 ms 之后被阻塞，在 30 ms 的时间片中，线程的顺序会是 A1,B1,A2,B2,A3,B3。如下图所示</p>
<p><img src="/2021/05/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B/46.png" style="zoom:67%;"></p>
<p>用户级线程和内核级线程之间的主要差别在于<code>性能</code>。用户级线程的切换需要少量的机器指令（想象一下Java程序的线程切换），而内核线程需要完整的上下文切换，修改内存映像，使高速缓存失效，这会导致了若干数量级的延迟。另一方面，在使用内核级线程时，一旦线程阻塞在 I/O 上就不需要在用户级线程中那样将整个进程挂起。</p>
<p>从进程 A 的一个线程切换到进程 B 的一个线程，其消耗要远高于运行进程 A 的两个线程（涉及修改内存映像，修改高速缓存），内核对这种切换的消耗是了解到，可以通过这些信息作出决定。</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/13/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/%5Bobject%20Object%5D"
                alt="Jason" />
            
              <p class="site-author-name" itemprop="name">Jason</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20fa%20fa-archive">
              
                  <span class="site-state-item-count">435</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">61</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="true"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
 <!--
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>







-->
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>




















  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v="></script>

  <script type="text/javascript" src="/js/src/motion.js?v="></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v="></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
