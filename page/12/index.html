<!DOCTYPE html>
<html lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jasonxqh.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jason‘s Blog">
<meta property="og:url" content="https://jasonxqh.github.io/page/12/index.html">
<meta property="og:site_name" content="Jason‘s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jasonxqh.github.io/page/12/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jason‘s Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jason‘s Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/06/10/%E6%A6%82%E7%8E%87%E8%AE%BA%E7%AC%AC%E5%85%AD%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/10/%E6%A6%82%E7%8E%87%E8%AE%BA%E7%AC%AC%E5%85%AD%E7%AB%A0/" class="post-title-link" itemprop="url">概率论第六章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-06-10 16:34:10" itemprop="dateCreated datePublished" datetime="2021-06-10T16:34:10+08:00">2021-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-16 11:11:26" itemprop="dateModified" datetime="2023-01-16T11:11:26+08:00">2023-01-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概率论第六章-参数估计"><a href="#概率论第六章-参数估计" class="headerlink" title="概率论第六章 参数估计"></a>概率论第六章 参数估计</h1><h2 id="点估计的概念"><a href="#点估计的概念" class="headerlink" title="点估计的概念"></a>点估计的概念</h2><p>首先我们给出<strong>点估计的定义</strong>：</p>
<p>设 $x_1,x_2\cdots,x_n$ 是来自总体的一个样本，用于估计未知参数 $\theta$ 的统计量 $\hat\theta =\hat\theta(x_1,x_2\cdots,x_n)$ 称为$\theta$ 的估计量，或称为 $\theta$ 的点估计。</p>
<p>在这里，如何构造统计量$\hat\theta$ 并没有明确的规定。只要满足一定的合理性(一般指无偏性)即可。</p>
<p>那么，什么是<strong>无偏估计</strong>？ 下面给出其定义</p>
<p>设 $\hat\theta(x_1.x_2\cdots,x_n)$ 是$\theta$ 的一个估计，$\theta$ 的参数空间为$\Theta$ ,若对任意的$\theta\in\Theta$ ，有：</p>
<script type="math/tex; mode=display">
E_\theta(\hat\theta) =\theta</script><p>则称$\hat\theta$是$\theta$的无偏估计，否则就称其为有偏估计。</p>
<p>无偏性也可以改写为 $E_\theta(\hat\theta-\theta)= 0$ , 这表示无偏估计没有系统偏差。</p>
<p>当我们使用 $\hat\theta$ 估计 $\theta$  时，由于样本的随机性，$\theta$ 与 $\hat\theta$ 总是有偏差的。无偏性表示，把这些偏差平均起来其值为0.但是若估计不具有无偏性，则无论使用多少次，其平均也会与参数真值也有一定的距离，这个距离就是系统误差。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li>对任意总体而言，<strong>样本均值 是总体均值的无偏估计</strong>。当总体k阶矩存在时，样本k阶原点矩$a_k$ 是总体k阶矩原点矩$\mu_k$ 的无偏估计。但是对k阶中心距则不一样，比如说样本方差 $s_n^2$ 就不是总体方差 $\sigma^2$ 的无偏估计。因为$E(s_n^2) = \frac{n-1}{n}\sigma^2$ ， 其中 $E(s_n^2)$是经验分布函数的方差。</li>
</ul>
<p>但是我们可以说 $E(s<em>n^2)$是 $\sigma^2$的渐近无偏。 因为满足：$\lim\limits</em>{n\rightarrow \infty}E(\hat\theta_n)=0$</p>
<ul>
<li>怎么判断哪一个无偏估计更加有效呢？可以使用求 $Var(\hat\theta)$ ，谁的方差小，谁更有效</li>
</ul>
<p>经典学派的点估计方法一共由三种：1. 替换(也就是接下来我们要讲的矩估计)  2. 拟态 3. 似然</p>
<h2 id="矩估计及相合性"><a href="#矩估计及相合性" class="headerlink" title="矩估计及相合性"></a>矩估计及相合性</h2><p>矩估计是点估计的一种特殊情况。其本质就是用经验分布函数去替换总体分布，其理论基础就是格利文科定理。统计思想就是替换原理。</p>
<p>替换原理常指用样本矩去替换总体矩，这里的矩可以使原点矩也可以是中心距；并用样本矩的函数替换相应的总体矩的函数。</p>
<p>根据这个替换原理，在总体分布形式未知的场合也可以对各种参数作出估计。譬如：</p>
<ul>
<li>用样本均值 $\overline x$ 估计总体均值 $E(X)$</li>
<li>用样本方差 $s^2$ 来估计总体方差$Var(X)$</li>
<li>用事件A出现的频率估计事件A发生的概率。</li>
<li>用样本的p分位数估计总体的p分位数，特别的，用样本中位数估计总体中位数。</li>
</ul>
<h3 id="概率函数已知时未知参数的矩估计"><a href="#概率函数已知时未知参数的矩估计" class="headerlink" title="概率函数已知时未知参数的矩估计"></a>概率函数已知时未知参数的矩估计</h3><p>现在我们给出矩估计的使用方法。设总体具有已知的概率函数 $p(x;\theta_1,\theta_2,\cdots,\theta_k),(\theta_1,\theta_2,\cdots,\theta_k)\in \Theta$ 是未知参数或参数向量，$x_1,x_2\cdots,x_n$是样本，假定总体的k阶原点矩$\mu_k$ 存在，则对所有的j，有 $0&lt;j&lt;k,\mu_j$ 都存在。<br>若假设$\theta_1,\theta_2,\cdots,\theta_k$ 能够表示成 $\mu_1,\mu_2,\cdots,\mu_k$ 的函数 $\theta_j=\theta_j(\mu_1,\mu_2,\cdots,u_k)$ ，则可以给出诸 $\theta_j$ 的矩估计</p>
<script type="math/tex; mode=display">
\hat\theta_j = \theta_j(a_1,a_2,\cdots,a_k) , j = 1,2\cdots,k</script><p>其中 $a<em>1,a_2\cdots,a_k$ 是前k阶样本原点矩，$a_j = \frac{1}{n}\sum</em>{i=1}^n x_i^j$ . 进一步的，如果我们要估计$\theta_1,\theta_2\cdots,\theta_k$的函数 $\hat\eta = g(\theta_1,\theta_2,\cdots,\theta_k)$ 则可以直接得到 $\eta$ 的矩估计为：</p>
<script type="math/tex; mode=display">
\hat\eta = g(\hat\theta_1,\hat\theta_2,\cdots,\hat\theta_k)</script><p>有上面的式子可得，当k=1时，我们通常可以由样本均值出发对参数进行估计，当$k=2$时，可以由一阶二阶原点矩出发来估计未知参数。</p>
<p>上面的定义比较抽象，现在我们用几个例子来说一下。</p>
<h5 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h5><p>设总体为指数分布，其密度函数为：</p>
<script type="math/tex; mode=display">
p(x;\lambda) =\lambda e^{-\lambda x} , x\geq 0</script><p>其中，$x_1,x_2\cdots,x_n$ 是样本</p>
<p>现在，我们要估计这个分布函数中的参数$\lambda$ ,我们所要做的就是用矩来表示这个$\lambda$.</p>
<p>很显然，对于指数分布来说 ，$E(X) = \frac{1}{\lambda}\Rightarrow \lambda = \frac{1}{E(X)}$ ，就是说可以<strong>用一阶原点矩来表示未知参数$\lambda$</strong></p>
<p>因此，我们就可利用矩法，$\hat\theta_j = \theta_j(a_1,a_2,\cdots,a_k)$ 得到， </p>
<script type="math/tex; mode=display">
\hat\lambda = 1/\overline x</script><p>不过，由于 $Var(X) = 1/\lambda^2 \Rightarrow \lambda = 1/\sqrt{Var(X)}$ 可知，$\lambda$ 的估计也可以取为：</p>
<script type="math/tex; mode=display">
\hat \lambda_1 = 1/s</script><p> s为样本标准差，这说明矩估计可能是不唯一的，此时通常应该 <strong>尽量采用低阶矩</strong> 给出未知参数的估计。</p>
<h5 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h5><p>设 $x_1,x_2\cdots,x_n$ 是来自均匀分布 $U(a,b)$ 的样本，a与b均是未知参数。怎么用矩估计呢？</p>
<p>这里，我们要用矩来表示a和b，自然想到期望和方差。</p>
<script type="math/tex; mode=display">
E(X) = \frac{a+b}{2},Var(X) = \frac{(b-a)^2}{12}</script><p>不难推出</p>
<script type="math/tex; mode=display">
a = E(X)-3\sqrt{Var(X)}, b = E(X)+3\sqrt{Var(X)}</script><p>由此可以得到 a和b的矩估计：</p>
<script type="math/tex; mode=display">
\hat a = \overline x-\sqrt 3s,~~\hat b = \overline x+\sqrt 3 s</script><h5 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h5><p>设总体分布列/密度函数如下，$x_1,x_2,\cdots,x_n$ 是样本，试求未知参数的矩估计：</p>
<p>a. $P(X=x)=(x-1)\theta^2(1-\theta)^{x-2},x=2,3\cdots,0&lt;\theta&lt;1$ </p>
<p>我们用 $E(X)$去表示$\theta$,这是一个离散的分布列，那么怎么求期望呢？ 求和或者求积分</p>
<script type="math/tex; mode=display">
E(X) = \sum_{i=2}^\infty x(x-1)\theta^2(1-\theta)^{k-2} = \theta^2 \sum_{i=2}^\infty x(x-1)\theta^2(1-\theta)^{k-2}</script><p>很容易看出，我们要求和的部分可以看做是： </p>
<script type="math/tex; mode=display">
\sum_{k=2}^\infty \frac{\partial^2(1-\theta)^k}{\partial\theta} = \frac{\partial^2}{\partial\theta}\sum_{k=2}^\infty(1-\theta)^k \\~\\
=\frac{2}{\theta^3}</script><p>所以</p>
<script type="math/tex; mode=display">
E(X) = \frac{2}{\theta^3}\cdot\theta^2 = \frac{2}{\theta}\\~\\
\theta = \frac 2{E(X)} , \hat\theta = \frac{2}{\overline X}</script><h3 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h3><p>上面说了点估计还有拟合和似然两种方法，现在我们来讲拟合。最经典的拟合方法就是最小二乘法，也就是配直线的过程。</p>
<p><img src="/2021/06/10/%E6%A6%82%E7%8E%87%E8%AE%BA%E7%AC%AC%E5%85%AD%E7%AB%A0/1.png" style="zoom: 33%;"></p>
<h3 id="相合性"><a href="#相合性" class="headerlink" title="相合性"></a>相合性</h3><p>点估计是一个统计量，因此它是一个随机变量。在我们有足够的观测值之后，根据格利文科定理，随着样本量的不断增大，经验分布函数逼近真是分不含糊，因此完全可以要求估计量随着样本量的不断增大而逼近参数真值。<strong>这就是相合性</strong>，以下是定义：</p>
<p>设$\theta\in\Theta$ 为未知参数，$\hat\theta_n = \hat\theta_n(x_1,x_2\cdots,x_n)$是一个估计量，n是样本容量，若对任何一个 $\epsilon &gt; 0$.有：</p>
<script type="math/tex; mode=display">
\lim\limits_{n\rightarrow \infty} P(|\hat\theta_n-\theta|\geq \epsilon)=0</script><p>则称$\hat\theta_n$ 为参数 $\theta$ 的相合估计。</p>
<p>相合性被认为是对估计的一个最基本要求，如果一个估计量，在样本量不断增大时，它都不能把被估参数估计到任意指定的精度。那么这个估计是很值得怀疑的，通常，不满足相合性要求的估计不予考虑。通常称相合性是一个好估计的必要条件。但是，只满足相合性也是不够的。</p>
<p>其实，若把依赖于样本量n的估计量$\hat\theta_n$ 看做是一个<strong>随机变量序列</strong>，相合性就是$\hat\theta_n$ 依概率收敛到$\theta$ 。基于很多大数定律，其实相合性是很好论证的，只要我们将$\hat\theta_n$写成独立同分布的随机变量求和的形式即可。利用辛钦大数定律，证明其方差存在即可。</p>
<h4 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h4><p>设$\hat\theta_n = \hat\theta_n(x_1,x_2\cdots,x_n)$ 是$\theta$ 的一个估计量，若：</p>
<script type="math/tex; mode=display">
\lim\limits_{n\rightarrow\infty} E(\hat\theta_n) = \theta,~ \lim\limits_{n\rightarrow\infty} Var(\hat\theta_n) = 0</script><p>则 $\hat\theta_n$ 是 $\theta$ 的相合估计</p>
<p>当n充分大的时候， 估计值的期望是和真实的值是逼近的，其方差收敛到0。那么我一定能推出这是满足相合性的。换句话说，我只要求其一阶矩和二阶矩即可。</p>
<h5 id="例1-1"><a href="#例1-1" class="headerlink" title="例1"></a>例1</h5><p>设$x<em>1,x_2\cdots,x_n$ 是来自均匀总体 $U(0,\theta)$  的样本，证明 $x</em>{(n)}$ 是 $\theta$ 的相合估计。</p>
<p>我们可以由次序统计量的分布，我们知道 $\hat\theta = x_{(n)}$ 的分布密度函数为：</p>
<script type="math/tex; mode=display">
p(y) =ny^{n-1}/\theta^n, y<\theta</script><p>故有：</p>
<script type="math/tex; mode=display">
E(\hat\theta) = \int_{0}^\theta ny^ndy/\theta^n = \frac{n}{n+1} \theta\rightarrow \theta(n\rightarrow\infty)\\~\\
E(\hat\theta^2) = \int_{0}^\theta n y^{n+1}dy/\theta^n = \frac{n}{n+2} \theta^2\\~\\
Var(\hat\theta) = \frac{n}{n+2}\theta^2-(\frac{n}{n+1}\theta)^2 = \frac{n}{(n+1)^2(n+2)}\theta^2\rightarrow 0(n\rightarrow \infty)</script><p>因此，由上面说的定理1可得，$x_{(n)}$ 是$\theta$ 的相合估计。</p>
<h4 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h4><p>若$\hat\theta<em>{n1},\hat\theta</em>{n2}\cdots,\hat\theta<em>{nk}$ 分别是$\theta_1,\cdots,\theta_k$ 的相合估计，$\eta = g(\theta_1,\theta_2\cdots,\theta_k)$ 是 $\theta_1,\theta_2\cdots,\theta_k$ 的连续函数，则$\hat\eta_n = g(\hat\theta</em>{n1},\hat\theta<em>{n2},\cdots,\hat\theta</em>{nk}) $ 是$\eta$ 的相合估计。</p>
<p>用语言来描述这个定理就是，如果$\eta$能表示成一些参数的连续函数，那么就可以通过函数变换来求出$\eta$的相合估计。说明相合估计对于连续函数具有传递性</p>
<h5 id="例2-1"><a href="#例2-1" class="headerlink" title="例2"></a>例2</h5><p>刚才说的都是连续的例子，现在我们来说说离散的例子：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>a1</th>
<th>a2</th>
<th>a3</th>
</tr>
</thead>
<tbody>
<tr>
<td>P</td>
<td>$\theta^2$</td>
<td>$2\theta(1-\theta)$</td>
<td>$(1-\theta)^2$</td>
</tr>
<tr>
<td>n</td>
<td>$n_1$</td>
<td>$n_2$</td>
<td>$n_3$</td>
</tr>
<tr>
<td>频率</td>
<td>$\frac{n_1}{n}$</td>
<td>$\frac{n_2}{n}$</td>
<td>$\frac{n_3}{n}$</td>
</tr>
</tbody>
</table>
</div>
<p>我们使用矩估计，可以用替换的思想。这里的未知参数是 $\theta$ </p>
<p>那么，我们可以从频率出发，可以近似地认为a1发生的频率就等于其$p$ 的值，也就是 $\hat \theta_1 = \sqrt{p_1} = \sqrt{\frac{n_1}{n}}$ </p>
<p>注意了，给定的估计一定是要有未知参数的。</p>
<p>同样的想法，我们可以写出不同的关于$\theta$ 的表达式</p>
<ul>
<li>$\eta= \theta = 1-\sqrt{p_3} ,\hat\eta_n = \hat\theta_2 = 1-\sqrt{n_3/n}$ </li>
<li><p>$\eta(\theta)=p_1+p_2/2,\hat\eta_n =\hat\theta_3 = (n_1+n_2/2)/n$</p>
<p>由定理2 可得，以上三者都是$\eta$的相合估计</p>
</li>
</ul>
<h4 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h4><p>设$x_1,x_2\cdots,x_n$ 是来自正态总体$N(\mu,\sigma^2)$ 的样本序列，则由辛钦大数定律及依概率收敛的性质可得：</p>
<ul>
<li>$\overline x$ 是$\mu$ 的相合估计</li>
<li>$s_n^2$ 是$\sigma^2$ 的相合估计</li>
<li>$s^2$ 也是$\sigma^2$的相合估计</li>
</ul>
<p><strong>由此也可以看到参数的相合估计不止一个</strong></p>
<p>另外，有大数定理可以看到，矩估计一般都具有相合性，比如：</p>
<ul>
<li>样本均值是总体均值的相合估计</li>
<li>样本标准差是总体标准差的相合估计</li>
<li>样本变异系数 $s/\overline x$ 是总体变异系数的相合估计</li>
</ul>
<h2 id="最大似然估计与EM算法"><a href="#最大似然估计与EM算法" class="headerlink" title="最大似然估计与EM算法"></a>最大似然估计与EM算法</h2><p>刚才我们讲了点估计中的矩估计(替换)以及拟合，现在我们来讲讲第三种——似然</p>
<p>最大似然法（Maximum Likelihood，ML）也称为最大概似估计，也叫极大似然估计，是一种具有理论性的点估计法，此方法的基本思想是：当从模型总体随机抽取n组样本观测值后，最合理的参数估计量应该使得从模型中抽取该n组样本观测值的概率最大，而不是像最小二乘估计法旨在得到使得模型能最好地拟合样本数据的参数估计量</p>
<p>个随机试验如有若干个可能的结果A，B，C，… ，若在一次试验中，结果A出现了，那么可以认为实验条件对A的出现有利，也即出现的概率P(A)较大。极大似然原理的直观想法我们用下面例子说明。设甲箱中有99个白球，1个黑球；乙箱中有1个白球．99个黑球。现随机取出一箱，再从抽取的一箱中随机取出一球，结果是黑球，这一黑球从乙箱抽取的概率比从甲箱抽取的概率大得多，这时我们自然更多地相信这个黑球是取自乙箱的。一般说来，事件A发生的概率与某一未知参数$\theta$ 有关，$\theta$ 取值不同，则事件A发生的概率 $P(A|\theta)$ 也不同，当我们在一次试验中事件A发生了，则认为此时的$\theta$ 值应是 t 的一切可能取值中使$P(A|\theta)$达到<strong>最大的那一个</strong>， 极大似然估计法就是要选取这样的t值作为参数t的估计值，<strong>使所选取的样本在被选的总体中出现的可能性为最大</strong>。 </p>
<p>似然的核心想法就是<strong>以成败论英雄</strong>。</p>
<p>首先我们来讲一下什么事似然函数。</p>
<p>其实，似然函数就是这个分布的<strong>概率函数</strong> , 只不过是将其看做关于$\theta$的函数，也就是 $P_\theta(x_1,x_2,\cdots,x_n)$.那么对样本而言，就是联合分布列/密度</p>
<p>1.求极大似然函数估计值的一般步骤：</p>
<p>（1） 写出似然函数；</p>
<p>（2） 对似然函数取对数，并整理；</p>
<p>（3） 求导数</p>
<p>（4） 解似然方程 。</p>
<p>2.利用高等数学中求多元函数的极值的方法，有以下极大似然估计法的具体做法：</p>
<p>(1)根据总体的分布，建立似然函数  </p>
<script type="math/tex; mode=display">
L(x_1,x_2,\cdots,x_n;\theta_1,\theta_2\cdots,\theta_k)</script><p>(2) 当 L 关于 $\theta_1,\theta_2\cdots,\theta_k$ 可微时，(由微积分求极值的原理）可由方程组</p>
<script type="math/tex; mode=display">
\frac{\partial L}{\partial \theta_i} = 0,i=1,2\cdots,k</script><p>定出</p>
<script type="math/tex; mode=display">
\hat\theta_i(i=1,2\cdots,k)</script><p>称以上方程组为似然方程. </p>
<p><strong>因为 L 与 $\ln L$ 有相同的极大值点</strong>，所以 $\hat\theta_i(i=1,2,\cdots,k)$也可由方程组</p>
<script type="math/tex; mode=display">
\frac{\partial \ln L} {\partial\theta_i} = 0,i=1,2\cdots,k</script><p>定出 $\hat\theta_i(i=1,2\cdots,k)$ , 称以上方程组为<strong>对数似然方程</strong>；$\hat\theta_i(i=1,2\cdots,k)$ 就是所求参数 $ \theta_i(i=1,2\cdots,k)$ 的<strong>极大似然估计量</strong>。</p>
<p>当总体是离散型的， 将上面的概率密度函数 $f(x,\theta_1,\theta_2\cdots,\theta_k)$ ，换成它的分布律 $P(X=x;\theta_1,\theta_2\cdots,\theta_k)$</p>
<h5 id="例1-2"><a href="#例1-2" class="headerlink" title="例1"></a>例1</h5><p>$x\sim b(1,\theta)$,样本为 $x_1,x_2\cdots,x_n$,求其极大似然估计量</p>
<p><strong>第一步</strong>，我们写出其似然函数，这是一个离散的样本，因此：</p>
<script type="math/tex; mode=display">
L(\theta) = P_\theta(x_1,\cdots,x_n)=\prod_{i=1}^n P_e(x_i)=\prod_{i=1}^n \theta^{x_1}(1-\theta)^{1-x_i}\\~\\
=\theta^{\Sigma x_i}(1-\theta)^{n-\Sigma x_i}\\~\\</script><p><strong>第二步，</strong>求出其对数似然函数(计算会更方便)</p>
<script type="math/tex; mode=display">
\ln L(\theta) = \sum x_i \ln\theta +(n-\sum x_i)\ln(1-\theta)</script><p><strong>第三步，</strong>对其求导，因为要找到 $\hat\theta$ 的最大值,所以导数等于0是必要条件。但是导数等于0不一定代表$L(\theta)$能取最大值(也可能是最小值), 所以，我们可以求二阶导来验证一下，不过一般来说都是最大值</p>
<script type="math/tex; mode=display">
\frac{\partial\ln L(\theta)}{\partial\theta} = \frac{\sum x_i}{\theta}-\frac{n-\sum x_i}{1-\theta} = 0</script><p><strong>第四步，求解对数似然方程</strong></p>
<script type="math/tex; mode=display">
\hat\theta = \frac{1}{n}\sum_{i=1}^n x_i = \overline x</script><p>极大似然估计一般记为<strong>MLE</strong></p>
<h5 id="例2-2"><a href="#例2-2" class="headerlink" title="例2"></a>例2</h5><p>我们继续看这个例子，对于离散的分布。刚才我们仅仅根据一两个条件，就给出了关于$\theta$的矩估计，这让我们不禁感觉是不是没有用上全部的信息，因此我们可以用极大似然估计得到更精确的$\hat\theta$</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>a1</th>
<th>a2</th>
<th>a3</th>
</tr>
</thead>
<tbody>
<tr>
<td>P</td>
<td>$\theta^2$</td>
<td>$2\theta(1-\theta)$</td>
<td>$(1-\theta)^2$</td>
</tr>
<tr>
<td>n</td>
<td>$n_1$</td>
<td>$n_2$</td>
<td>$n_3$</td>
</tr>
<tr>
<td>频率</td>
<td>$\frac{n_1}{n}$</td>
<td>$\frac{n_2}{n}$</td>
<td>$\frac{n_3}{n}$</td>
</tr>
</tbody>
</table>
</div>
<p>我们也是一样的做法。首先给出其似然函数$L(\theta)$</p>
<script type="math/tex; mode=display">
L(\theta) = (\theta^2)^{n_1}[2\theta(1-\theta)]^{n_2}[(1-\theta)^2]^{n_3} = 2^{n_2}\theta^{2n_1+n_2}(1-\theta)^{2n_3+n_2}</script><p>然后，对其求对数似然函数：</p>
<script type="math/tex; mode=display">
\ln L(\theta) = (2n_1+n_2)\ln\theta +(2n_3+n_2)\ln(1-\theta)+n_2\ln2</script><p>然后对$\theta$求导，令导数为0：</p>
<script type="math/tex; mode=display">
\frac{2n_1+n_2}{\theta}-\frac{2n_3+n_2}{1-\theta} = 0</script><p>解之，得到：</p>
<script type="math/tex; mode=display">
\hat\theta = \frac{2n_1+n_2}{2(n_1+n_2+n_3)}=\frac{2n_1+n_2}{2n}</script><p>最后我们要验证一下</p>
<script type="math/tex; mode=display">
\frac{\partial^2\ln L(\theta)}{\partial\theta^2} = -\frac{n_1+n_2}{\theta^2}-\frac{2n_3+n_2}{(1-\theta)^2}<0</script><p>所以说$\hat\theta$ 是极大值点。</p>
<h5 id="例3-1"><a href="#例3-1" class="headerlink" title="例3"></a>例3</h5><p>虽然说求导函数是求最大似然估计最常用的方法，但并不是在所有场合都是有效的，比如说下面这个例子：</p>
<p>设$x_1,x_2\cdots,x_n$是来自均匀总体$U(0,\theta)$ 的样本，试求$\theta$的最大似然估计</p>
<p><strong>第一步</strong>，求出似然函数,这里x的取值和$\theta$有关，因此我们需要乘以示性函数。</p>
<script type="math/tex; mode=display">
L(\theta) = \frac{1}{\theta^n}\prod_{i=1}^nI_{\{0<x_i\leq\theta\}} = \frac{1}{\theta^n}I_{\{x(n)\leq \theta\}}</script><p><strong>第二步</strong>，我们开始分析。要使 $L(\theta)$ 达到最大，首先示性函数肯定要取1，再让$1/\theta^n$ 尽可能大。由于 $\frac{1}{\theta^n}$是单调减函数，所以$\theta$的取值要尽可能小。但是$\theta$ 又不可能小于样本的最大值$x<em>{(n)}$ 。因此，直接可以得出最大似然估计为 $\hat\theta = x</em>{(n)}$</p>
<h5 id="例4"><a href="#例4" class="headerlink" title="例4"></a>例4</h5><p>但是注意了，最大似然也可能是一在一个范围中的，比如说：</p>
<p>求 $p(x;\theta) = 1,\theta-\frac{1}{2}&lt;x&lt;\theta+\frac12$ 这个分布的最大似然估计：</p>
<p><strong>第一步：</strong> 写出似然函数： </p>
<script type="math/tex; mode=display">
L(\theta) = 1\cdot I_{\{\theta-\frac{1}{2}<x_{(1)}<x_{(n)}<\theta_2+\frac12\}}</script><p><strong>第二步</strong>：求出$\theta$的值或者范围。 要让 $L(\theta)$ 尽量大，首先示性函数应该为1。 这样解出来的$\theta$ 才能保证整个似然函数为1。 $x<em>{(n)}-\frac12&lt;\theta&lt;x</em>{(1)}+\frac12$</p>
<h5 id="例5"><a href="#例5" class="headerlink" title="例5"></a>例5</h5><p>设$x_1,x_2,\cdots,x_n$ 是来自密度函数为 $p(x;\theta) = e^{-(x-\theta)},x&gt;\theta$ 的总体的样本。求$\theta$ 的最大似然估计 $\hat\theta_1$ 是否是相合估计，是否是无偏估计？</p>
<p><strong>第一步：写出似然函数</strong>： </p>
<script type="math/tex; mode=display">
L(\theta) = e^{-\sum x_i+n\theta }I_{\{x_{(1)}>\theta\}}\\~\\</script><p> 要让示性函数取1，必须让 $\theta&lt;x<em>{(1)}$ . 所以$\theta$ 最大似然估计为 $\hat\theta_1 = x</em>{(1)}$ </p>
<p>然后我们就要判断其是否是无偏估计。 </p>
<p>判断是否为无偏估计(需满足 $E(\hat\theta) = \theta$ )</p>
<p><strong>第二步：写出x(1)的密度函数：</strong></p>
<script type="math/tex; mode=display">
F(x_1) = 1-[1-F(x)]^n = 1-[1-(1-e^{-x+\theta})]^n\\~\\
p(x_1) = ne^{-n(x-\theta)} \\~\\
E(X) = \int_\theta^\infty xne^{-n(x-\theta)}dx = \int_{\theta}^\infty (t+\theta) ne^{-nt} dt = \frac{1}{n}+\theta\neq \theta</script><p>因此，$x_{(1)}$不是 $\theta$ 的无偏估计</p>
<p>那么$x_{(1)}$是不是$\theta$ 的相合估计呢？ 首先，当$n\rightarrow \infty$ 时，$E(\hat\theta) = \theta$ </p>
<p>现在就要验证，当$n\rightarrow \infty$ 时，是否 $Var(\hat\theta) = 0$</p>
<script type="math/tex; mode=display">
\lim\limits_{n\rightarrow\infty} Var(\hat\theta_1) = E(\hat\theta_1^2)-E^2(\theta)\\~\\ = E(\hat\theta_1^2) - (\frac{1}{n}+\theta)^2</script><p>因此我们现在要计算 $E(\hat\theta_1^2)$</p>
<script type="math/tex; mode=display">
E(\hat\theta_1^2)  = \int_0^\infty x^2ne^{-n(x-\theta)}dn\\~\\
令 x-\theta = t\\~\\
=\int_0^{\infty} (t+\theta)^2ne^{-nt}dt\\~\\
=n\int_0^{\infty} t^2e^{-nt}dt+2n\theta\int_0^\infty te^{-nt} dt+\theta^2n\int_0^\infty e^{-nt} dt\\~\\
=\theta^2+2\theta/n+\frac2{n^2}</script><p>因此</p>
<script type="math/tex; mode=display">
Var(\hat\theta_1) = \theta^2+\frac{2\theta}{n} +\frac{2}{n^2}-(\frac{1}{n}+\theta)^2  = \frac{1}{n^2}\\~\\</script><p>显然，当 $n\rightarrow\infty$ 时，$Var(\frac{1}{n^2})\rightarrow 0$. 因此，$\hat\theta_1$ 是 $\theta$ 的相合估计</p>
<p>最大似然估计有一个简单而有用的性质：若果$\hat\theta$是$\theta$的最大似然估计，则对任一函数$g(\theta)$，$g(\hat\theta)$ 是其最大似然估计。该性质称为最大似然估计的<strong>不变性</strong>. 从而使得一些复杂结构的参数的最大似然估计的获得变得更容易了。</p>
<h3 id="渐近正态性"><a href="#渐近正态性" class="headerlink" title="渐近正态性"></a>渐近正态性</h3><p>最大似然估计还有一个良好的性质：<strong>它通常具有渐近正态性</strong> 。现在给出其定义：</p>
<p>参数$\theta$ 的相合估计$\hat\theta_n$ 称为渐近正态的，若存在趋于0的非负常数序列 $\sigma_n(\theta)$ ，使得 $\frac{\hat\theta_n-\theta}{\sigma_n(\theta)}$ 依分布收敛于标准正态分布。这是也称 $\hat\theta_n$服从<strong>渐近正态分布</strong>$N(\theta,\sigma_n^2(\theta))$ ,记为$\hat\theta_n\sim AN(\theta,\sigma_n^2(\theta))$ ，$\sigma^2_n(\theta)$ 称为$\hat\theta_n$的渐近方差。</p>
<h5 id="例1-3"><a href="#例1-3" class="headerlink" title="例1"></a>例1</h5><p>设总体为泊松分布$P(\lambda)$，无论是矩估计还是最大似然估计，我们都得到一样的$\lambda$估计：样本均值，即：</p>
<script type="math/tex; mode=display">
\hat\lambda_n = \overline x_n= \frac{1}{n}\sum_{i=1}^n x_i</script><p>由中心极限定理，$(\hat\lambda_n-\lambda)/\sqrt{\lambda/n}$ 依分布收敛 $N(0,1)$，因此, $\hat\lambda_n$是渐近正态的，且：</p>
<script type="math/tex; mode=display">
\hat\lambda_n \sim AN(\lambda,\lambda/n)</script><p>这里的常数序列 $\sigma_n(\lambda) = \sqrt{\lambda/n}\rightarrow 0$ 它表示$\hat\lambda_n$依概率收敛于$\lambda$的速度为 $ 1/\sqrt{n} $</p>
<h2 id="点估计的评价方法"><a href="#点估计的评价方法" class="headerlink" title="点估计的评价方法"></a>点估计的评价方法</h2><p>上面三部分我们讲了几种不同的点估计方法，那么我们怎么来判断一个点估计的好坏呢？前面我们说到了无偏性、相合性。 其实，为了在不同的点估计间进行比较选择，我们就必须对各种点估计的好坏给出评价标准。 统计学中给出了众多的估计量评价标准，对同一估计量使用不同的评价标准可能会得到完全不同的结论。</p>
<h3 id="均方误差"><a href="#均方误差" class="headerlink" title="均方误差"></a>均方误差</h3><p>相合性和渐近正态性是在大样本场合下评价估计好坏的两个重要标准。无偏估计常使用方差的大小来判断该估计的好坏，而有偏估计常使用均方误差来判断。 </p>
<p>一般而言，在样本量一定时，评价一个点估计的好坏使用的度量指标总是点估计值$\hat\theta$与参数真值$\theta$ 的距离的函数，最常用的函数式距离的平方。但是由于$\hat\theta$具有随机性，可以对该函数求期望。这就是下面给出的<strong>均方误差</strong></p>
<script type="math/tex; mode=display">
MSE (\hat\theta) = E(\hat\theta-\theta)^2</script><p>均方误差是评价点估计的最一般的标准。自然，我们希望估计的均方误差越小越好。注意到：</p>
<script type="math/tex; mode=display">
MSE(\hat\theta) = E[(\hat\theta-E(\hat\theta))+(E(\hat\theta)-\theta)]^2\\~\\
=E(\hat\theta-E(\hat\theta))^2+(E(\hat\theta)-\theta)^2+2E[(\hat\theta-E(\hat\theta))(E(\hat\theta)-\theta)]</script><p>由于</p>
<p>所以，</p>
<script type="math/tex; mode=display">
MSE(\hat\theta) = Var(\hat\theta)+(E(\hat\theta)-\theta)^2</script><p>我们看到，均方误差由点估计的方差与与偏差$|E(\hat\theta-\theta)|$的平法两部分组成。 如果$\hat\theta$是$\theta$的无偏估计，则$MSE(\hat\theta)=Var(\hat\theta)$，此时用均方误差评价点估计与用方差是完全一样的。这也说明用方差来考察无偏估计的有效性是合理的。</p>
<p>注意了，当$\hat\theta$ 不是$\theta$的无偏估计时，就要看其均方误差 $MSE(\hat\theta)$, 不仅要看其方差大小，还要其偏差大小。在有些情况下，有偏估计其实是优于无偏估计的。</p>
<h3 id="一致最小均方误差估计"><a href="#一致最小均方误差估计" class="headerlink" title="一致最小均方误差估计"></a>一致最小均方误差估计</h3><p>设有样本 $x_1,x_2\cdots,x_n$ ，对待参数 $\theta$ ,有一个估计类，称 $\hat\theta(x_1,x_2,\cdots,x_n)$ 是该估计类中$\theta$ 的一致最小均方误差估计，如果对于该估计类中另外任意一个$\theta$ 的估计 $\tilde \theta$ , 在参数空间$\Theta$上都有：</p>
<script type="math/tex; mode=display">
MSE_\theta(\hat\theta)\leq MSE_\theta(\tilde \theta)</script><p>但是，若考虑所有可能的估计，则一致最小均方误差估计是不存在的，从而使没有意义的。因此，人们通常的就对估计提一些合理性要求，前面说的无偏性就是一个常见的合理性要求。</p>
<h3 id="一致最小方差无偏估计"><a href="#一致最小方差无偏估计" class="headerlink" title="一致最小方差无偏估计"></a>一致最小方差无偏估计</h3><p>当我们要求$\hat\theta$ 是$\theta$ 的无偏估计时，均方误差就简化为估计的方差，此时一致最小均方误差估计就是一致最小方差无偏估计。 其定义如下：</p>
<p>对于参数估计问题，设$\hat\theta$ 是$\theta$ 的一个无偏估计. 如果对另外任意一个$\theta$ 的无偏估计$\tilde \theta$ ，在参数空间 $\Theta$上都有：</p>
<script type="math/tex; mode=display">
Var_\theta(\hat\theta)\leq Var_\theta(\tilde\theta)</script><p>则称$\hat\theta$ 是$\theta$的一致最小方差无偏估计，简记为 UMVUE</p>
<h4 id="定理1-1"><a href="#定理1-1" class="headerlink" title="定理1"></a>定理1</h4><p>设 $X=(x_1,x_2\cdots,x_n)$ 是来自某总体的一个样本，$\hat\theta=\hat\theta(X)$ 是$\theta$的一个无偏估计，$Var(\hat\theta)&lt;\infty$ , 则 $\hat\theta$是$\theta$的UMVUE的充要条件是：</p>
<p>对任意一个满足 $E(\varphi(X))=0$ 和 $Var(\varphi(X))&lt; \infty$ 都有：</p>
<script type="math/tex; mode=display">
Cov_\theta(\hat\theta,\varphi)=0,~~\forall \theta \in \Theta</script><p>这个定理表明，$\theta$ 的UMVUE 必与任一<strong>零的无偏估计</strong>不相关，反之亦然。</p>
<h5 id="例1-4"><a href="#例1-4" class="headerlink" title="例1"></a>例1</h5><p>设 $x_1,x_2\cdots,x_n$ 是来自于下列总体的简单样本</p>
<script type="math/tex; mode=display">
p(x) = \begin{cases}1,\theta-\dfrac{1}{2}\leq x\leq \theta +\dfrac{1}{2}\\ 0,其他\end{cases}  -\infty \leq x\leq \infty</script><p>证明样本均值 $\overline x$ 即 $\frac{1}{2}(x<em>{(1)}+x</em>{(n)})$ 都是$\theta$的无偏估计，问哪一个更为有效？</p>
<p>想要问哪一个无偏估计更加有效，就要看看哪一个 $Var(\hat\theta)$更小</p>
<p><strong>第一步：求$E(\hat\theta_1),Var(\hat\theta_1)$</strong>   </p>
<script type="math/tex; mode=display">
E(\hat\theta_1) = E(X) =\overline x\\~\\
Var(\hat\theta_1)= \frac{1}{n} Var(X) =\frac{1}{12n}</script><p><strong>第二步：求$E(\hat\theta_2),Var(\hat\theta_2)$</strong></p>
<h3 id="充分性原则"><a href="#充分性原则" class="headerlink" title="充分性原则"></a>充分性原则</h3><h4 id="定理2-1"><a href="#定理2-1" class="headerlink" title="定理2"></a>定理2</h4><p>设总体概率函数为$p(x;\theta),x_1,x_2\cdots,x_n$ 是其样本，$T=T(x_1,x_2,\cdots,x_n)$ 是$\theta$的充分统计量，则对$\theta$ 的任一无偏估计$\hat\theta = \hat\theta(x_1,x_2\cdots,x_n)$ ，令 $\tilde\theta = E(\hat\theta|T)$ 与$\theta$ 无关，则$\tilde\theta$ 也是$\theta$的无偏估计</p>
<p>这说明，如果无偏估计不是充分统计量的函数，则将其对充分统计量求条件期望可以得到一个新的无偏估计，该估计的方差比原来的估计的方差要小，从而降低了无偏估计的方差。 换言之，考虑$\theta$的估计问题，只需要在基于充分统计量的函数中进行即可，该说法对所有的统计推断问题都是成立的，这就是充分性原则。</p>
<h5 id="例1-5"><a href="#例1-5" class="headerlink" title="例1"></a>例1</h5><p>设 $x_1,x_2\cdots,x_n$ 是来自$b(1,p)$的样本，则 $\overline x $ 是 p 的充分统计量，为估计 $\theta = p^2$ ，我们可以先令一个”不太准”的$\theta$ 估计</p>
<script type="math/tex; mode=display">
\theta =\begin{cases}1,~~~x_1=1,x_2=1\\ 0, ~~其他\end{cases}</script><p>现在我们来看看在这是不是无偏估计：</p>
<script type="math/tex; mode=display">
E(\hat\theta_1) =P(x_1=1,x_2=1 )= p\cdot p =\theta</script><p>所以，$\hat\theta<em>1$ 是 $\theta$ 的 无偏估计。 但是这个估计并不好，因为只用了两个观测值。 我们可以用上面说的定理来优化改进： 求 $\hat\theta_1$ 关于充分统计量 $T=\sum</em>{i=1}^nx_i$ 的条件期望，过程如下：</p>
<script type="math/tex; mode=display">
\hat\theta = E(\hat\theta_1 |T=t) = P(\hat\theta_1=1 | T=t) = \frac{P(x_1=1,x_2=1,T=t)}{P(T=t)}\\~\\
=\frac{P(x_1=1,x_2=1,\sum_{t=3}^{n}x_i=t-2)}{P(T=t)} = \frac{p\cdot p~C_{n-2}^{t-2}p^{t-2}{(1-p)^{n-t}}}{C_n^t p^t(1-p)^{n-t}}\\~\\
=\frac{C_{n-2}^{t-2}}{C_n^t} = \frac{t(t-1)}{n(n-1)}</script><p>其中 $t = \sum_{i=1}^n x_i$ 可以验证，$\hat\theta$ 是 $\theta$ 的无偏估计，且$Var(\hat\theta)&lt;Var(\hat\theta_1)$ </p>
<h3 id="费希尔信息量"><a href="#费希尔信息量" class="headerlink" title="费希尔信息量"></a>费希尔信息量</h3><p>最大似然估计的渐近主要由费希尔信息量 $I(\theta)$  决定，现在先介绍$I(\theta)$ ，然后讲述克拉默-拉奥不对呢公式，又是它可以用来判断UMVUE</p>
<p>设总体的概率函数$p(x;\theta),\theta\in\Theta$  满足下列条件</p>
<ol>
<li>参数空间 $\Theta$ 是直线上的一个开区间；</li>
<li>支撑 $S={x;p(x;\theta)&gt;0}$ 与 $\theta$ </li>
<li>导数 $\frac{\partial }{\partial\theta}p(x;\theta)$  对一切 $\theta\in \Theta$ 存在</li>
<li>对$p(x;\theta)$ ，积分与微分运算可交换次序，即：</li>
</ol>
<script type="math/tex; mode=display">
\frac{\partial}{\partial\theta}\int_{-\infty}^{\infty} p(x;\theta )dx = \int_{-\infty}^{\infty} \frac{\partial}{\partial \theta} p(x;\theta)dx</script><ol>
<li>期望 $E[\frac{\partial}{\partial\theta}\ln p(x;\theta)]^2$  存在</li>
</ol>
<p>那么总体分布的<strong>费希尔信息量</strong>是：</p>
<script type="math/tex; mode=display">
I(\theta) = E[\frac{\partial}{\partial\theta}\ln p(x;\theta)]^2 = -E(\frac{\partial^2\ln p(x;\theta)}{\partial\theta})</script><h5 id="例1-6"><a href="#例1-6" class="headerlink" title="例1"></a>例1</h5><p>设总体分布为泊松分布 $P(\lambda)$ ，其分布列：</p>
<script type="math/tex; mode=display">
p(x;\lambda) = \frac{\lambda^x}{x!}e^{-\lambda}</script><p>那么</p>
<script type="math/tex; mode=display">
\ln p(x;\lambda) = x\ln\lambda -\lambda -\ln(x!)\\~\\
\frac{\partial }{\partial\lambda} \ln p(x;\lambda) = x/\lambda -1\\~\\</script><p>于是： </p>
<script type="math/tex; mode=display">
I(\lambda) =E(\frac{x-\lambda}{\lambda})^2 =Var(x)/\lambda^2 = \frac{1}{\lambda}</script><h3 id="CR-克拉默-拉奥-不等式"><a href="#CR-克拉默-拉奥-不等式" class="headerlink" title="CR(克拉默-拉奥) 不等式"></a>CR(克拉默-拉奥) 不等式</h3><p>设总体分布$p(x;\theta)$ 满足定义上述费希尔通信量的条件，$x_1\cdots,x_n$ 是来自该总体的样本，$T=T(x_1\cdots,x_n)$ 是$g(\theta)$ 的任一个无偏估计，$g’(\theta) = \frac{\partial g(\theta)}{\partial \theta}$ 存在，且对$\Theta$ 中一切 $\theta$ ，对</p>
<script type="math/tex; mode=display">
g(\theta) = \int_{-\infty}^{\infty}\cdots\int_{-\infty}^{\infty} T(x_1,\cdots,x_n) \prod_{i=1}^np(x_i;\theta)dx_1\cdots d_{x_n}</script><p>的微商可在积分号下进行，即：</p>
<script type="math/tex; mode=display">
g'(\theta) =\int_{-\infty}^{\infty}\cdots\int_{-\infty}^{\infty} [\frac{\partial}{\partial\theta}\ln\prod_{i=1}^np(x_i;\theta)]\prod_{i=1}^np(x_i;\theta)dx_1\cdots d_{x_n}</script><p>对离散总体，也是一样。 则有：</p>
<script type="math/tex; mode=display">
Var(T)\geq [g'(\theta)]^2/nI(\theta)</script><p>将上式称为是克拉默-拉奥不等式，$[g’(\theta)]^2/(n\ln(\theta))$ 称为$g(\theta)$的无偏估计的方差的$C-R$<strong>下界</strong>。 </p>
<p>特别的，对$\theta$ 的无偏估计$\hat\theta$,有 $Var(\hat\theta)\geq(nI(\theta))^{-1}$ </p>
<p>如果 $Var(T)=[g’(\theta)]^2/nI(\theta)$ 成立，我们称$T=T(x_1,x_2\cdots,x_n)$是 $g(\theta)$的有效估计。</p>
<h2 id="贝叶斯估计"><a href="#贝叶斯估计" class="headerlink" title="贝叶斯估计"></a>贝叶斯估计</h2><p>之前说的经典学派的估计认为，参数是一个值。而贝叶斯学派认为，参数是一个随机变量。</p>
<p>经典学派通过样本采样的方式，来估计参数。但是万一样本较少怎么办？万一只有一次实验，似乎就直接决定了这个参数是什么，这恐怕不太靠谱。</p>
<p>但是理论和现实不太一样，在工业生产中，我们对一个参数可能有预先的判断。 如果综合前面的预判，加上为数不多的样本，就可以让参数的估计变得更加靠谱一些</p>
<p>用学术性的话语来说，经典学派对统计推断使用到了两种信息：总体信息和样本信息。但是，贝叶斯学派认为，除了上述两种信息之外，统计推断还应该使用第三种信息：先验信息。</p>
<p>现在来介绍他一下先验信息：如果我们把抽取样本看做是一次试验，则样本信息就是试验中得到的信息。实际中，人们在试验之前对要做的问题在经验上和资料上总是有所了解的，这些信息对统计推断是有益的。先验信息即抽样(试验)之前有关统计问题的一些信息。</p>
<p>贝叶斯估计总体可以概括为4句话：</p>
<ol>
<li>待估参数$\theta$ 是一个随机变量</li>
<li>在得到样本前，对$\theta$ 有一个认识。我们可以用一个分布来刻画这种认识，称为先验分布，通常被认为是 $\pi(\theta)$ </li>
<li>样本是用来调整对这个参数$\theta$ 的认识的。调整的方式是 Bayes 公式。调整后称其为<strong>后验公式</strong></li>
<li>Bayes推断都是基于后验分布的。</li>
</ol>
<h3 id="贝叶斯公式的密度函数形式"><a href="#贝叶斯公式的密度函数形式" class="headerlink" title="贝叶斯公式的密度函数形式"></a>贝叶斯公式的密度函数形式</h3><ol>
<li><p>在贝叶斯统计中，$p(x;\theta)$ 应写为 $p(x|\theta)$ .它表示在随机变量$\theta$ 取某个给定值时总体的条件概率函数</p>
</li>
<li><p>根据参数$\theta$ 的先验信息确定先验分布$\pi(\theta)$</p>
</li>
<li><p>从贝叶斯的观点来看，样本$X=(x_1,x_2,\cdots,x_n)$ 的产生要分两步产生。首先<strong>设想</strong>从分布$\pi(\theta)$ 产生一个个体$\theta_0$ 这一步是”上帝”做的，我们是看不到的。第二步，从$p(X|\theta_0)$ 中产生一组样本。这时样本$X = （x_1,x_2\cdots,x_n)$ 的联合条件概率函数为：</p>
<script type="math/tex; mode=display">
p(X|\theta_0) = p(x_1,x_2\cdots,x_n|\theta_0) = \prod_{i=1}^np(x_i|\theta_0)</script><p>这个分布综合了总体信息和样本信息</p>
</li>
<li><p>由于$\theta_0$是设想出来的，仍然是未知的，它是按照先验分布$\pi(\theta)$产生的。 为了把先验信息综合进去，不能只考虑$\theta_0$。因此，对$\theta$的其他可能发生的可能性也需要加以考虑，故要用$\pi(\theta)$ 进行综合，这样一来，样本X和参数$\theta$的联合分布为：</p>
<script type="math/tex; mode=display">
h(X,\theta) = p(X|\theta)\pi(\theta)</script></li>
<li><p>我们的目的是要对未知参数$\theta$ 做一个统计推断。在没有样本信息时，我们只能依据先验分布对$\theta$作出判断。在有了样本观测值$X=(x_1,x_2\cdots,x_n)$ 之后，我们应该依据 $h(X,\theta)$ 对$\theta$ 作出推断。若把$h(X,\theta)$做如下分解：</p>
<script type="math/tex; mode=display">
h(X,\theta) = \pi(\theta|X)m(X)</script><p>其中$m(X)$是X的边际概率函数</p>
<script type="math/tex; mode=display">
m(X) = \int_{\Theta}h(X,\theta) d\theta = \int_{\Theta}p(X|\theta)\pi(\theta)d\theta</script><p>它与$\theta$无关，或者说$m(X)$ 不包含任何关于$\theta$ 的信息。因此能用来对$\theta$作出推断的仅是条件分布 $\pi(\theta|X)$ ，它的计算公式是：</p>
<script type="math/tex; mode=display">
\pi(\theta|X) = \frac{h(X,\theta)}{m(X)} = \frac{p(X|\theta)\pi(\theta)}{\int_{\Theta}p(X|\theta)\pi(\theta)d\theta}</script><p>这个条件就是$\theta$ 的后验分布了。它集中了总体、样本和先验中有关$\theta$的一切信息。他要比$\pi(\theta)$更接近$\theta$的实际情况。</p>
</li>
</ol>
<p>那么如何选先验分布？ 一般来说是收集历史资料，但是在题目中，我们可以采用<strong>同等无知</strong>的办法。</p>
<h5 id="例1-7"><a href="#例1-7" class="headerlink" title="例1"></a>例1</h5><p>对 $x|\theta\sim b(1,\theta),x_1,x_2\cdots,x_n$为样本，$\theta\in (0,1)$ 我们要去估计 $\theta$，那怎么选先验？</p>
<p>第一步：先验分布</p>
<p>在没有样本的情况下，这里我们暂且不适用同等无知的方法，因为我们知道贝塔分布的定义域是在 0-1之间的，因此我们这里可以将$\theta$的先验分布定位$Be(a,b)$, 即 $\pi(\theta) \sim Be(a,b) $</p>
<p>第二步：求后验分布</p>
<p>根据上面的步骤，我们可以写出 </p>
<script type="math/tex; mode=display">
h(X,\theta) = p(X|\theta)\pi(\theta) =  \frac{1}{Be(a,b)}\theta^{a-1+\sum x_i}(1-\theta)^{n+b-1-\sum x_i}\\~\\
m(X) = \int_{\Theta}h(X,\theta) d\theta = \int_{\Theta}p(X|\theta)\pi(\theta)d\theta =\int\frac{1}{Be(a,b)}\theta^{a-1+\sum x_i}(1-\theta)^{n+b-1-\sum x_i} d\theta\\~\\</script><p>最终解得：</p>
<script type="math/tex; mode=display">
\pi(\theta|X) \sim Be(a+\sum x_i,b+n-\sum x_i)</script><h3 id="贝叶斯估计-1"><a href="#贝叶斯估计-1" class="headerlink" title="贝叶斯估计"></a>贝叶斯估计</h3><p>我们得出估计之后，就要给出一个$\theta$的估计值，那么通常有三种方法：</p>
<ul>
<li>使用后验分布的密度函数最大值作为$\theta$ 的点估计的最大后验估计</li>
<li>使用后验分布的中位数作为$\theta$ 的点估计的后验中位数估计</li>
<li>使用后验分布的均值作为$\theta$的点估计的后验期望估计</li>
</ul>
<p>用得最多的是后验期望估计，它一般也简称为贝叶斯估计，记为$\hat\theta_B$</p>
<h5 id="例1-8"><a href="#例1-8" class="headerlink" title="例1"></a>例1</h5><p><img src="/2021/06/10/%E6%A6%82%E7%8E%87%E8%AE%BA%E7%AC%AC%E5%85%AD%E7%AB%A0/3.png" alt></p>
<h3 id="共轭先验分布"><a href="#共轭先验分布" class="headerlink" title="共轭先验分布"></a>共轭先验分布</h3><p>从上面贝叶斯公式可以看出，整个贝叶斯统计推断只要先验分布确定后就没有理论上的困难。关于先验分布的确定有多种途径，此处我们介绍一类最常用的先验分布类——共轭先验分布</p>
<p>设 $\theta$ 是总体分布$p(x;\theta)$ 中的参数，$\pi(\theta)$ 是先验分布，若对任意来自$p(x;\theta)$的样本观测值得到的后验分布$\pi(\theta|X)$ 与 $\pi(\theta)$ 属于同一个分布族，则称该分布族是$\theta$的共轭先验分布(族)</p>
<h2 id="区间估计"><a href="#区间估计" class="headerlink" title="区间估计"></a>区间估计</h2><p>上面我们都在说点估计，也就是找一个 $\hat\theta = \hat\theta(x_1,\cdots,x_n)$ 作为 $\theta$ 的估计。 但是现在我们来讲区间估计，也就是要找两个点，令其为 $\hat\theta_L,\hat\theta_U$ 使得 $\hat\theta_L&lt;\hat\theta_U$ 。 这样就能够构成一个区间来估计未知参数。因此，这个区间的<strong>精确度</strong>和<strong>准确度</strong>就变得十分重要。</p>
<p>什么是<strong>准确度</strong>？ 在点估计中，可以用MSE来衡量估计的准确度。但是在区间估计中，我们就想让区间能盖住$\theta$ 的概率尽可能大，但是又不能让区间长度太大。因此我们引入<strong>置信区间</strong>的概念。</p>
<p><strong>定义1：</strong></p>
<p>设 $\theta$ 是总体的一个参数，其参数空间为 $\Theta$， $x_1,x_2\cdots,x_n$ 是来自该总体的样本，对给定的一个$\alpha$, 若对于任意的 $\theta\in\Theta$， 有：</p>
<script type="math/tex; mode=display">
P_\theta(\hat\theta_L\leq \theta\leq \hat\theta_U)\geq 1-\alpha</script><p>则称 $[\hat\theta_L,\hat\theta_U]$ 为$\theta$的置信水平为 $1-\alpha$ 的置信区间。 $\hat\theta_L$ 和 $\hat\theta_U$ 分别是 $\theta$ 的置信下限和置信上限。我们用频率来解释置信水平。 平均而言，在大量的区间估计观测值中，至少有 $100(1-\alpha)\%$ 包含$\theta$。因此，我们希望置信水平越大越好，$\alpha$ 通常是一个较小的值</p>
<p>了解了置信区间，现在我们再来定义<strong>同等置信区间、(单侧)置信下限、(单侧)置信上界</strong></p>
<p><strong>定义2：</strong></p>
<p>如果说，上面置信区间的定义左右两边恰好取等于号时</p>
<script type="math/tex; mode=display">
P_\theta(\hat\theta_L\leq \theta\leq \hat\theta_U)= 1-\alpha</script><p>则称 $[\hat\theta_L,\hat\theta_U]$ 为$\theta$的置信水平为 $1-\alpha$ 的<strong>同等置信区间</strong>。</p>
<p><strong>定义3：</strong></p>
<p>如果我们构造的区间 形如 $[\hat\theta_L,\infty)$ 那么我们可以定义满足下式时： </p>
<script type="math/tex; mode=display">
P_\theta(\hat\theta_L\leq\theta)\geq 1-\alpha</script><p>称 $\hat\theta_L$ 为$\theta$ 的置信水平为 $1-\alpha$ 的(单侧)置信下限。类似的可以定义<strong>同等置信下限</strong></p>
<p><strong>定义4：</strong></p>
<p>如果我们构造的区间 形如 $(-\infty,\hat\theta_U]$ 那么我们可以定义满足下式时： </p>
<script type="math/tex; mode=display">
P_\theta(\hat\theta_U\geq\theta)\geq 1-\alpha</script><p>称 $\hat\theta_U$ 为$\theta$ 的置信水平为 $1-\alpha$ 的(单侧)置信上限。类似的可以定义<strong>同等置信上限</strong></p>
<p>那什么又是<strong>精确度</strong>呢？</p>
<p>通常可以用区间的长度来度量其精确度。我们希望这个区间的长度越短越好。</p>
<p>那么怎么去寻找一个合适的置信区间呢？是选择双侧的置信区间还是单侧的置信区间呢？我们要去看估计的参数的目标是什么。比如说我要估计在一个流水线上螺丝钉的大小，因为螺丝钉的大小一定是有标准的，这时候我们就要使用双侧估计，我们称其为<strong>望目</strong>，我们是基于目标值给出一个区间估计。 另外一种情况是<strong>望大</strong>或<strong>望小</strong>，比如说要去考虑某个行业的收入水平，理论上来说我给出的应该是一个单侧区间，因为不会给出一个收入的天花板，这时候我希望这个参数越大越好。</p>
<p>那么如何构造一个置信区间呢？接下来我们来学习 <strong>枢轴量法</strong></p>
<h3 id="枢轴量"><a href="#枢轴量" class="headerlink" title="枢轴量"></a>枢轴量</h3><p>枢轴量法的步骤可以概括为如下三步：</p>
<ol>
<li>设法构造一个样本和 $\theta$ 的函数 $G = G(x_1,x_2\cdots,x_n,\theta)$ 使得 G 不依赖于未知参数。一般称这种性质的G 为枢轴量. 还有就是枢轴量的<strong>分布已知</strong>。 但在这之前，我们得先找找待估参数的点估计。</li>
<li>适当地选择两个常数 c,d 使对给定的 $\alpha(0&lt;\alpha&lt;1)$ 有：</li>
</ol>
<script type="math/tex; mode=display">
P(c\leq G\leq d) = 1-\alpha</script><p>在离散场合，上式的等号需改为$\geq$</p>
<ol>
<li>加入能将 $c\leq G\leq d$ 进行不等式等价变形化为 $\hat\theta_L\leq \theta\leq \hat\theta_U$,则有：</li>
</ol>
<script type="math/tex; mode=display">
P_\theta(\hat\theta_L\leq \theta\leq \hat\theta_U)= 1-\alpha</script><p>这表明$[\hat\theta_L,\hat\theta_U] $ 是 $\theta$ 的 $1-\alpha$ 的同等置信空间。</p>
<p>能满足 $P(c\leq G\leq d) = 1-\alpha$ 的c 、d取值有很多，选择的目的是希望 $E_\theta(\hat\theta_U-\hat\theta_L)$ 尽可能短。其实，很难找到最佳的c、d,一般是让两个尾部的概率各位$\alpha/2$ 即：</p>
<script type="math/tex; mode=display">
P_\theta(G<c) = P_\theta(G>d) = \alpha/2</script><p>现在我们来讲几个例子：</p>
<h5 id="例1-9"><a href="#例1-9" class="headerlink" title="例1"></a>例1</h5><p>$x_1,x_2\cdots,x_n\sim N(\mu,\sigma_0^2)$ , $\sigma_0$ 已知，用枢轴量法来估计$\mu$ </p>
<p><strong>第一步</strong>求 $\mu$ 的点估计 ： $\hat\mu = \overline x$</p>
<p><strong>第二步</strong> 求 $\overline x$ 的分布 即 $\overline x\sim N(\mu,\frac{\sigma_0^2}{n})$ </p>
<p><strong>第三步</strong> 标准化 ， </p>
<script type="math/tex; mode=display">
G = \frac{\overline x-\mu}{\sqrt{\frac{\sigma_0^2}{n}}}\sim N(0,1)</script><p>现在， G 是一个枢轴量了，因为只和样本、待估参数 $\mu$ 有关，没有未知参数，且G的分布已知</p>
<p><strong>第四步</strong> 我们的目标是找到一个区间，把这个区间用足(区间准确率又要高，区间长度又要短)。</p>
<p>我们要找两个分位数点，使得被这两个点<strong>夹住</strong> 的部分的概率等于 $1-\alpha$ </p>
<p>假设我定义左边的点为 $u<em>{\alpha_1}$,右边的点为 $\mu</em>{\alpha_2}$,如下图所示：</p>
<p><img src="/2021/06/10/%E6%A6%82%E7%8E%87%E8%AE%BA%E7%AC%AC%E5%85%AD%E7%AB%A0/4.jpg" style="zoom: 67%;"></p>
<p>我们用 $\alpha_1$表示 $\alpha_2$，那么从面积来看，$\alpha_2$ 为左侧两块面积之和即 $\alpha_2 =1- (\alpha-\alpha_1)$</p>
<p> 我一定能找到这样的分位数点，使得：</p>
<script type="math/tex; mode=display">
P(u_{\alpha_1}\leq \frac{\overline x-\mu}{\sqrt{\frac{\sigma_0^2}{n}}}\leq u_{1-(\alpha-\alpha_1)}) = 1-\alpha</script><p><strong>第五步</strong> 反解 $\mu$</p>
<script type="math/tex; mode=display">
P(\overline x-u_{1-(\alpha-\alpha_1)}\cdot\sqrt{\frac{\sigma_0^2}{n}}\leq u\leq\overline x-u_{\alpha_1}\sqrt{\frac{\sigma_0^2}{n}}) = 1-\alpha</script><p>可以证明 当 $\alpha<em>1 = \alpha/2$ 时，区间长度最小。此时，$u</em>{\alpha<em>1} = -u</em>{1-\frac{\alpha}2}$</p>
<p><strong>第六步</strong> 得出区间估计</p>
<script type="math/tex; mode=display">
[\overline x-u_{1-\frac\alpha2}\cdot\sqrt{\frac{\sigma_0^2}{n}},\overline x+u_{1-\frac{\alpha}{2}}\sqrt{\frac{\sigma_0^2}{n}}]</script><h5 id="例2-3"><a href="#例2-3" class="headerlink" title="例2"></a>例2</h5><p>现在，我们对原题做一个小变形，就是说把 $\sigma_0$ 从已知改成未知。</p>
<p>即 $x_1,x_2\cdots,x_n\sim N(\mu,\sigma^2)$  要估计 参数 $\mu$ </p>
<p><strong>第一步</strong>求 $\mu$ 的点估计 ： $\hat\mu = \overline x$</p>
<p><strong>第二步</strong> 求 $\overline x$ 的分布 即 $\overline x\sim N(\mu,\frac{\sigma^2}{n})$ </p>
<p><strong>第三步</strong> 标准化 ， </p>
<script type="math/tex; mode=display">
\frac{\overline x-\mu}{\sqrt{\frac{\sigma^2}{n}}}\sim N(0,1)</script><p>我们发现这时候标准化后的式子不再是枢轴量了，因为里面包含了一个 未知的”讨厌参数“ $\sigma$ </p>
<p>该怎么办？</p>
<p><strong>第四步</strong> </p>
<p>既然$\sigma$未知，不妨用 $\sigma^2$ 的估计代替 $\sigma^2$，也就是 $\hat\sigma^2 = s^2$， 再带入原式得：</p>
<script type="math/tex; mode=display">
G= \frac{\overline x-\mu}{\sqrt{\frac{s^2}{n}}} = \frac{\frac{\overline x-\mu}{\sqrt{\sigma^2/n}}}{\sqrt{\frac{(n-1)s^2}{\sigma^2}/(n-1)}}</script><p>现在G 已经是一个枢轴量了，因为变形之后 $\sigma^2$ 会被约掉</p>
<p>上面是一个标准正态N(0,1)， 下面是一个卡方分布/(n-1) ，这说明  $G\sim t(n-1)$ </p>
<p><strong>第五步</strong> 变形</p>
<p>类似于上一个例子，可以得到此时 $\mu$ 的 $1-\alpha$ 置信区间为</p>
<script type="math/tex; mode=display">
\overline x \pm t_{1-\alpha/2}(n-1)\frac{s}{\sqrt n}</script><h5 id="例3-2"><a href="#例3-2" class="headerlink" title="例3"></a>例3</h5><p>$x_1,x_2\cdots,x_n\sim U(0,\theta)$ ,用枢轴量法来估计$\theta$  </p>
<p><strong>第一步</strong> 求 $\theta$ 的点估计 ： $\hat\theta =x_{n}$</p>
<p><strong>第二步</strong> 求  $x<em>{(n)}$ 的分布 即 $G = \frac{x</em>{(n)}}{\theta}\sim Be(n,1)$ </p>
<p><strong>第三步</strong> </p>
<script type="math/tex; mode=display">
P(c \leq \frac{x_{(n)}}{\theta}\leq d)=1-\alpha</script><p>$c,d$ 是贝塔分布的两个分位数点, </p>
<script type="math/tex; mode=display">
P(x\leq c) = \int_0^c n x^{n-1}dx = x^n|_0^c = c^n</script><p>因此 我们要选择适当的c和d使得：$d^n-c^n = 1-\alpha$</p>
<p><strong>第四步</strong> 变形得到：</p>
<script type="math/tex; mode=display">
\frac{x_{(n)}}{d}\leq \theta\leq \frac{x_{(n)}}{c}</script><p>该区间的平均长度为 $(\frac{1}{c}-\frac{1}{d})E(x_{(n)})$ ，在上述条件下，求导两次可以得到：当 $d=1,c=\sqrt[n]{\alpha}$ 时，$\frac{1}{c}-\frac{1}{d}$取最小值，这说明：</p>
<script type="math/tex; mode=display">
[x_{(n)},x_{(n)}/\sqrt[n]{\alpha}]</script><p>是 $\theta$ 的此类区间估计中置信水平为 $1-\alpha$ 的最短置信区间</p>
<h5 id="例4-1"><a href="#例4-1" class="headerlink" title="例4"></a>例4</h5><p>现在我们来估计 $\sigma^2$</p>
<p>也就是 $x_1,x_2\cdots,x_n\sim N(\mu,\sigma^2)$ </p>
<p><strong>第一步：</strong> 给出$\sigma^2$ 的点估计：  $\hat\sigma^2 = s^2$ </p>
<p><strong>第二步：</strong> 求出  $s^2$ 的分布： </p>
<script type="math/tex; mode=display">
G = \frac{(n-1)s^2}{\sigma^2}\sim\mathcal{X}(n-1)</script><p>这个量是枢轴量，因为分布已知且只和待估参数有关</p>
<p><strong>第三步：</strong></p>
<script type="math/tex; mode=display">
\mathcal{X}_{\alpha_1}^2(n-1) \leq \frac{(n-1)s^2}{\sigma^2}\leq \mathcal{X}^2_{1-(\alpha-\alpha_1)}(n-1)</script><p><strong>第四步</strong> 反解得到：</p>
<script type="math/tex; mode=display">
\frac{(n-1)s^2}{\mathcal{X}^2_{1-(\alpha-\alpha_1)}(n-1)} \leq \sigma^2\leq \frac{(n-1)s^2}{\mathcal{X}^2_{\alpha_1}(n-1)}</script><p>值得注意的是，这两个点并不是关于0对称的，因为卡方本身并不是一个对称分布。那么这两个点怎么找呢？找最优解是很麻烦的，实际上我们直接令 $\alpha_1 = \alpha/2$ 即可。实际中， $\alpha/2$和 最优解的相差也并不是很大。</p>
<p><img src="/2021/06/10/%E6%A6%82%E7%8E%87%E8%AE%BA%E7%AC%AC%E5%85%AD%E7%AB%A0/5.jpg" style="zoom: 67%;"></p>
<p><strong>例题5</strong></p>
<p>上面说的都是连续的估计，现在我们来说一下离散的估计。</p>
<p>$x_1,x_2\cdots,x_n\sim b(1,\theta)$ ，让我们估计事件A成功地概率 $\theta$</p>
<p><strong>第一步</strong>： 求出$\theta$的点估计。</p>
<script type="math/tex; mode=display">
\hat\theta = \overline x = \frac{1}{n}\sum_{i=1}^n x_i</script><p><strong>第二步</strong>：求 $\overline x$ 的分布 </p>
<script type="math/tex; mode=display">
\sum x_i = n\overline x \sim b(n,\theta)</script><p><strong>第三步</strong>：标准化，用中心极限定理</p>
<script type="math/tex; mode=display">
(CLT) G = \frac{\overline x-\theta}{\sqrt{\frac{\theta(1-\theta)}{n}}}\sim N(0,1)</script><p>这是一个枢轴量，因为分布已知且只与目标参数 $\theta$ 有关</p>
<p><strong>第四步</strong> 构造近似置信区间</p>
<p>因为这是一个对称的分布，所以我们可以这样写：</p>
<script type="math/tex; mode=display">
(\frac{\overline x-\theta}{\sqrt{\frac{\theta(1-\theta)}{n}}})^2\leq (u_{1-\alpha/2})^2</script><p>解得</p>
<script type="math/tex; mode=display">
(\overline x-\theta)^2 \leq(u_{1-\alpha/2})^2 \cdot (\frac{\theta(1-\theta)}{n})\\~\\
\theta\in[\overline x-u_{1-\frac{\alpha}2}\cdot \sqrt{\frac{\overline x(1-\overline x)}{n}},\overline x+u_{1-\frac{\alpha}2}\cdot \sqrt{\frac{\overline x(1-\overline x)}{n}}]</script><p>从上面这个式子来看，在对称的枢轴量分布时(通常是标准正态)，可以直接求解：</p>
<script type="math/tex; mode=display">
G^2\leq (u_{1-\frac{\alpha}2})^2</script><p>来求解未知参数</p>
<h5 id="例题6"><a href="#例题6" class="headerlink" title="例题6"></a>例题6</h5><p>现在我们来讲两个正态总体下的置信空间</p>
<p>设 $x_1,\cdots,x_n$​ 是来自 $N(\mu_1,\sigma_1^2)$​ 的样本 ，$y_1,\cdots,y_n$​ 是来自$N(\mu_2 ,\sigma_2^2)$​ 的样本，且两个样本相互独立 ,$\sigma_1^2,\sigma_2^2$​ 已知。$\overline x$​ 和 $\overline y$​ 是他们的样本均值，现在我们要计算 $\theta = \mu_1-\mu_2$​ 的置信区间 </p>
<p><strong>第一步</strong>:  </p>
<p>求出 $\theta$ 的点估计： $\hat\theta = \hat x-\hat y$ </p>
<p>因为 $\overline x\sim N(\mu_1,\frac{\sigma_1^2}{m}),\overline y \sim N(\mu_2,\frac{\sigma_2^2}{n})$ </p>
<p>因此 $\hat\theta \sim N(\mu_1-\mu_2.\frac{\sigma_1^2}{m}+\frac{\sigma_2^2}n)$  </p>
<p><strong>第二步</strong> 标准化</p>
<script type="math/tex; mode=display">
G = \frac{\overline x-\overline y-\theta}{\sqrt{\frac{\sigma_1^2}{m}+\frac{\sigma_2^2}{n}}}\sim N(0,1)</script><p><strong>第三步</strong></p>
<script type="math/tex; mode=display">
P(u_{\alpha/2}\leq G\leq u_{1-\alpha/2})=1-\alpha \\~\\
G^2\leq u^2_{1-\frac{\alpha}{2}}\\~\\
\theta\in \overline x-\overline y \pm u_{1-\frac{\alpha}2}\sqrt{\frac{\sigma_1^2}{m}+\frac{\sigma^2}{n}}</script><h5 id="例题7"><a href="#例题7" class="headerlink" title="例题7"></a>例题7</h5><p>刚才说的是, $\sigma_1^2,\sigma_2^2$ 已知的情况，现在来谈谈 ,$\sigma_1^2,\sigma_2^2$ 未知的情况</p>
<p><strong>第一步</strong>： 求 $\theta$ 的点估计 $\hat\theta=\overline x-\overline y = \mu_1-\mu_2$</p>
<p><strong>第二步：</strong>  $\overline x\sim N(\mu_1,\frac{\sigma^2}{m}),\overline y \sim N(\mu_2,\frac{\sigma^2}{n})$​ </p>
<script type="math/tex; mode=display">
\hat\theta = \overline x-\overline y \sim N(\mu_1-\mu_2,(\frac1m+\frac1n)\sigma^2)</script><p><strong>第三步</strong> 标准化</p>
<script type="math/tex; mode=display">
\frac{\overline x-\overline y-\theta}{\sqrt{(\frac1m+\frac1n)\sigma^2}}\sim N(0,1)</script><p>这并不是一个枢轴量，我们需要把 $\sigma^2$ 换成样本方差。</p>
<p> <strong>第四步：</strong></p>
<p>那么在两样本的时候，样本方差就要用合方差来替换：</p>
<script type="math/tex; mode=display">
\hat\sigma^2 = s_w^2 = \frac{(m-1)s_x^2+(n-1)s_y^2}{m+n-2}\sim\mathcal{X}^2(m+n-2)</script><p><strong>第五步：</strong> 带入原式构造枢轴量：</p>
<script type="math/tex; mode=display">
G= \sqrt{\frac{m+n}{mn}}\frac{\overline x-\overline y-\theta}{\sqrt{s_w^2}}\sim t(m+n-2)</script><p><strong>第六步</strong></p>
<p>反解得到： </p>
<script type="math/tex; mode=display">
\overline x-\overline y \pm \sqrt\frac{m+n}{mn}s_wt_{1-\alpha/2} (m+n-2)</script><h5 id="例题8"><a href="#例题8" class="headerlink" title="例题8"></a>例题8</h5><p>求 $\theta = \frac{\sigma_1^2}{\sigma_2^2}$ 的区间估计，在这种情况下，$\mu_1,\mu_2$ 都是默认未知的</p>
<p><strong>第一步：</strong> 求 $\theta$ 的点估计。</p>
<script type="math/tex; mode=display">
\theta = \frac{\sigma_1^2}{\sigma_2^2}~~~, ~\hat\theta = \frac{s_x^2}{s_y^2}</script><p><strong>第二步</strong>： 构造枢轴量：</p>
<p>已知 $s_x^2,s_y^2$ 是互相独立且可以变换成 $\mathcal{X}^2$ 分布</p>
<script type="math/tex; mode=display">
\frac{s_x^2/\sigma_1^2}{s_y^2/\sigma_2^2}\sim F(m-1,n-1)</script><p> <strong>第三步</strong>：</p>
<script type="math/tex; mode=display">
P(F_{\frac{\alpha}2}(m-1,n-1)\leq \frac{s_x^2}{s_y^2}\cdot \frac{\sigma_2^2}{\sigma_1^2}\leq F_{1-\alpha/2}(m-1,n-1))\\~\\</script><p><strong>第四步：</strong> 反解得到：</p>
<script type="math/tex; mode=display">
\theta\in [\frac{s_x^2}{s_y^2}\frac{1}{F_{1-\alpha/2}(m-1,n-1)},\frac{s_x^2}{s_y^2}\frac{1}{F_{\alpha/2}(m-1,n-1)}]</script>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/" class="post-title-link" itemprop="url">计算机网络-期末大作业</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-06-05 14:21:36" itemprop="dateCreated datePublished" datetime="2021-06-05T14:21:36+08:00">2021-06-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-23 22:24:16" itemprop="dateModified" datetime="2022-08-23T22:24:16+08:00">2022-08-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机网络-期末大作业"><a href="#计算机网络-期末大作业" class="headerlink" title="计算机网络-期末大作业"></a>计算机网络-期末大作业</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><p>在这个编程作业中，你将用Java语言开发一个简单的Web服务器，它仅能处理一个请求，具体而言，你的Web服务器将：</p>
<ol>
<li>当一个客户(浏览器)联系时创建一个连接套接字；</li>
<li>从这个连接接收HTTP请求</li>
<li>解释该请求以确定所请求的特定文件</li>
<li>从服务器的文件系统获得请求的文件</li>
<li>创建一个由请求的文件组成的HTTP响应报文，报文前面有首部行</li>
<li>经TCP连接向请求的浏览器返回响应</li>
</ol>
<h4 id="具体需求"><a href="#具体需求" class="headerlink" title="具体需求"></a>具体需求</h4><ul>
<li>请使用 ServerSocket 和 Socket 进行代码实现</li>
<li>请使用多线程接管连接</li>
<li>在浏览器中输入<code>localhost:8081/index.html</code> 能显示出自己的学号</li>
<li>在浏览器中输入 <code>localhost:8081</code> 下其他无效路径显示404not found</li>
<li>在浏览器中输入 <code>localhost:8081/shutdown</code> 能使服务器关闭</li>
<li>使用postman再次进行测试，测试 <code>get/post</code>两种请求方法</li>
</ul>
<h3 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h3><p>在这个编程作业中，你将用java语言研发一个简单的Web代理服务器</p>
<ol>
<li>当你的代理服务器从一个浏览器接收到对某个对象的HTTP请求，他生成对相同对象的一个新HTTP请求并向初始服务器发送</li>
<li>当该代理从初始服务器接收到具有该对象的HTTP响应时，它生成一个包括该对象的新HTTP 响应，并发送给该客户</li>
<li>这个代理将是多线程的，使其在同一时间能够处理多个请求</li>
</ol>
<h4 id="具体需求-1"><a href="#具体需求-1" class="headerlink" title="具体需求"></a>具体需求</h4><ul>
<li>在题目1.1 的代码上进行修改，使用ServerSocket和 Socket 进行代码实现</li>
<li>请使多线程接管连接(最好使用线程池)</li>
<li>请分别使用浏览器和postman 进行代理的测试</li>
</ul>
<h4 id="功能和性能需求"><a href="#功能和性能需求" class="headerlink" title="功能和性能需求"></a>功能和性能需求</h4><ul>
<li>之后会给大家一个压测的client端进行测试，在保证功能完整的前提下测试每秒相应的请求数</li>
<li><strong>附加题(选做)</strong> : 分析现有的 能支持同时连接的最大数，修改代码使得服务器能同时支持一千个连接(需要使用NIO)</li>
</ul>
<h2 id="开发历程"><a href="#开发历程" class="headerlink" title="开发历程"></a>开发历程</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="反-序列化"><a href="#反-序列化" class="headerlink" title="(反)序列化"></a>(反)序列化</h4><p>要求我们开发一个Java后端，我这里使用了Maven，方便后期对项目进行管理和维护。因此，引入(反)序列化对项目的配置(环境变量、端口号等)进行管理是必不可少的。那么在这个项目中，我们用JSON 来存放关于项目的配置信息，并通过 Jackson 将JSON 中的键值对序列化后变成Java对象。</p>
<p>那么首先就要用maven引入 Jakson包，因此我们需要在 <code>pom.xml</code>中添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Dependencies --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意了，我们这里需要在idea的设置中对两个地方进行修改：</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/2.png" style="zoom:67%;"></p>
<p>第一个在maven设置中三个都要勾选，可以自动下载依赖。</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/1.png" style="zoom:67%;"></p>
<p>在第二个在maven&gt;import 中，要勾选这两个Override，将maven库改为本地的仓库。 否则在引入Jackson是会出现找不到包的情况。</p>
<p>进入到正式的序列化</p>
<p>首先在项目文件夹中新建一个 <code>util</code> 文件夹来存放 <code>Json</code>类，这个类会的作用能让 JSON中的键值对和java对象之间相互转换。</p>
<p>这里我要讲几个预备知识：</p>
<ul>
<li><code>ObjectMapper</code>类是Jackson库的主要类，它提供一些功能将数据集或对象转换的实现。</li>
<li>将 JSON 转换为Java 对象，称为反序列化。但是考虑到 JSON中的 key值和对象中的成员名可能不完全一致，因此需要在 <code>configure()</code> 中将<code>DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</code>设置为false。</li>
<li>JsonNode类是Jackson库的一个类，该类可以很容易的操作Json格式的数据。如获取某个简单json串中某个key的值、获取某个层层嵌套的json串中某个key的值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.httpserver.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Json</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ObjectMapper myObjectMapper = defaultObjectMapper();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ObjectMapper <span class="title">defaultObjectMapper</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> om;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 这个parse函数的作用是收到 是一个json格式String,得到的是一个JsonNode类型                                          </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JsonNode <span class="title">parse</span><span class="params">(String jsonSrc)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myObjectMapper.readTree(jsonSrc);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 这个fromJson接受两个参数：JsonNode和目标类，目的是将JsonNode转换成自定义的java类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A&gt; <span class="function">A <span class="title">fromJson</span><span class="params">(JsonNode node,Class&lt;A&gt; clazz)</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myObjectMapper.treeToValue(node,clazz);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// toJson 和 fromJson的作用相反，是将自定义的java类转换成JsonNode</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JsonNode <span class="title">toJson</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myObjectMapper.valueToTree(obj);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//将JsonNode 序列化成一个 JSON 字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">stringify</span><span class="params">(JsonNode node)</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> generateJson(node,<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果打开SerializationFeature.INDENT_OUTPUT这个特性开关，能以多行缩进格式化的格式输出JSON</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generateJson</span> <span class="params">(Object o,<span class="keyword">boolean</span> pretty)</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">        ObjectWriter objectWriter = myObjectMapper.writer();</span><br><span class="line">        <span class="keyword">if</span> (pretty)&#123;</span><br><span class="line">            objectWriter = objectWriter.with(SerializationFeature.INDENT_OUTPUT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> objectWriter.writeValueAsString(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们就要写将JSON字符串转化成哪个Java类了。</p>
<p>我们创建一个 <code>Configuration</code>类，用来存放 json 中的键值对信息：</p>
<p>因为当前有两个键值对： <code>port</code> 和 <code>webroot</code> ，因此我们要为这两个变量设置getter和setter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.httpserver.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> String webroot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Configuration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPort</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWebroot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> webroot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWebroot</span><span class="params">(String webroot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.webroot = webroot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是单单有这个 <code>Configuration</code> 类，还是不够的，我们还需要一个<strong>经纪人</strong>，负责读取JSON文件，并将其注入<code>Configuration</code>对象中. 我们将其命名为 <code>ConfigurationManager</code> 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.httpserver.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.JsonNode;</span><br><span class="line"><span class="keyword">import</span> com.httpserver.util.Json;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationManager</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConfigurationManager myConfigurationManager;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  Configuration myCurrentConfiguration;</span><br><span class="line"><span class="comment">// Configuration的构造函数，这里将其私有化了</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ConfigurationManager</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 暴露一个 getInstance()方法，返回一个实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurationManager <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (myConfigurationManager ==<span class="keyword">null</span>)</span><br><span class="line">            myConfigurationManager = <span class="keyword">new</span> ConfigurationManager();</span><br><span class="line">        <span class="keyword">return</span> myConfigurationManager;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Used to load a configuration file aby the path provided</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"><span class="comment">//这个方法是关键，也就是读取JSON文件，生成Configuration对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadConfigurationFile</span><span class="params">(String filePath)</span></span>&#123;</span><br><span class="line">        FileReader fileReader = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 创建一个 FileReader 并读取文件</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileReader = <span class="keyword">new</span> FileReader(filePath);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HttpConfigurationException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!((i=fileReader.read())!=-<span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> HttpConfigurationException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append((<span class="keyword">char</span>)i);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 创建一个JsonNode 用来存放 parse()返回的信息</span></span><br><span class="line">        JsonNode conf = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conf = Json.parse(sb.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HttpConfigurationException(<span class="string">"Error parsing the configuration file"</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 利用 fromJson 方法将JsonNode中的信息放入Configuration类中</span></span><br><span class="line">            myCurrentConfiguration = Json.fromJson(conf,Configuration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HttpConfigurationException(<span class="string">"Error parsing the configuration file,internal"</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Returns the current loaded Configuration</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">  <span class="comment">// 将处理好的 Configuration 对象返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Configuration <span class="title">getCurrentConfiguration</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (myCurrentConfiguration == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HttpConfigurationException(<span class="string">"No Current Configuration Set."</span>);</span><br><span class="line">        &#125;<span class="keyword">return</span> myCurrentConfiguration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到我上面在处理异常的时候用到的是<code>HttpConfigurationException</code> 这是一个我自定义的异常类,其继承自<code>IOException</code></p>
<p><strong>测试</strong></p>
<p>我现在在<code>resource</code>文件加下编写 <code>http.json</code>文件</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"port"</span>: <span class="number">8080</span>,</span><br><span class="line">  <span class="attr">"webroot"</span>: <span class="string">"/java"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后创建 HttpServer类，作为启动器，并在 main方法中写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Server Starting..."</span>);</span><br><span class="line">				<span class="comment">// 首先，利用经纪人将http.json注入内置的Configuration对象中</span></span><br><span class="line">        ConfigurationManager</span><br><span class="line">                          .getInstance()</span><br><span class="line">                          .loadConfigurationFile(<span class="string">"src/main/resources/http.json"</span>);</span><br><span class="line">  		<span class="comment">// 然后利用getCurrentConfiguration() 来返回这个对象</span></span><br><span class="line">        Configuration conf = ConfigurationManager</span><br><span class="line">                          .getInstance()</span><br><span class="line">                          .getCurrentConfiguration();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Using Port: "</span>+ conf.getPort());</span><br><span class="line">        System.out.println(<span class="string">"Using WebRoot: "</span>+ conf.getWebroot());</span><br><span class="line">        </span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其中，JsonNode 打印结果如下：</p>
<p><code>{&quot;port&quot;:8080,&quot;webroot&quot;:&quot;/java&quot;}</code></p>
<p>整个打印结果如下：</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/3.png" style="zoom: 150%;"></p>
<h4 id="日志插件"><a href="#日志插件" class="headerlink" title="日志插件"></a>日志插件</h4><p>在后端测试中，在终端使用日志是十分重要的。虽然可以使用<code>System.out</code> 但是在多线程情况下，输出日志能让我们的程序显得更加严谨并让我们得到更多信息</p>
<p>首先还是在 <code>pom.xml</code>中添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--LOGGING--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>等待自动下载完成后，就可以对整个类使用Logger了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = (Logger) LoggerFactory.getLogger(HttpServer<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>对于一个项目来说，后期的测试是必不可少的因此我们使用测试工具 junit</p>
<p>首先在 <code>pom.xml</code> 中添加依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.0-M5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后只要对特定的类建立测试类即可</p>
<h3 id="解决单个client-连接"><a href="#解决单个client-连接" class="headerlink" title="解决单个client 连接"></a>解决单个client 连接</h3><p>现在我们来模拟单个链接时的情况，功能十分简陋，远不是最终成型的样子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Server Starting..."</span>);</span><br><span class="line"></span><br><span class="line">        ConfigurationManager.getInstance().loadConfigurationFile(<span class="string">"src/main/resources/http.json"</span>);</span><br><span class="line">        Configuration conf = ConfigurationManager.getInstance().getCurrentConfiguration();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Using Port: "</span>+ conf.getPort());</span><br><span class="line">        System.out.println(<span class="string">"Using WebRoot: "</span>+ conf.getWebroot());</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          <span class="comment">// 创建一个 ServerSocket</span></span><br><span class="line">            ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(conf.getPort());</span><br><span class="line">          <span class="comment">// 当接入client之后，创建套接字</span></span><br><span class="line">            Socket socket = serverSocket.accept();</span><br><span class="line">				<span class="comment">// 创建输入输出流</span></span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            OutputStream outputStream = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">            String html = <span class="string">"&lt;html&gt;&lt;head&gt;&lt;title&gt;Hello,My name is Jason&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;My ID is 10195501423&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> String CRLF = <span class="string">"\n\r"</span>;</span><br><span class="line">				<span class="comment">// 编写返回信息</span></span><br><span class="line">          String response =</span><br><span class="line">                    <span class="string">"HTTP/1.1 200 OK"</span>+CRLF+</span><br><span class="line">                    <span class="string">"Content-Length: "</span>+html.getBytes(StandardCharsets.UTF_8).length+CRLF+</span><br><span class="line">                    CRLF+</span><br><span class="line">                    html+</span><br><span class="line">                    CRLF+CRLF;</span><br><span class="line">            outputStream.write(response.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            inputStream.close();</span><br><span class="line">            outputStream.close();</span><br><span class="line">            socket.close();</span><br><span class="line">            serverSocket.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 首先，在地址栏搜索 <code>localhost:8080</code>之后，会弹回一个html，如下图所示：</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/4.png" style="zoom: 150%;"></p>
<p>通过Wireshark抓包后，我们可以看出浏览器和我写的Java server中是存在tcp通讯的。当浏览器请求8080端口的时候，server就会发送一个tcp包</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/5.png" style="zoom: 150%;"></p>
<p>其中，响应报文如下，包括 HTTP版本，状态码以及数据内容，数据内容是一个html字符串。也就是我们 response的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Hypertext Transfer Protocol</span><br><span class="line">    HTTP&#x2F;1.1 200 OK\n</span><br><span class="line">    \r</span><br><span class="line">    [HTTP response 1&#x2F;1]</span><br><span class="line">    [Time since request: 0.040561000 seconds]</span><br><span class="line">    [Request in frame: 328]</span><br><span class="line">    [Request URI: http:&#x2F;&#x2F;localhost:8080&#x2F;]</span><br><span class="line">    File Data: 132 bytes</span><br><span class="line">    Data (132 bytes)</span><br></pre></td></tr></table></figure>
<h3 id="解决多个client-连接"><a href="#解决多个client-连接" class="headerlink" title="解决多个client 连接"></a>解决多个client 连接</h3><p>显然，刚才的实现方法是不理想的，因为只能连接一个client，且代码很乱。因此我们现在要优化刚才的代码，能让多个client连接. 这就需要用到多线程。</p>
<p>那么首先我们先用LOGGER来替换掉<code>System.out</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = (Logger) LoggerFactory.getLogger(HttpServer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="comment">// 直接用 LOGGER.info 就能输出</span></span><br><span class="line">        LOGGER.info(<span class="string">"Server Starting..."</span>);</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们架构一下接下来的操作：既然要多线程，那么我们必须保持socket 在一段时间内始终保持打开状态。然后对于每一个接入的client，可以新开一个线程。因此我们可以采用父子线程的方式来实现这个功能。父线程负责维持socket打开并接入client，子线程可以负责处理client的请求。</p>
<p>于是我们新建一个父线程类叫 <code>ListenerThread.java</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = (Logger) LoggerFactory.getLogger(HttpServer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> String webroot;</span><br><span class="line">    <span class="keyword">private</span> ServerSocket serverSocket;</span><br><span class="line">	<span class="comment">// 从 HttpServer 中获取port和 webroot</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListenerThread</span><span class="params">(<span class="keyword">int</span> port, String webroot)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.webroot = webroot;</span><br><span class="line">        <span class="keyword">this</span>.serverSocket = <span class="keyword">new</span> ServerSocket(<span class="keyword">this</span>.port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这个线程是一直等待的</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          <span class="comment">// 当 ServerSocket没关且被绑定在端口上的时候，这个线程就开着</span></span><br><span class="line">            <span class="keyword">while</span>(serverSocket.isBound()&amp;&amp;!serverSocket.isClosed()) &#123;</span><br><span class="line">                Socket socket = serverSocket.accept();</span><br><span class="line">              <span class="comment">// 每当接入一个client在日志中记入，并开启一个子线程</span></span><br><span class="line">                LOGGER.info(<span class="string">"Connection accepted: "</span>+socket.getInetAddress());</span><br><span class="line">                WorkerThread workerThread = <span class="keyword">new</span> WorkerThread(socket);</span><br><span class="line">                workerThread.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            LOGGER.error(<span class="string">"Problem with setting socket..."</span>,e);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (serverSocket!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后创建一个子线程类： <code>WorkerThread.java</code>， 子线程做的事情就是处理client发来的http请求，大量代码是复制的。不过因为父进程创建子进程时需要将socket传入，所以要创建一个参数为socket的构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.httpserver.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.httpserver.HttpServer;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = (Logger) LoggerFactory.getLogger(HttpServer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WorkerThread</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = socket.getInputStream();</span><br><span class="line">            outputStream = socket.getOutputStream();</span><br><span class="line">            String html = <span class="string">"&lt;html&gt;&lt;head&gt;&lt;title&gt;Hello,My name is Jason&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;My ID is 10195501423&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> String CRLF = <span class="string">"\n\r"</span>;</span><br><span class="line">            String response =</span><br><span class="line">                    <span class="string">"HTTP/1.1 200 OK"</span> + CRLF +</span><br><span class="line">                            <span class="string">"Content-Length: "</span> + html.getBytes(StandardCharsets.UTF_8).length + CRLF +</span><br><span class="line">                            CRLF +</span><br><span class="line">                            html +</span><br><span class="line">                            CRLF + CRLF;</span><br><span class="line"></span><br><span class="line">            outputStream.write(response.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            LOGGER.info(<span class="string">"   Connection Processing Finished"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            LOGGER.error(<span class="string">"Problem with communication"</span>,e) ;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//最后，当线程结束时，需要关闭 inputeStream、outPutStream和socket</span></span><br><span class="line">            <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (outputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    outputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    outputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后如下图所示，我们开启多个tag，同时访问 <code>localhost:8080</code> 发现使用了这种方式以后，后端会自动为连进来的client创建不同的进程</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/6.png" style="zoom: 150%;"></p>
<h3 id="解析请求"><a href="#解析请求" class="headerlink" title="解析请求"></a>解析请求</h3><p>刚才我们所做的，是非常简单的功能，也就是收到请求，不管请求什么，都返回相同的东西。因此不论我请求 <code>localhost:8080</code>还是<code>localhost:8080/index</code> 只要是在这个端口发起的请求，都会收到 My ID is 1019550123的返回结果。因此现在我们需要解析client发来的请求。</p>
<p> 要解析请求，首先我们要捕获 client发来的HTTP头部信息，我们可以这样来写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _byte;</span><br><span class="line"><span class="keyword">while</span>((_byte=inputStream.read())&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">    System.out.print((<span class="keyword">char</span>) _byte);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我在浏览器中请求 <code>localhost:8080/index</code>， 结果如下：</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/7.png" style="zoom: 150%;"></p>
<p>在请求头中包含了这是一个 GET 请求，路由是 <code>/index</code></p>
<p>整个HTTP请求的格式如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP-message &#x3D; start-line						&#x2F;&#x2F; 在请求时的格式是：method SP request-target SP HTTP-version CRLF</span><br><span class="line">							+(header-field CRLF) &#x2F;&#x2F;可能有多个信息</span><br><span class="line">							CRLF</span><br><span class="line">							[ message-body ]		&#x2F;&#x2F;请求体</span><br></pre></td></tr></table></figure>
<p>现在我们可以进行解析了。我们来介绍两种解析器: Lexer Parser 和 Lexerless Parser。 前者会把 socket发来的流先处理成token，再讲token转为我们想要的信息(请求方式、路由等)。后者则是直接转换。</p>
<p>这里我们使用后者，因为我们对时间的要求较高，需要对请求进行迅速解析。</p>
<p>搞清楚 HTTP 请求的格式之后，我们知道最重要的部分就是请求的方式以及请求的目标文件。这两者决定了Server怎么去响应请求。因此我们需要创建几个比较基础的类：<code>HttpMethod</code> 和<code>HttpStatusCode</code>是两个枚举类，分别用来放请求方法和状态码。<code>HttpRequest</code> 用来存放请求行的信息(请求方式、目标文件以及HTTP版本)</p>
<h4 id="HttpMethod"><a href="#HttpMethod" class="headerlink" title="HttpMethod"></a>HttpMethod</h4><p>这是一个枚举类，用来存放请求方式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.http.request;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> HttpMethod &#123;</span><br><span class="line">    GET,HEAD,POST,PUT,DELETE;</span><br><span class="line">    <span class="comment">// MAX_LENGTH 代表最长的请求方式，如果超出这个值就说明是非法请求</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_LENGTH;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> tempMaxLength = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(HttpMethod method:values())&#123;</span><br><span class="line">            <span class="keyword">if</span>(method.name().length()&gt;tempMaxLength)&#123;</span><br><span class="line">                tempMaxLength = method.name().length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        MAX_LENGTH = tempMaxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="HttpStatusCode"><a href="#HttpStatusCode" class="headerlink" title="HttpStatusCode"></a>HttpStatusCode</h4><p>这个类用来存放状态码，我这里列举了几个错误时发生的状态码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.http.request;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> HttpStatusCode &#123;</span><br><span class="line">    Client_ERROR_400_BAD_REQUEST(<span class="number">400</span>,<span class="string">"Bad request"</span>),</span><br><span class="line">    Client_ERROR_401_METHOD_NOT_ALLOWED(<span class="number">401</span>,<span class="string">"Method not allowed"</span>),</span><br><span class="line">    Client_ERROR_414_BAD_REQUEST(<span class="number">414</span>,<span class="string">"URL Too long"</span>),</span><br><span class="line">    SERVER_ERROR_500_INTERNAL_SERVER_ERROR(<span class="number">500</span>,<span class="string">"Internmal server error"</span>),</span><br><span class="line">    SERVER_ERROR_501_NOT_IMPLEMENTED(<span class="number">501</span>,<span class="string">"Internal server error"</span>),</span><br><span class="line">    SERVER_ERROR_404_NOT_FOUND(<span class="number">404</span>,<span class="string">"NOT FOUND"</span>),</span><br><span class="line">    SERVER_ERROR_200_OK(<span class="number">200</span>,<span class="string">"OK"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> STATUS_CODE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String MESSAGE;</span><br><span class="line"></span><br><span class="line">    HttpStatusCode(<span class="keyword">int</span> status_code, String message) &#123;</span><br><span class="line">        STATUS_CODE = status_code;</span><br><span class="line">        MESSAGE = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="HttpRequest"><a href="#HttpRequest" class="headerlink" title="HttpRequest"></a>HttpRequest</h4><p>这个类用来存放请求行的信息(请求方式、目标文件以及HTTP版本) </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.http.request;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HttpMethod method;</span><br><span class="line">    <span class="keyword">private</span> String requestTarget;</span><br><span class="line">    <span class="keyword">private</span> String httpVersion;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    HttpRequest() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpMethod <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//packege level</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMethod</span><span class="params">(String methodName)</span> <span class="keyword">throws</span> HttpParsingException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(HttpMethod method:HttpMethod.values())&#123;</span><br><span class="line">            <span class="keyword">if</span>(methodName.equals(methodName))&#123;</span><br><span class="line">                <span class="keyword">this</span>.method = method;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HttpParsingException(</span><br><span class="line">            HttpStatusCode.SERVER_ERROR_501_NOT_IMPLEMENTED</span><br><span class="line">            );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRequestTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> requestTarget;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRequestTarget</span><span class="params">(String requestTarget)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.requestTarget = requestTarget;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHttpVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> httpVersion;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHttpVersion</span><span class="params">(String httpVersion)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.httpVersion = httpVersion;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="HttpParser"><a href="#HttpParser" class="headerlink" title="HttpParser"></a>HttpParser</h4><p>这是解析器最重要的部分了，起作用相当一座桥梁，能够把 Byte转换为字符串。事实上需要对三个部分进行解析： 请求行、头部以及请求体。但是根据这个项目的要求，我们只要来解析请求行即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpParser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(HttpParser<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      	<span class="comment">//接下来对头部进行拆解，我们知道头部的格式是：</span></span><br><span class="line">      <span class="comment">/* Method+SP+Target+SP+HttpVersion+CRLF */</span></span><br><span class="line">      <span class="comment">//又这是通过字节流传送的，因此我们需要在一开始就查询空格换行的ASCII码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SP =<span class="number">0x20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CR =<span class="number">0x0D</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LF =<span class="number">0x0A</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 首先吗，从子线程传进来一个socket的输入流，然后在这个 parseHttpRequest方法中进行解析</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpRequest <span class="title">parseHttpRequest</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> HttpParsingException </span>&#123;</span><br><span class="line">        <span class="comment">// a bridge from Byte to String</span></span><br><span class="line">        InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(inputStream, StandardCharsets.US_ASCII);</span><br><span class="line"></span><br><span class="line">        HttpRequest request = <span class="keyword">new</span> HttpRequest();</span><br><span class="line">			<span class="comment">//解析请求行</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            parseRequestLine(reader,request);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//解析头部信息</span></span><br><span class="line">        parseHeaders(reader,request);</span><br><span class="line">      <span class="comment">//解析请求体</span></span><br><span class="line">        parseBody(reader,request);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseRequestLine</span><span class="params">(InputStreamReader reader, HttpRequest request)</span> <span class="keyword">throws</span> IOException, HttpParsingException </span>&#123;</span><br><span class="line">        StringBuilder processingDataBuffer = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> methodParsed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> requestTargetParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> _byte;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((_byte=reader.read())&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="comment">//如果读到 CR 了，就说明头部行即将结束在往后读取一个信息</span></span><br><span class="line">            <span class="keyword">if</span>(_byte==CR)&#123;</span><br><span class="line">                _byte = reader.read();</span><br><span class="line">              <span class="comment">//如果CR后面是LF，说明头部行已结束，最后一个part是Http Version，我们设置一下</span></span><br><span class="line">                <span class="keyword">if</span>(_byte == LF)&#123;</span><br><span class="line">                    LOGGER.debug(<span class="string">"Request Line VERSION to Process: &#123;&#125;"</span>, processingDataBuffer.toString());</span><br><span class="line">                    request.setHttpVersion(processingDataBuffer.toString());</span><br><span class="line">                <span class="comment">//因为读到最后一个部分了，但是前面的method和target却仍然未设置，说明出错了</span></span><br><span class="line">                    <span class="keyword">if</span>(!methodParsed || !requestTargetParsed)&#123;</span><br><span class="line">                        <span class="keyword">throw</span>  <span class="keyword">new</span> HttpParsingException(HttpStatusCode.Client_ERROR_414_BAD_REQUEST);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 如果读到空格，说明有一部分已经结束了</span></span><br><span class="line">            <span class="keyword">if</span>(_byte == SP)&#123;</span><br><span class="line">              <span class="comment">//method是第一部分，因此先判断method是否设置，若未设置则设置并把flag置为true</span></span><br><span class="line">                <span class="keyword">if</span>(!methodParsed)&#123;</span><br><span class="line">                    LOGGER.debug(<span class="string">"Request Line to Process: &#123;&#125;"</span>, processingDataBuffer.toString());</span><br><span class="line">                    request.setMethod(processingDataBuffer.toString());</span><br><span class="line">                    methodParsed = <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!requestTargetParsed)&#123;</span><br><span class="line">              <span class="comment">// 然后判断 target是否已设置，若未设置则把target置为true</span></span><br><span class="line">                    LOGGER.debug(<span class="string">"Request Line to Process: &#123;&#125;"</span>, processingDataBuffer.toString());</span><br><span class="line">                    request.setRequestTarget(processingDataBuffer.toString());</span><br><span class="line">                    requestTargetParsed=<span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  <span class="comment">//如果读到最后发现请求行还是有空格，说明这是个错误的请求</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> HttpParsingException(HttpStatusCode.Client_ERROR_414_BAD_REQUEST);</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">// 每一部分解析完成后，在Buffer中删除该信息</span></span><br><span class="line">                processingDataBuffer.delete(<span class="number">0</span>,processingDataBuffer.length());</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//既不是SP也不是CRLF，说明是我们要的信息，我们将其记录在一个Buffer当中取用</span></span><br><span class="line">                processingDataBuffer.append((<span class="keyword">char</span>)_byte);</span><br><span class="line">                <span class="keyword">if</span>(!methodParsed)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(processingDataBuffer.length()&gt;HttpMethod.MAX_LENGTH)&#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> HttpParsingException((HttpStatusCode.SERVER_ERROR_501_NOT_IMPLEMENTED));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseHeaders</span><span class="params">(InputStreamReader inputStream,HttpRequest request)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseBody</span><span class="params">(InputStreamReader inputStream,HttpRequest request)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ResponseBuilder"><a href="#ResponseBuilder" class="headerlink" title="ResponseBuilder"></a>ResponseBuilder</h4><p>解析完头部信息之后，我们就需要根据请求的结果编写响应报文了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.http.response;</span><br><span class="line"></span><br><span class="line">import com.http.request.HttpStatusCode;</span><br><span class="line"></span><br><span class="line">public class ResponseBuilder &#123;</span><br><span class="line">   private static final String CRLF &#x3D; &quot;\n\r&quot;;</span><br><span class="line">   private static String response;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   public static String build(String html,HttpStatusCode statusCode) &#123;</span><br><span class="line">       response &#x3D;</span><br><span class="line">            &quot;HTTP&#x2F;1.1 &quot;+statusCode.STATUS_CODE+&quot; &quot;+statusCode.MESSAGE+ CRLF +</span><br><span class="line">                  &quot;Content-Length: &quot; + html.getBytes().length + CRLF +</span><br><span class="line">                  CRLF +</span><br><span class="line">                  html +</span><br><span class="line">                  CRLF + CRLF;</span><br><span class="line">      return response;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="子线程的部分修改"><a href="#子线程的部分修改" class="headerlink" title="子线程的部分修改"></a>子线程的部分修改</h4><p>因为我们把响应报文的编写交给 ResponseBuilder了，因此我们这里需要调用ResponseBuilder并传入状态码和socket流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//.....</span></span><br><span class="line"><span class="comment">//如果请求的是正确的内容，那么我们就返回状态码200</span></span><br><span class="line">        <span class="keyword">if</span>(clientRequest.getRequestTarget().equals(<span class="string">"/index.html"</span>))&#123;</span><br><span class="line">            String html = <span class="string">"&lt;html&gt;&lt;head&gt;&lt;title&gt;Hello,My name is Jason&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;My ID is 10195501423&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;"</span>;</span><br><span class="line">            String response = ResponseBuilder.build(html,HttpStatusCode.SERVER_ERROR_200_OK);</span><br><span class="line">            outputStream.write(response.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(clientRequest.getRequestTarget().equals(<span class="string">"/shutdown"</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">"收到客户端的请求，关闭服务器"</span>);</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果请求的是不存在的文件，那么我们就需要将状态码设置为404</span></span><br><span class="line">            String html = loadHtmlFile(<span class="string">"/Users/jasonxu/IdeaProjects/finalproject/src/main/Web/404.html"</span>);</span><br><span class="line">            String response = ResponseBuilder.build(html,HttpStatusCode.SERVER_ERROR_404_NOT_FOUND);</span><br><span class="line">            outputStream.write(response.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LOGGER.info(<span class="string">"   Connection Processing Finished"</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException | HttpParsingException e)&#123;</span><br><span class="line">        LOGGER.error(<span class="string">"Problem with communication"</span>,e) ;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (outputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终结果：输入<code>localhost:8080/index.html</code> 之后，显示如下</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/9.png" style="zoom: 150%;"></p>
<p>输入<code>localhost:8080/222</code>（其他) ,显示如下</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/8.png" style="zoom: 150%;"></p>
<p>输入<code>localhost:8080/shutdown</code> 服务器关闭：</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/10.png" style="zoom: 150%;"></p>
<p>Postman 测试结果如下：</p>
<p>我们发现，postman测试的结果都通过了，且用GET和POST方法也没有出现错误。</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/11.png" style="zoom: 150%;"></p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/12.png" style="zoom: 150%;"></p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/13.png" style="zoom: 150%;"></p>
<h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h4><p>现在我们用 Jmeter 来测试一下这个 Java Server：</p>
<p>在1000线程并发时，发现这个server能毫无压力得处理。</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/24.png" style="zoom: 150%;"></p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/25.png" style="zoom: 150%;"></p>
<p>最终，在测到4900个并发线程的时候，出现了请求失败的情况。对此我又多测试了几次，最终测得这个server的极限压力大概是5000个线程左右</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/27.png" style="zoom: 150%;"></p>
<p>我们现在尝试优化这个server，采用线程池的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1000</span>, <span class="number">10000</span>, <span class="number">400</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">        <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">2000</span>));</span><br></pre></td></tr></table></figure>
<p>这几个参数分别是：</p>
<ul>
<li>corePoolSize：核心池的大小</li>
</ul>
<ul>
<li>maximumPoolSize：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；</li>
<li>keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。</li>
<li>unit：参数keepAliveTime的时间单位</li>
<li>workQueue：一个阻塞队列，用来存储等待执行的任务</li>
</ul>
<p>如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；</p>
<p>如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；</p>
<p>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；</p>
<p>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。</p>
<p>我给核心池开了1000个线程，(事实上根本用不了那么多)，在这之后，我用8000个并发请求也能轻松处理。一个错误都没有</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/28.png" style="zoom: 150%;"></p>
<h3 id="1-2-代理服务器的编写"><a href="#1-2-代理服务器的编写" class="headerlink" title="1.2 代理服务器的编写"></a>1.2 代理服务器的编写</h3><h4 id="“不正确”的代理服务器"><a href="#“不正确”的代理服务器" class="headerlink" title="“不正确”的代理服务器"></a>“不正确”的代理服务器</h4><p> 代理服务器相当于一个中转站，需要解析请求报文和响应报文并生成新的报文。一开始我还以为是proxy和server都要自己写，结果改了半天最终成功了才发现其实只需要写proxy，要代理浏览器访问的页面。但是失误已经酿成了，因此我把这个失误的版本也贴上来。</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/14.png" style="zoom: 150%;"></p>
<p>流程如下</p>
<ol>
<li>在8081端口， proxy作为server，收到了来自 client 的请求，开一个线程解析request、生成新的request。</li>
<li>proxy作为client，利用socket.connect，向端口(8080)传输新的request</li>
<li>端口8080 收到以后，解析request，然后生成response。</li>
<li>server 构造完后向端口8081传输response</li>
<li>Proxy在端口8081收到response，然后生成新的response，并向浏览器发送。</li>
</ol>
<p>整个流程都由一个线程完成。因此我们还是采用父子线程的架构模式。整个 <code>workThread</code>如下图所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = (Logger) LoggerFactory.getLogger(ProxyServer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    RequestParser myRequestParser = <span class="keyword">new</span> RequestParser();</span><br><span class="line">    ResponseParser myResponseParser = <span class="keyword">new</span> ResponseParser();</span><br><span class="line"></span><br><span class="line">    Socket socketToServer = <span class="keyword">new</span> Socket();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WorkerThread</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String CRLF = <span class="string">"\n\r"</span>;</span><br><span class="line"></span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        OutputStream outputStreamToServer = <span class="keyword">null</span>;</span><br><span class="line">        InputStream inputStreamFromServer = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> _byte;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 利用connect方法，可以实现两个端口之间的流传递</span></span><br><span class="line">            socketToServer.connect(<span class="keyword">new</span> InetSocketAddress(Inet4Address.getLocalHost(),</span><br><span class="line">                    <span class="number">8080</span>), <span class="number">50</span>);</span><br><span class="line">          <span class="comment">// inputStream和 outputStream 是8081端口的输入输出流</span></span><br><span class="line">            inputStream = socket.getInputStream();</span><br><span class="line">            outputStream = socket.getOutputStream();</span><br><span class="line">          <span class="comment">// outputStreamToServer和 inputStreamFromServer 是对于8080端口的输入输出流</span></span><br><span class="line">            outputStreamToServer = socketToServer.getOutputStream();</span><br><span class="line">            inputStreamFromServer = socketToServer.getInputStream();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*******************解析Request from Client*****************/</span></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          1.首先8081端口收到client发来的request，交给myRequestParser去解析，信息存到httpRequest中</span></span><br><span class="line"><span class="comment">          2.利用RequestBuilder 来构造转发的请求。</span></span><br><span class="line"><span class="comment">          3.利用outputStreamToServer，将构造的请求转发给server</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">                HttpRequest httpRequest = myRequestParser.parseHttpRequest(inputStream);</span><br><span class="line"></span><br><span class="line">                System.out.println(httpRequest.getMethod());</span><br><span class="line">                System.out.println(httpRequest.getRequestTarget());</span><br><span class="line"></span><br><span class="line">                String request = RequestBuilder.build(httpRequest.getMethod(),httpRequest.getRequestTarget(),httpRequest.getHttpVersion());</span><br><span class="line">                outputStreamToServer.write(request.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            <span class="comment">/****************解析Response from Server*****************/</span></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          1. 收到来自server的response之后，交给myResponseParser去解析，并存入httpResponse中</span></span><br><span class="line"><span class="comment">          2. 利用httpResponse，构造新的response</span></span><br><span class="line"><span class="comment">          3. 将response转发给client</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">            HttpResponse httpResponse = myResponseParser.parseHttpResponse(inputStreamFromServer);</span><br><span class="line"></span><br><span class="line">            System.out.println(httpResponse.getStatusCode());</span><br><span class="line">            System.out.println(httpResponse.getStatusMessage());</span><br><span class="line"></span><br><span class="line">            String response = ResponseBuilder.build(httpResponse);</span><br><span class="line">            outputStream.write(response.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*******************Finish*************************/</span></span><br><span class="line">            LOGGER.info(<span class="string">"   Connection Processing Finished"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException | HttpParsingException e)&#123;</span><br><span class="line">            LOGGER.error(<span class="string">"Problem with communication"</span>,e) ;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (outputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    outputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    outputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终结果如下图所示，用postman和浏览器分别测试：</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/15.png" style="zoom: 150%;"></p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/17.png" style="zoom: 150%;"></p>
<h3 id="“正经”代理服务器"><a href="#“正经”代理服务器" class="headerlink" title="“正经”代理服务器"></a>“正经”代理服务器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = (Logger) LoggerFactory.getLogger(ProxyServer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WorkerThread</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        OutputStream outputStreamToClient = <span class="keyword">null</span>;</span><br><span class="line">        InputStream inputStreamFromClient = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        Socket proxySocket = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        InputStream inputFromServer = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream outputToServer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStreamFromClient = socket.getInputStream();</span><br><span class="line">            outputStreamToClient = socket.getOutputStream();</span><br><span class="line">            String line;</span><br><span class="line">            String host = <span class="string">""</span>;</span><br><span class="line">            LineBuffer lineBuffer = <span class="keyword">new</span> LineBuffer(<span class="number">1024</span>);</span><br><span class="line">            StringBuilder headStr = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="comment">//读取HTTP请求头，并拿到HOST请求头和method</span></span><br><span class="line">            <span class="keyword">while</span> ( (line = lineBuffer.readLine(inputStreamFromClient))!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                headStr.append(line).append(<span class="string">"\r\n"</span>);</span><br><span class="line">                <span class="keyword">if</span> (line.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    String[] temp = line.split(<span class="string">" "</span>);</span><br><span class="line">                    <span class="keyword">if</span> (temp[<span class="number">0</span>].contains(<span class="string">"Host"</span>)) &#123;</span><br><span class="line">                        host = temp[<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 请求方式</span></span><br><span class="line">            String type = headStr.substring(<span class="number">0</span>, headStr.indexOf(<span class="string">" "</span>));</span><br><span class="line">            LOGGER.debug(<span class="string">"type: "</span>+type);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//根据host头解析出目标服务器的host和port</span></span><br><span class="line">            String[] hostTemp = host.split(<span class="string">":"</span>);</span><br><span class="line">            host = hostTemp[<span class="number">0</span>];</span><br><span class="line">            LOGGER.debug(<span class="string">"host: "</span>+host);</span><br><span class="line">            <span class="keyword">int</span> port = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hostTemp.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                port = Integer.parseInt(hostTemp[<span class="number">1</span>]);</span><br><span class="line">                LOGGER.debug(<span class="string">"port: "</span>+port);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//连接到目标服务器</span></span><br><span class="line">            proxySocket = <span class="keyword">new</span> Socket(host, port);</span><br><span class="line">            inputFromServer = proxySocket.getInputStream();</span><br><span class="line">            outputToServer = proxySocket.getOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//根据HTTP method来判断是https还是http请求，https</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"CONNECT"</span>.equalsIgnoreCase(type)) &#123;</span><br><span class="line">              <span class="comment">//如果是https，type是CONNECT，如果是http则type是GET、POST之类的</span></span><br><span class="line">              <span class="comment">//https需要建立隧道，以便能和client之间进行二进制数据的收发。</span></span><br><span class="line">                outputStreamToClient.write(<span class="string">"HTTP/1.1 200 Connection Established\r\n\r\n"</span>.getBytes());</span><br><span class="line">                outputStreamToClient.flush();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//http直接将请求头转发</span></span><br><span class="line">                outputToServer.write(headStr.toString().getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//新开线程转发客户端请求至目标服务器，这边使用线程的原因是需要异步操作</span></span><br><span class="line">            <span class="keyword">new</span> ProxyWorkerThread(inputStreamFromClient, outputToServer).start();</span><br><span class="line">            <span class="comment">//转发目标服务器响应至客户端</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                outputStreamToClient.write(inputFromServer.read());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (inputFromServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    outputToServer.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (outputToServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    outputToServer.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (proxySocket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    proxySocket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (inputStreamFromClient != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    inputStreamFromClient.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (outputStreamToClient != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    outputStreamToClient.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="LineBuffer类"><a href="#LineBuffer类" class="headerlink" title="LineBuffer类"></a>LineBuffer类</h4><p>这个类设置了一个可以自动扩容的缓冲区，用来读client请求.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.httpserver.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LineBuffer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SP =<span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CR =<span class="string">'\r'</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LF =<span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LineBuffer</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readLine</span><span class="params">(InputStream input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bts = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="keyword">this</span>.size];</span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">      <span class="comment">//因为在请求头中，每一行的结尾都是 "\r\n" 所以当一行结束时，就返回这一行字符串</span></span><br><span class="line">       <span class="keyword">while</span>(flag!=<span class="number">2</span>&amp;&amp;(b= input.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            bts[index++] = (<span class="keyword">byte</span>) b;</span><br><span class="line">            <span class="keyword">if</span>(b == CR &amp;&amp; flag%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                flag++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(b== LF &amp;&amp; flag%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                flag++;</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="number">2</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> String(bts,<span class="number">0</span>,index-<span class="number">2</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(index==bts.length)&#123;</span><br><span class="line">                <span class="comment">//满了就扩容</span></span><br><span class="line">                <span class="keyword">byte</span>[] newBts = <span class="keyword">new</span> <span class="keyword">byte</span>[bts.length*<span class="number">2</span>];</span><br><span class="line">                System.arraycopy(bts,<span class="number">0</span>,newBts,<span class="number">0</span>,bts.length);</span><br><span class="line">                bts = newBts;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ProxyWorkerThread类"><a href="#ProxyWorkerThread类" class="headerlink" title="ProxyWorkerThread类"></a>ProxyWorkerThread类</h4><p>这个类负责将客户端的请求转发到目标服务器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyWorkerThread</span>  <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> InputStream input;</span><br><span class="line">    <span class="keyword">private</span> OutputStream output;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyWorkerThread</span><span class="params">(InputStream inputStreamFromClient, OutputStream outputToServer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.input = inputStreamFromClient;</span><br><span class="line">        <span class="keyword">this</span>.output = outputToServer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                output.write(input.read());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用代理服务器上网之前，首先需要设置chrome的代理配置。将端口改为代理服务器监听的8080端口</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/21.png" style="zoom: 150%;"></p>
<p>结果如下图所示</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/22.png" style="zoom: 150%;"></p>
<p>如果访问https，也是同样的操作</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/23.png" style="zoom: 150%;"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek13/" class="post-title-link" itemprop="url">计算机网络报告week13</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-06-03 16:03:36" itemprop="dateCreated datePublished" datetime="2021-06-03T16:03:36+08:00">2021-06-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-23 22:22:22" itemprop="dateModified" datetime="2022-08-23T22:22:22+08:00">2022-08-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Week-13-利用Wireshark分析ARP协议"><a href="#Week-13-利用Wireshark分析ARP协议" class="headerlink" title="Week 13 : 利用Wireshark分析ARP协议"></a>Week 13 : 利用Wireshark分析ARP协议</h1><h2 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1.  实验目的"></a>1.  实验目的</h2><ul>
<li>掌握Wireshark软件的过滤语法</li>
<li>掌握ARP 的工作原理</li>
</ul>
<h2 id="2-实验任务"><a href="#2-实验任务" class="headerlink" title="2. 实验任务"></a>2. 实验任务</h2><ul>
<li>学会利用Wireshark 抓包分析ARP协议</li>
</ul>
<h2 id="3-实验过程"><a href="#3-实验过程" class="headerlink" title="3. 实验过程"></a>3. 实验过程</h2><h3 id="3-1-预备知识"><a href="#3-1-预备知识" class="headerlink" title="3.1 预备知识"></a>3.1 预备知识</h3><ul>
<li>ARP(Address Resolution Protocol) 协议，即地址解析协议。该协议的功能就是将IP地址解析成MAC地址。ARP的基本功能就是负责将一个已知的IP地址解析成MAC地址，以便主机间能正常进行通信。</li>
</ul>
<p><img src="/2021/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek13/1.jpg" style="zoom:67%;"></p>
<ul>
<li>ARP 协议的解析过程只使用了两种数据包： 一个ARP请求和一个ARP响应，如下图所示：</li>
</ul>
<p><img src="/2021/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek13/2.jpg" style="zoom:67%;"></p>
<ul>
<li>其详细工作原理是：<ol>
<li>当主机A想要给主机B发送数据时，主机A会首先在自己的本地ARP缓存表中检查与主机B匹配的MAC地址。</li>
<li>如果主机A在自己的缓存表中没有找到主机B的相关条目，那么它就要想办法获取主机B的MAC地址。这就需要将ARP的请求帧广播到网络上所有主机中。这个请求帧包含有主机A的IP地址和MAC地址，以及主机B的IP地址。网络中凡是收到请求帧的主机都会检查自己的IP地址是否与请求地址一致，如果不一致，则会丢弃该请求帧。对于上图来说，主机C和主机D会丢弃主机A发出的请求帧。</li>
<li>主机B确定ARP请求中的IP地址和自己的IP地址一致，那么就会将主机A的IP地址和MAC地址添加到本地的缓存列表中</li>
<li>主机B将包含有自己MAC地址的ARP响应消息直接回复给主机A(单播)</li>
<li>主机A收到从主机B发来的ARP响应消息之后，会将主机B的IP地址和MAC地址添加到自己的ARP缓存表中。接下来，主机A就可以向主机B发送消息了</li>
</ol>
</li>
<li>如果想要查看ARP缓存表，可以打开cmd ，输入”arp -a”</li>
</ul>
<p><img src="/2021/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek13/3.jpg" style="zoom:67%;"></p>
<h3 id="3-2-分析-ARP-数据包"><a href="#3-2-分析-ARP-数据包" class="headerlink" title="3.2 分析 ARP 数据包"></a>3.2 分析 ARP 数据包</h3><ul>
<li>选择一个ARP缓存表中没有的地址进行分析，如： <code>ping 192.168.1.110</code></li>
</ul>
<p><img src="/2021/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek13/5.jpg" style="zoom:67%;"></p>
<ul>
<li>利用Wireshark 抓取 ARP 包，并进行分析，再次通过 arp -a 命令可以发现该IP地址对应的mac信息已添加在缓存表中了</li>
</ul>
<p><img src="/2021/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek13/4.jpg" style="zoom:67%;"></p>
<h4 id="task1"><a href="#task1" class="headerlink" title="task1"></a>task1</h4><p>如上图所示，分析当ARP缓存表不存在某个IP信息时，数据发送是的请求和应答数据报信息，截图并标注具体ARP字段数据，请在实验报告中附上结果截图</p>
<p>我在笔记本上开了一个虚拟机，地址是 <code>192.168.31.100</code>, </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Address Resolution Protocol (request) </span><br><span class="line">    Hardware type: Ethernet (1)  	# 硬件类型</span><br><span class="line">    Protocol type: IPv4 (0x0800) 	# 上层协议类型</span><br><span class="line">    Hardware size: 6						 	# MAC 地址长度</span><br><span class="line">    Protocol size: 4							# IP 地址长度</span><br><span class="line">    Opcode: request (1)						# 操作类型，这里是request	</span><br><span class="line">    Sender MAC address: BeijingX_2e:de:27 (50:d2:f5:2e:de:27) # 源MAC地址</span><br><span class="line">    Sender IP address: 192.168.31.1														# 源IP地址 </span><br><span class="line">    Target MAC address: 00:00:00_00:00:00 (00:00:00:00:00:00) # 目的 mac 地址</span><br><span class="line">    Target IP address: 192.168.31.100		# 目的 ip 地址</span><br></pre></td></tr></table></figure>
<p>我们发现，在还没有加入缓存的时候，我们发送的ARP请求包中是不知道目标主机的mac地址的，因此默认为：<code>00:00:00:00:00:00</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Address Resolution Protocol (reply)</span><br><span class="line">    Hardware type: Ethernet (1) 			# 硬件类型</span><br><span class="line">    Protocol type: IPv4 (0x0800) 			# 上层协议类型</span><br><span class="line">    Hardware size: 6 									#  MAC 地址长度</span><br><span class="line">    Protocol size: 4									#  IP 地址长度</span><br><span class="line">    Opcode: reply (2)									#  操作类型，reply	</span><br><span class="line">    Sender MAC address: IntelCor_75:21:32 (38:00:25:75:21:32)	# 源MAC地址</span><br><span class="line">    Sender IP address: 192.168.31.100													# 源IP地址 </span><br><span class="line">    Target MAC address: Apple_e2:a1:2e (4c:20:b8:e2:a1:2e)		# 目的 mac 地址</span><br><span class="line">    Target IP address: 192.168.31.15													# 目的 ip 地址</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek13/6.png" style="zoom:67%;"></p>
<h4 id="task2"><a href="#task2" class="headerlink" title="task2"></a>task2</h4><p>分析当ARP缓存表存在某个Ip信息时，ARP请求和接收MAC地址分析，(只截图，写出目的MAC地址和源MAC地址)，并分析与task1中数据包存在的区别，在实验报告中附上截图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Address Resolution Protocol (request)</span><br><span class="line">    Hardware type: Ethernet (1)</span><br><span class="line">    Protocol type: IPv4 (0x0800)</span><br><span class="line">    Hardware size: 6</span><br><span class="line">    Protocol size: 4</span><br><span class="line">    Opcode: request (1)</span><br><span class="line">    Sender MAC address: Apple_e2:a1:2e (4c:20:b8:e2:a1:2e)</span><br><span class="line">    Sender IP address: 192.168.31.15</span><br><span class="line">    Target MAC address: IntelCor_75:21:32 (38:00:25:75:21:32)</span><br><span class="line">    Target IP address: 192.168.31.100</span><br></pre></td></tr></table></figure>
<p>但是当ARP中已经包含了该主机的mac地址后，在发送ARP请求包时，在<code>Target MAC address</code> 中直接填入目标主机的mac地址了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Address Resolution Protocol (reply)</span><br><span class="line">    Hardware type: Ethernet (1)</span><br><span class="line">    Protocol type: IPv4 (0x0800)</span><br><span class="line">    Hardware size: 6</span><br><span class="line">    Protocol size: 4</span><br><span class="line">    Opcode: reply (2)</span><br><span class="line">    Sender MAC address: IntelCor_75:21:32 (38:00:25:75:21:32)</span><br><span class="line">    Sender IP address: 192.168.31.100</span><br><span class="line">    Target MAC address: Apple_e2:a1:2e (4c:20:b8:e2:a1:2e)</span><br><span class="line">    Target IP address: 192.168.31.15</span><br></pre></td></tr></table></figure>
<p>但是 ARP 响应包，前后都是一样的。</p>
<p><img src="/2021/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek13/7.png" style="zoom:67%;"></p>
<p>这时候我们已经发现，刚才ping 的 192.168.31.100 的mac地址已经添加到arp缓存表中去了，而且我们发现，这个地址和我开虚拟机的电脑的地址是一模一样的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/" class="post-title-link" itemprop="url">计算机网络-网络层</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-06-02 15:52:12" itemprop="dateCreated datePublished" datetime="2021-06-02T15:52:12+08:00">2021-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-09 23:27:02" itemprop="dateModified" datetime="2025-04-09T23:27:02+08:00">2025-04-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机网络-网络层"><a href="#计算机网络-网络层" class="headerlink" title="计算机网络-网络层"></a>计算机网络-网络层</h1><p>学习自：<a href="https://github.com/crisxuan/bestJavaer/blob/master/computer-network/computer-internet.md" target="_blank" rel="noopener">https://github.com/crisxuan/bestJavaer/blob/master/computer-network/computer-internet.md</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/126754314" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/126754314</a></p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/1.png"></p>
<p>之前我们说了应用层和运输层。运输层是提供进程的端到端通信。那么下面我们将学习网络层是怎样实现主机到主机的通信服务的。<strong>几乎每个端系统都有网络层这一部分</strong>，所以，网络层必然是很复杂的。</p>
<h3 id="网络服务模型"><a href="#网络服务模型" class="headerlink" title="网络服务模型"></a>网络服务模型</h3><p>因特网的网络层提供了单一的服务，即<strong>尽力而为</strong>。 这让传送的分组不能保证以它们发送的顺序被接收，也不能保证它们最终交付；既不能保证端到端时延，也不能保证最小有效带宽。尽管什么都不保证，但是这种服务模型却能满足大多数网络服务。</p>
<h2 id="网络层概述"><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h2><p>网络层是OSI的第三层，它位于传输层和链路层之间，网络层的主要目的是实现两个端系统之间透明的数据传输。</p>
<blockquote>
<p>TCP/IP 把表示层和会话层都归入了应用层。</p>
</blockquote>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2.png"></p>
<p>网络层可以分成两种平面，在第四章主要讲的是数据平面，负责<strong>转发网络流量</strong>，如路由器交换机中的转发表；在第五章主要讲的是控制平面, 作用是控制网络的行为，比如<strong>网络路径的选择(路由)</strong>。</p>
<p>网络层的作用从表面看上去非常简单，即将<code>分组</code><strong>从一台主机移动到另外一台主机</strong>。为了实现这个功能，网络层需要两种功能</p>
<ul>
<li><code>转发</code>：因为在互联网中有很多<code>路由器</code>的存在，而路由器是构成互联网的根本，路由器最重要的一个功能就是<code>分组转发</code>，当一个分组到达某路由器的一条输入链路时，该路由器会将分组移动到适当的输出链路。转发是在数据平面中实现的唯一功能。</li>
<li><code>路由选择</code>： 当分组由发送方流向接收方时，网络层必须选择这些分组的路径。计算这些路径选择的算法被称为 <code>路由选择算法(routing algorithm)</code>。</li>
</ul>
<p>也就是说，转发是指<strong>将分组从一个输入链路转移到适当输出链路接口的路由器本地动作</strong>，而路由选择是指<strong>确定分组从源到目的地锁定为的路径的选择</strong>。我们后面会经常提到。</p>
<blockquote>
<p> 那么，路由器怎么知道有哪些路径可以选择呢？</p>
</blockquote>
<p>每台路由器都有一个关键的概念就是 <code>转发表(forwarding table)</code>。路由器通过检查数据包标头中字段的值，来定位转发表中的项来实现转发。标头中的值即对应着转发表中的值，这个值指出了分组将被转发的路由器输出链路。如下图所示: </p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/3.png"></p>
<p>上图中有一个 1001 分组到达路由器后，首先会在转发表中进行索引，然后由路由选择算法决定分组要走的路径。每台路由器都有两种功能：<strong>转发和路由选择</strong>。下面我们就来聊一聊路由器的工作原理。</p>
<h2 id="数据层面"><a href="#数据层面" class="headerlink" title="数据层面"></a>数据层面</h2><h3 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h3><p>下面是一个路由器体系的体系结构图，路由器主要是由4个组件组成：</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/4.png"></p>
<ul>
<li>输入端口：<code>输入端口(input port)</code>有很多功能。<code>线路终端功能</code>和<code>数据链路处理</code>功能，这两个功能实现了路由器的单个输入链路相关联的物理层和数据链路层。<code>输入端口查找/转发功能</code>对路由器的交换功能来说至关重要，由路由器的交换结构来决定输出端口，具体来讲应该是<strong>查询转发表</strong>来确定的。</li>
<li>(高速)交换结构：<code>交换结构(Switching fabric)</code>就是将路由器的输入端口连接到它的输出端口。这种交换结构相当于是<strong>路由器内部的网络</strong>。</li>
<li>输出端口：<code>输出端口(Output ports)</code> 通过交换结构转发分组，并通过物理层和数据链路层的功能传输分组，因此，输出端口作为输入端口执行反向数据链接和物理层功能。</li>
<li>路由选择处理器：<code>路由选择处理器(Routing processor)</code> 在路由器内执行路由协议，维护路由表并执行网络管理功能。这属于控制平面的内容</li>
</ul>
<h4 id="输入端口"><a href="#输入端口" class="headerlink" title="输入端口"></a>输入端口</h4><p>上面介绍了输入端口有很多功能，包括线路终端、数据处理、查找转发，其实这些功能在输入端口的内部有相应的模块，输入端口的内部实现如下图所示</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/5.png"> </p>
<p>每个输入端口中都有一个路由处理器维护的<strong>路由表的副本</strong>，根据路由处理器进行更新。这个路由表的副本能 够使每个输入端口进行切换，而无需经过路由处理器统一处理。这是一种<code>分散式</code>的切换，这种方式避免了路 由选择器统一处理造成转发瓶颈。</p>
<p>在输入端口处理能力有限的路由器中，输入端口不会进行交换功能，而是由路由处理器统一处理，然后根据 路由表查找并将数据包转发到相应的输出端口。</p>
<blockquote>
<p>一般这种路由器不是单独的路由器，而是工作站或者服务器充当的路由，这种路由器内部中，路由处理器其实就是 <code>CPU</code>，而输入端口其实只是<code>网卡</code>。</p>
</blockquote>
<p>输入端口会根据转发表定位输出端口，然后再会进行分组转发，那么现在就有一个问题，是不是每一个分组都有自己的一条链路呢？如果分组数量非常大，到达亿级的话，也会有亿个输出端口路径吗？</p>
<p>我们的潜意识中显然不是的，来看下面一个例子。</p>
<p>下面是三个输入端口对应了转发表中的三个输出链路的示例</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/6.png"></p>
<p>可以看到，对于这个例子来说，路由器转发表中不需要那么多条链路，只需要四条就够，即对应输出链路 0 1 2 3 。也就是说，能够使用 4 个转发表就可以实现亿级链路。</p>
<blockquote>
<p>如何实现呢？</p>
</blockquote>
<p>使用这种风格的转发表，路由器分组的地址 <code>前缀(prefix)</code> 会与该表中的表项进行匹配。</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/7.png"></p>
<p>如果存在一个匹配项，那么就会转发到对应的链路上，可能不好理解，我举个例子来说吧。</p>
<p>比如这时有一个分组是 <code>11000011 10010101 00010000 0001100</code>到达，因为这个分组与 <code>11000011 10010101 00010000</code>相匹配，所以路由器会转发到 0 链路接口上。如果一个前缀不匹配上面三个输出链路中的一种，那么路由器将向链路接口 3 进行转发。</p>
<p>路由匹配遵循 <code>最长前缀匹配原则(longest prefix matching rule)</code>，最长匹配原则故名思义就是如果有两个匹配项一个长一个短的话，<strong>就匹配最长的</strong>。</p>
<p>一旦通过查找功能确定了分组的输出端口后，那么该分组就会<strong>进入交换结构</strong>。在进入交换结构时，如果交换结构正在被使用，<strong>就会阻塞新到的分组</strong>，等到交换结构调度新的分组。</p>
<h4 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h4><p>交换结构是路由器的核心功能，通过交换功能把分组从输入端口转发至输出端口，这就是交换结构的主要功能。交换结构有多种形式，主要分为 <strong>通过内存交换、通过总线交换、通过互联网络进行交换</strong>，下面我们分开来探讨一下。</p>
<ul>
<li>经过内存交换：最开始的传统计算机就是使用<code>内存交换</code>的，在输入端口和输出端口之间是通过 CPU 进行的。输入端口和输出端口的功能就好像传统操作系统中的 I/O 设备一样。当一个分组到达输入端口时，这个端口会首先以<code>中断</code> 的方式向路由选择器发出信号，将分组从输入端口拷贝到内存中。然后，路由选择处理器从分组首部中提取目标地址，在转发表中找出适当的输出端口进行转发，同时将分组复制到输出端口的缓存中。这种方式比较低效，早期的路由器都是以这种方式实现的。</li>
</ul>
<blockquote>
<p>这里需要注意一点，如果内存带宽以每秒读取或者写入 B 个数据包，那么总的交换机吞吐量(数据包从输入端口到输出端口的总速率) 必须小于 B/2。</p>
</blockquote>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/8.png"></p>
<ul>
<li>经过总线交换：在这种处理方式中，总线经由输入端口<strong>直接</strong>将分组传送到输出端口，中间<strong>不需要路由选择器的干预</strong>。总线的工作流程如下：输入端口给分组分配一个<code>标签</code>，然后分组经由总线发送给<strong>所有的输出端口</strong>，每个输出端口都会判断标签中的端口和自己的是否匹配，如果匹配的话，那么这个输出端口就会把标签拆掉，这个标签只用于交换机内部跨越总线。如果同时有 <code>多个</code> 分组到达路由器的话，那么只有一个分组能够被处理，其他分组需要再进入交换结构前等待。也就是说这对总线的带宽要求很高。</li>
</ul>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/9.png"></p>
<ul>
<li>经过互联网络交换：这是一种纵横式的交换网络。它能克服单一、共享式总线带宽限制。它使输入端口和输出端口两两之间都有一条网路。如下图所示</li>
</ul>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/10.png"></p>
<h4 id="输出端口处理"><a href="#输出端口处理" class="headerlink" title="输出端口处理"></a>输出端口处理</h4><p>如下图所示，输出端口处理取出已经存放在输出端口内存中的分组并将其发送到输出链路上。包括选择和去除排队的分组进行传输，执行所需的链路层和物理层的功能。</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/11.png"></p>
<p>在输入端口中有等待进入交换的排队队列，而在输出端口中<strong>有等待转发的排队队列</strong>，排队的位置和程度取决于<strong>流量负载、交换结构</strong>的相对频率和线路速率。</p>
<p>随着队列的不断增加，会导致路由器的缓存空间被耗尽，进而使没有内存可以存储溢出的队列，致使分组出现<code>丢包(packet loss)</code>，这就是我们说的在网络中丢包或者被路由器丢弃。于是，接下来我们来讲一下排队。</p>
<h3 id="路由器出现排队"><a href="#路由器出现排队" class="headerlink" title="路由器出现排队"></a>路由器出现排队</h3><p>下面我们通过输入端口的排队队列和输出端口的排队队列来介绍一下可能出现的排队情况。</p>
<h4 id="输入队列-HOL阻塞"><a href="#输入队列-HOL阻塞" class="headerlink" title="输入队列(HOL阻塞)"></a>输入队列(HOL阻塞)</h4><p>如果<strong>交换结构的处理速度没有输入队列到达的速度快</strong>，在这种情况下，输入端口将会出现排队情况，到达交换结构前的分组会加入输入端口队列中，以等待通过交换结构传送到输出端口。</p>
<p>为了描述清楚输入队列，我们假设以下情况：</p>
<ul>
<li>使用网络互联(crossbar)的交换方式；</li>
<li>假定所有链路的速度相同；</li>
<li>在链路中一个分组由输入端口交换到输出端口所花的时间相同，从任意一个输入端口传送到给定的输出端口；</li>
<li>分组按照 FCFS 的方式，只要输出端口不同，就可以进行并行传送。但是如果位于任意两个输入端口中的分组是发往同一个目的地的，那么其中的一个分组将被阻塞，而且必须在输入队列中等待，因为交换结构一次只能传输一个到指定端口。</li>
</ul>
<p>如下图所示</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/12.png"></p>
<p>在 A 队列中，输入队列中的两个分组会发送至同一个目的地 X，假设在交换结构正要发送 A 中的分组，在这个时候，C 队列中也有一个分组发送至 X，在这种情况下，C 中发送至 X 的分组将会等待，不仅如此，C 队列中发送至 Y 输出端口的分组也会等待，即使 Y 中没有出现竞争的情况。这种现象叫做 <code>线路前部阻塞(Head-Of-The-Line, HOL)</code> 。</p>
<p>也就是说，在一个输入队列中排队的分组<strong>必须</strong>等待通过交换结构发送，即使输出端口是空的，因为它被位于线路前部的另一个分组所阻塞了。</p>
<h4 id="输出队列"><a href="#输出队列" class="headerlink" title="输出队列"></a>输出队列</h4><p>我们下面讨论输出队列中出现等待的情况。假设<strong>交换速率要比输入/输出的传输速率快很多</strong>，而且有 N 个输入分组的目的地是转发至相同的输出端口。在这种情况下，在向输出链路发送分组的过程中，将会有 N 个新分组到达传输端口。因为输出端口在一个单位时间内只能传输一个分组，那么这 N 个分组将会等待。然而在等待 N 个分组被处理的过程中，同时又有 N 个分组到达，所以 ，分组队列能够在输出端口形成。这种情况下最终会因为分组数量变的足够大，从而<code>耗尽</code> 输出端口的可用内存。</p>
<p>如果没有足够的内存来缓存分组的话，就必须考虑其他的方式，主要有两种：一种是丢失分组，采用 <code>弃尾(drop-tail)</code> 的方法；一种是删除一个或多个已经排队的分组，从而来为新的分组腾出空间。</p>
<blockquote>
<p>网络层的策略对 TCP 拥塞控制影响很大的就是路由器的分组丢弃策略。在最简单的情况下，路由器的队列通常都是按照 FCFS 的规则处理到来的分组。由于队列长度总是有限的，因此当队列已经满了的时候，以后再到达的所有分组（如果能够继续排队，这些分组都将排在队列的尾部）将都被丢弃。这就叫做尾部丢弃策略。</p>
</blockquote>
<p>通常情况下，在缓冲填满之前将其丢弃是更好的策略。</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/13.png"></p>
<p>如上图所示，A B C 每个输入端口都到达了一个分组，而且这个分组都是发往 X 的，同一时间只能处理一个分组，然后这时，又有两个分组分别由 A B 发往 X，所以此时有 4 个分组在 X 中进行等待。</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/14.png"></p>
<p>等上一个分组被转发完成后，输出端口就会选择在剩下的分组中根据 <code>分组调度(packet scheduleer)</code> 选择一个分组来进行传输，我们下面就会聊到分组调度</p>
<p>那么我们一般怎么来计算一个合理的缓冲区呢？ 我们的目标是不能丢包，但可以忍受排队。设 N 为TCP流的数目， C为链路的数量，RTT为往返时间</p>
<script type="math/tex; mode=display">
Buffer = \frac{RTT\cdot C}{\sqrt N}</script><h3 id="分组调度"><a href="#分组调度" class="headerlink" title="分组调度"></a>分组调度</h3><p>现在我们来讨论一下分组调度次序的问题，即排队的分组如何经输出链路传输的问题。我们生活中有无数排队的例子，但是我们生活中一般的排队算法都是 <code>先来先服务(FCFS)</code>，也是<code>先进先出(FIFO)</code>。</p>
<h4 id="先进先出"><a href="#先进先出" class="headerlink" title="先进先出"></a>先进先出</h4><p>先进先出就映射为数据结构中的<code>队列</code>，只不过它现在是链路调度规则的排队模型。</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/15.png"></p>
<p>FIFO 调度规则按照分组到达输出链路队列的相同次序来选择分组，先到达队列的分组将先会被转发。在这种抽象模型中，如果队列已满，那么弃尾的分组将是队列末尾的后面一个。</p>
<h4 id="优先级排队"><a href="#优先级排队" class="headerlink" title="优先级排队"></a>优先级排队</h4><p>优先级排队是先进先出排队的改良版本，到达输出链路的分组被分类放入输出队列中的优先权类，如下图所示</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/16.png"></p>
<p>通常情况下，每个优先级不同的分组有自己的优先级类，每个优先级类有自己的队列，分组传输会首先从优先级高的队列中进行，在同一类优先级的分组之间的选择通常是以 FIFO 的方式完成。</p>
<h4 id="循环加权公平排队"><a href="#循环加权公平排队" class="headerlink" title="循环加权公平排队"></a>循环加权公平排队</h4><p>在<code>循环加权公平规则(round robin queuing discipline)</code> 下，分组像使用优先级那样被分类。然而，在类之间却<strong>不存在严格的服务优先权</strong>。循环调度器在这些类之间循环轮流提供服务。如下图所示</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/17.png"></p>
<p>在循环加权公平排队中，类 1 的分组被传输，接着是类 2 的分组，最后是类 3 的分组，这算是一个循环，然后接下来又重新开始，又从 1 -&gt; 2 -&gt; 3 这个顺序进行轮询。每个队列也是一个先入先出的队列。</p>
<p>这是一种所谓的<code>保持工作排队(work-conserving queuing)</code> 的规则，就是说如果轮询的过程中发现有空队列，输出端口不会等待分组，而是继续轮询下面的队列。</p>
<h3 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h3><p>路由器对分组进行转发后，就会把数据包传到网络上，数据包最终是要传递到客户端或者服务器上的，那么数据包怎么知道要发往哪里呢？起到关键作用的就是 IP 协议。</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/18.png"></p>
<p>IP 主要分为三个部分，分别是 <strong>IP 寻址、路由和分包组包</strong>。下面我们主要围绕这三点进行阐述。</p>
<h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><p>既然一个数据包要在网络上传输，那么肯定需要知道这个数据包到底发往哪里，也就是说需要一个目标地址信息，<strong>IP 地址就是连接网络中的所有主机进行通信的目标地址</strong>，因此，在网络上的每个主机都需要有自己的 IP 地址。</p>
<p>在 IP 数据报发送的链路中，有可能链路非常长，比如说由中国发往美国的一个数据报，由于网络抖动等一些意外因素可能会导致数据报丢失，这时我们在这条链路中会放入一些 <code>中转站</code>，一方面能够确保数据报是否丢失，另一方面能够控制数据报的转发，这个中转站就是我们前面聊过的路由器，这个转发过程就是 <code>路由控制</code>。</p>
<p><code>路由控制(Routing)</code> 是指将分组数据发送到最终目标地址的功能，即使网络复杂多变，也能够通过路由控制到达目标地址。因此，一个数据报能否到达目标主机，关键就在于路由器的控制。</p>
<p>这里有一个名词，就是 <code>跳</code>，因为在一条链路中可能会布满很多路由器，路由器和路由器之间的数据报传送就是跳，比如你和隔壁老王通信，中间就可能会经过路由器 A-&gt; 路由器 B -&gt; 路由器 C 。</p>
<blockquote>
<p>那么一跳的范围有多大呢？</p>
</blockquote>
<p><strong>一跳是指从源 MAC 地址到目标 MAC 地址之间传输帧的区间</strong>，这里引出一个新的名词，MAC 地址是啥？</p>
<p>MAC 地址指的就是计算机的<code>物理地址(Physical Address)</code>，它是用来确认网络设备位置的地址。在 OSI 网络模型中，网络层负责 IP 地址的定位，而数据链路层负责 MAC 地址的定位。MAC 地址用于在网络中<strong>唯一标示一个网卡</strong>，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的 MAC 地址，也就是说 MAC 地址和网卡是紧密联系在一起的。</p>
<p>路由器的每一跳都需要询问当前中转的路由器，下一跳应该跳到哪里，从而跳转到目标地址。而不是数据报刚开始发送后，网络中所有的通路都会显示出来。这种多次跳转也叫做<code>多跳路由</code>。在一定数量的<code>跳</code> 之后，数据报就会失去作用，被丢掉。</p>
<h5 id="IP地址的定义"><a href="#IP地址的定义" class="headerlink" title="IP地址的定义"></a>IP地址的定义</h5><p>现如今有两个版本的 IP 地址，IPv4 和 IPv6，我们首先探讨一下现如今还在广泛使用的 IPv4 地址，后面再考虑 IPv6 。</p>
<p>IPv4 由 32 位正整数来表示，在计算机内部会转化为二进制来处理，但是二进制不符合人类阅读的习惯，所以我们根据<code>易读性</code>的原则把 32 位的 IP 地址以 8 位为一组，分成四组，每组之间以 <code>.</code> 进行分割，再将每组转换为十进制数。如下图所示</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/20.png" style="zoom:50%;"></p>
<p>那么上面这个 32 位的 IP 地址就会被转换为十进制的 156.197.1.1。</p>
<p>除此之外，从图中我们还可以得到如下信息</p>
<p>每个这样 8 位位一组的数字，自然是非负数，其取值范围是 [0,255]。</p>
<p>IP 地址的总个数有 $2^{32}$次幂个，这个数值算下来是 <code>4294967296</code> ，大概能允许 43 亿台设备连接到网络。实际上真的如此吗？</p>
<p>实际上 IP 不会以主机的个数来配置的，而是根据设备上的 <code>网卡(NIC)</code> 进行配置，每一块网卡都会设置一个或者多个 IP 地址，而且通常一台路由器会有至少两块网卡，所以可以设置两个以上的 IP 地址，所以主机的数量远远达不到 43 亿。 </p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/21.png" style="zoom:50%;"></p>
<h5 id="保留IP地址"><a href="#保留IP地址" class="headerlink" title="保留IP地址"></a>保留IP地址</h5><p>在IPv4 的几类地址中，有几个保留的地址空间不能在互联网上使用。这些地址用于特殊目的，不能在局域网外部路由。</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/25.png" style="zoom:50%;"></p>
<h5 id="IP-地址构造和分类"><a href="#IP-地址构造和分类" class="headerlink" title="IP 地址构造和分类"></a>IP 地址构造和分类</h5><p>IP 地址由 <code>网络标识</code> 和 <code>主机标识</code> 两部分组成，网络标识代表着网络地址，主机标识代表着主机地址。网络标识在数据链路的每个段配置不同的值。网络标识必须保证相互连接的每个段的地址都不重复。而相同段内相连的主机必须有相同的网络地址。IP 地址的 <code>主机标识</code> 则不允许在同一网段内重复出现。</p>
<h5 id="子网"><a href="#子网" class="headerlink" title="子网"></a>子网</h5><p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/22.png" style="zoom:50%;"></p>
<p>为了确定网络区域，分开主机和路由器的每个接口，从而产生了若干个分离的网络岛，接口端连接了这些独立网络的端点。这些独立的网络岛叫做<strong>子网</strong></p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/24.png" style="zoom:50%;"></p>
<p>上图一共有6个子网，因为根据定义，分开主机和路由器的每个接口所产生的网络岛都算一个子网。</p>
<h5 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h5><p><code>子网掩码(subnet mask)</code> 又叫做网络掩码，它是一种用来指明一个 IP 地址的哪些位标识的是主机所在的网络。子网掩码用于屏蔽 IP 地址的一部分<strong>以区别网络标识和主机标识</strong>。 比如说：</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/23.png" style="zoom:50%;"></p>
<p>上图中子网掩码有24位，也就是高位的24位相同的计算机IP地址属于一个子网。剩下的8位用来作为主机标识。也就是说，我们只要知道子网掩码，就可以计算出这个子网中最多有多少计算机(需要减去 0.0.0.0 和1.1.1.1) </p>
<p>从上面的介绍也可以看出，在一个子网中，如果主机多的话，是很容易导致地址冲突的，为此我们接下来要介绍动态地址分配协议: DHCP</p>
<h4 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h4><p>DHCP 的全称是： Dynamic Host Configuration Protocol .</p>
<p>首先在这个子网中有一个跑着DHCP的 Server. 它能帮助主机自动配置地址。</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/28.png"></p>
<p>DHCP server和client 之间的对话过程如上图所示。</p>
<ul>
<li>一开始client是没有地址的，因此默认为 0.0.0.0，向全域进行广播(广播地址是 255.255.255.255)。</li>
<li>DHCP server听到后会给予回应，向需要IP的主机提供IP地址(以下图为例): 223.1.2.4, 网络掩码: 223.1.2.0/24, 默认路由器: 223.1.2.5 以及本地DNS服务器的IP地址.</li>
<li>client收到后还是进行广播(因为此时仍然没有给其分配地址)</li>
<li>最后DHCP server会响应DHCP ACK报文，此时client正式拥有了地址</li>
</ul>
<p>这边IP地址是有<strong>租约</strong>的，为3600秒，在这之后如果主机还在线，则可以<strong>续约</strong>。</p>
<p><strong>DHCP不光会告诉你在子网的IP地址，还会告诉你DNS，网关和子网掩码。</strong></p>
<p>DHCP是应用层协议，其底层是通过UDP实现的。</p>
<h4 id="路由聚集"><a href="#路由聚集" class="headerlink" title="路由聚集"></a>路由聚集</h4><p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/29.png"></p>
<p>ISP会下发IP地址，同时通告那些IP地址是我管辖的。</p>
<p>ISP又会向ICANN申请地址。</p>
<p>那么路由聚集有什么好处呢？ 答：可以方便管理。因为我总不能每买一台电脑就像电信局打电话申请一个IP地址，肯定是在一个子网里面分配地址。这样一来，意味着一个子网只通过接入IP地址的<strong>部分前缀</strong>和外部因特网相连, 外界并不关心子网内还存在着多个组织, 这种使用单个网络前缀通告多个网络的能力通常称为路由聚集。而且这个做法相当大地减少了在这些路由器中转发表的长度. </p>
<p>那么子网中不同的电脑怎么和外界进行交流呢？ 比如下图，子网中有三台电脑，IP地址各不相同，但是出去的时候，都是一个地址 <code>138.76.29.7</code> . 在子网中，通过不同的端口来判断不同的主机</p>
<ul>
<li>10.0.0.1 这个主机要通过3345端口发送一条信息</li>
<li>信息交给NAT router之后，就变成 138.76.29.7 ，5001端口发出</li>
<li>反馈信息在138.76.29.7 的5001端口收到之后，经过NAT router之后就传到变成10.0.0.1的3345串口</li>
</ul>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/30.png"></p>
<h4 id="IPV4"><a href="#IPV4" class="headerlink" title="IPV4"></a>IPV4</h4><p>IPv4 的全称是 <code>Internet Protocol version 4</code>，是 Internet 协议的第四版。IPv4 是一种无连接的协议，这个协议会尽最大努力交付数据包，也就是说它不能保证任何数据包能到达目的地，也不能保证所有的数据包都会按照正确的顺序到达目标主机，这些都是由上层比如传输控制协议控制的。也就是说，单从 IP 看来，这是一个不可靠的协议。</p>
<blockquote>
<p>前面我们讲过网络层分组被称为 <code>数据报</code>，所以我们接下来的叙述也会围绕着数据报展开。</p>
</blockquote>
<p>IPv4 的数据报格式如下</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/19.png"></p>
<p>上图我们也看出来了，TCP和数据报报文段首部都是20字节，加在一起，40字节是必要的。</p>
<p>在IP数据报中有很多信息：</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/1.jpg" style="zoom:50%;"></p>
<ul>
<li><code>版本字段(Version)</code>占用 4 bit，通信双方使用的版本必须一致，对于 IPv4 版本来说，字段值是 4。</li>
<li><code>首部长度(Internet Header Length)</code> 占用 4 bit，首部长度说明首部有多少 32 位(4 字节)。由于 IPv4 首部可能包含不确定的选项，因此这个字段被用来确定数据的偏移量。大多数 IP 不包含这个选项，所以一般首部长度设置为 5， 数据报为 20 字节 。</li>
<li><code>服务类型(Differential Services Codepoint，DSCP)</code> 占用 6 bit，以便使用不同的 IP 数据报，比如一些低时延、高吞吐量和可靠性的数据报。服务类型如下表所示</li>
</ul>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/26.png" style="zoom:50%;"></p>
<ul>
<li><p><code>拥塞通告(Explicit Congestion Notification，ECN)</code> 占用 2 bit，它允许在不丢弃报文的同时通知对方网络拥塞的发生。ECN 是一种可选的功能，仅当两端都支持并希望使用，且底层网络支持时才被使用。 最开始 DSCP 和 ECN 统称为 TOS，也就是区分服务，但是后来被细化为了 DSCP 和 ECN。</p>
</li>
<li><p><code>数据报长度(Total Length)</code> 占用 16 bit，这 16 位是包括在数据在内的总长度，理论上数据报的总长度为 2 的 16 次幂 - 1，最大长度是 65535 字节，但是实际上数据报很少有超过 1500 字节的。IP 规定所有主机都必须支持最小 576 字节的报文，但大多数现代主机支持更大的报文。当下层的数据链路协议的<code>最大传输单元（MTU）</code>字段的值小于 IP 报文长度时，报文就必须被分片。</p>
</li>
<li><p><code>标识符(Identification)</code> 占用 16 bit，这个字段用来标识所有的分片，因为分片不一定会按序到达，所以到达目标主机的所有分片会进行重组，每产生一个数据报，计数器加1，并赋值给此字段。</p>
</li>
<li><p><code>标志(Flags)</code> 占用 3 bit，标志用于控制和识别分片，这 3 位分别是</p>
<ul>
<li>0 位：保留，必须为0；</li>
<li>1 位：<code>禁止分片（Don’t Fragment，DF）</code>，当 DF = 0 时才允许分片；</li>
<li>2 位：<code>更多分片（More Fragment，MF）</code>，MF = 1 代表后面还有分片，MF = 0 代表已经是最后一个分片。</li>
</ul>
<p>如果 DF 标志被设置为 1 ，但是路由要求必须进行分片，那么这条数据报回丢弃</p>
</li>
<li><p><code>分片偏移(Fragment Offset)</code> 占用 13 位，它指明了每个分片相对于原始报文开头的偏移量，以 8 字节作单位。</p>
</li>
<li><p><code>存活时间(Time To Live，TTL)</code> 占用 8 位，存活时间避免报文在互联网中<code>迷失</code>，比如陷入路由环路。存活时间以秒为单位，但小于一秒的时间均向上取整到一秒。在现实中，这实际上成了一个跳数计数器：报文经过的每个路由器都将此字段减 1，当此字段等于 0 时，报文不再向下一跳传送并被丢弃，这个字段最大值是 255。</p>
</li>
<li><p><code>协议(Protocol)</code> 占用 8 位，这个字段定义了报文数据区使用的协议。协议内容可以在 <a href="https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml" target="_blank" rel="noopener">https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml</a> 官网上获取。比如值为6表明交给TCP, 值为17表明交给UDP.</p>
</li>
<li><p><code>首部校验和(Header Checksum)</code> 占用 16 位，首部校验和会对字段进行纠错检查，在每一跳中，路由器都要重新计算出的首部检验和并与此字段进行比对，如果不一致，此报文将会被丢弃。</p>
</li>
<li><p><code>源地址(Source address)</code> 占用 32 位，它是 IPv4 地址的构成条件，源地址指的是数据报的发送方</p>
</li>
<li><p><code>目的地址(Destination address)</code>占用 32 位，它是 IPv4 地址的构成条件，目标地址指的是数据报的接收方</p>
</li>
<li><p><code>选项(Options)</code> 是附加字段，选项字段占用 1 - 40 个字节不等，一般会跟在目的地址之后。如果首部长度 &gt; 5，就应该考虑选项字段。</p>
</li>
<li><p><code>数据</code> 不是首部的一部分，因此并不被包含在首部检验和中。</p>
</li>
</ul>
<h5 id="IPv4-分片"><a href="#IPv4-分片" class="headerlink" title="IPv4 分片"></a>IPv4 分片</h5><p>一个链路层帧能承载的最大数据量叫做<code>最大传输单元(Maximum Transmission Unit, MTU)</code>，每个 IP 数据报封装在链路层帧中从一台路由器传到下一台路由器。因为每个链路层所支持的最大 MTU 不一样，当数据报的大小超过 MTU 后，会在链路层进行分片，每个数据报会在链路层单独封装，每个较小的片都被称为 <code>片(fragement)</code>。</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/27.png" style="zoom:50%;"></p>
<p>每个片在到达目的地后会进行重组，准确的来说是在运输层之前会进行重组，TCP 和 UDP 都会希望发送完整的、未分片的报文，出于性能的原因，分片重组不会在路由器中进行，而是会在目标主机中进行重组。</p>
<p>当目标主机收到从发送端发送过来的数据报后，它需要确定这些数据报中的分片是否是由源数据报分片传递过来的，如果是的话，还需要确定何时收到了分片中的<code>最后一片</code>，并且这些片会如何拼接一起成为数据报。</p>
<p>针对这些潜在的问题，IPv4 设计者将 <strong>标识、标志和片偏移</strong>放在 IP 数据报首部中。当生成一个数据报时，发送主机会为该数据报设置源和目的地址的同时贴上<code>标识号</code>。发送主机通常将它发送的每个数据报的标识 + 1。当某路由器需要对一个数据报分片时，形成的每个数据报具有初始数据报的<strong>源地址、目标地址和标识号</strong>。当目的地从同一发送主机收到一系列数据报时，它能够检查数据报的标识号以确定哪些数据是由源数据报发送过来的。由于 IP 是一种不可靠的服务，分片可能会在网路中丢失，鉴于这种情况，通常会把分片的最后一个比特设置为 0 ，其他分片设置为 1，同时使用偏移字段指定分片应该在数据报的哪个位置。</p>
<h5 id="IPv4-寻址"><a href="#IPv4-寻址" class="headerlink" title="IPv4 寻址"></a>IPv4 寻址</h5><p>IPv4 支持三种不同类型的寻址模式，分别是</p>
<ul>
<li>单播寻址模式：在这种模式下，数据只发送到一个目的地的主机。</li>
</ul>
<h4 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h4><p>随着端系统接入的越来越多，IPv4 已经无法满足分配了，所以，IPv6 应运而生，IPv6 就是为了解决 IPv4 的地址耗尽问题而被标准化的网际协议。IPv4 的地址长度为 4 个 8 字节，即 32 比特， 而 IPv6 的地址长度是原来的四倍，也就是 128 比特，一般写成 8 个 16 位字节。</p>
<p>从 IPv4 切换到 IPv6 及其耗时，需要将网络中所有的主机和路由器的 IP 地址进行设置，在互联网不断普及的今天，替换所有的 IP 是一个工作量及其庞大的任务。我们后面会说。</p>
<p>我们先来看一下 IPv6 的地址是怎样的</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/31.png" style="zoom:50%;"></p>
<ul>
<li><code>版本</code>与 IPv4 一样，版本号由 4 bit 构成，IPv6 版本号的值为 6。</li>
<li><code>流量类型(Traffic Class)</code> 占用 8 bit，它就相当于 IPv4 中的服务类型(Type Of Service)。</li>
<li><code>流标签(Flow Label)</code> 占用 20 bit，这 20 比特用于标识一条数据报的流，能够对一条流中的某些数据报给出优先权，或者它能够用来对来自某些应用的数据报给出更高的优先权，只有流标签、源地址和目标地址一致时，才会被认为是一个流。</li>
<li><code>有效载荷长度(Payload Length)</code> 占用 16 bit，这 16 比特值作为一个无符号整数，它给出了在 IPv6 数据报中跟在鼎昌 40 字节数据报首部后面的字节数量。</li>
<li><code>下一个首部(Next Header)</code> 占用 8 bit，它用于标识数据报中的内容需要交付给哪个协议，是 TCP 协议还是 UDP 协议。</li>
<li><code>跳限制(Hop Limit)</code> 占用 8 bit，这个字段与 IPv4 的 TTL 意思相同。数据每经过一次路由就会减 1，减到 0 则会丢弃数据。</li>
<li><code>源地址(Source Address)</code> 占用 128 bit (8 个 16 位 )，表示发送端的 IP 地址。</li>
<li><code>目标地址(Destination Address)</code> 占用 128 bit (8 个 16 位 )，表示接收端 IP 地址。</li>
</ul>
<p>可以看到，相较于 IPv4 ，IPv6 取消了下面几个字段</p>
<ul>
<li><strong>标识符、标志和比特偏移</strong>：IPv6 不允许在中间路由器上进行分片和重新组装。这种操作只能在端系统上进行，IPv6 将这个功能放在端系统中，加快了网络中的转发速度。</li>
<li><strong>首部校验和</strong>：因为在运输层和数据链路执行了报文段完整性校验工作，IP 设计者大概觉得在网络层中有首部校验和比较多余，所以去掉了。<strong>IP 更多专注的是快速处理分组数据</strong>。</li>
<li><strong>选项字段</strong>：选项字段不再是标准 IP 首部的一部分了，但是它并没有消失，而是可能出现在 IPv6 的扩展首部，也就是下一个首部中。</li>
</ul>
<h4 id="IPv6-扩展首部"><a href="#IPv6-扩展首部" class="headerlink" title="IPv6 扩展首部"></a>IPv6 扩展首部</h4><p>IPv4 首部长度固定，无法将选项字段加入其中，取而代之的是 IPv6 使用了<code>扩展首部</code></p>
<p>扩展首部通常介于 IPv6 首部与 TCP/UDP 首部之间，在 IPv4 中可选长度固定为 40 字节，在 IPv6 中没有这样的限制。IPv6 的扩展首部可以是任意长度。扩展首部中还可以包含扩展首部协议和下一个扩展字段。</p>
<p>IPv6 首部中没有标识和标志字段，<strong>对 IP 进行分片时，需要使用到扩展首部</strong>。</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/32.png" style="zoom:50%;"></p>
<p>具体的扩展首部表如下所示</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/33.png" style="zoom:50%;"></p>
<p>下面我们来看一下 IPv6 都有哪些特点</p>
<h4 id="IPv6-特点"><a href="#IPv6-特点" class="headerlink" title="IPv6 特点"></a>IPv6 特点</h4><p>IPv6 的特点在 IPv4 中得以实现，但是即便实现了 IPv4 的操作系统，也未必实现了 IPv4 的所有功能。而 IPv6 却将这些功能大众化了，也就表明这些功能在 IPv6 已经进行了实现，这些功能主要有</p>
<ul>
<li><strong>地址空间变得更大</strong>：这是 IPv6 最主要的一个特点，即支持更大的地址空间。</li>
<li><strong>精简报文结构</strong>: IPv6 要比 IPv4 精简很多，IPv4 的报文长度不固定，而且有一个不断变化的选项字段；IPv6 报文段固定，并且将选项字段，分片的字段移到了 IPv6 扩展头中，这就极大的精简了 IPv6 的报文结构。</li>
<li><strong>实现了自动配置</strong>：IPv6 支持其主机设备的<strong>状态和无状态</strong>自动配置模式。这样，没有 <code>DHCP 服务器</code>不会停止跨段通信。</li>
<li><strong>层次化的网络结构</strong>： IPv6 不再像 IPv4 一样按照 A、B、C等分类来划分地址，而是通过 IANA -&gt; RIR -&gt; ISP 这样的顺序来分配的。IANA 是国际互联网号码分配机构，RIR 是区域互联网注册管理机构，ISP 是一些运营商（例如电信、移动、联通）。</li>
<li><strong>IPSec</strong>：IPv6 的扩展报头中有一个认证报头、封装安全净载报头，这两个报头是 IPsec 定义的。通过这两个报头网络层自己就可以实现端到端的安全，而无需像 IPv4 协议一样需要其他协议的帮助。</li>
<li><strong>支持任播</strong>：IPv6 引入了一种新的寻址方式，称为任播寻址。</li>
</ul>
<h4 id="IPv6-地址"><a href="#IPv6-地址" class="headerlink" title="IPv6 地址"></a>IPv6 地址</h4><p>我们知道，IPv6 地址长度为 128 位，他所能表示的范围是 2 ^ 128 次幂，这个数字非常庞大，几乎涵盖了你能想到的所有主机和路由器，那么 IPv6 该如何表示呢？</p>
<p>一般我们将 128 比特的 IP 地址以每 16 比特为一组，并用 <code>:</code> 号进行分隔，如果出现连续的 0 时还可以将 0 省略，并用 <code>::</code> 两个冒号隔开，记住，一个 IP 地址只允许出现一次两个连续的冒号。</p>
<p>下面是一些 IPv6 地址的示例</p>
<ul>
<li>二进制数表示</li>
</ul>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/34.png" style="zoom:50%;"></p>
<ul>
<li>用十六进制数表示</li>
</ul>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/35.png" style="zoom:50%;"></p>
<ul>
<li>出现两个冒号的情况</li>
</ul>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/36.png" style="zoom:50%;"></p>
<p>如上图所示，A120 和 4CD 中间的 0 被 :: 所取代了。</p>
<h3 id="如何从-IPv4-迁移到-IPv6"><a href="#如何从-IPv4-迁移到-IPv6" class="headerlink" title="如何从 IPv4 迁移到 IPv6"></a>如何从 IPv4 迁移到 IPv6</h3><p>我们上面聊了聊 IPv4 和 IPv6 的报文格式、报文含义是什么、以及 IPv4 和 IPv6 的特征分别是什么，看完上面的内容，你已经知道了 IPv4 现在马上就变的不够用了，而且随着 IPv6 的不断发展和引用，虽然新型的 IPv6 可以做到<code>向后兼容</code>，即 IPv6 可以收发 IPv4 的数据报，但是<strong>已经部署的具有 IPv4 能力的系统却不能够处理 IPv6 数据报</strong>。所以 IPv4 噬需迁移到 IPv6，迁移并不意味着将 IPv4 替换为 IPv6。这仅意味着同时启用 IPv6 和 IPv4。</p>
<blockquote>
<p>那么现在就有一个问题了，IPv4 如何迁移到 IPv6 呢？这就是我们接下来讨论的重点。</p>
</blockquote>
<h4 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h4><p>最简单的方式就是设置一个标志日，指定某个时间点和日期，此时全球的因特网机器都会在这时关机从 IPv4 迁移到 IPv6 。上一次重大的技术迁移是在 35 年前，但是很显然，不用我过多解释，这种情况肯定是 <code>不行的</code>。影响不可估量不说，如何保证全球人类都能知道如何设置自己的 IPv6 地址？一个设计数十亿台机器的标志日现在是想都不敢想的。</p>
<h4 id="隧道技术"><a href="#隧道技术" class="headerlink" title="隧道技术"></a>隧道技术</h4><p>现在已经在实践中使用的从 IPv4 迁移到 IPv6 的方法是 <code>隧道技术(tunneling)</code>。</p>
<blockquote>
<p>什么是隧道技术呢？</p>
</blockquote>
<p>隧道技术是一种使用互联网络的基础设施在网络之间的传输数据的方式，使用隧道传递的数据可以是不同协议的数据帧或包。使用隧道技术所遵从的协议叫做<code>隧道协议(tunneling protocol)</code>。隧道协议会将这些协议的数据帧或包封装在新的包头中发送。新的包头提供了路由信息，从而使封装的负载数据能够通过互联网络进行传递。</p>
<p>使用隧道技术一般都会建一个<code>隧道</code>，建隧道的依据如下：</p>
<p>比如两个 IPv6 节点(下方 B、E)要使用 IPv6 数据报进行交互，但是它们是经由两个 IPv4 的路由器进行互联的。那么我们就需要将 IPv6 节点和 IPv4 路由器组成一个隧道，如下图所示</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/37.png" style="zoom:50%;"></p>
<p>借助于隧道，在隧道发送端的 IPv6 节点可将整个 IPv6 数据报<strong>放到一个 IPv4 数据报的<code>数据(有效载荷)</code> 字段中</strong>，于是，IPv4 数据报的地址被设置为指向隧道接收端的 IPv6 的节点，比如上面的 E 节点。然后再发送给隧道中的第一个节点 C，如下所示</p>
<p> <img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/38.png" style="zoom:50%;"></p>
<p>隧道中间的 IPv4 提供路由，路由器不知道这个 IPv4 内部包含一个指向 IPv6 的地址。隧道接收端的 IPv6 节点收到 IPv4 数据报，会确定这个 IPv4 数据报含有一个 IPv6 数据报，通过观察数据报长度和数据得知。然后取出 IPv6 数据报，再为 IPv6 提供路由，就好像两个节点直接相连传输数据报一样。</p>
<h3 id="通用转发与SDN-软件定义网络"><a href="#通用转发与SDN-软件定义网络" class="headerlink" title="通用转发与SDN(软件定义网络)"></a>通用转发与SDN(软件定义网络)</h3><p>现在我们来讲通用转发和SDN, 其核心技术OpenFlow通过将网络设备的控制面与数据面分离开来，从而实现了网络流量的灵活控制，使网络作为管道变得更加智能，为核心网络及应用的创新提供了良好的平台。</p>
<p>在前面说的转发中，首先要查找目的IP地址(匹配)，然后将分组发送到特定输出端口(动作)。现在说的通用转发则是在一张表中就实现<code>匹配加动作</code>模式。而基于目的的转发可能意味着路由转发表非常庞大，且功能单一，不具有普遍性</p>
<p>下图就是SDN的模式</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/39.png" style="zoom:50%;"></p>
<p>利用分层的思想，SDN将数据与控制相分离。在控制层，包括具有逻辑中心化和可编程的控制器，可掌握全局网络信息。在数据层，包括交换机，仅提供简单的数据转发功能，可以快速处理匹配的数据包，适应流量日益增长的需求。两层之间采用开放的统一接口（如OpenFlow等）进行交互。控制器通过标准接口向交换机下发统一标准规则，交换机仅需按照这些规则执行相应的动作即可</p>
<p>使用了这张本地流表，当路由器收到一些垃圾网站的地址时，就可以直接丢弃了，相当于防火墙的功能。</p>
<h4 id="通用转发规则"><a href="#通用转发规则" class="headerlink" title="通用转发规则"></a>通用转发规则</h4><ul>
<li><p>Pattern: match values in packet header fields</p>
</li>
<li><p>Actions: for matched packet: drop, forward, modify, matched packet or send matched packet to controller </p>
</li>
<li><p>Priority: disambiguate overlapping patterns</p>
</li>
<li><p>Counters: <code>#bytes and #packets</code></p>
</li>
</ul>
<p>下面是一张流表，* 是通配符。比如收到来自<code>1.2.*.*</code> 的数据报就直接丢掉</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/40.png" style="zoom:50%;"></p>
<p>Openflow 可以通过MAC地址进行匹配,也可以通过IP地址进行匹配。</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/41.png" style="zoom:50%;"></p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/42.png" style="zoom:50%;"></p>
<ul>
<li>第一个例子，从 <code>51.6.0.8</code>来的包就转发到port6</li>
<li>第二个例子，只要通过端口号22来的包就直接扔掉</li>
<li>第三个例子，所有来自主机 <code>128.119.1.1</code> 发来的包就直接丢掉</li>
<li>第四个例子，屏蔽了某个特殊的MAC地址</li>
</ul>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/43.png" style="zoom:50%;"></p>
<h5 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h5><p>P19. Consider the SDN OpenFlow network shown in Figure 4.30 . Suppose that the desiredforwarding behavior for datagrams arriving at s2 is as follows:</p>
<ul>
<li>any datagrams arriving on input port 1 from hosts h5 or h6 that are destined to hosts h1 or h2 should be forwarded over output port 2;</li>
<li>any datagrams arriving on input port 2 from hosts h1 or h2 that are destined to hosts h5 or h6 should be forwarded over output port 1;</li>
<li>any arriving datagrams on input ports 1 or 2 and destined to hosts h3 or h4 should be delivered to the host specified;</li>
<li>hosts h3 and h4 should be able to send datagrams to each other</li>
</ul>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/44.png" style="zoom:50%;"></p>
<p>Specify the flow table entries in s2 that implement this forwarding behavior</p>
<p>对于S2来说，接口1收到来自h5或者h6的包之后，需要通过接口2来转发给h1或者h2</p>
<p>同样的，接口2收到来自h1或者h2的包之后，需要通过接口1来转发给h5或者h6</p>
<p>因此可以这样写：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>匹配</th>
<th>动作</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ingress Port = 1,src= <code>10.3.*.*</code> ,Dst = <code>10.1.*.*</code></td>
<td>Forward(2)</td>
</tr>
<tr>
<td>Ingress Port = 2,src= <code>10.1*.*</code> ,Dst = <code>10.3.*.*</code></td>
<td>Forward(1)</td>
</tr>
</tbody>
</table>
</div>
<p>对于第三条要求，从接口1、2收到的数据报，要通过接口3、4定向发送到h3和h4</p>
<p>因此可以这样写：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>匹配</th>
<th>动作</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ingress Port = 1,Dst = <code>10.2.0.3</code></td>
<td>Forward(3)</td>
</tr>
<tr>
<td>Ingress Port = 1,Dst = <code>10.2.0.4</code></td>
<td>Forward(4)</td>
</tr>
<tr>
<td>Ingress Port = 2,Dst = <code>10.2.0.3</code></td>
<td>Forward(3)</td>
</tr>
<tr>
<td>Ingress Port = 2,Dst = <code>10.2.0.4</code></td>
<td>Forward(4)</td>
</tr>
</tbody>
</table>
</div>
<p>对于第四条要求，h3和h4可以通过接口互相传信息</p>
<p>因此可以这样写：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>匹配</th>
<th>动作</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ingress Port = 4,src= <code>10.2.0.4</code> ,Dst = <code>10.2.0.3</code></td>
<td>Forward(3)</td>
</tr>
<tr>
<td>Ingress Port = 3 ,src= <code>10.2.0.3</code> ,Dst = <code>10.2.0.4</code></td>
<td>Forward(4)</td>
</tr>
</tbody>
</table>
</div>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/45.png" style="zoom:50%;"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>匹配</th>
<th>动作</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ingress Port=<code>3</code>    Dst=<code>10.1.*.*</code></td>
<td>Forward(2)</td>
</tr>
<tr>
<td>Ingress Port=<code>3</code>    Dst=<code>10.3.*.*</code></td>
<td>Forward(2)</td>
</tr>
<tr>
<td>Ingress Port=<code>4</code>    Dst=<code>10.1.*.*</code></td>
<td>Forward(1)</td>
</tr>
<tr>
<td>Ingress Port=<code>4</code>    Dst=<code>10.3.*.*</code></td>
<td>Forward(1)</td>
</tr>
</tbody>
</table>
</div>
<p>也就是说，来自h3主机的会从s2的接口2转发到s1，并由s1转发到h1、h2,或者再转发到s3, 这样就是顺时针转发</p>
<p>同样的，来自h4主机的包会在s2的接口1直接转发给s3，然后再有s3转发给s1，这就是逆时针方向</p>
<h2 id="控制层面"><a href="#控制层面" class="headerlink" title="控制层面"></a>控制层面</h2><p>传统上，控制平面功能与数据平面的转发功能在一起实现，在路由器中作为统一的整体。 但是在SDN中，在数据平面和控制平面做出了明确的分割，在一台分离的”控制器”服务中实现了控制平面功能，该<strong>控制器服务</strong>与<strong>它所控制的路由器转发组件</strong>完全分开并远离</p>
<p>在这个部分，我们将学习转发表和流表是如何计算、维护和安装的。下面给出了两种控制平面和数据平面的方案。</p>
<p><strong>每路由器控制：在控制平面中各个路由选择算法相互作用</strong></p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/46.png" style="zoom:50%;"></p>
<p><strong>逻辑集中式控制：一个完全分开的(Normally remote)控制器与本地控制代理交互</strong> 这对路由器的计算能力的要求可以没那么高。而且能够统一化接口，对品牌的差异性要求不大。</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/47.png" style="zoom:50%;"></p>
<h3 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h3><p>路由选择算法的目的是从发送方到接收方的过程中确定一条通过路由器网络的<strong>好的路径</strong>。 因为无论是<strong>每路由器控制方法</strong>还是<strong>逻辑集中式控制方法</strong>，发送过程中必定总是要经过一条定义良好的一连串路由器路径。</p>
<p>在数据结构中，我们学过在图中找一条最短路径的算法，如Djkstra 算法和 Bellman-Ford算法。 它们分别对应着<strong>链路状态路由选择算法(link state)</strong>和<strong>距离向量路由选择方法(distance vector)</strong></p>
<h4 id="链路状态路由选择算法"><a href="#链路状态路由选择算法" class="headerlink" title="链路状态路由选择算法"></a>链路状态路由选择算法</h4><p>LS 算法中，所有的链路开销都是已知的。实践中，这是通过让每个节点向网络中所有其他节点广播链路状态分组来完成的。每个链路状态分组包含他所连接的链路的标识和开销。</p>
<p>LS算法的实现就是Djkstra算法，详见我的博客： <a href="https://jasonxqh.github.io/2020/06/21/图与贪心算法/#最短路径：Dijkstra算法"> 最短路径：Dijkstra算法</a></p>
<p>当LS算法终止时，对于每个节点，我们都能得到从源节点沿着它的最低开销路径的前一节点。以此方式我们可以构建从源节点到所有目的节点的完整路径。</p>
<p>虽然在局域网中，主机的个数有限，因此可以简单的计算，但是整个英特网的节点很多，计算起来会比较麻烦。其算法复杂度平均为 $O(n^2)$， 优化过后可得到 $O(n\log n)$</p>
<h5 id="振荡问题"><a href="#振荡问题" class="headerlink" title="振荡问题"></a>振荡问题</h5><p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/48.png" style="zoom:50%;"></p>
<p>上图是一个简单的网络拓扑，图中的链路开销等于链路上承载的负载，例如反映要经历的时延。在该例中，链路开销是非对称的，即当在链路$(u,v)$两个方向所承载的负载相同时，$c(u,v)$和$c(v,u)$ 才相等。在上例中，节点z产生发往w的一个单元的流量，节点x也产生发往w的一个单元的流量，并且节点y也产生发往w的一个数量为e的流量。</p>
<p>那么当LS算法再次运行时，节点y (5-5a)确定顺时针到w的路径开销为1，逆时针(一直使用的) 到w的路径开销为1+e。因此y到w的最低开销路径现在变为顺时针的。类似的，x确定其到w的新的最低开销路径也是顺时针的，产生如(5-5b) 中所示的开销。当LS算法下次运行时，节点x、y和z都检测到一条到w的逆时针方向开销为0的路径。它们都将其流量引导到逆时针方向的路由上。</p>
<p>在下次运行LS算法时，x,y,z 又将其流量引导到顺时针方向的路由上。</p>
<p>很显然，这是一种不好的振荡。如何才能防止这样的振荡？一种解决方案可能强制链路开销不依赖于所承载的流量，但那是一种不可接受的解决方案——因为路由选择的目标之一就是要避开高度拥塞的链路。</p>
<p>另一种解决方案就是确保并非所有的路由器都同时运行LS算法，在每个节点上算法的时机也将是不同的。</p>
<h4 id="距离向量路由选择方法"><a href="#距离向量路由选择方法" class="headerlink" title="距离向量路由选择方法"></a>距离向量路由选择方法</h4><p>DV算法是一种迭代的，异步的和分布式的算法，而LS算法是一种使用全局信息的算法。其本质是 Bellman-Ford算法。</p>
<p>Bellman-Ford 算法是一种动态规划的算法。那么首先我们来了解一下Bellman-Ford 方程式：</p>
<p>令 $d_x(y)$ 为 x节点到y节点的最小代价，那么</p>
<script type="math/tex; mode=display">
d_x(y) = \min\{c(x,v)+d_v(y)\}</script><p>其中，$c(x,v)$ 代表 x到邻居v的距离，$d_v(y)$ 代表邻居 v到y节点的最小代价。我们看到下一张图</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/49.png" style="zoom:67%;"></p>
<p>我们从u出发，计算到z的距离。</p>
<p>显然$d_v(z) = 5,d_x(z) = 3,d_w(z) = 3$ ,那么 </p>
<script type="math/tex; mode=display">
d_u(z) = \min\{\\c(u,v)+d_v(z),\\c(u,x)+d_x(z),\\c(u,w)+d_w(z)\}
 =\min\{2+5,1+3,5+3\} = 4</script><p>与 LS算法相比，DV算法只知道它邻居的信息，而不掌握全局的拓扑信息。</p>
<p>DV算法的迭代是这样的一个循环：</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/50.png" style="zoom:67%;"></p>
<p>每个节点都在等待它邻居发来的变化信息，收到以后就重新计算距离，计算完成后把更新后的信息传给它的所有邻居并等待进入下次循环。直到距离不再变化，收敛的时候就停止算法</p>
<p>现在来看一个具体的例子：</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/51.png" style="zoom:67%;"></p>
<h5 id="DV算法存在的问题"><a href="#DV算法存在的问题" class="headerlink" title="DV算法存在的问题"></a>DV算法存在的问题</h5><p>DV算法也存在一些问题。其一就是<strong>好消息传播得快，坏消息传播得慢</strong>，我们分别讨论。</p>
<p><strong>好消息情况</strong></p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/52.png" style="zoom:67%;"></p>
<p>当x与y之间的距离向量从4变为1时，这是个好消息。</p>
<p>$t_0$ 时刻，y收到了这个变动，更新了它的DV表格，并告诉了它的邻居</p>
<p>$t_1$ 时刻，z收到了y发来的信息，并更新了它的DV表格，这时候，z到x的距离就从5变成2了。然后z也将这个好消息发给它的邻居</p>
<p>$t_2$时刻，y收到了来自z的更新，z告诉y：“我到x的距离只有2啦，可以借助我来更新！”，结果y并不需要更新它的表格了，因为y到x 的距离本来就比2小。至此，算法到这里就结束了，因为DV表都收敛了。</p>
<p><strong>坏消息情况</strong></p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/53.png" style="zoom:67%;"></p>
<p>当x与y之间的距离向量从4变为60时，这是个十足的坏消息。这时候，会发生如下的事：</p>
<ol>
<li>在链路开销变化之前，$D_y(x) = 4,D_y(z) = 1,D_z(y)=1,D_z(x)=5$. 在 $t_0$ 时刻，y检测到链路开销变化。y计算它到x的新开销。$D_y(x) = \min{c(y,x)+D_x(x),c(y,z)+D_z(x)}=\min{60+0,1+5}=6$ (因为此时 $D_z(x)$ 尚未更新。这就是我们所谓的<strong>路由环路</strong>，即为到达x，y通过z路由，z又通过y路由。路由选择环路就像一个黑洞，即目的地为x的分组在 $t_1$ 时刻到达y或者z之后，将在这两个节点之间不停地来回反复，直到转发表再次收敛为止</li>
<li>因为节点y已经算出到x的新的最低开销，其在$t_1$时刻将该新距离向量通知z</li>
<li>在$t_1$之后的某个时间，z收到了来自y的新距离向量，他指示了y到x的最低开销是6。z知道它能以开销1到达y，因此计算出到x的新最低开销 $D_z(x) = \min{50+0,1+6}=7$ 。因为z到x的最低开销已经增加了，于是他在 $t_2$时刻通知y其新开销</li>
<li>以类似的方式，在收到z的新距离向量后，$D_y(x) = \min(60+0,1+7) =8$, 并向z发送其距离向量。接下来z确定$D_z(x) = 9$ 并向y发送其距离向量……</li>
<li>最终，直到z最终算出它经由y的路径开销大于50为止，算法才能停止，而此时已经过了44次迭代。这就是<strong>坏消息传播得慢</strong>的原理</li>
</ol>
<h5 id="增加毒性逆转"><a href="#增加毒性逆转" class="headerlink" title="增加毒性逆转"></a>增加毒性逆转</h5><p>那么怎么破解这个问题呢？就是要破这个环路。</p>
<p>如果 $z$ 通过 $y$ 路由选择到目的地x，则z将通告y：“嗨，兄弟，我到x的距离是无穷大！“，也就是告诉y $D_z(x) = \infty$ . 那么，只要z经由y到x，那么z就会持续地向y讲述这个<strong>善意的小谎言</strong>。因为y相信z没有到x的路径，因此只要z继续经y到x，y将永远不会试图经由z路由选择到x</p>
<p>这时候$D_z(x) = \infty$, 因此$D_y(x) = \min{60+0,\infty} = 60$, 而 $D_z(x) =\min {60+1,50+0} = 50$, 最后 $D_y(x) = \min{50+1,60+0}=51$</p>
<p>然而，毒性逆转并没有解决一般的无穷级数问题。当涉及到3个或者更多节点(不只是直接相连的两个邻居节点)的环路，将无法使用毒性逆转技术检测到</p>
<h4 id="LS和DV的对比"><a href="#LS和DV的对比" class="headerlink" title="LS和DV的对比"></a>LS和DV的对比</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>LS</th>
<th>DV</th>
</tr>
</thead>
<tbody>
<tr>
<td>报文复杂度</td>
<td>每次更新O(nE) 条信息</td>
<td>只在邻居间交换，时间不等</td>
</tr>
<tr>
<td>收敛速度</td>
<td>要求 $O(nE)$个报文的$O(n^2)$算法</td>
<td>收敛较慢，有时会遇到选择环路</td>
</tr>
<tr>
<td>鲁棒性</td>
<td>较为鲁棒，路由计算较为分离</td>
<td>鲁棒性较差，会将错误扩散至整个网络</td>
</tr>
</tbody>
</table>
</div>
<h3 id="AS内：OSPF"><a href="#AS内：OSPF" class="headerlink" title="AS内：OSPF"></a>AS内：OSPF</h3><p>事实上，因特网是网络的网络，它并不是扁平的。我们把一个局域网叫做 AS(autonomous systems)。然后定义局域网内部的路由选择为 （intro-AS routing), 局域网和局域网之间的路由选择为 (inter-AS routing)</p>
<p>在同一个局域网内，采用相同的路由选择算法。我们通常使用 OSPF 路由</p>
<p>OSPF即开放最短路优先，它是一种链路状态协议，并使用Dijkstra来计算转发表。</p>
<p>OSPF的优点：</p>
<ul>
<li>安全 ，它可以在密码学上通过一些方法来保证数据不能被恶意篡改，另外能确定是某个人发出的信息，不能冒名顶替</li>
<li>允许有多条相同开销的路径 。这就是说，当存在多条相等开销的路径时，无需仅选择单一的路径来承载所有的流量</li>
<li>对单播与多播路由选择的综合支持较好 </li>
<li>支持在单个AS中的层次结构</li>
</ul>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/54.png" style="zoom:67%;"></p>
<p>OSFP 协议 试运行在 应用层上的。</p>
<h3 id="AS之间的路由选择：BGP"><a href="#AS之间的路由选择：BGP" class="headerlink" title="AS之间的路由选择：BGP"></a>AS之间的路由选择：BGP</h3><p>在ISP之间进行路由选择，就需要一个BGP协议</p>
<p>BGP 的全程是 Broder Gateway Protocol 边界网关协议。其无疑是所有因特网协议中最重要的。正式这个协议将因特网中数以千计的ISP黏合起来。对于自治系统AS之间的路由选择，要使用OSPF协议那样代价作为度量来寻找最佳路由是不现实的。比较合理的做法是在自治系统之间交换<strong>“可达性”</strong>信息。例如，告知相邻路由器：达到目的网路N可经过自治系统$AS_x$。在BGP的世界中，在路由器的转发表将具有形式为$(x,I)$的表项，其中x是一个前缀，如(<code>138.16.68/22</code>)，I 则是该路由器的接口之一的接口号</p>
<p>作为一种AS间的路由选择协议，BGP为每台路由器提供了这样的服务：</p>
<ul>
<li>从邻居AS获得前缀的可达性信息，BGP允许每个子网向因特网的其它部分通告：”嗨！我在这！”。 如果没有BGP，每个子网将孤独地存在</li>
<li>确定到该前缀的“最好的”路由。最好的路由将基于策略以及可达性信息来确定</li>
</ul>
<h4 id="通告BGP路由信息"><a href="#通告BGP路由信息" class="headerlink" title="通告BGP路由信息"></a>通告BGP路由信息</h4><p>对于每个AS，每台路由器要么是一台<code>网关路由器(gateway router)</code>，要么是一台<code>内部路由器(internal router)</code>.网关路由器是一台位于AS边缘的路由器，它直接连接到AS中的一台或者多台路由器。内部路由器仅连接在它自己AS中的主机和路由器。</p>
<p>如图所示， BGP 按照运行方式分为 EBGP（External/Exterior BGP）和 IBGP（Internal/Interior BGP）。</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/56.jpg" style="zoom:67%;"></p>
<p><strong>EBGP：</strong>运行于不同 AS 之间的 BGP 称为 EBGP。为了防止 AS 间产生环路，当 BGP 设备接收 EBGP 对等体发送的路由时，会将带有本地 AS 号的路由丢弃。</p>
<p><strong>IBGP：</strong>运行于同一 AS 内部的 BGP 称为 IBGP。为了防止 AS 内产生环路， BGP 设备不将从IBGP 对等体学到的路由通告给其他 IBGP 对等体，并与所有 IBGP 对等体建立全连接。为了解决 IBGP 对等体的连接数量太多的问题， BGP 设计了路由反射器和 BGP 联盟。</p>
<p>考虑下面这张图，AS内部的短虚线是IBGP，AS之间有长虚线是EBGP。 现在 AS3 要想 AS2发送一个BGP报文，告知 x 存在并位于AS3中。</p>
<p>在这个过程中: </p>
<p>网关路由器3a先向网关路由器2c发送了一个eBGP报文“AS3 x”。</p>
<p>网关路由器2c然后向AS2中的所有其他路由器(包括网关路由器2a)发送iBGP报文”AS3 x”</p>
<p>网关路由器2a接下来向网关路由器1c发送一个eBGP报文“AS2 AS3 x”</p>
<p>最后，网关路由器1c使用iBGP向AS1中的所有路由器发送报文”AS2 AS3 x”。 </p>
<p>在这个过程完成之后，在AS1和AS2中的每个路由器都知道了x的存在并且也都知道了通往x的AS路径</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/56.png" style="zoom:67%;"></p>
<p>再来看一个例子，当路由器1c到路由器3a附加了一条物理链路之后，在这种情况下，从AS1到x有两条路径：经过路由器1c的路径<code>AS2 AS3 x</code>以及经过路由器1d的新路径 <code>AS3 x</code> </p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/58.png" style="zoom:67%;"></p>
<h4 id="确定最好的路由"><a href="#确定最好的路由" class="headerlink" title="确定最好的路由"></a>确定最好的路由</h4><p>就像上面的图一样，从一个给定的路由器到一个目的子网可能有多条路径。事实上，因特网中的路由器常常接收到很多不同的可能路径的可达性信息。</p>
<p>那么，一台路由器怎么在这些路径中进行选择呢？</p>
<p>我们首先来了解一些BGP属性：AS-PATH 和 NEXT-HOP</p>
<blockquote>
<p>AS-PATH 属性包含了已经通告过的 AS的列表，如我们在前面的例子中所见。当一个前缀通过某AS时，该AS将其$ASN$ 加入 AS-PATH 中的现有列表。此外，AS-PATH 还可以用来检测和防止通告环路，因为如果一台路由器在列表中看到了包含他自己的AS，它将拒绝该通告  </p>
<p>NEXT-HOP 是 AS-PATH <strong>起始的路由器接口的IP地址</strong>。我们还是那上面这张图为例：<br>对于AS1通过AS2到x的路由“AS2 AS3 x” ，其属性 NEXT-HOP 是路由器2a最左端的接口的IP地址;<br>对于AS1绕过AS2到x的路由”AS3 x” ，其NEXT-HOP 是路由器3a的下侧接口</p>
</blockquote>
<h5 id="热土豆路由选择"><a href="#热土豆路由选择" class="headerlink" title="热土豆路由选择"></a>热土豆路由选择</h5><p>对于 AS 间的路由选择，路由器要如何学习到哪些网络可供转发？BGP 路由选择的原理是<strong>热土豆路由选择</strong>，即从所有路由中选择到开始该路由的 NEXT-HOP 路由器具有的最小开销作为学习的信息。通过热土豆路由选择添加 AS 外前缀的步骤如图所示，当 路由表学习可达性信息时，<strong>BGP 协议和 AS 内路由选择协议(OSPF 协议)需要协同工作</strong>。</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/59.png" style="zoom:80%;"></p>
<p>热土豆路由选择的思想是：将分组发给最近的网关路由器，用尽可能最低开销将分组送出其所在 AS。之所以称之为热土豆，就是当分组被类比为“热土豆”时，由于烫手，所以我们要尽可能快地把“热土豆”扔给下一个人。因此热土豆路由选择是一种自私的算法，它只考虑到减小自己 AS 内传输分组的开销，但是忽略了 AS 外端到端的其他开销。</p>
<p>比如说下面这个例子：</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/60.png" style="zoom:67%;"></p>
<p>现在 路由器1b想发送给x信息，有两条路由可以走：<code>AS2 AS3 x</code>和<code>AS3 x</code>. 假设开销定义为需要穿越的链路数，那么如果选择<code>AS2 AS3 x</code> ，NEXT-HOP 为 2a最左侧接口，最低开销为 2， 如果选择 <code>AS3 x</code> ，NEXT-HOP 则为3d的最左端接口，开销为3。 这时候，虽然我们从上帝视角看选择路由 <code>AS3 x</code> 更快，但是这颗<strong>热土豆</strong>太烫手了，1b想要尽快的把这个烫手的山芋扔给下一个人，那么它还是会选择<code>AS2 AS3 x</code>这条路径。</p>
<p>因而，热土豆路由选择是自私的算法，即他试图在减小他自己AS中的开销，而忽略在其AS之外的端对端开销的其他部分。</p>
<h5 id="路由器选择算法"><a href="#路由器选择算法" class="headerlink" title="路由器选择算法"></a>路由器选择算法</h5><p>在实践中，BGP使用了一种比热土豆路由选择更复杂但却结合了其特点的算法。我们知道BGP的路由选择算法的<strong>输入</strong>是<strong>到某前缀的所有路由的集合</strong>。如果到相同的前缀有两条或者多条路由，则顺序调用下列消除规则直到余下一条路由。</p>
<ol>
<li>路由被指派一个<strong>本地偏好(local preference)</strong> 值作为其属性之一。一条路由的本地偏好可能<strong>由该路由器设置</strong>或者可能<strong>由在相同AS中的另一台路由器学习到</strong> 。本地偏好属性的值是一种策略决定，它完全取决于AS的网络管理员。<strong>具有最高本地偏好值的路由将被选择</strong></li>
<li>从余下的路由中(现在都具有相同的最高本地偏好值)，将选择具有最短的AS-PATH路由。如果该规则是路由选择的唯一规则，那么BGP将使用DV算法决定路径，其中距离的测度使用AS跳的跳数而不是使用路由器跳的跳数</li>
<li>从余下的路由中(现在都具有最高本地偏好值和相同的AS-PATH长度)，使用热土豆选择，即选择具有最靠近 NEXT-HOP路由器的路由</li>
<li>如果仍留下多条路由，该路由器使用BGP标识符来选择路由。</li>
</ol>
<p>这样，回到上面这个例子。</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/60.png" style="zoom:67%;"></p>
<p>首先使用规定1(这里假设都具有最高的本地偏好值)</p>
<p>然后使用规定2，选择出最短的AS-PATH。因此将直接使用 <code>AS3 x</code> 路由。我们看到, BGP此时不再使用一种自私的算法了。</p>
<h3 id="SDN-控制平面"><a href="#SDN-控制平面" class="headerlink" title="SDN 控制平面"></a>SDN 控制平面</h3><p>下图提供了一个通用的SDN控制器详尽的示意图。控制器的功能大体可以分为3个层次，我们以一种非典型的自底向上的方式考虑这些层次：</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/61.png" style="zoom:67%;"></p>
<ul>
<li><strong>通信层</strong>： SDN 控制器和受控网络设备之间的通信。如果SDN控制器需要控制远程的机器运行，需要一个协议来传送控制器与这些设备的信息。如上图所示，这个协议构成了控制器体系结构的最底层。 控制器和受控设备之间的通信跨越了一个接口，他现在被称为控制器的<code>南向接口</code> </li>
<li><strong>网络范围状态管理层</strong>：由SDN控制平面做出的最终控制决定，将要求控制其具有 <code>有关网络的主机</code>、<code>链路</code>、<code>交换机</code>等设备的最新状态信息。</li>
<li><strong>对于网络控制应用程序层的接口</strong>：控制器通过其<code>北向API</code> 与网络控制应用程序交互。该API允许网络控制应用程序在状态管理层之间 读写网络状态和流表。 当状态改变事件发生时，应用程序能够注册进行通告。</li>
</ul>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h5 id="1"><a href="#1" class="headerlink" title="1"></a>1</h5><p>前面讲过路由器和链路层交换机都被称为分组交换机. 路由器与链路层交换机间的根本区别是什么?</p>
<p>答:<br>路由器和链路层交换机的根本区别是它们服务于不同的网络层协议. 链路层交换机基于链路层帧中的字段值做出转发决定, <strong>服务于第二层链路层</strong>; 路由器基于网络层数据报中的首部字段值做出转发决定, <strong>服务于第三层网络层</strong>.</p>
<h5 id="2"><a href="#2" class="headerlink" title="2"></a>2</h5><p>讨论为什么在高速路由器的每个输入端口都存储转发表的影子副本.</p>
<p>答： </p>
<p>首先一个路由器是有很多个输入端口的, 转发行为的第一步是在转发表中查找输出接口. 如果每个输入端口都并发地调用路由选择器查找输出接口必然会产生时延. 所以要在高速路由器的每个输入端口都存储转发表的影子副本, 使转发决策能在每个输入端口本地做出,<strong>避免了集中式处理的瓶颈</strong>.</p>
<h5 id="3"><a href="#3" class="headerlink" title="3"></a>3</h5><p>路由器有IP地址吗? 如果有, 多少个?</p>
<ul>
<li>路由器有IP地址, 这里的有IP地址并不是说有一个IP地址标志一台路由器. 而是说路由器的一个输入或输出端口对应着一个IP地址.</li>
<li>所以一个路由器拥有的IP地址数是不确定的, 假如一个路由器有一个输入端和两个输出端, 那么对应地就有三个IP地址, 分别对应三个端口.</li>
</ul>
<h5 id="4"><a href="#4" class="headerlink" title="4"></a>4</h5><p>什么时候一个大数据报分割成多个较小的数据报? 较小的数据报在什么地方装配成一个较大的数据报?</p>
<ul>
<li>网络层的数据报需要往下经过链路层封装成链路层帧才能放上链路开始传输. 然而一个链路层帧的载荷大小根据链路层协议的不同而不同, 数据报的大小不能超过一个链路层帧的最大传送单元(Maximum Transmission Unit, MTU). 所以当链路层<strong>遇到大于自身MTU的数据报时</strong>需要把数据报分割成多个较小的数据报. <strong>这项工作将放到端系统中进行, 因为如果在路由器中进行的话会大大降低路由器的性能</strong>.</li>
<li>较小的数据报在<strong>目的端系统的网络层</strong>进行装配.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/" class="post-title-link" itemprop="url">计算机网络报告Week12</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-30 21:01:30" itemprop="dateCreated datePublished" datetime="2021-05-30T21:01:30+08:00">2021-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-23 22:25:30" itemprop="dateModified" datetime="2022-08-23T22:25:30+08:00">2022-08-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Week12-TCP协议和IP协议分析"><a href="#Week12-TCP协议和IP协议分析" class="headerlink" title="Week12 TCP协议和IP协议分析"></a>Week12 TCP协议和IP协议分析</h1><h2 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1.实验目的"></a>1.实验目的</h2><ul>
<li>了解TCP协议的工作原理</li>
<li>学习TCP建立连接三次握手的过程</li>
<li>学习TCP断开连接四次挥手的过程</li>
<li>快速简单了解IP协议，特别是IP数据报</li>
<li>研究IP数据分片方法</li>
</ul>
<h2 id="2-实验任务"><a href="#2-实验任务" class="headerlink" title="2. 实验任务"></a>2. 实验任务</h2><ul>
<li>使用 Wireshark 快速了解TCP协议</li>
<li>使用 Wireshark 快速了解 IP 协议</li>
</ul>
<h2 id="3-实验过程"><a href="#3-实验过程" class="headerlink" title="3. 实验过程"></a>3. 实验过程</h2><h3 id="3-1-Wireshark-抓取TCP包"><a href="#3-1-Wireshark-抓取TCP包" class="headerlink" title="3.1 Wireshark 抓取TCP包"></a>3.1 Wireshark 抓取TCP包</h3><ul>
<li>TCP 协议 </li>
</ul>
<p>TCP 被称为是面向连接的(connection oriented), 这是因为在一个应用进程可以开始向另一个应用进程发送数据之前，这两个进程必须互相先”握手”, 即它们必须相互发送某些预备报文段，以建立确保数据传输的参数。</p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/1.jpg" style="zoom: 50%;"></p>
<ul>
<li>Wireshark 相关知识详见 Exp6: DNS 报文分析和基于UDP的Socket编程</li>
</ul>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/2.jpg" style="zoom: 50%;"></p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/3.jpg" style="zoom: 50%;"></p>
<h4 id="Task1"><a href="#Task1" class="headerlink" title="Task1:"></a>Task1:</h4><p>利用Wireshark 抓取一个TCP抓取数据包， 查看其具体数据结构和实际的数据 (要求根据报文结构正确标识每个部分)， 请将实验结果附在实验报告中</p>
<p>这里，注释的部分为该字段的名称以及实际数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Transmission Control Protocol, Src Port: <span class="number">50177</span>, Dst Port: <span class="number">443</span>, Seq: <span class="number">1</span>, Ack: <span class="number">2</span>, Len: <span class="number">0</span></span><br><span class="line">    Source Port: <span class="number">50177</span>   					<span class="comment"># 源端口号   C4	01</span></span><br><span class="line">    Destination Port: <span class="number">443</span>					<span class="comment"># 目的端口号 01 bb</span></span><br><span class="line">    [Stream index: <span class="number">16</span>]					</span><br><span class="line">    [TCP Segment Len: <span class="number">0</span>]</span><br><span class="line">    Sequence Number: <span class="number">1</span>    (relative sequence number)		<span class="comment"># 序号 	12 2f f1 74</span></span><br><span class="line">    Sequence Number (raw): <span class="number">305131892</span>										</span><br><span class="line">    [Next Sequence Number: <span class="number">1</span>    (relative sequence number)] </span><br><span class="line">    Acknowledgment Number: <span class="number">2</span>    (relative ack number) 	<span class="comment"># 确认号 60 c2 55 c9</span></span><br><span class="line">    Acknowledgment number (raw): <span class="number">1623348681</span></span><br><span class="line">    <span class="number">0101</span> .... = Header Length: <span class="number">20</span> bytes (<span class="number">5</span>)		<span class="comment"># 首部长度 (长8个bit) 50</span></span><br><span class="line">    Flags: <span class="number">0x010</span> (ACK)</span><br><span class="line">        <span class="number">000.</span> .... .... = Reserved: Not set <span class="comment"># 保留未用 50 10</span></span><br><span class="line">        ..<span class="number">.0</span> .... .... = Nonce: Not set</span><br><span class="line">        .... <span class="number">0.</span>.. .... = Congestion Window Reduced (CWR): Not set</span><br><span class="line">        .... <span class="number">.0</span>.. .... = ECN-Echo: Not set</span><br><span class="line">        .... .<span class="number">.0</span>. .... = Urgent: Not set</span><br><span class="line">        .... ..<span class="number">.1</span> .... = Acknowledgment: Set <span class="comment"># Flag中的ACK已经被标记</span></span><br><span class="line">        .... .... <span class="number">0.</span>.. = Push: Not set			</span><br><span class="line">        .... .... <span class="number">.0</span>.. = Reset: Not set</span><br><span class="line">        .... .... .<span class="number">.0</span>. = Syn: Not set</span><br><span class="line">        .... .... ..<span class="number">.0</span> = Fin: Not set </span><br><span class="line">        <span class="comment"># 其余Flag均未被标记</span></span><br><span class="line">        [TCP Flags: ·······A····]</span><br><span class="line">    Window: <span class="number">4096</span> 									<span class="comment"># 接收窗口大小 10 00</span></span><br><span class="line">    [Calculated window size: <span class="number">4096</span>]</span><br><span class="line">    [Window size scaling factor: <span class="number">-1</span> (unknown)]</span><br><span class="line">    Checksum: <span class="number">0x5abf</span> [unverified]	<span class="comment"># 因特网检验和 5a bf</span></span><br><span class="line">    [Checksum Status: Unverified]</span><br><span class="line">    Urgent Pointer: <span class="number">0</span>							<span class="comment"># 紧急数据指针 00 00 (未设置)</span></span><br><span class="line">    [SEQ/ACK analysis]</span><br><span class="line">    [Timestamps]</span><br></pre></td></tr></table></figure>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/1.png" style="zoom: 50%;"></p>
<h3 id="3-2-TCP-三次握手"><a href="#3-2-TCP-三次握手" class="headerlink" title="3.2 TCP 三次握手"></a>3.2 TCP 三次握手</h3><p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/4.jpg"></p>
<h4 id="Task2："><a href="#Task2：" class="headerlink" title="Task2："></a>Task2：</h4><p>根据TCP三次握手的交互图以及TCP报文段结构图逐步分析三次握手过程，请将实验结果附在实验报告中</p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/9.png"></p>
<p>这就是本地电脑和百度三次握手的过程。 每次握手的过程这里重复了两次，但内容是一样的</p>
<h5 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h5><p>首先，是从本地客户端发向百度服务器的一个数据报。在这个数据报中，Seq=0，说明一开始是从序号为0的包好事发送的。我们看到这里SYN 这一位已经被设为1了，因为还没收到来自百度的确认信息，因此这里ACK为设为0</p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/10.png"></p>
<h5 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h5><p>这是百度服务器给本地电脑发送的报文，其中 Seq=0, ACK = 1 ,因为TCP是全双工通信的，因此从百度发送来的第一个报文段也是从 seq=0 开始的。但是这个报文段中包含了对我发给百度的包的确认信息，因此这里ACK被设置了，且值为1，这说明 1 以前的包我全部都收到了，请本地发送1以后的包</p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/11.png"></p>
<h5 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h5><p>第三次握手是本地发送给百度服务器的，此时， Seq=1, 说明这是本地发送的第二个包了(第一个包Seq=0) ； ACK = 1 说明已经收到了来自服务端的 1以前的所有包。</p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/12.png"></p>
<p>至此，本地和服务端的三次握手已经结束，可以相互传递信息了</p>
<h3 id="3-3-TCP-四次挥手"><a href="#3-3-TCP-四次挥手" class="headerlink" title="3.3 TCP 四次挥手"></a>3.3 TCP 四次挥手</h3><p>当通信双方完成数据传输，需要进行TCP连接的释放，由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍然能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。因为正常关闭过程需要发送4个TCP帧，因此这个过程也叫四次挥手。</p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/5.jpg"></p>
<h4 id="Task3"><a href="#Task3" class="headerlink" title="Task3:"></a>Task3:</h4><p>根据TCP四次挥手的交互图以及TCP报文段结构图逐步分析四次挥手过程，请将实验结果附在实验报告中。</p>
<p>这是四次挥手的过程：</p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/13.png"></p>
<h5 id="第一次挥手"><a href="#第一次挥手" class="headerlink" title="第一次挥手"></a>第一次挥手</h5><p>第一次挥手是百度向本地发送的一个包， Seq=80634 Ack =6224. 同时，设定了Fin位，表示服务器单方面想和本地断开联系。</p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/14.png"></p>
<h5 id="第二次挥手"><a href="#第二次挥手" class="headerlink" title="第二次挥手"></a>第二次挥手</h5><p>第二次挥手是本地收到了百度想要结束的Fin之后，返回了一个带有ACK的包。同时告诉服务器，ACK=80635,说明80635以前的数据段都已经收到了。</p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/15.png"></p>
<h5 id="第三次挥手"><a href="#第三次挥手" class="headerlink" title="第三次挥手"></a>第三次挥手</h5><p>前两次挥手是主动关闭方断开连接，但是只是单方面关闭连接。现在要被动关闭方来断开连接，才能实现真正的断连。</p>
<p>我们看到这个是 本地向百度发送的包，设置了Fin和ACK，注意到这个包的ACK和第二次挥手发送的ACk的值是一模一样的，因为在这两次挥手之间没有收到新的来自百度的包</p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/16.png"></p>
<h5 id="第四次挥手"><a href="#第四次挥手" class="headerlink" title="第四次挥手"></a>第四次挥手</h5><p>第四次挥手，是百度收到了本地发送的带有FIN 标志的包后，返回的确认报文。</p>
<p>这个报文比较特殊，因为返回的报文只设置了RST位，没有设置 Seq，Ack。 RST位被设置以后，接收端收到之后不必发送ACK包。</p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/17.png"></p>
<h3 id="3-4-IP分片"><a href="#3-4-IP分片" class="headerlink" title="3.4 IP分片"></a>3.4 IP分片</h3><ul>
<li>IP报文格式</li>
</ul>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/6.jpg"></p>
<ul>
<li>根据上课学习知道IP报文要交给数据链路层封装后才能发送，理想状况下，每个IP报文正好能放在同一个物理帧中发送。如果一个数据包超过1500字节(以太网的帧中最多可容纳1500字节的数据). 就需要将该包进行分片发送，这个上限被称为物理网络的最大传输单元(MTU. Maxium Transfer Unit)</li>
<li>TCP/IP 协议在发送IP数据报文时，一般选择一个合适的初始长度。当这个报文要从一个MTU大的子网发送一个MTU 小的网络时，IP协议就把这个报文的数据部分分割成能被目的子网锁容纳的较小的数据分片，组成较小的报文发送。每个较小的报文被称为一个分片。 每个分片都有一个IP 报文头，分片后的数据包的IP报头和原式IP报头分片偏移、MF标志位和校验字段不同外，其他都一样。</li>
<li>下面通过使用ICMP 包，来产生IP分片数据包。使用ICMP包进行测试时，如果不指定包的大小，可能无法查看被分片的数据报。由于IP首部占用20个字节，ICMP首部占8个字节，所以捕获ICMP包大小最大为1472字节。但是在一般情况下，ping 命令默认的大小都不会唱过1472。 这样，发送的ICMP包就可以顺利通过，不需要经过分片再传输，如果想捕获到IP分片的包，需要指定发送的ICMP包必须大于1472 字节。</li>
<li>可通过下方命令指定发送包的大小，如： <code>ping -s 3005 www.ecnu.edu.cn</code></li>
</ul>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/7.jpg"></p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/8.jpg"></p>
<h4 id="Task4"><a href="#Task4" class="headerlink" title="Task4"></a>Task4</h4><p>任取一个有IP协议的ICMP数据报并根据该报文分析IP协议的报文格式(正确标注每一个部分)， 请将实验结果附在实验报告中</p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/18.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Internet Protocol Version <span class="number">4</span>, Src: <span class="number">192.168</span><span class="number">.31</span><span class="number">.15</span>, Dst: <span class="number">180.101</span><span class="number">.49</span><span class="number">.11</span> <span class="comment"># 源地址和目标地址</span></span><br><span class="line">    <span class="number">0100</span> .... = Version: <span class="number">4</span>	<span class="comment"># 版本号，一般是4   </span></span><br><span class="line">    .... <span class="number">0101</span> = Header Length: <span class="number">20</span> bytes (<span class="number">5</span>) <span class="comment"># 头部长度，为20 bytes</span></span><br><span class="line">    Differentiated Services Field: <span class="number">0x00</span> (DSCP: CS0, ECN: Not-ECT)</span><br><span class="line">    Total Length: <span class="number">84</span> <span class="comment">#总长度 16进制值为 00 54</span></span><br><span class="line">    Identification: <span class="number">0xe6a0</span> (<span class="number">59040</span>) <span class="comment"># 标志 </span></span><br><span class="line">    Flags: <span class="number">0x00</span>					<span class="comment"># 标识</span></span><br><span class="line">    Fragment Offset: <span class="number">0</span> <span class="comment"># 片偏移 和flag合起来是 0000</span></span><br><span class="line">    Time to Live: <span class="number">64</span>	 <span class="comment"># 生存时间 40</span></span><br><span class="line">    Protocol: ICMP (<span class="number">1</span>) <span class="comment"># 协议 01</span></span><br><span class="line">    Header Checksum: <span class="number">0xcee0</span> [validation disabled] <span class="comment"># 首部检验和 ce e0</span></span><br><span class="line">    [Header checksum status: Unverified]</span><br><span class="line">    Source Address: <span class="number">192.168</span><span class="number">.31</span><span class="number">.15</span>		<span class="comment"># 源地址 ce a8 1f 0f </span></span><br><span class="line">    Destination Address: <span class="number">180.101</span><span class="number">.49</span><span class="number">.11</span> <span class="comment"># 目标地址 b4 65 31 0b</span></span><br></pre></td></tr></table></figure>
<h4 id="Task5"><a href="#Task5" class="headerlink" title="Task5"></a>Task5</h4><p>对截获的报文进行分析，将属于同一个ICMP报文的分片找出来，并分析其字节长度特点(如，每个分片的大小，片偏移等)，请将实验结果附在报告中</p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/19.png"></p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/20.png"></p>
<p>我想 www.ecnu.edu.cn ping 了一段长1500的报文，发现被分割成了两段。其中一段长 1514，一段长62</p>
<p>点开第一段报文和第二段报文：</p>
<p><img src="/2021/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8AWeek12/21.png"></p>
<p>我们发现他们的 Identification 都是一样的，为 0x0bcd. 由此我们可以断定这两个分片属于同一个ICMP报文。</p>
<p>第一段报文是只有IP层，没有ICMP层的。总长度为1500，即一个MTU。但是因为IP层头长度为20，所以data的总长度只有1480。 因为这是第一个报文，因此并没有数据偏移量，因此这时 <strong>Fragment Offset : 0</strong> ，同时在Flags中也有注明，说有其他分片。</p>
<p>第二段报文报文的总长度为48，头长度为20，data是28，那么为什么不是20而是28呢？因为ICMP的头部占了8个字节。因为这是最后一段报文，因此Flag为0，前面只有一个满的报文，因此 <strong>Fragment Offset</strong>为1480. </p>
<p>因为说不管ping的字节有多长，一定都是填满一个报文之后再分出来，所以其Offset 一定都是1480的整数倍。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A-rdt3-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A-rdt3-0/" class="post-title-link" itemprop="url">计算机网络报告-rdt3.0</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-23 10:29:14" itemprop="dateCreated datePublished" datetime="2021-05-23T10:29:14+08:00">2021-05-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-25 04:31:40" itemprop="dateModified" datetime="2022-08-25T04:31:40+08:00">2022-08-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机网络报告-rdt3-0"><a href="#计算机网络报告-rdt3-0" class="headerlink" title="计算机网络报告-rdt3.0"></a>计算机网络报告-rdt3.0</h1><p>在我的学习博客 <a href="https://jasonxqh.github.io/2021/05/03/计算机网络-运输层总结/#rdt3-0">可靠数据传输原理 rdt3.0</a> 中，我已经详细介绍了 rdt3.0 的发送方和接收方的有限状态机，并且介绍了 GBN 和 SR 的原理。</p>
<h2 id="报文类"><a href="#报文类" class="headerlink" title="报文类"></a>报文类</h2><p>我们把packet 抽象出来单独写一个类。在这个类中，我们提供了一些方法——生成包的方法生成和检验校验和的方法，解析报文的方法，模拟包报文出错的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company; </span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">packet</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 类中必须囊括序号、以及检验和</span></span><br><span class="line">   Integer seqNo;</span><br><span class="line">   Integer checksum;</span><br><span class="line">  <span class="comment">// 发送的内容</span></span><br><span class="line">   <span class="keyword">public</span> String content;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 初始化的packet 的seqNo=1, </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">packet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      seqNo = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 这个方法教给发送者调用，可以将读取的信息封装到 packet当中</span></span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createPacket</span><span class="params">(String pContent,<span class="keyword">int</span> seqNo)</span> </span>&#123;</span><br><span class="line">		content = pContent;</span><br><span class="line">   	<span class="comment">// 为内容设置校验和</span></span><br><span class="line">		checksum = generateChecksum(content);</span><br><span class="line">   	<span class="comment">// 在rdt3.0中，序号只可能是0或者1，由发送者控制序号的变化</span></span><br><span class="line">		<span class="keyword">this</span>.seqNo = seqNo;</span><br><span class="line">	&#125;</span><br><span class="line">   <span class="comment">// 帮助发送者生成统一格式的信息</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">generateMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> seqNo+ <span class="string">" "</span> + checksum + <span class="string">" "</span> + content;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 生成检验和的函数，原本算法就是将前面3个16位相加，但是这里没有源端口和目的端口</span></span><br><span class="line">  <span class="comment">// 因此，我们对发送的信息做一个处理，将其转换为ascii码作为检验和</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Integer <span class="title">generateChecksum</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> asciiInt;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">         asciiInt = (<span class="keyword">int</span>) s.charAt(i);</span><br><span class="line">         sum = sum + asciiInt;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个方法是帮助接收者解析从套接字获取的data</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseMessage</span><span class="params">(String pcontent)</span> </span>&#123;</span><br><span class="line">       String[] splited = pcontent.split(<span class="string">"\\s+"</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; splited.length; i++) &#123; </span><br><span class="line">         <span class="comment">// 依次赋值给seqNo 和 checksum</span></span><br><span class="line">          seqNo = Integer.parseInt(splited[<span class="number">0</span>]);</span><br><span class="line">          checksum = Integer.parseInt(splited[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 最后一个元素才是 要发送的内容</span></span><br><span class="line">          content = splited[<span class="number">2</span>];</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 模拟包出错，可以将checksum+1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">corruptChecksum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       checksum = checksum + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个方法是帮助接收者判断包裹的信息是否出错的，也就是将计算得到的checksum和发送来的checksum作比较</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">validateMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	Integer newChecksum = generateChecksum(content);</span><br><span class="line">    	<span class="keyword">if</span> (newChecksum.equals(checksum))</span><br><span class="line">    		<span class="keyword">return</span>  seqNo;</span><br><span class="line">    <span class="comment">//如果两者不相等，说明包损坏了，给发送者发送相反的ACK，这样发送者就知道出错了，需要重发</span></span><br><span class="line">    	<span class="keyword">else</span> &#123;</span><br><span class="line">        seqNo = <span class="number">1</span>-seqNo;</span><br><span class="line">        <span class="keyword">return</span> seqNo;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="网络层搭建"><a href="#网络层搭建" class="headerlink" title="网络层搭建"></a>网络层搭建</h2><p>要实现rdt 3.0 我们首先要搭建一个底层的网络层,作为传输信道。它的作用就是连接两个”主机端“，这里，发送者和接收者用同一主机上的两个进程来模拟。这样，发送者和接收者就可以通过”网络层”来相互传递消息了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">network</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 泛型 List用来存放要发送的所有信息</span></span><br><span class="line">	<span class="keyword">static</span> List&lt;Object&gt; allMessages = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">  <span class="comment">// 用serverSocket这个类型的套接字来接入发送者和接收者</span></span><br><span class="line">	<span class="keyword">static</span> ServerSocket serverSocket;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> portNumber;</span><br><span class="line">    </span><br><span class="line">    portNumber = <span class="number">5678</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">			serverSocket = <span class="keyword">new</span> ServerSocket(portNumber);</span><br><span class="line">			System.out.println(<span class="string">"Waiting... connect receiver"</span>);</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      服务器需随时待命，因为不知道客户端什么时候会发来请求，此时，我们需要使用ServerSocket</span></span><br><span class="line"><span class="comment">      ServerSocket与Socket不同，ServerSocket是等待客户端的请求，一旦获得一个连接请求，就创建一个Socket示例来与客户端进行通信。 </span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">				<span class="keyword">new</span> MessageThread(serverSocket.accept()).start();</span><br><span class="line">				<span class="keyword">new</span> MessageThread(serverSocket.accept()).start();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"I/O failure: "</span> + e.getMessage());</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将接收到的套接字传送给MessageThread类，为了模拟出 检验和出现错误、丢包的情况，我们这里需要分类来写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Socket socket = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACK2 = <span class="string">"ACK2"</span>;</span><br><span class="line">	MessageThread mt = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">int</span> ID = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MessageThread</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.socket = socket;</span><br><span class="line">		allMessages.add(<span class="keyword">this</span>);</span><br><span class="line">		ID = allMessages.size() - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String input = <span class="string">""</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			PrintWriter streamOut = <span class="keyword">null</span>;</span><br><span class="line">			BufferedReader readerIn = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//  给接进来的socket创建一个PrintWriter，这样就可以直接通过println来向客户端或者服务端传信息</span></span><br><span class="line">			streamOut = <span class="keyword">new</span> PrintWriter(socket.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line">      <span class="comment">// 给socket的输入流创建一个 BufferedReader,作为缓冲区，</span></span><br><span class="line">			readerIn = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">	</span><br><span class="line">			System.out.println(<span class="string">"Get connection from: "</span> + socket.getRemoteSocketAddress().toString());</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">while</span> ((input = readerIn.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果读入为空</span></span><br><span class="line">				<span class="keyword">if</span> (input.equals(<span class="string">"-1"</span>)) &#123;</span><br><span class="line">					<span class="comment">// 且这个线程为 发送者，那么就给接收者发一个-1</span></span><br><span class="line">					<span class="keyword">if</span> (ID == <span class="number">1</span>) &#123;</span><br><span class="line">						sendToOtherThread(<span class="string">"-1"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 这是一个正则表达式，用来匹配任意空白字符的，也就是按照空白处分割message</span></span><br><span class="line">				String[] splitedMsg = input.split(<span class="string">"\\s+"</span>);</span><br><span class="line">				<span class="comment">//现在开始我们要模拟 顺利发送、丢包、包损坏这些情况</span></span><br><span class="line">				<span class="keyword">double</span> x = Math.random();</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//这里我设置了有一半的几率会顺利通过。当receiver 回传ack时，长度只有1，这里也设为通过</span></span><br><span class="line">				<span class="keyword">if</span> (x &lt; <span class="number">0.5</span> || splitedMsg.length == <span class="number">1</span>) <span class="comment">// PASS</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (splitedMsg[<span class="number">0</span>].contains(<span class="string">"ACK"</span>)) &#123;</span><br><span class="line">						System.out.println(<span class="string">"Receiver: "</span> + splitedMsg[<span class="number">0</span>] + <span class="string">", to Sender"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span>  </span><br><span class="line">						System.out.println(<span class="string">"Sender: Packet"</span> + splitedMsg[<span class="number">0</span>]  +<span class="string">", PASS"</span>);</span><br><span class="line">          <span class="comment">// 将一个端的信息发送到另外一端</span></span><br><span class="line">					sendToOtherThread(input);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 如果出现了包损坏，我们的策略就是修改检验和，几率是1/4</span></span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (x &gt;= <span class="number">0.5</span> &amp;&amp; x &lt;= <span class="number">0.75</span>) <span class="comment">// CORRUPT</span></span><br><span class="line">				&#123;</span><br><span class="line">          <span class="comment">// 创建一个新的packet对象</span></span><br><span class="line">					packet p = <span class="keyword">new</span> packet();</span><br><span class="line">					p.parseMessage(input);</span><br><span class="line">					p.corruptChecksum();</span><br><span class="line">					System.out.println(<span class="string">"Sender: Packet"</span> + splitedMsg[<span class="number">0</span>]  + <span class="string">", CORRUPT"</span>);</span><br><span class="line">          <span class="comment">//将生成的数据发送给另外一端</span></span><br><span class="line">					sendToOtherThread(p.generateMessage());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 有1/4 的几率会丢包，出现丢失时，不需要使用 sendToOtherThread,这里我没有用线程，因此我只能回传给Sender一个丢包信息，并等待sender重传</span></span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					System.out.println(<span class="string">"Sender: Packet"</span> + splitedMsg[<span class="number">0</span>] + <span class="string">", DROP"</span>);</span><br><span class="line">          streamOut.println(ACK2);</span><br><span class="line">        &#125;</span><br><span class="line">		   &#125;</span><br><span class="line">		   socket.close();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 给套接字输出流创建一个 PrintWriter，然后通过 println 将pMessage传给对应的套接字</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String pMessage)</span> </span>&#123;</span><br><span class="line">		PrintWriter streamOut = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			streamOut = <span class="keyword">new</span> PrintWriter(socket.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line">			streamOut.println(pMessage);	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 这个方法是将信息从一个进程发送到另一个进程的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendToOtherThread</span><span class="params">(String pMessage)</span> </span>&#123;</span><br><span class="line">      mt = (MessageThread)allMessages.get(<span class="number">1</span>-ID);</span><br><span class="line">      <span class="comment">// 通过上面定义的方法，将文件传送给另外一端</span></span><br><span class="line">      mt.send(pMessage);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="发送者"><a href="#发送者" class="headerlink" title="发送者"></a>发送者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Thread.sleep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">sender</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> String hostName;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> portNumber;</span><br><span class="line">	<span class="keyword">static</span> String fileName;</span><br><span class="line">	<span class="keyword">int</span> SeqNo;</span><br><span class="line">  <span class="comment">// 首先设置一些必要的信息，比如端口号，主机名，需要传送的文件</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        hostName = <span class="string">"localhost"</span>;</span><br><span class="line">        portNumber = <span class="number">5678</span>;</span><br><span class="line">        fileName = <span class="string">"/Users/jasonxu/IdeaProjects/rdt3.0/src/com/company/message.txt"</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 然后开启发送者</span></span><br><span class="line">			<span class="keyword">new</span> sender().startSender(hostName, portNumber, fileName);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"Something falied: "</span> + e.getMessage());</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startSender</span><span class="params">(String hostName, <span class="keyword">int</span> portNumber, String fileName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">		Socket socket = <span class="keyword">null</span>;</span><br><span class="line">		PrintWriter streamOut = <span class="keyword">null</span>;</span><br><span class="line">		BufferedReader streamIn = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建套接字</span></span><br><span class="line">			socket = <span class="keyword">new</span> Socket(hostName, portNumber);</span><br><span class="line">      <span class="comment">// 创建一个套接字的输出流</span></span><br><span class="line">			streamOut = <span class="keyword">new</span> PrintWriter(socket.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line">      <span class="comment">// 创建一个缓冲区，用来读取收到的信息</span></span><br><span class="line">			streamIn = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line"></span><br><span class="line">			String ACK;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 从文件读取信息流</span></span><br><span class="line">				FileInputStream fstream = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">        <span class="comment">// 将信息流转化成数据流</span></span><br><span class="line">				DataInputStream dataIn = <span class="keyword">new</span> DataInputStream(fstream);</span><br><span class="line">				BufferedReader buffReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(dataIn));</span><br><span class="line"></span><br><span class="line">				String input;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">int</span> totalSent = <span class="number">0</span>;</span><br><span class="line">				String message = <span class="string">""</span>;</span><br><span class="line">				<span class="comment">// 首先创建一个新的包</span></span><br><span class="line">				packet pak = <span class="keyword">new</span> packet();</span><br><span class="line">        <span class="comment">// 开始从 buffReader读取数据</span></span><br><span class="line">				<span class="keyword">while</span> ((input = buffReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//将信息按照空隙分开</span></span><br><span class="line">					String[] splited = input.split(<span class="string">"\\s+"</span>);</span><br><span class="line">					<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">          <span class="comment">// 对每一段文字，生成一个包，按顺序发送</span></span><br><span class="line">					<span class="keyword">while</span> (i &lt; splited.length) &#123;</span><br><span class="line">            <span class="comment">// 创建包</span></span><br><span class="line">						pak.createPacket(splited[i],<span class="keyword">this</span>.SeqNo);</span><br><span class="line">            <span class="comment">// 给包填充 data</span></span><br><span class="line">						message = pak.generateMessage();</span><br><span class="line">            <span class="comment">// 将数据推出去</span></span><br><span class="line">						streamOut.println(message);</span><br><span class="line">            <span class="comment">// 从输入缓冲区读取数据</span></span><br><span class="line">						ACK = streamIn.readLine();</span><br><span class="line">						</span><br><span class="line">						totalSent++;</span><br><span class="line">						<span class="comment">//如果ACK的数值与发送报文的序号一致，则i++,发送下一个报文</span></span><br><span class="line">						 <span class="keyword">if</span> (validateACK(ACK, pak.seqNo)) &#123;</span><br><span class="line">							i++;</span><br><span class="line">               <span class="comment">//序号0和1之间转换</span></span><br><span class="line">							<span class="keyword">this</span>.SeqNo = <span class="number">1</span>-<span class="keyword">this</span>.SeqNo;</span><br><span class="line">							System.out.println(<span class="string">"Waiting: "</span> + ACK + <span class="string">", totalsent: "</span> + totalSent + <span class="string">", "</span> + ACK + <span class="string">"Successfully sent"</span>);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 否则就说明丢失或者损坏，需要等待重传</span></span><br><span class="line">							 System.out.println(<span class="string">"Waiting: packet"</span>+ pak.seqNo + <span class="string">" CORRUPT OR LOST"</span> + <span class="string">", totalsent: "</span> + totalSent + <span class="string">", Waiting for resend"</span>);</span><br><span class="line">							 sleep(<span class="number">1000</span>);</span><br><span class="line">						 &#125;</span><br><span class="line">					&#125;</span><br><span class="line">					streamOut.println(-<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">        <span class="comment">//全部发送完成后，关闭输入流</span></span><br><span class="line">				dataIn.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				System.err.println(<span class="string">"Error: "</span> + e.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">			System.err.println(<span class="string">"Cannot find the host: "</span> + hostName);</span><br><span class="line">			System.exit(<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.err.println(<span class="string">"Couldn't read/write from the connection: "</span> + e.getMessage());</span><br><span class="line">			System.exit(<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">assert</span> streamOut != <span class="keyword">null</span>;</span><br><span class="line">			streamOut.close();</span><br><span class="line">			<span class="keyword">assert</span> streamIn != <span class="keyword">null</span>;</span><br><span class="line">			streamIn.close();</span><br><span class="line">			socket.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 这个方法帮助发送者判断ACK号是否和序列号相等</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateACK</span><span class="params">(String ACKfromNetwork, Integer seqNo)</span> </span>&#123;</span><br><span class="line">		String ACKN = <span class="string">"ACK"</span> + seqNo.toString();</span><br><span class="line">		<span class="keyword">return</span> ACKN.equals(ACKfromNetwork);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接收者"><a href="#接收者" class="headerlink" title="接收者"></a>接收者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company; </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">receiver</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> String hostName;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> portNumber;</span><br><span class="line"><span class="comment">// 首先给接收者确定一些基本信息： 主机名，端口</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        hostName = <span class="string">"localhost"</span>;</span><br><span class="line">        portNumber = <span class="number">5678</span>;</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 启动一个接收者</span></span><br><span class="line">			<span class="keyword">new</span> receiver().startReceiver(hostName, portNumber);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"Something falied: "</span> + e.getMessage());</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startReceiver</span><span class="params">(String hostName, <span class="keyword">int</span> portNumber)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> </span><br><span class="line">		Socket socket = <span class="keyword">null</span>;</span><br><span class="line">		PrintWriter streamOut = <span class="keyword">null</span>;</span><br><span class="line">		BufferedReader streamIn = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建套接字、套接字输入输出流</span></span><br><span class="line">			socket = <span class="keyword">new</span> Socket(hostName, portNumber);</span><br><span class="line">			streamOut = <span class="keyword">new</span> PrintWriter(socket.getOutputStream(), <span class="keyword">true</span>);</span><br><span class="line">			streamIn = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">					</span><br><span class="line">			String input, output;</span><br><span class="line">			<span class="keyword">int</span> totalReceived = <span class="number">0</span>;</span><br><span class="line">			StringBuilder msg = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">			System.out.println(<span class="string">"Waiting... connect sender"</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 创建一个新的包，用来返回ack信息</span></span><br><span class="line">			packet pak = <span class="keyword">new</span> packet();</span><br><span class="line">			<span class="keyword">while</span> ((input = streamIn.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">// 如果输入为-1，说明包已经发送完毕，同时跳出循环</span></span><br><span class="line">				<span class="keyword">if</span> (input.equals(<span class="string">"-1"</span>)) &#123;</span><br><span class="line">					streamOut.println(-<span class="number">1</span>);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 解析收到的包中的信息</span></span><br><span class="line">				pak.parseMessage(input);</span><br><span class="line">				totalReceived++;</span><br><span class="line">        <span class="comment">// 验证包是否正确</span></span><br><span class="line">				<span class="keyword">int</span> tempNumber = pak.validateMessage();</span><br><span class="line">				output = <span class="string">"Waiting seqNo: "</span> + pak.seqNo+ <span class="string">", validateMessage: ACK"</span> + tempNumber+ <span class="string">", totalReceived: "</span> + totalReceived + <span class="string">", input"</span> + input;</span><br><span class="line">        <span class="comment">// 如果ack序号和seqNo不相等，说明包错了，等待重传</span></span><br><span class="line">				<span class="keyword">if</span>(pak.validateMessage()!=tempNumber)</span><br><span class="line">					System.out.println(<span class="string">"Waiting seqNo: "</span> + pak.seqNo+ <span class="string">", validateMessage: ACK"</span> + tempNumber+<span class="string">", Packet"</span>+pak.seqNo+<span class="string">" Corrupt,Please Resend"</span>);</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//包正确，那么打印、输出</span></span><br><span class="line">					msg.append(pak.content).append(<span class="string">" "</span>);</span><br><span class="line">					System.out.println(output);</span><br><span class="line">				&#125;</span><br><span class="line">        <span class="comment">// 返回ACK序号</span></span><br><span class="line">				streamOut.println(<span class="string">"ACK"</span>+pak.validateMessage());</span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">// 打印所有信息</span></span><br><span class="line">			System.out.println(<span class="string">"Total Message: "</span> + msg);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">			System.err.println(<span class="string">"Cannot find the host: "</span> + hostName);</span><br><span class="line">			System.exit(<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			System.err.println(<span class="string">"Couldn't read/write from the connection: "</span> + e.getMessage());</span><br><span class="line">			System.exit(<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			streamOut.close();</span><br><span class="line">			streamIn.close();</span><br><span class="line">			socket.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h2><h3 id="network"><a href="#network" class="headerlink" title="network"></a>network</h3><p><img src="/2021/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A-rdt3-0/1.png" style="zoom:67%;"></p>
<p>这是运输通道的打印信息，我们看到，第一个packet0是顺利通过的，第二个packet1的第一次发送出现了包错误，因此返回了一个ACK0, 重发后通过。第三个包出现了两次丢包和两次出错，最后通过。</p>
<h3 id="receiver"><a href="#receiver" class="headerlink" title="receiver"></a>receiver</h3><p><img src="/2021/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A-rdt3-0/2.png" style="zoom:67%;"></p>
<p>这是接收者的打印信息，我们看到出现丢包的话，接收者是收不到的，但是如果出现包错误，那么接收者会返回一个不同的ACK序号通知发送者重发</p>
<h3 id="sender"><a href="#sender" class="headerlink" title="sender"></a>sender</h3><p><img src="/2021/05/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A-rdt3-0/3.png" style="zoom:67%;"></p>
<p>这是发送者的打印信息，如果出现丢包或者包错误，会等待后重新发送，同时记录发送包的次数</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/05/21/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0%E5%A4%A7%E7%BA%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/21/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0%E5%A4%A7%E7%BA%B2/" class="post-title-link" itemprop="url">数据科学数学基础复习大纲</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-05-21 08:15:10 / Modified: 08:39:42" itemprop="dateCreated datePublished" datetime="2021-05-21T08:15:10+08:00">2021-05-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据科学数学基础复习大纲"><a href="#数据科学数学基础复习大纲" class="headerlink" title="数据科学数学基础复习大纲"></a>数据科学数学基础复习大纲</h1><p><img src="/2021/05/21/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0%E5%A4%A7%E7%BA%B2/1.png" style="zoom:80%;"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/05/19/os-project3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/19/os-project3/" class="post-title-link" itemprop="url">os-project3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-19 13:15:15" itemprop="dateCreated datePublished" datetime="2021-05-19T13:15:15+08:00">2021-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-06-08 23:15:26" itemprop="dateModified" datetime="2021-06-08T23:15:26+08:00">2021-06-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="I-O-subsystem"><a href="#I-O-subsystem" class="headerlink" title="I/O subsystem"></a>I/O subsystem</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ol>
<li><p>熟悉类UNIX系统的I/O设备管理</p>
</li>
<li><p>熟悉MINIX块设备驱动</p>
</li>
<li><p>熟悉MINIX RAM盘</p>
</li>
</ol>
<h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><ul>
<li><p>在MINIX3中安装一块X MB大小的RAM盘（minix中已有6块用户可用RAM盘，7块系统保留RAM盘），可以挂载并且存取文件操作。</p>
</li>
<li><p>测试RAM盘和DISK盘的文件读写速度，分析其读写速度差异原因（可用图表形式体现在实验报告中）。</p>
</li>
</ul>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="增加RAM盘："><a href="#增加RAM盘：" class="headerlink" title="增加RAM盘："></a>增加RAM盘：</h3><ul>
<li>修改<code>/usr/src/minix/drivers/storage/memory/memory.c</code>，增加默认的用户RAM盘数：<code>RAMDISKS=7</code>。</li>
</ul>
<p><img src="/2021/05/19/os-project3/2.png"></p>
<ul>
<li>重新编译内核，重启reboot。</li>
<li>创建设备<code>mknod /dev/myram b 1 13</code>，查看设备是否创建成功输入<code>ls /dev/ | grep ram</code>。</li>
</ul>
<p><img src="/2021/05/19/os-project3/3.png"></p>
<ul>
<li><p>实现<code>buildmyram</code>初始化工具（用于分配容量）。</p>
<ul>
<li>参考<code>/usr/src/minix/commands/ramdisk/ramdisk.c</code>，实现<code>buildmyram.c</code>，但是需要将KB单位修改成MB。</li>
<li><code>ramdisk.c</code> 代码如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;minix/paths.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioc_memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">signed</span> <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line">	<span class="keyword">char</span> *d;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(argc &lt; <span class="number">2</span> || argc &gt; <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;size in kB&gt; [device]\n"</span>,</span><br><span class="line">			argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	d = argc == <span class="number">2</span> ? _PATH_RAMDISK : argv[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">if</span>((fd=<span class="built_in">open</span>(d, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(d);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KFACTOR 1024</span></span><br><span class="line">	<span class="built_in">size</span> = atol(argv[<span class="number">1</span>])*KFACTOR;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">size</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"size should be non-negative.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(ioctl(fd, MIOCRAMSIZE, &amp;<span class="built_in">size</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">"MIOCRAMSIZE"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"size on %s set to %ldkB\n"</span>, d, <span class="built_in">size</span>/KFACTOR);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译<code>buildmyram.c</code>文件，然后执行命令： <code>./buildmyram &lt;size in MB&gt; /dev/myram</code>。创建一个RAM盘。</li>
</ul>
</li>
</ul>
<p>我们将KB变成MB ，可以这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;minix/paths.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioc_memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">char</span> *d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span> || argc &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s &lt;size in MB&gt; [device]\n"</span>,</span><br><span class="line">            argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    d = argc == <span class="number">2</span> ? _PATH_RAMDISK : argv[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>((fd=<span class="built_in">open</span>(d, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(d);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 需要把宏从1024改为1024*1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MFACTOR 1048576</span></span><br><span class="line">    <span class="built_in">size</span> = atol(argv[<span class="number">1</span>])*MFACTOR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">size</span> &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"size should be non-negative.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ioctl(fd, MIOCRAMSIZE, &amp;<span class="built_in">size</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"MIOCRAMSIZE"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"size on %s set to %ldMB\n"</span>, d, <span class="built_in">size</span>/MFACTOR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/05/19/os-project3/4.png"></p>
<ul>
<li><p>在ram盘上创建内存文件系统，<code>mkfs.mfs /dev/myram</code>。</p>
</li>
<li><p>将ram盘挂载到用户目录下，<code>mount /dev/myram /root/myram</code>,(首先必须先<code>mkdir myram</code>)查看是否挂在成功：输入df，结果如下：</p>
</li>
</ul>
<p><img src="/2021/05/19/os-project3/5.png">其中,GB、MB、512-block 转换方式如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>GB</th>
<th>MB</th>
<th>512-blocks</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1024</td>
<td>2097152</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>注：重启后用户自定义的ram盘内容会丢失，需要重新设置大小，创建文件系统，并挂载。</li>
</ul>
<p><img src="/2021/05/19/os-project3/6.png"></p>
<p>重启后，我们会发现刚刚创建的ram盘就丢失了，我们就需要重复下面三条命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;buildmyram 700 &#x2F;dev&#x2F;myram 	&#x2F;&#x2F; 因为吞吐量不会大于700MB&#x2F;s 这里就把Ram盘设置为700mb</span><br><span class="line">mkfs.mfs &#x2F;dev&#x2F;myram</span><br><span class="line">mount &#x2F;dev&#x2F;myram &#x2F;root&#x2F;myram</span><br></pre></td></tr></table></figure>
<h2 id="性能测试："><a href="#性能测试：" class="headerlink" title="性能测试："></a>性能测试：</h2><p>RAM盘和Disk盘的性能测试中，需要采用多进程并发的同步读写，并发数要增加到设备接近“饱和”状态（吞吐量难以继续提升，但是I/O延时恶化）。在出现饱和前，总吞吐量随着并发数线性增长。</p>
<p>性能测试的二个变量为<strong>块大小</strong>（推荐64B/256B/1KB/4KB/16KB/64KB）和<strong>块扫描方式</strong>（顺序/随机）。可以画<strong>四张曲线图</strong>对比RAM盘和Disk盘性能（随机读，随机写，顺序读，顺序写）。实验结果预计为RAM盘性能高于DISK盘，特别是随机读写性能。<strong>对比在不同的blocksize下的性能</strong>，然后通过Excel把数据制作成图表。</p>
<h3 id="编写测试文件"><a href="#编写测试文件" class="headerlink" title="编写测试文件"></a>编写测试文件</h3><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>使用posix函数open打开文件，利用O_SYNC参数使得write/read操作为同步模式。</li>
<li>一定要检查write/read函数的返回值，以及写入的字节数目，确定是否成功。</li>
<li>为了简化实验，可以<strong>为每个进程分配一个独立的文件</strong>。为了减小主机操作系统的缓存机制造成的误差，文件总大小越大越好（例如300MB）。</li>
<li>随机读写时，可以采用<code>lseek()</code>重新定位文件指针；顺序读写时，默认文件指针自动移动，当读到文件末尾时，可以用<code>lseek()</code>返回文件头。</li>
<li>每组的读写需要反复持续一段时间，过短的时间会造成误差较大。</li>
<li>通常情况下，7~15个进程达到饱和，吞吐量不会高于700MB/s (ram盘顺序读写)。</li>
<li>如果minix虚拟机建在SSD下，会导致随机和顺序的差距减小，所以最好把虚拟机放在机械硬盘上，实验效果更明显。</li>
</ul>
<p>首先， usr文件夹是硬盘, 而myram 文件夹是内存。我们需要将一个尽可能大的文件放到这两个文件夹中去。</p>
<h4 id="写方法"><a href="#写方法" class="headerlink" title="写方法"></a>写方法</h4><p>写文件:打开文件，判断返回值，如果正常打开文件就判断是否随机写，进行写操作</p>
<p>这里要说一下打开文件的方式，<code>O_CREAT,O_RDWR,O_SYNC</code> 以及权限编码：</p>
<p><code>O_RDWR</code> 即以<strong>可读写</strong>的方式打开文件</p>
<p><code>O_SYNC</code>以同步的方式打开文件，利用<code>O_SYNC</code>参数使得<code>write/read</code>操作为同步模式</p>
<p><code>O_CREAT</code>若想要打开的文件不存在则自动建立该文件</p>
<p>后面四位数字分别代表 <strong>全部用户(all), 文件用户(user),同组用户(group),其他用户(other)</strong> 的权限</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>十进制</th>
<th>二进制</th>
<th>代表</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>000</td>
<td>无</td>
</tr>
<tr>
<td>1</td>
<td>001</td>
<td>—x(只可执行)</td>
</tr>
<tr>
<td>2</td>
<td>010</td>
<td>-w-(只可写)</td>
</tr>
<tr>
<td>3</td>
<td>011</td>
<td>-wx(可写可执行)</td>
</tr>
<tr>
<td>4</td>
<td>100</td>
<td>r—(只可读)</td>
</tr>
<tr>
<td>5</td>
<td>101</td>
<td>r-x(可读可执行)</td>
</tr>
<tr>
<td>6</td>
<td>110</td>
<td>rw-(可读可写)</td>
</tr>
<tr>
<td>7</td>
<td>111</td>
<td>rwx(可读可写可执行)</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向缓存中写入大小为blocksize的数字</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_to_buf</span><span class="params">(<span class="keyword">char</span>* buf, <span class="keyword">int</span> blocksize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; blocksize; i++)</span><br><span class="line">        buf[i] = rand() % <span class="number">94</span> + <span class="number">33</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_file</span><span class="params">(<span class="keyword">int</span> blocksize, <span class="keyword">bool</span> isrand, <span class="keyword">char</span> *filepath, <span class="keyword">int</span> fs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> total_block = fs / blocksize; <span class="comment">// 需要写入的总block数</span></span><br><span class="line">    <span class="keyword">char</span>* buf = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * blocksize); <span class="comment">// 缓存字符串，大小为一个block </span></span><br><span class="line">  	<span class="comment">//往缓存中写入数据</span></span><br><span class="line">    write_to_buf(buf, blocksize);</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">// 只写、同步打开文件,并处理错误</span></span><br><span class="line">    <span class="keyword">if</span> ((fd = <span class="built_in">open</span>(filepath, O_WRONLY|O_SYNC)) &lt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Open Error!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; total_block; i++)</span><br><span class="line">    &#123;</span><br><span class="line">  <span class="comment">//write()会把缓存中的数据写到文件当中去. 当然, 文件读写位置也会随之移动.</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">write</span>(fd, buf, blocksize) == <span class="number">-1</span>) <span class="comment">// 写入缓存 </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Write Error!\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isrand) <span class="comment">// 如果随机写，每次写入随机编号的block </span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">//lseek可以将读写未知移到任意未知</span></span><br><span class="line">            <span class="keyword">if</span> (lseek(fd, rand() % total_block * blocksize, SEEK_SET) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Lseek Error!\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">close</span>(fd) != <span class="number">0</span>) <span class="comment">//关闭文件 并处理错误</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Close Error!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="读方法"><a href="#读方法" class="headerlink" title="读方法"></a>读方法</h4><p>读方法和写方法的结构是一样的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_file</span><span class="params">(<span class="keyword">int</span> blocksize, <span class="keyword">bool</span> isrand, <span class="keyword">char</span> *filepath, <span class="keyword">int</span> fs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> total_block = fs / blocksize; <span class="comment">// 需要读取的总block数 </span></span><br><span class="line">    <span class="keyword">char</span>* buf = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * blocksize); <span class="comment">// 缓存字符串，大小为一个block</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = <span class="built_in">open</span>(filepath, O_CREAT | O_RDWR | O_SYNC, <span class="number">0755</span>)) &lt; <span class="number">0</span>) <span class="comment">// 只读、同步打开文件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Open Error!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; total_block ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((code = <span class="built_in">read</span>(fd, buf, blocksize)) == <span class="number">-1</span>) <span class="comment">// 将文件中的信息读取至缓存</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Read Error!\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isrand) <span class="comment">// 如果随机读，就随机跳到某个地方开始读</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (lseek(fd, rand() % total_block * blocksize, SEEK_SET) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Lseek Error!\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (code == <span class="number">0</span>) <span class="comment">// 如果顺序读，并且已经读到队尾，那么就移到文件开头继续读</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (lseek(fd, <span class="number">0</span>, SEEK_SET) == <span class="number">-1</span>)<span class="comment">//移动到文件开头</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Lseek to Head Error!\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">close</span>(fd) != <span class="number">0</span>) <span class="comment">/* 关闭文件 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Close Error!\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h4><p>主函数：首先创建和命名文件，通过循环执行<code>read_file</code>和<code>write_file</code>函数测试读写差异。测试<code>blocksize</code>和<code>concurrency</code>对测试读写速度的影响，最后输出结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先写两个 utils， 第一个函数是获取当前的时间</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get_current_time</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    struct timeval tv;</span><br><span class="line">    gettimeofday(&amp;tv, NULL);</span><br><span class="line">    <span class="keyword">return</span> tv.tv_sec * <span class="number">1000</span> + tv.tv_usec / <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二个是获取运行时间</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get_run_time</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> starttime, <span class="keyword">long</span> <span class="keyword">long</span> endtime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> endtime - starttime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> io_list</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">write</span>, <span class="built_in">read</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> order_list</span><br><span class="line">    &#123;</span><br><span class="line">        sequential = <span class="literal">false</span>,  <span class="built_in">random</span> = <span class="literal">true</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> starttime, endtime, usetime;</span><br><span class="line">    <span class="keyword">char</span> filepath[MaxFileName];</span><br><span class="line">  <span class="comment">// 定义块数组，从 64到66536</span></span><br><span class="line">    <span class="keyword">int</span> blocksizelist[] = &#123;<span class="number">64</span>, <span class="number">256</span>,<span class="number">1024</span>, <span class="number">4096</span> ,<span class="number">16384</span>, <span class="number">66536</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> blocksize;</span><br><span class="line">    <span class="keyword">int</span> filesizeMB;</span><br><span class="line">    <span class="keyword">long</span> filesize = <span class="number">100</span> * MFACTOR; <span class="comment">// 1024*1024</span></span><br><span class="line">    <span class="keyword">int</span> concurrency = <span class="number">5</span>;					<span class="comment">// 并发5</span></span><br><span class="line">    <span class="keyword">bool</span> deletefile = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> RedoTime = <span class="number">3</span>;							<span class="comment">//重复次数为3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> io;</span><br><span class="line">    <span class="keyword">bool</span> order;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">4</span>) </span><br><span class="line">        help_and_quit();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(argv[<span class="number">1</span>], <span class="string">"-w"</span>, <span class="number">2</span>)) </span><br><span class="line">            io = <span class="built_in">write</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(argv[<span class="number">1</span>], <span class="string">"-r"</span>, <span class="number">2</span>))</span><br><span class="line">            io = <span class="built_in">read</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            help_and_quit();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(argv[<span class="number">2</span>], <span class="string">"-0"</span>, <span class="number">2</span>)) </span><br><span class="line">            order = sequential;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(argv[<span class="number">2</span>], <span class="string">"-1"</span>, <span class="number">2</span>))</span><br><span class="line">            order = <span class="built_in">random</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            help_and_quit();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((filesizeMB = atoi(argv[<span class="number">3</span>])) &gt;= <span class="number">1</span> &amp;&amp; filesizeMB &lt;= <span class="number">200</span>) </span><br><span class="line">            filesize = filesizeMB * MFACTOR;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            help_and_quit();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;= <span class="number">6</span>; k+=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        blocksize = blocksizelist[k];</span><br><span class="line">        starttime = get_current_time();</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; concurrency; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">sprintf</span>(filepath, <span class="string">"./file%d.txt"</span>, i);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((fd = creat(filepath, <span class="number">777</span>)) == <span class="number">-1</span>) <span class="comment">/* 创建文件后关闭 */</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"Create Error!\n"</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">close</span>(fd) != <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"Close Error!\n"</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (io == <span class="built_in">read</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    write_file(blocksize, order, filepath, filesize/concurrency);</span><br><span class="line">                    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; RedoTime - <span class="number">1</span>; j++)</span><br><span class="line">                        read_file(blocksize, order, filepath, filesize/concurrency);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; RedoTime - <span class="number">1</span>; j++)</span><br><span class="line">                        write_file(blocksize, order, filepath, filesize/concurrency);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (deletefile &amp;&amp; (<span class="built_in">remove</span>(filepath) != <span class="number">0</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"Remove Error!\n"</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// printf("Parent process running\n");</span></span><br><span class="line">        <span class="keyword">while</span> (waitpid(pid, <span class="literal">NULL</span>, <span class="number">0</span>) != <span class="number">-1</span>)&#123;&#125;</span><br><span class="line">        <span class="comment">// printf("All child processes finished\n");</span></span><br><span class="line"></span><br><span class="line">        endtime = get_current_time();</span><br><span class="line">        usetime = get_run_time(starttime, endtime);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"File size: %ld MB.\n"</span>, filesize / MFACTOR);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Blocksize: %d.\n"</span>, blocksize);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Redo times: %d.\n"</span>, RedoTime);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Execution time: %lld msec(s).\n"</span>, usetime);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Throughput: %f MB/S\n\n"</span>, ((<span class="keyword">double</span>)filesize / MFACTOR) * RedoTime / ((<span class="keyword">double</span>)usetime / <span class="number">1024</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>分块大小</th>
<th>ram</th>
<th>disk</th>
</tr>
</thead>
<tbody>
<tr>
<td>64</td>
<td>12.387097</td>
<td>10.858385</td>
</tr>
<tr>
<td>256</td>
<td>47.872838</td>
<td>27.863946</td>
</tr>
<tr>
<td>1024</td>
<td>157.538462</td>
<td>91.237491</td>
</tr>
<tr>
<td>4096</td>
<td>380.19802</td>
<td>180.705582</td>
</tr>
<tr>
<td>16384</td>
<td>550.044763</td>
<td>236.307692</td>
</tr>
<tr>
<td>66536</td>
<td>646.736842</td>
<td>257.826269</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>分块大小</td>
<td>ram</td>
<td>disk</td>
</tr>
<tr>
<td>64</td>
<td>17.886463</td>
<td>8.031373</td>
</tr>
<tr>
<td>256</td>
<td>71.300917</td>
<td>47.690775</td>
</tr>
<tr>
<td>1024</td>
<td>228.997391</td>
<td>110.048361</td>
</tr>
<tr>
<td>4096</td>
<td>519.357566</td>
<td>169.185606</td>
</tr>
<tr>
<td>16384</td>
<td>722.823529</td>
<td>195.047619</td>
</tr>
<tr>
<td>66536</td>
<td>783.673469</td>
<td>201.442623</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>分块大小</td>
<td>ram</td>
<td>disk</td>
</tr>
<tr>
<td>64</td>
<td>4.561823</td>
<td>5.918561</td>
</tr>
<tr>
<td>256</td>
<td>20.2999336</td>
<td>11.837121</td>
</tr>
<tr>
<td>1024</td>
<td>71.168771</td>
<td>23.674242</td>
</tr>
<tr>
<td>4096</td>
<td>297.24238</td>
<td>47.348485</td>
</tr>
<tr>
<td>16384</td>
<td>550.537634</td>
<td>94.69697</td>
</tr>
<tr>
<td>66536</td>
<td>695.022624</td>
<td>189.393939</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>分块大小</td>
<td>ram</td>
<td>disk</td>
</tr>
<tr>
<td>64</td>
<td>5.809929</td>
<td>0.610483</td>
</tr>
<tr>
<td>256</td>
<td>24.924949</td>
<td>2.032418</td>
</tr>
<tr>
<td>1024</td>
<td>96</td>
<td>8.908608</td>
</tr>
<tr>
<td>4096</td>
<td>372.353636</td>
<td>55.941</td>
</tr>
<tr>
<td>16384</td>
<td>625.025432</td>
<td>139.098936</td>
</tr>
<tr>
<td>66536</td>
<td>722.823529</td>
<td>219.428571</td>
</tr>
</tbody>
</table>
</div>
<p>结果如下图所示：</p>
<p><img src="/2021/05/19/os-project3/7.png"></p>
<p><img src="/2021/05/19/os-project3/8.png"></p>
<p><img src="/2021/05/19/os-project3/9.png"></p>
<p><img src="/2021/05/19/os-project3/10.png"></p>
<p>将随机</p>
<p><img src="/2021/05/19/os-project3/11.png"></p>
<p><img src="/2021/05/19/os-project3/12.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/" class="post-title-link" itemprop="url">操作系统-死锁</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-17 13:22:29" itemprop="dateCreated datePublished" datetime="2021-05-17T13:22:29+08:00">2021-05-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-24 01:05:34" itemprop="dateModified" datetime="2022-06-24T01:05:34+08:00">2022-06-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>思维导图：</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/1.png" style="zoom:80%;"></p>
<p>计算机系统中有很多<code>独占性</code>的资源，在同一时刻只能每个资源只能由一个进程使用，我们之前经常提到过打印机，这就是一个独占性的资源，<strong>同一时刻不能有两个打印机同时输出结果，否则会引起文件系统的瘫痪</strong>。所以，操作系统具有授权一个进程单独访问资源的能力。</p>
<p>两个进程独占性的访问某个资源，从而等待另外一个资源的执行结果，会导致两个进程都被阻塞，并且两个进程都不会释放各自的资源，这种情况就是 <code>死锁(deadlock)</code>。</p>
<p>死锁可以发生在任何层面，在不同的机器之间可能会发生死锁，在数据库系统中也会导致死锁，比如进程 A 对记录 R1 加锁，进程 B 对记录 R2 加锁，然后进程 A 和 B 都试图把对象的记录加锁，这种情况下就会产生死锁。</p>
<p>下面我们就来讨论一下什么是死锁、死锁的条件是什么、死锁如何预防、活锁是什么等。</p>
<p>首先你需要先了解一个概念，那就是资源是什么</p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>大部分的死锁都和资源有关，在进程对设备、文件具有独占性（排他性）时会产生死锁。我们把这类需要排他性使用的对象称为<code>资源(resource)</code>。资源主要分为 <strong>可抢占资源和不可抢占资源</strong></p>
<h3 id="可抢占资源和不可抢占资源"><a href="#可抢占资源和不可抢占资源" class="headerlink" title="可抢占资源和不可抢占资源"></a>可抢占资源和不可抢占资源</h3><p>资源主要有可抢占资源和不可抢占资源。<code>可抢占资源(preemptable resource)</code> 可以从拥有它的进程中抢占而不会造成其他影响，内存就是一种可抢占性资源，任何进程都能够抢先获得内存的使用权。</p>
<p><code>不可抢占资源(nonpreemtable resource)</code> 指的是除非引起错误或者异常，否则进程无法抢占指定资源，这种不可抢占的资源比如有光盘，在进程执行调度的过程中，其他进程是不能得到该资源的。</p>
<p>死锁与不可抢占资源有关，虽然抢占式资源也会造成死锁，不过这种情况的解决办法通常是在进程之间重新分配资源来化解。所以，我们的重点自然就会放在了不可抢占资源上。</p>
<p>下面给出了使用资源所需事件的抽象顺序</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/2.png" style="zoom:80%;"></p>
<p>如果在请求时资源不存在，请求进程就会强制等待。在某些操作系统中，当请求资源失败时进程会自动阻塞，当自资源可以获取时进程会自动唤醒。在另外一些操作系统中，请求资源失败并显示错误代码，然后等待进程等待一会儿再继续重试。</p>
<p>请求资源失败的进程会陷入一种<strong>请求资源、休眠、再请求资源</strong>的循环中。此类进程虽然没有阻塞，但是处于从目的和结果考虑，这类进程和阻塞差不多，因为这类进程并没有做任何有用的工作。</p>
<p>请求资源的这个过程是很依赖操作系统的。在一些系统中，一个 <code>request</code> 系统调用用来允许进程访问资源。在一些系统中，操作系统对资源的认知是它是一种特殊文件，在任何同一时刻只能被一个进程打开和占用。资源通过 <code>open</code> 命令进行打开。如果文件已经正在使用，那么这个调用者会阻塞直到当前的占用文件的进程关闭文件为止。</p>
<h3 id="资源获取"><a href="#资源获取" class="headerlink" title="资源获取"></a>资源获取</h3><p>对于一些数据库系统中的记录这类资源来说，应该由用户进程来对其进行管理。有一种管理方式是使用<code>信号量(semaphore)</code> 。这些信号量会初始化为 1 。互斥锁也能够起到相同的作用。</p>
<blockquote>
<p>这里说一下什么是<code>互斥锁(Mutexes)</code>:</p>
<p>在计算机程序中，<code>互斥对象(mutex)</code> 是一个程序对象，它允许多个程序共享同一资源，例如文件访问权限，但并不是同时访问。需要锁定资源的线程都必须在使用资源时将互斥锁与其他线程绑定（进行加锁）。当不再需要数据或线程结束时，互斥锁设置为解锁。</p>
</blockquote>
<p>下面是一个伪代码，这部分代码说明了信号量的资源获取、资源释放等操作，如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore aResource;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processA</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  down(&amp;aResource);</span><br><span class="line">	useResource();</span><br><span class="line">  up(&amp;aResource);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面显示了一个进程资源获取和释放的过程，但是一般情况下会存在多个资源同时获取锁的情景，这样该如何处理？如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore aResource;</span><br><span class="line">semaphore bResource;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processA</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  down(&amp;aResource);</span><br><span class="line">  down(&amp;bResource);</span><br><span class="line">	useAResource();</span><br><span class="line">  useBResource();</span><br><span class="line">  up(&amp;aResource);</span><br><span class="line">  up(&amp;bResource);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于单个进程来说，并不需要加锁，因为不存在和这个进程的竞争条件。所以单进条件下程序能够完好运行。</p>
<p>现在让我们考虑两个进程的情况，A 和 B ，还存在两个资源。如下所示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore aResource;</span><br><span class="line">semaphore bResource;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processA</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  down(&amp;aResource);</span><br><span class="line">  down(&amp;bResource);</span><br><span class="line">	useBothResource();</span><br><span class="line">  up(&amp;bResource);</span><br><span class="line">  up(&amp;aResource);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processB</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  down(&amp;aResource);</span><br><span class="line">  down(&amp;bResource);</span><br><span class="line">	useBothResource();</span><br><span class="line">  up(&amp;bResource);</span><br><span class="line">  up(&amp;aResource);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，两个进程以相同的顺序访问资源。一个进程在另一个进程之前获取资源，如果另外一个进程想在第一个进程释放之前获取资源，那么它会由于资源的加锁而阻塞，直到该资源可用为止。</p>
<p>在下面这段代码中，有一些变化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore aResource;</span><br><span class="line">semaphore bResource;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processA</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  down(&amp;aResource);</span><br><span class="line">  down(&amp;bResource);</span><br><span class="line">	useBothResource();</span><br><span class="line">  up(&amp;bResource);</span><br><span class="line">  up(&amp;aResource);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processB</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  down(&amp;bResource); <span class="comment">// 变化的代码 交换了A和B的位置</span></span><br><span class="line">  down(&amp;aResource); <span class="comment">// 变化的代码</span></span><br><span class="line">	useBothResource();</span><br><span class="line">  up(&amp;aResource); <span class="comment">// 变化的代码 </span></span><br><span class="line">  up(&amp;bResource); <span class="comment">// 变化的代码 </span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种情况就不同了，可能会发生同时获取两个资源并有效地阻塞另一个过程，直到完成为止。也就是说，可能会发生进程 A 获取资源 A 的同时进程 B 获取资源 B 的情况。然后每个进程在尝试获取另一个资源时被阻塞。</p>
<p>在这里我们会发现一个简单的获取资源顺序的问题就会造成<code>死锁</code>，所以死锁是很容易发生的，所以下面我们就对死锁做一个详细的认识和介绍。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>如果要对死锁进行一个定义的话，下面的定义比较贴切</p>
<p><strong>如果一组进程中的每个进程都在等待一个事件，而这个事件只能由该组中的另一个进程触发，这种情况会导致死锁</strong>。</p>
<p>简单一点来表述一下，就是每个进程都在等待其他进程释放资源，而其他资源也在等待每个进程释放资源，这样没有进程抢先释放自己的资源，这种情况会产生死锁，所有进程都会无限的等待下去。</p>
<p>换句话说，死锁进程结合中的每个进程都在等待另一个死锁进程已经占有的资源。但是由于所有进程都不能运行，它们之中任何一个资源都无法释放资源，所以没有一个进程可以被唤醒。这种死锁也被称为<code>资源死锁(resource deadlock)</code>。资源死锁是最常见的类型，但不是所有的类型，我们后面会介绍其他类型，我们先来介绍资源死锁</p>
<h3 id="资源死锁的条件"><a href="#资源死锁的条件" class="headerlink" title="资源死锁的条件"></a>资源死锁的条件</h3><p>针对我们上面的描述，资源死锁可能出现的情况主要有</p>
<ul>
<li>互斥条件：每个资源都被分配给了一个进程或者资源是可用的</li>
<li>保持和等待条件：已经获取资源的进程被认为能够获取新的资源</li>
<li>不可抢占条件：分配给一个进程的资源不能强制的从其他进程抢占资源，它只能由占有它的进程显示释放</li>
<li>循环等待：死锁发生时，系统中一定有两个或者两个以上的进程组成一个循环，循环中的每个进程都在等待下一个进程释放的资源。</li>
</ul>
<p>发生死锁时，上面的情况必须同时会发生。如果其中任意一个条件不成立，死锁就不会发生。可以通过破坏其中任意一个条件来破坏死锁，下面这些破坏条件就是我们探讨的重点</p>
<h3 id="死锁模型"><a href="#死锁模型" class="headerlink" title="死锁模型"></a>死锁模型</h3><p>Holt 在 1972 年提出对死锁进行建模，建模的标准如下：</p>
<ul>
<li>圆形表示进程</li>
<li>方形表示资源</li>
</ul>
<p>从资源节点到进程节点表示资源已经被进程占用，如下图所示</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/3.png" style="zoom:80%;"></p>
<p>在上图中表示当前资源 R 正在被 A 进程所占用</p>
<p>由进程节点到资源节点的有向图表示当前进程正在请求资源，并且该进程已经被阻塞，处于等待这个资源的状态</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/4.png" style="zoom:80%;"></p>
<p>在上图中，表示的含义是进程 B 正在请求资源 S 。Holt 认为，死锁的描述应该如下</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/5.png" style="zoom:80%;"></p>
<p>这是一个死锁的过程，进程 C 等待资源 T 的释放，资源 T 却已经被进程 D 占用，进程 D 等待请求占用资源 U ，资源 U 却已经被线程 C 占用，从而形成环。</p>
<p>总结一点：<strong>吃着碗里的看着锅里的容易死锁</strong></p>
<p>那么如何避免死锁呢？我们还是通过死锁模型来聊一聊</p>
<p>假设有三个进程 (A、B、C) 和三个资源(R、S、T) 。三个进程对资源的请求和释放序列如下图所示</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/6.png" style="zoom:80%;"></p>
<p>操作系统可以任意选择一个非阻塞的程序运行，所以它可以决定运行 A 直到 A 完成工作；它可以运行 B 直到 B 完成工作；最后运行 C。</p>
<p>这样的顺序不会导致死锁（因为不存在对资源的竞争），但是这种情况也完全没有<code>并行性</code>。进程除了在请求和释放资源外，还要做计算和输入/输出的工作。当进程按照顺序运行时，在等待一个 I/O 时，另一个进程不能使用 CPU。所以，严格按照串行的顺序执行并不是最优越的。另一方面，如果没有进程在执行任何 I/O 操作，那么最短路径优先作业会优于轮转调度，所以在这种情况下串行可能是最优越的</p>
<p>现在我们假设进程会执行计算和 I/O 操作，所以轮询调度是一种合理的<code>调度算法</code>。资源请求可能会按照下面这个顺序进行</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/7.png" style="zoom:80%;"></p>
<p>下图是针对上面这六个步骤的资源分配图。</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/8.png" style="zoom:80%;"></p>
<blockquote>
<p>这里需要注意一个问题，为什么从资源出来的有向图指向了进程却表示<strong>进程请求资源</strong>呢？笔者刚开始看也有这个疑问，但是想了一下这个意思解释为进程占用资源比较合适，而进程的有向图指向资源表示进程被阻塞的意思。</p>
</blockquote>
<p>在上面的第四个步骤，进程 A 正在等待资源 S；第五个步骤中，进程 B 在等待资源 T；第六个步骤中，进程 C 在等待资源 R，因此<strong>产生了环路</strong>并导致了死锁。</p>
<p>然而，操作系统并没有规定一定按照某种特定的顺序来执行这些进程。遇到一个可能会引起死锁的线程后，操作系统可以干脆不批准请求，并把进程挂起一直到安全状态为止。比如上图中，如果操作系统认为有死锁的可能，它可以选择不把资源 S 分配给 B ，这样 B 被挂起。这样的话操作系统会只运行 A 和 C，那么资源的请求和释放就会是下面的步骤</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/9.png" style="zoom:80%;"></p>
<p>下图是针对上面这六个步骤的资源分配图。</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/10.png" style="zoom:80%;"></p>
<p>在第六步执行完成后，可以发现并没有产生死锁，此时就可以把资源 S 分配给 B，因为 A 进程已经执行完毕，C 进程已经拿到了它想要的资源。进程 B 可以直接获得资源 S，也可以等待进程 C 释放资源 T 。</p>
<p>有四种处理死锁的策略：</p>
<ul>
<li>忽略死锁带来的影响（惊呆了）</li>
<li>检测死锁并恢复死锁，死锁发生时对其进行检测，一旦发生死锁后，采取行动解决问题</li>
<li>通过仔细分配资源来避免死锁</li>
<li>通过破坏死锁产生的四个条件之一来避免死锁</li>
</ul>
<p>下面我们分别介绍一下这四种方法</p>
<h2 id="鸵鸟算法"><a href="#鸵鸟算法" class="headerlink" title="鸵鸟算法"></a>鸵鸟算法</h2><p>最简单的解决办法就是使用<code>鸵鸟算法(ostrich algorithm)</code>，把头埋在沙子里，假装问题根本没有发生。每个人看待这个问题的反应都不同。数学家认为死锁是不可接受的，必须通过有效的策略来防止死锁的产生。工程师想要知道问题发生的频次，系统因为其他原因崩溃的次数和死锁带来的严重后果。如果死锁发生的频次很低，而经常会由于硬件故障、编译器错误等其他操作系统问题导致系统崩溃，那么大多数工程师不会修复死锁。</p>
<h2 id="死锁检测和恢复"><a href="#死锁检测和恢复" class="headerlink" title="死锁检测和恢复"></a>死锁检测和恢复</h2><p>第二种技术是死锁的检测和恢复。这种解决方式不会尝试去阻止死锁的出现。相反，这种解决方案会希望死锁尽可能的出现，在监测到死锁出现后，对其进行恢复。下面我们就来探讨一下死锁的检测和恢复的几种方式</p>
<h3 id="每种类型一个资源的死锁检测方式"><a href="#每种类型一个资源的死锁检测方式" class="headerlink" title="每种类型一个资源的死锁检测方式"></a>每种类型一个资源的死锁检测方式</h3><p>每种资源类型都有一个资源是什么意思？我们经常提到的打印机就是这样的，资源只有打印机，但是设备都不会超过一个。</p>
<p>可以通过构造一张资源分配表来检测这种错误，比如我们上面提到的</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/11.png" style="zoom:80%;"></p>
<p>的算法来检测从 $P_1$ 到 $P_n$ 这 $n$ 个进程中的死锁。假设资源类型为 $m$，$E_1$ 代表资源类型1，$E_2$ 表示资源类型 2 ，$E_i$ 代表资源类型$ i ,(1 &lt;= i &lt;= m)$。E 表示的是 <code>现有资源向量(existing resource vector)</code>，代表每种已存在的资源总数。</p>
<p>现在我们就需要构造两个数组：C 表示的是<code>当前分配矩阵(current allocation matrix)</code> ，R 表示的是 <code>请求矩阵(request matrix)</code>。$C<em>i$ 表示的是 $P_i $持有每一种类型资源的资源数。所以，$C</em>{ij} $表示 $P<em>i$ 持有资源 $j$ 的数量。$R</em>{ij}$ 表示$ P_i$ 所需要获得的资源 $j$ 的数量 </p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/12.png" style="zoom:80%;"></p>
<p>一般来说，已分配资源 j 的数量加起来再和所有可供使用的资源数相加 = 该类资源的总数。</p>
<p><strong>死锁的检测就是基于向量的比较</strong>。每个进程起初都是没有被标记过的，算法会开始对进程做标记，进程被标记后说明进程被执行了，不会进入死锁，当算法结束时，<strong>任何没有被标记过的进程都会被判定为死锁进程</strong>。</p>
<p>上面我们探讨了两种检测死锁的方式，那么现在你知道怎么检测后，你何时去做死锁检测呢？一般来说，有两个考量标准：</p>
<ul>
<li>每当有资源请求时就去检测，这种方式会占用昂贵的 CPU 时间。</li>
<li>每隔 k 分钟检测一次，或者当 CPU 使用率降低到某个标准下去检测。考虑到 CPU 效率的原因，如果死锁进程达到一定数量，就没有多少进程可以运行，所以 CPU 会经常空闲。</li>
</ul>
<h3 id="从死锁中恢复"><a href="#从死锁中恢复" class="headerlink" title="从死锁中恢复"></a>从死锁中恢复</h3><p>上面我们探讨了如何检测进程死锁，我们最终的目的肯定是想让程序能够正常的运行下去，所以针对检测出来的死锁，我们要对其进行恢复，下面我们会探讨几种死锁的恢复方式</p>
<h4 id="通过抢占进行恢复"><a href="#通过抢占进行恢复" class="headerlink" title="通过抢占进行恢复"></a>通过抢占进行恢复</h4><p>在某些情况下，可能会临时将某个资源从它的持有者转移到另一个进程。比如在不通知原进程的情况下，将某个资源从进程中强制取走给其他进程使用，使用完后又送回。这种恢复方式一般比较困难而且有些简单粗暴，<strong>并不可取</strong>。</p>
<h4 id="通过回滚进行恢复"><a href="#通过回滚进行恢复" class="headerlink" title="通过回滚进行恢复"></a>通过回滚进行恢复</h4><p>如果系统设计者和机器操作员知道有可能发生死锁，那么就可以定期检查流程。进程的检测点意味着进程的状态可以被写入到文件以便后面进行恢复。检测点不仅包含<code>存储映像(memory image)</code>，还包含<code>资源状态(resource state)</code>。一种更有效的解决方式是不要覆盖原有的检测点，而是每出现一个检测点都要把它写入到文件中，这样当进程执行时，就会有一系列的检查点文件被累积起来。</p>
<p>为了进行恢复，要从上一个较早的检查点上开始，这样所需要资源的进程会回滚到上一个时间点，在这个时间点上，死锁进程还没有获取所需要的资源，可以在此时对其进行资源分配。</p>
<h4 id="杀死进程恢复"><a href="#杀死进程恢复" class="headerlink" title="杀死进程恢复"></a>杀死进程恢复</h4><p>最简单有效的解决方案是直接杀死一个死锁进程。但是杀死一个进程可能照样行不通，这时候就需要杀死别的资源进行恢复。</p>
<p>另外一种方式是选择一个环外的进程作为牺牲品来释放进程资源。</p>
<h2 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h2><p>我们上面讨论的是如何检测出现死锁和如何恢复死锁，下面我们探讨几种规避死锁的方式</p>
<h3 id="单个资源的银行家算法"><a href="#单个资源的银行家算法" class="headerlink" title="单个资源的银行家算法"></a>单个资源的银行家算法</h3><p>银行家算法是 Dijkstra 在 1965 年提出的一种调度算法，它本身是一种死锁的调度算法。它的模型是基于一个城镇中的银行家，银行家向城镇中的客户承诺了一定数量的贷款额度。算法要做的就是判断请求是否会进入一种不安全的状态。如果是，就拒绝请求，如果请求后系统是安全的，就接受该请求。</p>
<p>比如下面的例子，银行家一共为所有城镇居民提供了 15 单位个贷款额度，一个单位表示 1k 美元，如下所示</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/13.png" style="zoom:80%;"></p>
<p>城镇居民都喜欢做生意，所以就会涉及到贷款，每个人能贷款的最大额度不一样，在某一时刻，A/B/C/D 的贷款金额如下</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/14.png" style="zoom:80%;"></p>
<p>上面每个人的贷款总额加起来是 13，马上接近 15，银行家只能给 A 和 C 进行放贷，可以拖着 B 和 D、所以，可以让 A 和 C 首先完成，释放贷款额度，以此来满足其他居民的贷款。这是一种<code>安全</code>的状态。</p>
<p>如果每个人的请求导致总额会超过甚至接近 15 ，就会处于一种不安全的状态，如下所示</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/15.png" style="zoom:80%;"></p>
<p>这样，每个人还能贷款至少 2 个单位的额度，如果其中有一个人发起最大额度的贷款请求，就会使系统处于一种死锁状态。</p>
<blockquote>
<p>这里注意一点：不安全状态并不一定引起死锁，由于客户不一定需要其最大的贷款额度，但是银行家不敢抱着这种侥幸心理。</p>
</blockquote>
<p>银行家算法就是对每个请求进行检查，检查是否请求会引起不安全状态，如果不会引起，那么就接受该请求；如果会引起，那么就推迟该请求。</p>
<p>类似的，还有多个资源的银行家算法，读者可以自行了解。</p>
<h2 id="破坏死锁"><a href="#破坏死锁" class="headerlink" title="破坏死锁"></a>破坏死锁</h2><p>死锁本质上是无法避免的，因为它需要获得未知的资源和请求，但是死锁是满足四个条件后才出现的，它们分别是</p>
<ul>
<li>互斥</li>
<li>保持和等待</li>
<li>不可抢占</li>
<li>循环等待</li>
</ul>
<p>我们分别对这四个条件进行讨论，按理说破坏其中的任意一个条件就能够破坏死锁</p>
<h3 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h3><p>我们首先考虑的就是<strong>破坏互斥使用条件</strong>。如果资源不被一个进程独占，那么死锁肯定不会产生。如果两个打印机同时使用一个资源会造成混乱，打印机的解决方式是使用 <code>假脱机打印机(spooling printer)</code> ，这项技术可以<strong>允许多个进程同时产生输出</strong>，在这种模型中，实际请求打印机的唯一进程是打印机守护进程，也称为后台进程。后台进程不会请求其他资源。我们可以消除打印机的死锁。</p>
<p>后台进程通常被编写为能够输出完整的文件后才能打印，假如两个进程都占用了假脱机空间的一半，而这两个进程都没有完成全部的输出，就会导致死锁。</p>
<p>因此，尽量做到尽可能少的进程可以请求资源。</p>
<h3 id="破坏保持等待的条件"><a href="#破坏保持等待的条件" class="headerlink" title="破坏保持等待的条件"></a>破坏保持等待的条件</h3><p>第二种方式是如果我们能阻止持有资源的进程请求其他资源，我们就能够消除死锁。一种实现方式是让所有的进程开始执行前请求全部的资源。如果所需的资源可用，进程会完成资源的分配并运行到结束。如果有任何一个资源处于频繁分配的情况，那么没有分配到资源的进程就会等待。</p>
<p>很多进程<strong>无法在执行完成前就知道到底需要多少资源</strong>，如果知道的话，就可以使用银行家算法；还有一个问题是这样<strong>无法合理有效利用资源</strong>。</p>
<p>还有一种方式是进程在请求其他资源时，先释放所占用的资源，然后再尝试一次获取全部的资源。</p>
<h3 id="破坏不可抢占条件"><a href="#破坏不可抢占条件" class="headerlink" title="破坏不可抢占条件"></a>破坏不可抢占条件</h3><p>破坏不可抢占条件也是可以的。可以通过虚拟化的方式来避免这种情况。</p>
<h3 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h3><p>现在就剩最后一个条件了，循环等待条件可以通过多种方法来破坏。一种方式是制定一个标准，一个进程在任何时候只能使用一种资源。如果需要另外一种资源，必须释放当前资源。对于需要将大文件从磁带复制到打印机的过程，此限制是不可接受的。</p>
<p>另一种方式是将所有的资源统一编号，如下图所示</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/16.png" style="zoom:80%;"></p>
<p>进程可以在任何时间提出请求，但是所有的请求都必须按照资源的顺序提出。如果按照此分配规则的话，那么资源分配之间不会出现环。</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/17.png" style="zoom:80%;"></p>
<p>尽管通过这种方式来消除死锁，但是编号的顺序不可能让每个进程都会接受。</p>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>下面我们来探讨一下其他问题，包括 <strong>通信死锁、活锁是什么、饥饿问题和两阶段加锁</strong></p>
<h3 id="两阶段加锁"><a href="#两阶段加锁" class="headerlink" title="两阶段加锁"></a>两阶段加锁</h3><p>虽然很多情况下死锁的避免和预防都能处理，但是效果并不好。随着时间的推移，提出了很多优秀的算法用来处理死锁。例如在数据库系统中，一个经常发生的操作是请求锁住一些记录，然后更新所有锁定的记录。当同时有多个进程运行时，就会有死锁的风险。</p>
<p>一种解决方式是使用 <code>两阶段锁(two-phase locking)</code>。顾名思义分为两个阶段，一阶段是进程尝试一次锁定它需要的所有记录。如果成功后，才会开始第二阶段，第二阶段是执行更新并释放锁。第一阶段并不做真正有意义的工作。</p>
<p>如果在第一阶段某个进程所需要的记录已经被加锁，那么该进程会释放所有锁定的记录并重新开始第一阶段。从某种意义上来说，这种方法类似于预先请求所有必需的资源或者是在进行一些不可逆的操作之前请求所有的资源。</p>
<p>不过在一般的应用场景中，两阶段加锁的策略并不通用。如果一个进程缺少资源就会半途中断并重新开始的方式是不可接受的。</p>
<h3 id="通信死锁"><a href="#通信死锁" class="headerlink" title="通信死锁"></a>通信死锁</h3><p>我们上面一直讨论的是资源死锁，资源死锁是一种死锁类型，但并不是唯一类型，还有通信死锁，也就是两个或多个进程在发送消息时出现的死锁。进程 A 给进程 B 发了一条消息，然后进程 A 阻塞直到进程 B 返回响应。假设请求消息丢失了，那么进程 A 在一直等着回复，进程 B 也会阻塞等待请求消息到来，这时候就产生<code>死锁</code>。</p>
<p>尽管会产生死锁，但是这并不是一个资源死锁，因为 A 并没有占据 B 的资源。事实上，通信死锁并没有完全可见的资源。根据死锁的定义来说：每个进程因为等待其他进程引起的事件而产生阻塞，这就是一种死锁。相较于最常见的通信死锁，我们把上面这种情况称为<code>通信死锁(communication deadlock)</code>。</p>
<p>通信死锁不能通过调度的方式来避免，但是可以使用通信中一个非常重要的概念来避免：<code>超时(timeout)</code>。在通信过程中，只要一个信息被发出后，发送者就会启动一个定时器，定时器会记录消息的超时时间，如果超时时间到了但是消息还没有返回，就会认为消息已经丢失并重新发送，通过这种方式，可以避免通信死锁。</p>
<p>但是并非所有网络通信发生的死锁都是通信死锁，也存在资源死锁，下面就是一个典型的资源死锁。</p>
<p>当一个数据包从主机进入路由器时，会被放入一个缓冲区，然后再传输到另外一个路由器，再到另一个，以此类推直到目的地。缓冲区都是资源并且数量有限。如下图所示，每个路由器都有 10 个缓冲区（实际上有很多）。</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/18.png" style="zoom:80%;"></p>
<p>假如路由器 A 的所有数据需要发送到 B ，B 的所有数据包需要发送到 D，然后 D 的所有数据包需要发送到 A 。没有数据包可以移动，因为在另一端没有缓冲区可用，这就是一个典型的资源死锁。</p>
<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>你会发现一个很有意思的事情，死锁就跟榆木脑袋一样，不会转弯。我看过古代的一则故事：</p>
<p><img src="/2021/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/19.png" style="zoom:80%;"></p>
<p>如果说死锁很<code>痴情</code>的话，那么<code>活锁</code>用一则成语来表示就是 <code>弄巧成拙</code>。</p>
<p>某些情况下，当进程意识到它不能获取所需要的下一个锁时，就会尝试礼貌的释放已经获得的锁，然后等待非常短的时间再次尝试获取。可以想像一下这个场景：当两个人在狭路相逢的时候，都想给对方让路，相同的步调会导致双方都无法前进。</p>
<p>现在假想有一对并行的进程用到了两个资源。它们分别尝试获取另一个锁失败后，两个进程都会释放自己持有的锁，再次进行尝试，这个过程会一直进行重复。很明显，这个过程中没有进程阻塞，但是进程仍然不会向下执行，这种状况我们称之为 <code>活锁(livelock)</code>。</p>
<h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>与死锁和活锁的一个非常相似的问题是 <code>饥饿(starvvation)</code>。想象一下你什么时候会饿？一段时间不吃东西是不是会饿？对于进程来讲，最重要的就是资源，如果一段时间没有获得资源，那么进程会产生饥饿，这些进程会永远得不到服务。</p>
<p>我们假设打印机的分配方案是每次都会分配给最小文件的进程，那么要打印大文件的进程会永远得不到服务，导致进程饥饿，进程会无限制的推后，虽然它没有阻塞。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>死锁是一类通用问题，任何操作系统都会产生死锁。当每一组进程中的每个进程都因等待由该组的其他进程所占有的资源而导致阻塞，死锁就发生了。这种情况会使所有的进程都处于无限等待的状态。</p>
<p>死锁的检测和避免可以通过安全和不安全状态来判断，其中一个检测方式就是银行家算法；当然你也可以使用鸵鸟算法对死锁置之不理，但是你肯定会遭其反噬。</p>
<p>也可以在设计时通过系统结构的角度来避免死锁，这样能够预防死锁；也可以破坏死锁的四个条件来破坏死锁。资源死锁并不是唯一性的死锁，还有通信间死锁，可以设置适当的超时时间来完成。</p>
<p>活锁和死锁的问题有些相似，它们都是一种进程无法继续向下执行的状态。由于进程调度策略导致尝试获取进程的一方永远无法获得资源后，进程会导致饥饿的出现。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/05/16/%E7%BB%9F%E8%AE%A1%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%835-1-5-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/16/%E7%BB%9F%E8%AE%A1%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%835-1-5-3/" class="post-title-link" itemprop="url">统计量及其分布5.1-5.3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-16 15:27:07" itemprop="dateCreated datePublished" datetime="2021-05-16T15:27:07+08:00">2021-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-01-16 11:56:01" itemprop="dateModified" datetime="2023-01-16T11:56:01+08:00">2023-01-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="总体与样本"><a href="#总体与样本" class="headerlink" title="总体与样本"></a>总体与样本</h2><h3 id="总体与个体"><a href="#总体与个体" class="headerlink" title="总体与个体"></a>总体与个体</h3><p>在一个统计问题中，我们把研究对象的全体称为<strong>总体</strong>，构成总体的每个成员称为<strong>个体</strong>。比如说：</p>
<ul>
<li>某大学的全体学生构成问题的总体，每一个学生就是一个个体</li>
</ul>
<p>抛开实际背景，总体就是一堆数，这堆数中有大有小，因此用一个概率分布去描述和归纳总体是恰当的。从这个意义看，总体就是一个分布，而其数量指标就是服从这个分布的随机变量。所以<strong>从总体中抽样</strong>与<strong>从某分布中抽样</strong>是同一个意思</p>
<p>总体还有<strong>有限总体</strong>和<strong>无限总体</strong>，接下来将以无限总体作为主要研究对象。</p>
<h3 id="样本"><a href="#样本" class="headerlink" title="样本"></a>样本</h3><p>为了了解总体的分布，我们从总体中随机地抽取n个个体，记其指标值为$x_1,x_2\cdots,x_n$, 则 $x_1,x_2,\cdots,x_n$称为总体的<strong>一个样本</strong>。</p>
<h2 id="样本数据的整理与显示"><a href="#样本数据的整理与显示" class="headerlink" title="样本数据的整理与显示"></a>样本数据的整理与显示</h2><h3 id="经验分布函数"><a href="#经验分布函数" class="headerlink" title="经验分布函数"></a>经验分布函数</h3><p>设$x<em>1,x_2\cdots,x_n$ 是取自总体分布函数为$F(x)$的样本，若将样本观测值有小到大进行排列，记为$x</em>{(1)},x<em>{(2)},\cdots,x</em>{(n)}$ ,则$x<em>{(1)},x</em>{(2)},\cdots,x_{(n)}$ 称为<strong>有序样本</strong>，用有序样本定义如下函数：</p>
<script type="math/tex; mode=display">
F_n(x) =F\left( x\right) \begin{cases}0, 当x<x_{(1)} \\
k/n ~~,当x_{(k)}\leq x <x_{(k+1)} \\
1 ,当 x\geq x_{(n)} \end{cases}</script><p>则$F_n(x)$ 是一非减右连续函数，称$F_n(x)$为该样本的<strong>经验分布函数</strong></p>
<p>设$x_1,x_2,\cdots,x_n$是取自总体分布函数为$F(x)$的样本，$F_n(x)$ 是经验分布函数，当$n\rightarrow \infty$时，有：</p>
<script type="math/tex; mode=display">
P(\sup\limits_{-\infty<x<\infty}|F_n(x)-F(x)|\rightarrow 0)=1</script><p>因此，经验分布函数的pdf和cdf可以写为：</p>
<script type="math/tex; mode=display">
</script><h1 id="统计量及其分布"><a href="#统计量及其分布" class="headerlink" title="统计量及其分布"></a>统计量及其分布</h1><h2 id="统计量与抽样分布"><a href="#统计量与抽样分布" class="headerlink" title="统计量与抽样分布"></a>统计量与抽样分布</h2><p>设 $x_1,x_2\cdots,x_n$ 为取自某个总体的样本，若样本函数 $T=T(x_1,x_2\cdots,x_n)$ 中不含任何未知函数，则称T为<strong>统计量</strong>。因此，统计量是一类函数，而统计量的分布称为<strong>抽样分布</strong>。</p>
<p>按照这一定义，若$x<em>1,x_2\cdots,x_n$ 为样本，则 $\sum</em>{i=1}^n x<em>i,\sum</em>{i=1}^n x_i^2$ 都是统计量，但是当$\mu,\sigma^2$ 未知时，$x_1-\mu,x_1/\sigma$ 这类的函数就不能称之为统计量。 注意了，<strong>尽管统计量不依赖于未知参数，但是它的分布是依赖于未知参数的</strong>。</p>
<p>下面我么来介绍一些常见的统计量及其抽样分布</p>
<h2 id="样本均值及其抽样分布"><a href="#样本均值及其抽样分布" class="headerlink" title="样本均值及其抽样分布"></a>样本均值及其抽样分布</h2><p>首先我们给出样本均值的定义：</p>
<p>设 $x_1,x_2\cdots,x_n$ 为取自某总体的样本，其算数平均值称为<strong>样本均值</strong>，一般用$\overline x$ 表示，即：</p>
<script type="math/tex; mode=display">
\overline x= \frac{x_1+x_2+\cdots+x_n}{n}  = \frac{1}{n} \sum_{i=1}^n x_i</script><p>在<strong>分组样本场合</strong>，样本的<strong>近似公式</strong>为：</p>
<script type="math/tex; mode=display">
\overline x = \frac{x_1f_1+x_2f_2+\cdots+x_kf_k}{n} ~~~(n=\sum_{i=1}^n f_i)</script><p>其中，k为组数，$x_i$ 为第i组的组中值， $f_i$ 为第i组的频数</p>
<p>关于样本均值，有以下几个性质：</p>
<ul>
<li><p>若把样本中的数据与样本均值之差称为偏差，则样本<strong>所有偏差之和为0</strong>，即 $\sum_{i=1}^n(x_i-\overline n) = 0$ 这是显然的。</p>
</li>
<li><p>数据观测值与样本均值的偏差平方和最小，即 :</p>
<ul>
<li><script type="math/tex; mode=display">
\sum(x_i-c)^2\geq \sum(x_i-\overline x)^2</script></li>
<li><p>用文字描述的话，就是对任意给定的常数 c,  对于形如 $\sum(x_i-c)^2$ 的函数，$\sum(x_i-\overline x)^2$ 最小</p>
</li>
</ul>
</li>
<li><p>设 $x_1,x_2\cdots,x_n$ 是来自某个总体的样本，$\overline x$ 为样本均值</p>
<ul>
<li>若总体分布为 $N(\mu,\sigma^2)$ ， 则$\overline x$ 的精确分布为 $N(\mu,\sigma^2/n)$</li>
<li>若总体分布未知或者不是正态分布，且 $E(x)=\mu,Var(x) = \sigma^2$ 存在，则n较大时$\overline x$ 的<strong>渐进分布</strong>为$N(\mu,\sigma^2/n)$ 。<strong>这里渐近分布是指n较大的时候的近似分布</strong></li>
</ul>
</li>
</ul>
<h2 id="样本方差与样本标准差"><a href="#样本方差与样本标准差" class="headerlink" title="样本方差与样本标准差"></a>样本方差与样本标准差</h2><p>首先给出定义：</p>
<p>设 $x_1,x_2\cdots,x_n$ 为取自某总体的样本，则它关于样本均值 $\overline x$ 的<strong>平均偏差平方和</strong>就被称为<strong>样本方差</strong>：</p>
<script type="math/tex; mode=display">
s_n^2 =\frac{1}{n} \sum_{i=1}^n (x_i-\overline x)^2</script><p>其算术根 $s_n=\sqrt{s_n^2}$ 称为 <strong>样本标准差</strong>。相对样本方差而言，样本标准差通常更有实际意义，因为<strong>它与样本均值具有相同的度量单位</strong>。 </p>
<hr>
<p>在n 不大时，常用下式作为<strong>样本方差(s没有n)</strong>： </p>
<script type="math/tex; mode=display">
s^2 = \frac{1}{n-1}\sum_{i=1}^n (x_i-\overline x)^2</script><p>其算数根 $s=\sqrt{s^2}$ 也被称为样本标准差。</p>
<hr>
<p>在实际中，$s^2$ 比 $s^2_n$ 更常用，以后我们都是用 $s^2$ </p>
<p><strong>样本方差是度量样本散布大小的统计量</strong>， 在这个定义中，n 为 样本量，n-1 称为偏差平方和的自由度。其含义是： 在 $\overline x$ 确定后，n个偏差 $x_1-\overline x,x_2-\overline x,\cdots,x_n-\overline x$ 中只有 $n-1$个偏差可以自由变动(因为其和为0)</p>
<hr>
<p>样本偏差平方和有三个常用的表达式, 它们都可以用来计算样本方差：</p>
<script type="math/tex; mode=display">
\sum(x_i-\overline x)^2 = \sum x_i^2-\frac{(\sum x_i)^2}{n} = \sum x_i^2 - n\overline x^2</script><hr>
<p>在分组样本场合，样本方差的近似计算公式为：</p>
<script type="math/tex; mode=display">
s^2 = \frac{1}{n-1} \sum_{i=1}^k f_i(x_i-\overline x)^2  = \frac{1}{n-1}(\sum_{i=1}^k f_ix_i^2-n\overline x^2)</script><p>其中 $x_i,f_i$ 分别为第i个区间的组中值和频数，$\overline x = \frac{x_1f_1+x_2f_2+\cdots+x_kf_k}{n}$ 给出的均值近似值</p>
<h2 id="样本矩及其函数"><a href="#样本矩及其函数" class="headerlink" title="样本矩及其函数"></a>样本矩及其函数</h2><p>样本矩和矩一样，是样本均值和样本方差更一般的推广，是一类常见的统计量。</p>
<p>设 $x_1,x_2\cdots,x_n$ 是样本，k为正整数，则下面这个统计量被称为k阶原点矩</p>
<script type="math/tex; mode=display">
a_k = \frac{1}{n} \sum_{i=1}^n x_i^k</script><p>样本一阶原点矩就是样本均值</p>
<hr>
<p>类似的，我们给出样本的k阶 中心矩：</p>
<script type="math/tex; mode=display">
b_k = \frac{1}{n} \sum_{i=1}^n (x_i-\overline x)^k</script><p>样本二阶中心距就是样本方差</p>
<hr>
<p>现在再介绍样本偏度和样本峰度，它们都是中心矩的函数</p>
<p>设 $x_1,x_2\cdots,x_n$是样本，则称统计量 </p>
<script type="math/tex; mode=display">
\hat \beta_s = b_3/b_2^{3/2}</script><p>为<strong>样本偏度</strong></p>
<p>如果数据完全对称，那么$b_3=0$ 样本偏度就等于0；</p>
<p>如果 $\hat\beta_s$ 明显大于0，表示样本的右尾长，即样本中有几个特大的数，我们称其为正偏的右偏</p>
<p>如果 $\hat\beta_s$ 明显小于0，表示分布的左尾长，即样本中有几个特小的数，这反映了总体分布是负偏的或左偏的。</p>
<p><img src="/2021/05/16/%E7%BB%9F%E8%AE%A1%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%835-1-5-3/1.jpg" style="zoom:67%;"></p>
<hr>
<p> 设 $x_1,\cdots,x_n$ 是样本，则称统计量：</p>
<script type="math/tex; mode=display">
\hat\beta_k = \frac{b_4}{b_2^2}-3</script><p>为样本峰度</p>
<p>当 $\hat\beta_k$ 明显大于0 时，分布密度曲线在其峰值附近比正态分布来的更陡，尾部更细——称为尖顶型</p>
<p>当$\hat\beta_s$ 明显小于0时，分布密度曲线在其峰值附近比正态分布来得平坦，尾部更粗，称为平顶型</p>
<h2 id="次序统计量及其分布"><a href="#次序统计量及其分布" class="headerlink" title="次序统计量及其分布"></a>次序统计量及其分布</h2><p>设 $x<em>1\cdots,x_n$ 是取自总体X的样本，$x</em>{(i)}$ 称为该样本的第 i 个次序统计量，它的取值是将样本观测值由小到大排列后得到的第i个观测值。其中 $x<em>{(1)}$ 为该样本的最小次序统计量，$x</em>{(n)}$ 称为该样本的最大次序统计量。</p>
<p>$(x<em>{(1)},x</em>{(2)},\cdots,x_{(n)})$ 称为该样本的次序统计量</p>
<p>在一个样本中， $x<em>1,x_2\cdots x_n$ 是独立同分布的，而次序统计量 $x</em>{(1)},x<em>{(2)}\cdots,x</em>{(n)}$ 即不独立，分布也不相同。</p>
<p>接下来我们讨论次序统计量的抽样分布。</p>
<h3 id="单个次序统计量的分布"><a href="#单个次序统计量的分布" class="headerlink" title="单个次序统计量的分布"></a>单个次序统计量的分布</h3><p>设总体X的密度函数为 $p(x)$ 分布函数为$F(x)$ ，$x<em>1,x_2\cdots,x_n$为样本，则第k个次序统计量 $x</em>{(k)}$ 的密度函数为：</p>
<script type="math/tex; mode=display">
p_k(x) = \frac{n!}{(k-1)!(n-k)!}(F(x))^{k-1}(1-F(x))^{n-k}p(x)</script><p>特别的，当总体分布为 $U(0,1)$时，$x_1,\cdots,x_n$ 为样本，则其第k个次序统计量的密度函数为：</p>
<script type="math/tex; mode=display">
p_k(x)=\frac{n!}{(k-1)!(n-k)!}x^{k-1}(1-x)^{n-k}</script><p>这就是贝塔分布 $Be(k,n-k+1)$ 从而有 $E(x_{(k)})=\frac{k}{n+1}$</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>设总体目睹函数为：</p>
<script type="math/tex; mode=display">
p(x) = 3x^2~~0<x<1</script><p>现从该总体抽得一个容量为5的样本，试计算 $p(x_{2}&lt;\frac{1}{2})$ </p>
<p><strong>第一步：求出总体分布函数</strong></p>
<script type="math/tex; mode=display">
F(x) = \begin{cases}0,X\leq 0\\ x^{3},0<x<1\\ 1,x\geq 1\end{cases}</script><p><strong>第二步</strong>：求出$x_{(2 )}$ 的密度函数</p>
<script type="math/tex; mode=display">
p_2(x) = \frac{5!}{(2-1)!(5-2)!}(F(x))^{2-1}p(x)(1-F(x))^{5-2}\\
=20 x^33x^2(1-x^3)^3\\
=60x^5(1-x^3)^3 ~~~~~~ 0<x<1</script><p><strong>第三步：计算概率</strong></p>
<script type="math/tex; mode=display">
P(x_{(2)}<\frac12)= \int_0^{1/2} 60x^5(1-x^3)^3 dx\\
=\int_0^{1/8}20y(1-y)^3dy=\int_{7/8}^1 20(z^3-z^4)dz\\
=5(1-(\frac{7}{8})^4)-4(1-(\frac 78)^5) = 0.1207</script><h3 id="多个次序统计量及其函数分布"><a href="#多个次序统计量及其函数分布" class="headerlink" title="多个次序统计量及其函数分布"></a>多个次序统计量及其函数分布</h3><p>次序统计量$(x<em>{(i)},x</em>{(j)})(i&lt;j)$ 的联合分布密度函数为：</p>
<script type="math/tex; mode=display">
p_{ij}(y,z) = \frac{n!}{(i-1)!(j-i-1)!(n-j)!}[F(y)]^{i-1}[F(z)-F(y)]^{j-i-1}[1-F(z)]^{n-j}p(y)p(z),y\leq z</script><h2 id="样本分位数与样本中位数"><a href="#样本分位数与样本中位数" class="headerlink" title="样本分位数与样本中位数"></a>样本分位数与样本中位数</h2><p>样本中位数 $m_{0.5}$ 也是一个常见的统计量，它也是次序统计量的函数，当n为奇数时，取中间那个数；当n为偶数时，取中间两个数的平均数。</p>
<p>更一般的，样本p分位数$m_p$ 可如下定义：</p>
<script type="math/tex; mode=display">
F(x) = \begin{cases}x_{([np+1])},~~~~~ 若np不是整数\\~~\\ \frac12(x_{(np)}+x_{(np+1)})  ~~~~~若np是整数\end{cases}</script><h3 id="分位数的渐进分布"><a href="#分位数的渐进分布" class="headerlink" title="分位数的渐进分布"></a>分位数的渐进分布</h3><p>设总体密度函数为$p(x)$,$x_p$ 为其p分位数，$p(x)$ 在$x_p$处连续且 $p(x_p)&gt;0$ ,那么当$n\rightarrow \infty$时，样本p分位数$m_p$ 的渐进分布为：</p>
<script type="math/tex; mode=display">
m_p\sim N(x_p,\frac{p(1-p)}{np^2(x_p)})</script><p>特别的，对于样本中位数，当$n\rightarrow \infty$时，近似地有</p>
<script type="math/tex; mode=display">
m_{0.5}\sim N(x_{0.5}\frac{1}{4n\cdot p^2(x_{0.5})})</script><h4 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h4><p>在下列密度函数下分别寻求容量为n的样本中位数$m_{0.5}$的渐近分布：</p>
<ol>
<li><script type="math/tex; mode=display">
p(x) = 6x(1-x), 0<x<1</script><p>我们从这个密度函数就可以判断该分布为贝塔分布$Be(2,2)$ , 可以看出$p(x)$ 关于 0.5 对称，所以$x_{0.5}=0.5$ </p>
<p>于是可以带入公式，得到渐进分布为 $N(0.5,\frac{1}{9n})$</p>
<hr>
</li>
<li><script type="math/tex; mode=display">
p(x) = \frac{1}{\sqrt{2\pi} \sigma}\exp\{-\frac{(x-\mu)^2}{2\sigma^2}\}</script><p>显然，正态分布的中位数是 $\mu$  ,所以，$m_{0.5}$ 的渐近分布为$N(\mu,\frac{1}{4n\cdot\frac{1}{2\pi \sigma^2}}) =N(\mu,\frac{\pi\sigma^2}{2n})$</p>
<hr>
</li>
<li><script type="math/tex; mode=display">
p(x) = \begin{cases}2x, 0<x<1\\~\\0, 其他\end{cases}</script><p>该分布的分布函数为 $F(x) = \begin{cases}0,x&lt;0\~\x^2,0\leq x&lt;1\~\1 ,x\geq 1\end{cases}$ 所以相应的中位数为$\frac{\sqrt2}{2}$ ,所以$m_{0.5}$ 的渐进分布为 </p>
<script type="math/tex; mode=display">
N(\frac{\sqrt2}{2},\frac{1}{4n(2\times\frac{\sqrt2}{2})^2})=N(\frac{\sqrt2}2,\frac{1}{8n})</script></li>
</ol>
<h1 id="三大抽样分布"><a href="#三大抽样分布" class="headerlink" title="三大抽样分布"></a>三大抽样分布</h1><p>很多统计推断是基于正态分布的假设，以标准正态变量为基石而构造的三个著名的统计量在十几种有广泛的应用。</p>
<p><img src="/2021/05/16/%E7%BB%9F%E8%AE%A1%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%835-1-5-3/2.jpg" style="zoom:67%;"></p>
<p>下面我们逐个进行推导和证明</p>
<h3 id="mathcal-X-2-分布"><a href="#mathcal-X-2-分布" class="headerlink" title="$\mathcal X^2$ 分布"></a>$\mathcal X^2$ 分布</h3><p>设 $X_1,X_2\cdots,X_N$ 独立同分布于标准正态分布 $N(0,1)$ ，则 $\mathcal X^2 = \mathcal X_1^2+\cdots+\mathcal X_n^2$  的分布被称为自由度为n的$\mathcal X^2$ 分布，记为 $\mathcal X^2\sim \mathcal X^2(n)$ </p>
<p>在第三章中我们还给出了 卡方分布和伽马分布的关系，也就是$X^2(n) = Ga(\frac{n}2,\frac12)$ , 期望为 n， 方差为2n</p>
<p>$\mathcal X^2$ 分布有用的一个重要原因是下面这个定理：</p>
<h4 id="重要定理"><a href="#重要定理" class="headerlink" title="重要定理"></a>重要定理</h4><p>设 $x_1,x_2\cdots,x_n$ 是来自正态总体$N(\mu,\sigma^2)$ 的样本，其样本均值和样本方差分别为：</p>
<script type="math/tex; mode=display">
\begin{align}
&\overline x = \frac{1}{n}\sum_{i=1}^n x_i\\
&s^2 = \frac{1}{n-1} \sum_{i=1}^n(x_i-\overline x)^2
\end{align}</script><p>则有：</p>
<ol>
<li>$\overline x$ 与 $s^2$ 相互独立</li>
<li>$\overline x\sim N(\mu,\sigma^2/n)$</li>
<li>$\frac{(n-1)s^2}{\sigma^2}\sim \mathcal X^2(n-1)$ </li>
</ol>
<h3 id="F分布"><a href="#F分布" class="headerlink" title="F分布"></a>F分布</h3><p>设随机变量 $X_1\sim \mathcal X^2(m),X_2\sim\mathcal X^2(n)$，$X_1$ 与 $X_2$ 独立，则称 $F=\frac{X_1/m}{X_2/n}$ 的分布是自由度为m和n的F分布。记为 $F\sim F(m,n)$  ,其中m称为分子自由度，n称为分母自由度。</p>
<h4 id="推论："><a href="#推论：" class="headerlink" title="推论："></a>推论：</h4><p>设$x_1,x_2,\cdots,x_m$ 是来自 $N(\mu_1,\sigma_1^2)$的样本，$y_1\cdots,y_n$是来自$N(\mu_2,\sigma_2^2)$的样本，且此两样本相互独立。记：</p>
<script type="math/tex; mode=display">
s_x^2 = \frac{1}{m-1} \sum_{i=1}^m(x_i-\overline x)^2 , s_y^2 =\frac{1}{n-1}\sum_{i=1}^n(y_i-\overline y)^2</script><p>其中：</p>
<script type="math/tex; mode=display">
\overline x = \frac{1}{m} \sum_{i=1}^m x_i,\overline y = \frac{1}{n}\sum_{i=1}^n y_i</script><p>则有“</p>
<script type="math/tex; mode=display">
F=\frac{s_x^2/\sigma_1^2}{s_y^2/\sigma_2^2} \sim F(m-1,n-1) \\</script><p>特别的，若 $\sigma_1^2=\sigma_2^2$  则 $F=s_x^2/s_y^2\sim F(m-1,n-1)$</p>
<h4 id="例题：-构造F分布"><a href="#例题：-构造F分布" class="headerlink" title="例题： 构造F分布"></a>例题： 构造F分布</h4><p>设$x_1,x_2$是来自 $N(0,\sigma^2)$ 的样本，试求 $Y=(\frac{x_1+x_2}{x_1-x_2})^2$ 的分布。</p>
<p><strong>第一步：根据形态判断应该凑成哪个分布</strong></p>
<p>首先可以排除 t 分布的形式，因为没有根号出现。其次，这是一个分数的形式，因此最大的可能就是F分布。因此我们要想方设法配成F分布。</p>
<p>配成F分布的条件是：$F=\frac{X_1/m}{X_2/n}$ 其中$X_1$和$X_2$是两个卡方分布。而这里，$m=n=2$, 消去。 因此只要证明 $(x_1+x_2)^2$ 和 $(x_1-x_2)^2$ 都属于卡方分布即可。</p>
<p><strong>第二步：卡方分布怎么凑？</strong></p>
<p>凑卡方分布第一可以从 $Ga(n/2,1/2)$ 入手，或者从卡方分布：$x_1,x_2\cdots,x_n$ 独立同分布于标准正态分布, $\mathcal X^2 = x_1^2+\cdots+ x_n^2$ 的定义入手。</p>
<p>因为 $x_1,x_2$ 来自 $N(0,\sigma^2)$ , 二者又是独立同分布的，因此： $x_1+x_2\sim N(0,2\sigma^2),x_1-x_2\sim N(0,2\sigma^2)$ 把这两者看做是一个整体。标准化之后，可以获得：</p>
<script type="math/tex; mode=display">
\frac{x_1+x_2}{\sqrt{2\sigma^2}}\sim N(0,1)\\~\\
\frac{x_1-x_2}{\sqrt{2\sigma^2}}\sim N(0,1)</script><p>也就是说，一个单独的 $(\frac{x_1+x_2}{\sqrt{2\sigma^2}})^2$就可以看做是一个卡方分布;同理，$(\frac{x_1-x_2}{\sqrt{2\sigma^2}})^2$ 构成了另一个卡方分布，那么：</p>
<script type="math/tex; mode=display">
(\frac{x_1+x_2}{x_1-x_2})^2 =(\frac{(\frac{x_1+x_2}{\sqrt{2\sigma^2}})/2}{(\frac{x_1-x_2}{\sqrt{2\sigma^2}})/2})^2 \sim F(2-1,2-1)</script><hr>
<h3 id="t-分布"><a href="#t-分布" class="headerlink" title="t 分布"></a>t 分布</h3><p>设随机变量 $X_1$与$X_2$ 独立且$X_1\sim N(0,1),X_2\sim \mathcal X^2(n)$则称$t=\frac{X_1}{\sqrt{X_2/n}}$ 的分布为自由度为n的t分布，记为 $t\sim t(n)$</p>
<p>t分布的密度函数的图像是一个关于纵轴对称的分布，与标准正态分布的密度函数形状类似，只是峰比标准正态分布低一点尾部的概率比标准正态分布大一些</p>
<ul>
<li>自由度为1的t分布就是标准柯西分布，其均值不存在</li>
<li>$n&gt;1$时，t分布的数学期望存在且为0</li>
<li>$n&gt;2$时，t分布的方差存在且为$n/(n-2)$ </li>
<li>当自由度比较大时，t分布可以用$N(0,1)$分布近似</li>
</ul>
<h4 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h4><p>设 $x_1,x_2\cdots,x_n$ 是来自正态分布$N(\mu,\sigma^2)$的一个样本，$\overline x$ 与$s^2$ 分别是该样本的样本均值和样本方差则有：</p>
<script type="math/tex; mode=display">
t =\frac{\sqrt n(\overline x-\mu)}{s}\sim t(n-1)</script><h1 id="充分统计量"><a href="#充分统计量" class="headerlink" title="充分统计量"></a>充分统计量</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>我们之前谈了这么多的统计量，知道了统计量是关于样本的函数。对于一个总体来说，我们选取的样本是有限的，但是有限的样本会反映出总体的一些信息，进而可能帮助我们推断总体分布，那么我们希望某个统计量所包含的有用的信息和样本分布所包含的有用的信息是一样的，则这个统计量对将来的统计推断就非常有用——这就是充分统计量的直观含义</p>
<p>我们通过几个例子来更全面的了解充分统计量</p>
<h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><p>为研究某个运动员的打靶命中率$\theta$ ，我们对该运动员进行测试，观测其10次打靶结果，发现除了第3、6次未命中之外，其余8次都命中靶心。这样的观测结果告诉我们两点：</p>
<ol>
<li>打靶10次命中8次</li>
<li>2次不命中分别出现在第3次和第6次打靶上</li>
</ol>
<p>其实，第二点信息对我们了解这个运动员的命中率<strong>是没有帮助的</strong>。我们令每次射击要么命中要么不命中，命中为1，不命中为0. 那么命中率的计算和1出现的位置是没有关系的，而和出现1的次数有关系，比如第二轮打靶发现除了第1、2未命中其余都命中，虽然两轮样本观测值不一样，但是提供的关于命中率$\theta$的信息是一样的。因此<strong>在大多数实际问题中，试验编号信息常常对了解总体或者其参数是无关紧要的</strong></p>
<p>现在我们要想，什么统计量能反映出该选手的命中率$\theta$呢？ 很显然，令 $T = x_1+\cdots+x_n$ ，那么就可以通过T与样本数来反应命中率 $\theta$ 了。 统计上，将这种<strong>样本加工不损失信息</strong>称为<strong>充分性</strong></p>
<p>接下来，我们从概率层面分析：首先我们要搞清楚<strong>什么是有用的信息？</strong> 其实，有用的信息就和分布中的<strong>参数</strong></p>
<p>我们知道，样本$X=(x<em>1,x_2\cdots,x_n)$ 有一个样本联合分布 $F</em>\theta(X)$, 这个分布包含了样本中一切有关$\theta$的信息。 统计量$T=T(x<em>1\cdots,x_n)$也有一个抽样分布 $F</em>\theta^n(t)$ 。当我们期望用<strong>统计量T代替原始样本X并且不损失任何有关$\theta$的信息</strong> 时，说明 $F<em>\theta^T(t)$ 可以像$F</em>\theta(X)$ 一样概括了有关$ \theta$ 的一切信息。</p>
<p>换言之，我们考察统计量T的取值为t的情况下样本X的条件分布$F<em>\theta(X|T=t)$ ，当 $F</em>\theta(X|T=t)$ 不依赖于参数$\theta$ 时，说明样本所反映出来的有用的信息，都包含在统计量 T当中了。相当于我们给定了一个统计量的值之后，也就知道了样本中关于$\theta$的所有信息，剩下的其他信息就没什么价值了，这正是统计量具有充分性的含义。</p>
<h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><p>现在我们看看充分统计量和不充分的统计量之间的区别</p>
<p>设总体为二点分布 $b(1,\theta)$ ,$X<em>1,X_2\cdots,X_n$为样本，令 $T = X_1+X_2\cdots+X_n$ ，则在给定了T的取值之后，对于任意一组 $x_1,x_2\cdots,x_n$ ，$\sum</em>{i=1}^n x_i = t$ 都有：</p>
<script type="math/tex; mode=display">
P(X_1=x_1,X_2 =x_2,\cdots,X_n=x_n|T=t)\\~\\
=\frac{P(X_1=x_1,X_2 =x_2,\cdots,X_n=t-\sum_{i=1}^{n-1}x_i)}{P(\sum_{i=1}^n X_i=t)}\\~\\
=\prod_{i=1}^n P(X_i=x_i) \cdot P(X_n=t-\sum_{i=1}^{n-1}x_i)/C_n^t\theta^t(1-\theta)^n-t\\~\\</script><p>化简得到：</p>
<script type="math/tex; mode=display">
=\frac{\prod_{i=1}^{n-1}\theta^{x_i}(1-\theta)^{1-x_i}\cdot \theta^{t-\sum_{i=1}^{n-1}x_i}(1-\theta)^{1-t+\sum_{i=1}^{n-1}x_i}}{C_n^t \theta^t(1-\theta)^{n-t}}\\~\\
=\theta^{t}\cdot(1-\theta)^{n-t}/C_n^t\theta^t(1-\theta)^{n-t} \\~\\
=\frac{1}{C_n^t}</script><p>到最后，这个条件分布已经和 $\theta$没关系了。</p>
<p>但是我们现在令 $S=X_1+X_2$, 显然没有包含样本中所有关于$\theta$的信息，那么，在给定的$S=s$之后，对于任意一组$x_1,x_2\cdots,x_n,(x_1+x_2=s)$ 有：</p>
<script type="math/tex; mode=display">
P(X_1=x_1,X_2 =x_2,\cdots,X_n=x_n|S=s)\\~\\
=\frac{P(X_1=x_1,X_2=s-x_1,\cdots,X_n=x_n)}{P(X_1+X_2=s)}\\~\\
=\theta^{x_1}(1-\theta)^{1-x_1}\theta^{s-x_1}(1-\theta)^{1-s+x_1}\theta^{\sum_{i=3}^n x_i}(1-\theta)^{n-2-\sum_i^nx_i}/P(X_1+X_2=s) \\~\\
=\frac{\theta^{s+\sum_{i=3}^nx_i}(1-\theta)^{n-s-\sum_{i=3}^nx_i}}{C_2^s\theta^s(1-\theta)^{2-s}} =\frac{\theta^{\sum_{i=1}^nx_i}(1-\theta)^{n-2-\sum_{i=3}^nx_i}}{C_2^s}</script><p>这个分布最终的化简结果依赖于未知参数$\theta$，这说明样本中有关$\theta$的信息并没有完全包含在统计量S中。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>经过了上面这两个例子，其实充分统计量的定义就呼之欲出了。</p>
<p>设$x_1,x_2,\cdots,x_n$ 是来自某个总体的样本，总体分布函数为 $F(x;\theta)$ ,统计量 $T=T(x_1\cdots,x_n)$  称为$\theta$的充分统计量，如果在给定T的取值后$x_1\cdots,x_n$ 的条件分布与$\theta$无关</p>
<p>未知参数$\theta$ 可以是一维的也可以是多维的，应用中条件分布可以用条件分布列或者条件密度函数来表示。</p>
<h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p>设$x_1\cdots,x_n$ 是来自$N(\mu,1)$的样本，试证明 $T=\overline x$ 是$\mu$的充分统计量</p>
<p>总体采用<strong>配方</strong>策略</p>
<h2 id="因子分解定理"><a href="#因子分解定理" class="headerlink" title="因子分解定理"></a>因子分解定理</h2><p>在一般场合，直接由充分统计量的定义出发来验证一个统计量是充分的是困难的，因为条件分布的计算通常不那么容易。但是，我们有一个简单的办法判断一个统计量是否充分，这就是<strong>因子分解定理</strong>。 为了简便起见，我们引入一个两种分布类型通用的概念——<strong>概率函数</strong>。$f(x)$ 称为随机变量X的概率函数：在连续场合，$f(x)$表示X的概率密度函数，在离散场合，$f(x)$表示X的概率分布列。</p>
<p><strong>定理：</strong> </p>
<p>设总体概率函数为 $f(x;\theta)$ ,$x_1,\cdots,x_n$ 为样本，则 $T=T(x_1,x_2\cdots,x_n)$  为充分统计量的充分必要条件是：存在两个函数 $g(t;\theta)$ 和 $h(x_1,x_2\cdots,x_n)$ 使得对任意的 $ \theta$ 和任意一组观测值 $x_1\cdots,x_n$ 有：</p>
<script type="math/tex; mode=display">
f(x_1,x_2\cdots,x_n;\theta) = g(T(x_1,x_2\cdots,x_n),\theta) h(x_1,x_2\cdots,x_n)</script><p>其中，$g(t,\theta)$ 是通过统计量T的取值而依赖于样本的。也就是 $h(x_1,\cdots,x_n)$ 中不包含 $\theta$ 参数，$\theta$ 全部都在$g(t,\theta)$中</p>
<p>但是有时候我们在求联合分布函数的时候需要乘以一个示信函数 I， 当 x 和我们的参数之间存在关系时，比如：</p>
<p>设$x_1,x_2,\cdots,x_n$ 是取自总体 $U(0,\theta)$ 的样本，即总体的密度函数为：</p>
<script type="math/tex; mode=display">
p(x;\theta) = \begin{cases}1/\theta, 0<x<\theta\\~\\0, 其他\end{cases}</script><p>于是，样本的联合密度函数是：</p>
<script type="math/tex; mode=display">
p(x_1;\theta)p(x_2;\theta)\cdots p(x_3;\theta) = \begin{cases}(1/\theta)^n, 0 <\min\{x_i\}\leq \max\{x_i\}<\theta\\~\\
0,其他
\end{cases}</script><p>由于所有的 $x_i$都大于0， 且都小于$\theta$ 这里x的取值范围和$\theta$是有关系的，这时在写联合密度函数时就需要乘以示信函数，如下：</p>
<script type="math/tex; mode=display">
p(x_1;\theta)p(x_2;\theta)\cdots p(x_3;\theta) = (1/\theta)^n I_{\{x_{(n)}<\theta\}}</script><p>注意到这里示信函数为</p>
<script type="math/tex; mode=display">
 I_{\{x_{(n)}<\theta\}}</script><p>因为根据上面写的密度函数，最大的$x_i$ 也是小于参数$\theta$ 的</p>
<h4 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h4><p>设 $x_1\cdots,x_n\sim b(1,p)$  ，对其进行因子分解</p>
<script type="math/tex; mode=display">
f(x_1,x_2\cdots,x_n) = p^{\sum x_i}(1-p)^{n-\sum x_i}\\</script><p>令 $T=\sum x_i$ 经过配方：</p>
<script type="math/tex; mode=display">
=(1-p)^n\cdot(\frac{p}{1-p})^{\sum x_i}</script><p>那么，我们可以得到 $g(t;p)$ 和 $h(x_1,\cdots,x_n)$</p>
<script type="math/tex; mode=display">
g(t;p) = (1-p)^n(\frac{p}{1-p})^t\\
h(x_1,x_2\cdots,x_n) = 1</script><p>所以， $\sum x_i$ 是 $p$ 的充分统计量</p>
<h4 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h4><p>设 $x_1\cdots,x_n\sim N(0,\sigma^2)$ ，对其进行因子分解</p>
<script type="math/tex; mode=display">
p(x_1,x_2\cdots,x_n) = (2\pi)^{-\frac{n}{2}}(\sigma^2)^{-\frac{n}2}\exp\{-\frac{1}{2\sigma^2}\sum(x_i-0)^2\}\\~\\</script><p> 令 $T=\sum x_i^2$ ,经过配方可以得到 $g(t;\sigma^2)$和$h(x_1,x_2\cdots,x_n)$ </p>
<script type="math/tex; mode=display">
g(\sigma^2,t) = (\sigma^2)^{-\frac{n}2}\exp\{-\frac{1}{2\sigma^2}t \}\\~\\
h(x_1,x_2\cdots,x_n) = (2\pi)^{-\frac{n}2}</script><p>符合因子分解，那么 $\sum x_i^2$ 是$\sigma^2$的充分统计量</p>
<h4 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h4><p>设$x_1\cdots,x_n\sim N(\mu,\sigma^2)$  对其进行因子分解</p>
<p>这题比较特殊，因为这里 $\theta$ 是一个二维的参数： $\theta =\begin{pmatrix} n \ \sigma ^{2} \end{pmatrix}$</p>
<script type="math/tex; mode=display">
p(x_1,x_2\cdots,x_n) = (2\pi)^{-\frac n2}(\sigma^2)^{-\frac n2}\exp\{-\frac{1}{2\sigma^2}\sum_{i=1}^n(x_i-\mu)^2\}\\~\\
=(2\pi)^{-n/2}(\sigma^2)^{-n/2} \exp\{-\frac{1}{2\sigma^2}(\sum x_i^2-2n\overline x\mu+n\mu^2) \}\\~\\
 =(2\pi\sigma^2)^{-n/2}\exp\{-\frac{1}{2\sigma^2}\cdot n\mu^2\}\exp\{-\frac{1}{2\sigma^2}(\sum_{i=1}^n x_i^2-2\mu\sum_{i=1}^nx_i )\}</script><p>令$t<em>1=\sum</em>{i=1}^n x<em>i,t_2=\sum</em>{i=i}^n x_i^2$ 我们可以根据化简的结果计算$g(t;\theta)$和$h(x_1\cdots,x_n)$</p>
<script type="math/tex; mode=display">
g(t_1,t_2,\theta) = (2\pi\sigma^2)^{-n/2} exp\{-\frac{n\mu^2}{2\sigma^2}\}\exp\{-\frac{1}{2\sigma^2}(t_2-2\mu t_1)\} \\~\\
h(X) = 1</script><h4 id="例题4"><a href="#例题4" class="headerlink" title="例题4"></a>例题4</h4><p><img src="/2021/05/16/%E7%BB%9F%E8%AE%A1%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%835-1-5-3/3.jpg" style="zoom:67%;"></p>
<p>对于<strong>(a)</strong></p>
<ol>
<li>首先，观察 x的取值范围是否和参数有关系，并写出联合密度函数。</li>
</ol>
<p>显然这里，x和参数是有关系的，每一个 x 都要大于 $\mu$, 因此，最小的x也要大于$\mu$</p>
<script type="math/tex; mode=display">
p(x_1,x_2\cdots,x_n) = \prod_{i=1}^n \exp\{-(x_1-\mu)\}I(x>\mu)\\~\\
=\exp\{nu\}\prod_{i=1}^n \exp\{x_i\}I\{\mu<x_1\}</script><ol>
<li>根据因式分解定理，提取$T = x<em>{(1)}$ ，则 $g(t;\mu) = \prod</em>{i=1}^n\exp{-(x-\mu)}I{\mu&lt;x_{(1)}}$ ，$h(x)=1$</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jason</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">439</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    

  

</body>
</html>
