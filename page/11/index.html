<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=">


  <link rel="mask-icon" href="/images/logo.svg?v=" color="#222">














<meta property="og:type" content="website">
<meta property="og:title" content="Jason‘s Blog">
<meta property="og:url" content="https://jasonxqh.github.io/page/11/index.html">
<meta property="og:site_name" content="Jason‘s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '',
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    fancybox: false,
    tabs: ,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: 'undefined',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>







  <title>Jason‘s Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', '[object Object]', 'auto');
  ga('send', 'pageview');
</script>





<meta name="generator" content="Hexo 4.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">
  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
<a href="https://github.com/JasonXQH/JasonXQH.github.io" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jason‘s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/%20" rel="section">
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/07/16/%E5%90%B4%E6%81%A9%E8%BE%BE-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/16/%E5%90%B4%E6%81%A9%E8%BE%BE-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A01/" itemprop="url">吴恩达-机器学习1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-07-16T22:51:31+08:00">
                2021-07-16
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2021-07-19T21:54:28+08:00">
                2021-07-19
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="吴恩达-机器学习1"><a href="#吴恩达-机器学习1" class="headerlink" title="吴恩达-机器学习1"></a>吴恩达-机器学习1</h1><h2 id="一、-引言"><a href="#一、-引言" class="headerlink" title="一、 引言"></a>一、 引言</h2><h3 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h3><p>监督学习是指我们给计算机一个包含了正确数据(答案)的数据集，算法的目的就是给出更多的真确答案。这也被称为回归问题。比如说下面这张图，叉叉代表着搜集到的正确的数字。而我们要做的，是找出一条拟合的曲线，来预测某一个大小的房子的价格是多少。</p>
<p>虽然说价格最小精确到分，但是我们仍然可以将其认为是一个连续的值，因此可以用回归的模型来解决。回归的定义就是 : Predict continuous valued output.也就是预测连续的值。</p>
<p><img src="/2021/07/16/%E5%90%B4%E6%81%A9%E8%BE%BE-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A01/1.png" style="zoom:150%;"></p>
<p>​     下面是另外一种监督学习的例子，横轴是肿瘤的大小，而数轴只有0和1，0代表良性肿瘤，1代表是恶性肿瘤。</p>
<p><img src="/2021/07/16/%E5%90%B4%E6%81%A9%E8%BE%BE-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A01/2.png" style="zoom:150%;"></p>
<p>或者是这样的一个有两个维度的分布：</p>
<p><img src="/2021/07/16/%E5%90%B4%E6%81%A9%E8%BE%BE-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A01/3.png" style="zoom:150%;"></p>
<p>现在我们观测到一个肿瘤，我们的目的就是通过学习算法就将其归为某一类当中去。这是一个分类问题。比如第二张图，我们就可以在图上划出一条直线。</p>
<p>事实上，很多数据集不仅仅只有一个或者两个维度，可能有四五个或者更多特征。那怎么让学习算法能够处理这些特征呢？比如对于SVM(支持向量机)，就有一个特别灵巧的数学方法(核函数)，来允许计算机处理无穷多的特征</p>
<h3 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h3><p>对于无监督学习，我们给出的数据是没有标签的，如下：</p>
<p><img src="/2021/07/16/%E5%90%B4%E6%81%A9%E8%BE%BE-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A01/4.png" style="zoom:150%;"></p>
<p>我们不知道每个数据点代表什么，我们只被告知这里有一个数据集，我们能不能在这里找到某种结构。通过无监督学习，我们可以在这个数据集中找到两个 clusters(簇) ,也就是说，这是我们之前学习过的聚类算法(K-Means)</p>
<p>无监督学习的一些实践：</p>
<p>Google news:Google 每天会爬去数十万条新闻链接，然后将其聚类成一个一个新闻。比如说钻井平台新闻，集合了很多url，每个url指向不同新闻网站</p>
<p><img src="/2021/07/16/%E5%90%B4%E6%81%A9%E8%BE%BE-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A01/5.png" style="zoom:150%;"></p>
<p>聚类算法在基因组学中也有很多的应用。比如对于一个DNA微阵列数据的例子.</p>
<p><img src="/2021/07/16/%E5%90%B4%E6%81%A9%E8%BE%BE-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A01/6.png" style="zoom:150%;"></p>
<p>我们要做的就是运行一个聚类算法，把不同的个体归入不同的类或者归为不同类型的人。这是一种非监督学习，因为我们没有提前告知这个算法这些个体属于那一类人</p>
<p>非监督学习还可以用于社交圈，分析出和我们关系比较好的人，判断出哪些人互相认识并做推荐。在商业中，非监督学习可以将很多客户进行一个分类并进行精准的广告投放或者市场调研。</p>
<h2 id="单变量线性回归"><a href="#单变量线性回归" class="headerlink" title="单变量线性回归"></a>单变量线性回归</h2><h3 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h3><p>了解代价函数有助于我们弄清楚如何把最有可能的直线与我们的数据拟合。比如说对于一个数据集，我们给出一个假设 $h_\theta (x)=\theta_0+\theta_1x$ </p>
<p>$\theta_i’s $ 就是我们的参数。那么我们怎么才能选择 $\theta_0,\theta_1$ 来让拟合曲线更好地贴近我们的数据呢。我们用这样一个值来衡量 $\theta_0,\theta_1$ 是否合适。 </p>
<script type="math/tex; mode=display">
\min\limits_{\theta_0,\theta_1} \frac{1}{2m} \sum_{i=1}^m(h_0(x^{(i)})-y^{(i)})^2</script><p> 其中，$h_\theta(x^{(i)})=\theta_0+\theta_1x^{(i)}$ 是观测值，而$y^{(i)}$ 代表实际值。<br>我们要试图找到 $\theta_0,\theta_1$ 来让上面这个式子的值最小。</p>
<p>由此我们可以引出<strong>代价函数</strong>的定义。代价函数的自变量就是$\theta_i$ ,也就是用来衡量我们选取的$\theta$ 是否合理，如下图所示： </p>
<script type="math/tex; mode=display">
J(\theta_0,\theta_1) = \frac{1}{2m}\sum_{i=1}^m(h_0(x^{(i)})-y^{(i)})^2</script><p>代价函数也被称为平方误差函数。平方误差代价函数可能是解决回归问题最常用的手段了</p>
<h3 id="代价函数的直观理解I"><a href="#代价函数的直观理解I" class="headerlink" title="代价函数的直观理解I"></a>代价函数的直观理解I</h3><p>了解了原理之后我们来用例子说明代价函数是怎么操作的：</p>
<p>比如说现在我们的 $h<em>\theta = \theta_1x$ 那么其代价函数就是 $J(\theta_1)=\frac{1}{2m}\sum</em>{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})^2$ ,我们要求的就是$\min J(\theta_1)$  是的$\theta_1$</p>
<p><img src="/2021/07/16/%E5%90%B4%E6%81%A9%E8%BE%BE-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A01/7.png" style="zoom:80%;"></p>
<p>现在假设我们的训练集长这样，如果 $\theta_1=1$ 那么 $J(\theta_1)=0$ ; 如果 $\theta_1=0.5$, 那么 $J(\theta_1) = \frac{1}{2\cdot 3}[(0.5-1)^2+(1-2)^2+(1.5-3)^2] \approx 0.58$  如果 $\theta_1=0$ 那么 $J(0) =\frac{1}{2 \cdot 3}(1^2+2^2+3^2) \approx 2.333 $   </p>
<p>再取一些值、做了一些简单的比较之后，我们可以画出一个$J(\theta)$ 的图像，然后找到那个最小值，也就是 $\theta_1 = 1$ , 如下图所示：</p>
<p><img src="/2021/07/16/%E5%90%B4%E6%81%A9%E8%BE%BE-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A01/11.jpg" style="zoom:80%;"></p>
<blockquote>
<p>需要注意的是，$J(\theta)$ 是关于$\theta$ 的函数</p>
</blockquote>
<h3 id="代价函数的直观理解II"><a href="#代价函数的直观理解II" class="headerlink" title="代价函数的直观理解II"></a>代价函数的直观理解II</h3><p>上面是一个 $\theta$ 值画出来的代价函数，长得像一个碗 ，那么如果是 2个 $\theta $ 值画出来的代价函数长什么样呢？这个和训练集有关，有可能长成这个样子：</p>
<p><img src="/2021/07/16/%E5%90%B4%E6%81%A9%E8%BE%BE-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A01/8.png" style="zoom:80%;"></p>
<p>则可以看出在三维空间中存在一个使得$𝐽(\theta_0,\theta_1)$最小的点。</p>
<p>但是为了更好地展现三维图形，我们会使用等高线来表示含有两个参数的代价函数图像.如下图所示，在同一条等高线上，$J(\theta_0,\theta_1)$ 的取值都是一样的。我们要选择里中心点最近(也就是最低点)的$\theta_1,\theta_2$ 取值。</p>
<p><img src="/2021/07/16/%E5%90%B4%E6%81%A9%E8%BE%BE-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A01/9.png" style="zoom:80%;"></p>
<p>在接下来我们要学习一种可以自动找到这样满足 $\min J(\theta_0,\theta_1)$ 的 $\theta$ 的算法。也就是梯度下降算法</p>
<h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>梯度下降算法能将函数 J 最小化，它不仅仅被用在线性回归上，还被广泛应用于机器学习的众多范畴。</p>
<p>梯度下降问题可以解决 很复杂的形如$J(\theta_0,\theta_1,\cdots,\theta_n)$ 的最小值，但这里方便起见只用 $J(\theta_0,\theta_1)$ </p>
<p>算法的核心步骤其实很简单：</p>
<p>开始时我们随机选择一个参数的组合$(\theta_0,\theta_1,\cdots,\theta_n)$，计算代价函数，然后我们寻找下一个能让代价函数值<strong>下降最多的</strong>参数组合。我们持续这么做直到到一个局部最小值（<strong>local minimum</strong>），因为我们并没有尝试完所有的参数组合，所以不能确定我们得到的局部最小值是否便是全局最小值（<strong>global minimum</strong>），选择不同的初始参数组合，可能会找到不同的局部最小值。</p>
<ul>
<li>先给 $\theta_0,\theta_1$ 设置初始值(可以都为0)</li>
<li>一直改变 $\theta_0,\theta_1$ 的值，一直到我们找到 J 函数的最小值</li>
</ul>
<p><img src="/2021/07/16/%E5%90%B4%E6%81%A9%E8%BE%BE-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A01/10.png" style="zoom:80%;"></p>
<h3 id="梯度下降的直观理解"><a href="#梯度下降的直观理解" class="headerlink" title="梯度下降的直观理解"></a>梯度下降的直观理解</h3><h3 id="梯度下降的线性回归"><a href="#梯度下降的线性回归" class="headerlink" title="梯度下降的线性回归"></a>梯度下降的线性回归</h3><h2 id="线性代数回顾-Linear-Algebra-Review"><a href="#线性代数回顾-Linear-Algebra-Review" class="headerlink" title="线性代数回顾(Linear Algebra Review)"></a>线性代数回顾(<strong>Linear Algebra Review</strong>)</h2><h3 id="矩阵和向量"><a href="#矩阵和向量" class="headerlink" title="矩阵和向量"></a>矩阵和向量</h3><h3 id="加法和标量乘法"><a href="#加法和标量乘法" class="headerlink" title="加法和标量乘法"></a>加法和标量乘法</h3><h3 id="矩阵向量乘法"><a href="#矩阵向量乘法" class="headerlink" title="矩阵向量乘法"></a>矩阵向量乘法</h3><h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><h3 id="矩阵乘法的性质"><a href="#矩阵乘法的性质" class="headerlink" title="矩阵乘法的性质"></a>矩阵乘法的性质</h3><h3 id="逆、转置"><a href="#逆、转置" class="headerlink" title="逆、转置"></a>逆、转置</h3>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/07/05/Django%E5%AD%A6%E4%B9%A01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/" itemprop="url">Django学习1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-07-05T18:52:44+08:00">
                2021-07-05
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2021-12-01T14:06:24+08:00">
                2021-12-01
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Django学习1"><a href="#Django学习1" class="headerlink" title="Django学习1"></a>Django学习1</h1><h2 id="Fundamentals"><a href="#Fundamentals" class="headerlink" title="Fundamentals"></a>Fundamentals</h2><p>Django 是一个用来做Web开发的、基于python的开源框架。YouTube、Instergram等网页就是用Django制作的。</p>
<p>Django的好处有很多，比如说它直接提供了一个 <code>admin site</code>，也就是后台帮我们监控流量、处理用户信息等，帮我们减少了很多编程的时间。以及 <code>Object-related mapper(ORM)</code>，这可以让我们少些很多SQL语句。此外还有Authentication以及提供了Cache 等优点。</p>
<p>我们之前已经学过了一些前端和后端，前端有 React 后端有 Express。那其实Django是一个Web后端，当浏览器向后端发送HTTP请求的时候，后端就会通过查询、计算等步骤返回给前端一些数据(不返回网页是因为效率太低)，然后前段负责渲染这些数据。</p>
<blockquote>
<p>我们使用的环境</p>
<p>python3.9<br>pip3 install pipenv<br>vscode</p>
</blockquote>
<p>现在我们在文件夹中新建一个Django项目：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir storefront                           </span><br><span class="line">cd storefront</span><br><span class="line">pipenv install django</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/1.png" style="zoom:67%;"></p>
<p>输入<code>pipenv install django</code> 之后，会给这个Django项目新建一个虚拟的python环境。然后，python会在这个虚拟环境中下载Django。与此同时，python还为我们生成了两个文件： <code>Pipfile</code> 和 <code>Pipfile.lock</code>, 这两个文件存放着一些关于虚拟环境的信息：<code>Pipfile</code>如下，我们可以看到虚拟环境的python版本以及已经安装的package，这里暂且只有django 。其中<code>django = &quot;*&quot;</code> 代表可以兼容Django之前的版本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[[source]]</span><br><span class="line">url &#x3D; &quot;https:&#x2F;&#x2F;pypi.org&#x2F;simple&quot;</span><br><span class="line">verify_ssl &#x3D; true</span><br><span class="line">name &#x3D; &quot;pypi&quot;</span><br><span class="line"></span><br><span class="line">[packages]</span><br><span class="line">django &#x3D; &quot;*&quot;</span><br><span class="line"></span><br><span class="line">[dev-packages]</span><br><span class="line"></span><br><span class="line">[requires]</span><br><span class="line">python_version &#x3D; &quot;3.8&quot;</span><br></pre></td></tr></table></figure>
<p>接下来用<code>pipenv shell</code>来启动虚拟环境，并用<code>django-admin startproject storefront .</code> 来新建一个名叫<code>storefront</code> 的Django项目(之所以这里要加一个 <code>.</code> 是因为要把当前文件夹作为根目录，否则目录层级太多了，管理起来不方便)。创建好后如下图所示</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/2.png" style="zoom:67%;"></p>
<blockquote>
<p>在 <code>frontstore</code>子文件夹中有这些文件：</p>
<p><code>__init__.py</code> 是用来定义的</p>
<p><code>asgi.py,wsgi.py</code> 是用来发布项目的</p>
<p><code>setting.py</code> 是Django 项目的配置文件。如果你想知道这个文件是如何工作的，请查看<a href="https://docs.djangoproject.com/zh-hans/2.1/topics/settings/" target="_blank" rel="noopener">https://docs.djangoproject.com/zh-hans/2.1/topics/settings/</a></p>
<p><code>urls.py</code> 是用来保存路由网址的</p>
<p>在根目录下还有 <code>manage.py</code> ，是一个让你用各种方式管理 Django 项目的命令行工具。 </p>
</blockquote>
<p>现在如果我们直接运行 <code>django-admin runserver</code> 是不能启动这个Django项目的，会告诉我们还没有配置好。因此我们需要先运行：<code>python manage.py runserver 9000</code></p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/4.png" style="zoom:67%;"></p>
<p>打开<code>http://127.0.0.1:9000/</code> 可以看到如下页面：</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/3.png" style="zoom:67%;"></p>
<p>要在vscode中打开Terminal并使用python环境，首先可以通过快捷键<code>shift+command+p</code>打开配置栏并修改<code>python interpreter</code>为我们刚刚创建的虚拟环境。然后再通过 <strong>ctrl+` </strong> 或者  <strong>view&gt;terminal</strong>打开终端。</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/5.png" style="zoom:67%;"></p>
<h3 id="Creating-Your-First-App"><a href="#Creating-Your-First-App" class="headerlink" title="Creating Your First App"></a>Creating Your First App</h3><p>Django可以看成是一些组件的集合，其中每个组件负责不同的功能。在 <code>settings.py</code> 中，我们可以看到Django中已经默认安装的APP，我们也可以写自己的APP</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Application definition</span></span><br><span class="line"></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">'django.contrib.admin'</span>,</span><br><span class="line">    <span class="string">'django.contrib.auth'</span>,</span><br><span class="line">    <span class="string">'django.contrib.contenttypes'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages'</span>,</span><br><span class="line">    <span class="string">'django.contrib.staticfiles'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>创建的语句如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py startapp playground</span><br></pre></td></tr></table></figure>
<p>也就是创建一个名为 playground 的APP，结构如下</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/6.png" style="zoom:67%;"></p>
<blockquote>
<p>migration     文件夹是用来生成数据表的</p>
<p>admin.py      是用来写这个app的用户界面的</p>
<p>apps.py        是用来配置这个app的</p>
<p>models.py     是用来和“接收”数据库的信息的</p>
<p>tests.py        是用来单元测试的</p>
<p>views.py     视图，用来接受 Web 请求并且返回 Web 响应。</p>
</blockquote>
<p>创建完之后，我们需要在 <code>setting.py</code> 中加入这个APP</p>
<h3 id="Writing-Views"><a href="#Writing-Views" class="headerlink" title="Writing Views"></a>Writing Views</h3><p>View相当于一个句柄，收到了来自web前端发来的请求之后就返回一个Response。我们可以在里面写视图函数，视图函数的名字是任意的，比如下面这个 <code>say_hello</code>函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"><span class="comment"># request -&gt; response</span></span><br><span class="line"><span class="comment"># request handler</span></span><br><span class="line"><span class="comment"># action</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'Hello World'</span>)</span><br></pre></td></tr></table></figure>
<p>因此Django中的view用视图去理解是非常抽象的，我们将其理解为句柄即可。</p>
<p>这个意思是说，当解析得到了<code>playground/</code> 之后，交给<code>playground.urls</code>这个文件去处理/后面的内容。</p>
<p>写好了 视图，现在就要通过网页来访问后台了，于是我们要把urls注册进去。我们的目标是希望请求 <code>http://localhost:9000/playground/hello/</code>  时在前端显示 Hello World。</p>
<p>Django中的url是可以分层级注册的。比如说我在<code>frontstore</code>这个主应用文件夹下的<code>urls.py</code>中注册第一层的url :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">'playground/'</span>, include(<span class="string">'playground.urls'</span>))</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>现在我们编写<code>playground</code>中的<code>urls.py</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'hello/'</span>, views.say_hello),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这是第二层的url了，由于一开始<code>playground</code>交给上层解析掉了，现在我们只需要负责解析<code>hello/</code>即可。</p>
<blockquote>
<p>注意要点：</p>
<ul>
<li>url的每一部分必须以<code>/</code>为结尾</li>
<li>注意path的用法，调用函数的时候(如say_hello)不需要加双引号</li>
<li>注意include的用法，在调用文件的时候需要用双引号。</li>
</ul>
</blockquote>
<h3 id="Using-Templates"><a href="#Using-Templates" class="headerlink" title="Using Templates"></a>Using Templates</h3><p>Template字面意义是模板，在Django系统中，后端生成的数据会套用在模板中，然后发给前端。比如说：</p>
<p><code>views.py</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">'hello.html'</span>)</span><br></pre></td></tr></table></figure>
<p><code>hello.html</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这个很简单的例子中，当handler收到request之后，会调用渲染器<code>render()</code>将这个<code>HttpRequest</code> 放到<code>hello.html</code>这个模板中去处理。这里无论收到什么请求都会返回 <code>Hello World</code></p>
<h4 id="传入dictionary"><a href="#传入dictionary" class="headerlink" title="传入dictionary"></a>传入dictionary</h4><p>在使用 render函数时，还可像函数一样传入想要的参数，也可以写一些简单的逻辑，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def say_hello(request):</span><br><span class="line">    return render(request,&#39;hello.html&#39;,&#123;&#39;name&#39;:&#39;Jason&#39;&#125;)</span><br></pre></td></tr></table></figure>
<p>这里我传入了一个 <code>name</code>参数，<code>name</code>的值为<code>Jason</code>,那么在 <code>hello.html</code>中我就可以这样修改：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if name %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&#123;% else %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的逻辑是，如果传入的参数中有 name，那么就做一个渲染，否则直接传回<code>Hello World</code></p>
<blockquote>
<p>小细节</p>
<ul>
<li>结尾要写 endif 注意是连起来的</li>
<li>引用参数的时候要注意使用两对大括号</li>
</ul>
</blockquote>
<p>其实，现在Template的应用场景已经比较少了，现在流行的模式都是后端返回数据，前端渲染网页，而使用template的话就等于在后端就渲染好网页然后传给前端了。</p>
<h3 id="Debugging-Django-Applications-in-VSCode"><a href="#Debugging-Django-Applications-in-VSCode" class="headerlink" title="Debugging Django Applications in VSCode"></a>Debugging Django Applications in VSCode</h3><p>现在我们来讲讲如何调试Django项目，这里介绍两种方法：在VSCode中调试和使用Debug Toolbar进行调试。首先讲讲VSCode。</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/8.png" style="zoom:67%;"></p>
<p>首先点击右边的debug按钮，然后新建一个针对python&gt;Django的 <code>launch.json</code>文件，内容如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="attr">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Python: Django"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"python"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="attr">"program"</span>: <span class="string">"$&#123;workspaceFolder&#125;/manage.py"</span>,</span><br><span class="line">          <span class="comment">// 传入两个参数，启动参数和调试端口</span></span><br><span class="line">            <span class="attr">"args"</span>: [</span><br><span class="line">                <span class="string">"runserver"</span>，</span><br><span class="line">              	<span class="string">"9876"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"django"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们就在调试界面点击 Run 即可正常调试, 设间断点然后一步一步运行</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/9.png" style="zoom:67%;"></p>
<p>这边有几个符号，从左到右依次是：</p>
<ol>
<li>continue 2.Step over 3. Step into 4. Step out 5. Disconnect </li>
</ol>
<blockquote>
<p>注意点</p>
<ul>
<li><p>调试端口要和运行着程序的端口错开 </p>
</li>
<li><p>每次调试结束后，要删除间断点</p>
</li>
</ul>
</blockquote>
<h3 id="Using-Django-Debug-Toolbar"><a href="#Using-Django-Debug-Toolbar" class="headerlink" title="Using Django Debug Toolbar"></a>Using Django Debug Toolbar</h3><p>Django Debug Toolbar 是一个package，我们需要下载一下：教程在这里</p>
<p><a href="https://django-debug-toolbar.readthedocs.io/en/latest/installation.html" target="_blank" rel="noopener">https://django-debug-toolbar.readthedocs.io/en/latest/installation.html</a></p>
<blockquote>
<p>注意了，因为我们用的是虚拟环境，因此下载的时候需要用 <code>pipenv install django-debug-toolbar</code> 其余步骤和教程一致</p>
</blockquote>
<p>和VSCode不同，使用 toolbar 作为调试工具，需要传回一个HTML页面，因此我们需要对<code>hello.html</code>进行修改。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        &#123;% if name %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        &#123;% else %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>结果如下，还是比较炫酷的。</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/7.png" style="zoom:67%;"></p>
<h2 id="Build-a-Data-Model"><a href="#Build-a-Data-Model" class="headerlink" title="Build a Data Model"></a>Build a Data Model</h2><p>在Django这种后端框架中，是通过Model类来操作数据库的，程序员不需要关注SQL语句和数据库的类型(无论数据库是MySql、Sqlite，还是其它类型)，Django自动生成相应数据库类型的SQL语句，来完成对数据库数据的操作。</p>
<h3 id="Introduction-to-Data-Modeling"><a href="#Introduction-to-Data-Modeling" class="headerlink" title="Introduction to Data Modeling"></a>Introduction to Data Modeling</h3><p>进行Django开发的第一步是弄明白，我们要存储那些数据，这些数据之间有什么关系。比如说，商城中最重要的就是产品(Product)的信息：一个产品可以有名称、描述、价格、库存等信息。此外，不同的商品会分为不同的类型，因此我们还需要一个 类别(Collection)，这个类别也有自己的名称。</p>
<p>那么产品和类别之间是否有联系呢？ 肯定是有的。我们希望点击一个类别可以获取到其下面所有的产品，那么这是一个 <code>1对多</code> 的关系。如下图所示：</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/10.png" style="zoom:67%;"></p>
<p>数据与数据的关系还有<code>1对1</code>、<code>多对多</code></p>
<blockquote>
<p>注意点：</p>
<p>我们不需要考虑ID信息，Django会自动为我们生成。</p>
<p>要根据需求出发确定关系，不要天马行空</p>
</blockquote>
<h3 id="Building-an-E-commerce-Data-Model"><a href="#Building-an-E-commerce-Data-Model" class="headerlink" title="Building an E-commerce Data Model"></a>Building an E-commerce Data Model</h3><p>现在我们再来说几个数据模型：</p>
<p>比如说商品和购物车之间的关系</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/11.png" style="zoom:67%;"></p>
<p>还要客户、订单和商品之间的关系</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/12.png" style="zoom:67%;"></p>
<p>商品和标签之间的关系</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/13.png" style="zoom:67%;"></p>
<p>此外还有这样的关系：</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/18.png" style="zoom:67%;"></p>
<p><code>0..1</code> 表示一个集合中一个对象可以对应另一个集合中的0个或者1个对象</p>
<p>此外，还有：</p>
<p><code>0..*</code>表示一个集合中的一个对象对应另一个集合中的0个或多个对象。（ <strong>可以不对应</strong>）<br><code>1..*</code>表示一个集合中的一个对象对应另一个集合中的一个或多个对象。（ <strong>至少对应一个</strong>）</p>
<h3 id="Organizing-Models-in-Apps"><a href="#Organizing-Models-in-Apps" class="headerlink" title="Organizing Models in Apps"></a>Organizing Models in Apps</h3><p>之前我们说了Django是多个APP的合集，每个APP有属于自己的Data Model. 因此我们现在来看看怎么在APP中管理Data Model。</p>
<p>这里提供了三种模式，我们一次分析其利弊：</p>
<p>第一种就是把所有的字段都集成在一个 Model中，这样能让model迁移时更加方便，但是随着项目的扩大，会难以管理，如下图所示：</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/15.png" style="zoom: 50%;"></p>
<p>另一种就是交给不同的Model来管理，这种做法更加不可取，你可能认为这样很方便，但事实上这些字段之间是相互联系的，这样分开反而会导致耦合度、代码量大大提升：</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/14.png" style="zoom:67%;"></p>
<p>最后一种是最优解，也就是让不同的Model “各司其职”，只管好自己的事情。比如说Store中就没必要把<code>Tag,TaggedItem</code>加进来，因为这两个字段在其他场景下也可以使用，比如说社交网站上，朋友圈上都可以用；因此可以将其分开。</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/16.png" style="zoom: 33%;"></p>
<blockquote>
<p>归化数据模型的两个准则</p>
<ol>
<li>使得model之间的耦合度最小</li>
<li>使得每个model的内部凝聚性尽可能高</li>
</ol>
</blockquote>
<p>上面规划了两个Data Model，那么我们就创建两个APP来装下它们。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python manage.py startapp store </span><br><span class="line">python manage.py startapp tags</span><br></pre></td></tr></table></figure>
<p>创建完之后，别忘了在<code>settings.py</code>中添加这两个app</p>
<h3 id="Creating-Models"><a href="#Creating-Models" class="headerlink" title="Creating Models"></a>Creating Models</h3><p>理清楚各个App之间的关系之后，现在我们开始编写 APP 文件夹中的 <code>models.py</code>  </p>
<p>对于 <code>store</code>文件夹下的<code>models.py</code> ,之前我们说一个Store需包含商品、顾客、购物车、订单等元素，现在我们来一一实现。</p>
<p>首先我们创建一个 Product类，用来存放关于产品的相关信息，我们需要Model Field来Cover住这些信息，关于每个field都有这些通用的options参数可以写。</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/17.png" style="zoom: 50%;"></p>
<p>更多的Field我们可以参考Django的文档：</p>
<p><a href="https://docs.djangoproject.com/en/3.2/ref/models/fields/" target="_blank" rel="noopener">https://docs.djangoproject.com/en/3.2/ref/models/fields/</a></p>
<p>Class 格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">255</span>) </span><br><span class="line">    description = models.TextField()</span><br><span class="line">    price = models.                                             (max_digits=<span class="number">6</span>,decimal_places=<span class="number">2</span>)</span><br><span class="line">    inventory = models.IntegerField()</span><br><span class="line">    last_update = models.DateTimeField(auto_now=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>首先最重要的是商品的名称，我们用<code>CharField</code> 来cover它，选择用CharField 的好处是可以限定最长的字符串，这里我设置为255</p>
<p>其次是商品的描述，因为可能会很长，因此我们用<code>TextField()</code>来Cover，这是不限字数的</p>
<p>再来是商品的价格，因为价格包含整数和小数，这里使用<code>DecimalField</code>来Cover，需要设定最大长度和小数点后几位，比如说这个商场里最高价格只能标注为9999.99,那么就要设置<code>max_digits=6,decimal_places=2</code></p>
<p>在后面是商品的库存，因为不可能有半件商品，所以这里用<code>IntegerField()</code>来Cover就可以了。</p>
<p>最后是最后更新时间了，Django中提供了专门适用的时间格式 <code>DateTimeField(auto_now=True)</code> </p>
</blockquote>
<p>同样的我们依葫芦画瓢可以写出 Customer Class:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    first_name = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    last_name = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    email  = models.EmailField(unique=<span class="literal">True</span>)</span><br><span class="line">    phone = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    birth_date = models.DateField(null=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里要注意的是，每个客户的email都必须是独一无二的，因此在填写EmailField的时候要写 <code>unique=True</code></p>
<p>此外，在一开始创建客户的birth_date 的时候，是空白的(可以理解为客户可以自己完善信息)，因此要写 <code>null=True</code></p>
</blockquote>
<h3 id="Choice-Fields"><a href="#Choice-Fields" class="headerlink" title="Choice Fields"></a>Choice Fields</h3><p>设想有一个字段，他代表了你会员的等级，有金银铜三个等级，那么我们该如何创建字段，这时候就可以用 choice Fields来实现：</p>
<p>在Django文档中，给了我们这样一个示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">YEAR_IN_SCHOOL_CHOICES = [</span><br><span class="line">    (<span class="string">'FR'</span>, <span class="string">'Freshman'</span>),</span><br><span class="line">    (<span class="string">'SO'</span>, <span class="string">'Sophomore'</span>),</span><br><span class="line">    (<span class="string">'JR'</span>, <span class="string">'Junior'</span>),</span><br><span class="line">    (<span class="string">'SR'</span>, <span class="string">'Senior'</span>),</span><br><span class="line">    (<span class="string">'GR'</span>, <span class="string">'Graduate'</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这是一个 Choice Field, 表现形式是一个元组列表，每个元组中，前者是存放在数据库当中的信息，后者是易于用户理解的信息。按照这个形式，我们可以写出会员等级，如下：</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    MEMBERSHIP_BRONZE = <span class="string">'B'</span></span><br><span class="line">    MEMBERSHIP_SILVER = <span class="string">'S'</span></span><br><span class="line">    MEMBERSHIP_GOLD = <span class="string">'G'</span></span><br><span class="line">    MEMBERSHIP_CHOICES = [</span><br><span class="line">        (MEMBERSHIP_BRONZE,<span class="string">'Bronze'</span>),</span><br><span class="line">        (MEMBERSHIP_SILVER,<span class="string">'Silver'</span>),</span><br><span class="line">        (MEMBERSHIP_GOLD,<span class="string">'Gold'</span>),</span><br><span class="line">    ]</span><br><span class="line">    membership = models.CharField(max_length=<span class="number">1</span>, choices=MEMBERSHIP_CHOICES, default=MEMBERSHIP_BRONZE)</span><br><span class="line">    <span class="comment">#....</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>那么这里我们为什么又要将 存放在数据库当中的字段单独赋值呢？</p>
<p>这是为了降低耦合度，如果未来’B’ 替换成别的字，按照之前的方法，就需要修改两个地方，不方便管理，现在就变得很清楚明了了。</p>
</blockquote>
<p>同样的，我们可以对 Order类中的 payment_status字段设置为 Choice Field</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    PAYMENT_PENDING = <span class="string">'P'</span></span><br><span class="line">    PAYMENT_COMPLETE = <span class="string">'C'</span></span><br><span class="line">    PAYMENT_FAILD = <span class="string">'F'</span></span><br><span class="line">    PAYMENT_CHOICES= [</span><br><span class="line">        (PAYMENT_PENDING,<span class="string">'Pending'</span>),</span><br><span class="line">        (PAYMENT_COMPLETE,<span class="string">'Complete'</span>),</span><br><span class="line">        (PAYMENT_FAILD,<span class="string">'Faild'</span>)</span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    place_at = models.DateTimeField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line">    payment_status =  models.CharField(max_length=<span class="number">1</span>,choices=PAYMENT_CHOICES,default = PAYMENT_PENDING)</span><br></pre></td></tr></table></figure>
<h3 id="Defining-One-to-one-Relationships"><a href="#Defining-One-to-one-Relationships" class="headerlink" title="Defining One-to-one Relationships"></a>Defining One-to-one Relationships</h3><p>现在我们将两个class之间建立一对一的联系。首先要明白哪个是Parent，哪个是Child，比如说我要在Customer和Address 之间建立联系，那么显然Customer是Parent，Address 是Child.</p>
<blockquote>
<p>需要在child model 中联系 parent model，如下：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    street = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    city = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    customer = models.OneToOneField(Customer,on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure>
<p><code>OneToOneField</code> 的第一个参数是 parent model 的类型，这里是<code>Customer</code> , 第二个参数比较有意思，是说当 parent model 中的一条信息删除时，对应的child model的操作。</p>
<blockquote>
<p>CASCADE  代表这条对应的信息也一并删除</p>
<p>SET_NULL 代表这条对应的信息中的字段(这里是street和city)将被置为 NULL</p>
<p>SET_DEFAULT 顾名思义就是当信息删除时，字段恢复默认值</p>
<p>PROTECT 是一种保护机制，即必须先删除 child 再删除 parent</p>
</blockquote>
<p>此外我们还需要设置 <code>primary_key = True</code>,也就是将Address设置为主键，也就是客户必须要设置这个参数，且具有唯一性，我们可以用主键来定位一条信息。</p>
<blockquote>
<p>为什么要在这里设其为主键，因为只有这样才能保证 One to One 关系，否则django会默认生成一个ID字段并设其为主键，这样会导致多个Address 对应一个 Customer</p>
</blockquote>
<h3 id="Defining-a-One-to-many-Relationship"><a href="#Defining-a-One-to-many-Relationship" class="headerlink" title="Defining a One-to-many Relationship"></a>Defining a One-to-many Relationship</h3><p>刚才说的一个用户对应一个地址显然是不符合现实的，因此现在我们在它们之间定义 一对多关系。</p>
<p>语法： <code>bid = models.ForeignKey(&quot;要关联的模型类名称&quot;)</code> ，<strong>子关联父</strong></p>
<p>方法很简单，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    street = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    city = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    customer = models.ForeignKey(Customer,on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure>
<p>这里我们就要引入主键和外键的关系和区别了。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>主键</th>
<th>外键</th>
<th><strong>索引</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>定义：</td>
<td>唯一标识一条记录，不能有重复的，不允许为空</td>
<td>表的外键是另一表的主键, 外键可以有重复的, 可以是空值</td>
<td>该字段没有重复值，但可以有一个空值</td>
</tr>
<tr>
<td>作用：</td>
<td>用来保证数据完整性</td>
<td>用来和其他表建立联系用的</td>
<td>是提高查询排序的速度</td>
</tr>
<tr>
<td>个数：</td>
<td>主键只能有一个</td>
<td>一个表可以有多个外键</td>
<td>一个表可以有多个唯一索引</td>
</tr>
</tbody>
</table>
</div>
<p>Address是Customer的外键，说明一个Customer可以有多个Address. 定义了一个外键字段，那么在该字段生成数据表之后会变为这样的形式： <code>外键字段名_id</code>， 比如这里就会变成 <code>customer_id</code>, 如果多个Address关联到一个Customer，那么它们的<code>customer_id</code> 是一样的。</p>
<p>新加入的如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Collection</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">		<span class="comment">#...</span></span><br><span class="line">    collection = models.ForeignKey(Collection,on_delete=models.PROTECT)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">    customer = models.ForeignKey(Customer,on_delete=models.PROTECT)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderItem</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    order = models.ForeignKey(Order,on_delete=models.PROTECT)</span><br><span class="line">    product =  models.ForeignKey(Product,on_delete=models.PROTECT)</span><br><span class="line">    quantity = models.PositiveSmallIntegerField()</span><br><span class="line">    unit_price = models.DecimalField(max_digits=<span class="number">6</span>,decimal_places=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    street = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    city = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    customer = models.ForeignKey(Customer,on_delete=models.CASCADE)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cart</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    created_at = models.DateTimeField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CartItem</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    cart = models.ForeignKey(Cart,on_delete=models.CASCADE)</span><br><span class="line">    product = models.ForeignKey(Product,on_delete=models.CASCADE)</span><br><span class="line">    quantity = models.PositiveSmallIntegerField()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里要注意，有些 <code>on_delete</code>属性我们选择的是PROTECT，为什么呢？</p>
<p>比如说 Order和Customer 之间的关系，我们希望Customer被删除后，还能保留其之前下的订单(完以数据分析有用)</p>
<p>而有些关系比如说 Cart 和CartItem 之间，删除了购物车之后，想必不需要留下购物车中的物品了。</p>
</blockquote>
<h3 id="Defining-Many-to-many-Relationships"><a href="#Defining-Many-to-many-Relationships" class="headerlink" title="Defining Many-to-many Relationships"></a>Defining Many-to-many Relationships</h3><p>现在我们来定义多对多关系, 比如说商场里面商品和促销活动之间的关系。一个商品可以同时参加多个促销活动，同时一个促销活动也可以涵盖多个商品</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promotion</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    description = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    discount = models.FloatField()</span><br><span class="line">    <span class="comment"># product_set</span></span><br><span class="line">     </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    promotion = models.ManyToManyField(Promotion)</span><br></pre></td></tr></table></figure>
<p>这里我们在 Product 类中建立与 promotion 的多对多关系</p>
<h3 id="Resolving-Circular-Relationships"><a href="#Resolving-Circular-Relationships" class="headerlink" title="Resolving Circular Relationships"></a>Resolving Circular Relationships</h3><p>在 Store 中我们还会碰到这种问题：两个 model 是互相依赖的, 构建出了一个环形的关系(Circular Relationships) 如下所示：</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/18.png" style="zoom:67%;"></p>
<ul>
<li>一个 Collection 中可以有多个 Product，这代表 Product 依赖于 Collection</li>
<li>同时，特定的Product可以作为Collection的封面、代表 之类的，这说明Collection 反过来在依赖Product</li>
</ul>
<p>在 python 中，我若把 Collection 放在 Product 之前，会识别不出 Product，如下：</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/19.png" style="zoom:67%;"></p>
<p>为了解决这个问题，需要用引号将 Product 引起来,但这也是不够的，会报这样的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Reverse query name for &#39;store.Collection.featured_product&#39; clashes with field name &#39;store.Product.collection&#39;.</span><br><span class="line">HINT: Rename field &#39;store.Product.collection&#39;, or add&#x2F;change a related_name argument to the definition for field &#39;store.Collection.featured_product&#39;.</span><br></pre></td></tr></table></figure>
<p>这是因为在 <code>Collection</code> 中有一个字段叫 <code>featured_product</code> ，Django 会自动生成 Reverse Relationship ，也就是反向查找在 models.py 中是否有 <code>Product</code> 的类，如果有就会和其建立反向联系。但是现在的情况是 ，Product 中已经有一个名叫<code>collection</code> 的字段了，因此出现了名字上的冲突。</p>
<p>因此需要用到 <code>ForeignKey.related_name</code> 这个属性。<br>我不想让Django创建一个反向关联，因此我将其设为<code>+</code> 即可。这样一来， Collection可以找到Product，但又不会和Product创建反向关联，因此可以实现环形关系。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    featured_product = models.ForeignKey(<span class="string">'Product'</span>,on_delete=SET_NULL,null=<span class="literal">True</span> , related_name=<span class="string">'+'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Generic-Relationships"><a href="#Generic-Relationships" class="headerlink" title="Generic Relationships"></a>Generic Relationships</h3><p>之前我们说了对于 Tag、Likes 这样的 model，我们是希望其能在不同的情况下使用的， 比如说对于Like，允许用户在文章评论视频下方点赞，Tag可以再不同的场所打上标签。</p>
<p>那么对于这么多要点赞的类型，都需要创建1对多的关系，很显然代码量以及管理起来都比较繁琐。虽然Likes这个类是一对多关系里的“多”这一侧，但实际上他的模型字段也是广义上的“一”，因为他的外键字段和所连接的模型都是“一对一”建立连接的。</p>
<p>Django里面的ContentType其实就是起到一个自动一对多的作用，和任何模型都能连接起来，保证了代码的干净。</p>
<p>现在我们再来了解一下 <code>GenericForeignKey</code>, 普通的Foreignkey，只能“指向”单一的模型，而ContentType则可以允许和任意的模型进行连接，非常灵活。设立这种外键，你需要3个字段</p>
<blockquote>
<p>1：设定一个普通外键，连接于ContentType，一般名字叫“content_type”。<br> 这个字段实际上是代码你在Likes这个点赞里面，是给哪个对应的模型在点赞，是文章/评论/视频，或是其他。</p>
<p>2：设立一个PostiveIntegerField的字段，一般名字叫做“object_id”。<br> 以记录所对应的模型的实例的id号，比如我们给一篇文章点赞，这篇文章是Post类里的id为10的文章，那么这个object_id就是这个10。<br> 其实看到这里，应该清楚了，当你有了模型的名字，也告诉了你这个模型的实例的id号，你就可以找出这个实例了。</p>
<p>3：第三个也是最后一个，就是设定这个GenericForeignkey外键了，这个外键需要传入两个参数，就是上面的1和2，如果你为上面2个字段取的名字就是content_type和object_id的话，你可以不需要输入，因为这个字段默认会读取这2个名字。如果你自定义过了，那就需要你手动添加。</p>
</blockquote>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>回头我们所需要的应用场景上来，我创建了一个 tags 模型，里面设计两个 Class， Tag 和 TaggedItem ，前者可以看做是标签的实例，后者则是一个广泛的标签概念，可以打在不同的物品类型上面</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tag</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    label = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaggedItem</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    tag = models.ForeignKey(Tag,on_delete= models.CASCADE)</span><br><span class="line">    content_type = models.ForeignKey(ContentType,on_delete= models.CASCADE)</span><br><span class="line">    object_id = models.PositiveIntegerField()</span><br><span class="line">    content_object = GenericForeignKey()</span><br></pre></td></tr></table></figure>
<p>同样的，我们可以创建 <code>LikedItem</code> 类，用来给不同类型的物品点赞：其中，user就是用来定义是谁点的赞。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">from</span> django.contrib.contenttypes.models <span class="keyword">import</span> ContentType</span><br><span class="line"><span class="keyword">from</span> django.contrib.contenttypes.fields <span class="keyword">import</span> GenericForeignKey</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LikedItem</span> <span class="params">(models.Model)</span>:</span></span><br><span class="line">    user = models.ForeignKey(User,on_delete=models.CASCADE)</span><br><span class="line">    content_type = models.ForeignKey(ContentType,on_delete=models.CASCADE)</span><br><span class="line">    object_id = models.PositiveIntegerField()</span><br><span class="line">    content_object = GenericForeignKey()</span><br></pre></td></tr></table></figure>
<h2 id="Setting-Up-the-Database"><a href="#Setting-Up-the-Database" class="headerlink" title="Setting Up the Database"></a>Setting Up the Database</h2><p>我们首先来了解一下 SQLite,然后会使用Mysql数据库</p>
<h3 id="Creating-Migrations"><a href="#Creating-Migrations" class="headerlink" title="Creating Migrations"></a>Creating Migrations</h3><p>在Django项目中，我们并不会手动来创建数据库，Django会自动帮我们生成。</p>
<p>运行：<code>python manage.py makemigrations</code>  可以生成很多迁移文件：</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/20.png" style="zoom:67%;"></p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/21.png" style="zoom:67%;"></p>
<h4 id="更新与修改"><a href="#更新与修改" class="headerlink" title="更新与修改"></a>更新与修改</h4><p>如果我们要更新 migration文件，只需要修改完model 然后重新运行<code>python manage.py makemigrations</code>即可.比如说我要修改 class Product中的price字段，将其改名为unit_price, 然后运行。</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/22.png" style="zoom:67%;"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Generated by Django 3.2.5 on 2021-07-25 05:56</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> migrations</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Migration</span><span class="params">(migrations.Migration)</span>:</span></span><br><span class="line"></span><br><span class="line">    dependencies = [</span><br><span class="line">        (<span class="string">'store'</span>, <span class="string">'0001_initial'</span>),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    operations = [</span><br><span class="line">        migrations.RenameField(</span><br><span class="line">            model_name=<span class="string">'product'</span>,</span><br><span class="line">            old_name=<span class="string">'price'</span>,</span><br><span class="line">            new_name=<span class="string">'unit_price'</span>,</span><br><span class="line">        ),</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，我们在修改model的时候，之前一定要先将该app添加到<code>settings.py</code>当中去，否则Django是检测不出是否修改的。</p>
</blockquote>
<p>比如说现在我要给Product再添加一条字段：slug, slug可以帮助数据库更快的找到商品信息，比如说：<code>https://stackoverflow.com/questions/12099315/design-1-or-2-tables-for-a-1-to-0-1-relationship-with-sql-server</code>中的 <code>design-1-or-2-tables-for-a-1-to-0-1-relationship-with-sql-server</code> 就是这个页面的slug</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slug = models.SlugField(default=<span class="string">'-'</span>)</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">slug = models.SlugField(null=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意到，在0002号migration文件中，有一个dependencies列表，里面是0001号migration文件，说明后者是在前者的基础上进行修改的。因此，如果我们要重命名前面的 文件，就需要修改对应的dependeny</p>
</blockquote>
<h3 id="Running-Migrations"><a href="#Running-Migrations" class="headerlink" title="Running Migrations"></a>Running Migrations</h3><p>现在我们来运行上面创建的migration文件，用他们来生成数据表</p>
<p>运行： <code>python manage.py migrate</code> 即可</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/23.png" style="zoom:67%;"></p>
<p>我们发现Django是对所有的app中的migration文件进行迁移。</p>
<p>那么这些生成的数据表存放到哪里了呢？是存放到Django项目自带的sqllite数据库当中了。我们可以下载VSCode中的SQLite插件然后用这个插件打开数据库</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/24.png" style="zoom:67%;"></p>
<p>可以再导航栏的最下面发现SQLITE EXPLORER，里面就是生成的数据库。其中<code>django_migrations</code>数据表中就存放着每个app于其对应的migration的信息。</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/25.png" style="zoom:67%;"></p>
<p>如果我们要运行一个特定的migration文件，可以这样来写：</p>
<p><code>python manage.py sqlmigrate store 0003</code> Django就会运行至store app中的0003号文件，后面的文件不运行下去了</p>
<h4 id="小测试"><a href="#小测试" class="headerlink" title="小测试"></a>小测试</h4><blockquote>
<ol>
<li>Add zip to Address</li>
<li>Create a migration</li>
<li>Run it</li>
<li>Inspect the migrations table</li>
</ol>
</blockquote>
<h3 id="Customizing-Database-Schema"><a href="#Customizing-Database-Schema" class="headerlink" title="Customizing Database Schema"></a>Customizing Database Schema</h3><p>有些时候我们希望对数据标进行定制化，比如说修改索引，或者修改表名等. 为了实现这个效果，我们可以使用 元数据(Metadata)。</p>
<p>元数据可以用来描述一类事务，比如说对于人，我们可以从年龄、身高、相貌、性格来描述；对于数码图片，我们有作者、型号、光圈、曝光时间等。这都是元数据。</p>
<p>Django中我们也可以对Model 设置元数据：</p>
<p><a href="https://docs.djangoproject.com/en/3.2/ref/models/options/" target="_blank" rel="noopener">https://docs.djangoproject.com/en/3.2/ref/models/options/</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    MEMBERSHIP_BRONZE = <span class="string">'B'</span></span><br><span class="line">    MEMBERSHIP_SILVER = <span class="string">'S'</span></span><br><span class="line">    MEMBERSHIP_GOLD = <span class="string">'G'</span></span><br><span class="line">    MEMBERSHIP_CHOICES = [</span><br><span class="line">        (MEMBERSHIP_BRONZE,<span class="string">'Bronze'</span>),</span><br><span class="line">        (MEMBERSHIP_SILVER,<span class="string">'Silver'</span>),</span><br><span class="line">        (MEMBERSHIP_GOLD,<span class="string">'Gold'</span>),</span><br><span class="line">    ]</span><br><span class="line">    first_name = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    last_name = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    email  = models.EmailField(unique=<span class="literal">True</span>)</span><br><span class="line">    phone = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    birth_date = models.DateField(null=<span class="literal">True</span>)</span><br><span class="line">    membership = models.CharField(max_length=<span class="number">1</span>, choices=MEMBERSHIP_CHOICES, default=MEMBERSHIP_BRONZE)</span><br><span class="line">    <span class="comment"># Metadata 要写在Model里面</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">'store_customers'</span></span><br><span class="line">        indexes = [</span><br><span class="line">            models.Index(fields = [<span class="string">'last_name'</span>,<span class="string">'first_name'</span>])</span><br><span class="line">        ]</span><br></pre></td></tr></table></figure>
<p>这边我设置了两个元数据，一个是数据表的名字，另一个是数据表的索引，我改成了两个。</p>
<p>运行<code>python manage.py makemigration</code> 之后，因为修改了两个点，新生成的 migration文件命名为 auto </p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/26.png" style="zoom:67%;"></p>
<blockquote>
<p>Django能帮助我们快速创建一个APP因此对每个model都设置元数据是没有必要的</p>
<p>生成migration文件的时候，最好一次只修改一个地方，这样自动命名会比较直观 </p>
</blockquote>
<h3 id="Reverting-Migrations"><a href="#Reverting-Migrations" class="headerlink" title="Reverting Migrations"></a>Reverting Migrations</h3><p>假设我现在发现运行的Migration文件有错误，怎么回滚呢？</p>
<p>如果我们只想回退一步，那么只要在model中修改然后重新生成一个migration文件即可。 但假如一个migration里面有很多步骤，我想将其全部删除，又该怎么做呢？</p>
<p>上面我们讲到，用<code>python manage.py migrate XXXX</code> 可以精确运行到某一migration文件，因此我们如果要抹除0005，可以这么写：<code>python manage.py migrate store 0004</code>, 结果如下：</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/27.png" style="zoom:67%;"></p>
<p>但现在还是不行，因为0005文件仍然存在，若我再次运行<code>python manage.py migrate</code> ,还是会回到之前的版本，因此要删去这个文件以及在model中对应的代码。</p>
<p>虽然说这样也可行，但是最好的办法还是使用版本控制软件如 git，但是每次migrate之后注意commit </p>
<h3 id="Using-MySQL-in-Django"><a href="#Using-MySQL-in-Django" class="headerlink" title="Using MySQL in Django"></a>Using MySQL in Django</h3><p>要在Django框架下连接mysql，首先需要安装<code>pymysql</code> 和 <code>mysqlclient</code></p>
<p>然后在 <code>settings.py</code> 中修改 DATABASES 一项：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,</span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'storefront'</span>,</span><br><span class="line">        <span class="string">'HOST'</span>:<span class="string">'localhost'</span>,</span><br><span class="line">        <span class="string">'USER'</span>:<span class="string">'root'</span>,</span><br><span class="line">        <span class="string">'PASSWORD'</span>:<span class="string">'你的数据库密码'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一开始我发现仅仅安装mysqlclient 的话，启动程序时会出错：<code>NameError: name ‘_mysql‘ is not defined</code></p>
<p>这是因为django一开始调用MYSQLdb，与python3.x起了冲突。解决办法是在配置文件目录下的<code>__init__.py</code>文件下加入以下代码来用pymysql替代MySQLdb：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure>
<p>Django现在已经成功连接Mysql了，现在在Mysql中创建frontstore的DATABASE，然后调用<code>python manage.py migrate</code> ，就可以将数据全部载入mysql了：</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/28.png" style="zoom: 50%;"></p>
<h3 id="Running-Custom-SQL"><a href="#Running-Custom-SQL" class="headerlink" title="Running Custom SQL"></a>Running Custom SQL</h3><p>有时我们想要自己运行一些SQL语句来修改数据库，怎么实现？</p>
<p>首先，运行 <code>python manage.py makemigrations store --empty</code> 创建一个属于store app的空的migration文件。</p>
<p>我们要写的就是operation里面的SQL 语句，格式是：<code>migration.RunSQL()</code> 我们需要写两段SQL语句，第一段是修改的，第二段则是删除修改的，如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">from</span> django.db <span class="keyword">import</span> migrations</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Migration</span><span class="params">(migrations.Migration)</span>:</span></span><br><span class="line"></span><br><span class="line">    dependencies = [</span><br><span class="line">        (<span class="string">'store'</span>, <span class="string">'0004_address_zip'</span>),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    operations = [</span><br><span class="line">        migrations.RunSQL(<span class="string">"""</span></span><br><span class="line"><span class="string">            INSERT INTO store_collection (title)</span></span><br><span class="line"><span class="string">            VALUES ('collection1')</span></span><br><span class="line"><span class="string">        """</span>,<span class="string">"""</span></span><br><span class="line"><span class="string">            DELETE FROM store_collection</span></span><br><span class="line"><span class="string">            WHERE title = 'collection1'</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        )</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>
<p>如果不写第二段SQL语句的话，当我们想回滚时会发生报错： <code>... is not reversible</code> ，因此为了便于维护，还是需要写一下的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">django.db.migrations.exceptions.IrreversibleError: </span><br><span class="line">Operation &lt;RunSQL &quot;INSERT INTO store_collection (title) VALUES (&#39;collection1&#39;)&quot;&gt;</span><br><span class="line">in store.0005_auto_20210731_0052 is not reversible</span><br></pre></td></tr></table></figure>
<h3 id="Generating-Dummy-Data"><a href="#Generating-Dummy-Data" class="headerlink" title="Generating Dummy Data"></a>Generating Dummy Data</h3><p>创建一些无意义的数据，便于我们接下来的程序开发</p>
<p><a href="https://mockaroo.com/" target="_blank" rel="noopener">https://mockaroo.com/</a> 我们需要用这个网站帮我们生成数据</p>
<p>详见我的一篇博客：</p>
<p><a href="https://jasonxqh.github.io/2020/06/26/PostgreSql基础/#Generate-1000-Rows-with-Mockaroo">1.0.11. Generate 1000 Rows with Mockaroo</a></p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/29.png" style="zoom: 50%;"></p>
<p>下载好SQL语句文件之后，拖到Datagrip中运行即可。</p>
<h2 id="Django-ORM"><a href="#Django-ORM" class="headerlink" title="Django ORM"></a>Django ORM</h2><h3 id="Django-ORM-1"><a href="#Django-ORM-1" class="headerlink" title="Django ORM"></a>Django ORM</h3><p>ORM (<strong>Object Relational Mapping</strong>) 也就是对相关系映射，用于实现面向对象编程语言里不同类型系统的数据之间的转换。通俗得说，就是当我们要用程序将数据库中的表格拉出进行操作室，需要用一个对象去接收它</p>
<p>使用Python的Django模型的话，一般都会用它自带的ORM（Object-relational mapping）模型。这个ORM模型的设计比较简单，学起来不会特别花时间。不过，Django的ORM模型有自己的一套语法，有时候会觉得别扭。 </p>
<p>其实，之前我们写的migration以及model文件，也是通过ORM来转换成sql语句的。但这也并不意味着我们不再需要了解SQL语句，当处理一些复杂问题时，还是需要我们自己写sql的.</p>
<h3 id="Managers-and-QuerySets"><a href="#Managers-and-QuerySets" class="headerlink" title="Managers and QuerySets"></a>Managers and QuerySets</h3><p>关于Django ORM首先我们要明白 manager和queryset的概念。</p>
<p>manager 可以理解为一个数据库的接口，它可以管理、调用数据库中的信息。比如说下面这段代码，首先从models 中引入Product类， <code>Product.objects</code> 就是一个manager，它可以实现很多功能。比如说<code>all()</code> 可以获取数据表中的所有行，<code>get()</code>可以获得一个单一的对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> store.models <span class="keyword">import</span> Product</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(request)</span>:</span></span><br><span class="line">    Product.objects.all()</span><br></pre></td></tr></table></figure>
<p>manager 返回的数据叫做 quertset,类似于 list，里面放的是一个个模型类的对象，可用索引下标取出模型类的对象。比如下面，可以通过切片来打印对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(request)</span>:</span></span><br><span class="line">    query_set = Product.objects.all()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    print(query_set[<span class="number">0</span>:<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">'hello.html'</span>,&#123;<span class="string">'name'</span>:<span class="string">'Jason'</span>&#125;)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/30.png" style="zoom:67%;"></p>
<p>在 Django Toolbar中，我们也可以看到Django向数据库发送的SQL语句：</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/31.png" style="zoom:67%;"></p>
<p>此外还有<code>filter()</code> 用于查询符合条件的数据，<code>order_by()</code>用于对查询结果进行排序，<code>reverse()</code>用于对查询结果进行反转，<code>count()</code>用于对查询结果计数等操作，</p>
<p>详见：<a href="https://www.runoob.com/django/django-orm-1.html" target="_blank" rel="noopener">https://www.runoob.com/django/django-orm-1.html</a></p>
<h3 id="Retrieving-Objects"><a href="#Retrieving-Objects" class="headerlink" title="Retrieving Objects"></a>Retrieving Objects</h3><p>现在要说怎么检索对象。</p>
<ul>
<li>all</li>
</ul>
<p><code>all</code>方法是获得所有对象的方法，<code>queryset =  Product.objects.all()</code></p>
<ul>
<li>get</li>
</ul>
<p><code>get</code> 方法则是获得特定的一个对象的方法，里面的参数 <code>pk=?</code>便是对象的位置。比如：<code>product = Product.objects.get(pk=1)</code></p>
<p>注意，序号时从1开始算起的，所以如果写了 <code>pk=0</code>,Django会报错。为了解决这个问题，我们可以使用 <code>try-catch</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    product = Product.objects.get(pk=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">except</span> ObjectDoesNotExist:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>但是在这么简单的语句中使用try-catch 有点不太美观，因此我们还可以这样写：</p>
<p><code>Product.objects.filter(pk=0).first()</code></p>
<p>首先<code>filter</code> 会进行筛选，如果条件是 <code>pk = 0</code>，那么筛选结果就是空，然后再返回<code>first()</code>, 结果就是 null，用这种方法也不会报错</p>
<ul>
<li>exists()</li>
</ul>
<p>如果想单纯判断某一个对象是否存在，可以使用<code>exists()</code></p>
<p>比如：<code>Product.objects.filter(pk=0).exists()</code></p>
<h3 id="Filtering-Objects"><a href="#Filtering-Objects" class="headerlink" title="Filtering Objects"></a>Filtering Objects</h3><p>在使用 <code>filter()</code> 时，需要传入一个 <code>key-value</code>值，因此如果我们想筛选单价大于20元的商品时，是不能输入 <code>filter(unit_price&gt;20)</code> 的</p>
<p>为了解决这个问题，Django有自己的一套语言:<a href="https://docs.djangoproject.com/en/3.2/ref/models/querysets/" target="_blank" rel="noopener">https://docs.djangoproject.com/en/3.2/ref/models/querysets/</a></p>
<p>要表达 <code>unit_price&gt;20</code> ，可以用<code>unit_price__gt=20</code> ，同样的，大于等于可以用<code>__gte</code>, 此外还有<code>lt</code>,<code>lte</code>等</p>
<p>要表达一个范围，可以用<code>__range()</code> 比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(request)</span>:</span></span><br><span class="line">    query_set = Product.objects.filter(unit_price__range=(<span class="number">20</span>,<span class="number">30</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">'hello.html'</span>,&#123;<span class="string">'name'</span>:<span class="string">'Jason'</span>,<span class="string">'products'</span>:list(query_set)&#125;)</span><br></pre></td></tr></table></figure>
<p>再通过html的修改，我们可以将筛选出的结果显示在网页上</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/32.png" style="zoom:67%;"></p>
<ul>
<li>找出包含某些特定字符的信息</li>
</ul>
<p>可以使用 contains， 比如：<code>title__icontains = &#39;coffee&#39;</code> 注意，默认是区分大小写的，如果要求不区分大小写，可以在contains前面加 <code>i</code>.</p>
<p>类似的还有 <code>__startswith</code>,<code>__endswith</code></p>
<ul>
<li>筛选日期</li>
</ul>
<p>有一个字段是 <code>last_update</code>，类型是日期，可以用<code>__year</code>来筛选特定的年份，同样还有<code>__month</code>,<code>__day</code></p>
<p>比如说`Product.objects.filter(last_update__year  = 2021) </p>
<ul>
<li>判断是否为空</li>
</ul>
<p><code>__isnull</code> 是用来判断是否为空的，比如<code>Products.objects.filter(description__isnull = True)</code> 就会筛选处description字段为空的信息</p>
<ul>
<li><h3 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h3></li>
<li><p>Customers with .com accounts </p>
</li>
</ul>
<p><code>query_set = Customer.objects.filter(email__icontains = &#39;.com&#39;)</code></p>
<ul>
<li>Collections that don’t have a featured product</li>
</ul>
<p><code>query_set = Collection.objects.filter(featured_product__isnull = True)</code></p>
<ul>
<li>Products with low inventory (less than 10)</li>
</ul>
<p><code>query_set = Product.objects.filter(inventory__lt= 10)</code> </p>
<ul>
<li>Orders placed by customer with id = 1</li>
</ul>
<p>这道题要我们选择id=1的顾客下的订单，首先要明白customer和order是由一对多关系的. 注意，这里需要使用两个下划线：<code>__</code></p>
<p><code>query_set = Order.objects.filter(customer__id= 1)</code></p>
<ul>
<li>Order items for products in collection 3</li>
</ul>
<p>这道题还是比较难的，转了两个弯，要门选择出orderitem这张表中，属于 collection 3的商品。首先，product是orderitem的外键，而collection又是product的外键所以要<code>product__collection__3</code></p>
<p><code>query_set = OrderItem.objects.filter(product__collection__id =3)</code></p>
<h3 id="Complex-Lookups-Using-Q-Objects"><a href="#Complex-Lookups-Using-Q-Objects" class="headerlink" title="Complex Lookups Using Q Objects"></a>Complex Lookups Using Q Objects</h3><p>如果我想多条件查询，又该怎么办？</p>
<ul>
<li>实现 AND</li>
</ul>
<p>其中一种是用逗号分割查询条件：</p>
<p><code>queryset = Product.objects.filter(inventory__lt = 10,unit_price__lt = 20)</code></p>
<p>此外还有一种链式的filter写法，比如说：</p>
<p><code>queryset = Product.objects.filter(inventory__lt = 10).filter(unit_price__lt = 20)</code></p>
<ul>
<li>实现 OR</li>
</ul>
<p>要实现或查询(Q也可以用于与查询)，那么需要使用Q object，首先要引入 <code>from django.db.models import Q</code></p>
<p>Q()对象就是为了将这些条件组合起来。当我们在查询的条件中需要组合条件时(例如两个条件“且”或者“或”)时。我们可以使用Q()查询对象。 比如说：</p>
<p><code>query_set = Product.objects.filter(Q(inventory__lt=10)| Q(unit_price__lt=20))</code></p>
<p>这时候，我们可以用<code>&amp;、|、~</code> 这些符号来筛选符合条件的数据了。</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/33.png" style="zoom:67%;"></p>
<h3 id="Referencing-Fields-using-F-Objects"><a href="#Referencing-Fields-using-F-Objects" class="headerlink" title="Referencing Fields using F Objects"></a>Referencing Fields using F Objects</h3><p>F对象主要用于模型类的 A 字段属性与 B 字段属性两者的比较，即操作数据库中某一列的值。通常是对数据库中的字段值在不获取的情况下进行操作。F 对象内置在数据包<code>django.db.models</code>中，所以使用时需要提前导入。如下所示：<code>from django.db.models import F</code></p>
<p>在使用F对象进行查询的时候需要注意：一个 F() 对象代表了一个 Model 的字段的值；F 对象可以在没有实际访问数据库获取数据值的情况下对字段的值进行引用。</p>
<p>比如说我要对单列的所有制进行操作，统统加上20，可以这么写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> F</span><br><span class="line"><span class="keyword">from</span> index.models <span class="keyword">import</span> Book </span><br><span class="line"><span class="comment">#给Book所有实例价格（retail_price）涨价20元 </span></span><br><span class="line">Book.objects.all().update(retail_price=F(<span class="string">'retail_price'</span>)+<span class="number">20</span>) <span class="comment">#获取该列所有值并加20</span></span><br><span class="line"><span class="comment">#利用传统的方法实现涨价20元</span></span><br><span class="line">books = models.Book.objects.all() </span><br><span class="line"><span class="keyword">for</span> book <span class="keyword">in</span> books:     </span><br><span class="line">    book.update(retail_price=book.retail_price+<span class="number">20</span>)     </span><br><span class="line">    book.save()</span><br></pre></td></tr></table></figure>
<p>此外F对象还可以实现两个字段值(两列)之间的比较，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对数据库中两个字段的值进行比较，列出哪儿些书的零售价高于定价 </span></span><br><span class="line">books = Book.objects.filter(retail_price__gt=F(<span class="string">'price'</span>)) </span><br><span class="line"><span class="keyword">for</span> book <span class="keyword">in</span> books: </span><br><span class="line">    print(book.title, <span class="string">'定价:'</span>, book.price, <span class="string">'现价:'</span>, book.retail_price)</span><br></pre></td></tr></table></figure>
<h3 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a>Sorting</h3><ul>
<li>要对筛选出的结果进行排序，需要用到 <code>order_by</code> ，比如说：</li>
</ul>
<p><code>queryset = Product.objects.order_by(&#39;title&#39;)</code>  就会按照字母表顺序进行排列。来看看Django自动生成的SQL语句：</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/34.png" style="zoom:67%;"></p>
<ul>
<li><p>如果要倒排的话，只要在参数前面加一个 负号即可 <code>-</code> ，如：<code>queryset = Product.objects.order_by(&#39;-title&#39;)</code>  </p>
<ul>
<li>还有一种倒排的方法，就是在正常排序后加上<code>.reverse()</code>即可</li>
</ul>
</li>
<li><p>也可以设置多个排列参数，按照优先级在括号内依次传入多个参数即可。如：<code>queryset = Product.objects.order_by(&#39;unit_price&#39;,&#39;-title&#39;)</code>  </p>
</li>
</ul>
<blockquote>
<p>需要注意，<code>order_by()</code> 和<code>filter()</code>一样，返回的是一个 queryset，是可以被索引被迭代的</p>
<p>因此，我们可以用 <code>Product.objects.order_by(&#39;unit_price&#39;)[0]</code> 来获得第一个对象。其实，有一种更简单的方法，即<code>Product.objects.earliest(&#39;unit_price&#39;)</code> 也会返回单价最低的一个对象；当然，也有<code>latest()</code> 来获取单价最高的对象。</p>
</blockquote>
<h3 id="Limiting-Results"><a href="#Limiting-Results" class="headerlink" title="Limiting Results"></a>Limiting Results</h3><p>比如一个页面中最多显示5条信息，那么我们怎么对其进行限制呢？其实在python语法中这很简单：</p>
<p><code>queryset = Products.objects.all()[:5]</code> 是返回表中前五条信息</p>
<p><code>queryset = Products.objects.all()[5:10]</code> 是返回表中第6-10条信息</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/35.png" style="zoom:67%;"></p>
<h3 id="Selecting-Fields-to-Query"><a href="#Selecting-Fields-to-Query" class="headerlink" title="Selecting Fields to Query"></a>Selecting Fields to Query</h3><p>对于Product表格，我们想返回其title和description，那么用什么来选中特定的字段呢？<code>value()</code> ，这个方法会以字典的形式返回字段名和值。如下所示：</p>
<p><code>query_set = Product.objects.values(&#39;title&#39;,&#39;description&#39;)</code></p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/36.png" style="zoom:67%;"></p>
<p>此外，还可以显示关联表的字段，比如 collection是product 的外键，要筛选collection中的title字段可以这样写</p>
<p><code>query_set = Product.objects.values(&#39;title&#39;,&#39;collection__title&#39;)</code></p>
<p>sql语句如下：</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/37.png" style="zoom:67%;"></p>
<p>将html修改成打印整个product对象后，如下图所示</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/38.png" style="zoom:67%;"></p>
<p>如果我将<code>value()</code>换成<code>value_list()</code>，则会返回元组形式的对象，如下：</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/39.png" style="zoom:67%;"></p>
<blockquote>
<p>注意，value或者value list，会返回字段的值，只是表现的形式不同；</p>
<p>filter,order_by 则是对所有字段进行筛选并返回对象实例</p>
</blockquote>
<p>小测验：</p>
<ul>
<li>Select products  that have been ordered and sort them by title</li>
</ul>
<p>首先，订单中订购的产品都在 <code>OrderItem</code>表格中，里面的<code>product_id</code>就是订购的商品的编号。我们要将其筛选出来。订单可能有重复的商品，因此要用 <code>.distinct</code></p>
<p><code>OrderItem.objects.values(&#39;product__id&#39;).distinct()</code></p>
<p>然后，我们要用这些id找到product的名字：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Product.objects.filter(</span><br><span class="line">	 id__in = OrderItem.objects.values(<span class="string">'product__id'</span>).distinct()</span><br><span class="line">).order_by(<span class="string">'title'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Only-And-Defer"><a href="#Only-And-Defer" class="headerlink" title="Only() And Defer()"></a>Only() And Defer()</h3><p>那么有没有办法即返回对象，有能够对特定的列进行筛选呢？ 这种方法就是<code>only()</code></p>
<p>比如： <code>query_set = Product.objects.only(&#39;id&#39;,&#39;title&#39;)</code></p>
<p>特别要注意的是， 如果用到only在循环取值是最好是选择only中的列，否则将会再执行一次查询，效率很差 </p>
<p>比如我在 html中这么渲染：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      &#123;% for product in products %&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; product.title &#125;&#125; $&#123;&#123; product.unit_price&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>unit_price</code> 并没有在only中出现过，因此当要渲染<code></code>时，django会再次去mysql中查询，导致渲染一条信息就要多查一次，非常非常慢。</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/40.png" style="zoom:67%;"></p>
<blockquote>
<p>所以在渲染时一定要选中only中出现的列！</p>
</blockquote>
<p>和<code>only()</code>恰恰相反的是<code>defer()</code>， <code>defer()</code>中的字段名在sql查询时会被排除，只选择剩下的列。所以当我们在渲染时出现defer中的字段时，效率也会非常的差。</p>
<h3 id="Selecting-Related-Objects"><a href="#Selecting-Related-Objects" class="headerlink" title="Selecting Related Objects"></a>Selecting Related Objects</h3><p>有些时候我们不仅仅只引入一张表的内容，我们想要搜寻出与其相关的表的内容。 </p>
<p>比如说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># view.py</span><br><span class="line">query_set &#x3D; Product.objects.all()</span><br><span class="line"></span><br><span class="line"># hello.html</span><br><span class="line">&#123;% for product in products %&#125;</span><br><span class="line">&lt;li&gt;&#123;&#123; product.title &#125;&#125;-&#123;&#123;product.collection.title&#125;&#125;&lt;&#x2F;li&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>
<p>但如果这么写，会导致对于每一条数据，django都会去数据库中搜寻信息，效率会非常慢。怎么解决呢？</p>
<p>对于1对多的关系，比如说product只能属于一个collection，我们可以用<code>select_related</code>，它帮你直接连表操作、查询数据,括号内只能放外键字段。比如上面这个例子中要引用相关的collection数据表，则可以写如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queryset = Product.objects.selected_related(<span class="string">'collection'</span>).all()</span><br></pre></td></tr></table></figure>
<p>等于说现在这行代码就把两张表都预载了。</p>
<p>那么对于多对多字段，你不能使用select_related方法，这样做是为了避免对多对多字段执行JOIN操作从而造成最后的表非常大。Django提供了prefect_related方法来解决这个问题。prefect_related可用于<strong>多对多</strong>关系字段，也可用于反向外键关系(related_name)。 </p>
<p>比如说 product 和 promotion之间的关系是多对多的，在定义model时，对promotions使用的是<code>ManyToManyField()</code> </p>
<p>prefetch_related使用方法如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query_set = Product.objects.prefetch_related(<span class="string">'promotions'</span>).all()</span><br></pre></td></tr></table></figure>
<p>sql执行结果如下：</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/41.png" style="zoom:67%;"></p>
<p>此外，select_related 和 prefetch_related 可以连用，用来连接多张表格。比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">query_set = Product.objects</span><br><span class="line">						.prefetch_related(<span class="string">'promotions'</span>)</span><br><span class="line">						.select_related(<span class="string">'collection'</span>).all()</span><br></pre></td></tr></table></figure>
<h4 id="小练习-1"><a href="#小练习-1" class="headerlink" title="小练习"></a>小练习</h4><p>Get the last 5 orders with their customer and items(including product)</p>
<p>列出最后下单的5个订单以及对应的客户和商品</p>
<p>首先，我们要了解model，customer是Order中的外键，而order又是OrderItem的外键，要筛选出订单对应的顾客很简单，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query_set = Order.objects.select_related(<span class="string">'customer'</span>).order_by(<span class="string">'-placed_at'</span>)[:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p>但是要“反向使用外键”就比较困难，我们要知道，当我们设order为OrderItem的外键时，同时也设置了一个反向外键名为<code>orderitem_set</code> ,如果我们觉得这个名字不好，可以再定外键的时候额外使用<code>related_name</code>属性修改。然后使用<code>prefetch_related()</code>如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">query_set = Order.objects</span><br><span class="line">            .select_related(<span class="string">'customer'</span>)</span><br><span class="line">            .prefetch_related(<span class="string">'orderitem_set__product'</span>)</span><br><span class="line">            .order_by(<span class="string">'-placed_at'</span>)[:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/42.png" style="zoom:67%;"></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>当你查询单个主对象或主对象列表并需要在模板或其它地方中使用到每个对象的关联对象信息时，请一定记住使用select_related和prefetch_related一次性获取所有对象信息，从而提升数据库查询效率，避免重复查询。如果不确定是否有重复查询，可使用django-debug-toolbar查看。</p>
<p>对与单对单或单对多外键ForeignKey字段，使用select_related方法</p>
<p>对于多对多字段和反向外键关系，使用prefetch_related方法</p>
<p>两种方法均支持双下划线指定需要查询的关联对象的字段名</p>
<p>使用Prefetch方法可以给prefetch_related方法额外添加额外条件和属性。 </p>
<h3 id="Aggregating-Objects"><a href="#Aggregating-Objects" class="headerlink" title="Aggregating Objects"></a>Aggregating Objects</h3><p>现在我们想要计算一列值中的最大值或者平均值，就需要用到聚合函数了</p>
<p><code>aggregate()</code>中有很多“子函数”</p>
<p>首先可以导入：</p>
<p><code>from django.db.models.aggregates import *</code></p>
<ul>
<li>Count() </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = Product.objects.aggregate(Count(<span class="string">'id'</span>))</span><br></pre></td></tr></table></figure>
<p>如果要命名计算得到的列，可以这么写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = Product.objects.aggregate(count = Count(<span class="string">'id'</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>Min()</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = Product.objects.aggregate(min_price = Min(<span class="string">'unit_price'</span>))</span><br></pre></td></tr></table></figure>
<p>此外还可以与<code>filter()</code>联合使用，能聚合某一范围的信息。</p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>Write code to answer the following questions: </p>
<ul>
<li>How many orders do we have?</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = Order.objects.aggregate(Count(<span class="string">'id'</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>How many units of product 1 have we sold?</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = OrderItem.objects.filter(product__id=<span class="number">1</span>).aggregate(units_sold = Sum(<span class="string">'quantity'</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li><p>How many orders has customer 1 placed?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = Order.objects.filter(customer__id=<span class="number">1</span>).aggregate(total_order = Count(<span class="string">'id'</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>What is the min, max and average price of the products in collection 3?</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = Product.objects</span><br><span class="line">					.filter(collection__id = <span class="number">3</span>)</span><br><span class="line">  				.aggregate(min_price = Min(<span class="string">'unit_price'</span>),</span><br><span class="line">                     max_price = Max(<span class="string">'unit_price'</span>),</span><br><span class="line">                     avg_price = Avg(<span class="string">'unit_price'</span>))</span><br></pre></td></tr></table></figure>
<h3 id="Annotating-Objects"><a href="#Annotating-Objects" class="headerlink" title="Annotating Objects"></a>Annotating Objects</h3><p>我们之前学了Java中的 annotation,其实在Django中我们也可以用某种方法给对象打标签，如：</p>
<ul>
<li>```python<br>from django.db.models import Value<br>queryset = Customer.objects.annotate(is_new = Value(True))<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 我们不能直接传入布尔值，而要传入一个表达式, 因此要用&#96;Value(True)&#96;</span><br><span class="line"></span><br><span class="line">我们看到数据库中已经有新的列(is_new)了</span><br><span class="line"></span><br><span class="line">&lt;img src&#x3D;&quot;.&#x2F;Django学习1&#x2F;43.png&quot; style&#x3D;&quot;zoom:67%;&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">需要注意的是，这只是”暂时”的修改，数据库中并没有改动。</span><br><span class="line"></span><br><span class="line">+</span><br></pre></td></tr></table></figure>
from django.db.models import F<br>queryset = Customer.objects.annotate(is_new = F(‘id’))<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">同样的，可以用 F object 来创造一个与现有列一模一样的新列</span><br><span class="line"></span><br><span class="line">+ &#96;&#96;&#96;python</span><br><span class="line">  queryset &#x3D; Customer.objects.annotate(is_new &#x3D; F(&#39;id&#39;)+1)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>还可以对新列进行数值上的运算之类的操作。</p>
<h3 id="Calling-Database-Functions"><a href="#Calling-Database-Functions" class="headerlink" title="Calling Database Functions"></a>Calling Database Functions</h3><p>现在我们来介绍一下怎么在Django里面调用 mysql 提供的一些数据库函数，比如 Concat(字段连接)，Trunc(字段截取)等</p>
<p>我们在view中可以这样写，一共两种方法：</p>
<ol>
<li>第一种方法是导入Func类，然后在函数内部定义要调用的数据库函数类型，这里使用的是Concat(拼接函数)。要注意，两类拼接如果中间需要用空格隔开的话，需要使用<code>Value(&#39; &#39;)</code>,不能直接用<code>(&#39; &#39;)</code></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Value, F, Func</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(request)</span>:</span></span><br><span class="line">    query = Customer.objects.annotate(</span><br><span class="line">        <span class="comment"># CONCAT</span></span><br><span class="line">        full_name=Func(F(<span class="string">'first_name'</span>), Value(</span><br><span class="line">            <span class="string">' '</span>), F(<span class="string">'last_name'</span>), function=<span class="string">'CONCAT'</span>)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/44.png" style="zoom:67%;"></p>
<ol>
<li>第二种方法更加简单，在导入时就导入Concat函数，不需要在函数使用时确定函数类型</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models.functions <span class="keyword">import</span> Concat</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(request)</span>:</span></span><br><span class="line">    queryset = Customer.objects.annotate(</span><br><span class="line">        <span class="comment"># CONCAT</span></span><br><span class="line">        full_name=Concat(<span class="string">'first_name'</span>, Value(<span class="string">' '</span>), <span class="string">'last_name'</span>)</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'hello.html'</span>, &#123;<span class="string">'name'</span>: <span class="string">'Jason'</span>, <span class="string">'queryset'</span>: list(queryset)&#125;)</span><br></pre></td></tr></table></figure>
<p>更多Database Funtion可以参考Django官方文档：</p>
<p><a href="https://docs.djangoproject.com/en/3.2/ref/models/database-functions/" target="_blank" rel="noopener">https://docs.djangoproject.com/en/3.2/ref/models/database-functions/</a></p>
<h3 id="Grouping-Data"><a href="#Grouping-Data" class="headerlink" title="Grouping Data"></a>Grouping Data</h3><p>现在我们要计算一下每个人下的订单数量，该怎么办？</p>
<p>我们知道 Customer和Order是一对多的关系，customer是order的外键。这时候虽然数据库里Customer表格没有Order这个字段，但是Django models已经为我们创建了一个反向关系，我们使用Count函数就可以直接计算Order的数量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(request)</span>:</span></span><br><span class="line">    queryset = Customer.objects.annotate(</span><br><span class="line">        orders_count=Count(<span class="string">'order'</span>)</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'hello.html'</span>, &#123;<span class="string">'name'</span>: <span class="string">'Jason'</span>, <span class="string">'queryset'</span>: list(queryset)&#125;)</span><br></pre></td></tr></table></figure>
<p>通过Django生成的SQL语句，发现可以自动将customer和order两张表做连接</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/45.png" style="zoom:67%;"></p>
<h3 id="Working-with-Expression-Wrappers"><a href="#Working-with-Expression-Wrappers" class="headerlink" title="Working with Expression Wrappers"></a>Working with Expression Wrappers</h3><p>现在我们已经学习了Django中的 Value(表达布尔值、字符串等)、F(多列操作)、Func(数据库函数)，Aggregate(聚合函数)，它们都属于Expression类</p>
<p>现在我们来介绍另一种函数：ExpressionWrappers</p>
<p>当我们使用到一些复杂的表达式的时候，可能会涉及到数据格式的问题.比如说，我要新建一列：</p>
<p><code>queryset = Customer.objects.annotate(discount_price= F(&#39;unit_price&#39;)*0.8)</code> </p>
<p>这在Django系统中是会报错的，因为这个表达式中包含了多种类型的数据：unit_price是DecimalField而0.8是FloatField，这时候就需要用ExpressionWrappers来规定一下<code>output_field</code>来让输出结果统一了，一般我们要表示小数的时候都会选择<code>DecimalField()</code>，因其更准确</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(request)</span>:</span></span><br><span class="line">    discount_price = ExpressionWrapper(</span><br><span class="line">        F(<span class="string">'unit_price'</span>)*<span class="number">0.8</span>, output_field=DecimalField())</span><br><span class="line">    queryset = Customer.objects.annotate(discount_price=discount_price)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'hello.html'</span>, &#123;<span class="string">'name'</span>: <span class="string">'Jason'</span>, <span class="string">'queryset'</span>: list(queryset)&#125;)</span><br></pre></td></tr></table></figure>
<p>生成的URL如下：</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/46.png" style="zoom:67%;"></p>
<h3 id="Annotating-Exercises"><a href="#Annotating-Exercises" class="headerlink" title="Annotating Exercises"></a>Annotating Exercises</h3><p>Write code to get: </p>
<ul>
<li>Customers with their last order ID</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = Customer.objects.annotate(last_order_ID = Max(<span class="string">'order__id'</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>Collections and count of their products </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = Collection.objects.annotate(</span><br><span class="line">	products_count = Count(<span class="string">'product'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>Customers with more than 5 orders </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = Customer.objects\</span><br><span class="line">.annotate(</span><br><span class="line">	orders_count = Count(<span class="string">'product'</span>)</span><br><span class="line">)</span><br><span class="line">.filter(orders_count__gt=<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>Customers and the total amount they’ve spent </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result = Customer.objects.annotate(</span><br><span class="line">	total_spent = Sum(</span><br><span class="line">		F(<span class="string">'order__orderitem__unit_price'</span>)*</span><br><span class="line">		F(<span class="string">'order__orderitem__quantity'</span>)</span><br><span class="line">	)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>Top 5 best-selling products and their total sales Solutions are on the next page. </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">result = Customer.objects\</span><br><span class="line">.annotate(</span><br><span class="line">	total_spent = Sum(</span><br><span class="line">		F(<span class="string">'order__orderitem__unit_price'</span>)*</span><br><span class="line">		F(<span class="string">'order__orderitem__quantity'</span>)</span><br><span class="line">	)</span><br><span class="line">)</span><br><span class="line">.order_by(<span class="string">'-total_spent'</span>)[:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<h3 id="Querying-Generic-Relationships"><a href="#Querying-Generic-Relationships" class="headerlink" title="Querying Generic Relationships"></a>Querying Generic Relationships</h3><h3 id="Custom-Managers"><a href="#Custom-Managers" class="headerlink" title="Custom Managers"></a>Custom Managers</h3><h3 id="Understanding-QuerySet-Cache"><a href="#Understanding-QuerySet-Cache" class="headerlink" title="Understanding QuerySet Cache"></a>Understanding QuerySet Cache</h3><p>我们要善用 QuertSet Cache，这可以大大节省去数据库访问的时间。比如说：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(request)</span>:</span></span><br><span class="line">    queryset = Product.objects.all()</span><br><span class="line">    list(queryset)</span><br><span class="line">    list(queryset)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'hello.html'</span>, &#123;<span class="string">'name'</span>: <span class="string">'Jason'</span>, <span class="string">'queryset'</span>: list(queryset)&#125;)</span><br></pre></td></tr></table></figure>
<p>就相当于我们把数据库的数据都放在queryset这个缓存中了，之后用就不需要再去数据库查询了。</p>
<p>但是我们也要注意在某些情况下并不会访问缓存：</p>
<ul>
<li>重复获取queryset中一个特定的索引，将每次都查询数据库</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">queryset = Entry.objects.all()</span><br><span class="line"><span class="keyword">print</span> queryset[<span class="number">5</span>] <span class="comment"># Queries the database</span></span><br><span class="line"><span class="keyword">print</span> queryset[<span class="number">5</span>] <span class="comment"># Queries the database again</span></span><br></pre></td></tr></table></figure>
<ul>
<li>简单地打印查询集不会填充缓存</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">queryResult=models.Article.objects.all()</span><br><span class="line">print(queryResult) <span class="comment">#  hits database</span></span><br><span class="line">print(queryResult)</span><br></pre></td></tr></table></figure>
<h3 id="Creating-Objects"><a href="#Creating-Objects" class="headerlink" title="Creating Objects"></a>Creating Objects</h3><p>上面所说的都是对数据库的查询操作，现在我们来学习如何向数据库插入(增)数据</p>
<p>首先我们新创建一个 Collection对象，然后依次设定其字段</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(request)</span>:</span></span><br><span class="line">    collection = Collection()</span><br><span class="line">    collection.title = <span class="string">'Video Games'</span></span><br><span class="line">    collection.featured_product = Product(pk=<span class="number">1</span>)</span><br><span class="line">    collection.save()</span><br></pre></td></tr></table></figure>
<p>还有另外一种方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">collection = Collection.objects.create(title = <span class="string">'a'</span>,featured_product_id=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>但是这样的方法虽然简单但并不推荐，因为可以用<code>.</code>来轻易获得一个model对象中的属性，而用<code>create</code>是无法实现的，不太方便</p>
<p>执行效果如下：</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/47.png"></p>
<h3 id="Updating-Objects"><a href="#Updating-Objects" class="headerlink" title="Updating Objects"></a>Updating Objects</h3><p>对数数据库中一行的更新，我们一个很朴素的想法就是先筛选出来，再修改想要的字段值</p>
<p>但是我们不能这么写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(request)</span>:</span></span><br><span class="line">    collection = Collection(pk=<span class="number">12</span>)</span><br><span class="line">    collection.featured_product = <span class="literal">None</span></span><br><span class="line">    collection.save()</span><br></pre></td></tr></table></figure>
<p>因为这样Django会误认为你是对所有的字段都要进行修改。我们这里不想修改title，但是Django会认为我们是想将其置为空字符串。</p>
<p>因此，我们要用<code>get</code>函数先获取到目标对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(request)</span>:</span></span><br><span class="line">    collection = Collection.objects.get(pk=<span class="number">12</span>)</span><br><span class="line">    collection.featured_product = <span class="literal">None</span></span><br><span class="line">    collection.save()</span><br></pre></td></tr></table></figure>
<p>还可以使用这种方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">collection.objects</span><br><span class="line">	.filter(pk=<span class="number">11</span>)</span><br><span class="line">  .update(featured_product=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/48.png"></p>
<h3 id="Deleting-Objects"><a href="#Deleting-Objects" class="headerlink" title="Deleting Objects"></a>Deleting Objects</h3><p>删除数据是比较简单的，也有两种方法：</p>
<p>第一种：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(request)</span>:</span></span><br><span class="line">    collection = Collection.get(pk=<span class="number">12</span>)</span><br><span class="line">    collection.delete()</span><br></pre></td></tr></table></figure>
<p>第二种：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection.objects.filter(id__gt=<span class="number">5</span>).delete()</span><br></pre></td></tr></table></figure>
<h3 id="Transactions"><a href="#Transactions" class="headerlink" title="Transactions"></a>Transactions</h3><p>现在我们来用Django来创建事务。也就是如果不能执行成功，就需要回滚到未执行的状态。</p>
<p>要让一段代码称为一个事务，我们可以用<code>with transaction.atomic()</code>来包裹：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> transaction</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(request)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> transaction.atomic():</span><br><span class="line">        order = Order()</span><br><span class="line">        order.customer_id = <span class="number">1</span></span><br><span class="line">        order.save()</span><br><span class="line"></span><br><span class="line">        item = OrderItem()</span><br><span class="line">        item.order = order</span><br><span class="line">        item.product_id = <span class="number">1</span></span><br><span class="line">        item.quantity = <span class="number">1</span></span><br><span class="line">        item.unit_price = <span class="number">10</span></span><br><span class="line">        item.save()</span><br></pre></td></tr></table></figure>
<p>当然如果我们要对整个view function进行事务级别的包裹，我们可以使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@transaction.atomic()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(request)</span>:</span></span><br><span class="line">	<span class="comment">#....</span></span><br></pre></td></tr></table></figure>
<h3 id="Executing-Raw-SQL-Queries"><a href="#Executing-Raw-SQL-Queries" class="headerlink" title="Executing Raw SQL Queries"></a>Executing Raw SQL Queries</h3><p>最后，我们来学习如何在Django中执行原生SQL查询</p>
<p>一种是使用raw函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(request)</span>:</span></span><br><span class="line">    queryset = Product.objects.raw(<span class="string">'SELECT * FROM store_product'</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'hello.html'</span>, &#123;<span class="string">'name'</span>: <span class="string">'Jason'</span>, <span class="string">'result'</span>: list(queryset)&#125;)</span><br></pre></td></tr></table></figure>
<p>还有一种是使用<code>cursor</code>对象来执行任意sql语句</p>
<p>因为在使用cursor之后，需要手动用<code>close()</code>函数关闭连接，因此我们可以用<code>with connection.cursor()</code>来包裹住要执行的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> connection</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(request)</span>:</span></span><br><span class="line">		<span class="keyword">with</span> connection.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">			cursor.execute(<span class="string">'something'</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> render(request, <span class="string">'hello.html'</span>, &#123;<span class="string">'name'</span>: <span class="string">'Jason'</span>, <span class="string">'result'</span>: list(queryset)&#125;)</span><br></pre></td></tr></table></figure>
<p>此外，还可以用<code>cursor.callproc()</code>来执行mysql中已经存在的procedure</p>
<p>但是我们没有必要使用原生SQL进行查询，只有当原生查询比ORM中的函数更加简单的时候，才建议使用。</p>
<h2 id="The-Admin-Site"><a href="#The-Admin-Site" class="headerlink" title="The Admin Site"></a>The Admin Site</h2><h3 id="Setting-Up-the-Admin-Site"><a href="#Setting-Up-the-Admin-Site" class="headerlink" title="Setting Up the Admin Site"></a>Setting Up the Admin Site</h3><p>首先我们要在 settings中的 INSTALLED_APPS中添加sessions 应用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">		<span class="comment">#	...</span></span><br><span class="line">    <span class="string">'django.contrib.sessions'</span>,</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>添加以后，需要进行migrate</p>
<p>然后我们要在终端设置管理员信息，用<code>python manage.py createsuperuser</code>来创建：</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/49.png"></p>
<p>保存后，我们可以通过<code>http://localhost:9000/admin/</code> 进入管理后台</p>
<p>如果要修改密码，可以使用<code>python manage.py changepassword admin</code>修改</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/50.png"></p>
<p>此外，我们还可以修改<code>Django administration</code>和<code>Site administration</code>这两个字段值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">admin.site.site_header = <span class="string">'Storefront Admin'</span></span><br><span class="line">admin.site.index_title = <span class="string">'Admin'</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/51.png"></p>
<h3 id="Registering-Models"><a href="#Registering-Models" class="headerlink" title="Registering Models"></a>Registering Models</h3><p>我们可以在admin后台直接查看 model 的相关信息。</p>
<p>在每一个 app 中有一个<code>admin.py</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> models</span><br><span class="line"><span class="comment"># Register your models here.</span></span><br><span class="line">admin.site.register(models.Collection)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/52.png"></p>
<p>但是，我们只能看到每个collection的编号，一个理想的状态是我们可以直接看到每个collection的title是什么，否则不太直观，我们需要做如下改动</p>
<p>我们要对<code>__str__</code>这个函数进行一个重写，起作用就是一个对象到字符串的映射，默认的是 <code>return  super().__str__()</code>  也就是上面看到的<code>Collection object(i)</code>,现在我让其返回<code>self.title</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    featured_product = models.ForeignKey(</span><br><span class="line">        <span class="string">'Product'</span>, on_delete=models.SET_NULL, null=<span class="literal">True</span>, related_name=<span class="string">'+'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> self.title</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/53.png"></p>
<p>还有，我们发现这10个Collection是杂乱无章的排序的，我们可以用Meta类来排序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    title = models.CharField(max_length=<span class="number">255</span>)</span><br><span class="line">    featured_product = models.ForeignKey(</span><br><span class="line">        <span class="string">'Product'</span>, on_delete=models.SET_NULL, null=<span class="literal">True</span>, related_name=<span class="string">'+'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> self.title</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        ordering = [<span class="string">'title'</span>]</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/54.png"></p>
<h3 id="Customizing-the-List-Page"><a href="#Customizing-the-List-Page" class="headerlink" title="Customizing the List Page"></a>Customizing the List Page</h3><p>现在我们想给上面显示出来的表格多添加几列。</p>
<p>一种简单的方法就是创建一个<code>ProductAdmin</code>类，并在里面确定<code>list_display</code>属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class ProductAdmin(admin.ModelAdmin):</span><br><span class="line">    list_display &#x3D; [&#39;title&#39;,&#39;unit_price&#39;]</span><br><span class="line"></span><br><span class="line">admin.site.register(models.Product,ProductAdmin)</span><br></pre></td></tr></table></figure>
<p>当然，我们也可以使用 @ 来修饰：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@admin.register(models.Product)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    list_display = [<span class="string">'title'</span>,<span class="string">'unit_price'</span>]</span><br></pre></td></tr></table></figure>
<p>这种方式更简单，还不需要我们再注册，因为已经在@中注册了</p>
<p>此外，我们还可以对列开启修改功能, 也就是定义<code>list_editable</code>属性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@admin.register(models.Product)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    list_display = [<span class="string">'title'</span>,<span class="string">'unit_price'</span>]</span><br><span class="line">    list_editable = [<span class="string">'unit_price'</span>]</span><br></pre></td></tr></table></figure>
<p>规定每页的行数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@admin.register(models.Product)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    list_display = [<span class="string">'title'</span>,<span class="string">'unit_price'</span>]</span><br><span class="line">    list_editable = [<span class="string">'unit_price'</span>]</span><br><span class="line">    list_per_page = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/55.png" style="zoom: 50%;"></p>
<p>也可以在这里定义排序字段：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@admin.register(models.Product)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    list_display = [<span class="string">'title'</span>,<span class="string">'unit_price'</span>]</span><br><span class="line">    ordering = [<span class="string">'title'</span>]</span><br><span class="line">    list_editable = [<span class="string">'unit_price'</span>]</span><br><span class="line">    list_per_page = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<h3 id="Adding-Computed-Columns"><a href="#Adding-Computed-Columns" class="headerlink" title="Adding Computed Columns"></a>Adding Computed Columns</h3><p>现在我们要在products中添加一列Inventory，即库存。但是我们又不想直接显示库存的多少，而希望用low,ok来表示。怎么办？</p>
<p>我们可以自己创建一列，然后用一个mapper渲染上去，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@admin.register(models.Product)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    list_display = [<span class="string">'title'</span>,<span class="string">'unit_price'</span>,<span class="string">'inventory_status'</span>]</span><br><span class="line">    list_editable = [<span class="string">'unit_price'</span>]</span><br><span class="line">    list_per_page = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @admin.display(ordering='inventory')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inventory_status</span><span class="params">(self,product)</span>:</span></span><br><span class="line">        <span class="keyword">if</span>(product.inventory&lt;<span class="number">10</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'Low'</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'OK'</span></span><br></pre></td></tr></table></figure>
<p>在这里，我新建了一个<code>inventory_status</code> 的列，然后在下面我们创建一个函数来对该列进行一个映射：</p>
<p>因为这不是数据库内原生的列，因此如果我们设定排序字段的话Django是不会提供排序接口的。因此我们要在这个函数前面加上修饰<code>@admin.display(ordering=&#39;inventory&#39;)</code>,也就是说这列是根据inventory的大小排序的</p>
<h3 id="Selecting-Related-Objects-1"><a href="#Selecting-Related-Objects-1" class="headerlink" title="Selecting Related Objects"></a>Selecting Related Objects</h3><p>如果我要把该表的外键字段加进来，又该怎么解决呢?</p>
<p>比如说我想在Product表格中把它属于的Collection加进来，我们可以新建一列<code>collection_title</code>然后为其创建mapper，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    list_display = [<span class="string">'title'</span>,<span class="string">'unit_price'</span>,<span class="string">'inventory_status'</span>,<span class="string">'collection_title'</span>]</span><br><span class="line">    list_per_page = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">collection_title</span><span class="params">(self,product)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> product.collection.title</span><br></pre></td></tr></table></figure>
<p>但是这样会导致查询性能低的情况：</p>
<p>因为Django会为表中每行数据创建一条SQL查询语句</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/56.png" style="zoom: 50%;"></p>
<p>我们可以用这样一行代码来规避这些冗余的查询：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    list_display = [<span class="string">'title'</span>,<span class="string">'unit_price'</span>,<span class="string">'inventory_status'</span>,<span class="string">'collection_title'</span>]</span><br><span class="line">    list_per_page = <span class="number">10</span></span><br><span class="line">    list_select_related = [<span class="string">'collection'</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">collection_title</span><span class="params">(self,product)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> product.collection.title</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/57.png" style="zoom: 50%;"></p>
<p>这样，只需要执行一条SQL查询即可</p>
<p>当然，我们也可以直接在<code>list_display</code>中直接写外键相关的表的名字,比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@admin.register(models.Order)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    list_per_page = <span class="number">10</span></span><br><span class="line">    list_display = [<span class="string">'id'</span>,<span class="string">'placed_at'</span>,<span class="string">'customer'</span>]</span><br></pre></td></tr></table></figure>
<p>但是，我们还是要重写<code>__str__</code> 函数，让其返回客户的全名：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f'<span class="subst">&#123;self.first_name&#125;</span> <span class="subst">&#123;self.last_name&#125;</span>'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">    ordering = [<span class="string">'first_name'</span>,<span class="string">'last_name'</span>]</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/58.png" style="zoom: 50%;"></p>
<h3 id="Overriding-the-Base-QuerySet"><a href="#Overriding-the-Base-QuerySet" class="headerlink" title="Overriding the Base QuerySet"></a>Overriding the Base QuerySet</h3><p>现在我们要在Collection表格中新建一列，用来查询每个Collection一共有多少件Products</p>
<p>Collection和Products相当于一对多的关系, 有外键相连，因此可以通过Count来计算各个类别中的产品数量</p>
<p>首先新建一列<code>products_count</code>,然后创建一个函数让其返回<code>collection.products_count</code></p>
<p>但是我们知道Collection表格中并没有这一列，因此用默认的sql是查询不到结果的，因此我们要重写默认查询。使用到的工具就是<code>get_queryset</code>函数。在这个函数中，我们首先继承默认的<code>get_queryset</code>函数，然后将其返回的<code>products_count</code>改为对product数量的查询，也就是<code>Count(product)</code></p>
<p>最后，还要定义一下排序索引，即<code>@admin.display(ordering=&#39;products_count&#39;)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@admin.register(models.Collection)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    list_display = [<span class="string">'title'</span>,<span class="string">'products_count'</span>]</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @admin.display(ordering='products_count')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">products_count</span><span class="params">(self,collection)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> collection.products_count</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> super().get_queryset(request).annotate(</span><br><span class="line">            products_count = Count(<span class="string">'product'</span>)</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<p>注意，这个<code>@admin.display(ordering=&#39;&#39;)</code> 一定要修饰和列名一样的哪个函数，否则会不起作用。这里，要修饰<code>products_count</code></p>
<h3 id="Providing-Links-to-Other-Pages"><a href="#Providing-Links-to-Other-Pages" class="headerlink" title="Providing Links to Other Pages"></a>Providing Links to Other Pages</h3><p>现在我想点击 Collection中的<code>products_count</code>列，就跳到Product页面,并筛选出这个Collection中的产品信息。</p>
<p>我们一步一步来，首先要将<code>products_count</code> 中的字符串信息转换为链接，如下：</p>
<p>我们需要用到<code>format_html</code>函数，其中，占位符中的数字就是每个collection中的产品数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils.html <span class="keyword">import</span> format_html</span><br><span class="line"><span class="meta">@admin.register(models.Collection)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">   <span class="comment">#...</span></span><br><span class="line"><span class="meta">    @admin.display(ordering='products_count')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">products_count</span><span class="params">(self,collection)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> format_html(<span class="string">'&lt;a href="http://google.com"&gt;&#123;&#125;&lt;/a&gt;'</span>,collection.products_count)</span><br><span class="line">	 <span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p>然后，我们要把这边的google.com换成Products页面，如下：</p>
<p>我们需要用到 reverse函数，来帮助我们找到product页面的url，格式如下：<code>admin:app_model_page</code>。这里，app是<code>store</code>,model是<code>product</code>,page是<code>changelist</code> .</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils.html <span class="keyword">import</span> format_html</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> reverse</span><br><span class="line"><span class="meta">@admin.register(models.Collection)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">   <span class="comment">#...</span></span><br><span class="line"><span class="meta">    @admin.display(ordering='products_count')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">products_count</span><span class="params">(self,collection)</span>:</span></span><br><span class="line">        url = reverse(<span class="string">'admin:store_product_changelist'</span>) </span><br><span class="line">        <span class="keyword">return</span> format_html(<span class="string">'&lt;a href="&#123;&#125;"&gt;&#123;&#125;&lt;/a&gt;'</span>,url,collection.products_count)</span><br><span class="line">	 <span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/59.gif"></p>
<p>但这样只是跳转到了product页面，并没有筛选出对应collection的产品，因此我们需要对url进行完善。也就是在url中带上对collection的查询。比如说：<code>http://localhost:9000/admin/store/product/?collection__id=3</code></p>
<p>因此我们要对url后面加上 <code>?collection__id=*</code> 这样的格式</p>
<p>为了实现这个功能，我们需要引入一个<code>urlencode</code>函数，在里面可以做参数的映射，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils.html <span class="keyword">import</span> format_html,urlencode</span><br><span class="line"><span class="meta">@admin.register(models.Collection)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">		<span class="comment">#...</span></span><br><span class="line"><span class="meta">    @admin.display(ordering='products_count')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">products_count</span><span class="params">(self,collection)</span>:</span></span><br><span class="line">        url = (</span><br><span class="line">            reverse(<span class="string">'admin:store_product_changelist'</span>)</span><br><span class="line">            + <span class="string">'?'</span></span><br><span class="line">            + urlencode(&#123;</span><br><span class="line">                <span class="string">'collection__id'</span>: str(collection.id)</span><br><span class="line">            &#125;)</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> format_html(<span class="string">'&lt;a href="&#123;&#125;"&gt;&#123;&#125;&lt;/a&gt;'</span>,url,collection.products_count)</span><br><span class="line">   	<span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p>最终效果如下：</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/60.gif"></p>
<h3 id="Adding-Search-to-the-List-Page"><a href="#Adding-Search-to-the-List-Page" class="headerlink" title="Adding Search to the List Page"></a>Adding Search to the List Page</h3><p>如果我们要对某一字段查询，可以在类中添加<code>search_fields</code>字段：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@admin.register(models.Customer)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    list_display = [<span class="string">'first_name'</span>,<span class="string">'last_name'</span>,<span class="string">'membership'</span>]</span><br><span class="line">    list_editable = [<span class="string">'membership'</span>]</span><br><span class="line">    ordering = [<span class="string">'first_name'</span>,<span class="string">'last_name'</span>]</span><br><span class="line">    search_fields = [<span class="string">'first_name'</span>,<span class="string">'last_name'</span>]</span><br><span class="line">    list_per_page = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>但这样是搜索名字里有m的顾客，和我们想要搜索以m开头的顾客名不太一样，因此我们可以这么写：</p>
<p><code>search_fields = [&#39;first_name__startswith&#39;,&#39;last_name__startswith&#39;]</code></p>
<p>结果如下，</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/61.png"></p>
<p>但是这个搜索条件是大小写敏感的，如果我搜索的是<code>g</code>，是搜不到任何东西的。要让Django对搜索不敏感，可以这么写：</p>
<p><code>search_fields = [&#39;first_name__istartswith&#39;,&#39;last_name__istartswith&#39;]</code></p>
<h3 id="Adding-Filtering-to-the-List-Page"><a href="#Adding-Filtering-to-the-List-Page" class="headerlink" title="Adding Filtering to the List Page"></a>Adding Filtering to the List Page</h3><p>如果我们想在页面中加入筛选栏，只需要定义<code>list_filter</code>属性即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@admin.register(models.Product)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line"><span class="comment">#...</span></span><br><span class="line">    list_filter = [<span class="string">'collection'</span>,<span class="string">'last_update'</span>]</span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/62.png"></p>
<p>那么我们可以不可以自己创建一个筛选器呢？比如说对库存进行一个分类筛选，比如筛选出状态为Low的产品。</p>
<p>首先，我们要创建一个筛选器类，继承自<code>admin.SimpleListFilter</code>, 就叫其<code>InventoryFilter</code>就好</p>
<p>然后，我们要确认两个必要的参数：title和parameter_name，其中 title就是这个分类器的名字，也就是筛选栏顶部By后面的字符串；而parameter_name则用于url中作为查询的参数，也就是<code>http://localhost:9000/admin/store/product/?inventory=&lt;10</code>中?后面的字符串<code>inventory</code>。 </p>
<p>接着我们重写<code>lookups</code>函数.用来确定filter中的类别。这个函数要返回一个元组列表，每一个元组就代表filter中的一类元组第一个值代表url中的筛选条件,(也就是上面url最后的<code>&lt;10</code>),第二个值就是这类的名字。这里我们只要选出<code>low</code>的库存，因此我们只要写一个元组<code>(&lt;10,low)</code>即可：</p>
<p>但这样只是做了一个 &lt;10和low的映射，我们还需要写一下如果小于10的内部逻辑——也就是queryset函数：告诉它，如果url中的参数是<code>&lt;10</code>,应该做什么样的查询。</p>
<p>最后，我们要把这个类添加到<code>list_filter</code>中去</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InventoryFilter</span><span class="params">(admin.SimpleListFilter)</span>:</span></span><br><span class="line">    title = <span class="string">'inventory'</span></span><br><span class="line">    parameter_name = <span class="string">'inventory'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lookups</span><span class="params">(self, request, model_admin)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            (<span class="string">'&lt;10'</span>,<span class="string">'Low'</span>)</span><br><span class="line">        ]</span><br><span class="line"><span class="comment"># 这里给queryset加上了注解，让其等于QuerySet类，目的是让python给出更多的代码提示</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">queryset</span><span class="params">(self, request, queryset: QuerySet)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.value() == <span class="string">'&lt;10'</span>:</span><br><span class="line">            <span class="keyword">return</span> queryset.filter(inventory__lt = <span class="number">10</span>)</span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line"><span class="meta">@admin.register(models.Product)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line"><span class="comment">#...</span></span><br><span class="line">    list_filter = [<span class="string">'collection'</span>,<span class="string">'last_update'</span>,InventoryFilter]</span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/63.gif"></p>
<h3 id="Creating-Custom-Actions"><a href="#Creating-Custom-Actions" class="headerlink" title="Creating Custom Actions"></a>Creating Custom Actions</h3><p>我们知道在admin中，有Action表单，在里面可以删除选中的对象。那么我们可不可以自定义Action呢？</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/64.png"></p>
<p>比如说，我想自定义一个操作，每次点击会让选中的对象的库存清零。</p>
<p>首先，我们要新建一个函数，叫什么都行，尽量能表达出action的作用。注意，函数需要有三个参数：self,request和queryset</p>
<p>在这个函数中要写我们自定义操作的逻辑，这里我们就是把选中的对象的<code>inventory</code>属性清零。</p>
<p>此外我们还要定义<code>self.message_user</code>属性，用来确定返回给用户的信息，里面有必写的两个参数：</p>
<ul>
<li>第一个参数是request,直接写就好</li>
<li>第二个参数是信息的具体内种，这里用了一个带参数的字符串，<code>updated_count</code>即被更新的条目数量</li>
</ul>
<p><code>message_user</code>中的第三个参数是可选的，也就是确定信息的类型，这里选择的是<code>message.ERROR</code>，因此成功后的信息为红色警示</p>
<p>最后把这个函数加入到actions中去，注意要用字符串的形式。(函数用字符串的形式，类则不用)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@admin.register(models.Product)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">		<span class="comment">#...</span></span><br><span class="line">    actions = [<span class="string">'clear_inventory'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @admin.action(description='Clear inventory')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear_inventory</span><span class="params">(self,request,queryset)</span>:</span></span><br><span class="line">        updated_count = queryset.update(inventory=<span class="number">0</span>)</span><br><span class="line">        self.message_user(</span><br><span class="line">            request,</span><br><span class="line">            <span class="string">f'<span class="subst">&#123;updated_count&#125;</span> products were successfully updated'</span>,</span><br><span class="line">            messages.ERROR</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/65.gif"></p>
<h3 id="Customizing-Forms"><a href="#Customizing-Forms" class="headerlink" title="Customizing Forms"></a>Customizing Forms</h3><p>我们在products界面的右上角的ADD PRODUCT, 就会有一张现成的表单，现在我们想自定义这张表单。</p>
<h4 id="限制字段"><a href="#限制字段" class="headerlink" title="限制字段"></a>限制字段</h4><p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/66.png"></p>
<p>比如说我对于一个新的product，我只想开放title和slug这两个属性，其他属性都是默认值，那么可以这么写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@admin.register(models.Product)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    fields = [<span class="string">'title'</span>,<span class="string">'slug'</span>]</span><br><span class="line">    <span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/67.png"></p>
<h4 id="字段同步更新"><a href="#字段同步更新" class="headerlink" title="字段同步更新"></a>字段同步更新</h4><p>因为slug的内容和Title一样，是出现在url中的一个参数，因此，可以用定义<code>prepopulated_fields</code> 属性来让slug和Title保持一致，如下：</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/68.gif"></p>
<p>但是注意了，我们修改Title，slug会跟着一起变，但是我们如果在slug写了点东西，是不会和Title中的内容同步的，并且再回到Title中修改，slug也不会同步 </p>
<h4 id="下拉表单优化"><a href="#下拉表单优化" class="headerlink" title="下拉表单优化"></a>下拉表单优化</h4><p>对于离散的数据，Django会提供一个下拉表单供我们选择，但是如果离散值很多(比如选择省市)，那么下拉表单太长会很不方便，因此我们可以在下拉表单中添加一个搜索框。</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/69.png" style="zoom:67%;"></p>
<p>我们要修改两个地方，第一个地方是在<code>ProductAdmin</code>类中定义<code>autocomplete_fields</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@admin.register(models.Product)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    autocomplete_fields = [<span class="string">'collection'</span>]</span><br><span class="line">    prepopulated_fields = &#123;</span><br><span class="line">        <span class="string">'slug'</span>:[<span class="string">'title'</span>]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>此外我们还要在 <code>CollectionAdmin</code>中定义<code>search_fields</code>属性，否则相当于没开权限，没报错</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@admin.register(models.Collection)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollectionAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    search_fields = [<span class="string">'title'</span>]</span><br><span class="line">    <span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p>结果如下:</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/70.gif"></p>
<p>同样的，我们可以给order表单中的Customer字段添加搜索框</p>
<h4 id="auto-now-add-True对表单的影响"><a href="#auto-now-add-True对表单的影响" class="headerlink" title="auto_now_add=True对表单的影响"></a>auto_now_add=True对表单的影响</h4><p>如果在定义model的时候设立<code>placed_at</code> 为 <code>auto_now_add=True</code>，那么新建Order表单中是不会有<code>placed_at</code>的,因为系统会自动生成，此时如果删去<code>auto_now_add=True</code>就会出现<code>Placed at</code>字段,如下：</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/71.gif"></p>
<p>更多的自定义操作，可以看Django官方文档：</p>
<p><a href="https://docs.djangoproject.com/en/3.2/ref/contrib/admin/#modeladmin-options" target="_blank" rel="noopener">https://docs.djangoproject.com/en/3.2/ref/contrib/admin/#modeladmin-options</a></p>
<h3 id="Adding-Data-Validation"><a href="#Adding-Data-Validation" class="headerlink" title="Adding Data Validation"></a>Adding Data Validation</h3><p>我们新建一个Product，如果什么都不写就提交，Django会告诉你必写的字段还未填写内容。</p>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/74.png" style="zoom:50%;"></p>
<p>但是，在创建model的时候，如果我们设置属性是<code>null=True</code>的话，Django就不会给我们这种提示</p>
<p>此外，比如说对于<code>unit price</code>字段，我们知道需要填一个正数，但是现在Django只要求你填写数字，不要求正负。因此我们要通过代码把这个验证功能加上：</p>
<p>我们需要用到 <code>django.core.validators</code> 这个类。这里我们要规定价格的最小值，因此要用到<code>MinValueValidator</code>这个类，传入的1就代表最小值。第二个参数是可选的，即可以自定义不满足要求所返回的信息比如：<code>validators = [MinValueValidator(1,message=&quot;No No No&quot;)]</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.validators <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    unit_price = models.DecimalField(</span><br><span class="line">        max_digits=<span class="number">6</span>, </span><br><span class="line">        decimal_places=<span class="number">2</span>,</span><br><span class="line">        validators =[MinValueValidator(<span class="number">1</span>)]</span><br><span class="line">        )</span><br><span class="line">    <span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/75.png" style="zoom:50%;"></p>
<p><a href="https://docs.djangoproject.com/en/3.2/ref/validators/" target="_blank" rel="noopener">https://docs.djangoproject.com/en/3.2/ref/validators/</a></p>
<h3 id="Editing-Children-Using-Inlines"><a href="#Editing-Children-Using-Inlines" class="headerlink" title="Editing Children Using Inlines"></a>Editing Children Using Inlines</h3><p>我们现在可以新创建一个订单，但是没有办法在创建订单的时候确定订单中的产品。这时候就需要把子对象<code>OrderItem</code>添加进来,可以使用inlines属性：</p>
<p>首先我们要创建一个类，叫<code>OrderItemInline</code>, 它可以继承自<code>admin.TabularInline</code>也可以继承自<code>admin.StackedInline</code></p>
<p>我们想添加的是 OrderItem类型，因此要确定model属性<br>其中有字段product，我们要为其添加搜索框。<br>我们希望订单最少订购一件商品，最多10件，因此规定<code>min_num</code>和<code>max_num</code><br>如果我们不设定<code>min_num</code>和<code>max_num</code>，那么默认是3个，上不封顶。如果我们希望默认是0个，可以用<code>extra=0</code> ；否则，当我们设定<code>min_num=1</code>的时，默认就有4个Products了</p>
<p>最后，我们要在父类OrderAdmin中定义<code>inline</code>属性，把<code>OrderItemInline</code>传入</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderItemInline</span><span class="params">(admin.TabularInline)</span>:</span></span><br><span class="line">    model = models.OrderItem</span><br><span class="line">    autocomplete_fields=[<span class="string">'product'</span>]</span><br><span class="line">    min_num = <span class="number">1</span></span><br><span class="line">    max_num = <span class="number">10</span></span><br><span class="line">    extra = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@admin.register(models.Order)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">  	inlines = [OrderItemInline]</span><br><span class="line">    autocomplete_fields = [<span class="string">'customer'</span>]</span><br><span class="line">    list_per_page = <span class="number">10</span></span><br><span class="line">    list_display = [<span class="string">'id'</span>,<span class="string">'placed_at'</span>,<span class="string">'customer'</span>]</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/72.gif"></p>
<p><code>TabularInline</code>和<code>StackedInline</code> 的差别就在于排版方式，<code>StackedInline</code>是按列排版的，如下<br><img src="/2021/07/05/Django%E5%AD%A6%E4%B9%A01/73.png"></p>
<h3 id="Using-Generic-Relations"><a href="#Using-Generic-Relations" class="headerlink" title="Using Generic Relations"></a>Using Generic Relations</h3><p>现在，我们要把Tag以inline的形式加入到新建Product表单里面</p>
<p>首先，我们要把Tag界面加到Admin主页中去：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Tag</span><br><span class="line"><span class="comment"># Register your models here.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@admin.register(Tag)  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TagAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    search_fields = [<span class="string">'label'</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib.contenttypes.admin <span class="keyword">import</span> GenericTabularInline</span><br><span class="line"><span class="keyword">from</span> tags.models <span class="keyword">import</span> TaggedItem</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TagInline</span> <span class="params">(GenericTabularInline)</span>:</span></span><br><span class="line">    model = TaggedItem</span><br><span class="line"><span class="meta">@admin.register(models.Product)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    inline = [TagInline]</span><br><span class="line">    <span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<h3 id="Extending-Pluggable-Apps"><a href="#Extending-Pluggable-Apps" class="headerlink" title="Extending Pluggable Apps"></a>Extending Pluggable Apps</h3>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/06/28/%E6%A6%82%E7%8E%87%E8%AE%BA-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/28/%E6%A6%82%E7%8E%87%E8%AE%BA-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/" itemprop="url">概率论-假设检验</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-06-28T20:37:42+08:00">
                2021-06-28
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2021-09-10T08:38:06+08:00">
                2021-09-10
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="假设检验"><a href="#假设检验" class="headerlink" title="假设检验"></a>假设检验</h1><h2 id="假设检验的基本思想与概念"><a href="#假设检验的基本思想与概念" class="headerlink" title="假设检验的基本思想与概念"></a>假设检验的基本思想与概念</h2><p>我们先举一个女士品茶的例子：有一个女士称她可以鉴别奶茶是先加奶后加茶(MT)还是先加茶后加奶(MT). 那么，我们怎么来检验她是否有这种能力呢？</p>
<p>我们给出一个假设H：该女子没有这种鉴别能力。那么，如果H是正确的，她在10杯奶茶中只能猜，10次都猜对的概率为 $2^{-10}&lt;0.001$ ， 这是一个很小的概率，在一次试验中几乎不会发生，但如果这件事情真的发生的话，我们不能否决假设成立，但是更倾向于拒绝假设，从而认为该女士的确有辨别奶茶中 TM还是MT 的能力。</p>
<p>费舍尔用实验结果对假设H的对错进行判断的思维方式如下：</p>
<p><strong>加入试验结果与假设H发生锚段就拒绝原假设H，否则就接收原假设</strong> </p>
<p>我们记女士判断正确的杯数为 X, $x_i\sim b(1,p)$ ， 那么<strong>原假设H_0</strong>是无能力：$p=0.5$, <strong>备择假设H_1</strong>有能力：$p&gt;0.5,p\neq 1$</p>
<p>我们可以给出一张表：</p>
<p><img src="/2021/06/28/%E6%A6%82%E7%8E%87%E8%AE%BA-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/1.jpg" style="zoom:67%;"></p>
<p>第一类错误的含义是：实际上她是没有这种能力的，但是呢，我们判定的结果是她有这种能力。也就是错判</p>
<p>第二类错误的含义是：实际上她是有这种能力的，但是我们却认为它没有这种能力。就像是漏掉了，也就是漏判。</p>
<p>在假设检验中，我们是无法让错判概率和漏判概率同时取很低的，因为它们两者是矛盾的，如下面这个例子</p>
<p>$x\sim N(\mu,\sigma_0^2)$, $\sigma_0^2$ 是已知的，$x_1,\cdots,x_n$ 是样本。</p>
<p>第一步是给出假设. 检验样本均值是否恰好等于$\mu_0$ 还是 大于 $\mu_0$(一个已知量) </p>
<script type="math/tex; mode=display">
H_0: \mu = \mu_0 ~~~vs~~~ H_1: \mu>\mu_0</script><p>那么，如果我算出来的均值是$\overline x\geq c$的话，就很倾向于拒绝原假设。</p>
<p>那么怎么确定这个 c 值呢？我们先来看看<strong>错判概率$\alpha$</strong><br>在 $H_0$ 成立的情况下，$\mu = \mu_0$, 此时 $\overline x\sim N(\mu_0,\sigma_0^2/n)$ , 那么我们判断其不为真的概率为： </p>
<script type="math/tex; mode=display">
\alpha = P_u(\overline x>c)=P(\frac{\overline x-\mu_0}{\sqrt{\sigma_0^2/n}}>\frac{c-\mu_0}{\sqrt{\sigma_0^2/n}}) = 1-\Phi(\frac{c-\mu_0}{\sqrt{\sigma^2/n}})</script><p>现在我们看看<strong>漏判概率</strong><br>在 $H_1$ 成立的情况下，$\mu&gt; \mu_0$ ，$\overline x\sim N(\mu,\sigma_0^2/n)$ .</p>
<p>在楼盘情况下，我判断$H_0$ 为真，则：</p>
<script type="math/tex; mode=display">
\beta = P_\mu(\overline x< c) = P(\frac{\overline x-\mu }{\sqrt{\sigma_0^2/n}}<\frac{c-\mu }{\sqrt{\sigma_0^2/n}}) = \Phi(\frac{c-\mu }{\sqrt{\sigma^2/n}})</script><p>要时刻记住，这时候的$\mu$ 是大于$\mu_0$ 的，不能用$\mu_0$ 带入</p>
<p>我希望$\alpha$ 越小，那么我们希望 c越大，而 c越大则必然导致 $\beta$ 越大。因此 $\alpha$和 $\beta$ 之间是冲突的。</p>
<p>说完了这个例子，我们可以顺理成章得给出<strong>显著性水平</strong>的定义：</p>
<blockquote>
<p>对检验问题 $H_0:\theta\in\Theta_0 <del>~vs</del>~ H_1\in \Theta_1$ ，如果一个检验满足对任意的$\theta\in \Theta_0$ 其<strong>犯第一类错误的概率$\leq \alpha$</strong><br>则称该检验是<strong>显著性水平为$\alpha$的显著性检验</strong>， 简称<strong>水平为$\alpha$</strong>的检验 </p>
<p>提出显著性检验的概念就是要控制犯第一类错误的概率$\alpha$ ，不能让其过大与过小。在适当控制$\alpha$ 中制约$\beta$。 最长使用的选择是 $\alpha=0.05$,  又是也会选择 $\alpha = 0.1$ 或者 $\alpha = 0.01$</p>
</blockquote>
<p>那么，既然整个 $1-\Phi(\frac{c-\mu_0}{\sqrt{\sigma^2/n}})$ 要等于 $\alpha$ ，那么 $\Phi(\frac{c-\mu_0}{\sqrt{\sigma^2/n}})$ 就是要等于 $1-\alpha$ 。 也就是说， 我们可以反解出c值</p>
<script type="math/tex; mode=display">
\frac{c-\mu_0}{\sqrt{\sigma^2/n}} = u_{1-\alpha}\\~\\
c = u_{1-\alpha}\cdot\sqrt{\sigma^2/n} ~+\mu_0</script><p>解得c之后，我们发现，c把样本空间切割成了两部分。据此我们又引出了<strong>拒绝域</strong> 的概念</p>
<blockquote>
<p>如果满足 样本均值大于 $u_{1-\alpha}\cdot\sqrt{\sigma^2/n} ~+\mu_0$ 我们就拒绝原假设，这个域也被称为<strong>拒绝域</strong> </p>
<script type="math/tex; mode=display">
W= \{(x_1,\cdots,x_n):\overline x>u_{1-\alpha}\cdot\sqrt{\sigma^2/n} ~+\mu_0\}</script><p>而拒绝域的补集就是<strong>接受域</strong></p>
</blockquote>
<p>在一个二维平面中，拒绝域和接受域可表示如下：</p>
<p><img src="/2021/06/28/%E6%A6%82%E7%8E%87%E8%AE%BA-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/2.jpg" style="zoom:67%;"></p>
<p>现在再来一个例题：$x\sim N(\mu,\sigma^2)$, $\sigma^2$ 是未知的，$x_1,\cdots,x_n$ 是样本，同样是检验 $\mu$，计算拒绝域</p>
<p><strong>第一步：</strong> 给出点估计，$\hat\mu = \overline x\sim N(\mu,\frac{\sigma^2}{n})$</p>
<p><strong>第二步：</strong> 标准化：</p>
<script type="math/tex; mode=display">
\frac{\overline x-\mu_0}{\sqrt{\sigma^2/n}}</script><p>这时候由于$\sigma^2$ 未知，我们要用$s^2$ 去替代，替代完成后符合 t分布，即：</p>
<script type="math/tex; mode=display">
t = \frac{\overline x-\mu_0}{\sqrt{s^2/n}} \sim t(n-1)</script><p><strong>第三步：</strong> 计算显著性水平</p>
<script type="math/tex; mode=display">
\alpha = P(\frac{\overline x-\mu_0}{\sqrt{s^2/n}}>\frac{c-\mu_0}{\sqrt{s^2/n}})</script><p>要把显著性水平用足，因此这里要等于$\alpha$ 不能 $p\geq \alpha$</p>
<p>我们知道$\frac{\overline x-\mu_0}{\sqrt{s^2/n}}\sim t(n-1)$ 说明 </p>
<h5 id="例4"><a href="#例4" class="headerlink" title="例4"></a>例4</h5><p>上面说的都是单边的假设检验问题，现在来看看双边假设。现在拒绝的标准就要变了。如下图所示,阴影部分都是需要拒绝的：</p>
<p><img src="/2021/06/28/%E6%A6%82%E7%8E%87%E8%AE%BA-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/3.jpg" style="zoom:67%;"></p>
<script type="math/tex; mode=display">
\alpha = P(\frac{\overline x-\mu_0}{\sqrt{s^2/n}}\leq d_1)+P(\frac{\overline x-\mu_0}{\sqrt{s^2/n}}\geq d_2)</script>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" itemprop="url">文件系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-06-22T16:41:02+08:00">
                2021-06-22
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-06-30T09:54:34+08:00">
                2022-06-30
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>文章转载自：<a href="https://www.cnblogs.com/cxuanBlog/p/12565601.html" target="_blank" rel="noopener">https://www.cnblogs.com/cxuanBlog/p/12565601.html</a></p>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/0.png" style="zoom:67%;"></p>
<p>所有的应用程序都需要<code>存储</code>和<code>检索</code>信息。进程运行时，它能够在自己的存储空间内存储一定量的信息。然而，存储容量受<code>虚拟地址空间</code>大小的限制。对于一些应用程序来说，存储空间的大小是充足的，但是对于其他一些应用程序，比如航空订票系统、银行系统、企业记账系统来说，这些容量又显得太小了。</p>
<p>第二个问题是，当进程终止时信息会丢失。对于一些应用程序（例如数据库），信息会长久保留。在这些进程终止时，相关的信息应该保留下来，是不能丢失的。甚至这些应用程序崩溃后，信息也应该保留下来。</p>
<p>第三个问题是，通常需要很多进程在同一时刻访问这些信息。解决这种问题的方式是把这些信息单独保留在各自的进程中。</p>
<p>因此，对于长久存储的信息我们有三个基本需求：</p>
<ul>
<li><strong>必须要有可能存储的大量的信息</strong><ul>
<li><strong>信息必须能够在进程终止时保留</strong></li>
</ul>
</li>
<li><strong>必须能够使多个进程同时访问有关信息</strong></li>
</ul>
<p><code>磁盘(Magnetic disk)</code> 一直是用来长久保存信息的设备。近些年来，<code>固态硬盘</code>逐渐流行起来。</p>
<p><strong>固态硬盘不仅没有易损坏的移动部件，而且能够提供快速的随机访问</strong>。相比而言，虽然磁带和光盘也被广泛使用，但是它们的<strong>性能相对较差</strong>，通常应用于备份。我们会在后面探讨磁盘，现在姑且把磁盘当作一种大小固定块的线性序列好了，并且支持如下操作</p>
<ul>
<li>读块 k</li>
<li>写块 k</li>
</ul>
<p>事实上磁盘支持更多的操作，<strong>但是只要有了读写操作，原则上就能够解决长期存储的问题</strong>。</p>
<p>然而，磁盘还有一些不便于实现的操作，特别是在有很多程序或者多用户使用的大型系统上（如服务器）。在这种情况下，很容易产生一些问题，例如</p>
<ul>
<li>你如何找到这些信息？</li>
<li>你如何保证一个用户不会读取另外一个用户的数据？</li>
<li>你怎么知道哪些块是空闲的？等等问题</li>
</ul>
<p>我们可以针对这些问题提出一个新的抽象 - <code>文件</code>。<strong>进程和线程的抽象、地址空间和文件都是操作系统的重要概念</strong>。如果你能真正深入了解这三个概念，那么你就走上了成为操作系统专家的道路。</p>
<p><code>文件(Files)</code>是由进程创建的逻辑信息单元。一个磁盘会包含几千甚至几百万个文件，每个文件是独立于其他文件的。事实上，如果你能把每个文件都看作一个独立的地址空间，那么你就可以真正理解文件的概念了。</p>
<p>进程能够读取已经存在的文件，并在需要时重新创建他们。存储在文件中的信息必须是<code>持久的</code>，这也就是说，不会因为进程的创建和终止而受影响。一个文件只能在当用户明确删除的时候才能消失。尽管读取和写入都是最基本的操作，但还有许多其他操作，我们将在下面介绍其中的一些。</p>
<p>文件由操作系统进行管理，有关文件的构造、命名、访问、使用、保护、实现和管理方式都是操作系统设计的主要内容。从总体上看，操作系统中处理文件的部分称为 <code>文件系统(file system)</code>，这就是我们所讨论的。</p>
<p>从用户角度来说，用户通常会关心文件是由什么组成的，如何给文件进行命名，如何保护文件，以及可以对文件进行哪些操作等等。尽管是用链表还是用位图记录内存空闲区并不是用户所关心的主题，而这些对系统设计人员来说至关重要。下面我们就来探讨一下这些主题</p>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><p>文件是一种抽象机制，它提供了一种方式用来存储信息以及在后面进行读取。可能任何一种机制最重要的特性就是管理对象的命名方式。在创建一个文件后，它会给文件一个命名。当进程终止时，文件会继续存在，并且其他进程可以使用<code>名称访问该文件</code>。</p>
<p>文件命名规则对于不同的操作系统来说是不一样的，但是所有现代操作系统都允许使用 1 - 8 个字母的字符串作为合法文件名。</p>
<p>某些文件区分大小写字母，而大多数则不区分。<code>UNIX</code> 属于第一类；历史悠久的 <code>MS-DOS</code> 属于第二类（顺便说一句，尽管 MS-DOS 历史悠久，但 MS-DOS 仍在嵌入式系统中非常广泛地使用，因此它绝不是过时的）；因此，UNIX 系统会有三种不同的命名文件：<code>maria</code>、<code>Maria</code>、<code>MARIA</code> 。在 MS-DOS ，所有这些命名都属于相同的文件。</p>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/3.png" style="zoom:67%;"></p>
<p>这里可能需要在文件系统上预留一个位置。Windows 95 和 Windows 98 都使用了 MS-DOS 文件系统，叫做 <code>FAT-16</code>，因此继承了它的一些特征，例如有关文件名的构造方法。Windows 98 引入了对 FAT-16 的一些扩展，从而导致了 <code>FAT-32</code> 的生成，但是这两者很相似。另外，Windows NT，Windows 2000，Windows XP，Windows Vista，Windows 7 和 Windows 8 都支持 <code>FAT</code> 文件系统，这种文件系统有些过时。然而，这些较新的操作系统还具有更高级的<code>本机文件系统(NTFS)</code>，有不同的特性，那就是基于 <code>Unicode</code> 编码的文件名。事实上，Windows 8 还配备了另一种文件系统，简称 <code>ReFS(Resilient File System)</code>，但这个文件系统一般应用于 Windows 8 的服务器版本。下面除非我们特殊声明，否则我们在提到 MS-DOS 和 FAT 文件系统的时候，所指的就是 Windows 的 FAT-16 和 FAT-32。这里要说一下，有一种类似 FAT 的新型文件系统，叫做 <code>exFAT</code>。它是微软公司对闪存和大文件系统开发的一种优化的 FAT 32 扩展版本。ExFAT 是现在微软唯一能够满足 <code>OS X</code>读写操作的文件系统。</p>
<p>许多操作系统支持两部分的文件名，它们之间用 <code>.</code> 分隔开，比如文件名 <code>prog.c</code>。原点后面的文件称为 <code>文件扩展名(file extension)</code> ，文件扩展名通常表示文件的一些信息。例如在 MS-DOS 中，文件名是 1 - 8 个字符，加上 1 - 3 个字符的可选扩展名组成。在 UNIX 中，如果有扩展名，那么扩展名的长度将由用户来决定，一个文件甚至可以包括两个或更多的扩展名，例如 <code>homepage.html.zip</code>，html 表示一个 web 网页而 .zip 表示文件<code>homepage.html</code> 已经采用 zip 程序压缩完成。一些常用的文件扩展名以及含义如下图所示</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>扩展名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>bak</td>
<td>备份文件</td>
</tr>
<tr>
<td>c</td>
<td>c 源程序文件</td>
</tr>
<tr>
<td>gif</td>
<td>符合图形交换格式的图像文件</td>
</tr>
<tr>
<td>hlp</td>
<td>帮助文件</td>
</tr>
<tr>
<td>html</td>
<td>WWW 超文本标记语言文档</td>
</tr>
<tr>
<td>jpg</td>
<td>符合 JPEG 编码标准的静态图片</td>
</tr>
<tr>
<td>mp3</td>
<td>符合 MP3 音频编码格式的音乐文件</td>
</tr>
<tr>
<td>mpg</td>
<td>符合 MPEG 编码标准的电影</td>
</tr>
<tr>
<td>o</td>
<td>目标文件（编译器输出格式，尚未链接）</td>
</tr>
<tr>
<td>pdf</td>
<td>pdf 格式的文件</td>
</tr>
<tr>
<td>ps</td>
<td>PostScript 文件</td>
</tr>
<tr>
<td>tex</td>
<td>为 TEX 格式化程序准备的输入文件</td>
</tr>
<tr>
<td>txt</td>
<td>文本文件</td>
</tr>
<tr>
<td>zip</td>
<td>压缩文件</td>
</tr>
</tbody>
</table>
</div>
<p>在 UNIX 系统中，文件扩展名只是一种约定，操作系统并不强制采用。</p>
<p>名为 <code>file.txt</code> 的文件是文本文件，这个文件名更多的是提醒所有者，而不是给计算机传递信息。但是另一方面，C 编译器可能要求它编译的文件以<code>.c</code> 结尾，否则它会拒绝编译。然而，操作系统并不关心这一点。</p>
<p>对于可以处理多种类型的程序，约定就显得及其有用。例如 C 编译器可以编译、链接多种文件，包括 C 文件和汇编语言文件。这时扩展名就很有必要，编译器利用它们区分哪些是 C 文件，哪些是汇编文件，哪些是其他文件。因此，扩展名对于编译器判断哪些是 C 文件，哪些是汇编文件以及哪些是其他文件变得至关重要。</p>
<p>与 UNIX 相反，Windows 就会关注扩展名并对扩展名赋予了新的含义。<code>用户(或进程)</code> 可以在操作系统中注册<code>扩展名</code>，并且规定哪个程序能够拥有扩展名。当用户双击某个文件名时，拥有该文件名的程序就启动并运行文件。例如，双击 file.docx 启动了 Word 程序，并以 file.docx 作为初始文件。</p>
<h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>文件的构造有多种方式。下图列出了常用的三种构造方式</p>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/4.png" style="zoom:67%;"></p>
<p>上图中的 a 是一种无结构的字节序列，操作系统不关心序列的内容是什么，操作系统能看到的就是<code>字节(bytes)</code>。其文件内容的任何含义只在用户程序中进行解释。UNIX 和 Windows 都采用这种办法。</p>
<p>把文件看成字节序列提供了最大的灵活性。用户程序可以向文件中写任何内容，并且可以通过任何方便的形式命名。操作系统不会为为用户写入内容提供帮助，当然也不会干扰阻塞你。对于想做特殊操作的用户来说，后者是十分重要的。所有的 UNIX 版本（包括 Linux 和 OS X）和 Windows 都使用这种文件模型。</p>
<p>图 b 表示在文件结构上的第一部改进。在这个模型中，<strong>文件是具有固定长度记录的序列</strong>，每个记录都有其内部结构。 把文件作为记录序列的核心思想是：<strong>读操作返回一个记录，而写操作重写或者追加一个记录</strong>。</p>
<p>第三种文件结构如上图 c 所示。在这种组织结构中，文件由一颗<code>记录树</code>构成，记录树的长度不一定相同，每个记录树都在记录中的固定位置包含一个<code>key</code> 字段。这棵树按 key 进行排序，从而可以对特定的 key 进行快速查找。</p>
<p>在记录树的结构中，可以取出下一个记录，但是最关键的还是根据 key 搜索指定的记录。如上图 c 所示，用户可以读出指定的 <code>pony</code> 记录，而不必关心记录在文件中的确切位置。用户也可以在文件中添加新的记录。但是用户不能决定添加到何处位置，添加到何处位置是由<code>操作系统</code>决定的。</p>
<h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>很多操作系统支持多种文件类型。例如，UNIX（同样包括 OS X）和 Windows 都具有常规的文件和目录。除此之外，UNIX 还具有<code>字符特殊文件(character special file)</code> 和 <code>块特殊文件(block special file)</code>。<code>常规文件(Regular files)</code> 是包含有用户信息的文件。用户一般使用的文件大都是常规文件，常规文件一般包括 <strong>可执行文件、文本文件、图像文件</strong>，从常规文件读取数据或将数据写入时，内核会根据文件系统的规则执行操作，是写入可能被延迟，记录日志或者接受其他操作。</p>
<p><strong>字符特殊文件和输入/输出有关</strong>，用于串行 I/O 类设备，如终端、打印机、网络等。块特殊文件用于磁盘类设备。我们主要讨论的是常规文件。</p>
<p><strong>常规文件</strong>一般分为<strong>ASCII 码文件</strong>或者<strong>二进制文件</strong>。ASCII 码文件由文本组成。在一些系统中，每行都会用回车符结束（ASCII码是13，控制字符 CR，转义字符<code>\r</code>。），另外一些则会使用换行符（ASCII码是10，控制字符LF，转义字符<code>\n</code>）。一些系统（比如 Windows）两者都会使用。</p>
<p><strong>ASCII 文件的优点在于<code>显示</code> 和 <code>打印</code>，还可以用任何文本编辑器进行编辑。</strong>进一步来说，如果许多应用程序使用 ASCII 码作为输入和输出，那么很容易就能够把多个程序连接起来，一个程序的输出可能是另一个程序的输入，就像管道一样。</p>
<p>其他与 ASCII 不同的是二进制文件。打印出来的二进制文件是无法理解的。下面是一个二进制文件的格式，它取自早期的 UNIX 。尽管从技术上来看这个文件只是字节序列，但是操作系统只有在文件格式正确的情况下才会执行。</p>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/6.png" style="zoom:67%;"></p>
<p>这个文件有五个段：<strong>文件头、正文、数据、重定位位和符号表</strong>。文件头以 <code>魔数(magic number)</code> 为开始，<strong>表明这个文件是一个可执行文件（以防止意外执行非此格式的文件）</strong>。然后是文件各个部分的大小，开始执行的标志以及一些标志位。程序本身的正文和数据在<code>文件头</code>后面，他们被加载到内存中或者重定位会根据<code>重定位位</code>进行判断。符号表则用于<code>调试</code>。</p>
<p>二进制文件的另外一种形式是<code>存档文件</code>，它由<strong>已编译但没有链接的库过程（模块）组合而成</strong>。每个文件都以模块头开始，其中记录了<strong>名称、创建日期、所有者、保护码和文件大小</strong>。和可执行文件一样，模块头也都是二进制数，将它们复制到打印机将会产生乱码。</p>
<p>所有的操作系统必须至少能够识别一种文件类型：它自己的可执行文件。以前的 TOPS-20 系统（用于DECsystem 20）甚至要检查要执行的任何文件的创建时间，为了定位资源文件来检查自动文件创建后是否被修改过。如果被修改过了，那么就会自动编译文件。在 UNIX 中，就是在 shell 中嵌入 <code>make</code> 程序。此时操作系统要求用户必须采用固定的文件扩展名，从而确定哪个源程序生成哪个二进制文件。</p>
<blockquote>
<p>什么是 make 程序？在软件发展过程中，make 程序是一个自动编译的工具，它通过读取称为 <code>Makefiles</code> 的文件来自动从源代码构建可执行程序和库，该文件指定了如何导出目标程序。尽管集成开发环境和特定于语言的编译器功能也可以用于管理构建过程，但 Make 仍被广泛使用，尤其是在 Unix 和类似 Unix 的操作系统中使用。</p>
</blockquote>
<p>当程序从文件中读写数据时，请求会转到<code>内核处理程序(kernel driver)</code>。如果文件是常规文件，则数据由文件系统驱动程序处理，并且通常存储在磁盘或其他存储介质上的某块区域中，从文件中读取的数据就是之前在该位置写入的数据。</p>
<p>当数据读取或写入到设备文件时，请求会被设备驱动程序处理。每个设备文件都有一个关联的编号，该编号标示要使用的设备驱动程序。设备处理数据的工作是它自己的事儿。</p>
<ul>
<li><code>块设备</code> 也叫做块特殊文件，它的行为通常与普通文件相似：它们是字节数组，并且在给定位置读取的值是最后写入该位置的值。来自块设备的数据可以缓存在内存中，并从缓存中读取；写入可以被缓冲。块设备通常是可搜索的，<strong>块设备的概念是，相应的硬件可以一次读取或者写入整个块</strong>，例如磁盘上的一个扇区</li>
<li><code>字符设备</code> 也称为字符特殊文件，它的行为类似于管道、串行端口。将字节写入字符设备可能会导致它在屏幕上显示，在串行端口上输出，转换为声音。</li>
</ul>
<p><code>目录(Directories)</code> 是管理文件系统结构的系统文件。它是用于在计算机上存储文件的位置。目录位于<code>分层文件系统</code>中，例如 Linux，MS-DOS 和 UNIX。</p>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/7.png" style="zoom:67%;"></p>
<p>它显示所有本地和子目录（例如，cdn 目录中的 big 目录）。当前目录是 C 盘驱动器的<code>根目录</code>。之所以称为根目录，是因为该目录下没有任何内容，而其他目录都在该目录下<code>分支</code>。</p>
<h3 id="文件访问"><a href="#文件访问" class="headerlink" title="文件访问"></a>文件访问</h3><p>早期的操作系统<strong>只有一种访问方式</strong>：<code>序列访问(sequential access)</code>。在这些系统中，进程可以按照顺序读取所有的字节或文件中的记录，但是不能跳过并乱序执行它们。顺序访问文件是可以返回到起点的，需要时可以多次读取该文件。当存储介质是磁带而不是磁盘时，顺序访问文件很方便。</p>
<p>在<strong>使用磁盘来存储文件时</strong>，可以不按照顺序读取文件中的字节或者记录，或者按照关键字而不是位置来访问记录。这种能够以任意次序进行读取的称为<code>随机访问文件(random access file)</code>。许多应用程序都需要这种方式。</p>
<p>随机访问文件对许多应用程序来说都必不可少，例如，数据库系统。如果乘客打电话预定某航班机票，订票程序必须能够直接访问航班记录，而不必先读取其他航班的成千上万条记录。</p>
<p>有两种方法可以指示从何处开始读取文件。第一种方法是直接使用 <code>read</code> 从头开始读取。另一种是用一个特殊的 <code>seek</code> 操作设置当前位置，在 seek 操作后，从这个当前位置顺序地开始读文件。UNIX 和 Windows 使用的是后面一种方式。</p>
<h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p>文件包括文件名和数据。除此之外，所有的操作系统还会保存其他与文件相关的信息，如文件创建的日期和时间、文件大小。我们可以称这些为文件的<code>属性(attributes)</code>。有些人也喜欢把它们称作 <code>元数据(metadata)</code>。文件的属性在不同的系统中差别很大。文件的属性只有两种状态：<code>设置(set)</code> 和 <code>清除(clear)</code>。下面是一些常用的属性</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>保护</td>
<td>谁可以访问文件、以什么方式存取文件</td>
</tr>
<tr>
<td>密码（口令）</td>
<td>访问文件所需要的密码（口令）</td>
</tr>
<tr>
<td>创建者</td>
<td>创建文件者的 ID</td>
</tr>
<tr>
<td>所有者</td>
<td>当前所有者</td>
</tr>
<tr>
<td>只读标志</td>
<td>0 表示读/写，1 表示只读</td>
</tr>
<tr>
<td>隐藏标志</td>
<td>0 表示正常，1 表示不再列表中显示</td>
</tr>
<tr>
<td>系统标志</td>
<td>0 表示普通文件，1 表示系统文件</td>
</tr>
<tr>
<td>存档标志</td>
<td>0 表示已经备份，1 表示需要备份</td>
</tr>
<tr>
<td>ASCII / 二进制标志</td>
<td>0 表示 ASCII 文件，1 表示二进制文件</td>
</tr>
<tr>
<td>随机访问标志</td>
<td>0 表示只允许顺序访问，1 表示随机访问</td>
</tr>
<tr>
<td>临时标志</td>
<td>0 表示正常，1 表示进程退出时删除该文件</td>
</tr>
<tr>
<td>加锁标志</td>
<td>0 表示未加锁，1 表示加锁</td>
</tr>
<tr>
<td>记录长度</td>
<td>一个记录中的字节数</td>
</tr>
<tr>
<td>键的位置</td>
<td>每个记录中的键的偏移量</td>
</tr>
<tr>
<td>键的长度</td>
<td>键字段的字节数</td>
</tr>
<tr>
<td>创建时间</td>
<td>创建文件的日期和时间</td>
</tr>
<tr>
<td>最后一次存取时间</td>
<td>上一次访问文件的日期和时间</td>
</tr>
<tr>
<td>最后一次修改时间</td>
<td>上一次修改文件的日期和时间</td>
</tr>
<tr>
<td>当前大小</td>
<td>文件的字节数</td>
</tr>
<tr>
<td>最大长度</td>
<td>文件可能增长到的字节数</td>
</tr>
</tbody>
</table>
</div>
<p>没有一个系统能够同时具有上面所有的属性，但每个属性都在某个系统中采用。</p>
<p>前面四个属性（保护，口令，创建者，所有者）与文件保护有关，它们指出了谁可以访问这个文件，谁不能访问这个文件。</p>
<blockquote>
<p><code>保护（File Protection）</code>： 用于保护计算机上有价值数据的方法。文件保护是通过密码保护文件或者仅仅向特定用户或组提供权限来实现。</p>
</blockquote>
<p>在一些系统中，用户必须给出口令才能访问文件。<code>标志(flags)</code>是一些位或者短属性能够控制或者允许特定属性。</p>
<ul>
<li><code>隐藏文件位(hidden flag)</code>表示该文件不在文件列表中出现。</li>
<li><code>存档标志位(archive flag)</code>用于记录文件是否备份过，由备份程序清除该标志位；若文件被修改，操作系统则设置该标志位。用这种方法，备份程序可以知道哪些文件需要备份。</li>
<li><code>临时标志位(temporary flag)</code> 允许文件被标记为是否允许自动删除当进程终止时。</li>
</ul>
<p><code>记录长度(record-length)</code>、<code>键的位置(key-position)</code>和<code>键的长度(key-length)</code>等字段只能出现在用关键字查找记录的文件中。它们提供了查找关键字所需要的信息。</p>
<p>不同的时间字段记录了文件的创建时间、最近一次访问时间以及最后一次修改时间，它们的作用不同。例如，目标文件生成后被修改的源文件需要重新编译生成目标文件。这些字段提供了必要的信息。</p>
<p>当前大小字段指出了当前的文件大小，一些旧的大型机操作系统要求在创建文件时指定文件呢最大值，以便让操作系统提前保留最大存储值。但是一些服务器和个人计算机却不用设置此功能。</p>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>使用文件的目的是用来存储信息并方便以后的检索。对于存储和检索，不同的系统提供了不同的操作。以下是与文件有关的最常用的一些系统调用：</p>
<ol>
<li><code>Create</code>，创建不包含任何数据的文件。调用的目的是表示文件即将建立，并对文件设置一些属性。</li>
<li><code>Delete</code>，当文件不再需要，必须删除它以释放内存空间。为此总会有一个系统调用来删除文件。</li>
<li><code>Open</code>，在使用文件之前，必须先打开文件。这个调用的目的是允许系统将属性和磁盘地址列表保存到主存中，用来以后的快速访问。</li>
<li><code>Close</code>，当所有进程完成时，属性和磁盘地址不再需要，因此应关闭文件以释放表空间。很多系统限制进程打开文件的个数，以此达到鼓励用户关闭不再使用的文件。磁盘以块为单位写入，关闭文件时会强制写入最后一<code>块</code>，即使这个块空间内部还不满。</li>
<li><code>Read</code>，数据从文件中读取。通常情况下，读取的数据来自文件的当前位置。调用者必须指定需要读取多少数据，并且提供存放这些数据的缓冲区。</li>
<li><code>Write</code>，向文件写数据，写操作一般也是从文件的当前位置开始进行。如果当前位置是文件的末尾，则会直接追加进行写入。如果当前位置在文件中，则现有数据被覆盖，并且永远消失。</li>
<li><code>append</code>，使用 append 只能向文件末尾添加数据。</li>
<li><code>seek</code>，对于随机访问的文件，要指定从何处开始获取数据。通常的方法是用 seek 系统调用把当前位置指针指向文件中的特定位置。seek 调用结束后，就可以从指定位置开始读写数据了。</li>
<li><code>get attributes</code>，进程运行时通常需要读取文件属性。</li>
<li><code>set attributes</code>，用户可以自己设置一些文件属性，甚至是在文件创建之后，实现该功能的是 set attributes 系统调用。</li>
<li><code>rename</code>，用户可以自己更改已有文件的名字，rename 系统调用用于这一目的。</li>
</ol>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>文件系统通常提供<code>目录(directories)</code> 或者 <code>文件夹(folders)</code> 用于记录文件的位置，在很多系统中目录本身也是文件，下面我们会讨论关于文件，他们的组织形式、属性和可以对文件进行的操作。</p>
<h3 id="一级目录系统"><a href="#一级目录系统" class="headerlink" title="一级目录系统"></a>一级目录系统</h3><p>目录系统最简单的形式是有一个能够包含所有文件的目录。这种目录被称为<code>根目录(root directory)</code>，由于根目录的唯一性，所以其名称并不重要。在最早期的个人计算机中，这种系统很常见，部分原因是因为只有一个用户。下面是一个单层目录系统的例子</p>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/8.png" style="zoom:67%;"></p>
<p>该目录中有四个文件。这种设计的优点在于简单，并且能够快速定位文件，毕竟只有一个地方可以检索。这种目录组织形式现在一般用于简单的嵌入式设备（如数码相机和某些便携式音乐播放器）上使用。</p>
<h3 id="层次目录系统"><a href="#层次目录系统" class="headerlink" title="层次目录系统"></a>层次目录系统</h3><p>对于简单的应用而言，一般都用单层目录方式，但是这种组织形式并不适合于现代计算机，因为现代计算机含有成千上万个文件和文件夹。如果都放在根目录下，查找起来会非常困难。为了解决这一问题，出现了<code>层次目录系统(Hierarchical Directory Systems)</code>，也称为<code>目录树</code>。通过这种方式，可以用很多目录把文件进行分组。进而，如果多个用户共享同一个文件服务器，比如公司的网络系统，每个用户可以为自己的目录树拥有自己的私人根目录。这种方式的组织结构如下</p>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/9.png" style="zoom:67%;"></p>
<p>根目录含有目录 A、B 和 C ，分别属于不同的用户，其中两个用户个字创建了<code>子目录</code>。用户可以创建任意数量的子目录，现代文件系统都是按照这种方式组织的。</p>
<h3 id="路径名"><a href="#路径名" class="headerlink" title="路径名"></a>路径名</h3><p>当目录树组织文件系统时，需要有某种方法指明文件名。常用的方法有两种，第一种方式是每个文件都会用一个<code>绝对路径名(absolute path name)</code>，它由根目录到文件的路径组成。举个例子，<code>/usr/ast/mailbox</code> 意味着根目录包含一个子目录<code>usr</code>，usr 下面包含了一个 <code>mailbox</code>。绝对路径名总是以 <code>/</code> 开头，并且是唯一的。在UNIX中，路径的组件由<code>/</code>分隔。在Windows中，分隔符为<code>\</code>。 在 MULTICS 中，它是<code>&gt;</code>。 因此，在这三个系统中，相同的路径名将被编写如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Windows \usr\ast\mailbox </span><br><span class="line">UNIX &#x2F;usr&#x2F;ast&#x2F;mailbox </span><br><span class="line">MULTICS &gt;usr&gt;ast&gt;mailbox</span><br></pre></td></tr></table></figure>
<p>不论使用哪种方式，<strong>如果路径名的第一个字符是分隔符，那就是绝对路径</strong>。</p>
<p>另外一种指定文件名的方法是 <code>相对路径名(relative path name)</code>。它常常和 <code>工作目录(working directory)</code> （也称作 <code>当前目录(current directory)</code>）一起使用。用户可以指定一个目录作为当前工作目录。例如，如果当前目录是 <code>/usr/ast</code>，那么绝对路径 <code>/usr/ast/mailbox</code>可以直接使用 <code>mailbox</code> 来引用。也就是说，如果工作目录是 <code>/usr/ast</code>，则 UNIX 命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp &#x2F;usr&#x2F;ast&#x2F;mailbox  &#x2F;usr&#x2F;ast&#x2F;mailbox.bak</span><br></pre></td></tr></table></figure>
<p>和命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp mailbox mailbox.bak</span><br></pre></td></tr></table></figure>
<p>具有相同的含义。相对路径通常情况下更加方便和简洁。而它实现的功能和绝对路径安全相同。</p>
<p>一些程序需要访问某个特定的文件而不必关心当前的工作目录是什么。在这种情况下，应该使用绝对路径名。</p>
<p>支持层次目录结构的大多数操作系统在每个目录中有两个特殊的目录项<code>.</code> 和 <code>..</code>，长读作 <code>dot</code> 和 <code>dotdot</code>。dot 指的是当前目录，dotdot 指的是其父目录（在根目录中例外，在根目录中指向自己）。可以参考下面的进程树来查看如何使用。</p>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/10.png" style="zoom:67%;"></p>
<p>一个进程的工作目录是 <code>/usr/ast</code>，它可采用 <code>..</code> 沿树向上，例如，可用命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ..&#x2F;lib&#x2F;dictionary .</span><br></pre></td></tr></table></figure>
<p>把文件 <code>usr/lib/dictionary</code> 复制到自己的目录下，第一个路径告诉系统向上找（到 usr 目录），然后向下到 <code>lib</code> 目录，找到 dictionary 文件</p>
<p>第二个参数 <code>.</code> 指定当前的工作目录，当 cp 命令用目录名作为最后一个参数时，则把全部的文件复制到该目录中。当然，对于上述复制，键入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp &#x2F;usr&#x2F;lib&#x2F;dictionary .</span><br></pre></td></tr></table></figure>
<p>是更常用的方法。用户这里采用 <code>.</code> 可以避免键入两次 dictionary 。无论如何，键入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp &#x2F;usr&#x2F;lib&#x2F;dictionary dictionary</span><br></pre></td></tr></table></figure>
<p>也可正常工作，就像键入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp &#x2F;usr&#x2F;lib&#x2F;dictionary &#x2F;usr&#x2F;lib&#x2F;dictionary</span><br></pre></td></tr></table></figure>
<p>一样。所有这些命令都能够完成同样的工作。</p>
<h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><p>不同文件中管理目录的系统调用的差别比管理文件的系统调用差别大。为了了解这些系统调用有哪些以及它们怎样工作，下面给出一个例子（取自 UNIX）。</p>
<ol>
<li><code>Create</code>，创建目录，除了目录项 <code>.</code> 和 <code>..</code> 外，目录内容为空。</li>
<li><code>Delete</code>，删除目录，只有空目录可以删除。只包含 <code>.</code> 和 <code>..</code> 的目录被认为是空目录，这两个目录项通常不能删除</li>
<li><code>opendir</code>，目录内容可被读取。例如，未列出目录中的全部文件，程序必须先打开该目录，然后读其中全部文件的文件名。与打开和读文件相同，在读目录前，必须先打开文件。</li>
<li><code>closedir</code>，读目录结束后，应该关闭目录用于释放内部表空间。</li>
<li><code>readdir</code>，系统调用 readdir 返回打开目录的下一个目录项。以前也采用 read 系统调用来读取目录，但是这种方法有一个缺点：程序员必须了解和处理目录的内部结构。相反，不论采用哪一种目录结构，readdir 总是以标准格式返回一个目录项。</li>
<li><code>rename</code>，在很多方面目录和文件都相似。文件可以更换名称，目录也可以。</li>
<li><code>link</code>，链接技术允许在多个目录中出现同一个文件。这个系统调用指定一个存在的文件和一个路径名，并建立从该文件到路径所指名字的链接。这样，可以在多个目录中出现同一个文件。有时也被称为<code>硬链接(hard link)</code>。</li>
<li><code>unlink</code>，删除目录项。如果被解除链接的文件只出现在一个目录中，则将它从文件中删除。如果它出现在多个目录中，则只删除指定路径名的链接，依然保留其他路径名的链接。在 UNIX 中，用于删除文件的系统调用就是 unlink。</li>
</ol>
<h2 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h2><p>在对文件有了基本认识之后，现在是时候把目光转移到文件系统的<code>实现</code>上了。之前用户关心的一直都是文件是怎样命名的、可以进行哪些操作、目录树是什么，如何找到正确的文件路径等问题。而设计人员关心的是文件和目录是怎样存储的、磁盘空间是如何管理的、如何使文件系统得以流畅运行的问题，下面我们就来一起讨论一下这些问题。</p>
<h3 id="文件系统布局"><a href="#文件系统布局" class="headerlink" title="文件系统布局"></a>文件系统布局</h3><p>文件系统存储在<code>磁盘</code>中。大部分的磁盘能够划分出一到多个分区，叫做<code>磁盘分区(disk partitioning)</code> 或者是<code>磁盘分片(disk slicing)</code>。每个分区都有独立的文件系统，每块分区的文件系统可以不同。磁盘的 0 号分区称为 <code>主引导记录(Master Boot Record, MBR)</code>，用来<code>引导(boot)</code> 计算机。在 MBR 的结尾是<code>分区表(partition table)</code>。每个分区表给出每个分区由开始到结束的地址。系统管理员使用一个称为分区编辑器的程序来创建，调整大小，删除和操作分区。这种方式的一个缺点是很难适当调整分区的大小，导致一个分区具有很多可用空间，而另一个分区几乎完全被分配。</p>
<blockquote>
<p>MBR 可以用在 DOS 、Microsoft Windows 和 Linux 操作系统中。从 2010 年代中期开始，大多数新计算机都改用 GUID 分区表（GPT）分区方案。</p>
</blockquote>
<p>下面是一个用 <code>GParted</code> 进行分区的磁盘，表中的分区都被认为是 <code>活动的(active)</code>。</p>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/11.png" style="zoom:67%;"></p>
<p>当计算机开始引 boot 时，BIOS 读入并执行 MBR。</p>
<h4 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h4><p>MBR 做的第一件事就是<code>确定活动分区</code>，读入它的第一个块，称为<code>引导块(boot block)</code> 并执行。引导块中的程序<strong>将加载分区中的操作系统</strong>。为了一致性，<strong>每个分区都会从引导块开始，即使引导块不包含操作系统</strong>。引导块占据文件系统的前 4096 个字节，从磁盘上的字节偏移量 0 开始。引导块可用于启动操作系统。</p>
<blockquote>
<p>在计算机中，引导就是启动计算机的过程，它可以通过硬件（例如按下电源按钮）或者软件命令的方式来启动。开机后，电脑的 CPU 还不能执行指令，因为此时没有软件在主存中，所以一些软件必须先被加载到内存中，然后才能让 CPU 开始执行。也就是计算机开机后，首先会进行软件的装载过程。</p>
<p>重启电脑的过程称为<code>重新引导(rebooting)</code>，从休眠或睡眠状态返回计算机的过程不涉及启动。</p>
</blockquote>
<p>除了从引导块开始之外，磁盘分区的布局是随着文件系统的不同而变化的。通常文件系统会包含一些属性，如下</p>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/12.png" style="zoom:67%;"></p>
<h4 id="超级块"><a href="#超级块" class="headerlink" title="超级块"></a>超级块</h4><p>紧跟在引导块后面的是 <code>超级块(Superblock)</code>，超级块 的大小为 4096 字节，从磁盘上的字节偏移 4096 开始。<strong>超级块包含文件系统的所有关键参数</strong></p>
<ul>
<li>文件系统的大小</li>
<li>文件系统中的<strong>数据块数</strong></li>
<li>指示文件系统状态的标志</li>
<li>分配组大小</li>
</ul>
<p>这些信息描述了文件系统的布局，在计算机启动或者文件系统首次使用时，超级块会被读入内存。</p>
<h4 id="空闲空间块"><a href="#空闲空间块" class="headerlink" title="空闲空间块"></a>空闲空间块</h4><p>接着是文件系统中<code>空闲块</code>的信息，例如，<strong>可以用位图或者指针列表的形式</strong>给出。</p>
<p><strong>BitMap 位图或者 Bit vector 位向量</strong></p>
<p>位图或位向量是一系列位或位的集合，其中<strong>每个位对应一个磁盘块</strong>，该位可以采用两个值：0和1，<strong>0表示已分配该块，而1表示一个空闲块</strong>。下图中的磁盘上给定的磁盘块实例（分配了绿色块）可以用16位的位图表示为：0000111000000110。</p>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/13.png" style="zoom:67%;"></p>
<p><strong>使用链表进行管理</strong></p>
<p>在这种方法中，空闲磁盘块链接在一起，即一个空闲块包含指向下一个空闲块的指针。第一个磁盘块的块号存储在磁盘上的单独位置，也缓存在内存中。</p>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/14.png" style="zoom:67%;"></p>
<h4 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h4><p>这里不得不提一个叫做<code>碎片(fragment)</code>的概念，也称为片段。一般零散的单个数据通常称为片段。 磁盘块可以进一步分为固定大小的分配单元，片段只是在驱动器上彼此不相邻的文件片段。如果你不理解这个概念就给你举个例子。比如你用 Windows 电脑创建了一个文件，你会发现这个文件可以存储在任何地方，比如存在桌面上，存在磁盘中的文件夹中或者其他地方。你可以打开文件，编辑文件，删除文件等等。你可能以为这些都在一个地方发生，但是实际上并不是，你的硬盘驱动器可能会将文件中的一部分存储在一个区域内，另一部分存储在另外一个区域，在你打开文件时，硬盘驱动器会迅速的将文件的所有部分汇总在一起，以便其他计算机系统可以使用它。</p>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/15.png" style="zoom:67%;"></p>
<h4 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h4><p>然后在后面是一个 <code>inode(index node)</code>，也称作索引节点。它是一个数组的结构，每个文件有一个 inode，inode 非常重要，它说明了文件的方方面面。<strong>每个索引节点都存储对象数据的属性和磁盘块位置</strong></p>
<p>有一种简单的方法可以找到它们 <code>ls -lai</code> 命令。让我们看一下根文件系统：</p>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/16.png" style="zoom:67%;"></p>
<p>inode 节点主要包括了以下信息</p>
<ul>
<li>模式/权限（保护）</li>
<li>所有者 ID</li>
<li>组 ID</li>
<li>文件大小</li>
<li>文件的硬链接数</li>
<li>上次访问时间</li>
<li>最后修改时间</li>
<li>inode 上次修改时间</li>
</ul>
<p>文件分为两部分，索引节点和块。一旦创建后，每种类型的块数是固定的。你不能增加分区上 inode 的数量，也不能增加磁盘块的数量。</p>
<p>紧跟在 inode 后面的是根目录，它存放的是文件系统目录树的根部。最后，磁盘的其他部分存放了其他所有的目录和文件。</p>
<h3 id="文件的实现"><a href="#文件的实现" class="headerlink" title="文件的实现"></a>文件的实现</h3><p>最重要的问题是记录各个文件分别用到了哪些磁盘块。不同的系统采用了不同的方法。下面我们会探讨一下这些方式。分配背后的主要思想是<code>有效利用文件空间</code>和<code>快速访问文件</code> ，主要有三种分配方案</p>
<ul>
<li>连续分配</li>
<li>链表分配</li>
<li>索引分配</li>
</ul>
<h4 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h4><p>最简单的分配方案是把每个文件作为一连串连续数据块存储在磁盘上。因此，在具有 1KB 块的磁盘上，将为 50 KB 文件分配 50 个连续块。</p>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/17.png" style="zoom:67%;"></p>
<p>上面展示了 40 个连续的内存块。从最左侧的 0 块开始。初始状态下，还没有装载文件，因此磁盘是空的。接着，从磁盘开始处（块 0 ）处开始写入占用 4 块长度的内存 A 。然后是一个占用 6 块长度的内存 B，会直接在 A 的末尾开始写。</p>
<p>注意每个文件都会在新的文件块开始写，所以如果文件 A 只占用了 <code>3 又 1/2</code> 个块，那么最后一个块的部分内存会被浪费。在上面这幅图中，总共展示了 7 个文件，每个文件都会从上个文件的末尾块开始写新的文件块。</p>
<p>连续的磁盘空间分配有两个优点。</p>
<ul>
<li>第一，连续文件存储<strong>实现起来比较简单</strong>，只需要记住两个数字就可以：一个是第一个块的文件地址和文件的块数量。给定第一个块的编号，可以通过简单的加法找到任何其他块的编号。</li>
<li>第二点是<strong>读取性能比较强</strong>，可以通过一次操作从文件中读取整个文件。只需要一次寻找第一个块。后面就不再需要寻道时间和旋转延迟，所以数据会以全带宽进入磁盘。</li>
</ul>
<p>因此，连续的空间分配具有<code>实现简单</code>、<code>高性能</code>的特点。</p>
<p>不幸的是，连续空间分配也有很明显的不足。随着时间的推移，<strong>磁盘会变得很零碎</strong>。下图解释了这种现象</p>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/18.png" style="zoom:67%;"></p>
<p>这里有两个文件 D 和 F 被删除了。当删除一个文件时，此文件所占用的块也随之释放，就会在磁盘空间中留下一些空闲块。磁盘并不会在这个位置挤压掉空闲块，因为这会复制空闲块之后的所有文件，可能会有上百万的块，这个量级就太大了。</p>
<p>刚开始的时候，这个碎片不是问题，因为每个新文件都会在之前文件的结尾处进行写入。然而，磁盘最终会被填满，<strong>因此要么压缩磁盘、要么重新使用空闲块的空间</strong>。压缩磁盘的开销太大，因此不可行；后者会维护一个空闲列表，这个是可行的。但是这种情况又存在一个问题，为空闲块匹配合适大小的文件，需要知道该文件的<code>最终大小</code>。</p>
<p>想象一下这种设计的结果会是怎样的。用户启动 word 进程创建文档。应用程序首先会询问最终创建的文档会有多大。这个问题必须回答，否则应用程序就不会继续执行。如果空闲块的大小要比文件的大小小，程序就会终止。因为所使用的磁盘空间已经满了。那么现实生活中，有没有使用连续分配内存的介质出现呢？</p>
<p><code>CD-ROM</code> 就广泛的使用了连续分配方式。</p>
<blockquote>
<p><code>CD-ROM（Compact Disc Read-Only Memory）</code>即只读光盘，也称作只读存储器。是一种在电脑上使用的光碟。这种光碟只能写入数据一次，信息将永久保存在光碟上，使用时通过光碟驱动器读出信息。</p>
</blockquote>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/19.png" style="zoom:67%;"></p>
<p>然而 DVD 的情况会更加复杂一些。原则上，一个 <code>90分钟</code> 的电影能够被编码成一个独立的、大约 4.5 GB 的文件。但是文件系统所使用的 <code>UDF(Universal Disk Format)</code> 格式，使用一个 30 位的数来代表文件长度，从而把文件大小限制在 1 GB。所以，DVD 电影一般存储在 3、4个连续的 1 GB 空间内。这些构成单个电影中的文件块称为<code>扩展区(extends)</code>。</p>
<p>就像我们反复提到的，<strong>历史总是惊人的相似</strong>，许多年前，连续分配由于其<code>简单</code>和<code>高性能</code>被实际使用在磁盘文件系统中。后来由于用户不希望在创建文件时指定文件的大小，于是放弃了这种想法。但是随着 CD-ROM 、DVD、蓝光光盘等光学介质的出现，连续分配又流行起来。从而得出结论，<code>技术永远没有过时性</code>，现在看似很老的技术，在未来某个阶段可能又会流行起来。</p>
<h4 id="链表分配"><a href="#链表分配" class="headerlink" title="链表分配"></a>链表分配</h4><p>第二种存储文件的方式是<strong>为每个文件构造磁盘块链表</strong>，每个文件都是磁盘块的链接列表，就像下面所示</p>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/20.png" style="zoom:67%;"></p>
<p>每个块的第一个字作为指向下一块的指针，块的其他部分存放数据。如果上面这张图你看的不是很清楚的话，可以看看整个的链表分配方案</p>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/21.png" style="zoom:67%;"></p>
<p>与连续分配方案不同，这一方法可以充分利用每个磁盘块。除了最后一个磁盘块外，不会因为磁盘碎片而浪费存储空间。同样，在目录项中，只要存储了第一个文件块，那么其他文件块也能够被找到。</p>
<p>另一方面，在链表的分配方案中，<strong>尽管顺序读取非常方便，但是随机访问却很困难</strong>（这也是数组和链表数据结构的一大区别）。</p>
<p>还有一个问题是，由于指针会占用一些字节，每个磁盘块实际存储数据的字节数并不再是 2 的整数次幂。虽然这个问题并不会很严重，但是这种方式降低了程序运行效率。许多程序都是以长度为 2 的整数次幂来读写磁盘，由于每个块的前几个字节被指针所使用，所以要读出一个完成的块大小信息，就需要当前块的信息和下一块的信息拼凑而成，因此就引发了查找和拼接的开销。</p>
<h4 id="使用内存表进行链表分配"><a href="#使用内存表进行链表分配" class="headerlink" title="使用内存表进行链表分配"></a>使用内存表进行链表分配</h4><p>由于连续分配和链表分配都有其不可忽视的缺点。所以提出了使用内存中的表来解决分配问题。取出每个磁盘块的指针字，<strong>把它们放在内存的一个表中</strong>，就可以解决上述链表的两个不足之处。下面是一个例子</p>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/22.png" style="zoom:67%;"></p>
<p>上图表示了链表形成的磁盘块的内容。这两个图中都有两个文件，文件 A 依次使用了磁盘块地址 <strong>4、7、 2、 10、 12</strong>，文件 B 使用了<strong>6、3、11 和 14</strong>。也就是说，文件 A 从地址 4 处开始，顺着链表走就能找到文件 A 的全部磁盘块。同样，从第 6 块开始，顺着链走到最后，也能够找到文件 B 的全部磁盘块。你会发现，这两个链表都以不属于有效磁盘编号的特殊标记（-1）结束。内存中的这种表格称为 <code>文件分配表(File Application Table,FAT)</code>。</p>
<p>使用这种组织方式，整个块都可以存放数据。进而，随机访问也容易很多。虽然仍要顺着链在内存中查找给定的偏移量，但是整个链都存放在内存中，所以不需要任何磁盘引用。与前面的方法相同，不管文件有多大，在目录项中只需记录一个整数（起始块号），按照它就可以找到文件的全部块。</p>
<p>这种方式存在缺点，那就是<strong>必须要把整个链表放在内存中</strong>。对于 1TB 的磁盘和 1KB 的大小的块，那么这张表需要有 10 亿项。。。每一项对应于这 10 亿个磁盘块中的一块。每项至少 3 个字节，为了提高查找速度，有时需要 4 个字节。根据系统对空间或时间的优化方案，这张表要占用 3GB 或 2.4GB 的内存。FAT 的管理方式不能较好地扩展并应用于大型磁盘中。而这正是最初 MS-DOS 文件比较实用，并仍被各个 Windows 版本所安全支持。</p>
<h4 id="inode-1"><a href="#inode-1" class="headerlink" title="inode"></a>inode</h4><p>最后一个记录各个文件分别包含哪些磁盘块的方法是给每个文件赋予一个称为 <code>inode(索引节点)</code> 的数据结构，每个文件都与一个 <code>inode</code> 进行关联，inode 由整数进行标识。</p>
<p>下面是一个简单例子的描述。</p>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/23.png" style="zoom:67%;"></p>
<p>给出 inode 的长度，就能够找到文件中的所有块。</p>
<p>相对于在内存中使用表的方式而言，这种机制具有很大的优势。即只有在文件打开时，其 inode 才会在内存中。如果每个 inode 需要 n 个字节，最多 k 个文件同时打开，那么 inode 占有总共打开的文件是 kn 字节。仅需预留这么多空间。</p>
<p>这个数组要比我们上面描述的 <code>FAT(文件分配表)</code> 占用的空间小的多。原因是<strong>用于保存所有磁盘块的链接列表的表的大小与磁盘本身成正比</strong>。如果磁盘有 n 个块，那么这个表也需要 n 项。随着磁盘空间的变大，那么该表也随之<code>线性增长</code>。相反，inode 需要节点中的数组，<strong>其大小和可能需要打开的最大文件个数成正比</strong>。它与磁盘是 100GB、4000GB 还是 10000GB 无关。</p>
<p>inode 的一个问题是如果每个节点都会有固定大小的磁盘地址，那么文件增长到所能允许的最大容量外会发生什么？一个解决方案是<strong>最后一个磁盘地址不指向数据块</strong>，而是<strong>指向一个包含额外磁盘块地址的地址</strong>，如上图所示。一个更高级的解决方案是：有两个或者更多包含磁盘地址的块，或者指向其他存放地址的磁盘块的磁盘块。Windows 的 NTFS 文件系统采用了相似的方法，所不同的仅仅是大的 inode 也可以表示小的文件。</p>
<blockquote>
<p>NTFS 的全称是 <code>New Technology File System</code>，是微软公司开发的专用系统文件，NTFS 取代 FAT(文件分配表) 和 <code>HPFS(高性能文件系统)</code> ，并在此基础上进一步改进。例如增强对元数据的支持，使用更高级的数据结构以提升性能、可靠性和磁盘空间利用率等。</p>
</blockquote>
<h3 id="目录的实现"><a href="#目录的实现" class="headerlink" title="目录的实现"></a>目录的实现</h3><p>文件只有打开后才能够被读取。在文件打开1后，操作系统会使用用户提供的路径名来定位磁盘中的目录。目录项提供了查找文件磁盘块所需要的信息。根据系统的不同，提供的信息也不同，可能提供的信息是整个文件的磁盘地址，或者是第一个块的数量（两个链表方案）或 inode的数量。不过不管用哪种情况，目录系统的主要功能就是 <strong>将文件的 ASCII 码的名称映射到定位数据所需的信息上</strong>。</p>
<p>与此关系密切的问题是属性应该存放在哪里。每个文件系统包含不同的文件属性，例如文件的所有者和创建时间，需要存储的位置。一种显而易见的方法是直接<strong>把文件属性存放在目录中</strong>。有一些系统恰好是这么做的，如下。</p>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/24.png" style="zoom:67%;"></p>
<p>在这种简单的设计中，目录有一个固定大小的目录项列表，每个文件对应一项，其中包含一个固定长度的文件名，文件属性的结构体以及用以说明磁盘块位置的一个或多个磁盘地址。</p>
<p>对于采用 inode 的系统，会把 inode 存储在属性中而不是目录项中。在这种情况下，目录项会更短：仅仅只有文件名称和 inode 数量。这种方式如下所示</p>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/25.png" style="zoom:67%;"></p>
<p>到目前为止，我们已经假设文件具有较短的、固定长度的名字。在 MS-DOS 中，具有 1 - 8 个字符的基本名称和 1 - 3 个字符的可拓展名称。在 UNIX 版本 7 中，文件有 1 - 14 个字符，包括任何拓展。然而，几乎所有的现代操作系统都支持可变长度的扩展名。这是如何实现的呢？</p>
<p>最简单的方式是给予文件名一个长度限制，比如 255 个字符，然后使用上图中的设计，并为每个文件名保留 255 个字符空间。这种处理很简单，但是浪费了大量的目录空间，因为只有很少的文件会有那么长的文件名称。所以，需要一种其他的结构来处理。</p>
<p>一种可选择的方式是放弃所有目录项大小相同的想法。在这种方法中，每个目录项都包含一个固定部分，这个固定部分通常以目录项的长度开始，后面是固定格式的数据，通常包括<strong>所有者、创建时间、保护信息和其他属性</strong>。这个固定长度的头的后面是一个任意长度的实际文件名，如下图所示</p>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/26.png" style="zoom:67%;"></p>
<p>上图是 SPARC 机器使用正序放置。</p>
<blockquote>
<p>处理机中的一串字符存放的顺序有<code>正序(big-endian)</code> 和<code>逆序(little-endian)</code> 之分。正序存放的就是高字节在前低字节在后，而逆序存放的就是低字节在前高字节在后。</p>
</blockquote>
<p>这个例子中，有三个文件，分别是 <code>project-budget</code>、<code>personnel</code> 和 <code>foo</code>。每个文件名以一个特殊字符（通常是 0 ）结束，用矩形中的叉进行表示。</p>
<p>为了使每个目录项<strong>从字的边界开始</strong>，每个文件名被填充成整数个字，如下图所示</p>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/27.png" style="zoom:67%;"></p>
<p>这个方法的缺点是当文件被移除后，就会留下一块固定长度的空间，而新添加进来的文件大小不一定和空闲空间大小一致。</p>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/28.png" style="zoom:67%;"></p>
<p>这个问题与我们上面探讨的连续磁盘文件的问题是一样的，由于整个目录在内存中，所以只有对目录进行<code>紧凑拼接</code>操作才可节省空间。另一个问题是，一个目录项可能会分布在多个页上，<strong>在读取文件名时可能发生缺页中断</strong>。</p>
<p>处理可变长度文件名字的另外一种方法是，使目录项自身具有固定长度，而将文件名放在目录末尾的堆栈中。如上图所示的这种方式。这种方法的优点是当目录项被移除后，下一个文件将能够正常匹配移除文件的空间。当然，必须要对<code>堆</code>进行管理，因为在处理文件名的时候也会发生缺页异常。</p>
<p>到目前为止的所有设计中，在需要查找文件名时，所有的方案都是线性的从头到尾对目录进行搜索。对于特别长的目录，线性搜索的效率很低。<strong>提高文件检索效率</strong>的一种方式是在每个目录上使用<code>哈希表(hash table)</code>，也叫做<strong>散列表</strong>。我们假设表的大小为 n，在输入文件名时，文件名被散列在 0 和 n - 1 之间，例如，它被 n 除，并取余数。或者对构成文件名字的字求和或类似某种方法。</p>
<p>无论采用哪种方式，<strong>在添加一个文件时都要对与散列值相对 应的散列表进行检查</strong>。如果没有使用过，就会将一个指向目录项的指针指向这里。文件目录项紧跟着哈希表后面。如果已经使用过，就会构造一个链表（这种构造方式是不是和 HashMap 使用的数据结构一样？），链表的表头指针存放在表项中，并通过哈希值将所有的表项相连。</p>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/29.png" style="zoom:67%;"></p>
<p>查找文件的过程和添加类似:</p>
<ol>
<li>首先对文件名进行哈希处理</li>
<li>在哈希表中查找是否有这个哈希值，<ol>
<li>如果有的话，就检查这条链上所有的哈希项，查看文件名是否存在。</li>
<li>如果哈希不在链上，那么文件就不在目录中。</li>
</ol>
</li>
</ol>
<p>使用哈希表的优势是<code>查找非常迅速</code>，缺点是<code>管理起来非常复杂</code>。只有在系统中会有成千上万个目录项存在时，才会考虑使用散列表作为解决方案。</p>
<p>另外一种在大量目录中加快查找指令目录的方法是使用<code>缓存</code>，缓存查找的结果。在开始查找之前，会首先检查文件名是否在缓存中。如果在缓存中，那么文件就能立刻定位。当然，只有在较少的文件下进行多次查找，缓存才会发挥最大功效。</p>
<h3 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h3><p>当多个用户在同一个项目中工作时，他们通常需要共享文件。如果这个共享文件同时出现在多个用户目录下，那么他们协同工作起来就很方便。下面的这张图我们在上面提到过，但是有一个更改的地方，就是 <strong>C 的一个文件也出现在了 B 的目录下</strong>。</p>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/30.png" style="zoom:67%;"></p>
<p>如果按照如上图的这种组织方式而言，那么 B 的目录与该共享文件的联系称为 <code>链接(link)</code>。那么文件系统现在就是一个 <code>有向无环图(Directed Acyclic Graph, 简称 DAG)</code>，而不是一棵树了。</p>
<blockquote>
<p>在图论中，如果一个有向图从任意顶点出发无法经过若干条边回到该点，则这个图是一个<code>有向无环图</code>，我们不会在此着重探讨关于图论的东西，大家可以自行 google。</p>
</blockquote>
<p>将文件系统组织成为有向无环图<strong>会使得维护复杂化</strong>，但也是必须要付出的代价。</p>
<p><code>共享文件</code>很方便，但这也会带来一些问题。如果目录中包含磁盘地址，则当链接文件时，<strong>必须把 C 目录中的磁盘地址复制到 B 目录中</strong>。如果 B 或者 C 随后又向文件中添加内容，则仅在执行追加的用户的目录中显示新写入的数据块。这种变更将会对其他用户不可见，从而破坏了共享的目的。</p>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/31.png" style="zoom:67%;"></p>
<p>有两种方案可以解决这种问题。</p>
<ul>
<li>第一种解决方案，磁盘块不列入目录中，而是<strong>会把磁盘块放在与文件本身相关联的小型数据结构中。</strong>目录将指向这个小型数据结构。这是 <code>UNIX</code> 中使用的方式（小型数据结构就是 inode）。</li>
<li>在第二种解决方案中，通过让系统建立一个类型为 <code>LINK</code> 的新文件，并把该文件放在用户 B 的目录下，使得 B 与 C 建立链接。新的文件中只包含了它所链接的文件的路径名。当 用户B 想要读取文件C 时，操作系统会检查 用户B 的目录下存在一个类型为 LINK 的文件，进而找到该链接的文件和路径名，然后再去用户A的目录下去读文件C，这种方式称为 <code>符号链接(symbolic linking)</code>。</li>
</ul>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/32.png" style="zoom:67%;"></p>
<p>上面的每一种方法都有各自的缺点，在第一种方式中，B 链接到共享文件时，inode 记录文件的所有者为 C。<strong>建立一个链接并不改变所有关系</strong>，如下图所示。</p>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/33.png" style="zoom:67%;"></p>
<p>第一开始的情况如图 a 所示，此时 C 的目录的所有者是 C ，当目录 B 链接到共享文件时，并不会改变 C 的所有者关系，只是把计数 + 1，所以此时 <strong>系统知道目前有多少个目录指向这个文件</strong>。然后 C 尝试删除这个文件，这个时候有个问题，如果 C 把文件移除并清除了 inode 的话，那么 B 会有一个目录项指向无效的节点。如果 inode 以后分配给另一个文件，则 B 的链接指向一个错误的文件。系统通过 inode 可知文件仍在被引用，但是没有办法找到该文件的全部目录项以删除它们。指向目录的指针不能存储在 inode 中，原因是有可能有无数个这样的目录。</p>
<p>所以我们能做的就是删除 C 的目录项，但是将 inode 保留下来，并将计数设置为 1 ，如上图 c 所示。c 表示的是只有 B 有指向该文件的目录项，而该文件的前者是 C 。如果系统进行记账操作的话，那么 C 将继续为该文件付账直到 B 决定删除它，如果是这样的话，只有到计数变为 0 的时刻，才会删除该文件。</p>
<p>对于<code>符号链接</code>，以上问题不会发生，只有真正的文件所有者才有一个指向 inode 的指针。链接到该文件上的用户只有路径名，没有指向 inode 的指针。当文件所有者删除文件时，该文件被销毁。以后若试图通过符号链接访问该文件将会失败，因为系统不能找到该文件。删除符号链接不会影响该文件。</p>
<p>符号链接的问题是<strong>需要额外的开销</strong>。必须读取包含路径的文件，然后要一个部分接一个部分地扫描路径，直到找到 inode 。这些操作也许需要很多次额外的磁盘访问。此外，每个符号链接都需要额外的 inode ，以及额外的一个磁盘块用于存储路径，虽然如果路径名很短，作为一种优化，系统可以将它存储在 inode 中。符号链接有一个优势，即只要<strong>简单地提供一个机器的网络地址以及文件在该机器上驻留的路径</strong>，就可以连接全球任何地方机器上的文件。</p>
<p>还有另一个由链接带来的问题，在符号链接和其他方式中都存在。如果允许链接，文件有两个或多个路径。查找一指定目录及其子目录下的全部文件的程序将多次定位到被链接的文件。例如，一个将某一目录及其子目录下的文件转存到磁带上的程序有可能多次复制一个被链接的文件。进而，如果接着把磁带读入另一台机器，除非转出程序具有智能，否则被链接的文件将被两次复制到磁盘上，而不是只是被链接起来。</p>
<h3 id="日志结构文件系统"><a href="#日志结构文件系统" class="headerlink" title="日志结构文件系统"></a>日志结构文件系统</h3><p>技术的改变会给当前的文件系统带来压力。这种情况下，CPU 会变得越来越快，磁盘会变得越来越大并且越来越便宜（但不会越来越快）。内存容量也是以指数级增长。但是磁盘的寻道时间（除了固态盘，因为固态盘没有寻道时间）并没有获得提高。</p>
<p>这些因素结合起来意味着许多系统文件中出现性能瓶颈。为此，<code>Berkeley</code> 设计了一种全新的文件系统，试图缓解这个问题，这个文件系统就是 <code>日志结构文件系统(Log-structured File System, LFS)</code>。</p>
<p>日志结构文件系统由 <code>Rosenblum</code>和 <code>Ousterhout</code>于90年代初引入，旨在解决以下问题。</p>
<ul>
<li>不断增长的系统内存</li>
<li>顺序 I/O 性能胜过随机 I/O 性能</li>
<li>现有低效率的文件系统</li>
<li>文件系统不支持 RAID（虚拟化）</li>
</ul>
<p>另一方面，当时的文件系统不论是 UNIX 还是 FFS，都有大量的随机读写（在 FFS 中创建一个新文件至少需要5次随机写），因此成为整个系统的性能瓶颈。同时因为 <code>Page cache</code>的存在，作者认为随机读不是主要问题：随着越来越大的内存，大部分的读操作都能被 cache，因此 LFS 主要要解决的是减少对硬盘的随机写操作。</p>
<p>在这种设计中，inode 甚至具有与 UNIX 中相同的结构，但是现在它们分散在整个日志中，而不是位于磁盘上的固定位置。所以，inode 很定位。为了能够找到 inode ，维护了一个由 inode 索引的 <code>inode map(inode 映射)</code>。表项 i 指向磁盘中的第 i 个 inode 。这个映射保存在磁盘中，但是也保存在缓存中，因此，使用最频繁的部分大部分时间都在内存中。</p>
<blockquote>
<p>日志结构文件系统主要使用四种数据结构：Inode、Inode Map、Segment、Segment Usage Table。</p>
</blockquote>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/34.png" style="zoom:67%;"></p>
<p>到目前为止，所有写入最初都缓存在<code>内存</code>中，并且追加在<code>日志末尾</code>，所有缓存的写入都定期在单个段中写入磁盘。所以，现在打开文件也就意味着用映射定位文件的索引节点。一旦 inode 被定位后，磁盘块的地址就能够被找到。所有这些块本身都将位于日志中某处的分段中。</p>
<p>真实情况下的磁盘容量是有限的，所以最终日志会占满整个磁盘空间，这种情况下就会出现没有新的磁盘块被写入到日志中。幸运的是，许多现有段可能具有不再需要的块。例如，如果一个文件被覆盖了，那么它的 inode 将被指向新的块，但是旧的磁盘块仍在先前写入的段中占据着空间。</p>
<p>为了处理这个问题，LFS 有一个<code>清理(clean)</code>线程，它会循环扫描日志并对日志进行压缩。首先，通过查看日志中第一部分的信息来查看其中存在哪些索引节点和文件。它会检查当前 inode 的映射来查看 inode 否在在当前块中，是否仍在被使用。如果不是，该信息将被丢弃。如果仍然在使用，那么 inode 和块就会进入内存等待写回到下一个段中。然后原来的段被标记为空闲，以便日志可以用来存放新的数据。用这种方法，清理线程遍历日志，从后面移走旧的段，然后将有效的数据放入内存等待写到下一个段中。由此一来整个磁盘会形成一个大的<code>环形缓冲区</code>，写线程将新的段写在前面，而清理线程则清理后面的段。</p>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/35.png" style="zoom:67%;"></p>
<h3 id="日志文件系统"><a href="#日志文件系统" class="headerlink" title="日志文件系统"></a>日志文件系统</h3><p>虽然日志结构系统的设计很优雅，但是由于它们和现有的文件系统不相匹配，因此还没有广泛使用。不过，从日志文件结构系统衍生出来一种新的日志系统，叫做<code>日志文件系统</code>，<strong>它会记录系统下一步将要做什么的日志</strong>。微软的 <code>NTFS</code> 文件系统、Linux 的 <code>ext3</code> 就使用了此日志。 <code>OS X</code> 将日志系统作为可供选项。为了看清它是如何工作的，我们下面讨论一个例子，比如 <code>移除文件</code> ，这个操作在 UNIX 中需要三个步骤完成：</p>
<ul>
<li>在目录中删除文件</li>
<li>释放 inode 到空闲 inode 池</li>
<li>将所有磁盘块归还给空闲磁盘池。</li>
</ul>
<p>在 Windows 中，也存在类似的步骤。不存在系统崩溃时，这些步骤的执行顺序不会带来问题。但是一旦系统崩溃，就会带来问题。假如在第一步完成后系统崩溃。inode 和文件块将不会被任何文件获得，也不会再分配；它们只存在于废物池中的某个地方，并因此减少了可利用的资源。如果崩溃发生在第二步后，那么只有磁盘块会丢失。<code>日志文件系统</code>保留磁盘写入期间对文件系统所做的更改的日志或日志，该日志可用于快速重建可能由于系统崩溃或断电等事件而发生的损坏。</p>
<blockquote>
<p>一般文件系统崩溃后必须运行 <code>fsck（文件系统一致性检查）</code>实用程序。</p>
</blockquote>
<p>为了让日志能够正确工作，被写入的日志操作必须是 <code>幂等的(idempotent)</code>，它意味着只要有必要，它们就可以重复执行很多次，并不会带来破坏。像操作 <strong>更新位表并标记 inode k 或者块 n 是空闲的</strong> 可以重复执行任意次。同样地，查找一个目录并且删除所有叫 <code>foobar</code> 的项也是幂等的。相反，把从 inode k 新释放的块加入空闲表的末端不是幂等的，因为它们可能已经被释放并存放在那里了。</p>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/36.png" style="zoom:67%;"></p>
<p>为了增加可靠性，一个文件系统可以引入数据库中 <code>原子事务(atomic transaction)</code> 的概念。使用这个概念，一组动作可以被界定在开始事务和结束事务操作之间。这样，文件系统就会知道它必须完成所有的动作，要么就一个不做。</p>
<h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p>即使在同一台计算机上或者在同一个操作系统下，都会使用很多不同的文件系统。Windows 中的主要文件系统是 <code>NTFS 文件系统</code>，但不是说 Windows 只有 NTFS 操作系统，它还有一些其他的例如旧的 <code>FAT -32</code> 或<code>FAT -16</code> 驱动器或分区，其中包含仍需要的数据，闪存驱动器，旧的 CD-ROM 或 DVD（每个都有自己的独特文件系统）。Windows 通过指定不同的盘符来处理这些不同的文件系统，比如 <code>C:</code>，<code>D:</code> 等。盘符可以显示存在也可以隐式存在，如果你想找指定位置的文件，那么盘符是显示存在；如果当一个进程打开一个文件时，此时盘符是隐式存在，所以 Windows 知道向哪个文件系统传递请求。</p>
<p>相比之下，UNIX 采用了一种不同的方式，即 UNIX <strong>把多种文件系统整合到一个统一的结构中</strong>。一个 Linux 系统可以使用 <code>ext2</code> 作为根文件系统，<code>ext3</code> 分区装载在 <code>/usr</code> 下，另一块采用 <code>Reiser FS</code> 文件系统的硬盘装载到 <code>/home</code>下，以及一个 ISO 9660 的 CD - ROM 临时装载到 <code>/mnt</code> 下。从用户的观点来看，只有一个文件系统层级，但是事实上它们是由多个文件系统组合而成，对于用户和进程是不可见的。</p>
<p>UNIX 操作系统使用一种 <code>虚拟文件系统(Virtual File System, VFS)</code> 来尝试将多种文件系统构成一个有序的结构。关键的思想是抽象出所有文件系统都共有的部分，并将这部分代码放在一层，这一层再调用具体文件系统来管理数据。下面是一个 VFS 的系统结构</p>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/37.png" style="zoom:67%;"></p>
<p>还是那句经典的话，在计算机世界中，任何解决不了的问题都可以加个<code>代理</code>来解决。所有和文件相关的系统调用在最初的处理上都指向虚拟文件系统。这些来自用户进程的调用，都是标准的 <code>POSIX 系统调用</code>，比如 open、read、write 和 seek 等。VFS 对用户进程有一个 <code>上层</code> 接口，这个接口就是著名的 POSIX 接口。</p>
<p>VFS 也有一个对于实际文件的 <code>下层</code> 接口，就是上图中标记为 VFS 的接口。这个接口包含许多功能调用，这样 VFS 可以使每一个文件系统完成任务。因此，要创建一个可以与 VFS 一起使用的新文件系统，新文件系统的设计者必须确保它提供了 VFS 要求的功能。一个明显的例子是从磁盘读取特定的块，然后将其放入文件系统的缓冲区高速缓存中，然后返回指向该块的指针的函数。 因此，VFS具有两个不同的接口：上一个到用户进程，下一个到具体文件系统。</p>
<p>当系统启动时，根文件系统在 VFS 中注册。另外，当装载其他文件时，不管在启动时还是在操作过程中，它们也必须在 VFS 中注册。当一个文件系统注册时，根文件系统注册到 VFS。另外，在引导时或操作期间挂载其他文件系统时，它们也必须向 VFS 注册。当文件系统注册时，其基本作用是提供 VFS 所需功能的地址列表、调用向量表、或者 VFS 对象。因此一旦文件系统注册到 VFS，它就知道从哪里开始读取数据块。</p>
<p>装载文件系统后就可以使用它了。比如，如果一个文件系统装载到 <code>/usr</code> 并且一个进程调用它：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open("/usr/include/unistd.h",O_RDONLY)</span><br></pre></td></tr></table></figure>
<p>当解析路径时， VFS 看到新的文件系统被挂载到 <code>/usr</code>，并且通过搜索已经装载文件系统的超级块来确定它的超块。然后它找到它所转载的文件的根目录，在那里查找路径 <code>include/unistd.h</code>。然后 VFS 创建一个 vnode 并调用实际文件系统，以返回所有的在文件 inode 中的信息。这个信息和其他信息一起复制到 vnode （内存中）。而这些其他信息中最重要的是指向包含调用 vnode 操作的函数表的指针，比如 read、write 和 close 等。</p>
<p>当 vnode 被创建后，为了进程调用，VFS 在文件描述符表中创建一个表项，并将它指向新的 vnode，最后，VFS 向调用者返回文件描述符，所以调用者可以用它去 read、write 或者 close 文件。</p>
<p>当进程用文件描述符进行一个读操作时，VFS 通过进程表和文件描述符确定 vnode 的位置，并跟随指针指向函数表，这样就调用了处理 read 函数，运行在实际系统中的代码并得到所请求的块。VFS 不知道请求时来源于本地硬盘、还是来源于网络中的远程文件系统、CD-ROM 、USB 或者其他介质，所有相关的数据结构欧如下图所示</p>
<p><img src="/2021/06/22/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/38.png" style="zoom:67%;"></p>
<p><strong>从调用者进程号和文件描述符开始，进而是 vnode，读函数指针，然后是对实际文件系统的访问函数定位</strong>。</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/06/21/IO%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/21/IO%E7%AE%A1%E7%90%86/" itemprop="url">IO管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-06-21T16:23:01+08:00">
                2021-06-21
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-08-23T14:21:54+08:00">
                2022-08-23
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="I-O管理"><a href="#I-O管理" class="headerlink" title="I/O管理"></a>I/O管理</h1><p>搬运自: <a href="https://www.cnblogs.com/cxuanBlog/p/13156493.html" target="_blank" rel="noopener">https://www.cnblogs.com/cxuanBlog/p/13156493.html</a></p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/1.png" style="zoom:67%;"></p>
<p>我们之前的文章提到了操作系统的三个抽象，它们分别是<strong>进程、地址空间和文件</strong>，除此之外，操作系统还要控制所有的 I/O 设备。操作系统必须向设备<code>发送命令</code>，<code>捕捉中断</code>并<code>处理错误</code>。它还应该在设备和操作系统的其余部分之间提供一个简单易用的接口。操作系统<strong>如何管理 I/O</strong> 是我们接下来的重点。</p>
<p>不同的人对 I/O 硬件的理解也不同。对于电子工程师而言，I/O 硬件就是芯片、导线、电源和其他组成硬件的物理设备。而我们程序员眼中的 I/O 其实就是硬件提供给软件的<code>接口</code>，比如硬件接受到的命令、执行的操作以及反馈的错误。我们着重探讨的是<strong>如何对硬件进行编程</strong>，而不是其工作原理。</p>
<h2 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h2><p>I/O 设备又叫做输入/输出设备，它<strong>是人类用来和计算机进行通信的外部硬件</strong>。输入/输出设备能够向计算机发送数据(输出)并从计算机接收数据(输入)</p>
<p><code>I/O设备</code> 可以分成两种：块设备和字符设备</p>
<h4 id="块设备"><a href="#块设备" class="headerlink" title="块设备"></a>块设备</h4><p>块设备是一个能存储 <strong>固定大小块</strong>信息的设备，它支持以固定大小的块、扇区或群集读取和(可选)写入数据。每个块都有自己的<code>物理地址</code>。通常快的大小在512~65536之间。所有传输的信息都会以<code>连续</code>的块为单位。块设备的基本特征是每个块都较为对立，能够独立得进行读写。常见的块设备有：硬盘、光盘、U盘</p>
<h5 id="块设备的缺点"><a href="#块设备的缺点" class="headerlink" title="块设备的缺点"></a>块设备的缺点</h5><p>基于给定固态存储器的块设备比基于相同类型的存储器的<strong>字节寻址要慢一些</strong>，因为必须在块的开头开始读取或写入。所以，要读取该块的任何部分，必须寻找到该块的开始，读取整个块，如果不使用该块，则将其丢弃；要写入块的一部分，必须寻找到块的开始，将整个块读入内存，修改数据，再次寻找到块的开头处，然后将整个块写回设备。</p>
<h4 id="字符设备"><a href="#字符设备" class="headerlink" title="字符设备"></a>字符设备</h4><p>另一类 I/O 设备是<code>字符设备</code>。字符设备以<code>字符</code>为单位发送或接收一个字符流，而不考虑任何块结构。字符设备是不可寻址的，也没有任何寻道操作。常见的字符设备有 <strong>打印机、网络设备、鼠标、以及大多数与磁盘不同的设备</strong>。</p>
<h4 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h4><p>首先需要先了解一下设备控制器的概念。</p>
<p><strong>设备控制器是处理 CPU 传入和传出信号的系统</strong>。设备通过插头和插座连接到计算机，并且插座连接到设备控制器。设备控制器从连接的设备处接收数据，并将其存储在控制器内部的一些<code>特殊目的寄存器(special purpose registers)</code> 也就是本地缓冲区中。</p>
<p>I/O 设备通常由<code>机械组件(mechanical component)</code>和<code>电子组件(electronic component)</code>构成。电子组件被称为 <code>设备控制器(device controller)</code>或者 <code>适配器(adapter)</code>。在个人计算机上，它通常采用<code>可插入（PCIe）扩展插槽</code>的主板上的芯片或印刷电路卡的形式。</p>
<p>控制器与设备之间的接口通常是一个低层次的接口。例如，磁盘可能被格式化为 2,000,000 个扇区，每个磁道 512 字节。然而，实际从驱动出来的却是一个串行的比特流，从一个<code>前导符(preamble)</code>开始，然后是一个扇区中的 4096 位，最后是一个<code>校验和</code> 或 <code>ECC（错误码，Error-Correcting Code）</code>。前导符是在对磁盘进行格式化的时候写上去的，它包括柱面数和扇区号，扇区大小以及类似的数据，此外还包含同步信息。</p>
<p>控制器的任务是把串行的位流转换为字节块，并进行必要的错误校正工作。字节块通常会在控制器内部的一个缓冲区按位进行组装，然后再对校验和进行校验并证明字节块没有错误后，再将它复制到内存中。</p>
<h3 id="内存映射-I-O"><a href="#内存映射-I-O" class="headerlink" title="内存映射 I/O"></a>内存映射 I/O</h3><p>每个控制器都会有几个寄存器用来和 CPU 进行通信。通过写入这些寄存器，操作系统可以命令设备发送数据，接收数据、开启或者关闭设备等。通过从这些寄存器中读取信息，操作系统能够知道设备的状态，是否准备接受一个新命令等。</p>
<p>为了控制<code>寄存器</code>，许多设备都会有<code>数据缓冲区(data buffer)</code>，来供系统进行读写。例如，在屏幕上显示一个像素的常规方法是使用一个视频 RAM，这一 RAM 基本上只是一个数据缓冲区，用来供程序和操作系统写入数据。</p>
<p>那么问题来了，CPU 如何<strong>与设备寄存器和设备数据缓冲区进行通信呢</strong>？存在两个可选的方式。</p>
<p>第一种方法是，每个控制寄存器都被分配一个 <code>I/O 端口(I/O port)</code>号，这是一个 <strong>8 位或 16 位</strong>的整数。所有 I/O 端口的集合形成了受保护的 I/O 端口空间，以便普通用户程序无法访问它（只有操作系统可以访问）。使用特殊的 I/O 指令像是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IN REG,PORT</span><br></pre></td></tr></table></figure>
<p>CPU 可以读取控制寄存器 PORT 的内容并将结果放在 CPU 寄存器 REG 中。类似的，使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OUT PORT,REG</span><br></pre></td></tr></table></figure>
<p>CPU 可以将 REG 的内容写到控制寄存器中。大多数早期计算机，包括几乎所有大型主机，如 IBM 360 及其所有后续机型，都是以这种方式工作的。</p>
<blockquote>
<p>控制寄存器是一个处理器寄存器而改变或控制的一般行为 CPU 或其他数字设备。控制寄存器执行的常见任务包括中断控制，切换寻址模式，分页控制和协处理器控制。</p>
</blockquote>
<p>在这一方案中，<strong>内存地址空间和 I/O 地址空间是不相同的</strong>，如下图所示</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/2.png" style="zoom:67%;"> </p>
<p>指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IN R0,4</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV R0,4</span><br></pre></td></tr></table></figure>
<p>这一设计中完全不同。<strong>前者读取 I/O端口 4 的内容并将其放入 R0，而后者读取存储器字 4 的内容并将其放入 R0</strong>。这些示例中的 <strong>4 代表不同且不相关的地址空间</strong>。</p>
<p>第二个方法是 PDP-11 引入的，</p>
<blockquote>
<p>什么是 PDP-11?</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/3.png" style="zoom:67%;"></p>
</blockquote>
<p>它将<strong>所有控制寄存器映射到内存空间</strong>中，如下图所示</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/4.png" style="zoom:67%;"></p>
<p><code>内存映射的 I/O</code>是在 CPU 与其连接的外围设备之间交换数据和指令的一种方式，这种方式是处理器和 IO 设备共享同一<code>内存位置</code>的内存，即处理器和 IO 设备使用内存地址进行映射。</p>
<p>在大多数系统中，分配给控制寄存器的地址位于或者靠近地址的顶部附近。</p>
<p>下面是采用的一种混合方式</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/5.png" style="zoom:67%;"></p>
<p>这种方式具有与内存映射 I/O 的数据缓冲区，而控制寄存器则具有单独的 I/O 端口。x86 采用这一体系结构。在 IBM PC 兼容机中，除了 0 到 64K - 1 的 I/O 端口之外，640 K 到 1M - 1 的内存地址保留给设备的数据缓冲区。</p>
<p>这些方案是如何工作的呢？</p>
<p>当 CPU 想要读入一个字的时候，无论是从内存中读入还是从 I/O 端口读入，它都要将需要的地址放到总线地址线上，然后在总线的一条控制线上调用一个 <code>READ</code> 信号。<br>还有第二条信号线来表明需要的是 I/O 空间还是内存空间。如果是内存空间，内存将响应请求。如果是 I/O 空间，那么 I/O 设备将响应请求。<br>如果只有内存空间，那么每个内存模块和每个 I/O 设备都会将地址线和它所服务的地址范围进行比较。如果地址落在这一范围之内，它就会响应请求。<br>绝对不会出现地址既分配给内存又分配给 I/O 设备，所以不会存在歧义和冲突。</p>
<h4 id="内存映射-I-O-的优点和缺点"><a href="#内存映射-I-O-的优点和缺点" class="headerlink" title="内存映射 I/O 的优点和缺点"></a>内存映射 I/O 的优点和缺点</h4><p>这两种寻址控制器的方案具有不同的优缺点。先来看一下内存映射 I/O 的优点。</p>
<ul>
<li>第一，如果需要特殊的 I/O 指令读写设备控制寄存器，那么访问这些寄存器<strong>需要使用汇编代码</strong>，因为在 C 或 C++ 中不存在执行 <code>IN</code> 和 <code>OUT</code>指令的方法。调用这样的过程<strong>增加了 I/O 的开销</strong>。在内存映射中，控制寄存器只是内存中的变量，在 C 语言中可以和其他变量一样进行寻址。</li>
<li>第二，对于内存映射 I/O ，不需要特殊的保护机制就能够阻止用户进程执行 I/O 操作。操作系统需要保证的是禁止把控制寄存器的地址空间放在用户的虚拟地址中就可以了。</li>
<li>第三，对于内存映射 I/O，可以引用内存的每一条指令也可以引用控制寄存器，<strong>便于引用</strong></li>
</ul>
<p>在计算机设计中，几乎所有的事情都要权衡。内存映射 I/O 也是一样，它也有自己的缺点。</p>
<ul>
<li>首先，大部分计算机现在都会有一些对于内存字的缓存。缓存一个设备控制寄存器的代价是很大的。为了避免这种内存映射 I/O 的情况，硬件必须有选择性的禁用缓存，例如，在每个页面上禁用缓存，这个功能为硬件和操作系统增加了额外的复杂性，因此必须选择性的进行管理。</li>
<li>第二点，如果仅仅只有一个地址空间，那么所有的<code>内存模块(memory modules)</code>和所有的 I/O 设备都必须检查所有的内存引用来推断出谁来进行响应。</li>
</ul>
<blockquote>
<p>什么是内存模块？在计算中，存储器模块是其上安装有存储器集成电路的印刷电路板。</p>
</blockquote>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/6.png" style="zoom:67%;"></p>
<p>如果计算机是一种单总线体系结构的话，如下图所示</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/7.png" style="zoom:67%;"></p>
<p>让每个内存模块和 I/O 设备查看每个地址是简单易行的。</p>
<p>然而，现代个人计算机的趋势是专用的高速内存总线，如下图所示</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/8.png" style="zoom:67%;"></p>
<p>装备这一总线是为了优化内存访问速度，x86 系统还可以有多种总线（内存、PCIe、SCSI 和 USB）。如下图所示</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/9.png" style="zoom:67%;"></p>
<p>在内存映射机器上使用单独的内存总线的麻烦之处在于，I/O 设备无法通过内存总线查看内存地址，因此它们无法对其进行响应。此外，必须采取特殊的措施使内存映射 I/O 工作在具有多总线的系统上。一种可能的方法是首先将全部内存引用发送到内存，如果内存响应失败，CPU 再尝试其他总线。</p>
<p>第二种设计是在内存总线上放一个<code>探查设备</code>，放过所有潜在指向所关注的 I/O 设备的地址。此处的问题是，I/O 设备可能无法以内存所能达到的速度处理请求。</p>
<p>第三种可能的设计是在内存控制器中对地址进行过滤，这种设计与上图所描述的设计相匹配。这种情况下，内存控制器芯片中包含在引导时预装载的范围寄存器。这一设计的缺点是需要在引导时判定哪些内存地址而不是真正的内存地址。因而，每一设计都有支持它和反对它的论据，所以折中和权衡是不可避免的。</p>
<h3 id="直接内存访问"><a href="#直接内存访问" class="headerlink" title="直接内存访问"></a>直接内存访问</h3><p>无论一个 CPU 是否具有内存映射 I/O，它都需要寻址设备控制器以便与它们交换数据。CPU 可以从 I/O 控制器每次请求一个字节的数据，但是这么做会浪费 CPU 时间，所以经常会用到一种称为<code>直接内存访问(Direct Memory Access)</code> 的方案。为了简化，我们假设 CPU 通过单一的系统总线访问所有的设备和内存，该总线连接 CPU 、内存和 I/O 设备，如下图所示</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/10.png" style="zoom:67%;"></p>
<p>现代操作系统实际更为复杂，但是原理是相同的。如果硬件有<code>DMA 控制器</code>，那么操作系统只能使用 DMA。有时这个控制器会集成到磁盘控制器和其他控制器中，但这种设计需要在每个设备上都装有一个分离的 DMA 控制器。单个的 DMA 控制器可用于向多个设备传输，这种传输往往同时进行。</p>
<p>不管 DMA 控制器的物理地址在哪，它都能够独立于 CPU 从而访问系统总线，如上图所示。它包含几个可由 CPU 读写的寄存器，其中包括一个内存地址寄存器，字节计数寄存器和一个或多个控制寄存器。控制寄存器指定要<strong>使用的 I/O 端口、传送方向（从 I/O 设备读或写到 I/O 设备）、传送单位（每次一个字节或者每次一个字）以及在一次突发传送中要传送的字节数</strong>。</p>
<p>为了解释 DMA 的工作原理，我们首先看一下不使用 DMA 该如何进行磁盘读取。</p>
<ul>
<li>首先，控制器从<code>磁盘驱动器</code>串行地、一位一位的读一个块（一个或多个扇区），直到将整块信息放入控制器的内部缓冲区。</li>
<li>读取<code>校验和</code>以保证没有发生读错误。然后控制器会产生一个中断，当操作系统开始运行时，它会重复的从控制器的缓冲区中一次一个字节或者一个字地读取该块的信息，并将其存入内存中。</li>
</ul>
<h4 id="DMA-工作原理"><a href="#DMA-工作原理" class="headerlink" title="DMA 工作原理"></a>DMA 工作原理</h4><p>当使用 DMA 后，这个过程就会变得不一样了。<br>首先 CPU 通过设置 DMA 控制器的寄存器对它进行编程，所以 DMA 控制器知道将什么数据传送到什么地方。DMA 控制器还要向磁盘控制器发出一个命令，通知它从磁盘读数据到其内部的缓冲区并检验校验和。当有效数据位于磁盘控制器的缓冲区中时，DMA 就可以开始了。</p>
<p>第二步： DMA 控制器通过在总线上发出一个<code>读请求</code>到磁盘控制器而发起 DMA 传送。这个读请求就像其他读请求一样，磁盘控制器并不知道或者并不关心它是来自 CPU 还是来自 DMA 控制器。<br>第三步：通常情况下，要写的内存地址在总线的地址线上，所以当磁盘控制器去匹配下一个字时，它知道将该字写到什么地方，写到内存就是另外一个总线循环了。</p>
<p>第四步：当写操作完成时，磁盘控制器在总线上发出一个应答信号到 DMA 控制器。</p>
<p>然后，DMA 控制器会<strong>增加内存地址并减少字节数量</strong>。如果字节数量仍然大于 0 ，就会循环步骤 2 - 步骤 4 ，直到字节计数变为 0 。此时，DMA 控制器会打断 CPU 并告诉它传输已经完成了。操作系统开始运行时，它不会把磁盘块拷贝到内存中，因为它已经在内存中了。</p>
<p>不同 DMA 控制器的复杂程度差别很大。最简单的 DMA 控制器每次处理一次传输，就像上面描述的那样。更为复杂的情况是一次同时处理很多次传输，这样的控制器内部具有多组寄存器，每个通道一组寄存器。在传输每一个字之后，DMA 控制器就决定下一次要为哪个设备提供服务。DMA 控制器可能被设置为使用 <code>轮询算法</code>，或者它也有可能具有一个优先级规划设计，以便让某些设备受到比其他设备更多的照顾。假如存在一个明确的方法分辨应答信号，那么在同一时间就可以挂起对不同设备控制器的多个请求。</p>
<p>许多总线能够以两种模式操作：<strong>每次一字模式和块模式</strong>。一些 DMA 控制器也能够使用这两种方式进行操作。在前一个模式中，DMA 控制器请求传送一个字并得到这个字。如果 CPU 想要使用总线，它必须进行等待。设备可能会偷偷进入并且从 CPU 偷走一个总线周期，从而轻微的延迟 CPU。这种机制称为 <code>周期窃取(cycle stealing)</code>。</p>
<p>在块模式中，DMA 控制器告诉设备获取总线，然后进行一系列的传输操作，然后释放总线。这一操作的形式称为 <code>突发模式(burst mode)</code>。这种模式要比周期窃取更有效因为获取总线占用了时间，并且一次总线获得的代价是可以同时传输多个字。缺点是如果此时进行的是长时间的突发传送，有可能将 CPU 和其他设备阻塞很长的时间。</p>
<p>在我们讨论的这种模型中，有时被称为 <code>飞越模式(fly-by mode)</code>，DMA 控制器会告诉设备控制器把数据直接传递到内存。一些 DMA 控制器使用的另一种模式是让设备控制器将字发送给 DMA 控制器，然后 DMA 控制器发出第二条总线请求，将字写到任何可以写入的地方。采用这种方案，每个传输的字都需要一个额外的总线周期，但是更加灵活，因为它还可以执行设备到设备的复制，甚至是内存到内存的复制（通过事先对内存进行读取，然后对内存进行写入）。</p>
<p>大部分的 DMA 控制器使用物理地址进行传输。使用物理地址需要操作系统将目标内存缓冲区的虚拟地址转换为物理地址，并将该物理地址写入 DMA 控制器的地址寄存器中。另一种方案是一些 DMA 控制器将虚拟地址写入 DMA 控制器中。<br>然后，DMA 控制器必须使用 MMU 才能完成虚拟到物理的转换。仅当 MMU 是内存的一部分而不是 CPU 的一部分时，才可以将虚拟地址放在总线上。</p>
<h3 id="重温中断"><a href="#重温中断" class="headerlink" title="重温中断"></a>重温中断</h3><p>在一台个人计算机体系结构中，中断结构会如下所示</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/11.png" style="zoom:67%;"></p>
<p>当一个 I/O 设备完成它的工作后，它就会产生一个中断（默认操作系统已经开启中断），它通过在总线上声明已分配的信号来实现此目的。主板上的中断控制器芯片会检测到这个信号，然后执行中断操作。</p>
<p>如果在中断前没有其他中断操作阻塞的话，中断控制器将立刻对中断进行处理，如果在中断前还有其他中断操作<code>正在执行</code>，或者有其他设备发出级别<code>更高</code>的中断信号的话，那么这个设备将暂时不会处理。在这种情况下，该设备会继续在总线上置起中断信号，直到得到 CPU 服务。</p>
<p>为了处理中断，中断控制器在地址线上放置一个数字，指定要关注的设备是哪个，并声明一个信号以中断 CPU。中断信号导致 CPU 停止当前正在做的工作并且开始做其他事情。地址线上会有一个指向<code>中断向量表</code> 的索引，用来获取下一个程序计数器。这个新获取的程序计数器也就表示着程序将要开始，它会指向程序的开始处。一般情况下，陷阱和中断从这一点上看使用相同的机制，并且常常共享相同的中断向量。中断向量的位置可以硬连线到机器中，也可以位于内存中的任何位置，由 CPU 寄存器指向其起点。</p>
<p>中断服务程序开始运行后，中断服务程序通过将某个值写入中断控制器的 I/O 端口来确认中断。告诉它中断控制器可以自由地发出另一个中断。通过让 CPU 延迟响应来达到多个中断同时到达 CPU 涉及到竞争的情况发生。一些老的计算机没有集中的中断控制器，通常每个设备请求自己的中断。</p>
<p>硬件通常在服务程序开始前保存当前信息。对于不同的 CPU 来说，哪些信息需要保存以及保存在哪里差别很大。不管其他的信息是否保存，程序计数器必须要被保存，这对所有的 CPU 来说都是相同的，以此来恢复中断的进程。所有可见寄存器和大量内部寄存器也应该被保存。</p>
<p>上面说到硬件应该保存当前信息，那么保存在哪里是个问题，一种选择是将其放入到内部寄存器中，在需要时操作系统可以读出这些内部寄存器。这种方法会造成的问题是：一段时间内设备无法响应，直到所有的内部寄存器中存储的信息被读出后，才能恢复运行，以免第二个内部寄存器重写内部寄存器的状态。</p>
<p>第二种方式是在堆栈中保存信息，这也是大部分 CPU 所使用的方式。但是，这种方法也存在问题，因为使用的堆栈不确定，如果使用的是<code>当前堆栈</code>，则它很可能是用户进程的堆栈。堆栈指针甚至不合法，这样当硬件试图在它所指的地址处写入时，将会导致致命错误。如果使用的是内核堆栈，堆栈指针是合法的并且指向一个固定的页面，这样的机会可能会更大。然而，切换到内核态需要切换 MMU 上下文，并且可能使高速缓存或者 TLB 失效。静态或动态重新装载这些东西将增加中断处理的时间，浪费 CPU 时间。</p>
<h4 id="精确中断和不精确中断"><a href="#精确中断和不精确中断" class="headerlink" title="精确中断和不精确中断"></a>精确中断和不精确中断</h4><p>另一个问题是：现代 CPU 大量的采用<code>流水线</code>并且有时还采用<code>超标量(内部并行)</code>。在一些老的系统中，每条指令执行完毕后，微程序或硬件将检查是否存在未完成的中断。如果存在，那么程序计数器和 PSW 将被压入堆栈中开始中断序列。在中断程序运行之后，旧的 PSW 和程序计数器将从堆栈中弹出恢复先前的进程。</p>
<p>下面是一个流水线模型</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/12.png" style="zoom:67%;"></p>
<p>在流水线满的时候出现一个中断会发生什么情况？许多指令正处于不同的执行阶段，中断出现时，程序计数器的值可能无法正确地反应已经执行过的指令和尚未执行的指令的边界。事实上，许多指令可能部分执行力，不同的指令完成的程度或多或少。在这种情况下，a程序计数器更有可能反应的是将要被取出并压入流水线的下一条指令的地址，而不是刚刚被执行单元处理过的指令的地址。</p>
<p>在超标量的设计中，可能更加糟糕</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/13.png" style="zoom:67%;"></p>
<p>每个指令都可以分解成为微操作，微操作有可能乱序执行，这取决于内部资源（如功能单元和寄存器）的可用性。当中断发生时，某些很久以前启动的指令可能还没开始执行，而最近执行的指令可能将要马上完成。在中断信号出现时，可能存在许多指令处于不同的完成状态，它们与程序计数器之间没有什么关系。</p>
<p>使机器处于良好状态的中断称为<code>精确中断(precise interrupt)</code>。这样的中断具有四个属性：</p>
<ul>
<li>PC （程序计数器）保存在一个已知的地方</li>
<li>PC 所指向的指令之前所有的指令已经完全执行</li>
<li>PC 所指向的指令之后所有的指令都没有执行</li>
<li>PC 所指向的指令的执行状态是已知的</li>
</ul>
<p>不满足以上要求的中断称为 <code>不精确中断(imprecise interrupt)</code>，不精确中断让人很头疼。上图描述了不精确中断的现象。指令的执行时序和完成度具有不确定性，而且恢复起来也非常麻烦。</p>
<h2 id="IO-软件原理"><a href="#IO-软件原理" class="headerlink" title="IO 软件原理"></a>IO 软件原理</h2><h3 id="I-O-软件目标"><a href="#I-O-软件目标" class="headerlink" title="I/O 软件目标"></a>I/O 软件目标</h3><h4 id="设备独立性"><a href="#设备独立性" class="headerlink" title="设备独立性"></a>设备独立性</h4><p>现在让我们转向对 I/O 软件的研究，I/O 软件设计一个很重要的目标就是<code>设备独立性(device independence)</code>。啥意思呢？这意味着<strong>我们能够编写访问任何设备的应用程序，而不用事先指定特定的设备</strong>。比如你编写了一个能够从设备读入文件的应用程序，那么这个应用程序可以从硬盘、DVD 或者 USB 进行读入，不必再为每个设备定制应用程序。这其实就体现了设备独立性的概念。</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/14.png" style="zoom:67%;"></p>
<p>再比如说你可以输入一条下面的指令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort 输入 输出</span><br></pre></td></tr></table></figure>
<p>那么上面这个 <code>输入</code> 就可以接收来自任意类型的磁盘或者键盘，并且 <code>输出</code> 可以写入到任意类型的磁盘或者屏幕。</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/15.png" style="zoom:67%;"></p>
<p>计算机操作系统是这些硬件的媒介，因为不同硬件它们的指令序列不同，所以需要操作系统来做指令间的转换。</p>
<p>与设备独立性密切相关的一个指标就是<code>统一命名(uniform naming)</code>。设备的代号应该是一个整数或者是字符串，它们不应该依赖于具体的设备。在 UNIX 中，所有的磁盘都能够被集成到文件系统中，所以用户不用记住每个设备的具体名称，直接记住对应的路径即可，如果路径记不住，也可以通过 <code>ls</code> 等指令找到具体的集成位置。举个例子来说，比如一个 USB 磁盘被挂载到了 <code>/usr/cxuan/backup</code> 下，那么你把文件复制到 <code>/usr/cxuan/backup/device</code> 下，就相当于是把文件复制到了磁盘中，通过这种方式，实现了向任何磁盘写入文件都相当于是向指定的路径输出文件。</p>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>除了<code>设备独立性</code>外，I/O 软件实现的第二个重要的目标就是<code>错误处理(error handling)</code>。通常情况下来说，错误应该交给<code>硬件</code>层面去处理。如果设备控制器发现了读错误的话，它会尽可能的去修复这个错误。如果设备控制器处理不了这个问题，那么设备驱动程序应该进行处理，设备驱动程序会再次尝试读取操作，很多错误都是偶然性的，如果设备驱动程序无法处理这个错误，才会把错误向上抛到硬件层面（上层）进行处理，很多时候，上层并不需要知道下层是如何解决错误的。这就很像项目经理不用把每个决定都告诉老板；程序员不用把每行代码如何写告诉项目经理。这种处理方式不够透明。</p>
<h4 id="同步和异步传输"><a href="#同步和异步传输" class="headerlink" title="同步和异步传输"></a>同步和异步传输</h4><p>I/O 软件实现的第三个目标就是 <code>同步(synchronous)</code> 和 <code>异步(asynchronous，即中断驱动)</code>传输。这里先说一下同步和异步是怎么回事吧。</p>
<p>同步传输中数据通常以块或帧的形式发送。发送方和接收方在数据传输之前应该具有<code>同步时钟</code>。而在异步传输中，数据通常以字节或者字符的形式发送，异步传输则不需要同步时钟，但是会在传输之前向数据添加<code>奇偶校验位</code>。下面是同步和异步的主要区别</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/0.png" style="zoom:67%;"></p>
<p>回到正题。大部分<code>物理IO(physical I/O)</code> 是异步的。物理 I/O 中的 CPU 是很聪明的，CPU 传输完成后会转而做其他事情，它和中断心灵相通，等到中断发生后，CPU 才会回到传输这件事情上来。</p>
<blockquote>
<p>I/O 分为两种：物理I/O 和 <code>逻辑I/O(Logical I/O)</code>。</p>
<p>物理 I/O 通常是从磁盘等存储设备实际获取数据。逻辑 I/O 是对存储器（块，缓冲区）获取数据。</p>
</blockquote>
<h4 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h4><p>I/O 软件的最后一个问题是<code>缓冲(buffering)</code>。通常情况下，从一个设备发出的数据不会直接到达最后的设备。其间会经过一系列的校验、检查、缓冲等操作才能到达。举个例子来说，从网络上发送一个数据包，会经过一系列检查之后首先到达缓冲区，从而消除缓冲区填满速率和缓冲区过载。</p>
<h4 id="共享和独占"><a href="#共享和独占" class="headerlink" title="共享和独占"></a>共享和独占</h4><p>I/O 软件引起的最后一个问题就是共享设备和独占设备的问题。有些 I/O 设备能够被许多用户共同使用。一些设备比如磁盘，让多个用户使用一般不会产生什么问题，但是某些设备必须具有独占性，即只允许单个用户使用完成后才能让其他用户使用。</p>
<p>下面，我们来探讨一下如何使用程序来控制 I/O 设备。一共有三种控制 I/O 设备的方法</p>
<ul>
<li>使用程序控制 I/O</li>
<li>使用中断驱动 I/O</li>
<li>使用 DMA 驱动 I/O</li>
</ul>
<h3 id="使用程序控制-I-O"><a href="#使用程序控制-I-O" class="headerlink" title="使用程序控制 I/O"></a>使用程序控制 I/O</h3><p>使用程序控制 I/O 又被称为 <code>可编程I/O</code>，它是指由 CPU 在驱动程序软件控制下启动的数据传输，来访问设备上的寄存器或者其他存储器。CPU 会发出命令，然后等待 I/O 操作的完成。由于 CPU 的速度比 I/O 模块的速度快很多，因此可编程 I/O 的问题在于，CPU 必须等待很长时间才能等到处理结果。CPU 在等待时会采用<code>轮询(polling)</code>或者 <code>忙等(busy waiting)</code> 的方式，结果，整个系统的性能被严重拉低。可编程 I/O 十分简单，如果需要等待的时间非常短的话，可编程 I/O 倒是一个很好的方式。一个可编程的 I/O 会经历如下操作</p>
<ul>
<li>CPU 请求 I/O 操作</li>
<li>I/O 模块执行响应</li>
<li>I/O 模块设置状态位</li>
<li>CPU 会定期检查状态位</li>
<li>I/O 不会直接通知 CPU 操作完成</li>
<li>I/O 也不会中断 CPU</li>
<li>CPU 可能会等待或在随后的过程中返回</li>
</ul>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/16.png" style="zoom:67%;"></p>
<h3 id="使用中断驱动-I-O"><a href="#使用中断驱动-I-O" class="headerlink" title="使用中断驱动 I/O"></a>使用中断驱动 I/O</h3><p>鉴于上面可编程 I/O 的缺陷，我们提出一种改良方案，我们想要在 CPU 等待 I/O 设备的同时，能够做其他事情，等到 I/O 设备完成后，它就会产生一个中断，这个中断会停止当前进程并保存当前的状态。一个可能的示意图如下</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/17.png" style="zoom:67%;"></p>
<p>尽管中断减轻了 CPU 和 I/O 设备的等待时间的负担，但是由于还需要在 CPU 和 I/O 模块之前进行大量的逐字传输，因此在大量数据传输中效率仍然很低。下面是中断的基本操作</p>
<ul>
<li>CPU 进行读取操作</li>
<li>I/O 设备从外围设备获取数据，同时 CPU 执行其他操作</li>
<li>I/O 设备中断通知 CPU</li>
<li>CPU 请求数据</li>
<li>I/O 模块传输数据</li>
</ul>
<p>所以我们现在着手需要解决的就是 CPU 和 I/O 模块间数据传输的效率问题。</p>
<h3 id="使用-DMA-的-I-O"><a href="#使用-DMA-的-I-O" class="headerlink" title="使用 DMA 的 I/O"></a>使用 DMA 的 I/O</h3><p>DMA 的中文名称是直接内存访问，它意味着 CPU 授予 I/O 模块权限在不涉及 CPU 的情况下读取或写入内存。也<strong>就是 DMA 可以不需要 CPU 的参与</strong>。这个过程由称为 DMA 控制器（DMAC）的芯片管理。由于 DMA 设备可以直接在内存之间传输数据，而不是使用 CPU 作为中介，因此可以缓解总线上的拥塞。DMA 通过允许 CPU 执行任务，同时 DMA 系统通过系统和内存总线传输数据来提高系统并发性。</p>
<h2 id="I-O-层次结构"><a href="#I-O-层次结构" class="headerlink" title="I/O 层次结构"></a>I/O 层次结构</h2><p>I/O 软件通常组织成四个层次，它们的大致结构如下图所示</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/18.png" style="zoom:67%;"></p>
<p>每一层和其上下层都有明确的功能和接口。下面我们采用和计算机网络相反的套路，即自下而上的了解一下这些程序。</p>
<p>下面是另一幅图，这幅图显示了输入/输出软件系统所有层及其主要功能。</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/19.png" style="zoom:67%;"></p>
<p>下面我们具体的来探讨一下上面的层次结构</p>
<h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><p>在计算机系统中，中断就像女人的脾气一样无时无刻都在产生，中断的出现往往是让人很不爽的。中断处理程序又被称为<code>中断服务程序</code> 或者是 <code>ISR(Interrupt Service Routines)</code>，它是最靠近硬件的一层。中断处理程序由硬件中断、软件中断或者是软件异常启动产生的中断，用于实现设备驱动程序或受保护的操作模式（例如系统调用）之间的转换。</p>
<p>中断处理程序负责处理中断发生时的所有操作，操作完成后阻塞，然后启动中断驱动程序来解决阻塞。通常会有三种通知方式，依赖于不同的具体实现</p>
<ul>
<li>信号量实现中：在信号量上使用 <code>up</code> 进行通知；</li>
<li>管程实现：对管程中的条件变量执行 <code>signal</code> 操作</li>
<li>还有一些情况是发送一些消息</li>
</ul>
<p>不管哪种方式都是为了让阻塞的中断处理程序恢复运行。</p>
<p>中断处理方案有很多种，下面是 《<strong>ARM System Developer’s Guide Designing and Optimizing System Software</strong>》列出来的一些方案</p>
<ul>
<li><code>非嵌套</code>的中断处理程序按照顺序处理各个中断，非嵌套的中断处理程序也是最简单的中断处理</li>
<li><code>嵌套</code>的中断处理程序会处理多个中断而无需分配优先级</li>
<li><code>可重入</code>的中断处理程序可使用优先级处理多个中断</li>
<li><code>简单优先级</code>中断处理程序可处理简单的中断</li>
<li><code>标准优先级</code>中断处理程序比低优先级的中断处理程序在更短的时间能够处理优先级更高的中断</li>
<li><code>高优先级</code> 中断处理程序在短时间能够处理优先级更高的任务，并直接进入特定的服务例程。</li>
<li><code>优先级分组</code>中断处理程序能够处理不同优先级的中断任务</li>
</ul>
<p>下面是一些通用的中断处理程序的步骤，不同的操作系统实现细节不一样</p>
<ul>
<li>保存所有没有被中断硬件保存的寄存器</li>
<li>为中断服务程序设置上下文环境，可能包括设置 <code>TLB</code>、<code>MMU</code> 和页表，如果不太了解这三个概念，请参考另外一篇文章</li>
<li>为中断服务程序设置栈</li>
<li>对中断控制器作出响应，如果不存在集中的中断控制器，则继续响应中断</li>
<li>把寄存器从保存它的地方拷贝到进程表中</li>
<li>运行中断服务程序，它会从发出中断的设备控制器的寄存器中提取信息</li>
<li>操作系统会选择一个合适的进程来运行。如果中断造成了一些优先级更高的进程变为就绪态，则选择运行这些优先级高的进程</li>
<li>为进程设置 MMU 上下文，可能也会需要 TLB，根据实际情况决定</li>
<li>加载进程的寄存器，包括 PSW 寄存器</li>
<li>开始运行新的进程</li>
</ul>
<p>上面我们罗列了一些大致的中断步骤，不同性质的操作系统和中断处理程序能够处理的中断步骤和细节也不尽相同，下面是一个嵌套中断的具体运行步骤</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/20.png" style="zoom:67%;"></p>
<h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p>在上面的文章中我们知道了设备控制器所做的工作。我们知道每个控制器其内部都会有寄存器用来和设备进行沟通，发送指令，读取设备的状态等。</p>
<p>因此，每个连接到计算机的 I/O 设备都需要有某些特定设备的代码对其进行控制，例如鼠标控制器需要从鼠标接受指令，告诉下一步应该移动到哪里，键盘控制器需要知道哪个按键被按下等。这些提供 I/O 设备到设备控制器转换的过程的代码称为 <code>设备驱动程序(Device driver)</code>。</p>
<p>为了能够访问设备的硬件，实际上也就意味着，设备驱动程序通常是操作系统内核的一部分，至少现在的体系结构是这样的。但是也可以构造<code>用户空间</code>的设备驱动程序，通过系统调用来完成读写操作。这样就避免了一个问题，有问题的驱动程序会干扰内核，从而造成崩溃。所以，在用户控件实现设备驱动程序是构造系统稳定性一个非常有用的措施。<code>MINIX 3</code> 就是这么做的。下面是 MINI 3 的调用过程</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/21.png" style="zoom:67%;"></p>
<p>然而，大多数桌面操作系统要求驱动程序必须运行在内核中。</p>
<p>操作系统通常会将驱动程序归为 <code>字符设备</code> 和 <code>块设备</code>，我们上面也介绍过了</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/22.png" style="zoom:67%;"></p>
<p>在 UNIX 系统中，操作系统是一个<code>二进制程序</code>，包含需要编译到其内部的所有驱动程序，如果你要对 UNIX 添加一个新设备，需要重新编译内核，将新的驱动程序装到二进制程序中。</p>
<p>然而随着大多数个人计算机的出现，由于 I/O 设备的广泛应用，上面这种静态编译的方式不再有效，因此，从 <code>MS-DOS</code> 开始，操作系统转向驱动程序在执行期间动态的装载到系统中。</p>
<p>设备驱动程序具有很多功能，比如接受读写请求，对设备进行初始化、管理电源和日志、对输入参数进行有效性检查等。</p>
<p>设备驱动程序接受到读写请求后，会检查当前设备是否在使用，如果设备在使用，请求被排入队列中，等待后续的处理。如果此时设备是空闲的，驱动程序会检查硬件以了解请求是否能够被处理。在传输开始前，会启动设备或者马达。等待设备就绪完成，再进行实际的控制。<strong>控制设备就是对设备发出指令</strong>。</p>
<p>发出命令后，设备控制器便开始将它们写入控制器的<code>设备寄存器</code>。在将每个命令写入控制器后，会检查控制器是否接受了这条命令并准备接受下一个命令。一般控制设备会发出一系列的指令，这称为<code>指令序列</code>，设备控制器会依次检查每个命令是否被接受，下一条指令是否能够被接收，直到所有的序列发出为止。</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/23.png" style="zoom:67%;"></p>
<p>发出指令后，一般会有两种可能出现的情况。在大多数情况下，设备驱动程序会进行等待直到控制器完成它的事情。这里需要了解一下设备控制器的概念</p>
<blockquote>
<p>设备控制器的主要主责是<strong>控制一个或多个 I/O 设备，以实现 I/O 设备和计算机之间的数据交换</strong>。</p>
<p>设备控制器接收从 CPU 发送过来的指令，继而达到控制硬件的目的</p>
</blockquote>
<p>设备控制器是一个<code>可编址</code>的设备，当它仅控制一个设备时，它只有一个唯一的设备地址；如果设备控制器控制多个可连接设备时，则应含有多个设备地址，并使每一个设备地址对应一个设备。</p>
<p>设备控制器主要分为两种：字符设备和块设备</p>
<p>设备控制器的主要功能有下面这些</p>
<ul>
<li><strong>接收和识别命令</strong>：设备控制器可以接受来自 CPU 的指令，并进行识别。设备控制器内部也会有寄存器，用来存放指令和参数</li>
<li><strong>进行数据交换</strong>：CPU、控制器和设备之间会进行数据的交换，CPU 通过总线把指令发送给控制器，或从控制器中并行地读出数据；控制器将数据写入指定设备。</li>
<li><strong>地址识别</strong>：每个硬件设备都有自己的地址，设备控制器能够识别这些不同的地址，来达到控制硬件的目的，此外，为使 CPU 能向寄存器中写入或者读取数据，这些寄存器都应具有唯一的地址。</li>
<li><strong>差错检测</strong>：设备控制器还具有对设备传递过来的数据进行检测的功能。</li>
</ul>
<p>在这种情况下，设备控制器会阻塞，直到中断来解除阻塞状态。还有一种情况是操作是可以无延迟的完成，所以驱动程序不需要阻塞。在第一种情况下，操作系统可能被中断唤醒；第二种情况下操作系统不会被休眠。</p>
<p>设备驱动程序必须是<code>可重入</code>的，因为设备驱动程序会阻塞和唤醒然后再次阻塞。驱动程序不允许进行系统调用，但是它们通常需要与内核的其余部分进行交互。</p>
<h3 id="与设备无关的-I-O-软件"><a href="#与设备无关的-I-O-软件" class="headerlink" title="与设备无关的 I/O 软件"></a>与设备无关的 I/O 软件</h3><p>I/O 软件有两种，一种是我们上面介绍过的基于特定设备的，还有一种是<code>设备无关性</code>的，设备无关性也就是不需要特定的设备。设备驱动程序与设备无关的软件之间的界限取决于具体的系统。下面显示的功能由设备无关的软件实现</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/24.png" style="zoom:67%;"></p>
<p>与设备无关的软件的基本功能是对所有设备执行公共的 I/O 功能，并且向用户层软件提供一个统一的接口。</p>
<h4 id="缓冲-1"><a href="#缓冲-1" class="headerlink" title="缓冲"></a>缓冲</h4><p>无论是对于块设备还是字符设备来说，缓冲都是一个非常重要的考量标准。下面是从 <code>ADSL(调制解调器)</code> 读取数据的过程，调制解调器是我们用来联网的设备。</p>
<p>用户程序调用 read 系统调用阻塞用户进程，等待字符的到来，这是对到来的字符进行处理的一种方式。每一个到来的字符都会造成中断。<code>中断服务程序</code>会给用户进程提供字符，并解除阻塞。将字符提供给用户程序后，进程会去读取其他字符并继续阻塞，这种模型如下</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/25.png" style="zoom:67%;"></p>
<p>这一种方案是没有缓冲区的存在，因为用户进程如果读不到数据会阻塞，直到读到数据为止，这种情况效率比较低，而且阻塞式的方式，会直接阻止用户进程做其他事情，这对用户来说是不能接受的。还有一种情况就是每次用户进程都会重启，对于每个字符的到来都会重启用户进程，这种效率会严重降低，所以无缓冲区的软件不是一个很好的设计。</p>
<p>作为一个改良点，我们可以尝试在用户空间中使用一个能读取 n 个字节缓冲区来读取 n 个字符。这样的话，中断服务程序会把字符放到缓冲区中直到缓冲区变满为止，然后再去唤醒用户进程。这种方案要比上面的方案改良很多。</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/26.png" style="zoom:67%;"></p>
<p>但是这种方案也存在问题，当字符到来时，如果缓冲区被调出内存会出现什么问题？解决方案是把缓冲区锁定在内存中，但是这种方案也会出现问题，如果少量的缓冲区被锁定还好，如果大量的缓冲区被锁定在内存中，那么可以换进换出的页面就会收缩，造成系统性能的下降。</p>
<p>一种解决方案是在<code>内核</code>中内部创建一块缓冲区，让中断服务程序将字符放在内核内部的缓冲区中。</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/27.png" style="zoom:67%;"></p>
<p>当内核中的缓冲区要满的时候，会将用户空间中的页面调入内存，然后将内核空间的缓冲区复制到用户空间的缓冲区中，这种方案也面临一个问题就是假如用户空间的页面被换入内存，此时内核空间的缓冲区已满，这时候仍有新的字符到来，这个时候会怎么办？因为缓冲区满了，没有空间来存储新的字符了。</p>
<p>一种非常简单的方式就是再设置一个缓冲区就行了，在第一个缓冲区填满后，在缓冲区清空前，使用第二个缓冲区，这种解决方式如下</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/28.png" style="zoom:67%;"></p>
<p>当第二个缓冲区也满了的时候，它也会把数据复制到用户空间中，然后第一个缓冲区用于接受新的字符。这种具有两个缓冲区的设计被称为 <code>双缓冲(double buffering)</code>。</p>
<p>还有一种缓冲形式是 <code>循环缓冲(circular buffer)</code>。它由一个内存区域和两个指针组成。一个指针指向下一个空闲字，新的数据可以放在此处。另外一个指针指向缓冲区中尚未删除数据的第一个字。在许多情况下，硬件会在添加新的数据时，移动第一个指针；而操作系统会在删除和处理无用数据时会移动第二个指针。两个指针到达顶部时就回到底部重新开始。</p>
<p>缓冲区对输出来说也很重要。对输出的描述和输入相似</p>
<p>缓冲技术应用广泛，但它也有缺点。如果数据被缓冲次数太多，会影响性能。考虑例如如下这种情况，</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/29.png" style="zoom:67%;"></p>
<p>数据经过用户进程 -&gt; 内核空间 -&gt; 网络控制器，这里的网络控制器应该就相当于是 socket 缓冲区，然后发送到网络上，再到接收方的网络控制器 -&gt; 接收方的内核缓冲 -&gt; 接收方的用户缓冲，一条数据包被缓存了太多次，很容易降低性能。</p>
<h4 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h4><p>在 I/O 中，出错是一种再正常不过的情况了。当出错发生时，操作系统必须尽可能处理这些错误。有一些错误是只有特定的设备才能处理，有一些是由框架进行处理，这些错误和特定的设备无关。</p>
<p>I/O 错误的一类是程序员<code>编程</code>错误，比如还没有打开文件前就读流，或者不关闭流导致内存溢出等等。这类问题由程序员处理；另外一类是实际的 I/O 错误，例如向一个磁盘坏块写入数据，无论怎么写都写入不了。这类问题由驱动程序处理，驱动程序处理不了交给硬件处理，这个我们上面也说过。</p>
<h4 id="设备驱动程序统一接口"><a href="#设备驱动程序统一接口" class="headerlink" title="设备驱动程序统一接口"></a>设备驱动程序统一接口</h4><p>我们在操作系统概述中说到，操作系统一个非常重要的功能就是屏蔽了硬件和软件的差异性，为硬件和软件提供了统一的标准，这个标准还体现在为设备驱动程序提供统一的接口，因为不同的硬件和厂商编写的设备驱动程序不同，所以如果为每个驱动程序都单独提供接口的话，这样没法搞，所以必须统一。</p>
<h4 id="分配和释放"><a href="#分配和释放" class="headerlink" title="分配和释放"></a>分配和释放</h4><p>一些设备例如打印机，它只能由一个进程来使用，这就需要操作系统根据实际情况判断是否能够对设备的请求进行检查，判断是否能够接受其他请求，一种比较简单直接的方式是在特殊文件上执行 <code>open</code>操作。如果设备不可用，那么直接 open 会导致失败。还有一种方式是不直接导致失败，而是让其阻塞，等到另外一个进程释放资源后，在进行 open 打开操作。这种方式就把选择权交给了用户，由用户判断是否应该等待。</p>
<blockquote>
<p>注意：阻塞的实现有多种方式，有阻塞队列等</p>
</blockquote>
<h4 id="设备无关的块"><a href="#设备无关的块" class="headerlink" title="设备无关的块"></a>设备无关的块</h4><p>不同的磁盘会具有不同的扇区大小，但是软件不会关心扇区大小，只管存储就是了。一些字符设备可以一次一个字节的交付数据，而其他的设备则以较大的单位交付数据，这些差异也可以隐藏起来。</p>
<h3 id="用户空间的-I-O-软件"><a href="#用户空间的-I-O-软件" class="headerlink" title="用户空间的 I/O 软件"></a>用户空间的 I/O 软件</h3><p>虽然大部分 I/O 软件都在内核结构中，但是还有一些在用户空间实现的 I/O 软件，凡事没有绝对。一些 I/O 软件和库过程在用户空间存在，然后以提供系统调用的方式实现。比如说，将二进制整数转换成 ASCII码 一边打印，就需要用户空间的 I/O 软件。</p>
<h2 id="盘"><a href="#盘" class="headerlink" title="盘"></a>盘</h2><p>盘可以说是硬件里面比较简单的构造了，同时也是最重要的。下面我们从盘谈起，聊聊它的物理构造</p>
<h3 id="盘硬件"><a href="#盘硬件" class="headerlink" title="盘硬件"></a>盘硬件</h3><p>盘会有很多种类型。其中最简单的构造就是<code>磁盘(magnetic hard disks)</code>， 也被称为 <code>hard disk,HDD</code>等。磁盘通常与安装在磁臂上的磁头配对，磁头可将数据读取或者将数据写入磁盘，因此磁盘的读写速度都同样快。在磁盘中，数据是随机访问的，这也就说明可以通过任意的顺序来<code>存储</code>和<code>检索</code>单个数据块，所以你可以在任意位置放置磁盘来让磁头读取，磁盘是一种<code>非易失性</code>的设备，即使断电也能永久保留。</p>
<p>在计算机发展早期一般是用光盘来存储数据的，然而随着固态硬盘的流行，固态硬盘不包含运动部件的特点，成为现在计算机的首选存储方式。</p>
<h4 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h4><p>为了组织和检索数据，会将磁盘组织成特定的结构，这些特定的结构就是<strong>磁道、扇区和柱面</strong></p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/30.png" style="zoom:67%;"></p>
<p>每一个磁盘都是由无数个同心圆组成，这些同心圆就好像树的年轮一样</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/31.png" style="zoom:67%;"></p>
<p>磁盘被组织成柱面形式，每个盘用轴相连，每一个柱面包含若干磁道，每个磁道由若干扇区组成。软盘上大约每个磁道有 8 - 32 个扇区，硬盘上每条磁道上扇区的数量可达几百个，磁头大约是 1 - 16 个。</p>
<p>对于磁盘驱动程序来说，一个非常重要的特性就是控制器是否能够同时控制两个或者多个驱动器进行磁道寻址，这就是<code>重叠寻道(overlapped seek)</code>。对于控制器来说，它能够控制一个磁盘驱动程序完成寻道操作，同时让其他驱动程序等待寻道结束。控制器也可以在一个驱动程序上进行读写草哦做，与此同时让另外的驱动器进行寻道操作，但是软盘控制器不能在两个驱动器上进行读写操作。</p>
<h4 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h4><p>RAID 称为 <code>磁盘冗余阵列</code>，简称 <code>磁盘阵列</code>。利用虚拟化技术把多个硬盘结合在一起，成为一个或多个磁盘阵列组，目的是提升性能或数据冗余。</p>
<p>RAID 有不同的级别</p>
<ul>
<li>RAID 0 - 无容错的条带化磁盘阵列</li>
<li>RAID 1 - 镜像和双工</li>
<li>RAID 2 - 内存式纠错码</li>
<li>RAID 3 - 比特交错奇偶校验</li>
<li>RAID 4 - 块交错奇偶校验</li>
<li>RAID 5 - 块交错分布式奇偶校验</li>
<li>RAID 6 - P + Q冗余</li>
</ul>
<h4 id="磁盘格式化"><a href="#磁盘格式化" class="headerlink" title="磁盘格式化"></a>磁盘格式化</h4><p>磁盘由一堆铝的、合金或玻璃的盘片组成，磁盘刚被创建出来后，没有任何信息。磁盘在使用前必须经过<code>低级格式化(low-levvel format)</code>，下面是一个扇区的格式</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/32.png" style="zoom:67%;"></p>
<p>前导码相当于是标示扇区的开始位置，通常以位模式开始，前导码还包括<code>柱面号</code>、<code>扇区号</code>等一些其他信息。紧随前导码后面的是数据区，数据部分的大小由低级格式化程序来确定。大部分磁盘使用 512 字节的扇区。数据区后面是 ECC，ECC 的全称是 <strong>error correction code</strong> ，<code>数据纠错码</code>，它与普通的错误检测不同，ECC 还可以用于恢复读错误。ECC 阶段的大小由不同的磁盘制造商实现。ECC 大小的设计标准取决于<strong>设计者愿意牺牲多少磁盘空间来提高可靠性</strong>，以及程序可以处理的 ECC 的复杂程度。通常情况下 ECC 是 16 位，除此之外，硬盘一般具有一定数量的备用扇区，用于替换制造缺陷的扇区。</p>
<p>低级格式化后的每个 0 扇区的位置都和前一个磁道存在<code>偏移</code>，如下图所示</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/33.png" style="zoom:67%;"></p>
<p>这种方式又被称为 <code>柱面斜进(cylinder skew)</code>，之所以采用这种方式是为了提高程序的运行性能。可以这样想，磁盘在转动的过程中会经由磁头来读取扇区信息，在读取内侧一圈扇区数据后，磁头会进行向外侧磁道的寻址操作，寻址操作的同时磁盘在继续转动，如果不采用这种方式，可能刚好磁头寻址到外侧，0 号扇区已经转过了磁头，所以需要旋转一圈才能等到它继续读取，通过柱面斜进的方式可以消除这一问题。</p>
<p>柱面斜进量取决于驱动器的几何规格。柱面斜进量就是两个相邻同心圆 0 号扇区的差异量。如下图所示</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/34.png" style="zoom:67%;"></p>
<p>这里需要注意一点，不只有柱面存在斜进，磁头也会存在<code>斜进(head skew)</code>，但是磁头斜进比较小。</p>
<p>磁盘格式化会减少磁盘容量，减少的磁盘容量都会由前导码、扇区间间隙和 ECC 的大小以及保留的备用扇区数量。</p>
<p>在磁盘使用前，还需要经过最后一道工序，那就是对每个分区分别执行一次<code>高级格式化(high-level format)</code>，这一操作要设置一个引导块、空闲存储管理（采用位图或者是空闲列表）、根目录和空文件系统。这一步操作会把码放在分区表项中，告诉分区使用的是哪种文件系统，因为许多操作系统支持多个兼容的文件系统。在这一步之后，系统就可以进行引导过程。</p>
<p>当电源通电后，BIOS 首先运行，它会读取主引导记录并跳转到主引导记录中。然后引导程序会检查以了解哪个分区是处于活动的。然后，它从该分区读取<code>启动扇区(boot sector)</code>并运行它。启动扇区包含一个小程序来加载一个更大一点的引导器来搜索文件系统以找到<code>系统内核(system kernel)</code>，然后程序被转载进入内存并执行。</p>
<blockquote>
<p>这里说下什么是引导扇区：引导扇区是磁盘或者存储设备的保留扇区，其中包含用于完成计算机或磁盘引导过程所必要的数据或者代码。</p>
<p>引导扇区存储引导记录数据，这些数据用于在计算机启动时提供指令。有两种不同类型的引导扇区</p>
<ul>
<li>Master boot record 称为主引导扇区</li>
<li>Volume boot record 卷启动记录</li>
</ul>
<p>对于分区磁盘，引导扇区由主引导记录组成；</p>
<p>非分区磁盘由卷启动记录组成。</p>
</blockquote>
<h3 id="磁盘臂调度算法"><a href="#磁盘臂调度算法" class="headerlink" title="磁盘臂调度算法"></a>磁盘臂调度算法</h3><p>下面我们来探讨一下关于影响磁盘读写的算法，一般情况下，影响磁盘快读写的时间由下面几个因素决定</p>
<ul>
<li>寻道时间 - 寻道时间指的就是将磁盘臂移动到需要读取磁盘块上的时间</li>
<li>旋转延迟 - 等待合适的扇区旋转到磁头下所需的时间</li>
<li>实际数据的读取或者写入时间</li>
</ul>
<p>这三种时间参数也是磁盘寻道的过程。一般情况下，寻道时间对总时间的影响最大，所以，有效的降低寻道时间能够提高磁盘的读取速度。</p>
<p>如果磁盘驱动程序每次接收一个请求并按照接收顺序完成请求，这种处理方式也就是 <code>先来先服务(First-Come, First-served, FCFS)</code> ，这种方式很难优化寻道时间。因为每次都会按照顺序处理，不管顺序如何，有可能这次读完后需要等待一个磁盘旋转一周才能继续读取，而其他柱面能够马上进行读取，这种情况下每次请求也会排队。</p>
<p>通常情况下，磁盘在进行寻道时，其他进程会产生其他的磁盘请求。磁盘驱动程序会维护一张表，表中会记录着柱面号当作索引，每个柱面未完成的请求会形成链表，链表头存放在表的相应表项中。</p>
<p>一种对先来先服务的算法改良的方案是使用 <code>最短路径优先(SSF)</code> 算法，下面描述了这个算法。</p>
<p>假如我们在对磁道 6 号进行寻址时，同时发生了对 11 , 2 , 4, 14, 8, 15, 3 的请求，如果采用先来先服务的原则，如下图所示</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/35.png" style="zoom:67%;"></p>
<p>我们可以计算一下磁盘臂所跨越的磁盘数量为 5 + 9 + 2 + 10 + 6 + 7 + 12 = 51，相当于是跨越了 51 次盘面</p>
<p>如果使用最短路径优先，我们来计算一下跨越的盘面: 顺序是：6-2-3-4-8-11-14-15</p>
<p>跨越的磁盘数量为 4 + 1 + 1 + 4 + 3 + 3 + 1 = 17 ，相比 51 足足省了两倍的时间。</p>
<p>但是，最短路径优先的算法也不是完美无缺的，这种算法照样存在问题，那就是<code>优先级</code> 问题，</p>
<p>这里有一个原型可以参考就是我们日常生活中的电梯，电梯使用一种<code>电梯算法(elevator algorithm)</code> 来进行调度，从而满足协调效率和公平性这两个相互冲突的目标。电梯一般会保持向一个方向移动，<strong>直到在那个方向上没有请求为止，然后改变方向</strong>。</p>
<p>电梯算法需要维护一个<code>二进制位</code>，也就是当前的方向位：<code>UP(向上)</code>或者是 <code>DOWN(向下)</code>。当一个请求处理完成后，磁盘或电梯的驱动程序会检查该位，如果此位是 UP 位，磁盘臂或者电梯仓移到下一个更高跌未完成的请求。如果高位没有未完成的请求，则取相反方向。当方向位是 <code>DOWN</code>时，同时存在一个低位的请求，磁盘臂会转向该点。如果不存在的话，那么它只是停止并等待。</p>
<p>我们举个例子来描述一下电梯算法，比如各个柱面得到服务的顺序是 4，7，10，14，9，6，3，1 ，那么它的流程图如下</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/36.png" style="zoom:67%;"></p>
<p>所以电梯算法需要跨越的盘面数量是 3 + 3 + 4 + 5 + 3 + 3 + 1 = 22</p>
<p>电梯算法通常情况下不如 SSF 算法。</p>
<p>一些磁盘控制器为软件提供了一种检查磁头下方当前扇区号的方法，使用这样的控制器，能够进行另一种优化。如果对一个相同的柱面有两个或者多个请求正等待处理，驱动程序可以发出请求读写下一次要通过磁头的扇区。</p>
<blockquote>
<p>这里需要注意一点，当一个柱面有多条磁道时，相继的请求可能针对不同的磁道，这种选择没有代价，因为选择磁头不需要移动磁盘臂也没有旋转延迟。</p>
</blockquote>
<p>对于磁盘来说，<strong>最影响性能的就是寻道时间和旋转延迟</strong>，所以一次只读取一个或两个扇区的效率是非常低的。出于这个原因，许多磁盘控制器总是读出多个扇区并进行高速缓存，即使只请求一个扇区时也是这样。一般情况下读取一个扇区的同时会读取该扇区所在的磁道或者是所有剩余的扇区被读出，读出扇区的数量取决于控制器的高速缓存中有多少可用的空间。</p>
<p>磁盘控制器的高速缓存和操作系统的高速缓存有一些不同，磁盘控制器的高速缓存用于缓存没有实际被请求的块，而操作系统维护的高速缓存由显示地读出的块组成，并且操作系统会认为这些块在近期仍然会频繁使用。</p>
<p>当同一个控制器上有多个驱动器时，操作系统应该为每个驱动器都单独的维护一个未完成的请求表。一旦有某个驱动器闲置时，就应该发出一个寻道请求来将磁盘臂移到下一个被请求的柱面。如果下一个寻道请求到来时恰好没有磁盘臂处于正确的位置，那么驱动程序会在刚刚完成传输的驱动器上发出一个新的寻道命令并等待，等待下一次中断到来时检查哪个驱动器处于闲置状态。</p>
<h3 id="错误处理-2"><a href="#错误处理-2" class="headerlink" title="错误处理"></a>错误处理</h3><p>磁盘在制造的过程中可能会有瑕疵，如果瑕疵比较小，比如只有几位，那么使用坏扇区并且每次只是让 ECC 纠正错误是可行的，如果瑕疵较大，那么错误就不可能被掩盖。</p>
<p>一般坏块有两种处理办法，一种是在控制器中进行处理；一种是在操作系统层面进行处理。</p>
<p>这两种方法经常替换使用，比如一个具有 30 个数据扇区和两个备用扇区的磁盘，其中扇区 4 是有瑕疵的。</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/37.png" style="zoom:67%;"></p>
<p>控制器能做的事情就是将备用扇区之一重新映射。</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/38.png" style="zoom:67%;"></p>
<p>还有一种处理方式是将所有的扇区都向上移动一个扇区</p>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/39.png" style="zoom:67%;"></p>
<p>上面这这两种情况下控制器都必须知道哪个扇区，可以通过内部的表来跟踪这一信息，或者通过重写前导码来给出重新映射的扇区号。如果是重写前导码，那么涉及移动的方式必须重写后面所有的前导码，但是最终会提供良好的性能。</p>
<h3 id="稳定存储器"><a href="#稳定存储器" class="headerlink" title="稳定存储器"></a>稳定存储器</h3><p>磁盘经常会出现错误，导致好的扇区会变成坏扇区，驱动程序也有可能挂掉。RAID 可以对扇区出错或者是驱动器崩溃提出保护，然而 RAID 却不能对坏数据中的写错误提供保护，也不能对写操作期间的崩溃提供保护，这样就会破坏原始数据。</p>
<p>我们期望磁盘能够准确无误的工作，但是事实情况是不可能的，但是我们能够知道的是，一个磁盘子系统具有如下特性：当一个写命令发给它时，磁盘要么正确地写数据，要么什么也不做，让现有的数据完整无误的保留。这样的系统称为 <code>稳定存储器(stable storage)</code>。 稳定存储器的目标就是不惜一切代价保证磁盘的一致性。</p>
<p>稳定存储器使用两个一对相同的磁盘，对应的块一同工作形成一个无差别的块。稳定存储器为了实现这个目的，定义了下面三种操作：</p>
<ul>
<li><code>稳定写(stable write)</code></li>
<li><code>稳定读(stable read)</code></li>
<li><code>崩溃恢复(crash recovery)</code></li>
</ul>
<p>稳定写指的就是首先将块写到比如驱动器 1 上，然后将其读回来验证写入的是否正确，如果不正确，那么就会再次尝试写入和读取，一直到能够验证写入正确为止。如果块都写完了也没有验证正确，就会换块继续写入和读取，直到正确为止。无论尝试使用多少个备用块，都是在对你驱动器 1 写入成功之后，才会对驱动器 2 进行写入和读取。这样我们相当于是对两个驱动器进行写入。</p>
<p>稳定读指的就是首先从驱动器 1 上进行读取，如果读取操作会产生错误的 ECC，则再次尝试读取，如果所有的读取操作都会给出错误的 ECC，那么会从驱动器 2 上进行读取。这样我们相当于是对两个驱动器进行读取。</p>
<p>崩溃恢复指的是崩溃之后，恢复程序扫描两个磁盘，比较对应的块。如果一对块都是好的并且是相同的，就不会触发任何机制；如果其中一个块触发了 ECC 错误，这时候就需要使用好块来覆盖坏块。</p>
<p>如果 CPU 没有崩溃的话，那么这种方式是可行的，因为稳定写总是对每个块写下两个有效的副本，并且假设自发的错误不会再相同的时刻发生在两个对应的块上。如果在稳定写期间出现 CPU 崩溃会怎么样？这就取决于崩溃发生的精确时间，有五种情况，下面来说一下</p>
<ul>
<li>第一种情况是崩溃发生在写入之前，在恢复的时候就什么都不需要修改，旧的值也会继续存在。</li>
</ul>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/40.png" style="zoom:67%;"></p>
<ul>
<li>第二种情况是 CPU 崩溃发生在写入驱动器 1 的时候，崩溃导致块内容被破坏，然而恢复程序能够检测出这一种错误，并且从驱动器 2 恢复驱动器 1 上的块。</li>
</ul>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/41.png" style="zoom:67%;"></p>
<ul>
<li>第三种情况是崩溃发生在磁盘驱动器 1 之后但是还没有写驱动器 2 之前，这种情况下由于磁盘 1 已经写入成功</li>
</ul>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/42.png" style="zoom:67%;"></p>
<ul>
<li>第四种情况是崩溃发生在磁盘驱动 1 写入后在磁盘驱动 2 写入时，恢复期间会用好的块替换坏的块，两个块的最终值都是最新的</li>
</ul>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/43.png" style="zoom:67%;"></p>
<ul>
<li>最后一种情况就是崩溃发生在两个磁盘驱动写入后，这种情况下不会发生任何问题</li>
</ul>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/44.png" style="zoom:67%;"></p>
<p>这种模式下进行任何优化和改进都是可行的，但是代价高昂，一种改进是在稳定写期间监控被写入的块，这样在崩溃后进行检验的块只有一个。有一种 <code>非易失性 RAM</code> 能够在崩溃之后保留数据，但是这种方式并不推荐使用。</p>
<h2 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h2><p><code>时钟(Clocks)</code> 也被称为<code>定时器(timers)</code>，时钟/定时器对任何程序系统来说都是必不可少的。时钟负责维护时间、防止一个进程长期占用 CPU 时间等其他功能。<code>时钟软件(clock software)</code> 也是一种设备驱动的方式。下面我们就来对时钟进行介绍，一般都是先讨论硬件再介绍软件，采用由下到上的方式，也是告诉你，底层是最重要的。</p>
<h3 id="时钟硬件"><a href="#时钟硬件" class="headerlink" title="时钟硬件"></a>时钟硬件</h3><p>在计算机中有两种类型的时钟，这些时钟与现实生活中使用的时钟完全不一样。</p>
<ul>
<li>比较简单的一种时钟被连接到 110 V 或 220 V 的电源线上，这样每个<code>电压周期</code>会产生一个中断，大概是 50 - 60 HZ。这些时钟过去一直占据支配地位。</li>
<li>另外的一种时钟由晶体振荡器、计数器和寄存器组成，示意图如下所示</li>
</ul>
<p><img src="/2021/06/21/IO%E7%AE%A1%E7%90%86/45.png" style="zoom:67%;"></p>
<p>这种时钟称为<code>可编程时钟</code> ，可编程时钟有两种模式，一种是 <code>一键式(one-shot mode)</code>，当时钟启动时，会把存储器中的值复制到计数器中，然后，每次晶体的振荡器的脉冲都会使计数器 -1。当计数器变为 0 时，会产生一个中断，并停止工作，直到软件再一次显示启动。还有一种模式时 <code>方波(square-wave mode)</code> 模式，在这种模式下，当计数器变为 0 并产生中断后，存储寄存器的值会自动复制到计数器中，这种周期性的中断称为一个时钟周期。</p>
<h3 id="时钟软件"><a href="#时钟软件" class="headerlink" title="时钟软件"></a>时钟软件</h3><p>时钟硬件所做的工作只是根据已知的时间间隔产生中断，而其他的工作都是由<code>时钟软件</code>来完成，一般操作系统的不同，时钟软件的具体实现也不同，但是一般都会包括以下这几点</p>
<ul>
<li>维护一天的时间</li>
<li>阻止进程运行的时间超过其指定时间</li>
<li>统计 CPU 的使用情况</li>
<li>处理用户进程的警告系统调用</li>
<li>为系统各个部分提供看门狗定时器</li>
<li>完成概要剖析，监视和信息收集</li>
</ul>
<h3 id="软定时器"><a href="#软定时器" class="headerlink" title="软定时器"></a>软定时器</h3><p>时钟软件也被称为可编程时钟，可以设置它以程序需要的任何速率引发中断。时钟软件触发的中断是一种硬中断，但是某些应用程序对于硬中断来说是不可接受的。</p>
<p>这时候就需要一种<code>软定时器(soft timer)</code> 避免了中断，无论何时当内核因为某种原因呢在运行时，它返回用户态之前都会检查时钟来了解软定时器是否到期。如果软定时器到期，则执行被调度的事件也无需切换到内核态，因为本身已经处于内核态中。这种方式避免了频繁的内核态和用户态之前的切换，提高了程序运行效率。</p>
<p>软定时器因为不同的原因切换进入内核态的速率不同，原因主要有</p>
<ul>
<li>系统调用</li>
<li>TLB 未命中</li>
<li>缺页异常</li>
<li>I/O 中断</li>
<li>CPU 变得空闲</li>
</ul>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/06/14/os-project4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/14/os-project4/" itemprop="url">os-project4</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-06-14T12:06:23+08:00">
                2021-06-14
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-08-23T14:22:18+08:00">
                2022-08-23
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="os-project4"><a href="#os-project4" class="headerlink" title="os-project4"></a>os-project4</h1><h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h2><p>1.熟悉Minix操作系统的进程管理</p>
<p>2.学习Unix风格的内存管理</p>
<h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p>修改Minix3.1.2a的<strong>进程管理器</strong>，改进brk系统调用的实现，使得分配给进程的数据段+栈段空间耗尽时，brk系统调用给该进程<strong>分配一个更大的内存空间</strong>，并将原来空间中的数据复制至新分配的内存空间，释放原来的内存空间，并通知内核映射新分配的内存段。</p>
<p><img src="/2021/06/14/os-project4/1.png" style="zoom:67%;"></p>
<p><img src="/2021/06/14/os-project4/4.png" style="zoom:67%;"></p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>这次的试验需要用到 Minix3.1.2</p>
<p>在配置3.1.2的过程中，我发现 VirtualBox 似乎没有修改硬件兼容性的设置，因此最后还是在VMware上进行开发。</p>
<p>启动虚拟机时，在setup步骤中，网卡选择AMD LANCE，否则无法获得IP地址，其他可选择默认设置。安装完之后，输入shutdown，然后输入boot d0p0重启，后续关机都需输入shutdown，否则可能导致磁盘错误。</p>
<p>输入<code>mv /etc/rc.daemons.dist  /etc/rc.daemons</code>。在网络模式为NAT模式时，这样在重启后可以看到IP地址(若无法连接ftp，检查该处是否修改)。</p>
<p>在虚拟机终端输入<code>packman</code>可以安装额外的软件包（不能移除iso镜像），为了方便，可以选择全部安装（大概400MB）。安装完之后，open-ssh，vim等已经安装。输入passwd root为root用户创建密码，在重启后可用ftp连接虚拟机（仍然是NAT模式）</p>
<p>能获得ip之后，在虚拟机窗口中输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ftp</span><br><span class="line">open 192.168.98.128</span><br></pre></td></tr></table></figure>
<p>然后就可以在本机上通过ftp和ssh连接虚拟机了</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>PM是用户进程，printf结果显示在虚拟机下，可以不需要串口输出。</li>
<li><p>相关的函数</p>
<ul>
<li>alloc_mem 分配内存</li>
<li>sys_abscopy 拷贝内存内容</li>
<li>free_mem 释放内存</li>
<li>sys_newmap 通知内核，注册内存段</li>
<li>用户调用brk函数针对的是虚拟地址，而minix最底层内存管理是物理地址，不能混淆。</li>
<li>需要小心处理clicks 和 bytes的单位换算和对齐。</li>
</ul>
</li>
<li><p>本实验是修改brk系统调用的实现，所以不需要更改brk系统调用的接口，brk函数调用的参数和返回值请遵循原定义，请不要修改。</p>
</li>
<li><p>程序运行错误会可能产生体积很大的core文件，建议在磁盘空间较大的/home下做实验，否则可能会占满磁盘，导致无法开机。</p>
</li>
<li><p>如果break修改后导致程序的编译都无法正常进行（因为在程序编译的过程中可能需要brk系统调用）。在这种情况下，需从未修改过的内核中对程序进行编译。</p>
</li>
<li><p>CC编译器版本很老，语法检查很严格，编写C代码时不要引入非英文字符，或者使用高级语法。</p>
</li>
<li><p>本project使用的Minix版本号是3.1.2。</p>
</li>
</ul>
<h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><h4 id="修改内存分配："><a href="#修改内存分配：" class="headerlink" title="修改内存分配："></a>修改内存分配：</h4><p>我们知道，Minix的内存管理非常简单: 存储管理器保存着一张按照内存地址排列的空洞列表。当由于执行系统调用FORK或者EXEC需要内存时，系统会使用 <code>first-fit</code> 的策略找出一个能放得下的hole。那么首先我们来看一下<code>hole</code>的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_HOLES         128    <span class="comment">/* max # entries in hole table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NIL_HOLE (struct hole *)0 <span class="comment">//说明这块是空的</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NIL_HOLE (struct hole *) 0</span></span><br><span class="line"></span><br><span class="line">PRIVATE <span class="class"><span class="keyword">struct</span> <span class="title">hole</span> &#123;</span></span><br><span class="line"> 	phys_clicks h_base;           <span class="comment">/* 空洞的开始地址*/</span></span><br><span class="line">	phys_clicks h_len;            <span class="comment">/* 空洞的长度 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hole</span> *<span class="title">h_next</span>;</span>          <span class="comment">/* 指向下一个空洞 */</span></span><br><span class="line">&#125; hole[NR_HOLES]; </span><br><span class="line"></span><br><span class="line">PRIVATE <span class="class"><span class="keyword">struct</span> <span class="title">hole</span> *<span class="title">hole_head</span>;</span> 	<span class="comment">/* pointer to first hole */</span> </span><br><span class="line"></span><br><span class="line">PRIVATE <span class="class"><span class="keyword">struct</span> <span class="title">hole</span> *<span class="title">free_slots</span>;</span>    <span class="comment">/* ptr to list of unused table slots */</span></span><br></pre></td></tr></table></figure>
<p>那么现在，我们需要修改<code>/usr/src/servers/pm/alloc.c</code>中的<code>alloc_mem</code>函数，<strong>把first-fit修改成best-fit</strong>，即分配内存之前，先遍历整个空闲内存块列表，找到最佳匹配的空闲块。而之前的策略，是找到第一个能放下的空闲块。</p>
<p>不妨先看一下原来的best-fit策略是怎么写的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PUBLIC phys_clicks <span class="title">alloc_mem</span><span class="params">(clicks)</span></span></span><br><span class="line"><span class="function">phys_clicks clicks</span>;       </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">hole</span> *<span class="title">hp</span>, *<span class="title">prev_ptr</span>;</span></span><br><span class="line"> 	phys_clicks old_base;</span><br><span class="line">	hp = hole_head;<span class="comment">/*从链表头开始遍历*/</span></span><br><span class="line"> 	<span class="keyword">while</span> (hp != NIL_HOLE) &#123;</span><br><span class="line">		<span class="keyword">if</span> (hp-&gt;h_len &gt;= clicks) &#123;</span><br><span class="line">    	old_base = hp-&gt;h_base;  <span class="comment">/* 记下老的基地址 */</span></span><br><span class="line">    	hp-&gt;h_base += clicks;   <span class="comment">/* 修改空洞的基地址 */</span></span><br><span class="line">     	hp-&gt;h_len -= clicks;    <span class="comment">/* 修改空洞的长度*/</span></span><br><span class="line">    	<span class="comment">/* 如果空洞没有用完，直接返回，old_base 就是所求*/</span></span><br><span class="line">        <span class="keyword">if</span> (hp-&gt;h_len != <span class="number">0</span>) <span class="keyword">return</span>(old_base);</span><br><span class="line">		<span class="comment">/* 整个空洞都用完了，把该空洞放到一个free list中*/</span></span><br><span class="line">        del_slot(prev_ptr, hp);</span><br><span class="line">       <span class="keyword">return</span>(old_base);</span><br><span class="line">  &#125;</span><br><span class="line"> 	prev_ptr = hp;</span><br><span class="line"> 	hp = hp-&gt;h_next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PUBLIC phys_clicks <span class="title">alloc_mem</span><span class="params">(clicks)</span></span></span><br><span class="line"><span class="function">    phys_clicks clicks</span>; <span class="comment">/* click即需要请求的内存大小 */</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">/*search the whole linked list and allocate the minist space that can hold the process, which is called best-fit strategy*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">hole</span> *<span class="title">hp</span>, *<span class="title">temp</span>,*<span class="title">temp_ptr</span>,*<span class="title">prev_ptr</span>;</span></span><br><span class="line">    phys_clicks old_base;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">do-while 代码段的意思是，当我们循环一遍都没找到合适的空洞，就可以把退出内存的进程赶出去，然后再循环</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">     <span class="comment">//初始情况下， temp和及最佳适配hp都在链表头部</span></span><br><span class="line">    temp_ptr = hole_head;</span><br><span class="line">    prev_ptr=NIL_HOLE;</span><br><span class="line">    temp=hole_head;</span><br><span class="line">	hp = hole_head;</span><br><span class="line">    <span class="comment">//接下来遍历整个链表，找到最适合存放的block</span></span><br><span class="line">	<span class="keyword">while</span> (hp != NIL_HOLE &amp;&amp; hp-&gt;h_base &lt; swap_base) &#123;</span><br><span class="line">        <span class="comment">// 找到了一个空间大于clicks，就更新temp</span></span><br><span class="line">        <span class="keyword">if</span> (hp-&gt;h_len &gt;= clicks&amp;&amp;temp==hole_head) &#123;</span><br><span class="line">            temp=hp;</span><br><span class="line">            temp_ptr=prev_ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*找到比原来更合适的也更新temp*/</span></span><br><span class="line">        <span class="keyword">if</span>((hp-&gt;h_len &gt;= clicks&amp;&amp;hp-&gt;h_len&lt;temp-&gt;h_len)) &#123;</span><br><span class="line">            temp=hp;</span><br><span class="line">            temp_ptr=prev_ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*遍历链表*/</span></span><br><span class="line">		prev_ptr = hp;</span><br><span class="line">		hp = hp-&gt;h_next;</span><br><span class="line">	&#125; <span class="keyword">if</span>(temp!=hole_head)&#123;</span><br><span class="line">        <span class="comment">// 如果temp移动了就说明temp所在的位置就是最佳匹配。然后用hole_point指向它即可</span></span><br><span class="line">        hp=temp;</span><br><span class="line">        prev_ptr=temp_ptr;</span><br><span class="line">           old_base = hp-&gt;h_base;   <span class="comment">/* 记下老的基地址 */</span></span><br><span class="line">           hp-&gt;h_base += clicks;    <span class="comment">/* 修改空洞的基地址 */</span></span><br><span class="line">           hp-&gt;h_len -= clicks;    	<span class="comment">/* 修改空洞的长度*/</span></span><br><span class="line">          </span><br><span class="line">           <span class="comment">/* Remember new high watermark of used memory. */</span></span><br><span class="line">           <span class="keyword">if</span>(hp-&gt;h_base &gt; high_watermark)</span><br><span class="line">               high_watermark = temp-&gt;h_base;</span><br><span class="line">               <span class="comment">/*完全用完了，就删除，把该空洞放到一个free list中*/</span></span><br><span class="line">            <span class="keyword">if</span>(hp-&gt;h_len==<span class="number">0</span>)</span><br><span class="line">            del_slot(prev_ptr,hp);</span><br><span class="line">           <span class="keyword">return</span>(old_base);</span><br><span class="line">       &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (swap_out());		<span class="comment">/* try to swap some other process out */</span></span><br><span class="line">   </span><br><span class="line">  <span class="keyword">return</span>(NO_MEM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>修改/usr/src/servers/pm/break.c中的adjust函数，并增加了一个allocate_new_mem局部函数在adjust函数中调用。brk系统调用流程：</p>
<ul>
<li><p>do_brk函数<strong>计算数据段新的边界</strong>，然后调用adjust函数，adjust函数计算程序当前的空闲空间是否足够分配：</p>
<ul>
<li><p>若足够，则调整数据段指针，堆栈指针；通知内核程序的映像发生了变化，返回do_brk函数。</p>
</li>
<li><p>若不够，调用allocate_new_mem函数申请新的足够大的内存空间；将程序现有的数据段和堆栈段的内容分别拷贝至新内存区域的底部(bottom)和顶部(top)；通知内核程序的映像发生了变化；返回do_brk函数。</p>
</li>
<li><p>```c<br>r = adjust(rmp, new_clicks, new_sp); // 如果成功，adjust会返回OK<br>/<em>最后返回地址或者-1(报错)</em>/<br>rmp-&gt;mp_reply.reply_ptr = (r == OK ? m_in.addr : (char*)-1); </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">那么首先来看一下 &#96;adjust&#96; 函数的原理, 需要改动的地方其实不多。只是原本并没有不够用了就扩容的功能。当函数发现 &#96;lower&lt; gap_base&#96; 的时候，说明栈段和数据存储段发生了冲突，这时候调用 &#96;alloc_new_mem&#96; 并判断是否申请成功。是则返回0，否则就返回 ENOMEM，表示没空间了。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;c</span><br><span class="line">PUBLIC int adjust(rmp, data_clicks, sp) register struct mproc *rmp; &#x2F;* whose memory is being adjusted? *&#x2F;</span><br><span class="line">vir_clicks data_clicks;                                             &#x2F;* how big is data segment to become? *&#x2F;</span><br><span class="line">vir_bytes sp;                                                       &#x2F;* new value of sp *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;* </span><br><span class="line">    看栈段和数据段能否共存，有必要的话调整一下</span><br><span class="line">    需要注意的是，原版这里给出的注释是: 内存从未被分配或者是释放，它只是在数据段和栈段之间的空隙中加减罢了。如果gap的大小最终变为负数，说明这个调整失败了,此时就需要返回 ENOMEM</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">    register struct mem_map *mem_sp, *mem_dp;</span><br><span class="line">    vir_clicks sp_click, gap_base, lower, old_clicks;</span><br><span class="line">    int changed, r, ft;</span><br><span class="line">    long base_of_stack, delta; &#x2F;* longs avoid certain problems *&#x2F;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    int results;</span><br><span class="line"></span><br><span class="line">    mem_dp &#x3D; &amp;rmp-&gt;mp_seg[D]; &#x2F;*数据段指针*&#x2F; </span><br><span class="line">    mem_sp &#x3D; &amp;rmp-&gt;mp_seg[S]; &#x2F;*栈段指针*&#x2F;</span><br><span class="line">    changed &#x3D; 0;              &#x2F;*一个 flag,用来放栈段&#x2F;数据段是否已被修改*&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果当前 栈段长度为0，说明栈为空，直接返回OK</span><br><span class="line">    if (mem_sp-&gt;mem_len &#x3D;&#x3D; 0)</span><br><span class="line">        return (OK); &#x2F;* don&#39;t bother init *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;* See if stack size has gone negative (i.e., sp too close to 0xFFFF...) *&#x2F;</span><br><span class="line">    &#x2F;*</span><br><span class="line">    判断栈的大小是否已经为负</span><br><span class="line">    *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;栈基为虚拟地址加栈长度</span><br><span class="line">    base_of_stack &#x3D; (long)mem_sp-&gt;mem_vir + (long)mem_sp-&gt;mem_len;</span><br><span class="line">    sp_click &#x3D; sp &gt;&gt; CLICK_SHIFT; &#x2F;* click containing sp *&#x2F;</span><br><span class="line">    if (sp_click &gt;&#x3D; base_of_stack)</span><br><span class="line">        return (ENOMEM); &#x2F;* sp too high *&#x2F;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &#x2F;* 新旧栈指针的差 栈向下生长的距离,因为栈是向下生长的，所以要用当前的虚拟地址减*&#x2F;</span><br><span class="line">    </span><br><span class="line">    delta &#x3D; (long)mem_sp-&gt;mem_vir&#x2F;*旧*&#x2F; - (long)sp_click&#x2F;*新*&#x2F;;</span><br><span class="line">    &#x2F;&#x2F;r</span><br><span class="line">    lower &#x3D; (delta &gt; 0 ? sp_click : mem_sp-&gt;mem_vir);</span><br><span class="line"></span><br><span class="line">    &#x2F;* Add a safety margin for future stack growth. Impossible to do right. *&#x2F;</span><br><span class="line">#define SAFETY_BYTES (384 * sizeof(char *))</span><br><span class="line">#define SAFETY_CLICKS ((SAFETY_BYTES + CLICK_SIZE - 1) &#x2F; CLICK_SIZE)</span><br><span class="line">    gap_base &#x3D; mem_dp-&gt;mem_vir + data_clicks + SAFETY_CLICKS;</span><br><span class="line">    </span><br><span class="line">    &#x2F;*</span><br><span class="line">    origin:</span><br><span class="line">    说明栈段和数据存储段发生了冲突</span><br><span class="line">    if (lower &lt; gap_base) return(ENOMEM); &#x2F;* data and stack collided</span><br><span class="line">    new: 见下</span><br><span class="line">    *&#x2F;</span><br><span class="line">    &#x2F;* 现在，调用allocate_new_mem, 申请更大的内存空间 *&#x2F;</span><br><span class="line">    if (lower &lt; gap_base)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;*add the length of stack to the virtual address of stack</span><br><span class="line">        to get the length of the memory space*&#x2F;</span><br><span class="line">        results &#x3D; allocate_new_mem(rmp, data_clicks, delta, (phys_clicks)(rmp-&gt;mp_seg[S].mem_vir - rmp-&gt;mp_seg[D].mem_vir + rmp-&gt;mp_seg[S].mem_len));</span><br><span class="line">        &#x2F;&#x2F;判断是否申请成功</span><br><span class="line">        if (results &#x3D;&#x3D; ENOMEM)</span><br><span class="line">            return (ENOMEM);</span><br><span class="line">        else if (results &#x3D;&#x3D; OK)</span><br><span class="line">            return (OK);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    &#x2F;* 如果栈段数据段不冲突，那么就更新数据段的长度. *&#x2F;</span><br><span class="line">    old_clicks &#x3D; mem_dp-&gt;mem_len;</span><br><span class="line">    if (data_clicks !&#x3D; mem_dp-&gt;mem_len)</span><br><span class="line">    &#123;</span><br><span class="line">        mem_dp-&gt;mem_len &#x3D; data_clicks;</span><br><span class="line">        &#x2F;&#x2F;设置Flag</span><br><span class="line">        changed |&#x3D; DATA_CHANGED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 根据栈指针的变化修改栈的长度 *&#x2F;</span><br><span class="line">    if (delta &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">		&#x2F;&#x2F;更新栈指针的虚拟地址和物理地址，地址向下增长</span><br><span class="line">        mem_sp-&gt;mem_vir -&#x3D; delta;</span><br><span class="line">        mem_sp-&gt;mem_phys -&#x3D; delta;</span><br><span class="line">        &#x2F;&#x2F;更新栈长度</span><br><span class="line">        mem_sp-&gt;mem_len +&#x3D; delta;</span><br><span class="line">        changed |&#x3D; STACK_CHANGED;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    &#x2F;* 判断新的栈段、数据段大小是否适合地址空间 *&#x2F;</span><br><span class="line">    ft &#x3D; (rmp-&gt;mp_flags &amp; SEPARATE);</span><br><span class="line">#if (CHIP &#x3D;&#x3D; INTEL &amp;&amp; _WORD_SIZE &#x3D;&#x3D; 2)</span><br><span class="line">    r &#x3D; size_ok(ft, rmp-&gt;mp_seg[T].mem_len, rmp-&gt;mp_seg[D].mem_len,</span><br><span class="line">                rmp-&gt;mp_seg[S].mem_len, rmp-&gt;mp_seg[D].mem_vir, rmp-&gt;mp_seg[S].mem_vir);</span><br><span class="line">#else</span><br><span class="line">    r &#x3D; (rmp-&gt;mp_seg[D].mem_vir + rmp-&gt;mp_seg[D].mem_len &gt;</span><br><span class="line">         rmp-&gt;mp_seg[S].mem_vir)</span><br><span class="line">            ? ENOMEM</span><br><span class="line">            : OK;</span><br><span class="line">#endif</span><br><span class="line">    if (r &#x3D;&#x3D; OK)</span><br><span class="line">    &#123;</span><br><span class="line">        int r2;</span><br><span class="line">        if (changed &amp;&amp; (r2 &#x3D; sys_newmap(rmp-&gt;mp_endpoint, rmp-&gt;mp_seg)) !&#x3D; OK)</span><br><span class="line">            panic(__FILE__, &quot;couldn&#39;t sys_newmap in adjust&quot;, r2);</span><br><span class="line">        free_mem(old_base, old_clicks);</span><br><span class="line">        printf(&quot;free the old memory space\n&quot;);</span><br><span class="line">        return (OK);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;size not ok!\n&quot;);</span><br><span class="line">    &#x2F;* New sizes don&#39;t fit or require too many page&#x2F;segment registers. Restore.*&#x2F;</span><br><span class="line">    if (changed &amp; DATA_CHANGED)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        mem_dp-&gt;mem_len &#x3D; cur_clicks;</span><br><span class="line">        mem_dp-&gt;mem_phys &#x3D; cur_base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (changed &amp; STACK_CHANGED)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;restore stack segment\n&quot;);</span><br><span class="line">        mem_sp-&gt;mem_vir &#x3D; cur_v_base;</span><br><span class="line">        mem_sp-&gt;mem_phys &#x3D; cur_s_base;</span><br><span class="line">        mem_sp-&gt;mem_len &#x3D; cur_s_click;</span><br><span class="line">    &#125;</span><br><span class="line">    return (ENOMEM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2021/06/14/os-project4/6.png" style="zoom:67%;"></p>
<p>那么 我们自己写的<code>allocate_new_mem</code> 的原理又如何呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*===========================================================================*</span></span><br><span class="line"><span class="comment"> *			allocate_new_mem 		             *</span></span><br><span class="line"><span class="comment"> *===========================================================================*/</span></span><br><span class="line"><span class="function">PUBLIC <span class="keyword">int</span> <span class="title">allocate_new_mem</span><span class="params">(rmp, d_clicks, delta, clicks)</span> <span class="keyword">register</span> struct mproc *rmp</span>;</span><br><span class="line">phys_clicks d_clicks;</span><br><span class="line"><span class="keyword">long</span> delta;</span><br><span class="line">phys_clicks clicks;</span><br><span class="line"><span class="comment">/*rmp指向进程的mproc结构，</span></span><br><span class="line"><span class="comment">d_clicks为adjust函数中的data_clicks</span></span><br><span class="line"><span class="comment">click指原来内存空间的大小;</span></span><br><span class="line"><span class="comment">delta代表新旧栈指针的差值，表示栈向下增长了多少</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem_map</span> *<span class="title">mem_sp</span>, *<span class="title">mem_dp</span>;</span></span><br><span class="line"></span><br><span class="line">    phys_bytes old_bytes, data_bytes;</span><br><span class="line">    phys_bytes stak_bytes;</span><br><span class="line">    phys_bytes old_d_tran, new_d_tran;</span><br><span class="line">    phys_bytes old_s_tran, new_s_tran;</span><br><span class="line">    phys_clicks old_clicks, old_base;</span><br><span class="line">    phys_clicks new_clicks, new_base;</span><br><span class="line">    phys_clicks new_s_base;</span><br><span class="line">    phys_clicks old_s_base, stak_clicks;</span><br><span class="line">    phys_clicks cur_s_base, cur_base;</span><br><span class="line">    phys_clicks cur_clicks, cur_s_click;</span><br><span class="line">    vir_clicks cur_v_base, len_old;</span><br><span class="line">    <span class="keyword">int</span> c, d, e, s;</span><br><span class="line">    <span class="keyword">int</span> changed, r, ft;</span><br><span class="line">    changed = <span class="number">0</span>;</span><br><span class="line">    mem_dp = &amp;rmp-&gt;mp_seg[D];</span><br><span class="line">    mem_sp = &amp;rmp-&gt;mp_seg[S];</span><br><span class="line">    len_old = mem_sp-&gt;mem_len + (mem_sp-&gt;mem_vir - mem_dp-&gt;mem_vir);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*新的地址空间的大小是旧的2倍*/</span></span><br><span class="line">    old_clicks = clicks;</span><br><span class="line">    new_clicks = clicks * <span class="number">2</span>;</span><br><span class="line">    <span class="comment">/*调用alloc_mem并判断是否出错*/</span></span><br><span class="line">    <span class="keyword">if</span> ((new_base = alloc_mem(new_clicks)) == NO_MEM)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"allocate ---error!"</span>);</span><br><span class="line">        <span class="keyword">return</span> (ENOMEM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*与此同时，保存下来原来的栈段和数据段的地址和大小*/</span></span><br><span class="line">    <span class="comment">/*change clicks to bytes*/</span></span><br><span class="line">    data_bytes = (phys_bytes)rmp-&gt;mp_seg[D].mem_len &lt;&lt; CLICK_SHIFT;</span><br><span class="line">    stak_bytes = (phys_bytes)rmp-&gt;mp_seg[S].mem_len &lt;&lt; CLICK_SHIFT;</span><br><span class="line"></span><br><span class="line">    old_base = rmp-&gt;mp_seg[D].mem_phys;</span><br><span class="line">    old_s_base = rmp-&gt;mp_seg[S].mem_phys;</span><br><span class="line">    <span class="comment">/*the top of the stack*/</span></span><br><span class="line">    new_s_base = new_base + new_clicks - mem_sp-&gt;mem_len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*将新旧栈段和数据段基地址都转化为phys_bytes*/</span></span><br><span class="line">    new_d_tran = (phys_bytes)new_base &lt;&lt; CLICK_SHIFT;</span><br><span class="line">    old_d_tran = (phys_bytes)old_base &lt;&lt; CLICK_SHIFT;</span><br><span class="line">    </span><br><span class="line">    new_s_tran = (phys_bytes)new_s_base &lt;&lt; CLICK_SHIFT;</span><br><span class="line">    old_s_tran = (phys_bytes)old_s_base &lt;&lt; CLICK_SHIFT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*从下往上，用0来填充新获得的内存*/</span></span><br><span class="line">    sys_memset(<span class="number">0</span>, new_d_tran, (new_clicks &lt;&lt; CLICK_SHIFT));</span><br><span class="line">	<span class="comment">/*将数据段和栈段分别复制到新的内存空间的底部和顶部并通过sys_abscopy返回值判断是否复制成功*/</span></span><br><span class="line">    d = sys_abscopy(old_d_tran, new_d_tran, data_bytes);</span><br><span class="line">    <span class="keyword">if</span> (d &lt; <span class="number">0</span>)</span><br><span class="line">        panic(__FILE__, <span class="string">" can't copy data segment in alloc_new_mem"</span>, d);</span><br><span class="line">    s = sys_abscopy(old_s_tran, new_s_tran, stak_bytes);</span><br><span class="line">    <span class="keyword">if</span> (s &lt; <span class="number">0</span>)</span><br><span class="line">        panic(__FILE__, <span class="string">" can't copy stack segment in alloc_new_mem"</span>, s);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*保存当前的数据段和栈段的物理地址和虚拟地址*/</span></span><br><span class="line">    cur_base = rmp-&gt;mp_seg[D].mem_phys;</span><br><span class="line">    cur_s_base = rmp-&gt;mp_seg[S].mem_phys;</span><br><span class="line">    cur_v_base = rmp-&gt;mp_seg[S].mem_vir;</span><br><span class="line">    cur_s_click = mem_sp-&gt;mem_len;</span><br><span class="line">    <span class="comment">/*更新进程数据段和栈段的内存地址以及栈段的虚拟地址*/</span></span><br><span class="line">    rmp-&gt;mp_seg[D].mem_phys = new_base;</span><br><span class="line">    rmp-&gt;mp_seg[S].mem_phys = new_s_base;</span><br><span class="line">    rmp-&gt;mp_seg[S].mem_vir = rmp-&gt;mp_seg[D].mem_vir + new_clicks - mem_sp-&gt;mem_len;</span><br><span class="line">	<span class="comment">/*保存当前的数据段长度*/</span></span><br><span class="line">    cur_clicks = mem_dp-&gt;mem_len;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/*更新数据段的长度*/</span></span><br><span class="line">    <span class="keyword">if</span> (d_clicks != mem_dp-&gt;mem_len)</span><br><span class="line">    &#123;</span><br><span class="line">        mem_dp-&gt;mem_len = d_clicks;</span><br><span class="line">        changed |= DATA_CHANGED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 根据栈指针的变化更新栈长度. */</span></span><br><span class="line">    <span class="keyword">if</span> (delta &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"change stack segment\n"</span>);</span><br><span class="line">        mem_sp-&gt;mem_vir -= delta;</span><br><span class="line">        mem_sp-&gt;mem_phys -= delta;</span><br><span class="line">        mem_sp-&gt;mem_len += delta;</span><br><span class="line">        changed |= STACK_CHANGED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 判断新的栈段、数据段大小是否适合地址空间 */</span></span><br><span class="line">    ft = (rmp-&gt;mp_flags &amp; SEPARATE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (CHIP == INTEL &amp;&amp; _WORD_SIZE == 2)</span></span><br><span class="line">    r = size_ok(ft, rmp-&gt;mp_seg[T].mem_len, rmp-&gt;mp_seg[D].mem_len,</span><br><span class="line">                rmp-&gt;mp_seg[S].mem_len, rmp-&gt;mp_seg[D].mem_vir, rmp-&gt;mp_seg[S].mem_vir);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    r = (rmp-&gt;mp_seg[D].mem_vir + rmp-&gt;mp_seg[D].mem_len &gt;</span><br><span class="line">         rmp-&gt;mp_seg[S].mem_vir)</span><br><span class="line">            ? ENOMEM</span><br><span class="line">            : OK;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (r == OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> r2;</span><br><span class="line">        <span class="keyword">if</span> (changed &amp;&amp; (r2 = sys_newmap(rmp-&gt;mp_endpoint, rmp-&gt;mp_seg)) != OK)</span><br><span class="line">            panic(__FILE__, <span class="string">"couldn't sys_newmap in adjust"</span>, r2);</span><br><span class="line">        free_mem(old_base, old_clicks);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"free the old memory space\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> (OK);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    <span class="comment">//否则就是不OK了，那么就需要恢复栈段、数据段到旧的地址空间去</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"size not ok!\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (changed &amp; DATA_CHANGED)</span><br><span class="line">    &#123;</span><br><span class="line">        mem_dp-&gt;mem_len = cur_clicks;</span><br><span class="line">        mem_dp-&gt;mem_phys = cur_base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (changed &amp; STACK_CHANGED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"restore stack segment\n"</span>);</span><br><span class="line">        mem_sp-&gt;mem_vir = cur_v_base;</span><br><span class="line">        mem_sp-&gt;mem_phys = cur_s_base;</span><br><span class="line">        mem_sp-&gt;mem_len = cur_s_click;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ENOMEM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/14/os-project4/5.png" style="zoom:67%;"></p>
<ul>
<li>编译Minix：<ul>
<li>进入/usr/src/servers目录，输入make image, 等编译成功之后输入make install 安装新的PM程序。</li>
<li>进入/usr/src/tools目录，输入make hdboot, 成功之后再键入make install命令安装新的内核程序。</li>
<li>键入shutdown 命令关闭虚拟机，进入boot monitor界面。设置启动新内核的选项，在提示符键入：  <code>newminix(5,start new kernel) {image=/boot/image/3.1.2ar1;boot;}</code></li>
<li>然后回车，键入save命令保存设置。 5为启动菜单中的选择内核版本的键(数字键，可选其他数字键)，<strong>3.1.2ar1</strong>为在<code>/usr/src/tools</code>目录中输入<code>make install</code>之后生成的内核版本号，请记得在<code>/usr/src/tools</code>中执行<code>make install</code>命令之后记录生成的新内核版本号。 </li>
<li>输入<code>menu</code>命令，然后敲数字键（上一步骤中设置的数字）启动新内核，登录进<code>minix 3</code>中测试。</li>
</ul>
</li>
</ul>
<h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ul>
<li>测试程序在编写时有特定要求，即将所有的变量申明放到main函数之外，让所有的变量变成全局变量，不允许使用局部变量。按照Minix3的规则全局变量保存在数据段中，不存放在堆栈中，所以可以通过测试。</li>
<li>测试程序一只是简单测试sbrk调用，<strong>不断的调整数据段的上界</strong>，并未对新分配的内存空间进行访问。</li>
</ul>
<p>test1.c 代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> inc = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">sbrk</span><span class="params">(<span class="keyword">int</span> incr)</span></span>;</span><br><span class="line"><span class="keyword">char</span> *result;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">int</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    sbrk不是系统调用，是C库函数。sbrk/brk 是从堆中分配空间，本质是移动1个位置。向后移动是分配空间，向前移就是释放空间，sbrk用相对的证书值来确定位置，如果这个整数时整数，会从当前位置向后移若干字节，若为负数旧向前移动若干字节。在任何情况下，返回值永远时移动之前的位置</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span> (((<span class="keyword">int</span>)(result = sbrk(inc))) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                total += inc;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"incremented by %d, total %d\n"</span>, inc, total);</span><br><span class="line">            	<span class="comment">//每次inc都翻倍</span></span><br><span class="line">                inc += inc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改前如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">incremented by 1, total 1</span><br><span class="line">incremented by 2, total 3</span><br><span class="line">incremented by 4, total 7</span><br><span class="line">incremented by 8, total 15</span><br><span class="line">incremented by 16, total 31</span><br><span class="line">incremented by 32, total 63</span><br><span class="line">incremented by 64, total 127</span><br><span class="line">incremented by 128, total 255</span><br><span class="line">incremented by 256, total 511</span><br><span class="line">incremented by 512, total 1023</span><br><span class="line">incremented by 1024, total 2047</span><br><span class="line">incremented by 2048, total 4095</span><br><span class="line">incremented by 4096, total 8191</span><br><span class="line">incremented by 8192, total 16383</span><br><span class="line">incremented by 16384, total 32767</span><br><span class="line">incremented by 32768, total 65535</span><br></pre></td></tr></table></figure>
<p>修改后如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">incremented by 1, total 1</span><br><span class="line">incremented by 2, total 3</span><br><span class="line">incremented by 4, total 7</span><br><span class="line">incremented by 8, total 15</span><br><span class="line">incremented by 16, total 31</span><br><span class="line">incremented by 32, total 63</span><br><span class="line">incremented by 64, total 127</span><br><span class="line">incremented by 128, total 255</span><br><span class="line">incremented by 256, total 511</span><br><span class="line">incremented by 512, total 1023</span><br><span class="line">incremented by 1024, total 2047</span><br><span class="line">incremented by 2048, total 4095</span><br><span class="line">incremented by 4096, total 8191</span><br><span class="line">incremented by 8192, total 16383</span><br><span class="line">incremented by 16384, total 32767</span><br><span class="line">incremented by 32768, total 65535</span><br><span class="line">incremented by 65536, total 131071</span><br><span class="line">incremented by 131072, total 262143</span><br><span class="line">incremented by 262144, total 524287</span><br><span class="line">incremented by 524288, total 1048575</span><br><span class="line">incremented by 1048576, total 2097151</span><br><span class="line">incremented by 2097152, total 4194303</span><br><span class="line">incremented by 4194304, total 8388607</span><br><span class="line">incremented by 8388608, total 16777215</span><br><span class="line">incremented by 16777216, total 33554431</span><br><span class="line">incremented by 33554432, total 67108863</span><br></pre></td></tr></table></figure>
<ul>
<li>测试程序二则对新分配的内存空间进行了访问。</li>
</ul>
<p>test2.c 代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> inc = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">sbrk</span><span class="params">(<span class="keyword">int</span> incr)</span></span>;</span><br><span class="line"><span class="keyword">char</span> *result;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">int</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (((<span class="keyword">int</span>)(result = sbrk(inc))) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//向新分配的地址写一些东西</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; inc; i++)</span><br><span class="line">            result[i] = <span class="number">0x12</span>;</span><br><span class="line">        total += inc;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"incremented by: %d, total: %d , result: %d\n"</span>, inc, total,   (<span class="keyword">int</span>)result);</span><br><span class="line">        inc += inc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">incremented by: 1, total: 1 , result: 760</span><br><span class="line">incremented by: 2, total: 3 , result: 4096</span><br><span class="line">incremented by: 4, total: 7 , result: 4098</span><br><span class="line">incremented by: 8, total: 15 , result: 4102</span><br><span class="line">incremented by: 16, total: 31 , result: 4110</span><br><span class="line">incremented by: 32, total: 63 , result: 4126</span><br><span class="line">incremented by: 64, total: 127 , result: 4158</span><br><span class="line">incremented by: 128, total: 255 , result: 4222</span><br><span class="line">incremented by: 256, total: 511 , result: 4350</span><br><span class="line">incremented by: 512, total: 1023 , result: 4606</span><br><span class="line">incremented by: 1024, total: 2047 , result: 5118</span><br><span class="line">incremented by: 2048, total: 4095 , result: 6142</span><br><span class="line">incremented by: 4096, total: 8191 , result: 8190</span><br><span class="line">incremented by: 8192, total: 16383 , result: 12286</span><br><span class="line">incremented by: 16384, total: 32767 , result: 20478</span><br><span class="line">incremented by: 32768, total: 65535 , result: 36862</span><br></pre></td></tr></table></figure>
<p>修改后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">incremented by: 1, total: 1 , result: 760</span><br><span class="line">incremented by: 2, total: 3 , result: 4096</span><br><span class="line">incremented by: 4, total: 7 , result: 4098</span><br><span class="line">incremented by: 8, total: 15 , result: 4102</span><br><span class="line">incremented by: 16, total: 31 , result: 4110</span><br><span class="line">incremented by: 32, total: 63 , result: 4126</span><br><span class="line">incremented by: 64, total: 127 , result: 4158</span><br><span class="line">incremented by: 128, total: 255 , result: 4222</span><br><span class="line">incremented by: 256, total: 511 , result: 4350</span><br><span class="line">incremented by: 512, total: 1023 , result: 4606</span><br><span class="line">incremented by: 1024, total: 2047 , result: 5118</span><br><span class="line">incremented by: 2048, total: 4095 , result: 6142</span><br><span class="line">incremented by: 4096, total: 8191 , result: 8190</span><br><span class="line">incremented by: 8192, total: 16383 , result: 12286</span><br><span class="line">incremented by: 16384, total: 32767 , result: 20478</span><br><span class="line">incremented by: 32768, total: 65535 , result: 36862</span><br><span class="line">incremented by: 65536, total: 131071 , result: 69630</span><br><span class="line">incremented by: 131072, total: 262143 , result: 135166</span><br><span class="line">incremented by: 262144, total: 524287 , result: 266238</span><br><span class="line">incremented by: 524288, total: 1048575 , result: 528382</span><br><span class="line">incremented by: 1048576, total: 2097151 , result: 1052670</span><br><span class="line">incremented by: 2097152, total: 4194303 , result: 2101246</span><br><span class="line">incremented by: 4194304, total: 8388607 , result: 4198398</span><br><span class="line">incremented by: 8388608, total: 16777215 , result: 8392702</span><br><span class="line">incremented by: 16777216, total: 33554431 , result: 16781310</span><br><span class="line">incremented by: 33554432, total: 67108863 , result: 33558526</span><br></pre></td></tr></table></figure>
<ul>
<li>建议先通过测试程序一，再尝试测试程序二。通过修改brk，使得二个测试程序可以分配比之前更多的内存。测试程序最后的输出结果和分配给minix操作系统的物理内存数量有关。</li>
</ul>
<p>结果我们发现，通过修改 alloc_mem(分配策略) 和 adjust(调整策略) 之后，我们能申请到更多的内存空间了</p>
<h2 id="实验结论"><a href="#实验结论" class="headerlink" title="实验结论"></a>实验结论</h2><p>通过这次实验，我对分配策略有了更深刻的认识(下个匹配与最佳匹配等)。并更全面的从底层了解了堆调整的策略(比如sys_abscopy,alloc_mem函数，click和byte之间的转化等)</p>
<p>同时，对虚拟机的内核编译、代码调试也有了更多的经验。</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/06/10/%E6%A6%82%E7%8E%87%E8%AE%BA%E7%AC%AC%E5%85%AD%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/10/%E6%A6%82%E7%8E%87%E8%AE%BA%E7%AC%AC%E5%85%AD%E7%AB%A0/" itemprop="url">概率论第六章</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-06-10T16:34:10+08:00">
                2021-06-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2023-01-16T11:11:26+08:00">
                2023-01-16
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概率论第六章-参数估计"><a href="#概率论第六章-参数估计" class="headerlink" title="概率论第六章 参数估计"></a>概率论第六章 参数估计</h1><h2 id="点估计的概念"><a href="#点估计的概念" class="headerlink" title="点估计的概念"></a>点估计的概念</h2><p>首先我们给出<strong>点估计的定义</strong>：</p>
<p>设 $x_1,x_2\cdots,x_n$ 是来自总体的一个样本，用于估计未知参数 $\theta$ 的统计量 $\hat\theta =\hat\theta(x_1,x_2\cdots,x_n)$ 称为$\theta$ 的估计量，或称为 $\theta$ 的点估计。</p>
<p>在这里，如何构造统计量$\hat\theta$ 并没有明确的规定。只要满足一定的合理性(一般指无偏性)即可。</p>
<p>那么，什么是<strong>无偏估计</strong>？ 下面给出其定义</p>
<p>设 $\hat\theta(x_1.x_2\cdots,x_n)$ 是$\theta$ 的一个估计，$\theta$ 的参数空间为$\Theta$ ,若对任意的$\theta\in\Theta$ ，有：</p>
<script type="math/tex; mode=display">
E_\theta(\hat\theta) =\theta</script><p>则称$\hat\theta$是$\theta$的无偏估计，否则就称其为有偏估计。</p>
<p>无偏性也可以改写为 $E_\theta(\hat\theta-\theta)= 0$ , 这表示无偏估计没有系统偏差。</p>
<p>当我们使用 $\hat\theta$ 估计 $\theta$  时，由于样本的随机性，$\theta$ 与 $\hat\theta$ 总是有偏差的。无偏性表示，把这些偏差平均起来其值为0.但是若估计不具有无偏性，则无论使用多少次，其平均也会与参数真值也有一定的距离，这个距离就是系统误差。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li>对任意总体而言，<strong>样本均值 是总体均值的无偏估计</strong>。当总体k阶矩存在时，样本k阶原点矩$a_k$ 是总体k阶矩原点矩$\mu_k$ 的无偏估计。但是对k阶中心距则不一样，比如说样本方差 $s_n^2$ 就不是总体方差 $\sigma^2$ 的无偏估计。因为$E(s_n^2) = \frac{n-1}{n}\sigma^2$ ， 其中 $E(s_n^2)$是经验分布函数的方差。</li>
</ul>
<p>但是我们可以说 $E(s<em>n^2)$是 $\sigma^2$的渐近无偏。 因为满足：$\lim\limits</em>{n\rightarrow \infty}E(\hat\theta_n)=0$</p>
<ul>
<li>怎么判断哪一个无偏估计更加有效呢？可以使用求 $Var(\hat\theta)$ ，谁的方差小，谁更有效</li>
</ul>
<p>经典学派的点估计方法一共由三种：1. 替换(也就是接下来我们要讲的矩估计)  2. 拟态 3. 似然</p>
<h2 id="矩估计及相合性"><a href="#矩估计及相合性" class="headerlink" title="矩估计及相合性"></a>矩估计及相合性</h2><p>矩估计是点估计的一种特殊情况。其本质就是用经验分布函数去替换总体分布，其理论基础就是格利文科定理。统计思想就是替换原理。</p>
<p>替换原理常指用样本矩去替换总体矩，这里的矩可以使原点矩也可以是中心距；并用样本矩的函数替换相应的总体矩的函数。</p>
<p>根据这个替换原理，在总体分布形式未知的场合也可以对各种参数作出估计。譬如：</p>
<ul>
<li>用样本均值 $\overline x$ 估计总体均值 $E(X)$</li>
<li>用样本方差 $s^2$ 来估计总体方差$Var(X)$</li>
<li>用事件A出现的频率估计事件A发生的概率。</li>
<li>用样本的p分位数估计总体的p分位数，特别的，用样本中位数估计总体中位数。</li>
</ul>
<h3 id="概率函数已知时未知参数的矩估计"><a href="#概率函数已知时未知参数的矩估计" class="headerlink" title="概率函数已知时未知参数的矩估计"></a>概率函数已知时未知参数的矩估计</h3><p>现在我们给出矩估计的使用方法。设总体具有已知的概率函数 $p(x;\theta_1,\theta_2,\cdots,\theta_k),(\theta_1,\theta_2,\cdots,\theta_k)\in \Theta$ 是未知参数或参数向量，$x_1,x_2\cdots,x_n$是样本，假定总体的k阶原点矩$\mu_k$ 存在，则对所有的j，有 $0&lt;j&lt;k,\mu_j$ 都存在。<br>若假设$\theta_1,\theta_2,\cdots,\theta_k$ 能够表示成 $\mu_1,\mu_2,\cdots,\mu_k$ 的函数 $\theta_j=\theta_j(\mu_1,\mu_2,\cdots,u_k)$ ，则可以给出诸 $\theta_j$ 的矩估计</p>
<script type="math/tex; mode=display">
\hat\theta_j = \theta_j(a_1,a_2,\cdots,a_k) , j = 1,2\cdots,k</script><p>其中 $a<em>1,a_2\cdots,a_k$ 是前k阶样本原点矩，$a_j = \frac{1}{n}\sum</em>{i=1}^n x_i^j$ . 进一步的，如果我们要估计$\theta_1,\theta_2\cdots,\theta_k$的函数 $\hat\eta = g(\theta_1,\theta_2,\cdots,\theta_k)$ 则可以直接得到 $\eta$ 的矩估计为：</p>
<script type="math/tex; mode=display">
\hat\eta = g(\hat\theta_1,\hat\theta_2,\cdots,\hat\theta_k)</script><p>有上面的式子可得，当k=1时，我们通常可以由样本均值出发对参数进行估计，当$k=2$时，可以由一阶二阶原点矩出发来估计未知参数。</p>
<p>上面的定义比较抽象，现在我们用几个例子来说一下。</p>
<h5 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h5><p>设总体为指数分布，其密度函数为：</p>
<script type="math/tex; mode=display">
p(x;\lambda) =\lambda e^{-\lambda x} , x\geq 0</script><p>其中，$x_1,x_2\cdots,x_n$ 是样本</p>
<p>现在，我们要估计这个分布函数中的参数$\lambda$ ,我们所要做的就是用矩来表示这个$\lambda$.</p>
<p>很显然，对于指数分布来说 ，$E(X) = \frac{1}{\lambda}\Rightarrow \lambda = \frac{1}{E(X)}$ ，就是说可以<strong>用一阶原点矩来表示未知参数$\lambda$</strong></p>
<p>因此，我们就可利用矩法，$\hat\theta_j = \theta_j(a_1,a_2,\cdots,a_k)$ 得到， </p>
<script type="math/tex; mode=display">
\hat\lambda = 1/\overline x</script><p>不过，由于 $Var(X) = 1/\lambda^2 \Rightarrow \lambda = 1/\sqrt{Var(X)}$ 可知，$\lambda$ 的估计也可以取为：</p>
<script type="math/tex; mode=display">
\hat \lambda_1 = 1/s</script><p> s为样本标准差，这说明矩估计可能是不唯一的，此时通常应该 <strong>尽量采用低阶矩</strong> 给出未知参数的估计。</p>
<h5 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h5><p>设 $x_1,x_2\cdots,x_n$ 是来自均匀分布 $U(a,b)$ 的样本，a与b均是未知参数。怎么用矩估计呢？</p>
<p>这里，我们要用矩来表示a和b，自然想到期望和方差。</p>
<script type="math/tex; mode=display">
E(X) = \frac{a+b}{2},Var(X) = \frac{(b-a)^2}{12}</script><p>不难推出</p>
<script type="math/tex; mode=display">
a = E(X)-3\sqrt{Var(X)}, b = E(X)+3\sqrt{Var(X)}</script><p>由此可以得到 a和b的矩估计：</p>
<script type="math/tex; mode=display">
\hat a = \overline x-\sqrt 3s,~~\hat b = \overline x+\sqrt 3 s</script><h5 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h5><p>设总体分布列/密度函数如下，$x_1,x_2,\cdots,x_n$ 是样本，试求未知参数的矩估计：</p>
<p>a. $P(X=x)=(x-1)\theta^2(1-\theta)^{x-2},x=2,3\cdots,0&lt;\theta&lt;1$ </p>
<p>我们用 $E(X)$去表示$\theta$,这是一个离散的分布列，那么怎么求期望呢？ 求和或者求积分</p>
<script type="math/tex; mode=display">
E(X) = \sum_{i=2}^\infty x(x-1)\theta^2(1-\theta)^{k-2} = \theta^2 \sum_{i=2}^\infty x(x-1)\theta^2(1-\theta)^{k-2}</script><p>很容易看出，我们要求和的部分可以看做是： </p>
<script type="math/tex; mode=display">
\sum_{k=2}^\infty \frac{\partial^2(1-\theta)^k}{\partial\theta} = \frac{\partial^2}{\partial\theta}\sum_{k=2}^\infty(1-\theta)^k \\~\\
=\frac{2}{\theta^3}</script><p>所以</p>
<script type="math/tex; mode=display">
E(X) = \frac{2}{\theta^3}\cdot\theta^2 = \frac{2}{\theta}\\~\\
\theta = \frac 2{E(X)} , \hat\theta = \frac{2}{\overline X}</script><h3 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h3><p>上面说了点估计还有拟合和似然两种方法，现在我们来讲拟合。最经典的拟合方法就是最小二乘法，也就是配直线的过程。</p>
<p><img src="/2021/06/10/%E6%A6%82%E7%8E%87%E8%AE%BA%E7%AC%AC%E5%85%AD%E7%AB%A0/1.png" style="zoom: 33%;"></p>
<h3 id="相合性"><a href="#相合性" class="headerlink" title="相合性"></a>相合性</h3><p>点估计是一个统计量，因此它是一个随机变量。在我们有足够的观测值之后，根据格利文科定理，随着样本量的不断增大，经验分布函数逼近真是分不含糊，因此完全可以要求估计量随着样本量的不断增大而逼近参数真值。<strong>这就是相合性</strong>，以下是定义：</p>
<p>设$\theta\in\Theta$ 为未知参数，$\hat\theta_n = \hat\theta_n(x_1,x_2\cdots,x_n)$是一个估计量，n是样本容量，若对任何一个 $\epsilon &gt; 0$.有：</p>
<script type="math/tex; mode=display">
\lim\limits_{n\rightarrow \infty} P(|\hat\theta_n-\theta|\geq \epsilon)=0</script><p>则称$\hat\theta_n$ 为参数 $\theta$ 的相合估计。</p>
<p>相合性被认为是对估计的一个最基本要求，如果一个估计量，在样本量不断增大时，它都不能把被估参数估计到任意指定的精度。那么这个估计是很值得怀疑的，通常，不满足相合性要求的估计不予考虑。通常称相合性是一个好估计的必要条件。但是，只满足相合性也是不够的。</p>
<p>其实，若把依赖于样本量n的估计量$\hat\theta_n$ 看做是一个<strong>随机变量序列</strong>，相合性就是$\hat\theta_n$ 依概率收敛到$\theta$ 。基于很多大数定律，其实相合性是很好论证的，只要我们将$\hat\theta_n$写成独立同分布的随机变量求和的形式即可。利用辛钦大数定律，证明其方差存在即可。</p>
<h4 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h4><p>设$\hat\theta_n = \hat\theta_n(x_1,x_2\cdots,x_n)$ 是$\theta$ 的一个估计量，若：</p>
<script type="math/tex; mode=display">
\lim\limits_{n\rightarrow\infty} E(\hat\theta_n) = \theta,~ \lim\limits_{n\rightarrow\infty} Var(\hat\theta_n) = 0</script><p>则 $\hat\theta_n$ 是 $\theta$ 的相合估计</p>
<p>当n充分大的时候， 估计值的期望是和真实的值是逼近的，其方差收敛到0。那么我一定能推出这是满足相合性的。换句话说，我只要求其一阶矩和二阶矩即可。</p>
<h5 id="例1-1"><a href="#例1-1" class="headerlink" title="例1"></a>例1</h5><p>设$x<em>1,x_2\cdots,x_n$ 是来自均匀总体 $U(0,\theta)$  的样本，证明 $x</em>{(n)}$ 是 $\theta$ 的相合估计。</p>
<p>我们可以由次序统计量的分布，我们知道 $\hat\theta = x_{(n)}$ 的分布密度函数为：</p>
<script type="math/tex; mode=display">
p(y) =ny^{n-1}/\theta^n, y<\theta</script><p>故有：</p>
<script type="math/tex; mode=display">
E(\hat\theta) = \int_{0}^\theta ny^ndy/\theta^n = \frac{n}{n+1} \theta\rightarrow \theta(n\rightarrow\infty)\\~\\
E(\hat\theta^2) = \int_{0}^\theta n y^{n+1}dy/\theta^n = \frac{n}{n+2} \theta^2\\~\\
Var(\hat\theta) = \frac{n}{n+2}\theta^2-(\frac{n}{n+1}\theta)^2 = \frac{n}{(n+1)^2(n+2)}\theta^2\rightarrow 0(n\rightarrow \infty)</script><p>因此，由上面说的定理1可得，$x_{(n)}$ 是$\theta$ 的相合估计。</p>
<h4 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h4><p>若$\hat\theta<em>{n1},\hat\theta</em>{n2}\cdots,\hat\theta<em>{nk}$ 分别是$\theta_1,\cdots,\theta_k$ 的相合估计，$\eta = g(\theta_1,\theta_2\cdots,\theta_k)$ 是 $\theta_1,\theta_2\cdots,\theta_k$ 的连续函数，则$\hat\eta_n = g(\hat\theta</em>{n1},\hat\theta<em>{n2},\cdots,\hat\theta</em>{nk}) $ 是$\eta$ 的相合估计。</p>
<p>用语言来描述这个定理就是，如果$\eta$能表示成一些参数的连续函数，那么就可以通过函数变换来求出$\eta$的相合估计。说明相合估计对于连续函数具有传递性</p>
<h5 id="例2-1"><a href="#例2-1" class="headerlink" title="例2"></a>例2</h5><p>刚才说的都是连续的例子，现在我们来说说离散的例子：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>a1</th>
<th>a2</th>
<th>a3</th>
</tr>
</thead>
<tbody>
<tr>
<td>P</td>
<td>$\theta^2$</td>
<td>$2\theta(1-\theta)$</td>
<td>$(1-\theta)^2$</td>
</tr>
<tr>
<td>n</td>
<td>$n_1$</td>
<td>$n_2$</td>
<td>$n_3$</td>
</tr>
<tr>
<td>频率</td>
<td>$\frac{n_1}{n}$</td>
<td>$\frac{n_2}{n}$</td>
<td>$\frac{n_3}{n}$</td>
</tr>
</tbody>
</table>
</div>
<p>我们使用矩估计，可以用替换的思想。这里的未知参数是 $\theta$ </p>
<p>那么，我们可以从频率出发，可以近似地认为a1发生的频率就等于其$p$ 的值，也就是 $\hat \theta_1 = \sqrt{p_1} = \sqrt{\frac{n_1}{n}}$ </p>
<p>注意了，给定的估计一定是要有未知参数的。</p>
<p>同样的想法，我们可以写出不同的关于$\theta$ 的表达式</p>
<ul>
<li>$\eta= \theta = 1-\sqrt{p_3} ,\hat\eta_n = \hat\theta_2 = 1-\sqrt{n_3/n}$ </li>
<li><p>$\eta(\theta)=p_1+p_2/2,\hat\eta_n =\hat\theta_3 = (n_1+n_2/2)/n$</p>
<p>由定理2 可得，以上三者都是$\eta$的相合估计</p>
</li>
</ul>
<h4 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h4><p>设$x_1,x_2\cdots,x_n$ 是来自正态总体$N(\mu,\sigma^2)$ 的样本序列，则由辛钦大数定律及依概率收敛的性质可得：</p>
<ul>
<li>$\overline x$ 是$\mu$ 的相合估计</li>
<li>$s_n^2$ 是$\sigma^2$ 的相合估计</li>
<li>$s^2$ 也是$\sigma^2$的相合估计</li>
</ul>
<p><strong>由此也可以看到参数的相合估计不止一个</strong></p>
<p>另外，有大数定理可以看到，矩估计一般都具有相合性，比如：</p>
<ul>
<li>样本均值是总体均值的相合估计</li>
<li>样本标准差是总体标准差的相合估计</li>
<li>样本变异系数 $s/\overline x$ 是总体变异系数的相合估计</li>
</ul>
<h2 id="最大似然估计与EM算法"><a href="#最大似然估计与EM算法" class="headerlink" title="最大似然估计与EM算法"></a>最大似然估计与EM算法</h2><p>刚才我们讲了点估计中的矩估计(替换)以及拟合，现在我们来讲讲第三种——似然</p>
<p>最大似然法（Maximum Likelihood，ML）也称为最大概似估计，也叫极大似然估计，是一种具有理论性的点估计法，此方法的基本思想是：当从模型总体随机抽取n组样本观测值后，最合理的参数估计量应该使得从模型中抽取该n组样本观测值的概率最大，而不是像最小二乘估计法旨在得到使得模型能最好地拟合样本数据的参数估计量</p>
<p>个随机试验如有若干个可能的结果A，B，C，… ，若在一次试验中，结果A出现了，那么可以认为实验条件对A的出现有利，也即出现的概率P(A)较大。极大似然原理的直观想法我们用下面例子说明。设甲箱中有99个白球，1个黑球；乙箱中有1个白球．99个黑球。现随机取出一箱，再从抽取的一箱中随机取出一球，结果是黑球，这一黑球从乙箱抽取的概率比从甲箱抽取的概率大得多，这时我们自然更多地相信这个黑球是取自乙箱的。一般说来，事件A发生的概率与某一未知参数$\theta$ 有关，$\theta$ 取值不同，则事件A发生的概率 $P(A|\theta)$ 也不同，当我们在一次试验中事件A发生了，则认为此时的$\theta$ 值应是 t 的一切可能取值中使$P(A|\theta)$达到<strong>最大的那一个</strong>， 极大似然估计法就是要选取这样的t值作为参数t的估计值，<strong>使所选取的样本在被选的总体中出现的可能性为最大</strong>。 </p>
<p>似然的核心想法就是<strong>以成败论英雄</strong>。</p>
<p>首先我们来讲一下什么事似然函数。</p>
<p>其实，似然函数就是这个分布的<strong>概率函数</strong> , 只不过是将其看做关于$\theta$的函数，也就是 $P_\theta(x_1,x_2,\cdots,x_n)$.那么对样本而言，就是联合分布列/密度</p>
<p>1.求极大似然函数估计值的一般步骤：</p>
<p>（1） 写出似然函数；</p>
<p>（2） 对似然函数取对数，并整理；</p>
<p>（3） 求导数</p>
<p>（4） 解似然方程 。</p>
<p>2.利用高等数学中求多元函数的极值的方法，有以下极大似然估计法的具体做法：</p>
<p>(1)根据总体的分布，建立似然函数  </p>
<script type="math/tex; mode=display">
L(x_1,x_2,\cdots,x_n;\theta_1,\theta_2\cdots,\theta_k)</script><p>(2) 当 L 关于 $\theta_1,\theta_2\cdots,\theta_k$ 可微时，(由微积分求极值的原理）可由方程组</p>
<script type="math/tex; mode=display">
\frac{\partial L}{\partial \theta_i} = 0,i=1,2\cdots,k</script><p>定出</p>
<script type="math/tex; mode=display">
\hat\theta_i(i=1,2\cdots,k)</script><p>称以上方程组为似然方程. </p>
<p><strong>因为 L 与 $\ln L$ 有相同的极大值点</strong>，所以 $\hat\theta_i(i=1,2,\cdots,k)$也可由方程组</p>
<script type="math/tex; mode=display">
\frac{\partial \ln L} {\partial\theta_i} = 0,i=1,2\cdots,k</script><p>定出 $\hat\theta_i(i=1,2\cdots,k)$ , 称以上方程组为<strong>对数似然方程</strong>；$\hat\theta_i(i=1,2\cdots,k)$ 就是所求参数 $ \theta_i(i=1,2\cdots,k)$ 的<strong>极大似然估计量</strong>。</p>
<p>当总体是离散型的， 将上面的概率密度函数 $f(x,\theta_1,\theta_2\cdots,\theta_k)$ ，换成它的分布律 $P(X=x;\theta_1,\theta_2\cdots,\theta_k)$</p>
<h5 id="例1-2"><a href="#例1-2" class="headerlink" title="例1"></a>例1</h5><p>$x\sim b(1,\theta)$,样本为 $x_1,x_2\cdots,x_n$,求其极大似然估计量</p>
<p><strong>第一步</strong>，我们写出其似然函数，这是一个离散的样本，因此：</p>
<script type="math/tex; mode=display">
L(\theta) = P_\theta(x_1,\cdots,x_n)=\prod_{i=1}^n P_e(x_i)=\prod_{i=1}^n \theta^{x_1}(1-\theta)^{1-x_i}\\~\\
=\theta^{\Sigma x_i}(1-\theta)^{n-\Sigma x_i}\\~\\</script><p><strong>第二步，</strong>求出其对数似然函数(计算会更方便)</p>
<script type="math/tex; mode=display">
\ln L(\theta) = \sum x_i \ln\theta +(n-\sum x_i)\ln(1-\theta)</script><p><strong>第三步，</strong>对其求导，因为要找到 $\hat\theta$ 的最大值,所以导数等于0是必要条件。但是导数等于0不一定代表$L(\theta)$能取最大值(也可能是最小值), 所以，我们可以求二阶导来验证一下，不过一般来说都是最大值</p>
<script type="math/tex; mode=display">
\frac{\partial\ln L(\theta)}{\partial\theta} = \frac{\sum x_i}{\theta}-\frac{n-\sum x_i}{1-\theta} = 0</script><p><strong>第四步，求解对数似然方程</strong></p>
<script type="math/tex; mode=display">
\hat\theta = \frac{1}{n}\sum_{i=1}^n x_i = \overline x</script><p>极大似然估计一般记为<strong>MLE</strong></p>
<h5 id="例2-2"><a href="#例2-2" class="headerlink" title="例2"></a>例2</h5><p>我们继续看这个例子，对于离散的分布。刚才我们仅仅根据一两个条件，就给出了关于$\theta$的矩估计，这让我们不禁感觉是不是没有用上全部的信息，因此我们可以用极大似然估计得到更精确的$\hat\theta$</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>a1</th>
<th>a2</th>
<th>a3</th>
</tr>
</thead>
<tbody>
<tr>
<td>P</td>
<td>$\theta^2$</td>
<td>$2\theta(1-\theta)$</td>
<td>$(1-\theta)^2$</td>
</tr>
<tr>
<td>n</td>
<td>$n_1$</td>
<td>$n_2$</td>
<td>$n_3$</td>
</tr>
<tr>
<td>频率</td>
<td>$\frac{n_1}{n}$</td>
<td>$\frac{n_2}{n}$</td>
<td>$\frac{n_3}{n}$</td>
</tr>
</tbody>
</table>
</div>
<p>我们也是一样的做法。首先给出其似然函数$L(\theta)$</p>
<script type="math/tex; mode=display">
L(\theta) = (\theta^2)^{n_1}[2\theta(1-\theta)]^{n_2}[(1-\theta)^2]^{n_3} = 2^{n_2}\theta^{2n_1+n_2}(1-\theta)^{2n_3+n_2}</script><p>然后，对其求对数似然函数：</p>
<script type="math/tex; mode=display">
\ln L(\theta) = (2n_1+n_2)\ln\theta +(2n_3+n_2)\ln(1-\theta)+n_2\ln2</script><p>然后对$\theta$求导，令导数为0：</p>
<script type="math/tex; mode=display">
\frac{2n_1+n_2}{\theta}-\frac{2n_3+n_2}{1-\theta} = 0</script><p>解之，得到：</p>
<script type="math/tex; mode=display">
\hat\theta = \frac{2n_1+n_2}{2(n_1+n_2+n_3)}=\frac{2n_1+n_2}{2n}</script><p>最后我们要验证一下</p>
<script type="math/tex; mode=display">
\frac{\partial^2\ln L(\theta)}{\partial\theta^2} = -\frac{n_1+n_2}{\theta^2}-\frac{2n_3+n_2}{(1-\theta)^2}<0</script><p>所以说$\hat\theta$ 是极大值点。</p>
<h5 id="例3-1"><a href="#例3-1" class="headerlink" title="例3"></a>例3</h5><p>虽然说求导函数是求最大似然估计最常用的方法，但并不是在所有场合都是有效的，比如说下面这个例子：</p>
<p>设$x_1,x_2\cdots,x_n$是来自均匀总体$U(0,\theta)$ 的样本，试求$\theta$的最大似然估计</p>
<p><strong>第一步</strong>，求出似然函数,这里x的取值和$\theta$有关，因此我们需要乘以示性函数。</p>
<script type="math/tex; mode=display">
L(\theta) = \frac{1}{\theta^n}\prod_{i=1}^nI_{\{0<x_i\leq\theta\}} = \frac{1}{\theta^n}I_{\{x(n)\leq \theta\}}</script><p><strong>第二步</strong>，我们开始分析。要使 $L(\theta)$ 达到最大，首先示性函数肯定要取1，再让$1/\theta^n$ 尽可能大。由于 $\frac{1}{\theta^n}$是单调减函数，所以$\theta$的取值要尽可能小。但是$\theta$ 又不可能小于样本的最大值$x<em>{(n)}$ 。因此，直接可以得出最大似然估计为 $\hat\theta = x</em>{(n)}$</p>
<h5 id="例4"><a href="#例4" class="headerlink" title="例4"></a>例4</h5><p>但是注意了，最大似然也可能是一在一个范围中的，比如说：</p>
<p>求 $p(x;\theta) = 1,\theta-\frac{1}{2}&lt;x&lt;\theta+\frac12$ 这个分布的最大似然估计：</p>
<p><strong>第一步：</strong> 写出似然函数： </p>
<script type="math/tex; mode=display">
L(\theta) = 1\cdot I_{\{\theta-\frac{1}{2}<x_{(1)}<x_{(n)}<\theta_2+\frac12\}}</script><p><strong>第二步</strong>：求出$\theta$的值或者范围。 要让 $L(\theta)$ 尽量大，首先示性函数应该为1。 这样解出来的$\theta$ 才能保证整个似然函数为1。 $x<em>{(n)}-\frac12&lt;\theta&lt;x</em>{(1)}+\frac12$</p>
<h5 id="例5"><a href="#例5" class="headerlink" title="例5"></a>例5</h5><p>设$x_1,x_2,\cdots,x_n$ 是来自密度函数为 $p(x;\theta) = e^{-(x-\theta)},x&gt;\theta$ 的总体的样本。求$\theta$ 的最大似然估计 $\hat\theta_1$ 是否是相合估计，是否是无偏估计？</p>
<p><strong>第一步：写出似然函数</strong>： </p>
<script type="math/tex; mode=display">
L(\theta) = e^{-\sum x_i+n\theta }I_{\{x_{(1)}>\theta\}}\\~\\</script><p> 要让示性函数取1，必须让 $\theta&lt;x<em>{(1)}$ . 所以$\theta$ 最大似然估计为 $\hat\theta_1 = x</em>{(1)}$ </p>
<p>然后我们就要判断其是否是无偏估计。 </p>
<p>判断是否为无偏估计(需满足 $E(\hat\theta) = \theta$ )</p>
<p><strong>第二步：写出x(1)的密度函数：</strong></p>
<script type="math/tex; mode=display">
F(x_1) = 1-[1-F(x)]^n = 1-[1-(1-e^{-x+\theta})]^n\\~\\
p(x_1) = ne^{-n(x-\theta)} \\~\\
E(X) = \int_\theta^\infty xne^{-n(x-\theta)}dx = \int_{\theta}^\infty (t+\theta) ne^{-nt} dt = \frac{1}{n}+\theta\neq \theta</script><p>因此，$x_{(1)}$不是 $\theta$ 的无偏估计</p>
<p>那么$x_{(1)}$是不是$\theta$ 的相合估计呢？ 首先，当$n\rightarrow \infty$ 时，$E(\hat\theta) = \theta$ </p>
<p>现在就要验证，当$n\rightarrow \infty$ 时，是否 $Var(\hat\theta) = 0$</p>
<script type="math/tex; mode=display">
\lim\limits_{n\rightarrow\infty} Var(\hat\theta_1) = E(\hat\theta_1^2)-E^2(\theta)\\~\\ = E(\hat\theta_1^2) - (\frac{1}{n}+\theta)^2</script><p>因此我们现在要计算 $E(\hat\theta_1^2)$</p>
<script type="math/tex; mode=display">
E(\hat\theta_1^2)  = \int_0^\infty x^2ne^{-n(x-\theta)}dn\\~\\
令 x-\theta = t\\~\\
=\int_0^{\infty} (t+\theta)^2ne^{-nt}dt\\~\\
=n\int_0^{\infty} t^2e^{-nt}dt+2n\theta\int_0^\infty te^{-nt} dt+\theta^2n\int_0^\infty e^{-nt} dt\\~\\
=\theta^2+2\theta/n+\frac2{n^2}</script><p>因此</p>
<script type="math/tex; mode=display">
Var(\hat\theta_1) = \theta^2+\frac{2\theta}{n} +\frac{2}{n^2}-(\frac{1}{n}+\theta)^2  = \frac{1}{n^2}\\~\\</script><p>显然，当 $n\rightarrow\infty$ 时，$Var(\frac{1}{n^2})\rightarrow 0$. 因此，$\hat\theta_1$ 是 $\theta$ 的相合估计</p>
<p>最大似然估计有一个简单而有用的性质：若果$\hat\theta$是$\theta$的最大似然估计，则对任一函数$g(\theta)$，$g(\hat\theta)$ 是其最大似然估计。该性质称为最大似然估计的<strong>不变性</strong>. 从而使得一些复杂结构的参数的最大似然估计的获得变得更容易了。</p>
<h3 id="渐近正态性"><a href="#渐近正态性" class="headerlink" title="渐近正态性"></a>渐近正态性</h3><p>最大似然估计还有一个良好的性质：<strong>它通常具有渐近正态性</strong> 。现在给出其定义：</p>
<p>参数$\theta$ 的相合估计$\hat\theta_n$ 称为渐近正态的，若存在趋于0的非负常数序列 $\sigma_n(\theta)$ ，使得 $\frac{\hat\theta_n-\theta}{\sigma_n(\theta)}$ 依分布收敛于标准正态分布。这是也称 $\hat\theta_n$服从<strong>渐近正态分布</strong>$N(\theta,\sigma_n^2(\theta))$ ,记为$\hat\theta_n\sim AN(\theta,\sigma_n^2(\theta))$ ，$\sigma^2_n(\theta)$ 称为$\hat\theta_n$的渐近方差。</p>
<h5 id="例1-3"><a href="#例1-3" class="headerlink" title="例1"></a>例1</h5><p>设总体为泊松分布$P(\lambda)$，无论是矩估计还是最大似然估计，我们都得到一样的$\lambda$估计：样本均值，即：</p>
<script type="math/tex; mode=display">
\hat\lambda_n = \overline x_n= \frac{1}{n}\sum_{i=1}^n x_i</script><p>由中心极限定理，$(\hat\lambda_n-\lambda)/\sqrt{\lambda/n}$ 依分布收敛 $N(0,1)$，因此, $\hat\lambda_n$是渐近正态的，且：</p>
<script type="math/tex; mode=display">
\hat\lambda_n \sim AN(\lambda,\lambda/n)</script><p>这里的常数序列 $\sigma_n(\lambda) = \sqrt{\lambda/n}\rightarrow 0$ 它表示$\hat\lambda_n$依概率收敛于$\lambda$的速度为 $ 1/\sqrt{n} $</p>
<h2 id="点估计的评价方法"><a href="#点估计的评价方法" class="headerlink" title="点估计的评价方法"></a>点估计的评价方法</h2><p>上面三部分我们讲了几种不同的点估计方法，那么我们怎么来判断一个点估计的好坏呢？前面我们说到了无偏性、相合性。 其实，为了在不同的点估计间进行比较选择，我们就必须对各种点估计的好坏给出评价标准。 统计学中给出了众多的估计量评价标准，对同一估计量使用不同的评价标准可能会得到完全不同的结论。</p>
<h3 id="均方误差"><a href="#均方误差" class="headerlink" title="均方误差"></a>均方误差</h3><p>相合性和渐近正态性是在大样本场合下评价估计好坏的两个重要标准。无偏估计常使用方差的大小来判断该估计的好坏，而有偏估计常使用均方误差来判断。 </p>
<p>一般而言，在样本量一定时，评价一个点估计的好坏使用的度量指标总是点估计值$\hat\theta$与参数真值$\theta$ 的距离的函数，最常用的函数式距离的平方。但是由于$\hat\theta$具有随机性，可以对该函数求期望。这就是下面给出的<strong>均方误差</strong></p>
<script type="math/tex; mode=display">
MSE (\hat\theta) = E(\hat\theta-\theta)^2</script><p>均方误差是评价点估计的最一般的标准。自然，我们希望估计的均方误差越小越好。注意到：</p>
<script type="math/tex; mode=display">
MSE(\hat\theta) = E[(\hat\theta-E(\hat\theta))+(E(\hat\theta)-\theta)]^2\\~\\
=E(\hat\theta-E(\hat\theta))^2+(E(\hat\theta)-\theta)^2+2E[(\hat\theta-E(\hat\theta))(E(\hat\theta)-\theta)]</script><p>由于</p>
<p>所以，</p>
<script type="math/tex; mode=display">
MSE(\hat\theta) = Var(\hat\theta)+(E(\hat\theta)-\theta)^2</script><p>我们看到，均方误差由点估计的方差与与偏差$|E(\hat\theta-\theta)|$的平法两部分组成。 如果$\hat\theta$是$\theta$的无偏估计，则$MSE(\hat\theta)=Var(\hat\theta)$，此时用均方误差评价点估计与用方差是完全一样的。这也说明用方差来考察无偏估计的有效性是合理的。</p>
<p>注意了，当$\hat\theta$ 不是$\theta$的无偏估计时，就要看其均方误差 $MSE(\hat\theta)$, 不仅要看其方差大小，还要其偏差大小。在有些情况下，有偏估计其实是优于无偏估计的。</p>
<h3 id="一致最小均方误差估计"><a href="#一致最小均方误差估计" class="headerlink" title="一致最小均方误差估计"></a>一致最小均方误差估计</h3><p>设有样本 $x_1,x_2\cdots,x_n$ ，对待参数 $\theta$ ,有一个估计类，称 $\hat\theta(x_1,x_2,\cdots,x_n)$ 是该估计类中$\theta$ 的一致最小均方误差估计，如果对于该估计类中另外任意一个$\theta$ 的估计 $\tilde \theta$ , 在参数空间$\Theta$上都有：</p>
<script type="math/tex; mode=display">
MSE_\theta(\hat\theta)\leq MSE_\theta(\tilde \theta)</script><p>但是，若考虑所有可能的估计，则一致最小均方误差估计是不存在的，从而使没有意义的。因此，人们通常的就对估计提一些合理性要求，前面说的无偏性就是一个常见的合理性要求。</p>
<h3 id="一致最小方差无偏估计"><a href="#一致最小方差无偏估计" class="headerlink" title="一致最小方差无偏估计"></a>一致最小方差无偏估计</h3><p>当我们要求$\hat\theta$ 是$\theta$ 的无偏估计时，均方误差就简化为估计的方差，此时一致最小均方误差估计就是一致最小方差无偏估计。 其定义如下：</p>
<p>对于参数估计问题，设$\hat\theta$ 是$\theta$ 的一个无偏估计. 如果对另外任意一个$\theta$ 的无偏估计$\tilde \theta$ ，在参数空间 $\Theta$上都有：</p>
<script type="math/tex; mode=display">
Var_\theta(\hat\theta)\leq Var_\theta(\tilde\theta)</script><p>则称$\hat\theta$ 是$\theta$的一致最小方差无偏估计，简记为 UMVUE</p>
<h4 id="定理1-1"><a href="#定理1-1" class="headerlink" title="定理1"></a>定理1</h4><p>设 $X=(x_1,x_2\cdots,x_n)$ 是来自某总体的一个样本，$\hat\theta=\hat\theta(X)$ 是$\theta$的一个无偏估计，$Var(\hat\theta)&lt;\infty$ , 则 $\hat\theta$是$\theta$的UMVUE的充要条件是：</p>
<p>对任意一个满足 $E(\varphi(X))=0$ 和 $Var(\varphi(X))&lt; \infty$ 都有：</p>
<script type="math/tex; mode=display">
Cov_\theta(\hat\theta,\varphi)=0,~~\forall \theta \in \Theta</script><p>这个定理表明，$\theta$ 的UMVUE 必与任一<strong>零的无偏估计</strong>不相关，反之亦然。</p>
<h5 id="例1-4"><a href="#例1-4" class="headerlink" title="例1"></a>例1</h5><p>设 $x_1,x_2\cdots,x_n$ 是来自于下列总体的简单样本</p>
<script type="math/tex; mode=display">
p(x) = \begin{cases}1,\theta-\dfrac{1}{2}\leq x\leq \theta +\dfrac{1}{2}\\ 0,其他\end{cases}  -\infty \leq x\leq \infty</script><p>证明样本均值 $\overline x$ 即 $\frac{1}{2}(x<em>{(1)}+x</em>{(n)})$ 都是$\theta$的无偏估计，问哪一个更为有效？</p>
<p>想要问哪一个无偏估计更加有效，就要看看哪一个 $Var(\hat\theta)$更小</p>
<p><strong>第一步：求$E(\hat\theta_1),Var(\hat\theta_1)$</strong>   </p>
<script type="math/tex; mode=display">
E(\hat\theta_1) = E(X) =\overline x\\~\\
Var(\hat\theta_1)= \frac{1}{n} Var(X) =\frac{1}{12n}</script><p><strong>第二步：求$E(\hat\theta_2),Var(\hat\theta_2)$</strong></p>
<h3 id="充分性原则"><a href="#充分性原则" class="headerlink" title="充分性原则"></a>充分性原则</h3><h4 id="定理2-1"><a href="#定理2-1" class="headerlink" title="定理2"></a>定理2</h4><p>设总体概率函数为$p(x;\theta),x_1,x_2\cdots,x_n$ 是其样本，$T=T(x_1,x_2,\cdots,x_n)$ 是$\theta$的充分统计量，则对$\theta$ 的任一无偏估计$\hat\theta = \hat\theta(x_1,x_2\cdots,x_n)$ ，令 $\tilde\theta = E(\hat\theta|T)$ 与$\theta$ 无关，则$\tilde\theta$ 也是$\theta$的无偏估计</p>
<p>这说明，如果无偏估计不是充分统计量的函数，则将其对充分统计量求条件期望可以得到一个新的无偏估计，该估计的方差比原来的估计的方差要小，从而降低了无偏估计的方差。 换言之，考虑$\theta$的估计问题，只需要在基于充分统计量的函数中进行即可，该说法对所有的统计推断问题都是成立的，这就是充分性原则。</p>
<h5 id="例1-5"><a href="#例1-5" class="headerlink" title="例1"></a>例1</h5><p>设 $x_1,x_2\cdots,x_n$ 是来自$b(1,p)$的样本，则 $\overline x $ 是 p 的充分统计量，为估计 $\theta = p^2$ ，我们可以先令一个”不太准”的$\theta$ 估计</p>
<script type="math/tex; mode=display">
\theta =\begin{cases}1,~~~x_1=1,x_2=1\\ 0, ~~其他\end{cases}</script><p>现在我们来看看在这是不是无偏估计：</p>
<script type="math/tex; mode=display">
E(\hat\theta_1) =P(x_1=1,x_2=1 )= p\cdot p =\theta</script><p>所以，$\hat\theta<em>1$ 是 $\theta$ 的 无偏估计。 但是这个估计并不好，因为只用了两个观测值。 我们可以用上面说的定理来优化改进： 求 $\hat\theta_1$ 关于充分统计量 $T=\sum</em>{i=1}^nx_i$ 的条件期望，过程如下：</p>
<script type="math/tex; mode=display">
\hat\theta = E(\hat\theta_1 |T=t) = P(\hat\theta_1=1 | T=t) = \frac{P(x_1=1,x_2=1,T=t)}{P(T=t)}\\~\\
=\frac{P(x_1=1,x_2=1,\sum_{t=3}^{n}x_i=t-2)}{P(T=t)} = \frac{p\cdot p~C_{n-2}^{t-2}p^{t-2}{(1-p)^{n-t}}}{C_n^t p^t(1-p)^{n-t}}\\~\\
=\frac{C_{n-2}^{t-2}}{C_n^t} = \frac{t(t-1)}{n(n-1)}</script><p>其中 $t = \sum_{i=1}^n x_i$ 可以验证，$\hat\theta$ 是 $\theta$ 的无偏估计，且$Var(\hat\theta)&lt;Var(\hat\theta_1)$ </p>
<h3 id="费希尔信息量"><a href="#费希尔信息量" class="headerlink" title="费希尔信息量"></a>费希尔信息量</h3><p>最大似然估计的渐近主要由费希尔信息量 $I(\theta)$  决定，现在先介绍$I(\theta)$ ，然后讲述克拉默-拉奥不对呢公式，又是它可以用来判断UMVUE</p>
<p>设总体的概率函数$p(x;\theta),\theta\in\Theta$  满足下列条件</p>
<ol>
<li>参数空间 $\Theta$ 是直线上的一个开区间；</li>
<li>支撑 $S={x;p(x;\theta)&gt;0}$ 与 $\theta$ </li>
<li>导数 $\frac{\partial }{\partial\theta}p(x;\theta)$  对一切 $\theta\in \Theta$ 存在</li>
<li>对$p(x;\theta)$ ，积分与微分运算可交换次序，即：</li>
</ol>
<script type="math/tex; mode=display">
\frac{\partial}{\partial\theta}\int_{-\infty}^{\infty} p(x;\theta )dx = \int_{-\infty}^{\infty} \frac{\partial}{\partial \theta} p(x;\theta)dx</script><ol>
<li>期望 $E[\frac{\partial}{\partial\theta}\ln p(x;\theta)]^2$  存在</li>
</ol>
<p>那么总体分布的<strong>费希尔信息量</strong>是：</p>
<script type="math/tex; mode=display">
I(\theta) = E[\frac{\partial}{\partial\theta}\ln p(x;\theta)]^2 = -E(\frac{\partial^2\ln p(x;\theta)}{\partial\theta})</script><h5 id="例1-6"><a href="#例1-6" class="headerlink" title="例1"></a>例1</h5><p>设总体分布为泊松分布 $P(\lambda)$ ，其分布列：</p>
<script type="math/tex; mode=display">
p(x;\lambda) = \frac{\lambda^x}{x!}e^{-\lambda}</script><p>那么</p>
<script type="math/tex; mode=display">
\ln p(x;\lambda) = x\ln\lambda -\lambda -\ln(x!)\\~\\
\frac{\partial }{\partial\lambda} \ln p(x;\lambda) = x/\lambda -1\\~\\</script><p>于是： </p>
<script type="math/tex; mode=display">
I(\lambda) =E(\frac{x-\lambda}{\lambda})^2 =Var(x)/\lambda^2 = \frac{1}{\lambda}</script><h3 id="CR-克拉默-拉奥-不等式"><a href="#CR-克拉默-拉奥-不等式" class="headerlink" title="CR(克拉默-拉奥) 不等式"></a>CR(克拉默-拉奥) 不等式</h3><p>设总体分布$p(x;\theta)$ 满足定义上述费希尔通信量的条件，$x_1\cdots,x_n$ 是来自该总体的样本，$T=T(x_1\cdots,x_n)$ 是$g(\theta)$ 的任一个无偏估计，$g’(\theta) = \frac{\partial g(\theta)}{\partial \theta}$ 存在，且对$\Theta$ 中一切 $\theta$ ，对</p>
<script type="math/tex; mode=display">
g(\theta) = \int_{-\infty}^{\infty}\cdots\int_{-\infty}^{\infty} T(x_1,\cdots,x_n) \prod_{i=1}^np(x_i;\theta)dx_1\cdots d_{x_n}</script><p>的微商可在积分号下进行，即：</p>
<script type="math/tex; mode=display">
g'(\theta) =\int_{-\infty}^{\infty}\cdots\int_{-\infty}^{\infty} [\frac{\partial}{\partial\theta}\ln\prod_{i=1}^np(x_i;\theta)]\prod_{i=1}^np(x_i;\theta)dx_1\cdots d_{x_n}</script><p>对离散总体，也是一样。 则有：</p>
<script type="math/tex; mode=display">
Var(T)\geq [g'(\theta)]^2/nI(\theta)</script><p>将上式称为是克拉默-拉奥不等式，$[g’(\theta)]^2/(n\ln(\theta))$ 称为$g(\theta)$的无偏估计的方差的$C-R$<strong>下界</strong>。 </p>
<p>特别的，对$\theta$ 的无偏估计$\hat\theta$,有 $Var(\hat\theta)\geq(nI(\theta))^{-1}$ </p>
<p>如果 $Var(T)=[g’(\theta)]^2/nI(\theta)$ 成立，我们称$T=T(x_1,x_2\cdots,x_n)$是 $g(\theta)$的有效估计。</p>
<h2 id="贝叶斯估计"><a href="#贝叶斯估计" class="headerlink" title="贝叶斯估计"></a>贝叶斯估计</h2><p>之前说的经典学派的估计认为，参数是一个值。而贝叶斯学派认为，参数是一个随机变量。</p>
<p>经典学派通过样本采样的方式，来估计参数。但是万一样本较少怎么办？万一只有一次实验，似乎就直接决定了这个参数是什么，这恐怕不太靠谱。</p>
<p>但是理论和现实不太一样，在工业生产中，我们对一个参数可能有预先的判断。 如果综合前面的预判，加上为数不多的样本，就可以让参数的估计变得更加靠谱一些</p>
<p>用学术性的话语来说，经典学派对统计推断使用到了两种信息：总体信息和样本信息。但是，贝叶斯学派认为，除了上述两种信息之外，统计推断还应该使用第三种信息：先验信息。</p>
<p>现在来介绍他一下先验信息：如果我们把抽取样本看做是一次试验，则样本信息就是试验中得到的信息。实际中，人们在试验之前对要做的问题在经验上和资料上总是有所了解的，这些信息对统计推断是有益的。先验信息即抽样(试验)之前有关统计问题的一些信息。</p>
<p>贝叶斯估计总体可以概括为4句话：</p>
<ol>
<li>待估参数$\theta$ 是一个随机变量</li>
<li>在得到样本前，对$\theta$ 有一个认识。我们可以用一个分布来刻画这种认识，称为先验分布，通常被认为是 $\pi(\theta)$ </li>
<li>样本是用来调整对这个参数$\theta$ 的认识的。调整的方式是 Bayes 公式。调整后称其为<strong>后验公式</strong></li>
<li>Bayes推断都是基于后验分布的。</li>
</ol>
<h3 id="贝叶斯公式的密度函数形式"><a href="#贝叶斯公式的密度函数形式" class="headerlink" title="贝叶斯公式的密度函数形式"></a>贝叶斯公式的密度函数形式</h3><ol>
<li><p>在贝叶斯统计中，$p(x;\theta)$ 应写为 $p(x|\theta)$ .它表示在随机变量$\theta$ 取某个给定值时总体的条件概率函数</p>
</li>
<li><p>根据参数$\theta$ 的先验信息确定先验分布$\pi(\theta)$</p>
</li>
<li><p>从贝叶斯的观点来看，样本$X=(x_1,x_2,\cdots,x_n)$ 的产生要分两步产生。首先<strong>设想</strong>从分布$\pi(\theta)$ 产生一个个体$\theta_0$ 这一步是”上帝”做的，我们是看不到的。第二步，从$p(X|\theta_0)$ 中产生一组样本。这时样本$X = （x_1,x_2\cdots,x_n)$ 的联合条件概率函数为：</p>
<script type="math/tex; mode=display">
p(X|\theta_0) = p(x_1,x_2\cdots,x_n|\theta_0) = \prod_{i=1}^np(x_i|\theta_0)</script><p>这个分布综合了总体信息和样本信息</p>
</li>
<li><p>由于$\theta_0$是设想出来的，仍然是未知的，它是按照先验分布$\pi(\theta)$产生的。 为了把先验信息综合进去，不能只考虑$\theta_0$。因此，对$\theta$的其他可能发生的可能性也需要加以考虑，故要用$\pi(\theta)$ 进行综合，这样一来，样本X和参数$\theta$的联合分布为：</p>
<script type="math/tex; mode=display">
h(X,\theta) = p(X|\theta)\pi(\theta)</script></li>
<li><p>我们的目的是要对未知参数$\theta$ 做一个统计推断。在没有样本信息时，我们只能依据先验分布对$\theta$作出判断。在有了样本观测值$X=(x_1,x_2\cdots,x_n)$ 之后，我们应该依据 $h(X,\theta)$ 对$\theta$ 作出推断。若把$h(X,\theta)$做如下分解：</p>
<script type="math/tex; mode=display">
h(X,\theta) = \pi(\theta|X)m(X)</script><p>其中$m(X)$是X的边际概率函数</p>
<script type="math/tex; mode=display">
m(X) = \int_{\Theta}h(X,\theta) d\theta = \int_{\Theta}p(X|\theta)\pi(\theta)d\theta</script><p>它与$\theta$无关，或者说$m(X)$ 不包含任何关于$\theta$ 的信息。因此能用来对$\theta$作出推断的仅是条件分布 $\pi(\theta|X)$ ，它的计算公式是：</p>
<script type="math/tex; mode=display">
\pi(\theta|X) = \frac{h(X,\theta)}{m(X)} = \frac{p(X|\theta)\pi(\theta)}{\int_{\Theta}p(X|\theta)\pi(\theta)d\theta}</script><p>这个条件就是$\theta$ 的后验分布了。它集中了总体、样本和先验中有关$\theta$的一切信息。他要比$\pi(\theta)$更接近$\theta$的实际情况。</p>
</li>
</ol>
<p>那么如何选先验分布？ 一般来说是收集历史资料，但是在题目中，我们可以采用<strong>同等无知</strong>的办法。</p>
<h5 id="例1-7"><a href="#例1-7" class="headerlink" title="例1"></a>例1</h5><p>对 $x|\theta\sim b(1,\theta),x_1,x_2\cdots,x_n$为样本，$\theta\in (0,1)$ 我们要去估计 $\theta$，那怎么选先验？</p>
<p>第一步：先验分布</p>
<p>在没有样本的情况下，这里我们暂且不适用同等无知的方法，因为我们知道贝塔分布的定义域是在 0-1之间的，因此我们这里可以将$\theta$的先验分布定位$Be(a,b)$, 即 $\pi(\theta) \sim Be(a,b) $</p>
<p>第二步：求后验分布</p>
<p>根据上面的步骤，我们可以写出 </p>
<script type="math/tex; mode=display">
h(X,\theta) = p(X|\theta)\pi(\theta) =  \frac{1}{Be(a,b)}\theta^{a-1+\sum x_i}(1-\theta)^{n+b-1-\sum x_i}\\~\\
m(X) = \int_{\Theta}h(X,\theta) d\theta = \int_{\Theta}p(X|\theta)\pi(\theta)d\theta =\int\frac{1}{Be(a,b)}\theta^{a-1+\sum x_i}(1-\theta)^{n+b-1-\sum x_i} d\theta\\~\\</script><p>最终解得：</p>
<script type="math/tex; mode=display">
\pi(\theta|X) \sim Be(a+\sum x_i,b+n-\sum x_i)</script><h3 id="贝叶斯估计-1"><a href="#贝叶斯估计-1" class="headerlink" title="贝叶斯估计"></a>贝叶斯估计</h3><p>我们得出估计之后，就要给出一个$\theta$的估计值，那么通常有三种方法：</p>
<ul>
<li>使用后验分布的密度函数最大值作为$\theta$ 的点估计的最大后验估计</li>
<li>使用后验分布的中位数作为$\theta$ 的点估计的后验中位数估计</li>
<li>使用后验分布的均值作为$\theta$的点估计的后验期望估计</li>
</ul>
<p>用得最多的是后验期望估计，它一般也简称为贝叶斯估计，记为$\hat\theta_B$</p>
<h5 id="例1-8"><a href="#例1-8" class="headerlink" title="例1"></a>例1</h5><p><img src="/2021/06/10/%E6%A6%82%E7%8E%87%E8%AE%BA%E7%AC%AC%E5%85%AD%E7%AB%A0/3.png" alt></p>
<h3 id="共轭先验分布"><a href="#共轭先验分布" class="headerlink" title="共轭先验分布"></a>共轭先验分布</h3><p>从上面贝叶斯公式可以看出，整个贝叶斯统计推断只要先验分布确定后就没有理论上的困难。关于先验分布的确定有多种途径，此处我们介绍一类最常用的先验分布类——共轭先验分布</p>
<p>设 $\theta$ 是总体分布$p(x;\theta)$ 中的参数，$\pi(\theta)$ 是先验分布，若对任意来自$p(x;\theta)$的样本观测值得到的后验分布$\pi(\theta|X)$ 与 $\pi(\theta)$ 属于同一个分布族，则称该分布族是$\theta$的共轭先验分布(族)</p>
<h2 id="区间估计"><a href="#区间估计" class="headerlink" title="区间估计"></a>区间估计</h2><p>上面我们都在说点估计，也就是找一个 $\hat\theta = \hat\theta(x_1,\cdots,x_n)$ 作为 $\theta$ 的估计。 但是现在我们来讲区间估计，也就是要找两个点，令其为 $\hat\theta_L,\hat\theta_U$ 使得 $\hat\theta_L&lt;\hat\theta_U$ 。 这样就能够构成一个区间来估计未知参数。因此，这个区间的<strong>精确度</strong>和<strong>准确度</strong>就变得十分重要。</p>
<p>什么是<strong>准确度</strong>？ 在点估计中，可以用MSE来衡量估计的准确度。但是在区间估计中，我们就想让区间能盖住$\theta$ 的概率尽可能大，但是又不能让区间长度太大。因此我们引入<strong>置信区间</strong>的概念。</p>
<p><strong>定义1：</strong></p>
<p>设 $\theta$ 是总体的一个参数，其参数空间为 $\Theta$， $x_1,x_2\cdots,x_n$ 是来自该总体的样本，对给定的一个$\alpha$, 若对于任意的 $\theta\in\Theta$， 有：</p>
<script type="math/tex; mode=display">
P_\theta(\hat\theta_L\leq \theta\leq \hat\theta_U)\geq 1-\alpha</script><p>则称 $[\hat\theta_L,\hat\theta_U]$ 为$\theta$的置信水平为 $1-\alpha$ 的置信区间。 $\hat\theta_L$ 和 $\hat\theta_U$ 分别是 $\theta$ 的置信下限和置信上限。我们用频率来解释置信水平。 平均而言，在大量的区间估计观测值中，至少有 $100(1-\alpha)\%$ 包含$\theta$。因此，我们希望置信水平越大越好，$\alpha$ 通常是一个较小的值</p>
<p>了解了置信区间，现在我们再来定义<strong>同等置信区间、(单侧)置信下限、(单侧)置信上界</strong></p>
<p><strong>定义2：</strong></p>
<p>如果说，上面置信区间的定义左右两边恰好取等于号时</p>
<script type="math/tex; mode=display">
P_\theta(\hat\theta_L\leq \theta\leq \hat\theta_U)= 1-\alpha</script><p>则称 $[\hat\theta_L,\hat\theta_U]$ 为$\theta$的置信水平为 $1-\alpha$ 的<strong>同等置信区间</strong>。</p>
<p><strong>定义3：</strong></p>
<p>如果我们构造的区间 形如 $[\hat\theta_L,\infty)$ 那么我们可以定义满足下式时： </p>
<script type="math/tex; mode=display">
P_\theta(\hat\theta_L\leq\theta)\geq 1-\alpha</script><p>称 $\hat\theta_L$ 为$\theta$ 的置信水平为 $1-\alpha$ 的(单侧)置信下限。类似的可以定义<strong>同等置信下限</strong></p>
<p><strong>定义4：</strong></p>
<p>如果我们构造的区间 形如 $(-\infty,\hat\theta_U]$ 那么我们可以定义满足下式时： </p>
<script type="math/tex; mode=display">
P_\theta(\hat\theta_U\geq\theta)\geq 1-\alpha</script><p>称 $\hat\theta_U$ 为$\theta$ 的置信水平为 $1-\alpha$ 的(单侧)置信上限。类似的可以定义<strong>同等置信上限</strong></p>
<p>那什么又是<strong>精确度</strong>呢？</p>
<p>通常可以用区间的长度来度量其精确度。我们希望这个区间的长度越短越好。</p>
<p>那么怎么去寻找一个合适的置信区间呢？是选择双侧的置信区间还是单侧的置信区间呢？我们要去看估计的参数的目标是什么。比如说我要估计在一个流水线上螺丝钉的大小，因为螺丝钉的大小一定是有标准的，这时候我们就要使用双侧估计，我们称其为<strong>望目</strong>，我们是基于目标值给出一个区间估计。 另外一种情况是<strong>望大</strong>或<strong>望小</strong>，比如说要去考虑某个行业的收入水平，理论上来说我给出的应该是一个单侧区间，因为不会给出一个收入的天花板，这时候我希望这个参数越大越好。</p>
<p>那么如何构造一个置信区间呢？接下来我们来学习 <strong>枢轴量法</strong></p>
<h3 id="枢轴量"><a href="#枢轴量" class="headerlink" title="枢轴量"></a>枢轴量</h3><p>枢轴量法的步骤可以概括为如下三步：</p>
<ol>
<li>设法构造一个样本和 $\theta$ 的函数 $G = G(x_1,x_2\cdots,x_n,\theta)$ 使得 G 不依赖于未知参数。一般称这种性质的G 为枢轴量. 还有就是枢轴量的<strong>分布已知</strong>。 但在这之前，我们得先找找待估参数的点估计。</li>
<li>适当地选择两个常数 c,d 使对给定的 $\alpha(0&lt;\alpha&lt;1)$ 有：</li>
</ol>
<script type="math/tex; mode=display">
P(c\leq G\leq d) = 1-\alpha</script><p>在离散场合，上式的等号需改为$\geq$</p>
<ol>
<li>加入能将 $c\leq G\leq d$ 进行不等式等价变形化为 $\hat\theta_L\leq \theta\leq \hat\theta_U$,则有：</li>
</ol>
<script type="math/tex; mode=display">
P_\theta(\hat\theta_L\leq \theta\leq \hat\theta_U)= 1-\alpha</script><p>这表明$[\hat\theta_L,\hat\theta_U] $ 是 $\theta$ 的 $1-\alpha$ 的同等置信空间。</p>
<p>能满足 $P(c\leq G\leq d) = 1-\alpha$ 的c 、d取值有很多，选择的目的是希望 $E_\theta(\hat\theta_U-\hat\theta_L)$ 尽可能短。其实，很难找到最佳的c、d,一般是让两个尾部的概率各位$\alpha/2$ 即：</p>
<script type="math/tex; mode=display">
P_\theta(G<c) = P_\theta(G>d) = \alpha/2</script><p>现在我们来讲几个例子：</p>
<h5 id="例1-9"><a href="#例1-9" class="headerlink" title="例1"></a>例1</h5><p>$x_1,x_2\cdots,x_n\sim N(\mu,\sigma_0^2)$ , $\sigma_0$ 已知，用枢轴量法来估计$\mu$ </p>
<p><strong>第一步</strong>求 $\mu$ 的点估计 ： $\hat\mu = \overline x$</p>
<p><strong>第二步</strong> 求 $\overline x$ 的分布 即 $\overline x\sim N(\mu,\frac{\sigma_0^2}{n})$ </p>
<p><strong>第三步</strong> 标准化 ， </p>
<script type="math/tex; mode=display">
G = \frac{\overline x-\mu}{\sqrt{\frac{\sigma_0^2}{n}}}\sim N(0,1)</script><p>现在， G 是一个枢轴量了，因为只和样本、待估参数 $\mu$ 有关，没有未知参数，且G的分布已知</p>
<p><strong>第四步</strong> 我们的目标是找到一个区间，把这个区间用足(区间准确率又要高，区间长度又要短)。</p>
<p>我们要找两个分位数点，使得被这两个点<strong>夹住</strong> 的部分的概率等于 $1-\alpha$ </p>
<p>假设我定义左边的点为 $u<em>{\alpha_1}$,右边的点为 $\mu</em>{\alpha_2}$,如下图所示：</p>
<p><img src="/2021/06/10/%E6%A6%82%E7%8E%87%E8%AE%BA%E7%AC%AC%E5%85%AD%E7%AB%A0/4.jpg" style="zoom: 67%;"></p>
<p>我们用 $\alpha_1$表示 $\alpha_2$，那么从面积来看，$\alpha_2$ 为左侧两块面积之和即 $\alpha_2 =1- (\alpha-\alpha_1)$</p>
<p> 我一定能找到这样的分位数点，使得：</p>
<script type="math/tex; mode=display">
P(u_{\alpha_1}\leq \frac{\overline x-\mu}{\sqrt{\frac{\sigma_0^2}{n}}}\leq u_{1-(\alpha-\alpha_1)}) = 1-\alpha</script><p><strong>第五步</strong> 反解 $\mu$</p>
<script type="math/tex; mode=display">
P(\overline x-u_{1-(\alpha-\alpha_1)}\cdot\sqrt{\frac{\sigma_0^2}{n}}\leq u\leq\overline x-u_{\alpha_1}\sqrt{\frac{\sigma_0^2}{n}}) = 1-\alpha</script><p>可以证明 当 $\alpha<em>1 = \alpha/2$ 时，区间长度最小。此时，$u</em>{\alpha<em>1} = -u</em>{1-\frac{\alpha}2}$</p>
<p><strong>第六步</strong> 得出区间估计</p>
<script type="math/tex; mode=display">
[\overline x-u_{1-\frac\alpha2}\cdot\sqrt{\frac{\sigma_0^2}{n}},\overline x+u_{1-\frac{\alpha}{2}}\sqrt{\frac{\sigma_0^2}{n}}]</script><h5 id="例2-3"><a href="#例2-3" class="headerlink" title="例2"></a>例2</h5><p>现在，我们对原题做一个小变形，就是说把 $\sigma_0$ 从已知改成未知。</p>
<p>即 $x_1,x_2\cdots,x_n\sim N(\mu,\sigma^2)$  要估计 参数 $\mu$ </p>
<p><strong>第一步</strong>求 $\mu$ 的点估计 ： $\hat\mu = \overline x$</p>
<p><strong>第二步</strong> 求 $\overline x$ 的分布 即 $\overline x\sim N(\mu,\frac{\sigma^2}{n})$ </p>
<p><strong>第三步</strong> 标准化 ， </p>
<script type="math/tex; mode=display">
\frac{\overline x-\mu}{\sqrt{\frac{\sigma^2}{n}}}\sim N(0,1)</script><p>我们发现这时候标准化后的式子不再是枢轴量了，因为里面包含了一个 未知的”讨厌参数“ $\sigma$ </p>
<p>该怎么办？</p>
<p><strong>第四步</strong> </p>
<p>既然$\sigma$未知，不妨用 $\sigma^2$ 的估计代替 $\sigma^2$，也就是 $\hat\sigma^2 = s^2$， 再带入原式得：</p>
<script type="math/tex; mode=display">
G= \frac{\overline x-\mu}{\sqrt{\frac{s^2}{n}}} = \frac{\frac{\overline x-\mu}{\sqrt{\sigma^2/n}}}{\sqrt{\frac{(n-1)s^2}{\sigma^2}/(n-1)}}</script><p>现在G 已经是一个枢轴量了，因为变形之后 $\sigma^2$ 会被约掉</p>
<p>上面是一个标准正态N(0,1)， 下面是一个卡方分布/(n-1) ，这说明  $G\sim t(n-1)$ </p>
<p><strong>第五步</strong> 变形</p>
<p>类似于上一个例子，可以得到此时 $\mu$ 的 $1-\alpha$ 置信区间为</p>
<script type="math/tex; mode=display">
\overline x \pm t_{1-\alpha/2}(n-1)\frac{s}{\sqrt n}</script><h5 id="例3-2"><a href="#例3-2" class="headerlink" title="例3"></a>例3</h5><p>$x_1,x_2\cdots,x_n\sim U(0,\theta)$ ,用枢轴量法来估计$\theta$  </p>
<p><strong>第一步</strong> 求 $\theta$ 的点估计 ： $\hat\theta =x_{n}$</p>
<p><strong>第二步</strong> 求  $x<em>{(n)}$ 的分布 即 $G = \frac{x</em>{(n)}}{\theta}\sim Be(n,1)$ </p>
<p><strong>第三步</strong> </p>
<script type="math/tex; mode=display">
P(c \leq \frac{x_{(n)}}{\theta}\leq d)=1-\alpha</script><p>$c,d$ 是贝塔分布的两个分位数点, </p>
<script type="math/tex; mode=display">
P(x\leq c) = \int_0^c n x^{n-1}dx = x^n|_0^c = c^n</script><p>因此 我们要选择适当的c和d使得：$d^n-c^n = 1-\alpha$</p>
<p><strong>第四步</strong> 变形得到：</p>
<script type="math/tex; mode=display">
\frac{x_{(n)}}{d}\leq \theta\leq \frac{x_{(n)}}{c}</script><p>该区间的平均长度为 $(\frac{1}{c}-\frac{1}{d})E(x_{(n)})$ ，在上述条件下，求导两次可以得到：当 $d=1,c=\sqrt[n]{\alpha}$ 时，$\frac{1}{c}-\frac{1}{d}$取最小值，这说明：</p>
<script type="math/tex; mode=display">
[x_{(n)},x_{(n)}/\sqrt[n]{\alpha}]</script><p>是 $\theta$ 的此类区间估计中置信水平为 $1-\alpha$ 的最短置信区间</p>
<h5 id="例4-1"><a href="#例4-1" class="headerlink" title="例4"></a>例4</h5><p>现在我们来估计 $\sigma^2$</p>
<p>也就是 $x_1,x_2\cdots,x_n\sim N(\mu,\sigma^2)$ </p>
<p><strong>第一步：</strong> 给出$\sigma^2$ 的点估计：  $\hat\sigma^2 = s^2$ </p>
<p><strong>第二步：</strong> 求出  $s^2$ 的分布： </p>
<script type="math/tex; mode=display">
G = \frac{(n-1)s^2}{\sigma^2}\sim\mathcal{X}(n-1)</script><p>这个量是枢轴量，因为分布已知且只和待估参数有关</p>
<p><strong>第三步：</strong></p>
<script type="math/tex; mode=display">
\mathcal{X}_{\alpha_1}^2(n-1) \leq \frac{(n-1)s^2}{\sigma^2}\leq \mathcal{X}^2_{1-(\alpha-\alpha_1)}(n-1)</script><p><strong>第四步</strong> 反解得到：</p>
<script type="math/tex; mode=display">
\frac{(n-1)s^2}{\mathcal{X}^2_{1-(\alpha-\alpha_1)}(n-1)} \leq \sigma^2\leq \frac{(n-1)s^2}{\mathcal{X}^2_{\alpha_1}(n-1)}</script><p>值得注意的是，这两个点并不是关于0对称的，因为卡方本身并不是一个对称分布。那么这两个点怎么找呢？找最优解是很麻烦的，实际上我们直接令 $\alpha_1 = \alpha/2$ 即可。实际中， $\alpha/2$和 最优解的相差也并不是很大。</p>
<p><img src="/2021/06/10/%E6%A6%82%E7%8E%87%E8%AE%BA%E7%AC%AC%E5%85%AD%E7%AB%A0/5.jpg" style="zoom: 67%;"></p>
<p><strong>例题5</strong></p>
<p>上面说的都是连续的估计，现在我们来说一下离散的估计。</p>
<p>$x_1,x_2\cdots,x_n\sim b(1,\theta)$ ，让我们估计事件A成功地概率 $\theta$</p>
<p><strong>第一步</strong>： 求出$\theta$的点估计。</p>
<script type="math/tex; mode=display">
\hat\theta = \overline x = \frac{1}{n}\sum_{i=1}^n x_i</script><p><strong>第二步</strong>：求 $\overline x$ 的分布 </p>
<script type="math/tex; mode=display">
\sum x_i = n\overline x \sim b(n,\theta)</script><p><strong>第三步</strong>：标准化，用中心极限定理</p>
<script type="math/tex; mode=display">
(CLT) G = \frac{\overline x-\theta}{\sqrt{\frac{\theta(1-\theta)}{n}}}\sim N(0,1)</script><p>这是一个枢轴量，因为分布已知且只与目标参数 $\theta$ 有关</p>
<p><strong>第四步</strong> 构造近似置信区间</p>
<p>因为这是一个对称的分布，所以我们可以这样写：</p>
<script type="math/tex; mode=display">
(\frac{\overline x-\theta}{\sqrt{\frac{\theta(1-\theta)}{n}}})^2\leq (u_{1-\alpha/2})^2</script><p>解得</p>
<script type="math/tex; mode=display">
(\overline x-\theta)^2 \leq(u_{1-\alpha/2})^2 \cdot (\frac{\theta(1-\theta)}{n})\\~\\
\theta\in[\overline x-u_{1-\frac{\alpha}2}\cdot \sqrt{\frac{\overline x(1-\overline x)}{n}},\overline x+u_{1-\frac{\alpha}2}\cdot \sqrt{\frac{\overline x(1-\overline x)}{n}}]</script><p>从上面这个式子来看，在对称的枢轴量分布时(通常是标准正态)，可以直接求解：</p>
<script type="math/tex; mode=display">
G^2\leq (u_{1-\frac{\alpha}2})^2</script><p>来求解未知参数</p>
<h5 id="例题6"><a href="#例题6" class="headerlink" title="例题6"></a>例题6</h5><p>现在我们来讲两个正态总体下的置信空间</p>
<p>设 $x_1,\cdots,x_n$​ 是来自 $N(\mu_1,\sigma_1^2)$​ 的样本 ，$y_1,\cdots,y_n$​ 是来自$N(\mu_2 ,\sigma_2^2)$​ 的样本，且两个样本相互独立 ,$\sigma_1^2,\sigma_2^2$​ 已知。$\overline x$​ 和 $\overline y$​ 是他们的样本均值，现在我们要计算 $\theta = \mu_1-\mu_2$​ 的置信区间 </p>
<p><strong>第一步</strong>:  </p>
<p>求出 $\theta$ 的点估计： $\hat\theta = \hat x-\hat y$ </p>
<p>因为 $\overline x\sim N(\mu_1,\frac{\sigma_1^2}{m}),\overline y \sim N(\mu_2,\frac{\sigma_2^2}{n})$ </p>
<p>因此 $\hat\theta \sim N(\mu_1-\mu_2.\frac{\sigma_1^2}{m}+\frac{\sigma_2^2}n)$  </p>
<p><strong>第二步</strong> 标准化</p>
<script type="math/tex; mode=display">
G = \frac{\overline x-\overline y-\theta}{\sqrt{\frac{\sigma_1^2}{m}+\frac{\sigma_2^2}{n}}}\sim N(0,1)</script><p><strong>第三步</strong></p>
<script type="math/tex; mode=display">
P(u_{\alpha/2}\leq G\leq u_{1-\alpha/2})=1-\alpha \\~\\
G^2\leq u^2_{1-\frac{\alpha}{2}}\\~\\
\theta\in \overline x-\overline y \pm u_{1-\frac{\alpha}2}\sqrt{\frac{\sigma_1^2}{m}+\frac{\sigma^2}{n}}</script><h5 id="例题7"><a href="#例题7" class="headerlink" title="例题7"></a>例题7</h5><p>刚才说的是, $\sigma_1^2,\sigma_2^2$ 已知的情况，现在来谈谈 ,$\sigma_1^2,\sigma_2^2$ 未知的情况</p>
<p><strong>第一步</strong>： 求 $\theta$ 的点估计 $\hat\theta=\overline x-\overline y = \mu_1-\mu_2$</p>
<p><strong>第二步：</strong>  $\overline x\sim N(\mu_1,\frac{\sigma^2}{m}),\overline y \sim N(\mu_2,\frac{\sigma^2}{n})$​ </p>
<script type="math/tex; mode=display">
\hat\theta = \overline x-\overline y \sim N(\mu_1-\mu_2,(\frac1m+\frac1n)\sigma^2)</script><p><strong>第三步</strong> 标准化</p>
<script type="math/tex; mode=display">
\frac{\overline x-\overline y-\theta}{\sqrt{(\frac1m+\frac1n)\sigma^2}}\sim N(0,1)</script><p>这并不是一个枢轴量，我们需要把 $\sigma^2$ 换成样本方差。</p>
<p> <strong>第四步：</strong></p>
<p>那么在两样本的时候，样本方差就要用合方差来替换：</p>
<script type="math/tex; mode=display">
\hat\sigma^2 = s_w^2 = \frac{(m-1)s_x^2+(n-1)s_y^2}{m+n-2}\sim\mathcal{X}^2(m+n-2)</script><p><strong>第五步：</strong> 带入原式构造枢轴量：</p>
<script type="math/tex; mode=display">
G= \sqrt{\frac{m+n}{mn}}\frac{\overline x-\overline y-\theta}{\sqrt{s_w^2}}\sim t(m+n-2)</script><p><strong>第六步</strong></p>
<p>反解得到： </p>
<script type="math/tex; mode=display">
\overline x-\overline y \pm \sqrt\frac{m+n}{mn}s_wt_{1-\alpha/2} (m+n-2)</script><h5 id="例题8"><a href="#例题8" class="headerlink" title="例题8"></a>例题8</h5><p>求 $\theta = \frac{\sigma_1^2}{\sigma_2^2}$ 的区间估计，在这种情况下，$\mu_1,\mu_2$ 都是默认未知的</p>
<p><strong>第一步：</strong> 求 $\theta$ 的点估计。</p>
<script type="math/tex; mode=display">
\theta = \frac{\sigma_1^2}{\sigma_2^2}~~~, ~\hat\theta = \frac{s_x^2}{s_y^2}</script><p><strong>第二步</strong>： 构造枢轴量：</p>
<p>已知 $s_x^2,s_y^2$ 是互相独立且可以变换成 $\mathcal{X}^2$ 分布</p>
<script type="math/tex; mode=display">
\frac{s_x^2/\sigma_1^2}{s_y^2/\sigma_2^2}\sim F(m-1,n-1)</script><p> <strong>第三步</strong>：</p>
<script type="math/tex; mode=display">
P(F_{\frac{\alpha}2}(m-1,n-1)\leq \frac{s_x^2}{s_y^2}\cdot \frac{\sigma_2^2}{\sigma_1^2}\leq F_{1-\alpha/2}(m-1,n-1))\\~\\</script><p><strong>第四步：</strong> 反解得到：</p>
<script type="math/tex; mode=display">
\theta\in [\frac{s_x^2}{s_y^2}\frac{1}{F_{1-\alpha/2}(m-1,n-1)},\frac{s_x^2}{s_y^2}\frac{1}{F_{\alpha/2}(m-1,n-1)}]</script>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/" itemprop="url">计算机网络-期末大作业</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-06-05T14:21:36+08:00">
                2021-06-05
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-08-23T22:24:16+08:00">
                2022-08-23
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="计算机网络-期末大作业"><a href="#计算机网络-期末大作业" class="headerlink" title="计算机网络-期末大作业"></a>计算机网络-期末大作业</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><p>在这个编程作业中，你将用Java语言开发一个简单的Web服务器，它仅能处理一个请求，具体而言，你的Web服务器将：</p>
<ol>
<li>当一个客户(浏览器)联系时创建一个连接套接字；</li>
<li>从这个连接接收HTTP请求</li>
<li>解释该请求以确定所请求的特定文件</li>
<li>从服务器的文件系统获得请求的文件</li>
<li>创建一个由请求的文件组成的HTTP响应报文，报文前面有首部行</li>
<li>经TCP连接向请求的浏览器返回响应</li>
</ol>
<h4 id="具体需求"><a href="#具体需求" class="headerlink" title="具体需求"></a>具体需求</h4><ul>
<li>请使用 ServerSocket 和 Socket 进行代码实现</li>
<li>请使用多线程接管连接</li>
<li>在浏览器中输入<code>localhost:8081/index.html</code> 能显示出自己的学号</li>
<li>在浏览器中输入 <code>localhost:8081</code> 下其他无效路径显示404not found</li>
<li>在浏览器中输入 <code>localhost:8081/shutdown</code> 能使服务器关闭</li>
<li>使用postman再次进行测试，测试 <code>get/post</code>两种请求方法</li>
</ul>
<h3 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h3><p>在这个编程作业中，你将用java语言研发一个简单的Web代理服务器</p>
<ol>
<li>当你的代理服务器从一个浏览器接收到对某个对象的HTTP请求，他生成对相同对象的一个新HTTP请求并向初始服务器发送</li>
<li>当该代理从初始服务器接收到具有该对象的HTTP响应时，它生成一个包括该对象的新HTTP 响应，并发送给该客户</li>
<li>这个代理将是多线程的，使其在同一时间能够处理多个请求</li>
</ol>
<h4 id="具体需求-1"><a href="#具体需求-1" class="headerlink" title="具体需求"></a>具体需求</h4><ul>
<li>在题目1.1 的代码上进行修改，使用ServerSocket和 Socket 进行代码实现</li>
<li>请使多线程接管连接(最好使用线程池)</li>
<li>请分别使用浏览器和postman 进行代理的测试</li>
</ul>
<h4 id="功能和性能需求"><a href="#功能和性能需求" class="headerlink" title="功能和性能需求"></a>功能和性能需求</h4><ul>
<li>之后会给大家一个压测的client端进行测试，在保证功能完整的前提下测试每秒相应的请求数</li>
<li><strong>附加题(选做)</strong> : 分析现有的 能支持同时连接的最大数，修改代码使得服务器能同时支持一千个连接(需要使用NIO)</li>
</ul>
<h2 id="开发历程"><a href="#开发历程" class="headerlink" title="开发历程"></a>开发历程</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="反-序列化"><a href="#反-序列化" class="headerlink" title="(反)序列化"></a>(反)序列化</h4><p>要求我们开发一个Java后端，我这里使用了Maven，方便后期对项目进行管理和维护。因此，引入(反)序列化对项目的配置(环境变量、端口号等)进行管理是必不可少的。那么在这个项目中，我们用JSON 来存放关于项目的配置信息，并通过 Jackson 将JSON 中的键值对序列化后变成Java对象。</p>
<p>那么首先就要用maven引入 Jakson包，因此我们需要在 <code>pom.xml</code>中添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Dependencies --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意了，我们这里需要在idea的设置中对两个地方进行修改：</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/2.png" style="zoom:67%;"></p>
<p>第一个在maven设置中三个都要勾选，可以自动下载依赖。</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/1.png" style="zoom:67%;"></p>
<p>在第二个在maven&gt;import 中，要勾选这两个Override，将maven库改为本地的仓库。 否则在引入Jackson是会出现找不到包的情况。</p>
<p>进入到正式的序列化</p>
<p>首先在项目文件夹中新建一个 <code>util</code> 文件夹来存放 <code>Json</code>类，这个类会的作用能让 JSON中的键值对和java对象之间相互转换。</p>
<p>这里我要讲几个预备知识：</p>
<ul>
<li><code>ObjectMapper</code>类是Jackson库的主要类，它提供一些功能将数据集或对象转换的实现。</li>
<li>将 JSON 转换为Java 对象，称为反序列化。但是考虑到 JSON中的 key值和对象中的成员名可能不完全一致，因此需要在 <code>configure()</code> 中将<code>DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</code>设置为false。</li>
<li>JsonNode类是Jackson库的一个类，该类可以很容易的操作Json格式的数据。如获取某个简单json串中某个key的值、获取某个层层嵌套的json串中某个key的值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.httpserver.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Json</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ObjectMapper myObjectMapper = defaultObjectMapper();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ObjectMapper <span class="title">defaultObjectMapper</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> om;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 这个parse函数的作用是收到 是一个json格式String,得到的是一个JsonNode类型                                          </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JsonNode <span class="title">parse</span><span class="params">(String jsonSrc)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myObjectMapper.readTree(jsonSrc);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 这个fromJson接受两个参数：JsonNode和目标类，目的是将JsonNode转换成自定义的java类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;A&gt; <span class="function">A <span class="title">fromJson</span><span class="params">(JsonNode node,Class&lt;A&gt; clazz)</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myObjectMapper.treeToValue(node,clazz);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// toJson 和 fromJson的作用相反，是将自定义的java类转换成JsonNode</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JsonNode <span class="title">toJson</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myObjectMapper.valueToTree(obj);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//将JsonNode 序列化成一个 JSON 字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">stringify</span><span class="params">(JsonNode node)</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> generateJson(node,<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果打开SerializationFeature.INDENT_OUTPUT这个特性开关，能以多行缩进格式化的格式输出JSON</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generateJson</span> <span class="params">(Object o,<span class="keyword">boolean</span> pretty)</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">        ObjectWriter objectWriter = myObjectMapper.writer();</span><br><span class="line">        <span class="keyword">if</span> (pretty)&#123;</span><br><span class="line">            objectWriter = objectWriter.with(SerializationFeature.INDENT_OUTPUT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> objectWriter.writeValueAsString(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们就要写将JSON字符串转化成哪个Java类了。</p>
<p>我们创建一个 <code>Configuration</code>类，用来存放 json 中的键值对信息：</p>
<p>因为当前有两个键值对： <code>port</code> 和 <code>webroot</code> ，因此我们要为这两个变量设置getter和setter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.httpserver.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> String webroot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Configuration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPort</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWebroot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> webroot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWebroot</span><span class="params">(String webroot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.webroot = webroot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是单单有这个 <code>Configuration</code> 类，还是不够的，我们还需要一个<strong>经纪人</strong>，负责读取JSON文件，并将其注入<code>Configuration</code>对象中. 我们将其命名为 <code>ConfigurationManager</code> 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.httpserver.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.JsonNode;</span><br><span class="line"><span class="keyword">import</span> com.httpserver.util.Json;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationManager</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConfigurationManager myConfigurationManager;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  Configuration myCurrentConfiguration;</span><br><span class="line"><span class="comment">// Configuration的构造函数，这里将其私有化了</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ConfigurationManager</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// 暴露一个 getInstance()方法，返回一个实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurationManager <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (myConfigurationManager ==<span class="keyword">null</span>)</span><br><span class="line">            myConfigurationManager = <span class="keyword">new</span> ConfigurationManager();</span><br><span class="line">        <span class="keyword">return</span> myConfigurationManager;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Used to load a configuration file aby the path provided</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"><span class="comment">//这个方法是关键，也就是读取JSON文件，生成Configuration对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadConfigurationFile</span><span class="params">(String filePath)</span></span>&#123;</span><br><span class="line">        FileReader fileReader = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 创建一个 FileReader 并读取文件</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileReader = <span class="keyword">new</span> FileReader(filePath);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HttpConfigurationException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!((i=fileReader.read())!=-<span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> HttpConfigurationException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append((<span class="keyword">char</span>)i);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 创建一个JsonNode 用来存放 parse()返回的信息</span></span><br><span class="line">        JsonNode conf = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conf = Json.parse(sb.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HttpConfigurationException(<span class="string">"Error parsing the configuration file"</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 利用 fromJson 方法将JsonNode中的信息放入Configuration类中</span></span><br><span class="line">            myCurrentConfiguration = Json.fromJson(conf,Configuration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HttpConfigurationException(<span class="string">"Error parsing the configuration file,internal"</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Returns the current loaded Configuration</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">  <span class="comment">// 将处理好的 Configuration 对象返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Configuration <span class="title">getCurrentConfiguration</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (myCurrentConfiguration == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HttpConfigurationException(<span class="string">"No Current Configuration Set."</span>);</span><br><span class="line">        &#125;<span class="keyword">return</span> myCurrentConfiguration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到我上面在处理异常的时候用到的是<code>HttpConfigurationException</code> 这是一个我自定义的异常类,其继承自<code>IOException</code></p>
<p><strong>测试</strong></p>
<p>我现在在<code>resource</code>文件加下编写 <code>http.json</code>文件</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"port"</span>: <span class="number">8080</span>,</span><br><span class="line">  <span class="attr">"webroot"</span>: <span class="string">"/java"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后创建 HttpServer类，作为启动器，并在 main方法中写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Server Starting..."</span>);</span><br><span class="line">				<span class="comment">// 首先，利用经纪人将http.json注入内置的Configuration对象中</span></span><br><span class="line">        ConfigurationManager</span><br><span class="line">                          .getInstance()</span><br><span class="line">                          .loadConfigurationFile(<span class="string">"src/main/resources/http.json"</span>);</span><br><span class="line">  		<span class="comment">// 然后利用getCurrentConfiguration() 来返回这个对象</span></span><br><span class="line">        Configuration conf = ConfigurationManager</span><br><span class="line">                          .getInstance()</span><br><span class="line">                          .getCurrentConfiguration();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Using Port: "</span>+ conf.getPort());</span><br><span class="line">        System.out.println(<span class="string">"Using WebRoot: "</span>+ conf.getWebroot());</span><br><span class="line">        </span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其中，JsonNode 打印结果如下：</p>
<p><code>{&quot;port&quot;:8080,&quot;webroot&quot;:&quot;/java&quot;}</code></p>
<p>整个打印结果如下：</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/3.png" style="zoom: 150%;"></p>
<h4 id="日志插件"><a href="#日志插件" class="headerlink" title="日志插件"></a>日志插件</h4><p>在后端测试中，在终端使用日志是十分重要的。虽然可以使用<code>System.out</code> 但是在多线程情况下，输出日志能让我们的程序显得更加严谨并让我们得到更多信息</p>
<p>首先还是在 <code>pom.xml</code>中添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--LOGGING--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>等待自动下载完成后，就可以对整个类使用Logger了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = (Logger) LoggerFactory.getLogger(HttpServer<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>对于一个项目来说，后期的测试是必不可少的因此我们使用测试工具 junit</p>
<p>首先在 <code>pom.xml</code> 中添加依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.0-M5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后只要对特定的类建立测试类即可</p>
<h3 id="解决单个client-连接"><a href="#解决单个client-连接" class="headerlink" title="解决单个client 连接"></a>解决单个client 连接</h3><p>现在我们来模拟单个链接时的情况，功能十分简陋，远不是最终成型的样子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Server Starting..."</span>);</span><br><span class="line"></span><br><span class="line">        ConfigurationManager.getInstance().loadConfigurationFile(<span class="string">"src/main/resources/http.json"</span>);</span><br><span class="line">        Configuration conf = ConfigurationManager.getInstance().getCurrentConfiguration();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Using Port: "</span>+ conf.getPort());</span><br><span class="line">        System.out.println(<span class="string">"Using WebRoot: "</span>+ conf.getWebroot());</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          <span class="comment">// 创建一个 ServerSocket</span></span><br><span class="line">            ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(conf.getPort());</span><br><span class="line">          <span class="comment">// 当接入client之后，创建套接字</span></span><br><span class="line">            Socket socket = serverSocket.accept();</span><br><span class="line">				<span class="comment">// 创建输入输出流</span></span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            OutputStream outputStream = socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">            String html = <span class="string">"&lt;html&gt;&lt;head&gt;&lt;title&gt;Hello,My name is Jason&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;My ID is 10195501423&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> String CRLF = <span class="string">"\n\r"</span>;</span><br><span class="line">				<span class="comment">// 编写返回信息</span></span><br><span class="line">          String response =</span><br><span class="line">                    <span class="string">"HTTP/1.1 200 OK"</span>+CRLF+</span><br><span class="line">                    <span class="string">"Content-Length: "</span>+html.getBytes(StandardCharsets.UTF_8).length+CRLF+</span><br><span class="line">                    CRLF+</span><br><span class="line">                    html+</span><br><span class="line">                    CRLF+CRLF;</span><br><span class="line">            outputStream.write(response.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            inputStream.close();</span><br><span class="line">            outputStream.close();</span><br><span class="line">            socket.close();</span><br><span class="line">            serverSocket.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 首先，在地址栏搜索 <code>localhost:8080</code>之后，会弹回一个html，如下图所示：</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/4.png" style="zoom: 150%;"></p>
<p>通过Wireshark抓包后，我们可以看出浏览器和我写的Java server中是存在tcp通讯的。当浏览器请求8080端口的时候，server就会发送一个tcp包</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/5.png" style="zoom: 150%;"></p>
<p>其中，响应报文如下，包括 HTTP版本，状态码以及数据内容，数据内容是一个html字符串。也就是我们 response的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Hypertext Transfer Protocol</span><br><span class="line">    HTTP&#x2F;1.1 200 OK\n</span><br><span class="line">    \r</span><br><span class="line">    [HTTP response 1&#x2F;1]</span><br><span class="line">    [Time since request: 0.040561000 seconds]</span><br><span class="line">    [Request in frame: 328]</span><br><span class="line">    [Request URI: http:&#x2F;&#x2F;localhost:8080&#x2F;]</span><br><span class="line">    File Data: 132 bytes</span><br><span class="line">    Data (132 bytes)</span><br></pre></td></tr></table></figure>
<h3 id="解决多个client-连接"><a href="#解决多个client-连接" class="headerlink" title="解决多个client 连接"></a>解决多个client 连接</h3><p>显然，刚才的实现方法是不理想的，因为只能连接一个client，且代码很乱。因此我们现在要优化刚才的代码，能让多个client连接. 这就需要用到多线程。</p>
<p>那么首先我们先用LOGGER来替换掉<code>System.out</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = (Logger) LoggerFactory.getLogger(HttpServer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="comment">// 直接用 LOGGER.info 就能输出</span></span><br><span class="line">        LOGGER.info(<span class="string">"Server Starting..."</span>);</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们架构一下接下来的操作：既然要多线程，那么我们必须保持socket 在一段时间内始终保持打开状态。然后对于每一个接入的client，可以新开一个线程。因此我们可以采用父子线程的方式来实现这个功能。父线程负责维持socket打开并接入client，子线程可以负责处理client的请求。</p>
<p>于是我们新建一个父线程类叫 <code>ListenerThread.java</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = (Logger) LoggerFactory.getLogger(HttpServer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> String webroot;</span><br><span class="line">    <span class="keyword">private</span> ServerSocket serverSocket;</span><br><span class="line">	<span class="comment">// 从 HttpServer 中获取port和 webroot</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListenerThread</span><span class="params">(<span class="keyword">int</span> port, String webroot)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">        <span class="keyword">this</span>.webroot = webroot;</span><br><span class="line">        <span class="keyword">this</span>.serverSocket = <span class="keyword">new</span> ServerSocket(<span class="keyword">this</span>.port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这个线程是一直等待的</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">          <span class="comment">// 当 ServerSocket没关且被绑定在端口上的时候，这个线程就开着</span></span><br><span class="line">            <span class="keyword">while</span>(serverSocket.isBound()&amp;&amp;!serverSocket.isClosed()) &#123;</span><br><span class="line">                Socket socket = serverSocket.accept();</span><br><span class="line">              <span class="comment">// 每当接入一个client在日志中记入，并开启一个子线程</span></span><br><span class="line">                LOGGER.info(<span class="string">"Connection accepted: "</span>+socket.getInetAddress());</span><br><span class="line">                WorkerThread workerThread = <span class="keyword">new</span> WorkerThread(socket);</span><br><span class="line">                workerThread.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            LOGGER.error(<span class="string">"Problem with setting socket..."</span>,e);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (serverSocket!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后创建一个子线程类： <code>WorkerThread.java</code>， 子线程做的事情就是处理client发来的http请求，大量代码是复制的。不过因为父进程创建子进程时需要将socket传入，所以要创建一个参数为socket的构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.httpserver.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.httpserver.HttpServer;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = (Logger) LoggerFactory.getLogger(HttpServer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WorkerThread</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = socket.getInputStream();</span><br><span class="line">            outputStream = socket.getOutputStream();</span><br><span class="line">            String html = <span class="string">"&lt;html&gt;&lt;head&gt;&lt;title&gt;Hello,My name is Jason&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;My ID is 10195501423&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> String CRLF = <span class="string">"\n\r"</span>;</span><br><span class="line">            String response =</span><br><span class="line">                    <span class="string">"HTTP/1.1 200 OK"</span> + CRLF +</span><br><span class="line">                            <span class="string">"Content-Length: "</span> + html.getBytes(StandardCharsets.UTF_8).length + CRLF +</span><br><span class="line">                            CRLF +</span><br><span class="line">                            html +</span><br><span class="line">                            CRLF + CRLF;</span><br><span class="line"></span><br><span class="line">            outputStream.write(response.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            LOGGER.info(<span class="string">"   Connection Processing Finished"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            LOGGER.error(<span class="string">"Problem with communication"</span>,e) ;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//最后，当线程结束时，需要关闭 inputeStream、outPutStream和socket</span></span><br><span class="line">            <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (outputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    outputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    outputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后如下图所示，我们开启多个tag，同时访问 <code>localhost:8080</code> 发现使用了这种方式以后，后端会自动为连进来的client创建不同的进程</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/6.png" style="zoom: 150%;"></p>
<h3 id="解析请求"><a href="#解析请求" class="headerlink" title="解析请求"></a>解析请求</h3><p>刚才我们所做的，是非常简单的功能，也就是收到请求，不管请求什么，都返回相同的东西。因此不论我请求 <code>localhost:8080</code>还是<code>localhost:8080/index</code> 只要是在这个端口发起的请求，都会收到 My ID is 1019550123的返回结果。因此现在我们需要解析client发来的请求。</p>
<p> 要解析请求，首先我们要捕获 client发来的HTTP头部信息，我们可以这样来写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _byte;</span><br><span class="line"><span class="keyword">while</span>((_byte=inputStream.read())&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">    System.out.print((<span class="keyword">char</span>) _byte);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我在浏览器中请求 <code>localhost:8080/index</code>， 结果如下：</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/7.png" style="zoom: 150%;"></p>
<p>在请求头中包含了这是一个 GET 请求，路由是 <code>/index</code></p>
<p>整个HTTP请求的格式如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP-message &#x3D; start-line						&#x2F;&#x2F; 在请求时的格式是：method SP request-target SP HTTP-version CRLF</span><br><span class="line">							+(header-field CRLF) &#x2F;&#x2F;可能有多个信息</span><br><span class="line">							CRLF</span><br><span class="line">							[ message-body ]		&#x2F;&#x2F;请求体</span><br></pre></td></tr></table></figure>
<p>现在我们可以进行解析了。我们来介绍两种解析器: Lexer Parser 和 Lexerless Parser。 前者会把 socket发来的流先处理成token，再讲token转为我们想要的信息(请求方式、路由等)。后者则是直接转换。</p>
<p>这里我们使用后者，因为我们对时间的要求较高，需要对请求进行迅速解析。</p>
<p>搞清楚 HTTP 请求的格式之后，我们知道最重要的部分就是请求的方式以及请求的目标文件。这两者决定了Server怎么去响应请求。因此我们需要创建几个比较基础的类：<code>HttpMethod</code> 和<code>HttpStatusCode</code>是两个枚举类，分别用来放请求方法和状态码。<code>HttpRequest</code> 用来存放请求行的信息(请求方式、目标文件以及HTTP版本)</p>
<h4 id="HttpMethod"><a href="#HttpMethod" class="headerlink" title="HttpMethod"></a>HttpMethod</h4><p>这是一个枚举类，用来存放请求方式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.http.request;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> HttpMethod &#123;</span><br><span class="line">    GET,HEAD,POST,PUT,DELETE;</span><br><span class="line">    <span class="comment">// MAX_LENGTH 代表最长的请求方式，如果超出这个值就说明是非法请求</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_LENGTH;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> tempMaxLength = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(HttpMethod method:values())&#123;</span><br><span class="line">            <span class="keyword">if</span>(method.name().length()&gt;tempMaxLength)&#123;</span><br><span class="line">                tempMaxLength = method.name().length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        MAX_LENGTH = tempMaxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="HttpStatusCode"><a href="#HttpStatusCode" class="headerlink" title="HttpStatusCode"></a>HttpStatusCode</h4><p>这个类用来存放状态码，我这里列举了几个错误时发生的状态码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.http.request;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> HttpStatusCode &#123;</span><br><span class="line">    Client_ERROR_400_BAD_REQUEST(<span class="number">400</span>,<span class="string">"Bad request"</span>),</span><br><span class="line">    Client_ERROR_401_METHOD_NOT_ALLOWED(<span class="number">401</span>,<span class="string">"Method not allowed"</span>),</span><br><span class="line">    Client_ERROR_414_BAD_REQUEST(<span class="number">414</span>,<span class="string">"URL Too long"</span>),</span><br><span class="line">    SERVER_ERROR_500_INTERNAL_SERVER_ERROR(<span class="number">500</span>,<span class="string">"Internmal server error"</span>),</span><br><span class="line">    SERVER_ERROR_501_NOT_IMPLEMENTED(<span class="number">501</span>,<span class="string">"Internal server error"</span>),</span><br><span class="line">    SERVER_ERROR_404_NOT_FOUND(<span class="number">404</span>,<span class="string">"NOT FOUND"</span>),</span><br><span class="line">    SERVER_ERROR_200_OK(<span class="number">200</span>,<span class="string">"OK"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> STATUS_CODE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String MESSAGE;</span><br><span class="line"></span><br><span class="line">    HttpStatusCode(<span class="keyword">int</span> status_code, String message) &#123;</span><br><span class="line">        STATUS_CODE = status_code;</span><br><span class="line">        MESSAGE = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="HttpRequest"><a href="#HttpRequest" class="headerlink" title="HttpRequest"></a>HttpRequest</h4><p>这个类用来存放请求行的信息(请求方式、目标文件以及HTTP版本) </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.http.request;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HttpMethod method;</span><br><span class="line">    <span class="keyword">private</span> String requestTarget;</span><br><span class="line">    <span class="keyword">private</span> String httpVersion;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    HttpRequest() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpMethod <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//packege level</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMethod</span><span class="params">(String methodName)</span> <span class="keyword">throws</span> HttpParsingException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(HttpMethod method:HttpMethod.values())&#123;</span><br><span class="line">            <span class="keyword">if</span>(methodName.equals(methodName))&#123;</span><br><span class="line">                <span class="keyword">this</span>.method = method;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HttpParsingException(</span><br><span class="line">            HttpStatusCode.SERVER_ERROR_501_NOT_IMPLEMENTED</span><br><span class="line">            );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRequestTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> requestTarget;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRequestTarget</span><span class="params">(String requestTarget)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.requestTarget = requestTarget;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHttpVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> httpVersion;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHttpVersion</span><span class="params">(String httpVersion)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.httpVersion = httpVersion;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="HttpParser"><a href="#HttpParser" class="headerlink" title="HttpParser"></a>HttpParser</h4><p>这是解析器最重要的部分了，起作用相当一座桥梁，能够把 Byte转换为字符串。事实上需要对三个部分进行解析： 请求行、头部以及请求体。但是根据这个项目的要求，我们只要来解析请求行即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpParser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(HttpParser<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      	<span class="comment">//接下来对头部进行拆解，我们知道头部的格式是：</span></span><br><span class="line">      <span class="comment">/* Method+SP+Target+SP+HttpVersion+CRLF */</span></span><br><span class="line">      <span class="comment">//又这是通过字节流传送的，因此我们需要在一开始就查询空格换行的ASCII码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SP =<span class="number">0x20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CR =<span class="number">0x0D</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LF =<span class="number">0x0A</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 首先吗，从子线程传进来一个socket的输入流，然后在这个 parseHttpRequest方法中进行解析</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpRequest <span class="title">parseHttpRequest</span><span class="params">(InputStream inputStream)</span> <span class="keyword">throws</span> HttpParsingException </span>&#123;</span><br><span class="line">        <span class="comment">// a bridge from Byte to String</span></span><br><span class="line">        InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(inputStream, StandardCharsets.US_ASCII);</span><br><span class="line"></span><br><span class="line">        HttpRequest request = <span class="keyword">new</span> HttpRequest();</span><br><span class="line">			<span class="comment">//解析请求行</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            parseRequestLine(reader,request);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//解析头部信息</span></span><br><span class="line">        parseHeaders(reader,request);</span><br><span class="line">      <span class="comment">//解析请求体</span></span><br><span class="line">        parseBody(reader,request);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseRequestLine</span><span class="params">(InputStreamReader reader, HttpRequest request)</span> <span class="keyword">throws</span> IOException, HttpParsingException </span>&#123;</span><br><span class="line">        StringBuilder processingDataBuffer = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> methodParsed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> requestTargetParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> _byte;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((_byte=reader.read())&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="comment">//如果读到 CR 了，就说明头部行即将结束在往后读取一个信息</span></span><br><span class="line">            <span class="keyword">if</span>(_byte==CR)&#123;</span><br><span class="line">                _byte = reader.read();</span><br><span class="line">              <span class="comment">//如果CR后面是LF，说明头部行已结束，最后一个part是Http Version，我们设置一下</span></span><br><span class="line">                <span class="keyword">if</span>(_byte == LF)&#123;</span><br><span class="line">                    LOGGER.debug(<span class="string">"Request Line VERSION to Process: &#123;&#125;"</span>, processingDataBuffer.toString());</span><br><span class="line">                    request.setHttpVersion(processingDataBuffer.toString());</span><br><span class="line">                <span class="comment">//因为读到最后一个部分了，但是前面的method和target却仍然未设置，说明出错了</span></span><br><span class="line">                    <span class="keyword">if</span>(!methodParsed || !requestTargetParsed)&#123;</span><br><span class="line">                        <span class="keyword">throw</span>  <span class="keyword">new</span> HttpParsingException(HttpStatusCode.Client_ERROR_414_BAD_REQUEST);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 如果读到空格，说明有一部分已经结束了</span></span><br><span class="line">            <span class="keyword">if</span>(_byte == SP)&#123;</span><br><span class="line">              <span class="comment">//method是第一部分，因此先判断method是否设置，若未设置则设置并把flag置为true</span></span><br><span class="line">                <span class="keyword">if</span>(!methodParsed)&#123;</span><br><span class="line">                    LOGGER.debug(<span class="string">"Request Line to Process: &#123;&#125;"</span>, processingDataBuffer.toString());</span><br><span class="line">                    request.setMethod(processingDataBuffer.toString());</span><br><span class="line">                    methodParsed = <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!requestTargetParsed)&#123;</span><br><span class="line">              <span class="comment">// 然后判断 target是否已设置，若未设置则把target置为true</span></span><br><span class="line">                    LOGGER.debug(<span class="string">"Request Line to Process: &#123;&#125;"</span>, processingDataBuffer.toString());</span><br><span class="line">                    request.setRequestTarget(processingDataBuffer.toString());</span><br><span class="line">                    requestTargetParsed=<span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  <span class="comment">//如果读到最后发现请求行还是有空格，说明这是个错误的请求</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> HttpParsingException(HttpStatusCode.Client_ERROR_414_BAD_REQUEST);</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">// 每一部分解析完成后，在Buffer中删除该信息</span></span><br><span class="line">                processingDataBuffer.delete(<span class="number">0</span>,processingDataBuffer.length());</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//既不是SP也不是CRLF，说明是我们要的信息，我们将其记录在一个Buffer当中取用</span></span><br><span class="line">                processingDataBuffer.append((<span class="keyword">char</span>)_byte);</span><br><span class="line">                <span class="keyword">if</span>(!methodParsed)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(processingDataBuffer.length()&gt;HttpMethod.MAX_LENGTH)&#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> HttpParsingException((HttpStatusCode.SERVER_ERROR_501_NOT_IMPLEMENTED));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseHeaders</span><span class="params">(InputStreamReader inputStream,HttpRequest request)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseBody</span><span class="params">(InputStreamReader inputStream,HttpRequest request)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ResponseBuilder"><a href="#ResponseBuilder" class="headerlink" title="ResponseBuilder"></a>ResponseBuilder</h4><p>解析完头部信息之后，我们就需要根据请求的结果编写响应报文了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.http.response;</span><br><span class="line"></span><br><span class="line">import com.http.request.HttpStatusCode;</span><br><span class="line"></span><br><span class="line">public class ResponseBuilder &#123;</span><br><span class="line">   private static final String CRLF &#x3D; &quot;\n\r&quot;;</span><br><span class="line">   private static String response;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   public static String build(String html,HttpStatusCode statusCode) &#123;</span><br><span class="line">       response &#x3D;</span><br><span class="line">            &quot;HTTP&#x2F;1.1 &quot;+statusCode.STATUS_CODE+&quot; &quot;+statusCode.MESSAGE+ CRLF +</span><br><span class="line">                  &quot;Content-Length: &quot; + html.getBytes().length + CRLF +</span><br><span class="line">                  CRLF +</span><br><span class="line">                  html +</span><br><span class="line">                  CRLF + CRLF;</span><br><span class="line">      return response;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="子线程的部分修改"><a href="#子线程的部分修改" class="headerlink" title="子线程的部分修改"></a>子线程的部分修改</h4><p>因为我们把响应报文的编写交给 ResponseBuilder了，因此我们这里需要调用ResponseBuilder并传入状态码和socket流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//.....</span></span><br><span class="line"><span class="comment">//如果请求的是正确的内容，那么我们就返回状态码200</span></span><br><span class="line">        <span class="keyword">if</span>(clientRequest.getRequestTarget().equals(<span class="string">"/index.html"</span>))&#123;</span><br><span class="line">            String html = <span class="string">"&lt;html&gt;&lt;head&gt;&lt;title&gt;Hello,My name is Jason&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;My ID is 10195501423&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;"</span>;</span><br><span class="line">            String response = ResponseBuilder.build(html,HttpStatusCode.SERVER_ERROR_200_OK);</span><br><span class="line">            outputStream.write(response.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(clientRequest.getRequestTarget().equals(<span class="string">"/shutdown"</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">"收到客户端的请求，关闭服务器"</span>);</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果请求的是不存在的文件，那么我们就需要将状态码设置为404</span></span><br><span class="line">            String html = loadHtmlFile(<span class="string">"/Users/jasonxu/IdeaProjects/finalproject/src/main/Web/404.html"</span>);</span><br><span class="line">            String response = ResponseBuilder.build(html,HttpStatusCode.SERVER_ERROR_404_NOT_FOUND);</span><br><span class="line">            outputStream.write(response.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LOGGER.info(<span class="string">"   Connection Processing Finished"</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException | HttpParsingException e)&#123;</span><br><span class="line">        LOGGER.error(<span class="string">"Problem with communication"</span>,e) ;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (outputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                outputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终结果：输入<code>localhost:8080/index.html</code> 之后，显示如下</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/9.png" style="zoom: 150%;"></p>
<p>输入<code>localhost:8080/222</code>（其他) ,显示如下</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/8.png" style="zoom: 150%;"></p>
<p>输入<code>localhost:8080/shutdown</code> 服务器关闭：</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/10.png" style="zoom: 150%;"></p>
<p>Postman 测试结果如下：</p>
<p>我们发现，postman测试的结果都通过了，且用GET和POST方法也没有出现错误。</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/11.png" style="zoom: 150%;"></p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/12.png" style="zoom: 150%;"></p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/13.png" style="zoom: 150%;"></p>
<h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h4><p>现在我们用 Jmeter 来测试一下这个 Java Server：</p>
<p>在1000线程并发时，发现这个server能毫无压力得处理。</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/24.png" style="zoom: 150%;"></p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/25.png" style="zoom: 150%;"></p>
<p>最终，在测到4900个并发线程的时候，出现了请求失败的情况。对此我又多测试了几次，最终测得这个server的极限压力大概是5000个线程左右</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/27.png" style="zoom: 150%;"></p>
<p>我们现在尝试优化这个server，采用线程池的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1000</span>, <span class="number">10000</span>, <span class="number">400</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">        <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">2000</span>));</span><br></pre></td></tr></table></figure>
<p>这几个参数分别是：</p>
<ul>
<li>corePoolSize：核心池的大小</li>
</ul>
<ul>
<li>maximumPoolSize：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；</li>
<li>keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。</li>
<li>unit：参数keepAliveTime的时间单位</li>
<li>workQueue：一个阻塞队列，用来存储等待执行的任务</li>
</ul>
<p>如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；</p>
<p>如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；</p>
<p>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；</p>
<p>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。</p>
<p>我给核心池开了1000个线程，(事实上根本用不了那么多)，在这之后，我用8000个并发请求也能轻松处理。一个错误都没有</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/28.png" style="zoom: 150%;"></p>
<h3 id="1-2-代理服务器的编写"><a href="#1-2-代理服务器的编写" class="headerlink" title="1.2 代理服务器的编写"></a>1.2 代理服务器的编写</h3><h4 id="“不正确”的代理服务器"><a href="#“不正确”的代理服务器" class="headerlink" title="“不正确”的代理服务器"></a>“不正确”的代理服务器</h4><p> 代理服务器相当于一个中转站，需要解析请求报文和响应报文并生成新的报文。一开始我还以为是proxy和server都要自己写，结果改了半天最终成功了才发现其实只需要写proxy，要代理浏览器访问的页面。但是失误已经酿成了，因此我把这个失误的版本也贴上来。</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/14.png" style="zoom: 150%;"></p>
<p>流程如下</p>
<ol>
<li>在8081端口， proxy作为server，收到了来自 client 的请求，开一个线程解析request、生成新的request。</li>
<li>proxy作为client，利用socket.connect，向端口(8080)传输新的request</li>
<li>端口8080 收到以后，解析request，然后生成response。</li>
<li>server 构造完后向端口8081传输response</li>
<li>Proxy在端口8081收到response，然后生成新的response，并向浏览器发送。</li>
</ol>
<p>整个流程都由一个线程完成。因此我们还是采用父子线程的架构模式。整个 <code>workThread</code>如下图所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = (Logger) LoggerFactory.getLogger(ProxyServer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    RequestParser myRequestParser = <span class="keyword">new</span> RequestParser();</span><br><span class="line">    ResponseParser myResponseParser = <span class="keyword">new</span> ResponseParser();</span><br><span class="line"></span><br><span class="line">    Socket socketToServer = <span class="keyword">new</span> Socket();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WorkerThread</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String CRLF = <span class="string">"\n\r"</span>;</span><br><span class="line"></span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        OutputStream outputStreamToServer = <span class="keyword">null</span>;</span><br><span class="line">        InputStream inputStreamFromServer = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> _byte;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 利用connect方法，可以实现两个端口之间的流传递</span></span><br><span class="line">            socketToServer.connect(<span class="keyword">new</span> InetSocketAddress(Inet4Address.getLocalHost(),</span><br><span class="line">                    <span class="number">8080</span>), <span class="number">50</span>);</span><br><span class="line">          <span class="comment">// inputStream和 outputStream 是8081端口的输入输出流</span></span><br><span class="line">            inputStream = socket.getInputStream();</span><br><span class="line">            outputStream = socket.getOutputStream();</span><br><span class="line">          <span class="comment">// outputStreamToServer和 inputStreamFromServer 是对于8080端口的输入输出流</span></span><br><span class="line">            outputStreamToServer = socketToServer.getOutputStream();</span><br><span class="line">            inputStreamFromServer = socketToServer.getInputStream();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*******************解析Request from Client*****************/</span></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          1.首先8081端口收到client发来的request，交给myRequestParser去解析，信息存到httpRequest中</span></span><br><span class="line"><span class="comment">          2.利用RequestBuilder 来构造转发的请求。</span></span><br><span class="line"><span class="comment">          3.利用outputStreamToServer，将构造的请求转发给server</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">                HttpRequest httpRequest = myRequestParser.parseHttpRequest(inputStream);</span><br><span class="line"></span><br><span class="line">                System.out.println(httpRequest.getMethod());</span><br><span class="line">                System.out.println(httpRequest.getRequestTarget());</span><br><span class="line"></span><br><span class="line">                String request = RequestBuilder.build(httpRequest.getMethod(),httpRequest.getRequestTarget(),httpRequest.getHttpVersion());</span><br><span class="line">                outputStreamToServer.write(request.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">            <span class="comment">/****************解析Response from Server*****************/</span></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          1. 收到来自server的response之后，交给myResponseParser去解析，并存入httpResponse中</span></span><br><span class="line"><span class="comment">          2. 利用httpResponse，构造新的response</span></span><br><span class="line"><span class="comment">          3. 将response转发给client</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">            HttpResponse httpResponse = myResponseParser.parseHttpResponse(inputStreamFromServer);</span><br><span class="line"></span><br><span class="line">            System.out.println(httpResponse.getStatusCode());</span><br><span class="line">            System.out.println(httpResponse.getStatusMessage());</span><br><span class="line"></span><br><span class="line">            String response = ResponseBuilder.build(httpResponse);</span><br><span class="line">            outputStream.write(response.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*******************Finish*************************/</span></span><br><span class="line">            LOGGER.info(<span class="string">"   Connection Processing Finished"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException | HttpParsingException e)&#123;</span><br><span class="line">            LOGGER.error(<span class="string">"Problem with communication"</span>,e) ;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (outputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    outputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    outputStream.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终结果如下图所示，用postman和浏览器分别测试：</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/15.png" style="zoom: 150%;"></p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/17.png" style="zoom: 150%;"></p>
<h3 id="“正经”代理服务器"><a href="#“正经”代理服务器" class="headerlink" title="“正经”代理服务器"></a>“正经”代理服务器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = (Logger) LoggerFactory.getLogger(ProxyServer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WorkerThread</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        OutputStream outputStreamToClient = <span class="keyword">null</span>;</span><br><span class="line">        InputStream inputStreamFromClient = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        Socket proxySocket = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        InputStream inputFromServer = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream outputToServer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStreamFromClient = socket.getInputStream();</span><br><span class="line">            outputStreamToClient = socket.getOutputStream();</span><br><span class="line">            String line;</span><br><span class="line">            String host = <span class="string">""</span>;</span><br><span class="line">            LineBuffer lineBuffer = <span class="keyword">new</span> LineBuffer(<span class="number">1024</span>);</span><br><span class="line">            StringBuilder headStr = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="comment">//读取HTTP请求头，并拿到HOST请求头和method</span></span><br><span class="line">            <span class="keyword">while</span> ( (line = lineBuffer.readLine(inputStreamFromClient))!=<span class="keyword">null</span>) &#123;</span><br><span class="line">                headStr.append(line).append(<span class="string">"\r\n"</span>);</span><br><span class="line">                <span class="keyword">if</span> (line.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    String[] temp = line.split(<span class="string">" "</span>);</span><br><span class="line">                    <span class="keyword">if</span> (temp[<span class="number">0</span>].contains(<span class="string">"Host"</span>)) &#123;</span><br><span class="line">                        host = temp[<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 请求方式</span></span><br><span class="line">            String type = headStr.substring(<span class="number">0</span>, headStr.indexOf(<span class="string">" "</span>));</span><br><span class="line">            LOGGER.debug(<span class="string">"type: "</span>+type);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//根据host头解析出目标服务器的host和port</span></span><br><span class="line">            String[] hostTemp = host.split(<span class="string">":"</span>);</span><br><span class="line">            host = hostTemp[<span class="number">0</span>];</span><br><span class="line">            LOGGER.debug(<span class="string">"host: "</span>+host);</span><br><span class="line">            <span class="keyword">int</span> port = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hostTemp.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                port = Integer.parseInt(hostTemp[<span class="number">1</span>]);</span><br><span class="line">                LOGGER.debug(<span class="string">"port: "</span>+port);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//连接到目标服务器</span></span><br><span class="line">            proxySocket = <span class="keyword">new</span> Socket(host, port);</span><br><span class="line">            inputFromServer = proxySocket.getInputStream();</span><br><span class="line">            outputToServer = proxySocket.getOutputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//根据HTTP method来判断是https还是http请求，https</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"CONNECT"</span>.equalsIgnoreCase(type)) &#123;</span><br><span class="line">              <span class="comment">//如果是https，type是CONNECT，如果是http则type是GET、POST之类的</span></span><br><span class="line">              <span class="comment">//https需要建立隧道，以便能和client之间进行二进制数据的收发。</span></span><br><span class="line">                outputStreamToClient.write(<span class="string">"HTTP/1.1 200 Connection Established\r\n\r\n"</span>.getBytes());</span><br><span class="line">                outputStreamToClient.flush();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//http直接将请求头转发</span></span><br><span class="line">                outputToServer.write(headStr.toString().getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//新开线程转发客户端请求至目标服务器，这边使用线程的原因是需要异步操作</span></span><br><span class="line">            <span class="keyword">new</span> ProxyWorkerThread(inputStreamFromClient, outputToServer).start();</span><br><span class="line">            <span class="comment">//转发目标服务器响应至客户端</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                outputStreamToClient.write(inputFromServer.read());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (inputFromServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    outputToServer.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (outputToServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    outputToServer.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (proxySocket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    proxySocket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (inputStreamFromClient != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    inputStreamFromClient.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (outputStreamToClient != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    outputStreamToClient.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="LineBuffer类"><a href="#LineBuffer类" class="headerlink" title="LineBuffer类"></a>LineBuffer类</h4><p>这个类设置了一个可以自动扩容的缓冲区，用来读client请求.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.httpserver.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LineBuffer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SP =<span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CR =<span class="string">'\r'</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LF =<span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LineBuffer</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readLine</span><span class="params">(InputStream input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bts = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="keyword">this</span>.size];</span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">      <span class="comment">//因为在请求头中，每一行的结尾都是 "\r\n" 所以当一行结束时，就返回这一行字符串</span></span><br><span class="line">       <span class="keyword">while</span>(flag!=<span class="number">2</span>&amp;&amp;(b= input.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            bts[index++] = (<span class="keyword">byte</span>) b;</span><br><span class="line">            <span class="keyword">if</span>(b == CR &amp;&amp; flag%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                flag++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(b== LF &amp;&amp; flag%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                flag++;</span><br><span class="line">                <span class="keyword">if</span>(flag==<span class="number">2</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> String(bts,<span class="number">0</span>,index-<span class="number">2</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(index==bts.length)&#123;</span><br><span class="line">                <span class="comment">//满了就扩容</span></span><br><span class="line">                <span class="keyword">byte</span>[] newBts = <span class="keyword">new</span> <span class="keyword">byte</span>[bts.length*<span class="number">2</span>];</span><br><span class="line">                System.arraycopy(bts,<span class="number">0</span>,newBts,<span class="number">0</span>,bts.length);</span><br><span class="line">                bts = newBts;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ProxyWorkerThread类"><a href="#ProxyWorkerThread类" class="headerlink" title="ProxyWorkerThread类"></a>ProxyWorkerThread类</h4><p>这个类负责将客户端的请求转发到目标服务器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyWorkerThread</span>  <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> InputStream input;</span><br><span class="line">    <span class="keyword">private</span> OutputStream output;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyWorkerThread</span><span class="params">(InputStream inputStreamFromClient, OutputStream outputToServer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.input = inputStreamFromClient;</span><br><span class="line">        <span class="keyword">this</span>.output = outputToServer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                output.write(input.read());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用代理服务器上网之前，首先需要设置chrome的代理配置。将端口改为代理服务器监听的8080端口</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/21.png" style="zoom: 150%;"></p>
<p>结果如下图所示</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/22.png" style="zoom: 150%;"></p>
<p>如果访问https，也是同样的操作</p>
<p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%9C%9F%E6%9C%AB%E5%A4%A7%E4%BD%9C%E4%B8%9A/23.png" style="zoom: 150%;"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek13/" itemprop="url">计算机网络报告week13</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-06-03T16:03:36+08:00">
                2021-06-03
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-08-23T22:22:22+08:00">
                2022-08-23
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Week-13-利用Wireshark分析ARP协议"><a href="#Week-13-利用Wireshark分析ARP协议" class="headerlink" title="Week 13 : 利用Wireshark分析ARP协议"></a>Week 13 : 利用Wireshark分析ARP协议</h1><h2 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1.  实验目的"></a>1.  实验目的</h2><ul>
<li>掌握Wireshark软件的过滤语法</li>
<li>掌握ARP 的工作原理</li>
</ul>
<h2 id="2-实验任务"><a href="#2-实验任务" class="headerlink" title="2. 实验任务"></a>2. 实验任务</h2><ul>
<li>学会利用Wireshark 抓包分析ARP协议</li>
</ul>
<h2 id="3-实验过程"><a href="#3-实验过程" class="headerlink" title="3. 实验过程"></a>3. 实验过程</h2><h3 id="3-1-预备知识"><a href="#3-1-预备知识" class="headerlink" title="3.1 预备知识"></a>3.1 预备知识</h3><ul>
<li>ARP(Address Resolution Protocol) 协议，即地址解析协议。该协议的功能就是将IP地址解析成MAC地址。ARP的基本功能就是负责将一个已知的IP地址解析成MAC地址，以便主机间能正常进行通信。</li>
</ul>
<p><img src="/2021/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek13/1.jpg" style="zoom:67%;"></p>
<ul>
<li>ARP 协议的解析过程只使用了两种数据包： 一个ARP请求和一个ARP响应，如下图所示：</li>
</ul>
<p><img src="/2021/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek13/2.jpg" style="zoom:67%;"></p>
<ul>
<li>其详细工作原理是：<ol>
<li>当主机A想要给主机B发送数据时，主机A会首先在自己的本地ARP缓存表中检查与主机B匹配的MAC地址。</li>
<li>如果主机A在自己的缓存表中没有找到主机B的相关条目，那么它就要想办法获取主机B的MAC地址。这就需要将ARP的请求帧广播到网络上所有主机中。这个请求帧包含有主机A的IP地址和MAC地址，以及主机B的IP地址。网络中凡是收到请求帧的主机都会检查自己的IP地址是否与请求地址一致，如果不一致，则会丢弃该请求帧。对于上图来说，主机C和主机D会丢弃主机A发出的请求帧。</li>
<li>主机B确定ARP请求中的IP地址和自己的IP地址一致，那么就会将主机A的IP地址和MAC地址添加到本地的缓存列表中</li>
<li>主机B将包含有自己MAC地址的ARP响应消息直接回复给主机A(单播)</li>
<li>主机A收到从主机B发来的ARP响应消息之后，会将主机B的IP地址和MAC地址添加到自己的ARP缓存表中。接下来，主机A就可以向主机B发送消息了</li>
</ol>
</li>
<li>如果想要查看ARP缓存表，可以打开cmd ，输入”arp -a”</li>
</ul>
<p><img src="/2021/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek13/3.jpg" style="zoom:67%;"></p>
<h3 id="3-2-分析-ARP-数据包"><a href="#3-2-分析-ARP-数据包" class="headerlink" title="3.2 分析 ARP 数据包"></a>3.2 分析 ARP 数据包</h3><ul>
<li>选择一个ARP缓存表中没有的地址进行分析，如： <code>ping 192.168.1.110</code></li>
</ul>
<p><img src="/2021/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek13/5.jpg" style="zoom:67%;"></p>
<ul>
<li>利用Wireshark 抓取 ARP 包，并进行分析，再次通过 arp -a 命令可以发现该IP地址对应的mac信息已添加在缓存表中了</li>
</ul>
<p><img src="/2021/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek13/4.jpg" style="zoom:67%;"></p>
<h4 id="task1"><a href="#task1" class="headerlink" title="task1"></a>task1</h4><p>如上图所示，分析当ARP缓存表不存在某个IP信息时，数据发送是的请求和应答数据报信息，截图并标注具体ARP字段数据，请在实验报告中附上结果截图</p>
<p>我在笔记本上开了一个虚拟机，地址是 <code>192.168.31.100</code>, </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Address Resolution Protocol (request) </span><br><span class="line">    Hardware type: Ethernet (1)  	# 硬件类型</span><br><span class="line">    Protocol type: IPv4 (0x0800) 	# 上层协议类型</span><br><span class="line">    Hardware size: 6						 	# MAC 地址长度</span><br><span class="line">    Protocol size: 4							# IP 地址长度</span><br><span class="line">    Opcode: request (1)						# 操作类型，这里是request	</span><br><span class="line">    Sender MAC address: BeijingX_2e:de:27 (50:d2:f5:2e:de:27) # 源MAC地址</span><br><span class="line">    Sender IP address: 192.168.31.1														# 源IP地址 </span><br><span class="line">    Target MAC address: 00:00:00_00:00:00 (00:00:00:00:00:00) # 目的 mac 地址</span><br><span class="line">    Target IP address: 192.168.31.100		# 目的 ip 地址</span><br></pre></td></tr></table></figure>
<p>我们发现，在还没有加入缓存的时候，我们发送的ARP请求包中是不知道目标主机的mac地址的，因此默认为：<code>00:00:00:00:00:00</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Address Resolution Protocol (reply)</span><br><span class="line">    Hardware type: Ethernet (1) 			# 硬件类型</span><br><span class="line">    Protocol type: IPv4 (0x0800) 			# 上层协议类型</span><br><span class="line">    Hardware size: 6 									#  MAC 地址长度</span><br><span class="line">    Protocol size: 4									#  IP 地址长度</span><br><span class="line">    Opcode: reply (2)									#  操作类型，reply	</span><br><span class="line">    Sender MAC address: IntelCor_75:21:32 (38:00:25:75:21:32)	# 源MAC地址</span><br><span class="line">    Sender IP address: 192.168.31.100													# 源IP地址 </span><br><span class="line">    Target MAC address: Apple_e2:a1:2e (4c:20:b8:e2:a1:2e)		# 目的 mac 地址</span><br><span class="line">    Target IP address: 192.168.31.15													# 目的 ip 地址</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek13/6.png" style="zoom:67%;"></p>
<h4 id="task2"><a href="#task2" class="headerlink" title="task2"></a>task2</h4><p>分析当ARP缓存表存在某个Ip信息时，ARP请求和接收MAC地址分析，(只截图，写出目的MAC地址和源MAC地址)，并分析与task1中数据包存在的区别，在实验报告中附上截图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Address Resolution Protocol (request)</span><br><span class="line">    Hardware type: Ethernet (1)</span><br><span class="line">    Protocol type: IPv4 (0x0800)</span><br><span class="line">    Hardware size: 6</span><br><span class="line">    Protocol size: 4</span><br><span class="line">    Opcode: request (1)</span><br><span class="line">    Sender MAC address: Apple_e2:a1:2e (4c:20:b8:e2:a1:2e)</span><br><span class="line">    Sender IP address: 192.168.31.15</span><br><span class="line">    Target MAC address: IntelCor_75:21:32 (38:00:25:75:21:32)</span><br><span class="line">    Target IP address: 192.168.31.100</span><br></pre></td></tr></table></figure>
<p>但是当ARP中已经包含了该主机的mac地址后，在发送ARP请求包时，在<code>Target MAC address</code> 中直接填入目标主机的mac地址了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Address Resolution Protocol (reply)</span><br><span class="line">    Hardware type: Ethernet (1)</span><br><span class="line">    Protocol type: IPv4 (0x0800)</span><br><span class="line">    Hardware size: 6</span><br><span class="line">    Protocol size: 4</span><br><span class="line">    Opcode: reply (2)</span><br><span class="line">    Sender MAC address: IntelCor_75:21:32 (38:00:25:75:21:32)</span><br><span class="line">    Sender IP address: 192.168.31.100</span><br><span class="line">    Target MAC address: Apple_e2:a1:2e (4c:20:b8:e2:a1:2e)</span><br><span class="line">    Target IP address: 192.168.31.15</span><br></pre></td></tr></table></figure>
<p>但是 ARP 响应包，前后都是一样的。</p>
<p><img src="/2021/06/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8Aweek13/7.png" style="zoom:67%;"></p>
<p>这时候我们已经发现，刚才ping 的 192.168.31.100 的mac地址已经添加到arp缓存表中去了，而且我们发现，这个地址和我开虚拟机的电脑的地址是一模一样的。</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/" itemprop="url">计算机网络-网络层</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-06-02T15:52:12+08:00">
                2021-06-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2025-04-09T23:27:02+08:00">
                2025-04-09
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="计算机网络-网络层"><a href="#计算机网络-网络层" class="headerlink" title="计算机网络-网络层"></a>计算机网络-网络层</h1><p>学习自：<a href="https://github.com/crisxuan/bestJavaer/blob/master/computer-network/computer-internet.md" target="_blank" rel="noopener">https://github.com/crisxuan/bestJavaer/blob/master/computer-network/computer-internet.md</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/126754314" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/126754314</a></p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/1.png"></p>
<p>之前我们说了应用层和运输层。运输层是提供进程的端到端通信。那么下面我们将学习网络层是怎样实现主机到主机的通信服务的。<strong>几乎每个端系统都有网络层这一部分</strong>，所以，网络层必然是很复杂的。</p>
<h3 id="网络服务模型"><a href="#网络服务模型" class="headerlink" title="网络服务模型"></a>网络服务模型</h3><p>因特网的网络层提供了单一的服务，即<strong>尽力而为</strong>。 这让传送的分组不能保证以它们发送的顺序被接收，也不能保证它们最终交付；既不能保证端到端时延，也不能保证最小有效带宽。尽管什么都不保证，但是这种服务模型却能满足大多数网络服务。</p>
<h2 id="网络层概述"><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h2><p>网络层是OSI的第三层，它位于传输层和链路层之间，网络层的主要目的是实现两个端系统之间透明的数据传输。</p>
<blockquote>
<p>TCP/IP 把表示层和会话层都归入了应用层。</p>
</blockquote>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/2.png"></p>
<p>网络层可以分成两种平面，在第四章主要讲的是数据平面，负责<strong>转发网络流量</strong>，如路由器交换机中的转发表；在第五章主要讲的是控制平面, 作用是控制网络的行为，比如<strong>网络路径的选择(路由)</strong>。</p>
<p>网络层的作用从表面看上去非常简单，即将<code>分组</code><strong>从一台主机移动到另外一台主机</strong>。为了实现这个功能，网络层需要两种功能</p>
<ul>
<li><code>转发</code>：因为在互联网中有很多<code>路由器</code>的存在，而路由器是构成互联网的根本，路由器最重要的一个功能就是<code>分组转发</code>，当一个分组到达某路由器的一条输入链路时，该路由器会将分组移动到适当的输出链路。转发是在数据平面中实现的唯一功能。</li>
<li><code>路由选择</code>： 当分组由发送方流向接收方时，网络层必须选择这些分组的路径。计算这些路径选择的算法被称为 <code>路由选择算法(routing algorithm)</code>。</li>
</ul>
<p>也就是说，转发是指<strong>将分组从一个输入链路转移到适当输出链路接口的路由器本地动作</strong>，而路由选择是指<strong>确定分组从源到目的地锁定为的路径的选择</strong>。我们后面会经常提到。</p>
<blockquote>
<p> 那么，路由器怎么知道有哪些路径可以选择呢？</p>
</blockquote>
<p>每台路由器都有一个关键的概念就是 <code>转发表(forwarding table)</code>。路由器通过检查数据包标头中字段的值，来定位转发表中的项来实现转发。标头中的值即对应着转发表中的值，这个值指出了分组将被转发的路由器输出链路。如下图所示: </p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/3.png"></p>
<p>上图中有一个 1001 分组到达路由器后，首先会在转发表中进行索引，然后由路由选择算法决定分组要走的路径。每台路由器都有两种功能：<strong>转发和路由选择</strong>。下面我们就来聊一聊路由器的工作原理。</p>
<h2 id="数据层面"><a href="#数据层面" class="headerlink" title="数据层面"></a>数据层面</h2><h3 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h3><p>下面是一个路由器体系的体系结构图，路由器主要是由4个组件组成：</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/4.png"></p>
<ul>
<li>输入端口：<code>输入端口(input port)</code>有很多功能。<code>线路终端功能</code>和<code>数据链路处理</code>功能，这两个功能实现了路由器的单个输入链路相关联的物理层和数据链路层。<code>输入端口查找/转发功能</code>对路由器的交换功能来说至关重要，由路由器的交换结构来决定输出端口，具体来讲应该是<strong>查询转发表</strong>来确定的。</li>
<li>(高速)交换结构：<code>交换结构(Switching fabric)</code>就是将路由器的输入端口连接到它的输出端口。这种交换结构相当于是<strong>路由器内部的网络</strong>。</li>
<li>输出端口：<code>输出端口(Output ports)</code> 通过交换结构转发分组，并通过物理层和数据链路层的功能传输分组，因此，输出端口作为输入端口执行反向数据链接和物理层功能。</li>
<li>路由选择处理器：<code>路由选择处理器(Routing processor)</code> 在路由器内执行路由协议，维护路由表并执行网络管理功能。这属于控制平面的内容</li>
</ul>
<h4 id="输入端口"><a href="#输入端口" class="headerlink" title="输入端口"></a>输入端口</h4><p>上面介绍了输入端口有很多功能，包括线路终端、数据处理、查找转发，其实这些功能在输入端口的内部有相应的模块，输入端口的内部实现如下图所示</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/5.png"> </p>
<p>每个输入端口中都有一个路由处理器维护的<strong>路由表的副本</strong>，根据路由处理器进行更新。这个路由表的副本能 够使每个输入端口进行切换，而无需经过路由处理器统一处理。这是一种<code>分散式</code>的切换，这种方式避免了路 由选择器统一处理造成转发瓶颈。</p>
<p>在输入端口处理能力有限的路由器中，输入端口不会进行交换功能，而是由路由处理器统一处理，然后根据 路由表查找并将数据包转发到相应的输出端口。</p>
<blockquote>
<p>一般这种路由器不是单独的路由器，而是工作站或者服务器充当的路由，这种路由器内部中，路由处理器其实就是 <code>CPU</code>，而输入端口其实只是<code>网卡</code>。</p>
</blockquote>
<p>输入端口会根据转发表定位输出端口，然后再会进行分组转发，那么现在就有一个问题，是不是每一个分组都有自己的一条链路呢？如果分组数量非常大，到达亿级的话，也会有亿个输出端口路径吗？</p>
<p>我们的潜意识中显然不是的，来看下面一个例子。</p>
<p>下面是三个输入端口对应了转发表中的三个输出链路的示例</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/6.png"></p>
<p>可以看到，对于这个例子来说，路由器转发表中不需要那么多条链路，只需要四条就够，即对应输出链路 0 1 2 3 。也就是说，能够使用 4 个转发表就可以实现亿级链路。</p>
<blockquote>
<p>如何实现呢？</p>
</blockquote>
<p>使用这种风格的转发表，路由器分组的地址 <code>前缀(prefix)</code> 会与该表中的表项进行匹配。</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/7.png"></p>
<p>如果存在一个匹配项，那么就会转发到对应的链路上，可能不好理解，我举个例子来说吧。</p>
<p>比如这时有一个分组是 <code>11000011 10010101 00010000 0001100</code>到达，因为这个分组与 <code>11000011 10010101 00010000</code>相匹配，所以路由器会转发到 0 链路接口上。如果一个前缀不匹配上面三个输出链路中的一种，那么路由器将向链路接口 3 进行转发。</p>
<p>路由匹配遵循 <code>最长前缀匹配原则(longest prefix matching rule)</code>，最长匹配原则故名思义就是如果有两个匹配项一个长一个短的话，<strong>就匹配最长的</strong>。</p>
<p>一旦通过查找功能确定了分组的输出端口后，那么该分组就会<strong>进入交换结构</strong>。在进入交换结构时，如果交换结构正在被使用，<strong>就会阻塞新到的分组</strong>，等到交换结构调度新的分组。</p>
<h4 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h4><p>交换结构是路由器的核心功能，通过交换功能把分组从输入端口转发至输出端口，这就是交换结构的主要功能。交换结构有多种形式，主要分为 <strong>通过内存交换、通过总线交换、通过互联网络进行交换</strong>，下面我们分开来探讨一下。</p>
<ul>
<li>经过内存交换：最开始的传统计算机就是使用<code>内存交换</code>的，在输入端口和输出端口之间是通过 CPU 进行的。输入端口和输出端口的功能就好像传统操作系统中的 I/O 设备一样。当一个分组到达输入端口时，这个端口会首先以<code>中断</code> 的方式向路由选择器发出信号，将分组从输入端口拷贝到内存中。然后，路由选择处理器从分组首部中提取目标地址，在转发表中找出适当的输出端口进行转发，同时将分组复制到输出端口的缓存中。这种方式比较低效，早期的路由器都是以这种方式实现的。</li>
</ul>
<blockquote>
<p>这里需要注意一点，如果内存带宽以每秒读取或者写入 B 个数据包，那么总的交换机吞吐量(数据包从输入端口到输出端口的总速率) 必须小于 B/2。</p>
</blockquote>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/8.png"></p>
<ul>
<li>经过总线交换：在这种处理方式中，总线经由输入端口<strong>直接</strong>将分组传送到输出端口，中间<strong>不需要路由选择器的干预</strong>。总线的工作流程如下：输入端口给分组分配一个<code>标签</code>，然后分组经由总线发送给<strong>所有的输出端口</strong>，每个输出端口都会判断标签中的端口和自己的是否匹配，如果匹配的话，那么这个输出端口就会把标签拆掉，这个标签只用于交换机内部跨越总线。如果同时有 <code>多个</code> 分组到达路由器的话，那么只有一个分组能够被处理，其他分组需要再进入交换结构前等待。也就是说这对总线的带宽要求很高。</li>
</ul>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/9.png"></p>
<ul>
<li>经过互联网络交换：这是一种纵横式的交换网络。它能克服单一、共享式总线带宽限制。它使输入端口和输出端口两两之间都有一条网路。如下图所示</li>
</ul>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/10.png"></p>
<h4 id="输出端口处理"><a href="#输出端口处理" class="headerlink" title="输出端口处理"></a>输出端口处理</h4><p>如下图所示，输出端口处理取出已经存放在输出端口内存中的分组并将其发送到输出链路上。包括选择和去除排队的分组进行传输，执行所需的链路层和物理层的功能。</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/11.png"></p>
<p>在输入端口中有等待进入交换的排队队列，而在输出端口中<strong>有等待转发的排队队列</strong>，排队的位置和程度取决于<strong>流量负载、交换结构</strong>的相对频率和线路速率。</p>
<p>随着队列的不断增加，会导致路由器的缓存空间被耗尽，进而使没有内存可以存储溢出的队列，致使分组出现<code>丢包(packet loss)</code>，这就是我们说的在网络中丢包或者被路由器丢弃。于是，接下来我们来讲一下排队。</p>
<h3 id="路由器出现排队"><a href="#路由器出现排队" class="headerlink" title="路由器出现排队"></a>路由器出现排队</h3><p>下面我们通过输入端口的排队队列和输出端口的排队队列来介绍一下可能出现的排队情况。</p>
<h4 id="输入队列-HOL阻塞"><a href="#输入队列-HOL阻塞" class="headerlink" title="输入队列(HOL阻塞)"></a>输入队列(HOL阻塞)</h4><p>如果<strong>交换结构的处理速度没有输入队列到达的速度快</strong>，在这种情况下，输入端口将会出现排队情况，到达交换结构前的分组会加入输入端口队列中，以等待通过交换结构传送到输出端口。</p>
<p>为了描述清楚输入队列，我们假设以下情况：</p>
<ul>
<li>使用网络互联(crossbar)的交换方式；</li>
<li>假定所有链路的速度相同；</li>
<li>在链路中一个分组由输入端口交换到输出端口所花的时间相同，从任意一个输入端口传送到给定的输出端口；</li>
<li>分组按照 FCFS 的方式，只要输出端口不同，就可以进行并行传送。但是如果位于任意两个输入端口中的分组是发往同一个目的地的，那么其中的一个分组将被阻塞，而且必须在输入队列中等待，因为交换结构一次只能传输一个到指定端口。</li>
</ul>
<p>如下图所示</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/12.png"></p>
<p>在 A 队列中，输入队列中的两个分组会发送至同一个目的地 X，假设在交换结构正要发送 A 中的分组，在这个时候，C 队列中也有一个分组发送至 X，在这种情况下，C 中发送至 X 的分组将会等待，不仅如此，C 队列中发送至 Y 输出端口的分组也会等待，即使 Y 中没有出现竞争的情况。这种现象叫做 <code>线路前部阻塞(Head-Of-The-Line, HOL)</code> 。</p>
<p>也就是说，在一个输入队列中排队的分组<strong>必须</strong>等待通过交换结构发送，即使输出端口是空的，因为它被位于线路前部的另一个分组所阻塞了。</p>
<h4 id="输出队列"><a href="#输出队列" class="headerlink" title="输出队列"></a>输出队列</h4><p>我们下面讨论输出队列中出现等待的情况。假设<strong>交换速率要比输入/输出的传输速率快很多</strong>，而且有 N 个输入分组的目的地是转发至相同的输出端口。在这种情况下，在向输出链路发送分组的过程中，将会有 N 个新分组到达传输端口。因为输出端口在一个单位时间内只能传输一个分组，那么这 N 个分组将会等待。然而在等待 N 个分组被处理的过程中，同时又有 N 个分组到达，所以 ，分组队列能够在输出端口形成。这种情况下最终会因为分组数量变的足够大，从而<code>耗尽</code> 输出端口的可用内存。</p>
<p>如果没有足够的内存来缓存分组的话，就必须考虑其他的方式，主要有两种：一种是丢失分组，采用 <code>弃尾(drop-tail)</code> 的方法；一种是删除一个或多个已经排队的分组，从而来为新的分组腾出空间。</p>
<blockquote>
<p>网络层的策略对 TCP 拥塞控制影响很大的就是路由器的分组丢弃策略。在最简单的情况下，路由器的队列通常都是按照 FCFS 的规则处理到来的分组。由于队列长度总是有限的，因此当队列已经满了的时候，以后再到达的所有分组（如果能够继续排队，这些分组都将排在队列的尾部）将都被丢弃。这就叫做尾部丢弃策略。</p>
</blockquote>
<p>通常情况下，在缓冲填满之前将其丢弃是更好的策略。</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/13.png"></p>
<p>如上图所示，A B C 每个输入端口都到达了一个分组，而且这个分组都是发往 X 的，同一时间只能处理一个分组，然后这时，又有两个分组分别由 A B 发往 X，所以此时有 4 个分组在 X 中进行等待。</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/14.png"></p>
<p>等上一个分组被转发完成后，输出端口就会选择在剩下的分组中根据 <code>分组调度(packet scheduleer)</code> 选择一个分组来进行传输，我们下面就会聊到分组调度</p>
<p>那么我们一般怎么来计算一个合理的缓冲区呢？ 我们的目标是不能丢包，但可以忍受排队。设 N 为TCP流的数目， C为链路的数量，RTT为往返时间</p>
<script type="math/tex; mode=display">
Buffer = \frac{RTT\cdot C}{\sqrt N}</script><h3 id="分组调度"><a href="#分组调度" class="headerlink" title="分组调度"></a>分组调度</h3><p>现在我们来讨论一下分组调度次序的问题，即排队的分组如何经输出链路传输的问题。我们生活中有无数排队的例子，但是我们生活中一般的排队算法都是 <code>先来先服务(FCFS)</code>，也是<code>先进先出(FIFO)</code>。</p>
<h4 id="先进先出"><a href="#先进先出" class="headerlink" title="先进先出"></a>先进先出</h4><p>先进先出就映射为数据结构中的<code>队列</code>，只不过它现在是链路调度规则的排队模型。</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/15.png"></p>
<p>FIFO 调度规则按照分组到达输出链路队列的相同次序来选择分组，先到达队列的分组将先会被转发。在这种抽象模型中，如果队列已满，那么弃尾的分组将是队列末尾的后面一个。</p>
<h4 id="优先级排队"><a href="#优先级排队" class="headerlink" title="优先级排队"></a>优先级排队</h4><p>优先级排队是先进先出排队的改良版本，到达输出链路的分组被分类放入输出队列中的优先权类，如下图所示</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/16.png"></p>
<p>通常情况下，每个优先级不同的分组有自己的优先级类，每个优先级类有自己的队列，分组传输会首先从优先级高的队列中进行，在同一类优先级的分组之间的选择通常是以 FIFO 的方式完成。</p>
<h4 id="循环加权公平排队"><a href="#循环加权公平排队" class="headerlink" title="循环加权公平排队"></a>循环加权公平排队</h4><p>在<code>循环加权公平规则(round robin queuing discipline)</code> 下，分组像使用优先级那样被分类。然而，在类之间却<strong>不存在严格的服务优先权</strong>。循环调度器在这些类之间循环轮流提供服务。如下图所示</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/17.png"></p>
<p>在循环加权公平排队中，类 1 的分组被传输，接着是类 2 的分组，最后是类 3 的分组，这算是一个循环，然后接下来又重新开始，又从 1 -&gt; 2 -&gt; 3 这个顺序进行轮询。每个队列也是一个先入先出的队列。</p>
<p>这是一种所谓的<code>保持工作排队(work-conserving queuing)</code> 的规则，就是说如果轮询的过程中发现有空队列，输出端口不会等待分组，而是继续轮询下面的队列。</p>
<h3 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h3><p>路由器对分组进行转发后，就会把数据包传到网络上，数据包最终是要传递到客户端或者服务器上的，那么数据包怎么知道要发往哪里呢？起到关键作用的就是 IP 协议。</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/18.png"></p>
<p>IP 主要分为三个部分，分别是 <strong>IP 寻址、路由和分包组包</strong>。下面我们主要围绕这三点进行阐述。</p>
<h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><p>既然一个数据包要在网络上传输，那么肯定需要知道这个数据包到底发往哪里，也就是说需要一个目标地址信息，<strong>IP 地址就是连接网络中的所有主机进行通信的目标地址</strong>，因此，在网络上的每个主机都需要有自己的 IP 地址。</p>
<p>在 IP 数据报发送的链路中，有可能链路非常长，比如说由中国发往美国的一个数据报，由于网络抖动等一些意外因素可能会导致数据报丢失，这时我们在这条链路中会放入一些 <code>中转站</code>，一方面能够确保数据报是否丢失，另一方面能够控制数据报的转发，这个中转站就是我们前面聊过的路由器，这个转发过程就是 <code>路由控制</code>。</p>
<p><code>路由控制(Routing)</code> 是指将分组数据发送到最终目标地址的功能，即使网络复杂多变，也能够通过路由控制到达目标地址。因此，一个数据报能否到达目标主机，关键就在于路由器的控制。</p>
<p>这里有一个名词，就是 <code>跳</code>，因为在一条链路中可能会布满很多路由器，路由器和路由器之间的数据报传送就是跳，比如你和隔壁老王通信，中间就可能会经过路由器 A-&gt; 路由器 B -&gt; 路由器 C 。</p>
<blockquote>
<p>那么一跳的范围有多大呢？</p>
</blockquote>
<p><strong>一跳是指从源 MAC 地址到目标 MAC 地址之间传输帧的区间</strong>，这里引出一个新的名词，MAC 地址是啥？</p>
<p>MAC 地址指的就是计算机的<code>物理地址(Physical Address)</code>，它是用来确认网络设备位置的地址。在 OSI 网络模型中，网络层负责 IP 地址的定位，而数据链路层负责 MAC 地址的定位。MAC 地址用于在网络中<strong>唯一标示一个网卡</strong>，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的 MAC 地址，也就是说 MAC 地址和网卡是紧密联系在一起的。</p>
<p>路由器的每一跳都需要询问当前中转的路由器，下一跳应该跳到哪里，从而跳转到目标地址。而不是数据报刚开始发送后，网络中所有的通路都会显示出来。这种多次跳转也叫做<code>多跳路由</code>。在一定数量的<code>跳</code> 之后，数据报就会失去作用，被丢掉。</p>
<h5 id="IP地址的定义"><a href="#IP地址的定义" class="headerlink" title="IP地址的定义"></a>IP地址的定义</h5><p>现如今有两个版本的 IP 地址，IPv4 和 IPv6，我们首先探讨一下现如今还在广泛使用的 IPv4 地址，后面再考虑 IPv6 。</p>
<p>IPv4 由 32 位正整数来表示，在计算机内部会转化为二进制来处理，但是二进制不符合人类阅读的习惯，所以我们根据<code>易读性</code>的原则把 32 位的 IP 地址以 8 位为一组，分成四组，每组之间以 <code>.</code> 进行分割，再将每组转换为十进制数。如下图所示</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/20.png" style="zoom:50%;"></p>
<p>那么上面这个 32 位的 IP 地址就会被转换为十进制的 156.197.1.1。</p>
<p>除此之外，从图中我们还可以得到如下信息</p>
<p>每个这样 8 位位一组的数字，自然是非负数，其取值范围是 [0,255]。</p>
<p>IP 地址的总个数有 $2^{32}$次幂个，这个数值算下来是 <code>4294967296</code> ，大概能允许 43 亿台设备连接到网络。实际上真的如此吗？</p>
<p>实际上 IP 不会以主机的个数来配置的，而是根据设备上的 <code>网卡(NIC)</code> 进行配置，每一块网卡都会设置一个或者多个 IP 地址，而且通常一台路由器会有至少两块网卡，所以可以设置两个以上的 IP 地址，所以主机的数量远远达不到 43 亿。 </p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/21.png" style="zoom:50%;"></p>
<h5 id="保留IP地址"><a href="#保留IP地址" class="headerlink" title="保留IP地址"></a>保留IP地址</h5><p>在IPv4 的几类地址中，有几个保留的地址空间不能在互联网上使用。这些地址用于特殊目的，不能在局域网外部路由。</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/25.png" style="zoom:50%;"></p>
<h5 id="IP-地址构造和分类"><a href="#IP-地址构造和分类" class="headerlink" title="IP 地址构造和分类"></a>IP 地址构造和分类</h5><p>IP 地址由 <code>网络标识</code> 和 <code>主机标识</code> 两部分组成，网络标识代表着网络地址，主机标识代表着主机地址。网络标识在数据链路的每个段配置不同的值。网络标识必须保证相互连接的每个段的地址都不重复。而相同段内相连的主机必须有相同的网络地址。IP 地址的 <code>主机标识</code> 则不允许在同一网段内重复出现。</p>
<h5 id="子网"><a href="#子网" class="headerlink" title="子网"></a>子网</h5><p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/22.png" style="zoom:50%;"></p>
<p>为了确定网络区域，分开主机和路由器的每个接口，从而产生了若干个分离的网络岛，接口端连接了这些独立网络的端点。这些独立的网络岛叫做<strong>子网</strong></p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/24.png" style="zoom:50%;"></p>
<p>上图一共有6个子网，因为根据定义，分开主机和路由器的每个接口所产生的网络岛都算一个子网。</p>
<h5 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h5><p><code>子网掩码(subnet mask)</code> 又叫做网络掩码，它是一种用来指明一个 IP 地址的哪些位标识的是主机所在的网络。子网掩码用于屏蔽 IP 地址的一部分<strong>以区别网络标识和主机标识</strong>。 比如说：</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/23.png" style="zoom:50%;"></p>
<p>上图中子网掩码有24位，也就是高位的24位相同的计算机IP地址属于一个子网。剩下的8位用来作为主机标识。也就是说，我们只要知道子网掩码，就可以计算出这个子网中最多有多少计算机(需要减去 0.0.0.0 和1.1.1.1) </p>
<p>从上面的介绍也可以看出，在一个子网中，如果主机多的话，是很容易导致地址冲突的，为此我们接下来要介绍动态地址分配协议: DHCP</p>
<h4 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h4><p>DHCP 的全称是： Dynamic Host Configuration Protocol .</p>
<p>首先在这个子网中有一个跑着DHCP的 Server. 它能帮助主机自动配置地址。</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/28.png"></p>
<p>DHCP server和client 之间的对话过程如上图所示。</p>
<ul>
<li>一开始client是没有地址的，因此默认为 0.0.0.0，向全域进行广播(广播地址是 255.255.255.255)。</li>
<li>DHCP server听到后会给予回应，向需要IP的主机提供IP地址(以下图为例): 223.1.2.4, 网络掩码: 223.1.2.0/24, 默认路由器: 223.1.2.5 以及本地DNS服务器的IP地址.</li>
<li>client收到后还是进行广播(因为此时仍然没有给其分配地址)</li>
<li>最后DHCP server会响应DHCP ACK报文，此时client正式拥有了地址</li>
</ul>
<p>这边IP地址是有<strong>租约</strong>的，为3600秒，在这之后如果主机还在线，则可以<strong>续约</strong>。</p>
<p><strong>DHCP不光会告诉你在子网的IP地址，还会告诉你DNS，网关和子网掩码。</strong></p>
<p>DHCP是应用层协议，其底层是通过UDP实现的。</p>
<h4 id="路由聚集"><a href="#路由聚集" class="headerlink" title="路由聚集"></a>路由聚集</h4><p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/29.png"></p>
<p>ISP会下发IP地址，同时通告那些IP地址是我管辖的。</p>
<p>ISP又会向ICANN申请地址。</p>
<p>那么路由聚集有什么好处呢？ 答：可以方便管理。因为我总不能每买一台电脑就像电信局打电话申请一个IP地址，肯定是在一个子网里面分配地址。这样一来，意味着一个子网只通过接入IP地址的<strong>部分前缀</strong>和外部因特网相连, 外界并不关心子网内还存在着多个组织, 这种使用单个网络前缀通告多个网络的能力通常称为路由聚集。而且这个做法相当大地减少了在这些路由器中转发表的长度. </p>
<p>那么子网中不同的电脑怎么和外界进行交流呢？ 比如下图，子网中有三台电脑，IP地址各不相同，但是出去的时候，都是一个地址 <code>138.76.29.7</code> . 在子网中，通过不同的端口来判断不同的主机</p>
<ul>
<li>10.0.0.1 这个主机要通过3345端口发送一条信息</li>
<li>信息交给NAT router之后，就变成 138.76.29.7 ，5001端口发出</li>
<li>反馈信息在138.76.29.7 的5001端口收到之后，经过NAT router之后就传到变成10.0.0.1的3345串口</li>
</ul>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/30.png"></p>
<h4 id="IPV4"><a href="#IPV4" class="headerlink" title="IPV4"></a>IPV4</h4><p>IPv4 的全称是 <code>Internet Protocol version 4</code>，是 Internet 协议的第四版。IPv4 是一种无连接的协议，这个协议会尽最大努力交付数据包，也就是说它不能保证任何数据包能到达目的地，也不能保证所有的数据包都会按照正确的顺序到达目标主机，这些都是由上层比如传输控制协议控制的。也就是说，单从 IP 看来，这是一个不可靠的协议。</p>
<blockquote>
<p>前面我们讲过网络层分组被称为 <code>数据报</code>，所以我们接下来的叙述也会围绕着数据报展开。</p>
</blockquote>
<p>IPv4 的数据报格式如下</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/19.png"></p>
<p>上图我们也看出来了，TCP和数据报报文段首部都是20字节，加在一起，40字节是必要的。</p>
<p>在IP数据报中有很多信息：</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/1.jpg" style="zoom:50%;"></p>
<ul>
<li><code>版本字段(Version)</code>占用 4 bit，通信双方使用的版本必须一致，对于 IPv4 版本来说，字段值是 4。</li>
<li><code>首部长度(Internet Header Length)</code> 占用 4 bit，首部长度说明首部有多少 32 位(4 字节)。由于 IPv4 首部可能包含不确定的选项，因此这个字段被用来确定数据的偏移量。大多数 IP 不包含这个选项，所以一般首部长度设置为 5， 数据报为 20 字节 。</li>
<li><code>服务类型(Differential Services Codepoint，DSCP)</code> 占用 6 bit，以便使用不同的 IP 数据报，比如一些低时延、高吞吐量和可靠性的数据报。服务类型如下表所示</li>
</ul>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/26.png" style="zoom:50%;"></p>
<ul>
<li><p><code>拥塞通告(Explicit Congestion Notification，ECN)</code> 占用 2 bit，它允许在不丢弃报文的同时通知对方网络拥塞的发生。ECN 是一种可选的功能，仅当两端都支持并希望使用，且底层网络支持时才被使用。 最开始 DSCP 和 ECN 统称为 TOS，也就是区分服务，但是后来被细化为了 DSCP 和 ECN。</p>
</li>
<li><p><code>数据报长度(Total Length)</code> 占用 16 bit，这 16 位是包括在数据在内的总长度，理论上数据报的总长度为 2 的 16 次幂 - 1，最大长度是 65535 字节，但是实际上数据报很少有超过 1500 字节的。IP 规定所有主机都必须支持最小 576 字节的报文，但大多数现代主机支持更大的报文。当下层的数据链路协议的<code>最大传输单元（MTU）</code>字段的值小于 IP 报文长度时，报文就必须被分片。</p>
</li>
<li><p><code>标识符(Identification)</code> 占用 16 bit，这个字段用来标识所有的分片，因为分片不一定会按序到达，所以到达目标主机的所有分片会进行重组，每产生一个数据报，计数器加1，并赋值给此字段。</p>
</li>
<li><p><code>标志(Flags)</code> 占用 3 bit，标志用于控制和识别分片，这 3 位分别是</p>
<ul>
<li>0 位：保留，必须为0；</li>
<li>1 位：<code>禁止分片（Don’t Fragment，DF）</code>，当 DF = 0 时才允许分片；</li>
<li>2 位：<code>更多分片（More Fragment，MF）</code>，MF = 1 代表后面还有分片，MF = 0 代表已经是最后一个分片。</li>
</ul>
<p>如果 DF 标志被设置为 1 ，但是路由要求必须进行分片，那么这条数据报回丢弃</p>
</li>
<li><p><code>分片偏移(Fragment Offset)</code> 占用 13 位，它指明了每个分片相对于原始报文开头的偏移量，以 8 字节作单位。</p>
</li>
<li><p><code>存活时间(Time To Live，TTL)</code> 占用 8 位，存活时间避免报文在互联网中<code>迷失</code>，比如陷入路由环路。存活时间以秒为单位，但小于一秒的时间均向上取整到一秒。在现实中，这实际上成了一个跳数计数器：报文经过的每个路由器都将此字段减 1，当此字段等于 0 时，报文不再向下一跳传送并被丢弃，这个字段最大值是 255。</p>
</li>
<li><p><code>协议(Protocol)</code> 占用 8 位，这个字段定义了报文数据区使用的协议。协议内容可以在 <a href="https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml" target="_blank" rel="noopener">https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml</a> 官网上获取。比如值为6表明交给TCP, 值为17表明交给UDP.</p>
</li>
<li><p><code>首部校验和(Header Checksum)</code> 占用 16 位，首部校验和会对字段进行纠错检查，在每一跳中，路由器都要重新计算出的首部检验和并与此字段进行比对，如果不一致，此报文将会被丢弃。</p>
</li>
<li><p><code>源地址(Source address)</code> 占用 32 位，它是 IPv4 地址的构成条件，源地址指的是数据报的发送方</p>
</li>
<li><p><code>目的地址(Destination address)</code>占用 32 位，它是 IPv4 地址的构成条件，目标地址指的是数据报的接收方</p>
</li>
<li><p><code>选项(Options)</code> 是附加字段，选项字段占用 1 - 40 个字节不等，一般会跟在目的地址之后。如果首部长度 &gt; 5，就应该考虑选项字段。</p>
</li>
<li><p><code>数据</code> 不是首部的一部分，因此并不被包含在首部检验和中。</p>
</li>
</ul>
<h5 id="IPv4-分片"><a href="#IPv4-分片" class="headerlink" title="IPv4 分片"></a>IPv4 分片</h5><p>一个链路层帧能承载的最大数据量叫做<code>最大传输单元(Maximum Transmission Unit, MTU)</code>，每个 IP 数据报封装在链路层帧中从一台路由器传到下一台路由器。因为每个链路层所支持的最大 MTU 不一样，当数据报的大小超过 MTU 后，会在链路层进行分片，每个数据报会在链路层单独封装，每个较小的片都被称为 <code>片(fragement)</code>。</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/27.png" style="zoom:50%;"></p>
<p>每个片在到达目的地后会进行重组，准确的来说是在运输层之前会进行重组，TCP 和 UDP 都会希望发送完整的、未分片的报文，出于性能的原因，分片重组不会在路由器中进行，而是会在目标主机中进行重组。</p>
<p>当目标主机收到从发送端发送过来的数据报后，它需要确定这些数据报中的分片是否是由源数据报分片传递过来的，如果是的话，还需要确定何时收到了分片中的<code>最后一片</code>，并且这些片会如何拼接一起成为数据报。</p>
<p>针对这些潜在的问题，IPv4 设计者将 <strong>标识、标志和片偏移</strong>放在 IP 数据报首部中。当生成一个数据报时，发送主机会为该数据报设置源和目的地址的同时贴上<code>标识号</code>。发送主机通常将它发送的每个数据报的标识 + 1。当某路由器需要对一个数据报分片时，形成的每个数据报具有初始数据报的<strong>源地址、目标地址和标识号</strong>。当目的地从同一发送主机收到一系列数据报时，它能够检查数据报的标识号以确定哪些数据是由源数据报发送过来的。由于 IP 是一种不可靠的服务，分片可能会在网路中丢失，鉴于这种情况，通常会把分片的最后一个比特设置为 0 ，其他分片设置为 1，同时使用偏移字段指定分片应该在数据报的哪个位置。</p>
<h5 id="IPv4-寻址"><a href="#IPv4-寻址" class="headerlink" title="IPv4 寻址"></a>IPv4 寻址</h5><p>IPv4 支持三种不同类型的寻址模式，分别是</p>
<ul>
<li>单播寻址模式：在这种模式下，数据只发送到一个目的地的主机。</li>
</ul>
<h4 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h4><p>随着端系统接入的越来越多，IPv4 已经无法满足分配了，所以，IPv6 应运而生，IPv6 就是为了解决 IPv4 的地址耗尽问题而被标准化的网际协议。IPv4 的地址长度为 4 个 8 字节，即 32 比特， 而 IPv6 的地址长度是原来的四倍，也就是 128 比特，一般写成 8 个 16 位字节。</p>
<p>从 IPv4 切换到 IPv6 及其耗时，需要将网络中所有的主机和路由器的 IP 地址进行设置，在互联网不断普及的今天，替换所有的 IP 是一个工作量及其庞大的任务。我们后面会说。</p>
<p>我们先来看一下 IPv6 的地址是怎样的</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/31.png" style="zoom:50%;"></p>
<ul>
<li><code>版本</code>与 IPv4 一样，版本号由 4 bit 构成，IPv6 版本号的值为 6。</li>
<li><code>流量类型(Traffic Class)</code> 占用 8 bit，它就相当于 IPv4 中的服务类型(Type Of Service)。</li>
<li><code>流标签(Flow Label)</code> 占用 20 bit，这 20 比特用于标识一条数据报的流，能够对一条流中的某些数据报给出优先权，或者它能够用来对来自某些应用的数据报给出更高的优先权，只有流标签、源地址和目标地址一致时，才会被认为是一个流。</li>
<li><code>有效载荷长度(Payload Length)</code> 占用 16 bit，这 16 比特值作为一个无符号整数，它给出了在 IPv6 数据报中跟在鼎昌 40 字节数据报首部后面的字节数量。</li>
<li><code>下一个首部(Next Header)</code> 占用 8 bit，它用于标识数据报中的内容需要交付给哪个协议，是 TCP 协议还是 UDP 协议。</li>
<li><code>跳限制(Hop Limit)</code> 占用 8 bit，这个字段与 IPv4 的 TTL 意思相同。数据每经过一次路由就会减 1，减到 0 则会丢弃数据。</li>
<li><code>源地址(Source Address)</code> 占用 128 bit (8 个 16 位 )，表示发送端的 IP 地址。</li>
<li><code>目标地址(Destination Address)</code> 占用 128 bit (8 个 16 位 )，表示接收端 IP 地址。</li>
</ul>
<p>可以看到，相较于 IPv4 ，IPv6 取消了下面几个字段</p>
<ul>
<li><strong>标识符、标志和比特偏移</strong>：IPv6 不允许在中间路由器上进行分片和重新组装。这种操作只能在端系统上进行，IPv6 将这个功能放在端系统中，加快了网络中的转发速度。</li>
<li><strong>首部校验和</strong>：因为在运输层和数据链路执行了报文段完整性校验工作，IP 设计者大概觉得在网络层中有首部校验和比较多余，所以去掉了。<strong>IP 更多专注的是快速处理分组数据</strong>。</li>
<li><strong>选项字段</strong>：选项字段不再是标准 IP 首部的一部分了，但是它并没有消失，而是可能出现在 IPv6 的扩展首部，也就是下一个首部中。</li>
</ul>
<h4 id="IPv6-扩展首部"><a href="#IPv6-扩展首部" class="headerlink" title="IPv6 扩展首部"></a>IPv6 扩展首部</h4><p>IPv4 首部长度固定，无法将选项字段加入其中，取而代之的是 IPv6 使用了<code>扩展首部</code></p>
<p>扩展首部通常介于 IPv6 首部与 TCP/UDP 首部之间，在 IPv4 中可选长度固定为 40 字节，在 IPv6 中没有这样的限制。IPv6 的扩展首部可以是任意长度。扩展首部中还可以包含扩展首部协议和下一个扩展字段。</p>
<p>IPv6 首部中没有标识和标志字段，<strong>对 IP 进行分片时，需要使用到扩展首部</strong>。</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/32.png" style="zoom:50%;"></p>
<p>具体的扩展首部表如下所示</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/33.png" style="zoom:50%;"></p>
<p>下面我们来看一下 IPv6 都有哪些特点</p>
<h4 id="IPv6-特点"><a href="#IPv6-特点" class="headerlink" title="IPv6 特点"></a>IPv6 特点</h4><p>IPv6 的特点在 IPv4 中得以实现，但是即便实现了 IPv4 的操作系统，也未必实现了 IPv4 的所有功能。而 IPv6 却将这些功能大众化了，也就表明这些功能在 IPv6 已经进行了实现，这些功能主要有</p>
<ul>
<li><strong>地址空间变得更大</strong>：这是 IPv6 最主要的一个特点，即支持更大的地址空间。</li>
<li><strong>精简报文结构</strong>: IPv6 要比 IPv4 精简很多，IPv4 的报文长度不固定，而且有一个不断变化的选项字段；IPv6 报文段固定，并且将选项字段，分片的字段移到了 IPv6 扩展头中，这就极大的精简了 IPv6 的报文结构。</li>
<li><strong>实现了自动配置</strong>：IPv6 支持其主机设备的<strong>状态和无状态</strong>自动配置模式。这样，没有 <code>DHCP 服务器</code>不会停止跨段通信。</li>
<li><strong>层次化的网络结构</strong>： IPv6 不再像 IPv4 一样按照 A、B、C等分类来划分地址，而是通过 IANA -&gt; RIR -&gt; ISP 这样的顺序来分配的。IANA 是国际互联网号码分配机构，RIR 是区域互联网注册管理机构，ISP 是一些运营商（例如电信、移动、联通）。</li>
<li><strong>IPSec</strong>：IPv6 的扩展报头中有一个认证报头、封装安全净载报头，这两个报头是 IPsec 定义的。通过这两个报头网络层自己就可以实现端到端的安全，而无需像 IPv4 协议一样需要其他协议的帮助。</li>
<li><strong>支持任播</strong>：IPv6 引入了一种新的寻址方式，称为任播寻址。</li>
</ul>
<h4 id="IPv6-地址"><a href="#IPv6-地址" class="headerlink" title="IPv6 地址"></a>IPv6 地址</h4><p>我们知道，IPv6 地址长度为 128 位，他所能表示的范围是 2 ^ 128 次幂，这个数字非常庞大，几乎涵盖了你能想到的所有主机和路由器，那么 IPv6 该如何表示呢？</p>
<p>一般我们将 128 比特的 IP 地址以每 16 比特为一组，并用 <code>:</code> 号进行分隔，如果出现连续的 0 时还可以将 0 省略，并用 <code>::</code> 两个冒号隔开，记住，一个 IP 地址只允许出现一次两个连续的冒号。</p>
<p>下面是一些 IPv6 地址的示例</p>
<ul>
<li>二进制数表示</li>
</ul>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/34.png" style="zoom:50%;"></p>
<ul>
<li>用十六进制数表示</li>
</ul>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/35.png" style="zoom:50%;"></p>
<ul>
<li>出现两个冒号的情况</li>
</ul>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/36.png" style="zoom:50%;"></p>
<p>如上图所示，A120 和 4CD 中间的 0 被 :: 所取代了。</p>
<h3 id="如何从-IPv4-迁移到-IPv6"><a href="#如何从-IPv4-迁移到-IPv6" class="headerlink" title="如何从 IPv4 迁移到 IPv6"></a>如何从 IPv4 迁移到 IPv6</h3><p>我们上面聊了聊 IPv4 和 IPv6 的报文格式、报文含义是什么、以及 IPv4 和 IPv6 的特征分别是什么，看完上面的内容，你已经知道了 IPv4 现在马上就变的不够用了，而且随着 IPv6 的不断发展和引用，虽然新型的 IPv6 可以做到<code>向后兼容</code>，即 IPv6 可以收发 IPv4 的数据报，但是<strong>已经部署的具有 IPv4 能力的系统却不能够处理 IPv6 数据报</strong>。所以 IPv4 噬需迁移到 IPv6，迁移并不意味着将 IPv4 替换为 IPv6。这仅意味着同时启用 IPv6 和 IPv4。</p>
<blockquote>
<p>那么现在就有一个问题了，IPv4 如何迁移到 IPv6 呢？这就是我们接下来讨论的重点。</p>
</blockquote>
<h4 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h4><p>最简单的方式就是设置一个标志日，指定某个时间点和日期，此时全球的因特网机器都会在这时关机从 IPv4 迁移到 IPv6 。上一次重大的技术迁移是在 35 年前，但是很显然，不用我过多解释，这种情况肯定是 <code>不行的</code>。影响不可估量不说，如何保证全球人类都能知道如何设置自己的 IPv6 地址？一个设计数十亿台机器的标志日现在是想都不敢想的。</p>
<h4 id="隧道技术"><a href="#隧道技术" class="headerlink" title="隧道技术"></a>隧道技术</h4><p>现在已经在实践中使用的从 IPv4 迁移到 IPv6 的方法是 <code>隧道技术(tunneling)</code>。</p>
<blockquote>
<p>什么是隧道技术呢？</p>
</blockquote>
<p>隧道技术是一种使用互联网络的基础设施在网络之间的传输数据的方式，使用隧道传递的数据可以是不同协议的数据帧或包。使用隧道技术所遵从的协议叫做<code>隧道协议(tunneling protocol)</code>。隧道协议会将这些协议的数据帧或包封装在新的包头中发送。新的包头提供了路由信息，从而使封装的负载数据能够通过互联网络进行传递。</p>
<p>使用隧道技术一般都会建一个<code>隧道</code>，建隧道的依据如下：</p>
<p>比如两个 IPv6 节点(下方 B、E)要使用 IPv6 数据报进行交互，但是它们是经由两个 IPv4 的路由器进行互联的。那么我们就需要将 IPv6 节点和 IPv4 路由器组成一个隧道，如下图所示</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/37.png" style="zoom:50%;"></p>
<p>借助于隧道，在隧道发送端的 IPv6 节点可将整个 IPv6 数据报<strong>放到一个 IPv4 数据报的<code>数据(有效载荷)</code> 字段中</strong>，于是，IPv4 数据报的地址被设置为指向隧道接收端的 IPv6 的节点，比如上面的 E 节点。然后再发送给隧道中的第一个节点 C，如下所示</p>
<p> <img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/38.png" style="zoom:50%;"></p>
<p>隧道中间的 IPv4 提供路由，路由器不知道这个 IPv4 内部包含一个指向 IPv6 的地址。隧道接收端的 IPv6 节点收到 IPv4 数据报，会确定这个 IPv4 数据报含有一个 IPv6 数据报，通过观察数据报长度和数据得知。然后取出 IPv6 数据报，再为 IPv6 提供路由，就好像两个节点直接相连传输数据报一样。</p>
<h3 id="通用转发与SDN-软件定义网络"><a href="#通用转发与SDN-软件定义网络" class="headerlink" title="通用转发与SDN(软件定义网络)"></a>通用转发与SDN(软件定义网络)</h3><p>现在我们来讲通用转发和SDN, 其核心技术OpenFlow通过将网络设备的控制面与数据面分离开来，从而实现了网络流量的灵活控制，使网络作为管道变得更加智能，为核心网络及应用的创新提供了良好的平台。</p>
<p>在前面说的转发中，首先要查找目的IP地址(匹配)，然后将分组发送到特定输出端口(动作)。现在说的通用转发则是在一张表中就实现<code>匹配加动作</code>模式。而基于目的的转发可能意味着路由转发表非常庞大，且功能单一，不具有普遍性</p>
<p>下图就是SDN的模式</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/39.png" style="zoom:50%;"></p>
<p>利用分层的思想，SDN将数据与控制相分离。在控制层，包括具有逻辑中心化和可编程的控制器，可掌握全局网络信息。在数据层，包括交换机，仅提供简单的数据转发功能，可以快速处理匹配的数据包，适应流量日益增长的需求。两层之间采用开放的统一接口（如OpenFlow等）进行交互。控制器通过标准接口向交换机下发统一标准规则，交换机仅需按照这些规则执行相应的动作即可</p>
<p>使用了这张本地流表，当路由器收到一些垃圾网站的地址时，就可以直接丢弃了，相当于防火墙的功能。</p>
<h4 id="通用转发规则"><a href="#通用转发规则" class="headerlink" title="通用转发规则"></a>通用转发规则</h4><ul>
<li><p>Pattern: match values in packet header fields</p>
</li>
<li><p>Actions: for matched packet: drop, forward, modify, matched packet or send matched packet to controller </p>
</li>
<li><p>Priority: disambiguate overlapping patterns</p>
</li>
<li><p>Counters: <code>#bytes and #packets</code></p>
</li>
</ul>
<p>下面是一张流表，* 是通配符。比如收到来自<code>1.2.*.*</code> 的数据报就直接丢掉</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/40.png" style="zoom:50%;"></p>
<p>Openflow 可以通过MAC地址进行匹配,也可以通过IP地址进行匹配。</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/41.png" style="zoom:50%;"></p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/42.png" style="zoom:50%;"></p>
<ul>
<li>第一个例子，从 <code>51.6.0.8</code>来的包就转发到port6</li>
<li>第二个例子，只要通过端口号22来的包就直接扔掉</li>
<li>第三个例子，所有来自主机 <code>128.119.1.1</code> 发来的包就直接丢掉</li>
<li>第四个例子，屏蔽了某个特殊的MAC地址</li>
</ul>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/43.png" style="zoom:50%;"></p>
<h5 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h5><p>P19. Consider the SDN OpenFlow network shown in Figure 4.30 . Suppose that the desiredforwarding behavior for datagrams arriving at s2 is as follows:</p>
<ul>
<li>any datagrams arriving on input port 1 from hosts h5 or h6 that are destined to hosts h1 or h2 should be forwarded over output port 2;</li>
<li>any datagrams arriving on input port 2 from hosts h1 or h2 that are destined to hosts h5 or h6 should be forwarded over output port 1;</li>
<li>any arriving datagrams on input ports 1 or 2 and destined to hosts h3 or h4 should be delivered to the host specified;</li>
<li>hosts h3 and h4 should be able to send datagrams to each other</li>
</ul>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/44.png" style="zoom:50%;"></p>
<p>Specify the flow table entries in s2 that implement this forwarding behavior</p>
<p>对于S2来说，接口1收到来自h5或者h6的包之后，需要通过接口2来转发给h1或者h2</p>
<p>同样的，接口2收到来自h1或者h2的包之后，需要通过接口1来转发给h5或者h6</p>
<p>因此可以这样写：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>匹配</th>
<th>动作</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ingress Port = 1,src= <code>10.3.*.*</code> ,Dst = <code>10.1.*.*</code></td>
<td>Forward(2)</td>
</tr>
<tr>
<td>Ingress Port = 2,src= <code>10.1*.*</code> ,Dst = <code>10.3.*.*</code></td>
<td>Forward(1)</td>
</tr>
</tbody>
</table>
</div>
<p>对于第三条要求，从接口1、2收到的数据报，要通过接口3、4定向发送到h3和h4</p>
<p>因此可以这样写：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>匹配</th>
<th>动作</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ingress Port = 1,Dst = <code>10.2.0.3</code></td>
<td>Forward(3)</td>
</tr>
<tr>
<td>Ingress Port = 1,Dst = <code>10.2.0.4</code></td>
<td>Forward(4)</td>
</tr>
<tr>
<td>Ingress Port = 2,Dst = <code>10.2.0.3</code></td>
<td>Forward(3)</td>
</tr>
<tr>
<td>Ingress Port = 2,Dst = <code>10.2.0.4</code></td>
<td>Forward(4)</td>
</tr>
</tbody>
</table>
</div>
<p>对于第四条要求，h3和h4可以通过接口互相传信息</p>
<p>因此可以这样写：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>匹配</th>
<th>动作</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ingress Port = 4,src= <code>10.2.0.4</code> ,Dst = <code>10.2.0.3</code></td>
<td>Forward(3)</td>
</tr>
<tr>
<td>Ingress Port = 3 ,src= <code>10.2.0.3</code> ,Dst = <code>10.2.0.4</code></td>
<td>Forward(4)</td>
</tr>
</tbody>
</table>
</div>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/45.png" style="zoom:50%;"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>匹配</th>
<th>动作</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ingress Port=<code>3</code>    Dst=<code>10.1.*.*</code></td>
<td>Forward(2)</td>
</tr>
<tr>
<td>Ingress Port=<code>3</code>    Dst=<code>10.3.*.*</code></td>
<td>Forward(2)</td>
</tr>
<tr>
<td>Ingress Port=<code>4</code>    Dst=<code>10.1.*.*</code></td>
<td>Forward(1)</td>
</tr>
<tr>
<td>Ingress Port=<code>4</code>    Dst=<code>10.3.*.*</code></td>
<td>Forward(1)</td>
</tr>
</tbody>
</table>
</div>
<p>也就是说，来自h3主机的会从s2的接口2转发到s1，并由s1转发到h1、h2,或者再转发到s3, 这样就是顺时针转发</p>
<p>同样的，来自h4主机的包会在s2的接口1直接转发给s3，然后再有s3转发给s1，这就是逆时针方向</p>
<h2 id="控制层面"><a href="#控制层面" class="headerlink" title="控制层面"></a>控制层面</h2><p>传统上，控制平面功能与数据平面的转发功能在一起实现，在路由器中作为统一的整体。 但是在SDN中，在数据平面和控制平面做出了明确的分割，在一台分离的”控制器”服务中实现了控制平面功能，该<strong>控制器服务</strong>与<strong>它所控制的路由器转发组件</strong>完全分开并远离</p>
<p>在这个部分，我们将学习转发表和流表是如何计算、维护和安装的。下面给出了两种控制平面和数据平面的方案。</p>
<p><strong>每路由器控制：在控制平面中各个路由选择算法相互作用</strong></p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/46.png" style="zoom:50%;"></p>
<p><strong>逻辑集中式控制：一个完全分开的(Normally remote)控制器与本地控制代理交互</strong> 这对路由器的计算能力的要求可以没那么高。而且能够统一化接口，对品牌的差异性要求不大。</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/47.png" style="zoom:50%;"></p>
<h3 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h3><p>路由选择算法的目的是从发送方到接收方的过程中确定一条通过路由器网络的<strong>好的路径</strong>。 因为无论是<strong>每路由器控制方法</strong>还是<strong>逻辑集中式控制方法</strong>，发送过程中必定总是要经过一条定义良好的一连串路由器路径。</p>
<p>在数据结构中，我们学过在图中找一条最短路径的算法，如Djkstra 算法和 Bellman-Ford算法。 它们分别对应着<strong>链路状态路由选择算法(link state)</strong>和<strong>距离向量路由选择方法(distance vector)</strong></p>
<h4 id="链路状态路由选择算法"><a href="#链路状态路由选择算法" class="headerlink" title="链路状态路由选择算法"></a>链路状态路由选择算法</h4><p>LS 算法中，所有的链路开销都是已知的。实践中，这是通过让每个节点向网络中所有其他节点广播链路状态分组来完成的。每个链路状态分组包含他所连接的链路的标识和开销。</p>
<p>LS算法的实现就是Djkstra算法，详见我的博客： <a href="https://jasonxqh.github.io/2020/06/21/图与贪心算法/#最短路径：Dijkstra算法"> 最短路径：Dijkstra算法</a></p>
<p>当LS算法终止时，对于每个节点，我们都能得到从源节点沿着它的最低开销路径的前一节点。以此方式我们可以构建从源节点到所有目的节点的完整路径。</p>
<p>虽然在局域网中，主机的个数有限，因此可以简单的计算，但是整个英特网的节点很多，计算起来会比较麻烦。其算法复杂度平均为 $O(n^2)$， 优化过后可得到 $O(n\log n)$</p>
<h5 id="振荡问题"><a href="#振荡问题" class="headerlink" title="振荡问题"></a>振荡问题</h5><p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/48.png" style="zoom:50%;"></p>
<p>上图是一个简单的网络拓扑，图中的链路开销等于链路上承载的负载，例如反映要经历的时延。在该例中，链路开销是非对称的，即当在链路$(u,v)$两个方向所承载的负载相同时，$c(u,v)$和$c(v,u)$ 才相等。在上例中，节点z产生发往w的一个单元的流量，节点x也产生发往w的一个单元的流量，并且节点y也产生发往w的一个数量为e的流量。</p>
<p>那么当LS算法再次运行时，节点y (5-5a)确定顺时针到w的路径开销为1，逆时针(一直使用的) 到w的路径开销为1+e。因此y到w的最低开销路径现在变为顺时针的。类似的，x确定其到w的新的最低开销路径也是顺时针的，产生如(5-5b) 中所示的开销。当LS算法下次运行时，节点x、y和z都检测到一条到w的逆时针方向开销为0的路径。它们都将其流量引导到逆时针方向的路由上。</p>
<p>在下次运行LS算法时，x,y,z 又将其流量引导到顺时针方向的路由上。</p>
<p>很显然，这是一种不好的振荡。如何才能防止这样的振荡？一种解决方案可能强制链路开销不依赖于所承载的流量，但那是一种不可接受的解决方案——因为路由选择的目标之一就是要避开高度拥塞的链路。</p>
<p>另一种解决方案就是确保并非所有的路由器都同时运行LS算法，在每个节点上算法的时机也将是不同的。</p>
<h4 id="距离向量路由选择方法"><a href="#距离向量路由选择方法" class="headerlink" title="距离向量路由选择方法"></a>距离向量路由选择方法</h4><p>DV算法是一种迭代的，异步的和分布式的算法，而LS算法是一种使用全局信息的算法。其本质是 Bellman-Ford算法。</p>
<p>Bellman-Ford 算法是一种动态规划的算法。那么首先我们来了解一下Bellman-Ford 方程式：</p>
<p>令 $d_x(y)$ 为 x节点到y节点的最小代价，那么</p>
<script type="math/tex; mode=display">
d_x(y) = \min\{c(x,v)+d_v(y)\}</script><p>其中，$c(x,v)$ 代表 x到邻居v的距离，$d_v(y)$ 代表邻居 v到y节点的最小代价。我们看到下一张图</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/49.png" style="zoom:67%;"></p>
<p>我们从u出发，计算到z的距离。</p>
<p>显然$d_v(z) = 5,d_x(z) = 3,d_w(z) = 3$ ,那么 </p>
<script type="math/tex; mode=display">
d_u(z) = \min\{\\c(u,v)+d_v(z),\\c(u,x)+d_x(z),\\c(u,w)+d_w(z)\}
 =\min\{2+5,1+3,5+3\} = 4</script><p>与 LS算法相比，DV算法只知道它邻居的信息，而不掌握全局的拓扑信息。</p>
<p>DV算法的迭代是这样的一个循环：</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/50.png" style="zoom:67%;"></p>
<p>每个节点都在等待它邻居发来的变化信息，收到以后就重新计算距离，计算完成后把更新后的信息传给它的所有邻居并等待进入下次循环。直到距离不再变化，收敛的时候就停止算法</p>
<p>现在来看一个具体的例子：</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/51.png" style="zoom:67%;"></p>
<h5 id="DV算法存在的问题"><a href="#DV算法存在的问题" class="headerlink" title="DV算法存在的问题"></a>DV算法存在的问题</h5><p>DV算法也存在一些问题。其一就是<strong>好消息传播得快，坏消息传播得慢</strong>，我们分别讨论。</p>
<p><strong>好消息情况</strong></p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/52.png" style="zoom:67%;"></p>
<p>当x与y之间的距离向量从4变为1时，这是个好消息。</p>
<p>$t_0$ 时刻，y收到了这个变动，更新了它的DV表格，并告诉了它的邻居</p>
<p>$t_1$ 时刻，z收到了y发来的信息，并更新了它的DV表格，这时候，z到x的距离就从5变成2了。然后z也将这个好消息发给它的邻居</p>
<p>$t_2$时刻，y收到了来自z的更新，z告诉y：“我到x的距离只有2啦，可以借助我来更新！”，结果y并不需要更新它的表格了，因为y到x 的距离本来就比2小。至此，算法到这里就结束了，因为DV表都收敛了。</p>
<p><strong>坏消息情况</strong></p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/53.png" style="zoom:67%;"></p>
<p>当x与y之间的距离向量从4变为60时，这是个十足的坏消息。这时候，会发生如下的事：</p>
<ol>
<li>在链路开销变化之前，$D_y(x) = 4,D_y(z) = 1,D_z(y)=1,D_z(x)=5$. 在 $t_0$ 时刻，y检测到链路开销变化。y计算它到x的新开销。$D_y(x) = \min{c(y,x)+D_x(x),c(y,z)+D_z(x)}=\min{60+0,1+5}=6$ (因为此时 $D_z(x)$ 尚未更新。这就是我们所谓的<strong>路由环路</strong>，即为到达x，y通过z路由，z又通过y路由。路由选择环路就像一个黑洞，即目的地为x的分组在 $t_1$ 时刻到达y或者z之后，将在这两个节点之间不停地来回反复，直到转发表再次收敛为止</li>
<li>因为节点y已经算出到x的新的最低开销，其在$t_1$时刻将该新距离向量通知z</li>
<li>在$t_1$之后的某个时间，z收到了来自y的新距离向量，他指示了y到x的最低开销是6。z知道它能以开销1到达y，因此计算出到x的新最低开销 $D_z(x) = \min{50+0,1+6}=7$ 。因为z到x的最低开销已经增加了，于是他在 $t_2$时刻通知y其新开销</li>
<li>以类似的方式，在收到z的新距离向量后，$D_y(x) = \min(60+0,1+7) =8$, 并向z发送其距离向量。接下来z确定$D_z(x) = 9$ 并向y发送其距离向量……</li>
<li>最终，直到z最终算出它经由y的路径开销大于50为止，算法才能停止，而此时已经过了44次迭代。这就是<strong>坏消息传播得慢</strong>的原理</li>
</ol>
<h5 id="增加毒性逆转"><a href="#增加毒性逆转" class="headerlink" title="增加毒性逆转"></a>增加毒性逆转</h5><p>那么怎么破解这个问题呢？就是要破这个环路。</p>
<p>如果 $z$ 通过 $y$ 路由选择到目的地x，则z将通告y：“嗨，兄弟，我到x的距离是无穷大！“，也就是告诉y $D_z(x) = \infty$ . 那么，只要z经由y到x，那么z就会持续地向y讲述这个<strong>善意的小谎言</strong>。因为y相信z没有到x的路径，因此只要z继续经y到x，y将永远不会试图经由z路由选择到x</p>
<p>这时候$D_z(x) = \infty$, 因此$D_y(x) = \min{60+0,\infty} = 60$, 而 $D_z(x) =\min {60+1,50+0} = 50$, 最后 $D_y(x) = \min{50+1,60+0}=51$</p>
<p>然而，毒性逆转并没有解决一般的无穷级数问题。当涉及到3个或者更多节点(不只是直接相连的两个邻居节点)的环路，将无法使用毒性逆转技术检测到</p>
<h4 id="LS和DV的对比"><a href="#LS和DV的对比" class="headerlink" title="LS和DV的对比"></a>LS和DV的对比</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>LS</th>
<th>DV</th>
</tr>
</thead>
<tbody>
<tr>
<td>报文复杂度</td>
<td>每次更新O(nE) 条信息</td>
<td>只在邻居间交换，时间不等</td>
</tr>
<tr>
<td>收敛速度</td>
<td>要求 $O(nE)$个报文的$O(n^2)$算法</td>
<td>收敛较慢，有时会遇到选择环路</td>
</tr>
<tr>
<td>鲁棒性</td>
<td>较为鲁棒，路由计算较为分离</td>
<td>鲁棒性较差，会将错误扩散至整个网络</td>
</tr>
</tbody>
</table>
</div>
<h3 id="AS内：OSPF"><a href="#AS内：OSPF" class="headerlink" title="AS内：OSPF"></a>AS内：OSPF</h3><p>事实上，因特网是网络的网络，它并不是扁平的。我们把一个局域网叫做 AS(autonomous systems)。然后定义局域网内部的路由选择为 （intro-AS routing), 局域网和局域网之间的路由选择为 (inter-AS routing)</p>
<p>在同一个局域网内，采用相同的路由选择算法。我们通常使用 OSPF 路由</p>
<p>OSPF即开放最短路优先，它是一种链路状态协议，并使用Dijkstra来计算转发表。</p>
<p>OSPF的优点：</p>
<ul>
<li>安全 ，它可以在密码学上通过一些方法来保证数据不能被恶意篡改，另外能确定是某个人发出的信息，不能冒名顶替</li>
<li>允许有多条相同开销的路径 。这就是说，当存在多条相等开销的路径时，无需仅选择单一的路径来承载所有的流量</li>
<li>对单播与多播路由选择的综合支持较好 </li>
<li>支持在单个AS中的层次结构</li>
</ul>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/54.png" style="zoom:67%;"></p>
<p>OSFP 协议 试运行在 应用层上的。</p>
<h3 id="AS之间的路由选择：BGP"><a href="#AS之间的路由选择：BGP" class="headerlink" title="AS之间的路由选择：BGP"></a>AS之间的路由选择：BGP</h3><p>在ISP之间进行路由选择，就需要一个BGP协议</p>
<p>BGP 的全程是 Broder Gateway Protocol 边界网关协议。其无疑是所有因特网协议中最重要的。正式这个协议将因特网中数以千计的ISP黏合起来。对于自治系统AS之间的路由选择，要使用OSPF协议那样代价作为度量来寻找最佳路由是不现实的。比较合理的做法是在自治系统之间交换<strong>“可达性”</strong>信息。例如，告知相邻路由器：达到目的网路N可经过自治系统$AS_x$。在BGP的世界中，在路由器的转发表将具有形式为$(x,I)$的表项，其中x是一个前缀，如(<code>138.16.68/22</code>)，I 则是该路由器的接口之一的接口号</p>
<p>作为一种AS间的路由选择协议，BGP为每台路由器提供了这样的服务：</p>
<ul>
<li>从邻居AS获得前缀的可达性信息，BGP允许每个子网向因特网的其它部分通告：”嗨！我在这！”。 如果没有BGP，每个子网将孤独地存在</li>
<li>确定到该前缀的“最好的”路由。最好的路由将基于策略以及可达性信息来确定</li>
</ul>
<h4 id="通告BGP路由信息"><a href="#通告BGP路由信息" class="headerlink" title="通告BGP路由信息"></a>通告BGP路由信息</h4><p>对于每个AS，每台路由器要么是一台<code>网关路由器(gateway router)</code>，要么是一台<code>内部路由器(internal router)</code>.网关路由器是一台位于AS边缘的路由器，它直接连接到AS中的一台或者多台路由器。内部路由器仅连接在它自己AS中的主机和路由器。</p>
<p>如图所示， BGP 按照运行方式分为 EBGP（External/Exterior BGP）和 IBGP（Internal/Interior BGP）。</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/56.jpg" style="zoom:67%;"></p>
<p><strong>EBGP：</strong>运行于不同 AS 之间的 BGP 称为 EBGP。为了防止 AS 间产生环路，当 BGP 设备接收 EBGP 对等体发送的路由时，会将带有本地 AS 号的路由丢弃。</p>
<p><strong>IBGP：</strong>运行于同一 AS 内部的 BGP 称为 IBGP。为了防止 AS 内产生环路， BGP 设备不将从IBGP 对等体学到的路由通告给其他 IBGP 对等体，并与所有 IBGP 对等体建立全连接。为了解决 IBGP 对等体的连接数量太多的问题， BGP 设计了路由反射器和 BGP 联盟。</p>
<p>考虑下面这张图，AS内部的短虚线是IBGP，AS之间有长虚线是EBGP。 现在 AS3 要想 AS2发送一个BGP报文，告知 x 存在并位于AS3中。</p>
<p>在这个过程中: </p>
<p>网关路由器3a先向网关路由器2c发送了一个eBGP报文“AS3 x”。</p>
<p>网关路由器2c然后向AS2中的所有其他路由器(包括网关路由器2a)发送iBGP报文”AS3 x”</p>
<p>网关路由器2a接下来向网关路由器1c发送一个eBGP报文“AS2 AS3 x”</p>
<p>最后，网关路由器1c使用iBGP向AS1中的所有路由器发送报文”AS2 AS3 x”。 </p>
<p>在这个过程完成之后，在AS1和AS2中的每个路由器都知道了x的存在并且也都知道了通往x的AS路径</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/56.png" style="zoom:67%;"></p>
<p>再来看一个例子，当路由器1c到路由器3a附加了一条物理链路之后，在这种情况下，从AS1到x有两条路径：经过路由器1c的路径<code>AS2 AS3 x</code>以及经过路由器1d的新路径 <code>AS3 x</code> </p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/58.png" style="zoom:67%;"></p>
<h4 id="确定最好的路由"><a href="#确定最好的路由" class="headerlink" title="确定最好的路由"></a>确定最好的路由</h4><p>就像上面的图一样，从一个给定的路由器到一个目的子网可能有多条路径。事实上，因特网中的路由器常常接收到很多不同的可能路径的可达性信息。</p>
<p>那么，一台路由器怎么在这些路径中进行选择呢？</p>
<p>我们首先来了解一些BGP属性：AS-PATH 和 NEXT-HOP</p>
<blockquote>
<p>AS-PATH 属性包含了已经通告过的 AS的列表，如我们在前面的例子中所见。当一个前缀通过某AS时，该AS将其$ASN$ 加入 AS-PATH 中的现有列表。此外，AS-PATH 还可以用来检测和防止通告环路，因为如果一台路由器在列表中看到了包含他自己的AS，它将拒绝该通告  </p>
<p>NEXT-HOP 是 AS-PATH <strong>起始的路由器接口的IP地址</strong>。我们还是那上面这张图为例：<br>对于AS1通过AS2到x的路由“AS2 AS3 x” ，其属性 NEXT-HOP 是路由器2a最左端的接口的IP地址;<br>对于AS1绕过AS2到x的路由”AS3 x” ，其NEXT-HOP 是路由器3a的下侧接口</p>
</blockquote>
<h5 id="热土豆路由选择"><a href="#热土豆路由选择" class="headerlink" title="热土豆路由选择"></a>热土豆路由选择</h5><p>对于 AS 间的路由选择，路由器要如何学习到哪些网络可供转发？BGP 路由选择的原理是<strong>热土豆路由选择</strong>，即从所有路由中选择到开始该路由的 NEXT-HOP 路由器具有的最小开销作为学习的信息。通过热土豆路由选择添加 AS 外前缀的步骤如图所示，当 路由表学习可达性信息时，<strong>BGP 协议和 AS 内路由选择协议(OSPF 协议)需要协同工作</strong>。</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/59.png" style="zoom:80%;"></p>
<p>热土豆路由选择的思想是：将分组发给最近的网关路由器，用尽可能最低开销将分组送出其所在 AS。之所以称之为热土豆，就是当分组被类比为“热土豆”时，由于烫手，所以我们要尽可能快地把“热土豆”扔给下一个人。因此热土豆路由选择是一种自私的算法，它只考虑到减小自己 AS 内传输分组的开销，但是忽略了 AS 外端到端的其他开销。</p>
<p>比如说下面这个例子：</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/60.png" style="zoom:67%;"></p>
<p>现在 路由器1b想发送给x信息，有两条路由可以走：<code>AS2 AS3 x</code>和<code>AS3 x</code>. 假设开销定义为需要穿越的链路数，那么如果选择<code>AS2 AS3 x</code> ，NEXT-HOP 为 2a最左侧接口，最低开销为 2， 如果选择 <code>AS3 x</code> ，NEXT-HOP 则为3d的最左端接口，开销为3。 这时候，虽然我们从上帝视角看选择路由 <code>AS3 x</code> 更快，但是这颗<strong>热土豆</strong>太烫手了，1b想要尽快的把这个烫手的山芋扔给下一个人，那么它还是会选择<code>AS2 AS3 x</code>这条路径。</p>
<p>因而，热土豆路由选择是自私的算法，即他试图在减小他自己AS中的开销，而忽略在其AS之外的端对端开销的其他部分。</p>
<h5 id="路由器选择算法"><a href="#路由器选择算法" class="headerlink" title="路由器选择算法"></a>路由器选择算法</h5><p>在实践中，BGP使用了一种比热土豆路由选择更复杂但却结合了其特点的算法。我们知道BGP的路由选择算法的<strong>输入</strong>是<strong>到某前缀的所有路由的集合</strong>。如果到相同的前缀有两条或者多条路由，则顺序调用下列消除规则直到余下一条路由。</p>
<ol>
<li>路由被指派一个<strong>本地偏好(local preference)</strong> 值作为其属性之一。一条路由的本地偏好可能<strong>由该路由器设置</strong>或者可能<strong>由在相同AS中的另一台路由器学习到</strong> 。本地偏好属性的值是一种策略决定，它完全取决于AS的网络管理员。<strong>具有最高本地偏好值的路由将被选择</strong></li>
<li>从余下的路由中(现在都具有相同的最高本地偏好值)，将选择具有最短的AS-PATH路由。如果该规则是路由选择的唯一规则，那么BGP将使用DV算法决定路径，其中距离的测度使用AS跳的跳数而不是使用路由器跳的跳数</li>
<li>从余下的路由中(现在都具有最高本地偏好值和相同的AS-PATH长度)，使用热土豆选择，即选择具有最靠近 NEXT-HOP路由器的路由</li>
<li>如果仍留下多条路由，该路由器使用BGP标识符来选择路由。</li>
</ol>
<p>这样，回到上面这个例子。</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/60.png" style="zoom:67%;"></p>
<p>首先使用规定1(这里假设都具有最高的本地偏好值)</p>
<p>然后使用规定2，选择出最短的AS-PATH。因此将直接使用 <code>AS3 x</code> 路由。我们看到, BGP此时不再使用一种自私的算法了。</p>
<h3 id="SDN-控制平面"><a href="#SDN-控制平面" class="headerlink" title="SDN 控制平面"></a>SDN 控制平面</h3><p>下图提供了一个通用的SDN控制器详尽的示意图。控制器的功能大体可以分为3个层次，我们以一种非典型的自底向上的方式考虑这些层次：</p>
<p><img src="/2021/06/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82/61.png" style="zoom:67%;"></p>
<ul>
<li><strong>通信层</strong>： SDN 控制器和受控网络设备之间的通信。如果SDN控制器需要控制远程的机器运行，需要一个协议来传送控制器与这些设备的信息。如上图所示，这个协议构成了控制器体系结构的最底层。 控制器和受控设备之间的通信跨越了一个接口，他现在被称为控制器的<code>南向接口</code> </li>
<li><strong>网络范围状态管理层</strong>：由SDN控制平面做出的最终控制决定，将要求控制其具有 <code>有关网络的主机</code>、<code>链路</code>、<code>交换机</code>等设备的最新状态信息。</li>
<li><strong>对于网络控制应用程序层的接口</strong>：控制器通过其<code>北向API</code> 与网络控制应用程序交互。该API允许网络控制应用程序在状态管理层之间 读写网络状态和流表。 当状态改变事件发生时，应用程序能够注册进行通告。</li>
</ul>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h5 id="1"><a href="#1" class="headerlink" title="1"></a>1</h5><p>前面讲过路由器和链路层交换机都被称为分组交换机. 路由器与链路层交换机间的根本区别是什么?</p>
<p>答:<br>路由器和链路层交换机的根本区别是它们服务于不同的网络层协议. 链路层交换机基于链路层帧中的字段值做出转发决定, <strong>服务于第二层链路层</strong>; 路由器基于网络层数据报中的首部字段值做出转发决定, <strong>服务于第三层网络层</strong>.</p>
<h5 id="2"><a href="#2" class="headerlink" title="2"></a>2</h5><p>讨论为什么在高速路由器的每个输入端口都存储转发表的影子副本.</p>
<p>答： </p>
<p>首先一个路由器是有很多个输入端口的, 转发行为的第一步是在转发表中查找输出接口. 如果每个输入端口都并发地调用路由选择器查找输出接口必然会产生时延. 所以要在高速路由器的每个输入端口都存储转发表的影子副本, 使转发决策能在每个输入端口本地做出,<strong>避免了集中式处理的瓶颈</strong>.</p>
<h5 id="3"><a href="#3" class="headerlink" title="3"></a>3</h5><p>路由器有IP地址吗? 如果有, 多少个?</p>
<ul>
<li>路由器有IP地址, 这里的有IP地址并不是说有一个IP地址标志一台路由器. 而是说路由器的一个输入或输出端口对应着一个IP地址.</li>
<li>所以一个路由器拥有的IP地址数是不确定的, 假如一个路由器有一个输入端和两个输出端, 那么对应地就有三个IP地址, 分别对应三个端口.</li>
</ul>
<h5 id="4"><a href="#4" class="headerlink" title="4"></a>4</h5><p>什么时候一个大数据报分割成多个较小的数据报? 较小的数据报在什么地方装配成一个较大的数据报?</p>
<ul>
<li>网络层的数据报需要往下经过链路层封装成链路层帧才能放上链路开始传输. 然而一个链路层帧的载荷大小根据链路层协议的不同而不同, 数据报的大小不能超过一个链路层帧的最大传送单元(Maximum Transmission Unit, MTU). 所以当链路层<strong>遇到大于自身MTU的数据报时</strong>需要把数据报分割成多个较小的数据报. <strong>这项工作将放到端系统中进行, 因为如果在路由器中进行的话会大大降低路由器的性能</strong>.</li>
<li>较小的数据报在<strong>目的端系统的网络层</strong>进行装配.</li>
</ul>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/12/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/%5Bobject%20Object%5D"
                alt="Jason" />
            
              <p class="site-author-name" itemprop="name">Jason</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20fa%20fa-archive">
              
                  <span class="site-state-item-count">435</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">61</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="true"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
 <!--
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>







-->
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>




















  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v="></script>

  <script type="text/javascript" src="/js/src/motion.js?v="></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v="></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
