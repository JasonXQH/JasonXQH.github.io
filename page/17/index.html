<!DOCTYPE html>
<html lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jasonxqh.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jason‘s Blog">
<meta property="og:url" content="https://jasonxqh.github.io/page/17/index.html">
<meta property="og:site_name" content="Jason‘s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jasonxqh.github.io/page/17/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jason‘s Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jason‘s Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/" class="post-title-link" itemprop="url">异常控制流（ECF）1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-24 13:02:24" itemprop="dateCreated datePublished" datetime="2020-12-24T13:02:24+08:00">2020-12-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-25 22:39:22" itemprop="dateModified" datetime="2022-06-25T22:39:22+08:00">2022-06-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="异常控制流（ECF）1"><a href="#异常控制流（ECF）1" class="headerlink" title="异常控制流（ECF）1"></a>异常控制流（ECF）1</h1><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p>首先我们要了解控制流的概念,从给处理器加点到断电为止，程序计数器假设一个值得序列如下：</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/2.png" style="zoom:100%;"></p>
<p>其中  $inst_k$ 代表着一条条指令。每次从 $inst_1$ 到 $inst_2$ 的过渡被称为控制转移。这样的控制转移序列叫做处理器的控制流。</p>
<h3 id="更改控制流"><a href="#更改控制流" class="headerlink" title="更改控制流"></a>更改控制流</h3><p>我们知道，进程有三个状态，running(拿到CPU并运行)，waiting(在等一个事件发生，在这个事件没有发生之前即使拿到了CPU也做不了事)，ready(已就绪，但是还没拿到CPU，等拿到了立即可以执行)</p>
<p>当哪些事件发生的时候系统会更改控制流呢？</p>
<h4 id="two-mechanisms-for-changing-control-flow"><a href="#two-mechanisms-for-changing-control-flow" class="headerlink" title="two mechanisms for changing control flow"></a>two mechanisms for changing control flow</h4><ul>
<li>Jump and branches</li>
<li>Call and return</li>
</ul>
<h4 id="Insufficient-for-a-useful-system"><a href="#Insufficient-for-a-useful-system" class="headerlink" title="Insufficient for a useful system"></a>Insufficient for a useful system</h4><ul>
<li>Data arrives from a disk or a network adapter <ul>
<li>当磁盘或者网络的数据到达的时候，系统会发出一个事件，代表数据传输完成。这时候从waiting进入到ready状态。这时候就需要操作系统中的代码来做。操作系统会把一个队列移动到另一个队列去，特别是这个进程优先级很高，我们甚至要直接把现在在running的进程拉下来然后把这个进程直接拿到CPU去运行</li>
</ul>
</li>
<li>Instruction divides by zero<ul>
<li>代码除以0了。这也需要操作系统来做。</li>
</ul>
</li>
<li>User hits Ctrl-C at the key board<ul>
<li>按Ctrl-C 退出程序。这时候也是操作系统来执行的</li>
</ul>
</li>
<li>System timer expires                    <ul>
<li>如果一个操作系统很多人在运行，那么操作系统会让每个人轮流运行一段时长。时间一到操作系统会把当前执行的挂起，状态设置为ready，然后把下一个进程放到CPU当中去</li>
</ul>
</li>
</ul>
<p>因此，系统需要一个 ECF的机制，也就是异常控制流来对这些变化做出反应。</p>
<h2 id="异常控制流"><a href="#异常控制流" class="headerlink" title="异常控制流"></a>异常控制流</h2><p>在异常发生的时候，很多时候要执行的代码并不是用户写的，而是操作系统写的。这些操作系统执行的代码块就放置在地址空间中的Kernel code and data 层里面，如下图所示：</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/1.png" style="zoom:80%;"></p>
<p>异常控制流在计算机系统的各个层级都有涉及。</p>
<h3 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h3><ul>
<li><p>Exceptions</p>
<ul>
<li><p>Change in control flow in response to a system event</p>
</li>
<li><p>implemented using combination of hardware and OS software</p>
</li>
</ul>
</li>
</ul>
<p>在操作系统层面是比较底层的Exception(也叫interruption)，这时候需要硬件和软件来共同完成。</p>
<h3 id="高层"><a href="#高层" class="headerlink" title="高层"></a>高层</h3><p>在操作系统层面以上的，一共有三种</p>
<ul>
<li>Process context switch</li>
</ul>
<p>一个进程在运行过程中的状态被称为context。 那么当状态切换的时候，就是context switch。再说得简单一点，就是进程切换</p>
<p>context switch要做这样一些工作：</p>
<ol>
<li>保留寄存器(包括栈顶指针)</li>
<li>状态字需要保留</li>
<li>pc要保留，并指向新的进程开始的第一条指令</li>
</ol>
<ul>
<li>Signals  - Implemented by OS software</li>
</ul>
<p>一个进程可以主动的发一个signal，比如说 kill 指令可以杀死一个进程；或者yield指令，可以将CPU让出来让别人用；sleep指令可以先睡眠，过一会再回来运行</p>
<ul>
<li>Nonlocal jumps：setjump() 和 longjmp()</li>
</ul>
<p>跳到很远的地方去执行</p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常(exception)就是控制流中的突变，用来响应处理器状态中的某些变化。</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/3.png" style="zoom:120%;"></p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>在这张图中，当处理器状态中发生一个重要变化的时候，处理器正在处理 $I_{current}$ 。在处理器中，状态被编码为不同的位和信号。状态变化称为 event(事件)。</p>
<p>事件可能和当前指令的执行直接相关。比如发生内存缺页、算术溢出、或者一条指令试图除以0等等。<br>另一方面，事件也可能和当前指令的执行没有关系，比如一个系统定时器产生信号或者一个I/O请求完成</p>
<p>在任何情况下，当处理器检测到有事件发生的时候，它就会通过一张  异常表 的跳转表来跳到一个专门设计用来处理这类事件的操作系统子程序。</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/4.png" style="zoom:120%;"></p>
<p>当异常处理程序完成处理后，根据引起的异常的事件的类型，会发生一下三种情况：</p>
<ol>
<li>处理程序将控制返回给当前指令 $I_{curr}$ ，即当事件发生的时候正在执行的指令。比如说缺页 page fault</li>
<li>处理程序将控制返回给 $I_{next}$，如果没有异常将会执行下一条指令。比如说 arithmetic overflow 溢出了</li>
<li>处理程序终止被中断的程序。比如说 ctrl+c</li>
</ol>
<h3 id="异常类别"><a href="#异常类别" class="headerlink" title="异常类别"></a>异常类别</h3><p>首先我们要了解同步和异步的概念。</p>
<p>同步代表着我必须马上回应出现的异常，处理完才能进行下一步操作。异步则代表我可以先执行其他操作，让系统去处理这个异常，等处理完后再回来也可以。</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/5.png"></p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/10.png"></p>
<h4 id="Interrupts-中断"><a href="#Interrupts-中断" class="headerlink" title="Interrupts(中断)"></a>Interrupts(中断)</h4><p>中断时异步发生的，这是来自处理器<strong>外部</strong> 的I/O设备信号的结果。硬件中断<strong>并不是由任何一条专门的指令造成的</strong>，从这个意义上说他是异步的。</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/6.png"></p>
<p>当处理程序返回时，它就将控制返回给下一条指令(也即如果没有发生中断，在控制流中会在当前指令之后的那条指令)。结果是程序继续执行，就好像没有发生过一样</p>
<p>比如说：Timer interrupt，这个意思是说我的时钟周期到了，不给我用了，系统强制把我的进程中断，执行其他进程。</p>
<p>又比如说外部的I/O设备中断，比如我按下 Ctrl-C，直接退出进程；网络或者磁盘上的数据到了，那么这个时候就会去执行其他进程</p>
<h4 id="Trap-陷阱"><a href="#Trap-陷阱" class="headerlink" title="Trap(陷阱)"></a>Trap(陷阱)</h4><p>陷阱是有意的异常，是执行一条指令的结果。就像中断处理程序一样，陷阱处理程序将控制返回到下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做<strong>系统调用</strong>。</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/7.png"></p>
<p>用户程序经常需要向内核请求服务，比如读一个文件（read)、创建一个新的进程(fork) 加载一个新的程序（execve)，或者终止当前进程（exit)。为了允许对这些内核服务的受控的访问，处理器提供了一条特殊的<code>syscall n</code>指令，当用户程序想要请求服务n时，可以执行这条指令。执行<code>syscall</code>指令会导致一个到异常处理程序的陷阱, 这个处理程序解析参数，并调用适当的内核程序。</p>
<p>比如说我们在用 gdb调试的时候设置的breakpoints</p>
<h4 id="Fault"><a href="#Fault" class="headerlink" title="Fault"></a>Fault</h4><p>故障由错误情况引起，它可能能够被故障处理程序<strong>修正</strong>。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而<strong>重新执行它</strong>。否则，处理程序返回到内核中的abort 例程，abort 例程会终止引起故障的应用程序</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/8.png"></p>
<h4 id="Aborts-终止"><a href="#Aborts-终止" class="headerlink" title="Aborts(终止)"></a>Aborts(终止)</h4><p>终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如DRAM 或者 SRAM 位被损坏时发生的奇偶错误。终止处理程序从不将控制返回给应用程序。</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/9.png"></p>
<h4 id="Linux-x86-64-系统中的异常"><a href="#Linux-x86-64-系统中的异常" class="headerlink" title="Linux/x86-64 系统中的异常"></a>Linux/x86-64 系统中的异常</h4><p>x86-64 系统定义了256种不同的异常类型。</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/10.png"></p>
<h4 id="x86-64-的故障与终止"><a href="#x86-64-的故障与终止" class="headerlink" title="x86-64 的故障与终止"></a>x86-64 的故障与终止</h4><p><strong>除法错误</strong>。当应用试图除以零时，或者当一个除法指令的结果对于目标操作数来说太大了的时候，就会发生除法错误（异常0)。Unix 不会试图从除法错误中恢复，而是选择终止程序。Linux shell 通常会把除法错误报告为“浮点异常(Floatmg exception)”</p>
<p><strong>一般保护故障</strong>。许多原因都会导致不为人知的一般保护故障（异常13)，通常是因为一个程序引用了一个未定义的虚拟内存区域，或者因为程序试图写一个只读的文本段。Linux 不会尝试恢复这类故障。Linux shell 通常会把这种一般保护故障报告为“段故障(Segmentation fault)”</p>
<p><strong>缺页</strong>(异常14)是会重新执行产生故障的指令的一个异常示例。处理程序将适当的磁盘上虚拟内存的一个页面映射到物理内存的一个页面，然后重新执行这条产生故障的指令。我们将在第9 章中看到缺页是如何工作的细节。</p>
<p><strong>机器检查</strong>。机器检査（异常18)是在导致故障的指令执行中检测到致命的硬件错误时发生的。机器检査处理程序从不返回控制给应用程序。</p>
<h4 id="x86-64-的系统调用"><a href="#x86-64-的系统调用" class="headerlink" title="x86-64 的系统调用"></a>x86-64 的系统调用</h4><p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/12.png"></p>
<p>当我们system call的时候，汇编指令用的是 syscall，注意，这时候rsp并不是在用户栈里面，而会把栈指针指导Kernel里面去</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><p>进程：进程就是在运行中的程序。CPU在使用的时候都是以进程为单位的。</p>
<p>线程：随着我们的应用程序越来越复杂，我们希望CPU能处理一个程序的并行任务。也就是一个进程里面有多个指令执行的序列，这些序列可以是异步的。比如说把一个人比作一个进程，那么他可以学算法、可以学CSAPP、可以学音乐，这些科目就是线程，它们共享人的大脑、书包、宿舍(cache,memory等资源)</p>
<p>注意，当有多个线程的时候，每个线程的stack是不共享的，因为他们有不同的指令序列。</p>
<p>上下文：上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和数据，它的<strong>栈</strong>、<strong>通用目的寄存器的内容</strong>、<strong>程序计数器</strong>、<strong>环境变量</strong>以及 <strong>打开文件描述符的集合</strong></p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/13.png" style="zoom:67%;"></p>
<p>每次用户通过向shell 输人一个可执行目标文件的名字，运行程序时，shell 就会创建一个新的进程，然后在这个新进程的上下文中运行这个可执行目标文件。应用程序也能够创建新进程，并且在这个新进程的上下文中运行它们自己的代码或其他应用程序。</p>
<p>在这一节，我们将关注进程提供给应用程序的关键抽象：</p>
<ul>
<li>Logical control flow：一个独立的逻辑控制流，它提供了一个假象，好像我们程序独占地使用处理器</li>
<li>Private address space：一个私有的地址空间，它提供了一个假象，好像我们的程序独占地使用内存系统</li>
</ul>
<h3 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h3><p>multi-programming 多道程序，也就是是多个进程的意思。</p>
<p>multi-threading: 多线程</p>
<p>multi-tasking: 多任务，机器进行多项任务批处理，交互性差</p>
<p>multi-processing ： 多任务处理</p>
<p>Time sharing(分时)：将时间划分成时间片，进程按时间片轮流执行</p>
<p>Multi-programming(多道)：系统中存在多个程序同时执行，增加CP的利用率。</p>
<p>区别：分时主要针对提高系统的响应速度，改善用户体验；多道主要针对增加系统的利用</p>
<p>multi-threading 和 multi-tasking 是一回事。</p>
<p>我们刚才说了进程会向每个人提供一种假象，好像它在独占地使用处理器。那么我们如果这时候去看PC(程序计数器)的值，就会发现这些值唯一地对应于包含在程序的可执行目标文件中的指令。这个PC值得序列就叫做逻辑控制流(简称逻辑流)</p>
<p>比如说下图，一个运行着三个进程的系统。处理器的一个物理控制流被分成了三个逻辑流，每个进程一个。 每个竖直的条表示一个进程的逻辑流的一部分。</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/14.png"></p>
<p>在这个例子中，三个逻辑流的执行是交错的。进程A运行了一会儿，然后是进程B开始运行到完成。然后，进程C运行了一会，进程A接着运行直到完成。最后进程C可以运行到结束了。</p>
<p>上图的关键点在于进程是轮流使用处理器的。每个进程执行它的流的一部分，然后被抢占(暂时挂起)，然后轮到其他进程。对于一个运行在这些进程之一的上下文中的程序，它看上去就像是在独占地使用处理器。</p>
<p>但是如果我们精确地测量每条指令使用的时间，会发现在程序中一些指令的执行之间，CPU好像会周期性地停顿。但是这并不会改变程序内存位置或者寄存器的内容。</p>
<h3 id="并发流"><a href="#并发流" class="headerlink" title="并发流"></a>并发流</h3><p>一个逻辑流的执行在时间上与另一个流重叠，称为并发流(concurrent flow)，这两个流被称为并发地运行。</p>
<p>比如说流X和Y互相并发，当且仅当 (X在Y开始之后和Y结束之前开始|Y在X开始之后和X结束之前开始)</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/15.png"></p>
<p>在这张图中，进程A和B并发地运行，A和C也是并发运行，但是B和C不是并发运行，因为B的最后一条指令在C的第一条指令之前执行</p>
<p>多个流并发地执行的一般现象被称为并发（concurrency)。一个进程和其他进程轮流运行的概念称为多任务（multitasking)。一个进程执行它的控制流的一部分的每一时间段叫做时间片（time slicing) 因此，多任务也叫做时间分片（time slicing).比如说上图，进程A的流是由两个时间片组成的。</p>
<p>但是在真正的执行过程中间，它们是不相交的，分离的。不过从用户的角度来看，并发地进程是相交的。因此在用户看来，三个进程是这样运行的。</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/16.png"></p>
<h3 id="私有地址空间"><a href="#私有地址空间" class="headerlink" title="私有地址空间"></a>私有地址空间</h3><p>进程会为每个程序提供它自己的私有地址空间。一般而言，和这个空间中某个地址相关联的那个内存字节是不能被其他进程读或者写的，因此说这个地址空间是私有的。</p>
<p>每一个地址空间的组织结构都是类似的。</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/17.png"></p>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>内核为每一个进程都维持一个上下文。上下文就是内核重新启动一个被抢占的进程所需的状态。</p>
<p>它由一些对象的值组成，这些对象包括<strong>通用目的寄存器</strong>、<strong>浮点寄存器</strong>、<strong>程序计数器</strong>、<strong>用户栈</strong>、<strong>状态寄存器</strong>、<strong>内核栈</strong>、<strong>各种内核数据结构(页表、进程表、文件表等)</strong></p>
<p>在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫<strong>调度</strong>，是由内核中称为调度器的代码处理的。</p>
<p>在内核调度了一个新的进程运行后，它就抢占当前的进程，并使用一种称为上下文切换的机制来将控制转移到新的进程</p>
<p>上下文切换有三个步骤：</p>
<ol>
<li>保存当前进程的上下文</li>
<li>恢复某个先前被抢占的进程被保存的上下文</li>
<li>将控制传递给这个新恢复的进程</li>
</ol>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/18.png"></p>
<p>如上图所示，进程A进行了read的系统调用，此时内核不会只等待读取的完成而什么都不做，而是切换到进程B继续执行。磁盘发出中断信号表面数据以及存入内存中，此时内核又会切换回进程A，继续执行read后的指令。</p>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="System-Call-Error-Handling"><a href="#System-Call-Error-Handling" class="headerlink" title="System Call Error Handling"></a>System Call Error Handling</h3><p>在出现错误时，Linux系统级函数通常返回-1和设置全局变量errno来指示原因</p>
<p>比如说fork()函数，它是用来创建一个新进程的。如果它的pid小于0，就说明创建新进程失败了，因此我们需要报告并打印这个错误信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"fork error: %s\n"</span>, strerror(errno));</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是我们对每个错误都这样写的话，会非常麻烦而且容易出错，因此我们可以把这个函数封装一下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unix_error</span><span class="params">(<span class="keyword">char</span> *msg)</span> <span class="comment">/* Unix-style error */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s: %s\n"</span>, msg, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">	unix_error(<span class="string">"fork error"</span>);</span><br></pre></td></tr></table></figure>
<p>这样以后，我只要 写一个<code>unix_error</code>函数,然后调用即可</p>
<h4 id="Wrappers"><a href="#Wrappers" class="headerlink" title="Wrappers"></a>Wrappers</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">Fork</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">    	unix_error(<span class="string">"Fork error"</span>);</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br><span class="line">/..../</span><br><span class="line">pid = Fork();</span><br></pre></td></tr></table></figure>
<p>我们可以写得更有层次一点，将fork()函数封装在Fork()函数当中</p>
<p>这里我们再关注一下fork()函数，fork()是仅有的调用一次返回两次的函数。return的数值有两种情况，一种是return自己的 <code>pid</code>，另一种是return 子进程的 <code>pid</code></p>
<h4 id="Obtaining-Process-IDs"><a href="#Obtaining-Process-IDs" class="headerlink" title="Obtaining Process IDs"></a>Obtaining Process IDs</h4><p><code>pid_t getpid(void)</code> 这个函数返回当前进程的PID</p>
<p><code>pid_t getppid(void)</code>这个函数返回父进程的PID</p>
<h3 id="创建和终止进程"><a href="#创建和终止进程" class="headerlink" title="创建和终止进程"></a>创建和终止进程</h3><p>从一个程序员的角度，我们可以认为一个进程一定是这三个状态中的一个</p>
<p><strong>Running:</strong></p>
<p>Running 状态就是拿到CPU直接可以运行；也可以说是Ready，即现在还没拿到CPU,但是拿到CPU之后可以马上运行</p>
<p><strong>Stopping:</strong></p>
<p>进程的执行被挂起，处于等待状态。当收到 SIGSTOP、SIGTSTP、SIGTTIN或者SIGTTOU信号时，进程就会停止，并且保持停止到它收到一个SIGCONT信号，在这个时刻，进程再次开始运行</p>
<p><strong>Terminated:</strong></p>
<p>结束状态，但是分配给进程的资源还没有回收。这种状态也叫做Zombie ，也就是我们常说的僵尸进程。</p>
<h4 id="Terminating"><a href="#Terminating" class="headerlink" title="Terminating"></a>Terminating</h4><p>当发生以下三个情况的时候，进程就会被终止</p>
<ul>
<li>Receiving a signal whose default action is to terminate </li>
<li>Returning from the main routine</li>
<li>Calling the exit function</li>
</ul>
<p>exit 函数 <code>void exit(int status)</code></p>
<ul>
<li>Terminates with an <em>exit status</em> of status </li>
<li>Convention: normal return status is 0,nonzero on error</li>
<li>Another way to explicitly set the exit status is to return an integer value from the main routine</li>
</ul>
<p>exit没有return，只有call。因此在exit()后面写代码是毫无意义的。</p>
<h4 id="Creating-Processes"><a href="#Creating-Processes" class="headerlink" title="Creating Processes"></a>Creating Processes</h4><p>当我们调用fork函数的时候，父进程会创造一个新的子进程</p>
<p><code>int fork(void)</code> 的一些注意点</p>
<ul>
<li><p>Returns 0 to the child process,child’s PID to parent process</p>
<ul>
<li>即如果我拿到了一个PID，就说明我是父进程；如果我拿到了一个0，就说明我是一个子进程</li>
</ul>
</li>
<li><p>子进程和父进程基本是一样的：</p>
<ul>
<li>子进程得到了一个和父进程一模一样的虚拟地址空间，连页表都是相等的。但是请注意，只是长得一样，他们的地址空间还是相互独立的，并不会因为子进程修改了某个值从而影响父进程中的值</li>
<li>子进程拿到的资源、打开文件的列表，也是和父进程一样的</li>
<li>只有PID和父进程是不一样的。</li>
</ul>
</li>
</ul>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/19.png"></p>
<p>下面是一段fork的例子，当pid\=\=0,代表这是一个子进程，并++x; 否则就说明这是一个父进程,并—x。</p>
<p>请注意</p>
<ul>
<li>父进程和子进程是并发运行的==父进程和子进程谁先拿到CPU是没有规定的==, 因此不能预测谁先回来谁后回来。</li>
<li>Duplicate but separate address space.也就是我上面所说，修改父进程中的x是不会对子进程中的x造成影响的，反之亦然</li>
<li>Shared open files，父进程打开的文件，子进程看到的话也是打开着的</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    pid = Fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">/* Child */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child : x=%d\n"</span>, ++x);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Parent */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent: x=%d\n"</span>, --x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/20.png"></p>
<p>如果我们一定要某一个进程在另一个进程之后，我们可以这样来设计我们的程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fork wrapper function */</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    initialize();</span><br><span class="line">    <span class="keyword">int</span> parent_delay = choose_delay();</span><br><span class="line">    <span class="keyword">int</span> child_delay = choose_delay();</span><br><span class="line">    <span class="keyword">pid_t</span> parent_pid = getpid();</span><br><span class="line">    <span class="keyword">pid_t</span> child_pid_or_zero = real_fork();</span><br><span class="line">    <span class="comment">//如果大于0，就说明这是个父进程，那么我们就打印子进程、要等多少；父进程，要等多少时间</span></span><br><span class="line">    <span class="keyword">if</span> (child_pid_or_zero &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Parent */</span></span><br><span class="line">        <span class="keyword">if</span> (verbose) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(</span><br><span class="line">            <span class="string">"Fork. Child pid=%d, delay = %dms. Parent pid=%d, delay = %dms\n"</span>,</span><br><span class="line">                child_pid_or_zero, child_delay,</span><br><span class="line">                parent_pid, parent_delay);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ms_sleep(parent_delay);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Child，那么子进程就等待一段时间*/</span></span><br><span class="line">        ms_sleep(child_delay);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> child_pid_or_zero;<span class="comment">//返回子进程的PID</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Modeling-fork-with-Process-Graphs"><a href="#Modeling-fork-with-Process-Graphs" class="headerlink" title="Modeling fork with Process Graphs"></a>Modeling fork with Process Graphs</h3><p>我们可以针对fork之后的进程画一张进程图。流程图是捕获并发程序中语句的偏序关系的有用工具。</p>
<ul>
<li>在这张图中每一个结点是我代码中的一条指令。</li>
<li>$a\rightarrow b$ 代表着 a在b之前发生</li>
<li>边能够打标签，表示某一个变量的值</li>
<li><code>printf</code>  结点可以被标为 输出</li>
<li>每张图最早的是由一个没有入读的结点开始的。</li>
</ul>
<p>对于这张图，我们做拓扑排序。并且图的任何拓扑类型都对应于一个可行的总体排序</p>
<p>下面是一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    pid = Fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">/* Child */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child : x=%d\n"</span>, ++x);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Parent */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent: x=%d\n"</span>, --x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于之前那个例子，我们画出流程图如下</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/21.png"></p>
<p>此外，我们还可以画出更加抽象的 Relabled Graph , Feasible total ordering </p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/22.png"></p>
<h4 id="小练习1"><a href="#小练习1" class="headerlink" title="小练习1"></a>小练习1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"L0\n"</span>);</span><br><span class="line">    fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"L1\n"</span>);</span><br><span class="line">    fork();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Bye\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们对这个程序画流程图，如下：</p>
<p>第一次是乘2，第二次对子进程和父进程同时乘2.因此会出来两个L1，4个Bye</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/23.png"></p>
<p>根据这幅图 我们可以得到一个可行的输出</p>
<p>$L0\rightarrow L1\rightarrow Bye\rightarrow Bye\rightarrow L1\rightarrow Bye\rightarrow Bye$</p>
<p>我们知道L1必定在两个Bye之前，但是这两个分支输出的顺序是不知道的。</p>
<h4 id="小练习2"><a href="#小练习2" class="headerlink" title="小练习2"></a>小练习2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fork4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"L0\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (Fork() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"L1\n"</span>);</span><br><span class="line">        <span class="keyword">if</span> (Fork() != <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="built_in">printf</span>(<span class="string">"L2\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Bye\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当代码中存在if 判断的时候，那么流程图又该怎么画？</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/24.png"></p>
<p>我们看到if的条件是 <code>Fork()!=0</code> ，也就是必须是父进程才能进行L1和L2的输出，如果是子进程，那么会直接输出Bye</p>
<p>一个可能的答案是： $L0\rightarrow L1\rightarrow Bye\rightarrow Bye\rightarrow L2\rightarrow Bye$ </p>
<h4 id="小练习3"><a href="#小练习3" class="headerlink" title="小练习3"></a>小练习3</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fork5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"L0\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"L1\n"</span>);</span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="built_in">printf</span>(<span class="string">"L2\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Bye\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和练习2不同，这里是只有子进程能输出L1、L2，父进程是只能输出Bye的</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/25.png"></p>
<p>我们可以通过拓扑排序输出一个可行的序列</p>
<p>$L0\rightarrow Bye\rightarrow L1\rightarrow L2\rightarrow Bye\rightarrow Bye$ </p>
<h3 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h3><p>当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收（reaped)。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程，从此时开始,该进程就不存在了。一个<strong>终止了</strong>但还<strong>未被回收</strong>的进程称为 僵尸进程</p>
<p>如果一个父进程先于子进程终止，那么Kernel会安排init进程(PID=1,在系统启动时由内核创建)作为孤儿进程的养父。然后由init进程来回收他们。然而长时间运行的程序(shell/服务器)，总是应该回收他们的僵尸子进程，因为即使它们没有运行，也会消耗系统的内存资源。</p>
<p>父进程可以通过<code>wait</code>或者<code>waitpid</code>函数来等待 它的子进程终止或者停止</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pit_t</span> pid,<span class="keyword">int</span> *statusp,<span class="keyword">int</span> options)</span></span>;</span><br><span class="line"><span class="comment">/*返回值：如果成功，则为子进程的PID;如果WNOHANG,则为0;如果是其他错误,则为-1*/</span></span><br></pre></td></tr></table></figure>
<p>父进程得到返回值之后，Kernel需要将僵尸子进程删除。</p>
<h4 id="例子1：Zombie-Example"><a href="#例子1：Zombie-Example" class="headerlink" title="例子1：Zombie Example"></a>例子1：Zombie Example</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fork7</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Child */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Terminating Child, PID = %d\n"</span>, getpid());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Running Parent, PID = %d\n"</span>, getpid());</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">            <span class="comment">/* Infinite loop */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父进程是6639，子进程是6640</p>
<p>因为子进程先exit(0)了，但是父进程没有收回子进程，所以子进程现在是 defunct的，说明这个进程是僵尸进程。</p>
<p>这时候我们如果 <code>kill 6639</code> ，那么会同时回收父进程和子进程。</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/26.png">     </p>
<h4 id="例子2-Non-terminating-Child-Example"><a href="#例子2-Non-terminating-Child-Example" class="headerlink" title="例子2: Non-terminating Child Example"></a>例子2: Non-terminating Child Example</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fork8</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* Child */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Running Child, PID = %d\n"</span>,getpid());</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>); <span class="comment">/* Infinite loop */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Terminating Parent, PID = %d\n"</span>,getpid());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，如果我们先终止的是父进程，我们发现即使父进程已经被终止了，但是子进程还是在运行当中。我们一定要显式地Kill 子进程才能终止。</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/27.png"></p>
<h3 id="wait-Synchronizing-with-Children"><a href="#wait-Synchronizing-with-Children" class="headerlink" title="wait: Synchronizing with Children"></a>wait: Synchronizing with Children</h3><p>如果我不去杀掉父进程，如何仍能在子进程 $exit(0)$ 的时候收回子进程？我们可以用wait函数。wait函数可以通过系统调用和子进程的状态进行同步。</p>
<p><code>int wait (int *child_status)</code> 这是wait函数的用法，后面跟的时子进程的状态</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/28.png"></p>
<p>调用wait之后，父进程就会进入一个suspended状态，等到子进程的特定的状态产生，才会做后面的事情。也就是做一个同步的工作。wait函数的返回值就是这个被终止掉的子进程的 <code>pid</code>，如果<code>child_status!=NULL</code>,那么它所指向的整数将被设置为一个值，该值指示子进程终止的原因和退出状态:</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/29.png"></p>
<h4 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fork9</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> child_status;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"HC: hello from child\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"HP: hello from parent\n"</span>);</span><br><span class="line">        wait(&amp;child_status);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"CT: child has terminated\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Bye\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请画出这个例子的流程图：</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/30.png"></p>
<p>我们看到，在fork之后，子进程会打印<code>HC: hello from child</code> ；而父进程会打印 <code>HP: hello from parent</code> 打印完之后父进程并不会直接打印 <code>CT</code> ，因为这时候他在等待子进程结束，等子进程结束之后，父进程才会打印<code>CT: child has terminated</code> 最后打印Bye</p>
<p>所以 <code>Feasible output</code> 可以为 HC HF CT Bye 或者 HP HC CT Bye</p>
<h4 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h4><p>如果多个子进程结束了，这时候该怎么办？ 这时候wait会接收任何一个子进程发出的信号。这时候对于父进程，需要得到终止的到底是哪个子进程，然后将终止的子进程的pid和子进程终止的状态显示出来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fork10</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid[N];</span><br><span class="line">    <span class="keyword">int</span> i, child_status;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    <span class="keyword">if</span> ((pid[i] = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">100</span>+i); <span class="comment">/* Child */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123; <span class="comment">/* Parent */</span></span><br><span class="line">        <span class="keyword">pid_t</span> wpid = wait(&amp;child_status);</span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(child_status))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Child %d terminated with exit status %d\n"</span>,wpid, WEXITSTATUS(child_status));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line"> 		    <span class="built_in">printf</span>(<span class="string">"Child %d terminate abnormally\n"</span>, wpid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我有很多的子进程，但我只关心某一个特定的子进程，那么我可以使用<code>waitpid</code>这个函数。通过这个函数，我们可以按照顺序依次回收进程。如果前面一个进程没有结束，那么后面一个进程也不能提前被回收。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fork11</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid[N];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> child_status;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        <span class="keyword">if</span> ((pid[i] = fork()) == <span class="number">0</span>)</span><br><span class="line">        	<span class="built_in">exit</span>(<span class="number">100</span>+i); <span class="comment">/* Child */</span></span><br><span class="line">    <span class="keyword">for</span> (i = N<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">pid_t</span> wpid = waitpid(pid[i], &amp;child_status, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(child_status))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Child %d terminated with exit status %d\n"</span>,wpid, WEXITSTATUS(child_status));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">	        <span class="built_in">printf</span>(<span class="string">"Child %d terminate abnormally\n"</span>, wpid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="execve"><a href="#execve" class="headerlink" title="execve"></a>execve</h3><p>Fork是创建一个进程，但是这个进程所有的东西都是和父亲共享的。但是有时候我们想要一个进程运行一个新的程序。这时候我们就需要构建一个程序的代码并加载程序，这时候就需要<code>execve</code> 来帮助我们完成</p>
<p><code>int execve(char *filename,char *argv[],char *envp[])</code></p>
<p><code>filename</code> 表明了文件在哪个地方，<code>*argv[]</code>是一个指针数组 <code>argv[0]</code>就是指这个filename ，没有<code>*argc[]</code> 的原因是因为 <code>argc</code> 代表了参数的个数，但是<code>execve</code>并不需要这个量 </p>
<p>作用就是 Overwrites code, data, and stack . 保留了 PID, open files and signal context</p>
<ul>
<li><code>execve</code> 函数仅调用一次，(成功的话)并且不会返回，这是因为函数将栈清除了，也就是说return地址没了，所以不会返回。<code>fork</code>是调用则会返回两次</li>
<li>但是如果<code>execve</code>调用不成功，那么就会返回-1</li>
</ul>
<p>比如说这样一段代码，首先创建一个子进程，然后对其执行 <code>/bin/ls -lt /usr/include</code> 命令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((pid = Fork()) == <span class="number">0</span>) &#123; <span class="comment">/* Child runs program */</span></span><br><span class="line">    <span class="keyword">if</span> (execve(myargv[<span class="number">0</span>], myargv, environ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s: Command not found.\n"</span>, myargv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/31.png"></p>
<p>在<code>execve</code> 加载了 filename之后，它调用了启动代码。启动代码设置栈，并将控制传递给了新程序的主函数，该主函数有如下形式的原型：<code>int main(int argc,char **argv,char **envp);</code> </p>
<p>当main开始执行的时候，用户栈的组织结构如下图所示 。让我们从栈底(高地址)往栈顶(低地址)依次看一看。首先是参数和环境字符串。全局变量<code>environ</code>指向这些指针中的第一个 <code>envp[0]</code>.紧随环境变量数组之后的是以null 结尾的argv[]数组，其中每个元素都指向栈中的一个参数字符串.</p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/32.png" style="zoom:67%;"></p>
<p><img src="/2020/12/24/%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%EF%BC%88ECF%EF%BC%891/33.png" style="zoom:67%;"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" class="post-title-link" itemprop="url">CSAPP动态内存分配</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-01 21:22:38" itemprop="dateCreated datePublished" datetime="2020-12-01T21:22:38+08:00">2020-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-25 16:21:54" itemprop="dateModified" datetime="2022-06-25T16:21:54+08:00">2022-06-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CSAPP动态内存分配"><a href="#CSAPP动态内存分配" class="headerlink" title="CSAPP动态内存分配"></a>CSAPP动态内存分配</h1><p>动态内存分配器维护着一个进程的虚拟内存区域，称为<strong>堆</strong>。 比如说 malloc，我们用malloc来申请一段虚拟内存的时候，操作系统分配给我们的是一段 block ，但这个block和之前提到的page、cache中的block是不一样的，这边每个block的<strong>大小是不一样</strong>的。</p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/1.png" style="zoom:80%;"></p>
<p>分配过来的blocks，有两种。</p>
<ul>
<li>一种是allocated也就是被分配的，已分配的块显式地保留 <strong>供应用程序使用</strong><ul>
<li>一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用<strong>程序显式执行的</strong>，要么是内<strong>存分配器自身隐式执行</strong>的。</li>
</ul>
</li>
<li>还有一种是free，也就是没有被分配的，因此可以用来分配。</li>
</ul>
<p>分配器也有两种：显式的分配器和隐式的分配器</p>
<ul>
<li>显式分配器：比如说 C语言中的malloc和free，C++当中的new和delete</li>
<li>隐式分配器：比如说 Java语言中的垃圾回收系统。</li>
</ul>
<h2 id="显式分配器"><a href="#显式分配器" class="headerlink" title="显式分配器"></a>显式分配器</h2><p>现在我们主要讨论显式分配器的设计与实现。</p>
<h3 id="malloc和free函数"><a href="#malloc和free函数" class="headerlink" title="malloc和free函数"></a>malloc和free函数</h3><h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>malloc</code>函数返回一个指针。执行完需要进行判断，因为不一定每次申请分配内存都能成功。如果申请不成功就返回一个空指针，并设置一个errno；若申请成功就返回一个大小至少为size字节的内存块，还有可能比size更大,因为给我们的块会为可能包含在这个块内的任何数据对象类型做对齐。在64位模式中，malloc返回的块的地址总是16的倍数。</p>
<h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br></pre></td></tr></table></figure>
<p>free适合malloc对应的，我们可以利用这个函数来回收之前分配的内存。注意，这个 * p 一定要是 malloc，calloc和realloc这三个函数的返回值，否则会报错。</p>
<h4 id="sbrk"><a href="#sbrk" class="headerlink" title="sbrk"></a>sbrk</h4><p>sbrk 函数通过将内核的brk 指针增加incr 来扩展和收缩堆。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sbrk</span><span class="params">(<span class="keyword">intptr_t</span> incr)</span></span></span><br></pre></td></tr></table></figure>
<p>下面是malloc和free函数实际使用例子：</p>
<p>首先我们用malloc申请一个长度为n的数值类型为long的数组。然后对数组进行一个赋值以及后续操作。最后在程序结束时将其free</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> i, *p;</span><br><span class="line">	<span class="comment">/* Allocate a block of n longs */</span></span><br><span class="line">	p = (<span class="keyword">long</span> *) <span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">long</span>)); </span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		perror(<span class="string">"malloc"</span>); </span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* Initialize allocated block */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">   		p[i] = i;</span><br><span class="line">    <span class="comment">/* Do something with p */</span></span><br><span class="line">    . . .</span><br><span class="line">    <span class="comment">/* Return allocated block to the heap */</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="malloc-和free-实现管理堆"><a href="#malloc-和free-实现管理堆" class="headerlink" title="malloc 和free 实现管理堆"></a>malloc 和free 实现管理堆</h4><p>假设下面是一个堆的模型，我们定义两条规则：</p>
<ul>
<li><p>Show 8-byte words as squares 没一格子代表了一个 word</p>
</li>
<li><p>Allocations are double-word aligned. 双字对齐</p>
</li>
</ul>
<p><code>#define SIZ sizeof(size_t)</code></p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/2.png" style="zoom:80%;"></p>
<ul>
<li>我们一开始申请4倍的SIZ ,于是就有了黄色的4个格子</li>
<li>紧接着我们申请5倍的SIZ，因为要<strong>双字对齐</strong>，因此我们要划出6个格子来。</li>
<li>我们申请6倍的SIZ,malloc 就从空闲块的前部切出一个6字的块</li>
<li>调用free后，会释放掉第二部申请的5*SIZ 的块。</li>
<li>程序请求一个2字的块。在这种情况中，malloc分配在前一步中被释放的那个块的一部分并返回一个指向这个新块的指针。</li>
</ul>
<p><strong>一些分配和回收时的约束</strong></p>
<ul>
<li>处理任意请求序列。一个应用可以有任意的分配请求和释放请求序列，只要满足约束条件：每个释放请求必须对应于一个当前已分配块，这个块是由一个以前的分配请求获得的。因此，<strong>分配器不可以假设分配和释放请求的顺序</strong>。例如，分配器不能假设<strong>所有</strong>的分配请求<strong>都有</strong>相匹配的释放请求，或者有相匹配的分配和空闲请求是嵌套的。</li>
<li>立即响应请求。分配器<strong>必须立即响应</strong>分配请求。因此，<strong>不允许</strong>分配器为了提髙性能<strong>重新排列或者缓冲</strong>请求。不能是异步的</li>
<li>只使用堆。为了使分配器是可扩展的，分配器使用的任何非标量数据结构都必须保存在堆里。</li>
<li>对齐块（对齐要求）。分配器必须对齐块，使得它们可以保存任何类型的数据对象。</li>
<li>不修改已分配的块。分配器只能操作或者改变空闲块。特别是，一旦块被分配了，就不允许修改或者移动它了。因此，诸如压缩已分配块这样的技术是不允许使用的。(就是把中间的空的blocks压出来，这种是不可以的)</li>
</ul>
<h3 id="衡量分配器性能的一些指数："><a href="#衡量分配器性能的一些指数：" class="headerlink" title="衡量分配器性能的一些指数："></a>衡量分配器性能的一些指数：</h3><h4 id="吞吐率"><a href="#吞吐率" class="headerlink" title="吞吐率"></a>吞吐率</h4><p>现在我们假设 假定n 个分配和释放请求的某种序列 $R<em>0,R_1,\cdots,R_k,\cdots ,R</em>{n-1}$；我们希望一个分配器的吞吐率最大化,吞吐率的定义就是每个单位时间里完成的请求数。</p>
<p>例如，如果一个分配器在1 秒内完成500 个分配请求和500 个释放请求，那么它的吞吐率就是每秒1000 次操作</p>
<h4 id="内存利用率"><a href="#内存利用率" class="headerlink" title="内存利用率"></a>内存利用率</h4><p>我们要知道内存虚拟内存是一个有限的空间，我们不能一直向他申请blocks，因此我们必须高效地使用虚拟内存。对于可能被要求分配和释放大块内存的动态内存分配器来说，尤其如此。</p>
<h4 id="峰值利用率"><a href="#峰值利用率" class="headerlink" title="峰值利用率"></a>峰值利用率</h4><p>对于n 个分配和释放请求的某种序列 $R<em>0,R_1,\cdots,R_k,\cdots ,R</em>{n-1}$</p>
<p>如果说一个应用程序请求一个 p 字节的块，那么得到的已分配块地<strong>payload</strong> 是 p字节。</p>
<p>在请求 $R_k$ 完成之后，aggregate payload(聚集有效载荷) 表示为 $P_k$,即当前已分配的块地有效载荷之和。</p>
<p>$H_k$表示堆地当前的大小(单调非递减)</p>
<p>那么，前面 k+1 个请求得峰值利用率，表示为 $U<em>k$, $U_k = \frac{max</em>{i\leq k}P_i}{H_k}$ </p>
<p>我们看到，分配器的目标就是在整个序列中使 $U_{n-1}$ 最大化。但是最大化吞吐率和最大化利用率之间是相互牵制的。</p>
<p>当我们以<strong>堆利用率为代价时</strong> ，很容易编写出<strong>吞吐率最大化的</strong>分配器。</p>
<h3 id="Fragmentation"><a href="#Fragmentation" class="headerlink" title="Fragmentation"></a>Fragmentation</h3><p>碎片即分配内存时产生的额外开销，它也是造成堆利用率很低的主要原因</p>
<p>有两种形式的碎片：内部碎片(internal fragmentation)和外部碎片（external fragmentation)</p>
<h4 id="internal-fragmentation"><a href="#internal-fragmentation" class="headerlink" title="internal fragmentation"></a>internal fragmentation</h4><p>内部碎片就是<strong>已经被分配</strong>出去（能明确指出属于哪个进程）<strong>却不能被利用</strong>的内存空间</p>
<p>占有这些区域或页面的<strong>进程并不使用这个存储块</strong>。而在进程占有这块存储块时，<strong>系统无法利用</strong>它。直到进程释放它，或进程结束时，系统才有可能利用这个存储块。</p>
<p>当一个已分配块(allocated block) 比有效载荷(payload) 大的时候，内部碎片就会发生</p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/3.png" style="zoom:80%;"></p>
<h4 id="external-fragmentation"><a href="#external-fragmentation" class="headerlink" title="external fragmentation"></a>external fragmentation</h4><p>外部碎片是位于任何两个 <strong>操作系统分配的用于装载进程的内存区域</strong> 或<strong>页面之间</strong>的空闲区域</p>
<p>外部碎片指的是还没有被分配出去（不属于任何进程），但由于<strong>太小了</strong>无法分配给申请内存空间的新进程的内存空闲区域。</p>
<p>外部碎片是处于任何两个已分配区域或页面之间的空闲存储块。这些存储块的<strong>总和可以满足当前申请</strong>的长度要求，但是由于它们的<strong>地址不连续</strong>或其他原因，使得系统无法满足当前申请。</p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/4.png" style="zoom:80%;"></p>
<p>比如说对于第五个请求，heap中明明有8个格子，但是却无法给7*SIZ分配空间</p>
<h3 id="实现一个分配器"><a href="#实现一个分配器" class="headerlink" title="实现一个分配器"></a>实现一个分配器</h3><p>要实现一个分配器，我们必须要解决这样几个问题</p>
<ul>
<li><p>How do we know how much memory to free given just a pointer?</p>
<ul>
<li>给free一个指针，那么分配器要怎么知道释放多少大小的内存空间？</li>
</ul>
</li>
<li><p>空闲块组织：How do we keep track of the free blocks? </p>
<ul>
<li>我们怎么知道那些blocks是空的呢？怎么知道这一块空的区域的大小呢？</li>
</ul>
</li>
<li>分割：What do we do with the extra space when allocating a structure that is smaller than the free block it is placed in?<ul>
<li>当分配一个比它所在的空闲块还小的结构时，我们如何处理额外的空间 (比如说6块空的分配掉4块，那么剩下两块怎么标记？)</li>
</ul>
</li>
<li>放置：How do we pick a block to use for allocation — many might fit?<ul>
<li>如果我有多个满足条件的空间，我应该选择哪一个进行分配</li>
</ul>
</li>
<li>合并：How do we reuse a block that has been freed?<ul>
<li>释放出来后的内存空间我怎么重新利用？比如前面也是空的，后面也是空的，我要不要将他们合并在一起？</li>
</ul>
</li>
</ul>
<h3 id="隐式空闲链表"><a href="#隐式空闲链表" class="headerlink" title="隐式空闲链表"></a>隐式空闲链表</h3><p>因为像放置、分割以及合并这样的基本技术贯穿在许多不同的空闲块组织中，所以我们将在一种叫做隐式空闲链表的简单空闲块组织结构中来介绍它们。</p>
<p>隐式分配器：会自动回收用户使用的存储空间，简单来说就是带GC功能，如Java使用的就是隐式的堆分配器</p>
<p>显式分配器：要求用户显示的分配/释放堆空间，如C/C++用的就是显式的堆分配器</p>
<h4 id="释放多少大小的内存空间"><a href="#释放多少大小的内存空间" class="headerlink" title="释放多少大小的内存空间"></a>释放多少大小的内存空间</h4><p>如果我们要知道在释放时应该是放多少空间，那么我们可以在每一块block的前面放一个word来记录这个block的大小。比如说我这里申请了4个SIZ，分配了6个SIZ，那么就在一个word中记录这个block的大小：即48.</p>
<p>前面的word是这个block的header；后面的多余的空格即这个block的Padding(填充物)</p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/5.png" style="zoom:80%;"></p>
<h4 id="1-0-Keeping-Track-of-Free-Blocks"><a href="#1-0-Keeping-Track-of-Free-Blocks" class="headerlink" title="1.0 Keeping Track of Free Blocks"></a>1.0 Keeping Track of Free Blocks</h4><p>对于隐式的链表来说：</p>
<p>我们知道，每一个payload开始的位置必须是偶数个word，但是上面说了，每一个block的第一个word记录了这个block的大小。因此在堆的一开始我们必须空出来一个word。</p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/7.png" style="zoom:80%;"></p>
<p> 此外还有三种方法：</p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/9.png" style="zoom:80%;"></p>
<p>将一个block放大，我们可以看到这样的结构：</p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/6.png" style="zoom:80%;"></p>
<p>也就是说一个block 是由一个字的header、payload 以及一些padding组成的。header编码了这个块的大小，以及这个块是已分配的还是空闲的。如果我们强加一个双字的对齐约束条件，那么块大小就总是8 的倍数，且块大小的最低3 位总是零。(因为这是一个二进制数，因此只要满足后三位总是0，那么<strong>前面29位所表达的块的大小</strong> 就始终是8的倍数)因此，我们只需要内存大小的29 个高位，释放剩余的3 位来编码其他信息。</p>
<p>我们用3位中的最低位a来指明这个块是分配的还是空闲的。那么这个头部的大小计算公式就是：</p>
<p><code>block-&gt;header = size|alloc;</code></p>
<p>比如说一个分配的块的大小是24字节，那么它的头部就等于 </p>
<p><code>0x00000018|0x1 = 0x00000019</code></p>
<p>一个块大小为40(0x28) 字节的<strong>空闲块</strong>具有如下的头部</p>
<p><code>0x00000028|0x0 = 0x00000028</code></p>
<p>假设块的格式如上图所示，我们可以将堆组织为一个连续的已分配块和空闲块的序列</p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/8.png" style="zoom:80%;"></p>
<p>我们称这种结构为隐式空闲链表，是因为空闲块是通过头部中的大小字段隐含地连接着的。分配器可以通过遍历堆中所有的块，从而间接地遍历整个空闲块的集合。</p>
<p>注意，我们需要某种特殊标记的结束块，在这个示例中，就是一个设置了<strong>已分配位而大小为零</strong>的<strong>终止头部</strong>(end block)</p>
<p><strong>隐式空闲链表的优点是简单。显著的缺点是任何操作的开销，例如放置分配的块，要求对空闲链表进行搜索，该搜索所需时间与堆中已分配块和空闲块的总数呈线性关系。</strong></p>
<p>很重要的一点就是意识到系统<strong>对齐要求</strong>和<strong>分配器对块格式的选择</strong>会对分配器上的<strong>最小块大小</strong>有<strong>强制的要求</strong>。没有已分配块或者空闲块可以比这个最小值还小。例如，如果我们假设一个双字的对齐要求，那么每个块的大小都必须是双字（8 字节）的倍数。因此,9-35的块格式就导致<strong>最小的块大小为两个字</strong>：一个字作头，另一个字维持对齐要求。即使应用只请求一字节，分配器也仍然需要创建一个两字的块。</p>
<h4 id="放置策略-placement-policy"><a href="#放置策略-placement-policy" class="headerlink" title="放置策略(placement policy)"></a>放置策略(placement policy)</h4><p>当一个应用请求一个k字节的块的时候，分配器就会搜索空闲列表来查找一个足够大的可以放置所请求块的空闲块。我们有很多种放置策略：</p>
<h5 id="首次适配"><a href="#首次适配" class="headerlink" title="首次适配"></a>首次适配</h5><p>首次适配即从链表头开始查找，选择第一个合适的空闲块。</p>
<p>优点就是它趋向于将大的空闲块保留在链表后面</p>
<p>缺点是它趋向于在靠近链表起始处留下小空闲块的“碎片”，这就增加了对较大块的搜索时间</p>
<h5 id="下一次适配"><a href="#下一次适配" class="headerlink" title="下一次适配"></a>下一次适配</h5><p>下一次适配和首次适配相似，只不过不是从链表的起始处开始搜索，而是<strong>从上一次查询结束的地方开始</strong></p>
<p>下一次适配比首次适配运行起来明显要快一些。但是内存利用率要比首次适配低得多。</p>
<h5 id="最佳适配"><a href="#最佳适配" class="headerlink" title="最佳适配"></a>最佳适配</h5><p>最佳适配是检査每个空闲块，选择适合所需请求大小的最小空闲块</p>
<p>最佳适配比首次是配合下一次适配的利用率都要高一点，但在<strong>简单空闲链表组织结构(如隐式空闲链表)当中</strong>，使用最佳适配的缺点就是它要求对堆进行彻底的搜索。</p>
<h4 id="分割空闲块"><a href="#分割空闲块" class="headerlink" title="分割空闲块"></a>分割空闲块</h4><p>当我们找到一个匹配的空闲块之后，我们就需要分配这个空闲块中的空间。</p>
<p>我们自然可以选用整个空闲块，但是这样就会造成很多内部碎片。但如果放置策略趋向于产生较好的匹配，那么额外的内部碎片也是可以接受的。</p>
<p>但是如果匹配得不太好，那么分配器就通常会选择将这个空闲块分割为两部分。第一部分变成分配块，剩下的空间形成一个新的空闲块。</p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/10.png" style="zoom:80%;"></p>
<p>比如说上图，我们在size = 48的空闲块中插入一个size = 32的block，这时候空间块就会被拆成一个长为32的分配块、一个长为16的空闲块</p>
<h4 id="释放、合并空闲块"><a href="#释放、合并空闲块" class="headerlink" title="释放、合并空闲块"></a>释放、合并空闲块</h4><p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/11.png" style="zoom:80%;"></p>
<p>在释放块是时，我们不需要对被释放的块的header进行修改。我们只需要跳过这个block，将前一个header指向下下个block的header即可。</p>
<p>上面所说的是和后面的block相连，但是如果想要和<strong>前一个block相连</strong>，那么事情就变得复杂起来了。因为如果我们的模型只是一个带头部的隐式空闲链表，就没有一个指针指向前面一个block。那么我们只能是搜索整个链表，同时记住前面块的位置。那么如果这样操作，我们会发现每次调用free所需要的时间都和堆的大小成线性关系。即使使用更复杂更精细的空闲链表，搜索时间也不会是常数。</p>
<h4 id="2-0-带边界标记的合并"><a href="#2-0-带边界标记的合并" class="headerlink" title="2.0 带边界标记的合并"></a>2.0 带边界标记的合并</h4><p>于是我们可以将刚才提出的模型进行一个修改。这个修改是knuth提出来的。对于一个free block(空闲的块)，我们可以把这个块的结尾处改成一个footer。其中，<strong>footer是header的一个副本</strong>。这个设计十分巧妙，如果每个块都包括这样一个footer，那么分配器就可以通过检查它的footer，来判断前面一个块的起始位置和状态。</p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/12.png" style="zoom:80%;"> </p>
<p>那么当分配器释放当前块的时候，可能存在有以下四种情况</p>
<p><strong>1) 前面的块和后面的块都是已分配的</strong></p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/14.png" style="zoom:80%;"></p>
<p>对于这种情况，我们只要将中间这个空闲块的header和footer的占用位从1改成0即可。</p>
<p><strong>2) 前面的块是已分配的，后面的块是空闲的</strong></p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/15.png" style="zoom:80%;"></p>
<p>对于这种情况，新的header的和就等于释放的这一块的header+它后面那块free block的header，然后对footer也进行相应的修改。并将二者的占用位改成0</p>
<p><strong>3) 前面的块是空闲的，后面的块是已分配的</strong></p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/16.png" style="zoom:80%;"></p>
<p>这种情况和2一样。</p>
<p><strong>4) 前面的和后面的块都是空闲的</strong></p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/17.png" style="zoom:80%;"></p>
<p>对于前面的块和后面的块都是free block的情况，我们需要修改前面的块的header和后面的块的footer。其大小就是将三个块的大小相加。对于中间这些数据，都被跳过了，不用去修改它们。</p>
<p>于是整个模型如下图所示：</p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/13.png" style="zoom:80%;"></p>
<p>我们发现<strong>最前面和最后面的两块空间是利用不起来的</strong>。因为malloc返回的地址并不是header的起始地址，而是<strong>payload的起始地址</strong>。而payload的起始地址必须是偶数对齐的，因此必须要有一个word空出来的。</p>
<p>因为heap是自底向上生长的，因此我们定义Dummy footer是在第一个block之前的；Dummy header是在最后一个block之后的。而且他们都要被标记成已分配，这是因为他们不能和block进行合并操作。</p>
<h4 id="3-0-No-Boundary-Tag-for-Allocated-Blocks"><a href="#3-0-No-Boundary-Tag-for-Allocated-Blocks" class="headerlink" title="3.0 No Boundary Tag for Allocated Blocks"></a>3.0 No Boundary Tag for Allocated Blocks</h4><p>对于已经分配了的blocks来说，如果要有footer，由于对齐的原因，有可能要多两个字节来存放。因此，我们可以对分配了的block进行一些修改：</p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/19.png" style="zoom:80%;"></p>
<p>我们可以进一步地用2位来表示状态，多出来的一位可以用来表示前一个block是满的还是空的。这样，我们仅仅用一位就能节省额外地footer，分配了的block仅保留一个header。但是对于payload为空的块，我们还是保留footer。</p>
<p>那么上面所说的4种情况就要发生一些细小的改变了：</p>
<p><strong>1) 前面的块和后面的块都是已分配的</strong></p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/20.png" style="zoom:80%;"></p>
<p><strong>2) 前面的块是已分配的，后面的块是空闲的</strong></p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/21.png" style="zoom:80%;"></p>
<p><strong>3) 前面的块是空闲的，后面的块是已分配的</strong></p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/22.png" style="zoom:80%;"></p>
<p><strong>4) 前面的和后面的块都是空闲的</strong></p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/23.png" style="zoom:80%;"></p>
<h3 id="隐式空闲链表总结"><a href="#隐式空闲链表总结" class="headerlink" title="隐式空闲链表总结"></a>隐式空闲链表总结</h3><ul>
<li>Implementation 实现是比较简单的</li>
<li>Allocate cost：<ul>
<li>Linear time worst case 最差情况下分配时间是线性的</li>
</ul>
</li>
<li>Free cost：<ul>
<li>constant time worst case 最差情况下也是常数时间</li>
<li>even with coalescing   </li>
</ul>
</li>
<li>Memory overhead<ul>
<li>will depend on placement policy 时间复杂的决定于放置策略</li>
<li>First-fit ,next-fit ,best-fit 有三种放置策略</li>
</ul>
</li>
<li>Not used in practice for malloc/free because of linear time allocation <ul>
<li>used in many special purpose applications</li>
</ul>
</li>
<li>However ,the concepts of splitting and boundary tag coalescing are general to all allocators</li>
</ul>
<h3 id="显式空闲链表"><a href="#显式空闲链表" class="headerlink" title="显式空闲链表"></a>显式空闲链表</h3><p>显示链表是说我并不需要管理分配的空间，而是要管好那些空闲的空间. 因为块分配与堆块的总数呈线性关系，所以对于通用的分配器，隐式空闲链表是不适合的。</p>
<p><img src="/2020/12/01/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/24.png" style="zoom:80%;"></p>
<p>一种更好的方法是将空闲块组织为某种形式的显式数据结构。因为根据定义，程序不需要一个空闲块的主体，所以实现这个数据结构的指针可以存放在这些空闲块的主体里面。例如，堆可以组织成一个双向空闲链表，在每个空闲块中，都包含一个pred(前驱）和succ(后继指针)</p>
<p>使用双向链表而不是隐式空闲链表，使首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。不过，释放一个块的时间可以是线性的，也可能是个常数，这取决于我们所选择的空闲链表中块的排序策略。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/11/26/OptimalBST/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/26/OptimalBST/" class="post-title-link" itemprop="url">OptimalBST</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-11-26 15:30:07 / Modified: 22:20:58" itemprop="dateCreated datePublished" datetime="2020-11-26T15:30:07+08:00">2020-11-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DP/" itemprop="url" rel="index"><span itemprop="name">DP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Optimal-BST"><a href="#Optimal-BST" class="headerlink" title="Optimal BST"></a>Optimal BST</h1><h2 id="什么是最优二叉搜索树？"><a href="#什么是最优二叉搜索树？" class="headerlink" title="什么是最优二叉搜索树？"></a>什么是最优二叉搜索树？</h2><p>假设我们在设计一个实现英语到法语的翻译，对英语文本中出现的每个单词查找对应的法语单词。</p>
<p>为了实现这个操作，我们可以创建一颗二叉搜索树，将n个英语单词作为关键词，对应的法语单词作为关联数据。</p>
<p>于对文本中的每个单词都要进行搜索， 我们希望花费在搜索上的总时间尽量少</p>
<p>我们知道平衡二叉搜索树或者红黑树的搜索时间是 $O(logn)$ 。但是，单词出现的频率是不同的。</p>
<p>像 “the” 这种频繁使用的单词有可能位于搜索树中远离根的位置上，搜索一次可能需要花费很多时间；而像 “machicolation” 这种很少使用的单词可能位于靠近根的位置上，搜索一次只要花很少的时间。</p>
<p>这样的结构会减慢翻译的速度， 因为在二叉树搜索树中<strong>搜索一个关键字需要访问的结点数</strong>等于<strong>包含关键字的结点的深度加1</strong> , 我们希望文本中频繁出现的单词被置于靠近根的位置。更甚者，文本中的一些单词可能没有对应的法语单词，这些单词根本不应该出现在二叉搜索树中中。</p>
<p>于是我们定义：<strong>在给定单词出现频率的前提下，我们应该如何组织一颗二叉搜索树，使得所有搜索操作访问的结点总数最少</strong>，就是一个最优二叉搜索树问题。</p>
<p>抽象总结一下这个问题：</p>
<p>给定一个n个不同关键字已排序的序列$K=<k_1,k_2,\cdots,k_n>$ 我们希望用这些关键字构造一棵二叉搜索树。对于每个关键字 $k<em>i$ ，都有一个概率 $p_i$ 表示其搜索频率。<br>有些要搜索的值可能不在k当中，因此我们还需要有n+1个”伪关键字” $d_0,d_1,\cdots d_n$ 表示<strong>不在K中的值</strong>：其中 $d_0$ 表示所有小于 $k_1$ 的值，$d_n$ 表示所有大于$k_n$ 的值，对 $i = 1,2,\cdots,n-1$ ，伪关键字 $d_i $ 表示所有在 $k_i$ 和 $k</em>{i+1}$ 之间的值。对每个伪关键字 $d_i$ ，也都有一个概率p表示对应的搜索频率。这些结点是整个二叉树的叶子结点</k_1,k_2,\cdots,k_n></p>
<p>下图是对一个 n=5 个关键字的集合构造的两颗二叉搜索树。 每次搜索要么成功(找到关键字$k_i$)，要么失败(找到某个伪关键字$d_i$) </p>
<p>因此 我们可以得到如下公式： $\sum<em>{i=1}^n p_i+\sum</em>{i=0}^n q_i = 1$ </p>
<p><img src="/2020/11/26/OptimalBST/1.png" style="zoom: 120%;"></p>
<p>对于 $p_i$ 和$q_i$ 的搜索概率如下：</p>
<p><img src="/2020/11/26/OptimalBST/2.png" style="zoom: 120%;"></p>
<p>由于我们知道每个关键字和伪关键字的搜索概率，因而可以确定一颗给定的二叉搜索树T中进行一次搜索的期望代价</p>
<p>假定一次搜索的代价等于访问的节点数，即此次搜索找到的结点在T中的深度再加1，那么计算公式如下：</p>
<p>$E[T中搜索代价] = \sum<em>{i=1}^n(depth_T(k_i)+1)*p_i+\sum</em>{i=0}^n(depth_T(d_i)+1)*q_i$ </p>
<p>从这个公式我们可以算出，上图(a)树的期望搜索代价为2.80，而(b)树的期望搜索代价为2.75</p>
<p>那么对于一个给定的概率集合，我们希望构造一棵期望搜索代价最小的二叉树，称之为最优二叉搜索树。对于上面这组概率来说，最优二叉搜索树是 (b)树。</p>
<p>因此可见最优二叉搜索树并不一定是最矮的(b比a高)，而且概率最高的关键字也并不一定出现在二叉搜索树的根节点(概率最高应该是k5而最优二叉搜索树的根节点是$k_2$)。 </p>
<p>关于这个问题，我们如果通过穷举法，肯定是不行的，因此我们采用动态规划的方法来求解：</p>
<h2 id="动态规划方法求解"><a href="#动态规划方法求解" class="headerlink" title="动态规划方法求解"></a>动态规划方法求解</h2><h3 id="最优二叉搜索树的最优解"><a href="#最优二叉搜索树的最优解" class="headerlink" title="最优二叉搜索树的最优解"></a>最优二叉搜索树的最优解</h3><p>给定关键字序列 $k<em>i,\cdots,k_j$,其中某个关键字，比如说 $k_r(i\leq r\leq j)$, 是这些关键字的最优子树的<strong>根节点</strong>。那么 $k_r$ 的左子树就包含关键字 $k_i,\cdots,k</em>{r-1}$和伪关键字($d<em>{i-1},\cdots,d</em>{r-1}$) ；同理右子树包含关键字 $k<em>{r+1},\cdots ,k_j$ 和伪关键字 ($d_r,\cdots,d_j$). 只要我们检查所有可能的根节点 $k_r(i\leq r\leq j)$,并对每种情况分别求包含 $k_i,\cdots,k</em>{r-1}$ 以及包含$k_{r+1},\cdots ,k_j$ 的最优二叉搜索树，即可保证找到原问题的最优解。</p>
<h3 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h3><p>我们定义 $e[i,j]$ 为在包含关键字 $k_i,\cdots,k_j$ 的最优二叉搜索树中进行一次搜索的期望代价。最终我们希望计算出 $e[1,n]$</p>
<p>当 $j\geq i$ 的时候，我们需要从 $k<em>i,\cdots,k_j$中选择一个根节点 $k_r$ ，然后构造一颗包含关键字 $k_i,\cdots,k</em>{r-1}$ 的最优二叉搜索树作为其左子树，以及一颗包含关键字 $k_{r+1},\cdots,k_j$ 的二叉搜索树作为其右子树。</p>
<p>由于当一颗子树成为一个结点的字数时，期望搜索代价的增加值应为所有的概率之和，因此对于包含关键字 $k<em>i,\cdots,k_j$ 的子树，所有概率之和为 $w(i,j) = \sum</em>{l=i}^jp<em>l+\sum</em>{l=i-1}^jq_l$ </p>
<p>因此，若 $k_r$ 为包含关键字 $k_i,\cdots,k_j$ 的最优二叉搜索树的根节点，我们有如下公式</p>
<p>$e[i,j] = p_r+(e[i,r-1]+w(i,r-1))+(e[r+1,j]+w(r+1,j))$ </p>
<p>又因为 $w(i,j) = w(i,r-1)+p_r+w(r+1,j)$</p>
<p>因此$e[i,j]$ 可以重写为 $e[i,j]=e[i,r-1]+e[r+1,j]+w(i,j)$ </p>
<p>我们可以选取期望搜索代价最低者作为根节点，可以得到最终的递归公式</p>
<p><img src="/2020/11/26/OptimalBST/3.png" style="zoom: 120%;"></p>
<p>$e[i,j]$ 的值给出了最优二叉搜索树的期望搜索代价。为了记录最优二叉搜索树的结构，对于包含关键字 $k_i,\cdots,k_j(i\leq i\leq j\leq n)$ 的最优二叉搜索树，我们定义 $root[i,j]$ 保存根结点 $k_r$ 的下标r。</p>
<h3 id="计算最优二叉搜索树的期望搜索代价"><a href="#计算最优二叉搜索树的期望搜索代价" class="headerlink" title="计算最优二叉搜索树的期望搜索代价"></a>计算最优二叉搜索树的期望搜索代价</h3><p>​                                                                </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/" class="post-title-link" itemprop="url">卷积神经网路理论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-24 21:37:52" itemprop="dateCreated datePublished" datetime="2020-11-24T21:37:52+08:00">2020-11-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-12-02 13:04:50" itemprop="dateModified" datetime="2021-12-02T13:04:50+08:00">2021-12-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="卷积神经网路理论"><a href="#卷积神经网路理论" class="headerlink" title="卷积神经网路理论"></a>卷积神经网路理论</h1><h2 id="Convolutional-Neural-Networks"><a href="#Convolutional-Neural-Networks" class="headerlink" title="Convolutional Neural Networks"></a>Convolutional Neural Networks</h2><p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/1.png" style="zoom:120%;"></p>
<p>对于这张图片，我们会产生一种错觉：图片中的人是向右看的还是向前看的。我们发现如果我们观察这个人的右轮廓，就会觉得这个人是向右看的。如果我们直视这个人的眼睛和耳朵，那么就会觉得这个人是向前看的。因此我们可以推断出我们看见什么取决于大脑看见的特征.</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/1.jpg" style="zoom:60%;"></p>
<p>又比如说这一张图，我们如果看红色的轮廓，那我们会认为这是一个年轻的小孩正在侧脸注视前方。但是如果我们看蓝笔画出的轮廓，就会观察到一个老婆婆低下头打着盹。</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/3.png" style="zoom:100%;"></p>
<p>最后一张图片，让我们的大脑变得无所适从——我们会在两张脸的特征上跳来跳去，导致一开始这张图片会有些眼花缭乱的感觉。</p>
<p>这三个例子都在告诉我们我们的大脑是怎么运作的：大脑分析处理现实生活中看到的东西的特征然后经过处理得到我们认知的图像。这就导致了我们会出现很多错觉。</p>
<p>在卷积神经网络当中，机器处理分析图像的方式和我们的大脑非常类似。</p>
<p>现在我们来看一些例子：下面三张图片是神经网络预测的图片</p>
<p>前两幅图计算机都非常准确得预测了照片中的物体，但是对于第三张图片的预测却出现了偏差。这是因为第三张图片本身拍摄的就不是非常清晰，特征也不是很明显，下面几个选项的描述也有点模糊。因此机器预测这个图片中的物品是剪刀而不是放大镜  </p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/4.png" style="zoom:100%;"></p>
<p>这是CNN(卷积神经网络) 的简易模型：</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/5.png" style="zoom:100%;"></p>
<p>比如说：</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/6.png" style="zoom:100%;"></p>
<p>卷积神经网络并不会给出一个100%的概率，这就好像有时候我们会对别人的表情神态判断错误一样</p>
<p>对于一幅图片，我们知道它是由像素组成的。在电脑里，一张图片就表现为一个矩阵。比如说一张2x2像素的灰白图，在电脑里就是一个2x2的矩阵，每个元素的取值范围是 (0,255)</p>
<p>如果是一张彩色的照片，那么我们就需要3个2x2的矩阵来对其进行存储，因为色彩是由3个维度的数据RGB组成的。</p>
<h3 id="计算机怎么读取图片"><a href="#计算机怎么读取图片" class="headerlink" title="计算机怎么读取图片"></a>计算机怎么读取图片</h3><p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/7.png" style="zoom:100%;"></p>
<p>比如说一个笑脸的照片，我们可以用01矩阵来存储：0代表白，1代表黑</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/8.png" style="zoom:100%;"></p>
<h3 id="卷积网络的步骤"><a href="#卷积网络的步骤" class="headerlink" title="卷积网络的步骤"></a>卷积网络的步骤</h3><p>STEP1: Convolution 卷积</p>
<p>STEP2: Max Pooling 最大池化</p>
<p>STEP3: Flattening 平坦化</p>
<p>STEP4: Full Connection 全连接</p>
<h2 id="Convolution"><a href="#Convolution" class="headerlink" title="Convolution"></a>Convolution</h2><p>这是卷积的公式,但是这里我们并不会过多的解释数学层面的，因此其内部的原理可以参考这篇文章：</p>
<p><a href="http://cs.nju.edu.cn/wujx/paper/CNN.pdf" target="_blank" rel="noopener">http://cs.nju.edu.cn/wujx/paper/CNN.pdf</a></p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/10.png" style="zoom:100%;"></p>
<p>那么，卷积的直观含义是什么呢？</p>
<p>假设左边的矩阵是输入的图片，为了简化像素用01表示。中间的3x3矩阵叫做特征探测器，大多数卷积神经网络中用的都是3x3的矩阵，但是也有用5x5和7x7的。特征探测器和输入的图像矩阵做一个运算: 将特征探测器覆盖在图像矩阵的一片区域上，然后将这九个数相对应的一个值乘以一个值，计算过后特征探测器会向右移动，移动的距离叫做步长。最后计算九个数对应相乘的和</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/12.png" style="zoom:100%;"></p>
<p>计算过后的矩阵如下：我们可以叫它 特征图或者Convolved Feature, 显然这个输入的矩阵被压缩了一点。这里我们用的步长是1(当步长为2的时候，得到的Feature Map就会进一步变小，通常2的效果更好)。</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/11.png" style="zoom:100%;"></p>
<p>卷积过后，虽然矩阵中存储的数据变少了，但是特征探测器的目的是探测某些特征，也就是探测图像的某些完整部分。特征探测器具有某些特定的模式，而Feature map中数字最大的地方就是与探测器模式相匹配的地方。</p>
<p>这和我们大脑的工作模式相似，我们并不会一个一个像素看，而是看一些局部的特征。卷积也是这样，通过特征探测器在特征图中保留下有用的信息。</p>
<p>卷积过程中仅仅创建一张特征图是远远不够的。因为我们需要用到多个不同种类的特征探测器，所以需要创建多个特征图来保留图像中的信息。 然后，通过神经网络的训练，来决定哪个特征对于某个分类特别重要。</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/13.png" style="zoom:100%;"></p>
<p>特征探测在滤镜/美化图片当中有广泛的应用，比如说对于这张泰姬陵的照片</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/14.png" style="zoom:100%;"></p>
<h4 id="锐化"><a href="#锐化" class="headerlink" title="锐化"></a>锐化</h4><p>如果特征探测器是这样的，那么会对图像产生锐化的效果，照片会更加清晰：</p>
<p>因为这个探测器中间的数值是5，周围是-1，这个目的就是突触主体元素，而减少边缘周围的像素。</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/15.png" style="zoom:100%;"></p>
<h4 id="模糊"><a href="#模糊" class="headerlink" title="模糊"></a>模糊</h4><p>同样，模糊操作是一个 全部都是1的 探测器，这就说明了中间的像素和周围像素有着同等的重要性。他们合在一起就像是图片变模糊了一样</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/16.png" style="zoom:100%;"></p>
<h4 id="边界增强滤镜"><a href="#边界增强滤镜" class="headerlink" title="边界增强滤镜:"></a>边界增强滤镜:</h4><p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/17.png" style="zoom:100%;"></p>
<p>这个探测器只有-1和1，也就是说我们去掉了围绕中间主要元素周围的像素，只在左边保留一个-1。但是这个探测器的原理比较难以理解</p>
<h4 id="边界探测滤镜："><a href="#边界探测滤镜：" class="headerlink" title="边界探测滤镜："></a>边界探测滤镜：</h4><p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/18.png" style="zoom:100%;"></p>
<p>中间是4而上下左右是1，因此这个探测器削弱了中间主要元素的重要性，而提升了周围元素的重要性。这就期限了探测边框的效果</p>
<h4 id="Emboss浮雕滤镜"><a href="#Emboss浮雕滤镜" class="headerlink" title="Emboss浮雕滤镜"></a>Emboss浮雕滤镜</h4><p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/19.png" style="zoom:100%;"></p>
<p>这个探测器，我们发现它是左右不对成的，因此体现在图片上也感觉到这个图片朝左凸出</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/20.png" style="zoom:100%;"></p>
<h3 id="ReLU-Layer-线性整流函数"><a href="#ReLU-Layer-线性整流函数" class="headerlink" title="ReLU Layer 线性整流函数"></a>ReLU Layer 线性整流函数</h3><p>现在我们来介绍 ReLU，这是在卷积的基础上再添加的一个步骤</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/21.png" style="zoom:100%;"></p>
<p>数据通过ReLU后，过滤掉负值，只会保留非负值，比如下面这幅图的效果：</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/25.png" style="zoom:100%;"></p>
<p>使用 ReLU的原因是它类似于一个过滤器，能打破神经网络的线性，并提高图像里或者神经网络模型中的 非线性。那么为什么要提高非线性呢？因为图像通常是高度非线性的，当我们在识别相邻不同物体时，有不同的边界、不同的颜色，因此图像可能具有很多非线性的元素。但是当我们进行卷积操作去建立我们的特征图的时候，有可能会引进一些线性的东西。</p>
<p>下面是一个例子：</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/22.png" style="zoom:100%;"></p>
<p>这张建筑物的图片，通过探测器处理之后变成了这样一张图片：</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/23.png" style="zoom:100%;"></p>
<p>其中，黑色是负值而白色是正值。我们看到这幅图片中，白色到黑色之间是类似于线性变化的。但是我们再通过ReLU处理一下，就会得到这样一幅图片：</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/24.png" style="zoom:100%;"></p>
<p>我们发现这样子的话这张图片就只有非负值了，白色和灰色之间没有一个渐变的阶段。</p>
<p>虽然我们现在还不能解释这样处理的好处，但是起码能给我们一个主观上的感受。</p>
<p>运用ReLU而不是Sigmoid函数，因为ReLU能有效解决梯度爆炸的问题，计算速度非常快（之所以计算快，因为relu函数公式的原因）<br>而之前的sigmoid函数的缺点：计算量相对大（公式$1/(1+e^{-z})$复杂），sigmoid函数反向传播时，很容易就会出现梯度爆炸现象</p>
<p>拓展阅读资料：</p>
<p> <a href="https://arxiv.org/pdf/1609.04112.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1609.04112.pdf</a></p>
<p><a href="https://arxiv.org/pdf/1502.01852.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1502.01852.pdf</a></p>
<h2 id="Max-Pooling-最大池化"><a href="#Max-Pooling-最大池化" class="headerlink" title="Max Pooling  最大池化"></a>Max Pooling  最大池化</h2><p> 现在我们有好几张不同角度拍摄的猎豹的照片，我们怎么能让电脑在这几张不同的照片中识别出猎豹呢？</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/26.png" style="zoom:100%;"></p>
<p>我们知道猎豹眼睛下方的“黑色泪痕”是一个辨别猎豹最明显的标志。但是如果电脑说必须在特定的位置，有特定的形状纹理才能识别到这个特征，那恐怕连一张照片都识别不了。所以我们必须确定我们的神经网络拥有一个空间不变性(spatial invariance’)的特性，这代表着电脑不用关心这个特征位于哪里，在图像的哪个位置。因为我们在制作特征图和制作卷积层的时候已经将这种情况考虑进去了。电脑也不需要关心采集到的特征是否有一些倾斜是否在纹理上有不同。所以我们的神经网络必须要有一些弹性，能够找到这种特征，这就是池化的作用</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/27.png" style="zoom:100%;"></p>
<p>这就是最大池化的操作了。我们用一个 2x2的矩阵框在特征图上移动，然后每次选取矩阵框中最大的数字放在Pooled Feature Map当中，我们采用的步长是2.当然也可以选择1，只不过这样方框的位置和原来的位置就出现了重叠。这里超过了矩阵的边框也不要紧，只要记录下每个框中最大的数值即可。</p>
<p>经过最大池化，我们还是能够保留特征——那些最大值就是非常明显的特征，同时我们删除了75%不是明显特征的信息，减少了数据规模，防止出现信息过度拟合。更重要的是，我们保留了明显的特征，因此我们的算法可以允许一些图片的失真或者扭曲。</p>
<p>比如说对猎豹的泪痕花纹，假设这个花纹在特征探测是获得的数字是4. 那么，如果图像扭曲了，4出现了移位，只要和之前在同一个矩阵框之下，在池化后都能被记录下来。</p>
<p>问题： 池化有很多种，还有最小池化、平均池化 ，对于不同的池化方法，我们可以读者一篇论文</p>
<p><a href="http://ais.uni-bonn.de/papers/icann2010_maxpool.pdf" target="_blank" rel="noopener">http://ais.uni-bonn.de/papers/icann2010_maxpool.pdf</a></p>
<p>经过最大池化，现在的模型如下：</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/28.png" style="zoom:100%;"></p>
<p>我们可以在这个网站上 <a href="http://scs.ryerson.ca/~aharley/vis/conv/flat.html" target="_blank" rel="noopener">http://scs.ryerson.ca/~aharley/vis/conv/flat.html</a> 感受到池化带给我们的直观感受</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/29.png" style="zoom:100%;"></p>
<p>当我在左边输入8的时候，整个输入、卷积、池化、全连接的过程就在右边可视化了出来</p>
<p>最底下一层是我们的输入层</p>
<p>倒数第二层是第一次的卷积操作</p>
<p>倒数第三层是第一次的池化操作，我们发现经过了池化操作，图画变小了但是基本的特征还是保留了下来。</p>
<p>接着两层是第二次的卷积和池化，最上面是两次的全连接层，最后输出预测结果。</p>
<p>我们将8稍稍向右倾斜，发现得到的池化结果还是相似的。这就说明池化能让神经网络的弹性更大。</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/30.png" style="zoom:100%;"></p>
<p>但是当我们画一个笑脸，我们会发现这个神经网络是识别不出这是一个笑脸的。因为显然它只被0-9训练过，对其他的输入是一无所知的。这就好比我们看到了一件我们从来没看到过的东西，我们会说：这个东西比较像XXX(一个我们认识的东西)</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/31.png" style="zoom:100%;"></p>
<h2 id="Flattening"><a href="#Flattening" class="headerlink" title="Flattening"></a>Flattening</h2><p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/32.png" style="zoom:100%;"></p>
<p>Flattening 操作非常简单，对于池化后的矩阵，我们只需要将其压平成一列即可。</p>
<p>那么，生成多个特征图放进卷积层，再通过ReLU函数来生成池化层，最后压平放入一个长向量里，这个长向量就是神经网络的一个输入层。</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/33.png" style="zoom:100%;"></p>
<h2 id="Full-Connection"><a href="#Full-Connection" class="headerlink" title="Full Connection"></a>Full Connection</h2><p>这一步我们将把整个ANN加到CNN一系列操作之后，如图所示：</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/34.png" style="zoom:100%;"></p>
<p>我们看到之前ANN中的隐藏层现在变成了一个全连接层。全连接层是一种特别的隐藏层，因为它和输入层还有输出层是全连接的。而一般的隐藏层并不这么干。</p>
<p>这里神经网络的主要目的是：它能把我们得到的特征加入更多的属性，以得到更好的预测结果。我们之前已经有了平坦化之后的输出向量，在那个向量里已经蕴含了一些特征，比如对照片进行一个分类操作，但与此同时我们知道ANN能够对特征进行一个推理和分析并发现新的属性，那我们为何不利用ANN这种功能来优化这些特征呢？</p>
<p>下面是一个更加复杂的例子，通过对这个例子的分析，我们会对CNN有更加深刻的理解：</p>
<p>在这个模型当中我们有两层全连接层，并且有两个输出神经元(狗和猫)。我们知道在ANN当中只有一个输出神经元，那在CNN中为什么要有两个神经元呢？事实上，如果分成两类的话，我们可以用一个二元的输出神经元：0代表狗，1代表猫。但是如果要分类的东西较多，比如说还有鸟，大象之类的动物，那就必须给每一个动物都分配一个输出神经元。这是CNN 的特性。</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/35.png" style="zoom:100%;"></p>
<p>图像经过卷积池化平坦化后的数据被输入到ANN当中，然后通过一个损失函数(交叉熵函数)计算误差，这个误差是用来衡量神经网络的性能的。计算出误差以后我们将误差往回传播并调整一些参数：比如说这些神经网络中的权重和卷积过程中的特征探测器。因为很可能一开始的特征探测器是错误的，因此调整特征探测器能提高预测的准确性。经过调整后，再将信息传递到ANN当中，并计算误差，返回调整。以此进行多轮学习，最终我们的神经网络会得到优化。</p>
<p>这个过程和ANN是一样的，只是需要的时间更长一点，因为多了之前的三个步骤(卷积池化压平)</p>
<p>那么这两个输出神经元是如何工作的呢？</p>
<p>我们先从狗开始，我们首先要做的就是找到哪些权重杯赋予与“狗”神经元相连接的突触。这样我们就可以知道那个神经元对”狗”重要。为了方便，我们把值设置为0-1之间，如果这个神经元是0.9、1，那么就说明这个神经元被激活了，它认为它找到了某个特征；0就代表这个神经元没有找到特征。这些神经元的值将会传给Dog和Cat这两个输出神经元，然后由Dog和Cat神经元负责去判断这个特征是否符合它的要求。</p>
<p>比如说这里，第一、二、六个神经元被激活了，它们分别代表狗的耳朵，鼻子和舌头。那么在训练的时候狗神经元就知道这些特征是属于狗的，经过多次迭代，狗神经元在预测的时候就会认为如果这些神经元都激活了，那么这张图片就应该属于狗，因此狗神经元就会被激活。而猫神经元就会认为这些隐藏层的神经元被激活时，图像中的动物并不是猫，久而久之，猫神经元就会忽略这些神经元的信号。</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/36.png" style="zoom:100%;"></p>
<p>同理，对猫来说也有“属于”它的神经元，而狗神经元就会选择忽视那些属于猫特征的神经元。</p>
<p>经过成千上百次的训练，CNN就会自己判断这张图片是属于猫还是属于狗了，如下图所示</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/37.png" style="zoom:100%;"></p>
<p>这时候我输入一张狗的照片，要CNN帮我们预测分类。他们会通过倾听全连接层传递的信息而进行判断并给出可能是狗的概率和可能是猫的概率。概率是由全连接层的神经元根据他们的值 “投票”产生的 ，这就是全连接网络的工作原理。</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/38.png" style="zoom:100%;"></p>
<p>整一个CNN的过程可以用下图总结</p>
<p><img src="/2020/11/24/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E8%B7%AF%E7%90%86%E8%AE%BA/39.png" style="zoom:100%;"></p>
<p>学习博客：</p>
<p><a href="https://adeshpande3.github.io/adeshpande3.github.io/The-9-Deep-Learning-Papers-You-Need-To-Know-About.html" target="_blank" rel="noopener">https://adeshpande3.github.io/adeshpande3.github.io/The-9-Deep-Learning-Papers-You-Need-To-Know-About.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" class="post-title-link" itemprop="url">CSAPP虚拟内存</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-24 13:33:55" itemprop="dateCreated datePublished" datetime="2020-11-24T13:33:55+08:00">2020-11-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-25 19:44:00" itemprop="dateModified" datetime="2022-06-25T19:44:00+08:00">2022-06-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CSAPP虚拟内存"><a href="#CSAPP虚拟内存" class="headerlink" title="CSAPP虚拟内存"></a>CSAPP虚拟内存</h1><h2 id="物理和虚拟地址"><a href="#物理和虚拟地址" class="headerlink" title="物理和虚拟地址"></a>物理和虚拟地址</h2><p>一个使用物理寻址的系统：</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2.png" style="zoom:80%;"></p>
<p>一个使用虚拟寻址的系统：</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/1.png" style="zoom:80%;"></p>
<p>使用虚拟寻址，CPU通过生成一个<strong>虚拟地址来访问主存</strong>，这个虚拟地址在被送到内存之前先转换成适当的物理地址。将一个虚拟地址转换为物理地址的任务叫做地址翻译。 地址翻译需要CPU硬件和操作系统之间的紧密合作。CPU芯片上叫做内存管理单元(Memory Management Unit,简称MMU) 的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理</p>
<h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><p>地址空间（address space)是一个非负整数地址的有序集合: ${0,1,2,\cdots}$ . 如果地址空间中的整数时连续的，那么我们说他是一个线性地址空间。</p>
<p>为了简化讨论，我们总是假设使用的是线性地址空间。在一个带虚拟内存的系统中，CPU 从一个有$N=2^n$个地址的地址空间中生成虚拟地址，这个地址空间称为虚拟地址空间（virtual address space) :<br>${0,1,2\cdots,N-1}$ </p>
<p>一个地址空间的大小是由表示最大地址所需要的位数来描述的。例如，一个包含$N=2^n$个地址的虚拟地址空间就叫做一个n 位地址空间。现代系统通常支持32 位或者64 位虚拟地址空间。</p>
<p>一个系统还有— 个物理地址空间（physical address space)，对应于系统中物理内存的M个字节：<br>${0,1,2\cdots,M-1}$,  M不要求是2 的幂，但是为了简化讨论，我们假设 $W=2^m$</p>
<p>我们允许每个数据对象有多个独立的地址，其中每个地址都选自一个不同的地址空间。这就是虚拟内存的基本思想。主存中的每字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址</p>
<h2 id="虚拟内存作为缓存的工具"><a href="#虚拟内存作为缓存的工具" class="headerlink" title="虚拟内存作为缓存的工具"></a>虚拟内存作为缓存的工具</h2><p>接下来我我们来看看<strong>虚拟内存作为缓存的工具</strong></p>
<p>一般来说，虚拟内存是一组连续的存放在硬盘当中的bytes</p>
<p>我们把虚拟地址空间分成很多很多小块，每一个小块叫做一个page。这些page会与真实的物理内存空间进行映射，物理内存也被分成了很多小块，每一个小块可以叫做page也可以叫做frame。虚拟内存的pages很多都是空的，不然的话物理空间没有那么多page和虚拟地址空间一一映射</p>
<p>注意，<strong>这里的物理地址空间所代表的是主存DRAM，并不是Cache SRAM。</strong>因为磁盘的缓存就是DRAM，此外，DRAM还需要SRAM作为它的缓存</p>
<p>如下图所示：</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/3.png" style="zoom:80%;"></p>
<p>我们发现page有不同的状态</p>
<p>比较理想的的状态是page在我的缓存里面，这时候page的状态叫做 Cached</p>
<p>第二种状态叫做unallocated,代表这一个page在磁盘和内存中都没为其分配任何空间。</p>
<p>第三种叫做uncached，也就是还没有缓存的。表明我还没有用这个page,page中的数据当前并不在我的内存里面，他可能是在栈里面或者堆里面的某块空间。</p>
<h3 id="DRAM-Cache-Organization"><a href="#DRAM-Cache-Organization" class="headerlink" title="DRAM Cache Organization"></a>DRAM Cache Organization</h3><p>如果是DRAM作为磁盘的缓存的话，从磁盘中加载到Cache line中的block需要大于1ms的时间(一百万个运行周期)。因为DRAM比Disk要快差不多10000倍，而SRAM又比DRAM块十多倍。</p>
<p>因此，我们希望一次从磁盘中读取较多的信息，让读取的效率变高:</p>
<ul>
<li>Large page (block) size : typically 4KB<ul>
<li>Linux “huge pages” are 2MB(default) to 1GB</li>
</ul>
</li>
<li>Fully associative <ul>
<li>当DRAM作为disk的Cache的时候，表现为全相连的cache，也就是说，所有的cache line都是连在一起的。整个Cache 就只有一个set</li>
<li>这样，任何一个virtual page可以放在物理内存当中的任意一个空的地方</li>
<li>但这样就需要一张很大的映射表，来记录哪一个virtual page映射到哪一个physical page. 比如说4G内存，需要一个 8bytes*1M 的空间</li>
</ul>
</li>
<li><p>不命中时的替换策略也很重要，因为替换错了虚拟页的处罚也非常之高。因此，与硬件对SRAM 缓存相比，操作系统对DRAM 缓存使用了更复杂精密的替换算法</p>
</li>
<li><p>因为对磁盘的访问时间很长，DRAM 缓存总是使用回写，而不是直写。</p>
</li>
</ul>
<h3 id="Enabling-Data-Structure-Page-Table"><a href="#Enabling-Data-Structure-Page-Table" class="headerlink" title="Enabling Data Structure: Page Table"></a>Enabling Data Structure: Page Table</h3><p>同Cache一样，虚拟内存系统必须有某种方法来判定一个<strong>虚拟页是否缓存在DRAM 中的某个地方</strong>。如果是，系统还必须确定这个虚拟页<strong>存放在哪个物理页中</strong>。如果不命中，系统必须判断这个<strong>虚拟页存放在磁盘的哪个位置</strong>，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到DRAM 中，替换这个牺牲页。</p>
<p>我们提出了一个解决方案： page table (页表)</p>
<p><strong>页表将虚拟页映射到物理页</strong>。每一次地址翻译硬件(MMU)将一个虚拟地址转换为物理地址的时候，都会读取页表。操作系统负责维护页表的内容，以及在磁盘和DRAM之间来回传送页</p>
<p>页表就是一个页表条目（Page Table Entry , PTE)的<strong>数组</strong>,每一个PTE都是由一个有效位和一个n位地址字段组成的。</p>
<ul>
<li>其中，有效位表明了该虚拟页当前是否被缓存在DRAM当中。如果设置了有效位为1，那么地址字段就表示DRAM 中相应的物理页的起始位置，这个物理页中缓存了该虚拟页。</li>
<li>如果没有设置有效位，(0) ,那么<strong>一个空地址表示这个虚拟页还未被分配</strong>。</li>
</ul>
<p>比如说下图，一共有8个虚拟页和4个物理页的系统的页表。</p>
<ul>
<li>四个虚拟页(VP 1、2、7、4) 当前被缓存在DRAM当中。</li>
<li>两个页(VP0,5) 还没有被分配</li>
<li>剩下的页(VP3,6) 已经被分配了，但是当前还没有被缓存，(为其分配物理地址)</li>
</ul>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/4.png" style="zoom:80%;"></p>
<h4 id="Page-Hit"><a href="#Page-Hit" class="headerlink" title="Page Hit"></a>Page Hit</h4><p>Page hit: reference to VM word that is in physical memory (DRAM cache hit)</p>
<p>当CPU想要读取包含在VP2的虚拟内存的一个字时(VP2已经被缓存在DRAM当中)。地址翻译硬件MMU 将<strong>虚拟地址作为一个索引</strong>来定位PTE2，并从内存中读取它，因为设置了有效位，那么地址翻译硬件就知道VP2是缓存在内存当中的了。</p>
<p>所以，地址翻译硬件<strong>用PTE中的物理内存地址,构造出这个字的物理地址</strong>并读取它</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/5.png" style="zoom:80%;"></p>
<h4 id="Page-Fault"><a href="#Page-Fault" class="headerlink" title="Page Fault"></a>Page Fault</h4><p>Page fault: reference to VM word that is not in physical memory (DRAM cache miss)</p>
<p>当我发生page fault的时候，也就是缺页。那么整个计算机的处理流程如下：</p>
<ul>
<li>CPU想引用VP3中的一个字，但是我们知道VP3并未缓存在DRAM当中。</li>
<li>地址翻译硬件从内存中读取PTE3，但是发现这个valid bit =0，推断出VP3未被缓存。而且出现了一个缺页异常</li>
<li>缺页异常<strong>调用内核中的缺页异常处理程序</strong>，该程序会选择牺牲一个页。这里我们选择的是PP3中存放的VP4<ul>
<li>当VP4已经被写道磁盘当中去了，dirty bit =0,这时候它将直接删除</li>
<li>当VP4还没有写到磁盘当中，dirty bit =1,因此内核会先将其复制到磁盘</li>
</ul>
</li>
</ul>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/6.png" style="zoom:120%;"></p>
<ul>
<li>处理完VP4之后，内核从磁盘复制VP3到内存中的PP3，并更新PTE3，随后返回</li>
<li>当异常处理程序返回时，它会<strong>重新启动导致缺页的指令</strong>，该指令会<strong>把导致缺页的虚拟地址重发送到<br>地址翻译硬件</strong>。但是现在，VP 3 已经缓存在主存中了，那么页命中也能由地址翻译硬件正常处理了。</li>
</ul>
<p>整个过程会消耗非常非常多的时间</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/7.png" style="zoom:120%;"></p>
<h4 id="Triggering-a-Page-Fault"><a href="#Triggering-a-Page-Fault" class="headerlink" title="Triggering a Page Fault"></a>Triggering a Page Fault</h4><p>什么时候会触发缺页？</p>
<p>比如说，当一个用户想要在一个地址中写入东西</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">1000</span>]; </span><br><span class="line">main ()</span><br><span class="line">&#123;</span><br><span class="line">	a[<span class="number">500</span>] = <span class="number">13</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其汇编语言如下：</p>
<p><code>80483b7:      c7 05 10 9d 04 08 0d     $0xd,0x8049d10</code> </p>
<p>但是这个位置所在的page ，正在磁盘上面，于是MMU 就受到了缺页报错。</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/8.png" style="zoom:100%;"></p>
<h4 id="Completing-page-fault"><a href="#Completing-page-fault" class="headerlink" title="Completing page fault"></a>Completing page fault</h4><ul>
<li>发现缺页错误，操作系统的底层Kernel会协助我们将磁盘中的页复制到主存当中</li>
<li>然后返回并重新执行movl，这时候就没有缺页错误了。</li>
</ul>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.png" style="zoom:90%;"></p>
<h4 id="Allocating-Pages"><a href="#Allocating-Pages" class="headerlink" title="Allocating Pages"></a>Allocating Pages</h4><p>下图为我们展示了一个分配一个新的虚拟内存页时（例如，调用malloc）对页表的影响。</p>
<p>在这个示例中，VP5的分配过程是在磁盘上创建空间并更新PTE5，使它能指向磁盘上这个新创建的页面</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/10.png" style="zoom:90%;"></p>
<h3 id="又是局部性救了我们"><a href="#又是局部性救了我们" class="headerlink" title="又是局部性救了我们"></a>又是局部性救了我们</h3><p>虚拟内存看起来效率很低，但实际上它十分有效，这归因于局部性原理</p>
<p>尽管在整个运行过程中程序引用的不同页面的总数可能超出物理内存总的大小，但是局部性原则保证了在任意时刻，程序将<strong>趋向于在一个较小的活动页面(active page)集合上</strong>工作，这个集合叫做<strong>工作集(working set)</strong>或者<strong>常驻集合(resident set)</strong></p>
<ul>
<li><p>如果 工作集的大小小于物理内存的大小，那么程序就会有良好的时间局部性，虚拟内存系统就能做的相当好</p>
</li>
<li><p>但是如果工作集的大小大于物理内存的大小，那么程序将进入一个 抖动(Trashing) 的状态，这是页面将不断地换进换出。<br>如果在多个进程同时运行的情况下，当所有的工作集大小之和大于主存的大小的时候，也会发生抖动。这时候我们需要”挂起”一个占用内存较大的进程，将其放到磁盘当中去，腾出空间给优先级比较高的、能快速跑完的程序。</p>
</li>
</ul>
<p>虽然虚拟内存通常是有效的，但是如果一个程序的性能非常慢，那么程序员就需要考虑是不是电脑发生了抖动</p>
<h2 id="虚拟地址对内存管理的简化"><a href="#虚拟地址对内存管理的简化" class="headerlink" title="虚拟地址对内存管理的简化"></a>虚拟地址对内存管理的简化</h2><p>虚拟地址是一个有用的机制，因为它大大地简化了内存管理，并提供了一种自然的保护内存的方法</p>
<p>之前我们都是假设有一个单独的页表和所有的物理内存进行映射，但是我们要知道，实际上，操作系统<strong>为每一个进程提供了一个独立的页表</strong>，也就是一个独立的虚拟地址空间，如下图所示：</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/11.png" style="zoom:90%;"></p>
<p>在这个实例当中，Process 1 的页表VP1映射到PP2，VP2映射到PP6 同理，Process2 的 页表的VP1映射到PP8，而Process2映射到PP6.因此，我们知道了多个虚拟页面可以同时映射到同一个共享物理页面上。==提问：这样为啥能提升局部性?==</p>
<p><strong>按需页面调度</strong>和<strong>独立的虚拟地址空间</strong>的结合，对系统中内存的使用和管理造成了深远的影响。特别地，VM <strong>简化了链接和加载、代码和数据共享，以及应用程序的内存分配</strong></p>
<h3 id="简化链接"><a href="#简化链接" class="headerlink" title="简化链接"></a>简化链接</h3><p><a href="https://jasonxqh.github.io/2020/11/21/CSAPP链接/">CSAPP链接</a></p>
<p>独立的地址空间允许<strong>每个进程的内存映像使用相同的基本格式</strong>，而<strong>不管代码和数据实际存放在物理内存的何处</strong></p>
<p>对于64 位地址空间，代码段总是从虚拟地址0x400000 开始。数据段跟在代码段之后，中间有一段符合要求的对齐空白。栈占据用户进程地址空间最高的部分，并向下生长。这样的一致性极大地简化了链接器的设计和实现，允许链接器<strong>生成完全链接的可执行文件</strong>，这些可执行文件是<strong>独立于物理内存中代码和数据的最终位置的</strong>。</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/12.png" style="zoom:90%;"></p>
<h3 id="简化加载"><a href="#简化加载" class="headerlink" title="简化加载"></a>简化加载</h3><p>虚拟内存还使得容易向内存中加载可执行文件和共享对象文件。要把目标文件中<code>.text</code>和<code>.data</code> 节加载到一个新创建的进程中，Linux <strong>加载器</strong>为代码和数据段<strong>分配虚拟页</strong>，把它们标记为无效的（即未被缓存的）， 将<strong>页表条目指向目标文件中适当的位置</strong>。</p>
<p>但是，加载器从<strong>不从磁盘到内存实际复制任何数据</strong>。在每个页初次被引用时，要么是CPU 取指令时引用的，要么是一条正在执行的指令引用一个内存位置时引用的，虚拟内存系统会按照需要自动地调整数据页。</p>
<h3 id="简化共享"><a href="#简化共享" class="headerlink" title="简化共享"></a>简化共享</h3><p>独立地址空间为操作系统提供了一个<strong>管理用户进程</strong>和<strong>操作系统自身</strong>之间共享的一致机制。一般而言，每个进程都有自己私有的代码、数据、堆以及栈区域，是不和其他进程共享的。在这种情况中，<strong>操作系统创建页表，将相应的虚拟页映射到不连续的物理页面</strong>。</p>
<p>然而，在一些情况中，还是<strong>需要进程来共享代码和数据</strong>。例如，每个进程必须调用相同的<strong>操作系统内核代码</strong>，而每个C 程序都会调用C 标准库中的程序，比如 <code>printf()</code> . 操作系统通过<strong>将不同进程中适当的虚拟页面映射到相同的物理页面</strong>，从而安排<strong>多个进程共享这部分代码的一个副本</strong>，而不是在每个进程中都包括单独的内核和C标准库的副本</p>
<h3 id="简化内存分配"><a href="#简化内存分配" class="headerlink" title="简化内存分配"></a>简化内存分配</h3><p>虚拟内存为向用户进程提供一个<strong>简单的分配额外内存的机制</strong>。当一个运行在用户进程中的程序要求<strong>额外的堆空间</strong>时（如调用malloc 的结果）， 操作系统分配一个适当数字(例如k)个<strong>连续的虚拟内存页面</strong>，并且将它们<strong>映射到物理内存</strong>中<strong>任意位置的k个任意的物理页面</strong>。由于页表工作的方式，操作系统没有<strong>必要分配k个连续的物理内存页面</strong>。==页面可以随机地分散在物理内存中==。</p>
<h2 id="虚拟地址对内存的保护"><a href="#虚拟地址对内存的保护" class="headerlink" title="虚拟地址对内存的保护"></a>虚拟地址对内存的保护</h2><p>计算机系统必须为操作系统提供手段来<strong>控制对内存系统的访问</strong>。</p>
<ul>
<li><strong>不应该允许一个用户进程修改它的只读代码段</strong>。</li>
<li><strong>不应该允许它读或修改任何内核中的代码和数据结构</strong>。</li>
<li><strong>不应该允许它读或者写其他进程的私有内存</strong></li>
<li><strong>不允许它修改任何与其他进程共享的虚拟页面</strong></li>
</ul>
<p>除非所有的共享者都显式地允许它这么做</p>
<p>而<strong>提供独立的地址空间使得区分不同进程的私有内存变得容易</strong> ，我们可以通过在PTE 上添加一些<strong>额外的许可位</strong>来控制对一个虚拟页面内容的读取、改写和运行之类的权限。</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/13.png" style="zoom:90%;"></p>
<h2 id="Address-translation"><a href="#Address-translation" class="headerlink" title="Address translation"></a>Address translation</h2><p>现在我们来谈谈地址翻译的基础知识，为了让我们了解硬件在支持虚拟内存中的角色</p>
<p>下面概括了我们在这节里将要使用的所有符号</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/14.png" style="zoom:90%;"></p>
<p>形式上来说，地址翻译是一个 $N$ 元素的虚拟地址空间$(VAS)$中的元素和一个M元素的物理地址空间 $(PAS)$ 中元素之间的映射 : $MAP:VAS\rightarrow PAS \cup \emptyset$ </p>
<script type="math/tex; mode=display">
MAP\left( A\right) \begin{cases}A' \text{如果虚拟地址A处的数据在PAS的物理地址A'处}\\ \emptyset \text{如果虚拟地址A处的数据不在物理内存中}\end{cases}</script><p>下面这张图展示了MMU如何利用页表来实现上述的映射。CPU中的一个控制寄存器，页表基址寄存器(Page Table Base Register,RTBR)指向当前的页表。 n位的虚拟地址包含两个部分: 一个<strong>p位的虚拟页面偏移量</strong>(Virtual Page Offset,VPO),p是由page的大小决定的,$P=2^p$（比如page的大小为64bytes，那么$P=2^6$,那么p就有6位）<em>和一个<em>*(n-p)位的虚拟页号</em></em>(Virtual Number Page,VPN)</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/15.png" style="zoom:90%;"></p>
<p>MMU 利用 VPN 来选择适当的PTE。例如，VPN0 选择PTE0 ; VPN1选择PTE1.以此类推。</p>
<p>将页表条目中物理页号(Physical Page Number, PPN)和虚拟地址中的VPO 串联起来，就得到相应的物理地址。注意，因为物理和虚拟页面都是P 字节的，所以<strong>物理页面偏移(Physical Page Offset, PPO)和VPO 是相同的</strong>。</p>
<h4 id="Address-Translation-Page-Hit"><a href="#Address-Translation-Page-Hit" class="headerlink" title="Address Translation : Page Hit"></a>Address Translation : Page Hit</h4><p>当页命中的时候，CPU硬件执行的步骤：</p>
<ul>
<li>第一步：处理器生成一个虚拟地址(VA)，并把它传送给MMU</li>
<li>第二步：MMU 生成 PTE 地址 (PTEA)，并从Cache/Main memory 请求得到它</li>
<li>第三步：高速缓存/主存 向MMU返回PTE</li>
<li>第四步：MMU构造物理地址，并把它传送给高速缓存/主存</li>
<li>第五步：高速缓存/主存返回所请求的数据给处理器</li>
</ul>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/16.png" style="zoom:90%;"></p>
<p>我们要注意到MMU是在Cache 之前的！</p>
<h4 id="Address-Translation-：Page-Fault"><a href="#Address-Translation-：Page-Fault" class="headerlink" title="Address Translation ：Page Fault"></a>Address Translation ：Page Fault</h4><p>和页命中时完全由硬件处理不同，当缺页时，要求硬件和操作系统内核(Kernel)共同完成，如下图所示。</p>
<ul>
<li>第一步：处理器生成一个虚拟地址(VA)，并把它传送给MMU</li>
<li>第二步：MMU 生成 PTE 地址 (PTEA)，并从Cache/Main memory 请求得到它</li>
<li>第三步：高速缓存/主存 向MMU返回PTE</li>
<li>第四步：发现PTE的有效位是0，说明缺页了。这时MMU触发了一次异常，传递了CPU中的控制到操作系统内核中的缺页异常处理程序</li>
<li>第五步：缺页处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则将其换出到磁盘。(回写)</li>
<li>第六步：缺页处理程序页面从磁盘中调取新的页面到Cache/Main Memory,并更新内存中的PTE</li>
<li>第七步：缺页处理程序返回到原来的进程，再次执行导致缺页的指令。CPU 将引起缺页的虚拟地址重新发送给MMU。<br>因为虚拟页面现在缓存在物理内存中，所以就会命中，在MMU 执行了页命中情况的几个步骤之后，主存就会将所请求字返回给处理器</li>
</ul>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/17.png" style="zoom:90%;"></p>
<h3 id="结合Cache和VM"><a href="#结合Cache和VM" class="headerlink" title="结合Cache和VM"></a>结合Cache和VM</h3><p>现在我们把Cache 和Memory拆开来，看看整一个取数据的逻辑：</p>
<p>首先我们要知道Page Table也有可能存放在L1 Cache当中的。因此从MMU出来的 PTEA首先会在L1 Cache中查找。</p>
<ul>
<li>如果命中了，那么就从Cache返回PTE到MMU，然后MMU再生成物理地址去Cache中请求数据<ul>
<li>如果Cache中有数据，那么Cache会返回数据给CPU</li>
<li>如果Cache中没有数据，那么就会跟着物理地址去内存中查找</li>
</ul>
</li>
<li>如果未命中，那么就跑到主存中的页表当中去查找，然后的处理逻辑和上面所说的相同 </li>
</ul>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/18.png" style="zoom:90%;"></p>
<h3 id="TLB-Translation-Lookaside-Buffer"><a href="#TLB-Translation-Lookaside-Buffer" class="headerlink" title="TLB(Translation Lookaside Buffer)"></a>TLB(Translation Lookaside Buffer)</h3><p>虽然说之前的查询，如果PTE在L1中，开销只要1-2个周期；如果在内存中则要几十上百个周期，已经是比较快了，但是很多系统还是不满意，希望消除这样的开销。于是，他是在MMU中放置了<strong>一个关于PTE的小缓存</strong>，我们称其为TLB</p>
<p>TLB是一个虚拟寻址的缓存，其中每一行都保存着一个由<strong>单个PTE组成的块</strong>。TLB通常有着高度的相联度。</p>
<p>用于组选择和行匹配的索引和标记字段是从虚拟地址中的虚拟页号(VPN)中提取出来的。如下图所示。如果TLB有 $T=2^t$个组，那么TLB索引(TLBI)是由VPN的t个最低位组成的，而TLB标记(TLBT)是由VPN剩余位组成的</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/19.png" style="zoom:90%;"></p>
<h4 id="TLB-Hit"><a href="#TLB-Hit" class="headerlink" title="TLB Hit"></a>TLB Hit</h4><p>下图展示了当TLB 命中时(通常情况)所包括的步骤。这里的关键点是，所有的地址翻译步骤都是在芯片上的MMU 中执行的，因此非常快</p>
<p>第1 步：CPU 产生一个虚拟地址。<br>第2 步和第3 步：MMU拿着VPN去TLB中找，并从TLB 中取出相应的PTE。注意，这个查询速度是非常快的。因为有很多晶体管并行查询，时间接近于O(1)<br>第4 步：MMU 将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存。<br>第5 步：高速缓存/主存将所请求的数据字返回给CPU</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/20.png" style="zoom:90%;"></p>
<h4 id="TLB-miss"><a href="#TLB-miss" class="headerlink" title="TLB miss"></a>TLB miss</h4><p>当TLB 不命中时，MMU 必须从L1 缓存中取出相应的PTE, 如下图所示。新取出的PTE 存放在TLB 中，可能会覆盖一个已经存在的条目。</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/21.png" style="zoom:90%;"></p>
<h3 id="Multi-Level-Page-Tables"><a href="#Multi-Level-Page-Tables" class="headerlink" title="Multi-Level Page Tables"></a>Multi-Level Page Tables</h3><p>假设我们的电脑是48位的，每个PTE大小是8 byte，每个页的大小是4kb，那么如果将这些PTE全放到一个page table当中的话，我们就需要 $2^{48}\cdot 2^{-12}\cdot 2^3 = 2^{39}$ bytes 也就是一张512GB的大表，而这张大表有很多的PTE为空，造成了很大浪费。因此仅创建一张页表显然是不现实的。所以我们采用了另一个方案：多层页表</p>
<p>为了简便，我们这里以二层页表为例：第一层页表中存放的PTE指向的是第二层的某一张页表，而第二层中存放的PTE则是指向内存当中的页</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/22.png" style="zoom:90%;"></p>
<p>因为第一层很多PTE是空的，那么它们就不会指向一个页表，因此不用为其分配空间，因此节省下了不少内存。事实上，计算机采用的是多层页表，也就是说仅仅双层列表还是不够的。</p>
<h4 id="Translating-with-a-k-level-Page-Table"><a href="#Translating-with-a-k-level-Page-Table" class="headerlink" title="Translating with a k-level Page Table"></a>Translating with a k-level Page Table</h4><p>这是一个多级列表的示意图，只要最终找到了PPN，那么这一路页表都必须存在。此外，每一层都能节省下一定的空间，最后就能达到一个比较高效的、又体积比较小的方案。</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/23.png" style="zoom:90%;"></p>
<h2 id="地址翻译总结"><a href="#地址翻译总结" class="headerlink" title="地址翻译总结"></a>地址翻译总结</h2><p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/24.png" style="zoom:90%;"></p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/25.png" style="zoom:90%;"></p>
<p>首先我们拿到的信息有3点</p>
<ul>
<li>虚拟地址是14位的</li>
<li>物理地址是12位的</li>
<li>页的大小是64个bytes，也就是 $P= 2^6$  因此 $p=6$ ，这点非常重要，因为p的大小即是 VPO和PPO的位数，因此我们可以在上图画出VPO、PPO所占的位置和PPN(12-6 = 6 位)，VPN(14-6=8位)</li>
</ul>
<p>现在有一个虚拟地址 ： $00001101101001$ ,我们就知道它的VPN为 $00001101$ ,其VPO为$101001$ </p>
<p>根据查找顺序，接下来应该是去TLB当中查找，因此我们还要再VPN的基础上求出TLBT和TLBI。TLBT是标签，TLBI是用于定位的，我们需要现根据TLB的组数来确定TLBI有几位，然后再将剩余位设置成TLBT</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/26.png" style="zoom:90%;"></p>
<p>我们看到，TLB一共有$4 = 2^2$ 组。因此TLBI为2位，TLBT位6位，因此真个虚拟地址可以做如下划分：</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/27.png" style="zoom:90%;"></p>
<p>那么根据TLBI我们先定位到set1，然后再根据TLBT(0x03)进行匹配，发现valid位为1，匹配成功，于是我们可以从TLB中取出这个虚拟地址对应的PPN = 2D</p>
<p>我们知道物理地址是由PPN和PPO组成的，而PPO和VPO又是一模一样的，因此物理地址即可翻译出来：这里要注意，因为PPN只有6位，所以0x2d要写成0b101101(二进制)</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/28.png" style="zoom:90%;"></p>
<p>有了物理地址，我们就可以去Cache当中找数据了。那么我们首先看一下这个cache的结构，然后再来将物理地址分为Tag、Index和Offset3个部分</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/29.png" style="zoom:90%;"></p>
<p>我们发现这个Cache一共有$16=2^4$组，那么我们就需要用4位来表示 Cache Index也就是CI，又因为每一组set中，有 $4 = 2^2$个block，因此Cache Offset 需要分配2位，剩下的就是 Cache Tag了。因此在物理内存中的划分如上图所示。</p>
<p>在Cache中查找数据的时候，首先要查Index，这里是0xA; 找到以后匹配Tag,这里是0x2D，发现匹配上了; 并且Valid bit = 1 。所以这是一个典型的Cache hit.我们根据offset = 1来锁定最终取到的数据为 0x15</p>
<h2 id="Memory-Mapping"><a href="#Memory-Mapping" class="headerlink" title="Memory Mapping"></a>Memory Mapping</h2><p><strong>Linux</strong> 通过将一个<strong>虚拟内存区域</strong>与一个<strong>磁盘上的对象</strong>（object)关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射(memory mapping)。有了内存映射，我们就只要访问像访问内存一样访问磁盘上的对象，而不需要用fopen ,fclose 这些函数去访问了。</p>
<p>虚拟内存可以映射到两种类型的对象：<strong>Linux文件系统中的普通文件</strong> 和 <strong>匿名文件</strong> 。</p>
<h4 id="Linux文件系统中的普通文件"><a href="#Linux文件系统中的普通文件" class="headerlink" title="Linux文件系统中的普通文件"></a>Linux文件系统中的普通文件</h4><p>一个区域可以映射到一个普通磁盘文件的连续部分，例如一个<strong>可执行目标文件</strong>。  </p>
<h4 id="匿名文件"><a href="#匿名文件" class="headerlink" title="匿名文件"></a>匿名文件</h4><p>匿名文件是由内核 (kernel) 创建的，包含的全是二进制0.</p>
<p>CPU 第一次引用这样一个区域内的虚拟页面时，内核就在物理内存中找到一个合适的牺牲页面，如果该页面被修改过，就将这个页面换出来，用二进制零覆盖牺牲页面并更新页表，将这个页面标记为是驻留在内存中的。注意在磁盘和内存之间并没有实际的数据传送。</p>
<p>==这两类文件的区别和应用场景还没有搞明白==</p>
<p>无论在哪种情况中旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的交换文件（swap file)之间换来换去。交换文件也叫做交换空间（swap space)或者交换区域 (swap area)</p>
<h3 id="共享对象"><a href="#共享对象" class="headerlink" title="共享对象"></a>共享对象</h3><p>内存映射给我们提供了一种清晰的机制，用来控制多个进程如何共享对象。</p>
<p>一个对象可以被映射到虚拟内存的一个区域，要么作为共享对象，要么作为私有对象。</p>
<p><strong>共享对象</strong>：</p>
<p>如果一个进程将一个共享对象映射到它的虚拟地址空间的一个区域内，那么<strong>这个进程</strong>对<strong>这个区域</strong>的<strong>任何写操作</strong>，对其他进程而言(映射了这个共享对象的)也是可见的。而且，这些变化也会<strong>反映在磁盘上的原始对象</strong>中</p>
<p><strong>私有对象</strong> :</p>
<p>对其它进程来说不可见而且进程对这个区域所做的任何写操作都不会反映在磁盘上的对象当中。</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/30.png" style="zoom:90%;"></p>
<p>关键点在于即使对象被映射到了<strong>多个共享区域</strong>，物理内存中也只需要存放共享对象的<strong>一个副本</strong>，而这个对象在不同的进程当中所处的虚拟地址是不一样的。</p>
<h4 id="Copy-On-Write"><a href="#Copy-On-Write" class="headerlink" title="Copy-On-Write"></a>Copy-On-Write</h4><p>私有对象在被映射到虚拟内存的时候会使用一种Copy-On-Write的技术。因为私有对象要满足在被修改时对其它进程来说不可见、磁盘上的文件也不会进行改变的要求。Copy-On-Write顾名思义就是<strong>在写的时候复制</strong>。</p>
<p>其核心思想是，如果有多个调用者（callers）同时要求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（transparently）</p>
<p>对于每个映射私有对象的进程，<strong>相应私有区域</strong>的页表条目都被标记为<strong>只读</strong>，且物理内存上的页这时候被标记成了<strong>(Private copy-on-write</strong>), 当进程2要修改原来的对象的时候，会触发一个保护故障，这时候保护故障程序就会在物理内存中创建这个页面的一个<strong>新副本</strong>，更新页表条目指向这个新的副本，然后恢复这个页面的可写权限，当故障处理程序返回时，CPU <strong>重新执行这个写操作</strong>，现在在<strong>新创建的页面上这个写操作</strong>就可以正常执行了。如下图所示</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/31.png" style="zoom:90%;"></p>
<p>也就是说，读的时候大家可以一起读，只有在写的时候(迫不得已)，才进行一个拷贝。是一种 Lazy Copy的模式。</p>
<p>这样做的好处是加快启动进程，加快相应时间。因为读取很快，但是写很慢，因此每次写只拷贝要写的那几个page。</p>
<h3 id="使用-mmap-函数的用户级内存映射"><a href="#使用-mmap-函数的用户级内存映射" class="headerlink" title="使用 mmap 函数的用户级内存映射"></a>使用 mmap 函数的用户级内存映射</h3><p>Linux 进程可以使用 <code>mmap</code>函数来创建新的虚拟内存区域，并将对象映射到这些区域中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *staxt, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/32.png" style="zoom:90%;"></p>
<p>mmap 函数要求内核创建一个新的虚拟内存区域，最好是从地址start 开始的一个区域，并将文件描述符fd 指定的对象的一个连续的(chunk)映射到这个新的区域。</p>
<p>连续的对象片大小为length 字节，从距文件开始处偏移量为offset 字节的地方开始。start地址仅仅是一个暗示，通常被定义为NULL.</p>
<p>因为mmap的返回值是一个指针，这个指针并没有规定数据类型。我们就可以通过这个指针来访问磁盘上的文件，我访问、修改的所有东西可以在磁盘当中进行同步。</p>
<h3 id="mmap的-用处"><a href="#mmap的-用处" class="headerlink" title="mmap的 用处"></a>mmap的 用处</h3><ul>
<li>读取大文件<ul>
<li>mmap可以使用分页机制将文件放入内存中</li>
</ul>
</li>
<li>共享数据结构<ul>
<li>When call with MAP_SHARED flag<ul>
<li>Multiple processes have access to same region of memory</li>
<li>Risky!</li>
</ul>
</li>
</ul>
</li>
<li>File-based data structures<ul>
<li>E.g., database</li>
<li>Give protargument PROT_READ | PROT_WRITE</li>
<li>When unmap region, file will be updated via write-back</li>
<li>Can implement load from file / update / write back to file</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/" class="post-title-link" itemprop="url">CSAPP链接</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-21 14:10:24" itemprop="dateCreated datePublished" datetime="2020-11-21T14:10:24+08:00">2020-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-22 21:05:18" itemprop="dateModified" datetime="2022-08-22T21:05:18+08:00">2022-08-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CSAPP链接-Linking"><a href="#CSAPP链接-Linking" class="headerlink" title="CSAPP链接(Linking)"></a>CSAPP链接(Linking)</h1><p>为什么要用 Linking？</p>
<ol>
<li>能让程序模块化<ul>
<li>Linking可以让程序写成一个包含了较小源文件的集合，而不是将所有代码整合到一起。</li>
<li>Linking允许我们构建一些包含常用函数的库(Math library,standard C library)</li>
</ul>
</li>
<li>能提高整个程序的运行效率<ul>
<li>在时间方面，可以单独编译<ul>
<li>改变其中一个源文件即可，然后重新编译</li>
<li>不需要重新编译其他的源文件</li>
<li>可以同时编译多个文件</li>
</ul>
</li>
<li>空间方便，可以编写库<ul>
<li>常见的函数可以整合到一个文件夹当中                         </li>
<li>静态链接<ul>
<li>静态链接的过程就已经把要链接的内容已经链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行</li>
</ul>
</li>
<li>动态链接<ul>
<li>动态链接这个过程没有把内容链接进去，而是在执行的过程中，再去找要链接的内容，生成的可执行文件中并没有要链接的内容，所以当你删除动态库时，可执行程序就不能运行。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="编译器驱动程序"><a href="#编译器驱动程序" class="headerlink" title="编译器驱动程序"></a>编译器驱动程序</h2><p>现在我们有两个 .c文件：</p>
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = sum(<span class="built_in">array</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sum.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">   		s += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们在shell中输入这样的命令之后：<code>gcc -Og -o prog main.c sum.c</code></p>
<p>机器会调用 GCC 来驱动程序：流程如下</p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/1.png" style="zoom: 120%;"></p>
<ol>
<li>首先，驱动程序运行了 C 预处理器(C-preprocessor即cpp) ，它会将C的源程序main.c翻译成一个 ASCII 码的中间文件 main.i</li>
<li>接下来，驱动程序运行C编译器(C compiler即ccl) ，它将main.i 翻译成一个 ASCII汇编语言文件 main.s</li>
<li>然后驱动程序运行汇编器(assembler即as) 将main.s文件翻译成一个可重定位目标文件 main.o,同理，生成sum.o</li>
<li>最后，它运行链接器程序ld，将main.o 和 sum.o 以及一些必要的系统目标文件组合起来，创建一个可执行目标文件 prog:</li>
<li>要运行可执行proq，我们在linux shell 的命令行中下输入 <code>./prog</code> ，shell就会调用一个叫做加载器(loader)的函数，他将可执行文件中的prog中的代码和数据复制到内存，然后将控制转移到这个程序的开头</li>
</ol>
<h2 id="三种-Object-Files"><a href="#三种-Object-Files" class="headerlink" title="三种 Object Files"></a>三种 Object Files</h2><h3 id="Executable-and-Linkable-Format-ELF"><a href="#Executable-and-Linkable-Format-ELF" class="headerlink" title="Executable and Linkable Format (ELF)"></a>Executable and Linkable Format (ELF)</h3><p>ELF格式，是标准的<strong>目标文件的二进制格式</strong>。是三种对象文件统一的格式</p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/3.png" style="zoom: 100%;"></p>
<ul>
<li><p>Elf header</p>
<ul>
<li>Word size, byte ordering, file type (.o, exec, .so),machine type, etc.</li>
</ul>
</li>
<li><p>Segment header table</p>
<ul>
<li>Page size, virtual address memory segments (sections), segment sizes.</li>
</ul>
</li>
<li>.text section<ul>
<li>Code 代码</li>
</ul>
</li>
<li>.rodata section (read-only)<ul>
<li>放只读的数据。如跳转表，字符串常量、带 const 修饰的全局变量和静态变量等</li>
</ul>
</li>
<li>.data section<ul>
<li>用于维护初始化的且初始值非0的全局变量和静态变量（不带 const 修饰）</li>
<li>这部分需要空间</li>
</ul>
</li>
<li>.bss section 用于维护未初始化的或初始值为0的全局变量和静态变量（不带 const 修饰）<ul>
<li>Uninitialized global variables 没有初始化的全局变量</li>
<li>“Block Started by Symbol”</li>
<li>不占用目标文件的空间,因此更节省空间</li>
</ul>
</li>
<li>.symtab section 符号表<ul>
<li>Symbol table 符号表</li>
<li>Procedure and static variable names 静态变量的名字</li>
<li>Section names and locations 对应所在的section的名字和位置</li>
</ul>
</li>
<li>.rel.text section <ul>
<li>Relocation info for .text section</li>
<li>Addresses of instructions that will need to be modified in the executable</li>
<li>Instructions for modifying.</li>
</ul>
</li>
<li>.rel.data section<ul>
<li>Relocation info for .data section</li>
<li>Addresses of pointer data that will need to be modified in the merged executable</li>
</ul>
</li>
<li>.debug section<ul>
<li>Info for symbolic debugging (gcc -g) 编译成debug版本的时候会用</li>
</ul>
</li>
<li>Section header table<ul>
<li>Offsets and sizes of each section</li>
</ul>
</li>
</ul>
<h3 id="Relocatable-object-file-o-file"><a href="#Relocatable-object-file-o-file" class="headerlink" title="Relocatable object file(.o file)"></a>Relocatable object file(.o file)</h3><p>可重定位的文件，包含了代码和数据(初始化全局变量的数据，<strong>不包含局部变量的初始化</strong>，局部变量在真正压栈的时候才会将其初始化，在一开始连空间都没有给它分配)</p>
<p><strong>可重定位文件只能和别人链接，不能单独运行</strong></p>
<h3 id="Executable-object-file-a-out-file"><a href="#Executable-object-file-a-out-file" class="headerlink" title="Executable object file(a.out file)"></a>Executable object file(a.out file)</h3><p>可执行文件，能直接被放在内存当中并被执行的。常常由多个.o文件链接而来</p>
<p>LF 可执行文件被设计得很容易加载到内存，可执行文件的连续的片(chunk)被映射到连续的内存段。程序头部表（program header table)描述了这种映射关系</p>
<h4 id="加载可执行目标文件"><a href="#加载可执行目标文件" class="headerlink" title="加载可执行目标文件"></a>加载可执行目标文件</h4><p>我们可以在linux下用 <code>./prog</code> 来运行可执行目标文件。</p>
<p>因为prog并不是一个内置的shell命令，所以shell会认为 prog是一个可执行目标文件，通过调用加载器的操作系统代码来运行它。加载器可以将可执行目标文件中的代码和数据从磁盘复制到内存当中，然后通过跳转到程序的第一条指令或入口点来运行该程序。这个过程叫做加载</p>
<p>在分配栈、共享库和堆的地址的时候，链接器会使用地址空间布局随机化。虽然每次程序运行的时候<strong>这些区域的地址都会改变</strong>，但是他们的<strong>相对位置是不变的</strong>。</p>
<ul>
<li><p>当加载器运行时，它创建类似于下图所示的内存映像。在程序头部表的引导下,加载器将可执行文件的片(chunk)复制到代码段和数据段。</p>
</li>
<li><p>接下来，加载器跳转到程序的入口点，也就 <code>_start</code>函数的地址。这个函数是在系统目标文件<code>ctrl.o</code>中定义的，对所有的C程序都是一样的。</p>
</li>
<li><code>_start</code> 函数调用系统启动函数<code>__libc_start_main</code> ，该函数定义在<code>libc.so</code>中。它初始化执行环境，调用用户层的<code>main</code> 函数，处理 <code>main</code> 函数的返回值，并且在需要的时候把控制返回给内核。</li>
</ul>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/1.jpg" style="zoom: 100%;"></p>
<h3 id="Share-object-file-so-file"><a href="#Share-object-file-so-file" class="headerlink" title="Share object file(.so file)"></a>Share object file(.so file)</h3><p>共享目标文件是一种特殊的可以重定位的目标文件，它只在运行的时候，由操作系统现成得加进去。在windows系统中 .so文件被叫做 .dll(Dynamic Link Libraries)</p>
<h2 id="静态链接-符号解析-symbol-resolution"><a href="#静态链接-符号解析-symbol-resolution" class="headerlink" title="静态链接-符号解析(symbol resolution)"></a>静态链接-符号解析(symbol resolution)</h2><p>为了构造可执行文件，链接器必须完成两个主要任务：符号解析和重定向</p>
<p>目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或者一个静态变量(static 声明的变量)，也就是说，除了关键字之外，我们写的都是符号。符号解析的目的是将每一个符号引用正好和一个符号定义关联起来。</p>
<p>比如说<br><code>void swap()</code>是定义了一个符号，而 <code>swap()</code> 是调用了一个符号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span> </span>&#123;…&#125; 	<span class="comment">/* define symbol swap */</span></span><br><span class="line">swap(); 			<span class="comment">/* reference symbol swap */</span></span><br><span class="line"><span class="keyword">int</span> *xp = &amp;x; 		<span class="comment">/* define symbol xp, reference x */</span></span><br></pre></td></tr></table></figure>
<p>符号定义都被存放在一个符号表当中(symbol table)，这张符号表记录了符号的名字大小和位置。这些记录组成了一个数组。</p>
<p>符号解析的目的是将每一个符号引用正好和一个符号定义关联起来。</p>
<h3 id="静态变量、全局变量、局部变量"><a href="#静态变量、全局变量、局部变量" class="headerlink" title="静态变量、全局变量、局部变量"></a>静态变量、全局变量、局部变量</h3><ul>
<li>在内存里的位置不一样</li>
<li>静态变量不能被其他 .c文件访问，全局变量可以</li>
<li>静态变量可以在函数里面定义，出了函数再进来静态变量的值还是一样的。不会因为函数返回就没了。可以用来保留反复调用的函数的中间状态。</li>
<li>静态变量可以节省空间，减少无谓的压栈和出栈的次数</li>
</ul>
<p>接下来我们还要详细讲解一下全局变量的注意事项</p>
<h3 id="三种symbols"><a href="#三种symbols" class="headerlink" title="三种symbols"></a>三种symbols</h3><p><strong>Global symbols</strong></p>
<p>全局符号就是在本地<code>.c</code>文件中定义，在其他模块中也能引用 。 如<strong>非static函数和非static的全局变量</strong>（指<strong>不带static的全局变量</strong>）</p>
<p><strong>External symbols</strong></p>
<p>在外部文件定义，当前文件可以引用的，叫做外部符号。<strong>由其他模块定义并被模块m引用</strong>的全局符号（标志是extern，<strong>extern用来修饰全局变量，即声明在“最外层”</strong>）（要体现引用，否则不会进入符号表）</p>
<p><strong>Local symbols</strong></p>
<p> <strong>仅由模块m定义并能被本模块引用的本地符号</strong>。例如，在模块m中定义的<strong>带static的函数和变量（无论定义变量的位置，是全局还是在函数中，只要变量前面有static，都算是（本地）符号！）</strong></p>
<p>注意：局部符号并不是局部变量!!!!</p>
<p><strong>Local non-static C variables  vs local static variables</strong></p>
<ul>
<li><strong>本地非静态变量是存放在栈里</strong>的而<strong>本地静态变量</strong>是存放在 .bss或者 .data当中的</li>
</ul>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/6.png" style="zoom: 120%;"></p>
<p>问2个问题：</p>
<ul>
<li>一开头的<code>static int x</code>和<code>f()</code>、<code>g()</code>中的<code>static int x</code>，这三个 x是不是同一个 x？</li>
</ul>
<p>这是三个不同的静态变量，都在.data当中初始化了。在编译的时候，还要给x加上不同的后缀。 </p>
<ul>
<li>如果是同一个x，那么它们的值？如果不是x，那么return的x分别是哪一个x？</li>
</ul>
<p><code>f()、g()</code>中返回的值即在函数中定义的<code>static int</code>;<code>h()</code>返回的值是global的static int</p>
<p>第一次调用<code>f(),g(),h()</code>。返回的值分别是 17，33，42</p>
<p>第二次调用<code>f(),g(),h()</code>。返回的值分别是 18，47，69</p>
<p>因此我们也可以了解静态变量的性质：在进入函数，x还是之前的x，并不会重新声明</p>
<h3 id="关于symbols划分的例题"><a href="#关于symbols划分的例题" class="headerlink" title="关于symbols划分的例题"></a>关于symbols划分的例题</h3><p><strong>例1</strong></p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/4.png" style="zoom: 120%;"></p>
<p>比如说在 main.c里面，sum() 并不是 global symbol，是一个 external symbol</p>
<p>array和 main都是global symbol</p>
<p>val是局部变量，并不是symbol</p>
<p><strong>例2</strong></p>
<p>我们再来看一个例子，下面这个.c文件哪些名字会被保存在 symbol table 当中呢？</p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/5.png" style="zoom: 120%;"></p>
<p><code>incr</code> 是全局变量 是 global symbol</p>
<p><code>foo</code> 是static 修饰的，是local symbol</p>
<p>a,argc，argv都是参数，不是变量</p>
<p><code>main</code> 是一个 global symbol</p>
<p><code>printf</code> 是一个external symbol</p>
<p>我们可以用命令 <code>readelf -s symbols.o</code> 来看一下符号表</p>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p><strong>Type Mismatch Example</strong></p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/13.png" style="zoom: 120%;"></p>
<p>这样两个.c文件编译，还是能打印出来的，只是最后答应出来的是类型为long int的3.14</p>
<p>所以，我们尽量不要用全局变量，在多人合作的情况下非常容易出错。</p>
<p>如果一定要用，那么要养成一些习惯</p>
<ul>
<li>如果我自己的模块，要一直用，那就加static</li>
<li>在定义一个全局变量的时候顺便初始化它</li>
<li>如果我们引用了一个外部的全局变量，那么就用 关键词 extern 去修饰<ul>
<li>这样能将其变成一个 weak symbol</li>
<li>当其他文件中没有定义这个变量，但我加了extern，linker 也会报错。</li>
</ul>
</li>
</ul>
<h3 id="Use-of-extern-in-h-Files"><a href="#Use-of-extern-in-h-Files" class="headerlink" title="Use of extern in .h Files"></a>Use of extern in .h Files</h3><p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/14.png" style="zoom: 120%;"></p>
<p>我们做一个 .h文件，里面声明了全局变量 g和全局函数f()，然后在其他文件中通过 Include 来将这两个全局变量和全局函数加进来</p>
<p>这是标准的头文件使用方法，头文件一般只写声明，不写定义! 因为头文件是在预处理的时候将.h文件加入到.c文件去，如果在.h文件中写了定义，那么在预处理的时候c1.c和c2.c都会有.h中关于变量和函数的定义，在链接器将两个.c文件链接的时候会报重复定义的错误</p>
<h3 id="链接器怎么解决重复定义的？"><a href="#链接器怎么解决重复定义的？" class="headerlink" title="链接器怎么解决重复定义的？"></a>链接器怎么解决重复定义的？</h3><p>首先，我们要了解符号 是 strong 还是 weak的概念</p>
<p>Strong: procedures and initialized globals  初始化了的全局变量是Strong 的</p>
<p>Weak: uninitialized globals Or ones declared with specifier extern 没有初始化或者是外部符号是 Weak的</p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/7.png" style="zoom: 100%;"></p>
<p>当发生冲突的时候，有一些规则</p>
<ul>
<li>Rule 1: 同名字且都为Strong的符号是不被允许的<ul>
<li>相同名字的 strong 符号只能定义一次，否则 Linker是会报错的</li>
</ul>
</li>
<li>Rule 2: 如果有一个强的和若干个弱的符号，那么选择那个强的符号<ul>
<li>References to the weak symbol resolve to the strong symbol</li>
</ul>
</li>
<li>Rule 3如果没有一个强的，有很多弱的符号，那就随便选一个<ul>
<li>Can override this with gcc –fno-common</li>
<li>也可以要求编译器强制报错，不要产生任何的warning和error</li>
</ul>
</li>
</ul>
<p>下面是一些例子：</p>
<p><strong>1：</strong></p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/9.png" style="zoom: 150%;"></p>
<p>因为在两个文件里， p1都是strong的符号，因此 链接器会报错。</p>
<p><strong>2：</strong></p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/8.png" style="zoom: 150%;"></p>
<p>p1和p2 不冲突，两个x都是弱符号，因此不冲突</p>
<p><strong>3：</strong></p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/10.png" style="zoom: 150%;"></p>
<p>两个x的数据类型都是不同的，但是这也是被允许的。linker是不管类型的，他只管x在哪</p>
<p>然而，严格意义上来说这是不行的。因为double(8个字节)比int大，当我们在p2中写入的时候，因为x和y是连续存放的，因此可能会把 int y (4个字节)覆盖掉。</p>
<p><strong>4： </strong></p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/11.png" style="zoom: 150%;"></p>
<p>同理，虽然是合法的，但是 double的x可能吧 int y给覆盖掉</p>
<p><strong>5：</strong></p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/12.png" style="zoom: 150%;"></p>
<p>两个x是一强一弱的，会选择强的那个初始化，因此并不会冲突</p>
<p>注意：只有 compiler会注意到类型，linker是不会进行类型检查的</p>
<h2 id="静态链接-重定位-relocation"><a href="#静态链接-重定位-relocation" class="headerlink" title="静态链接-重定位(relocation)"></a>静态链接-重定位(relocation)</h2><p>静态重定位是在目标程序装入内存时，由装入程序对目标程序中的指令和数据的地址进行修改，即把<strong>程序的逻辑地址都改成实际的地址</strong>。对每个程序来说，这种地址变换只是在装入时一次完成，在程序运行期间不再进行重定位。</p>
<p>例如，一个以“0”作为参考地址的装配模块，要装入以1000为起始地址的存储空间。显然，在装入之前要做某些修改，程序才能正确执行。例如，MOV　 EAX，[500]这条指令的意义，是把相对地址为500的存储单元内容1234装入eax寄存器。现在内容为1234的存储单元的实际地址为1500， 即为相对地址(500)加上装入的地址(1000),因此，MOV　EAX，[500]这条指令中的直接地址码也要相应地加上起始地址，而成为MOV　 EAX，[1500]。<br>程序中涉及直接地址的每条指令都要进行这样的修改。需要修改的位置称为重定位项，所做的加实际装入模块起始地址修改中的块起始地址称为重定位因子。</p>
<p>我们看到，从可重定位目标文件到可执行目标文件，经历了下图这样一个过程：</p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/2.png" style="zoom: 120%;"></p>
<p>拿一个实际例子来说，可执行文件包含了从不同.o文件中来的内容。最终我们要生成一个可执行文件，其代码段和数据段是放在一起的。因此我们要对两个.o 文件做一个拼接。比如说我们要把<code>main()</code> 、<code>sum()</code>放在一起。 也就是说做一个将 .o文件剪开，再归类拼接到一起的过程 。</p>
<p>假设现在 main.o 和 sum.o 发生了链接；又有一个 main1和sum.o 还有 swap.o 一起发生了链接，构成另外一个可执行文件。这就可能造成了 sum() 在不同的可执行文件当中相对于main() 的相对位置也是不同的。因此，链接器需要为目标文件中的符号进行重定位</p>
<h3 id="Relocation-Entries"><a href="#Relocation-Entries" class="headerlink" title="Relocation Entries"></a>Relocation Entries</h3><p>那么从左边的部分到右边的部分，需要解决的问题就是将 函数和.data中的一些变量的地址给固定下来(将地址填到相应位置)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val = sum(<span class="built_in">array</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sum.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,s = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i= <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		s+=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重定位算法"><a href="#重定位算法" class="headerlink" title="重定位算法"></a>重定位算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">foreach section s &#123;</span><br><span class="line">    foreach relocation entry r &#123;</span><br><span class="line">        refptr = s + r.offset; <span class="comment">/* ptr to reference to be relocated */</span></span><br><span class="line">            <span class="comment">/* Relocate a PC-relative reference */</span></span><br><span class="line">            <span class="keyword">if</span> (r.type == R_X86_64_PC32) &#123;</span><br><span class="line">                refaddr = ADDR(s) + r.offset; <span class="comment">/* ref’s run-time address */</span></span><br><span class="line">                *refptr = (<span class="keyword">unsigned</span>) (ADDR(r.symbol) + r.addend - refaddr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* Relocate an absolute reference */</span></span><br><span class="line">         	<span class="keyword">if</span> (r.type == R_X86_64_32)</span><br><span class="line">         		*refptr = (<span class="keyword">unsigned</span>) (ADDR(r.symbol) + r.addend);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们看看这个链接器是如何进行重定位的。首先，可重定位目标文件main.o 如下：</p>
<p>我们看到这时候的 .o 文件用的都是相对地址，是以 0为起始地址的</p>
<p>我们注意到。array的地址一开始被初始化为0，然后后面还有一条注释表明在重定位的时候才会把绝对地址填进去</p>
<p>同理，sum() 函数也是一个相对位置(填入的是返回后的地址，也就是+13)，在重定位的时候，才会填入绝对的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000000000000</span> &lt;main&gt;:</span><br><span class="line"><span class="number">0</span>: 	<span class="number">48</span> <span class="number">83</span> ec <span class="number">08</span> 	sub		$<span class="number">0x8</span>,%rsp</span><br><span class="line"><span class="number">4</span>: 	be <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> 	mov 	$<span class="number">0x2</span>,%esi</span><br><span class="line"><span class="number">9</span>: 	bf <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> 	mov 	$<span class="number">0x0</span>,%edi 		# %edi = &amp;<span class="built_in">array</span></span><br><span class="line">				a: R_X86_64_32 <span class="built_in">array</span> 		# Relocation entry</span><br><span class="line">e: 	e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> 	callq 	<span class="number">13</span> &lt;main+<span class="number">0x13</span>&gt; 	# sum()</span><br><span class="line">				f: R_X86_64_PC32 sum<span class="number">-0x4</span> 	# Relocation entry</span><br><span class="line"><span class="number">13</span>: <span class="number">48</span> <span class="number">83</span> c4 <span class="number">08</span> 	add 	$<span class="number">0x8</span>,%rsp</span><br><span class="line"><span class="number">17</span>: c3 						retq</span><br></pre></td></tr></table></figure>
<p>main函数引用了两个全局符号，一个是array，还有一个是sum。为每个引用，汇编器都产生一个重定位条目，然后显示在后面一行上:这里是<code>a: R_X86_64_32 array</code>和<code>f: R_X86_64_PC32 sum-0x4</code></p>
<p>这些重定位条目告诉链接器对sum的引用要进行32位<strong>相对地址</strong>进行重定位 ，表现为<code>R_X86_64_PC32</code>; 但是对 array的引用是进行32位<strong>绝对地址</strong>的重定位,表现为 <code>R_X86_64_32</code></p>
<h3 id="相对引用"><a href="#相对引用" class="headerlink" title="相对引用"></a>相对引用</h3><p>在上面的汇编代码中，main函数在第六行调用sum数，sum函数是在模块sum.o 中的。call指令 开始于节偏移 <code>0xe</code> 的地方，包括一字节的操作码<code>0xe8</code>,后跟着的是PC相对引用的占位符。现在还是00</p>
<p>假设重定位条目 r 由 4个字段组成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.offset = <span class="number">0xf</span></span><br><span class="line">r.symbol = sum</span><br><span class="line">r.type 	= R_X86_64_PC32</span><br><span class="line">r.addend = <span class="number">-4</span></span><br></pre></td></tr></table></figure>
<p>这些字段告诉链接器修改开始于偏移量<code>0xf</code> 处的32 位PC相对引用，这样在运行时它会指向 sum 例程。现在，假设链接器已经确定 <code>ADDR(.text)=0x4004d0</code>和 <code>ADDR(sum)=0x4004e8</code></p>
<p>然后通过相对寻址算法，连接器可以计算出<strong>引用的运行时地址</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">refaddr &#x3D; ADDR(s) + r.offset</span><br><span class="line">&#x3D; 0x4004d0 + 0xf</span><br><span class="line">&#x3D; 0x4004df</span><br></pre></td></tr></table></figure>
<p>然后更新引用，让它在运行时指向sum程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*refptr &#x3D; (unsigned) (ADDR(r.symbol) + r.addend - refaddr)</span><br><span class="line">&#x3D; (unsigned) (0x4004e8 +(-4)- 0x4004df)</span><br><span class="line">&#x3D; (unsigned) (0x5)</span><br></pre></td></tr></table></figure>
<p>因此，在在最后的.o文件中， call指令有着如下的重定位形式</p>
<p><code>4004de:         e8 05 00 00 00         callq 4004e8 &lt;sum&gt; # sum()</code></p>
<p>在运行时，call指令将存放在地址0x4004de 处。当CPU执行call 指令时，PC 的值为0x4004e3, 即紧随在call 指令之后的指令的地址。为了执行这条指令，CPU 执行以下的步骤：<br>1) 将PC 压入栈中</p>
<p>2) $PC\leftarrow PC+0x5 = 0x4004e3+0x5 = 0x4004e8$</p>
<p>下面是重定位之后的在 可执行文件的text区域中的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">00000000004004d0 &lt;main&gt;:</span><br><span class="line">4004d0: 		48 83 ec 08 		sub $0x8,%rsp</span><br><span class="line">4004d4: 		be 02 00 00 00 		mov $0x2,%esi</span><br><span class="line">4004d9: 		bf 18 10 60 00 		mov $0x601018,%edi # %edi &#x3D; &amp;array</span><br><span class="line">4004de: 		e8 05 00 00 00 		callq 4004e8 &lt;sum&gt; # sum()</span><br><span class="line">4004e3: 		48 83 c4 08 		add $0x8,%rsp</span><br><span class="line">4004e7: 		c3 					retq</span><br><span class="line">00000000004004e8 &lt;sum&gt;:</span><br><span class="line">4004e8: 		b8 00 00 00 00 		mov $0x0,%eax</span><br><span class="line">4004ed: 		ba 00 00 00 00 		mov $0x0,%edx</span><br><span class="line">4004f2: 		eb 09 				jmp 4004fd &lt;sum+0x15&gt;</span><br><span class="line">4004f4: 		48 63 ca 			movslq %edx,%rcx</span><br><span class="line">4004f7: 		03 04 8f 			add (%rdi,%rcx,4),%eax</span><br><span class="line">4004fa: 		83 c2 01 			add $0x1,%edx</span><br><span class="line">4004fd: 		39 f2 cmp 			%esi,%edx</span><br><span class="line">4004ff: 		7c f3 				jl 4004f4 &lt;sum+0xc&gt;</span><br><span class="line">400501: 		f3 c3 				repz retq</span><br></pre></td></tr></table></figure>
<p>我们有发现，在 .o 文件当中 <code>e:  e8 00 00 00 00 callq 13 &lt;main+0x13&gt; # sum()</code> 这行汇编代码已经变成了<br><code>4004de:   e8 05 00 00 00     callq 4004e8 &lt;sum&gt; # sum()</code> ，其中 0x4004e8 是sum的绝对地址，因为产生跳转目标的编码是由<strong>目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差</strong>得出的。因此这时候产生跳转目标的编码 = 0x4004e8-0x4004e3 = 0x05,和指令的十六进制表示相匹配，callq 采用的这种方式就是基于PC的相对地址寻址方法。</p>
<h3 id="绝对引用"><a href="#绝对引用" class="headerlink" title="绝对引用"></a>绝对引用</h3><p>重定位绝对引用相当简单。比如下面这段汇编。 mov指令将array的地址(一个32位立即地址)复制到寄存器$\%edi$当中。mov指令开始于偏移量0x9 的位置，包括1字节操作码 $0xbf$ ，后面跟着array 的32位绝对引用的占位符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">0: 	48 83 ec 08 	sub		$0x8,%rsp</span><br><span class="line">4: 	be 02 00 00 00 	mov 	$0x2,%esi</span><br><span class="line">9: 	bf 00 00 00 00 	mov 	$0x0,%edi 		# %edi &#x3D; &amp;array</span><br><span class="line">				a: R_X86_64_32 array 		# Relocation entry</span><br><span class="line">e: 	e8 00 00 00 00 	callq 	13 &lt;main+0x13&gt; 	# sum()</span><br><span class="line">				f: R_X86_64_PC32 sum-0x4 	# Relocation entry</span><br><span class="line">13: 48 83 c4 08 	add 	$0x8,%rsp</span><br><span class="line">17: c3 						retq</span><br></pre></td></tr></table></figure>
<p>现在给出占位符条目 r ，包括4个字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.offset &#x3D; 0xa</span><br><span class="line">r.symbol &#x3D; array</span><br><span class="line">r.type 	&#x3D; R_X86_64_32</span><br><span class="line">r.addend &#x3D; 0</span><br></pre></td></tr></table></figure>
<p>这些字段告诉链接器要修改从偏移量$0xa$ 开始的绝对引用，这样在运行时它将会指向array的第一个字节。现在，假设链接器已经确定</p>
<p><code>ADDR(r.symbol)=ADDR(array)=0x601018</code></p>
<p>那么根据上面的算法，我们可以计算 <code>*refptr</code>的值 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*refptr &#x3D; (unsigned) (ADDR(r.symbol) + r.addend)</span><br><span class="line">		&#x3D; (unsigned) (0x601018+0)</span><br><span class="line">		&#x3D; (unsigned) (0x601018)</span><br></pre></td></tr></table></figure>
<p>因此我们要将汇编改为</p>
<p><code>4004d9:    bf 18 10 60 00      mov    $0x601018,%edi</code> 因为我们的机器是小端法 </p>
<h2 id="库-libraries"><a href="#库-libraries" class="headerlink" title="库(libraries)"></a>库(libraries)</h2><h3 id="什么是库？"><a href="#什么是库？" class="headerlink" title="什么是库？"></a>什么是库？</h3><p>库是一些常用函数的集合，比如说基于 Math,I/O,memory management,string manipulation 的一些操作函数。</p>
<p>那么我们要引用库中的函数，有两种方法：</p>
<ul>
<li>选择1：将所有的函数放到一个源文件当中<ul>
<li>这样程序员就会将一个很大的文件链接到自己的程序当中</li>
<li>空间和时间的效率都很差。我只用一个函数，但是我却要链接很多很多其他没用的函数链接进来，这样就会浪费内存和磁盘的空间。且每次编译都要进行很多无谓的工作。</li>
</ul>
</li>
<li>选择2：将每一个库函数分别放在不同的源文件当中<ul>
<li>程序员将合适的函数精确的链接到自己的程序当中</li>
<li>更加油效率，但对程序员来说很不友好，要记住更多函数的名字，压力更大。</li>
</ul>
</li>
</ul>
<p>这两种方法都不是特别好，于是我们提出了两种方案。</p>
<h3 id="静态库-static-library"><a href="#静态库-static-library" class="headerlink" title="静态库(static library)"></a>静态库(static library)</h3><ul>
<li><p>archive(.a库文件) 就是把所有的函数头尾相连，打包。前面加一个index索引</p>
</li>
<li><p>使用链接器，使其尝试通过在一个或多个存档中查找符号来解析未解析的外部引用。</p>
</li>
<li>当我和库文件( .a)连接的时候，会到 .a 文件当中去查找哪些.o 文件是我需要的。那么这一部分 .o文件链接到我的可执行文件当中</li>
</ul>
<p>.a 和 .o 文件的关系如下：</p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/16.png" style="zoom: 120%;"></p>
<p>我们也可以字节编写一个 .a 文件：</p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/17.png" style="zoom: 120%;"></p>
<p>在编译链接的过程如下图所示：</p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/18.png" style="zoom: 120%;"></p>
<p>当我们安装环境的时候，已经把库的查找路径安装进去了，编译器会根据这些缺省的路径去查找。</p>
<p>查找的优先级：include 某一个文件可以用双引号”” 和一个\&lt;> 双引号代表当前目录下的文件，而\&lt;> 则代表在系统缺省路径中查找。</p>
<h4 id="使用静态库"><a href="#使用静态库" class="headerlink" title="使用静态库"></a>使用静态库</h4><ul>
<li>按顺序扫描.o文件和.a文件</li>
<li>在扫面描的时候，把unresolved 符号引用都保存下来</li>
<li>每当一个新的 .o 和 .a 进来，我们回去看前面的那张表，去看看前面保存的哪些unresolved 符号是否在这些 .o和 .a 文件中存在。逐个把这些unresolved 符号解析掉</li>
<li>如果整个过程结束，发现表中还有symbol没有找到，那么就会报 symbol not found ，链接失败</li>
</ul>
<h3 id="动态链接共享库-shared-library"><a href="#动态链接共享库-shared-library" class="headerlink" title="动态链接共享库(shared library)"></a>动态链接共享库(shared library)</h3><p>静态链接库有如下缺点：</p>
<ol>
<li>增加了硬盘的占用空间</li>
<li>增加了内存的占用空间，比如说一份printf的代码可能会在内存中存放100份</li>
<li>如果要更新某些库中的一些函数，我不得不将和这个库有关的程序重新编译链接一遍。这个代价是非常非常大的。编译一个程序是十分消耗时间的。</li>
</ol>
<p>所以我们引入了共享库/动态链接库的概念</p>
<p>当我想要一个 对象文件的时候，我并不将其链接进我们的程序，只有在要使用这个文件的时候，再动态的加载进去。这样就能让磁盘只保存一份库的代码即可</p>
<p>那么有哪些情况需要用到 object file呢？</p>
<ol>
<li>当加载可执行程序的时候，发现要用特定的object file，就将其加载到内存当中去</li>
<li>可执行程序要用到某个 object file中的某个全局变量或者函数的时候，到那句语句要执行的时候我在将对应的object file加载进去。</li>
</ol>
<p>在windows中，这类库叫做 .dll ; 在linux环境下，叫做 .so</p>
<h4 id="What-dynamic-libraries-are-required"><a href="#What-dynamic-libraries-are-required" class="headerlink" title="What dynamic libraries are required"></a>What dynamic libraries are required</h4><ul>
<li>.interp section<ul>
<li>Specifies the dynamic linker to use (i.e.,ld-linux.so)</li>
</ul>
</li>
<li>.dynamic section<ul>
<li>Specifies the names, etc of the dynamic libraries to use</li>
</ul>
</li>
<li>where are the libraries found <ul>
<li>专门有一个可执行文件 ldd帮我们去找到我们需要的动态链接库在什么地方</li>
</ul>
</li>
</ul>
<h4 id="生成一个动态链接库的例子"><a href="#生成一个动态链接库的例子" class="headerlink" title="生成一个动态链接库的例子"></a>生成一个动态链接库的例子</h4><p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/19.png" style="zoom: 120%;"></p>
<p>将两个 .o 文件，通过命令 <code>gcc -shared -o libvector.so addvec.o multvec.o</code> 这行命令来生成一个 .so 文件。 其中 <code>.o</code> 表示 output，即说明生成的这个文件(共享库)是什么名字。</p>
<h4 id="Dynamic-Linking-at-load-time"><a href="#Dynamic-Linking-at-load-time" class="headerlink" title="Dynamic Linking at load-time"></a>Dynamic Linking at load-time</h4><p>现在我们来讲一下加载过程中怎么样使用共享库</p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/20.png" style="zoom: 120%;"></p>
<p>我们对程序采用动态链接，这就是编译链接生成函数的内部步骤。</p>
<p>我们通过 <code>gcc -o prog21 main2.o ./libvector.so</code> 这行命令就可以将main2.o 和我们需要的 libvector.so,libc.so 组合生成prog21文件。</p>
<p>但是这个prog21文件有 main2.o的代码，但是却没有 libvector.so 的代码，仅仅是在里面“埋了一个伏笔告诉我们会用到libvector.so “</p>
<p>当我们要运行的时候(最后)，系统会通过动态链接器(ld-linux.so) 将需要的两个 .so 文件加载进去。最终形成一个完整的文件。</p>
<h4 id="Dynamic-Linking-at-Run-time"><a href="#Dynamic-Linking-at-Run-time" class="headerlink" title="Dynamic Linking at Run-time"></a>Dynamic Linking at Run-time</h4><p>现在有一个程序如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> x[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> y[<span class="number">2</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> z[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *handle;<span class="comment">//handle是一个句柄，我们通过handle这个指针来拿到我想要的东西</span></span><br><span class="line">    <span class="keyword">void</span> (*addvec)(<span class="keyword">int</span> *, <span class="keyword">int</span> *, <span class="keyword">int</span> *, <span class="keyword">int</span>);<span class="comment">//函数指针，</span></span><br><span class="line">    <span class="keyword">char</span> *error;<span class="comment">//字符串数组，来传递错误信息的</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Dynamically load the shared library that contains addvec() */</span></span><br><span class="line">    <span class="comment">//一开始用handle来挂住一个文件，也就是相对路径下的 libvector.so文件</span></span><br><span class="line">    handle = dlopen(<span class="string">"./libvector.so"</span>, RTLD_LAZY);</span><br><span class="line">    <span class="comment">//这里的 LAZY 翻译成 “迟" 的，也就是能不加载就不加载，不得已要的时候才加载</span></span><br><span class="line">    <span class="keyword">if</span> (!handle) &#123;</span><br><span class="line">    	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, dlerror());</span><br><span class="line">        <span class="comment">//如果handle没有打开这个文件，那就报标准错误</span></span><br><span class="line">   		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get a pointer to the addvec() function we just loaded */</span></span><br><span class="line">    addvec = dlsym(handle, <span class="string">"addvec"</span>);</span><br><span class="line">    <span class="keyword">if</span> ((error = dlerror()) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//如果dlerror 非空，那么也要把错误输出</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, error);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Now we can call addvec() just like any other function */</span></span><br><span class="line">    addvec(x, y, z, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"z = [%d %d]\n"</span>, z[<span class="number">0</span>], z[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Unload the shared library */</span></span><br><span class="line">    <span class="comment">//如果要关闭外部的资源，要看看handle的返回值是否是负的，负的就要报错</span></span><br><span class="line">    <span class="comment">//我们可以用man来看系统调用。</span></span><br><span class="line">    <span class="keyword">if</span> (dlclose(handle) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个工程的逻辑如下：</p>
<p>首先我们要在本地申明一个和要链接的动态库绑定的指针(handle)</p>
<p>然后打开这个共享库</p>
<p>然后正常使用共享库当中的符号 </p>
<p>最后关闭这个共享库</p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/21.png" style="zoom: 120%;"></p>
<h3 id="静态库-vs-动态库"><a href="#静态库-vs-动态库" class="headerlink" title="静态库  vs 动态库"></a>静态库  vs 动态库</h3><p>静态库和动态库的载入时间是不一样的。</p>
<p>静态库的代码在编译的过程中已经载入到可执行文件中，所以最后生成的可执行文件相对较大。</p>
<p>动态库的代码在可执行程序运行时才载入内存，在编译过程中仅简单的引用，所以最后生成的可执行文件相对较小。可以提高代码的可复用度和降低程序的耦合度。</p>
<p>静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库。</p>
<p>动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入，因此在程序运行时还需要动态库存在。</p>
<p>无论静态库，还是动态库，都是由.o文件创建的。因此，我们必须将源程序hello.c通过gcc先编译成.o文件。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>链接能让多个目标文件最终组合成一个程序</p>
</li>
<li><p>链接可以在程序生命周期的不同时间发生:</p>
<ul>
<li>Compile time (when a program is compiled) 编译阶段，静态库</li>
<li>Load time (when a program is loaded into memory) 加载阶段，动态库</li>
<li>Run time (while a program is executing) 运行阶段, 动态库</li>
</ul>
</li>
<li><p>了解链接能帮助我们避免恶心的错误</p>
</li>
</ul>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/22.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/11/17/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1-%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/17/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1-%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/" class="post-title-link" itemprop="url">最长公共/上升子序列</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-17 12:51:31" itemprop="dateCreated datePublished" datetime="2020-11-17T12:51:31+08:00">2020-11-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-08 11:33:30" itemprop="dateModified" datetime="2021-01-08T11:33:30+08:00">2021-01-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DP/" itemprop="url" rel="index"><span itemprop="name">DP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="最长公共-上升子序列"><a href="#最长公共-上升子序列" class="headerlink" title="最长公共/上升子序列"></a>最长公共/上升子序列</h1><h2 id="什么是LCS"><a href="#什么是LCS" class="headerlink" title="什么是LCS"></a>什么是LCS</h2><p>现在我们拿到2个字符串</p>
<p>string1：a b c d e f g h i</p>
<p>string 2 : c d  g i </p>
<p>我们发现，string1中的子序列 c d g i 和string2 的子序列 c d g i(也就是string2本身)相匹配，且<strong>下标是严格递增的</strong>那么我们说这两个字符串的最长公共子序列是：\<c d g i\></c></p>
<p>但是下面这种情况，最长字串还是 \<c d g i\></c></p>
<p>string1: a b c d e f g h i</p>
<p>string2 :e c d g i</p>
<p>虽然 string1和string2中都有e，但是因为他们的<strong>下标并不是严格递增</strong>的，因此 e c g d i 并不是string1和string2 的子序列。</p>
<p>最后一个例子：</p>
<p>string1： a b d a c e</p>
<p>string2:  b  a  b c e</p>
<p>这里，我们发现 \<a b c e> 和 \<b a c e> 都是string1和string2的最长公共子串，因此，LCS的个数是不唯一的</b></a></p>
<p>通过上面这些例子，我们可以这样来解释最长公共子序列问题(longest common subsequence problem)：</p>
<p>给定两个序列 $X=<x_1,x_2,\cdots,x_m>$和 $Y=<y_1,y_2,\cdots,y_n>$ 那么这时候如果 Z 既是X的子序列，又是Y 的子序列，且没有更长的子序列满足上述条件，我们称其为X和Y的最长公共子序列。我们要求的就是 Z 表示的长度最长的公共子序列。</y_1,y_2,\cdots,y_n></x_1,x_2,\cdots,x_m></p>
<h2 id="LCS-using-recursion"><a href="#LCS-using-recursion" class="headerlink" title="LCS using recursion"></a>LCS using recursion</h2><p>现在我们来讨论一下LCS的子问题，对两个序列 $X=<x_1,x_2,\cdots,x_m>$和 $Y=<y_1,y_2,\cdots,y_n>$ </y_1,y_2,\cdots,y_n></x_1,x_2,\cdots,x_m></p>
<ul>
<li>如果 $x<em>m=y_n$，则我们应该求解 $X</em>{m-1}$ 和 $Y_{n-1}$ 的一个LCS。并将 $x_m=y_n$ 追加到这个LCS的末尾，也就得到了 X和Y的一个LCS</li>
<li>如果$x<em>m\neq y_n$ 那么我们必须求解两个子问题： 求 $X</em>{m-1}$ 和 $Y$ 的一个 LCS 与 $X$ 和 $Y_{n-1}$ 的一个LCS。两个LCS的较长者(或者一样长)即为X和Y的一个LCS。</li>
</ul>
<p>上述子问题包括了所有情况，我们可以像矩阵链乘法一样写一个最优解的递归式。我们定义 $c[i,j]$ 表示 $X_i$ 和 $Y_j$ 的LCS长度，如果i =0 或者j=0，即一个序列的长度就等于0，那么LCS的长度为0。公式如下：</p>
<p><img src="/2020/11/17/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1-%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/1.png" style="zoom:80%;"></p>
<p>我们用一个例子来展现一个简单的递归过程</p>
<p><img src="/2020/11/17/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1-%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/1.jpg" style="zoom:80%;"></p>
<h2 id="LCS-using-memoisation"><a href="#LCS-using-memoisation" class="headerlink" title="LCS using memoisation"></a>LCS using memoisation</h2><p>我们可以用一个二维数组记录下子问题的最优解。当$i,j$ 等于0的时候，其所在的那一行就填写0。剩下的格子中的数值取决于它左边上面的最大值(当$x_i\neq y_j$) 的时候，或者其左上方的格子+1(当$x_i = y_j$) 的时候。</p>
<p><img src="/2020/11/17/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1-%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/2.png" style="zoom:80%;"></p>
<p>这个算法的时间复杂度即为扫描这个二维数组的时间，设 n=string1.length , m=string2.length ,则 时间复杂度为 $O(mn)$ </p>
<p>空间复杂度即为一些常量的存储和二维数组的开销，为$O(mn)+O(1)=O(mn)$ </p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>伪代码：</p>
<p><img src="/2020/11/17/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1-%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/3.png"></p>
<p><img src="/2020/11/17/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1-%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/4.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxNum  100000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxInt  2147483647</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> memoisation[maxSize][maxSize];</span><br><span class="line"><span class="keyword">int</span> lcs[maxSize][maxSize]; <span class="comment">// left 0 leftup : 1 up:2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="built_in">string</span> x,<span class="built_in">string</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">int</span> m = x.length();</span><br><span class="line">    <span class="keyword">int</span> n = y.length();</span><br><span class="line"></span><br><span class="line">    memoisation[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    memoisation[<span class="number">1</span>][<span class="number">0</span>]= memoisation[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;m+<span class="number">2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        memoisation[i][<span class="number">0</span>] = x[i - <span class="number">2</span>];</span><br><span class="line">        lcs[i][<span class="number">0</span>] = x[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n+<span class="number">2</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        memoisation[<span class="number">0</span>][j] = y[j - <span class="number">2</span>];</span><br><span class="line">        lcs[<span class="number">0</span>][j] = y[j - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m+<span class="number">2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        memoisation[i][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        lcs[i][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;n+<span class="number">2</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        memoisation[<span class="number">1</span>][j]=<span class="number">0</span>;</span><br><span class="line">        lcs[<span class="number">1</span>][j]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">2</span>;j&lt;n+<span class="number">2</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">2</span>;i&lt;m+<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            memoisation[i][j] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (x[i<span class="number">-2</span>]==y[j<span class="number">-2</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                memoisation[i][j] = memoisation[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                lcs[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(memoisation[i - <span class="number">1</span>][j] &gt;= memoisation[i][j - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                memoisation[i][j] = memoisation[i - <span class="number">1</span>][j];</span><br><span class="line">                lcs[i][j] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                memoisation[i][j] = memoisation[i][j - <span class="number">1</span>];</span><br><span class="line">                lcs[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printlcsmatrix</span><span class="params">(<span class="built_in">string</span> x,<span class="built_in">string</span> y)</span></span>&#123;<span class="comment">//递归输出最优方案</span></span><br><span class="line">    <span class="keyword">int</span> m = x.length();</span><br><span class="line">    <span class="keyword">int</span> n = y.length();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"下面是存储继承子问题箭头的矩阵(左为0,左上为1,上为2)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">"\t"</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">'\t'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n+<span class="number">2</span>;i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;y[i<span class="number">-2</span>]&lt;&lt;<span class="string">'\t'</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>;j&lt;n+<span class="number">2</span>;j++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; lcs[<span class="number">1</span>][j] &lt;&lt; <span class="string">'\t'</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;m+<span class="number">2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;x[i<span class="number">-2</span>]&lt;&lt;<span class="string">'\t'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n+<span class="number">2</span>;j++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; lcs[i][j] &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_dp</span><span class="params">(<span class="built_in">string</span> x,<span class="built_in">string</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = x.length();</span><br><span class="line">    <span class="keyword">int</span> n = y.length();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"下面是存储标量乘法次数的矩阵(纵坐标为i,横坐标为j)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">"\t"</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">'\t'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n+<span class="number">2</span>;i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;y[i<span class="number">-2</span>]&lt;&lt;<span class="string">'\t'</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>;j&lt;n+<span class="number">2</span>;j++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; memoisation[<span class="number">1</span>][j] &lt;&lt; <span class="string">'\t'</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;m+<span class="number">2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;x[i<span class="number">-2</span>]&lt;&lt;<span class="string">'\t'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n+<span class="number">2</span>;j++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; memoisation[i][j] &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printlcs</span><span class="params">(<span class="built_in">string</span> x,<span class="keyword">int</span> lenx,<span class="keyword">int</span> leny)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lenx == <span class="number">1</span>||leny == <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (lcs[lenx][leny]==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printlcs(x,lenx<span class="number">-1</span>,leny<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;x[lenx<span class="number">-2</span>]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (lcs[lenx][leny] == <span class="number">2</span>)</span><br><span class="line">        printlcs(x,lenx<span class="number">-1</span>,leny);</span><br><span class="line">    <span class="keyword">else</span> printlcs(x,lenx,leny<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> X,Y;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;X;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;Y;</span><br><span class="line">    <span class="keyword">int</span> m = X.length();</span><br><span class="line">    <span class="keyword">int</span> n = Y.length();</span><br><span class="line">    <span class="built_in">find</span>(X,Y);</span><br><span class="line">    print_dp(X,Y);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    printlcsmatrix(X,Y);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"根据矩阵，我们可以得到两个字符串的lcs为: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    printlcs(X,m+<span class="number">1</span>,n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/11/17/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1-%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/5.png" style="zoom:120%;">    </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/11/17/%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/17/%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%E6%B3%95/" class="post-title-link" itemprop="url">矩阵链乘法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-17 12:40:33" itemprop="dateCreated datePublished" datetime="2020-11-17T12:40:33+08:00">2020-11-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-26 22:26:48" itemprop="dateModified" datetime="2020-11-26T22:26:48+08:00">2020-11-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DP/" itemprop="url" rel="index"><span itemprop="name">DP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="矩阵链乘法"><a href="#矩阵链乘法" class="headerlink" title="矩阵链乘法"></a>矩阵链乘法</h1><h2 id="什么是矩阵乘法？"><a href="#什么是矩阵乘法？" class="headerlink" title="什么是矩阵乘法？"></a>什么是矩阵乘法？</h2><p>这是线性代数最重要的一个部分，这里我直接写矩阵乘法的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> a_n,a_m,b_n,b_m;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a_m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;b_n;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;a_n;k++)&#123;</span><br><span class="line">                ans[i][j]+=a[i][k]*b[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码我们可以看出，一共要进行三重循环，对于矩阵$a[a_m][a_n]$和 $b[b_m][b_n]$ 来说，他们能够相乘，那么必然 $a_n=b_m$</p>
<p>那么这个算法一共要进行的乘法计算次数为：$a_m<em>a_n</em>b_n$ </p>
<p>比如说，对于矩阵 $A_1[10][100],A_2[100][5]$ 来说，他们要相乘，乘法运算的次数为: $10\cdot100\cdot5=5000$次 </p>
<h2 id="什么是-矩阵链-乘法？"><a href="#什么是-矩阵链-乘法？" class="headerlink" title="什么是 矩阵链 乘法？"></a>什么是 矩阵链 乘法？</h2><p>给定 n 个矩阵的链 $<A_1\cdot a_2,\cdots,a_n>$ 矩阵$A<em>i$ 的规模为 $p</em>{i-1} \times p_i(i\leq i\leq n)$ ,求完全括号化方案，使得计算乘积 $A_1A_2\cdots A_n$ 所需标量乘法次数最小。</A_1\cdot></p>
<p>我们以矩阵链$<A_1,A_2,A_3>$相乘为例．来说明不同的加括另方式会导致不同的计算代价． 假设三个矩阵的规模分别为$10\times 100$、 $100\times 5$和$5\times 50$. 如果按$((A_1,A_2)A_3)$的顺序计算．为计算$A_1A_2(计算后矩阵规模为10\times 5)$, 需要做10• 100• 5 = 5000次标量乘法， 再与$A_3$ 相乘又需要做10• 5• 50 = 2 500次标量乘法． 共需7500次标量乘法．</A_1,A_2,A_3></p>
<p>但是，如果按$(A_1(A_2A_3))$ 的顺序．计算$A_2A_3$(计算后矩阵规模为 $100\times 50$), 需100 ·5·50=25000次标量乘法, 再与$A_1$相乘又需10•100• 50=50 000次标鬟乘法． 共需75000次标量乘法． 因此．按第一种顺序计算矩阵链乘积要比第二种顺序快10倍．</p>
<h2 id="用动态规划方法求解"><a href="#用动态规划方法求解" class="headerlink" title="用动态规划方法求解"></a>用动态规划方法求解</h2><p><img src="/2020/11/17/%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%E6%B3%95/1.jpg" style="zoom:80%;"></p>
<p>我们可以这么来理解：令 $m[i,j]$ 表示计算矩阵 $A_i\cdots A_j$ 所需标量乘法次数的最小值，那么原问题的最优解 就变成了 $m[1,n]$</p>
<p>我们可以递归定义$m[i,j]$如下． 对于 $i,j$ 时的平凡问题．矩阵链只包含唯一的矩阵，那么这时候就不用做任何的标量乘法运算。所以，对所有的 $i = 1,2,\cdots,n,m[i,i]=0 $ .我们假设 $A<em>iA</em>{i+1}\cdots A<em>j$ 的最优括号化方案的分割点再矩阵 $A_k$ 和 $A</em>{k+1}$ 之间，其中 $i\leq k&lt;j$，那么，$m[i,j]$ 就等于计算 $A<em>{i\cdots k}$ 和 $A</em>{k+1\cdots j}$ 相乘的代价为 $p_{i-1}p_kp_i$次标量乘法运算。因此，我们得到：</p>
<p>$m[i,j] = m[i,k]+m[k+1,j]+p_{i-1}p_kp_j$</p>
<p>此递归公式假定最优分割点k是已经知道的，但是事实上我们并不知道。不过 k只有 j-i种可能。由于最优分割点必在这其中，我们只要检查所有可能的情况。找到最优解即可。因此我们可以写出下面这个递归公式</p>
<p><img src="/2020/11/17/%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%E6%B3%95/1.png" style="zoom:80%;"></p>
<p> 比如说对于一个长为4 的矩阵链，我们可以这样将他的完整的递归链条写出来。</p>
<p><img src="/2020/11/17/%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%E6%B3%95/2.jpg" style="zoom:80%;"></p>
<p>但这样写十分庞杂，我们可以将它整合到一个 i * j 的棋盘格当中。</p>
<p> 比如说题目是这样的：</p>
<p> <img src="/2020/11/17/%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%E6%B3%95/2.png" style="zoom:80%;"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxNum  100000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxInt  2147483647</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[maxSize][maxSize];</span><br><span class="line"><span class="keyword">int</span> cut[maxSize][maxSize];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> *sequence,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k,chain_length;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][i] = <span class="number">0</span>;</span><br><span class="line">        cut[i][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        cut[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        cut[<span class="number">0</span>][j] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(chain_length = <span class="number">2</span>;chain_length&lt;=n;chain_length++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;=n-chain_length+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            j = i+chain_length<span class="number">-1</span>;</span><br><span class="line">            dp[i][j] = maxInt;</span><br><span class="line">            <span class="keyword">for</span>(k=i;k&lt;j;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = dp[i][k]+dp[k+<span class="number">1</span>][j]+sequence[i<span class="number">-1</span>]*sequence[k]*sequence[j];</span><br><span class="line">                <span class="keyword">if</span>(temp &lt; dp[i][j])</span><br><span class="line">                    dp[i][j] =temp,cut[i][j] =k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;<span class="comment">//递归输出最优方案</span></span><br><span class="line">    <span class="keyword">if</span>(start==<span class="built_in">end</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"A%d"</span>,start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"("</span>);</span><br><span class="line">        <span class="built_in">print</span>(start,cut[start][<span class="built_in">end</span>]);</span><br><span class="line">        <span class="built_in">print</span>(cut[start][<span class="built_in">end</span>]+<span class="number">1</span>,<span class="built_in">end</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_dp</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"下面是存储标量乘法次数的矩阵(纵坐标为i,横坐标为j)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\t"</span>,dp[i][j]);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"下面是存储截断点位置的矩阵(纵坐标为i,横坐标为j)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\t"</span>,cut[i][j]);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sequences[maxNum],n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;number;</span><br><span class="line">        sequences[i] = number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">find</span>(sequences,n);</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    print_dp(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么对于刚才的题目，我们可以输出 m矩阵和k矩阵，并且给出最优的括号解</p>
<p><img src="/2020/11/17/%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%E6%B3%95/3.png" style="zoom:80%;"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">CSAPP存储器层次结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-14 09:40:28" itemprop="dateCreated datePublished" datetime="2020-11-14T09:40:28+08:00">2020-11-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-25 15:24:20" itemprop="dateModified" datetime="2022-06-25T15:24:20+08:00">2022-06-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="存储器层次结构-The-memory-hierarchy"><a href="#存储器层次结构-The-memory-hierarchy" class="headerlink" title="存储器层次结构(The memory hierarchy)"></a>存储器层次结构(The memory hierarchy)</h1><h2 id="存储技术"><a href="#存储技术" class="headerlink" title="存储技术"></a>存储技术</h2><p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/1.png" style="zoom:80%;"></p>
<h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/9.png" style="zoom:80%;"></p>
<p> 这是一个硬盘的内部结构，圆形的部分是磁片，Arm是磁头臂，其尖端就是一个磁头。</p>
<p>我们将磁盘模型抽象出来：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/10.png" style="zoom:80%;"></p>
<ul>
<li>磁盘中有很多磁片，每一张磁片有2面</li>
<li>磁片的每一面又有若干的同心圆，叫做磁道(track)</li>
<li>磁道之间并不是连续的，中间有gap将其分成一小段一小段，每一小段叫做一个sector</li>
</ul>
<h4 id="磁盘容量"><a href="#磁盘容量" class="headerlink" title="磁盘容量"></a>磁盘容量</h4><p>现在的磁盘都是以TB为单位来计算的</p>
<p>一张磁盘的容量和下面几个参数有关：</p>
<ul>
<li>Recording density</li>
</ul>
<p>number of bits that can be squeezed into a 1 inch segment of a track.每英寸的sector可以放多少数据</p>
<ul>
<li>Track density</li>
</ul>
<p>number of tracks that can be squeezed into a 1 inch radial segment.一张磁片上可以放多少磁道</p>
<ul>
<li>Areal density</li>
</ul>
<p>product of recording and track density. 每平方英寸上可以放多少bity</p>
<h4 id="磁盘操作"><a href="#磁盘操作" class="headerlink" title="磁盘操作"></a>磁盘操作</h4><p>磁盘和磁头都可以运动。磁盘是转动，而磁头接近于径向移动。通过磁头径向移动，其可以扫到所有的磁道。在读取或者写入数据的时候，我们只要将磁头移动到特定的track上并旋转磁片，就可以通过电磁感应来讲数据写道特定的sector当中去。</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/11.png" style="zoom:80%;"></p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/12.png" style="zoom:80%;"></p>
<h4 id="磁盘访问："><a href="#磁盘访问：" class="headerlink" title="磁盘访问："></a>磁盘访问：</h4><p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/13.png" style="zoom:80%;"></p>
<p>现在我们在访问蓝色的数据，访问完之后，如果我们要访问红色的数据，需要进行上述几个步骤。</p>
<p>首先，我们要将磁头移动到红色区域所位于的磁道上方，(抬起来移动过去)，这个过程叫做 seek(寻道)、</p>
<p>接下来，我们要将磁片旋转，让红色区域转到磁头的下方，这个过程叫 Rotational latency</p>
<p>最后，我们的磁头要碰到红色区域进行电磁感应并传输数据</p>
<p>这些过程，都是机械运动，所以相对于内存来说，磁盘访问是非常非常慢的。</p>
<h4 id="访问时间"><a href="#访问时间" class="headerlink" title="访问时间"></a>访问时间</h4><p>我们来计算一下磁盘访问时间。 简单来说 就是上面几个过程的所消耗时间之和，也就是寻道时间+旋转时间+传送时间</p>
<p>$T<em>{access} = T</em>{avg~seek}+T<em>{avg~rotation}+T</em>{avg~transfer}$ </p>
<p>寻道时间通常为3~9ms,一次寻道的最大时间 $T_{maxseek}$可以高达20ms。</p>
<p>旋转时间是的计算公式为 $T_{avg~rotation}= \frac{1}{2}\times\frac{1}{RPM}\times\frac{60s}{1min}$ RPM即为每分钟的转速</p>
<p>传送时间一般依赖于旋转速度和每条磁道的扇区数目。因此我们可以这样来计算</p>
<p>$T_{avg~transfer} = \frac{1}{RPM}\times\frac{1}{(平均扇区数/磁道)}\times \frac{60s}{1min}$ </p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/14.png" style="zoom:80%;"></p>
<p>估计访问下面这个磁盘上一个扇区的访问时间（以ms 为单位）：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/48.png" style="zoom:120%;"></p>
<p>$T<em>{avg~rotation} =\frac{1}{2}\times T</em>{max~rotation}=\frac{1}{2}\times\frac{60s}{15000RPM}\times\frac{1000ms}{1s}= 2ms$</p>
<p>$T_{avg~transfer}=(60s/15000RMP)\times\frac{1}{500扇区/磁道}\times\frac{1000ms}{s}= 0.008ms$ </p>
<p>所以预计总的访问时间为 $8+2+0.008 \approx10ms$ </p>
<p>硬盘两个参数很重要：随机访问速度和连续访问速度。硬盘的随机访问速度是很慢的，但是连续访问速度是很快的。当我们写的随机算法将内存中的空间占满之后，数据便要随机存储到硬盘当中去，这时候磁盘的随机访问速度如果很慢那么这个算法肯定是会垮掉的。</p>
<p>比如说这一题：假设1MB 的文件由512 个字节的逻辑块组成，存储在具有如下特性的磁盘驱动器上：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/49.png" style="zoom:120%;"></p>
<p>对于下面的情况，假设程序顺序地读文件的逻辑块，一个接一个，将读/写头定位道第一块上的时间是 $T<em>{avg~seek}+T</em>{avg~rotations}$</p>
<p>A. 最好的情况: 给定逻辑块道磁盘扇区地最好的可能的映射(顺序的)，估计读取这个文件所需要的最优时间</p>
<p>B. 随机的情况：如果块是随机映射到磁盘扇区的，估计读这个文件所需要的时间,以毫秒为单位</p>
<p>首先我们计算 $T<em>{access}=T</em>{seek}+T<em>{avg~rotation}+T</em>{avg~transfer}=5ms+\frac{1}{2}\times\frac{60}{10000}\times\frac{1000ms}{1s}+\frac{60s}{10000RPM}\times\frac{1}{1000扇区/磁道}\times\frac{1000ms}{1s}\approx 8ms$</p>
<p>如果是最好的情况，块被映射到连续的扇区，在同一柱面上，那样就可以一块接一块地读取，不用寻道和移动读写头。一旦读/写头定位到了第一个扇区，我们只需要旋转磁盘2整圈(每圈1000个扇区，每个扇区512字节)来读取2000个块。所以读取这个文件地总时间只要 $T<em>{seek}+T</em>{avg~rotation}+2\times T_{max~rotation}=5+3+12=20ms$ </p>
<p>随机的情况下，块被随机地映射到扇区上，读2000块中的每一块都需要 $T<em>{avg~seek}+T</em>{avg~rotations}$ms = 8*2000=16000ms=16秒</p>
<p>所以，我们看得到，清理磁盘碎片是一件很重要的事情！</p>
<h4 id="I-O-Bus"><a href="#I-O-Bus" class="headerlink" title="I/O Bus"></a>I/O Bus</h4><p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/15.png" style="zoom:80%;"></p>
<p>磁盘是挂在磁盘控制器上的，而磁盘控制器是挂在I/O Bus，与I/O bridge相连的。那么我们要读取disk中的sector的话，首先要告诉磁盘控制器，然后从磁盘中取出数据后，直接放入内存而不经过CPU的。这种模式叫做 DMA(Direct Memory Access) 直接内存访问。</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/16.png" style="zoom:80%;"></p>
<p>那么为什么不用CPU去取数据呢？因为CPU是一个很贵的”劳动力“，而取数据是一个相对比较低端的”杂活”，我们要让CPU去干更加复杂的计算。</p>
<h3 id="Nonvolatile-Memories"><a href="#Nonvolatile-Memories" class="headerlink" title="Nonvolatile Memories"></a>Nonvolatile Memories</h3><ul>
<li><p>DRAM和SRAM都是易于丢失的内存，停电之后，里面的数据都没了</p>
</li>
<li><p>非易失的内存，在停电之后，数据并不会丢失</p>
<ul>
<li>Read-only memory (ROM): programmed during production</li>
<li>Electrically eraseable PROM (EEPROM): electronic erase capability</li>
<li>Flash memory: EEPROMs, with partial (block-level) erase capability (U盘)</li>
<li>3D XPoint (Intel Optane) &amp; emerging NVMs</li>
</ul>
</li>
</ul>
<p>非易失的数据，有这些应用：</p>
<ul>
<li>Firmware(固件) programs stored in a ROM(比如Bios，磁盘控制器，网卡，显卡加速器等)</li>
<li>固态硬盘(ssd)</li>
<li>Disk caches</li>
</ul>
<h3 id="SSD-固态硬盘"><a href="#SSD-固态硬盘" class="headerlink" title="SSD(固态硬盘)"></a>SSD(固态硬盘)</h3><p>固态硬盘的结构如下：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/17.png" style="zoom:80%;"></p>
<p>SSD中，有很多Block，每个Block之间又有很多Page</p>
<ul>
<li>每一个Page的大小从4k-512k不等，每一个Blocks又有32-128个page</li>
<li>读和写都是以page为单位进行的</li>
<li>不能只写1个page，需要把整个block擦除之后再写</li>
<li>每一个block的寿命大概是写入十万次</li>
</ul>
<h4 id="ssd的性能"><a href="#ssd的性能" class="headerlink" title="ssd的性能"></a>ssd的性能</h4><p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/18.png" style="zoom:80%;"></p>
<p>顺序的读取：2G出头，顺序的写入：2G不到一点。但是随机读和随机写入相对于顺序的读取和写入慢很多很多。随机的写入特别慢，因为我们先要擦除block，再写入。</p>
<p>我们这里还要了解一Buffer和Cache的区别</p>
<p>Cache是缓存，一般认为Cache中有的，比它第一级的存储区域也要有。cache是其下一级的一个子集</p>
<p>Buffer是缓冲，我们将一些数据暂时放到Buffer中，但Buffer中的数据可能并不会在低一级的存储器中。相当于一个蓄水池。</p>
<p>SSD中的DRAM是个Buffer，因为我一下子要将东西写入page中是不方便的，所以我们暂时把数据放到蓄水池Buffer当中。</p>
<p>还有一个作用，Buffer是将随机的数据，变成连续的数据，这样可以提升写入速度，同时也付出了昂贵的DRAM造价</p>
<h2 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h2><p>局部性对硬件和软件系统的设计和性能都有着极大的影响，有良好局部性的程序比局部性差的程序<br>运行得更快。因此一个编写良好的计算机程序常常具有良好的局部性。也就是说它们倾向于 <strong>引用</strong> 邻近于 <strong>最近引用过的数据项</strong> 的数据项，或者是最近引用过的数据项本身。</p>
<p>局部性常常有两种不同的形式：时间局部性和空间局部性。</p>
<p>时间局部性良好是说，被引用过一次的内存位置很可能再<strong>不远的将来</strong>再次被多次引用</p>
<p>空间局部性良好是说，如果一个内存的位置被引用了一次，那么程序很可能在不远的将来引用<strong>附近的</strong>一个内存位置。</p>
<p>对于一个同一个算法来说，调换两行遍历代码并不会影响算法的复杂度，但是其局部性可能相差会非常非常大。比如说一个二维数组元素求和的算法.正常来说我们写双重循环，内层循环会读一行数据，外层循环则负责换行。因此这个 <code>sumarrayrows</code> 算法具有良好的空间局部性，因为他按照数组被存储的优先顺序来访问这个数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_array_rows</span><span class="params">(<span class="keyword">int</span> a[M][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">    	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">    		sum += a[i][j];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法得到了一个很好的<strong>步长为1</strong> 的引用模式，具有良好的空间局部性：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/2.png" style="zoom:120%;"></p>
<p>但是我们只要做一个很小的改动，就会对其局部性有很大的影响。比如说我们把循环中的i、j和M、N调换</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_array_cols</span><span class="params">(<span class="keyword">int</span> a[M][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">    	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">    		sum += a[i][j];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这样的交换就会导致这个算法的空间局部性很差，因为他按照列顺序来扫描数组，而不是按照行顺序，因为在C数组再内存中是按照行顺序存放的。</p>
<p>我们得到了一个步长为N的引用模式，如图所示：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/3.png" style="zoom:120%;"></p>
<p>我们再来举一个例子：</p>
<p>一个对三维数组求和的算法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_array_3d</span><span class="params">(<span class="keyword">int</span> a[M][N][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">    		<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; M; k++)</span><br><span class="line">    			sum += a[k][i][j];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到，三层循环是按照i、j、k来执行的的，但是 我们最后访问的却是<code>a[k][i][j]</code>这显然是一个局部性很差的算法，因为其步长是<code>N*N*sizeof(int)</code> ,我们需要调整一下循环的顺序来将这个算法的步长改为1——将第二层关于j的循环放在最内层即可。</p>
<p>最后，让我们讲一些评价程序中局部性的一些简单原则：</p>
<ul>
<li>重复引用相同变量的程序有良好的时间局部性</li>
<li>对于步长为k的引用模式的程序，<strong>步长越小，空间局部性越好</strong>。在内存中以大步长跳来跳去的程序空间局部性会很差。</li>
<li>对于取指令来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好。</li>
</ul>
<h2 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h2><p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/4.png" style="zoom:120%;"></p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/8.png" style="zoom:120%;"></p>
<p>我们的存储器大致可以画成一个金字塔形，越上面的造价越贵、读取方式越快、容量越小；相反的，底层的存储设备变得更慢</p>
<ul>
<li><p>在最高层(L0) 是少量快速的CPU<strong>寄存器</strong>，CPU 可以在一个时钟周期内访问它们。</p>
</li>
<li><p>接下来是一个或多个小型到中型的<strong>基于SRAM 的高速缓存存储器</strong>，可以在几个CPU 时钟周期内访问它<br>们。这些元器件发热量高耗电大，因此没有办法造的很大。这里我们设计了3层Cache</p>
</li>
<li><p>然后是一个大的<strong>基于DRAM 的主存</strong>，可以在几十到几百个时钟周期内访问它们,</p>
</li>
<li><p>接下来是慢速但是容量很大的<strong>本地磁盘</strong>。</p>
</li>
<li><p>最后，有些系统甚至包括了一层附加的远程服务器上的磁盘，要通过网络来访问它们</p>
</li>
</ul>
<p>对于Cache，我们是一行一行读入的，每一行是64个字节</p>
<p>对于磁盘，我们会读取相当大的一块区域，而且磁盘跳读是非常慢的。</p>
<p>我们知道，现在的CPU读取和磁盘读取的速度相差地越来越大，我们希望用便宜的价格买到大容量存储的设备，又希望在读取时能达到一个较高的速度，怎么办？这时候Cache就应运而生了， 在运行程序的时候，我们希望将我们需要的数据放在靠近金字塔顶端的Cache中，把我们不要的数据放在底层磁盘当中。这样，只有在进行数据交换的时候，才会到磁盘当中去取，时间才会变慢。</p>
<p>这就好像一个贪心算法，根据局部性原理，当我们访问过一个数据之后，我们就可以将其放在上层cache中，因为将来很可能再会用到。也就是说，上层是下层的缓存。</p>
<h3 id="存储器层次结构中的缓存"><a href="#存储器层次结构中的缓存" class="headerlink" title="存储器层次结构中的缓存"></a>存储器层次结构中的缓存</h3><p>一般而言，高速缓存(cache)是一个小而快速的存储设备，它作为存储在更大、也更慢的设备中的数据对象的缓冲区域。使用高速缓存的过程称为缓存(caching)</p>
<p>存储器层次结构的中心思想是，对于每个k，位于為层的更快更小的存储设备作为位于k+1层的更大更慢的存储设备的缓存。换句话说，层次结构中的每一层都缓存来自较低一层的数据对象。</p>
<p>比如说这个例子，第k层更小更快也更贵，其只有4个块，缓存着第k+1层块的一个子集。k+1层存储器被划分为16个大小固定的块，编号为 0~15</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/5.png" style="zoom:120%;"></p>
<h4 id="Hit"><a href="#Hit" class="headerlink" title="Hit"></a>Hit</h4><p>接下来我们来介绍一个概念： Hit 命中.简单来说，就是上一级想要的数据，下一级刚好有。比如下面这个例子，顶层的想要数据14，然后发现Cache里面刚好有数据14，那么这就是命中了。</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/7.png" style="zoom:120%;"></p>
<h4 id="Miss"><a href="#Miss" class="headerlink" title="Miss"></a>Miss</h4><p>Miss和Hit相反，也就是说没有命中。比如下面这个例子，上面的数据想要12，而第二层Cache中原来的数据为8、9、14、3并没有12，所以这就是一个Miss。于是Cache又要向下一层Memory里去找数据12，Memory里有12，然后将其提到Cache中去。</p>
<p>那么这就出现了一个问题：我们怎么来决定什么元素应该被替换(上面这个例子中，9被替换)？ 也就是说找到一个Victim。这是在操作系统中要学习的内容，也就是 Replacement policy,也是我们规定的一套标准。</p>
<p> <img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/6.png" style="zoom:120%;"></p>
<h3 id="3-Types-of-Cache-Misses"><a href="#3-Types-of-Cache-Misses" class="headerlink" title="3 Types of Cache Misses"></a>3 Types of Cache Misses</h3><p>我们要知道 ，程序出现了Miss的话，要再向下级去寻找，这就导致运行时间长了很多，是一种严重拉低效率的情况。</p>
<h4 id="Code-compulsory-miss"><a href="#Code-compulsory-miss" class="headerlink" title="Code (compulsory) miss"></a>Code (compulsory) miss</h4><p>顾名思义，就是冷启动。因为我们电脑启动的时候，Cache里面是没有数据的，因此第一次肯定会miss。</p>
<p>所以也说这是 compulsory miss</p>
<h4 id="Capacity-miss"><a href="#Capacity-miss" class="headerlink" title="Capacity miss"></a>Capacity miss</h4><p>Capacity是容量之意，比如说，我每一次循环里面要读取的数据时4个kb，但是一个cache里面的容量只有3k，那么不管怎么访问和优化，都会出现miss的情况。有点捉襟见肘的意思。</p>
<p>容量不够的话，我们可以停止一些程序的运行，以确保急需cache的程序来访问内存。</p>
<h4 id="Conflict-miss"><a href="#Conflict-miss" class="headerlink" title="Conflict miss"></a>Conflict miss</h4><p>举一个例子，假设我们规定，在k+1层的编码为i的block 必须被放到k层编码为(i mod 4) 的block当中，而我们又必须反复去读取0,8,0,8这一串数据，那么虽然说我k层的blocks还没有用完，capacity也是够的，但是每次访问还是会出现miss，因为0，8 mod4都是0，被映射到了同一个对应的block，造成了conflict miss。因此，这种情况是我们需要规避的，我们需要设计良好的机制来减少甚至避免这种情况的发生。</p>
<h2 id="Cache-Memories-高速缓存存储器"><a href="#Cache-Memories-高速缓存存储器" class="headerlink" title="Cache Memories(高速缓存存储器)"></a>Cache Memories(高速缓存存储器)</h2><p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/19.png" style="zoom:120%;"></p>
<p>这就是Cache在CPU中的模拟结构。CPU会首先在cache memory中去找。</p>
<p>下面这幅图是Instruction Cache在CPU中的一些具体的功能</p>
<p><code>Fetch Control</code> 是决定取哪一条指令的，然后再到Cache中去取。</p>
<p><code>Instruction Decode</code> 是将从Cache中取回来的指令变成二进制编码的</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/20.png" style="zoom:120%;"></p>
<h3 id="General-Cache-Organization"><a href="#General-Cache-Organization" class="headerlink" title="General Cache Organization"></a>General Cache Organization</h3><p>cache memory是这样来组织的：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/21.png" style="zoom:120%;"></p>
<p>一个cache里面有若干个set，每个set里面又有若干的cache line。 一个cache里面，有$2^s$个sets，每一个sets里面又有 $2^e$个cache line。这样做的目的是为了编码比较方便。</p>
<p> 每一个cache line内部又分成三个部分，分别是 v,tag和B。</p>
<ul>
<li><p>B就是Cache line里面的存储空间,大小为 $2^b$个 bytes</p>
</li>
<li><p>v只有一位，全称为 valid bit，来标志这个cache line 是否有用。</p>
</li>
<li>tag则是这个cache line的标签。</li>
</ul>
<p>现在我们来做一个小练习：</p>
<p>我们得到了表格中的一部分信息，我们现在要讲表格补齐，因此这里我们需要对地址的划分非常清楚</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">高速缓存</th>
<th>m(位数)</th>
<th>C(cache大小)</th>
<th>B(块大小)</th>
<th>E(cache line总数)</th>
<th>S(Set总数)</th>
<th>t(tag位数)</th>
<th>s(set位数)</th>
<th>b(block位数)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td>32</td>
<td>1024</td>
<td>4</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td>32</td>
<td>1024</td>
<td>8</td>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td>32</td>
<td>1024</td>
<td>32</td>
<td>32</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>C代表了Cache Size 也就是 $S\times E\times B = 1024$  这里我们已经知道了B和E，于是我们可以先填写S。</p>
<ol>
<li>第一个cache 的$S = 1024/4 = 256$，也就是说这个Cache 有256个set</li>
<li>同理，第二个Cache的$S = 1024/(8\times 4) = 32$ ,也就是说这个Cache 有32个set</li>
<li>第三个Cache的$S = 1024/(32\times 32) = 1$,也就是说这是一个全相连的Cache,只有一个Set</li>
<li>知道了 S之后，我们可以根据 $S = 2^s$ 求出小s的值，小s的值即地址空间关于定位Set的位数</li>
<li>知道了B之后，我们可以根据 $B = 2^b$ 求出小b的值，小b的值即地址空间关于定位block偏移量的位数</li>
<li>知道了 s和 b之后，我们就可以知道 t的值，因为$t= m-s-b$ 其中m为地址的总位数，因为地址的总位数只由三个部分 t,s,b组成。</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">高速缓存</th>
<th>m(位数)</th>
<th>C(cache大小)</th>
<th>B(块大小)</th>
<th>E(cache line总数)</th>
<th>S(Set总数)</th>
<th>t(tag位数)</th>
<th>s(set位数)</th>
<th>b(block位数)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td>32</td>
<td>1024</td>
<td>4</td>
<td>1</td>
<td>256</td>
<td>22</td>
<td>8</td>
<td>2</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td>32</td>
<td>1024</td>
<td>8</td>
<td>4</td>
<td>32</td>
<td>24</td>
<td>5</td>
<td>3</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td>32</td>
<td>1024</td>
<td>32</td>
<td>32</td>
<td>1</td>
<td>27</td>
<td>0</td>
<td>5</td>
</tr>
</tbody>
</table>
</div>
<h3 id="读取Cache"><a href="#读取Cache" class="headerlink" title="读取Cache"></a>读取Cache</h3><p>示意图如下：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/22.png" style="zoom:120%;"></p>
<p>现在拿到了一个地址，机器不会直接去内存里去找地址，而是先会在Cache里面寻找，寻找流程如下：</p>
<p>一串地址可以分成三个部分：tag + set index + block offset(偏移量)</p>
<ol>
<li>首先利用set index位来定位这串地址在cache中位于哪一个sets，因为一共有$2^s$ 个sets，所以我们需要用 s位来当我们的索引</li>
<li>在定位到的set中，遍历所有的cache line,查找是否有和我们地址中 tag段相匹配的 cache line</li>
<li>如果找到了这个cache line，并且这个cache line是valid ，那么就说命中cache了</li>
<li>最后通过我们的offset定位到特定的数据</li>
</ol>
<p>定位 set $\Rightarrow $ 匹配tag $\Rightarrow$ 找到byte</p>
<h3 id="Direct-Mapped-Cache-E-1"><a href="#Direct-Mapped-Cache-E-1" class="headerlink" title="Direct Mapped Cache(E=1)"></a>Direct Mapped Cache(E=1)</h3><p>当E等于1的时候，每一个set只有1条cache line，这时这种cache也被称为是 Direct Mapped Cache。假设每个cache line 中的block size B 为8 bytes.那么这个cache的模型就如下图所示：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/23.png" style="zoom:100%;"></p>
<p>这种Cache的查找模式如下：</p>
<p>我们定位到set之后，我们去看tag是否与cache line中的tag相匹配，还要看这个cache line是否valid。同时满足两个条件才能说命中了。如果一开始tag就不匹配，那么这个cache line就是victim，我们要删除它并替换掉。</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/24.png" style="zoom:100%;"></p>
<p>下面是一个模拟的查找情景。我们有一个4位的地址，cache中有4个sets，每一个sets中有一个cache line，每个cache line的Block 空间为 2 bytes 。block里面存放的数据，就是<strong>查找地址指向的数据 </strong>。</p>
<p>查找地址左边一列是地址所代表的十进制数，查找不成功的时候，我们会将这个地址指向的数(前/后两个)放到blocks当中去。</p>
<p>那么我们查找的第一行是 $[0000_2]$ ,所以应该映射到第0个set，这时候cache是空的，所以是cold  miss，然后将这个数据0存储到第一行cache line当中，因为一个cache line可以存储两个bytes，所以我们在将0输入的时候同时也要将0后面的数字1也一并输入</p>
<p>第二行是$[0001_2]$ ，映射到第0个set，这时候cache line是有数据的，然后我们看tag也适合cache line相匹配的，于是这一个地址是 Hit</p>
<p>第三行是$[0111_2]$ ,定位到set3，显然这时候cache line是空的，那么就是 cold miss</p>
<p>第四行是$[1000_2]$, 定位到set0，tag不匹配，所以miss，并且将set0作为victim，将其替换成 $v=1,Tag=1,M[8-9]$</p>
<p>第五行是$[0000_2]$ ,定位到set0，tag又不匹配，所以miss,并且将set0作为 victim,将其替换成$v=1,Tag =0,M[0-1]$ </p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/25.png" style="zoom:100%;"></p>
<h3 id="E-Way-Set-Associative-Cache-组相连的cache"><a href="#E-Way-Set-Associative-Cache-组相连的cache" class="headerlink" title="E-Way Set Associative Cache 组相连的cache"></a>E-Way Set Associative Cache 组相连的cache</h3><p>顾名思义就是说一个set当中有多个cache line,这里取 E=2，每个cacheline当中有8个bytes</p>
<p>那么查找的过程如下：</p>
<p>首先还是找到对应的set</p>
<p>其次同时比较两个cache line 的tag，匹配到哪个进入那个cache，如果两个都不匹配，就是miss，这时候要在两个cache line里面选择一个杀掉</p>
<p>选择哪个cache line有多种方法，可以是随机的，也可以是least recent used(LRU)，即<strong>最近最少使用的cache line</strong>。但是最近最少使用实现起来没有那么简单，如何高效实现是一件比较复杂的事情。</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/26.png" style="zoom:100%;"></p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/27.png" style="zoom:100%;"></p>
<p>我们用一个例子来模拟E=2时，cache的查找情况:</p>
<ol>
<li>第一个 $[0000_2]$ 肯定是miss的，因为这时候cache里面还没有东西。因此，我们把set0中的cache line1存放 $[0000_2]$ 指向的数据$ M[0-1]$</li>
<li>第二行 $[0001_2]$ ，先匹配set0，然后匹配tag 00，匹配成功，于是 hit</li>
<li>第三行 $[0111_2]$ ，先匹配set1，然后匹配tag 01，发现cache line是空的，所以miss</li>
<li>第四行 $[1000_2]$ ，先匹配 set0，然后匹配tag10，发现cache line 是空的，所以miss</li>
<li>第五行 $[0000_2]$ ，先匹配 set0， 然后匹配set0，发现cache line 非空，所以hit</li>
</ol>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/29.png" style="zoom:100%;"></p>
<p>我们看到，读取同样的数据，因为我们的分配方式不同。两路的组相连cache 比 直接写入内存(E=1)少了一次 miss，多了一次hit，因此更加灵活。 </p>
<h4 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h4><p>一个地址，为什么要把tag设为前面几位，而把set设置在中间几位呢？</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/34.png" style="zoom:100%;"></p>
<p>如果把 前面几位设置成set的话，会导致以下这种结果。</p>
<p>set0会在最前面，set1第二……,每一个set中间又是连续的。这样我在一段地址里面进行读写循环，会导致conflict miss的几率大大提高，严重降低机器的运行效率</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/36.png" style="zoom:100%;"></p>
<p>而将Tag放在前面，将set放在中间，那么在一块连续的内存当中，相同set的地址不会挤在一起，从而降低了conflict miss，并提高了机器的运行效率</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/35.png" style="zoom:100%;"></p>
<p>现在我们来做一个小练习：假想一个高速缓存，用地址的高s 位做组索引，那么内存块连续的片(chunk)会被映射到同一个高速缓存组。</p>
<p>A. 每个这样的连续的数组片中有多少个块</p>
<p>B. 考虑下面的代码，它运行在一个高速缓存形式为$(S,E,B,m) = (512,1,32,32)$ 的系统上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">40960</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">4096</span>;i++)</span><br><span class="line">	sum+=<span class="built_in">array</span>[i];</span><br></pre></td></tr></table></figure>
<p>我们首先要知道如果用地址的高s位作为组索引，整个地址的三部分结构如下：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/3.jpg" style="zoom:100%;"></p>
<p>那么随着地址的渐渐增加，我们址答每个连续的数组片(chunk) 是由$2^t$个块组成的，这里t是标记位数。因此，数组头$2^t$ 个块都会映射到组0，而接下来$2^t$ 个块 会被映射到组1，以此类推</p>
<p>对于B小题来说，我们可以轻易地计算出s = 9,b = 5,因此t=32-14=18位，也就是说数组中头 $2^{18}$ 个块会被映射到组0。现在我们来计算数组需要占用多少块。我们的数组只由$(4096*4)/32 =512$ 个块组成，所以数组中所有的块都会被映射到组0。因此在任何时刻高速缓存至多只能保存一个数组块。很明显用高位做索引不能充分利用cache</p>
<h3 id="Cache-Write"><a href="#Cache-Write" class="headerlink" title="Cache Write"></a>Cache Write</h3><p>刚才我们讨论了 cache 的读取，现在我们来讨论一下cache的写入。</p>
<h4 id="Write-Hit"><a href="#Write-Hit" class="headerlink" title="Write-Hit"></a>Write-Hit</h4><p>如果我们要写入的数据在cache line中，这时候叫做cache hit 当我们这时候我们要做一个选择：</p>
<ol>
<li>通写 write-through(write immediately to memory)</li>
</ol>
<p>数据被立即写入磁盘，另外也会在缓存保存一份（用来提升读性能）。</p>
<ol>
<li>回写 write-back(defer write to memory until replacement of line)</li>
</ol>
<p>先写到cache line里, 用回写这种机制的时候，需要在cache line 中添加一个dirty bit(脏位)，这个dirty就代表这行cache line暂时还没有写到磁盘当中去，所以我们在找victim的时候，当我们发现这个cache line 是干净的，那么就直接将其替换即可，如果这行cache line是脏的， 在这时候就要将cache line中的数据存到内存中去。</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/32.png" style="zoom: 120%;"></p>
<p>这两者的差别也可以用图表示出来：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/31.png" style="zoom: 120%;"></p>
<p>回写的优点：</p>
<p>write-back：磁盘写性能高，每次只要写一行cache line 即可</p>
<p>回写的缺点：</p>
<p>wirite-back：系统崩溃或突然断电时，cache中的数据会丢失。有时候另外一个线程在读取数据的时候，可能会导致读取的和写入的不一致。</p>
<p>通写的优点：</p>
<p>读取和写入永远是一致的</p>
<p>通写的缺点:</p>
<p>开销很大</p>
<h4 id="Write-miss"><a href="#Write-miss" class="headerlink" title="Write-miss"></a>Write-miss</h4><p>如果我们要写入的数据没有存放在 cache line当中，那么这时候就是 Write-miss</p>
<p>比如说我在键盘中输入的数据，肯定是cache line中没有的，根据计算机硬件架构体系，这些数据首先会被存入到内存当中。</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/33.png" style="zoom: 120%;"></p>
<ol>
<li>写分配 Write-allocate (将要写入的数据从内存中取出放到cache当中并更新cache line)</li>
<li>非写分配 No-write-allocate (直接写到memory当中，不更新cache)</li>
</ol>
<p>目前的系统常用的机制是 ：write-back + write-allocate </p>
<h2 id="Cache-Performance-Metrics"><a href="#Cache-Performance-Metrics" class="headerlink" title="Cache Performance Metrics"></a>Cache Performance Metrics</h2><h4 id="Miss-rate"><a href="#Miss-rate" class="headerlink" title="Miss rate"></a>Miss rate</h4><p>Miss rate = 1- Hit rate ，因为一次访问存取要么miss 要么 hit</p>
<p>一般情况下， L1 cache 的miss rate是 3%-10%</p>
<p>L2 cache 的miss rate 一般在 1% 以下。</p>
<h4 id="Hit-Time"><a href="#Hit-Time" class="headerlink" title="Hit Time"></a>Hit Time</h4><p>Hit Time即当我命中cache 和从cache 中取到数所花费的时间，包括了查找set，匹配tag的时间</p>
<p>比较典型的例子：</p>
<p>对于L1 cache 来说，是4个运行周期</p>
<p>对于L2 cache 来说，是10个运行周期</p>
<h4 id="Miss-Penalty"><a href="#Miss-Penalty" class="headerlink" title="Miss Penalty"></a>Miss Penalty</h4><p>当我们出现 miss的情况，需要大概50-200个运行周期去从内存中取得我们的数据。</p>
<p>问题：为什么不用hit rate 而用 miss rate？</p>
<p>因为用户更关心的是平均访问的时间，对于hit rate来说，其值一般在90%以上，那么当hit rate 相差 1% 的时候，比如从97%提升到99%，看上去这两个数相差了2%，以为提升的幅度很小；而事实上miss rate却从3%降到了1%，机器的性能提升了不止一倍。假设一共有100次cache 读取，之前是3*200+97*4 而现在变成了 1*200+99*4，相差接近3倍，这是hit rate反映不出来的，而miss rate从3%降至1%则能体现出这种倍数差距。</p>
<p>miss rate在0%-10%所反映的和电脑实际性能之间基本上是呈线性关系的，但是显然 hit rate 并不是线性关系。</p>
<h3 id="The-memory-mountain-内存山"><a href="#The-memory-mountain-内存山" class="headerlink" title="The memory mountain 内存山"></a>The memory mountain 内存山</h3><p>内存山是整本书最有代表性的</p>
<ul>
<li>Read throughput 读的带宽<ul>
<li>也就是从内存中每秒能读取多少数据</li>
</ul>
</li>
<li>Memory mountain：我们运行一个能反应空间局部性和时间局部性对读取吞吐量变化的函数，然后将其可视化出来</li>
</ul>
<p>测试原理如下：</p>
<p>stride是步长，此外，我们还定义了2倍步长，3倍步长和4倍步长. 每一次我们加上1、2、3、4倍步长</p>
<p>data数组总的长度是elems，因为要保证加上4倍步长不能冲出数组，所以循环到 length-sx4这个长度为止</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> data[MAXELEMS]; <span class="comment">/* Global array to traverse */</span></span><br><span class="line"><span class="comment">/* test - Iterate over first "elems" elements of</span></span><br><span class="line"><span class="comment">* 			array "data" with stride of "stride“,</span></span><br><span class="line"><span class="comment">* 			using 4x4 loop unrolling.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> elems, <span class="keyword">int</span> stride)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> i, sx2=stride*<span class="number">2</span>, sx3=stride*<span class="number">3</span>, sx4=stride*<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">long</span> acc0 = <span class="number">0</span>, acc1 = <span class="number">0</span>, acc2 = <span class="number">0</span>, acc3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> length = elems, limit = length - sx4;</span><br><span class="line">    <span class="comment">/* Combine 4 elements at a time */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i += sx4) &#123;</span><br><span class="line">        acc0 = acc0 + data[i];</span><br><span class="line">        acc1 = acc1 + data[i+stride];</span><br><span class="line">        acc2 = acc2 + data[i+sx2];</span><br><span class="line">        acc3 = acc3 + data[i+sx3];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Finish any remaining elements */</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">  		acc0 = acc0 + data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((acc0 + acc1) + (acc2 + acc3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跑之前先要测试一遍，来把cache 填满，因为cache 之前是空的</p>
<p>acc1，2，3，4每次循环都会被调用，所以他们几乎不会出寄存器，data数组在内存当中，每次访问的是 data[i+xstride]，因为data数组是在内存中连续存储的，因此 stride越大，说明空间局部性越弱；stride越小，代表空间局部性越强</p>
<p> <img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/38.png" style="zoom: 120%;"></p>
<p>下面是根据吞吐量画出来的内存山：吞吐率越高，性能越好，吞吐率越低，性能越差。</p>
<p>当步长较小的时候，即使是好几倍的步长，也跳不出 L1 cache，因此吞吐量始终维持在一个很高的水平。(黄色部分)</p>
<p>但随着步长的增加，读取的时候会跳出L1 cache，进入L2 cache 或者 L3 cache，这时候吞吐量就下了一个很大的台阶。表现为橙色和紫色部分。</p>
<p>当步长达到一定程度的时候，我们发现吞吐率不会下降了，这是因为每次读取都是cache miss，必须回到内存中去读取，所以速度最慢。表现为深蓝色部分</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/37.png" style="zoom: 120%;">,</p>
<h3 id="Rearrangeing-loops-to-improve-spatial-locality-提升空间复杂度"><a href="#Rearrangeing-loops-to-improve-spatial-locality-提升空间复杂度" class="headerlink" title="Rearrangeing loops to improve spatial locality(提升空间复杂度)"></a>Rearrangeing loops to improve spatial locality(提升空间复杂度)</h3><p>我们用矩阵乘法来举例子，最基本的矩阵乘法的写法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ijk */</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">        sum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (k=<span class="number">0</span>; k&lt;n; k++)</span><br><span class="line">        sum += a[i][k] * b[k][j];</span><br><span class="line">        c[i][j] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据类型都是long ,也就是8个bytes，算法的复杂度为 $O(N^3)$ </p>
<p>现在我们来分析一下 矩阵乘法的miss rate</p>
<p>我们对矩阵和cache提出这些假设：</p>
<ul>
<li>Block size = 32B</li>
<li>矩阵的边长(N)非常大，1/N 接近于0 (如高分辨率的图片)</li>
<li>矩阵大到连cache都放不下一行数据</li>
</ul>
<p><strong>分析方法</strong></p>
<p>我们对最内层循环进行分析：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/39.png" style="zoom: 100%;"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">	sum += a[<span class="number">0</span>][i];</span><br></pre></td></tr></table></figure>
<p>我们知道，C语言中的数组是按照行存放的。每次循环访问的都是同一行的数字，因此这个循环对于a矩阵的局部性是非常好的。但是因为这个数组的边非常大，cache都放不下，因此还是存在一定的 miss rate。这个miss rate 可以由 $\frac{sizeof(a<em>{ij})}{B}$ 来计算(B指Block的大小)，也就是说每访问$ B/ sizeof(a</em>{ij})$ 个数据后，会出现 一次miss。</p>
<p>但是如果稍微改一下算法，虽然不改变最终结果和算法的复杂度，但是也会让局部性变得很差</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	sum += a[i][<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>比如改成上面这样子，每次跳一行来读取一个数字，因为cache 放不下一行，所以必然每次都会出现miss，因此这个算法的miss rate = 1，局部性非常差</p>
<h4 id="三种不同的矩阵乘法的写法"><a href="#三种不同的矩阵乘法的写法" class="headerlink" title="三种不同的矩阵乘法的写法"></a>三种不同的矩阵乘法的写法</h4><p><strong>Matrix Multiplication (ijk)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ijk */</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">        sum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (k=<span class="number">0</span>; k&lt;n; k++)</span><br><span class="line">            sum += a[i][k] * b[k][j];</span><br><span class="line">        c[i][j] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/43.png" style="zoom: 100%;"></p>
<p>Block = 32B, 数据类型为long  </p>
<p>这个miss rate可以这样来计算：</p>
<p>对于A矩阵：每次访问四个数据出现一次miss ，miss rate = 0.25</p>
<p>对于B矩阵：每次都是跳了一行，因此 miss rate = 1</p>
<p>对于C矩阵：只要求在指定位置写入即可，miss rate = 0</p>
<p>avg misses/iter = 1.25</p>
<p><strong>Matrix Multiplication (kij)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (k=<span class="number">0</span>; k&lt;n; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    r = a[i][k];</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">    	c[i][j] += r * b[k][j];	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/42.png" style="zoom: 100%;"></p>
<p>这个矩阵乘法比较奇怪</p>
<p>在最里面的循环，a矩阵并不要进行操作，因此其miss rate = 0</p>
<p>对于B矩阵和C矩阵移动的是j，因此他们的miss rate  = 0.25</p>
<p>avg misses/iter = 0.5</p>
<p><strong>Matrix Multiplication (jki)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* jki */</span></span><br><span class="line"><span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (k=<span class="number">0</span>; k&lt;n; k++) &#123;</span><br><span class="line">    r = b[k][j];</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    	c[i][j] += a[i][k] * r;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/41.png" style="zoom: 100%;"></p>
<p>这种算法的局部性最差，A矩阵和C矩阵都是跳行访问的，miss rate = 1.0,而B是固定的，miss rate =0</p>
<p>avg misses/iter = 2.0</p>
<p>从实验数据上也可以看到这个差别：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/40.png" style="zoom: 100%;"></p>
<h4 id="Using-Blocking-to-improve-temporal-locality-时间复杂度"><a href="#Using-Blocking-to-improve-temporal-locality-时间复杂度" class="headerlink" title="Using Blocking to improve temporal locality(时间复杂度)"></a>Using Blocking to improve temporal locality(时间复杂度)</h4><p>我们还是拿矩阵乘法来举例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c = (<span class="keyword">double</span> *) <span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">double</span>), n*n);</span><br><span class="line"><span class="comment">/* Multiply n x n matrices a and b */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmm</span><span class="params">(<span class="keyword">double</span> *a, <span class="keyword">double</span> *b, <span class="keyword">double</span> *c, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">            	c[i*n + j] += a[i*n + k] * b[k*n + j];	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/44.png" style="zoom: 100%;"></p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/45.png" style="zoom: 100%;"></p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/46.png" style="zoom: 100%;"></p>
<p><strong>Blocking Summary</strong></p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/47.png" style="zoom: 100%;"></p>
<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>下列三个函数，以不同的空间局部性成都，执行相同的操作，请对这些空间函数就空间局部性进行排序。并解释如何得到排序结果</p>
<p>a) structs 数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> N 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> vel[<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">int</span> acc[<span class="number">3</span>];</span><br><span class="line">&#125;<span class="built_in">point</span>;</span><br><span class="line"><span class="built_in">point</span> p[N];</span><br></pre></td></tr></table></figure>
<p>b) clear1 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear1</span><span class="params">(<span class="built_in">point</span> *p,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i ,j ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">        	p[i].vel[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>；j &lt; <span class="number">3</span>j j++)</span><br><span class="line">        	p[i].acc[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c) clear2 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear2</span><span class="params">(<span class="built_in">point</span> *p, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i ,j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">        p[i].vel[j] = <span class="number">0</span>;</span><br><span class="line">        p[i].acc[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>d) clear 3数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    	p[i].vel[j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">   		p[i].acc[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道判断空间局部性的好坏，就要看步长、扫描顺序。首先我们画出struct的结构如下：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/2.jpg" style="zoom: 100%;"></p>
<p>我们先来看看clear1，它以步长为1的引用模式访问vel数组和acc数组，因此明显地具有最好的空间局部性。</p>
<p>clear2和clear1一样，是依次扫描N个结构中的一个，但是在每个结构当中步长并不为1，比如当j = 0的时候，vel[j] 偏移量为0，而acc[j] 的偏移量为12。所以说clear2的空间局部性比clear1要更差一些。</p>
<p>函数clear3不仅在每个结构当中跳来跳去，而且还要从结构跳到结构，所以clear3的空间局部性比clear2和clear1都要差</p>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>在信号处理和科学计算的应用中，转置矩阵的行和列是一个很重要的问题。从局部性的角度来看，它也很有趣，因为它的引用模式既是以行为主 (wise)的，也是以列为主(column-wise)的。例如，考虑下面的转置函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transpose1</span><span class="params">(<span class="built_in">array</span> dst, <span class="built_in">array</span> src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">        	dst[j][i] = src[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设在一台具有如下属性的机器上运行这段代码</p>
<ul>
<li>sizeof(int) =4</li>
<li>src数组从地址0开始，dst数组从地址16(十进制)开始</li>
<li>只有一个L1告诉数据缓存，他是直接映射的、直写的和写分配的。块的大小为8个字节</li>
<li>这个高速缓存总的大小为16个数据字节(16 data bytes)，一开始是空的</li>
<li>对 src和dst数组的访问分别是读和写不命中的唯一来源</li>
</ul>
<p>A.对每个row和col,指明对$src[row][col]$和 $dst[row][col]$ 的访问时命中还是不命中。例如，读$src[0][0]$ 会不命中，写$dst[0][0]$ 也不会命中</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/4.jpg" style="zoom: 100%;"></p>
<p>首先我们要画出src和dst的图像，如上图所示。这里注意，每个高速缓存行只包含数组的一个行，杠苏缓存正好只能够保存一个数组。而且对于所有的i，src和dst的行i是映射到同一个高速缓存行的。但是我们发现Cache是肯定不够大的，所以对一个数组的引用总是要驱逐另一个数组的有用的行。</p>
<p>比如说对 $dst[0][0]$ 写会驱逐当我们读 $src[0][0]$ 时加载进来的那一行。所以当我们接下来读取$src[0][1]$ 时，会有一个不命中。</p>
<p>B. 对于一个大小为32数据字节的Cache重复这个练习</p>
<p>当高速缓存为32字节的时候，它足够大，并能容纳这两个数组。因此，所有的不命中都是开始时的冷不命中。</p>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>最近一个很成功的游戏SimAquarium 的核心就是一个紧密循环（tight loop), 它计算256 个海藻(algae)的平均位置。在一台具有块大小为16 字节(B=16) .整个大小为1024 字节的直接映射数据缓存的机器上测量它的高速缓存性能。定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct algae_position &#123;</span><br><span class="line">	int x;</span><br><span class="line">	int y;</span><br><span class="line">&#125;</span><br><span class="line">struct algae.position grid[16][16];</span><br><span class="line">int total_x &#x3D; 0, totally &#x3D; 0;</span><br><span class="line">int i, j;</span><br></pre></td></tr></table></figure>
<p>还有如下假设：</p>
<ul>
<li>sizeof(int) = 4</li>
<li>grid 从内存地址0开始</li>
<li>这个高速缓存开始时是空的</li>
<li>唯一的内存访问时对数组grid的元素的访问。变量 i，j,total_x和total_y 存放在寄存器当中</li>
</ul>
<p>确定下面代码的高速缓存性能：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">31</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">    	total_x += grid[i][j].x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">31</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">    	total_y += grid[i][j].y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们要画出这struct的结构和整一个struct数组的样子</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/5.jpg" style="zoom: 100%;"></p>
<p>每个16字节的高速缓存包含着两个连续的algae_position 结构。每个循环按照内存的访问顺序访问这些结构，每次读一个整数元素。所以每个循环的模式就是不命中、命中、不命中、命中，依次类推。这里我们不必实际列举出读和不命中的总数就能预测出不命中率为50%</p>
<p>A. 读总数是多少？</p>
<p>读的总数为 16*16 = 256</p>
<p>B. 缓存不命中的读总数是多少？</p>
<p>缓存不命中的总数是256</p>
<p>C. 不命中率是多少？ 50%</p>
<h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>给定上面的四条假设</p>
<ul>
<li>sizeof(int) = 4</li>
<li>grid 从内存地址0开始</li>
<li>这个高速缓存开始时是空的</li>
<li>唯一的内存访问时对数组grid的元素的访问。变量 i，j,total_x和total_y 存放在寄存器当中</li>
</ul>
<p>确定下列代码的高速缓存性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line">        total_x += grid[j][i].x;</span><br><span class="line">        total_y += grid[j][i].y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A. 读总数是多少？512<br>B. 高速缓存不命中的读总数是多少？ 256</p>
<p>如图所示：</p>
<p>C. 不命中率是多少？50%<br>D. 如果高速缓存有两倍大，那么不命中率会是多少呢？如果高速缓存有现在的两倍大，那么它能保存整个grid数组。所有的不命中都会是开始时的冷不命中，而不命中的概率会降低到25%</p>
<p>确定下面代码的高速缓存性能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line">        total_x += grid[i][j].x;</span><br><span class="line">        total_y += grid[i][j].y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个循环有很好的步长为1的引用模式，因此所有的不命中都是最开始时的冷不命中。</p>
<p>A. 读总数是多少？512<br>B. 高速缓存不命中的读总数是多少？ 128</p>
<p>C. 不命中率是多少？ 25%<br>D.如果高速缓存有两倍大，那么不命中率会是多少呢？无论高速缓存的大小增加多少，还是会冷命中，因此不会改变不命中率，因为冷不命中时不可能避免的。</p>
<h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>假设我们再下列条件下执行代码中的三个求和函数</p>
<ul>
<li>sizeof(int) = 4</li>
<li>机器有4KB直接映射的高速缓存，块大小为16字节</li>
<li>在两个循环中，代码只对数据进行内存访问。循环索引和值sum都存放在寄存器当中</li>
<li>数组a从内存地址 0x8000000处开始存储 </li>
</ul>
<p>对于N=64和N=60 这两种情况，在表中填写他们大概的高速缓存不命中率</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/50.png" style="zoom: 100%;"></p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/51.png" style="zoom: 100%;"></p>
<p>当N=64的时候首先我们要画出cache的草图和数组的草图</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/7.jpg" style="zoom: 100%;"></p>
<p> 因为数组的大小为cache的4倍，而cache又是直接映射的缓存，所以每次存储255个block就要从头开始，一共四次。所以对于前1/4个数组，出现的是cold miss，而且miss一次会hit3次。后面3/4个数组出现的是conflict miss，但也是miss一次hit3次。因此 miss rate = 25%</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/52.png" style="zoom: 100%;"></p>
<p>对于 sumB，它的局部性是比较差的，read cache order如下：</p>
<p>我们是按照 $a[0][0],a[1][0],a[2][0]$这样的顺序访问的，每次跳一行，一行64*4=256个字节，也就是会跳16个block，因此一开始的时候我们是读取第 $0,16,32…240$ 个cache的，但是这样还只到$a[15][0]$ 当读取$a[16][0]$ 的时候又会返回到第0个cache</p>
<p>0,16,32…240(4times);1,17,33,…241,(4 times)…;15,31,47,…255 (4 times)</p>
<p>对于 sumC</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i+=<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j+=<span class="number">2</span>)</span><br><span class="line">    sum += (a[j][i] + a[j][i+<span class="number">1</span>] + a[j+<span class="number">1</span>][i] + a[j+<span class="number">1</span>][i+<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<p>如果读取了$a[j][i],a[j+1][i]$ 那么 $a[j][i+1],a[j+1][i+1]$肯定是hit的</p>
<p>因此我们可以简化成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i+=<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j+=<span class="number">2</span>)</span><br><span class="line">    sum += (a[j][i] + a[j+<span class="number">1</span>][i]);</span><br></pre></td></tr></table></figure>
<p>上面这个函数和下面这个函数是等价的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i+=<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">    sum += a[j][i];</span><br></pre></td></tr></table></figure>
<p>这和sumB类似，但是因为$i+=2$,所以read cache order只做了2次循环</p>
<p>因此对于这个函数，missrate = 50%，但同时，对于原函数miss count = $64/2<em>64</em>50\% $ = 64*64/4</p>
<p>所以missrate仍然是25%</p>
<p>如果 N=60 的话，那么 对于 sumA和sumC都和 N=64是一样的，为25%</p>
<p>let’s see first inner loop $a[0][0] -&gt; a[59][0]$</p>
<p>read memory address order:</p>
<p>0, 60*4, 60*4*2, …. 60*4*59</p>
<p>read cache order:</p>
<p>0, 15, 30, …., 225, (17 numbers) 255, 14, 29, ….., 224, (17 numbers) 254, 13, 28, ….., 223, (17 numbers) 253, 12, 27, 42, 57, 72, 87, 102, 117 (9 numbers)</p>
<p>all read miss and store into different blocks</p>
<p>next 3 loops: $a[0][1] -&gt; a[59][1], a[0][2] -&gt; a[59][2], a[0][3] -&gt; a[59][3]$</p>
<p>all hit</p>
<p>althrough N is smaller and not power of 2, miss rate is still 25%</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">人工神经网络</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-07 22:24:57" itemprop="dateCreated datePublished" datetime="2020-11-07T22:24:57+08:00">2020-11-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-12-02 22:46:48" itemprop="dateModified" datetime="2021-12-02T22:46:48+08:00">2021-12-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="人工神经网络"><a href="#人工神经网络" class="headerlink" title="人工神经网络"></a>人工神经网络</h1><h2 id="感性认识"><a href="#感性认识" class="headerlink" title="感性认识"></a>感性认识</h2><h3 id="神经元"><a href="#神经元" class="headerlink" title="神经元"></a>神经元</h3><p>首先我们来讲讲 Neuron 神经元。他是组成神经网络的基本结构。</p>
<p>我们都知道生物上的神经元，即神经细胞是长什么样的。深度学习的目标就是模拟大脑的运行，但是我们怎么用机器来模拟神经元呢? </p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/1.png" style="zoom:150%;"></p>
<p>这是一个神经元的模型，树突和轴突就是用来传递神经信号的。(高中生物？？？？)</p>
<p>我们可以用一个简图来模拟上述操作：</p>
<p>第一层黄色的神经元是信号输入层 。在人类的大脑中，输入层就是我们的各种感觉：视觉、听觉、触觉等，而大脑中的神经元则是用来处理这些器官采集到的电信号的。对于机器，输入一些数据(自变量)，通过神经元产生一个输出值</p>
<p>第二层绿色就是神经元，扮演着我们大脑的角色。我们也叫其隐藏层</p>
<p>第三层是红色的输出值。神经元处理好输入数据后传出一个输出值，并更进一步地传递给下一层</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/2.png" style="zoom:100%;"></p>
<p>在输入层的内部结构是这样的：</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/3.png" style="zoom:100%;"></p>
<p>这些自变量都是指每一次观测得到的值，我们可以将其想象成是数据表里的一行数据。我们将用这些数据来训练我们的神经网络模型。但是需要注意的是，在应用他们之前，我们需要将它们标准化(stand)——即让他们平均值为0，方差为1 / 归一化(normalize)—-即让数据分布在0-1之间的值。</p>
<p>输出值可以是以下几种类型：可以是连续的值，也可以是二进制数，还可以是一个分类变量(如果是分类变量，那么就代表有多个输出值)</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/4.png" style="zoom:100%;"></p>
<p>接下来我们要讲的是突触(synapses) ，每一个突触都被赋予了一个权重。权重对神经网络非常重要，神经网络就是通过这些权重来学习的。通过计算和改变权重，神经网络决定在每一次计算中对于某个神经元的哪一个信号比较重要、哪个比较不重要，以及哪个信号可以传递下去、那个信号应该被屏蔽等等</p>
<p>所以权重非常关键，当我们在训练神经网络的时候基本上就是在调节权重，这也是为什么我们要学梯度下降和反向传播算法的原因了</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/5.png" style="zoom:100%;"></p>
<p>最后我们来讲讲神经元，神经元里到底发生了什么？</p>
<p>第一步，神经元会将  输入值* 权重 求和</p>
<p>$\sum_{i=1}^{m}w_ix_i$  </p>
<p>第二步，运用激活函数 $\phi(\sum_{i=1}^m w_ix_i)$ ,这样神经元就可以知道它是否需要让一个信号通过</p>
<p>第三步，如果神经元决定通过这个信号，那么它就会将其输出给下一个神经元</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/6.png" style="zoom:100%;"></p>
<p>神经元综合的输入信号和偏置（符号为 -1~1）相加之后产生当前<strong>神经元最终的处理信号</strong>net，该信号称为<strong>净激活或净激励</strong>（net activation），激活信号作为上图中圆圈的右半部分f（<em>）函数的输入，即f(net)； f称为<strong>激活函数或激励函数</strong>（Activation Function），<em>*激活函数的主要作用是加入非线性因素，解决线性模型的表达、分类能力不足的问题</em></em>。上图中y是当前神经元的输出。</p>
<h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>激活函数有很多很多种，我们这里讲四种比较常用的激活函数</p>
<h4 id="Threshold-Function-阈值函数"><a href="#Threshold-Function-阈值函数" class="headerlink" title="Threshold Function 阈值函数"></a>Threshold Function 阈值函数</h4><p>阈值函数很简单，y轴只有0或者1。如果输入阈值函数的值权重和小于0的话，阈值函数输出0；如果大于0，则输出1.</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/7.png" style="zoom:100%;"></p>
<h4 id="Sigmoid-Function"><a href="#Sigmoid-Function" class="headerlink" title="Sigmoid Function"></a>Sigmoid Function</h4><p>这个函数的优点是一条光滑的曲线，当输入值小于0的时候，y接近0；当输入值大于0的时候，y接近1</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/8.png" style="zoom:100%;"></p>
<h4 id="Rectifier-function-ReLU"><a href="#Rectifier-function-ReLU" class="headerlink" title="Rectifier function(ReLU)"></a>Rectifier function(ReLU)</h4><p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/9.png" style="zoom:100%;"></p>
<p>Rectifier function 是近来比较流行的激活函数，当输入信号小于0时，输出为0；当输入信号大于0时，输出等于输入。</p>
<p>ReLU的优点：</p>
<ol>
<li><p>ReLU是部分线性的，并且不会出现过饱和的现象，使用ReLU得到的随机梯度下降法（SGD）的收敛速度比Sigmodi和tanh都快。</p>
</li>
<li><p>ReLU只需要一个阈值就可以得到激活值，不需要像Sigmoid一样需要复杂的指数运算。</p>
</li>
</ol>
<p>ReLU的缺点：</p>
<p>在训练的过程中，ReLU神经元比价脆弱容易失去作用。例如当ReLU神经元接收到一个非常大的的梯度数据流之后，这个神经元有可能再也不会对任何输入的数据有反映了，所以在训练的时候要设置一个较小的合适的学习率参数。</p>
<h4 id="tanh"><a href="#tanh" class="headerlink" title="tanh"></a>tanh</h4><p>tanh是Sigmoid函数的变形，tanh的均值是0，在实际应用中有比Sigmoid更好的效果。</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/10.png" style="zoom:100%;"></p>
<p>拓展资料： <a href="http://jmlr.org/proceedings/papers/v15/glorot11a/glorot11a.pdf" target="_blank" rel="noopener">http://jmlr.org/proceedings/papers/v15/glorot11a/glorot11a.pdf</a></p>
<p>现在我们来做两个练习：</p>
<p>假设我们的输出值只为0或者1，那么我们应该怎么选择激活函数？</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/11.png" style="zoom:100%;"></p>
<p>我们可以选择两种，第一种就是Threshold 激活函数，因为y轴只能是0或者1；第二种则是sigmoid函数,用它来表示取到0或者1的概率。</p>
<p>第二个练习是一个应用，假设我们的神经网络长这样:</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/12.png" style="zoom:100%;"></p>
<p>一般，我们先用整流函数(ReLU) 再使用 sigmoid函数</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/13.png" style="zoom:100%;"></p>
<p>即在隐藏层使用ReLU，在输出层使用Sigmoid函数</p>
<h3 id="神经网络如何工作"><a href="#神经网络如何工作" class="headerlink" title="神经网络如何工作"></a>神经网络如何工作</h3><p>现在我们来看一个实例，看看可以如何应用神经网络来解决一些实际的问题</p>
<p>我们将用房地产评估的例子来作为介绍。看看怎么把房地产的参数引入神经网络并预测房地产的价值</p>
<p>我们暂时不讲怎么训练这个神经网络，假设它已经被训练好了，仅仅来看看神经网络是怎么来预测的。</p>
<p>我们假设，一个房地产的价格和四个参数有关：</p>
<ul>
<li>Area面积</li>
<li>Bedrooms 卧室数目</li>
<li>Distance to city 离市中心多远</li>
<li>Age 房龄</li>
</ul>
<p>这四个变量将是我们的输入值，输出值是房子的预估价值。</p>
<p>如果没有隐藏层，那么整个模型长这样：可以简单地给它们一个权重，然后price直接等于权重和</p>
<p>这个模型也是大多数机器学习中回归算法的模型</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/14.png" style="zoom:100%;"></p>
<p>这就是神经网络的强大之处，即使没有隐藏层，也可以进行一些预测。隐藏层让整个模型变得更加灵活和强大。能提高预测的准确率。</p>
<p>现在我们加入隐藏层：</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/1.jpg" style="zoom:100%;"></p>
<p>现在假设四个参数都和隐藏层的第一个神经元有突触，这些突触上有不同的权重。</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/2.jpg" style="zoom:100%;"></p>
<p>我们看到对于第一个神经元，它只关注 Area和Distance to City，也就是说它认为这两个参数对房价的影响比较大。这个神经元的职能就是来寻找离城市不远同时面积又大的房产。当这两个参数达到一定水平的时候，激活函数就会激活这个神经元并输出信号并最终影响到输出层的价格。因此，这个神经元并不在乎卧室的数目和房产的年龄。这也是为什么神经网络如此强大的原因：我们拥有很多这样的神经元，每个神经元各司其职——我们也将会看看其他的神经元如何操作</p>
<p>我们来看下一个位于中间位置的神经元：中间这个神经元的输入为三个数据：住房面积，房间个数和房龄。这可能是因为在对数据集进行训练时，神经网络发现这三个数据之间有特定的联系：比如在某一个地区一个家庭拥有很多孩子，常常在找房龄较小、卧室比较多、住房面积又比较大的。所以这个神经元可能就认为一个住房面积比较大的，卧室数目大于3个的，房子又比较新的房型在这个房地产市场非常吃香，于是满足条件的就会通过激活函数把神经元激活。</p>
<p> <img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/3.jpg" style="zoom:100%;"></p>
<p>还有可能是这样一个情况：一个神经元仅仅接收来自一个输入层的数据：Age<br>这可能是因为这个神经元认为房龄的长短对房价的影响比较重要 。比如说有些老房子比较破，房价会低；新房子房价会高。但是有些房子(如上海花园洋房) 是历史遗留财产，价格可能又会更高一些。</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/4.jpg" style="zoom:100%;"></p>
<p>这就是神经元的例子，他会发现我们用肉眼很难发现的规律。 隐藏层提高了整个神经网络模型的灵活性，能找到那些特别的特征并将它们结合起来考虑。每一个神经元都不能完整预测出房价，但把它们放在一起，可能就会得到意想不到的结果。</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/5.jpg" style="zoom:100%;"></p>
<h3 id="神经网络如何学习"><a href="#神经网络如何学习" class="headerlink" title="神经网络如何学习"></a>神经网络如何学习</h3><p>这里有一个基本的神经网络模型，隐藏层只有一个神经元。它被称为：“单层前馈神经网络”，也叫感知机“perception”。这个模型的输出值是 $\hat y$ ，但这并不是真实值，真实值是y，两者之间存在一个较大的误差。这个误差我们用一个 cost function(损失函数) 来衡量。损失函数有很多种，最常用的就是 $C= \frac{1}{2}(\hat y - y)^2$  .在图像上用柱形图表示如下:</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/15.png" style="zoom:100%;"></p>
<p>我们的目标就是让损失函数的值尽可能地小，因为其值越小， $\hat y$ 与 $y$ 就越接近，神经网络的学习效果也就越好。所以机器在比较了y与 $\hat y$ 之后，将其差值反馈给神经网络(紫色箭头)，然后神经网络会通过这个信息来更新权重以减少两者之间的差值。所以在神经网络中我们唯一能<strong>控制</strong> 的就是<strong>各个突触的权重</strong> </p>
<p>我们多次输入同一行数据，让权重不断调节，努力减小损失函数的值。</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/16.png" style="zoom:100%;"></p>
<p>但事实上，一个数据集不可能只有一行数据，完整的数据集如下：</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/17.png" style="zoom:100%;"></p>
<p>我们要把这些数据都输入到神经网络当中，并得到 $\hat y$ 。随后，我们再将真实的数据用绿色柱体渲染上去。如下图：</p>
<p>(这里实际上只有一个神经元，只是重复了8次)</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/18.png" style="zoom:100%;"></p>
<p>然后我们计算损失函数 $C = \sum \frac{1}{2}(\hat y-y)^2$  的值，并将其反馈给神经元来让其更新权重。</p>
<p>我们的目标是最小化损失函数，一旦我们找到了损失函数的最小值，就说明整个模型已经训练完毕</p>
<p>拓展资料：</p>
<p><a href="https://stats.stackexchange.com/questions/154879/a-list-of-cost-functions-used-in-neural-networks-alongside-applications" target="_blank" rel="noopener">https://stats.stackexchange.com/questions/154879/a-list-of-cost-functions-used-in-neural-networks-alongside-applications</a></p>
<h3 id="梯度下降和随机梯度下降"><a href="#梯度下降和随机梯度下降" class="headerlink" title="梯度下降和随机梯度下降"></a>梯度下降和随机梯度下降</h3><p>我们现在来看，这些权重是怎么被调整的。</p>
<p>要降低代价函数的值，最笨的方法就是取很多不同的权重，然后比较哪些权重组合比较好。 但是随着神经元的增加、突触会变得很多，我们就会被迫遇到 维数困难(Curse of Dimensionality) .比如说我们有25个权重，对每个权重我们可以取1000个不同的值，那么$1000^{25}$ 就等于 $10^{75}$   次计算，这是一个天文数字</p>
<p>所以我们需要用到梯度下降算法，简单的来说我们就要对损失函数求导并判断其在递增还是递减，一直找到损失函数最低点处。</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/20.png" style="zoom:100%;"></p>
<p>对于一个2维空间，我们可以这样来画</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/21.png" style="zoom:100%;"></p>
<p>同样，对于3维空间，如下所示：</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/22.png" style="zoom:100%;"></p>
<p>那么随机梯度下降是什么呢？</p>
<p>比如说我们现在的代价函数长这样：</p>
<p>因为我们可以选择不同类型的代价函数，所以长成这样也是有可能的。</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/23.png" style="zoom:100%;"></p>
<p>那么我们根据正常的梯度下降算法，很可能只找到了一个极小值，并没有找到整个函数的最小值。于是我们需要用随机梯度下降的方法来寻找最低点。对于批量梯度下降，我们将所有行的数据输入，才反馈一个值并更新我们的权重；但是对于随机梯度下降，我们则需要在每次输入一行的时候就反馈一个值并调整权重。</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/24.png" style="zoom:100%;"></p>
<p>这样就可以帮助我们避免选择极小值。因为随机梯度下降它一次只对一行数据进行操作，具有更大幅度的波动，因此也更容易找到最小值。</p>
<p>具体设计数学的算法逻辑我将在吴恩达的机器学习课程笔记中记载，在这里就不再细说。</p>
<p>拓展文章：<a href="http://iamtrask.github.io/2015/07/27/python-network-part2/" target="_blank" rel="noopener">http://iamtrask.github.io/2015/07/27/python-network-part2/</a></p>
<p><a href="http://neuralnetworksanddeeplearning.com/chap2.html" target="_blank" rel="noopener">http://neuralnetworksanddeeplearning.com/chap2.html</a></p>
<h3 id="反向传播算法"><a href="#反向传播算法" class="headerlink" title="反向传播算法"></a>反向传播算法</h3><p>我们之前说过 Forward Propagation(前向传播)，也就是信息进入输入层后，向前方传播以计算出 $\hat y$ </p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/25.png" style="zoom:100%;"></p>
<p>那么当计算出代价函数之后，这个代价就会反向传播(Backpropagation) ,这样可以让我们来调整权重。</p>
<p>在这篇文章中，介绍了反向传播算法中的数学原理：<a href="http://neuralnetworksanddeeplearning.com/chap2.html" target="_blank" rel="noopener">http://neuralnetworksanddeeplearning.com/chap2.html</a></p>
<p><strong>用随机梯度下降方法来训练人工神经网络的步骤：</strong></p>
<ol>
<li><p>随机初始化我们的权重，让他们接近于0但是不等于0</p>
</li>
<li><p>输入我们数据集的第一行数据到输入层，让每个特征都对应一个输入节点。</p>
</li>
<li><p>前向传播，从左到右,一直得到 $\hat y$</p>
</li>
<li><p>比较真实值和预测值，计算误差</p>
</li>
<li><p>使用反向传播算法，将误差传播回去。并对每一个权重进行调整</p>
</li>
<li><p>重复步骤一到五并对每行数据都更新我们的权重(强化学习)</p>
</li>
<li><p>当整个训练集数据都已经训练完毕，那么我们称这个神经网络为 epoch(一代)，我们要进行多代的训练，才能让神经网络模型将代价函数降到最小</p>
</li>
</ol>
<h2 id="项目实践"><a href="#项目实践" class="headerlink" title="项目实践"></a>项目实践</h2><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>首先我们导入一些包,我们需要用到numpy,tensorflow,datatime 和 fashion_mnist数据集。这个数据集，来自于kaggle ,网站是： <a href="https://www.kaggle.com/zalando-research/fashionmnist" target="_blank" rel="noopener">https://www.kaggle.com/zalando-research/fashionmnist</a></p>
<p>这个数据集比较大，有七万多幅大小为28*28 的图像，每一张图像中的物品属于一类衣物，一共有10类衣物。分别是：</p>
<ul>
<li>0 T-shirt/top</li>
<li>1 Trouser</li>
<li>2 Pullover 套头衫</li>
<li>3 Dress</li>
<li>4 Coat</li>
<li>5 Sandal 凉鞋</li>
<li>6 Shirt</li>
<li>7 Sneaker</li>
<li>8 Bag</li>
<li>9 Ankle boot</li>
</ul>
<p>我们要做的就是用60000幅图像来训练我们的神经网络并用剩下10000幅当测试集交给神经网络去分类。</p>
<p>最后我们要做的是对测试集的测试结果进行一个评估</p>
<p>因为我们现在构建的是人工神经网络而不是卷积神经网络，神经网络的输入是一维的向量，但是这里我们要处理的对象是28*28的像素。因此我们会修改形状(reshape)，来讲28*28 的二维图像变形称为一个包括784个元素的一维输入向量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.datasets <span class="keyword">import</span> fashion_mnist</span><br></pre></td></tr></table></figure>
<h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><p>接下来，我们要把数据集设置成能被神经网络接受的格式，一共有4步：</p>
<h4 id="loading-the-dataset"><a href="#loading-the-dataset" class="headerlink" title="loading the dataset"></a>loading the dataset</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(X_train,y_train),(X_test,y_test) = fashion_mnist.load_data()</span><br></pre></td></tr></table></figure>
<h4 id="Normalizing-the-images"><a href="#Normalizing-the-images" class="headerlink" title="Normalizing the images"></a>Normalizing the images</h4><p>第二步，我们将图像归一化。我们将训练集和测试集中图像的每个像素除以最大像素数(255)。</p>
<p>这样，每个像素都将在[0,1]范围内。通过对图像进行归一化，我们可以确保我们的模型(ANN)运行得更快。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X_train = X_train / <span class="number">255.0</span></span><br><span class="line">X_test = X_test / <span class="number">255.0</span></span><br></pre></td></tr></table></figure>
<h4 id="Reshaping-the-dataset"><a href="#Reshaping-the-dataset" class="headerlink" title="Reshaping the dataset"></a>Reshaping the dataset</h4><p>第三步，我们将图像变成一维向量的格式以便神经网络能够接受。因为图像的大小为28*28 所以我我们这样来写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X_train = X_train.reshape(<span class="number">-1</span>, <span class="number">28</span>*<span class="number">28</span>)</span><br></pre></td></tr></table></figure>
<p>其中，-1 代表了对所有元素都执行这个操作。</p>
<p>修改完后，X_train的形状从(60000,28,28) 变成了(60000,784) </p>
<h3 id="构建人工神经网络"><a href="#构建人工神经网络" class="headerlink" title="构建人工神经网络"></a>构建人工神经网络</h3><p>现在我们用Tensorflow来构建人工神经网络</p>
<h4 id="Defining-the-model"><a href="#Defining-the-model" class="headerlink" title="Defining the model"></a>Defining the model</h4><p>我们先定义一个 Sequential 模型.(序贯模型)序贯模型是函数式模型的简略版，为最简单的线性、从头到尾的结构顺序，不分叉，是多个网络层的线性堆叠。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = tf.keras.models.Sequential()</span><br></pre></td></tr></table></figure>
<p>接下来我们来一个一个添加神经网络的不同层</p>
<h4 id="Adding-a-first-fully-connected-hidden-layer"><a href="#Adding-a-first-fully-connected-hidden-layer" class="headerlink" title="Adding a first fully-connected hidden layer"></a>Adding a first fully-connected hidden layer</h4><p>第一个是全连接层。全连接层会拥有不同的超参数。因为在 神经网络中，除了寻找最优的权重和偏置等参数，设定合适的超参数也同样重要。比如各层<strong>神经元的数量</strong>、<strong>batch_size的取值</strong>、<strong>参数更新时的学习率</strong>、<strong>权值衰减系数</strong>或学习的epoch等。超参数寻找过程一般会伴随很多试错，所以用尽可能高效的方法找到超参数非常重要。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">model.add(tf.keras.layers.Dense(units=<span class="number">128</span>,</span><br><span class="line">								activation=<span class="string">'relu'</span>, </span><br><span class="line">                                input_shape=(<span class="number">784</span>, )</span><br><span class="line">                               )</span><br><span class="line">         )</span><br></pre></td></tr></table></figure>
<p>我们用 <code>model.add()</code> 的方法来给我们的模型添加一个新的层。这里，我们添加的 fully-connected layer(全连接层)是一个Dense对象，在Dense类中我们又定义了三个参数：units即神经元的个数，activation即我们选择的激活函数，我们这里选的relu即rectifier activate function.(整流激活函数)。 第三个参数即输入参数的形状，input_shape =(784, )及说明这是一个包含了784个元素的向量，因为一幅图画的像素个数就是784。</p>
<h4 id="Adding-a-second-layer-with-Dropout"><a href="#Adding-a-second-layer-with-Dropout" class="headerlink" title="Adding a second layer with Dropout"></a>Adding a second layer with Dropout</h4><p>现在，我们要加入第二层，也就是Dropout层。dropout 是一种正则化技巧，我们会随机将一层中的神经元设为0。通过这种方法，一定比例的神经元会失活从而他们的权重不会再更新。我们添加dropout层就是决定了百分之多少的神经元会失活。这里，我们设置为0.2 意味着20%的神经元将失活</p>
<p>但这不是意味着失活的神经元就没用了，只是说每一次迭代，都只有20%的神经元会失活并停止学习过程，我们这样做的原因是为了避免神经网络过度学习导致过度拟合。因为在训练集上过度学习的画，在测试集上的结果就会很糟糕</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.add(tf.keras.layers.Dropout(<span class="number">0.2</span>))</span><br></pre></td></tr></table></figure>
<h4 id="Adding-the-output-layer"><a href="#Adding-the-output-layer" class="headerlink" title="Adding the output layer"></a>Adding the output layer</h4><p>添加输出层，这个输出层也是一个Dense对象。即神经网络对图像预测的最后分类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model.add(tf.keras.layers.Dense(units=<span class="number">10</span>,</span><br><span class="line">								activation=<span class="string">'softmax'</span>)</span><br><span class="line">		 )</span><br></pre></td></tr></table></figure>
<p>因为 units =10 ,因为我们一共有10类衣服。这里我们使用的是<code>softmax</code>激活函数，因为我们希望通过神经网络来获得每一个类别的概率，利用<code>softmax</code>可以返回最高概率值的分类。</p>
<h4 id="Compiling-the-model"><a href="#Compiling-the-model" class="headerlink" title="Compiling the model"></a>Compiling the model</h4><p>现在我们已经完成了构造神经网络的基本步骤，接下来我们要编译这个模型，也就是将这个神经网络连接到一个优化器上(optimizer),并选择一个损失(loss)</p>
<p>这里，我们的优化器选择的是随机梯度下降算法(推荐)，loss就是预测值和目标之间的误差</p>
<p>因为这不是一个二元分类而是有10类，所以说，我们要填写metrics参数为sparse_categorical_accuracy</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model.compile(optimizer=<span class="string">'adam'</span>,</span><br><span class="line">              loss=<span class="string">'sparse_categorical_crossentropy'</span>,</span><br><span class="line">              metrics=[<span class="string">'sparse_categorical_accuracy'</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.summary()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/26.png" style="zoom:100%;"></p>
<h4 id="Training-the-model"><a href="#Training-the-model" class="headerlink" title="Training the model"></a>Training the model</h4><p>编译好模型之后，我们加入数据，来训练神经网络，我们只要一行代码就能解决训练的问题。</p>
<p>输入训练集的X和y，并输入训练几代神经网络这三个强制参数即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.fit(X_train, y_train, epochs=<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/27.png" style="zoom:100%;"></p>
<p>我们看到随着代数的叠加，模型的准确率越来越高了。但这是训练集内部的准确率，并不是测试集的准确率，接下来我们就要将这个模型应用于测试集并对其进行一个评估    </p>
<h3 id="评估人工神经网络"><a href="#评估人工神经网络" class="headerlink" title="评估人工神经网络"></a>评估人工神经网络</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_loss, test_accuracy = model.evaluate(X_test, y_test)</span><br></pre></td></tr></table></figure>
<p>loss: 0.3490 </p>
<p> accuracy: 0.8736</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;Test accuracy: &#123;&#125;&quot;.format(test_accuracy))</span><br></pre></td></tr></table></figure>
<p>Test accuracy: 0.8736000061035156</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/16/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/18/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jason</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">439</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    

  

</body>
</html>
