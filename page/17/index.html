<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=">


  <link rel="mask-icon" href="/images/logo.svg?v=" color="#222">














<meta property="og:type" content="website">
<meta property="og:title" content="Jason‘s Blog">
<meta property="og:url" content="https://jasonxqh.github.io/page/17/index.html">
<meta property="og:site_name" content="Jason‘s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '',
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    fancybox: false,
    tabs: ,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: 'undefined',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>







  <title>Jason‘s Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', '[object Object]', 'auto');
  ga('send', 'pageview');
</script>





<meta name="generator" content="Hexo 4.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">
  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
<a href="https://github.com/JasonXQH/JasonXQH.github.io" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jason‘s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/%20" rel="section">
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" itemprop="url">CSAPP虚拟内存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-24T13:33:55+08:00">
                2020-11-24
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-06-25T19:44:00+08:00">
                2022-06-25
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="CSAPP虚拟内存"><a href="#CSAPP虚拟内存" class="headerlink" title="CSAPP虚拟内存"></a>CSAPP虚拟内存</h1><h2 id="物理和虚拟地址"><a href="#物理和虚拟地址" class="headerlink" title="物理和虚拟地址"></a>物理和虚拟地址</h2><p>一个使用物理寻址的系统：</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/2.png" style="zoom:80%;"></p>
<p>一个使用虚拟寻址的系统：</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/1.png" style="zoom:80%;"></p>
<p>使用虚拟寻址，CPU通过生成一个<strong>虚拟地址来访问主存</strong>，这个虚拟地址在被送到内存之前先转换成适当的物理地址。将一个虚拟地址转换为物理地址的任务叫做地址翻译。 地址翻译需要CPU硬件和操作系统之间的紧密合作。CPU芯片上叫做内存管理单元(Memory Management Unit,简称MMU) 的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理</p>
<h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><p>地址空间（address space)是一个非负整数地址的有序集合: ${0,1,2,\cdots}$ . 如果地址空间中的整数时连续的，那么我们说他是一个线性地址空间。</p>
<p>为了简化讨论，我们总是假设使用的是线性地址空间。在一个带虚拟内存的系统中，CPU 从一个有$N=2^n$个地址的地址空间中生成虚拟地址，这个地址空间称为虚拟地址空间（virtual address space) :<br>${0,1,2\cdots,N-1}$ </p>
<p>一个地址空间的大小是由表示最大地址所需要的位数来描述的。例如，一个包含$N=2^n$个地址的虚拟地址空间就叫做一个n 位地址空间。现代系统通常支持32 位或者64 位虚拟地址空间。</p>
<p>一个系统还有— 个物理地址空间（physical address space)，对应于系统中物理内存的M个字节：<br>${0,1,2\cdots,M-1}$,  M不要求是2 的幂，但是为了简化讨论，我们假设 $W=2^m$</p>
<p>我们允许每个数据对象有多个独立的地址，其中每个地址都选自一个不同的地址空间。这就是虚拟内存的基本思想。主存中的每字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址</p>
<h2 id="虚拟内存作为缓存的工具"><a href="#虚拟内存作为缓存的工具" class="headerlink" title="虚拟内存作为缓存的工具"></a>虚拟内存作为缓存的工具</h2><p>接下来我我们来看看<strong>虚拟内存作为缓存的工具</strong></p>
<p>一般来说，虚拟内存是一组连续的存放在硬盘当中的bytes</p>
<p>我们把虚拟地址空间分成很多很多小块，每一个小块叫做一个page。这些page会与真实的物理内存空间进行映射，物理内存也被分成了很多小块，每一个小块可以叫做page也可以叫做frame。虚拟内存的pages很多都是空的，不然的话物理空间没有那么多page和虚拟地址空间一一映射</p>
<p>注意，<strong>这里的物理地址空间所代表的是主存DRAM，并不是Cache SRAM。</strong>因为磁盘的缓存就是DRAM，此外，DRAM还需要SRAM作为它的缓存</p>
<p>如下图所示：</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/3.png" style="zoom:80%;"></p>
<p>我们发现page有不同的状态</p>
<p>比较理想的的状态是page在我的缓存里面，这时候page的状态叫做 Cached</p>
<p>第二种状态叫做unallocated,代表这一个page在磁盘和内存中都没为其分配任何空间。</p>
<p>第三种叫做uncached，也就是还没有缓存的。表明我还没有用这个page,page中的数据当前并不在我的内存里面，他可能是在栈里面或者堆里面的某块空间。</p>
<h3 id="DRAM-Cache-Organization"><a href="#DRAM-Cache-Organization" class="headerlink" title="DRAM Cache Organization"></a>DRAM Cache Organization</h3><p>如果是DRAM作为磁盘的缓存的话，从磁盘中加载到Cache line中的block需要大于1ms的时间(一百万个运行周期)。因为DRAM比Disk要快差不多10000倍，而SRAM又比DRAM块十多倍。</p>
<p>因此，我们希望一次从磁盘中读取较多的信息，让读取的效率变高:</p>
<ul>
<li>Large page (block) size : typically 4KB<ul>
<li>Linux “huge pages” are 2MB(default) to 1GB</li>
</ul>
</li>
<li>Fully associative <ul>
<li>当DRAM作为disk的Cache的时候，表现为全相连的cache，也就是说，所有的cache line都是连在一起的。整个Cache 就只有一个set</li>
<li>这样，任何一个virtual page可以放在物理内存当中的任意一个空的地方</li>
<li>但这样就需要一张很大的映射表，来记录哪一个virtual page映射到哪一个physical page. 比如说4G内存，需要一个 8bytes*1M 的空间</li>
</ul>
</li>
<li><p>不命中时的替换策略也很重要，因为替换错了虚拟页的处罚也非常之高。因此，与硬件对SRAM 缓存相比，操作系统对DRAM 缓存使用了更复杂精密的替换算法</p>
</li>
<li><p>因为对磁盘的访问时间很长，DRAM 缓存总是使用回写，而不是直写。</p>
</li>
</ul>
<h3 id="Enabling-Data-Structure-Page-Table"><a href="#Enabling-Data-Structure-Page-Table" class="headerlink" title="Enabling Data Structure: Page Table"></a>Enabling Data Structure: Page Table</h3><p>同Cache一样，虚拟内存系统必须有某种方法来判定一个<strong>虚拟页是否缓存在DRAM 中的某个地方</strong>。如果是，系统还必须确定这个虚拟页<strong>存放在哪个物理页中</strong>。如果不命中，系统必须判断这个<strong>虚拟页存放在磁盘的哪个位置</strong>，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到DRAM 中，替换这个牺牲页。</p>
<p>我们提出了一个解决方案： page table (页表)</p>
<p><strong>页表将虚拟页映射到物理页</strong>。每一次地址翻译硬件(MMU)将一个虚拟地址转换为物理地址的时候，都会读取页表。操作系统负责维护页表的内容，以及在磁盘和DRAM之间来回传送页</p>
<p>页表就是一个页表条目（Page Table Entry , PTE)的<strong>数组</strong>,每一个PTE都是由一个有效位和一个n位地址字段组成的。</p>
<ul>
<li>其中，有效位表明了该虚拟页当前是否被缓存在DRAM当中。如果设置了有效位为1，那么地址字段就表示DRAM 中相应的物理页的起始位置，这个物理页中缓存了该虚拟页。</li>
<li>如果没有设置有效位，(0) ,那么<strong>一个空地址表示这个虚拟页还未被分配</strong>。</li>
</ul>
<p>比如说下图，一共有8个虚拟页和4个物理页的系统的页表。</p>
<ul>
<li>四个虚拟页(VP 1、2、7、4) 当前被缓存在DRAM当中。</li>
<li>两个页(VP0,5) 还没有被分配</li>
<li>剩下的页(VP3,6) 已经被分配了，但是当前还没有被缓存，(为其分配物理地址)</li>
</ul>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/4.png" style="zoom:80%;"></p>
<h4 id="Page-Hit"><a href="#Page-Hit" class="headerlink" title="Page Hit"></a>Page Hit</h4><p>Page hit: reference to VM word that is in physical memory (DRAM cache hit)</p>
<p>当CPU想要读取包含在VP2的虚拟内存的一个字时(VP2已经被缓存在DRAM当中)。地址翻译硬件MMU 将<strong>虚拟地址作为一个索引</strong>来定位PTE2，并从内存中读取它，因为设置了有效位，那么地址翻译硬件就知道VP2是缓存在内存当中的了。</p>
<p>所以，地址翻译硬件<strong>用PTE中的物理内存地址,构造出这个字的物理地址</strong>并读取它</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/5.png" style="zoom:80%;"></p>
<h4 id="Page-Fault"><a href="#Page-Fault" class="headerlink" title="Page Fault"></a>Page Fault</h4><p>Page fault: reference to VM word that is not in physical memory (DRAM cache miss)</p>
<p>当我发生page fault的时候，也就是缺页。那么整个计算机的处理流程如下：</p>
<ul>
<li>CPU想引用VP3中的一个字，但是我们知道VP3并未缓存在DRAM当中。</li>
<li>地址翻译硬件从内存中读取PTE3，但是发现这个valid bit =0，推断出VP3未被缓存。而且出现了一个缺页异常</li>
<li>缺页异常<strong>调用内核中的缺页异常处理程序</strong>，该程序会选择牺牲一个页。这里我们选择的是PP3中存放的VP4<ul>
<li>当VP4已经被写道磁盘当中去了，dirty bit =0,这时候它将直接删除</li>
<li>当VP4还没有写到磁盘当中，dirty bit =1,因此内核会先将其复制到磁盘</li>
</ul>
</li>
</ul>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/6.png" style="zoom:120%;"></p>
<ul>
<li>处理完VP4之后，内核从磁盘复制VP3到内存中的PP3，并更新PTE3，随后返回</li>
<li>当异常处理程序返回时，它会<strong>重新启动导致缺页的指令</strong>，该指令会<strong>把导致缺页的虚拟地址重发送到<br>地址翻译硬件</strong>。但是现在，VP 3 已经缓存在主存中了，那么页命中也能由地址翻译硬件正常处理了。</li>
</ul>
<p>整个过程会消耗非常非常多的时间</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/7.png" style="zoom:120%;"></p>
<h4 id="Triggering-a-Page-Fault"><a href="#Triggering-a-Page-Fault" class="headerlink" title="Triggering a Page Fault"></a>Triggering a Page Fault</h4><p>什么时候会触发缺页？</p>
<p>比如说，当一个用户想要在一个地址中写入东西</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">1000</span>]; </span><br><span class="line">main ()</span><br><span class="line">&#123;</span><br><span class="line">	a[<span class="number">500</span>] = <span class="number">13</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其汇编语言如下：</p>
<p><code>80483b7:      c7 05 10 9d 04 08 0d     $0xd,0x8049d10</code> </p>
<p>但是这个位置所在的page ，正在磁盘上面，于是MMU 就受到了缺页报错。</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/8.png" style="zoom:100%;"></p>
<h4 id="Completing-page-fault"><a href="#Completing-page-fault" class="headerlink" title="Completing page fault"></a>Completing page fault</h4><ul>
<li>发现缺页错误，操作系统的底层Kernel会协助我们将磁盘中的页复制到主存当中</li>
<li>然后返回并重新执行movl，这时候就没有缺页错误了。</li>
</ul>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/9.png" style="zoom:90%;"></p>
<h4 id="Allocating-Pages"><a href="#Allocating-Pages" class="headerlink" title="Allocating Pages"></a>Allocating Pages</h4><p>下图为我们展示了一个分配一个新的虚拟内存页时（例如，调用malloc）对页表的影响。</p>
<p>在这个示例中，VP5的分配过程是在磁盘上创建空间并更新PTE5，使它能指向磁盘上这个新创建的页面</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/10.png" style="zoom:90%;"></p>
<h3 id="又是局部性救了我们"><a href="#又是局部性救了我们" class="headerlink" title="又是局部性救了我们"></a>又是局部性救了我们</h3><p>虚拟内存看起来效率很低，但实际上它十分有效，这归因于局部性原理</p>
<p>尽管在整个运行过程中程序引用的不同页面的总数可能超出物理内存总的大小，但是局部性原则保证了在任意时刻，程序将<strong>趋向于在一个较小的活动页面(active page)集合上</strong>工作，这个集合叫做<strong>工作集(working set)</strong>或者<strong>常驻集合(resident set)</strong></p>
<ul>
<li><p>如果 工作集的大小小于物理内存的大小，那么程序就会有良好的时间局部性，虚拟内存系统就能做的相当好</p>
</li>
<li><p>但是如果工作集的大小大于物理内存的大小，那么程序将进入一个 抖动(Trashing) 的状态，这是页面将不断地换进换出。<br>如果在多个进程同时运行的情况下，当所有的工作集大小之和大于主存的大小的时候，也会发生抖动。这时候我们需要”挂起”一个占用内存较大的进程，将其放到磁盘当中去，腾出空间给优先级比较高的、能快速跑完的程序。</p>
</li>
</ul>
<p>虽然虚拟内存通常是有效的，但是如果一个程序的性能非常慢，那么程序员就需要考虑是不是电脑发生了抖动</p>
<h2 id="虚拟地址对内存管理的简化"><a href="#虚拟地址对内存管理的简化" class="headerlink" title="虚拟地址对内存管理的简化"></a>虚拟地址对内存管理的简化</h2><p>虚拟地址是一个有用的机制，因为它大大地简化了内存管理，并提供了一种自然的保护内存的方法</p>
<p>之前我们都是假设有一个单独的页表和所有的物理内存进行映射，但是我们要知道，实际上，操作系统<strong>为每一个进程提供了一个独立的页表</strong>，也就是一个独立的虚拟地址空间，如下图所示：</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/11.png" style="zoom:90%;"></p>
<p>在这个实例当中，Process 1 的页表VP1映射到PP2，VP2映射到PP6 同理，Process2 的 页表的VP1映射到PP8，而Process2映射到PP6.因此，我们知道了多个虚拟页面可以同时映射到同一个共享物理页面上。==提问：这样为啥能提升局部性?==</p>
<p><strong>按需页面调度</strong>和<strong>独立的虚拟地址空间</strong>的结合，对系统中内存的使用和管理造成了深远的影响。特别地，VM <strong>简化了链接和加载、代码和数据共享，以及应用程序的内存分配</strong></p>
<h3 id="简化链接"><a href="#简化链接" class="headerlink" title="简化链接"></a>简化链接</h3><p><a href="https://jasonxqh.github.io/2020/11/21/CSAPP链接/">CSAPP链接</a></p>
<p>独立的地址空间允许<strong>每个进程的内存映像使用相同的基本格式</strong>，而<strong>不管代码和数据实际存放在物理内存的何处</strong></p>
<p>对于64 位地址空间，代码段总是从虚拟地址0x400000 开始。数据段跟在代码段之后，中间有一段符合要求的对齐空白。栈占据用户进程地址空间最高的部分，并向下生长。这样的一致性极大地简化了链接器的设计和实现，允许链接器<strong>生成完全链接的可执行文件</strong>，这些可执行文件是<strong>独立于物理内存中代码和数据的最终位置的</strong>。</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/12.png" style="zoom:90%;"></p>
<h3 id="简化加载"><a href="#简化加载" class="headerlink" title="简化加载"></a>简化加载</h3><p>虚拟内存还使得容易向内存中加载可执行文件和共享对象文件。要把目标文件中<code>.text</code>和<code>.data</code> 节加载到一个新创建的进程中，Linux <strong>加载器</strong>为代码和数据段<strong>分配虚拟页</strong>，把它们标记为无效的（即未被缓存的）， 将<strong>页表条目指向目标文件中适当的位置</strong>。</p>
<p>但是，加载器从<strong>不从磁盘到内存实际复制任何数据</strong>。在每个页初次被引用时，要么是CPU 取指令时引用的，要么是一条正在执行的指令引用一个内存位置时引用的，虚拟内存系统会按照需要自动地调整数据页。</p>
<h3 id="简化共享"><a href="#简化共享" class="headerlink" title="简化共享"></a>简化共享</h3><p>独立地址空间为操作系统提供了一个<strong>管理用户进程</strong>和<strong>操作系统自身</strong>之间共享的一致机制。一般而言，每个进程都有自己私有的代码、数据、堆以及栈区域，是不和其他进程共享的。在这种情况中，<strong>操作系统创建页表，将相应的虚拟页映射到不连续的物理页面</strong>。</p>
<p>然而，在一些情况中，还是<strong>需要进程来共享代码和数据</strong>。例如，每个进程必须调用相同的<strong>操作系统内核代码</strong>，而每个C 程序都会调用C 标准库中的程序，比如 <code>printf()</code> . 操作系统通过<strong>将不同进程中适当的虚拟页面映射到相同的物理页面</strong>，从而安排<strong>多个进程共享这部分代码的一个副本</strong>，而不是在每个进程中都包括单独的内核和C标准库的副本</p>
<h3 id="简化内存分配"><a href="#简化内存分配" class="headerlink" title="简化内存分配"></a>简化内存分配</h3><p>虚拟内存为向用户进程提供一个<strong>简单的分配额外内存的机制</strong>。当一个运行在用户进程中的程序要求<strong>额外的堆空间</strong>时（如调用malloc 的结果）， 操作系统分配一个适当数字(例如k)个<strong>连续的虚拟内存页面</strong>，并且将它们<strong>映射到物理内存</strong>中<strong>任意位置的k个任意的物理页面</strong>。由于页表工作的方式，操作系统没有<strong>必要分配k个连续的物理内存页面</strong>。==页面可以随机地分散在物理内存中==。</p>
<h2 id="虚拟地址对内存的保护"><a href="#虚拟地址对内存的保护" class="headerlink" title="虚拟地址对内存的保护"></a>虚拟地址对内存的保护</h2><p>计算机系统必须为操作系统提供手段来<strong>控制对内存系统的访问</strong>。</p>
<ul>
<li><strong>不应该允许一个用户进程修改它的只读代码段</strong>。</li>
<li><strong>不应该允许它读或修改任何内核中的代码和数据结构</strong>。</li>
<li><strong>不应该允许它读或者写其他进程的私有内存</strong></li>
<li><strong>不允许它修改任何与其他进程共享的虚拟页面</strong></li>
</ul>
<p>除非所有的共享者都显式地允许它这么做</p>
<p>而<strong>提供独立的地址空间使得区分不同进程的私有内存变得容易</strong> ，我们可以通过在PTE 上添加一些<strong>额外的许可位</strong>来控制对一个虚拟页面内容的读取、改写和运行之类的权限。</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/13.png" style="zoom:90%;"></p>
<h2 id="Address-translation"><a href="#Address-translation" class="headerlink" title="Address translation"></a>Address translation</h2><p>现在我们来谈谈地址翻译的基础知识，为了让我们了解硬件在支持虚拟内存中的角色</p>
<p>下面概括了我们在这节里将要使用的所有符号</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/14.png" style="zoom:90%;"></p>
<p>形式上来说，地址翻译是一个 $N$ 元素的虚拟地址空间$(VAS)$中的元素和一个M元素的物理地址空间 $(PAS)$ 中元素之间的映射 : $MAP:VAS\rightarrow PAS \cup \emptyset$ </p>
<script type="math/tex; mode=display">
MAP\left( A\right) \begin{cases}A' \text{如果虚拟地址A处的数据在PAS的物理地址A'处}\\ \emptyset \text{如果虚拟地址A处的数据不在物理内存中}\end{cases}</script><p>下面这张图展示了MMU如何利用页表来实现上述的映射。CPU中的一个控制寄存器，页表基址寄存器(Page Table Base Register,RTBR)指向当前的页表。 n位的虚拟地址包含两个部分: 一个<strong>p位的虚拟页面偏移量</strong>(Virtual Page Offset,VPO),p是由page的大小决定的,$P=2^p$（比如page的大小为64bytes，那么$P=2^6$,那么p就有6位）<em>和一个<em>*(n-p)位的虚拟页号</em></em>(Virtual Number Page,VPN)</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/15.png" style="zoom:90%;"></p>
<p>MMU 利用 VPN 来选择适当的PTE。例如，VPN0 选择PTE0 ; VPN1选择PTE1.以此类推。</p>
<p>将页表条目中物理页号(Physical Page Number, PPN)和虚拟地址中的VPO 串联起来，就得到相应的物理地址。注意，因为物理和虚拟页面都是P 字节的，所以<strong>物理页面偏移(Physical Page Offset, PPO)和VPO 是相同的</strong>。</p>
<h4 id="Address-Translation-Page-Hit"><a href="#Address-Translation-Page-Hit" class="headerlink" title="Address Translation : Page Hit"></a>Address Translation : Page Hit</h4><p>当页命中的时候，CPU硬件执行的步骤：</p>
<ul>
<li>第一步：处理器生成一个虚拟地址(VA)，并把它传送给MMU</li>
<li>第二步：MMU 生成 PTE 地址 (PTEA)，并从Cache/Main memory 请求得到它</li>
<li>第三步：高速缓存/主存 向MMU返回PTE</li>
<li>第四步：MMU构造物理地址，并把它传送给高速缓存/主存</li>
<li>第五步：高速缓存/主存返回所请求的数据给处理器</li>
</ul>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/16.png" style="zoom:90%;"></p>
<p>我们要注意到MMU是在Cache 之前的！</p>
<h4 id="Address-Translation-：Page-Fault"><a href="#Address-Translation-：Page-Fault" class="headerlink" title="Address Translation ：Page Fault"></a>Address Translation ：Page Fault</h4><p>和页命中时完全由硬件处理不同，当缺页时，要求硬件和操作系统内核(Kernel)共同完成，如下图所示。</p>
<ul>
<li>第一步：处理器生成一个虚拟地址(VA)，并把它传送给MMU</li>
<li>第二步：MMU 生成 PTE 地址 (PTEA)，并从Cache/Main memory 请求得到它</li>
<li>第三步：高速缓存/主存 向MMU返回PTE</li>
<li>第四步：发现PTE的有效位是0，说明缺页了。这时MMU触发了一次异常，传递了CPU中的控制到操作系统内核中的缺页异常处理程序</li>
<li>第五步：缺页处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则将其换出到磁盘。(回写)</li>
<li>第六步：缺页处理程序页面从磁盘中调取新的页面到Cache/Main Memory,并更新内存中的PTE</li>
<li>第七步：缺页处理程序返回到原来的进程，再次执行导致缺页的指令。CPU 将引起缺页的虚拟地址重新发送给MMU。<br>因为虚拟页面现在缓存在物理内存中，所以就会命中，在MMU 执行了页命中情况的几个步骤之后，主存就会将所请求字返回给处理器</li>
</ul>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/17.png" style="zoom:90%;"></p>
<h3 id="结合Cache和VM"><a href="#结合Cache和VM" class="headerlink" title="结合Cache和VM"></a>结合Cache和VM</h3><p>现在我们把Cache 和Memory拆开来，看看整一个取数据的逻辑：</p>
<p>首先我们要知道Page Table也有可能存放在L1 Cache当中的。因此从MMU出来的 PTEA首先会在L1 Cache中查找。</p>
<ul>
<li>如果命中了，那么就从Cache返回PTE到MMU，然后MMU再生成物理地址去Cache中请求数据<ul>
<li>如果Cache中有数据，那么Cache会返回数据给CPU</li>
<li>如果Cache中没有数据，那么就会跟着物理地址去内存中查找</li>
</ul>
</li>
<li>如果未命中，那么就跑到主存中的页表当中去查找，然后的处理逻辑和上面所说的相同 </li>
</ul>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/18.png" style="zoom:90%;"></p>
<h3 id="TLB-Translation-Lookaside-Buffer"><a href="#TLB-Translation-Lookaside-Buffer" class="headerlink" title="TLB(Translation Lookaside Buffer)"></a>TLB(Translation Lookaside Buffer)</h3><p>虽然说之前的查询，如果PTE在L1中，开销只要1-2个周期；如果在内存中则要几十上百个周期，已经是比较快了，但是很多系统还是不满意，希望消除这样的开销。于是，他是在MMU中放置了<strong>一个关于PTE的小缓存</strong>，我们称其为TLB</p>
<p>TLB是一个虚拟寻址的缓存，其中每一行都保存着一个由<strong>单个PTE组成的块</strong>。TLB通常有着高度的相联度。</p>
<p>用于组选择和行匹配的索引和标记字段是从虚拟地址中的虚拟页号(VPN)中提取出来的。如下图所示。如果TLB有 $T=2^t$个组，那么TLB索引(TLBI)是由VPN的t个最低位组成的，而TLB标记(TLBT)是由VPN剩余位组成的</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/19.png" style="zoom:90%;"></p>
<h4 id="TLB-Hit"><a href="#TLB-Hit" class="headerlink" title="TLB Hit"></a>TLB Hit</h4><p>下图展示了当TLB 命中时(通常情况)所包括的步骤。这里的关键点是，所有的地址翻译步骤都是在芯片上的MMU 中执行的，因此非常快</p>
<p>第1 步：CPU 产生一个虚拟地址。<br>第2 步和第3 步：MMU拿着VPN去TLB中找，并从TLB 中取出相应的PTE。注意，这个查询速度是非常快的。因为有很多晶体管并行查询，时间接近于O(1)<br>第4 步：MMU 将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存。<br>第5 步：高速缓存/主存将所请求的数据字返回给CPU</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/20.png" style="zoom:90%;"></p>
<h4 id="TLB-miss"><a href="#TLB-miss" class="headerlink" title="TLB miss"></a>TLB miss</h4><p>当TLB 不命中时，MMU 必须从L1 缓存中取出相应的PTE, 如下图所示。新取出的PTE 存放在TLB 中，可能会覆盖一个已经存在的条目。</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/21.png" style="zoom:90%;"></p>
<h3 id="Multi-Level-Page-Tables"><a href="#Multi-Level-Page-Tables" class="headerlink" title="Multi-Level Page Tables"></a>Multi-Level Page Tables</h3><p>假设我们的电脑是48位的，每个PTE大小是8 byte，每个页的大小是4kb，那么如果将这些PTE全放到一个page table当中的话，我们就需要 $2^{48}\cdot 2^{-12}\cdot 2^3 = 2^{39}$ bytes 也就是一张512GB的大表，而这张大表有很多的PTE为空，造成了很大浪费。因此仅创建一张页表显然是不现实的。所以我们采用了另一个方案：多层页表</p>
<p>为了简便，我们这里以二层页表为例：第一层页表中存放的PTE指向的是第二层的某一张页表，而第二层中存放的PTE则是指向内存当中的页</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/22.png" style="zoom:90%;"></p>
<p>因为第一层很多PTE是空的，那么它们就不会指向一个页表，因此不用为其分配空间，因此节省下了不少内存。事实上，计算机采用的是多层页表，也就是说仅仅双层列表还是不够的。</p>
<h4 id="Translating-with-a-k-level-Page-Table"><a href="#Translating-with-a-k-level-Page-Table" class="headerlink" title="Translating with a k-level Page Table"></a>Translating with a k-level Page Table</h4><p>这是一个多级列表的示意图，只要最终找到了PPN，那么这一路页表都必须存在。此外，每一层都能节省下一定的空间，最后就能达到一个比较高效的、又体积比较小的方案。</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/23.png" style="zoom:90%;"></p>
<h2 id="地址翻译总结"><a href="#地址翻译总结" class="headerlink" title="地址翻译总结"></a>地址翻译总结</h2><p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/24.png" style="zoom:90%;"></p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/25.png" style="zoom:90%;"></p>
<p>首先我们拿到的信息有3点</p>
<ul>
<li>虚拟地址是14位的</li>
<li>物理地址是12位的</li>
<li>页的大小是64个bytes，也就是 $P= 2^6$  因此 $p=6$ ，这点非常重要，因为p的大小即是 VPO和PPO的位数，因此我们可以在上图画出VPO、PPO所占的位置和PPN(12-6 = 6 位)，VPN(14-6=8位)</li>
</ul>
<p>现在有一个虚拟地址 ： $00001101101001$ ,我们就知道它的VPN为 $00001101$ ,其VPO为$101001$ </p>
<p>根据查找顺序，接下来应该是去TLB当中查找，因此我们还要再VPN的基础上求出TLBT和TLBI。TLBT是标签，TLBI是用于定位的，我们需要现根据TLB的组数来确定TLBI有几位，然后再将剩余位设置成TLBT</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/26.png" style="zoom:90%;"></p>
<p>我们看到，TLB一共有$4 = 2^2$ 组。因此TLBI为2位，TLBT位6位，因此真个虚拟地址可以做如下划分：</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/27.png" style="zoom:90%;"></p>
<p>那么根据TLBI我们先定位到set1，然后再根据TLBT(0x03)进行匹配，发现valid位为1，匹配成功，于是我们可以从TLB中取出这个虚拟地址对应的PPN = 2D</p>
<p>我们知道物理地址是由PPN和PPO组成的，而PPO和VPO又是一模一样的，因此物理地址即可翻译出来：这里要注意，因为PPN只有6位，所以0x2d要写成0b101101(二进制)</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/28.png" style="zoom:90%;"></p>
<p>有了物理地址，我们就可以去Cache当中找数据了。那么我们首先看一下这个cache的结构，然后再来将物理地址分为Tag、Index和Offset3个部分</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/29.png" style="zoom:90%;"></p>
<p>我们发现这个Cache一共有$16=2^4$组，那么我们就需要用4位来表示 Cache Index也就是CI，又因为每一组set中，有 $4 = 2^2$个block，因此Cache Offset 需要分配2位，剩下的就是 Cache Tag了。因此在物理内存中的划分如上图所示。</p>
<p>在Cache中查找数据的时候，首先要查Index，这里是0xA; 找到以后匹配Tag,这里是0x2D，发现匹配上了; 并且Valid bit = 1 。所以这是一个典型的Cache hit.我们根据offset = 1来锁定最终取到的数据为 0x15</p>
<h2 id="Memory-Mapping"><a href="#Memory-Mapping" class="headerlink" title="Memory Mapping"></a>Memory Mapping</h2><p><strong>Linux</strong> 通过将一个<strong>虚拟内存区域</strong>与一个<strong>磁盘上的对象</strong>（object)关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射(memory mapping)。有了内存映射，我们就只要访问像访问内存一样访问磁盘上的对象，而不需要用fopen ,fclose 这些函数去访问了。</p>
<p>虚拟内存可以映射到两种类型的对象：<strong>Linux文件系统中的普通文件</strong> 和 <strong>匿名文件</strong> 。</p>
<h4 id="Linux文件系统中的普通文件"><a href="#Linux文件系统中的普通文件" class="headerlink" title="Linux文件系统中的普通文件"></a>Linux文件系统中的普通文件</h4><p>一个区域可以映射到一个普通磁盘文件的连续部分，例如一个<strong>可执行目标文件</strong>。  </p>
<h4 id="匿名文件"><a href="#匿名文件" class="headerlink" title="匿名文件"></a>匿名文件</h4><p>匿名文件是由内核 (kernel) 创建的，包含的全是二进制0.</p>
<p>CPU 第一次引用这样一个区域内的虚拟页面时，内核就在物理内存中找到一个合适的牺牲页面，如果该页面被修改过，就将这个页面换出来，用二进制零覆盖牺牲页面并更新页表，将这个页面标记为是驻留在内存中的。注意在磁盘和内存之间并没有实际的数据传送。</p>
<p>==这两类文件的区别和应用场景还没有搞明白==</p>
<p>无论在哪种情况中旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的交换文件（swap file)之间换来换去。交换文件也叫做交换空间（swap space)或者交换区域 (swap area)</p>
<h3 id="共享对象"><a href="#共享对象" class="headerlink" title="共享对象"></a>共享对象</h3><p>内存映射给我们提供了一种清晰的机制，用来控制多个进程如何共享对象。</p>
<p>一个对象可以被映射到虚拟内存的一个区域，要么作为共享对象，要么作为私有对象。</p>
<p><strong>共享对象</strong>：</p>
<p>如果一个进程将一个共享对象映射到它的虚拟地址空间的一个区域内，那么<strong>这个进程</strong>对<strong>这个区域</strong>的<strong>任何写操作</strong>，对其他进程而言(映射了这个共享对象的)也是可见的。而且，这些变化也会<strong>反映在磁盘上的原始对象</strong>中</p>
<p><strong>私有对象</strong> :</p>
<p>对其它进程来说不可见而且进程对这个区域所做的任何写操作都不会反映在磁盘上的对象当中。</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/30.png" style="zoom:90%;"></p>
<p>关键点在于即使对象被映射到了<strong>多个共享区域</strong>，物理内存中也只需要存放共享对象的<strong>一个副本</strong>，而这个对象在不同的进程当中所处的虚拟地址是不一样的。</p>
<h4 id="Copy-On-Write"><a href="#Copy-On-Write" class="headerlink" title="Copy-On-Write"></a>Copy-On-Write</h4><p>私有对象在被映射到虚拟内存的时候会使用一种Copy-On-Write的技术。因为私有对象要满足在被修改时对其它进程来说不可见、磁盘上的文件也不会进行改变的要求。Copy-On-Write顾名思义就是<strong>在写的时候复制</strong>。</p>
<p>其核心思想是，如果有多个调用者（callers）同时要求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（transparently）</p>
<p>对于每个映射私有对象的进程，<strong>相应私有区域</strong>的页表条目都被标记为<strong>只读</strong>，且物理内存上的页这时候被标记成了<strong>(Private copy-on-write</strong>), 当进程2要修改原来的对象的时候，会触发一个保护故障，这时候保护故障程序就会在物理内存中创建这个页面的一个<strong>新副本</strong>，更新页表条目指向这个新的副本，然后恢复这个页面的可写权限，当故障处理程序返回时，CPU <strong>重新执行这个写操作</strong>，现在在<strong>新创建的页面上这个写操作</strong>就可以正常执行了。如下图所示</p>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/31.png" style="zoom:90%;"></p>
<p>也就是说，读的时候大家可以一起读，只有在写的时候(迫不得已)，才进行一个拷贝。是一种 Lazy Copy的模式。</p>
<p>这样做的好处是加快启动进程，加快相应时间。因为读取很快，但是写很慢，因此每次写只拷贝要写的那几个page。</p>
<h3 id="使用-mmap-函数的用户级内存映射"><a href="#使用-mmap-函数的用户级内存映射" class="headerlink" title="使用 mmap 函数的用户级内存映射"></a>使用 mmap 函数的用户级内存映射</h3><p>Linux 进程可以使用 <code>mmap</code>函数来创建新的虚拟内存区域，并将对象映射到这些区域中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *staxt, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/11/24/CSAPP%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/32.png" style="zoom:90%;"></p>
<p>mmap 函数要求内核创建一个新的虚拟内存区域，最好是从地址start 开始的一个区域，并将文件描述符fd 指定的对象的一个连续的(chunk)映射到这个新的区域。</p>
<p>连续的对象片大小为length 字节，从距文件开始处偏移量为offset 字节的地方开始。start地址仅仅是一个暗示，通常被定义为NULL.</p>
<p>因为mmap的返回值是一个指针，这个指针并没有规定数据类型。我们就可以通过这个指针来访问磁盘上的文件，我访问、修改的所有东西可以在磁盘当中进行同步。</p>
<h3 id="mmap的-用处"><a href="#mmap的-用处" class="headerlink" title="mmap的 用处"></a>mmap的 用处</h3><ul>
<li>读取大文件<ul>
<li>mmap可以使用分页机制将文件放入内存中</li>
</ul>
</li>
<li>共享数据结构<ul>
<li>When call with MAP_SHARED flag<ul>
<li>Multiple processes have access to same region of memory</li>
<li>Risky!</li>
</ul>
</li>
</ul>
</li>
<li>File-based data structures<ul>
<li>E.g., database</li>
<li>Give protargument PROT_READ | PROT_WRITE</li>
<li>When unmap region, file will be updated via write-back</li>
<li>Can implement load from file / update / write back to file</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/" itemprop="url">CSAPP链接</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-21T14:10:24+08:00">
                2020-11-21
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-08-22T21:05:18+08:00">
                2022-08-22
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="CSAPP链接-Linking"><a href="#CSAPP链接-Linking" class="headerlink" title="CSAPP链接(Linking)"></a>CSAPP链接(Linking)</h1><p>为什么要用 Linking？</p>
<ol>
<li>能让程序模块化<ul>
<li>Linking可以让程序写成一个包含了较小源文件的集合，而不是将所有代码整合到一起。</li>
<li>Linking允许我们构建一些包含常用函数的库(Math library,standard C library)</li>
</ul>
</li>
<li>能提高整个程序的运行效率<ul>
<li>在时间方面，可以单独编译<ul>
<li>改变其中一个源文件即可，然后重新编译</li>
<li>不需要重新编译其他的源文件</li>
<li>可以同时编译多个文件</li>
</ul>
</li>
<li>空间方便，可以编写库<ul>
<li>常见的函数可以整合到一个文件夹当中                         </li>
<li>静态链接<ul>
<li>静态链接的过程就已经把要链接的内容已经链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行</li>
</ul>
</li>
<li>动态链接<ul>
<li>动态链接这个过程没有把内容链接进去，而是在执行的过程中，再去找要链接的内容，生成的可执行文件中并没有要链接的内容，所以当你删除动态库时，可执行程序就不能运行。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="编译器驱动程序"><a href="#编译器驱动程序" class="headerlink" title="编译器驱动程序"></a>编译器驱动程序</h2><p>现在我们有两个 .c文件：</p>
<p>main.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = sum(<span class="built_in">array</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sum.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">   		s += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们在shell中输入这样的命令之后：<code>gcc -Og -o prog main.c sum.c</code></p>
<p>机器会调用 GCC 来驱动程序：流程如下</p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/1.png" style="zoom: 120%;"></p>
<ol>
<li>首先，驱动程序运行了 C 预处理器(C-preprocessor即cpp) ，它会将C的源程序main.c翻译成一个 ASCII 码的中间文件 main.i</li>
<li>接下来，驱动程序运行C编译器(C compiler即ccl) ，它将main.i 翻译成一个 ASCII汇编语言文件 main.s</li>
<li>然后驱动程序运行汇编器(assembler即as) 将main.s文件翻译成一个可重定位目标文件 main.o,同理，生成sum.o</li>
<li>最后，它运行链接器程序ld，将main.o 和 sum.o 以及一些必要的系统目标文件组合起来，创建一个可执行目标文件 prog:</li>
<li>要运行可执行proq，我们在linux shell 的命令行中下输入 <code>./prog</code> ，shell就会调用一个叫做加载器(loader)的函数，他将可执行文件中的prog中的代码和数据复制到内存，然后将控制转移到这个程序的开头</li>
</ol>
<h2 id="三种-Object-Files"><a href="#三种-Object-Files" class="headerlink" title="三种 Object Files"></a>三种 Object Files</h2><h3 id="Executable-and-Linkable-Format-ELF"><a href="#Executable-and-Linkable-Format-ELF" class="headerlink" title="Executable and Linkable Format (ELF)"></a>Executable and Linkable Format (ELF)</h3><p>ELF格式，是标准的<strong>目标文件的二进制格式</strong>。是三种对象文件统一的格式</p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/3.png" style="zoom: 100%;"></p>
<ul>
<li><p>Elf header</p>
<ul>
<li>Word size, byte ordering, file type (.o, exec, .so),machine type, etc.</li>
</ul>
</li>
<li><p>Segment header table</p>
<ul>
<li>Page size, virtual address memory segments (sections), segment sizes.</li>
</ul>
</li>
<li>.text section<ul>
<li>Code 代码</li>
</ul>
</li>
<li>.rodata section (read-only)<ul>
<li>放只读的数据。如跳转表，字符串常量、带 const 修饰的全局变量和静态变量等</li>
</ul>
</li>
<li>.data section<ul>
<li>用于维护初始化的且初始值非0的全局变量和静态变量（不带 const 修饰）</li>
<li>这部分需要空间</li>
</ul>
</li>
<li>.bss section 用于维护未初始化的或初始值为0的全局变量和静态变量（不带 const 修饰）<ul>
<li>Uninitialized global variables 没有初始化的全局变量</li>
<li>“Block Started by Symbol”</li>
<li>不占用目标文件的空间,因此更节省空间</li>
</ul>
</li>
<li>.symtab section 符号表<ul>
<li>Symbol table 符号表</li>
<li>Procedure and static variable names 静态变量的名字</li>
<li>Section names and locations 对应所在的section的名字和位置</li>
</ul>
</li>
<li>.rel.text section <ul>
<li>Relocation info for .text section</li>
<li>Addresses of instructions that will need to be modified in the executable</li>
<li>Instructions for modifying.</li>
</ul>
</li>
<li>.rel.data section<ul>
<li>Relocation info for .data section</li>
<li>Addresses of pointer data that will need to be modified in the merged executable</li>
</ul>
</li>
<li>.debug section<ul>
<li>Info for symbolic debugging (gcc -g) 编译成debug版本的时候会用</li>
</ul>
</li>
<li>Section header table<ul>
<li>Offsets and sizes of each section</li>
</ul>
</li>
</ul>
<h3 id="Relocatable-object-file-o-file"><a href="#Relocatable-object-file-o-file" class="headerlink" title="Relocatable object file(.o file)"></a>Relocatable object file(.o file)</h3><p>可重定位的文件，包含了代码和数据(初始化全局变量的数据，<strong>不包含局部变量的初始化</strong>，局部变量在真正压栈的时候才会将其初始化，在一开始连空间都没有给它分配)</p>
<p><strong>可重定位文件只能和别人链接，不能单独运行</strong></p>
<h3 id="Executable-object-file-a-out-file"><a href="#Executable-object-file-a-out-file" class="headerlink" title="Executable object file(a.out file)"></a>Executable object file(a.out file)</h3><p>可执行文件，能直接被放在内存当中并被执行的。常常由多个.o文件链接而来</p>
<p>LF 可执行文件被设计得很容易加载到内存，可执行文件的连续的片(chunk)被映射到连续的内存段。程序头部表（program header table)描述了这种映射关系</p>
<h4 id="加载可执行目标文件"><a href="#加载可执行目标文件" class="headerlink" title="加载可执行目标文件"></a>加载可执行目标文件</h4><p>我们可以在linux下用 <code>./prog</code> 来运行可执行目标文件。</p>
<p>因为prog并不是一个内置的shell命令，所以shell会认为 prog是一个可执行目标文件，通过调用加载器的操作系统代码来运行它。加载器可以将可执行目标文件中的代码和数据从磁盘复制到内存当中，然后通过跳转到程序的第一条指令或入口点来运行该程序。这个过程叫做加载</p>
<p>在分配栈、共享库和堆的地址的时候，链接器会使用地址空间布局随机化。虽然每次程序运行的时候<strong>这些区域的地址都会改变</strong>，但是他们的<strong>相对位置是不变的</strong>。</p>
<ul>
<li><p>当加载器运行时，它创建类似于下图所示的内存映像。在程序头部表的引导下,加载器将可执行文件的片(chunk)复制到代码段和数据段。</p>
</li>
<li><p>接下来，加载器跳转到程序的入口点，也就 <code>_start</code>函数的地址。这个函数是在系统目标文件<code>ctrl.o</code>中定义的，对所有的C程序都是一样的。</p>
</li>
<li><code>_start</code> 函数调用系统启动函数<code>__libc_start_main</code> ，该函数定义在<code>libc.so</code>中。它初始化执行环境，调用用户层的<code>main</code> 函数，处理 <code>main</code> 函数的返回值，并且在需要的时候把控制返回给内核。</li>
</ul>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/1.jpg" style="zoom: 100%;"></p>
<h3 id="Share-object-file-so-file"><a href="#Share-object-file-so-file" class="headerlink" title="Share object file(.so file)"></a>Share object file(.so file)</h3><p>共享目标文件是一种特殊的可以重定位的目标文件，它只在运行的时候，由操作系统现成得加进去。在windows系统中 .so文件被叫做 .dll(Dynamic Link Libraries)</p>
<h2 id="静态链接-符号解析-symbol-resolution"><a href="#静态链接-符号解析-symbol-resolution" class="headerlink" title="静态链接-符号解析(symbol resolution)"></a>静态链接-符号解析(symbol resolution)</h2><p>为了构造可执行文件，链接器必须完成两个主要任务：符号解析和重定向</p>
<p>目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或者一个静态变量(static 声明的变量)，也就是说，除了关键字之外，我们写的都是符号。符号解析的目的是将每一个符号引用正好和一个符号定义关联起来。</p>
<p>比如说<br><code>void swap()</code>是定义了一个符号，而 <code>swap()</code> 是调用了一个符号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">()</span> </span>&#123;…&#125; 	<span class="comment">/* define symbol swap */</span></span><br><span class="line">swap(); 			<span class="comment">/* reference symbol swap */</span></span><br><span class="line"><span class="keyword">int</span> *xp = &amp;x; 		<span class="comment">/* define symbol xp, reference x */</span></span><br></pre></td></tr></table></figure>
<p>符号定义都被存放在一个符号表当中(symbol table)，这张符号表记录了符号的名字大小和位置。这些记录组成了一个数组。</p>
<p>符号解析的目的是将每一个符号引用正好和一个符号定义关联起来。</p>
<h3 id="静态变量、全局变量、局部变量"><a href="#静态变量、全局变量、局部变量" class="headerlink" title="静态变量、全局变量、局部变量"></a>静态变量、全局变量、局部变量</h3><ul>
<li>在内存里的位置不一样</li>
<li>静态变量不能被其他 .c文件访问，全局变量可以</li>
<li>静态变量可以在函数里面定义，出了函数再进来静态变量的值还是一样的。不会因为函数返回就没了。可以用来保留反复调用的函数的中间状态。</li>
<li>静态变量可以节省空间，减少无谓的压栈和出栈的次数</li>
</ul>
<p>接下来我们还要详细讲解一下全局变量的注意事项</p>
<h3 id="三种symbols"><a href="#三种symbols" class="headerlink" title="三种symbols"></a>三种symbols</h3><p><strong>Global symbols</strong></p>
<p>全局符号就是在本地<code>.c</code>文件中定义，在其他模块中也能引用 。 如<strong>非static函数和非static的全局变量</strong>（指<strong>不带static的全局变量</strong>）</p>
<p><strong>External symbols</strong></p>
<p>在外部文件定义，当前文件可以引用的，叫做外部符号。<strong>由其他模块定义并被模块m引用</strong>的全局符号（标志是extern，<strong>extern用来修饰全局变量，即声明在“最外层”</strong>）（要体现引用，否则不会进入符号表）</p>
<p><strong>Local symbols</strong></p>
<p> <strong>仅由模块m定义并能被本模块引用的本地符号</strong>。例如，在模块m中定义的<strong>带static的函数和变量（无论定义变量的位置，是全局还是在函数中，只要变量前面有static，都算是（本地）符号！）</strong></p>
<p>注意：局部符号并不是局部变量!!!!</p>
<p><strong>Local non-static C variables  vs local static variables</strong></p>
<ul>
<li><strong>本地非静态变量是存放在栈里</strong>的而<strong>本地静态变量</strong>是存放在 .bss或者 .data当中的</li>
</ul>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/6.png" style="zoom: 120%;"></p>
<p>问2个问题：</p>
<ul>
<li>一开头的<code>static int x</code>和<code>f()</code>、<code>g()</code>中的<code>static int x</code>，这三个 x是不是同一个 x？</li>
</ul>
<p>这是三个不同的静态变量，都在.data当中初始化了。在编译的时候，还要给x加上不同的后缀。 </p>
<ul>
<li>如果是同一个x，那么它们的值？如果不是x，那么return的x分别是哪一个x？</li>
</ul>
<p><code>f()、g()</code>中返回的值即在函数中定义的<code>static int</code>;<code>h()</code>返回的值是global的static int</p>
<p>第一次调用<code>f(),g(),h()</code>。返回的值分别是 17，33，42</p>
<p>第二次调用<code>f(),g(),h()</code>。返回的值分别是 18，47，69</p>
<p>因此我们也可以了解静态变量的性质：在进入函数，x还是之前的x，并不会重新声明</p>
<h3 id="关于symbols划分的例题"><a href="#关于symbols划分的例题" class="headerlink" title="关于symbols划分的例题"></a>关于symbols划分的例题</h3><p><strong>例1</strong></p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/4.png" style="zoom: 120%;"></p>
<p>比如说在 main.c里面，sum() 并不是 global symbol，是一个 external symbol</p>
<p>array和 main都是global symbol</p>
<p>val是局部变量，并不是symbol</p>
<p><strong>例2</strong></p>
<p>我们再来看一个例子，下面这个.c文件哪些名字会被保存在 symbol table 当中呢？</p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/5.png" style="zoom: 120%;"></p>
<p><code>incr</code> 是全局变量 是 global symbol</p>
<p><code>foo</code> 是static 修饰的，是local symbol</p>
<p>a,argc，argv都是参数，不是变量</p>
<p><code>main</code> 是一个 global symbol</p>
<p><code>printf</code> 是一个external symbol</p>
<p>我们可以用命令 <code>readelf -s symbols.o</code> 来看一下符号表</p>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p><strong>Type Mismatch Example</strong></p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/13.png" style="zoom: 120%;"></p>
<p>这样两个.c文件编译，还是能打印出来的，只是最后答应出来的是类型为long int的3.14</p>
<p>所以，我们尽量不要用全局变量，在多人合作的情况下非常容易出错。</p>
<p>如果一定要用，那么要养成一些习惯</p>
<ul>
<li>如果我自己的模块，要一直用，那就加static</li>
<li>在定义一个全局变量的时候顺便初始化它</li>
<li>如果我们引用了一个外部的全局变量，那么就用 关键词 extern 去修饰<ul>
<li>这样能将其变成一个 weak symbol</li>
<li>当其他文件中没有定义这个变量，但我加了extern，linker 也会报错。</li>
</ul>
</li>
</ul>
<h3 id="Use-of-extern-in-h-Files"><a href="#Use-of-extern-in-h-Files" class="headerlink" title="Use of extern in .h Files"></a>Use of extern in .h Files</h3><p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/14.png" style="zoom: 120%;"></p>
<p>我们做一个 .h文件，里面声明了全局变量 g和全局函数f()，然后在其他文件中通过 Include 来将这两个全局变量和全局函数加进来</p>
<p>这是标准的头文件使用方法，头文件一般只写声明，不写定义! 因为头文件是在预处理的时候将.h文件加入到.c文件去，如果在.h文件中写了定义，那么在预处理的时候c1.c和c2.c都会有.h中关于变量和函数的定义，在链接器将两个.c文件链接的时候会报重复定义的错误</p>
<h3 id="链接器怎么解决重复定义的？"><a href="#链接器怎么解决重复定义的？" class="headerlink" title="链接器怎么解决重复定义的？"></a>链接器怎么解决重复定义的？</h3><p>首先，我们要了解符号 是 strong 还是 weak的概念</p>
<p>Strong: procedures and initialized globals  初始化了的全局变量是Strong 的</p>
<p>Weak: uninitialized globals Or ones declared with specifier extern 没有初始化或者是外部符号是 Weak的</p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/7.png" style="zoom: 100%;"></p>
<p>当发生冲突的时候，有一些规则</p>
<ul>
<li>Rule 1: 同名字且都为Strong的符号是不被允许的<ul>
<li>相同名字的 strong 符号只能定义一次，否则 Linker是会报错的</li>
</ul>
</li>
<li>Rule 2: 如果有一个强的和若干个弱的符号，那么选择那个强的符号<ul>
<li>References to the weak symbol resolve to the strong symbol</li>
</ul>
</li>
<li>Rule 3如果没有一个强的，有很多弱的符号，那就随便选一个<ul>
<li>Can override this with gcc –fno-common</li>
<li>也可以要求编译器强制报错，不要产生任何的warning和error</li>
</ul>
</li>
</ul>
<p>下面是一些例子：</p>
<p><strong>1：</strong></p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/9.png" style="zoom: 150%;"></p>
<p>因为在两个文件里， p1都是strong的符号，因此 链接器会报错。</p>
<p><strong>2：</strong></p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/8.png" style="zoom: 150%;"></p>
<p>p1和p2 不冲突，两个x都是弱符号，因此不冲突</p>
<p><strong>3：</strong></p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/10.png" style="zoom: 150%;"></p>
<p>两个x的数据类型都是不同的，但是这也是被允许的。linker是不管类型的，他只管x在哪</p>
<p>然而，严格意义上来说这是不行的。因为double(8个字节)比int大，当我们在p2中写入的时候，因为x和y是连续存放的，因此可能会把 int y (4个字节)覆盖掉。</p>
<p><strong>4： </strong></p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/11.png" style="zoom: 150%;"></p>
<p>同理，虽然是合法的，但是 double的x可能吧 int y给覆盖掉</p>
<p><strong>5：</strong></p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/12.png" style="zoom: 150%;"></p>
<p>两个x是一强一弱的，会选择强的那个初始化，因此并不会冲突</p>
<p>注意：只有 compiler会注意到类型，linker是不会进行类型检查的</p>
<h2 id="静态链接-重定位-relocation"><a href="#静态链接-重定位-relocation" class="headerlink" title="静态链接-重定位(relocation)"></a>静态链接-重定位(relocation)</h2><p>静态重定位是在目标程序装入内存时，由装入程序对目标程序中的指令和数据的地址进行修改，即把<strong>程序的逻辑地址都改成实际的地址</strong>。对每个程序来说，这种地址变换只是在装入时一次完成，在程序运行期间不再进行重定位。</p>
<p>例如，一个以“0”作为参考地址的装配模块，要装入以1000为起始地址的存储空间。显然，在装入之前要做某些修改，程序才能正确执行。例如，MOV　 EAX，[500]这条指令的意义，是把相对地址为500的存储单元内容1234装入eax寄存器。现在内容为1234的存储单元的实际地址为1500， 即为相对地址(500)加上装入的地址(1000),因此，MOV　EAX，[500]这条指令中的直接地址码也要相应地加上起始地址，而成为MOV　 EAX，[1500]。<br>程序中涉及直接地址的每条指令都要进行这样的修改。需要修改的位置称为重定位项，所做的加实际装入模块起始地址修改中的块起始地址称为重定位因子。</p>
<p>我们看到，从可重定位目标文件到可执行目标文件，经历了下图这样一个过程：</p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/2.png" style="zoom: 120%;"></p>
<p>拿一个实际例子来说，可执行文件包含了从不同.o文件中来的内容。最终我们要生成一个可执行文件，其代码段和数据段是放在一起的。因此我们要对两个.o 文件做一个拼接。比如说我们要把<code>main()</code> 、<code>sum()</code>放在一起。 也就是说做一个将 .o文件剪开，再归类拼接到一起的过程 。</p>
<p>假设现在 main.o 和 sum.o 发生了链接；又有一个 main1和sum.o 还有 swap.o 一起发生了链接，构成另外一个可执行文件。这就可能造成了 sum() 在不同的可执行文件当中相对于main() 的相对位置也是不同的。因此，链接器需要为目标文件中的符号进行重定位</p>
<h3 id="Relocation-Entries"><a href="#Relocation-Entries" class="headerlink" title="Relocation Entries"></a>Relocation Entries</h3><p>那么从左边的部分到右边的部分，需要解决的问题就是将 函数和.data中的一些变量的地址给固定下来(将地址填到相应位置)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val = sum(<span class="built_in">array</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sum.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,s = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i= <span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		s+=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重定位算法"><a href="#重定位算法" class="headerlink" title="重定位算法"></a>重定位算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">foreach section s &#123;</span><br><span class="line">    foreach relocation entry r &#123;</span><br><span class="line">        refptr = s + r.offset; <span class="comment">/* ptr to reference to be relocated */</span></span><br><span class="line">            <span class="comment">/* Relocate a PC-relative reference */</span></span><br><span class="line">            <span class="keyword">if</span> (r.type == R_X86_64_PC32) &#123;</span><br><span class="line">                refaddr = ADDR(s) + r.offset; <span class="comment">/* ref’s run-time address */</span></span><br><span class="line">                *refptr = (<span class="keyword">unsigned</span>) (ADDR(r.symbol) + r.addend - refaddr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* Relocate an absolute reference */</span></span><br><span class="line">         	<span class="keyword">if</span> (r.type == R_X86_64_32)</span><br><span class="line">         		*refptr = (<span class="keyword">unsigned</span>) (ADDR(r.symbol) + r.addend);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们看看这个链接器是如何进行重定位的。首先，可重定位目标文件main.o 如下：</p>
<p>我们看到这时候的 .o 文件用的都是相对地址，是以 0为起始地址的</p>
<p>我们注意到。array的地址一开始被初始化为0，然后后面还有一条注释表明在重定位的时候才会把绝对地址填进去</p>
<p>同理，sum() 函数也是一个相对位置(填入的是返回后的地址，也就是+13)，在重定位的时候，才会填入绝对的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000000000000</span> &lt;main&gt;:</span><br><span class="line"><span class="number">0</span>: 	<span class="number">48</span> <span class="number">83</span> ec <span class="number">08</span> 	sub		$<span class="number">0x8</span>,%rsp</span><br><span class="line"><span class="number">4</span>: 	be <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> 	mov 	$<span class="number">0x2</span>,%esi</span><br><span class="line"><span class="number">9</span>: 	bf <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> 	mov 	$<span class="number">0x0</span>,%edi 		# %edi = &amp;<span class="built_in">array</span></span><br><span class="line">				a: R_X86_64_32 <span class="built_in">array</span> 		# Relocation entry</span><br><span class="line">e: 	e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> 	callq 	<span class="number">13</span> &lt;main+<span class="number">0x13</span>&gt; 	# sum()</span><br><span class="line">				f: R_X86_64_PC32 sum<span class="number">-0x4</span> 	# Relocation entry</span><br><span class="line"><span class="number">13</span>: <span class="number">48</span> <span class="number">83</span> c4 <span class="number">08</span> 	add 	$<span class="number">0x8</span>,%rsp</span><br><span class="line"><span class="number">17</span>: c3 						retq</span><br></pre></td></tr></table></figure>
<p>main函数引用了两个全局符号，一个是array，还有一个是sum。为每个引用，汇编器都产生一个重定位条目，然后显示在后面一行上:这里是<code>a: R_X86_64_32 array</code>和<code>f: R_X86_64_PC32 sum-0x4</code></p>
<p>这些重定位条目告诉链接器对sum的引用要进行32位<strong>相对地址</strong>进行重定位 ，表现为<code>R_X86_64_PC32</code>; 但是对 array的引用是进行32位<strong>绝对地址</strong>的重定位,表现为 <code>R_X86_64_32</code></p>
<h3 id="相对引用"><a href="#相对引用" class="headerlink" title="相对引用"></a>相对引用</h3><p>在上面的汇编代码中，main函数在第六行调用sum数，sum函数是在模块sum.o 中的。call指令 开始于节偏移 <code>0xe</code> 的地方，包括一字节的操作码<code>0xe8</code>,后跟着的是PC相对引用的占位符。现在还是00</p>
<p>假设重定位条目 r 由 4个字段组成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.offset = <span class="number">0xf</span></span><br><span class="line">r.symbol = sum</span><br><span class="line">r.type 	= R_X86_64_PC32</span><br><span class="line">r.addend = <span class="number">-4</span></span><br></pre></td></tr></table></figure>
<p>这些字段告诉链接器修改开始于偏移量<code>0xf</code> 处的32 位PC相对引用，这样在运行时它会指向 sum 例程。现在，假设链接器已经确定 <code>ADDR(.text)=0x4004d0</code>和 <code>ADDR(sum)=0x4004e8</code></p>
<p>然后通过相对寻址算法，连接器可以计算出<strong>引用的运行时地址</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">refaddr &#x3D; ADDR(s) + r.offset</span><br><span class="line">&#x3D; 0x4004d0 + 0xf</span><br><span class="line">&#x3D; 0x4004df</span><br></pre></td></tr></table></figure>
<p>然后更新引用，让它在运行时指向sum程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*refptr &#x3D; (unsigned) (ADDR(r.symbol) + r.addend - refaddr)</span><br><span class="line">&#x3D; (unsigned) (0x4004e8 +(-4)- 0x4004df)</span><br><span class="line">&#x3D; (unsigned) (0x5)</span><br></pre></td></tr></table></figure>
<p>因此，在在最后的.o文件中， call指令有着如下的重定位形式</p>
<p><code>4004de:         e8 05 00 00 00         callq 4004e8 &lt;sum&gt; # sum()</code></p>
<p>在运行时，call指令将存放在地址0x4004de 处。当CPU执行call 指令时，PC 的值为0x4004e3, 即紧随在call 指令之后的指令的地址。为了执行这条指令，CPU 执行以下的步骤：<br>1) 将PC 压入栈中</p>
<p>2) $PC\leftarrow PC+0x5 = 0x4004e3+0x5 = 0x4004e8$</p>
<p>下面是重定位之后的在 可执行文件的text区域中的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">00000000004004d0 &lt;main&gt;:</span><br><span class="line">4004d0: 		48 83 ec 08 		sub $0x8,%rsp</span><br><span class="line">4004d4: 		be 02 00 00 00 		mov $0x2,%esi</span><br><span class="line">4004d9: 		bf 18 10 60 00 		mov $0x601018,%edi # %edi &#x3D; &amp;array</span><br><span class="line">4004de: 		e8 05 00 00 00 		callq 4004e8 &lt;sum&gt; # sum()</span><br><span class="line">4004e3: 		48 83 c4 08 		add $0x8,%rsp</span><br><span class="line">4004e7: 		c3 					retq</span><br><span class="line">00000000004004e8 &lt;sum&gt;:</span><br><span class="line">4004e8: 		b8 00 00 00 00 		mov $0x0,%eax</span><br><span class="line">4004ed: 		ba 00 00 00 00 		mov $0x0,%edx</span><br><span class="line">4004f2: 		eb 09 				jmp 4004fd &lt;sum+0x15&gt;</span><br><span class="line">4004f4: 		48 63 ca 			movslq %edx,%rcx</span><br><span class="line">4004f7: 		03 04 8f 			add (%rdi,%rcx,4),%eax</span><br><span class="line">4004fa: 		83 c2 01 			add $0x1,%edx</span><br><span class="line">4004fd: 		39 f2 cmp 			%esi,%edx</span><br><span class="line">4004ff: 		7c f3 				jl 4004f4 &lt;sum+0xc&gt;</span><br><span class="line">400501: 		f3 c3 				repz retq</span><br></pre></td></tr></table></figure>
<p>我们有发现，在 .o 文件当中 <code>e:  e8 00 00 00 00 callq 13 &lt;main+0x13&gt; # sum()</code> 这行汇编代码已经变成了<br><code>4004de:   e8 05 00 00 00     callq 4004e8 &lt;sum&gt; # sum()</code> ，其中 0x4004e8 是sum的绝对地址，因为产生跳转目标的编码是由<strong>目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差</strong>得出的。因此这时候产生跳转目标的编码 = 0x4004e8-0x4004e3 = 0x05,和指令的十六进制表示相匹配，callq 采用的这种方式就是基于PC的相对地址寻址方法。</p>
<h3 id="绝对引用"><a href="#绝对引用" class="headerlink" title="绝对引用"></a>绝对引用</h3><p>重定位绝对引用相当简单。比如下面这段汇编。 mov指令将array的地址(一个32位立即地址)复制到寄存器$\%edi$当中。mov指令开始于偏移量0x9 的位置，包括1字节操作码 $0xbf$ ，后面跟着array 的32位绝对引用的占位符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">0: 	48 83 ec 08 	sub		$0x8,%rsp</span><br><span class="line">4: 	be 02 00 00 00 	mov 	$0x2,%esi</span><br><span class="line">9: 	bf 00 00 00 00 	mov 	$0x0,%edi 		# %edi &#x3D; &amp;array</span><br><span class="line">				a: R_X86_64_32 array 		# Relocation entry</span><br><span class="line">e: 	e8 00 00 00 00 	callq 	13 &lt;main+0x13&gt; 	# sum()</span><br><span class="line">				f: R_X86_64_PC32 sum-0x4 	# Relocation entry</span><br><span class="line">13: 48 83 c4 08 	add 	$0x8,%rsp</span><br><span class="line">17: c3 						retq</span><br></pre></td></tr></table></figure>
<p>现在给出占位符条目 r ，包括4个字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.offset &#x3D; 0xa</span><br><span class="line">r.symbol &#x3D; array</span><br><span class="line">r.type 	&#x3D; R_X86_64_32</span><br><span class="line">r.addend &#x3D; 0</span><br></pre></td></tr></table></figure>
<p>这些字段告诉链接器要修改从偏移量$0xa$ 开始的绝对引用，这样在运行时它将会指向array的第一个字节。现在，假设链接器已经确定</p>
<p><code>ADDR(r.symbol)=ADDR(array)=0x601018</code></p>
<p>那么根据上面的算法，我们可以计算 <code>*refptr</code>的值 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*refptr &#x3D; (unsigned) (ADDR(r.symbol) + r.addend)</span><br><span class="line">		&#x3D; (unsigned) (0x601018+0)</span><br><span class="line">		&#x3D; (unsigned) (0x601018)</span><br></pre></td></tr></table></figure>
<p>因此我们要将汇编改为</p>
<p><code>4004d9:    bf 18 10 60 00      mov    $0x601018,%edi</code> 因为我们的机器是小端法 </p>
<h2 id="库-libraries"><a href="#库-libraries" class="headerlink" title="库(libraries)"></a>库(libraries)</h2><h3 id="什么是库？"><a href="#什么是库？" class="headerlink" title="什么是库？"></a>什么是库？</h3><p>库是一些常用函数的集合，比如说基于 Math,I/O,memory management,string manipulation 的一些操作函数。</p>
<p>那么我们要引用库中的函数，有两种方法：</p>
<ul>
<li>选择1：将所有的函数放到一个源文件当中<ul>
<li>这样程序员就会将一个很大的文件链接到自己的程序当中</li>
<li>空间和时间的效率都很差。我只用一个函数，但是我却要链接很多很多其他没用的函数链接进来，这样就会浪费内存和磁盘的空间。且每次编译都要进行很多无谓的工作。</li>
</ul>
</li>
<li>选择2：将每一个库函数分别放在不同的源文件当中<ul>
<li>程序员将合适的函数精确的链接到自己的程序当中</li>
<li>更加油效率，但对程序员来说很不友好，要记住更多函数的名字，压力更大。</li>
</ul>
</li>
</ul>
<p>这两种方法都不是特别好，于是我们提出了两种方案。</p>
<h3 id="静态库-static-library"><a href="#静态库-static-library" class="headerlink" title="静态库(static library)"></a>静态库(static library)</h3><ul>
<li><p>archive(.a库文件) 就是把所有的函数头尾相连，打包。前面加一个index索引</p>
</li>
<li><p>使用链接器，使其尝试通过在一个或多个存档中查找符号来解析未解析的外部引用。</p>
</li>
<li>当我和库文件( .a)连接的时候，会到 .a 文件当中去查找哪些.o 文件是我需要的。那么这一部分 .o文件链接到我的可执行文件当中</li>
</ul>
<p>.a 和 .o 文件的关系如下：</p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/16.png" style="zoom: 120%;"></p>
<p>我们也可以字节编写一个 .a 文件：</p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/17.png" style="zoom: 120%;"></p>
<p>在编译链接的过程如下图所示：</p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/18.png" style="zoom: 120%;"></p>
<p>当我们安装环境的时候，已经把库的查找路径安装进去了，编译器会根据这些缺省的路径去查找。</p>
<p>查找的优先级：include 某一个文件可以用双引号”” 和一个\&lt;> 双引号代表当前目录下的文件，而\&lt;> 则代表在系统缺省路径中查找。</p>
<h4 id="使用静态库"><a href="#使用静态库" class="headerlink" title="使用静态库"></a>使用静态库</h4><ul>
<li>按顺序扫描.o文件和.a文件</li>
<li>在扫面描的时候，把unresolved 符号引用都保存下来</li>
<li>每当一个新的 .o 和 .a 进来，我们回去看前面的那张表，去看看前面保存的哪些unresolved 符号是否在这些 .o和 .a 文件中存在。逐个把这些unresolved 符号解析掉</li>
<li>如果整个过程结束，发现表中还有symbol没有找到，那么就会报 symbol not found ，链接失败</li>
</ul>
<h3 id="动态链接共享库-shared-library"><a href="#动态链接共享库-shared-library" class="headerlink" title="动态链接共享库(shared library)"></a>动态链接共享库(shared library)</h3><p>静态链接库有如下缺点：</p>
<ol>
<li>增加了硬盘的占用空间</li>
<li>增加了内存的占用空间，比如说一份printf的代码可能会在内存中存放100份</li>
<li>如果要更新某些库中的一些函数，我不得不将和这个库有关的程序重新编译链接一遍。这个代价是非常非常大的。编译一个程序是十分消耗时间的。</li>
</ol>
<p>所以我们引入了共享库/动态链接库的概念</p>
<p>当我想要一个 对象文件的时候，我并不将其链接进我们的程序，只有在要使用这个文件的时候，再动态的加载进去。这样就能让磁盘只保存一份库的代码即可</p>
<p>那么有哪些情况需要用到 object file呢？</p>
<ol>
<li>当加载可执行程序的时候，发现要用特定的object file，就将其加载到内存当中去</li>
<li>可执行程序要用到某个 object file中的某个全局变量或者函数的时候，到那句语句要执行的时候我在将对应的object file加载进去。</li>
</ol>
<p>在windows中，这类库叫做 .dll ; 在linux环境下，叫做 .so</p>
<h4 id="What-dynamic-libraries-are-required"><a href="#What-dynamic-libraries-are-required" class="headerlink" title="What dynamic libraries are required"></a>What dynamic libraries are required</h4><ul>
<li>.interp section<ul>
<li>Specifies the dynamic linker to use (i.e.,ld-linux.so)</li>
</ul>
</li>
<li>.dynamic section<ul>
<li>Specifies the names, etc of the dynamic libraries to use</li>
</ul>
</li>
<li>where are the libraries found <ul>
<li>专门有一个可执行文件 ldd帮我们去找到我们需要的动态链接库在什么地方</li>
</ul>
</li>
</ul>
<h4 id="生成一个动态链接库的例子"><a href="#生成一个动态链接库的例子" class="headerlink" title="生成一个动态链接库的例子"></a>生成一个动态链接库的例子</h4><p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/19.png" style="zoom: 120%;"></p>
<p>将两个 .o 文件，通过命令 <code>gcc -shared -o libvector.so addvec.o multvec.o</code> 这行命令来生成一个 .so 文件。 其中 <code>.o</code> 表示 output，即说明生成的这个文件(共享库)是什么名字。</p>
<h4 id="Dynamic-Linking-at-load-time"><a href="#Dynamic-Linking-at-load-time" class="headerlink" title="Dynamic Linking at load-time"></a>Dynamic Linking at load-time</h4><p>现在我们来讲一下加载过程中怎么样使用共享库</p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/20.png" style="zoom: 120%;"></p>
<p>我们对程序采用动态链接，这就是编译链接生成函数的内部步骤。</p>
<p>我们通过 <code>gcc -o prog21 main2.o ./libvector.so</code> 这行命令就可以将main2.o 和我们需要的 libvector.so,libc.so 组合生成prog21文件。</p>
<p>但是这个prog21文件有 main2.o的代码，但是却没有 libvector.so 的代码，仅仅是在里面“埋了一个伏笔告诉我们会用到libvector.so “</p>
<p>当我们要运行的时候(最后)，系统会通过动态链接器(ld-linux.so) 将需要的两个 .so 文件加载进去。最终形成一个完整的文件。</p>
<h4 id="Dynamic-Linking-at-Run-time"><a href="#Dynamic-Linking-at-Run-time" class="headerlink" title="Dynamic Linking at Run-time"></a>Dynamic Linking at Run-time</h4><p>现在有一个程序如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> x[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> y[<span class="number">2</span>] = &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> z[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *handle;<span class="comment">//handle是一个句柄，我们通过handle这个指针来拿到我想要的东西</span></span><br><span class="line">    <span class="keyword">void</span> (*addvec)(<span class="keyword">int</span> *, <span class="keyword">int</span> *, <span class="keyword">int</span> *, <span class="keyword">int</span>);<span class="comment">//函数指针，</span></span><br><span class="line">    <span class="keyword">char</span> *error;<span class="comment">//字符串数组，来传递错误信息的</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Dynamically load the shared library that contains addvec() */</span></span><br><span class="line">    <span class="comment">//一开始用handle来挂住一个文件，也就是相对路径下的 libvector.so文件</span></span><br><span class="line">    handle = dlopen(<span class="string">"./libvector.so"</span>, RTLD_LAZY);</span><br><span class="line">    <span class="comment">//这里的 LAZY 翻译成 “迟" 的，也就是能不加载就不加载，不得已要的时候才加载</span></span><br><span class="line">    <span class="keyword">if</span> (!handle) &#123;</span><br><span class="line">    	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, dlerror());</span><br><span class="line">        <span class="comment">//如果handle没有打开这个文件，那就报标准错误</span></span><br><span class="line">   		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get a pointer to the addvec() function we just loaded */</span></span><br><span class="line">    addvec = dlsym(handle, <span class="string">"addvec"</span>);</span><br><span class="line">    <span class="keyword">if</span> ((error = dlerror()) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//如果dlerror 非空，那么也要把错误输出</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, error);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Now we can call addvec() just like any other function */</span></span><br><span class="line">    addvec(x, y, z, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"z = [%d %d]\n"</span>, z[<span class="number">0</span>], z[<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Unload the shared library */</span></span><br><span class="line">    <span class="comment">//如果要关闭外部的资源，要看看handle的返回值是否是负的，负的就要报错</span></span><br><span class="line">    <span class="comment">//我们可以用man来看系统调用。</span></span><br><span class="line">    <span class="keyword">if</span> (dlclose(handle) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个工程的逻辑如下：</p>
<p>首先我们要在本地申明一个和要链接的动态库绑定的指针(handle)</p>
<p>然后打开这个共享库</p>
<p>然后正常使用共享库当中的符号 </p>
<p>最后关闭这个共享库</p>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/21.png" style="zoom: 120%;"></p>
<h3 id="静态库-vs-动态库"><a href="#静态库-vs-动态库" class="headerlink" title="静态库  vs 动态库"></a>静态库  vs 动态库</h3><p>静态库和动态库的载入时间是不一样的。</p>
<p>静态库的代码在编译的过程中已经载入到可执行文件中，所以最后生成的可执行文件相对较大。</p>
<p>动态库的代码在可执行程序运行时才载入内存，在编译过程中仅简单的引用，所以最后生成的可执行文件相对较小。可以提高代码的可复用度和降低程序的耦合度。</p>
<p>静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库。</p>
<p>动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入，因此在程序运行时还需要动态库存在。</p>
<p>无论静态库，还是动态库，都是由.o文件创建的。因此，我们必须将源程序hello.c通过gcc先编译成.o文件。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>链接能让多个目标文件最终组合成一个程序</p>
</li>
<li><p>链接可以在程序生命周期的不同时间发生:</p>
<ul>
<li>Compile time (when a program is compiled) 编译阶段，静态库</li>
<li>Load time (when a program is loaded into memory) 加载阶段，动态库</li>
<li>Run time (while a program is executing) 运行阶段, 动态库</li>
</ul>
</li>
<li><p>了解链接能帮助我们避免恶心的错误</p>
</li>
</ul>
<p><img src="/2020/11/21/CSAPP%E9%93%BE%E6%8E%A5/22.png"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/11/17/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1-%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/17/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1-%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/" itemprop="url">最长公共/上升子序列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-17T12:51:31+08:00">
                2020-11-17
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2021-01-08T11:33:30+08:00">
                2021-01-08
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DP/" itemprop="url" rel="index">
                    <span itemprop="name">DP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="最长公共-上升子序列"><a href="#最长公共-上升子序列" class="headerlink" title="最长公共/上升子序列"></a>最长公共/上升子序列</h1><h2 id="什么是LCS"><a href="#什么是LCS" class="headerlink" title="什么是LCS"></a>什么是LCS</h2><p>现在我们拿到2个字符串</p>
<p>string1：a b c d e f g h i</p>
<p>string 2 : c d  g i </p>
<p>我们发现，string1中的子序列 c d g i 和string2 的子序列 c d g i(也就是string2本身)相匹配，且<strong>下标是严格递增的</strong>那么我们说这两个字符串的最长公共子序列是：\<c d g i\></c></p>
<p>但是下面这种情况，最长字串还是 \<c d g i\></c></p>
<p>string1: a b c d e f g h i</p>
<p>string2 :e c d g i</p>
<p>虽然 string1和string2中都有e，但是因为他们的<strong>下标并不是严格递增</strong>的，因此 e c g d i 并不是string1和string2 的子序列。</p>
<p>最后一个例子：</p>
<p>string1： a b d a c e</p>
<p>string2:  b  a  b c e</p>
<p>这里，我们发现 \<a b c e> 和 \<b a c e> 都是string1和string2的最长公共子串，因此，LCS的个数是不唯一的</b></a></p>
<p>通过上面这些例子，我们可以这样来解释最长公共子序列问题(longest common subsequence problem)：</p>
<p>给定两个序列 $X=<x_1,x_2,\cdots,x_m>$和 $Y=<y_1,y_2,\cdots,y_n>$ 那么这时候如果 Z 既是X的子序列，又是Y 的子序列，且没有更长的子序列满足上述条件，我们称其为X和Y的最长公共子序列。我们要求的就是 Z 表示的长度最长的公共子序列。</y_1,y_2,\cdots,y_n></x_1,x_2,\cdots,x_m></p>
<h2 id="LCS-using-recursion"><a href="#LCS-using-recursion" class="headerlink" title="LCS using recursion"></a>LCS using recursion</h2><p>现在我们来讨论一下LCS的子问题，对两个序列 $X=<x_1,x_2,\cdots,x_m>$和 $Y=<y_1,y_2,\cdots,y_n>$ </y_1,y_2,\cdots,y_n></x_1,x_2,\cdots,x_m></p>
<ul>
<li>如果 $x<em>m=y_n$，则我们应该求解 $X</em>{m-1}$ 和 $Y_{n-1}$ 的一个LCS。并将 $x_m=y_n$ 追加到这个LCS的末尾，也就得到了 X和Y的一个LCS</li>
<li>如果$x<em>m\neq y_n$ 那么我们必须求解两个子问题： 求 $X</em>{m-1}$ 和 $Y$ 的一个 LCS 与 $X$ 和 $Y_{n-1}$ 的一个LCS。两个LCS的较长者(或者一样长)即为X和Y的一个LCS。</li>
</ul>
<p>上述子问题包括了所有情况，我们可以像矩阵链乘法一样写一个最优解的递归式。我们定义 $c[i,j]$ 表示 $X_i$ 和 $Y_j$ 的LCS长度，如果i =0 或者j=0，即一个序列的长度就等于0，那么LCS的长度为0。公式如下：</p>
<p><img src="/2020/11/17/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1-%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/1.png" style="zoom:80%;"></p>
<p>我们用一个例子来展现一个简单的递归过程</p>
<p><img src="/2020/11/17/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1-%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/1.jpg" style="zoom:80%;"></p>
<h2 id="LCS-using-memoisation"><a href="#LCS-using-memoisation" class="headerlink" title="LCS using memoisation"></a>LCS using memoisation</h2><p>我们可以用一个二维数组记录下子问题的最优解。当$i,j$ 等于0的时候，其所在的那一行就填写0。剩下的格子中的数值取决于它左边上面的最大值(当$x_i\neq y_j$) 的时候，或者其左上方的格子+1(当$x_i = y_j$) 的时候。</p>
<p><img src="/2020/11/17/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1-%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/2.png" style="zoom:80%;"></p>
<p>这个算法的时间复杂度即为扫描这个二维数组的时间，设 n=string1.length , m=string2.length ,则 时间复杂度为 $O(mn)$ </p>
<p>空间复杂度即为一些常量的存储和二维数组的开销，为$O(mn)+O(1)=O(mn)$ </p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>伪代码：</p>
<p><img src="/2020/11/17/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1-%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/3.png"></p>
<p><img src="/2020/11/17/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1-%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/4.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxNum  100000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxInt  2147483647</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> memoisation[maxSize][maxSize];</span><br><span class="line"><span class="keyword">int</span> lcs[maxSize][maxSize]; <span class="comment">// left 0 leftup : 1 up:2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="built_in">string</span> x,<span class="built_in">string</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">int</span> m = x.length();</span><br><span class="line">    <span class="keyword">int</span> n = y.length();</span><br><span class="line"></span><br><span class="line">    memoisation[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    memoisation[<span class="number">1</span>][<span class="number">0</span>]= memoisation[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;m+<span class="number">2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        memoisation[i][<span class="number">0</span>] = x[i - <span class="number">2</span>];</span><br><span class="line">        lcs[i][<span class="number">0</span>] = x[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n+<span class="number">2</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        memoisation[<span class="number">0</span>][j] = y[j - <span class="number">2</span>];</span><br><span class="line">        lcs[<span class="number">0</span>][j] = y[j - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m+<span class="number">2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        memoisation[i][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        lcs[i][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;n+<span class="number">2</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        memoisation[<span class="number">1</span>][j]=<span class="number">0</span>;</span><br><span class="line">        lcs[<span class="number">1</span>][j]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">2</span>;j&lt;n+<span class="number">2</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">2</span>;i&lt;m+<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            memoisation[i][j] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (x[i<span class="number">-2</span>]==y[j<span class="number">-2</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                memoisation[i][j] = memoisation[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                lcs[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(memoisation[i - <span class="number">1</span>][j] &gt;= memoisation[i][j - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                memoisation[i][j] = memoisation[i - <span class="number">1</span>][j];</span><br><span class="line">                lcs[i][j] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                memoisation[i][j] = memoisation[i][j - <span class="number">1</span>];</span><br><span class="line">                lcs[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printlcsmatrix</span><span class="params">(<span class="built_in">string</span> x,<span class="built_in">string</span> y)</span></span>&#123;<span class="comment">//递归输出最优方案</span></span><br><span class="line">    <span class="keyword">int</span> m = x.length();</span><br><span class="line">    <span class="keyword">int</span> n = y.length();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"下面是存储继承子问题箭头的矩阵(左为0,左上为1,上为2)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">"\t"</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">'\t'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n+<span class="number">2</span>;i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;y[i<span class="number">-2</span>]&lt;&lt;<span class="string">'\t'</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>;j&lt;n+<span class="number">2</span>;j++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; lcs[<span class="number">1</span>][j] &lt;&lt; <span class="string">'\t'</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;m+<span class="number">2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;x[i<span class="number">-2</span>]&lt;&lt;<span class="string">'\t'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n+<span class="number">2</span>;j++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; lcs[i][j] &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_dp</span><span class="params">(<span class="built_in">string</span> x,<span class="built_in">string</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = x.length();</span><br><span class="line">    <span class="keyword">int</span> n = y.length();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"下面是存储标量乘法次数的矩阵(纵坐标为i,横坐标为j)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">"\t"</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">'\t'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n+<span class="number">2</span>;i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;y[i<span class="number">-2</span>]&lt;&lt;<span class="string">'\t'</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>;j&lt;n+<span class="number">2</span>;j++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; memoisation[<span class="number">1</span>][j] &lt;&lt; <span class="string">'\t'</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;m+<span class="number">2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;x[i<span class="number">-2</span>]&lt;&lt;<span class="string">'\t'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n+<span class="number">2</span>;j++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; memoisation[i][j] &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printlcs</span><span class="params">(<span class="built_in">string</span> x,<span class="keyword">int</span> lenx,<span class="keyword">int</span> leny)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lenx == <span class="number">1</span>||leny == <span class="number">1</span> )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (lcs[lenx][leny]==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printlcs(x,lenx<span class="number">-1</span>,leny<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;x[lenx<span class="number">-2</span>]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (lcs[lenx][leny] == <span class="number">2</span>)</span><br><span class="line">        printlcs(x,lenx<span class="number">-1</span>,leny);</span><br><span class="line">    <span class="keyword">else</span> printlcs(x,lenx,leny<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> X,Y;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;X;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;Y;</span><br><span class="line">    <span class="keyword">int</span> m = X.length();</span><br><span class="line">    <span class="keyword">int</span> n = Y.length();</span><br><span class="line">    <span class="built_in">find</span>(X,Y);</span><br><span class="line">    print_dp(X,Y);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    printlcsmatrix(X,Y);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"根据矩阵，我们可以得到两个字符串的lcs为: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    printlcs(X,m+<span class="number">1</span>,n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/11/17/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1-%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/5.png" style="zoom:120%;">    </p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/11/17/%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/17/%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%E6%B3%95/" itemprop="url">矩阵链乘法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-17T12:40:33+08:00">
                2020-11-17
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-11-26T22:26:48+08:00">
                2020-11-26
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DP/" itemprop="url" rel="index">
                    <span itemprop="name">DP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="矩阵链乘法"><a href="#矩阵链乘法" class="headerlink" title="矩阵链乘法"></a>矩阵链乘法</h1><h2 id="什么是矩阵乘法？"><a href="#什么是矩阵乘法？" class="headerlink" title="什么是矩阵乘法？"></a>什么是矩阵乘法？</h2><p>这是线性代数最重要的一个部分，这里我直接写矩阵乘法的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> a_n,a_m,b_n,b_m;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a_m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;b_n;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;a_n;k++)&#123;</span><br><span class="line">                ans[i][j]+=a[i][k]*b[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码我们可以看出，一共要进行三重循环，对于矩阵$a[a_m][a_n]$和 $b[b_m][b_n]$ 来说，他们能够相乘，那么必然 $a_n=b_m$</p>
<p>那么这个算法一共要进行的乘法计算次数为：$a_m<em>a_n</em>b_n$ </p>
<p>比如说，对于矩阵 $A_1[10][100],A_2[100][5]$ 来说，他们要相乘，乘法运算的次数为: $10\cdot100\cdot5=5000$次 </p>
<h2 id="什么是-矩阵链-乘法？"><a href="#什么是-矩阵链-乘法？" class="headerlink" title="什么是 矩阵链 乘法？"></a>什么是 矩阵链 乘法？</h2><p>给定 n 个矩阵的链 $<A_1\cdot a_2,\cdots,a_n>$ 矩阵$A<em>i$ 的规模为 $p</em>{i-1} \times p_i(i\leq i\leq n)$ ,求完全括号化方案，使得计算乘积 $A_1A_2\cdots A_n$ 所需标量乘法次数最小。</A_1\cdot></p>
<p>我们以矩阵链$<A_1,A_2,A_3>$相乘为例．来说明不同的加括另方式会导致不同的计算代价． 假设三个矩阵的规模分别为$10\times 100$、 $100\times 5$和$5\times 50$. 如果按$((A_1,A_2)A_3)$的顺序计算．为计算$A_1A_2(计算后矩阵规模为10\times 5)$, 需要做10• 100• 5 = 5000次标量乘法， 再与$A_3$ 相乘又需要做10• 5• 50 = 2 500次标量乘法． 共需7500次标量乘法．</A_1,A_2,A_3></p>
<p>但是，如果按$(A_1(A_2A_3))$ 的顺序．计算$A_2A_3$(计算后矩阵规模为 $100\times 50$), 需100 ·5·50=25000次标量乘法, 再与$A_1$相乘又需10•100• 50=50 000次标鬟乘法． 共需75000次标量乘法． 因此．按第一种顺序计算矩阵链乘积要比第二种顺序快10倍．</p>
<h2 id="用动态规划方法求解"><a href="#用动态规划方法求解" class="headerlink" title="用动态规划方法求解"></a>用动态规划方法求解</h2><p><img src="/2020/11/17/%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%E6%B3%95/1.jpg" style="zoom:80%;"></p>
<p>我们可以这么来理解：令 $m[i,j]$ 表示计算矩阵 $A_i\cdots A_j$ 所需标量乘法次数的最小值，那么原问题的最优解 就变成了 $m[1,n]$</p>
<p>我们可以递归定义$m[i,j]$如下． 对于 $i,j$ 时的平凡问题．矩阵链只包含唯一的矩阵，那么这时候就不用做任何的标量乘法运算。所以，对所有的 $i = 1,2,\cdots,n,m[i,i]=0 $ .我们假设 $A<em>iA</em>{i+1}\cdots A<em>j$ 的最优括号化方案的分割点再矩阵 $A_k$ 和 $A</em>{k+1}$ 之间，其中 $i\leq k&lt;j$，那么，$m[i,j]$ 就等于计算 $A<em>{i\cdots k}$ 和 $A</em>{k+1\cdots j}$ 相乘的代价为 $p_{i-1}p_kp_i$次标量乘法运算。因此，我们得到：</p>
<p>$m[i,j] = m[i,k]+m[k+1,j]+p_{i-1}p_kp_j$</p>
<p>此递归公式假定最优分割点k是已经知道的，但是事实上我们并不知道。不过 k只有 j-i种可能。由于最优分割点必在这其中，我们只要检查所有可能的情况。找到最优解即可。因此我们可以写出下面这个递归公式</p>
<p><img src="/2020/11/17/%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%E6%B3%95/1.png" style="zoom:80%;"></p>
<p> 比如说对于一个长为4 的矩阵链，我们可以这样将他的完整的递归链条写出来。</p>
<p><img src="/2020/11/17/%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%E6%B3%95/2.jpg" style="zoom:80%;"></p>
<p>但这样写十分庞杂，我们可以将它整合到一个 i * j 的棋盘格当中。</p>
<p> 比如说题目是这样的：</p>
<p> <img src="/2020/11/17/%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%E6%B3%95/2.png" style="zoom:80%;"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxSize 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxNum  100000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxInt  2147483647</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[maxSize][maxSize];</span><br><span class="line"><span class="keyword">int</span> cut[maxSize][maxSize];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> *sequence,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k,chain_length;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][i] = <span class="number">0</span>;</span><br><span class="line">        cut[i][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        cut[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        cut[<span class="number">0</span>][j] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(chain_length = <span class="number">2</span>;chain_length&lt;=n;chain_length++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;=n-chain_length+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            j = i+chain_length<span class="number">-1</span>;</span><br><span class="line">            dp[i][j] = maxInt;</span><br><span class="line">            <span class="keyword">for</span>(k=i;k&lt;j;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = dp[i][k]+dp[k+<span class="number">1</span>][j]+sequence[i<span class="number">-1</span>]*sequence[k]*sequence[j];</span><br><span class="line">                <span class="keyword">if</span>(temp &lt; dp[i][j])</span><br><span class="line">                    dp[i][j] =temp,cut[i][j] =k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;<span class="comment">//递归输出最优方案</span></span><br><span class="line">    <span class="keyword">if</span>(start==<span class="built_in">end</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"A%d"</span>,start);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"("</span>);</span><br><span class="line">        <span class="built_in">print</span>(start,cut[start][<span class="built_in">end</span>]);</span><br><span class="line">        <span class="built_in">print</span>(cut[start][<span class="built_in">end</span>]+<span class="number">1</span>,<span class="built_in">end</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_dp</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"下面是存储标量乘法次数的矩阵(纵坐标为i,横坐标为j)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\t"</span>,dp[i][j]);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"下面是存储截断点位置的矩阵(纵坐标为i,横坐标为j)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\t"</span>,cut[i][j]);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sequences[maxNum],n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;number;</span><br><span class="line">        sequences[i] = number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">find</span>(sequences,n);</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    print_dp(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么对于刚才的题目，我们可以输出 m矩阵和k矩阵，并且给出最优的括号解</p>
<p><img src="/2020/11/17/%E7%9F%A9%E9%98%B5%E9%93%BE%E4%B9%98%E6%B3%95/3.png" style="zoom:80%;"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/" itemprop="url">CSAPP存储器层次结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-14T09:40:28+08:00">
                2020-11-14
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-06-25T15:24:20+08:00">
                2022-06-25
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="存储器层次结构-The-memory-hierarchy"><a href="#存储器层次结构-The-memory-hierarchy" class="headerlink" title="存储器层次结构(The memory hierarchy)"></a>存储器层次结构(The memory hierarchy)</h1><h2 id="存储技术"><a href="#存储技术" class="headerlink" title="存储技术"></a>存储技术</h2><p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/1.png" style="zoom:80%;"></p>
<h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/9.png" style="zoom:80%;"></p>
<p> 这是一个硬盘的内部结构，圆形的部分是磁片，Arm是磁头臂，其尖端就是一个磁头。</p>
<p>我们将磁盘模型抽象出来：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/10.png" style="zoom:80%;"></p>
<ul>
<li>磁盘中有很多磁片，每一张磁片有2面</li>
<li>磁片的每一面又有若干的同心圆，叫做磁道(track)</li>
<li>磁道之间并不是连续的，中间有gap将其分成一小段一小段，每一小段叫做一个sector</li>
</ul>
<h4 id="磁盘容量"><a href="#磁盘容量" class="headerlink" title="磁盘容量"></a>磁盘容量</h4><p>现在的磁盘都是以TB为单位来计算的</p>
<p>一张磁盘的容量和下面几个参数有关：</p>
<ul>
<li>Recording density</li>
</ul>
<p>number of bits that can be squeezed into a 1 inch segment of a track.每英寸的sector可以放多少数据</p>
<ul>
<li>Track density</li>
</ul>
<p>number of tracks that can be squeezed into a 1 inch radial segment.一张磁片上可以放多少磁道</p>
<ul>
<li>Areal density</li>
</ul>
<p>product of recording and track density. 每平方英寸上可以放多少bity</p>
<h4 id="磁盘操作"><a href="#磁盘操作" class="headerlink" title="磁盘操作"></a>磁盘操作</h4><p>磁盘和磁头都可以运动。磁盘是转动，而磁头接近于径向移动。通过磁头径向移动，其可以扫到所有的磁道。在读取或者写入数据的时候，我们只要将磁头移动到特定的track上并旋转磁片，就可以通过电磁感应来讲数据写道特定的sector当中去。</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/11.png" style="zoom:80%;"></p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/12.png" style="zoom:80%;"></p>
<h4 id="磁盘访问："><a href="#磁盘访问：" class="headerlink" title="磁盘访问："></a>磁盘访问：</h4><p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/13.png" style="zoom:80%;"></p>
<p>现在我们在访问蓝色的数据，访问完之后，如果我们要访问红色的数据，需要进行上述几个步骤。</p>
<p>首先，我们要将磁头移动到红色区域所位于的磁道上方，(抬起来移动过去)，这个过程叫做 seek(寻道)、</p>
<p>接下来，我们要将磁片旋转，让红色区域转到磁头的下方，这个过程叫 Rotational latency</p>
<p>最后，我们的磁头要碰到红色区域进行电磁感应并传输数据</p>
<p>这些过程，都是机械运动，所以相对于内存来说，磁盘访问是非常非常慢的。</p>
<h4 id="访问时间"><a href="#访问时间" class="headerlink" title="访问时间"></a>访问时间</h4><p>我们来计算一下磁盘访问时间。 简单来说 就是上面几个过程的所消耗时间之和，也就是寻道时间+旋转时间+传送时间</p>
<p>$T<em>{access} = T</em>{avg~seek}+T<em>{avg~rotation}+T</em>{avg~transfer}$ </p>
<p>寻道时间通常为3~9ms,一次寻道的最大时间 $T_{maxseek}$可以高达20ms。</p>
<p>旋转时间是的计算公式为 $T_{avg~rotation}= \frac{1}{2}\times\frac{1}{RPM}\times\frac{60s}{1min}$ RPM即为每分钟的转速</p>
<p>传送时间一般依赖于旋转速度和每条磁道的扇区数目。因此我们可以这样来计算</p>
<p>$T_{avg~transfer} = \frac{1}{RPM}\times\frac{1}{(平均扇区数/磁道)}\times \frac{60s}{1min}$ </p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/14.png" style="zoom:80%;"></p>
<p>估计访问下面这个磁盘上一个扇区的访问时间（以ms 为单位）：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/48.png" style="zoom:120%;"></p>
<p>$T<em>{avg~rotation} =\frac{1}{2}\times T</em>{max~rotation}=\frac{1}{2}\times\frac{60s}{15000RPM}\times\frac{1000ms}{1s}= 2ms$</p>
<p>$T_{avg~transfer}=(60s/15000RMP)\times\frac{1}{500扇区/磁道}\times\frac{1000ms}{s}= 0.008ms$ </p>
<p>所以预计总的访问时间为 $8+2+0.008 \approx10ms$ </p>
<p>硬盘两个参数很重要：随机访问速度和连续访问速度。硬盘的随机访问速度是很慢的，但是连续访问速度是很快的。当我们写的随机算法将内存中的空间占满之后，数据便要随机存储到硬盘当中去，这时候磁盘的随机访问速度如果很慢那么这个算法肯定是会垮掉的。</p>
<p>比如说这一题：假设1MB 的文件由512 个字节的逻辑块组成，存储在具有如下特性的磁盘驱动器上：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/49.png" style="zoom:120%;"></p>
<p>对于下面的情况，假设程序顺序地读文件的逻辑块，一个接一个，将读/写头定位道第一块上的时间是 $T<em>{avg~seek}+T</em>{avg~rotations}$</p>
<p>A. 最好的情况: 给定逻辑块道磁盘扇区地最好的可能的映射(顺序的)，估计读取这个文件所需要的最优时间</p>
<p>B. 随机的情况：如果块是随机映射到磁盘扇区的，估计读这个文件所需要的时间,以毫秒为单位</p>
<p>首先我们计算 $T<em>{access}=T</em>{seek}+T<em>{avg~rotation}+T</em>{avg~transfer}=5ms+\frac{1}{2}\times\frac{60}{10000}\times\frac{1000ms}{1s}+\frac{60s}{10000RPM}\times\frac{1}{1000扇区/磁道}\times\frac{1000ms}{1s}\approx 8ms$</p>
<p>如果是最好的情况，块被映射到连续的扇区，在同一柱面上，那样就可以一块接一块地读取，不用寻道和移动读写头。一旦读/写头定位到了第一个扇区，我们只需要旋转磁盘2整圈(每圈1000个扇区，每个扇区512字节)来读取2000个块。所以读取这个文件地总时间只要 $T<em>{seek}+T</em>{avg~rotation}+2\times T_{max~rotation}=5+3+12=20ms$ </p>
<p>随机的情况下，块被随机地映射到扇区上，读2000块中的每一块都需要 $T<em>{avg~seek}+T</em>{avg~rotations}$ms = 8*2000=16000ms=16秒</p>
<p>所以，我们看得到，清理磁盘碎片是一件很重要的事情！</p>
<h4 id="I-O-Bus"><a href="#I-O-Bus" class="headerlink" title="I/O Bus"></a>I/O Bus</h4><p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/15.png" style="zoom:80%;"></p>
<p>磁盘是挂在磁盘控制器上的，而磁盘控制器是挂在I/O Bus，与I/O bridge相连的。那么我们要读取disk中的sector的话，首先要告诉磁盘控制器，然后从磁盘中取出数据后，直接放入内存而不经过CPU的。这种模式叫做 DMA(Direct Memory Access) 直接内存访问。</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/16.png" style="zoom:80%;"></p>
<p>那么为什么不用CPU去取数据呢？因为CPU是一个很贵的”劳动力“，而取数据是一个相对比较低端的”杂活”，我们要让CPU去干更加复杂的计算。</p>
<h3 id="Nonvolatile-Memories"><a href="#Nonvolatile-Memories" class="headerlink" title="Nonvolatile Memories"></a>Nonvolatile Memories</h3><ul>
<li><p>DRAM和SRAM都是易于丢失的内存，停电之后，里面的数据都没了</p>
</li>
<li><p>非易失的内存，在停电之后，数据并不会丢失</p>
<ul>
<li>Read-only memory (ROM): programmed during production</li>
<li>Electrically eraseable PROM (EEPROM): electronic erase capability</li>
<li>Flash memory: EEPROMs, with partial (block-level) erase capability (U盘)</li>
<li>3D XPoint (Intel Optane) &amp; emerging NVMs</li>
</ul>
</li>
</ul>
<p>非易失的数据，有这些应用：</p>
<ul>
<li>Firmware(固件) programs stored in a ROM(比如Bios，磁盘控制器，网卡，显卡加速器等)</li>
<li>固态硬盘(ssd)</li>
<li>Disk caches</li>
</ul>
<h3 id="SSD-固态硬盘"><a href="#SSD-固态硬盘" class="headerlink" title="SSD(固态硬盘)"></a>SSD(固态硬盘)</h3><p>固态硬盘的结构如下：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/17.png" style="zoom:80%;"></p>
<p>SSD中，有很多Block，每个Block之间又有很多Page</p>
<ul>
<li>每一个Page的大小从4k-512k不等，每一个Blocks又有32-128个page</li>
<li>读和写都是以page为单位进行的</li>
<li>不能只写1个page，需要把整个block擦除之后再写</li>
<li>每一个block的寿命大概是写入十万次</li>
</ul>
<h4 id="ssd的性能"><a href="#ssd的性能" class="headerlink" title="ssd的性能"></a>ssd的性能</h4><p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/18.png" style="zoom:80%;"></p>
<p>顺序的读取：2G出头，顺序的写入：2G不到一点。但是随机读和随机写入相对于顺序的读取和写入慢很多很多。随机的写入特别慢，因为我们先要擦除block，再写入。</p>
<p>我们这里还要了解一Buffer和Cache的区别</p>
<p>Cache是缓存，一般认为Cache中有的，比它第一级的存储区域也要有。cache是其下一级的一个子集</p>
<p>Buffer是缓冲，我们将一些数据暂时放到Buffer中，但Buffer中的数据可能并不会在低一级的存储器中。相当于一个蓄水池。</p>
<p>SSD中的DRAM是个Buffer，因为我一下子要将东西写入page中是不方便的，所以我们暂时把数据放到蓄水池Buffer当中。</p>
<p>还有一个作用，Buffer是将随机的数据，变成连续的数据，这样可以提升写入速度，同时也付出了昂贵的DRAM造价</p>
<h2 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h2><p>局部性对硬件和软件系统的设计和性能都有着极大的影响，有良好局部性的程序比局部性差的程序<br>运行得更快。因此一个编写良好的计算机程序常常具有良好的局部性。也就是说它们倾向于 <strong>引用</strong> 邻近于 <strong>最近引用过的数据项</strong> 的数据项，或者是最近引用过的数据项本身。</p>
<p>局部性常常有两种不同的形式：时间局部性和空间局部性。</p>
<p>时间局部性良好是说，被引用过一次的内存位置很可能再<strong>不远的将来</strong>再次被多次引用</p>
<p>空间局部性良好是说，如果一个内存的位置被引用了一次，那么程序很可能在不远的将来引用<strong>附近的</strong>一个内存位置。</p>
<p>对于一个同一个算法来说，调换两行遍历代码并不会影响算法的复杂度，但是其局部性可能相差会非常非常大。比如说一个二维数组元素求和的算法.正常来说我们写双重循环，内层循环会读一行数据，外层循环则负责换行。因此这个 <code>sumarrayrows</code> 算法具有良好的空间局部性，因为他按照数组被存储的优先顺序来访问这个数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_array_rows</span><span class="params">(<span class="keyword">int</span> a[M][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">    	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">    		sum += a[i][j];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法得到了一个很好的<strong>步长为1</strong> 的引用模式，具有良好的空间局部性：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/2.png" style="zoom:120%;"></p>
<p>但是我们只要做一个很小的改动，就会对其局部性有很大的影响。比如说我们把循环中的i、j和M、N调换</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_array_cols</span><span class="params">(<span class="keyword">int</span> a[M][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">    	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">    		sum += a[i][j];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这样的交换就会导致这个算法的空间局部性很差，因为他按照列顺序来扫描数组，而不是按照行顺序，因为在C数组再内存中是按照行顺序存放的。</p>
<p>我们得到了一个步长为N的引用模式，如图所示：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/3.png" style="zoom:120%;"></p>
<p>我们再来举一个例子：</p>
<p>一个对三维数组求和的算法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_array_3d</span><span class="params">(<span class="keyword">int</span> a[M][N][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">    		<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; M; k++)</span><br><span class="line">    			sum += a[k][i][j];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到，三层循环是按照i、j、k来执行的的，但是 我们最后访问的却是<code>a[k][i][j]</code>这显然是一个局部性很差的算法，因为其步长是<code>N*N*sizeof(int)</code> ,我们需要调整一下循环的顺序来将这个算法的步长改为1——将第二层关于j的循环放在最内层即可。</p>
<p>最后，让我们讲一些评价程序中局部性的一些简单原则：</p>
<ul>
<li>重复引用相同变量的程序有良好的时间局部性</li>
<li>对于步长为k的引用模式的程序，<strong>步长越小，空间局部性越好</strong>。在内存中以大步长跳来跳去的程序空间局部性会很差。</li>
<li>对于取指令来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好。</li>
</ul>
<h2 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h2><p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/4.png" style="zoom:120%;"></p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/8.png" style="zoom:120%;"></p>
<p>我们的存储器大致可以画成一个金字塔形，越上面的造价越贵、读取方式越快、容量越小；相反的，底层的存储设备变得更慢</p>
<ul>
<li><p>在最高层(L0) 是少量快速的CPU<strong>寄存器</strong>，CPU 可以在一个时钟周期内访问它们。</p>
</li>
<li><p>接下来是一个或多个小型到中型的<strong>基于SRAM 的高速缓存存储器</strong>，可以在几个CPU 时钟周期内访问它<br>们。这些元器件发热量高耗电大，因此没有办法造的很大。这里我们设计了3层Cache</p>
</li>
<li><p>然后是一个大的<strong>基于DRAM 的主存</strong>，可以在几十到几百个时钟周期内访问它们,</p>
</li>
<li><p>接下来是慢速但是容量很大的<strong>本地磁盘</strong>。</p>
</li>
<li><p>最后，有些系统甚至包括了一层附加的远程服务器上的磁盘，要通过网络来访问它们</p>
</li>
</ul>
<p>对于Cache，我们是一行一行读入的，每一行是64个字节</p>
<p>对于磁盘，我们会读取相当大的一块区域，而且磁盘跳读是非常慢的。</p>
<p>我们知道，现在的CPU读取和磁盘读取的速度相差地越来越大，我们希望用便宜的价格买到大容量存储的设备，又希望在读取时能达到一个较高的速度，怎么办？这时候Cache就应运而生了， 在运行程序的时候，我们希望将我们需要的数据放在靠近金字塔顶端的Cache中，把我们不要的数据放在底层磁盘当中。这样，只有在进行数据交换的时候，才会到磁盘当中去取，时间才会变慢。</p>
<p>这就好像一个贪心算法，根据局部性原理，当我们访问过一个数据之后，我们就可以将其放在上层cache中，因为将来很可能再会用到。也就是说，上层是下层的缓存。</p>
<h3 id="存储器层次结构中的缓存"><a href="#存储器层次结构中的缓存" class="headerlink" title="存储器层次结构中的缓存"></a>存储器层次结构中的缓存</h3><p>一般而言，高速缓存(cache)是一个小而快速的存储设备，它作为存储在更大、也更慢的设备中的数据对象的缓冲区域。使用高速缓存的过程称为缓存(caching)</p>
<p>存储器层次结构的中心思想是，对于每个k，位于為层的更快更小的存储设备作为位于k+1层的更大更慢的存储设备的缓存。换句话说，层次结构中的每一层都缓存来自较低一层的数据对象。</p>
<p>比如说这个例子，第k层更小更快也更贵，其只有4个块，缓存着第k+1层块的一个子集。k+1层存储器被划分为16个大小固定的块，编号为 0~15</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/5.png" style="zoom:120%;"></p>
<h4 id="Hit"><a href="#Hit" class="headerlink" title="Hit"></a>Hit</h4><p>接下来我们来介绍一个概念： Hit 命中.简单来说，就是上一级想要的数据，下一级刚好有。比如下面这个例子，顶层的想要数据14，然后发现Cache里面刚好有数据14，那么这就是命中了。</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/7.png" style="zoom:120%;"></p>
<h4 id="Miss"><a href="#Miss" class="headerlink" title="Miss"></a>Miss</h4><p>Miss和Hit相反，也就是说没有命中。比如下面这个例子，上面的数据想要12，而第二层Cache中原来的数据为8、9、14、3并没有12，所以这就是一个Miss。于是Cache又要向下一层Memory里去找数据12，Memory里有12，然后将其提到Cache中去。</p>
<p>那么这就出现了一个问题：我们怎么来决定什么元素应该被替换(上面这个例子中，9被替换)？ 也就是说找到一个Victim。这是在操作系统中要学习的内容，也就是 Replacement policy,也是我们规定的一套标准。</p>
<p> <img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/6.png" style="zoom:120%;"></p>
<h3 id="3-Types-of-Cache-Misses"><a href="#3-Types-of-Cache-Misses" class="headerlink" title="3 Types of Cache Misses"></a>3 Types of Cache Misses</h3><p>我们要知道 ，程序出现了Miss的话，要再向下级去寻找，这就导致运行时间长了很多，是一种严重拉低效率的情况。</p>
<h4 id="Code-compulsory-miss"><a href="#Code-compulsory-miss" class="headerlink" title="Code (compulsory) miss"></a>Code (compulsory) miss</h4><p>顾名思义，就是冷启动。因为我们电脑启动的时候，Cache里面是没有数据的，因此第一次肯定会miss。</p>
<p>所以也说这是 compulsory miss</p>
<h4 id="Capacity-miss"><a href="#Capacity-miss" class="headerlink" title="Capacity miss"></a>Capacity miss</h4><p>Capacity是容量之意，比如说，我每一次循环里面要读取的数据时4个kb，但是一个cache里面的容量只有3k，那么不管怎么访问和优化，都会出现miss的情况。有点捉襟见肘的意思。</p>
<p>容量不够的话，我们可以停止一些程序的运行，以确保急需cache的程序来访问内存。</p>
<h4 id="Conflict-miss"><a href="#Conflict-miss" class="headerlink" title="Conflict miss"></a>Conflict miss</h4><p>举一个例子，假设我们规定，在k+1层的编码为i的block 必须被放到k层编码为(i mod 4) 的block当中，而我们又必须反复去读取0,8,0,8这一串数据，那么虽然说我k层的blocks还没有用完，capacity也是够的，但是每次访问还是会出现miss，因为0，8 mod4都是0，被映射到了同一个对应的block，造成了conflict miss。因此，这种情况是我们需要规避的，我们需要设计良好的机制来减少甚至避免这种情况的发生。</p>
<h2 id="Cache-Memories-高速缓存存储器"><a href="#Cache-Memories-高速缓存存储器" class="headerlink" title="Cache Memories(高速缓存存储器)"></a>Cache Memories(高速缓存存储器)</h2><p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/19.png" style="zoom:120%;"></p>
<p>这就是Cache在CPU中的模拟结构。CPU会首先在cache memory中去找。</p>
<p>下面这幅图是Instruction Cache在CPU中的一些具体的功能</p>
<p><code>Fetch Control</code> 是决定取哪一条指令的，然后再到Cache中去取。</p>
<p><code>Instruction Decode</code> 是将从Cache中取回来的指令变成二进制编码的</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/20.png" style="zoom:120%;"></p>
<h3 id="General-Cache-Organization"><a href="#General-Cache-Organization" class="headerlink" title="General Cache Organization"></a>General Cache Organization</h3><p>cache memory是这样来组织的：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/21.png" style="zoom:120%;"></p>
<p>一个cache里面有若干个set，每个set里面又有若干的cache line。 一个cache里面，有$2^s$个sets，每一个sets里面又有 $2^e$个cache line。这样做的目的是为了编码比较方便。</p>
<p> 每一个cache line内部又分成三个部分，分别是 v,tag和B。</p>
<ul>
<li><p>B就是Cache line里面的存储空间,大小为 $2^b$个 bytes</p>
</li>
<li><p>v只有一位，全称为 valid bit，来标志这个cache line 是否有用。</p>
</li>
<li>tag则是这个cache line的标签。</li>
</ul>
<p>现在我们来做一个小练习：</p>
<p>我们得到了表格中的一部分信息，我们现在要讲表格补齐，因此这里我们需要对地址的划分非常清楚</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">高速缓存</th>
<th>m(位数)</th>
<th>C(cache大小)</th>
<th>B(块大小)</th>
<th>E(cache line总数)</th>
<th>S(Set总数)</th>
<th>t(tag位数)</th>
<th>s(set位数)</th>
<th>b(block位数)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td>32</td>
<td>1024</td>
<td>4</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td>32</td>
<td>1024</td>
<td>8</td>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td>32</td>
<td>1024</td>
<td>32</td>
<td>32</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>C代表了Cache Size 也就是 $S\times E\times B = 1024$  这里我们已经知道了B和E，于是我们可以先填写S。</p>
<ol>
<li>第一个cache 的$S = 1024/4 = 256$，也就是说这个Cache 有256个set</li>
<li>同理，第二个Cache的$S = 1024/(8\times 4) = 32$ ,也就是说这个Cache 有32个set</li>
<li>第三个Cache的$S = 1024/(32\times 32) = 1$,也就是说这是一个全相连的Cache,只有一个Set</li>
<li>知道了 S之后，我们可以根据 $S = 2^s$ 求出小s的值，小s的值即地址空间关于定位Set的位数</li>
<li>知道了B之后，我们可以根据 $B = 2^b$ 求出小b的值，小b的值即地址空间关于定位block偏移量的位数</li>
<li>知道了 s和 b之后，我们就可以知道 t的值，因为$t= m-s-b$ 其中m为地址的总位数，因为地址的总位数只由三个部分 t,s,b组成。</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">高速缓存</th>
<th>m(位数)</th>
<th>C(cache大小)</th>
<th>B(块大小)</th>
<th>E(cache line总数)</th>
<th>S(Set总数)</th>
<th>t(tag位数)</th>
<th>s(set位数)</th>
<th>b(block位数)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td>32</td>
<td>1024</td>
<td>4</td>
<td>1</td>
<td>256</td>
<td>22</td>
<td>8</td>
<td>2</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td>32</td>
<td>1024</td>
<td>8</td>
<td>4</td>
<td>32</td>
<td>24</td>
<td>5</td>
<td>3</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td>32</td>
<td>1024</td>
<td>32</td>
<td>32</td>
<td>1</td>
<td>27</td>
<td>0</td>
<td>5</td>
</tr>
</tbody>
</table>
</div>
<h3 id="读取Cache"><a href="#读取Cache" class="headerlink" title="读取Cache"></a>读取Cache</h3><p>示意图如下：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/22.png" style="zoom:120%;"></p>
<p>现在拿到了一个地址，机器不会直接去内存里去找地址，而是先会在Cache里面寻找，寻找流程如下：</p>
<p>一串地址可以分成三个部分：tag + set index + block offset(偏移量)</p>
<ol>
<li>首先利用set index位来定位这串地址在cache中位于哪一个sets，因为一共有$2^s$ 个sets，所以我们需要用 s位来当我们的索引</li>
<li>在定位到的set中，遍历所有的cache line,查找是否有和我们地址中 tag段相匹配的 cache line</li>
<li>如果找到了这个cache line，并且这个cache line是valid ，那么就说命中cache了</li>
<li>最后通过我们的offset定位到特定的数据</li>
</ol>
<p>定位 set $\Rightarrow $ 匹配tag $\Rightarrow$ 找到byte</p>
<h3 id="Direct-Mapped-Cache-E-1"><a href="#Direct-Mapped-Cache-E-1" class="headerlink" title="Direct Mapped Cache(E=1)"></a>Direct Mapped Cache(E=1)</h3><p>当E等于1的时候，每一个set只有1条cache line，这时这种cache也被称为是 Direct Mapped Cache。假设每个cache line 中的block size B 为8 bytes.那么这个cache的模型就如下图所示：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/23.png" style="zoom:100%;"></p>
<p>这种Cache的查找模式如下：</p>
<p>我们定位到set之后，我们去看tag是否与cache line中的tag相匹配，还要看这个cache line是否valid。同时满足两个条件才能说命中了。如果一开始tag就不匹配，那么这个cache line就是victim，我们要删除它并替换掉。</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/24.png" style="zoom:100%;"></p>
<p>下面是一个模拟的查找情景。我们有一个4位的地址，cache中有4个sets，每一个sets中有一个cache line，每个cache line的Block 空间为 2 bytes 。block里面存放的数据，就是<strong>查找地址指向的数据 </strong>。</p>
<p>查找地址左边一列是地址所代表的十进制数，查找不成功的时候，我们会将这个地址指向的数(前/后两个)放到blocks当中去。</p>
<p>那么我们查找的第一行是 $[0000_2]$ ,所以应该映射到第0个set，这时候cache是空的，所以是cold  miss，然后将这个数据0存储到第一行cache line当中，因为一个cache line可以存储两个bytes，所以我们在将0输入的时候同时也要将0后面的数字1也一并输入</p>
<p>第二行是$[0001_2]$ ，映射到第0个set，这时候cache line是有数据的，然后我们看tag也适合cache line相匹配的，于是这一个地址是 Hit</p>
<p>第三行是$[0111_2]$ ,定位到set3，显然这时候cache line是空的，那么就是 cold miss</p>
<p>第四行是$[1000_2]$, 定位到set0，tag不匹配，所以miss，并且将set0作为victim，将其替换成 $v=1,Tag=1,M[8-9]$</p>
<p>第五行是$[0000_2]$ ,定位到set0，tag又不匹配，所以miss,并且将set0作为 victim,将其替换成$v=1,Tag =0,M[0-1]$ </p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/25.png" style="zoom:100%;"></p>
<h3 id="E-Way-Set-Associative-Cache-组相连的cache"><a href="#E-Way-Set-Associative-Cache-组相连的cache" class="headerlink" title="E-Way Set Associative Cache 组相连的cache"></a>E-Way Set Associative Cache 组相连的cache</h3><p>顾名思义就是说一个set当中有多个cache line,这里取 E=2，每个cacheline当中有8个bytes</p>
<p>那么查找的过程如下：</p>
<p>首先还是找到对应的set</p>
<p>其次同时比较两个cache line 的tag，匹配到哪个进入那个cache，如果两个都不匹配，就是miss，这时候要在两个cache line里面选择一个杀掉</p>
<p>选择哪个cache line有多种方法，可以是随机的，也可以是least recent used(LRU)，即<strong>最近最少使用的cache line</strong>。但是最近最少使用实现起来没有那么简单，如何高效实现是一件比较复杂的事情。</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/26.png" style="zoom:100%;"></p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/27.png" style="zoom:100%;"></p>
<p>我们用一个例子来模拟E=2时，cache的查找情况:</p>
<ol>
<li>第一个 $[0000_2]$ 肯定是miss的，因为这时候cache里面还没有东西。因此，我们把set0中的cache line1存放 $[0000_2]$ 指向的数据$ M[0-1]$</li>
<li>第二行 $[0001_2]$ ，先匹配set0，然后匹配tag 00，匹配成功，于是 hit</li>
<li>第三行 $[0111_2]$ ，先匹配set1，然后匹配tag 01，发现cache line是空的，所以miss</li>
<li>第四行 $[1000_2]$ ，先匹配 set0，然后匹配tag10，发现cache line 是空的，所以miss</li>
<li>第五行 $[0000_2]$ ，先匹配 set0， 然后匹配set0，发现cache line 非空，所以hit</li>
</ol>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/29.png" style="zoom:100%;"></p>
<p>我们看到，读取同样的数据，因为我们的分配方式不同。两路的组相连cache 比 直接写入内存(E=1)少了一次 miss，多了一次hit，因此更加灵活。 </p>
<h4 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h4><p>一个地址，为什么要把tag设为前面几位，而把set设置在中间几位呢？</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/34.png" style="zoom:100%;"></p>
<p>如果把 前面几位设置成set的话，会导致以下这种结果。</p>
<p>set0会在最前面，set1第二……,每一个set中间又是连续的。这样我在一段地址里面进行读写循环，会导致conflict miss的几率大大提高，严重降低机器的运行效率</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/36.png" style="zoom:100%;"></p>
<p>而将Tag放在前面，将set放在中间，那么在一块连续的内存当中，相同set的地址不会挤在一起，从而降低了conflict miss，并提高了机器的运行效率</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/35.png" style="zoom:100%;"></p>
<p>现在我们来做一个小练习：假想一个高速缓存，用地址的高s 位做组索引，那么内存块连续的片(chunk)会被映射到同一个高速缓存组。</p>
<p>A. 每个这样的连续的数组片中有多少个块</p>
<p>B. 考虑下面的代码，它运行在一个高速缓存形式为$(S,E,B,m) = (512,1,32,32)$ 的系统上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">40960</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">4096</span>;i++)</span><br><span class="line">	sum+=<span class="built_in">array</span>[i];</span><br></pre></td></tr></table></figure>
<p>我们首先要知道如果用地址的高s位作为组索引，整个地址的三部分结构如下：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/3.jpg" style="zoom:100%;"></p>
<p>那么随着地址的渐渐增加，我们址答每个连续的数组片(chunk) 是由$2^t$个块组成的，这里t是标记位数。因此，数组头$2^t$ 个块都会映射到组0，而接下来$2^t$ 个块 会被映射到组1，以此类推</p>
<p>对于B小题来说，我们可以轻易地计算出s = 9,b = 5,因此t=32-14=18位，也就是说数组中头 $2^{18}$ 个块会被映射到组0。现在我们来计算数组需要占用多少块。我们的数组只由$(4096*4)/32 =512$ 个块组成，所以数组中所有的块都会被映射到组0。因此在任何时刻高速缓存至多只能保存一个数组块。很明显用高位做索引不能充分利用cache</p>
<h3 id="Cache-Write"><a href="#Cache-Write" class="headerlink" title="Cache Write"></a>Cache Write</h3><p>刚才我们讨论了 cache 的读取，现在我们来讨论一下cache的写入。</p>
<h4 id="Write-Hit"><a href="#Write-Hit" class="headerlink" title="Write-Hit"></a>Write-Hit</h4><p>如果我们要写入的数据在cache line中，这时候叫做cache hit 当我们这时候我们要做一个选择：</p>
<ol>
<li>通写 write-through(write immediately to memory)</li>
</ol>
<p>数据被立即写入磁盘，另外也会在缓存保存一份（用来提升读性能）。</p>
<ol>
<li>回写 write-back(defer write to memory until replacement of line)</li>
</ol>
<p>先写到cache line里, 用回写这种机制的时候，需要在cache line 中添加一个dirty bit(脏位)，这个dirty就代表这行cache line暂时还没有写到磁盘当中去，所以我们在找victim的时候，当我们发现这个cache line 是干净的，那么就直接将其替换即可，如果这行cache line是脏的， 在这时候就要将cache line中的数据存到内存中去。</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/32.png" style="zoom: 120%;"></p>
<p>这两者的差别也可以用图表示出来：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/31.png" style="zoom: 120%;"></p>
<p>回写的优点：</p>
<p>write-back：磁盘写性能高，每次只要写一行cache line 即可</p>
<p>回写的缺点：</p>
<p>wirite-back：系统崩溃或突然断电时，cache中的数据会丢失。有时候另外一个线程在读取数据的时候，可能会导致读取的和写入的不一致。</p>
<p>通写的优点：</p>
<p>读取和写入永远是一致的</p>
<p>通写的缺点:</p>
<p>开销很大</p>
<h4 id="Write-miss"><a href="#Write-miss" class="headerlink" title="Write-miss"></a>Write-miss</h4><p>如果我们要写入的数据没有存放在 cache line当中，那么这时候就是 Write-miss</p>
<p>比如说我在键盘中输入的数据，肯定是cache line中没有的，根据计算机硬件架构体系，这些数据首先会被存入到内存当中。</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/33.png" style="zoom: 120%;"></p>
<ol>
<li>写分配 Write-allocate (将要写入的数据从内存中取出放到cache当中并更新cache line)</li>
<li>非写分配 No-write-allocate (直接写到memory当中，不更新cache)</li>
</ol>
<p>目前的系统常用的机制是 ：write-back + write-allocate </p>
<h2 id="Cache-Performance-Metrics"><a href="#Cache-Performance-Metrics" class="headerlink" title="Cache Performance Metrics"></a>Cache Performance Metrics</h2><h4 id="Miss-rate"><a href="#Miss-rate" class="headerlink" title="Miss rate"></a>Miss rate</h4><p>Miss rate = 1- Hit rate ，因为一次访问存取要么miss 要么 hit</p>
<p>一般情况下， L1 cache 的miss rate是 3%-10%</p>
<p>L2 cache 的miss rate 一般在 1% 以下。</p>
<h4 id="Hit-Time"><a href="#Hit-Time" class="headerlink" title="Hit Time"></a>Hit Time</h4><p>Hit Time即当我命中cache 和从cache 中取到数所花费的时间，包括了查找set，匹配tag的时间</p>
<p>比较典型的例子：</p>
<p>对于L1 cache 来说，是4个运行周期</p>
<p>对于L2 cache 来说，是10个运行周期</p>
<h4 id="Miss-Penalty"><a href="#Miss-Penalty" class="headerlink" title="Miss Penalty"></a>Miss Penalty</h4><p>当我们出现 miss的情况，需要大概50-200个运行周期去从内存中取得我们的数据。</p>
<p>问题：为什么不用hit rate 而用 miss rate？</p>
<p>因为用户更关心的是平均访问的时间，对于hit rate来说，其值一般在90%以上，那么当hit rate 相差 1% 的时候，比如从97%提升到99%，看上去这两个数相差了2%，以为提升的幅度很小；而事实上miss rate却从3%降到了1%，机器的性能提升了不止一倍。假设一共有100次cache 读取，之前是3*200+97*4 而现在变成了 1*200+99*4，相差接近3倍，这是hit rate反映不出来的，而miss rate从3%降至1%则能体现出这种倍数差距。</p>
<p>miss rate在0%-10%所反映的和电脑实际性能之间基本上是呈线性关系的，但是显然 hit rate 并不是线性关系。</p>
<h3 id="The-memory-mountain-内存山"><a href="#The-memory-mountain-内存山" class="headerlink" title="The memory mountain 内存山"></a>The memory mountain 内存山</h3><p>内存山是整本书最有代表性的</p>
<ul>
<li>Read throughput 读的带宽<ul>
<li>也就是从内存中每秒能读取多少数据</li>
</ul>
</li>
<li>Memory mountain：我们运行一个能反应空间局部性和时间局部性对读取吞吐量变化的函数，然后将其可视化出来</li>
</ul>
<p>测试原理如下：</p>
<p>stride是步长，此外，我们还定义了2倍步长，3倍步长和4倍步长. 每一次我们加上1、2、3、4倍步长</p>
<p>data数组总的长度是elems，因为要保证加上4倍步长不能冲出数组，所以循环到 length-sx4这个长度为止</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> data[MAXELEMS]; <span class="comment">/* Global array to traverse */</span></span><br><span class="line"><span class="comment">/* test - Iterate over first "elems" elements of</span></span><br><span class="line"><span class="comment">* 			array "data" with stride of "stride“,</span></span><br><span class="line"><span class="comment">* 			using 4x4 loop unrolling.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> elems, <span class="keyword">int</span> stride)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> i, sx2=stride*<span class="number">2</span>, sx3=stride*<span class="number">3</span>, sx4=stride*<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">long</span> acc0 = <span class="number">0</span>, acc1 = <span class="number">0</span>, acc2 = <span class="number">0</span>, acc3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> length = elems, limit = length - sx4;</span><br><span class="line">    <span class="comment">/* Combine 4 elements at a time */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; limit; i += sx4) &#123;</span><br><span class="line">        acc0 = acc0 + data[i];</span><br><span class="line">        acc1 = acc1 + data[i+stride];</span><br><span class="line">        acc2 = acc2 + data[i+sx2];</span><br><span class="line">        acc3 = acc3 + data[i+sx3];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Finish any remaining elements */</span></span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">  		acc0 = acc0 + data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((acc0 + acc1) + (acc2 + acc3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跑之前先要测试一遍，来把cache 填满，因为cache 之前是空的</p>
<p>acc1，2，3，4每次循环都会被调用，所以他们几乎不会出寄存器，data数组在内存当中，每次访问的是 data[i+xstride]，因为data数组是在内存中连续存储的，因此 stride越大，说明空间局部性越弱；stride越小，代表空间局部性越强</p>
<p> <img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/38.png" style="zoom: 120%;"></p>
<p>下面是根据吞吐量画出来的内存山：吞吐率越高，性能越好，吞吐率越低，性能越差。</p>
<p>当步长较小的时候，即使是好几倍的步长，也跳不出 L1 cache，因此吞吐量始终维持在一个很高的水平。(黄色部分)</p>
<p>但随着步长的增加，读取的时候会跳出L1 cache，进入L2 cache 或者 L3 cache，这时候吞吐量就下了一个很大的台阶。表现为橙色和紫色部分。</p>
<p>当步长达到一定程度的时候，我们发现吞吐率不会下降了，这是因为每次读取都是cache miss，必须回到内存中去读取，所以速度最慢。表现为深蓝色部分</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/37.png" style="zoom: 120%;">,</p>
<h3 id="Rearrangeing-loops-to-improve-spatial-locality-提升空间复杂度"><a href="#Rearrangeing-loops-to-improve-spatial-locality-提升空间复杂度" class="headerlink" title="Rearrangeing loops to improve spatial locality(提升空间复杂度)"></a>Rearrangeing loops to improve spatial locality(提升空间复杂度)</h3><p>我们用矩阵乘法来举例子，最基本的矩阵乘法的写法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ijk */</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">        sum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (k=<span class="number">0</span>; k&lt;n; k++)</span><br><span class="line">        sum += a[i][k] * b[k][j];</span><br><span class="line">        c[i][j] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据类型都是long ,也就是8个bytes，算法的复杂度为 $O(N^3)$ </p>
<p>现在我们来分析一下 矩阵乘法的miss rate</p>
<p>我们对矩阵和cache提出这些假设：</p>
<ul>
<li>Block size = 32B</li>
<li>矩阵的边长(N)非常大，1/N 接近于0 (如高分辨率的图片)</li>
<li>矩阵大到连cache都放不下一行数据</li>
</ul>
<p><strong>分析方法</strong></p>
<p>我们对最内层循环进行分析：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/39.png" style="zoom: 100%;"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">	sum += a[<span class="number">0</span>][i];</span><br></pre></td></tr></table></figure>
<p>我们知道，C语言中的数组是按照行存放的。每次循环访问的都是同一行的数字，因此这个循环对于a矩阵的局部性是非常好的。但是因为这个数组的边非常大，cache都放不下，因此还是存在一定的 miss rate。这个miss rate 可以由 $\frac{sizeof(a<em>{ij})}{B}$ 来计算(B指Block的大小)，也就是说每访问$ B/ sizeof(a</em>{ij})$ 个数据后，会出现 一次miss。</p>
<p>但是如果稍微改一下算法，虽然不改变最终结果和算法的复杂度，但是也会让局部性变得很差</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	sum += a[i][<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>比如改成上面这样子，每次跳一行来读取一个数字，因为cache 放不下一行，所以必然每次都会出现miss，因此这个算法的miss rate = 1，局部性非常差</p>
<h4 id="三种不同的矩阵乘法的写法"><a href="#三种不同的矩阵乘法的写法" class="headerlink" title="三种不同的矩阵乘法的写法"></a>三种不同的矩阵乘法的写法</h4><p><strong>Matrix Multiplication (ijk)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ijk */</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">        sum = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (k=<span class="number">0</span>; k&lt;n; k++)</span><br><span class="line">            sum += a[i][k] * b[k][j];</span><br><span class="line">        c[i][j] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/43.png" style="zoom: 100%;"></p>
<p>Block = 32B, 数据类型为long  </p>
<p>这个miss rate可以这样来计算：</p>
<p>对于A矩阵：每次访问四个数据出现一次miss ，miss rate = 0.25</p>
<p>对于B矩阵：每次都是跳了一行，因此 miss rate = 1</p>
<p>对于C矩阵：只要求在指定位置写入即可，miss rate = 0</p>
<p>avg misses/iter = 1.25</p>
<p><strong>Matrix Multiplication (kij)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (k=<span class="number">0</span>; k&lt;n; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    r = a[i][k];</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">    	c[i][j] += r * b[k][j];	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/42.png" style="zoom: 100%;"></p>
<p>这个矩阵乘法比较奇怪</p>
<p>在最里面的循环，a矩阵并不要进行操作，因此其miss rate = 0</p>
<p>对于B矩阵和C矩阵移动的是j，因此他们的miss rate  = 0.25</p>
<p>avg misses/iter = 0.5</p>
<p><strong>Matrix Multiplication (jki)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* jki */</span></span><br><span class="line"><span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (k=<span class="number">0</span>; k&lt;n; k++) &#123;</span><br><span class="line">    r = b[k][j];</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    	c[i][j] += a[i][k] * r;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/41.png" style="zoom: 100%;"></p>
<p>这种算法的局部性最差，A矩阵和C矩阵都是跳行访问的，miss rate = 1.0,而B是固定的，miss rate =0</p>
<p>avg misses/iter = 2.0</p>
<p>从实验数据上也可以看到这个差别：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/40.png" style="zoom: 100%;"></p>
<h4 id="Using-Blocking-to-improve-temporal-locality-时间复杂度"><a href="#Using-Blocking-to-improve-temporal-locality-时间复杂度" class="headerlink" title="Using Blocking to improve temporal locality(时间复杂度)"></a>Using Blocking to improve temporal locality(时间复杂度)</h4><p>我们还是拿矩阵乘法来举例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">c = (<span class="keyword">double</span> *) <span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">double</span>), n*n);</span><br><span class="line"><span class="comment">/* Multiply n x n matrices a and b */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmm</span><span class="params">(<span class="keyword">double</span> *a, <span class="keyword">double</span> *b, <span class="keyword">double</span> *c, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k++)</span><br><span class="line">            	c[i*n + j] += a[i*n + k] * b[k*n + j];	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/44.png" style="zoom: 100%;"></p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/45.png" style="zoom: 100%;"></p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/46.png" style="zoom: 100%;"></p>
<p><strong>Blocking Summary</strong></p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/47.png" style="zoom: 100%;"></p>
<h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>下列三个函数，以不同的空间局部性成都，执行相同的操作，请对这些空间函数就空间局部性进行排序。并解释如何得到排序结果</p>
<p>a) structs 数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> N 1000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> vel[<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">int</span> acc[<span class="number">3</span>];</span><br><span class="line">&#125;<span class="built_in">point</span>;</span><br><span class="line"><span class="built_in">point</span> p[N];</span><br></pre></td></tr></table></figure>
<p>b) clear1 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear1</span><span class="params">(<span class="built_in">point</span> *p,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i ,j ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">        	p[i].vel[j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>；j &lt; <span class="number">3</span>j j++)</span><br><span class="line">        	p[i].acc[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c) clear2 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear2</span><span class="params">(<span class="built_in">point</span> *p, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i ,j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</span><br><span class="line">        p[i].vel[j] = <span class="number">0</span>;</span><br><span class="line">        p[i].acc[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>d) clear 3数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    	p[i].vel[j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">   		p[i].acc[j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道判断空间局部性的好坏，就要看步长、扫描顺序。首先我们画出struct的结构如下：</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/2.jpg" style="zoom: 100%;"></p>
<p>我们先来看看clear1，它以步长为1的引用模式访问vel数组和acc数组，因此明显地具有最好的空间局部性。</p>
<p>clear2和clear1一样，是依次扫描N个结构中的一个，但是在每个结构当中步长并不为1，比如当j = 0的时候，vel[j] 偏移量为0，而acc[j] 的偏移量为12。所以说clear2的空间局部性比clear1要更差一些。</p>
<p>函数clear3不仅在每个结构当中跳来跳去，而且还要从结构跳到结构，所以clear3的空间局部性比clear2和clear1都要差</p>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>在信号处理和科学计算的应用中，转置矩阵的行和列是一个很重要的问题。从局部性的角度来看，它也很有趣，因为它的引用模式既是以行为主 (wise)的，也是以列为主(column-wise)的。例如，考虑下面的转置函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transpose1</span><span class="params">(<span class="built_in">array</span> dst, <span class="built_in">array</span> src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">        	dst[j][i] = src[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设在一台具有如下属性的机器上运行这段代码</p>
<ul>
<li>sizeof(int) =4</li>
<li>src数组从地址0开始，dst数组从地址16(十进制)开始</li>
<li>只有一个L1告诉数据缓存，他是直接映射的、直写的和写分配的。块的大小为8个字节</li>
<li>这个高速缓存总的大小为16个数据字节(16 data bytes)，一开始是空的</li>
<li>对 src和dst数组的访问分别是读和写不命中的唯一来源</li>
</ul>
<p>A.对每个row和col,指明对$src[row][col]$和 $dst[row][col]$ 的访问时命中还是不命中。例如，读$src[0][0]$ 会不命中，写$dst[0][0]$ 也不会命中</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/4.jpg" style="zoom: 100%;"></p>
<p>首先我们要画出src和dst的图像，如上图所示。这里注意，每个高速缓存行只包含数组的一个行，杠苏缓存正好只能够保存一个数组。而且对于所有的i，src和dst的行i是映射到同一个高速缓存行的。但是我们发现Cache是肯定不够大的，所以对一个数组的引用总是要驱逐另一个数组的有用的行。</p>
<p>比如说对 $dst[0][0]$ 写会驱逐当我们读 $src[0][0]$ 时加载进来的那一行。所以当我们接下来读取$src[0][1]$ 时，会有一个不命中。</p>
<p>B. 对于一个大小为32数据字节的Cache重复这个练习</p>
<p>当高速缓存为32字节的时候，它足够大，并能容纳这两个数组。因此，所有的不命中都是开始时的冷不命中。</p>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>最近一个很成功的游戏SimAquarium 的核心就是一个紧密循环（tight loop), 它计算256 个海藻(algae)的平均位置。在一台具有块大小为16 字节(B=16) .整个大小为1024 字节的直接映射数据缓存的机器上测量它的高速缓存性能。定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct algae_position &#123;</span><br><span class="line">	int x;</span><br><span class="line">	int y;</span><br><span class="line">&#125;</span><br><span class="line">struct algae.position grid[16][16];</span><br><span class="line">int total_x &#x3D; 0, totally &#x3D; 0;</span><br><span class="line">int i, j;</span><br></pre></td></tr></table></figure>
<p>还有如下假设：</p>
<ul>
<li>sizeof(int) = 4</li>
<li>grid 从内存地址0开始</li>
<li>这个高速缓存开始时是空的</li>
<li>唯一的内存访问时对数组grid的元素的访问。变量 i，j,total_x和total_y 存放在寄存器当中</li>
</ul>
<p>确定下面代码的高速缓存性能：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">31</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">    	total_x += grid[i][j].x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">31</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">    	total_y += grid[i][j].y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们要画出这struct的结构和整一个struct数组的样子</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/5.jpg" style="zoom: 100%;"></p>
<p>每个16字节的高速缓存包含着两个连续的algae_position 结构。每个循环按照内存的访问顺序访问这些结构，每次读一个整数元素。所以每个循环的模式就是不命中、命中、不命中、命中，依次类推。这里我们不必实际列举出读和不命中的总数就能预测出不命中率为50%</p>
<p>A. 读总数是多少？</p>
<p>读的总数为 16*16 = 256</p>
<p>B. 缓存不命中的读总数是多少？</p>
<p>缓存不命中的总数是256</p>
<p>C. 不命中率是多少？ 50%</p>
<h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>给定上面的四条假设</p>
<ul>
<li>sizeof(int) = 4</li>
<li>grid 从内存地址0开始</li>
<li>这个高速缓存开始时是空的</li>
<li>唯一的内存访问时对数组grid的元素的访问。变量 i，j,total_x和total_y 存放在寄存器当中</li>
</ul>
<p>确定下列代码的高速缓存性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line">        total_x += grid[j][i].x;</span><br><span class="line">        total_y += grid[j][i].y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A. 读总数是多少？512<br>B. 高速缓存不命中的读总数是多少？ 256</p>
<p>如图所示：</p>
<p>C. 不命中率是多少？50%<br>D. 如果高速缓存有两倍大，那么不命中率会是多少呢？如果高速缓存有现在的两倍大，那么它能保存整个grid数组。所有的不命中都会是开始时的冷不命中，而不命中的概率会降低到25%</p>
<p>确定下面代码的高速缓存性能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line">        total_x += grid[i][j].x;</span><br><span class="line">        total_y += grid[i][j].y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个循环有很好的步长为1的引用模式，因此所有的不命中都是最开始时的冷不命中。</p>
<p>A. 读总数是多少？512<br>B. 高速缓存不命中的读总数是多少？ 128</p>
<p>C. 不命中率是多少？ 25%<br>D.如果高速缓存有两倍大，那么不命中率会是多少呢？无论高速缓存的大小增加多少，还是会冷命中，因此不会改变不命中率，因为冷不命中时不可能避免的。</p>
<h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>假设我们再下列条件下执行代码中的三个求和函数</p>
<ul>
<li>sizeof(int) = 4</li>
<li>机器有4KB直接映射的高速缓存，块大小为16字节</li>
<li>在两个循环中，代码只对数据进行内存访问。循环索引和值sum都存放在寄存器当中</li>
<li>数组a从内存地址 0x8000000处开始存储 </li>
</ul>
<p>对于N=64和N=60 这两种情况，在表中填写他们大概的高速缓存不命中率</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/50.png" style="zoom: 100%;"></p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/51.png" style="zoom: 100%;"></p>
<p>当N=64的时候首先我们要画出cache的草图和数组的草图</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/7.jpg" style="zoom: 100%;"></p>
<p> 因为数组的大小为cache的4倍，而cache又是直接映射的缓存，所以每次存储255个block就要从头开始，一共四次。所以对于前1/4个数组，出现的是cold miss，而且miss一次会hit3次。后面3/4个数组出现的是conflict miss，但也是miss一次hit3次。因此 miss rate = 25%</p>
<p><img src="/2020/11/14/CSAPP%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/52.png" style="zoom: 100%;"></p>
<p>对于 sumB，它的局部性是比较差的，read cache order如下：</p>
<p>我们是按照 $a[0][0],a[1][0],a[2][0]$这样的顺序访问的，每次跳一行，一行64*4=256个字节，也就是会跳16个block，因此一开始的时候我们是读取第 $0,16,32…240$ 个cache的，但是这样还只到$a[15][0]$ 当读取$a[16][0]$ 的时候又会返回到第0个cache</p>
<p>0,16,32…240(4times);1,17,33,…241,(4 times)…;15,31,47,…255 (4 times)</p>
<p>对于 sumC</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i+=<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j+=<span class="number">2</span>)</span><br><span class="line">    sum += (a[j][i] + a[j][i+<span class="number">1</span>] + a[j+<span class="number">1</span>][i] + a[j+<span class="number">1</span>][i+<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<p>如果读取了$a[j][i],a[j+1][i]$ 那么 $a[j][i+1],a[j+1][i+1]$肯定是hit的</p>
<p>因此我们可以简化成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i+=<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j+=<span class="number">2</span>)</span><br><span class="line">    sum += (a[j][i] + a[j+<span class="number">1</span>][i]);</span><br></pre></td></tr></table></figure>
<p>上面这个函数和下面这个函数是等价的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i+=<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">    sum += a[j][i];</span><br></pre></td></tr></table></figure>
<p>这和sumB类似，但是因为$i+=2$,所以read cache order只做了2次循环</p>
<p>因此对于这个函数，missrate = 50%，但同时，对于原函数miss count = $64/2<em>64</em>50\% $ = 64*64/4</p>
<p>所以missrate仍然是25%</p>
<p>如果 N=60 的话，那么 对于 sumA和sumC都和 N=64是一样的，为25%</p>
<p>let’s see first inner loop $a[0][0] -&gt; a[59][0]$</p>
<p>read memory address order:</p>
<p>0, 60*4, 60*4*2, …. 60*4*59</p>
<p>read cache order:</p>
<p>0, 15, 30, …., 225, (17 numbers) 255, 14, 29, ….., 224, (17 numbers) 254, 13, 28, ….., 223, (17 numbers) 253, 12, 27, 42, 57, 72, 87, 102, 117 (9 numbers)</p>
<p>all read miss and store into different blocks</p>
<p>next 3 loops: $a[0][1] -&gt; a[59][1], a[0][2] -&gt; a[59][2], a[0][3] -&gt; a[59][3]$</p>
<p>all hit</p>
<p>althrough N is smaller and not power of 2, miss rate is still 25%</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" itemprop="url">人工神经网络</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-07T22:24:57+08:00">
                2020-11-07
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2021-12-02T22:46:48+08:00">
                2021-12-02
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="人工神经网络"><a href="#人工神经网络" class="headerlink" title="人工神经网络"></a>人工神经网络</h1><h2 id="感性认识"><a href="#感性认识" class="headerlink" title="感性认识"></a>感性认识</h2><h3 id="神经元"><a href="#神经元" class="headerlink" title="神经元"></a>神经元</h3><p>首先我们来讲讲 Neuron 神经元。他是组成神经网络的基本结构。</p>
<p>我们都知道生物上的神经元，即神经细胞是长什么样的。深度学习的目标就是模拟大脑的运行，但是我们怎么用机器来模拟神经元呢? </p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/1.png" style="zoom:150%;"></p>
<p>这是一个神经元的模型，树突和轴突就是用来传递神经信号的。(高中生物？？？？)</p>
<p>我们可以用一个简图来模拟上述操作：</p>
<p>第一层黄色的神经元是信号输入层 。在人类的大脑中，输入层就是我们的各种感觉：视觉、听觉、触觉等，而大脑中的神经元则是用来处理这些器官采集到的电信号的。对于机器，输入一些数据(自变量)，通过神经元产生一个输出值</p>
<p>第二层绿色就是神经元，扮演着我们大脑的角色。我们也叫其隐藏层</p>
<p>第三层是红色的输出值。神经元处理好输入数据后传出一个输出值，并更进一步地传递给下一层</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/2.png" style="zoom:100%;"></p>
<p>在输入层的内部结构是这样的：</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/3.png" style="zoom:100%;"></p>
<p>这些自变量都是指每一次观测得到的值，我们可以将其想象成是数据表里的一行数据。我们将用这些数据来训练我们的神经网络模型。但是需要注意的是，在应用他们之前，我们需要将它们标准化(stand)——即让他们平均值为0，方差为1 / 归一化(normalize)—-即让数据分布在0-1之间的值。</p>
<p>输出值可以是以下几种类型：可以是连续的值，也可以是二进制数，还可以是一个分类变量(如果是分类变量，那么就代表有多个输出值)</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/4.png" style="zoom:100%;"></p>
<p>接下来我们要讲的是突触(synapses) ，每一个突触都被赋予了一个权重。权重对神经网络非常重要，神经网络就是通过这些权重来学习的。通过计算和改变权重，神经网络决定在每一次计算中对于某个神经元的哪一个信号比较重要、哪个比较不重要，以及哪个信号可以传递下去、那个信号应该被屏蔽等等</p>
<p>所以权重非常关键，当我们在训练神经网络的时候基本上就是在调节权重，这也是为什么我们要学梯度下降和反向传播算法的原因了</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/5.png" style="zoom:100%;"></p>
<p>最后我们来讲讲神经元，神经元里到底发生了什么？</p>
<p>第一步，神经元会将  输入值* 权重 求和</p>
<p>$\sum_{i=1}^{m}w_ix_i$  </p>
<p>第二步，运用激活函数 $\phi(\sum_{i=1}^m w_ix_i)$ ,这样神经元就可以知道它是否需要让一个信号通过</p>
<p>第三步，如果神经元决定通过这个信号，那么它就会将其输出给下一个神经元</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/6.png" style="zoom:100%;"></p>
<p>神经元综合的输入信号和偏置（符号为 -1~1）相加之后产生当前<strong>神经元最终的处理信号</strong>net，该信号称为<strong>净激活或净激励</strong>（net activation），激活信号作为上图中圆圈的右半部分f（<em>）函数的输入，即f(net)； f称为<strong>激活函数或激励函数</strong>（Activation Function），<em>*激活函数的主要作用是加入非线性因素，解决线性模型的表达、分类能力不足的问题</em></em>。上图中y是当前神经元的输出。</p>
<h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p>激活函数有很多很多种，我们这里讲四种比较常用的激活函数</p>
<h4 id="Threshold-Function-阈值函数"><a href="#Threshold-Function-阈值函数" class="headerlink" title="Threshold Function 阈值函数"></a>Threshold Function 阈值函数</h4><p>阈值函数很简单，y轴只有0或者1。如果输入阈值函数的值权重和小于0的话，阈值函数输出0；如果大于0，则输出1.</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/7.png" style="zoom:100%;"></p>
<h4 id="Sigmoid-Function"><a href="#Sigmoid-Function" class="headerlink" title="Sigmoid Function"></a>Sigmoid Function</h4><p>这个函数的优点是一条光滑的曲线，当输入值小于0的时候，y接近0；当输入值大于0的时候，y接近1</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/8.png" style="zoom:100%;"></p>
<h4 id="Rectifier-function-ReLU"><a href="#Rectifier-function-ReLU" class="headerlink" title="Rectifier function(ReLU)"></a>Rectifier function(ReLU)</h4><p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/9.png" style="zoom:100%;"></p>
<p>Rectifier function 是近来比较流行的激活函数，当输入信号小于0时，输出为0；当输入信号大于0时，输出等于输入。</p>
<p>ReLU的优点：</p>
<ol>
<li><p>ReLU是部分线性的，并且不会出现过饱和的现象，使用ReLU得到的随机梯度下降法（SGD）的收敛速度比Sigmodi和tanh都快。</p>
</li>
<li><p>ReLU只需要一个阈值就可以得到激活值，不需要像Sigmoid一样需要复杂的指数运算。</p>
</li>
</ol>
<p>ReLU的缺点：</p>
<p>在训练的过程中，ReLU神经元比价脆弱容易失去作用。例如当ReLU神经元接收到一个非常大的的梯度数据流之后，这个神经元有可能再也不会对任何输入的数据有反映了，所以在训练的时候要设置一个较小的合适的学习率参数。</p>
<h4 id="tanh"><a href="#tanh" class="headerlink" title="tanh"></a>tanh</h4><p>tanh是Sigmoid函数的变形，tanh的均值是0，在实际应用中有比Sigmoid更好的效果。</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/10.png" style="zoom:100%;"></p>
<p>拓展资料： <a href="http://jmlr.org/proceedings/papers/v15/glorot11a/glorot11a.pdf" target="_blank" rel="noopener">http://jmlr.org/proceedings/papers/v15/glorot11a/glorot11a.pdf</a></p>
<p>现在我们来做两个练习：</p>
<p>假设我们的输出值只为0或者1，那么我们应该怎么选择激活函数？</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/11.png" style="zoom:100%;"></p>
<p>我们可以选择两种，第一种就是Threshold 激活函数，因为y轴只能是0或者1；第二种则是sigmoid函数,用它来表示取到0或者1的概率。</p>
<p>第二个练习是一个应用，假设我们的神经网络长这样:</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/12.png" style="zoom:100%;"></p>
<p>一般，我们先用整流函数(ReLU) 再使用 sigmoid函数</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/13.png" style="zoom:100%;"></p>
<p>即在隐藏层使用ReLU，在输出层使用Sigmoid函数</p>
<h3 id="神经网络如何工作"><a href="#神经网络如何工作" class="headerlink" title="神经网络如何工作"></a>神经网络如何工作</h3><p>现在我们来看一个实例，看看可以如何应用神经网络来解决一些实际的问题</p>
<p>我们将用房地产评估的例子来作为介绍。看看怎么把房地产的参数引入神经网络并预测房地产的价值</p>
<p>我们暂时不讲怎么训练这个神经网络，假设它已经被训练好了，仅仅来看看神经网络是怎么来预测的。</p>
<p>我们假设，一个房地产的价格和四个参数有关：</p>
<ul>
<li>Area面积</li>
<li>Bedrooms 卧室数目</li>
<li>Distance to city 离市中心多远</li>
<li>Age 房龄</li>
</ul>
<p>这四个变量将是我们的输入值，输出值是房子的预估价值。</p>
<p>如果没有隐藏层，那么整个模型长这样：可以简单地给它们一个权重，然后price直接等于权重和</p>
<p>这个模型也是大多数机器学习中回归算法的模型</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/14.png" style="zoom:100%;"></p>
<p>这就是神经网络的强大之处，即使没有隐藏层，也可以进行一些预测。隐藏层让整个模型变得更加灵活和强大。能提高预测的准确率。</p>
<p>现在我们加入隐藏层：</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/1.jpg" style="zoom:100%;"></p>
<p>现在假设四个参数都和隐藏层的第一个神经元有突触，这些突触上有不同的权重。</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/2.jpg" style="zoom:100%;"></p>
<p>我们看到对于第一个神经元，它只关注 Area和Distance to City，也就是说它认为这两个参数对房价的影响比较大。这个神经元的职能就是来寻找离城市不远同时面积又大的房产。当这两个参数达到一定水平的时候，激活函数就会激活这个神经元并输出信号并最终影响到输出层的价格。因此，这个神经元并不在乎卧室的数目和房产的年龄。这也是为什么神经网络如此强大的原因：我们拥有很多这样的神经元，每个神经元各司其职——我们也将会看看其他的神经元如何操作</p>
<p>我们来看下一个位于中间位置的神经元：中间这个神经元的输入为三个数据：住房面积，房间个数和房龄。这可能是因为在对数据集进行训练时，神经网络发现这三个数据之间有特定的联系：比如在某一个地区一个家庭拥有很多孩子，常常在找房龄较小、卧室比较多、住房面积又比较大的。所以这个神经元可能就认为一个住房面积比较大的，卧室数目大于3个的，房子又比较新的房型在这个房地产市场非常吃香，于是满足条件的就会通过激活函数把神经元激活。</p>
<p> <img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/3.jpg" style="zoom:100%;"></p>
<p>还有可能是这样一个情况：一个神经元仅仅接收来自一个输入层的数据：Age<br>这可能是因为这个神经元认为房龄的长短对房价的影响比较重要 。比如说有些老房子比较破，房价会低；新房子房价会高。但是有些房子(如上海花园洋房) 是历史遗留财产，价格可能又会更高一些。</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/4.jpg" style="zoom:100%;"></p>
<p>这就是神经元的例子，他会发现我们用肉眼很难发现的规律。 隐藏层提高了整个神经网络模型的灵活性，能找到那些特别的特征并将它们结合起来考虑。每一个神经元都不能完整预测出房价，但把它们放在一起，可能就会得到意想不到的结果。</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/5.jpg" style="zoom:100%;"></p>
<h3 id="神经网络如何学习"><a href="#神经网络如何学习" class="headerlink" title="神经网络如何学习"></a>神经网络如何学习</h3><p>这里有一个基本的神经网络模型，隐藏层只有一个神经元。它被称为：“单层前馈神经网络”，也叫感知机“perception”。这个模型的输出值是 $\hat y$ ，但这并不是真实值，真实值是y，两者之间存在一个较大的误差。这个误差我们用一个 cost function(损失函数) 来衡量。损失函数有很多种，最常用的就是 $C= \frac{1}{2}(\hat y - y)^2$  .在图像上用柱形图表示如下:</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/15.png" style="zoom:100%;"></p>
<p>我们的目标就是让损失函数的值尽可能地小，因为其值越小， $\hat y$ 与 $y$ 就越接近，神经网络的学习效果也就越好。所以机器在比较了y与 $\hat y$ 之后，将其差值反馈给神经网络(紫色箭头)，然后神经网络会通过这个信息来更新权重以减少两者之间的差值。所以在神经网络中我们唯一能<strong>控制</strong> 的就是<strong>各个突触的权重</strong> </p>
<p>我们多次输入同一行数据，让权重不断调节，努力减小损失函数的值。</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/16.png" style="zoom:100%;"></p>
<p>但事实上，一个数据集不可能只有一行数据，完整的数据集如下：</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/17.png" style="zoom:100%;"></p>
<p>我们要把这些数据都输入到神经网络当中，并得到 $\hat y$ 。随后，我们再将真实的数据用绿色柱体渲染上去。如下图：</p>
<p>(这里实际上只有一个神经元，只是重复了8次)</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/18.png" style="zoom:100%;"></p>
<p>然后我们计算损失函数 $C = \sum \frac{1}{2}(\hat y-y)^2$  的值，并将其反馈给神经元来让其更新权重。</p>
<p>我们的目标是最小化损失函数，一旦我们找到了损失函数的最小值，就说明整个模型已经训练完毕</p>
<p>拓展资料：</p>
<p><a href="https://stats.stackexchange.com/questions/154879/a-list-of-cost-functions-used-in-neural-networks-alongside-applications" target="_blank" rel="noopener">https://stats.stackexchange.com/questions/154879/a-list-of-cost-functions-used-in-neural-networks-alongside-applications</a></p>
<h3 id="梯度下降和随机梯度下降"><a href="#梯度下降和随机梯度下降" class="headerlink" title="梯度下降和随机梯度下降"></a>梯度下降和随机梯度下降</h3><p>我们现在来看，这些权重是怎么被调整的。</p>
<p>要降低代价函数的值，最笨的方法就是取很多不同的权重，然后比较哪些权重组合比较好。 但是随着神经元的增加、突触会变得很多，我们就会被迫遇到 维数困难(Curse of Dimensionality) .比如说我们有25个权重，对每个权重我们可以取1000个不同的值，那么$1000^{25}$ 就等于 $10^{75}$   次计算，这是一个天文数字</p>
<p>所以我们需要用到梯度下降算法，简单的来说我们就要对损失函数求导并判断其在递增还是递减，一直找到损失函数最低点处。</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/20.png" style="zoom:100%;"></p>
<p>对于一个2维空间，我们可以这样来画</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/21.png" style="zoom:100%;"></p>
<p>同样，对于3维空间，如下所示：</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/22.png" style="zoom:100%;"></p>
<p>那么随机梯度下降是什么呢？</p>
<p>比如说我们现在的代价函数长这样：</p>
<p>因为我们可以选择不同类型的代价函数，所以长成这样也是有可能的。</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/23.png" style="zoom:100%;"></p>
<p>那么我们根据正常的梯度下降算法，很可能只找到了一个极小值，并没有找到整个函数的最小值。于是我们需要用随机梯度下降的方法来寻找最低点。对于批量梯度下降，我们将所有行的数据输入，才反馈一个值并更新我们的权重；但是对于随机梯度下降，我们则需要在每次输入一行的时候就反馈一个值并调整权重。</p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/24.png" style="zoom:100%;"></p>
<p>这样就可以帮助我们避免选择极小值。因为随机梯度下降它一次只对一行数据进行操作，具有更大幅度的波动，因此也更容易找到最小值。</p>
<p>具体设计数学的算法逻辑我将在吴恩达的机器学习课程笔记中记载，在这里就不再细说。</p>
<p>拓展文章：<a href="http://iamtrask.github.io/2015/07/27/python-network-part2/" target="_blank" rel="noopener">http://iamtrask.github.io/2015/07/27/python-network-part2/</a></p>
<p><a href="http://neuralnetworksanddeeplearning.com/chap2.html" target="_blank" rel="noopener">http://neuralnetworksanddeeplearning.com/chap2.html</a></p>
<h3 id="反向传播算法"><a href="#反向传播算法" class="headerlink" title="反向传播算法"></a>反向传播算法</h3><p>我们之前说过 Forward Propagation(前向传播)，也就是信息进入输入层后，向前方传播以计算出 $\hat y$ </p>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/25.png" style="zoom:100%;"></p>
<p>那么当计算出代价函数之后，这个代价就会反向传播(Backpropagation) ,这样可以让我们来调整权重。</p>
<p>在这篇文章中，介绍了反向传播算法中的数学原理：<a href="http://neuralnetworksanddeeplearning.com/chap2.html" target="_blank" rel="noopener">http://neuralnetworksanddeeplearning.com/chap2.html</a></p>
<p><strong>用随机梯度下降方法来训练人工神经网络的步骤：</strong></p>
<ol>
<li><p>随机初始化我们的权重，让他们接近于0但是不等于0</p>
</li>
<li><p>输入我们数据集的第一行数据到输入层，让每个特征都对应一个输入节点。</p>
</li>
<li><p>前向传播，从左到右,一直得到 $\hat y$</p>
</li>
<li><p>比较真实值和预测值，计算误差</p>
</li>
<li><p>使用反向传播算法，将误差传播回去。并对每一个权重进行调整</p>
</li>
<li><p>重复步骤一到五并对每行数据都更新我们的权重(强化学习)</p>
</li>
<li><p>当整个训练集数据都已经训练完毕，那么我们称这个神经网络为 epoch(一代)，我们要进行多代的训练，才能让神经网络模型将代价函数降到最小</p>
</li>
</ol>
<h2 id="项目实践"><a href="#项目实践" class="headerlink" title="项目实践"></a>项目实践</h2><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>首先我们导入一些包,我们需要用到numpy,tensorflow,datatime 和 fashion_mnist数据集。这个数据集，来自于kaggle ,网站是： <a href="https://www.kaggle.com/zalando-research/fashionmnist" target="_blank" rel="noopener">https://www.kaggle.com/zalando-research/fashionmnist</a></p>
<p>这个数据集比较大，有七万多幅大小为28*28 的图像，每一张图像中的物品属于一类衣物，一共有10类衣物。分别是：</p>
<ul>
<li>0 T-shirt/top</li>
<li>1 Trouser</li>
<li>2 Pullover 套头衫</li>
<li>3 Dress</li>
<li>4 Coat</li>
<li>5 Sandal 凉鞋</li>
<li>6 Shirt</li>
<li>7 Sneaker</li>
<li>8 Bag</li>
<li>9 Ankle boot</li>
</ul>
<p>我们要做的就是用60000幅图像来训练我们的神经网络并用剩下10000幅当测试集交给神经网络去分类。</p>
<p>最后我们要做的是对测试集的测试结果进行一个评估</p>
<p>因为我们现在构建的是人工神经网络而不是卷积神经网络，神经网络的输入是一维的向量，但是这里我们要处理的对象是28*28的像素。因此我们会修改形状(reshape)，来讲28*28 的二维图像变形称为一个包括784个元素的一维输入向量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.datasets <span class="keyword">import</span> fashion_mnist</span><br></pre></td></tr></table></figure>
<h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><p>接下来，我们要把数据集设置成能被神经网络接受的格式，一共有4步：</p>
<h4 id="loading-the-dataset"><a href="#loading-the-dataset" class="headerlink" title="loading the dataset"></a>loading the dataset</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(X_train,y_train),(X_test,y_test) = fashion_mnist.load_data()</span><br></pre></td></tr></table></figure>
<h4 id="Normalizing-the-images"><a href="#Normalizing-the-images" class="headerlink" title="Normalizing the images"></a>Normalizing the images</h4><p>第二步，我们将图像归一化。我们将训练集和测试集中图像的每个像素除以最大像素数(255)。</p>
<p>这样，每个像素都将在[0,1]范围内。通过对图像进行归一化，我们可以确保我们的模型(ANN)运行得更快。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X_train = X_train / <span class="number">255.0</span></span><br><span class="line">X_test = X_test / <span class="number">255.0</span></span><br></pre></td></tr></table></figure>
<h4 id="Reshaping-the-dataset"><a href="#Reshaping-the-dataset" class="headerlink" title="Reshaping the dataset"></a>Reshaping the dataset</h4><p>第三步，我们将图像变成一维向量的格式以便神经网络能够接受。因为图像的大小为28*28 所以我我们这样来写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X_train = X_train.reshape(<span class="number">-1</span>, <span class="number">28</span>*<span class="number">28</span>)</span><br></pre></td></tr></table></figure>
<p>其中，-1 代表了对所有元素都执行这个操作。</p>
<p>修改完后，X_train的形状从(60000,28,28) 变成了(60000,784) </p>
<h3 id="构建人工神经网络"><a href="#构建人工神经网络" class="headerlink" title="构建人工神经网络"></a>构建人工神经网络</h3><p>现在我们用Tensorflow来构建人工神经网络</p>
<h4 id="Defining-the-model"><a href="#Defining-the-model" class="headerlink" title="Defining the model"></a>Defining the model</h4><p>我们先定义一个 Sequential 模型.(序贯模型)序贯模型是函数式模型的简略版，为最简单的线性、从头到尾的结构顺序，不分叉，是多个网络层的线性堆叠。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = tf.keras.models.Sequential()</span><br></pre></td></tr></table></figure>
<p>接下来我们来一个一个添加神经网络的不同层</p>
<h4 id="Adding-a-first-fully-connected-hidden-layer"><a href="#Adding-a-first-fully-connected-hidden-layer" class="headerlink" title="Adding a first fully-connected hidden layer"></a>Adding a first fully-connected hidden layer</h4><p>第一个是全连接层。全连接层会拥有不同的超参数。因为在 神经网络中，除了寻找最优的权重和偏置等参数，设定合适的超参数也同样重要。比如各层<strong>神经元的数量</strong>、<strong>batch_size的取值</strong>、<strong>参数更新时的学习率</strong>、<strong>权值衰减系数</strong>或学习的epoch等。超参数寻找过程一般会伴随很多试错，所以用尽可能高效的方法找到超参数非常重要。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">model.add(tf.keras.layers.Dense(units=<span class="number">128</span>,</span><br><span class="line">								activation=<span class="string">'relu'</span>, </span><br><span class="line">                                input_shape=(<span class="number">784</span>, )</span><br><span class="line">                               )</span><br><span class="line">         )</span><br></pre></td></tr></table></figure>
<p>我们用 <code>model.add()</code> 的方法来给我们的模型添加一个新的层。这里，我们添加的 fully-connected layer(全连接层)是一个Dense对象，在Dense类中我们又定义了三个参数：units即神经元的个数，activation即我们选择的激活函数，我们这里选的relu即rectifier activate function.(整流激活函数)。 第三个参数即输入参数的形状，input_shape =(784, )及说明这是一个包含了784个元素的向量，因为一幅图画的像素个数就是784。</p>
<h4 id="Adding-a-second-layer-with-Dropout"><a href="#Adding-a-second-layer-with-Dropout" class="headerlink" title="Adding a second layer with Dropout"></a>Adding a second layer with Dropout</h4><p>现在，我们要加入第二层，也就是Dropout层。dropout 是一种正则化技巧，我们会随机将一层中的神经元设为0。通过这种方法，一定比例的神经元会失活从而他们的权重不会再更新。我们添加dropout层就是决定了百分之多少的神经元会失活。这里，我们设置为0.2 意味着20%的神经元将失活</p>
<p>但这不是意味着失活的神经元就没用了，只是说每一次迭代，都只有20%的神经元会失活并停止学习过程，我们这样做的原因是为了避免神经网络过度学习导致过度拟合。因为在训练集上过度学习的画，在测试集上的结果就会很糟糕</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.add(tf.keras.layers.Dropout(<span class="number">0.2</span>))</span><br></pre></td></tr></table></figure>
<h4 id="Adding-the-output-layer"><a href="#Adding-the-output-layer" class="headerlink" title="Adding the output layer"></a>Adding the output layer</h4><p>添加输出层，这个输出层也是一个Dense对象。即神经网络对图像预测的最后分类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model.add(tf.keras.layers.Dense(units=<span class="number">10</span>,</span><br><span class="line">								activation=<span class="string">'softmax'</span>)</span><br><span class="line">		 )</span><br></pre></td></tr></table></figure>
<p>因为 units =10 ,因为我们一共有10类衣服。这里我们使用的是<code>softmax</code>激活函数，因为我们希望通过神经网络来获得每一个类别的概率，利用<code>softmax</code>可以返回最高概率值的分类。</p>
<h4 id="Compiling-the-model"><a href="#Compiling-the-model" class="headerlink" title="Compiling the model"></a>Compiling the model</h4><p>现在我们已经完成了构造神经网络的基本步骤，接下来我们要编译这个模型，也就是将这个神经网络连接到一个优化器上(optimizer),并选择一个损失(loss)</p>
<p>这里，我们的优化器选择的是随机梯度下降算法(推荐)，loss就是预测值和目标之间的误差</p>
<p>因为这不是一个二元分类而是有10类，所以说，我们要填写metrics参数为sparse_categorical_accuracy</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model.compile(optimizer=<span class="string">'adam'</span>,</span><br><span class="line">              loss=<span class="string">'sparse_categorical_crossentropy'</span>,</span><br><span class="line">              metrics=[<span class="string">'sparse_categorical_accuracy'</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.summary()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/26.png" style="zoom:100%;"></p>
<h4 id="Training-the-model"><a href="#Training-the-model" class="headerlink" title="Training the model"></a>Training the model</h4><p>编译好模型之后，我们加入数据，来训练神经网络，我们只要一行代码就能解决训练的问题。</p>
<p>输入训练集的X和y，并输入训练几代神经网络这三个强制参数即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.fit(X_train, y_train, epochs=<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/11/07/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/27.png" style="zoom:100%;"></p>
<p>我们看到随着代数的叠加，模型的准确率越来越高了。但这是训练集内部的准确率，并不是测试集的准确率，接下来我们就要将这个模型应用于测试集并对其进行一个评估    </p>
<h3 id="评估人工神经网络"><a href="#评估人工神经网络" class="headerlink" title="评估人工神经网络"></a>评估人工神经网络</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_loss, test_accuracy = model.evaluate(X_test, y_test)</span><br></pre></td></tr></table></figure>
<p>loss: 0.3490 </p>
<p> accuracy: 0.8736</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;Test accuracy: &#123;&#125;&quot;.format(test_accuracy))</span><br></pre></td></tr></table></figure>
<p>Test accuracy: 0.8736000061035156</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/11/07/Tensorflow%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%BC%A0%E9%87%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/07/Tensorflow%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E4%B8%8E%E5%BC%A0%E9%87%8F/" itemprop="url">Tensorflow常量变量与张量</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-07T10:36:40+08:00">
                2020-11-07
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-11-07T16:06:48+08:00">
                2020-11-07
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Tensorflow常量变量与张量"><a href="#Tensorflow常量变量与张量" class="headerlink" title="Tensorflow常量变量与张量"></a>Tensorflow常量变量与张量</h1><p>我们今天要讲的是Tensorflow2.0的一些基本操作。在了解Tensorflow之前，我们需要先来了解一下常量变量与张量</p>
<h2 id="常量变量"><a href="#常量变量" class="headerlink" title="常量变量"></a>常量变量</h2><p>推荐阅读博客 <a href="https://sowhat.blog.csdn.net/article/details/79188449" target="_blank" rel="noopener">https://sowhat.blog.csdn.net/article/details/79188449</a> 下面摘抄一些核心的概念和例子</p>
<p>常量就是constant，被声明之后无法改变。变量是variable，声明之后仍能改变。张量则是一个比较大的概念。</p>
<p>几何代数中定义的张量是基于向量和矩阵的推广，通俗一点理解的话，我们可以将标量视为零阶张量，矢量视为一阶张量，那么矩阵就是二阶向量</p>
<p>张量是现代机器学习的基础。它的核心是一个数据容器，多数情况下，它包含数字，有时候它也包含字符串，但这种情况比较少。因此把它想象成一个数字的水桶。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>阶</th>
<th>数学实例</th>
<th>代码实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>纯量(只有大小)</td>
<td>s =123</td>
</tr>
<tr>
<td>1</td>
<td>向量(有大小和方向)</td>
<td>v = [1.1,2.2,3.3]</td>
</tr>
<tr>
<td>2</td>
<td>矩阵(数据表)</td>
<td>m = [[1,2,3],[4,5,6],[7,8,9]]</td>
</tr>
<tr>
<td>3</td>
<td>3阶张量(数据立体)</td>
<td>t = [[[2],[4],[6]],[[8],[10],[12]],[[14], [16],[18]]]</td>
</tr>
<tr>
<td>n</td>
<td>n阶</td>
<td>n维的一个空间</td>
</tr>
</tbody>
</table>
</div>
<p> 现在我们来熟悉一下在Tensorflow中怎么声明常量变量与张量</p>
<h3 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor_20 = tf.constant([[<span class="number">23</span>,<span class="number">4</span>],[<span class="number">32</span>,<span class="number">51</span>]])</span><br><span class="line">tensor_20</span><br></pre></td></tr></table></figure>
<p>打印结果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;tf.Tensor: shape=(<span class="number">2</span>, <span class="number">2</span>), dtype=int32, numpy=</span><br><span class="line">array([[<span class="number">23</span>,  <span class="number">4</span>],</span><br><span class="line">       [<span class="number">32</span>, <span class="number">51</span>]])&gt;</span><br></pre></td></tr></table></figure>
<p>如果要查看tensor的形状，我们可以这样写:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor_20.shape</span><br></pre></td></tr></table></figure>
<p>打印： TensorShape([2, 2])</p>
<h3 id="数值与Tensorflow的常量之间的相互转换"><a href="#数值与Tensorflow的常量之间的相互转换" class="headerlink" title="数值与Tensorflow的常量之间的相互转换"></a>数值与Tensorflow的常量之间的相互转换</h3><p>利用 <code>tensor_20.numpy()</code>可以将刚刚定义的tf常量用一个普通的二维数组的形式呈现出来。我们也可以通过这个方法直接来得到常量的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[<span class="number">23</span>,  <span class="number">4</span>],</span><br><span class="line">       [<span class="number">32</span>, <span class="number">51</span>]])</span><br></pre></td></tr></table></figure>
<p>要将普通的numpy数组转换成tf的常量，也非常简单，利用 <code>tf.constant()</code> 即可。这种转换是tensorflow2.0的最新特性，非常方便</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numpy_tensor = np.array([[<span class="number">23</span>,<span class="number">4</span>],[<span class="number">32</span>,<span class="number">51</span>]])</span><br><span class="line">tensor_from_numpy = tf.constant(numpy_tensor)</span><br><span class="line">tensor_from_numpy</span><br></pre></td></tr></table></figure>
<p>打印结果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;tf.Tensor: shape=(<span class="number">2</span>, <span class="number">2</span>), dtype=int32, numpy=</span><br><span class="line">array([[<span class="number">23</span>,  <span class="number">4</span>],</span><br><span class="line">       [<span class="number">32</span>, <span class="number">51</span>]])&gt;</span><br></pre></td></tr></table></figure>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>声明一个变量和声明一个常量只需要将 <code>tf.constant()</code> 改成 <code>tf.Variable()</code> 即可，但是要注意这个Variable 只能是大写V。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tf2_variable &#x3D; tf.Variable([[1.,2.,3.],[4.,5.,6.]])</span><br><span class="line">tf2_variable</span><br></pre></td></tr></table></figure>
<p>打印如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;tf.Variable <span class="string">'Variable:0'</span> shape=(<span class="number">2</span>, <span class="number">3</span>) dtype=float32, numpy=</span><br><span class="line">array([[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>],</span><br><span class="line">       [<span class="number">4.</span>, <span class="number">5.</span>, <span class="number">6.</span>]], dtype=float32)&gt;</span><br></pre></td></tr></table></figure>
<p>那么变量也是可以通过 <code>.numpy</code> 来转换成numpy数组的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tf2_variable.numpy()</span><br><span class="line">array([[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>],</span><br><span class="line">       [<span class="number">4.</span>, <span class="number">5.</span>, <span class="number">6.</span>]], dtype=float32)</span><br></pre></td></tr></table></figure>
<h4 id="修改变量的值"><a href="#修改变量的值" class="headerlink" title="修改变量的值"></a>修改变量的值</h4><p>我们可以通过定位到变量中某一个位置并通过 <code>.assign()</code> 的方法将变量中的某个值修改。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tf2_variable[<span class="number">0</span>,<span class="number">2</span>].assign(<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 打印得到</span></span><br><span class="line">&lt;tf.Variable <span class="string">'UnreadVariable'</span> shape=(<span class="number">2</span>, <span class="number">3</span>) dtype=float32, numpy=</span><br><span class="line">array([[  <span class="number">1.</span>,   <span class="number">2.</span>, <span class="number">100.</span>],</span><br><span class="line">       [  <span class="number">4.</span>,   <span class="number">5.</span>,   <span class="number">6.</span>]], dtype=float32)&gt;</span><br></pre></td></tr></table></figure>
<h2 id="张量运算"><a href="#张量运算" class="headerlink" title="张量运算"></a>张量运算</h2><p>tensorflow定义的常量和变量都属于张量。现在我们对我们定义的张量进行一些运算操作</p>
<p>首先我们来定义一个常量张量，这个常量张量并不会被修改但是仍然可以参与运算</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor = tf.constant([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br></pre></td></tr></table></figure>
<h3 id="addition"><a href="#addition" class="headerlink" title="addition"></a>addition</h3><p>利用 <code>tensor+2</code> 可以让tensor中所有的元素都加上2</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tensor+<span class="number">2</span></span><br><span class="line"><span class="comment"># 打印如下</span></span><br><span class="line">&lt;tf.Tensor: shape=(<span class="number">2</span>, <span class="number">2</span>), dtype=int32, numpy=</span><br><span class="line">array([[<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">5</span>, <span class="number">6</span>]])&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Multiplication"><a href="#Multiplication" class="headerlink" title="Multiplication"></a>Multiplication</h3><p>利用 <code>tensor*5</code> 可以让tensor中所有的元素都乘上5</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tensor*<span class="number">5</span></span><br><span class="line"><span class="comment"># 打印如下</span></span><br><span class="line">&lt;tf.Tensor: shape=(<span class="number">2</span>, <span class="number">2</span>), dtype=int32, numpy=</span><br><span class="line">array([[ <span class="number">5</span>, <span class="number">10</span>],</span><br><span class="line">       [<span class="number">15</span>, <span class="number">20</span>]])&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Using-Numpy-functions-on-Tensorflow-tensors"><a href="#Using-Numpy-functions-on-Tensorflow-tensors" class="headerlink" title="Using Numpy functions on Tensorflow tensors"></a>Using Numpy functions on Tensorflow tensors</h3><p>我们也可以用numpy的一些数学方法来计算Tensorflow中的张量，但是得到的数据类型不是tensor而是numpy array</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.square(tensor)</span><br><span class="line">array([[ <span class="number">1</span>,  <span class="number">4</span>],</span><br><span class="line">       [ <span class="number">9</span>, <span class="number">16</span>]], dtype=int32)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.sqrt(tensor)</span><br><span class="line">array([[1.        , 1.41421356],</span><br><span class="line">       [1.73205081, 2.        ]])</span><br></pre></td></tr></table></figure>
<h3 id="两个张量之间的点乘"><a href="#两个张量之间的点乘" class="headerlink" title="两个张量之间的点乘"></a>两个张量之间的点乘</h3><p>使用 <code>dot</code> 方法，就可以计算两个张良之间的点乘</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">print(tensor)</span><br><span class="line">print(tensor_20)</span><br><span class="line">np.dot(tensor, tensor_20)</span><br><span class="line"># 打印如下</span><br><span class="line">tf.Tensor(</span><br><span class="line">[[1 2]</span><br><span class="line"> [3 4]], shape&#x3D;(2, 2), dtype&#x3D;int32)</span><br><span class="line">tf.Tensor(</span><br><span class="line">[[23  4]</span><br><span class="line"> [32 51]], shape&#x3D;(2, 2), dtype&#x3D;int32)</span><br><span class="line">array([[ 87, 106],</span><br><span class="line">       [197, 216]])</span><br></pre></td></tr></table></figure>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><code>.constant()</code> 方法并不仅仅能定义一个常量张量。还能创建一个字符串常量.一般来说我们不会经常使用到 tensorflow来创建字符串，除了用它来做NLP之外。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tf_string = tf.constant(<span class="string">"TensorFlow"</span>)</span><br><span class="line">tf_string</span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line">&lt;tf.Tensor: id=<span class="number">62</span>, shape=(), dtype=string, numpy=<span class="string">b'TensorFlow'</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="简单的字符串操作"><a href="#简单的字符串操作" class="headerlink" title="简单的字符串操作"></a>简单的字符串操作</h3><p>我们可以用 <code>strings.length()</code> 方法来求出字符串的长度。其中 numpy=10 的意思就是说这个字符串的长度为10</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tf.strings.length(tf_string)</span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line">&lt;tf.Tensor: id=<span class="number">49</span>, shape=(), dtype=int32, numpy=<span class="number">10</span>&gt;</span><br></pre></td></tr></table></figure>
<p>我们还可以利用<code>strings.unicode_decode()</code>对字符串进行重新编码。比如将其设置为 <code>UTF8</code> 编码格式的话，打印结果如下: 我们看到字符串变成了一个长为10的数字数组，因为UTF-8格式会将字符串的每一个字母编码成一个数字。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tf.strings.unicode_decode(tf_string, <span class="string">"UTF8"</span>)</span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line">&lt;tf.Tensor: </span><br><span class="line">id=<span class="number">58</span>, shape=(<span class="number">10</span>,), </span><br><span class="line">dtype=int32,</span><br><span class="line">numpy=array([ <span class="number">84</span>, <span class="number">101</span>, <span class="number">110</span>, <span class="number">115</span>, <span class="number">111</span>, <span class="number">114</span>,  <span class="number">70</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">119</span>], </span><br><span class="line">dtype=int32)&gt;</span><br></pre></td></tr></table></figure>
<h3 id="字符串数组"><a href="#字符串数组" class="headerlink" title="字符串数组"></a>字符串数组</h3><p>下面这个写法是如何用 tensorflow来实现一个字符串数组的。这里创建的是一个一维的字符串数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tf_string_array = tf.constant([<span class="string">"TensorFlow"</span>, <span class="string">"Deep Learning"</span>, <span class="string">"AI"</span>])</span><br></pre></td></tr></table></figure>
<p>通过遍历我们可以打印出字符串数组中的每一个元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> string <span class="keyword">in</span> tf_string_array:</span><br><span class="line">  print(string)</span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line">tf.Tensor(<span class="string">b'TensorFlow'</span>, shape=(), dtype=string)</span><br><span class="line">tf.Tensor(<span class="string">b'Deep Learning'</span>, shape=(), dtype=string)</span><br><span class="line">tf.Tensor(<span class="string">b'AI'</span>, shape=(), dtype=string)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/11/03/%E7%BA%A2%E9%BB%91%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/03/%E7%BA%A2%E9%BB%91%E6%A0%91/" itemprop="url">红黑树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-03T14:01:22+08:00">
                2020-11-03
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-12-08T21:13:48+08:00">
                2022-12-08
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>平衡二叉树(AVL树) 虽然可以保证再最坏的情况下，查找、插入和删除的时间复杂度为$O(\log n)$ ，但是插入和删除后重新调整平衡可能需要多达 $O(\log n)$ 次的旋转，频繁地调整平衡导致全树地整体拓扑结构地变化。AVL树地左右子树高度绝对差的绝对值不超过1，而红黑树在AVL树“适度平衡”的基础上，进一步放宽条件：<strong>红黑树的左右子树高度不超过两倍</strong>。</p>
<p>红黑树也是一种平衡二叉搜索树，虽然和AVL树一样，<strong>查找、插入和删除的时间复杂度均为 </strong>$O(\log n)$ ，但其统计性能更好一些，不需要频繁调整平衡，且<strong>任何不平衡都能在3次旋转之内解决</strong>。因此红黑树在很多地方都广泛应用，例如在C++ STL中的 set，multiset，map，multimap 都应用了红黑树的变体。Java中的集合类 TreeMap 就是红黑树的实现。</p>
<p>首先我们来介绍一个概念：<strong>黑高</strong>。 从<strong>某个节点x(不包含该节点) 到叶子的任意一条路径上黑色节点</strong>称为该节点的黑高</p>
<p><strong>红黑树是满足以下性质的二叉搜索树</strong></p>
<p>1) 每个节点都是红色或者是黑色的</p>
<p>2) 根节点是黑色的 //<strong>旋转的时候需要维护</strong></p>
<p>3) 每个叶子节点是黑色的(包括空孩子)</p>
<p>4) 如果一个节点为红色，则其孩子节点、父节点必定为黑色。//<strong>旋转的时候需要维护</strong></p>
<p>5) 从任一结点到其后代叶子的路径上，均包含相同数目的黑节点。这说明左右子树的黑高是相同的 //<strong>旋转的时候需要维护</strong></p>
<ul>
<li>因此，<strong>ps：红黑树的黑色节点越多红黑树就平衡，如果一颗红黑树全是黑色节点，那么这一定是一颗满二叉树。</strong></li>
</ul>
<p><img src="/2020/11/03/%E7%BA%A2%E9%BB%91%E6%A0%91/1.png" style="zoom:120%;"></p>
<p>问题：红黑树没有AVL树那么平衡，为什么查找插入和删除的速度也是$O(\log n)$ 呢？</p>
<p>这是因为含有n个内部节点的红黑树的高度不超过$O(\log n)$ </p>
<p> 证明：假设红黑树的高度为h，根到叶子结点至少一半是黑色节点，根的黑高至少为 $h/2$ ，那么高为 $h/2$ 的二叉树节点数为 $2^{h/2}-1$ ，而除了这些节点，后面的 h/2 肯定还有节点存在，否则树高也不会为h。因此 $n\geq 2^{h/2}-1$, 即 $n+1\geq 2^{h/2}$ .两边同时取对数，得到 $h\leq 2log(n+1)=O(\log n)$</p>
<h3 id="红黑树与4阶B树"><a href="#红黑树与4阶B树" class="headerlink" title="红黑树与4阶B树"></a>红黑树与4阶B树</h3><p>红黑树和4阶B树之间存在等价关系。如哦从红黑树的树根开始，自顶向下逐层检查，如果遇到红结点，则将该节点压缩到父节点一侧；如果遇到黑节点，则保留。因为<strong>红结点对黑高没有贡献</strong>，而黑结点对黑高有贡献。</p>
<p>红黑树与4阶B树的4种等价方式：</p>
<p>1） 两个黑孩子(黑黑)，如图所示：</p>
<p><img src="/2020/11/03/%E7%BA%A2%E9%BB%91%E6%A0%91/2.png" style="zoom:150%;"></p>
<p> 2）左黑右红(黑红)，如图所示：</p>
<p><img src="/2020/11/03/%E7%BA%A2%E9%BB%91%E6%A0%91/3.png" style="zoom:150%;"></p>
<p>3) 左红右黑(红黑) ，如图所示：</p>
<p><img src="/2020/11/03/%E7%BA%A2%E9%BB%91%E6%A0%91/4.png" style="zoom:150%;"></p>
<p>4）两个红孩子(红红)，如图所示</p>
<p><img src="/2020/11/03/%E7%BA%A2%E9%BB%91%E6%A0%91/5.png" style="zoom:150%;"></p>
<p>从红黑树与4阶B树的等价关系可以看出，4阶B树中的结点中必然含有一个黑节点。而且不会出现红色的父亲。每一个结点最多包含三个关键字：如果包含2个红关键字，则黑关键字必然在中间位置。</p>
<p>我们可以尝试将这一棵红黑树进行压缩。</p>
<p><img src="/2020/11/03/%E7%BA%A2%E9%BB%91%E6%A0%91/1.png" style="zoom:120%;"></p>
<p>最后可以得到这样一棵4阶的B树</p>
<p><img src="/2020/11/03/%E7%BA%A2%E9%BB%91%E6%A0%91/1.jpg" style="zoom:120%;"></p>
<p> 那么既然红黑树和4阶B树是可以互相转化的，那么为什么还要用红黑树呢？这是因为红黑树和B树处理的方向不同。B树主要用于内外存的访问，旋转不是很容易，但是红黑树的旋转调平衡比较方便</p>
<h3 id="红黑树的查找"><a href="#红黑树的查找" class="headerlink" title="红黑树的查找"></a>红黑树的查找</h3><p>红黑树的查找相当于二叉搜索树的查找。因为红黑树也要有中序有序性。</p>
<h3 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h3><p>在红黑树中插入xx，首先要查找。如果查找成功，什么也不用做，直接返回即可。如果查找失败了，那么就在查找失败的位置创建x结点，并置红色(如果是树根，则置为黑色)</p>
<p>那么，为什么插入的结点一定要置为红色呢？</p>
<p>如果置为黑色有可能改变黑高，违反性质5。如果置红色，不会改变黑高，但是有可能违反性质4(红结点必然有黑孩子)</p>
<p>插入分为两种情况：</p>
<ul>
<li>如果新插入的结点x的父亲为黑色，则仍然满足红黑树的条件，插入成功</li>
<li>如果新插入的结点的父亲为红色，则出现“双红”(也就是说父亲和孩子都是红色的),此时需要修正，使其满足红黑树的条件。</li>
</ul>
<h4 id="双红修正："><a href="#双红修正：" class="headerlink" title="双红修正："></a>双红修正：</h4><p>将x的父亲和祖父记为p(parent) 、g(grandpa), x的叔叔记为 u（uncle).下面我们会说明修正过程，让大家明白红黑树中的结点为什么可以那么任性的变颜色。</p>
<h5 id="u为黑色"><a href="#u为黑色" class="headerlink" title="u为黑色"></a>u为黑色</h5><p><strong>修正原理</strong>：当u为黑色，x及其父亲p出现”双红“，可以根据红黑树与4阶B树来进行转换实现。首先将红黑树通过压缩转换为4阶B树，此时4阶B树的结点中出现了两个红色的结点，则黑节点必然在中间。因此将中间结点p置为黑色，两旁的结点置为红色，然后再将其转为红黑树即可。</p>
<p>如图所示：</p>
<p><img src="/2020/11/03/%E7%BA%A2%E9%BB%91%E6%A0%91/6.png" style="zoom:150%;"></p>
<p><strong>修正方法</strong></p>
<p>修正的原理清楚了，那么该修正方法也可以看作是旋转和染色的过程。g到x的路径为LL，执行LL型旋转。将g右旋，然后将旋转后的根染黑，将其两个孩子染红，如图所示：</p>
<p><img src="/2020/11/03/%E7%BA%A2%E9%BB%91%E6%A0%91/7.png" style="zoom:150%;"></p>
<p>同样的道理，如果x是p的右孩子，也可以采用该方法来修正。如图所示：</p>
<p><img src="/2020/11/03/%E7%BA%A2%E9%BB%91%E6%A0%91/8.png" style="zoom:150%;"></p>
<p>通过旋转来解决的话，我们可以这样来做：</p>
<p>通过x向左旋转，我们可以得到一个LL型的红黑树，然后就按照上面所说的方法将g右旋下来并进行染色即可</p>
<p><img src="/2020/11/03/%E7%BA%A2%E9%BB%91%E6%A0%91/9.png" style="zoom:150%;"></p>
<p>根据对称性，如果g的左右子树互换了位置，则又会出现两种情况(RR型或者RL型) ，如图所示:</p>
<p><img src="/2020/11/03/%E7%BA%A2%E9%BB%91%E6%A0%91/10.png" style="zoom:150%;"></p>
<p><strong>RR型</strong>:</p>
<p><img src="/2020/11/03/%E7%BA%A2%E9%BB%91%E6%A0%91/2.jpg" style="zoom:120%;"></p>
<p><strong>RL型：</strong></p>
<p><img src="/2020/11/03/%E7%BA%A2%E9%BB%91%E6%A0%91/3.jpg" style="zoom:120%;"></p>
<h5 id="u为红色"><a href="#u为红色" class="headerlink" title="u为红色"></a>u为红色</h5><p>如果x的叔叔为红色，x及其父亲p出现”双红“。其修正方法也可以根据红黑树与4阶B树的转换实现。首先将红黑树通过压缩转换为4阶B树，此时4阶B树的节点中出现了4个结点，发生上溢，需要执行分裂操作。令g上升到g的父结点中，分裂后x、p均为红结点，而4阶B树结点中必然含有一个黑节点，因此可以保持x的红色，将p、u染黑，g染红(保持黑高不变，如果g为树根，则染黑)，然后将其转换为红黑树即可</p>
<p><img src="/2020/11/03/%E7%BA%A2%E9%BB%91%E6%A0%91/11.png" style="zoom:100%;"></p>
<p>由于g上升到父节点之后，仍然可能会发生上溢，因此我们可以将g看作是新插入的结点，采用同样的方法处理，上溢有可能一直向上传递到根，总的操作并不会超过树高。</p>
<p><strong>修正方法</strong>：</p>
<p>以上是红黑树的修正原理，我们理解了原理之后可以简单粗暴地直接染色：将<strong>父亲和叔叔染黑，祖父染红</strong>。即p、u变黑，g变红。因为g的父亲可能是红色，因此将g看作是新插入的结点，采用同样的方法处理，每处理一次，上升两层，一直到树根</p>
<p>总结：</p>
<p><img src="/2020/11/03/%E7%BA%A2%E9%BB%91%E6%A0%91/13.png" style="zoom:100%;"></p>
<h3 id="构建实例"><a href="#构建实例" class="headerlink" title="构建实例"></a>构建实例</h3><p>下面我们用插画的形式来构建一颗红黑树，关键字为(12,16,2,30,28,20,60,29,85)</p>
<p>1) 输入12，创建一个根节点，置为黑色. 如图所示：</p>
<p><img src="/2020/11/03/%E7%BA%A2%E9%BB%91%E6%A0%91/4.jpg" style="zoom:20%;"></p>
<p>2) 输入16，创建新节点，置为红色，按照二叉搜索树规则查找到插入位置，新节点的父亲为黑色，不违反红黑树的性质，直接插入即可</p>
<p><img src="/2020/11/03/%E7%BA%A2%E9%BB%91%E6%A0%91/5.jpg" style="zoom:40%;"></p>
<p>3) 插入2，创建新节点，置为红色，按照二叉搜索树的规则查找到插入位置，新节点的父亲为黑色， 未违反红黑树的性质，直接插入即可</p>
<p><img src="/2020/11/03/%E7%BA%A2%E9%BB%91%E6%A0%91/6.jpg" style="zoom:40%;"></p>
<p>4) 插入30，创建新结点，置为红色，按照二叉搜索树规则查找到插入的位置，新节点的父亲为红色，出现”双红”，且新节点的叔叔也是红色，符合第2中修正方案。直接染色：将父亲和叔叔染黑，祖父染红，但是因为祖父为树根，树根永远保持黑色。</p>
<p><img src="/2020/11/03/%E7%BA%A2%E9%BB%91%E6%A0%91/7.jpg" style="zoom:40%;"></p>
<p>5) 输入28，创建新节点，置为红色。按照二叉搜索树规则查找到插入位置，新节点的父亲为红色，出现了“双红”。且新节点的叔叔为黑色，符合第1中修正方案。16到28的路径为RL，执行RL型旋转。即先执行右旋再执行左旋。最后将根28染成黑色，其两个孩子16，30染红.</p>
<p><img src="/2020/11/03/%E7%BA%A2%E9%BB%91%E6%A0%91/8.jpg" style="zoom:40%;"></p>
<p>6) 输入20，创建新结点，置为红色，按照二叉搜索树规则查找到插入位置，新结点的父亲为红色 ，且新节点的叔叔也是红色，符合第2种修正方案。我们就 直接染色：将父亲和叔叔染黑，祖父染红。祖父染红后将该节点作为新的结点，向上检查，看是否再次出现“双红”，未出现，插入完成。</p>
<p><img src="/2020/11/03/%E7%BA%A2%E9%BB%91%E6%A0%91/14.png" style="zoom:60%;"></p>
<p>7）输入60，29 创建新结点，置为红色，按照二叉搜索树规则查找到插入位置，新节点的福清为黑色，未违反红黑树的性质，插入完成</p>
<p><img src="/2020/11/03/%E7%BA%A2%E9%BB%91%E6%A0%91/9.jpg" style="zoom:40%;"></p>
<p>8）输入85，创建新结点，置为红色 ，新结点的父亲和叔叔都是红色，将其染黑，并江爷爷30染红</p>
<p><img src="/2020/11/03/%E7%BA%A2%E9%BB%91%E6%A0%91/10.jpg" style="zoom:60%;"></p>
<p>但是，此时30的父亲为红色，出现了双红，且30的叔叔为黑色，符合第一种修正方案，12到30的路径为RR，执行RR型旋转，执行左旋后，将根28染黑，其两个孩子12、30染红。如图所示：</p>
<p><img src="/2020/11/03/%E7%BA%A2%E9%BB%91%E6%A0%91/11.jpg" style="zoom:60%;"></p>
<h3 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a>红黑树的删除</h3><p>在红黑树种中删除x，首先要通过查找。如果查找失败，什么也不做，直接返回即可。如果查找成功，则需要判断后处理：</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/11/02/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B8%8E%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/02/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B8%8E%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" itemprop="url">监督学习与非监督学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-02T07:59:35+08:00">
                2020-11-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-11-02T16:19:56+08:00">
                2020-11-02
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="监督学习与非监督学习"><a href="#监督学习与非监督学习" class="headerlink" title="监督学习与非监督学习"></a>监督学习与非监督学习</h1><h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><p>监督学习是指我们给计算机一个包含了正确数据(答案)的数据集，算法的目的就是给出更多的真确答案。这也被称为回归问题。比如说下面这张图，叉叉代表着搜集到的正确的数字。而我们要做的，是找出一条拟合的曲线，来预测某一个大小的房子的价格是多少。</p>
<p>虽然说价格最小精确到分，但是我们仍然可以将其认为是一个连续的值，因此可以用回归的模型来解决。回归的定义就是 : Predict continuous valued output.也就是预测连续的值。</p>
<p><img src="/2020/11/02/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B8%8E%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/1.png" style="zoom:150%;"></p>
<p>​     下面是另外一种监督学习的例子，横轴是肿瘤的大小，而数轴只有0和1，0代表良性肿瘤，1代表是恶性肿瘤。</p>
<p><img src="/2020/11/02/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B8%8E%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/2.png" style="zoom:120%;"></p>
<p>或者是这样的一个有两个维度的分布：</p>
<p><img src="/2020/11/02/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B8%8E%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/3.png" style="zoom:130%;"></p>
<p>现在我们观测到一个肿瘤，我们的目的就是通过学习算法就将其归为某一类当中去。这是一个分类问题。比如第二张图，我们就可以在图上划出一条直线。</p>
<p>事实上，很多数据集不仅仅只有一个或者两个维度，可能有四五个或者更多特征。那怎么让学习算法能够处理这些特征呢？比如对于SVM(支持向量机)，就有一个特别灵巧的数学方法(核函数)，来允许计算机处理无穷多的特征</p>
<h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><p>对于无监督学习，我们给出的数据是没有标签的，如下：</p>
<p><img src="/2020/11/02/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B8%8E%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/4.png" style="zoom:150%;"></p>
<p>我们不知道每个数据点代表什么，我们只被告知这里有一个数据集，我们能不能在这里找到某种结构。通过无监督学习，我们可以在这个数据集中找到两个 clusters(簇) ,也就是说，这是我们之前学习过的聚类算法(K-Means)</p>
<p>无监督学习的一些实践：</p>
<p>Google news:Google 每天会爬去数十万条新闻链接，然后将其聚类成一个一个新闻。比如说钻井平台新闻，集合了很多url，每个url指向不同新闻网站</p>
<p><img src="/2020/11/02/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B8%8E%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/5.png" style="zoom:100%;"></p>
<p>聚类算法在基因组学中也有很多的应用。比如对于一个DNA微阵列数据的例子.</p>
<p><img src="/2020/11/02/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B8%8E%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/6.png" style="zoom:120%;"></p>
<p>我们要做的就是运行一个聚类算法，把不同的个体归入不同的类或者归为不同类型的人。这是一种非监督学习，因为我们没有提前告知这个算法这些个体属于那一类人</p>
<p>非监督学习还可以用于社交圈，分析出和我们关系比较好的人，判断出哪些人互相认识并做推荐。在商业中，非监督学习可以将很多客户进行一个分类并进行精准的广告投放或者市场调研。</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/11/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/11/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E6%95%B4%E7%90%86/" itemprop="url">算法设计与分析整理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-11-01T15:58:47+08:00">
                2020-11-01
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2020-11-05T22:27:48+08:00">
                2020-11-05
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="算法设计与分析整理"><a href="#算法设计与分析整理" class="headerlink" title="算法设计与分析整理"></a>算法设计与分析整理</h1><h2 id="Lec1"><a href="#Lec1" class="headerlink" title="Lec1"></a>Lec1</h2><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p>详见： <a href="https://jasonxqh.github.io/2020/08/28/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%92%8C%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/">https://jasonxqh.github.io/2020/08/28/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%92%8C%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</a></p>
<h3 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h3><p>我们要搞清楚几个概念：</p>
<p>$O:f(n)=O(g(n))$,也就就是 $\exists c&gt;0$和$n_0$ </p>
<p>当 $n\geq n_0$ 的时候 ，有$f(n)\leq cg(n)$  。也就是说，$g(n)$ 是 $f(n)$ 的渐进上界</p>
<p>e.g. $2n^2=O(n^3)(c=1,n_0=2)$ ,也可以说 $2n^2\in O(n^3)$ </p>
<p>$\Omega:f(n)=\Omega(g(n))$,也就是 $\exists c&gt;0,n_0$ </p>
<p>当 $n\geq n_0$ 的时候  ，有$f(n)\geq cg(n)$  。 也就是说 $g(n)$ 是 $f(n)$的渐近下界</p>
<p>e.g.$n^{0.5}=\Omega(\lg n)$ </p>
<p>$\Theta:f(n)=\Theta(g(n))$, 也就是 $\exists c_1&gt;0,\exists c_2&gt;0,n_0$ </p>
<p>当 $n\geq n_0$ 的时候 ，有 $c_1g(n)\leq f(n)\leq c_2g(n)$ 。也就是说 g(n) 与 f(n) 同阶</p>
<p>当一个n足够大的时候， 一个 $\Theta(n^2)$ 的算法始终会击败一个 $\Theta(n^3)$ 的算法</p>
<p>e.g. $\frac{1}{2}n^2+2n=\Theta(n^2)$ </p>
<h4 id="插入排序算法分析"><a href="#插入排序算法分析" class="headerlink" title="插入排序算法分析"></a>插入排序算法分析</h4><p>Worst case: Input reverse sorted</p>
<p>$T(n)=\sum_{j=2}^n\Theta(j)=\Theta(n^2)$ </p>
<p>Average case: All permutations equally likely</p>
<p>$T(n)=\sum_{j=2}^n\Theta(j/2)=\Theta(n^2)$ </p>
<h4 id="合并排序算法分析"><a href="#合并排序算法分析" class="headerlink" title="合并排序算法分析"></a>合并排序算法分析</h4><p>合并算法 $A[1\cdots n]$ </p>
<ol>
<li>If n=1, done</li>
<li>Recursively sort $A[1,\cdots,[n/2]]$ and $A[[n/2]+1,\cdots ,n]$ </li>
<li>Merge the 2 sorted lists</li>
</ol>
<p>$T\left( n\right) =\begin{cases}\Theta \left( 1\right)<del>if</del>n=1\ 2T\left( \frac{n}{2}\right) +\Theta (n)<del>if</del>n &gt;1\end{cases}$ </p>
<p><img src="/2020/11/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E6%95%B4%E7%90%86/1.png" style="zoom:80%;"></p>
<p>Three methods: Substitution（代入法）, Iteration（递归树法）, Master（主方法）</p>
<h3 id="主定理"><a href="#主定理" class="headerlink" title="主定理"></a>主定理</h3><p>$T(n) = aT(n/b) + f(n)$ </p>
<p> 我们要比较  $f(n)$ and $n^{log_ba}$ </p>
<p>如果 $f(n)$ 增长得比 $n^{log_ba}$ 慢，那么就是 $\Theta(n^{log_ba})$</p>
<p>$f(n)$ 是和 $n^{log_ba}$ 同阶的，那么结果是 $\Theta(n^{log_ba}\log n)$ </p>
<p>$f(n)$ 增长得比 $n^{log_ba}$ 更快，那么就是 $\Theta(f(n))$</p>
<p><img src="/2020/11/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E6%95%B4%E7%90%86/3.png" style="zoom:180%;"></p>
<p><strong>对于a: </strong> $T(n)=4T(n/3)+n\lg n$  </p>
<p><img src="/2020/11/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E6%95%B4%E7%90%86/4.png" style="zoom:180%;"></p>
<p><strong>对于b:</strong> $3T(n/3)+n/\lg n$</p>
<p><img src="/2020/11/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E6%95%B4%E7%90%86/5.png" style="zoom:180%;"></p>
<p><img src="/2020/11/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E6%95%B4%E7%90%86/6.png" style="zoom:180%;"></p>
<p><img src="/2020/11/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E6%95%B4%E7%90%86/7.png" style="zoom:180%;"></p>
<p><strong>对于c：</strong> $T(n)=4T(n/2)+n^2\sqrt{n}$ </p>
<p><img src="/2020/11/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E6%95%B4%E7%90%86/11.png" style="zoom:180%;"></p>
<p><strong>对于d</strong></p>
<p><img src="/2020/11/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E6%95%B4%E7%90%86/8.png" style="zoom:180%;"></p>
<p><strong>对于e:</strong> $T(n)=2T(n/2)+n/\lg n$ </p>
<p>和 b 一样</p>
<p><strong>对于f：</strong>$T(n)=T(n/2)+T(n/4)+T(n/8)+n$ </p>
<p><img src="/2020/11/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E6%95%B4%E7%90%86/9.png" style="zoom:180%;"></p>
<p><strong>对于g：</strong>$T(n)=T(n-1)+\frac{1}{n}$</p>
<p>调和级数求和： $T(n)=\Theta(\lg n)$ </p>
<p><strong>对于h: </strong>$T(n)=T(n-1)+\lg n$</p>
<p>$\lg n+\lg (n-1)+\lg(n-2)+\cdots+\lg2+\lg1 = \lg(n!)$</p>
<p>$T(n)=\Theta(n\lg n)$ </p>
<p><strong>对于i：</strong>$T(n)=T(n-2)+\frac{1}{\lg n}$ </p>
<p>$\frac{1}{\lg n}+\frac{1}{\lg(n-1)}+\frac{1}{\lg(n-2)}+\frac{1}{\lg(n-3)}+\cdots+\frac{1}{lg3}+\frac{1}{\lg2}$</p>
<p>$T(n)=\Theta(\frac{n}{\lg n})$ </p>
<p><strong>对于j:</strong> $T(n)=\sqrt{n}T(\sqrt{n})+n$ </p>
<p><img src="/2020/11/01/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E6%95%B4%E7%90%86/10.png" style="zoom:180%;"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/16/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/18/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/%5Bobject%20Object%5D"
                alt="Jason" />
            
              <p class="site-author-name" itemprop="name">Jason</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20fa%20fa-archive">
              
                  <span class="site-state-item-count">435</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">61</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="true"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
 <!--
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>







-->
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>




















  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v="></script>

  <script type="text/javascript" src="/js/src/motion.js?v="></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v="></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
