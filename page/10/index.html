<!DOCTYPE html>
<html lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jasonxqh.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jason‘s Blog">
<meta property="og:url" content="https://jasonxqh.github.io/page/10/index.html">
<meta property="og:site_name" content="Jason‘s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jasonxqh.github.io/page/10/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jason‘s Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jason‘s Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/10/16/Nodejs%E5%9F%BA%E7%A1%805%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/16/Nodejs%E5%9F%BA%E7%A1%805%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">Nodejs基础5测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-10-16 15:13:18 / Modified: 15:31:04" itemprop="dateCreated datePublished" datetime="2021-10-16T15:13:18+08:00">2021-10-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/node/" itemprop="url" rel="index"><span itemprop="name">node</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Nodejs基础5测试"><a href="#Nodejs基础5测试" class="headerlink" title="Nodejs基础5测试"></a>Nodejs基础5测试</h1><h2 id="Integration-Testing"><a href="#Integration-Testing" class="headerlink" title="Integration Testing"></a>Integration Testing</h2><p>和单元测试不一样，集成测试可以引入外部的一些信息(数据库)对我们设计的api进行调试。</p>
<h3 id="Setting-Up-the-Test-Db"><a href="#Setting-Up-the-Test-Db" class="headerlink" title="Setting Up the Test Db"></a>Setting Up the Test Db</h3><p>我们需要真实的数据库来运行集成测试，但是我们又不想用已经创建好了的项目数据库来直接测试，因为在集成测试中，我们会插入或者删除一些数据，为了避免造成混乱，我们需要新建一个测试数据库。</p>
<h3 id="Your-First-Integration-Test"><a href="#Your-First-Integration-Test" class="headerlink" title="Your First Integration Test"></a>Your First Integration Test</h3><h3 id="Populating-the-Test-Db"><a href="#Populating-the-Test-Db" class="headerlink" title="Populating the Test Db"></a>Populating the Test Db</h3><h3 id="Testing-Routes-with-Parameters"><a href="#Testing-Routes-with-Parameters" class="headerlink" title="Testing Routes with Parameters"></a>Testing Routes with Parameters</h3><h3 id="Validating-ObjectIDs"><a href="#Validating-ObjectIDs" class="headerlink" title="Validating ObjectIDs"></a>Validating ObjectIDs</h3><h3 id="Refactoring-with-Confidence"><a href="#Refactoring-with-Confidence" class="headerlink" title="Refactoring with Confidence"></a>Refactoring with Confidence</h3><h3 id="Testing-the-Authorization"><a href="#Testing-the-Authorization" class="headerlink" title="Testing the Authorization"></a>Testing the Authorization</h3><h3 id="Testing-the-Invalid-Inputs"><a href="#Testing-the-Invalid-Inputs" class="headerlink" title="Testing the Invalid Inputs"></a>Testing the Invalid Inputs</h3><h3 id="Testing-the-Happy-Path"><a href="#Testing-the-Happy-Path" class="headerlink" title="Testing the Happy Path"></a>Testing the Happy Path</h3><h3 id="Writing-Clean-Tests"><a href="#Writing-Clean-Tests" class="headerlink" title="Writing Clean Tests"></a>Writing Clean Tests</h3><h3 id="Testing-the-Auth-Middleware"><a href="#Testing-the-Auth-Middleware" class="headerlink" title="Testing the Auth Middleware"></a>Testing the Auth Middleware</h3><h3 id="Unit-Testing-the-Auth-Middleware"><a href="#Unit-Testing-the-Auth-Middleware" class="headerlink" title="Unit Testing the Auth Middleware"></a>Unit Testing the Auth Middleware</h3><h3 id="Code-Coverage-7-09"><a href="#Code-Coverage-7-09" class="headerlink" title="Code Coverage (7:09)"></a>Code Coverage (7:09)</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/10/11/%E4%B8%80%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/11/%E4%B8%80%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/" class="post-title-link" itemprop="url">一元线性回归</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-10-11 21:24:56" itemprop="dateCreated datePublished" datetime="2021-10-11T21:24:56+08:00">2021-10-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-05 14:33:18" itemprop="dateModified" datetime="2022-01-05T14:33:18+08:00">2022-01-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="线性回归的背景"><a href="#线性回归的背景" class="headerlink" title="线性回归的背景"></a>线性回归的背景</h1><p>在实际问题中，感兴趣的变量y与易于获得的变量x之间存在紧密关联，但又不由变量x而唯一确定的，这种关系通常称为<strong>统计关系</strong></p>
<p>若变量y与x间有统计关系，那么通常称y为因变量或者响应变量，x为自变量或者解释变量，这里x在机器学习方法中也会被称为特征。</p>
<p>在给定x的取值之后，y的取值是无法唯一确定的。于是，我们可以将y认为是一个随机变量，并需要通过概率分布来对其进行描述，而我们常常关心的是这个概率分布的数字特征，如<strong>期望和方差</strong>。</p>
<p>在给定x的时候，称y的条件数学期望为 y 关于 x 的(均值)回归函数，即：</p>
<script type="math/tex; mode=display">
f(x) = E(y|x)</script><p>注意到，$f(x)$​​ 不仅是 x 的一个确定性的函数，并且从平均意义上刻画了变量y与x间统计关系的规律</p>
<p>而如何确定这个<strong>确定性</strong>的函数f是回归问题中最为核心的问题。</p>
<ul>
<li>线性回归模型可看作将这个函数f 取为x的一个线性函数模式, 如 $f(x)=\beta_0+\beta_1 x$</li>
<li>神经网络模型可看作将这个函数f 取为x的一个非线性函数的形式，如 $f(x)=\max(0,\beta_0+\beta_1x)$​ (Relu函数)</li>
<li>深度学习模型可理解为这个函数f 取为x的多个非线性函数的复合形式。</li>
</ul>
<h1 id="一元线性回归"><a href="#一元线性回归" class="headerlink" title="一元线性回归"></a>一元线性回归</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="模型版"><a href="#模型版" class="headerlink" title="模型版"></a>模型版</h3><p>一元回归模型为：</p>
<script type="math/tex; mode=display">
y = \beta_0+\beta_1x+\epsilon</script><p>其中，$\beta_0,\beta_1$ 为两个未知参数，常称为回归系数，而$\varepsilon$​ 是随机误差。</p>
<p>一元回归模型与数据模型$y=\beta_0+\beta_1x$ 在理解上是不同的，主要的差异在于是否引入了随机误差项$\varepsilon$ :</p>
<ul>
<li>在数学模型中，两个变量之间的关系是确定性的</li>
<li>在统计模型中，两个变量之间的关系是不确定的</li>
</ul>
<p>那么，在一元线性回归模型中，确定性的部分是$\beta_0+\beta_1x$, 随机性的部分为$\varepsilon$ </p>
<p>随机误差项用来概括由于人们认识以及其他客观原因的局限而没有考虑的种种偶然因素，一般，随机误差$\epsilon$​ 没有办法被观测，但<strong>通常假定</strong>$\varepsilon$​ 满足：</p>
<script type="math/tex; mode=display">
\cases{E(\varepsilon) = 0\\Var(\varepsilon) = \sigma^2<\infty}</script><p>其中，$E(\varepsilon)$​​ 表示$\varepsilon$​​ 的数学期望设其为0是为了避免参数不可识别，$Var(\varepsilon)$​​表示$\varepsilon$​​​​的方差</p>
<p>那么因为$\varepsilon$是一个随机变量，所以$y=\beta_0+\beta_1 x+\varepsilon$ 也是随机变量，那么关于x求条件期望，即：</p>
<script type="math/tex; mode=display">
E(y|x) = \beta_0+\beta_1x</script><p>注意到$E(y|x)$​是关于x的一个函数，表示用x的信息刻画因变量y，作为y的”预测“，我们称$E(y|x)=\beta_0+\beta_1x$为回归方程。</p>
<h3 id="数据版"><a href="#数据版" class="headerlink" title="数据版"></a>数据版</h3><p>一般假定我们观测到的数据${(x<em>i,y_i)}</em>{i=1}^n$ 符合线性回归模型及其假设，即：</p>
<script type="math/tex; mode=display">
\cases{y_i= \beta_0+\beta_1x_i+\varepsilon_i,i=1,2\cdots,n\\~\\
E(\varepsilon)=0 ~~~ Var(\varepsilon_i)=\sigma^2}</script><p>同时假定n组数据是独立观测的，即$\varepsilon_1,\varepsilon_2,\cdots,\varepsilon_n$​​是独立同分布的随机变量. </p>
<p>所以，$y_1,y_2\cdots,y_n$ 的期望与方差分别为：</p>
<script type="math/tex; mode=display">
\begin{align}
&E(y_i)= \beta_0+\beta_1x_i\\
&Var(y_i) = \sigma^2, i = 1,2\cdots,n
\end{align}</script><p>这表明，随机变量$y_1,y_2\cdots,y_n$​ 服从不同的分布，方差相等，但是期望不等，且相互独立</p>
<p>模型版和数据版的差别就是，前者强调的是模型，后者侧重的是数据</p>
<h2 id="任务：预测和参数估计"><a href="#任务：预测和参数估计" class="headerlink" title="任务：预测和参数估计"></a>任务：预测和参数估计</h2><p>首先我们来说说回归的最常见的任务之一就是通过n组样本观测值$(x_i,y_i),i=1,2\cdots,n$ 对一个新的个体进行预测。具体来说，如果$x_0$ 已知，那么 $\beta_0+\beta_1x_0$ 是$y_0$的一个合理的预测值 </p>
<p>现在问题来了，这个方程里面的两个参数$\beta_0$​和$\beta_1$​怎么估呢？我们需要通过观测到的数据$(x_i,y_i),i=1,\cdots,n$​​进行估计。一般我们会用$\hat\beta_0$​ 和 $\hat\beta_1$​ 分别表示$\beta_0$​和$\beta_1$​ 的估计值。那么，y关于x的一元线性<strong>经验</strong>回归方程为:</p>
<script type="math/tex; mode=display">
\hat y = \hat\beta_0+\hat\beta_1 x</script><p>称其图形为<strong>经验回归直线</strong>，其中，$\hat\beta_0$ 表示经验回归直线的截距，$\hat\beta_1$表示经验回归直线的斜率</p>
<p>给定$x=x_0$后，称：</p>
<script type="math/tex; mode=display">
\hat y_0 = \hat \beta_0+\hat\beta_1x_0</script><p>为回归值。又是也称为拟合值或者预测值。</p>
<h3 id="最小二乘估计"><a href="#最小二乘估计" class="headerlink" title="最小二乘估计"></a>最小二乘估计</h3><p>在概率论中我们讲了估计的三种思想：似然、替换和拟合</p>
<p>拟合的方法就是配直线，也就是我们现在要讲的<strong>最小二乘</strong></p>
<p>对于每一个样本观测值$(x_i,y_i)$ ，定义偏差为观测值$y_i$ 与其回归至$E(y_i|x_i)$的差异为：</p>
<script type="math/tex; mode=display">
y_i - E(y_i|x_i) = y_i - \beta_0-\beta_1x_i</script><p>偏差平方和为：</p>
<script type="math/tex; mode=display">
Q(\beta_0,\beta_1) = \sum_{i=1}^n(y_i-E(y_i))^2\\
=\sum_{i=1}^n (y_i-\beta_0-\beta_1x_i)^2</script><p>用图形来表示，就如下图：</p>
<p><img src="/2021/10/11/%E4%B8%80%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/1.jpeg" alt="1" style="zoom:67%;"></p>
<p>我们称通过最小化偏差平方和$Q(\beta_0,\beta_1)$​​而得到的参数估计方法，为<strong>最小二乘估计</strong> ,下面给出其数学定义：</p>
<script type="math/tex; mode=display">
\begin{align}
(\hat\beta_0,\hat\beta_1)& = \arg\min_{\beta_0,\beta_1} Q(\beta_0,\beta_1)\\
&=\arg\min_{\beta_0,\beta_1}\sum_{i=1}^n(y_i-\hat\beta_0-\hat\beta_1x_i)^2
\end{align}</script><p>我们发现这其实就是一个求极值的问题，因为$Q$ 是关于$\hat\beta_0,\hat\beta_1$的非负二次函数，所以其最小值总是存在的。</p>
<p>那么要求极值，我们首先要求一阶导数，即：</p>
<script type="math/tex; mode=display">
\cases{\frac{\partial Q}{\partial \beta_0} = -2\sum_{i=1}^n(y_i-\beta_0-\beta_1x_i)=0\\~\\
\frac{\partial Q}{\partial\beta_1} = -2\sum_{i=1}^n(y_i-\beta_0-\beta_1x_i)x_i = 0
}</script><p>整理得到<strong>正规方程</strong>：</p>
<script type="math/tex; mode=display">
\cases{n\beta_0+\overline x\beta_1 = n\overline y\\~\\
n\overline x\beta_0+\sum_{i=1}^nx_i^2\beta_1=\sum_{i=1}^n x_iy_i}</script><p>于是，$\beta_0,\beta_1$的最小二乘估计为：</p>
<script type="math/tex; mode=display">
\begin{align}
&\hat\beta_0 = \overline y -\hat\beta_1\overline x\\~\\
&\hat\beta_1 = \frac{\sum_{i=1}^n(x_i-\overline x)(y_i-\overline y)}{\sum_{i=1}^n(x_i-\overline x)^2}
\end{align}</script><p>其中，</p>
<script type="math/tex; mode=display">
\overline x = \frac{1}{n} \sum_{i=1}^n x_i,\overline y = \frac{1}{n}\sum_{i=1}^n y_i</script><p>分别为$x_1,x_2\cdots,x_n$ 和 $y_1,y_2\cdots,y_n$ 的样本均值</p>
<p>我们可以用跟简单的记号来表示$\hat\beta_0$和$\hat\beta_1$ </p>
<script type="math/tex; mode=display">
\begin{align}
&l_{xx} = \sum_{i=1}^n (x_i-\overline x)^2 = \sum_{i=1}^n x_i^2-n(\overline x)^2\\~\\
&l_{xy} = \sum_{i=1}^n (x_i-\overline x)(y_i-\overline y) = \sum_{i=1}^n x_iy_i -n\overline x\cdot\overline y
\end{align}</script><p>于是，最小二乘估计简写为：</p>
<script type="math/tex; mode=display">
\cases{
\hat\beta_0 = \overline y -\hat\beta_1\overline x ,\\~\\
\hat\beta_1 = l_{xx}^{-1}l_{xy}
}</script><p>但是，我们是根据一阶导数求出的$\hat\beta$​ ，这实际上是 $Q(\beta_0,\beta_1)$​的稳定点, 但是是否为最小值点，仍需要根据其二阶导在$(\hat\beta_0,\hat\beta_1)$​上表现来判断是否为最小值点：</p>
<script type="math/tex; mode=display">
\cases{\frac{\partial Q}{\partial \beta_0} = -2\sum_{i=1}^n(y_i-\beta_0-\beta_1x_i)=0\\~\\
\frac{\partial Q}{\partial\beta_1} = -2\sum_{i=1}^n(y_i-\beta_0-\beta_1x_i)x_i = 0
}</script><p>从上式可以推得：$Q(\beta_0,\beta_1)$的二阶偏导为：</p>
<script type="math/tex; mode=display">
\begin{vmatrix} \begin{pmatrix} 2n & 2n\overline x \\ 2n\overline x & 2\sum_{i=1}^nx_i^2 \end{pmatrix} \end{vmatrix} = 4n\sum_{i=1}^nx_i^2-4n^2(\overline x)^2</script><p>我们提取出4n,发现剩下的式子就是$l_{xx}$,因此：</p>
<script type="math/tex; mode=display">
= 4n(\sum_{i=1}^nx_i^2-n(\overline x)^2) = \sum_{i-1}^n(x_i-\overline x)^2</script><p>因此，二阶导大于0，说明Q在$\hat\beta_0,\hat\beta_1$​处取最小值</p>
<h3 id="最大似然估计"><a href="#最大似然估计" class="headerlink" title="最大似然估计"></a>最大似然估计</h3><p>我们首先来回顾一下最大似然估计：</p>
<p>最大似然估计是依赖于总体的概率函数$f(x;\theta)$以及样本所提供的信息来求未知参数的估计。当总体X为连续随机变量时，其密度函数为：</p>
<script type="math/tex; mode=display">
\{f(x;\theta),\theta\in \Theta\}</script><p>假定总体X的一个独立同分布的样本为$x_1,x_2\cdots,x_n$ 参数的似然函数为：</p>
<script type="math/tex; mode=display">
L(\theta;x_1,x_2,\cdots,x_n) = \prod_{i=1}^nf(x_i;\theta)</script><p>最大似然估计指的是在参数空间 $\Theta$​ 中选取随机样本$(X_1,X_2,\cdots,X_n)$落在点$(x_1,x_2\cdots,x_n)$附近最大概率的$\hat\theta$ 为未知参数$\theta$的估计值，即$\hat\theta$ 需要满足：</p>
<script type="math/tex; mode=display">
\hat\theta = \arg \max_{\theta} L(\theta;x_1,x_2\cdots,x_n)</script><h4 id="分布假定"><a href="#分布假定" class="headerlink" title="分布假定"></a>分布假定</h4><p>那么要做极大似然估计的话，我们首先要假定分布，有了密度函数才能得到似然函数。</p>
<p>在一元线性回归模型中，最常见的假定为$\varepsilon$ 服从正态分布，即</p>
<script type="math/tex; mode=display">
\varepsilon\sim N(0,\sigma^2)</script><p>从数据角度看，由于 $\varepsilon_1,\varepsilon_2\cdots,\varepsilon_n$ 都是与$\varepsilon$独立同分布的随机变量，因而有：</p>
<script type="math/tex; mode=display">
\varepsilon_i\sim N(0,\sigma^2),i=1,2,\cdots,n</script><p>在 $\varepsilon_i$ 服从正态分布的假定下，$y_i$ 也服从正态分布 ，即</p>
<script type="math/tex; mode=display">
y_i\sim N(\beta_0+\beta_1x_i,\sigma^2),i = 1,2\cdots,n</script><p>因此，我们可以得到$y_i$的密度函数：</p>
<script type="math/tex; mode=display">
f_i(y_i) = \frac{1}{\sqrt{2\pi\sigma^2}}\exp\{-\frac{1}{2\sigma^2}[y_i-(\beta_0+\beta_1x_i)]^2 \}</script><p>因为 $y_1,y_2\cdots,y_n$​的密度函数是和i相关的，各不相同，我们用 $f_i$ 代替 $f(y_i)$ 更为合适</p>
<p>那么，似然函数为：</p>
<script type="math/tex; mode=display">
\begin{align}
L(\beta_0,\beta_1,\sigma^2) &= \prod_{i=1}^n f_i(y_i)\\
&=(2\pi\sigma^2)^{-\frac{n}{2}}\exp\{-\frac{1}{2\sigma^2}\sum_{i=1}^n[y_i-(\beta_0+\beta_1x_i)]^2 \}
\end{align}</script><p>于是，对数似然函数为：</p>
<script type="math/tex; mode=display">
\ln L (\beta_0,\beta_1,\sigma^2) = -\frac{n}{2}\ln(2\pi\sigma^2)-\frac{1}{2\sigma^2}\sum_{i=1}^n(y_i-(\beta_0+\beta_1x_i))^2</script><p>易知 L 的最大值点与 $\ln L$ 的最大值点是相同的。我们发现：</p>
<script type="math/tex; mode=display">
\arg\max_{\beta_0,\beta_1}\ln L(\beta_0,\beta_1,\sigma^2) \Leftrightarrow \min_{\beta_0,\beta_1}Q(\beta_0,\beta_1)</script><p>即：回归系数$\beta_0,\beta_1$的最大似然估计和最小二乘估计的形式是一致的。</p>
<h4 id="求解-sigma-2"><a href="#求解-sigma-2" class="headerlink" title="求解$\sigma^2$"></a>求解$\sigma^2$</h4><p>我们可以对$\ln L(\beta_0,\beta_1,\sigma^2)$关于$\sigma^2$求导，并令一阶导数为0，得到：</p>
<script type="math/tex; mode=display">
\frac{\partial \ln L}{\partial \sigma^2} =-\frac{n}{2\sigma^2}+\frac{1}{4\sigma^2}\sum_{i=1}^n(y_i-(\beta_0+\beta_1x_i))^2 = 0</script><p>那么，$\sigma^2$ 的最大似然估计为：</p>
<script type="math/tex; mode=display">
\hat\sigma^2_{ML} = \frac{1}{n}\sum_{i=1}^n(y_i-\hat y_i)^2\\
=\frac{1}{n}\sum_{i=1}^n(y_i-(\hat\beta_0+\hat\beta_1x_i))^2</script><p>$\hat\sigma_{ML}^2$是$\sigma^2$​ 的有偏估计。因为极大似然估计就是有偏的。这里我们有两个参数，因此要除以 n-2。</p>
<p>在实际应用中，更为常用的是$\sigma^2$ 的无偏估计，即：</p>
<script type="math/tex; mode=display">
\hat\sigma^2 = \frac{1}{n-2}\sum_{i=1}^n(y_i-(\hat\beta_0+\hat\beta_1x_i))^2</script><p>最大似然估计是在 $\varepsilon_i\sim N(0,\sigma^2)$ 的正态分布假设下求得的，而最小二乘估计则估计则对分布假设没有要求。所以说，极大似然估计也可以看成是最小二乘估计，只是多了一个条件。因此极大似然估计相对于最小二乘估计更为稳健</p>
<p>$y_1,y_2,\cdots,y_n$ 是独立的正态分布样本，而不是同分布的，但这并不妨碍最大似然方法去求解。因此极大似然估计只要定义出似然函数即可，不要求样本同分布。</p>
<h4 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h4><p>如果$y_1,y_2\cdots,y_n$ 是相互独立的且$y_i$是正态分布随机变量，即</p>
<script type="math/tex; mode=display">
y_i\sim N(\beta_0+\beta_1x_i,\sigma^2)</script><p>那么</p>
<ul>
<li><p>$\beta_0,\beta_1$ 均服从正态分布</p>
<script type="math/tex; mode=display">
\begin{align}
&\hat\beta_0\sim N(\beta_0,(\frac{1}{n}+\frac{\overline x^2}{l_{xx}})\sigma^2)\\
&\hat\beta_1\sim N(\beta_1,\frac{\sigma^2}{l_{xx}})
\end{align}</script></li>
<li><p>$\beta_0,\beta_1$两者的协方差如下：</p>
<script type="math/tex; mode=display">
Cov(\hat\beta_0,\hat\beta_1) = -\frac{\overline x}{l_{xx}}\sigma^2</script><p>从这个公式我们可以得出：只有当$\overline x=0$ 的时候，两者才不相关，要做到这一点需要对样本数据进行<strong>中心化</strong>，否则我们得到的$\beta_0$ 和 $\beta_1$ 都是相关的。</p>
</li>
</ul>
<h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><h5 id="步骤1：用-yi-线性表出-beta-0-beta-1"><a href="#步骤1：用-yi-线性表出-beta-0-beta-1" class="headerlink" title="步骤1：用$yi$线性表出$\beta{0},\beta_1$"></a>步骤1：用$y<em>i$线性表出$\beta</em>{0},\beta_1$</h5><ul>
<li>首先我们可以将 $\hat\beta_1$写成 $y_i$ 随机变量的一个加权求和的形式。(因为x是确定的)</li>
</ul>
<script type="math/tex; mode=display">
\begin{align}
\hat\beta_1 = l_{xx}^{-1}l_{yy} &= l_{xx}^{-1}\sum_{i=1}^n(x_i-\overline x)(y_i-\overline y)\\
&=l_{xx}^{-1}(\sum_{i=1}^m(x_i-\overline x)y_i-\sum_{i=1}^n(x_i-\overline x)\overline y)\\
&=l_{xx}^{-1}(\sum_{i=1}^n (x_i-\overline x)y_i)\\
&=\sum_{i=1}^n\frac{(x_i-\overline x)}{l_{xx}}y_i
\end{align}</script><p>第二个等式中的后者为0，因为 $\sum<em>{i=1}^n(x_i-\overline x)=\sum</em>{i=1}^n x_i-n\overline x=0$​</p>
<ul>
<li>我们可以将$\hat\beta_0$写为以下的形式：</li>
</ul>
<script type="math/tex; mode=display">
\begin{align}
\hat\beta_0& = \overline y -\hat\beta_1 \overline x\\
&=\frac{1}{n}\sum_{i=1}^n y_i -\sum_{i=1}^n\frac{(x_i-\overline x)}{l_{xx}}y_i\overline x\\
&=\sum_{i=1}^n(\frac{1}{n}-\frac{\overline x(x_i-\overline x)}{l_{xx}})y_i
\end{align}</script><p>因此$\hat\beta_0$和$\hat\beta_1$ 均可以看做是 $y_1,y_2\cdots,y_n$的线性组合。已知$y_1,y_2\cdots,y_n$是相互独立的正态随机变量，那么 $\hat\beta_0$和$\hat\beta_1$​均服从正态分布</p>
<h5 id="步骤2：考虑期望和方差"><a href="#步骤2：考虑期望和方差" class="headerlink" title="步骤2：考虑期望和方差"></a>步骤2：考虑期望和方差</h5><p>接下来，我们需要考虑这两个估计的均值与方差，从而进一步确定分布</p>
<ul>
<li>一方面，考虑 $\hat\beta_1$ 的期望与方差，即：</li>
</ul>
<script type="math/tex; mode=display">
\begin{align}
E(\hat\beta_1) &=\sum_{i=1}^n\frac{(x_i-\overline x)}{l_{xx}}E(y_i)
\\& = \sum_{i=1}^n (\frac{x_i-\overline x}{l_{xx}})(\beta_0+\beta_1x_i)\\
&=\sum_{i=1}^n \frac{(x_i-\overline x)}{l_{xx}}\beta_0+\sum_{i=1}^n\frac{x_i(x_i-\overline x)}{l_{xx}}\beta_1
\end{align}</script><p>我们可以让其减去$\sum<em>{i=1}^n\frac{\overline x(x_i-\overline x)}{l</em>{xx}}\beta_1$ 因为这个式子为0</p>
<script type="math/tex; mode=display">
=\sum_{i=1}^n \frac{(x_i-\overline x)}{l_{xx}}\beta_0+\sum_{i=1}^n\frac{x_i(x_i-\overline x)}{l_{xx}}\beta_1-\sum_{i=1}^n\frac{\overline x(x_i-\overline x)}{l_{xx}}\beta_1\\</script><p>将后两项展开，可以得到一个平方项</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n\frac{(x_i-\overline x)}{l_{xx}}\beta_0+\sum_{i=1}^n\frac{(x_i-\overline x)^2}{l_{xx}}\beta_1</script><p>前面一项，因为$\sum<em>{i=1}^n(x_i-\overline x)=\sum</em>{i=1}^n x_i-n\overline x=0$​ ,因此</p>
<script type="math/tex; mode=display">
E(\hat\beta_1) = \beta_1</script><p>对于方差，就更为简单了：</p>
<script type="math/tex; mode=display">
Var(\hat\beta_1) = \sum_{i=1}^n(\frac{x_i-\overline x}{l_{xx}})^2Var(y_i)\\
= \sum_{i=1}^n \frac{(x_i-\overline x)^2}{(l_{xx})^2}\sigma^2 = \frac{\sigma^2}{l_{xx}}</script><ul>
<li>另一方面，考虑 $\hat\beta_0$ 的期望与方差，即</li>
</ul>
<script type="math/tex; mode=display">
E(\hat\beta_0) = E(\overline y)-E(\hat\beta_1)\overline x\\
~~~~~~~~~~~~~~~~~~~~~~~~=\frac{1}{n}\sum_{i=1}^n(\beta_0+\beta_1x)-\beta_1\overline x\\
~~~~~~~~~~~~~~~~~~~=\beta_0+\beta_1\overline x-\beta_1\overline x=\beta_0</script><p>方差：</p>
<script type="math/tex; mode=display">
Var(\hat\beta_0) = \sum_{i=1}^n(\frac{1}{n}-\frac{(x_i-\overline x)\overline x}{l_{xx}})^2\text{Var}(y_i)\\
=\sigma^2\sum_{i=1}^n(\frac{1}{n^2}-\frac{2(x_i-\overline x)\overline x}{nl_{xx}}+\frac{(x_i-\overline x)^2\overline x^2}{l^2_{xx}})\\
=\sigma^2(\frac{1}{n}+\frac{\overline x^2}{l_{xx}})</script><h5 id="第三步：求协方差"><a href="#第三步：求协方差" class="headerlink" title="第三步：求协方差"></a>第三步：求协方差</h5><p>因为 $y_1,y_2\cdots,y_n$相互独立，所以我们把第一步求出的$\beta_0,\beta_1$的式子带入，得到： </p>
<script type="math/tex; mode=display">
\text{Cov}(\hat\beta_0,\hat\beta_1) = \text{Cov}(\sum_{i=1}^n(\frac{1}{n}-\frac{(x_i-\overline x)\overline x}{l_{xx}})y_i~,\sum_{i=1}^n\frac{(x_i-\overline x)}{l_{xx}}y_i)</script><p>我们可以将它们看做是 $y_i$的线性组合之间的协方差。因为当$y_i$ 之间不相等，就说明他们是独立的，两个独立的协方差之间是0，因此我们只要看做是 $y_i,y_i$​即可.</p>
<p>那么，$y_i$​和$y_i$​的协方差就是$y_i$​​的方差，其方差为$\sigma^2$ ,前面$\sum$可以都看成是系数，提取出来即可，最后化简：</p>
<script type="math/tex; mode=display">
=\sum_{i=1}^n(\frac{1}{n}-\frac{(x_i-\overline x)\overline x}{l_{xx}})\sum_{i=1}^n\frac{(x_i-\overline x)}{l_{xx}}\sigma^2\\
=(\sum_{i=1}^n\frac{x_i-\overline x}{l_{xx}}-\sum_{i=1}^n\frac{(x_i-\overline x)^2\overline x}{l_{xx}} )\sigma^2\\
=-\frac{\overline x}{l_{xx}}\sigma^2</script><h5 id="第四步：给出推论"><a href="#第四步：给出推论" class="headerlink" title="第四步：给出推论"></a>第四步：给出推论</h5><ul>
<li>$\hat\beta_0,\hat\beta_1$​分别是$\beta_0,\beta_1$​​ 的无偏估计，而且这个无偏估计并不需要服从正态分布。 </li>
<li>除 $\overline x=0$ 外，$\hat\beta_0$与$\hat\beta_1$是相关的，只有当数据中心化以后才是不相关的</li>
<li><p>为了提高$\hat\beta<em>0,\hat\beta_1$的估计精度(即降低它们的方差)就要求样本量n增加，这样会使得$l</em>{xx}$增大，即要求 $x_1,\cdots,x_n$比较分散。这样会使得方差变小—数据波动更小</p>
<h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4></li>
</ul>
<blockquote>
<ul>
<li>我提出了一个假设之后，在建模中就要以这个假设为默认条件</li>
<li>在建模的过程中，提出了很多假设，我们要用数据去验证是否符合这些假设</li>
</ul>
</blockquote>
<p>那么在这个线性回归模型中，我们提出了什么假设呢？</p>
<ul>
<li>最核心的假定为：线性性。即x是会影响y的。否则，如果x不在式子里，我们能用样本均值来预测y了。那么加了x之后，预测效果会不会提升呢？肯定是会的。因此，我们首先要检验出：x是否会对y产生影响。如果没有，我们干嘛用x去预测y呢？</li>
</ul>
<h2 id="回归方程的显著性检验"><a href="#回归方程的显著性检验" class="headerlink" title="回归方程的显著性检验"></a>回归方程的显著性检验</h2><p>首先我们要来考虑$\beta_1$是否为0，若真的为0，那么其实$y$和 $x$之间是没有必然联系的，但是，我们估出来的$\hat\beta_1$可能不是0，那么这时候怎么进行判断呢？那么在这种情况下，对一个参数的估计有点类似于假设检验的问题。 检验问题为：</p>
<script type="math/tex; mode=display">
H_0:\beta_1 =0 ~~\text{vs} ~~H_1 : \beta_1 \neq 0</script><p>如果我们的得到的结论是拒绝$H_0$ ,那么我们认为回归方程是显著的。</p>
<p>接下来我们会介绍三种估计方法</p>
<h3 id="F检验"><a href="#F检验" class="headerlink" title="F检验"></a>F检验</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>我们用<strong>方差分析</strong>的思想：</p>
<ul>
<li>令回归值为 $\hat y_i = \hat\beta_0+\hat\beta_1 x_i$   残差：$e_i = y_i-\hat y_i$ </li>
<li><strong>偏差平方和</strong>为 $SS<em>T = \sum</em>{i=1}^n(y<em>i-\overline y)^2 = l</em>{yy}$​ ,其中 $\overline y = \frac{1}{n}\sum_{i=1}^n y_i$​ </li>
<li>引起$y<em>i$​ 不同的原因主要是因为$H_0$​ 可能不真，即$\beta_1\neq 0$​ ，即在每一个x的观测处的回归值都不相同。因此我们可以定义<strong>回归平方和</strong>为：$SS_R = \sum</em>{i=1}^n (\hat y_i-\overline y)^2$​​​ . 也就是落在直线上的点与均值的平方和</li>
<li>引起$y<em>i$​​​ 不同还可能因为误差，因此在得到回归值之后，y的观测值与回归值之间还有差异。因此可以定义<strong>残差平方和</strong>为：$SS_E = \sum</em>{i=1}^n (y_i-\hat y_i)^2$​ </li>
</ul>
<p>那么，我们可以在一元线性回归场合下的平方和分解式：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n(y_i-\overline y)^2 = \sum_{i=1}^n(y_i-\hat y_i+\hat y_i-\overline y)^2\\
=\sum_{i=1}^n(y_i-\hat y_i)^2+\sum_{i=1}^n(\hat y_i-\overline y)^2\\</script><p>我们发现，其交叉项是0</p>
<p>最后这个式子就代表： $SS_T = SS_R+SS_E$ </p>
<h4 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h4><p>设 $y_i = \beta_0+\beta_1x_i+\varepsilon_i$</p>
<p>其中， $\varepsilon_i,\cdots,\varepsilon_n$ 相互独立，且：</p>
<script type="math/tex; mode=display">
E(\varepsilon_i)= 0,\text{Var} (\varepsilon_i) = \sigma^2 ,i=1,2\cdots,n</script><p>我们有：</p>
<script type="math/tex; mode=display">
E(SS_R) = \sigma^2+\beta_1^2l_{xx}\\
E(SS_E) = (n-2)\sigma^2</script><h5 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h5><ul>
<li>我们首先来关注$SS_R$​</li>
</ul>
<p>它可以看做是有线性回归模型下的估计($\hat y$​) 与无线性回归模型下的估计($\overline y$​)的差的平方和</p>
<p>在最小二乘估计中我们得到了 $\hat\beta_0 = \overline y -\hat\beta_1\overline x $​,从中可以获得$\beta$关于 $\overline y$ 的式子</p>
<script type="math/tex; mode=display">
SS_R = \sum_{i=1}^n(\hat y_i-\overline y) = \sum_{i=1}^n((\hat\beta_0+\hat\beta_1 x_i)-(\hat\beta_0+\hat\beta_1\overline x))^2=\hat\beta_1^2l_{xx}</script><p>然后我们对 $SS_R$​求期望，这里面$\hat \beta_1$​是随机变量，这里假定x是固定的变量。运用 $Var(x)=(E(X))^2-E(X^2)$​ 可得</p>
<script type="math/tex; mode=display">
E(SS_R) =E(\hat\beta^2_1)l_{xx} =(Var(\hat\beta_1)+(E(\hat\beta_1))^2)l_{xx}\\</script><p>又因为在定理1中证明了$E(\hat\beta_1)$​是无偏的，$E(\hat\beta_1)=\beta_1$​</p>
<p>因此</p>
<script type="math/tex; mode=display">
=(\frac{\sigma^2}{l_{xx}}+\beta_1^2)l_{xx}\\
=\sigma^2+\beta_1^2l_{xx}</script><ul>
<li>然后来关注$SS_E$​</li>
</ul>
<script type="math/tex; mode=display">
SS_E = \sum_{i=1}^n(y_i-\hat y_i)^2 = \sum_{i=1}^n(\beta_0+\beta_1 x_i+\epsilon_i-\hat\beta_0-\hat\beta_1 x_i)^2\\
=\sum_{i=1}^n((\beta_0-\hat\beta_0)+(\beta_1-\hat\beta_1)x_i+\varepsilon_i)^2\\
=\sum_{i=1}^n((\beta_0-\hat\beta_0)^2+(\beta_1-\hat\beta_1)^2x_i^2+\varepsilon_i^2+2(\beta_0-\hat\beta_0)(\beta_1-\hat\beta_1)+2(\beta_0-\hat\beta_0)\varepsilon_i+2(\beta_1-\hat\beta_1)x_i\varepsilon_i)</script><blockquote>
<p> 我们可以把 $\sum_{i=1}^nE(\beta_0-\hat\beta_0)^2$​ 看做是n倍的$Var(\hat\beta_0)$​​  因为 $\hat\beta_0$是$\beta$的无偏估计，因此$\beta$可以看做是$E(\beta_0)$​</p>
<p>同理，$\sum<em>{i=1}^nE(\beta_1-\hat\beta_1)^2x_i^2=Var(\hat\beta_1)\sum</em>{i=1}^n x_i^2$​ </p>
<p>$2E(\sum_{i=1}^n(\beta_0-\hat\beta_0)(\beta_1-\hat\beta_1))=2nE(\beta_0-\hat\beta_0)(\beta_1-\hat\beta_1) = 2nCov(\hat\beta_1,\hat\beta_0)$​</p>
<p>又因为$\beta_0,\varepsilon_i$是独立的，因此：$E(\beta_0\varepsilon_i)=E(\beta_0)E(\varepsilon_i) = 0$​</p>
</blockquote>
<p>因此，</p>
<script type="math/tex; mode=display">
\begin{align}
E(SS_E) = &nVar(\hat\beta_0)+Var(\hat\beta_1)\sum_{i=1}^nx_i^2+nVar(\varepsilon_i)+2n\text{Cov}(\hat\beta_1,\hat\beta_0) \\
&-2\sum_{i=1}^nE(\hat\beta_0\varepsilon_i)-2\sum_{i=1}^nx_iE(\hat\beta_1\varepsilon_i)
\end{align}</script><p>在这个式子中，我们已知的是$nVar(\hat\beta_0),Var(\hat\beta_1),Var(\varepsilon_i),2nCov(\hat\beta_1,\hat\beta_0)$ 因此我们现在要算 $E(\hat\beta_0\varepsilon_i),E(\hat\beta_1\varepsilon_i)$​</p>
<p>首先我们要把$\hat\beta_0,\hat\beta_1$​​ 写成是$y_1,\cdots,y_n$的线性组合</p>
<script type="math/tex; mode=display">
\hat\beta_0 = \sum_i (\frac{1}{n}-\frac{(x_i-\overline x)\overline x}{l_{xx}})y_i\\
\hat\beta_1 = \sum_i \frac{(x_i-\overline x)}{l_{xx}}y_i</script><ul>
<li>对于 $E(\hat\beta_0\varepsilon_i)$,我们知道$y_i$之间是独立的 </li>
</ul>
<script type="math/tex; mode=display">
E(\hat\beta_0\varepsilon_i) =E(\varepsilon_i\sum_{j}(\frac{1}{n}-\frac{(x_j-\overline x)\overline x}{l_{xx}})y_i)\\

=E(\varepsilon_i\sum_{j}(\frac{1}{n}-\frac{(x_j-\overline x)\overline x}{l_{xx}})(\beta_0+\beta_1x_j+\varepsilon_j))\\</script><p>因此当 $j\neq i$ 的时候，期望可以写成 $E(\varepsilon_i)\cdot E(\cdots) = 0$,因此，只有当 $i=j$ 的时候才需要被留下：</p>
<script type="math/tex; mode=display">
\begin{align}
&E(\varepsilon_i\sum_{j}(\frac{1}{n}-\frac{(x_j-\overline x)\overline x}{l_{xx}})(\beta_0+\beta_1x_i+\varepsilon_i))\\
&= E(\varepsilon^2_i(\frac{1}{n}-\frac{(x_i-\overline x)\overline x}{l_{xx}}))\\
&=(\frac{1}{n}-\frac{(x_i-\overline x)\overline x}{l_{xx}})\sigma^2
\end{align}</script><ul>
<li>对于$E(\hat\beta_1\varepsilon_i)$,同样用类似的思路证明：</li>
</ul>
<script type="math/tex; mode=display">
\begin{align}
E(\hat\beta_1\varepsilon_i) &= E(\varepsilon_i\sum_{j}\frac{x_j-\overline x}{l_{xx}}y_j)\\
&=E(\varepsilon_i\sum_{j}\frac{(x_j-\overline x)}{l_{xx}}(\beta_0+\beta_1x_j+\varepsilon_i))\\
&=\frac{(x_i-\overline x)}{l_{xx}}\sigma^2
\end{align}</script><p>因此：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^nE(\hat\beta_0\varepsilon_i) = \sum_{i=1}^n(\frac{1}{n}-\frac{(x_i-\overline x)\overline x}{l_{xx}})\sigma^2= \sigma^2\\
\sum_{i=1}^n x_iE(\hat\beta_1\varepsilon_i) = \sum_{i=1}^n x_i\frac{(x_i-\overline x)}{l_{xx}}\sigma^2</script><p>已知 $l<em>{xx}=\sum</em>{i=1}^n(x<em>i-\overline x)^2 = \sum</em>{i=1}^n x<em>i^2-2\sum</em>{i=1}^nx<em>i\overline x+n(\overline x)^2=\sum</em>{i=1}^n x_i^2-n\overline x$​.  因此原式 $ = \sigma^2$</p>
<p>综上，</p>
<script type="math/tex; mode=display">
\begin{align}
E(SS_E ) &= n(\frac{1}{n}+\frac{\overline x^2}{l_{xx}})\sigma^2+\frac{\sigma^2}{l_{xx}}\sum_ix_i^2+n\sigma^2-2n\frac{\overline x^2}{l_{xx}}\sigma^2-2\sigma^2-2\sigma^2\\
&=\sigma^2(1+\frac{\sum x_i^2}{l_{xx}}-\frac{n\overline x^2}{l_{xx}}+n-4)\\
&=(n-2)\sigma^2
\end{align}</script><h4 id="定理3"><a href="#定理3" class="headerlink" title="定理3"></a>定理3</h4><p>设 $y_1,\cdots,y_n$ 相互独立，且：</p>
<script type="math/tex; mode=display">
y_i\sim N(\beta_0+\beta_1x_i,\sigma^2),i = 1,2\cdots,n\\</script><p>则有：</p>
<ul>
<li>$SS_E/\sigma^2\sim\mathcal X^2(n-2)$</li>
<li>若$H_0$ 成立，则有 $SS_R/\sigma^2\sim \mathcal X^2(1)$</li>
<li>$SS_R$​​与 $SS_E$​​，$\overline y$​​ 独立 </li>
</ul>
<p>这三点在回归里面是非常核心的，其重要性在于其构造出了F检验。</p>
<h5 id="证明-1"><a href="#证明-1" class="headerlink" title="证明-1"></a>证明-1</h5><p>首先，我们需要构造一个<strong>正交矩阵A</strong>，形如：</p>
<p><img src="/2021/10/11/%E4%B8%80%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/2.png" alt="1" style="zoom:67%;"></p>
<p>根据正交矩阵的性质$AA’=I$​, 则A需要满足：</p>
<script type="math/tex; mode=display">
\sum_k  a_{i,k}a_{j,k} =0,1\leq i<j\leq n-2\\
\frac{1}{\sqrt n} \sum_j a_{i,j} = 0\\
\sum_j a_{i,j}\frac{x_j-\overline x}{\sqrt{l_{xx}}}\\
\sum_{j}(a_{i,j})^2 = 1</script><blockquote>
<p>第一个条件是说，如果i和j不相等的话，那么第i行和第j行对应元素的乘积的和是要等于0的</p>
<p>第二个条件是：前面n-2行与倒数第二行的对应元素的乘积的和要等于0，因为不再对角线上</p>
<p>第三个条件是：前面n-2行与最后一行的对应元素的乘积的和要等于0，因为也不再对角线上</p>
<p>第四个条件是: 对角线上要满足都是1，因此每一行各个元素的平方和为1</p>
</blockquote>
<p>在这个矩阵中，前面 n-2行是不确定的，因此有 n(n-2)的未知数。然后第一个条件有$\pmatrix{n-2\2}$​个方程，后面三个条件每一个都有$n-2$​个方程，因此一共有 $\frac{(n-2)(n-3)}{2}$个方程。​</p>
<p>因此，只要 $n\geq 3$​ ，未知参数个数不少于方程个数，因此，正交矩阵A一定是存在的</p>
<p>接下来，我们令 $z=Ay$, 其中 $z=(z_1,z_2\cdots,z_n)’$ 满足</p>
<script type="math/tex; mode=display">
z_i = \sum_ja_{ij}y_j, ~~i = 1,\cdots,n-2\\
z_{n-1} = \frac{\sum_{j}(x_j-\overline x)y_j}{\sqrt{l_{xx}}} = \frac{\sum_{j} (x_j-\overline x)(y_j-\overline y)}{\sqrt{l_{xx}}} = \frac{l_{xy}}{\sqrt{l_{xx}}} = \sqrt{l_{xx}} \cdot  \frac{l_{xy}}{l_{xx }} = \sqrt {l_{xx }}\hat\beta_1\\
z_n = \frac{1}{\sqrt n}\sum_j y_j = \sqrt n \overline y</script><blockquote>
<p>第二个式子是因为：$l<em>{xy} = \sum</em>{i=1}^n x_iy_i-n\overline x\cdot \overline y$</p>
<p>又： $\sum<em>{i=1}^n (x_i-\overline x)y_i = \sum</em>{i=1}^nx<em>iy_i-\sum</em>{i=1}^n y<em>i\overline x= \sum</em>{i=1}^n x_iy_i-n\overline y\cdot\overline x$ </p>
<p>两者是等价的</p>
</blockquote>
<p>我们看到z也是正态随机变量的线性组合，因此可以很方便的记录其均值和方差：</p>
<script type="math/tex; mode=display">
E(z_i) = E(\sum_j a_{ij}y_j) = \sum_j a_{ij}(\beta_0+\beta_1x_j)\\
=\beta_0\sum_j a_{ij} +\beta_1\sum_ja_{ij}x_j = 0,i=1,\cdots,n\\
E(z_{n-1}) = \sqrt{l_{xx}}\beta_1\\
E(z_n) = \sqrt n (\beta_0+\beta_1\hat x)\\
Var(z) = Var(Ay) = \bold{A}Var(y)\bold{A}' = \bold{A}\sigma^2\bold{I_n}\bold{A'} = \sigma^2\bold{I_n}</script><blockquote>
<p>$\sum<em>ja</em>{ij}=0$​,因此 第一个式子等于0</p>
</blockquote>
<p>由上面的结论，可以得出以下结论：</p>
<ul>
<li>我们知道Z是服从正态分布的，又z的方差为对角矩阵，是不存在协方差的。因此，$z_1,z_2\cdots,z_n$是相互独立的。</li>
<li>前n-2个分量$z_1,z_2\cdots,z_n$是独立同分布的，且分布为$N(0,\sigma^2)$</li>
<li>$z<em>{n-1}$的分布为$N(\sqrt{l</em>{xx}}\beta_1,\sigma^2 )$</li>
<li>$z_n$ 的分布为$N(\sqrt n(\beta_0+\beta_1\overline x),\sigma^2)$</li>
</ul>
<p>最后，我们要用$z$去表示 $SS_T,SS_R,SS_E$</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n z_i^2 = z'z = \bold{y'A'Ay} = \bold{y'y} = \sum_{i}y_i^2 =l_{yy}+n\overline y^2= SS_T +n\overline y^2\\
z_{n-1} = \sqrt{l_{xx}}\hat\beta_1 = \sqrt {SS_R}\\
z_n = \sqrt n\overline y</script><p>然后我们可以整理为：</p>
<script type="math/tex; mode=display">
SS_T+n\overline y^2 =\sum_{i=1}^n z_i^2 =  \sum_{i=1}^{n-2} z_i^2+SS_R+n\overline y^2\\</script><p>即 $SS<em>T = \sum</em>{i=1}^{n-2}z_i^2+SS_R$</p>
<p>因为 $SS_T = SS_R+SS_E$,所以 $SS_E$的分布就得到了：是一些列正态随机变量的平方和，是一个卡方分布</p>
<script type="math/tex; mode=display">
SS_E = \sum_{i=1}^{n-2}z_i^2\sim \mathcal X^2(n-2)</script><h5 id="证明-2"><a href="#证明-2" class="headerlink" title="证明-2"></a>证明-2</h5><p>若$H_0$成立,则$\beta_1= 0$, 可以得到：</p>
<script type="math/tex; mode=display">
\sqrt {SS_R} = z_{n-1}\sim N(0,\sigma^2)</script><p>所以，变换得到：</p>
<script type="math/tex; mode=display">
\frac{SS_R}{\sigma^2} = (\frac{z_{n-1}}{\sigma})^2\sim \mathcal X^2(1)</script><h5 id="证明-3"><a href="#证明-3" class="headerlink" title="证明-3"></a>证明-3</h5><p>因为$SS<em>E$与前 $n-2$个$z_i$有关，$SS_R$仅与 $z</em>{n-1}$有关，$\overline y$仅与$z_n$有关，因此$SS_R$和 $SS_E,\overline y$相互独立</p>
<p>因为$\hat\beta_1$ 仅与$SS_R$有关，所以$\hat\beta_1$与$SS_E,\overline y$​相互独立</p>
<h4 id="检验统计量"><a href="#检验统计量" class="headerlink" title="检验统计量"></a>检验统计量</h4><p>现在我们来进行假设检验：</p>
<p>构造形如</p>
<script type="math/tex; mode=display">
F_0 = \frac{SS_R}{SS_E/(n-2)}</script><p>的检验统计量来检验。那么，在$\beta_1 = 0$时，$F\sim F(1,n-2)$，对于给定的显著性水平$\alpha$,其拒绝域为：</p>
<script type="math/tex; mode=display">
F_0\geq F_{1-\alpha}(1,n-2)</script><p>即大于临界值，SSR就越大，说明$\beta_1$是起作用的，我们就拒绝原假设</p>
<p>这就是F检验</p>
<p><img src="/2021/10/11/%E4%B8%80%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/3.png" style="zoom:67%;"></p>
<h3 id="t检验"><a href="#t检验" class="headerlink" title="t检验"></a>t检验</h3><p>如果说F检验的方法的内核是方差分析，那么t检验的方法的内核就是参数估计了——我通过去找到点估计，找到枢轴量，构造检验统计量然后去做检验。</p>
<h4 id="检验统计量-1"><a href="#检验统计量-1" class="headerlink" title="检验统计量"></a>检验统计量</h4><p><img src="/2021/10/11/%E4%B8%80%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/6.png" style="zoom:67%;"></p>
<h3 id="相关系数的检验"><a href="#相关系数的检验" class="headerlink" title="相关系数的检验"></a>相关系数的检验</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>现在我们来聊第三个问题，一个模型中$\beta_1$ 如果不起作用的话，就说明x，y之间是没有线性关系的。</p>
<p>那么，由于一元线性回归方差可以反映出两个随机变量x与y间的相关关系时，它的显著性检验还可以通过对二维总体相关系数$\rho$​的检验进行。</p>
<p>假设为：</p>
<script type="math/tex; mode=display">
H_0:\rho = 0~~~vs~~~H_1:\rho\neq 0</script><p>如果样本相关系数很小，很有理由认为总体均值为0，接受原假设，反之，我们拒绝原假设。</p>
<p>我们将样本相关系数作为检验统计量：</p>
<script type="math/tex; mode=display">
r = \frac{\sum_{i=1}^n(x_i-\overline x)(y_i-\overline y)}{\sqrt{\sum_{i=1}^n(x_i-\overline x)^2\sum_{i=1}^n(y_i-\overline y)^2}} = \frac{l_{xy}}{\sqrt{l_{xx}l_{yy}}}</script><p>下面我们用具体的图来理解样本相关系数的大小：</p>
<p><img src="/2021/10/11/%E4%B8%80%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/4.png" style="zoom: 50%;"></p>
<p>对于a、b两张图，直线是确定的，所有点都在直线上面。因此我们算出来的样本相关系数的绝对值算出来一定是1</p>
<p>对于c，我们发现这个点的分布基本是随机地，散乱的，此时其相关系数接近于0</p>
<p>对于d，我们发现点复合某个函数，并不是线性的，但是其相关系数也不等于0</p>
<p>对于e、f，状态是比较理想的。</p>
<h4 id="检验统计量-2"><a href="#检验统计量-2" class="headerlink" title="检验统计量"></a>检验统计量</h4><p>当$H_0$为真时，$|r|$应该比较小；当 $|r|$​  比较大的时候，应该拒绝原假设</p>
<p>因此，拒绝域为${|r|\geq c}$ ，其中，临界值c可以由$H_0$成立时的样本相关系数的分布确定，该分布与自由度$n-2$有关。</p>
<p>对给定的显著性水平$\alpha$ ,由$P(W) = P(|r|\geq c)=\alpha$ 可知，临界值c应该是$H<em>0:\rho = 0$成立下r的分布的$1-\alpha/2$ 分位数，故我们记为：$c = r</em>{1-\alpha/2}(n-2)$</p>
<p>那么，这个临界值的式子给出了，怎么获得呢? 因此我们要考虑三个检验之间的关系</p>
<h2 id="三种检验之间的关系"><a href="#三种检验之间的关系" class="headerlink" title="三种检验之间的关系"></a>三种检验之间的关系</h2><h3 id="t检验与F检验统计量的关系"><a href="#t检验与F检验统计量的关系" class="headerlink" title="t检验与F检验统计量的关系"></a>t检验与F检验统计量的关系</h3><script type="math/tex; mode=display">
t_0^2=(\frac{\hat\beta_1}{\hat\sigma/\sqrt{l_{xx}}})^2 = \frac{\hat\beta_1^2l_{xx}}{\sqrt{SS_E/(n-2)}} = \frac{SS_R}{SS_E/(n-2)} = F_0</script><p>其中，第三个等式成立是因为回归平方和$SS_R$与$\hat\beta_1$之间存在如下关系：</p>
<script type="math/tex; mode=display">
SS_R = \sum_{i=1}^n(\hat y_i-\overline y)^2 = \sum_{i=1}^n(\hat\beta_0+\hat\beta_1x_i-\overline y)^2\\
=\sum_{i=1}^n[\overline y+\hat\beta_1(x_i-\overline x)-\overline y]^2 \\
=\sum_{i=1}^n[\hat\beta_1(x_i-\overline x)]^2= \beta_1^2l_{xx}</script><p>因此，实际上F检验和t检验是等价的。</p>
<h3 id="F检验统计量与r的关系"><a href="#F检验统计量与r的关系" class="headerlink" title="F检验统计量与r的关系"></a>F检验统计量与r的关系</h3><script type="math/tex; mode=display">
r^2 = (\hat\beta_1\sqrt{\frac{l_{xx}}{l_{yy}}})^2 = \hat\beta_1^2\frac{l_{xx}}{l_{yy}} = \frac{SS_R}{SS_T} = \frac{SS_R}{SS_R+SS_E}</script><p>分子分母同除以 $SS_E/(n-2)$可以得到:</p>
<script type="math/tex; mode=display">
=\frac{SS_R/(SS_E/(n-2))}{SS_R/(SS_E/(n-2))+n-2}=\frac{F_0}{F_0+(n-2)}</script><p>这表明了 $|r|$ 是 $F<em>0$ 的严格单调增函数，因此可以从F分布的$1-\alpha$ 分位数 $F</em>{1-\alpha}(1,n-2)$ 得到相关系数检验 所需要确定的临界值 $r_{1-\alpha/2}(n-2)$, 即</p>
<script type="math/tex; mode=display">
r_{1-\alpha/2}(n-2) = \sqrt{\frac{F_{1-\alpha}(1,n-2)}{F_{1-\alpha}(1,n-2)+(n-2)}}</script><p>因此，$r^2$ 会常常作为回归分析中一项重要的指标。我们定义<strong>样本决定系数</strong>为<strong>回归平方和</strong>与<strong>总偏差平方和</strong>之比，即：</p>
<script type="math/tex; mode=display">
r^2 = \frac{SS_R}{SS_T}</script><p>样本决定系数$r^2$是一个回归直线与样本观测值拟合优度的相对指标，反应因变量的波动中能用自变量解释的比例。$r^2$ 的取值在0到1之前。 $r^2$​越接近1，拟合度越好</p>
<blockquote>
<p>通常来说我们更看中$R^2$​ 其定义是 $\frac{SS_R}{SS_T}$ ，在一元线性回归中，刚好其等于样本方差的平方即 $R^2 =r^2$​</p>
</blockquote>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li>三种检验方法在一元线性回归模型下是等价的</li>
<li>但在多元线性回归场合，经推广F检验仍然可用，另两个检验就无法使用了</li>
<li>如果无法拒绝原假设，则可以认为回归方程不是显著的，导致这种情况可能有如下几种原因<ul>
<li>误差与正态假设严重偏离</li>
<li>Y与X无关</li>
<li>Y与X虽然相关，但不是线性关系</li>
<li>Y与X以外的因素有更密切的关系</li>
</ul>
</li>
</ul>
<h2 id="估计与预测"><a href="#估计与预测" class="headerlink" title="估计与预测"></a>估计与预测</h2><p>之前我们所说的都是建模，然后确定模型是否有效。现在我们终于要来做预测了。那么，我们对什么来做预测呢？——随机变量。</p>
<p>当$x=x_0$时，我们关心的是 $y_0 = \beta_0+\beta_1x_0+\epsilon_0$ </p>
<p>注意到，$y_0$是本身一个随机变量。 对于一个随机变量，在掌握了单个数值信息的情况下是很难刻画y的分布的，因此我们可以构造一个区间，使得$y_0$ 落在区间的概率为$1-\alpha$,即确定一个常数$\var$ 使得$P(|y_0-\hat y_0|\leq \var) = 1-\alpha$ ，称区间$[\hat y_0-\var,\hat y_0+\var]$ 为$y_0$的概率为$1-\alpha$ 的预测区间，这是一个<strong>预测问题</strong></p>
<h3 id="关于-E-y-0-​的估计"><a href="#关于-E-y-0-​的估计" class="headerlink" title="关于$E(y_0)$​的估计"></a>关于$E(y_0)$​的估计</h3><h4 id="点估计"><a href="#点估计" class="headerlink" title="点估计"></a>点估计</h4><p>我们只能通过期望。在$x=x_0$时，我们需要考虑$E(y_0) = \beta_0+\beta_1x_0$​ 一个直观的估计为：</p>
<script type="math/tex; mode=display">
\hat E(y_0) = \hat\beta_0+\hat\beta_1x_0</script><p>通常记为$\hat y_0$​ , 表示在 $x=x_0$ 时响应变量的估计值</p>
<h4 id="定理-4"><a href="#定理-4" class="headerlink" title="定理 4"></a>定理 4</h4><p>如果 $y_1,y_2\cdots,y_n$ 是相互独立的且$y_i$ 是正态分布随机变量，即 $y_i\sim N(\beta_0+\beta_1x_i,\sigma^2)$,那么，对给定的$x_0$</p>
<script type="math/tex; mode=display">
\hat y_0 = \hat\beta_0+\hat\beta_1x_0 \sim N(\beta_0+\beta_1x_0,(\frac{1}{n}+\frac{(x_0-\overline x)^2}{l_{xx}})\sigma^2)</script><h5 id="证明-2"><a href="#证明-2" class="headerlink" title="证明"></a>证明</h5><p>根据定理1可得：</p>
<script type="math/tex; mode=display">
\hat\beta_0\sim N(\beta_0,(\frac{1}{n}+\frac{\overline x^2}{l_{xx}})\sigma^2)\\
\hat\beta_1\sim N(\beta_1,\frac{\sigma^2}{l_{xx}})</script><p>因此在给定$x_0$的时候，$\hat y_0$ 也是 $y_1\cdots,y_n$的线性组合，因此$\hat y_0$ 也服从正态分布。其均值和方差为：</p>
<script type="math/tex; mode=display">
\begin{align}
E(\hat y_0)&= E(\hat\beta_0)+E(\hat\beta_1)x_0 = \beta_0+\beta_1x_0\\
Var(\hat y_0)& = Var(\hat\beta_0+\hat\beta_1x_0)\\
&=Var(\hat\beta_0)+Var(\hat\beta_1)x_0^2+2Cov(\hat\beta_0,\hat\beta_1)x_0\\
&=(\frac{1}{n}+\frac{\overline x^2}{l_{xx}})\sigma^2+\frac{x_0^2\sigma^2}{l_{xx}}-\frac{2\overline xx_0}{l_{xx}}\sigma^2\\
&=(\frac{1}{n}+\frac{(x_0-\overline x)^2}{l_{xx}})\sigma^2
\end{align}</script><h4 id="区间估计"><a href="#区间估计" class="headerlink" title="区间估计"></a>区间估计</h4><p>已知$\hat y_0$的分布为</p>
<script type="math/tex; mode=display">
\hat y_0 = \hat\beta_0+\hat\beta_1x_0 \sim N(\beta_0+\beta_1x_0,(\frac{1}{n}+\frac{(x_0-\overline x)^2}{l_{xx}})\sigma^2)</script><p>现在要构造枢轴量，其中，$\sigma^2$ 可以用其估计代替</p>
<p>于是，我们有：</p>
<script type="math/tex; mode=display">
\frac{(\hat y_0-E(y_0))/\sqrt{\frac{1}{n}+\frac{x_0-\overline x}{l_{xx}}\sigma^2}}{\sqrt{\frac{SS_E}{\sigma^2}/(n-2)}} =\frac{\hat y_0-E(y_0)}{\hat\sigma\sqrt{\frac{1}{n}+\frac{(x_0-\overline x)^2}{l_{xx}}}}\sim t(n-2)</script><p>因此，$E(y_0)$的置信水平为$1-\alpha$的置信区间为：</p>
<script type="math/tex; mode=display">
[\hat y_0-\var,\hat y_0+\var]</script><p>其中，</p>
<script type="math/tex; mode=display">
\var = t_{1-\alpha/2}(n-2)\hat\sigma\sqrt{\frac{1}{n}+\frac{(x_0-\overline x)^2}{l_{xx}}}</script><h3 id="关于-y-0-​​-的预测"><a href="#关于-y-0-​​-的预测" class="headerlink" title="关于$y_0 $​​ 的预测"></a>关于$y_0 $​​ 的预测</h3><h4 id="点预测"><a href="#点预测" class="headerlink" title="点预测"></a>点预测</h4><p>在预测$y_0$的时候，我们如果考虑点预测，那么通常我们还是取这个随机变量的均值，于是$y_0$的点预测也是$\hat y_0$</p>
<p>但是，由于$y_0$是一个连续随机变量，恰好取到一个点的概率为0，因此在实际应用中，对$y_0$进行区间预测更为合理。</p>
<h4 id="区间预测"><a href="#区间预测" class="headerlink" title="区间预测"></a>区间预测</h4><p>事实上 $y_0 = E(y_0)+\varepsilon_0$ ，因为通常假定$\varepsilon_0\sim N(0,\sigma^2)$ ，所以$y_0$的最有可能的取值仍然是$\hat y_0$ </p>
<p>因此，我们可以使用一个以$\hat y_0$为中心的区间：</p>
<script type="math/tex; mode=display">
[\hat y_0-\var,\hat y_0+\var]</script><p>作为$y_0$的取值范围，如何确定$\var$的值是需要进一步讨论的。</p>
<p>和$E(y_0)$的去测过程一样，我们要构造一个枢轴量</p>
<p>一方面，我们知道：</p>
<script type="math/tex; mode=display">
y_0\sim N(\beta_0+\beta_1x_0,\sigma^2)</script><p>其点预测我们之前已经推出：</p>
<script type="math/tex; mode=display">
\hat y_0 = \hat\beta_0+\hat\beta_1x_0 \sim N(\beta_0+\beta_1x_0,(\frac{1}{n}+\frac{(x_0-\overline x)^2}{l_{xx}})\sigma^2)</script><p>又因为 $y_0$ 与$\hat y_0$ 独立，所以：</p>
<script type="math/tex; mode=display">
y_0-\hat y_0 \sim N(0,(1+\frac{1}{n}+\frac{(x_0-\overline x)^2}{l_{xx}})\sigma^2)</script><p>另一方面，因为 ${(n-2)\hat\sigma^2}/{\sigma^2}\sim \mathcal{X^2}(n-2)$​​，而且$y_0,\hat y_0,\hat\sigma^2$相互独立，所以有：</p>
<script type="math/tex; mode=display">
\frac{y_0-\hat y_0}{\hat\sigma\sqrt{1+\frac{1}{n}+\frac{(x_0-\overline x)^2}{l_{xx}}}}\sim t(n-2)</script><p>因此，预测区间为：</p>
<script type="math/tex; mode=display">
[\hat y_0-\var,\hat y_0+\var]</script><p>其中，$\var$ 为：</p>
<script type="math/tex; mode=display">
\var = \var(x_0) = t_{1-\alpha/2}(n-2)\hat\sigma\sqrt{1+\frac{1}{n}+\frac{(x_0-\overline x)^2}{l_{xx}}}</script><p>我们发现，估计区间中的$\var$和预测区间中的$\var$ 是不一样的，预测区间中的$\var$会更加宽一点。因此我们发现，当预测的时候，波动更大，因为我们会引入新样本。</p>
<p><img src="/2021/10/11/%E4%B8%80%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/5.png"></p>
<p>观察上图，我们发现预测区间呈现一个喇叭口的形状，越接近$\overline x$ 越窄，越两变越宽。说明数据波动的越大，会导致$\sigma$的估计越大，最终导致$\var$越大。</p>
<p>此外我们还要知道，这个区间是和样本量有关系的，如果样本量越大，$n$越大，因此区间会越窄</p>
<p>此外，如果我们要预测的新样本和训练集的均值离得非常远，那么预测区间就越大，预测效果就越差。在一元线性回归中，表现为离均值$\overline x$越远预测效果越差。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/10/07/%E5%A4%9A%E9%87%8D%E6%AF%94%E8%BE%83%E5%92%8C%E5%8F%8C%E5%9B%A0%E5%AD%90%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/07/%E5%A4%9A%E9%87%8D%E6%AF%94%E8%BE%83%E5%92%8C%E5%8F%8C%E5%9B%A0%E5%AD%90%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">多重比较和双因子方差分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-10-07 08:38:20" itemprop="dateCreated datePublished" datetime="2021-10-07T08:38:20+08:00">2021-10-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-05 13:13:02" itemprop="dateModified" datetime="2022-01-05T13:13:02+08:00">2022-01-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="多重比较和双因子方差分析"><a href="#多重比较和双因子方差分析" class="headerlink" title="多重比较和双因子方差分析"></a>多重比较和双因子方差分析</h1><p>之前我们学习了单因子方差分析，单因子方差分析是用来比较分组之间均值是否相等的问题，但是当我们拒绝原假设之后，我们不知道哪些组是相等的，哪些组是不相等的。因此我们需要进一步考虑这个问题。</p>
<h2 id="多重比较"><a href="#多重比较" class="headerlink" title="多重比较"></a>多重比较</h2><h3 id="水平均值差的置信区间"><a href="#水平均值差的置信区间" class="headerlink" title="水平均值差的置信区间"></a>水平均值差的置信区间</h3><p>首先我们要想，到底是原假设成立的时候，因子A是显著的还是备择假设成立的时候因子A是显著的。答案是<strong>备择假设</strong>，因为当原假设成立的时候，不同组之间的均值是相等的，因此因子A是不显著的。</p>
<p>当因子A显著时，有充分的理由认为因子A的各个水平中<strong>至少存在一对的均值是不相等的</strong>。但这并不说明，所有的水平均值都是不相等的。那么，我们就想知道哪些水平的均值是不相等的。一个很自然的想法就是，给定一对水平$(i,i’)$  ，构造$\mu<em>i-\mu</em>{i’}$​ 的区间估计。如果该区间不包括0，就说明$\mu<em>i$和$\mu</em>{i’}$必不相等。</p>
<p>我们来构造区间估计的枢轴量：</p>
<ul>
<li>分布为：</li>
</ul>
<script type="math/tex; mode=display">
\overline{y_{i\cdot}}\sim N(\mu_i,\frac{\sigma^2}{m})~ \text{和}~~\overline{y_{i'}}\sim N(\mu_{i'},\frac{\sigma^2}{m})</script><p>因为两者独立，所以 $\overline y<em>{i\cdot}-\overline y</em>{i’}\sim N(\mu<em>i-\mu</em>{i’},2\sigma^2m^{-1})$​ . 对其进行标准化：</p>
<script type="math/tex; mode=display">
\frac{(\overline y_{i\cdot}-\overline y_{i'})-(\mu_i-\mu_{i'})}{\sqrt{2\sigma^2m^{-1}}}\sim N(0,1)</script><p>因为这个分布中$\sigma^2$是未知的，我们要用其估计 $\hat\sigma^2$来代替。估计哪里来呢？在两样本方差t检验中，定义的是和方差。那么在这个情况下，每一组都是对方差的一个估计，那么我们只要对每一组方差都进行一个加权平均就可以了。即$SS_E/n-a$  ，分母是由a个水平，每个水平是(m-1) 乘起来就是 $n-a$​​ 。 这样的估计更加稳定，因为有更多的组，波动更小。</p>
<p><img src="/2021/10/07/%E5%A4%9A%E9%87%8D%E6%AF%94%E8%BE%83%E5%92%8C%E5%8F%8C%E5%9B%A0%E5%AD%90%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90/9.png"> </p>
<h3 id="多重比较问题"><a href="#多重比较问题" class="headerlink" title="多重比较问题"></a>多重比较问题</h3><p>问题又来了，如果是两样本t检验的区间估计，只存在一个区间，但是在这个问题中,一共有a个不同的水平，总共有 a(a-1)/2 对不同的水平组合，每一对水平都有一个置信水平为1的置信区间。然而，要求其同时成立的话，其联合置信水平就无法达到$1-\alpha$了</p>
<p>比如说，若$A_1,A_2\cdots,A_k$ 表示k个随机事件，且每个事件发生的概率均为$1-\alpha$ ,即 $P(A_i)=1-\alpha.i=1,2\cdots,k$ 则其共同发生的概率为：</p>
<script type="math/tex; mode=display">
\begin{align}
P(\cap_{i=1}^k A_i) &\leq P(A_1) = 1-\alpha\\
P(\cap_{i=1}^k A_i) &= 1-P(\cup_{i=1}^k\overline A_i)\\
&\geq 1-\sum_{i=1}^k P(\overline A_i) = 1-k(1-(1-\alpha))\\
&=1-k\alpha
\end{align}</script><p>这说明它们同时发生的概率实际上要在$1-k\alpha$ 和 $1-\alpha$ 之间，可能要比 $1-\alpha$ 小很多</p>
<p>那么，为了使得它们同时发生的概率不低于$1-\alpha$ ，一个很自然的方法就是把每个事件发生的概率都提高。也就是让$\alpha$ 取得更小，让置信水平从 $1-\alpha/2$ 提高到 $1-\alpha/(a(a-1)/2)$ </p>
<p>于是：</p>
<script type="math/tex; mode=display">
P(\cap_{i=1}^{a(a-1)/2}A_i) \geq 1-a(a-1)/2\cdot\frac{\alpha}{a(a-1)/2} = 1-\alpha</script><p>这叫做<em>Bonferroni</em>方法，虽然这种方法非常简单，但是会导致所得到的置信区间过于保守，精度很差</p>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>在方差分析中，经F检验拒绝原假设，表明因子A是显著的，即a个水平的均值不全相等。进一步，我们需要确定哪些水平之间是存在差异的，哪些水平之间是没有差异的。</p>
<p>在$a(a&gt;2)$ 个水平均值中同时比较任意两个水平均值间有无明显差异的问题叫做<strong>多重比较</strong>，也就是说，在显著性水平为 $\alpha$ 同时检验 $a(a-1)/2$ 个假设</p>
<script type="math/tex; mode=display">
H_0^{ii'}:\mu_i = \mu_{i'} .\\1\leq i<i'\leq a</script><p>当$H<em>0^{ii’}$​ 成立时，$|\overline y</em>{i\cdot}-\overline y_{i’}|$​ 不应过大，过大就应该拒绝 $H_0^{ii’}$​</p>
<p>于是，在同时考察这些 $H_0^{ii’}$ 时，这些$H_0^{ii’}$中至少有一个不成立就构成了多重比较检验的拒绝域，即拒绝域的形式就是：</p>
<script type="math/tex; mode=display">
W=\bigcup_{1\leq i<i'\leq a}\{|\overline y_{i\cdot}-\overline y_{i'\cdot}|\geq c_{ii'}\}</script><p>其中$c_{ii’}$是临界值，由原假设 $H_0^{ii’}$成立时$P(W)=\alpha$ 来确定。 </p>
<h3 id="Tukey方法"><a href="#Tukey方法" class="headerlink" title="Tukey方法"></a>Tukey方法</h3><p>由多重比较我们可以得出，要求 $a(a-1)/2$​​​ 个临界值$c<em>{ii’}$​​ 这是很烦的一件事， 而Tukey方法则对其进行了简化，对所求的临界值提出一些合理的假设。因为由于<strong>各个水平下重复次数均相等</strong>，基于对称性一个很自然的要求是$c</em>{ii’}$​​是相等的，我们记为c。</p>
<script type="math/tex; mode=display">
P(W) = P(\bigcup_{i\leq i<i'\leq a}\{|\overline y_{i\cdot}-\overline y_{i'\cdot}|\geq c\})\\
=1-P(\bigcap_{1\leq i<i'\leq a}\{|\overline y_{i\cdot}-\overline y_{i'\cdot}|< c\})\\
=1-P(\max_{1\leq i<i'\leq a}\{|\overline y_{i\cdot}-\overline y_{i'\cdot}|< c\})\\
=P(\max_{1\leq i<i'\leq a}\{|\overline y_{i\cdot}-\overline y_{i'\cdot}|\geq c\})\\
=P(\max_{1\leq i<i'\leq a}|\frac{(\overline y_{i\cdot}-\mu)-(\overline y_{i'\cdot}-\mu)}{\hat\sigma/\sqrt m}|\geq \frac{c}{\hat\sigma/\sqrt m}\})\\
=P(\max_{i}\frac{(\overline y_{i\cdot}-\mu)}{\hat\sigma/\sqrt m}-\min_{i}\frac{\overline y_{i\cdot}-\mu}{\hat\sigma/\sqrt m}\geq \frac{c}{\hat\sigma/\sqrt m}\})\\</script><p>第一步就是 德摩根公式。</p>
<p>第二步：要求交集小于c，就是要让这里面最大的差值要小于c</p>
<p>第三步：正常转换</p>
<p>第四步：标准化，分子让其减去$\mu$和加上$\mu$,分母上除以$\hat\sigma/\sqrt m$ </p>
<p>第五步：我们要求第四步式子的最大值，一定是最大减最小值。</p>
<p>我们要确定c的值，就要将c反解出来。</p>
<p>我们令不等号左边的式子为一随机变量：这是一个很复杂的随机变量，既有矩又有次序统计量。</p>
<script type="math/tex; mode=display">
q(a,df)=\max_{i}\frac{(\overline y_{i\cdot}-\mu)}{\hat\sigma/\sqrt m}-\min_{i}\frac{\overline y_{i\cdot}-\mu}{\hat\sigma/\sqrt m}</script><p>因为 </p>
<script type="math/tex; mode=display">
\frac{\overline y_{i\cdot}-\mu}{\hat\sigma/\sqrt m}\sim t(n-a)</script><p>在原假设成立的情况下，$\mu_i$都为$\mu$ </p>
<p>$q(a,df)$ 可以看做a个独立同分布的自由度为df的t分布的随机变量的极差。一般称q为t化极差统计量。</p>
<p>这个分布并不是常见的分布，它与水平数目a和t分布的自由度 df=n-a有关，但是与$\mu,\sigma^2,m$​ 无关。</p>
<h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>那么，如何获得t化极差统计量的分布？可以通过蒙特卡罗方法获得：</p>
<p><img src="/2021/10/07/%E5%A4%9A%E9%87%8D%E6%AF%94%E8%BE%83%E5%92%8C%E5%8F%8C%E5%9B%A0%E5%AD%90%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90/1.png" style="zoom:67%;"></p>
<h4 id="反解"><a href="#反解" class="headerlink" title="反解"></a>反解</h4><p>我们可以由：</p>
<script type="math/tex; mode=display">
P(W) = P(q(a,df)\geq \sqrt m c/\hat\sigma) = \alpha</script><p>来推出：</p>
<script type="math/tex; mode=display">
c=q_{1-\alpha}(a,df)\hat\sigma/\sqrt m</script><p>其中，$q_\alpha(a,df)$表示$q(a,df)$的$\alpha$分位数</p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>在给定的显著性水平$\alpha$下，确定t化极差统计量的分位数$q<em>{1-\alpha}(a,df)$ 并计算 $c=q</em>{1-\alpha}(a,df)\hat\sigma/\sqrt m$</p>
<p>比较每一组样本均值的差与临界值c的大小，如果$|\overline y<em>{i\cdot}-\overline y</em>{i’\cdot}\geq c$</p>
<p>那么认为水平i与水平 $i’$ 之间有显著差异，反之则认为这两个水平之间无差异</p>
<h2 id="双因子方差分析"><a href="#双因子方差分析" class="headerlink" title="双因子方差分析"></a>双因子方差分析</h2><h3 id="主效应与交互效应"><a href="#主效应与交互效应" class="headerlink" title="主效应与交互效应"></a>主效应与交互效应</h3><p>事实上，在实际问题中，影响响应变量的因子数量不止一个，在这里我们考虑两个因子A和B。假定因子A有a个不同的水平，因子B有b个不同的水平，那么因子A和因子B的组合共有ab种。而且，在每一种因子组合下，对响应变量有m次重复观测。</p>
<p>当某一因子的水平改变时导致了响应变量发生变化，称该现象为<strong>因子效应</strong>。</p>
<p>某一因子对响应变量的直接影响，称为主效应</p>
<h4 id="主效应"><a href="#主效应" class="headerlink" title="主效应"></a>主效应</h4><p><img src="/2021/10/07/%E5%A4%9A%E9%87%8D%E6%AF%94%E8%BE%83%E5%92%8C%E5%8F%8C%E5%9B%A0%E5%AD%90%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90/2.png" style="zoom:67%;"></p>
<p>在这种情况下：</p>
<p>因子A的主效应： $= \frac{40+50}{2}-\frac{20+30}{2}=20$</p>
<p>因子B的主效应： $=\frac{30+50}{2}-\frac{20+40}{2}=10$​</p>
<p>这表明了：</p>
<p>因子A从低水平增至高水平时，其平均响应变量增加了20个单位</p>
<p>因子B从低水平增至高水平时，其平均响应变量增加了10个单位</p>
<h4 id="交互效应"><a href="#交互效应" class="headerlink" title="交互效应"></a>交互效应</h4><p>除了主效应之外，因子对响应变量的影响还存在另外一种形式：</p>
<ul>
<li>在一些化工生产中，温度和材料都是影响产品质量的重要因素，不同材料在不同温度水平下对产品质量的影响是不同的</li>
<li>在线上购物行为中，消费者会存在从众心理，而线上商家会利用优惠券的让利形式进一步刺激消费者购买，因此在这些因素的共同作用下，电商主播直播带货非常火爆</li>
</ul>
<p>所以说，当对于两个因子来说，因子A和因子B给响应变量产生的影响有影响，这种影响不是因子A对响应变量直接的影响，而是一种间接作用，称为交互效应。比如说这种情况：</p>
<p><img src="/2021/10/07/%E5%A4%9A%E9%87%8D%E6%AF%94%E8%BE%83%E5%92%8C%E5%8F%8C%E5%9B%A0%E5%AD%90%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90/3.png" style="zoom:67%;"></p>
<ul>
<li>在因子B处于低水平时，因子A的效应为：$60-20=40$</li>
<li>在因子B处于高水平时，因子A的效应为：$30-40=-10$</li>
</ul>
<p>这表明了，因子A的效应是依赖于因子B所选择的水平，由此可见因子A和因子B之间存在交互作用。交互作用的大小可以用因子B处于不同水平下因子A的效应的平均差来表示，即：</p>
<p>因子A和B的交互效应$=\frac{-10-40}{2}=-25$</p>
<h4 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h4><p>我们可以通过图像来判断两个因子之间是否存在交互效应：</p>
<p><img src="/2021/10/07/%E5%A4%9A%E9%87%8D%E6%AF%94%E8%BE%83%E5%92%8C%E5%8F%8C%E5%9B%A0%E5%AD%90%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90/4.png" style="zoom:80%;"></p>
<p>在第一种情况下，因子A无论在什么水平下，因子B的增量是一样的，因此可以判断A和B是不交互的</p>
<p>在第二种情况下，因子A的水平高低对B的增量产生影响，反之亦然，因此可以判断A和B是互相交互的。</p>
<h3 id="双因子方差分析的模型及假设"><a href="#双因子方差分析的模型及假设" class="headerlink" title="双因子方差分析的模型及假设"></a>双因子方差分析的模型及假设</h3><p>那么我们有没有一个量化的方法来考虑这个问题呢？</p>
<p>首先，我们要给出一些假定：</p>
<ul>
<li><p>因子A有a个水平，$i=1,2\cdots,a$ </p>
</li>
<li><p>因子B有b个水平，$j=1,2\cdots,b$</p>
</li>
<li><p>$y_{ijk}$​ 表示因子A处于第i个水平和因子B处于第j个水平时响应变量的第k个观测值，$k=1,2\cdots,m$</p>
</li>
<li><p>在这个模型中，样本量为$n=abm$</p>
</li>
</ul>
<p>通常，数据按照下表的形式呈现：</p>
<p><img src="/2021/10/07/%E5%A4%9A%E9%87%8D%E6%AF%94%E8%BE%83%E5%92%8C%E5%8F%8C%E5%9B%A0%E5%AD%90%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90/5.png" style="zoom:80%;"></p>
<p>和单因子方差分析的模型一样，双因子方差分析模型也有均值模型和效应模型</p>
<h4 id="均值模型"><a href="#均值模型" class="headerlink" title="均值模型"></a>均值模型</h4><p>在双因子方差分析的均值模型可以定义为：</p>
<script type="math/tex; mode=display">
y_{ijk} = \mu_{ij}+\epsilon_{ijk}\cases{i=1,2\cdots,a\\~\\j=1,2\cdots,b\\~\\k=1,2\cdots,m}</script><p>$\mu<em>{ij}$可以认为是不同因子水平组合下响应变量$y</em>{ijk}$的均值</p>
<h4 id="效应模型"><a href="#效应模型" class="headerlink" title="效应模型"></a>效应模型</h4><p>我们可以将$\mu_{ij}$分为四个部分，在双因子方差分析的效应模型可以定义为：</p>
<script type="math/tex; mode=display">
y_{ijk} = \mu+\alpha_i+\beta_j+(\alpha\beta)_{ij}+\epsilon_{ijk}\cases{i=1,2\cdots,a\\~\\j=1,2\cdots,b\\~\\k=1,2\cdots,m}</script><ul>
<li>$\mu$ 表示总体均值</li>
<li>$\alpha_i$表示因子A(行因子)的第i个水平效应(主效应)</li>
<li>$\beta_i$表示因子B(列因子)的第j个水平效应(主效应)</li>
<li>$(\alpha\beta)<em>{ij}$表示因子A和B之间的交互关系，注意不等价于$\alpha_i\cdot\beta_j$ , 我们需要将$(\alpha\beta)</em>{ij}$​看成是一个新的符号？为什么不成立呢？因为一旦成立，交互效应就会等于主效应的乘积，那么就成为一个约束、一个假设了</li>
</ul>
<p>此外，类似于单因子方差分析效应模型，为避免参数不可识别的问题，我们对这些效应参数需要一些约束</p>
<script type="math/tex; mode=display">
\begin{align}
&\sum_{i=1}^a \alpha_i = 0,\\ 
&\sum_{j=1}^b\beta_j = 0,\\ 
&\sum_{i=1}^a(\alpha\beta)_{ij} = \sum_{j=1}^b (\alpha\beta)_{ij} = 0
\end{align}</script><p>此外我们要对实验误差$\varepsilon_{ijk}$ 进行一个假设，将其看成是均值为0且方差为$\sigma^2$ 的正态分布随机变量，即：</p>
<script type="math/tex; mode=display">
\varepsilon_{ijk} \sim N(0,\sigma^2)</script><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>双因子方差分析模型的一般形式为：</p>
<script type="math/tex; mode=display">
\begin{align}
&y_{ijk} = \mu+\alpha_i+\beta_j+(\alpha\beta)_{ij}+\varepsilon_{ijk},\varepsilon_{ijk}\sim N(0,\sigma^2)\\~\\
&i=1,2\cdots,a;j=1,2\cdots,b;k=1,2\cdots,m\\~\\
s.t.&\sum_{i=1}^a \alpha_i = 0,\sum_{j=1}^b \beta_i = 0\\
&\sum_{i=1}^a(\alpha\beta)_{ij}=\sum_{j=1}^b{(\alpha\beta)_{ij}}=0\
\end{align}</script><h3 id="双因子方差分析的检验"><a href="#双因子方差分析的检验" class="headerlink" title="双因子方差分析的检验"></a>双因子方差分析的检验</h3><h4 id="检验问题"><a href="#检验问题" class="headerlink" title="检验问题"></a>检验问题</h4><p>我们要检验的问题是：在双因子方差分析模型中，我们不仅关心因子A和B的主效应是否显著，还关心因子A和B的交互作用是否显著。</p>
<p>我们要针对以下三组问题进行检验</p>
<ul>
<li>其一，判断因子A是否对响应变量有直接影响，即：</li>
</ul>
<script type="math/tex; mode=display">
H_0:\alpha_1=\alpha_2\cdots=\alpha_a = 0~~vs~~H_1:\text{因子A至少存在一个水平}\alpha_i\neq 0</script><ul>
<li>其二：判断因子B是否对响应变量有直接影响，即：</li>
</ul>
<script type="math/tex; mode=display">
H_0:\beta_1=\beta_2=\cdots=\beta_b = 0 ~~vs~~H_1:\text{因子B至少存在一个水平}\beta_j\neq 0</script><ul>
<li>其三，判断因子A和B是否对响应变量有交互作用，即：</li>
</ul>
<script type="math/tex; mode=display">
\begin{align}
&\text{H}_0 : \text{对于任意} i=1,2\cdots,a;j=1,2\cdots,b,(\alpha\beta)_{ij} = 0 ~~\text{均成立}\\~\\
&\text{H}_1: \text{因子A和B至少存在一组水平组合}(\alpha\beta)_{ij}\neq 0
\end{align}</script><h4 id="检验统计量"><a href="#检验统计量" class="headerlink" title="检验统计量"></a>检验统计量</h4><p>我们采用方差分解的想法来构建检验统计量。在介绍总偏差平方和分解公式之前，我们先来定义写必需符号</p>
<ul>
<li>$y_{i\cdot\cdot}$  表示在因子A第i个水平下响应变量的总和</li>
<li>$y_{\cdot j\cdot}$  表示在因子B第j个水平下响应变量的综合2</li>
<li>$y_{ij\cdot}$ 表示在因子A第i个水平下且因子B第j个水平下响应变量的总和</li>
<li>$y_{\cdots}$ 表示所有响应变量的总和</li>
<li>$\overline y<em>{i\cdot\cdot},\overline y</em>{\cdot j\cdot},\overline y<em>{ij\cdot},\overline y</em>{\cdots}$ 表示相应的均值</li>
</ul>
<p>我们可以用公式来表示这些符号，即：</p>
<script type="math/tex; mode=display">
\begin{align}
&y_{i\cdot\cdot} =\sum_{j=1}^b\sum_{k=1}^m y_{ijk}&\overline y_{i\cdot\cdot}=\frac{1}{bm}y_{i\cdot\cdot}\\
&y_{\cdot j\cdot} = \sum_{i=1}^a\sum_{k=1}^m y_{ijk}&\overline y_{\cdot j\cdot} =\frac{1}{am} y_{\cdot j\cdot}\\
&y_{ij\cdot} = \sum_{k=1}^m y_{ijk}&\overline y_{ij\cdot} = \frac{1}{m}y_{ij\cdot}\\
&y_{\cdots} = \sum_{i=1}^a\sum_{j=1}^b\sum_{k=1}^m y_{ijk} &\overline y_{\cdots} = \frac{1}{n}y_{\cdots}
\end{align}</script><p>模仿单因子方差分析，我们可以给出$SS_T$的式子：</p>
<script type="math/tex; mode=display">
\begin{align}
\sum_{i=1}^a\sum_{j=1}^b\sum_{k=1}^m(y_{ijk}-\overline y_{\cdots})^2 &= \sum_{i=1}^a\sum_{j=1}^b\sum_{k=1}^m((\overline y_{i\cdot\cdot}-\overline y_{\cdot\cdot\cdot})+(\overline y_{\cdot j\cdot}-\overline y_{ij\cdot})+(\overline y_{ij\cdot}-\overline y_{i\cdot\cdot}-\overline y_{\cdot j\cdot}+\overline y_{\cdot\cdot\cdot})+(\overline y_{ijk}-\overline y_{ij\cdot}))^2\\~\\
&=bm\sum_{i=1}^a (y_{i\cdot\cdot}-\overline y_{\cdot\cdot\cdot})^2+am\sum_{j=1}^b(\overline y_{\cdot j\cdot}-\overline y_{\cdot\cdot\cdot})^2+m\sum_{i=1}^a\sum_{j=1}^b(\overline y_{ij\cdot}-\overline y_{i\cdot\cdot}-\overline y_{\cdot j \cdot}+\overline y_{\cdot\cdot\cdot})^2+\sum_{i=1}^a\sum_{j-1}^b\sum_{k=1}^m(y_{ijk}-\overline y_{ij\cdot})^2
\end{align}</script><p>其中，中间项都是等于0的。用单因子的技巧就可以证明</p>
<ul>
<li>注意到，第一项是根据因子A对数据进行划分从而引起的偏差平方和，我们记为$SS_A$</li>
<li>第二项类似地可以记为$SS_B$</li>
<li>第三项可以写为$m\sum<em>{i=1}^a\sum</em>{j=1}^b((\overline y<em>{ij\cdot}-\overline y</em>{\cdot\cdot\cdot})-(\overline y<em>{i\cdot\cdot}-\overline y</em>{\cdot\cdot\cdot})-(\overline y<em>{\cdot j\cdot}-\overline y</em>{\cdot\cdot\cdot}))^2$ , 记为 $SS_{AB}$ </li>
<li>最后一项，为了排除因子A和B的效应之外响应变量的剩余偏差平方和，我们记为$SS_E$</li>
</ul>
<p>总的偏差平方和的分解公式可以简记为：</p>
<script type="math/tex; mode=display">
SS_T = SS_A+SS_B+SS_{AB}+SS_E</script><p>类似于单因子方差分析模型，在双因子方差分析模型中，我们可以类似地利用三个比值：</p>
<script type="math/tex; mode=display">
\frac{SS_A}{SS_E},\frac{SS_B}{SS_E},\frac{SS_{AB}}{SS_E}</script><p>我们需要推导出$SS<em>E$ 和在原假设成立时$SS_A,SS_B,SS</em>{AB}$的分布</p>
<p>因为$SS<em>A,SS_B,SS</em>{AB},SS<em>E$均为偏差平方和，所以一个合理的猜测是，这些偏差平方和的分布可能是一个卡方分布。根据Cochran定理，这些偏差平方和可以看做是多少个独立的随机变量的平方和。例如，$SS_A=bm\sum</em>{i=1}^a(\overline y<em>{i\cdot\cdot}-\overline y</em>{\cdot\cdot\cdot})$ 可以将数据按因子A的<strong>a个水平</strong>来进行分组，在第i组内响应变量的均值$\overline y<em>{i\cdot\cdot}$ 看作一个独立的样本，而$\overline y</em>{\cdot\cdot\cdot}$​​可以看做a组数据的样本均值。</p>
<p>$SS<em>A$​ 可以看做是这a个数据的离差平方和乘以一个常数。对于离差平方和来说，自由度可以看作样本个数减一。于是，$SS_A$​ 的自由度为a-1。类似地，我们可以得到$SS_B,SS</em>{AB},SS_E$ 的自由度，如下表</p>
<p><img src="/2021/10/07/%E5%A4%9A%E9%87%8D%E6%AF%94%E8%BE%83%E5%92%8C%E5%8F%8C%E5%9B%A0%E5%AD%90%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90/6.png" alt="6"></p>
<p>类似于在单因子方差分析模型中的定义，偏差平方和除以相应的自由度之后所得到的被称为均方</p>
<p>其实，构造检验统计量实际上是均方的比值，而不是偏差平方和的比值，这是因为F分布随机变量的构造方式。根据之前的定理，我们发现 $MS_E$​​​ 一直在$\sigma^2$​​​ 附近波动。</p>
<p>只有当原假设成立时，$MS<em>A,MS_B,MS</em>{AB}$​​ 都会在$\sigma^2$​​ 附近波动的。于是，$\frac{MS<em>A}{MS_E},\frac{MS_B}{MS_E},\frac{MS</em>{AB}}{MS_E}$​​  都应该比较接近于1的，并不会特别大。如果差得比较远，就说明某一效应非常明显，我们就会拒绝原假设。</p>
<p>因此，我们可以通过这三个比值，是否大于临界值，从而判断原假设成立，还是备择假设成立</p>
<h4 id="均方的期望"><a href="#均方的期望" class="headerlink" title="均方的期望"></a>均方的期望</h4><p><img src="/2021/10/07/%E5%A4%9A%E9%87%8D%E6%AF%94%E8%BE%83%E5%92%8C%E5%8F%8C%E5%9B%A0%E5%AD%90%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90/8.png" alt="6"></p>
<p>在双因子方差模型中，均方$MS<em>A,MS_B,MS</em>{AB},MS_E$ 的期望分别为：</p>
<script type="math/tex; mode=display">
\begin{align}
&E(MS_A)=E(\frac{SS_A}{a-1})=\sigma^2 +\frac{bm\sum_{i=1}^a \alpha_i^2}{a-1}\\
&E(MS_B)=E(\frac{SS_B}{b-1})=\sigma^2 +\frac{am\sum_{j=1}^b\beta_i^2}{b-1}\\
&E(MS_{AB})=E(\frac{SS_{AB}}{(a-1)(b-1)})=\sigma^2 +\frac{m\sum_{i=1}^a\sum_{j=1}^b(\alpha\beta)_{ij}^2}{(a-1)(b-1)}\\
&E(MS_E) = E(\frac{SS_E}{ab(m-1)})=\sigma^2
\end{align}</script><h4 id="如何确定临界值？"><a href="#如何确定临界值？" class="headerlink" title="如何确定临界值？"></a>如何确定临界值？</h4><p>当原假设成立的时候，类似单因子方差分析模型，我们可以推出</p>
<script type="math/tex; mode=display">
\begin{align}
&SS_A\sim \mathcal{X}^2(a-1)\\
&SS_B\sim \mathcal{X}^2(b-1)\\
&SS_{AB}\sim \mathcal{X}^2((a-1)(b-1))\\
&SS_E\sim \mathcal{X}^2(ab(m-1))
\end{align}</script><p>而且$SS<em>A,SS_B,SS</em>{AB},SS_E$ 都是相互独立的</p>
<p>于是，一个显而易见的结论是我们所需要的比值都是服从F分布的，即</p>
<script type="math/tex; mode=display">
\begin{align}
&\frac{MS_A}{MS_E}\sim F(a-1,ab(m-1))\\
&\frac{MS_B}{MS_E}\sim F(b-1,ab(m-1))\\
&\frac{MS_{AB}}{MS_E}\sim F((a-1)(b-1),ab(m-1))\\
\end{align}</script><p>由此，我们可以确定相应F分布的临界值</p>
<p><img src="/2021/10/07/%E5%A4%9A%E9%87%8D%E6%AF%94%E8%BE%83%E5%92%8C%E5%8F%8C%E5%9B%A0%E5%AD%90%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90/7.png" alt="7"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/09/24/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/24/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C/" class="post-title-link" itemprop="url">数据科学与工程算法-哈希</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-24 08:37:14" itemprop="dateCreated datePublished" datetime="2021-09-24T08:37:14+08:00">2021-09-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-01-10 13:30:02" itemprop="dateModified" datetime="2024-01-10T13:30:02+08:00">2024-01-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据科学与工程算法-哈希算法"><a href="#数据科学与工程算法-哈希算法" class="headerlink" title="数据科学与工程算法-哈希算法"></a>数据科学与工程算法-哈希算法</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>首先我们提出两种情境：</p>
<ol>
<li>判断用户名是否被注册</li>
</ol>
<p>我们当然可以对用户名建立B+树索引，这样可以提高查询效率，复杂度为$O(\ln n)$ ，其中n为集合大小。</p>
<p>但是我们能不能找到$O(1)$复杂度的方法呢?</p>
<ol>
<li>文本冗余检测</li>
</ol>
<p>假设我们有搜索引擎定期爬取网页内容，但是爬取太多冗余文本会浪费存储空间。然而，将海量文本逐篇对比过于低效了，如何判断网页的内容是否冗余呢？</p>
<p>哈希函数我们都不陌生，用数学公式来表达就是：</p>
<script type="math/tex; mode=display">
h(\text{key}) = \text{value}\in\mathbb{Z^+}</script><p>用图片来显示就是：<br><img src="/2021/09/24/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C/1.png" style="zoom:67%;"></p>
<h3 id="哈希函数的作用："><a href="#哈希函数的作用：" class="headerlink" title="哈希函数的作用："></a>哈希函数的作用：</h3><ul>
<li>压缩存储：哈希值所需的存储空间远小于输入关键词占用的空间<ul>
<li>网页URL哈希到某个未知，可以表示为一个整数</li>
<li>邮件地址哈希成一个整数</li>
</ul>
</li>
<li>无冲突：理想状态下，输入不同的关键词会得到不同的哈希值<ul>
<li>即使是两个差异很小的关键词也会得到两个完全不同的哈希值</li>
<li>相同关键词被相同哈希函数哈希，不可能得到两个不同的值</li>
</ul>
</li>
<li>不可逆：在不知道哈希函数的情形下，仅知道哈希值，不可能轻易地猜到此哈希值对应的关键词<ul>
<li>唯一找到关键词的方法是暴力算法</li>
<li>正是因为这一点，哈希函数称为最重要的密码学工具之一</li>
</ul>
</li>
</ul>
<h3 id="哈希表性能"><a href="#哈希表性能" class="headerlink" title="哈希表性能"></a>哈希表性能</h3><ul>
<li>哈希函数：将冲突最小化，使得key和value均匀地分布在整个表中</li>
<li>冲突解决策略：将key/value存储在不同的位置，或将多个key/value用链表串起来</li>
<li>哈希表大小：表过大会降低碰撞的可能，单会造成内存空间的浪费。过小的哈希会增加碰撞的可能性</li>
</ul>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>布隆过滤器是为了应对碰撞而提出的一种高空间效率的概率数据结构，用于判断一个元素是否属于一个集合的成员。</p>
<p>布隆过滤器有广泛的应用：</p>
<ul>
<li>垃圾邮件地址过滤器：可以有效过滤垃圾邮件地址</li>
<li>拼写检查：能很快发现文字编辑软件中输入的错</li>
<li>重复检查：用于网络爬虫判断某个URL是否已经被爬取过了，或用户名是否被注册过</li>
</ul>
<p>那么布隆过滤器是怎么被提出的呢？我们已经知道哈希面临的问题是冲突，假设哈希函数是良好的，那么如果我们的位阵列长度为m个点，那么如果我们想将冲突率降低到例如 $1\%$ ，这个散列表就只能容纳 $m/100$​​​ 个元素。显然这很浪费空间效率。解决的办法也很简单，就是使用多重哈希，如果他们有一个判断出元素不在集合中，那肯定是不在的；如果它们都说在，虽然也有一定的可能性它们在说谎，不过直觉上判断这种事情的概率是比较低的。这就是布隆过滤器。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>它的优点是空间效率和查询时间都比一般的算法要好的多。隆过滤器存储空间和插入/查询时间都是常数。另外, Hash函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>但是布隆过滤器的缺点和优点一样明显。误算率是其中之一。随着存入的元素数量增加，误算率随之增加。常见的补救办法是建立一个小的白名单，存储那些可能被误判的元素。但是如果元素数量太少，则使用散列表足矣。</p>
<p>另外，一般情况下不能从布隆过滤器中删除元素。我们很容易想到把位列阵变成整数数组，每插入一个元素相应的计数器加1, 这样删除元素时将计数器减掉就可以了。然而要保证安全的删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面. 这一点单凭这个过滤器是无法保证的。另外计数器回绕也会造成问题。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假定集合中有n个元素，位数组初始长度为m,每个位置都被置为0，那么给定一组k个哈希函数 $h_1,\cdots,h_k$ ，其中$h_i$ 的范围为${0,\cdots,m-1}$ ；这个例子中 $m=18,k=3$ </p>
<p>那么我们要插入三个元素${x,y,z}$ ,每个元素就会被哈希到位数组中的三个位置。如下图所示：</p>
<p><img src="/2021/09/24/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C/2.png" style="zoom:67%;"></p>
<h3 id="元素插入"><a href="#元素插入" class="headerlink" title="元素插入"></a>元素插入</h3><p>现在我们约定3个哈希函数$h_1,h_2,h_3$，其中$h_i$的范围为 ${0,1,\cdots,9}$ ，初始状态长度为10 的位数组每个位置为置为0.</p>
<p><img src="/2021/09/24/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C/3.png" style="zoom:67%;"></p>
<p>然后，元素$x_1$​被映射到了 ${1,4,9}$​​, 于是将1、4、9都改成1</p>
<p><img src="/2021/09/24/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C/4.png" style="zoom:67%;"></p>
<p>接着元素$x_2$​被映射到了${4,5,8}$​, 于是4、5、8置为1，因为4已经是1了，所以不变</p>
<p><img src="/2021/09/24/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C/5.png" style="zoom:67%;"></p>
<h3 id="元素查询"><a href="#元素查询" class="headerlink" title="元素查询"></a>元素查询</h3><p>现在位数组中存放着两个元素，我们要查询的时候，流程如下：</p>
<ul>
<li>查询 $y_1$, $H(y_1)= {1,4,9}\longrightarrow Yes$</li>
<li>查询 $y_2$, $H(y_2) = {0,4,8}\longrightarrow No$</li>
<li>查询$y_3$, $H(y_3)={1,5,8}$ 这并不是存入的元素，但是在1、5、8这三个位置上的值却都是1，因此出现了假阳性的情况</li>
</ul>
<p>所以说，布隆过滤器会出现误判的情况：</p>
<ul>
<li>虽然不会出现拒真的情形(假阴性不会出现 ), 是真的不会给你判成假的</li>
<li>但是<strong>可能会出现纳伪的情形</strong>(假阳性)</li>
</ul>
<h3 id="误判率分析"><a href="#误判率分析" class="headerlink" title="误判率分析"></a>误判率分析</h3><p>当插入一个元素到布隆过滤器，一个哈希函数未将某个特定位置置为1的概率为 $1-\frac{1}{m}$</p>
<p>当一个元素插入布隆过滤器后，k个哈希函数未将特定位置置为1的概率为 $(1-\frac{1}{m})^k$ </p>
<p>将n个元素插入布隆过滤器后，特定位置未被置为1的概率为 $(1-\frac{1}{m})^{kn}$ </p>
<p>因此，某个特定位置为1的概率为 $(1-(1-\frac{1}{m})^{kn})$</p>
<p>现在，在查询某个元素的时候，当k个哈希函数对应的位置均为1，则过滤器声称该元素属于该集合。但如果这个元素不属于集合，就会发生误判。其概率是：</p>
<script type="math/tex; mode=display">
f = ((1-(1-\frac{1}{m})^{kn}))^k\approx (1-e^{-\frac{kn}{m}})^k</script><p>可以近似是因为极限：</p>
<script type="math/tex; mode=display">
\lim\limits_{m\rightarrow \infty}(1-\frac{1}{m})^{kn} =\lim\limits_{m\rightarrow\infty}((1+\frac{1}{-m})^{-m})^{-\frac{kn}{m}} = e^{-1\cdot\frac{kn}{m}}</script><p>从这个概率可知:</p>
<ul>
<li>误判概率随着布隆过滤器<strong>位数组的长度m</strong>的增大而减小</li>
<li>随着更多元素的加入，误判概率随<strong>元素个数n</strong>的增加而增加</li>
</ul>
<p>那么如何降低误判概率呢？</p>
<ul>
<li>集合中元素个数相对固定，空间大小可能受限</li>
<li>可以通过适当选择哈希函数的个数即k值来<strong>最小化概率</strong>$(1-e^{-\frac{kn}{m}})^k$</li>
</ul>
<h2 id="局部位置敏感哈希-LSH"><a href="#局部位置敏感哈希-LSH" class="headerlink" title="局部位置敏感哈希(LSH)"></a>局部位置敏感哈希(LSH)</h2><p>现在有一个情境，就是对冗余文本的检测，将文章一一对比查找在性能上肯定说不过去。因此我们可以将文本分块, 然后将相似的块大概率会被哈希到同一个桶中，而不相似的文档大概率会被哈希到不同的桶中。到时候，我们就只在一个桶里进行比较就可以了。</p>
<p>利用这种技术，我们可以用来做抄袭检测、镜像网站的发现。</p>
<p>局部位置敏感哈希可以用来在海量文档中查找其中的冗余文本。步骤如下：</p>
<ul>
<li>Shingling ：将文档转换为集合</li>
<li>Min-Hashing：将大的几何转换为短的签名，同时保留相似性</li>
<li>局部敏感哈希：筛选或寻找相似文档候选对</li>
</ul>
<p><img src="/2021/09/24/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C/7.png" style="zoom:67%;"></p>
<h4 id="Jaccard相似度"><a href="#Jaccard相似度" class="headerlink" title="Jaccard相似度"></a>Jaccard相似度</h4><p>给定集合A和B，Jaccard相似度定义为：</p>
<script type="math/tex; mode=display">
\text{Jaccord} (A,B) = \frac{|A\cap B|}{|A\cup B|}</script><p>给定集合A和B，Jaccord距离定义为：</p>
<script type="math/tex; mode=display">
d(A,B) = 1-\frac{|A\cap B|}{|A\cup B|}</script><p>Jaccard 相似度可以用来衡量文本之间的相似度</p>
<h3 id="Shingling文档的集合表示"><a href="#Shingling文档的集合表示" class="headerlink" title="Shingling文档的集合表示"></a>Shingling文档的集合表示</h3><p>首先，要对文本建模。</p>
<ul>
<li>定义Document为文档出现的单词集合</li>
<li>因为简单的分词会损失上下文信息，那么为了关注单词的顺序，我们需要定义Shingles</li>
</ul>
<p>文本中的 <em>K-Shingles</em> 是文本中连续k个token(字符、单词等)组成的序列。比如说，给定字符串 D = abcab,令k=2，则字符串的2-Shingles为</p>
<script type="math/tex; mode=display">
S(D)=\{ab,bc,ca\}</script><p>如果<em>k-Shingles</em>看做是multiset(可重复)，那么</p>
<script type="math/tex; mode=display">
S(D)=\{ab,bc,ca,ab\}</script><p>当我们得到了两个文档的$S(D)$​ 之后，我们就可以计算器Jaccord相似度.但是，当文档数量非常庞大时(假设为1000000)，那么待计算相似度的文档对有：</p>
<script type="math/tex; mode=display">
N(N-1)/2 \approx 5\times 10^{11}</script><p>计算机需要非常长时间才能进行如此庞大的计算。因此，我们需要在得到了k-Shingling之后，运用某个哈希函数将长度为k的字符串映射为桶编号。进一步将一系列集合表示成特征矩阵。其中，每行代表一个桶，每列代表一个文档。给定4篇文档：其转换图如下</p>
<p><img src="/2021/09/24/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C/9.jpeg" style="zoom:67%;"></p>
<h3 id="Min-Hashing"><a href="#Min-Hashing" class="headerlink" title="Min-Hashing"></a>Min-Hashing</h3><p>最小哈希是一类特殊的哈希函数。其定义：</p>
<p>给定布尔向量$\bold{v}$​ 和随机排列$h$​  ,$h(v)$​ 为布尔向量$\bold{v}$​ 经过随机排列后得到的新向量，$mh(\bold{v})$ 为新得到的布尔向量$h(\bold v)$ 中第一个不为0的行号。函数$mh(\bold v)$被称为是最小哈希函数</p>
<p>比如说，我将上面这个表格打乱，得到：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>S1</th>
<th>S2</th>
<th>S3</th>
<th>S4</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>这里打乱之后，行号仍然按顺序标注，否则打乱就没有意义了。</p>
<p>按照竖着来看，$mh(\bold{v})$ 为新得到的布尔向量$h(\bold v)$ 中第一个不为0的行号。因此可以求出每个个文档的最小哈希值分别为： </p>
<script type="math/tex; mode=display">
mh(d_1)=1 ,mh(d_2)=4,mh(d_3)=1,mh(d_4)=0</script><h4 id="最小哈希与Jaccard相似度"><a href="#最小哈希与Jaccard相似度" class="headerlink" title="最小哈希与Jaccard相似度"></a>最小哈希与Jaccard相似度</h4><p>现在我们可以证明：在经过打乱后的两个集合计算得到的最小哈希值相等的概率，是等于这两个集合的Jaccard相似度的。</p>
<p>我们仅考虑集合S1和S2 这两列.那么这两列所在的行有以下三种类型：</p>
<ul>
<li>这一行的S1和S2都为1，记为X类</li>
<li>这一行只有一个值为1，一个值为0，记为Y类</li>
<li>这一行两个值都为0，记为Z类。</li>
</ul>
<p>假设属于X类的行有x个，属于Y类的行有y个，所以S1和S2交集的元素个数为x，并集的元素个数为x+y,所以$Jaccard(S_1,S_2) = \frac{x}{x+y} $</p>
<p>接下来计算最下哈希$h(S_1)=h(S_2)$​ 的概率，经过打乱之后，对特征值从上往下进行扫描，在碰到Y类行之前碰到X行的概率为$\frac{x}{x+y}$​; 又因为X类行中$h(S_1)=h(S_2)$ ,所以$h(S_1)=h(S_2)$的概率为$\frac{x}{x+y}$,即这两个集合Jaccard相似度。</p>
<p>因此，我们可以通过<strong>多次随机重排</strong>来求出多个不同的最小哈希值，则可以运用$mh(S_1)=mh(S_2)$ 发生的频率估计事件 $mh(S_1)=mh(S_2)$​ 发生的概率。</p>
<p>由此我们来引出最小哈希签名：</p>
<h4 id="最小哈希签名"><a href="#最小哈希签名" class="headerlink" title="最小哈希签名"></a>最小哈希签名</h4><p>上面是用一个行打乱来处理特征矩阵，然后就可以得到每个集合最小哈希值，这样多个集合就会有多个最小哈希值，这些值就可以组成一列</p>
<p>当我们用多个随机行打乱（假设为n个，分别为$h_1,h_2\cdots h_n$）来处理特征矩阵时，然后分别计算打乱后的这n个矩阵的最小哈希值；这样，对于集合S，就会有n个最小哈希值，这n个哈希值就可以组成一个列向量，为$[h_1(S), h_2(S)\cdots h_n(S)]$；</p>
<p>因此对于一个集合，经过上面的处理后，就能得到一个列向量；如果有m个集合，就会有m个列向量，每个列向量中有n个元素。把这m个列向量组成一个矩阵，这个矩阵就是特征矩阵的签名矩阵；</p>
<p>这个签名矩阵的列数与特征矩阵相同，但行数为n，也即哈希函数的个数。</p>
<p>通常来说，n都会比特征矩阵的行数要小很多，所以签名矩阵就会比特征矩阵小很多。</p>
<h4 id="最小哈希签名矩阵的计算"><a href="#最小哈希签名矩阵的计算" class="headerlink" title="最小哈希签名矩阵的计算"></a>最小哈希签名矩阵的计算</h4><p>现在我们来举一个具体的计算样例来理解最小哈希签名</p>
<p>首先我们用n来代表哈希函数的个数，通过哈希函数，我们可以来模拟行打乱的效果。</p>
<p>令$SIG(i,c)$表示签名矩阵中第$ i$ 个哈希函数在第$c$列上的元素。开始时，将所有的$SIG(i,c)$初始化为 Inf(无穷大)，然后对第r行进行如下处理：</p>
<ol>
<li>计算$h_1(r), h_2(r)\cdots h_n(r)$​​；r为行数</li>
<li>对于每一列c:<ul>
<li>如果c所在的第r行为0，则什么都不做；</li>
<li>如果c所在的第r行为1，则对于每个$i=1,2\cdots ,n$，将SIG(i,c)置为原来的$SIG(i,c)$和$h_i(r)$​之间的最小值。 </li>
</ul>
</li>
</ol>
<p>例如，考虑上面的特征矩阵，将abcde换成对应的行号，在后面加上两个哈希函数，其中$h_1(x)=(x+1) \mod 5\h_2(x) = (3\cdot x+1) \mod 5$​，注意这里x指的是行号：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>s1</th>
<th>s2</th>
<th>s3</th>
<th>s4</th>
<th>h1</th>
<th>h2</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>2</td>
<td>4</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>4</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>3</td>
</tr>
</tbody>
</table>
</div>
<p>接下来计算签名矩阵。一开始时，全部初始化为Inf:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>s1</th>
<th>s2</th>
<th>s3</th>
<th>s4</th>
</tr>
</thead>
<tbody>
<tr>
<td>h1</td>
<td>Inf</td>
<td>Inf</td>
<td>Inf</td>
<td>Inf</td>
</tr>
<tr>
<td>h2</td>
<td>Inf</td>
<td>Inf</td>
<td>Inf</td>
<td>Inf</td>
</tr>
</tbody>
</table>
</div>
<p>接着看特征矩阵中的第0行；这时S2和S3的值为0，所以无需改动；S1和S4的值为1，需改动。h1= 1，h2= 1。1比Inf小，所以需把S1和S4这两个位置对应的值替换掉，替换后效果如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>s1</th>
<th>s2</th>
<th>s3</th>
<th>s4</th>
</tr>
</thead>
<tbody>
<tr>
<td>h1</td>
<td>1</td>
<td>Inf</td>
<td>Inf</td>
<td>1</td>
</tr>
<tr>
<td>h2</td>
<td>1</td>
<td>Inf</td>
<td>Inf</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>接着看第1行；只有S3的值为1；此时h1= 2，h2= 4；对S3那一列进行替换，得到：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>s1</th>
<th>s2</th>
<th>s3</th>
<th>s4</th>
</tr>
</thead>
<tbody>
<tr>
<td>h1</td>
<td>1</td>
<td>Inf</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>h2</td>
<td>1</td>
<td>Inf</td>
<td>4</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>接着看第2行；S2和S4的值为1；h1=3，h2=2；因为签名矩阵S4那一列的两个值都为1，比3和2小，所以只需替换S2那一列：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>s1</th>
<th>s2</th>
<th>s3</th>
<th>s4</th>
</tr>
</thead>
<tbody>
<tr>
<td>h1</td>
<td>1</td>
<td>3</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>h2</td>
<td>1</td>
<td>2</td>
<td>4</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>接着看第3行；S1，S3和S4的值都为1，h1=4, h2= 0；替换后效果如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>s1</th>
<th>s2</th>
<th>s3</th>
<th>s4</th>
</tr>
</thead>
<tbody>
<tr>
<td>h1</td>
<td>1</td>
<td>3</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>h2</td>
<td>0</td>
<td>2</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p> 接着看第4行；S3值为1，h1=0, h2= 3，最终效果如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>s1</th>
<th>s2</th>
<th>s3</th>
<th>s4</th>
</tr>
</thead>
<tbody>
<tr>
<td>h1</td>
<td>1</td>
<td>3</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>h2</td>
<td>0</td>
<td>2</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>这样，所有的行都被遍历一次了，最终得到的签名矩阵如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>s1</th>
<th>s2</th>
<th>s3</th>
<th>s4</th>
</tr>
</thead>
<tbody>
<tr>
<td>h1</td>
<td>1</td>
<td>3</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>h2</td>
<td>0</td>
<td>2</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>基于这个签名矩阵，我们就可以<strong>估计原始集合</strong>之间的Jaccard相似度了。由于S1和S4对应的列向量完全一样，所以可以估计$SIM(S1,S4)=1$;  又比如说对于 S1和S3，两个元素中有一个一样，因此$SIM(S1,S3) = 0.5$</p>
<p>虽然用最小哈希签名矩阵可以近似<strong>估算两个集合的相似度</strong>，但是当哈希函数个数比较少的时候，估算误差可能会比较大，因此，需要选择恰当数量的哈希函数来降低估算误差。</p>
<h3 id="局部敏感哈希"><a href="#局部敏感哈希" class="headerlink" title="局部敏感哈希"></a>局部敏感哈希</h3><p>通过上面的方法处理过后，一篇文档可以用一个很小的签名矩阵来表示，节省下很多内存空间；但是，还有一个问题没有解决，那就是如果有很多篇文档，那么如果要找出相似度很高的文档，其中一种办法就是先计算出所有文档的签名矩阵，然后依次两两比较签名矩阵的相似度；这样做的缺点是当文档数量很多时，要比较的次数会非常大。那么<strong>我们可不可以只比较那些相似度可能会很高的文档，而直接忽略过那些相似度很低的文档</strong>。 </p>
<p>因此接下来我们就讨论这个问题的解决方法——<strong>局部敏感哈希</strong></p>
<p>首先，我们可以通过上面的方法得到一个签名矩阵，然后把这个矩阵划分成<strong>$b$个行条</strong>(band)，<strong>每个行条由$r$行组成</strong>。</p>
<p>对于每个行条，存在一个哈希函数能够将行条中的每r个整数组成的列向量（行条中的每一列）映射到某个桶中。可以对所有行条使用相同的哈希函数，但是对于每个行条我们都使用一个独立的桶数组，因此即便是不同行条中的相同列向量，也不会被哈希到同一个桶中。</p>
<p>这样，<strong>只要两个集合在某个行条中有落在相同桶的两列，这两个集合就被认为可能相似度比较高</strong>，作为后续计算的候选对；</p>
<p>而那些在所有行条中都不落在同一个桶中的两列，就会被认为相似度不会很高，而被直接忽略。下面直接看一个例子：</p>
<p><img src="/2021/09/24/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C/10.png"></p>
<p>可以看出，<strong>行条1</strong>中第2列和第4列的内容都为[0,2,1]，所以这两列会落在行条1下的相同桶中，因此无论在剩下的3个行条中这两列是否有落在相同桶中，这两个集合都会成为候选对。在行条1中不相等的两列还有另外的3次机会成为候选对，因为他们只需在剩下的3个行条中有一次相等即可。</p>
<p>经过上面的处理后，我们就找出了相似度可能会很高的一些候选对，接下来我们只需对这些候选队进行比较就可以了，而直接忽略那些不是候选对的集合。这个方法适合用来计算相似度超过某个值的文档的相似度，而不适用于计算所有文档的相似度，因为那些相似度可能很低的文档已经被直接忽略了。</p>
<p>现在我们来定量分析一下：</p>
<p>假定将某个最小哈希签名矩阵划分为b组，每组有r行组成。此外，假定两个集合的Jaccard相似度为s。那么，两个集合被哈希到同一个桶中的概率与其Jaccard 相似度存在如下关系：</p>
<ul>
<li>在<strong>具体某个组</strong>中，这对集合所有的最<strong>小哈希值都相等的概率</strong>是$s^r$</li>
<li>在这个组中，这对集合至少有一个位置的最小哈希值不相等的概率是$(1-s^r)$，即它们没有被映射到同一个桶中。</li>
<li>在任何一个组中，这对集合都没有被映射到同一个桶中的概率是$(1-s^r)^b$</li>
<li>进而，在整个最小哈希签名矩阵中，至少在一个组中的两个集合被映射到同一个桶中的概率为$1-(1-s^r)^b$</li>
</ul>
<p>我们给定任意的r和b的值，以相似度s的值为横坐标，以概率$1-(1-s^r)^b$的概率为纵坐标，则在二维坐标系中展示了一条S曲线, 如下图所示：</p>
<p><img src="/2021/09/24/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C/11.jpeg"></p>
<p>通常被映射到同一个桶中的概率的$\frac{1}{2}$处对应的s值被称为是<strong>相似度阈值</strong>。是一个关于b和r的函数。这一阈值的估计为$(1/b)^{1/r}$​ 。对于较大的b和r，s值大于相似度阈值的几何对很有可能被哈希到同一个桶中，而小于相似度阈值的不太可能被哈希到同一个桶中。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>假设一个布隆过滤器的容量是 $8\times 10^9$ 位，集合中有 $1\times 10^9$ 个元素。如果使用3个哈希函数，试计算误判率。如果使用4个哈希函数，误判率如何？</p>
<ul>
<li>当 $k=3$ 的时候</li>
</ul>
<script type="math/tex; mode=display">
r =(1- \exp\{-\frac{kn}{m}\})^k = (1-\exp\{-\frac{3}{8}\})^3 \\</script><ul>
<li>当$k=4$时候</li>
</ul>
<script type="math/tex; mode=display">
r =(1- \exp\{-\frac{kn}{m}\})^k = (1-\exp\{-\frac{1}{2}\})^4 \\</script><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>假定全集A有n个元素，随机从中抽取出两个子集 $A_1,A_2$ ，且每个自己都有m 个元素，求$A_1$和$A_2$ 两个集合的期望相似度。</p>
<p>首先，我们写出两个子集 Jacorrd 相似度的表达式. 为我们令两者的交集大小为a</p>
<script type="math/tex; mode=display">
Jacorrd(A_1,A_2) = \frac{a}{2m-a}</script><p>因此，我们可以计算期望 </p>
<script type="math/tex; mode=display">
E(JS(A_1,A_2)) = \sum_{a} P(a)JS(A_1,A_2)\\
P(a) = \frac{C_m^aC_{n-m}^{m-a}}{C_n^m}</script><p>但是，我们要分情况讨论，因为 $m\leq \frac{n}{2}$ 和 $m&gt;\frac{n}2$ 是不一样的</p>
<script type="math/tex; mode=display">
E(JS(A_1,A_2)) = \begin{cases}\sum_{a=0}^m P(a)\frac{a}{2m-a}&m\leq n/2 \\~\\ \sum_{a=2m-n}^m P(a)\frac{a}{2m-a}& m>{n}/{2} \end{cases}</script>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/09/21/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/21/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">数据管理系统-文档数据库设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-21 21:28:23" itemprop="dateCreated datePublished" datetime="2021-09-21T21:28:23+08:00">2021-09-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-12-01 15:37:22" itemprop="dateModified" datetime="2021-12-01T15:37:22+08:00">2021-12-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="文档数据库-索引"><a href="#文档数据库-索引" class="headerlink" title="文档数据库-索引"></a>文档数据库-索引</h1><p>文档数据库的索引采用的数据结构是B树。关于B树的创建、删除在这里就不说了，仅说说索引的创建与使用。</p>
<p>索引一般不会自动创建，需要我们手动为一个属性创建索引。创建了索引之后，查询的速度会快很多</p>
<p>mongodb创建索引的方式是：<code>db.myCollection.createIndex({&quot;name&quot;:1})</code></p>
<p>但是我们没有必要给所有的属性都加上索引，因为索引的每一个节点都是一个页，非常占用空间。此外，我们要保持索引和表中的数据一致。因此，更新索引的时候会增加不小的开销</p>
<p>我们适合在什么样的属性上添加索引呢？有几种原则：</p>
<ul>
<li>常用属性</li>
<li>不常被修改(稳定的属性)</li>
<li>索引要保证有效性。对一个有着名字、生日、性别属性的文档来说，把索引加在名字上式比较有效的。但是我们在性别上添加索引的话，不但不能提速，反而会变慢。因为性别的区分度很低，我们要找的数据是分散在各个地方的，每次对性别进行索引查找的代价甚至是不如直接扫描一遍文档来得快 </li>
</ul>
<p>有些时候我们会在不止一个属性上添加索引，这一部分我们放在关系数据库中去讨论</p>
<p><img src="/2021/09/21/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/6.png"></p>
<p><img src="/2021/09/21/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/7.png"></p>
<p>在这一题中，我们对 price进行了一个大于20而小于30的筛选，这使得筛选得到的数据是离散的分列的。效率并没有比不加索引的查询更快</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>假设某文档数据库中有N个文档，被存放在硬盘的K个页中(N&gt;K)。 我们要对这N个文档添加一个新的属性，导致K个页无法再容纳这K个文档。假设属性添加完毕后，需要J个页来容纳文档(N&gt;J&gt;K)。那么，相对高效的处理方式是：</p>
<p>A. 在硬盘上分配J个新页，然后对文档逐个进行修改，完成一个文档的修改就将它写到硬盘上的新页中，最后将K个旧页挥手</p>
<p>B. 在硬盘上分配 J 个新页，然后对文档逐个进行修改，修改后的文档先放入内存中的缓冲区，每当缓冲区满一页后将它写到硬盘上的新页中，最后将K个旧页回收</p>
<p>C. 对文档逐个进行修改，修改后的文档先全部放入内存中的缓冲区，修改完成后，将缓冲区的文档写入到 J 个新页中，最后将K个旧页回收</p>
<p>D.直接在 K 个旧页上进行修改，将溢出的文档放入内存中的缓冲区，修改完成后再将缓冲区的文档写入到 J-K 个新页中</p>
<p>答案是 ： B</p>
<h1 id="数据管理系统-文档数据库设计"><a href="#数据管理系统-文档数据库设计" class="headerlink" title="数据管理系统-文档数据库设计"></a>数据管理系统-文档数据库设计</h1><p><img src="/2021/09/21/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/1.jpeg" style="zoom:67%;"></p>
<p>上面是设计一个数据库的基本流程</p>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>我们用一个例子来考虑文档数据库的设计流程。首先，应该梳理出应用需要满足的功能。比如说博客应用</p>
<ol>
<li>所有人都可以成为博客网站的博主</li>
<li>所有人都可以写文章发表</li>
<li>所有人都可以看我发布的文章</li>
<li>博主和博主之间有粉丝的概念</li>
</ol>
<p>首先要设置一个界面，界面清晰了，功能就清晰了</p>
<p><img src="/2021/09/21/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/2.jpeg" style="zoom: 50%;"></p>
<p>第一个界面是登陆后的个人信息，右侧是博主关注的人的新文章</p>
<p>第二个界面是点击某一篇文章后显示的信息，包括文章的评论</p>
<p>第三个界面是点击第一个界面中的 NEW 按钮显示的，是创建一篇新的博客文章</p>
<p>第四个界面是点击作者信息后显示出来的其他人的信息</p>
<h2 id="概念设计"><a href="#概念设计" class="headerlink" title="概念设计"></a>概念设计</h2><p>对于这个应用我们的需求已经比较清晰了。现在我们开始概念设计</p>
<p>首先要解决的问题是：<strong>存什么</strong>, 也就是要保存几类对象的信息。很显然，有<strong>用户</strong>、<strong>文章</strong>、<strong>评论</strong>。 其关系如下：</p>
<p><img src="/2021/09/21/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/3.jpeg" style="zoom: 50%;"></p>
<p>理清关系之后，我们来解决<strong>怎么存</strong>的问题, 我们有两种典型的方式。</p>
<p>方式1：将所有信息存放到一个文档集合</p>
<p><img src="/2021/09/21/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/4.jpeg" style="zoom: 50%;"></p>
<p>这个文档是关于用户的，包含了用户本身的信息、粉丝的信息、文章的信息</p>
<p>方式2：对于每个对象，用一个文档集合来存放：</p>
<p><img src="/2021/09/21/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/5.jpeg" style="zoom: 50%;"></p>
<h2 id="不同文档结构设计的比较"><a href="#不同文档结构设计的比较" class="headerlink" title="不同文档结构设计的比较"></a>不同文档结构设计的比较</h2><p>上面我们用了两种方式来存放我们所需要的数据，那么那种方式更好呢？判断的标准是我们的应用如何访问数据库</p>
<p>首先，博主登录后看到的第一个页面，虽然可以很简单的获得个人信息，但是我们如果要获得用户关注的人所发的文章信息，会变得非常麻烦。因为我要扫描所有人的信息，找到其fans中ID与该用户相等的人的ID，并拿去找他发布的文章，其最终的结果是需要将整个文档集合扫描一遍，这个效率是很低的</p>
<p>如果是第二种方式，那么我们可以通过User文档来获得个人信息，我们可以扫描用户的fans的ID，去找到他们发布的文章。这样的代价低了很多</p>
<p>在这样一一比较之后，我们需要权衡利弊 来判断哪种方式是适合这个应用的。结果就是都不是太适合。下面我们给出一个较为适合的结构设计</p>
<h2 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h2><p><img src="/2021/09/21/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E6%96%87%E6%A1%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/8.jpeg" style="zoom: 50%;"></p>
<p>最终我们设计出来的文档数据结构如上图所示，我们发现我们在存储了基础必要的信息之后又加了不少冗余信息，包括在文档里面添加了作者的各种信息、在评论中也增加了作者的名字和ID等。这是一种用空间换时间的方法，我们通过存入冗余信息，让应用的每个页面能更快的获取到其所需要的信息</p>
<h2 id="文档数据库设计方法"><a href="#文档数据库设计方法" class="headerlink" title="文档数据库设计方法"></a>文档数据库设计方法</h2><ol>
<li>概念设计：对象以及对象之前的联系</li>
<li>结构设计：对象 &lt;-&gt; 文档；多个对象&lt;——&gt;文档(嵌入式)</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/09/15/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E5%B0%BE%E6%A6%82%E7%8E%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/15/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E5%B0%BE%E6%A6%82%E7%8E%87/" class="post-title-link" itemprop="url">数据科学算法基础-尾概率</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-15 16:14:48" itemprop="dateCreated datePublished" datetime="2021-09-15T16:14:48+08:00">2021-09-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-01-10 09:54:53" itemprop="dateModified" datetime="2024-01-10T09:54:53+08:00">2024-01-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据科学算法基础-尾概率"><a href="#数据科学算法基础-尾概率" class="headerlink" title="数据科学算法基础-尾概率"></a>数据科学算法基础-尾概率</h1><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>我们现在抛一枚均匀的硬币，正面和反面朝上的概率都是0.5，而且每次抛币都是独立的。知觉上，抛的次数越多正面朝上的概率越接近于0.5。如下图所示：</p>
<p><img src="/2021/09/15/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E5%B0%BE%E6%A6%82%E7%8E%87/1.jpg" style="zoom:67%;"></p>
<p>那么，如果我要计算到底抛多少次才能以$95\%$ 的概率保证正面朝上的频率和真实概率间的差距小于某个阈值(0.125)呢？</p>
<p>为了回答这个问题，我们要用到尾概率不等式来计算概率上界，这边有三个方法：</p>
<p>Markov不等式、Chebyshev不等式、和Chernoff不等式</p>
<h3 id="Markov-不等式"><a href="#Markov-不等式" class="headerlink" title="Markov 不等式"></a>Markov 不等式</h3><p>给定样本空间$\Omega$上的非负随机变量X，对 $\forall a\geq 0$ 有：</p>
<script type="math/tex; mode=display">
P(X>a)\leq \frac{E(X)}{a}</script><p>或者</p>
<script type="math/tex; mode=display">
P(X>aE(X))\leq \frac{1}{a}</script><h4 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h4><p>因为$X\geq 0$ ，我们得到：</p>
<script type="math/tex; mode=display">
E(X) = \int_0^\infty xp(x)dx = \int_0^a xp(x)dx +\int_a^\infty xp(x) dx\geq \int_0^\infty xp(x) dx\geq a\int_a^\infty p(x)dx = aP(X>a)</script><p>所以，我们得到 $P(X&gt;a)\leq \frac{E(X)}{a}$</p>
<p>但是，Markov不等式给出的尾概率上界可能非常宽松，比如说，我们要求均匀硬币抛掷n次之后，正面朝 上次数X大于$\frac{3}{4}n$​的概率是：</p>
<script type="math/tex; mode=display">
P(X\geq \frac{3}{4}n)\leq \frac{n/2}{3n/4} = \frac{2}{3}</script><p>用常识来判断，随着n的不断增大，正面朝上次数X 这个概率是很小的，但是用Markov不等式得出的结论是不管n多大，上界都是不变的。</p>
<h3 id="Chebyshev-不等式"><a href="#Chebyshev-不等式" class="headerlink" title="Chebyshev 不等式"></a>Chebyshev 不等式</h3><p>现在我们在马尔科夫不等式的基础上修改一下，令$Y = (X-\mu)^2$ ，带入Markov不等式可得：</p>
<script type="math/tex; mode=display">
P(Y > a^2)\leq \frac{E(Y)}{a^2}</script><p>然后，将概率中的$Y&gt;a^2$开平方，可以得到：</p>
<script type="math/tex; mode=display">
P(|X-\mu|\geq a)\leq \frac{\sigma^2}{a^2}</script><p>因此我们可以给出Chebshev不等式的定义：令X为定义在样本空间$\Omega$ 上的随机变量，对任意的一个正实数$\epsilon$，则：</p>
<script type="math/tex; mode=display">
P(|X-E(X)|\geq \epsilon) \leq \frac{Var(X)}{\epsilon^2}</script><p>切比雪夫不等式还可以写成如下形式：</p>
<script type="math/tex; mode=display">
P(|X-E(X)|<\varepsilon)\geq 1-\frac{Var(X)}{\varepsilon^2}</script><p>再分析一下抛硬币的例子，此时，概率P就变成了：</p>
<script type="math/tex; mode=display">
P(X>\frac34n)<P(|X-\frac{n}2|>\frac{n}{4})\leq \frac{Var(X)}{(n/4)^2}=\frac{16np(1-p)}{n^2}=\frac{4}{n}</script><p>如果抛掷均匀1000次，这一尾概率小于 0.004</p>
<p>这个上界就比Markov小很多了。 </p>
<h3 id="Chernoff-不等式"><a href="#Chernoff-不等式" class="headerlink" title="Chernoff 不等式"></a>Chernoff 不等式</h3><p>随着实验次数的增加，Chernoff 不等式将给出比Chebyshev不等式更紧的尾概率上界。</p>
<p>定理：</p>
<p>若$X<em>i$​ 为定义在样本空间$\Omega$​上的n个独立伯努利随机变量，且 $P(X_i=1)=p_i$​。 令 $X=\sum</em>{i=1}^nX<em>i$​和$\mu=\sum</em>{i=1}^np_i$​,对任意小的$\delta \in(0,1)$​ 有：</p>
<p>结论1：</p>
<script type="math/tex; mode=display">
P(X<(1-\delta)\mu)<(\frac{e^{-\delta}}{(1-\delta)^{(1-\delta)}})^\mu</script><p>结论2：</p>
<script type="math/tex; mode=display">
P(X>(1+\delta)\mu)<(\frac{e^{\delta}}{(1+\delta)^{(1+\delta)}})^\mu</script><p>然而，在不等式中计算$(1-\delta)^{1-\delta}$和$(1+\delta)^{1+\delta}$这两个数是比较麻烦的，因此我们可以用Taylor展开对其进行更进一步的简化。</p>
<p>已知：$\ln (1-\delta) = \sum_{i=1}^\infty -\frac{\delta^i}{i}$</p>
<p>所以：</p>
<script type="math/tex; mode=display">
(1-\delta)\ln(1-\delta) = (1-\delta)\sum_{i=1}^\infty -\frac{\delta^i}{i}=(-\delta+\delta^2-\delta^2/2+\delta^3/2-\cdots)>-\delta+\frac{\delta^2}{2}</script><p>因此</p>
<script type="math/tex; mode=display">
(1-\delta)^{(1-\delta)} >\exp(-\delta+\delta^2/2)\\</script><p>进一步：</p>
<script type="math/tex; mode=display">
P(X<(1-\delta)\mu)<(\frac{e^{-\mu}}{(1-\delta)^{1-\delta}})^\mu\\
<(\frac{e^{-\delta}}{\exp{(-\delta+\frac{\delta^2}{2})}})^\mu=\exp(\frac{-\mu\delta^2}{2})Z</script><p>同理，我们可以证明另外一种情况。</p>
<h4 id="简化后的Chernoff不等式"><a href="#简化后的Chernoff不等式" class="headerlink" title="简化后的Chernoff不等式"></a>简化后的Chernoff不等式</h4><p>结论1：</p>
<script type="math/tex; mode=display">
P(X<(1-\delta)\mu) < \exp (\frac{-\mu\delta^2}{2})\\
P(X>(1+\delta)\mu)<\exp (\frac{-\mu\delta^2}{4})</script><h2 id="Morris算法"><a href="#Morris算法" class="headerlink" title="Morris算法"></a>Morris算法</h2><p> 定义一个数据流, $i∈[1,m],a_i∈[1,n]$​​,频率向量$<fi>, i∈[1,n],f_i∈[1,m]$​​。  数据流是无限的，当数据流流过m个时，出现了N个$a_i$​。  请设计一个算法记录N的大小，要求空间复杂度为$loglog(N)$。</fi></p>
<h3 id="Morris算法-1"><a href="#Morris算法-1" class="headerlink" title="Morris算法"></a>Morris算法</h3><p><strong>算法</strong></p>
<p><img src="/2021/09/15/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E5%B0%BE%E6%A6%82%E7%8E%87/2.png" style="zoom:67%;"></p>
<ol>
<li><p>将X初始化为0</p>
</li>
<li><p>循环</p>
<p> 如果$a_ i$出现一次   就以$1/(2^X)$​的概率将X增加1</p>
</li>
<li><p>返回$\hat f=(2^X−1)$​</p>
</li>
</ol>
<h4 id="证明的目标"><a href="#证明的目标" class="headerlink" title="证明的目标"></a>证明的目标</h4><p>我们期望返回的值与N的差别尽量小，换句话说就是如果$\hat f$与N的差的绝对值大于某一个很小的值的概率很小，那么我们就可以用这种方法进行计数。说得更通俗一点就是使这个算法计算出的结果偏离N不多，或者偏离太多的概率特别小。</p>
<p>可以利用切比雪夫来证明这一点 $P{[|X - \mu| \geq \epsilon]} \leqslant \sigma^{2}/\epsilon^{2}$​​ </p>
<h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>计算期望：$E[2^{X_{N} } - 1] = N$​</p>
<script type="math/tex; mode=display">
E[2^{X_N}-1]=E[2^{X_N}]-1\\
E[2^{X_N}] = \sum_{i=0}^N 2^i\cdot P[X_n = i]\\
=\sum_{i=0}^N\{2^i\cdot P[X_{N-1}=i]+2P[X_{N-1}=i-1]-P[X_{N-1}=i]\}=E[2^{X_{N-1}}] +1\\
=E[2^{X_0}+N ]= N+1</script><p>因此 $E[2^{X_N}-1] = N$</p>
<p>计算方差：$var[2^{X_{N} } - 1] = \frac{1}{2}N^2-\frac{1}{2}N$</p>
<script type="math/tex; mode=display">
\sigma^2 = E[X^2]-E[x]^2\\
E[X^2] = E[4^{X_N}-2^{X_N+1}+1]=E[4^{X_N}]-(N^2+2N+1)\\
E[4^{X_N}] = \sum_{i=0}^N 4^i \cdot P[X_N=i]\\
=\sum_{i=0}^N\{4^i\cdot P[X_{N-1}=i] -2^i\cdot P[X_{N-1}=i]+2^{i+1}\cdot P[X_{N-1}=i-1]\}\\
=\sum_{i=0}^N\{4^i\cdot P[X_{N-1}=i] \}-\sum_{i=0}^N\{2^i\cdot P[X_{N-1}=i\}+\sum_{i=0}^{N-1}\{2^{i+2}\cdot P[X_{N-1}=i] \}\\
=E[4^{X_{N-1}}] +3N = \frac{3}{2}N^2+\frac{3}{2}N+1\\
\sigma^2 = \frac{3}{2}N^2+\frac{3}{2}N+1-(N^2+2N+1) = O(N^2)</script><p>我们令切比雪夫不等式中的 $X = 2^{X_N}-1$​</p>
<p>其中，$X_N$ 指的是$X$ 最终的值，是在这个计数器在流模型中经历了N个数字。则最终得到公式</p>
<script type="math/tex; mode=display">
P[|\hat N - N| \geq \epsilon N ] \leqslant\frac{n^2}{2\epsilon^2n^2}= \frac{1}{2\epsilon^{2} }</script><h4 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h4><p> Morris算法的优点是：输出结果是真实值的无偏估计</p>
<p>但显而易见，模型的正确性并不好，仅当$\epsilon\geq 1$ 时，尾概率上界不大于1/2, 并且<strong>随着N的增大误差和发生误差的概率也会变得越来越大</strong>。</p>
<p>关于近似计数有更加高效的算法morris+算法和morris++算法</p>
<h3 id="Morris-算法"><a href="#Morris-算法" class="headerlink" title="Morris+算法"></a>Morris+算法</h3><p>为了降低Morris算法数据结果的方差，我们提出了Morris+算法</p>
<p><img src="/2021/09/15/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E5%B0%BE%E6%A6%82%E7%8E%87/3.png" style="zoom:67%;"></p>
<p>用语言来描述就是：</p>
<ol>
<li>运行k次morris算法</li>
<li>记录记录结果$(X_1,\cdots,X_k)$</li>
<li>返回$\gamma = \frac{1}{k}\sum<em>{i = 1}^{k}(2^{X</em>{i} } - 1)$​</li>
</ol>
<h4 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h4><p> 直接获取各个$X_i$对应的期望和方差，这在证明morris算法的时候已经计算过了。</p>
<p> 于是可以直接根据期望的性质计算期望$E[γ]=N$</p>
<p> 因为各个变量之间是相互独立的，所以可以利用独立变量之间方差的性质计算方差$D[\gamma] = \frac{N^{2} - N}{2k}$</p>
<p>令切比雪夫不等式中的X为$\frac{1}{k}\sum<em>{i = 1}^{k}(2^{X</em>{i} } - 1)$​​，代入计算得到：$P[|\gamma - N| \geq \epsilon] \leqslant \frac{N^{2}-N}{2k\epsilon^{2} }\approx O(\frac{1}{k\epsilon^2})$​​, 换一种描述就是：</p>
<p>以1−c的概率，$\gamma = N \pm \sqrt{\frac{N^{2}-N}{2kc} }$​ 或者 $N\pm \frac{O(N)}{\sqrt k}$​</p>
<h4 id="评价-1"><a href="#评价-1" class="headerlink" title="评价"></a>评价</h4><p>Morris+算法的复杂度为$O(\frac{1}{\delta\epsilon^2})$</p>
<p>当N确定时，如果想以0.9的概率满足近似标准，使c=0.1，则有 ，我们会发现$k = \frac{5(N^{2} - N)}{\epsilon^{2} }$，这是你需要重复morris算法的次数。然而这么看代价也是不小的，因为这个算法为了保证准确性需要的k的个数并不少。</p>
<h3 id="Morris-算法-1"><a href="#Morris-算法-1" class="headerlink" title="Morris++算法"></a>Morris++算法</h3><p><img src="/2021/09/15/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E5%B0%BE%E6%A6%82%E7%8E%87/4.png" style="zoom:67%;"></p>
<p>用语言来描述，就是：</p>
<ol>
<li>重复morris+算法 $m = O(log(\frac{1}{\delta}))$​次</li>
<li>取m个结果的中位数</li>
</ol>
<p>为了得到$1−\delta$ 下的 $(1+\epsilon)$近似，使用morris+算法需要$k = O(\frac{1}{\epsilon^{2} \delta})$次计算，而morris++算法的工作就是将这一复杂度降低到了$O(\frac{1}{\epsilon^{2} }log(\frac{1}{\delta}))$​​​​说白了，也就是降低了计算次数。</p>
<h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><p>我们假设运行 t 个 Morris+ 实例，每一个都有 1/3 的失败概率，即：</p>
<script type="math/tex; mode=display">
P(\left|{\hat n-n}\right |>\epsilon n)<\frac{1}{k\epsilon^2} = \frac{1}{3},k = O(\frac{1}{\epsilon^2})</script><p>那么，输出所有 t 个 Morris+ 实例输出值的中位数的话，t个Morris+算法都失败的期望是不会超过$t/3$的。因此，Morris++如果输出了一个糟糕的估计，就会以为t个Morris+算法至少有一半都失败了。</p>
<p>我们定义随机变量 $Y_i = \cases{1, \text{if} \left|{\hat n_i-n}\right<br>|&gt;\epsilon n\~\0,\text{otherwise}}$​ 来表示的是第i次 Morris+ 算法失败与否</p>
<p>注意到：</p>
<script type="math/tex; mode=display">
\mu = E(\sum_{i} Y_i)\leq t/3</script><p>则根据Chernoff 不等式可以知道： </p>
<script type="math/tex; mode=display">
P(\sum_i Y_i > t/2) \leq P(\sum_i Y_i>(1+\frac{1}{2})\mu)\leq \exp(-\mu (1/2)^2/3)<\delta</script><p>也就是说得到了 $\exp (-\mu/12)&lt;\delta,\mu&lt;12\ln (1/\delta)$ </p>
<p>因此，需要运行 $t = O(\ln (1/\delta))$次 Morris+算法，其结果的中位数才能符合精度要求的近似估计。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>已知随机变量X的期望 $\mu = E(x)$ 和方差 $\sigma^2 = E[(X-\mu)^2]$. 如果定义随机变量 $X^* = \frac{X-\mu}{\sigma}$ ，证明 </p>
<script type="math/tex; mode=display">
P[|X^*|\geq c] \leq \frac{1}{c^2}</script><p>我们通过求变形后的 $X$ ，结合切比雪夫不等式，来实现</p>
<script type="math/tex; mode=display">
\begin{align}
&E(X^*) = 0\\
&Var(X^*) = \frac{1}{\sigma^2}Var(X) = 1\\
&P(|X^*-0|\geq c)\leq \frac{1}{c^2}
\end{align}</script><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>假设抛一枚均匀的硬币n次，随机变量X定义为正面朝上的次数</p>
<ul>
<li>运用 Chebyshev 不等式给出事件 $X&lt;\frac{n}{4}$ 的概率上界</li>
</ul>
<script type="math/tex; mode=display">
P(|X-\frac{n}{2}|\geq \frac{n}{4}) = P(X\leq \frac{n}{4})\leq \frac{n/4}{n^2/16} =4/n</script><ul>
<li>运用 Chernoff 不等式给出事件 $X&lt;\frac{n}{4}$ 的概率上界</li>
</ul>
<script type="math/tex; mode=display">
P(X<(1-\frac{1}{2})\frac{n}{2})\leq \exp(-\frac{\frac{n}{2}\cdot \frac{1}{4}}{2}) =\exp(-\frac{n}{16})</script><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>设一组独立随机变量 $X<em>i\sim Bernoulli(p)$ ,其中$i=1,\cdots,n$ ，令 $\overline X = \frac{1}{n}\sum</em>{i=1}^n X_i$ 试回答当$n$ 取多少时，使得</p>
<script type="math/tex; mode=display">
P(|\overline X-p|\leq \epsilon p)\geq 1-\delta</script><ol>
<li>首先，我们要改变符号</li>
</ol>
<script type="math/tex; mode=display">
P(|\overline X-p|>\epsilon p)<\delta</script><ol>
<li>同乘以n，得到：</li>
</ol>
<script type="math/tex; mode=display">
P(|\sum_{i=1}^n X_i-np|>\epsilon np)<\delta</script><ol>
<li>展开</li>
</ol>
<script type="math/tex; mode=display">
P(\sum_{i=1}^n X_i>(\epsilon+1) np)+P(\sum_{i=1}^nX_i<(1-\epsilon)np) <\delta</script><p>我们发现，式子左侧可以变成两个Chernoff 不等式</p>
<ol>
<li>利用切诺夫不等式进行放缩</li>
</ol>
<script type="math/tex; mode=display">
P(\sum_{i=1}^nX_i<(1-\epsilon)np)<\exp\{-\frac{np\epsilon^2}{2}\}\\
P(\sum_{i=1}^nX_i>(1+\epsilon)np)<\exp\{-\frac{np\epsilon^2}{3}\}</script><ol>
<li>反解</li>
</ol>
<script type="math/tex; mode=display">
\begin{align}
&2\exp\{-\frac{np\epsilon^2}{2}\}<\delta \\
&exp\{-\frac{np\epsilon^2}{2}\} <\frac \delta 2\\
&\frac{np\epsilon^2}{2}>\ln(\frac{2}{\delta})\\
&n>\frac{2\ln(2/\delta)}{p\epsilon^2}
\end{align}</script>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/09/14/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E6%8A%BD%E6%A0%B7%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E6%8A%BD%E6%A0%B7%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">数据科学算法基础-抽样算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-14 22:02:27" itemprop="dateCreated datePublished" datetime="2021-09-14T22:02:27+08:00">2021-09-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-07 12:08:24" itemprop="dateModified" datetime="2022-01-07T12:08:24+08:00">2022-01-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="抽样算法"><a href="#抽样算法" class="headerlink" title="抽样算法"></a>抽样算法</h1><p>在聊抽样算法之前，我们首先谈一下样本。</p>
<p>样本是总体的一个子集，对其进行观察以获得关于总体的信息。研究样本的目的在于得到有关总体的有效结论(概率论中学过，详见<a href="https://jasonxqh.github.io/2021/06/10/%E6%A6%82%E7%8E%87%E8%AE%BA%E7%AC%AC%E5%85%AD%E7%AB%A0/">参数估计博客</a>) </p>
<p>常见的抽样技术有：</p>
<ul>
<li>简单随机抽样</li>
<li>系统抽样</li>
<li>分层抽样</li>
<li>聚类抽样</li>
<li>多阶段抽样</li>
</ul>
<p>所有的这些方法都属于概率抽样</p>
<h2 id="常见抽样"><a href="#常见抽样" class="headerlink" title="常见抽样"></a>常见抽样</h2><h3 id="简单随机抽样"><a href="#简单随机抽样" class="headerlink" title="简单随机抽样"></a>简单随机抽样</h3><p>这是最简单的抽样算法。</p>
<p>在抽样过程中，若是有放回的抽样统计，那么选择每个对象的概率是相同的。</p>
<p>如果是无放回的抽样统计，在总体容量很大的时候，无放回抽样可以近似看做是等概率抽样。</p>
<p>方法： 令N 为总样本数，$X_i$ 为一随机变量。</p>
<script type="math/tex; mode=display">
X_i = \begin{cases} 1, ~~\text{第i个对象被选择}\\~\\0,~\text{否则}\end{cases}</script><p>其中$P(X_i=1)=p$​ ，为抽样率</p>
<h3 id="系统抽样"><a href="#系统抽样" class="headerlink" title="系统抽样"></a>系统抽样</h3><p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E6%8A%BD%E6%A0%B7%E7%AE%97%E6%B3%95/1.png" style="zoom:67%;"></p>
<p>假设我们要从容量为N的总体中抽取容量为n的样本，有两种系统抽样的策略：</p>
<h4 id="直线等距抽样"><a href="#直线等距抽样" class="headerlink" title="直线等距抽样"></a>直线等距抽样</h4><p>如果N能被n整除</p>
<ul>
<li>那么就可以确定样本大小n并计算<strong>跳跃间隔</strong> $k = \frac{N}{n}$</li>
<li>在1到k之间(包含1和K)随机选择一个起始点r。</li>
<li>然后，反复地在选定第$(r+k\cdot i)$ 个样本点，其中，$i = 1,2\cdots,n-1$</li>
</ul>
<p>相当于总体被分为n组，然后每组有k个样本，每个样本点被选择的概率为$\frac{1}{k}$ </p>
<p>在这种情况下，线性系统抽样方法是等概率的。</p>
<p>但N如果不能被n整除</p>
<ul>
<li>最后一组样本点个数不及k个</li>
<li>此时系统抽样就不是等概率的了。</li>
</ul>
<h4 id="循环系统抽样"><a href="#循环系统抽样" class="headerlink" title="循环系统抽样"></a>循环系统抽样</h4><ol>
<li><p>首先确定间隔 k, 使得 $k = \lfloor\frac{N}{n}\rfloor$</p>
</li>
<li><p>从1到N之间随机开始，选择第$(r+k\cdot i)/\mod N$，知道选择了n个样本为止。</p>
</li>
<li>因此，可能选择N个不同的样本集，而不是k个</li>
<li>在此时，这种抽样方法也是一种<strong>等概率抽样</strong>。</li>
</ol>
<p>系统抽样有以下优缺点：</p>
<ol>
<li>优点<ul>
<li>操作简单，容易取样</li>
<li>它使样本更均匀地分布在总体中</li>
<li>比简单随机抽样更有效，尤其是当列表中的样本点顺序与关注变量的特征无关时</li>
</ul>
</li>
<li>缺点<ul>
<li>一个不好的样本点排列可能会产生一个不具有代表性的样本集。比如我要统计公园一年来的客流量，那么如果起始点抽到了礼拜六，间隔又是一个礼拜，那么显然我采样得到的客流量要比平均客流量要多很多。</li>
<li>非严格等概率抽样，抽样误差计算复杂</li>
</ul>
</li>
</ol>
<h3 id="分层抽样"><a href="#分层抽样" class="headerlink" title="分层抽样"></a>分层抽样</h3><p>分层抽样是根据某种属性(比如性别、职称、院系、地域等)将总体分为多个不同的组。</p>
<p>然后，由满足分层变量值设定条件的样本点组成</p>
<p>这样做的好处是</p>
<ul>
<li>减少估计的标准误差</li>
<li>提供总体不同组别的单独估计(“域”估计)</li>
<li>对不同组别，可以使用不同的抽样方法并行地提高抽样效率</li>
</ul>
<h3 id="样本量分配方法"><a href="#样本量分配方法" class="headerlink" title="样本量分配方法"></a>样本量分配方法</h3><h2 id="水库抽样"><a href="#水库抽样" class="headerlink" title="水库抽样"></a>水库抽样</h2><p>水库抽样是一种针对流数据的高效等效率抽样方法</p>
<p>我们想象流数据应用场景：谷歌搜索引擎的关键词查询，电信骨干网络中转发的数据包。</p>
<p>那么如果想从流数据中抽取容量为1000的样本，怎么办？这是比较困难的，因为在流数据应用场景中，总体容量是无法事先知晓的。另外，可能需要随时返回样本。</p>
<p>现在，我们来介绍水库抽样：</p>
<p>首先，创建一个长度为1000的数组，作为水库。如果流数据不超过1000个元素，每个元素都存入该数组中。</p>
<p>那么，处理第i(i&gt;=1001)个元素，该如何做？</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>设 $S = {59,100,2,30,63,\cdots}$ 且$k=3$</p>
<p>前k个项直接添加到水库中，即样本集合为 ${59,100,2}$</p>
<p>当第4个元素30到达时，程序会随机生成一个1到4之间的随机整数，假定生成随机数$x=4$, 因为 $x&gt;k$ ，则钙元素直接被忽略。</p>
<p>当第5个元素63到达时，程序会随机生成一个1到5之间的随机整数，假定生成随机数$x=2$，因为$x&lt;k$ ，元素63直接替换水库中的第2个元素100. 因此，最终的样本集合为${59,63,2}$</p>
<h4 id="分布式水库抽样方法"><a href="#分布式水库抽样方法" class="headerlink" title="分布式水库抽样方法"></a>分布式水库抽样方法</h4><p>假如说，利用多台机器，能否加快水库抽样的速度呢？水库抽样是否可以扩展成分布式算法呢？</p>
<p>我们可以在每台机器上维护同样大小的水库，分别执行水库抽样算法。然后，对每个水库的样本进行重抽样，逻辑如下：</p>
<p><img src="/2021/09/14/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80-%E6%8A%BD%E6%A0%B7%E7%AE%97%E6%B3%95/2.png" style="zoom:67%;"></p>
<p>分布式水库抽样算法也非常高效，时间复杂度为$O(1)$</p>
<p>分布式水库抽样中，每个元素被重样的概率是相同的，且任意两个元素被抽样是相互独立的。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>设总体有14个个体，按照1~14进行编号。欲以系统抽样法抽取容量为 $n=4$ 的样本，且第一个抽中的样本编号为1，则其余3个样本编号为多少？</p>
<p><strong>这是系统抽样问题</strong></p>
<p>首先，我们要计算间隔 $k = \lfloor \frac{14}{4} \rfloor = 3$  ，也就是要跳跃3个样本取下一个样本，因此取 $1,5,9,13$</p>
<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>某校高一年级500名学生中，血型为O的有200人，血型为A的有125人，血型为B的有125人，血型为AB型的有50人．为了研究血型与色弱的关系，要从中抽取一个容量为40的样本，应如何抽样？写出血型为AB型的抽样过程．</p>
<p><strong>这是分层抽样算法</strong></p>
<p>首先，在500名学生中取40名样本，概率为 $\frac{2}{25}$ </p>
<p>所以，应用分层抽样法抽取</p>
<ul>
<li>血型为O型的： $\frac{2}{25}\times 200 = 16$ </li>
<li>血型为A型的: $\frac{2}{25}\times 125 = 10$</li>
<li>血型为B型的: $\frac{2}{25}\times 125 = 10$</li>
<li>血型为AB型的: $\frac{2}{25}\times 50 = 4$ </li>
</ul>
<p>AB型的4人可以这么抽取：</p>
<p>第一步：将50人随机编号，1~50</p>
<p>第二步：把以上50人的编号分别写在号签上</p>
<p>第三步：从袋子里抽取四个号签，找出对应的4人。</p>
<p>其余血型的人也可以用这种方法来抽取。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/09/13/%E8%BD%AF%E4%BB%B6%E4%BC%98%E5%8C%96-%E5%AE%BE%E5%88%A9%E6%B3%95%E5%88%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/13/%E8%BD%AF%E4%BB%B6%E4%BC%98%E5%8C%96-%E5%AE%BE%E5%88%A9%E6%B3%95%E5%88%99/" class="post-title-link" itemprop="url">软件优化-宾利法则</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-13 11:35:33" itemprop="dateCreated datePublished" datetime="2021-09-13T11:35:33+08:00">2021-09-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-14 16:20:52" itemprop="dateModified" datetime="2021-09-14T16:20:52+08:00">2021-09-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="软件优化-宾利法则"><a href="#软件优化-宾利法则" class="headerlink" title="软件优化-宾利法则"></a>软件优化-宾利法则</h1><p>现在我们来讲宾利法则，这个宾利不是车企，而是一个计算机学家。他提出了软件优化的若干法则。主要分为四个部分：数据结构，循环，逻辑，函数。每个部分又分为若干小点，现在我们来一一讲解</p>
<h2 id="Data-structures"><a href="#Data-structures" class="headerlink" title="Data structures"></a>Data structures</h2><h3 id="Packing-and-encoding-压缩和编码"><a href="#Packing-and-encoding-压缩和编码" class="headerlink" title="Packing and encoding 压缩和编码"></a>Packing and encoding 压缩和编码</h3><p>压缩的概念是用相同的机器语言表示尽可能多的数据，编码优化则是用尽可能少的bits去表示数据的值。</p>
<p>比如说，字符串”September 11,2018“ 能以18 bytes的大小被存储，这需要两个<code>double(64-bits) words</code> 才能放下。 这对于日期信息来说，是比较庞大的一段空间了。其实，要是计算公元前后4096年的日期，大概只要</p>
<script type="math/tex; mode=display">
\lceil\lg(365.25\times 8192)\rceil =22\text{bits}</script><p>就可以了，只需要 <code>single word(32-bit)</code> 就可以存储了</p>
<p>但是，修改了编码方式，并不意味着可以提升程序的性能。因为虽然空间上减少了很多。但是要计算得到这个编码，需要消耗更多的CPU性能，所以在这个情况下修改编码并不是一个很好地选择。</p>
<p>我们另辟蹊径，用另外一种数据结构来存储这些信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> year: <span class="number">13</span>;</span><br><span class="line">	<span class="keyword">int</span> month: <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">int</span> day: <span class="number">5</span>;</span><br><span class="line">&#125; <span class="keyword">date_t</span>;</span><br></pre></td></tr></table></figure>
<p>用struct来存储这些信息，同样只要消耗22 bits(存储年份需要13位，一位表示公园前后)，但是计算速度要比上面那种编码快很多。</p>
<h3 id="Augmentation-扩充策略"><a href="#Augmentation-扩充策略" class="headerlink" title="Augmentation 扩充策略"></a>Augmentation 扩充策略</h3><p>有些时候，我们对一个普通的数据结构加上一些信息，来让数据结构做更少的计算。</p>
<p>比如说，现在有两个链表，我们需要将它们头尾相连：正常的方法是，我们要先找到一个链表的尾部，然后再将其连到一个拎一个链表的头部，如下图所示</p>
<p><img src="/2021/09/13/%E8%BD%AF%E4%BB%B6%E4%BC%98%E5%8C%96-%E5%AE%BE%E5%88%A9%E6%B3%95%E5%88%99/1.png" style="zoom:50%;"></p>
<p>但是，我们可以在链表中添加一点东西，比如说，在head节点添加一个tail指针，让其指向该链表的尾部。这样一来，就可以迅速地找到链表的尾部了，如下图所示：</p>
<p><img src="/2021/09/13/%E8%BD%AF%E4%BB%B6%E4%BC%98%E5%8C%96-%E5%AE%BE%E5%88%A9%E6%B3%95%E5%88%99/2.png" style="zoom:50%;"></p>
<h3 id="Precomputation-预计算"><a href="#Precomputation-预计算" class="headerlink" title="Precomputation 预计算"></a>Precomputation 预计算</h3><p>预计算就是在程序里面先将要算的值存储下来。比如说要计算二项式系数，我们可以用递归的方法来做：</p>
<p><img src="/2021/09/13/%E8%BD%AF%E4%BB%B6%E4%BC%98%E5%8C%96-%E5%AE%BE%E5%88%A9%E6%B3%95%E5%88%99/3.png" style="zoom:50%;"></p>
<p>但是递归可能会消耗很多CPU性能，因此我们可以使用动态规划的方法，将预计算得到的值存储起来，如下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> CHOOSE_SIZE 100</span></span><br><span class="line"><span class="keyword">int</span> choose[CHOOSE_SIZE][CHOOSE_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_choose</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> n = <span class="number">0</span>;n &lt; CHOOSE_SIZE ;n++)&#123;</span><br><span class="line">		choose[n][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		choose[n][n] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> n = <span class="number">1</span>;n &lt; CHOOSE_SIZE; ++n)&#123;</span><br><span class="line">		choose[<span class="number">0</span>][n] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>;k&lt;n;++k)&#123;</span><br><span class="line">			choose[n][k] = choose[n<span class="number">-1</span>][k<span class="number">-1</span>]+choose[n<span class="number">-1</span>][k];</span><br><span class="line">			choose[k][n] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/09/13/%E8%BD%AF%E4%BB%B6%E4%BC%98%E5%8C%96-%E5%AE%BE%E5%88%A9%E6%B3%95%E5%88%99/4.png" style="zoom:50%;"></p>
<p>使用了动态规划以后，我们就不用做很深的递归了，只要在数组中取数即可。只要数组规模小于100x100即可</p>
<h3 id="Compile-time-initialization-编译时初始化"><a href="#Compile-time-initialization-编译时初始化" class="headerlink" title="Compile-time initialization 编译时初始化"></a>Compile-time initialization 编译时初始化</h3><p>编译时初始化就是在编译时存储一些常量，这样就可以减少计算的次数。还是以上面的pascal三角形为例，我们可以直接将二维数组存储起来。</p>
<p><img src="/2021/09/13/%E8%BD%AF%E4%BB%B6%E4%BC%98%E5%8C%96-%E5%AE%BE%E5%88%A9%E6%B3%95%E5%88%99/5.png" style="zoom:50%;"></p>
<h4 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h4><p>还有一种预计算的方法就是元编程(metaprogramming)。先看看 meta-data：</p>
<p>「我的电话是 +86 123 4567 8910」<br>  ——这是一条数据；<br>「+86 123 4567 8910 有十三个数字和一个字符，前两位是国家代码，后面是一个移动电话号码」   —— 这是关于前面那条数据的数据。</p>
<p>那么照猫画虎，怎样才算 meta-programming 呢？泛泛来说，只要是与编程相关的编程就算是 meta-programming 了——比如，若编程甲可以输出 A - Z，那么写程序甲算「编程」；而程序乙可以<strong>生成</strong>程序甲（也许还会连带着运行它输出 A - Z），那么编写程序乙的活动，就可以算作 meta-programming，「元编程」。注意，程序甲和程序乙并不一定是同一种语言.</p>
<p>比如说，要生成一张C语言的二维数组，可以这么编写C语言：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	init_choose();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"int choose[10][10] = &#123;\n"</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; <span class="number">10</span>;++a)&#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">" &#123;"</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>;b &lt; <span class="number">10</span>;++b)&#123;</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">"%3d, "</span>,choose[a][b]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"&#125;,\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"&#125;;\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Caching-缓存"><a href="#Caching-缓存" class="headerlink" title="Caching 缓存"></a>Caching 缓存</h3><p>缓存的想法就是将最近访问过的数据放到内存里，这样再次访问时就可以快速从内存里取出，而不用到磁盘里面去找。比如说求平方根的一个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">hypotenuse</span><span class="params">(<span class="keyword">double</span> A,<span class="keyword">double</span> B)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>(A*A+B*B);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以写成是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> cached_A = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">double</span> cached_B = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">double</span> cached_C = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">hypotenuse</span><span class="params">(<span class="keyword">double</span> A,<span class="keyword">double</span> B)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (A == cached_A &amp;&amp; B == cashed_B)&#123;</span><br><span class="line">		<span class="keyword">return</span> cached_h;</span><br><span class="line">	&#125;</span><br><span class="line">	cached_A = A;</span><br><span class="line">	cached_B = B;</span><br><span class="line">	cached_h = <span class="built_in">sqrt</span>(A*A + B*B);</span><br><span class="line">	<span class="keyword">return</span> cached_h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果缓存能有2/3的概率击中的话，那么就可以第一种方法快30%。但是这种缓存也不是很好，毕竟在现实情况下能击中的概率是很低的，还要进行判断等操作，弄不好就会得不偿失。</p>
<h3 id="Sparsity-稀疏"><a href="#Sparsity-稀疏" class="headerlink" title="Sparsity 稀疏"></a>Sparsity 稀疏</h3><h4 id="稀疏矩阵的存储"><a href="#稀疏矩阵的存储" class="headerlink" title="稀疏矩阵的存储"></a>稀疏矩阵的存储</h4><p>比如我们要做矩阵-向量乘法，如下：</p>
<p><img src="/2021/09/13/%E8%BD%AF%E4%BB%B6%E4%BC%98%E5%8C%96-%E5%AE%BE%E5%88%A9%E6%B3%95%E5%88%99/6.png" style="zoom:50%;"></p>
<p>如果我们就这样计算，那么需要计算36次乘法，还要很多次加法。但事实上我们看到系数矩阵有很多的值都是0，有效值只有14个，因此我们可以对其进行压缩。</p>
<p>我们采取CSR的方法，将稀疏矩阵变成这样的形式：</p>
<p><img src="/2021/09/13/%E8%BD%AF%E4%BB%B6%E4%BC%98%E5%8C%96-%E5%AE%BE%E5%88%A9%E6%B3%95%E5%88%99/7.png" style="zoom:50%;"></p>
<p>也就是说，采用三个一维数组来存储二维矩阵中的所有非零元素。这三个数组分别为：rows，cols和values。</p>
<ul>
<li>value数组存储所有的非零元素</li>
<li>column 数组存储所有非零元素的列下标</li>
<li>row 数组存储所有的非零数组的行下标。最原始的存储方式就是：<code>[0,0,1,1,1,1,2,2,3,3,4,5,5,5]</code>。 但是，我们通过row行可以看到，很多重复的数值，也就是每一行的多个元素，每个元素都对应着同样的行号，这样也浪费的空间，因此，我们引入csr稀疏矩阵存储方式，该存储方式将重复的行号压缩，只记录，开头和结尾元素的位置，也就变成了 <code>[0,2,6,8,10,11,14]</code></li>
</ul>
<p>其中，nnz就是整个稀疏矩阵中非零值的个数。 </p>
<p>这样，存储的空间复杂度就从$O(n^2)$ 变成了 $O(n+nnz)$ ，在n很大的时候，可以有效地减小复杂度。</p>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> n ,nnz;</span><br><span class="line">	<span class="keyword">int</span> *rows;			<span class="comment">// length n</span></span><br><span class="line">	<span class="keyword">int</span> *cols;			<span class="comment">// length nnz</span></span><br><span class="line">	<span class="keyword">double</span> *vals;		<span class="comment">// length nnz</span></span><br><span class="line">&#125; <span class="keyword">sparse_matrix_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spmv</span><span class="params">(<span class="keyword">sparse_matrix_t</span> *A,<span class="keyword">double</span> *x,<span class="keyword">double</span> *y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; A-&gt; n ; i++)&#123;</span><br><span class="line">		y[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = A-&gt; row[i];k&lt;A-&gt;rows[i+<span class="number">1</span>];k++)&#123;</span><br><span class="line">			<span class="keyword">int</span> j = A-&gt;cols[k];</span><br><span class="line">			y[i] += A-&gt;vals[k]*x[j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="稀疏图的存储"><a href="#稀疏图的存储" class="headerlink" title="稀疏图的存储"></a>稀疏图的存储</h4><p>在数据结构中，通常会用矩阵来存储图。如果这个图的边很少，那么显然这个矩阵就是一个稀疏矩阵了。因此，我们可以用CSR的方法来存稀疏图。如下图所示：</p>
<p><img src="/2021/09/13/%E8%BD%AF%E4%BB%B6%E4%BC%98%E5%8C%96-%E5%AE%BE%E5%88%A9%E6%B3%95%E5%88%99/8.png" style="zoom:50%;"></p>
<ul>
<li><p>节点0出来，指向1、3</p>
</li>
<li><p>节点1出来，指向2、3、4</p>
</li>
<li><p>节点2没有出度</p>
</li>
<li><p>节点3出来，指向2</p>
</li>
<li><p>节点4出来，指向2</p>
<p>如果这个边有权重的话，可以再添加一个和Edges长度一样的数组，记录每条边的权重。 </p>
</li>
</ul>
<h2 id="Logic"><a href="#Logic" class="headerlink" title="Logic"></a>Logic</h2><h3 id="Constant-folding-and-propagation-常量折叠与常量传播"><a href="#Constant-folding-and-propagation-常量折叠与常量传播" class="headerlink" title="Constant folding and propagation 常量折叠与常量传播"></a>Constant folding and propagation 常量折叠与常量传播</h3><p>常量折叠与常量传播的想法就是在编译的过程中，用常量表达式去替换在代码中要用到的表达式。</p>
<p>比如下面几个例子，我们已经申请了一系列常量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">orrery</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span> radius = <span class="number">6371000.0</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span> diameter = <span class="number">2</span>*radius;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span> circumference = M_PI * disameter;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多数的现代编译器不会真的产生计算的指令再将结果储存下来，取而代之的，他们会辨识出语句的结构，并在编译时期将数值计算出来（在这个例子，在处理diameter的时候，就会直接计算得到其值为12742000）</p>
<h3 id="Common-subexpression-elimination-公共子表达式消除"><a href="#Common-subexpression-elimination-公共子表达式消除" class="headerlink" title="Common-subexpression elimination 公共子表达式消除"></a>Common-subexpression elimination 公共子表达式消除</h3><p>公共子表达式消除是一项启发式的查询转换技术，它将反意连接词（如 OR）连接的谓词进行合并，消除不必要的子表达式。如果两个表达式等价但是复杂度不一样，我们就可以用低复杂度的表达式替换掉高复杂度的表达式</p>
<p>任何一个编译器都遵循两个原则：语义等价原则和保守原则。保守原则是说，如果不能确定能不能做，那么编译器就不会去做。</p>
<p>那么我们看到这个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = b+c;											a = b+c;</span><br><span class="line">b = a-d;						——&gt;				b = a-d;</span><br><span class="line">c = b+c;						——&gt; 			c = b+c;</span><br><span class="line">d = a-d;											d = b;</span><br></pre></td></tr></table></figure>
<p>我们可以用赋值语句替换掉原来的加运算。这样可以减少cpu的计算次数。但是要注意，在上例中第三句不能写成是<code>c=a</code>因为在第二句中，b的值进行了修改。</p>
<h3 id="Algebraic-identities-代数恒等式"><a href="#Algebraic-identities-代数恒等式" class="headerlink" title="Algebraic identities 代数恒等式"></a>Algebraic identities 代数恒等式</h3><p>代数恒等式的想法就是将代数等价的低复杂度表达式替换掉高复杂度的式子。</p>
<p>比如说，我要判断两个圆形是否相交，原始的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">double</span> x;			<span class="comment">// x-coordinate</span></span><br><span class="line">	<span class="keyword">double</span> y;			<span class="comment">// y-coordinate</span></span><br><span class="line">	<span class="keyword">double</span> z;			<span class="comment">// z-coordinate</span></span><br><span class="line">	<span class="keyword">double</span> r;			<span class="comment">// radius of ball</span></span><br><span class="line">&#125; <span class="keyword">ball_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">collides</span><span class="params">(<span class="keyword">ball_t</span> *b1, <span class="keyword">ball_t</span> *b2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> d = <span class="built_in">sqrt</span>(square(b1-&gt;x-b2-&gt;x)+square(b1-&gt;y - b2-&gt;y)+square(b1-&gt;z-b2-&gt;z));</span><br><span class="line">	<span class="keyword">return</span> d &lt;= b1-&gt;r + b2-&gt;r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是判断一下是否两个球圆心之间的距离是否大于两个球的半径之和。若大于说明未相交，反之则相交</p>
<p>但是这样的代数式比较复杂的，因为sqrt函数会消耗更大的计算机新能。因为$\sqrt u\leq v \text{~~~完全等价于} ~~u\leq v^2$我们可以用更简单的代数恒等式来替代上面这个逻辑：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">double</span> x;			<span class="comment">// x-coordinate</span></span><br><span class="line">	<span class="keyword">double</span> y;			<span class="comment">// y-coordinate</span></span><br><span class="line">	<span class="keyword">double</span> z;			<span class="comment">// z-coordinate</span></span><br><span class="line">	<span class="keyword">double</span> r;			<span class="comment">// radius of ball</span></span><br><span class="line">&#125; <span class="keyword">ball_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">collides</span><span class="params">(<span class="keyword">ball_t</span> *b1, <span class="keyword">ball_t</span> *b2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> d =  square(b1-&gt;x-b2-&gt;x)+square(b1-&gt;y - b2-&gt;y)+square(b1-&gt;z-b2-&gt;z) ;</span><br><span class="line">	<span class="keyword">return</span> d &lt;= square(b1-&gt;r + b2-&gt;r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Short-circuiting-抄近路"><a href="#Short-circuiting-抄近路" class="headerlink" title="Short-circuiting 抄近路"></a>Short-circuiting 抄近路</h3><p>Short-circuiting 的想法是当我知道了答案以后，我们就没必要把整套逻辑都做完，直接返回答案即可</p>
<p>比如说：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="comment">//All elements of A are nonnegative</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sum_exceeds</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> n,<span class="keyword">int</span> limit)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		sum += A[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum &gt; limit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以把最后的判断逻辑放到循环里面，一旦发现sum大于limit，直接跳出循环返回，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="comment">//All elements of A are nonnegative</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sum_exceeds</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> n,<span class="keyword">int</span> limit)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		sum += A[i];</span><br><span class="line">		<span class="keyword">if</span> (sum &gt; limit) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这两个程序都存在明显的逻辑漏洞。因为整数相加后有溢出的风险。</p>
<p>同样的，修改了这个逻辑之后，也不一定会拿到好处。因为我们在每一次循环中都要做if判断，如果前面很多数都很小，没有到达limit，那么程序就会一直执行if判断，运行速度反而会变慢。</p>
<h3 id="Ordering-tests-判断条件的顺序"><a href="#Ordering-tests-判断条件的顺序" class="headerlink" title="Ordering tests 判断条件的顺序"></a>Ordering tests 判断条件的顺序</h3><p>我们知道代码是根据顺序逻辑执行的。 Ordering tests的思想是在很少成功的case之前执行那些更经常“成功”的case（测试选择了特定的替代方案）。同样，代价少的测试应该先于代价高的测试。比如说下面这个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_whitespace</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (c == <span class="string">'\r'</span> || c==<span class="string">'\t'</span> || c==<span class="string">' '</span>||c == <span class="string">'\n'</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一篇文章里面，最常见的肯定是空格，换行回车符是比较少的。若采用上面这个策略，那么大多数字符要经过前两个比较才能成功判断为空格并退出判断。因此我们可以修改case的顺序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_whitespace</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (c == <span class="string">' '</span> || c==<span class="string">'\r'</span> || c==<span class="string">'\t'</span>||c == <span class="string">'\n'</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样大多数字符已进入if-case就会落入<code>c==&#39; &#39;</code>的判断并跳出判断，节省了判断次数 </p>
<h3 id="Creating-a-fast-path"><a href="#Creating-a-fast-path" class="headerlink" title="Creating a fast path"></a>Creating a fast path</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">double</span> x;			<span class="comment">// x-coordinate</span></span><br><span class="line">	<span class="keyword">double</span> y;			<span class="comment">// y-coordinate</span></span><br><span class="line">	<span class="keyword">double</span> z;			<span class="comment">// z-coordinate</span></span><br><span class="line">	<span class="keyword">double</span> r;			<span class="comment">// radius of ball</span></span><br><span class="line">&#125; <span class="keyword">ball_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">collides</span><span class="params">(<span class="keyword">ball_t</span> *b1, <span class="keyword">ball_t</span> *b2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (</span><br><span class="line">	(<span class="built_in">abs</span>(b1-&gt;x - b2-&gt;x)&gt;(b1-&gt;r + b2-&gt;r))||</span><br><span class="line">	(<span class="built_in">abs</span>(b1-&gt;y - b2-&gt;y)&gt;(b1-&gt;r + b2-&gt;r))||</span><br><span class="line">	(<span class="built_in">abs</span>(b1-&gt;z - b2-&gt;z)&gt;(b1-&gt;r + b2-&gt;r))</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">double</span> d =  square(b1-&gt;x-b2-&gt;x)+square(b1-&gt;y - b2-&gt;y)+square(b1-&gt;z-b2-&gt;z) ;</span><br><span class="line">	<span class="keyword">return</span> d &lt;= square(b1-&gt;r + b2-&gt;r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Combining-tests"><a href="#Combining-tests" class="headerlink" title="Combining tests"></a>Combining tests</h3><p>Combining tests的想法就是用一个if-case或者switch case 来替换多分支的if判断</p>
<p>比如我们要实现下面这张逻辑表。用if-case 来写，会非常非常复杂：</p>
<p><img src="/2021/09/13/%E8%BD%AF%E4%BB%B6%E4%BC%98%E5%8C%96-%E5%AE%BE%E5%88%A9%E6%B3%95%E5%88%99/9.png" style="zoom:50%;"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">full_add</span> <span class="params">(	<span class="keyword">int</span> a,</span></span></span><br><span class="line"><span class="function"><span class="params">								<span class="keyword">int</span> b,</span></span></span><br><span class="line"><span class="function"><span class="params">								<span class="keyword">int</span> c,</span></span></span><br><span class="line"><span class="function"><span class="params">								<span class="keyword">int</span> *sum,</span></span></span><br><span class="line"><span class="function"><span class="params">								<span class="keyword">int</span> *carry)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>( a == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(b == <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(c == <span class="number">0</span>)&#123;</span><br><span class="line">					*sum = <span class="number">0</span>;</span><br><span class="line">					*carry = <span class="number">0</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					*sum = <span class="number">1</span>;</span><br><span class="line">					*carry = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>(c == <span class="number">0</span>)&#123;</span><br><span class="line">					*sum = <span class="number">1</span>;</span><br><span class="line">					*carry = <span class="number">0</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					*sum = <span class="number">0</span>;</span><br><span class="line">					*carry = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>(b == <span class="number">0</span>)&#123;</span><br><span class="line">					<span class="keyword">if</span>(c == <span class="number">0</span>)&#123;</span><br><span class="line">						*sum = <span class="number">1</span>;</span><br><span class="line">						*carry = <span class="number">0</span>;</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						*sum = <span class="number">0</span>;</span><br><span class="line">						*carry = <span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (c == <span class="number">0</span>)&#123;</span><br><span class="line">						*sum = <span class="number">0</span>;</span><br><span class="line">						*carry = <span class="number">1</span>;</span><br><span class="line">					&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">						*sum = <span class="number">1</span>；</span><br><span class="line">						*carry = <span class="number">1</span>；</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为计算机会进行预测，会把预测得到的结果拿到内存里，但是这样的预测的正确性是很低的，因此会导致执行效率大大降低。为了解决这个问题，我们可以采用switch-case</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">full_add</span> <span class="params">(	<span class="keyword">int</span> a,</span></span></span><br><span class="line"><span class="function"><span class="params">								<span class="keyword">int</span> b,</span></span></span><br><span class="line"><span class="function"><span class="params">								<span class="keyword">int</span> c,</span></span></span><br><span class="line"><span class="function"><span class="params">								<span class="keyword">int</span> *sum,</span></span></span><br><span class="line"><span class="function"><span class="params">								<span class="keyword">int</span> *carry)</span></span>&#123;</span><br><span class="line">			<span class="keyword">int</span> <span class="built_in">text</span> = ((a==<span class="number">1</span>)&lt;&lt;<span class="number">2</span>)((b == <span class="number">1</span>)&lt;&lt;<span class="number">1</span>)(c == <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">switch</span>(<span class="built_in">text</span>)&#123;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">					*sum = <span class="number">0</span>;</span><br><span class="line">					*carry = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">					*sum = <span class="number">1</span>;</span><br><span class="line">					*carrt = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">					*sum = <span class="number">1</span>;</span><br><span class="line">					*carrt = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">					*sum = <span class="number">0</span>;</span><br><span class="line">					*carrt = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">					*sum = <span class="number">1</span>;</span><br><span class="line">					*carrt = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">					*sum = <span class="number">0</span>;</span><br><span class="line">					*carrt = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">					*sum = <span class="number">0</span>;</span><br><span class="line">					*carrt = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">					*sum = <span class="number">1</span>;</span><br><span class="line">					*carrt = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Loops"><a href="#Loops" class="headerlink" title="Loops"></a>Loops</h2><h3 id="Hoisting"><a href="#Hoisting" class="headerlink" title="Hoisting"></a>Hoisting</h3><p>hoisting 也叫做循环不变式的代码移动，就是将循环中不变的式子移动到循环外。这样就不用每次循环都进行计算了。比如下面这个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scale</span><span class="params">(<span class="keyword">double</span> *X,<span class="keyword">double</span> *Y,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">		Y[i] = X[i]*<span class="built_in">exp</span>(<span class="built_in">sqrt</span>(M_PI/<span class="number">2</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现这个 <code>exp(sqrt(M_PI/2))</code>是一个不变的量，但是放在循环里面每次都要计算一遍，很浪费，所以可以这样改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scale</span><span class="params">(<span class="keyword">double</span> *X,<span class="keyword">double</span> *Y,<span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> factor = <span class="built_in">exp</span>(<span class="built_in">sqrt</span>(M_PI/<span class="number">2</span>))</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">		Y[i] = X[i]*factor;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Sentinels-哨兵"><a href="#Sentinels-哨兵" class="headerlink" title="Sentinels  哨兵"></a>Sentinels  哨兵</h3><p>哨兵是一些在数据结构中的dummy value，用来简化边界条件的一些逻辑。</p>
<p>这是一个判断是否溢出的程序，如果sum变成了负数，说明溢出了，那么返回真。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#includer <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">overflow</span> <span class="params">(<span class="keyword">int64_t</span> *A, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// All elements of A are nonnegative</span></span><br><span class="line">  <span class="keyword">int64_t</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; ++i ) &#123;</span><br><span class="line">    sum += A[i];</span><br><span class="line">    <span class="keyword">if</span> ( sum &lt; A[i] ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们对这个程序进行优化，如果说sum加到最后发现小于<code>A[i]</code>了，说明溢出了，这时候i肯定是小于n的，所以返回true；如果加到<code>A[n-1]</code>之后，没有溢出，那么下一次就落入<code>sum &lt;= A[n]</code>的判断，必为真，此时i=n返回false</p>
<p>我们需要给这个程序添加一个哨兵，也就是 <code>A[n+1]=1</code> ，为了防止 <code>A[0]</code>到<code>A[n-1]</code>都是0的情况。否则加到<code>A[n]</code>后无法跳出循环，设定 <code>A[n+1]=1</code> 是为了<code>sum=INT64_MAX</code>之后再+1变为负值，跳出循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#includer <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="comment">//  Assumes that A[n] and A[n+1] exist and can be clobbered</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">overflow</span> <span class="params">(<span class="keyword">int64_t</span> *A, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// All elements of A are nonnegative</span></span><br><span class="line">  A[n] = INT64_MAX;</span><br><span class="line">  A[n+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int64_t</span> sum = A[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">while</span>( sum &gt;= A[i])&#123;</span><br><span class="line">  	sum += A[++i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (i &lt;n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Loop-unrolling-循环展开"><a href="#Loop-unrolling-循环展开" class="headerlink" title="Loop unrolling 循环展开"></a>Loop unrolling 循环展开</h3><p>循环展开尝试在一次迭代中执行多次迭代的内容。因此可以减少迭代的次数，因为迭代的过程需要消耗更多的机器指令。并且能让编译器优化更多内容。</p>
<p>但是，也不要展开太多。否则会导致指令缓存的滥用。因此，我们有两种展开方式，全展开和部分展开</p>
<h4 id="Full-Loop-unrolling"><a href="#Full-Loop-unrolling" class="headerlink" title="Full Loop unrolling"></a>Full Loop unrolling</h4><p>所有循环展开对于次数不多的循环是有效的，比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">	sum += A[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以换成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">sum += A[<span class="number">0</span>];</span><br><span class="line">sum += A[<span class="number">1</span>];</span><br><span class="line">sum += A[<span class="number">2</span>];</span><br><span class="line">sum += A[<span class="number">3</span>];</span><br><span class="line">sum += A[<span class="number">4</span>];</span><br><span class="line">sum += A[<span class="number">5</span>];</span><br><span class="line">sum += A[<span class="number">6</span>];</span><br><span class="line">sum += A[<span class="number">7</span>];</span><br><span class="line">sum += A[<span class="number">8</span>];</span><br><span class="line">sum += A[<span class="number">9</span>];</span><br><span class="line">sum += A[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<h4 id="Partial-Loop-unrolling"><a href="#Partial-Loop-unrolling" class="headerlink" title="Partial Loop unrolling"></a>Partial Loop unrolling</h4><p>部分循环展开更好一些，我们可以这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j ;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; n<span class="number">-3</span>;j+=<span class="number">4</span>)&#123;</span><br><span class="line">	sum += A[j];</span><br><span class="line">	sum += A[j+<span class="number">1</span>];</span><br><span class="line">	sum += A[j+<span class="number">2</span>];</span><br><span class="line">	sum += A[j+<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = j ; i&lt; n;++i)&#123;</span><br><span class="line">	sum += A[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Loop-fusion-循环融合"><a href="#Loop-fusion-循环融合" class="headerlink" title="Loop fusion 循环融合"></a>Loop fusion 循环融合</h3><p>Loop fusion是将循环次数相同的若干循环给放到一个循环当中，同样是用来减少循环次数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">	C[i] = (A[i] &lt;= B[i])? A[i]:B[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">	D[i] = (A[i] &lt;= B[i])? B[i]:A[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以把上述两个循环合并</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">	C[i] = (A[i] &lt;= B[i])? A[i]:B[i];</span><br><span class="line">	D[i] = (A[i] &lt;= B[i])? B[i]:A[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Eliminating-wasted-iteration"><a href="#Eliminating-wasted-iteration" class="headerlink" title="Eliminating wasted iteration"></a>Eliminating wasted iteration</h3><p>消除多余迭代同样是要减少迭代的次数。比如说在下面这个例子中，我们可以将双重循环和ifcase结合起来</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n; ++i)&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n; ++j)&#123;</span><br><span class="line">		<span class="keyword">if</span>(i &gt; j)&#123;</span><br><span class="line">			<span class="keyword">int</span> temp = A[i][j];</span><br><span class="line">			A[i][j] = A[j][i];</span><br><span class="line">			A[j][i] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以写成是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;++i)&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;i;++j)&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = A[i][j];</span><br><span class="line">		A[i][j] = A[j][i];</span><br><span class="line">		A[j][i] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><h3 id="Inlining-内联函数"><a href="#Inlining-内联函数" class="headerlink" title="Inlining 内联函数"></a>Inlining 内联函数</h3><p>内联函数也是在编译上下功夫，和宏不一样，宏是直接替换代码，不做语义上的检测。但是内联函数的话，编译器会在编译时进行语义上的检测，比用宏更加安全。</p>
<p>比如说：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">square</span> <span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum_of_squares</span> <span class="params">(<span class="keyword">double</span> *A,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		sum += square(A[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以将square变成内联函数，可以在编译时进行替换。减少调用所花费的指令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="keyword">inline</span> <span class="title">square</span> <span class="params">(<span class="keyword">double</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Tail-recursion-elimination"><a href="#Tail-recursion-elimination" class="headerlink" title="Tail-recursion elimination"></a>Tail-recursion elimination</h3><h3 id="Coarsening-recursion"><a href="#Coarsening-recursion" class="headerlink" title="Coarsening recursion"></a>Coarsening recursion</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/09/10/%E5%8D%95%E5%9B%A0%E5%AD%90%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/10/%E5%8D%95%E5%9B%A0%E5%AD%90%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">单因子方差分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-10 08:13:39" itemprop="dateCreated datePublished" datetime="2021-09-10T08:13:39+08:00">2021-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-05 10:44:02" itemprop="dateModified" datetime="2022-01-05T10:44:02+08:00">2022-01-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="单因子方差分析"><a href="#单因子方差分析" class="headerlink" title="单因子方差分析"></a>单因子方差分析</h1><h2 id="Review-二样本独立t检验"><a href="#Review-二样本独立t检验" class="headerlink" title="Review:二样本独立t检验"></a>Review:二样本独立t检验</h2><p>首先我们复习一下<strong>二样本独立t检验</strong>，因为这时单因子方差分析的一种特殊情况。</p>
<p>目的： 比较两个<strong>方差相等</strong>的独立正态分布的均值是否相等。</p>
<p>数据：</p>
<script type="math/tex; mode=display">
\text{样本1:~~}x_{11},x_{12},\cdots,x_{1m_1}\\
\text{样本2:~~}x_{21},x_{22},\cdots,x_{2m_2}</script><p>假定$x_{ij}$是独立的随机变量，其分布为 $N(\mu_i,\sigma^2)$,那么</p>
<ul>
<li>$\mu_i$ 表示第 i 组的总体均值</li>
<li>$\sigma^2$ 表示总体方差，是一个未知常数</li>
<li>$i=1,2$</li>
<li>$j=1,2\cdots,m$ </li>
</ul>
<p>我们的假设检验问题是：</p>
<script type="math/tex; mode=display">
H_0:\mu_1 = \mu_2 ~~vs~~ H_1:\mu_1\neq\mu_2</script><p>随后我们构造检验统计量t。检验统计量可以用枢轴量法导出来：</p>
<p><strong>第一步</strong>： 求 $\theta$ 的点估计 $\hat\theta=\overline x-\overline y = \mu_1-\mu_2$</p>
<p><strong>第二步：</strong>  $\overline x\sim N(\mu_1,\frac{\sigma^2}{m}),\overline y \sim N(\mu_2,\frac{\sigma^2}{n})$​ </p>
<script type="math/tex; mode=display">
\hat\theta = \overline x-\overline y \sim N(\mu_1-\mu_2,(\frac1m+\frac1n)\sigma^2)</script><p><strong>第三步</strong> 标准化</p>
<script type="math/tex; mode=display">
\frac{\overline x-\overline y-\theta}{\sqrt{(\frac1m+\frac1n)\sigma^2}}\sim N(0,1)</script><p>显然这并不是一个枢轴量，因为存在位置变量$\sigma^2$ ,我们需要把 $\sigma^2$​ 换成样本方差。</p>
<p> <strong>第四步：</strong></p>
<p>那么在两样本的时候由于样本量是不同的，样本方差就要用合方差来替换：</p>
<script type="math/tex; mode=display">
\hat\sigma^2 = s_w^2 = (\frac{1}{m_1+m_2-2})^{-1}((m_1-1)s_1^2+(m_2-1)s_2^2))</script><p>可以看做是$s_1^2$和$s_2^2$​​​的加权平均数。检验统计量可以写为：</p>
<script type="math/tex; mode=display">
\frac{\overline x-\overline y-\theta}{s_w\sqrt{(\frac1m+\frac1n)}}</script><p>又因为：</p>
<script type="math/tex; mode=display">
\frac{(m_1-1)s_x^2+(m_2-1)s_y^2}{\sigma^2}\sim\mathcal{X}^2(m_1+m_2-2)</script><p>所以当满足$H_0$ 成立时，</p>
<script type="math/tex; mode=display">
t = \frac{\overline x-\overline y}{s_w\sqrt{(\frac1{m_1}+\frac1{m_2})}}\sim t(m_1+m_2-2)</script><p>当$m_1=m_2=m$​ 时，检验统计量可简化为：检验统计量t服从自由度为$2(m-1)$ </p>
<script type="math/tex; mode=display">
t = \frac{\overline x-\overline y}{\sqrt{\frac{1}{m}(s_1^2+s_2^2)}}\sim t(m_1+m_2-2)</script><h3 id="拒绝域法"><a href="#拒绝域法" class="headerlink" title="拒绝域法"></a>拒绝域法</h3><p>我们令：</p>
<script type="math/tex; mode=display">
W = \{|t|\geq t_{1-\alpha/2}(2(m-1))\}</script><p>$t_\alpha(2(m-1))$   为自由度为$2(m-1)$的t分布的$\alpha$分位数</p>
<p>如果落在拒绝域，那么拒绝原假设，接收备择假设。$\mu_1\neq \mu_2$</p>
<p>如果未落在拒绝域，那么接受原假设，$\mu_1=\mu_2$​</p>
<h3 id="p值法"><a href="#p值法" class="headerlink" title="p值法"></a>p值法</h3><script type="math/tex; mode=display">
p = 2P(t>|t_0|)</script><p>t表示自由度为$2(m-1)$ 的t分布的随机变量，$t_0$​ 是通过样本计算的检验统计量。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="/2021/09/10/%E5%8D%95%E5%9B%A0%E5%AD%90%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90/1.png" style="zoom:33%;"></p>
<p>这里是一张减肥前后的差异变化表。我们令$x<em>{1j}$ 为减肥计划A六周前后的体重差异，$x</em>{2j}$​ 表示减肥计划B六周前后的体重差异，$j=1,\cdots,24$</p>
<p>我们假设在$x_{ij}$独立的情况下：</p>
<script type="math/tex; mode=display">
x_{ij}\sim N(\mu_i,\sigma^2) ,~~i = 1,2,j=1,2,\cdots,24</script><p>那么我们给出假设检验：</p>
<script type="math/tex; mode=display">
H_0 : \mu_1 = \mu_2~~~ vs ~~~H_1:\mu_1\neq \mu_2</script><p>同时计算得到：</p>
<script type="math/tex; mode=display">
\overline x_1 = -3.3 ,s_1^2 = 5.0183 \\~\\
\overline x_2 = -3.1125,s_2^2 = 5.7072\\~\\
s_w^2 = 5.3627</script><p>检验统计量为：</p>
<script type="math/tex; mode=display">
t = \frac{\overline x_1-\overline x_2}{s_w\sqrt{2/m}} = -0.2805</script><p>取显著性水平 $\alpha = 0.05$，则拒绝域为：</p>
<script type="math/tex; mode=display">
\{|t|\geq t_{1-\alpha/2}(2m-2)\} = \{|t|\geq 2.0129\}</script><p>我们发现计算得到的t并为落在拒绝域，因此我们接收原假设，两种减肥计划的效果是一致的</p>
<h2 id="单因子方差分析的模型及假设"><a href="#单因子方差分析的模型及假设" class="headerlink" title="单因子方差分析的模型及假设"></a>单因子方差分析的模型及假设</h2><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><p>那么问题来了，如果现在有三种减肥方式，我们又该怎么处理呢？两两做一次二样本独立t检验吗？显然这样比较耗费时间。因此我们提出了单因子方差分析模型</p>
<p>响应变量：我们关心的随机变量，一般用  y 来表示</p>
<p>因子：引发响应变量y大小变化的因素，一般用大写字母表示，例如：A，有a种不同的取值，通常 $a\geq 2$; 称因子A的一种取值为一个水平或者一个处理。</p>
<p>重复次数：在因子A每个水平下，随机变量的个数，记为m</p>
<p>在减肥方案的比较这个例子中：</p>
<ul>
<li>减肥计划前后的体重差作为响应变量</li>
<li>减肥计划为所关心的因子，$a=2$</li>
<li>每组有24名志愿者，即 $m=24$</li>
<li>样本量： $n = a\cdot m = 48$​</li>
</ul>
<p>现在，我们来定义一下这个模型中要用到的数据结构：</p>
<p><img src="/2021/09/10/%E5%8D%95%E5%9B%A0%E5%AD%90%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90/2.png" style="zoom: 50%;"></p>
<p>其中：</p>
<ul>
<li>$y_{ij}$ 表示在第i个水平下观测到的第j个响应变量</li>
<li>$y_{i\cdot}$  表示在第i个水平下响应变量的总和</li>
<li>$\overline y_{i\cdot}$ 表示在第i个水平下响应变量的均值</li>
<li>$y_{\cdot\cdot}$ 表示所有响应变量的总和</li>
<li>$\overline y_{\cdot\cdot}$ 表示所有响应变量的均值</li>
</ul>
<p>也就是说我们可以列出如下关系：</p>
<script type="math/tex; mode=display">
\begin{align}
&y_{i\cdot} = \sum_{j=1}^m y_{ij}\\
&\overline y_{i\cdot}  = \frac{y_{i\cdot}}{m} ~~i = 1,2\cdots,a\\~\\
&y_{\cdot\cdot}  = \sum^a_{i=1}\sum_{j=1}^m y_{ij} \\
&\overline y_{\cdot\cdot} = \frac{y_{\cdot\cdot}}{n}
\end{align}</script><h3 id="均值模型"><a href="#均值模型" class="headerlink" title="均值模型"></a>均值模型</h3><p>现在我们来定义两种模型：均值模型和效应模型</p>
<p>均值模型如下：</p>
<p>首先给出假设，</p>
<script type="math/tex; mode=display">
H_0 : \mu_1 = \mu_2 = \cdots = \mu_a\\~\\
H_1 : \text{存在 在两种水平i,j下的均值不相等，即}\mu_i\neq\mu_j</script><p>给出模型定义：</p>
<script type="math/tex; mode=display">
y_{ij} = \mu_i+\varepsilon_{ij}, \begin{cases}
   i=1,2\cdots,a   \\ j=1,2\cdots,m \end{cases}</script><p>其中，</p>
<ul>
<li>$\mu_i$ 表示因子的第i个水平下的均值</li>
<li>$\varepsilon<em>{ij}$ 是随机误差，通常认为随机误差的期望为零，即 $E(\varepsilon </em>{ij})=0$​  。因为如果 $E(y_{ij})$ 不为0，那么这个期望我们是看不到的，在估计的时候就会有两个期望，我们没有办法分开 $E(y)$和$E(\varepsilon)$ ，导致识别不了参数。</li>
</ul>
<p>我们可以明显的看出：$E(y_{ij}) = \mu_i,j=1,2\cdots,m$​</p>
<p>这个模型就被称为<strong>均值模型</strong>，因为这个模型只和均值有关系</p>
<h3 id="效应模型"><a href="#效应模型" class="headerlink" title="效应模型"></a>效应模型</h3><p>除了均值模型之外，方差分析里面还有一个模型叫做效应模型。</p>
<p>在因子的第i个水平下的均值可以划分成两部分：</p>
<ul>
<li>其一为总体均值 $\mu = \frac{1}{a}\sum_{i=1}^a \mu_i$​ </li>
<li>其二维第i个水平效应$\alpha_i$，也就是说，各个水平的效应是各个水平的均值与总体均值的偏差。</li>
</ul>
<script type="math/tex; mode=display">
\mu_i = \mu+\alpha_i,~i = 1,2\cdots,a</script><p>也就是有一个和组别没有关系的值加上一个和组别有关系的效应值。</p>
<p>然后可以写出效应模型的形式：</p>
<script type="math/tex; mode=display">
y_{ij} = \mu+\alpha_i+\varepsilon_{ij}, \begin{cases}
   i=1,2\cdots,a   \\ j=1,2\cdots,m \end{cases}</script><p>相对于均值模型，效应模型参数个数有所增加。但是这样会存在一种状况，$\alpha$ 取不同的几组值可能会得到相同的结果。因此为了避免参数无法识别的问题，我们通常需要对参数给出一个合理的约束。最常见的为：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n \alpha_i = 0</script><p>这表明了，因子A的各个水平的效应在零的附近波动，且所有的效应总和为0</p>
<p>此外，还有一种条件是： $\alpha<em>1=0$, 这个方程会导致参数的含义发生了变化。使用$\sum</em>{i=1}^n \alpha_i = 0$​，$\alpha$表示效应；而$\alpha_1 = 0$​​ <code>/**TODO:思考此时参数是什么含义**/.</code> </p>
<p>现在给出效应模型的假设，</p>
<script type="math/tex; mode=display">
H_0 : \alpha_1 = \alpha_2 = \cdots = \alpha_a\\~\\
H_1 : \text{存在第i个水平不为0，即} \alpha_i\neq 0</script><p>在效应模型中：</p>
<script type="math/tex; mode=display">
\mu_i = \mu+\alpha_i,i=1,2\cdots,a</script><p>总之，无论是均值模型还是效应模型，<strong>都仅考虑了一个因子</strong>，所以，称这两个模型为<strong>单因子方差分析模型</strong></p>
<h4 id="误差假定"><a href="#误差假定" class="headerlink" title="误差假定"></a>误差假定</h4><p>现在我们来假定随机误差：独立同分布条件下，随机误差是以均值为0，方差为$\sigma^2$的正态分布的随机变量</p>
<script type="math/tex; mode=display">
\varepsilon \sim N(0,\sigma^2)</script><p>这表明：在不同水平下，响应变量的波动大小是一致的；观测到的数据是相互独立且均服从正态分布，即：</p>
<script type="math/tex; mode=display">
y_{ij}\sim N(\mu+\alpha_i,\sigma^2)</script><p><strong>注意！</strong>： 观测到的数据是相互独立的，但并不是同分布的，因为每组的均值可能是不相等的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>单因子方差的模型为：</p>
<script type="math/tex; mode=display">
y_{ij} = \mu+\alpha_i+\varepsilon_{ij},\varepsilon_{ij}\sim N(0,\sigma^2),\begin{cases}
   i=1,2\cdots,a   \\ j=1,2\cdots,m \end{cases}\\~\\
   \text{s.t. } \sum_{i=1}^a \alpha_i = 0</script><p>现在我们可以用单因子方差分析去写一个二样本t检验的模型，如下：</p>
<script type="math/tex; mode=display">
y_{ij} = \mu+\alpha_i+\varepsilon_{ij},\varepsilon_{ij}\sim N(0,\sigma^2),\begin{cases}
   i=1,2 \\ j=1,2,\cdots,m \end{cases}\\~\\
   \text{s.t. } \sum_{i=1}^2 \alpha_i = 0</script><h2 id="单因子方差分析的检验"><a href="#单因子方差分析的检验" class="headerlink" title="单因子方差分析的检验"></a>单因子方差分析的检验</h2><p>我们再回到二样本t检验，我们在检验两组均值是否相等的本质就是比较两组样本均值差异与数据波动的大小。</p>
<p>所以，相比与数据的波动，两组样本均值的差异要大得多，那么我们才有足够的证据支撑说明这两组数据的均值是不一致的。</p>
<p>用一张图可以很清楚的解释：</p>
<p><img src="/2021/09/10/%E5%8D%95%E5%9B%A0%E5%AD%90%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90/1.jpg" style="zoom: 50%;"></p>
<p>A和B是两组样本，如果取自两个黑圈，那么显然两组样本的均值是不相等的。但是如果取自两个红圈，那么相比于数据的波动，两组样本均值差异不明显，因此可以认为两组均值相等。</p>
<h3 id="偏差平方和"><a href="#偏差平方和" class="headerlink" title="偏差平方和"></a>偏差平方和</h3><p>那么当$a\geq3$时，我们又该怎么分析呢？如下图：</p>
<p><img src="/2021/09/10/%E5%8D%95%E5%9B%A0%E5%AD%90%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90/3.png" style="zoom: 70%;"></p>
<p>观测这张图，我们发现，不同组别的均值是和对应的效应值$\alpha_i$相关的。此外，我们将所有数据看成一个整体，那么这个整体的波动又是和整体的方差有关的。 </p>
<p>为了分清楚这两者，我们需要推导一下偏差平方和的分解公式。</p>
<p>总偏差平方和等于所有点到所有响应变量的均值的偏差平方和</p>
<script type="math/tex; mode=display">
SS_T = \sum_{i=1}^a\sum_{j=1}^m(y_{ij}-\overline y_{..})^2</script><p>$SS_T$​ 可以拆分成两部分，也就是在里面加一项减一项，这是概率论的常见技巧。</p>
<script type="math/tex; mode=display">
\sum_{i=1}^a\sum_{j=1}^m(y_{ij}-\overline y_{..})^2  = \sum_{i=1}^a\sum_{j=1}^m((\overline y_{i\cdot}-\overline y_{\cdot\cdot})+(y_{ij}-\overline y_{i\cdot}))^2\\~\\</script><p>然后，第一部分是和j没有关系的，因此可以写为：</p>
<script type="math/tex; mode=display">
= m\sum_{i=1}^a(\overline y_{i\cdot}-\overline y_{\cdot\cdot})^2+\sum_{i=1}^a\sum_{j=1}^m(y_{ij}-\overline y_{i\cdot})^2+2\sum_{i=1}^a\sum_{j=1}^m(\overline y_{i\cdot}-\overline y_{\cdot\cdot})(y_{ij}-\overline y_{i\cdot})</script><p>再来，我们要敏锐的发现，交叉项是0，这是因为：</p>
<script type="math/tex; mode=display">
2\sum_{i=1}^a\sum_{j=1}^m(\overline y_{i\cdot}-\overline y_{\cdot\cdot})(y_{ij}-\overline y_{i\cdot}) = 2\sum_i(\overline y_{i\cdot}-\overline y_{\cdot\cdot})\sum_{j}^m(y_{ij}-\overline y_{i\cdot})\\~\\

\sum_{j}^m(y_{ij}-\overline y_{i\cdot}) = y_{i\cdot}-m\overline y_{i\cdot} = y_{i\cdot}-y_{i\cdot} = 0</script><p>因此，平方和分解公式的最终结果如下：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^a\sum_{j=1}^m(y_{ij}-\overline y_{..})^2 = m\sum_{i=1}^a(\overline y_{i\cdot}-\overline y_{\cdot\cdot})^2+\sum_{i=1}^a\sum_{j=1}^m(y_{ij}-\overline y_{i\cdot})^2</script><h4 id="SS-A"><a href="#SS-A" class="headerlink" title="$SS_A$"></a>$SS_A$</h4><p>其中，第一项为<strong>组间偏差平方和$SS_A$</strong> ,即</p>
<script type="math/tex; mode=display">
SS_A = m\sum_{i=1}^a(\overline y_{i\cdot}-\overline y_{\cdot\cdot})^2</script><p>$SS_A$ 表示了不同水平下，数据的平均值与所有数据的总平均值之间的偏差平方和，既包含了因子A取不同水平引起的数据差异，又包含了随机误差对其的影响。</p>
<h4 id="SS-E"><a href="#SS-E" class="headerlink" title="$SS_E$"></a>$SS_E$</h4><p>第二项为组内偏差平方和 $SS_E$, 即：</p>
<script type="math/tex; mode=display">
SS_E =\sum_{i=1}^a\sum_{j=1}^m(y_{ij}-\overline y_{i\cdot})^2</script><p>$SS<em>E$ 表示同一水平下数据$y</em>{ij}$与其平均值 $\overline y_{i\cdot}$的差异，是实验误差引起的</p>
<h3 id="检验统计量"><a href="#检验统计量" class="headerlink" title="检验统计量"></a>检验统计量</h3><p>平方和分解公式可以简记为：</p>
<script type="math/tex; mode=display">
SS_T = SS_A+SS_E</script><p>对于给定的一组数据，总偏差平方和$SS<em>T$ 是不变的。如果原假设成立，$SS_A$仅仅收到随机误差方差的影响，取值应该不大。是因为每组的样本均值 $\overline y</em>{i\cdot}$ 是$\mu_i$的一个合理的估计。</p>
<p>因此一个直观的想法是比较$SS_A/SS_T$ 。如果这个比值越大，说明$SS_A$ 不仅仅受到误差的影响，因此我们越有证据支持备择假设；反之，我们认为原假设更合理</p>
<p>但是在单因子反差分析模型中，我们所构造的检验统计量是基于： $SS_A/SS_E$  的。其实将$SS_E$ 带换掉，我们发现$SS_A/SS_E$是随着 $SS_A/SS_T$的增大而增大的。</p>
<h3 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h3><p>在单因子方差分析模型中，有：</p>
<ul>
<li>组内偏差平方和$SS_E$ 的分布为：</li>
</ul>
<script type="math/tex; mode=display">
\frac{SS_E}{\sigma^2} \sim \mathcal{X}^2(n-a)</script><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>根据单因子方差分析模型： $y<em>{ij} = \mu+\alpha_i+\varepsilon</em>{ij}$​​ ，将其带入$SS_E$公式可得</p>
<script type="math/tex; mode=display">
SS_E = \sum_{i=1}^a\sum_{j=1}^m(y_{ij}-\overline y_{i\cdot})^2 \\
=\sum_{i=1}^a\sum_{j=1}^m ((\mu+\alpha_i+\varepsilon_{ij})-\frac{1}{m}\sum_{j=1}^m(\mu+\alpha+\varepsilon_{ij}))^2</script><p>我们将求和符号打散，发现前两项可以保持不变(m消掉)，最后一项变为 $\frac{1}{m}\sum<em>{j=1}^m\varepsilon</em>{ij}$​ ，也就是每组的误差均值</p>
<script type="math/tex; mode=display">
SS_E=\sum_{i=1}^a\sum_{j=1}^m ((\mu+\alpha_i+\varepsilon_{ij})-\mu-\alpha-\frac{1}{m}\sum_{j=1}^m\varepsilon_{ij})^2\\~\\
=\sum_{i=1}^a\sum_{j=1}^m(\varepsilon_{ij}-\overline \varepsilon_{i\cdot})^2</script><p>同时，我们要知道 $\varepsilon_{ij}$是独立同分布的正态随机变量，即：</p>
<script type="math/tex; mode=display">
\varepsilon_{ij} \sim N(0,\sigma^2)</script><p>那么，在因子 A 的第i个水平下，$\varepsilon<em>{i1},\cdots,\varepsilon</em>{im}$ 可以看做来自正态总体 $N(0,\sigma^2)$的一组样本量为m的样本，而$\overline\varepsilon<em>{i\cdot} = m^{-1}\sum</em>{j=1}^m\varepsilon_{ij}$​可以看做是这组样本的样本均值。那么构造卡方就呼之欲出了。</p>
<script type="math/tex; mode=display">
\frac{SS_E}{\sigma^2}=\sum_{i=1}^a[\frac{1}{\sigma^2}\sum_{j=1}^m(\varepsilon_{ij}-\overline \varepsilon_{i\cdot})^2],i=1,2\cdots,a\\~\\
\text{其中:}\frac{1}{\sigma^2}\sum_{j=1}^m(\varepsilon_{ij}-\overline \varepsilon_{i\cdot})^2\sim\mathcal{X}^2(m-1)</script><p>又由于不同水平下的偏差平方和是相互独立的，因此根据卡方分布的可加性，有：</p>
<script type="math/tex; mode=display">
\frac{SS_E}{\sigma^2} \sim \mathcal{X}^2(a(m-1))\\~\\
\text{注意到：~~} a(m-1) = am-a = n-a</script><h3 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h3><p>在单因子方差分析模型中，有：</p>
<ul>
<li>组间偏差平方和的期望为:</li>
</ul>
<script type="math/tex; mode=display">
E(SS_A) = (a-1)\sigma^2+m\sum_{i=1}^a\alpha_i^2</script><p>特别的，在原假设 $H_0$成立时，有：</p>
<script type="math/tex; mode=display">
\frac{SS_A}{\sigma^2} \sim \mathcal{X}^2(a-1)</script><h4 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h4><p>证明策略与定理1类似，也是将$y<em>{ij} = \mu+\alpha_i+\varepsilon</em>{ij}$​ 代入</p>
<script type="math/tex; mode=display">
\begin{align}
SS_A &= m\sum_{i=1}^a(\overline y_{i\cdot}-\overline y_{\cdot\cdot})^2\\
&=m\sum_{i=1}^a (\frac{1}{m}\sum_{j=1}^m(\mu+\alpha_i+\varepsilon_{ij})-\frac{1}{n}\sum_{i=1}^a\sum_{j=1}^m(\mu+\alpha_i+\epsilon_{ij}))^2\\
&= m\sum_{i=1}^a (\alpha_i+\overline \varepsilon_{i\cdot}-\overline\varepsilon_{\cdot\cdot})^2
\end{align}</script><p>到这一步都很顺利。 现在我们看到括号里面有 $\alpha_i$ 和$\varepsilon$ ，这两个参数分别是确定的和随机的，我们要做的就是拆分他们。</p>
<script type="math/tex; mode=display">
=m\sum_{i=1}^a\alpha_i^2+m\sum_{i=1}^a(\overline\varepsilon_{i\cdot}-\overline\varepsilon_{\cdot\cdot})+2m\sum_{i=1}^a\alpha_i(\overline\varepsilon_{i\cdot}-\overline \varepsilon_{\cdot\cdot})</script><p>对于交叉项，这是一个数我们没办法再化成0了，但是我们可以求交叉项的期望。</p>
<p>因为 $\varepsilon_{ij}\sim N(0,\sigma^2)$ 且相互独立，所以：</p>
<script type="math/tex; mode=display">
\overline\varepsilon_{i\cdot} = \frac{1}{m}\sum_{j=1}^m\varepsilon_{ij}\sim N(0,\frac{\sigma^2}{m})\\
\overline \varepsilon_{\cdot\cdot} = \frac{1}{n}\sum_{i=1}^a\sum_{j=1}^m\varepsilon_{ij}\sim N(0,\frac{\sigma^2}{n})</script><p>因此：</p>
<script type="math/tex; mode=display">
E(2m\sum_{i=1}^a\alpha_i(\overline\varepsilon_{i\cdot}-\overline \varepsilon_{\cdot\cdot})) = 2m\sum_{i=1}^a\alpha_iE(\overline\varepsilon_{i\cdot}-\overline \varepsilon_{\cdot\cdot})=0</script><p>但这样一来就需要对整个$SS_A$​求期望。</p>
<script type="math/tex; mode=display">
E(SS_A) = m \sum_{i=1}^a\alpha_i^2+mE(\sum_{i=1}^a(\overline\varepsilon_{i\cdot}-\overline \varepsilon_{\cdot\cdot})^2)</script><p>现在我们又要来凑卡方了</p>
<ul>
<li>首先，$\overline \varepsilon<em>{i\cdot}$ 是第i个水平下随机误差的样本均值，因为不同水平下的随机误差是相互独立的，所以，这些随机误差的样本均值 $\overline\varepsilon</em>{1\cdot},\overline\varepsilon<em>{2\cdot},\cdots,\overline\varepsilon</em>{a\cdot}$是相互独立的。</li>
<li>又因为 </li>
</ul>
<script type="math/tex; mode=display">
\overline\varepsilon_{\cdot\cdot} = \frac{1}{n}\sum_{i=1}^a\sum_{j=1}^m\varepsilon_{ij}=\frac{1}{a}\sum_{i=1}^a\overline\varepsilon_{i\cdot}</script><p>可以看成是 a个$\overline\varepsilon<em>{1\cdot},\overline\varepsilon</em>{2\cdot},\cdots,\overline\varepsilon_{a\cdot}$ 的样本均值，因此卡方分布就呼之欲出了。</p>
<script type="math/tex; mode=display">
m(\sum_{i=1}^a(\overline\varepsilon_{i\cdot}-\overline \varepsilon_{\cdot\cdot})^2)/\sigma^2 \sim\mathcal{X}^2(a-1)\\
\sigma^2 E(m(\sum_{i=1}^a(\overline\varepsilon_{i\cdot}-\overline\varepsilon_{\cdot\cdot})^2)/\sigma^2 ) = \sigma^2(a-1)</script><p>综上，原式可以化简为：</p>
<script type="math/tex; mode=display">
E(SS_A) = m\sum_{i=1}^a\alpha_i^2+(a-1)\sigma^2</script><p>那么，当原假设 $H_0$成立时，因为 $\alpha_1=\alpha_2\cdots=\alpha_a =0$,我们有：</p>
<script type="math/tex; mode=display">
SS_A =m\sum_{i=1}^a(\overline\varepsilon_{i\cdot}-\overline \varepsilon_{\cdot\cdot})^2\\
SS_A/\sigma^2 =m\sum_{i=1}^a(\overline\varepsilon_{i\cdot}-\overline \varepsilon_{\cdot\cdot})^2/\sigma^2\sim\mathcal{X}^2(a-1)</script><h3 id="定理3"><a href="#定理3" class="headerlink" title="定理3"></a>定理3</h3><p>在单因子方差分析模型中，有：</p>
<ul>
<li>组间偏差平方和与组内偏差平方和独立。即</li>
</ul>
<script type="math/tex; mode=display">
SS_A \bot~ SS_E</script><p>这是因为，</p>
<script type="math/tex; mode=display">
SS_A = m\sum_{i=1}^a(\alpha_i+\overline\varepsilon_{i\cdot}-\overline\varepsilon_{i\cdot})^2</script><p>这是关于$\overline\varepsilon<em>{1\cdot},\overline\varepsilon</em>{2\cdot},\cdots,\overline\varepsilon_{a\cdot}$ 的函数。</p>
<p>同时，我们也要知道 $\sum<em>{j=1}^m(\varepsilon</em>{ij}-\overline\varepsilon<em>{i\cdot})^2$ 与 $\overline\varepsilon</em>{i\cdot}$是相互独立的，而且因子不同水平下的随机误差是相互独立的。</p>
<p>所以，$SS_A$ 和 $SS_E$ 独立</p>
<p>由于$SS_E$​和$SS_A$ 都可以化成卡方分布的形式，那么我们就可以这样来确定检验统计量</p>
<script type="math/tex; mode=display">
F_A = \frac{SS_A}{a-1}/\frac{SS_E}{n-a}</script><p>在原假设 $H_0$成立下服从自由度分别为$a-1$和n-a 的F分布，即 $F_A\sim F(a-1,n-a)$</p>
<h4 id="拒绝域法-1"><a href="#拒绝域法-1" class="headerlink" title="拒绝域法"></a>拒绝域法</h4><p>在显著性水平 $\alpha$下，如果：</p>
<script type="math/tex; mode=display">
F_A\geq F_{1-\alpha}(a-1,n-a)</script><p>那么，我们会拒绝原假设。<br><img src="/2021/09/10/%E5%8D%95%E5%9B%A0%E5%AD%90%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90/4.png" style="zoom: 70%;"></p>
<h4 id="p值法-1"><a href="#p值法-1" class="headerlink" title="p值法"></a>p值法</h4><p>计算p值来进行判断，即</p>
<script type="math/tex; mode=display">
p_A = P(F\geq F_A)</script><p>其中，$F_A$是通过样本计算而得的检验统计量，F为一个自由度为$a-1$和$n-a$的卡方分布的随机变量。如果 $p_A\leq \alpha$ 那么，我们会 拒绝原假设，否则我们无法拒绝原假设</p>
<h2 id="单因子方差分析的参数估计"><a href="#单因子方差分析的参数估计" class="headerlink" title="单因子方差分析的参数估计"></a>单因子方差分析的参数估计</h2><h3 id="点估计"><a href="#点估计" class="headerlink" title="点估计"></a>点估计</h3><p>由于</p>
<script type="math/tex; mode=display">
y_{ij}\sim N(\mu+\alpha_i,\sigma^2)~~i=1,2\cdots,a ,j=1,2\cdots,m</script><p>我们可以用极大似然估计来估计参数</p>
<script type="math/tex; mode=display">
(\mu,\alpha_1,\alpha_2,\cdots,\alpha_a,\sigma^2)</script><p>似然估计为：</p>
<script type="math/tex; mode=display">
L(\mu,\alpha_1,\alpha_2\cdots,\alpha_a,\sigma^2) = \prod_{i=1}^a\prod_{j=1}\bigg\{\frac{1}{\sqrt{2\pi\sigma^2}}\exp\big\{-\frac{(y_{ij}-\mu-\alpha_i)^2}{2\sigma^2}\big\}\bigg\}</script><p>其对数似然函数为：</p>
<script type="math/tex; mode=display">
l(\mu,\alpha_1,\alpha_2\cdots,\alpha_a,\sigma^2) = \ln L(\mu,\alpha_1,\alpha_2\cdots,\alpha_a,\sigma^2)\\
=-\frac{n}{2}\ln(2\pi\sigma^2)-\sum_{i=1}^a\sum_{j=1}^m\frac{(y_{ij}-\mu-\alpha_i)^2}{2\sigma^2}</script><p>接下来对各个参数求偏导，得到似然方程为：</p>
<script type="math/tex; mode=display">
\begin{cases} \frac{\partial l}{\partial \mu}=\frac{1}{\sigma^2}\sum_{i=1}^a\sum_{i=1}^m(y_{ij}-\mu-\alpha_i)=0  \\~\\\frac{\partial l}{\partial\alpha_i} =\frac{1}{\sigma^2}\sum_{j=1}^m(y_{ij}-\mu-\alpha_i)=0 ~~i=1,2\cdots,a \\~\\

\frac{\partial l}{\partial\sigma^2} = -\frac{n}{2\sigma^2}+\frac{1}{2\sigma^4}\sum_{i=1}^a\sum_{j=1}^m(y_{ij}-\mu-\alpha_i)^2 = 0
\end{cases}</script><p>其中，第一个方程式多余的，因为第二行中，a个方程组相加以后，就等于第一个方程式。因此我们还需要加上一个条件才能解出来，这个条件就是 $\sum_{i=1}^a\alpha_i=0$</p>
<p>于是，我们可以求出各个参数的极大似然估计为：</p>
<script type="math/tex; mode=display">
\begin{cases} 
\hat\mu=\overline y_{\cdot\cdot}
\\~\\
\hat\alpha_i = \overline y_{i\cdot}-\overline y_{\cdot\cdot},i=1,2\cdots,a
\\~\\
\hat\sigma^2_{MLE} = \frac{1}{n} \sum_{i=1}^a\sum_{j=1}^m(y_{ij}-\overline y_{i\cdot})^2 = \frac{SS_E}{n}
\end{cases}</script><p>由极大似然估计的不变性，各个水平的均值$\mu_i$的极大似然估计为：</p>
<script type="math/tex; mode=display">
\hat\mu_i =\overline y_{i\cdot}</script><p>因为 $E(SS<em>E)=\sigma^2(n-a)$ ，所以 $\hat\sigma^2</em>{MLE}$ 并不是$\sigma^2$的一个无偏估计。</p>
<h4 id="区间估计"><a href="#区间估计" class="headerlink" title="区间估计"></a>区间估计</h4><p><img src="/2021/09/10/%E5%8D%95%E5%9B%A0%E5%AD%90%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90/5.png" style="zoom:120%;"></p>
<p><img src="/2021/09/10/%E5%8D%95%E5%9B%A0%E5%AD%90%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90/6.png" style="zoom:120%;"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/09/08/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F1-2%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/08/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F1-2%E7%AB%A0/" class="post-title-link" itemprop="url">数据管理系统1-2章</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-08 06:27:56" itemprop="dateCreated datePublished" datetime="2021-09-08T06:27:56+08:00">2021-09-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-09-09 13:41:12" itemprop="dateModified" datetime="2021-09-09T13:41:12+08:00">2021-09-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据管理系统1-2章"><a href="#数据管理系统1-2章" class="headerlink" title="数据管理系统1-2章"></a>数据管理系统1-2章</h1><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="什么是系统"><a href="#什么是系统" class="headerlink" title="什么是系统"></a>什么是系统</h3><p>系统要拥有的性能：</p>
<ol>
<li>通用性</li>
<li>隔离性</li>
<li>精巧性</li>
</ol>
<h3 id="什么是数据管理系统"><a href="#什么是数据管理系统" class="headerlink" title="什么是数据管理系统"></a>什么是数据管理系统</h3><p>首先，数据管理系统要有<strong>数据存放</strong>功能，这是最基本的要求。其次，要有<strong>数据组织</strong>的功能，因为一个系统里面有很多结构复杂的数据，该系统要能够在需要时迅速找到这些数据。再来，要有<strong>数据正确</strong>的功能，比如说银行的数据系统，或者是淘宝的数据系统，数据的安全非常重要。最后，要提供一个数据处理的平台，大量的数据并不会拿到云上的服务器去处理，而是在数据管理系统处理完之后再输出</p>
<h3 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h3><ol>
<li>如何使用数据管理系统</li>
<li>构建思想</li>
<li>数据管理系统的实现原理<ul>
<li>RDBMS-PostgreSQL</li>
<li>NoSQL-Mongodb</li>
</ul>
</li>
</ol>
<h3 id="如何模块化"><a href="#如何模块化" class="headerlink" title="如何模块化"></a>如何模块化</h3><p>现在有一个程序，我们要他实现这样一个功能：</p>
<p>输入：一张表，每行为一个单词序列</p>
<p>输出：对每一行实施”位移“，并按照字母顺序输出所有”位移”</p>
<p>比如说：“A good day” -&gt;”good day A”和”day A good”</p>
<p>为了解决这个问题我们可以设计如下套方案：</p>
<p><img src="/2021/09/08/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F1-2%E7%AB%A0/1.png" style="zoom:67%;"></p>
<p>第一套方案是：设计5个模块，一个是总控模块；然后每个模块各自负责输入、位移、排序和输出操作，前一个模块处理完后，后一个模块接着处理，它们都访问的是同一片地址上的数据。</p>
<p>方案1 是一套非常自然的想法，是比较朴素的。</p>
<p>第二套方案是：设计6个模块，一个是总控模块，输入模块将数据存放到存储器中，存储器向上给出一个接口，供位移模块进行操作，位移操作完成后，由向上伸出一个接口，供排序模块操作，最后输出调用排序模块的接口输出数据。</p>
<p>直观来看，第一种更能让人理解，但是第二种更好。方案一中的四个模块有一个共同的接口，就是内存中的数据，那么当出现数据量过大导致存储器结构发生改变的时候，方案1中的四个模块都需要进行代码结构上的修改。而对于方案2，内存中的数据只需要排序模块来负责，其他模块只要调用更为底层的接口即可，因此出了问题可以只对存储器进行修改。</p>
<p>这就牵扯到模块化的一个重要原则：<strong>信息隐藏</strong>, 它可以用来衡量一个系统的模块化是否合理</p>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>请为以下程序做模块设计</p>
<blockquote>
<p>输入：若干文件，每个文件是一篇文章，由若干英文单词组成。<br>例如：file1.txt, file2.txt, file5.txt，….</p>
<p>输出：一个单词文件列表，记录了出现在文件中的每一个单词以及包含这个单词的所有文件的文件名。<br>例如： apple 出现于 file1.txt, file5.txt, ….<br>      fish 出现于 file2.txt, file5.txt, ….<br>      computer 出现于 file1.txt, file8.txt, …<br>      … …</p>
</blockquote>
<p><img src="/2021/09/08/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F1-2%E7%AB%A0/2.jpg" style="zoom:67%;"></p>
<ul>
<li>首先还是输入模块读入数据，放到存储器当中</li>
<li>然后，切词模块会把文章的单词一一提取，成为一个字符串数组。</li>
<li>接着打标签模块调用切词给出的接口，得到了字符串数组并为其打上了属于哪一篇文章的标签</li>
<li>最后交给输出模块输出。</li>
</ul>
<h2 id="文档数据库"><a href="#文档数据库" class="headerlink" title="文档数据库"></a>文档数据库</h2><h3 id="数据库系统的基本理念"><a href="#数据库系统的基本理念" class="headerlink" title="数据库系统的基本理念"></a>数据库系统的基本理念</h3><p>首先，基本所有数据库系统都有CRUD四种操作，分别代表：Create，Read，Update,Delete。</p>
<p>然后，我们要来介绍OOP(Object Oriented Programming) 也就是面向对象的程序设计，通常对于数据库中的一张数据表，我们要对其进行操作，就要设计一个于其相对应的数据模型。里面包含了个字段的名称、类型、限制以及字段之间的关系。</p>
<p>我们在Django教程中，对Mysql创建数据模型有着详细的介绍：<a href="https://jasonxqh.github.io/2021/07/05/Django学习1/#Build-a-Data-Model">Build a Data Model</a></p>
<p>在NodeJs教程中，对Mongodb数据库创建数据模型也有介绍：<a href="https://jasonxqh.github.io/2020/06/08/Express框架在后端的应用/#models目录">models目录</a> 以及 <a href="https://jasonxqh.github.io/2020/06/07/Nodejs基础2/#CRUD-Operations-Using-Mongoose">CRUD Operations Using Mongoose</a></p>
<p>在数据库中，每一张表其实也是一个数据模型。数据模型不同，数据库的使用功能也有不同。比如说关系数据库、文档数据库. 数据库里存档的数据可以看成是一个个对象。</p>
<h3 id="文档模型"><a href="#文档模型" class="headerlink" title="文档模型"></a>文档模型</h3><p>对于文档数据库而言，对象就是一个个文档。数据最终是存放在文档里面的。其结构如下：</p>
<p>database：数据库</p>
<p>Collection：文档集</p>
<p>document：文档</p>
<p>文档的组织结构是什么呢？在Mongodb中我们看到过这种形式：以一件淘宝商品为例：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"_id"</span>:&#123;<span class="attr">"$oid"</span>:<span class="string">"61133c8f94924b702a3b0d85"</span>&#125;,</span><br><span class="line">	<span class="attr">"url"</span>:<span class="string">"https://detail.tmall.com/item.htm?"</span>,</span><br><span class="line">	<span class="attr">"price"</span>:<span class="string">"¥98.00"</span>,</span><br><span class="line">	<span class="attr">"deal"</span>:<span class="string">"月成交 1000+笔 评价 8"</span>,</span><br><span class="line">	<span class="attr">"title"</span>:<span class="string">"纯棉学生宿舍三件套床上用品全棉床单被套四单人床被子套装全套六"</span>,</span><br><span class="line">	<span class="attr">"shop"</span>:<span class="string">"艾格妮斯旗舰店"</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个 key-value 的集合。key代表属性而value则代表取值。</p>
<p>文档里面也可以嵌套文档，这叫做子文档，比如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"name"</span> : Jason,</span><br><span class="line">	<span class="attr">"birthday"</span>: &#123;</span><br><span class="line">		<span class="attr">"year"</span>: <span class="number">2001</span> , <span class="attr">"Mon"</span>: <span class="number">5</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">"gender"</span>: male</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从几何的角度来看，这是一个树状的结构</p>
<h3 id="文档数据库的基本功能"><a href="#文档数据库的基本功能" class="headerlink" title="文档数据库的基本功能"></a>文档数据库的基本功能</h3><p>对于文档数据库，增删改查的指令是怎么实现的呢？</p>
<p>以mongodb为例：</p>
<p>插入操作(Create)：<code>db.myCollection.insertOne({...})</code></p>
<blockquote>
<p>db是数据库的名字</p>
<p>myCollection是文档集的名字</p>
<p>insertOne是方法</p>
</blockquote>
<p>查找操作(Read): <code>db.myCollection.find({...})</code></p>
<blockquote>
<p>find里面是该信息的描述信息。比如说</p>
<p><code>find({&quot;gender&quot;:&quot;male&quot;,&quot;birthday.year&quot;:&quot;2001&quot;})</code> 的查找条件就是：找到文档中包含gender、birthday.year属性的信息，并且要满足gender的值为male，bithday.year的值为2001</p>
</blockquote>
<p>其实在查询语句中的信息也是一个小文档，可以形象为一棵小树。观察小文档和大树的信息，可以发现小树是大树的一部分。因此说大树和小树是匹配的，大树是小数的查询结果。数据库系统所做的就是返回所有和小树匹配的大树。</p>
<p>修改操作(update): <code>db.myCollection.updateOne({&quot;name&quot;:&quot;Jason&quot;},{$set:{&quot;birthday.year&quot;:&quot;2002&quot;}})</code></p>
<blockquote>
<p>这条语句中包含了两个小文档，一个小文档是目标，即要查询的信息；第二个小文档是要修改的内容。<code>$set</code>是修改操作符，格式如下： <code>{ $set: { &lt;field1&gt;: &lt;value1&gt;, ... } }</code></p>
</blockquote>
<p>删除操作(delete)：<code>db.myCollection.deleteOne({&quot;name&quot;:&quot;Jason})</code></p>
<p>关于查找，我们可以使用<code>_id</code> 来查找某一个特定的文档</p>
<h3 id="文档是如何存储的"><a href="#文档是如何存储的" class="headerlink" title="文档是如何存储的"></a>文档是如何存储的</h3><p>现在我们知道了文档是放在数据库里面的，但这只是软件层面的，怎么从硬件层面来了解文档的存储、组织与管理呢？</p>
<p>文档数据是存放在硬盘(SSD/HDD)里面的。但是对于内存可以用来当做缓存，经常被使用的数据会存放在内存里，以便于CPU去使用。</p>
<p>那么文档是怎么放在硬盘里面的？要知道硬盘是一块连续的空间。连续紧挨着肯定不行，因为如果我要更新文档的时候，需要整体移动，导致空间管理很混乱。更合理的方式是将空间划分称一页一页的，页与页之间互相独立，每一页是固定的大小(4MB),我们可以将文档放在页里，当需要修改文档的时候，只需要调整页即可。</p>
<p>当要访问文档时，首先会将页提出并存放到内存里面，当使用完毕之后，会写回到硬盘里面。</p>
<h3 id="文档集的物理知识"><a href="#文档集的物理知识" class="headerlink" title="文档集的物理知识"></a>文档集的物理知识</h3><p>我们上面讲了，文档 是存放在页里面的，那么文档的集合是怎么将这些页组织、打包的呢？</p>
<p>在操作系统中我们学过，在文件系统中我们使用inode，结构如下：</p>
<p><img src="/2021/09/08/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F1-2%E7%AB%A0/3.png" style="zoom:67%;"></p>
<p>同样的，在数据库系统中也可以这样来组织。这里直接指针会直接指向数据存放的页，而间接指针指向的是存放有指针的扩展页。</p>
<p>当我们想要插入文档时，可以找到最后一页，然后再里面插入。</p>
<p>对于读取、更新、删除文档的操作，首先要找到文档在哪。首先要根据文档集合的名字，找到对应的inode，然后将文档集合中的页面存放到内存里面。然后要扫描整个文档集合来找到匹配项。显然，这种方法是不太理想的，因为要扫描整个文档会浪费大量的时间。</p>
<p>因此，还需要有一个索引函数，当我给其一个查询的条件之后，索隐函数会返回满足条件的文档所在的地址(页)，然后我们直接去页里读取、修改。这样的效率就会大大提高。</p>
<p>这种索引函数怎么实现？ 我们需要用到B树这个数据结构</p>
<h3 id="B树索引"><a href="#B树索引" class="headerlink" title="B树索引"></a>B树索引</h3><p>关于B树，我写了一篇博客，详细讲述了查找、插入以及删除的操作：<a href="https://jasonxqh.github.io/2020/06/17/B树/#B树">B树</a></p>
<h3 id="B树索引的特性"><a href="#B树索引的特性" class="headerlink" title="B树索引的特性"></a>B树索引的特性</h3><h3 id="B树索引的插入与删除"><a href="#B树索引的插入与删除" class="headerlink" title="B树索引的插入与删除"></a>B树索引的插入与删除</h3><h2 id="文档数据库设计"><a href="#文档数据库设计" class="headerlink" title="文档数据库设计"></a>文档数据库设计</h2><h3 id="数据库设计的基本概念"><a href="#数据库设计的基本概念" class="headerlink" title="数据库设计的基本概念"></a>数据库设计的基本概念</h3><h3 id="文档数据库设计实例：需求分析"><a href="#文档数据库设计实例：需求分析" class="headerlink" title="文档数据库设计实例：需求分析"></a>文档数据库设计实例：需求分析</h3><h3 id="实例：概念设计"><a href="#实例：概念设计" class="headerlink" title="实例：概念设计"></a>实例：概念设计</h3><h3 id="不同文档结构设计的比较"><a href="#不同文档结构设计的比较" class="headerlink" title="不同文档结构设计的比较"></a>不同文档结构设计的比较</h3><h3 id="实例：结构设计"><a href="#实例：结构设计" class="headerlink" title="实例：结构设计"></a>实例：结构设计</h3><h3 id="文档数据库设计方法"><a href="#文档数据库设计方法" class="headerlink" title="文档数据库设计方法"></a>文档数据库设计方法</h3><h2 id="实验课"><a href="#实验课" class="headerlink" title="实验课"></a>实验课</h2><p><a href="https://jasonxqh.github.io/2020/06/07/Nodejs基础2/#CRUD-Operations-Using-Mongoose">1.2. CRUD Operations Using Mongoose</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jason</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">439</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    

  

</body>
</html>
