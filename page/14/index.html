<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=">


  <link rel="mask-icon" href="/images/logo.svg?v=" color="#222">














<meta property="og:type" content="website">
<meta property="og:title" content="Jason‘s Blog">
<meta property="og:url" content="https://jasonxqh.github.io/page/14/index.html">
<meta property="og:site_name" content="Jason‘s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '',
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    fancybox: false,
    tabs: ,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: 'undefined',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>







  <title>Jason‘s Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', '[object Object]', 'auto');
  ga('send', 'pageview');
</script>





<meta name="generator" content="Hexo 4.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">
  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
<a href="https://github.com/JasonXQH/JasonXQH.github.io" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jason‘s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/%20" rel="section">
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/%20" rel="section">
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/%20" rel="section">
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/" itemprop="url">从题目出发复习数据科学数学基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-04-10T09:54:47+08:00">
                2021-04-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2021-06-30T13:23:26+08:00">
                2021-06-30
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="从题目出发复习数据科学数学基础"><a href="#从题目出发复习数据科学数学基础" class="headerlink" title="从题目出发复习数据科学数学基础"></a>从题目出发复习数据科学数学基础</h1><h1 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h1><h2 id="求卷积"><a href="#求卷积" class="headerlink" title="求卷积"></a>求卷积</h2><h2 id="求TF-IDF"><a href="#求TF-IDF" class="headerlink" title="求TF-IDF"></a>求TF-IDF</h2><h2 id="考虑结构风险的损失函数"><a href="#考虑结构风险的损失函数" class="headerlink" title="考虑结构风险的损失函数"></a>考虑结构风险的损失函数</h2><h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><h2 id="求矩阵的逆"><a href="#求矩阵的逆" class="headerlink" title="求矩阵的逆"></a>求矩阵的逆</h2><h2 id="求解线性方程组"><a href="#求解线性方程组" class="headerlink" title="求解线性方程组"></a>求解线性方程组</h2><h2 id="求-线性组合"><a href="#求-线性组合" class="headerlink" title="求 线性组合"></a>求 线性组合</h2><h2 id="求特征值与特征向量"><a href="#求特征值与特征向量" class="headerlink" title="求特征值与特征向量"></a>求特征值与特征向量</h2><h2 id="求新基坐标"><a href="#求新基坐标" class="headerlink" title="求新基坐标"></a>求新基坐标</h2><h2 id="求二次型的标准型"><a href="#求二次型的标准型" class="headerlink" title="求二次型的标准型"></a>求二次型的标准型</h2><h2 id="判断正定矩阵"><a href="#判断正定矩阵" class="headerlink" title="判断正定矩阵"></a>判断正定矩阵</h2><p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/11.png" style="zoom:80%;"></p>
<h2 id="标准正交化"><a href="#标准正交化" class="headerlink" title="标准正交化"></a>标准正交化</h2><p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/1.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/2.png" style="zoom:80%;"></p>
<p><strong>[a,b]即a与b的内积之意</strong></p>
<h1 id="度量与投影"><a href="#度量与投影" class="headerlink" title="度量与投影"></a>度量与投影</h1><h2 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h2><h3 id="范数的定义"><a href="#范数的定义" class="headerlink" title="范数的定义"></a>范数的定义</h3><p>设 $\mathbb V$ 是数域上 $\mathbb K$  的 n 维线性空间，那么函数 $||\cdot||: \mathbb V\rightarrow \mathbb R<del>,</del>x\rightarrow ||x||$   就是将 $x$ 映射为它的长度 $||x||\in \mathbb R$ ，并且满足非负性、齐次性和三角不等式。 </p>
<p>我们称$||x||$ 是向量 x 的向量函数，称定义了范数的线性空间 $\mathbb V$ 为赋范线性空间。</p>
<h3 id="几种常用的向量范数"><a href="#几种常用的向量范数" class="headerlink" title="几种常用的向量范数"></a>几种常用的向量范数</h3><h4 id="l-p-范数"><a href="#l-p-范数" class="headerlink" title="$l_p$ 范数"></a>$l_p$ 范数</h4><p>对于任意 $x = (x<em>1,x_2,\cdots,x_n)\in \mathbb R^n$ ，由 $||x||_p = (\sum</em>{i=1}^n |x_i|^p)\frac{1}{p}, 1\leq p&lt; \infty$ </p>
<p>定义的 $||\cdot||_p$ 是 $\mathbb R^n$  上的向量范数，称为 $p$ <strong>范数</strong> 或者 $l_p$<strong>范数</strong></p>
<ol>
<li>当 p = 1时，得到 <strong>1范数</strong> 或者 $l<em>1$ <strong>范数</strong> ，也称 <strong>Manhattan 范数</strong>  ： $||x||_1 =\sum</em>{i = 1}^n |x_i|$ </li>
<li>当 p = 2时，得到 <strong>2范数</strong> 或者 $l<em>2$ <strong>范数</strong>， 也称为<strong>欧几里得范数</strong> : $||x||_2 = \sqrt{\sum</em>{i=1}^n x_i^2}$ </li>
</ol>
<h4 id="l-infty-范数"><a href="#l-infty-范数" class="headerlink" title="$l_\infty $ 范数"></a>$l_\infty $ 范数</h4><p>当p取无线大的时候，是否存在这种范数呢？</p>
<p>对 $\forall x=(x<em>1,x_2,\cdots,x_n)\in \mathbb R^2$ ， 由 $||x||</em>\infty = \lim \limits_{p\rightarrow\infty} ||x||_p$ </p>
<p>也就是$||x||<em>\infty = \max</em>{i=1,\cdots,n}|x_i|$ </p>
<p>定义 $||\cdot||<em>\infty$ 是 $\mathbb R^n$ 上的向量范数，称为 $\infty$ 范数 或者 $l</em>\infty$ 范数。</p>
<h4 id="非向量范数"><a href="#非向量范数" class="headerlink" title="非向量范数"></a>非向量范数</h4><p>当 $0&lt;p&lt;1$ 时， 由 $||x||<em>p = (\sum</em>{i=1}^n|x_i|^p)$ 定义的 $||\cdot||_P $ 不是 $\mathbb R$ 上的向量范数</p>
<p>举一个特例就能证明。</p>
<h4 id="基数函数-l-0-范数"><a href="#基数函数-l-0-范数" class="headerlink" title="基数函数 $l_0$ 范数"></a>基数函数 $l_0$ 范数</h4><p>向量 $x$ 的基数函数定义为 $x$ 即 $card(x) = \sum_{i=1}^m \mathcal I(x_i \neq 0)$ </p>
<p>其中， $\mathcal I(x_i\neq 0)= \begin{cases}{1},x_i\neq 0\ 0, {x_i = 0}\end{cases}$</p>
<p>基数函数也被称为$l_0$ 范数，但是它并不满足范数定义的条件</p>
<h3 id="几种常见的矩阵范数"><a href="#几种常见的矩阵范数" class="headerlink" title="几种常见的矩阵范数"></a>几种常见的矩阵范数</h3><h4 id="矩阵1范数-列模"><a href="#矩阵1范数-列模" class="headerlink" title="矩阵1范数(列模)"></a>矩阵1范数(列模)</h4><p>矩阵的每一列上的元素<strong>绝对值</strong>先求和，再从中取个最大的，(列和最大)</p>
<h4 id="矩阵2范数-谱模"><a href="#矩阵2范数-谱模" class="headerlink" title="矩阵2范数(谱模)"></a>矩阵2范数(谱模)</h4><p>$||A||<em>2 = \max\limits</em>{X\neq0} \frac{||AX||<em>2}{||X||_2}=\sqrt{\lambda</em>{max}(A^TA)} =\sqrt{\max\limits_{1\leq i\leq n}|\lambda_i|}$ ,其中 $\lambda_i$为 $A^TA$ 的特征值。</p>
<p>也就是说求矩阵 $A^TA$ 的最大特征值的开方</p>
<h4 id="矩阵的无穷范数-行模"><a href="#矩阵的无穷范数-行模" class="headerlink" title="矩阵的无穷范数(行模)"></a>矩阵的无穷范数(行模)</h4><p>矩阵的每一行上的元素绝对值先求和，再从中取个最大的，（行和最大）</p>
<h3 id="求范数、无穷范数"><a href="#求范数、无穷范数" class="headerlink" title="求范数、无穷范数"></a>求范数、无穷范数</h3><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>求向量 $x=(-1,2,4)^T$ 的 0，1，2 和 $\infty$ 范数</p>
<p>$||x||_0 = 3$ 非0元素的个数</p>
<p>$||x||_1= |-1|+2+4 = 7$</p>
<p>$||x||_2 = \sqrt{|-1|^2+2^2+4^2} = \sqrt{21}$ </p>
<p>$||x||_\infty = max {|-1|,2,4}$ </p>
<h3 id="证明某函数为向量范数"><a href="#证明某函数为向量范数" class="headerlink" title="证明某函数为向量范数"></a>证明某函数为向量范数</h3><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>满足三个性质，即<strong>非负性、齐次性以及三角不等式</strong></p>
<p>注意了，当且仅当$x_i$ 全是0的时候，范数才等于零；如果$x_i$ 不为零式子却是0，那么这就不满足非负性</p>
<h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><h5 id="1"><a href="#1" class="headerlink" title="1"></a>1</h5><p>对任意的 $x = (x_1,x_2,x_3)^T\in \mathbb C^3$ ，试问如下实值函数是否构成向量范数?</p>
<ol>
<li>$|x_1|+|2x_2+x_3|$</li>
<li>$|x_1|+|2x_2|-5|x_3| $ </li>
</ol>
<p>要让函数构成向量范数，必须满足三个性质，即非负性、齐次性以及三角不等式</p>
<p>对于1</p>
<ul>
<li>非负性，易证</li>
<li>齐次性， 令 $c\in \mathbb C, |cx_1|+|2cx_2+cx_3|=|c|(|x_1|+|2x_2+x_3|)$ </li>
<li>三角不等式：$x = (x_1,x_2,x_3)^T,y = (y_1,y_2,y_2)^T \in \mathbb C^3$ , 则 $|x_1+y_1|+|2(x_2+y_2)+(x_3+y_3)|\leq |x_1|+|2x_2+x_3|+|y_1| + |2y_2+y_3|$ 即 x 的范式加上 y 的范式</li>
</ul>
<p>对于2</p>
<p>取 $x=(0,0,1)$ 则 $|0|+|2\times 0|-5|1| = -5 &lt; 0 $ 不满足非负性，所以2不是范范数</p>
<h2 id="证明某函数是内积"><a href="#证明某函数是内积" class="headerlink" title="证明某函数是内积"></a>证明某函数是内积</h2><h3 id="标准内积的定义："><a href="#标准内积的定义：" class="headerlink" title="标准内积的定义："></a>标准内积的定义：</h3><p>n维实向量空间 $\mathbb R^n$ 的<strong>标准内积</strong>(点积)<strong>是两个向量的对应元素乘积之和</strong>。</p>
<p>即： $<x,y> = x^Ty = \sum_{i=1}^n x_iy_i$  通常我们指内积都是这种标准内积</x,y></p>
<p>现在我们引申出内积的定义。设$\mathbb V$是数域上$\mathbb K$ 的 n 维线性空间，函数$&lt;\cdot,\cdot&gt;:\mathbb V\times \mathbb V\rightarrow \mathbb R $它把向量$x,y\in \mathbb V $   映射为一实数 $<x,y>\in \mathbb R$ 并满足以下几个条件 ，其中， $\forall \lambda \in \mathbb R$和向量 $x,y,z\in \mathbb V$ ,满足</x,y></p>
<ol>
<li>非负性 ：$ <x,x> \geq 0$ 当且仅当x=0的时候，$<x,x> =0$ </x,x></x,x></li>
<li>对称性：$<x,y>=<y,x>$</y,x></x,y></li>
<li>齐次性：$&lt;\lambda x,y&gt; = \lambda<x,y>$ </x,y></li>
<li>线性性：$<x+y,z>=<x,z>+<y,z>$ </y,z></x,z></x+y,z></li>
</ol>
<p>称$<x,y>$是向量 $x,y$的内积，称定义了内积的线性空间$mathbb V$ 为<strong>内积空间</strong>。 若内积是点积时，称定义了标准内积的线性空间为<strong>欧式空间</strong>。 </x,y></p>
<h2 id="四个基本子空间的计算"><a href="#四个基本子空间的计算" class="headerlink" title="四个基本子空间的计算"></a>四个基本子空间的计算</h2><h3 id="列空间-Col-A"><a href="#列空间-Col-A" class="headerlink" title="列空间 $Col(A)$"></a>列空间 $Col(A)$</h3><p>行空间是其列向量 ${a_1,a_2\cdots,a_n}$ 的所有<strong>线性组合的集合</strong>，它是 $\mathbb R^m$ 的一个子空间，用符号 $Col(A)$ 表示。有：</p>
<p>$Col(A)={y\in \mathbb R^m|y=\sum_{j=1}^n\alpha_ja_j,\alpha_j\in\mathbb R }=span{\alpha_1,\alpha_2,\cdots,\alpha_n }$ </p>
<h4 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h4><p>现有矩阵：$\begin{pmatrix} 1 &amp; -1 &amp; 0 \ 2 &amp; 4 &amp; 1 \ 4 &amp; 2 &amp; 1 \end{pmatrix}$ 求其列空间</p>
<ol>
<li><p><strong>矩阵列变换</strong> ： $\begin{pmatrix} 1 &amp; -1 &amp; 0 \ 2 &amp; 4 &amp; 1 \ 4 &amp; 2 &amp; 1 \end{pmatrix}=\begin{pmatrix} 1 &amp; 0 &amp; 0 \ 2 &amp; 1 &amp; 0 \ 4 &amp; 1 &amp; 0 \end{pmatrix}$ </p>
</li>
<li><p><strong>列公式</strong> : $Col(A)=\alpha_1(1,2,4)^T+\alpha_2(0,1,1)^T+\alpha_3(0,0,0)^T$ </p>
</li>
<li><strong>写成span形式：</strong> $=span{(1,2,4)^T,(0,1,1)^T}$</li>
</ol>
<h3 id="行空间-Row-A-Col-A-T"><a href="#行空间-Row-A-Col-A-T" class="headerlink" title="行空间$ Row(A)=Col(A^T)$"></a>行空间$ Row(A)=Col(A^T)$</h3><ol>
<li><strong>矩阵行变换: </strong> $\begin{pmatrix} 1 &amp; -1 &amp; 0 \ 2 &amp; 4 &amp; 1 \ 4 &amp; 2 &amp; 1 \end{pmatrix}=\begin{pmatrix} 1 &amp; -1 &amp; 0 \ 0 &amp; 6 &amp; 1 \ 0 &amp; 0 &amp; 0 \end{pmatrix}$ </li>
<li><strong>列公式：</strong> $Col(A^T)=\alpha_1(1,-1,0)^T+\alpha_2(0,6,1)^T+\alpha_3(0,0,0)^T$ </li>
<li><strong>写成span形式：</strong> $span{(1,-1,0)^T,(0,6,1)^T}$ </li>
</ol>
<h3 id="零空间-Null-A"><a href="#零空间-Null-A" class="headerlink" title="零空间 $Null(A)$"></a>零空间 $Null(A)$</h3><p>零空间是所有满足齐次线性方程组$Ax = 0$ 的解向量集合，它是$\mathbb R^n$ 的一个子空间，用符号</p>
<p>$Null (A) $表示，即有 $Null(A)={x\in \mathbb R^n|Ax=0}$ </p>
<ol>
<li>求解线性方程组 $Ax=0$ ，$\begin{pmatrix} 1 &amp; -1 &amp; 0 \ 2 &amp; 4 &amp; 1 \ 4 &amp; 2 &amp; 1 \end{pmatrix}x=\begin{pmatrix} 1 &amp; -1 &amp; 0 \ 0 &amp; 6 &amp; 1 \ 0 &amp; 0 &amp; 0 \end{pmatrix}x =0$ </li>
<li>解得$(x_1,x_2,x_3)^T =k (1,1,-6)^T$ </li>
<li><strong>写成span形式：</strong> $=span{(1,1,-6)^T}$ </li>
</ol>
<h3 id="左零空间-Null-A-T"><a href="#左零空间-Null-A-T" class="headerlink" title="左零空间 $Null(A^T)$"></a>左零空间 $Null(A^T)$</h3><p>左零空间是所有满足齐次线性方程组$A^Ty = 0$ 的解向量集合，它是$\mathbb R^m$ 的一个子空间，用符号</p>
<p>$Null (A^T) $表示，即有 $Null(A^T)={y\in \mathbb R^n|A^Ty=0}$ </p>
<ol>
<li>求解线性方程组 $A^Ty =\begin{pmatrix} 1 &amp; 2 &amp; 4 \ -1 &amp; 4 &amp; 2 \ 0 &amp; 1 &amp; 1 \end{pmatrix}y=0$</li>
<li>解得$(x_1,x_2,x_3)^T = k(2,1,-1)^T$ </li>
<li><strong>写成span形式</strong> $span{(2,1,-1)^T}$</li>
</ol>
<h2 id="求正交投影"><a href="#求正交投影" class="headerlink" title="求正交投影"></a>求正交投影</h2><p>设 $\mathbb V$ 是一向量空间，$\mathbb W\subseteq \mathbb V$ 是$\mathbb V$ 的一个子空间。如果线性映射$\pi:\mathbb V\rightarrow \mathbb W$ 满足 $\pi^2 =\pi\circ \pi = \pi$  则称 $\pi$为投影。</p>
<p>设$\pi$对应的矩阵$P<em>{\pi}$ ，显然$P</em>{\pi}$ 满足 $P^2<em>{\pi}=P</em>{\pi}$ ，称$P_\pi$为投影矩阵。</p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/3.png" style="zoom:80%;"></p>
<h3 id="到一维子空间"><a href="#到一维子空间" class="headerlink" title="到一维子空间"></a>到一维子空间</h3><p>设基底矩阵$B = [b]$，也就是这组基中仅有一个向量。</p>
<p>设$\mathbb R^n$ 的子空间$\mathbb W = Col(B)$, 我们想寻找一个点$\pi_\mathbb W(x)\in\mathbb W $最接近x。 </p>
<p>因为$\pi_\mathbb W(x)\in \mathbb W$，又 $W = Col (B) = span{b}$ </p>
<p>所以$\pi_\mathbb W(x)=\lambda b,\lambda\in \mathbb R$ </p>
<p>接下来，我们将逐步确定$\lambda,\pi<em>\mathbb W(x)$和投影矩阵$P</em>\pi$ </p>
<ol>
<li>确定 $\lambda$</li>
</ol>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/4.png" style="zoom:80%;"></p>
<ol>
<li>确定 $\pi_\mathbb W(x)$</li>
</ol>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/5.png" style="zoom:80%;"></p>
<ol>
<li>确定 $P_\pi$ </li>
</ol>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/6.png" style="zoom:80%;"></p>
<ol>
<li>求得投影： </li>
</ol>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/7.png" style="zoom:80%;"></p>
<h3 id="到一般子空间"><a href="#到一般子空间" class="headerlink" title="到一般子空间"></a>到一般子空间</h3><p>设$B = (b<em>1,\cdots, b_n)$ 是子空间$\mathbb U$ 的一个有序基底。任何$\mathbb U$ 上的投影$\pi</em>\mathbb U(x)$ 必须是U 中的一</p>
<p>个元素。故有$\pi<em>\mathbb U(x) = \sum</em>{i=1}^n\lambda_ib_i$</p>
<ol>
<li><strong>确定 $\lambda_1,\cdots,\lambda_n$</strong> </li>
</ol>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/8.png" style="zoom:80%;"></p>
<ol>
<li><strong>确定 $\pi_\mathbb W(x)$</strong></li>
</ol>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/9.png" style="zoom:80%;"></p>
<ol>
<li><strong>投影矩阵</strong>$P_\pi$ </li>
</ol>
<p>$P_\pi = B(B^TB)^{-1}B^T$</p>
<h4 id="例题：-1"><a href="#例题：-1" class="headerlink" title="例题："></a>例题：</h4><p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/10.png" style="zoom:80%;"></p>
<h3 id="到仿射空间"><a href="#到仿射空间" class="headerlink" title="到仿射空间"></a>到仿射空间</h3><p>给定一个仿射空间 $\mathbb L = x<em>0+\mathbb U$ 其中，$b_1,b_2$是$\mathbb U$ 的基向量，为了确定 x在$\mathbb L$ 上的正交投影 $\pi</em>\mathbb L(x)$ </p>
<p>我们将问题转化为我们知道如何解决的问题：投影到向量子空间上。为此，我们从x和$\mathbb L$ 中减去支撑点 $x_0$ ，所以 $\mathbb L-x_0=\mathbb U$恰好是向量子空间 $\mathbb U$ </p>
<p>现在，我们前面讨论过的在子空间上的投影，获得投影$\pi_\mathbb U(x-x_0)$ 。 最后我们通过添加$x_0$将该投影转换回 $\mathbb L$ ，这样我们就可以得到仿射空间 $\mathbb L$上的正交投影：</p>
<p>$\pi<em>\mathbb L(x) = x_0+\pi</em>\mathbb U(x-x_0)$ </p>
<h4 id="例题：-2"><a href="#例题：-2" class="headerlink" title="例题："></a>例题：</h4><p>求向量 $(1,1,1)^T$ 投影到仿射空间，$span{(1,-1,1)^T,(1,1,0)^T}+(1,2,1)^T$ 的正交投影</p>
<p>首先我要求 $\pi<em>\mathbb U(x-x_0)=\pi</em>\mathbb U(0,-1,0)$ </p>
<p>令 $B=\begin{pmatrix} 1 &amp; 1 \ -1 &amp; 1  \ 1 &amp; 0 \end{pmatrix}$ , $B^TB=\begin{pmatrix} 3&amp;0\0&amp;2\end{pmatrix}$ </p>
<p>$B^T(x-x_0)=\begin{pmatrix} 1&amp;-1&amp;1\1&amp;1&amp;0\end{pmatrix}\begin{pmatrix} 0&amp;-1&amp;0\end{pmatrix}^T =(1~~-1)^T$ </p>
<p>解方程组 $B^TB\lambda=B^Tx \Rightarrow \begin{pmatrix} 3&amp;0\0&amp;2\end{pmatrix}\lambda = \begin{pmatrix} 1\-1\end{pmatrix}$  解得 $\lambda=\begin{pmatrix} \frac{1}{3}\-\frac{1}{2}\end{pmatrix}$ </p>
<p>最后我们求 $\pi_\mathbb W(x-x_0)=B\lambda = \begin{pmatrix} -\frac{1}{6}\-\frac{5}{6}\\frac{1}{3}\end{pmatrix}$ </p>
<p>$\pi<em>\mathbb L(x)=x_0+\pi</em>\mathbb W(x-x_0)=\begin{pmatrix} \frac{5}{6}\\frac{7}{6}\\frac{4}{3}\end{pmatrix}$ </p>
<h1 id="线代基础"><a href="#线代基础" class="headerlink" title="线代基础"></a>线代基础</h1><p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/44.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/45.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/46.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/47.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/48.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/49.png" style="zoom:80%;"></p>
<h1 id="矩阵分解"><a href="#矩阵分解" class="headerlink" title="矩阵分解"></a>矩阵分解</h1><h2 id="求张成的子空间"><a href="#求张成的子空间" class="headerlink" title="求张成的子空间"></a>求张成的子空间</h2><p>设 $a<em>1,a_2,\cdots,a_r$ 是$\mathbb V$ 的一组向量，则这组向量所有可能的线性组合 $\sum</em>{k=1}^r\lambda_ka_k$  所成的集合是$\mathbb V$ 的一个子空间，称为由 $a_1,a_2,\cdots,a_r$ 张成的子空间，记作 $L(a_1,a_2,\cdots,a_r)$ 或者 $span(a_1,a_2,\cdots,a_r)$ 。 $(a_1,a_2,\cdots,a_r)$ 叫做$\mathbb V$ 的生成集。</p>
<p>换句话说，<strong>张成子空间</strong>就是由$x_1,x_2,…,x_r(r&gt;0)$中<strong>极大线性无关组作为基向量所构成的空间</strong>。因为其余任何向量都可以被这个无关组所表示，满足空间中向量的无穷性。</p>
<p>比如求 向量$(1,2,0)^T,(0,1,2)^T$  张成的子空间</p>
<p>首先确定两者线性无关，因此二者张成的子空间为 $((1,2,0)^T,(0,1,2)^T)$ </p>
<h2 id="求正交补空间"><a href="#求正交补空间" class="headerlink" title="求正交补空间"></a>求正交补空间</h2><p>设 $\mathbb S$ 和 $\mathbb T$ 是 $\mathbb R^n$ 的两个子空间。如果对于 $\forall v\in \mathbb S,\forall w\in \mathbb T$ 均有 $v^Tw = 0$ 我们说 $\mathbb S$垂直于 $\mathbb T$ 或者说 子空间$\mathbb S$ 和子空间 $\mathbb T$ 是<strong>正交的</strong>。</p>
<p>相对于正交，正交补是两个子空间更强的一种关系</p>
<p><strong>定义正交补： </strong> 设 $\mathbb V \in \mathbb R^n$ 是一个子空间,$\mathbb V$ 在$\mathbb R^n$ 中的正交补定义为集合：${w\in \mathbb R^n|v^Tw=0,\forall v\in\mathbb V}$ </p>
<p>记作$\mathbb V^{\bot}$ </p>
<p>已经知道了一个子空间，怎么求它的正交补呢？我们可以利用这个性质：</p>
<p>$Col(A^T)^\bot = Null(A) , Col(A)^\bot = Null(A^T)$  </p>
<p>因此$A= ((1,2,0)^T,(0,1,2)^T)$  的正交补就可以写作$ Null(A^T) = span{(4,-2,1)^T} $  </p>
<h2 id="LU-分解"><a href="#LU-分解" class="headerlink" title="LU 分解"></a>LU 分解</h2><p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/12.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/13.png" style="zoom:80%;"></p>
<p>判断是否能进行 LU 分解： 若矩阵的一阶顺序主子式为0，那么就不能分解。</p>
<p><strong>LU 分解指将</strong>$n\times n$ <strong>的矩阵A分解成两个三角矩阵的乘积</strong></p>
<p>其中， L 为 $n\times n$ 单位下三角矩阵(对角元素为1)，U 是  $n\times n$ 上三角矩阵。</p>
<p>从秩1分解的角度分析 $A=LU$ , 可以将 A 写成若干个 秩1矩阵和的形式：</p>
<script type="math/tex; mode=display">
A = l_1u_1+\cdots+l_ru_r = \sum_{i=1}^r l_iu_i</script><p>其中r为矩阵A的秩，若A是满秩，则 $r=n$ 。 $l_i$ 是 $L$ 的第$i$列；$u_i$ 是 $U$ 的第$i$行。 $l_iu_i$ 都是秩为1的矩阵，并且这个矩阵的前 $i-1$行和前$i-1$列的元素都是0</p>
<p>求矩阵A</p>
<script type="math/tex; mode=display">
A=\begin{pmatrix} 1 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 10 \end{pmatrix}</script><p>的LU分解</p>
<p>我们要像<strong>剥洋葱</strong>一样一层一层地分解矩阵A，同时要记得 L 的对角线都是1</p>
<ul>
<li>第一步</li>
</ul>
<p>令 $u<em>1$ 是 A 的第1行，$l_1$ 是A的第1列 除以 $u</em>{11}$ ,则：</p>
<script type="math/tex; mode=display">
l_1u_1 =\begin{pmatrix} 1 \\ 4 \\ 7  \end{pmatrix}\begin{pmatrix} 1 & 2 & 3\end{pmatrix} = \begin{pmatrix} 1 & 2 & 3 \\ 4 & 8 & 12 \\ 7 & 14 & 21 \end{pmatrix}\\~~\\
A-l_1u_1 = \begin{pmatrix} 1 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 10 \end{pmatrix}-\begin{pmatrix} 1 & 2 & 3 \\ 4 & 8 & 12 \\ 7 & 14 & 21 \end{pmatrix} = \begin{pmatrix} 0 & 0 & 0 \\ 0 & -3 & -6 \\ 0 & -6 & -11 \end{pmatrix}</script><ul>
<li>第二步</li>
</ul>
<p>令 $u<em>2$ 是 $A-l_1 u_1$ 的第2行，$l_2$ 是 $A-l_1u_1$ 的第二列除以$u</em>{22}$ </p>
<script type="math/tex; mode=display">
l_2u_2 =\begin{pmatrix} 0 \\ 1 \\ 2  \end{pmatrix}\begin{pmatrix} 0 & -3 & -6\end{pmatrix} = \begin{pmatrix} 0 & 0 & 0 \\ 0 & -3 & -6 \\ 0 & -6 & -12 \end{pmatrix}\\~~\\
A-l_1u_1-l_2u_2 = \begin{pmatrix} 0 & 0 & 0 \\ 0 & -3 & -6 \\ 0 & -6 & -11 \end{pmatrix}-\begin{pmatrix} 0 & 0 & 0 \\ 0 & -3 & -6 \\ 0 & -6 & -12 \end{pmatrix} = \begin{pmatrix} 0 & 0 & 0 \\ 0 & 0 & 0 \\ 0 & 0 & 1 \end{pmatrix}</script><ul>
<li>第三步</li>
</ul>
<p>令$u<em>3$ 是$A-l_1u_1-l_2u_2$  的第3行，$l_3$ 是 $A-l_1u_1-l_2u_2$ 的第3列除以$u</em>{33}$ 即</p>
<script type="math/tex; mode=display">
l_3 =\begin{pmatrix} 0 \\ 0 \\ 1  \end{pmatrix}, u_3 = \begin{pmatrix} 0 & 0 & 1 \end{pmatrix}</script><ul>
<li>第四步，我们要把$l_1,l_2,l_3$ 相加得到$L$ ,$u_1,u_2,u_3$ 相加得到$U$ </li>
</ul>
<script type="math/tex; mode=display">
A = LU = \begin{pmatrix} 1 & 0 & 0 \\ 4 & 1 & 0 \\ 7 & 2 & 1 \end{pmatrix}\begin{pmatrix} 1 & 2 & 3 \\ 0 & -3 & -6 \\ 0 & 0 & 1 \end{pmatrix}</script><h2 id="Cholesky-分解"><a href="#Cholesky-分解" class="headerlink" title="Cholesky 分解"></a>Cholesky 分解</h2><p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/14.png" style="zoom:80%;"></p>
<h2 id="QR分解"><a href="#QR分解" class="headerlink" title="QR分解"></a>QR分解</h2><p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/15.png" style="zoom:80%;"></p>
<h2 id="奇异值分解"><a href="#奇异值分解" class="headerlink" title="奇异值分解"></a>奇异值分解</h2><p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/16.png" style="zoom:80%;"></p>
<h2 id="谱分解"><a href="#谱分解" class="headerlink" title="谱分解"></a>谱分解</h2><p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/17.png" style="zoom:80%;"></p>
<h1 id="方程求解问题，最小二乘"><a href="#方程求解问题，最小二乘" class="headerlink" title="方程求解问题，最小二乘"></a>方程求解问题，最小二乘</h1><p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/18.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/19.png" style="zoom:80%;"></p>
<p>求解 $AA^T x = A^Tb \Rightarrow$ 方程组求解</p>
<p>QR 解法：</p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/50.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/51.png" style="zoom:80%;"></p>
<p>要求QR，为了凑分，我们只能先求正则化情况下的x，得到答案后，计算 R矩阵，令 $Rx =b^<em>$ 然后装模做样的求出 $b^</em>$, 其实只是我们反推得到的。</p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/21.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/22.png" style="zoom:80%;"></p>
<h1 id="矩阵微分"><a href="#矩阵微分" class="headerlink" title="矩阵微分"></a>矩阵微分</h1><p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/23.png" style="zoom:80%;"></p>
<p>求梯度：</p>
<p>首先，这让我们化简一下向量2-范数。$l_2 = \sqrt{\sum |x_i|^2}$ 那么对于这个矩阵，可以用 $\sqrt{(Ax+b-y)^T(Ax+b-y)}$ 来算</p>
<p>所以：</p>
<script type="math/tex; mode=display">
f(A) = \frac{1}{2}(Ax+b-y)^T(Ax+b-y)</script><p>由 $df = dTr(f) = Tr(df)$ 可得：</p>
<script type="math/tex; mode=display">
df = dTr(\frac{1}{2}(Ax+b-y)^T(Ax+b-y))\\~\\
df = Tr(d(\frac12(Ax+b-y)^T(Ax+b-y)))</script><p>我们知道这样一个公式： $df = Tr(A^Tdx)\Rightarrow \frac{\partial f}{\partial x}=(A^T)^T=A$</p>
<p>因此，我们如果要求 $\frac{\partial f}{\partial A}$, 也可以用这种方法</p>
<script type="math/tex; mode=display">
df = Tr(\frac{1}{2}d(Ax)^T(Ax+b-y)+\frac12(Ax+b-y)^Td(Ax))\\~\\
As ~~~Tr(A+B)=Tr(A)+Tr(B)\\~\\
df = Tr(\frac{1}{2}d(Ax)^T(Ax+b-y))~~+~~Tr(\frac12(Ax+b-y)^Td(Ax))\\~\\</script><p>因为我们知道$d(cA) = cd(A)$</p>
<p>所以前面这部分可以写成是：</p>
<script type="math/tex; mode=display">
df = Tr(\frac{1}{2}x^Td(A)^T(Ax+b-y))~~+~~Tr(\frac12(Ax+b-y)^Txd(A))\\~\\</script><p>又知道：$\frac{\partial}{\partial x^T}f = (\frac{\partial }{\partial x}f)^T$ ,所以这里 $x^T(Ax+b-y)$ 为f,</p>
<script type="math/tex; mode=display">
df = Tr(\frac{1}{2}(x^T(Ax+b-y)d(A))^T)~~+~~Tr(\frac12(Ax+b-y)^Txd(A))\\~\\
df = Tr(\frac{1}{2}(Ax+b-y)^Txd(A))~~+~~Tr(\frac12(Ax+b-y)^Txd(A))\\~\\
df = Tr(x(Ax+b-y)^TdA)</script><p>最后，我们求得：$df = (x(Ax+b-y)^T)^T=(Ax+b-y)x^T$</p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/24.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/25.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/26.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/27.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/28.png" style="zoom:80%;"></p>
<p>这里我们要说一些书本上的结论。</p>
<ol>
<li><script type="math/tex; mode=display">
\frac{\partial|A|}{\partial A}=(A^*)^T</script></li>
</ol>
<p>如果矩阵可逆，说明非奇异矩阵，那么：$\frac{\partial |A|}{\partial A}=|A|(A^{-1})^T$ </p>
<ol>
<li><script type="math/tex; mode=display">
d|A| = Tr(A^*dA)\\~\\
d|A| = Tr(|A|A^{-1}dA)</script></li>
</ol>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/29.png" style="zoom:80%;"></p>
<h1 id="优化基础1"><a href="#优化基础1" class="headerlink" title="优化基础1"></a>优化基础1</h1><p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/30.png" style="zoom:80%;"></p>
<p>Keyouxing</p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/31.png" style="zoom:80%;"></p>
<p>这是对可微函数的优化。首先就是要求出 $x^<em>$ 的梯度$\nabla f_0(x)^T$，同 时要检验 $\nabla f_0(x)^T(y-x)\geq 0$  成立则说明 x</em> 即最优点。</p>
<p>对于上面这题，首先要求 $\frac{\partial f}{\partial x}$ 然后把 pqx*都带入得到 $\nabla f_0(x)^T$ </p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/32.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/33.png" style="zoom:80%;"></p>
<p>目标是求 $\max{xy-f(x)}$ 然后 $xy-f(x)$ 的导数，并反解出x=g(y),再将其带入 $xy-f(x)$ 即可。</p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/34.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/35.png" style="zoom:80%;"></p>
<h1 id="优化II-对偶"><a href="#优化II-对偶" class="headerlink" title="优化II(对偶)"></a>优化II(对偶)</h1><p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/36.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/37.png" style="zoom:80%;"></p>
<p>a. 要证明目标函数(minimize), 和 不等式约束函数都是凸函数。</p>
<p>b. <img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/52.png" style="zoom:80%;"></p>
<p>对偶函数就是要求拉格朗日图形的下界。</p>
<p>c.slater条件，这里 定义域内部的点要满足 $g(x)$ 也就是 $\frac{x^2}y &lt;0 $ 成立</p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/53.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/38.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/39.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/40.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/41.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/42.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/43.png" style="zoom:80%;"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A6/" itemprop="url">计算机网络报告6</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-04-08T23:06:01+08:00">
                2021-04-08
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-08-25T04:31:26+08:00">
                2022-08-25
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Exp6-DNS报文分析和基于UDP的Socket编程"><a href="#Exp6-DNS报文分析和基于UDP的Socket编程" class="headerlink" title="Exp6: DNS报文分析和基于UDP的Socket编程"></a>Exp6: DNS报文分析和基于UDP的Socket编程</h1><p>[TOC]</p>
<p>题解请直接跳转task1,task2,task3 </p>
<h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><ul>
<li>学习DNS协议 </li>
<li>学习使用Datagram Socket</li>
</ul>
<h2 id="二、实验任务"><a href="#二、实验任务" class="headerlink" title="二、实验任务"></a>二、实验任务</h2><ul>
<li>使用Wireshark分析DNS协议 </li>
<li>使用DatagramSocket和DatagramPacket编写代码</li>
</ul>
<h2 id="三、实验过程"><a href="#三、实验过程" class="headerlink" title="三、实验过程"></a>三、实验过程</h2><h3 id="3-1-Wireshark补充"><a href="#3-1-Wireshark补充" class="headerlink" title="3.1 Wireshark补充"></a>3.1 Wireshark补充</h3><ul>
<li>着色规则</li>
</ul>
<p>数据包列表区中不同的协议使用了不同的颜色区分。协议颜色标识定位在菜单栏View —&gt; Coloring Rules。如下所示:</p>
<p><img src="/2021/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A6/1.png" style="zoom:67%;"></p>
<ul>
<li><p>Packet Details Pane(<strong>数据包详细信息</strong>)</p>
<p>在数据包列表中选择指定数据包，在数据包详细信息中会显示数据包的所有详细信息内容。数据包详细信息面板是最重要的，用来查看协议中的每一个字段。各行信息分别为:</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1）Frame: 物理层的数据帧概况</span><br><span class="line">2）Ethernet II: 数据链路层以太⽹帧头部信息</span><br><span class="line">3）Internet Protocol Version 4: 互联⽹层IP包头部信息</span><br><span class="line">4）Transmission Control Protocol: 传输层的数据段头部信息，此处是TCP</span><br><span class="line">5）Hypertext Transfer Protocol: 应⽤层的信息，此处是HTTP协议</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A6/2.png" style="zoom:67%;"></p>
<h4 id="3-1-1-Wireshake过滤器"><a href="#3-1-1-Wireshake过滤器" class="headerlink" title="3.1.1 Wireshake过滤器"></a>3.1.1 Wireshake过滤器</h4><ol>
<li>捕获过滤器<br>捕获过滤器 是指wireshark⼀开始在抓包时，就确定要抓取哪些类型的包；对于不需要的，不进⾏<br>抓取。</li>
</ol>
<p><img src="/2021/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A6/3.png" style="zoom:67%;"></p>
<ol>
<li>显示过滤器<br>显示过滤器 是指wireshark对所有的包都进⾏抓取，当⽤户分析数据包的信息，便于筛选出需要的<br>数据包</li>
</ol>
<p><img src="/2021/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A6/4.png" style="zoom:67%;"></p>
<p><strong>捕获过滤器</strong> 是在⽤户开始任务之前就要使⽤的规则；⽽显示过滤器 是任务开始之后（⽆论是否已<br>完成）要使⽤的规则。</p>
<h4 id="3-1-2-显示过滤器语法和实例"><a href="#3-1-2-显示过滤器语法和实例" class="headerlink" title="3.1.2 显示过滤器语法和实例"></a>3.1.2 显示过滤器语法和实例</h4><p>这⾥我们将主要介绍显示过滤器的常⽤语法和实例，捕获过滤器类似（可百度进⾏了解）。</p>
<ol>
<li>⽐较操作符</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;(eq)　　&#x2F;&#x2F;等于，equal</span><br><span class="line">!&#x3D;(ne)　　&#x2F;&#x2F;不等于，no equal</span><br><span class="line">&lt;(lt)　　 &#x2F;&#x2F;⼩于，less than</span><br><span class="line">&gt;(gt)　　 &#x2F;&#x2F;⼤于，great than</span><br><span class="line">&gt;&#x3D;(ge)　　&#x2F;&#x2F;⼤于等于，great equal</span><br><span class="line">&lt;&#x3D;(le)　　&#x2F;&#x2F;⼩于等于，less equal</span><br><span class="line">&amp;&amp;　　&#x2F;&#x2F;逻辑“与”运算</span><br><span class="line">||　　&#x2F;&#x2F;逻辑“或”运算</span><br><span class="line">!　　 &#x2F;&#x2F;逻辑“⾮”运算</span><br></pre></td></tr></table></figure>
<ol>
<li>协议过滤</li>
</ol>
<p>⽐较简单，直接在过滤框中直接输⼊协议名即可。 注意：协议名称需要输⼊⼩写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tcp、ip、dhcp、oicq、ftp、ssl等等</span><br><span class="line">icmp &#x2F;&#x2F;只查看HTTP协议的数据包列表</span><br><span class="line">udp || icmp || dns　&#x2F;&#x2F;只显示udp、icmp、dns相关协议的数据包</span><br><span class="line">not arp 等于 !arp　　&#x2F;&#x2F;不显示arp协议的数据包</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A6/5.png" style="zoom:67%;"></p>
<ol>
<li>过滤IP地址</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ip.addr&#x3D;&#x3D;192.168.1.104　　&#x2F;&#x2F;只显示源&#x2F;⽬的IP为192.168.1.3的数据包</span><br><span class="line">ip.src&#x3D;&#x3D;1.1.1.1 &#x2F;&#x2F;只显示源IP为1.1.1.1的数据包</span><br><span class="line">not ip.src&#x3D;&#x3D;1.1.1.1　　 &#x2F;&#x2F;不显示源IP为1.1.1.1的数据包</span><br><span class="line">ip.src&#x3D;&#x3D;1.1.1.1 or ip.dst&#x3D;&#x3D;1.1.1.2　　&#x2F;&#x2F;只显示源IP为1.1.1.1或⽬的IP为1.1.1.2的数据包</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A6/6.png" style="zoom:67%;"></p>
<ol>
<li>过滤端⼝</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tcp.port eq 80　　 &#x2F;&#x2F;只显示源&#x2F;⽬的端⼝为80的数据包</span><br><span class="line">tcp.dstport&#x3D;&#x3D;80　　&#x2F;&#x2F;只显示⽬的端⼝为80的数据包</span><br><span class="line">tcp.srcport&#x3D;&#x3D;80 &#x2F;&#x2F;只显示源端⼝为80的数据包</span><br><span class="line">tcp.port &gt;&#x3D;1 and tcp.port&lt;&#x3D;80　　&#x2F;&#x2F;只显示源&#x2F;⽬的端⼝⼤于等于1，⼩于等于80的数据包</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A6/7.png" style="zoom:67%;"></p>
<ol>
<li>过滤协议参数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcp.flags.syn &#x3D;&#x3D; 0x02　　&#x2F;&#x2F;显示包含syn标志位的数据包</span><br><span class="line">http.request.method&#x3D;&#x3D;&quot;get&quot;　　&#x2F;&#x2F;显示http请求中method值为get的包</span><br></pre></td></tr></table></figure>
<p>tips：如图所示，在显示过滤器中输⼊规则时，会出现提示信息，可据此了解更多的协议过滤规则</p>
<p><img src="/2021/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A6/8.png" style="zoom:67%;"></p>
<ol>
<li>逻辑运算符为 and/or/not</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">过滤多个条件组合时，使⽤and&#x2F;or。</span><br><span class="line">⽐如获取IP地址为192.168.1.104的ICMP数据包表达式为ip.addr &#x3D;&#x3D; 192.168.1.104 and icmp</span><br></pre></td></tr></table></figure>
<h3 id="3-2-DNS协议"><a href="#3-2-DNS协议" class="headerlink" title="3.2 DNS协议"></a>3.2 DNS协议</h3><h4 id="3-2-1-DNS协议简介"><a href="#3-2-1-DNS协议简介" class="headerlink" title="3.2.1 DNS协议简介"></a>3.2.1 DNS协议简介</h4><p>识别主机有两种⽅式：主机名、IP地址。前者便于记忆(如www.baidu.com)，但路由器很难处理(主机名⻓度不定)；后者定⻓、有层次结构，便于路由器处理，但难以记忆。折中的办法就是建⽴IP地址与主机名间的映射，这就是域名系统DNS做的⼯作。DNS通常由其他应⽤层协议使⽤(如HTTP、SMTP、FTP)，将主机名解析为IP地址。<br>在本实验中，我们将仔细查看 DNS 报⽂的细节。</p>
<h4 id="3-2-2-DNS报⽂"><a href="#3-2-2-DNS报⽂" class="headerlink" title="3.2.2 DNS报⽂"></a>3.2.2 DNS报⽂</h4><ul>
<li>报⽂格式<br>DNS只有两种报⽂：查询报⽂、响应报⽂，两者有着相同格式，如下：</li>
</ul>
<p><img src="/2021/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A6/9.png" style="zoom:67%;"></p>
<ul>
<li>捕获的DNS报⽂</li>
</ul>
<p>考虑访问百度⻚⾯的⼀个操作，在浏览器输⼊<a href="http://www.baidu.com/index.html并回⻋，⾸先需要将URL(存放对象的服务器主机名和对象的路径名)解析成IP地址，具体步骤为：" target="_blank" rel="noopener">http://www.baidu.com/index.html并回⻋，⾸先需要将URL(存放对象的服务器主机名和对象的路径名)解析成IP地址，具体步骤为：</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1）同⼀台⽤户主机上运⾏着DNS应⽤的客户机端(如浏览器)</span><br><span class="line">2）从上述URL抽取主机名[www.baidu.com](http:&#x2F;&#x2F;www.baidu.com&#x2F;)，传给DNS应⽤的客户机端(浏览器)</span><br><span class="line">3）该DNS客户机向DNS服务器发送⼀个包含主机名的请求(DNS查询报⽂)</span><br><span class="line">4）该DNS客户机收到⼀份回答报⽂(DNS响应报⽂)，该报⽂包含该主机名对应的IP地址 182.61.200.7</span><br><span class="line">5）浏览器由该IP地址定位的HTTP服务器发送⼀个TCP链接</span><br></pre></td></tr></table></figure>
<p>⽤Wireshark捕获的DNS报⽂如下图，第⼀⾏是DNS查询报⽂，第⼆⾏是DNS响应报⽂。</p>
<p><img src="/2021/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A6/10.png" style="zoom:67%;"></p>
<h4 id="域名解析过程："><a href="#域名解析过程：" class="headerlink" title="域名解析过程："></a>域名解析过程：</h4><p>表示授权应答 域名解析总体可分为两大步骤：</p>
<p>第一个步骤是本机向本地域名服务器发出一个DNS请求报文，报文里携带需要查询的域名；第二个步骤是本地域名服务器向本机回应一个DNS响应报文，里面包含域名对应的IP地址或者别名等。</p>
<p>注意：第一个步骤从主机到本地域名服务器是<strong>递归查询</strong>；第二大步骤中采用的是<strong>迭代查询</strong>，其实是包含了很多小步骤的</p>
<p><strong>递归查询：</strong>本机向本地域名服务器发出一次查询请求，<strong>就静待最终的结果</strong>。如果本地域名服务器无法解析，自己会以DNS客户机的身份向其它域名服务器查询，直到得到最终的IP地址告诉本机</p>
<p><strong>迭代查询：</strong>本地域名服务器向根域名服务器查询，根域名服务器告诉它下一步到哪里去查询，然后它再去查，<strong>每次它都是以客户机的身份去各个服务器查询 </strong></p>
<h4 id="task1"><a href="#task1" class="headerlink" title="task1:"></a>task1:</h4><p><strong>内容： 根据Wireshark抓取的报⽂信息（例，下图所示示例），分别分析DNS查询报⽂和响应报⽂的组成结构，参考上⾯的报⽂格式指出报⽂的每个部分（如，头部区域等），请将实验结果附在实验报告中。</strong></p>
<p><img src="/2021/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A6/11.png" style="zoom:67%;"></p>
<h5 id="DNS-查询报文格式："><a href="#DNS-查询报文格式：" class="headerlink" title="DNS 查询报文格式："></a>DNS 查询报文格式：</h5><div class="table-container">
<table>
<thead>
<tr>
<th>报文部分</th>
<th>字段名</th>
</tr>
</thead>
<tbody>
<tr>
<td>头部</td>
<td>Transaction ID (事务ID) <br>这是DNS报文的ID标识，对于<strong>请求报文和其对应的应答报文</strong>，该字段的值是<strong>相同的</strong>。通过这个ID课题区分DNS 应答报文是对哪个请求进行相应的。</td>
</tr>
<tr>
<td>头部</td>
<td>Flags (标志) <br>其中，Flags又有很多子字段，在下面详细介绍。</td>
</tr>
<tr>
<td>头部</td>
<td>Questions(问题计数)</td>
</tr>
<tr>
<td>头部</td>
<td>Answer RRs(回答资源记录数)</td>
</tr>
<tr>
<td>头部</td>
<td>Authority RRs(权威名称能服务器计数)</td>
</tr>
<tr>
<td>头部</td>
<td>Additional RRs(附加资源记录数)</td>
</tr>
<tr>
<td>问题部分</td>
<td>Queries (查询问题区域)</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Flags</strong> 这个字段是一串二进制编码，用来标志该请求报文的一些属性和窗台。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Flags: 0x0100 Standard query</span><br><span class="line">    0... .... .... .... &#x3D; Response: Message is a query</span><br><span class="line">    .000 0... .... .... &#x3D; Opcode: Standard query (0)</span><br><span class="line">    .... ..0. .... .... &#x3D; Truncated: Message is not truncated</span><br><span class="line">    .... ...1 .... .... &#x3D; Recursion desired: Do query recursively</span><br><span class="line">    .... .... .0.. .... &#x3D; Z: reserved (0)</span><br><span class="line">    .... .... ...0 .... &#x3D; Non-authenticated data: Unacceptable</span><br></pre></td></tr></table></figure>
<p>这个Flags字段里面一共有6个子字段：</p>
<ul>
<li><strong>Response:  </strong> 查询请求/响应的标志信息。 0代表查询请求，1代表响应请求，这里是0</li>
<li><strong>Opcode:</strong> 操作码。 0代表标准查询；1代表反响查询； 2代表服务器状态请求。</li>
<li><strong>Truncated: </strong> 表示是否被截断。 1代表响应已超过512字节并已经被截断，且只返回前面512个字节</li>
<li><strong>Recursion Desired: </strong> 期望递归。 该字段能在一个查询中设置，并在响应中返回。 该标志告诉名称服务器必须处理这个查询，这种方式被称为一个递归查询。如果该位为 0，且被请求的名称服务器没有一个授权回答，它将返回一个能解答该查询的其他名称服务器列表。这种方式被称为迭代查询。</li>
<li><strong>Z: </strong> 保留字段，在请求和响应报文中，值必须为0</li>
<li><strong>Non-authenticated data: Unacceptable：</strong>未经认证的数据；0 代表服务器已经进行了相关 DNSSEC 数字签名的验证 1 代表为服务器并未进行相关 DNSSEC 数字签名的验证</li>
</ul>
<p>事实上，Flags字段还有其他几个子字段：</p>
<ul>
<li><strong>Authoritative Answer</strong> 表示授权应答。 0代表 应答服务器不是该域名的权威解析服务器，1代表应答服务器是该域名的权威解析服务器。</li>
<li><strong>rcode</strong>返回码字段，表示响应的差错状态。不同的值代表了不同的错误。</li>
</ul>
<p><strong>Queries</strong> 查询问题区域：</p>
<p>该部分是用来显示 DNS 查询请求的问题，通常只有一个问题。该部分包含正在进行的查询信息，包含查询名（被查询主机名字）、查询类型、查询类。</p>
<p>比如说这是一个我查询 CSDN 时候捕捉到的DNS报文中的Queries部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Queries																		&#x2F;&#x2F;问题部分</span><br><span class="line">    www.csdn.net: type AAAA, class IN</span><br><span class="line">        Name: www.csdn.net								&#x2F;&#x2F;被查询的主机名字</span><br><span class="line">        [Name Length: 12]									&#x2F;&#x2F;名字长度</span><br><span class="line">        [Label Count: 3]					</span><br><span class="line">        Type: AAAA (IPv6 Address) (28)		&#x2F;&#x2F;查询类型，这里查询的是 IPv6 的地址</span><br><span class="line">        Class: IN (0x0001)								&#x2F;&#x2F;查询类字段，这里是互联网地址</span><br></pre></td></tr></table></figure>
<p>注意，DNS响应报文中的 Type类型要和查询报文中的Type类型保持一致。</p>
<h5 id="DNS-响应报文格式："><a href="#DNS-响应报文格式：" class="headerlink" title="DNS 响应报文格式："></a>DNS 响应报文格式：</h5><p>DNS响应报文的头部、查询问题区域结构基本和响应报文一致。并且一些查询主机的名字、查询类型等信息也需要保持一致。但是比起查询报文，响应报文多了一个资源记录部分：</p>
<p>资源记录部分是指 DNS 报文格式中的最后三个字段，包括<strong>Answers (回答问题区域)字段</strong>、<strong>Authoritative nameservers(权威名称服务器区域)字段</strong>、<strong>Additional records(附加信息区域)字段</strong>。这三个字段均采用一种称为资源记录的格式。 </p>
<p>这里我分析的是访问百度新闻的 DNS 响应报文。</p>
<p><strong>Answers 字段</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Answers</span><br><span class="line">    log.news.baidu.com: type CNAME, class IN, cname news.n.shifen.com # 资源记录部分</span><br><span class="line">        Name: log.news.baidu.com																			# 域名字段</span><br><span class="line">        Type: CNAME (Canonical NAME for an alias) (5)									# 类型字段，这里是CNAME</span><br><span class="line">        Class: IN (0x0001)				# 类字段</span><br><span class="line">        Time to live: 5483 (1 hour, 31 minutes, 23 seconds)# 生存时间</span><br><span class="line">        Data length: 16	#数据长度</span><br><span class="line">        CNAME: news.n.shifen.com# 资源数据，这里是 CNAME的信息</span><br></pre></td></tr></table></figure>
<p><strong>Authoritative字段</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Authoritative nameservers</span><br><span class="line">    n.shifen.com: type SOA, class IN, mname ns1.n.shifen.com	#资源记录部分</span><br><span class="line">        Name: n.shifen.com	</span><br><span class="line">        Type: SOA (Start Of a zone of Authority) (6)# 类型字段，这里是 SOA类型</span><br><span class="line">        Class: IN (0x0001)	#类字段</span><br><span class="line">        Time to live: 234 (3 minutes, 54 seconds)</span><br><span class="line">        Data length: 45</span><br><span class="line">        Primary name server: ns1.n.shifen.com 	# 该域名对应的权威名称服务器的名称</span><br><span class="line">        Responsible authority&#39;s mailbox: baidu_dns_master.baidu.com</span><br><span class="line">        Serial Number: 2104090020</span><br><span class="line">        Refresh Interval: 5 (5 seconds)</span><br><span class="line">        Retry Interval: 5 (5 seconds)</span><br><span class="line">        Expire limit: 2592000 (30 days)</span><br><span class="line">        Minimum TTL: 3600 (1 hour)</span><br></pre></td></tr></table></figure>
<p>在这里我们要了解一下 类型字段中 CNAME 类型和A类型的区别：</p>
<p>A类型即  Address，也是用来指定主机名（或域名）对应的IP地址记录。用户可以将该域名下的网站服务器指向到自己的web server上。</p>
<p>CNAME类型是 别名记录，也就是说，这种记录允许多个名字映射到另外一个域名。通常用于同时提供WWW和MAIL服务的计算机。例如，有一台计算机名为“host.mydomain.com”（A记录）。它同时提供WWW和MAIL服务，为了便于用户访问服务。可以为该计算机设置两个别名（CNAME）：WWW和MAIL。这两个别名的全称就<code>http://www.mydomain.com/</code>和<code>mail.mydomain.com</code>。实际上他们都指向 <code>host.mydomain.com</code></p>
<p>在 Authoritative 字段中的类型字段，这个报文中现实的是 SOA类型，这代表授权起始点 (SOA) 记录会提供有关域和相应托管区域的信息。此外，还有NS记录类型，会标识托管区域的名称服务器。NS 记录的值为名称服务器的域名。</p>
<h3 id="3-3-基于UDP的Socket编程"><a href="#3-3-基于UDP的Socket编程" class="headerlink" title="3.3 基于UDP的Socket编程"></a>3.3 基于UDP的Socket编程</h3><h4 id="3-3-1-什么是Socket"><a href="#3-3-1-什么是Socket" class="headerlink" title="3.3.1 什么是Socket"></a>3.3.1 什么是Socket</h4><ul>
<li>简单来说是⼀种地址和端⼝的结合描述协议。</li>
<li>TCP/IP协议的相关API的总称、是⽹络API的集合实现，涵盖了TCP和UDP。</li>
<li>UDP是⼀种⽤户报协议，⼜称为⽤户数据报⽂协议，是⼀个简单的⾯向数据报的传输层协议。</li>
<li>在本实验中，我们将重点学习基于UDP的Socket编程。</li>
</ul>
<h4 id="3-3-2-UDP核⼼API"><a href="#3-3-2-UDP核⼼API" class="headerlink" title="3.3.2 UDP核⼼API"></a>3.3.2 UDP核⼼API</h4><ul>
<li>DatagramSocket</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">⽤于接收与发送UDP的类。</span><br><span class="line">负责发送某⼀个UDP包，或者接收UDP包。</span><br><span class="line">DatagramSocket() &#x2F;&#x2F;创建简单实例，不指定端⼝与ip</span><br><span class="line">DatagramSocket(int port) &#x2F;&#x2F;创建监听固定端⼝的实例</span><br><span class="line">DatagramSocket(int port，InetAddress localAddr) &#x2F;&#x2F;创建固定端⼝指定ip的实例</span><br><span class="line">receive(DatagramPacket d) &#x2F;&#x2F;接收</span><br><span class="line">send(DatagramPack d) &#x2F;&#x2F;发送</span><br><span class="line">setSoTimeout(int timeout) &#x2F;&#x2F;设置超时、毫秒</span><br></pre></td></tr></table></figure>
<ul>
<li>DatagramPacket</li>
</ul>
<p>⽤于报⽂处理。<br>将byte数组、⽬标地址、⽬标端⼝等数据包装成报⽂或者将报⽂拆卸成byte数组。<br>是UDP的发送实体，也是接收实体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DatagramPacket(byte[] buf,int offset,int length、InetAddress address,int</span><br><span class="line">port)</span><br><span class="line">DatagramPacket(byte[] buf,int offset,int length、SocketAddress address)</span><br><span class="line">setData(byte[] buf ,int offset,int length)</span><br><span class="line">setData(byte[] buf)</span><br><span class="line">setLength(int length)</span><br><span class="line">getData()、getIffset()、getLength()</span><br><span class="line">setAddress(InetAddress iddrr)、setPort(int port)</span><br><span class="line">getAddress()、getPort()</span><br><span class="line">setSocketAddress(SocketAddress address)</span><br><span class="line">getSocketAddress()</span><br></pre></td></tr></table></figure>
<h4 id="3-3-3-小试牛刀-UDP传输案例"><a href="#3-3-3-小试牛刀-UDP传输案例" class="headerlink" title="3.3.3 小试牛刀: UDP传输案例"></a>3.3.3 小试牛刀: UDP传输案例</h4><p>UDP不分服务器端和客户端，这⾥为了更好地表示，采⽤了发送者和接收者的说法</p>
<h4 id="task2"><a href="#task2" class="headerlink" title="task2:"></a>task2:</h4><p><strong>内容：补充完整UDPSearcher类，并运⾏UDPProvider和UDPSearcher，请将实验结果附在实验报告中</strong></p>
<p>首先， TCP是面向连接的，且为两个端系统之间的数据流动提供可靠的字节流通道。而UDP是无连接的，从一个端系统向另一个端系统发送独立的数据分组，不对交付提供任何保证。</p>
<p>这个小程序的功能就是接收我们的学号并返回学号的长度。我将利用多线程来分别启动 UDPProvider和UDPSearcher。</p>
<ul>
<li>编写UDPProvider类 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPProvider</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Provider Started"</span>);</span><br><span class="line"><span class="comment">// 选择⼀个端⼝⽤于数据接收</span></span><br><span class="line">        DatagramSocket datagramSocket = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//首先在 9091端口开辟一个 Provider</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            datagramSocket = <span class="keyword">new</span> DatagramSocket(<span class="number">9091</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      <span class="comment">//接收送到这个端口来的数据包</span></span><br><span class="line">        DatagramPacket receivePack = <span class="keyword">new</span> DatagramPacket(buf, buf.length);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            datagramSocket.receive(receivePack);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//从数据包中读取发送者的端口号、地址、以及学号的长度</span></span><br><span class="line">        String ip = receivePack.getAddress().getHostAddress();</span><br><span class="line">        <span class="keyword">int</span> port = receivePack.getPort();</span><br><span class="line">        <span class="keyword">int</span> len = receivePack.getLength();</span><br><span class="line">			<span class="comment">// 将 学号从 Bytes[] 转换成 String 类型</span></span><br><span class="line">        String data = <span class="keyword">new</span> String(receivePack.getData(), <span class="number">0</span>, len);</span><br><span class="line">      <span class="comment">//打印</span></span><br><span class="line">        System.out.println(<span class="string">"receive from ip: "</span> + ip + <span class="string">"\tport: "</span> + port +</span><br><span class="line">                <span class="string">"\tdata: "</span> + data);</span><br><span class="line"><span class="comment">//回送数据</span></span><br><span class="line">      <span class="comment">// 编写返回数据的格式</span></span><br><span class="line">        String responseData = <span class="string">"receive data length = "</span> + len;</span><br><span class="line">        <span class="keyword">byte</span>[] responseDataBytes = responseData.getBytes();</span><br><span class="line">      <span class="comment">//编写返回包的信息</span></span><br><span class="line">        DatagramPacket responsePacket = <span class="keyword">new</span> DatagramPacket(</span><br><span class="line">                responseDataBytes,</span><br><span class="line">                responseDataBytes.length,</span><br><span class="line">                receivePack.getAddress(),</span><br><span class="line">                receivePack.getPort()</span><br><span class="line">        );</span><br><span class="line">      <span class="comment">// 会送数据包</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            datagramSocket.send(responsePacket);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Provider finished"</span>);</span><br><span class="line">        datagramSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编写UDPSearcher </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPSearcher</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Searcher Started"</span>);</span><br><span class="line"><span class="comment">// 搜索⽅不需要指定监听端⼝</span></span><br><span class="line">        DatagramSocket datagramSocket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            datagramSocket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line">        String sendData = <span class="string">"10195501423"</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] sendBytes = sendData.getBytes();</span><br><span class="line">        System.out.println(Arrays.toString(sendBytes));</span><br><span class="line"><span class="comment">// todo 请补充完sendPack,发送⾄localhost：9091</span></span><br><span class="line">        DatagramPacket sendPack = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//DatagramPacket包含四个字段，送出的信息(Bytes[]类型)、送出信息的长度，地址和端口</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sendPack = <span class="keyword">new</span> DatagramPacket(sendBytes,sendBytes.length, InetAddress.getLocalHost(),<span class="number">9091</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            datagramSocket.send(sendPack);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收回送数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        DatagramPacket receivePack = <span class="keyword">new</span> DatagramPacket(buf, buf.length);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            datagramSocket.receive(receivePack);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//从接受到的包中提取ip、端口和长度。</span></span><br><span class="line">        String ip = receivePack.getAddress().getHostAddress();</span><br><span class="line">        <span class="keyword">int</span> port = receivePack.getPort();</span><br><span class="line">        <span class="keyword">int</span> len = receivePack.getLength();</span><br><span class="line">        String data = <span class="keyword">new</span> String(receivePack.getData(), <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(<span class="string">"receive from ip: "</span> + ip + <span class="string">"\tport: "</span> + port +</span><br><span class="line">                <span class="string">"\tdata: "</span> + data);</span><br><span class="line">        System.out.println(<span class="string">"Searcher finished"</span>);</span><br><span class="line">        datagramSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">// 创建两个线程实例，分别调用。</span></span><br><span class="line">        Thread provider = <span class="keyword">new</span> Thread(<span class="keyword">new</span> UDPProvider());</span><br><span class="line">        Thread sercher = <span class="keyword">new</span> Thread(<span class="keyword">new</span> UDPSearcher());</span><br><span class="line"></span><br><span class="line">        provider.start();</span><br><span class="line">        sercher.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2021/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A6/12.png" style="zoom:67%;"></p>
<h4 id="task3"><a href="#task3" class="headerlink" title="task3:"></a>task3:</h4><p><strong>内容：改写UDPProvider和UDPSearcher以完成下述功能，请将实验结果附在实验报告中：</strong></p>
<ul>
<li>⼴播地址：255.255.255.255</li>
<li>现需完成如下场景的设计：<ul>
<li>UDPSearcher现将UDP包发送⾄⼴播地址的9091号端⼝（这表示该UDP包将会被⼴播⾄局域⽹下所有主机的对应端⼝）</li>
<li>如果有UDPProvider在监听，解析接受的UDP包，通过解析其中的data得到要回送的端⼝号，并将⾃⼰的⼀些信息写回，UDPSearcher接收到UDPProvider的消息后打印出来。</li>
</ul>
</li>
<li>现提供发送消息的格式：<ul>
<li>UDPSearcher请使⽤如下buildWithPort构建消息，port在实验中指定为30000</li>
<li>UDPProvider请使⽤如下parsePort解析收到的消息并得到要回写的端⼝号，然后⽤buildWithTag构建消息，tag可以是<code>String tag =UUID.randomUUID().toString();</code>，然后回送数据。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG_HEADER = <span class="string">"special tag:"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PORT_HEADER = <span class="string">"special port:"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">buildWithPort</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PORT_HEADER + port;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parsePort</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data.startsWith(PORT_HEADER)) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">                    Integer.parseInt(data.substring(PORT_HEADER.length()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">buildWithTag</span><span class="params">(String tag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> TAG_HEADER + tag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">parseTag</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data.startsWith(TAG_HEADER)) &#123;</span><br><span class="line">            <span class="keyword">return</span> data.substring(TAG_HEADER.length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改过的UDPProvider:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPProvider</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Provider Started"</span>);</span><br><span class="line"><span class="comment">// 选择⼀个端⼝⽤于数据接收</span></span><br><span class="line">        DatagramSocket datagramSocket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            datagramSocket = <span class="keyword">new</span> DatagramSocket(<span class="number">9091</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        DatagramPacket receivePack = <span class="keyword">new</span> DatagramPacket(buf, buf.length);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            datagramSocket.receive(receivePack);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取得 新的 port</span></span><br><span class="line">        <span class="keyword">int</span> len = receivePack.getLength();</span><br><span class="line">        String newPort = <span class="keyword">new</span> String(receivePack.getData(), <span class="number">0</span>, len);</span><br><span class="line">        <span class="keyword">int</span> port = MessageUtil.parsePort(newPort);</span><br><span class="line">        System.out.println(port);</span><br><span class="line">        String tag =UUID.randomUUID().toString();</span><br><span class="line">        String data = MessageUtil.buildWithTag(tag);</span><br><span class="line">        <span class="comment">//取得 新的ip</span></span><br><span class="line">        String newIP = receivePack.getAddress().getHostAddress();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"UDPProvider receive from ip: "</span> + newIP + <span class="string">"\tport: "</span> + port +</span><br><span class="line">                <span class="string">"\tdata: "</span> + <span class="keyword">new</span> String(receivePack.getData(), <span class="number">0</span>, len));</span><br><span class="line"><span class="comment">//回送数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] responseDataBytes = data.getBytes();</span><br><span class="line">        DatagramPacket responsePacket = <span class="keyword">new</span> DatagramPacket(</span><br><span class="line">                responseDataBytes,</span><br><span class="line">                responseDataBytes.length,</span><br><span class="line">                receivePack.getAddress(),</span><br><span class="line">                port</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            datagramSocket.send(responsePacket);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Provider finished"</span>);</span><br><span class="line">        datagramSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改过的UDPSearcher:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPSearcher</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Searcher Started"</span>);</span><br><span class="line"><span class="comment">// 搜索⽅不需要指定监听端⼝</span></span><br><span class="line">        DatagramSocket datagramSocket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            datagramSocket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line">        String sendData = MessageUtil.buildWithPort(<span class="number">30000</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] sendBytes = sendData.getBytes();</span><br><span class="line"></span><br><span class="line"><span class="comment">// todo 请补充完sendPack,发送⾄localhost：9091</span></span><br><span class="line">        DatagramPacket sendPack = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sendPack = <span class="keyword">new</span> DatagramPacket(sendBytes,sendBytes.length,InetAddress.getByName(<span class="string">"255.255.255.255"</span>),<span class="number">9091</span>);</span><br><span class="line">            datagramSocket.send(sendPack);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收回送数据</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            datagramSocket = <span class="keyword">new</span> DatagramSocket(<span class="number">30000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        DatagramPacket receivePack = <span class="keyword">new</span> DatagramPacket(buf, buf.length);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            datagramSocket.receive(receivePack);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        String ip = receivePack.getAddress().getHostAddress();</span><br><span class="line">        <span class="keyword">int</span> port = receivePack.getPort();</span><br><span class="line">        <span class="keyword">int</span> len = receivePack.getLength();</span><br><span class="line">        String data = <span class="keyword">new</span> String(receivePack.getData(), <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(<span class="string">"UDPSearcher receive from ip: "</span> + ip + <span class="string">"\tport: "</span> + port +</span><br><span class="line">                <span class="string">"\tdata: "</span> + data);</span><br><span class="line">        System.out.println(<span class="string">"Searcher finished"</span>);</span><br><span class="line">        datagramSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2021/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A6/13.png" style="zoom:67%;"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/04/07/docker%E5%9F%BA%E7%A1%801/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/07/docker%E5%9F%BA%E7%A1%801/" itemprop="url">docker基础1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-04-07T14:12:52+08:00">
                2021-04-07
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-05-08T15:46:36+08:00">
                2022-05-08
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="docker基础1"><a href="#docker基础1" class="headerlink" title="docker基础1"></a>docker基础1</h1><h2 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h2><p>因为我在博客：<a href="https://jasonxqh.github.io/2020/06/30/Linux基础/">Linux基础</a> 中详细介绍了一些基本命令，因此这里只展示summary的内容。</p>
<p>在docker中运行 ubuntu:</p>
<p><code>docker run ubuntu</code> ，会自动监测是否存在 ubuntu 容器，没有的话会去 docker hub 拉去该容器。</p>
<p>然后我们还要运行 <code>docker run -it ubuntu</code> 才能启动。</p>
<h3 id="Managing-packages"><a href="#Managing-packages" class="headerlink" title="Managing packages"></a>Managing packages</h3><ul>
<li>apt update</li>
<li>apt list</li>
<li>apt install nano</li>
<li>apt remove nano<h3 id="Navigating-the-file-system"><a href="#Navigating-the-file-system" class="headerlink" title="Navigating the file system"></a>Navigating the file system</h3></li>
</ul>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/1.png" style="zoom:100%;"></p>
<h3 id="Manipulating-files-and-directories"><a href="#Manipulating-files-and-directories" class="headerlink" title="Manipulating files and directories"></a>Manipulating files and directories</h3><p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/2.png" style="zoom:100%;"></p>
<h3 id="Editing-and-viewing-files"><a href="#Editing-and-viewing-files" class="headerlink" title="Editing and viewing files"></a>Editing and viewing files</h3><p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/3.png" style="zoom:100%;"></p>
<h3 id="Searching-for-text"><a href="#Searching-for-text" class="headerlink" title="Searching for text"></a>Searching for text</h3><p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/4.png" style="zoom:100%;"></p>
<h3 id="Finding-files-and-directories"><a href="#Finding-files-and-directories" class="headerlink" title="Finding files and directories"></a>Finding files and directories</h3><p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/5.png" style="zoom:100%;"></p>
<h3 id="Managing-environment-variables"><a href="#Managing-environment-variables" class="headerlink" title="Managing environment variables"></a>Managing environment variables</h3><p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/6.png" style="zoom:100%;"></p>
<h3 id="Managing-processes"><a href="#Managing-processes" class="headerlink" title="Managing processes"></a>Managing processes</h3><p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/7.png" style="zoom:100%;"></p>
<h3 id="Managing-users-and-groups"><a href="#Managing-users-and-groups" class="headerlink" title="Managing users and groups"></a>Managing users and groups</h3><p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/8.png" style="zoom:100%;"></p>
<h3 id="File-permissions"><a href="#File-permissions" class="headerlink" title="File permissions"></a>File permissions</h3><p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/9.png" style="zoom:100%;"></p>
<h2 id="Building-Images"><a href="#Building-Images" class="headerlink" title="Building Images"></a>Building Images</h2><p>在这一章，我们要学习</p>
<ul>
<li>创建 Docker文件</li>
<li>对images 进行版本控制</li>
<li>共享 images</li>
<li>保存、加载images</li>
</ul>
<h3 id="Images-and-Containers"><a href="#Images-and-Containers" class="headerlink" title="Images and Containers"></a>Images and Containers</h3><p>学习博客：<a href="https://www.jianshu.com/p/2a0aaf76734a?utm_campaign=hugo" target="_blank" rel="noopener">https://www.jianshu.com/p/2a0aaf76734a?utm_campaign=hugo</a></p>
<p>首先我们要了解 Images 和 Containers的区别。</p>
<h4 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h4><p>镜像（Image）就是一堆<strong>只读层</strong>（read-only layer）的统一视角，下面的这张图能够帮助读者理解镜像的定义。</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/11.png" style="zoom:100%;"></p>
<p>它包含了：</p>
<ul>
<li>A cut-down OS</li>
<li>Third-party libraries</li>
<li>Application files</li>
<li>Environment variables</li>
</ul>
<p>从左边我们看到了多个只读层，它们重叠在一起。除了最下面一层，其它层都会有一个指针指向下一层。这些层是Docker内部的实现细节，并且能够 在主机（运行Docker的机器）的文件系统上访问到。统一文件系统（union file system）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。 我们可以在图片的右边看到这个视角的形式。</p>
<h4 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h4><p>容器（container）的定义和镜像（image）几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。</p>
<p>Container(容器)则像是我们开的虚拟机一样，它提供了：</p>
<ul>
<li>An isolated environment</li>
<li>Can be stopped &amp; restart</li>
<li>Container只是一个进程！但是它是一个特殊的进程，因为他有Image提供的自己的文件系统</li>
</ul>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/12.png" style="zoom:100%;"></p>
<p><strong>要点：容器 = 镜像 + 可读层。并且容器的定义并没有提及是否要运行容器</strong></p>
<p>综上我们可以这样来画出 Container和Images 的示意图：</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/10.png" style="zoom:100%;"></p>
<p>如果我们在两个终端分别运行 ubuntu，会发现他们的ID是不一样的，而且它们所属的文件系统(容器)也是不一样的。因此它们互相独立，不能访问对方的文件</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/13.png" style="zoom:100%;"></p>
<p>可以这样理解：容器是运行着的镜像</p>
<h3 id="Sample-Web-Application"><a href="#Sample-Web-Application" class="headerlink" title="Sample Web Application"></a>Sample Web Application</h3><p>我们拿到一个React项目，要在一台电脑上运行，需要三步</p>
<ul>
<li>Install Node 下载 Node.js</li>
<li>npm install 下载该项目的依赖</li>
<li>npm start 启动该项目</li>
</ul>
<h3 id="Dockerfile-Instructions"><a href="#Dockerfile-Instructions" class="headerlink" title="Dockerfile Instructions"></a>Dockerfile Instructions</h3><p>启动一个Docker项目，首先就是要创建一个 Dockerfile， Dockerfile 包含了创建一个镜像的所有指令。</p>
<p>一个 Dockerfile 主要包含下面几种指令：</p>
<ul>
<li>FROM        说明 base image，从基础镜像开始搭建</li>
<li>WORKDIR    项目工作的文件夹</li>
<li>COPY and ADD      # to copy files/directories</li>
<li>RUN                       # to run commands</li>
<li>ENV                        # to set environment variable</li>
<li>EXPOSE                # to document the port the container is listen</li>
<li>USER                   # to set the user running the app</li>
<li>CMD                   # to set the default command/pro</li>
<li>ENTRYPOINT        # to set the default command/prog</li>
</ul>
<h3 id="Choosing-the-Right-Base-Image"><a href="#Choosing-the-Right-Base-Image" class="headerlink" title="Choosing the Right Base Image"></a>Choosing the Right Base Image</h3><p>在mac在某个文件夹打开终端可以用 alfred 中的  open iterm 命令。然后输入 <code>code .</code>  就可以使用vscode 打开此文件夹，这种工作流是比较快的。</p>
<p>我们在根目录下创建 Dockerfile 文件。</p>
<p>首先我们要确定该项目的 base image，选择一个正确的docker image 十分重要。</p>
<p>关于什么技术栈使用什么base image，我们可以上  <a href="https://docs.docker.com/samples/" target="_blank" rel="noopener">https://docs.docker.com/samples/</a> 上找(我更喜欢dash 配合 alfred直接搜索) </p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/14.png" style="zoom:100%;"></p>
<p>比如说我想写一个关于 ASP.NET Core 的项目，我就可以点进第三个查看 ,里面有示例代码。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> mcr.microsoft.com/dotnet/core/sdk:<span class="number">3.1</span> AS build-<span class="keyword">env</span></span><br><span class="line"><span class="comment"># 注意，这里的代码网址可能一直在更新，因此我们要自己去找去问</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy csproj and restore as distinct layers</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> *.csproj ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> dotnet restore</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy everything else and build</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> dotnet publish -c Release -o out</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Build runtime image</span></span><br><span class="line"><span class="keyword">FROM</span> mcr.microsoft.com/dotnet/core/aspnet:<span class="number">3.1</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=build-env /app/out .</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"dotnet"</span>, <span class="string">"aspnetapp.dll"</span>]</span></span><br></pre></td></tr></table></figure>
<p>在这个ReactJS 项目中，我们自然使用node，但是使用哪个版本的node十分重要，我们<strong>不要这样写</strong>： <code>FROM node:latest</code>  因为这样会导致随时间推移版本号不一致，导致维护项目变得十分困难。</p>
<p>我们在dockerhub 上可以找到很多node image：</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/15.png" style="zoom:100%;"></p>
<p>在中间一列，分别是操作系统和CPU架构。我们要选择当前CPU架构的版本进行下载。但事实上当我要下载这个image的时候，docker会自动帮我选择适合我电脑CPU的镜像版本。</p>
<p>为了能让我们的项目编译的更快，我们这里使用 alpine版本的node，因为只要几十M。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">14.16</span>.<span class="number">0</span>-alpine3.<span class="number">13</span></span><br></pre></td></tr></table></figure>
<p>选择好 base image之后，我么可以编译项目了：</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/16.png" style="zoom:100%;"></p>
<p>接下来，我们使用 <code>docker run -it react-app</code> 运行该项目，发现我们进入了node当中，可以直接运行js代码的那种。但这并不是我们想要的，我们希望的是进入一个shell或者bash，同时又有该node环境。为了实现这个效果我们可以将命令这样写：</p>
<p><code>docker run -it react-app sh</code>代表进入shell，注意了这里不能将sh 替换成bash，因为alpine很小，没有bash。</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/17.png" style="zoom:100%;"></p>
<h3 id="Copying-Files-and-Directories"><a href="#Copying-Files-and-Directories" class="headerlink" title="Copying Files and Directories"></a>Copying Files and Directories</h3><p><code>COPY</code> 和 <code>ADD</code> 的作用基本相同，只不过 <code>ADD</code> 相较于<code>COPY</code>多了一些功能：</p>
<p>当我们执行<code>docker build -t react-app .</code>命令的时候，docker客户端就会把这些内容交给docker engine去构建。docker engine 会一一执行 Dockerfile中的命令。但是Docker Engine 是没有权限访问当前文件下的其他文件的。因此我们要使用 COPY和ADD 指令。</p>
<p>COPY 顾名思义，就是将当前文件夹中的文件复制到我们创建的镜像当中去；ADD 则是将文件添加到镜像当中。</p>
<p>我们可以一一加入文件夹中的文件： <code>COPY package.json /app/</code>  ,其中 <code>/app/</code> 是复制到的目的地,<strong>需要绝对路径</strong>。</p>
<p>注意，如果要添加多个文件，需要注意大小写，且 <code>/app/</code><strong>后面的斜杠一定要加</strong>的</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">14.16</span>.<span class="number">0</span>-alpine3.<span class="number">13</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> package.json README.md /app/</span></span><br></pre></td></tr></table></figure>
<p>当然也可以使用相对路径，这时候我们就要先用<code>WORKDIR</code> 来规定工作区域： 这里我规定 WORKDIR 是<code>/app</code> 那么接下来我使用命令 <code>COPY . .</code> 第一个 <code>.</code> 代表将文件夹下的所有内容都复制。第二个<code>.</code> 是目的地，即代表当前的文件夹<code>/app</code></p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">14.16</span>.<span class="number">0</span>-alpine3.<span class="number">13</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br></pre></td></tr></table></figure>
<p>此外，还可以用列表的形式来写 COPY 命令，但是不常用：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">14.16</span>.<span class="number">0</span>-alpine3.<span class="number">13</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> [<span class="string">"hello world.txt"</span>,<span class="string">"."</span>]</span></span><br></pre></td></tr></table></figure>
<h4 id="ADD-特有功能"><a href="#ADD-特有功能" class="headerlink" title="ADD 特有功能"></a>ADD 特有功能</h4><ol>
<li>ADD 可以加入URL</li>
</ol>
<p>比如说我有一个json文件是放在网络服务器上的，因此我就可以通过 <code>ADD  http://.../file.json .</code>  将这个文件添加到镜像当中。</p>
<ol>
<li>ADD 可以添加压缩文件</li>
</ol>
<p><code>ADD file.zip .</code> 使用这个命令后，docker会自动解压这个压缩文件，并将其中的内容加到镜像文件当中</p>
<h4 id="构建："><a href="#构建：" class="headerlink" title="构建："></a>构建：</h4><p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/18.png" style="zoom:100%;"></p>
<p>我们看到这个镜像一下子从二十多MB跳到一百多MB了，这是因为我们<code>npm install</code> 下载了大量node modules</p>
<h3 id="Excluding-Files-and-Directories"><a href="#Excluding-Files-and-Directories" class="headerlink" title="Excluding Files and Directories"></a>Excluding Files and Directories</h3><p>问题出现了，当我们的项目越做越大的时候，如果按照之前的方法，就要把几百兆的modules传给一个虚拟化的Linux机器，这样性能很低。 而且，这些依赖都已经记录在 <code>package.json</code> 中。因此我们没有必要将 node_moduls 拷贝到镜像当中，而是在linux中自己使用<code>npm install</code>安装</p>
<p>这样做的方法有两个好处：</p>
<ol>
<li>可以大大缩小 build context 的体积</li>
<li>镜像构建速度也能提升很多。 </li>
</ol>
<p>那么怎么才能将特定的文件排除在外呢？ 我们想到，在git中我们可以使用 <code>.gitignore</code>文件来屏蔽一些文件，那么在docker中，也有这样一个 <code>.dockerignore</code>的文件，用来屏蔽不需要添加到镜像中的文件。</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/19.png" style="zoom:100%;"></p>
<p>我们看到，屏蔽了node_modules之后，构建镜像的速度变得很快，在app文件夹中也没有 <code>node_modules</code>文件夹了。</p>
<h3 id="Running-Commands"><a href="#Running-Commands" class="headerlink" title="Running Commands"></a>Running Commands</h3><p>现在我们要在 dockerfile中添加RUN 命令，以便在构建的时候下载项目所需要的依赖。这样就不用构建完之后再手动<code>npm install</code> 了。</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/20.png" style="zoom:100%;"></p>
<h3 id="Setting-Environment-Variables"><a href="#Setting-Environment-Variables" class="headerlink" title="Setting Environment Variables"></a>Setting Environment Variables</h3><p>现在我们来设置 环境变量。比如说，当我们用前端和后端沟通的时候，使用环境变量可以为我们节省很多代码。</p>
<p>语法格式： <code>ENV API_URL=http://api.myapp.com/</code></p>
<p>在启动镜像之后，首先我们可以用<code>printenv</code>来打印所有的环境变量</p>
<p>然后我们可以通过两种方法查询特定的环境变量</p>
<p><code>printenv API_URL</code> 或者 <code>echo $API_URL</code> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;app # printenv API_URL</span><br><span class="line">http:&#x2F;&#x2F;api.myapp.com&#x2F;</span><br><span class="line">&#x2F;app # echo $API_URL</span><br><span class="line">http:&#x2F;&#x2F;api.myapp.com&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="Exposing-Ports"><a href="#Exposing-Ports" class="headerlink" title="Exposing Ports"></a>Exposing Ports</h3><p>我们需要为运行的程序设置一个端口，在Dockerfile中可以这么写：<code>EXPOSE 3000</code></p>
<p>但是注意了，这只是将程序挂载到 container 中的3000端口，并不是我本地电脑的3000端口，虽然都是localhost</p>
<h3 id="Setting-the-User"><a href="#Setting-the-User" class="headerlink" title="Setting the User"></a>Setting the User</h3><p>在默认情况下，Docker会以root用户来运行程序。虽然说root用户的权限最高，但是也会存在不少安全漏洞。因此，为了运行这个项目，我们需要创建一个普通用户，其权限比较低。</p>
<p>首先我们要创建一个组，<code>addgroup app</code> </p>
<p>然后我们创建一个 system user 并将其加入刚刚创建的组中 <code>adduser -S -G app app</code> ,这句命令的意思就是创建一个叫做app的user，并把它加入到名叫 app的组中。</p>
<p>我们还可以把这两个命令放在一个命令中： <code>addgroup app &amp;&amp; adduser -S -G app app</code></p>
<p>在<code>Dockerfile</code>中，我们可以这样写创建用户、切换用户：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> addgroup app &amp;&amp; adduser -S -G app app</span></span><br><span class="line"><span class="keyword">USER</span> app</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/21.png" style="zoom:100%;"></p>
<p>我们重新编译之后，输入 <code>whoami</code> ,这时候用户已经切成了app. </p>
<p>用<code>ls -l</code> 可以列出根目录下的一些文件信息，我们发现它们的所有者都是root，app用户是没有权限修改这些文件的，这就消除一些人修改文件的想法，增加了项目的安全性。</p>
<h3 id="Defining-Entrypoints"><a href="#Defining-Entrypoints" class="headerlink" title="Defining Entrypoints"></a>Defining Entrypoints</h3><h4 id="在terminal中直接启动项目"><a href="#在terminal中直接启动项目" class="headerlink" title="在terminal中直接启动项目"></a>在terminal中直接启动项目</h4><p>现在我们要不进入interactive模式，直接启动react-app，可以使用<code>docker run react-app npm start</code> ，其中跟在后面的 <code>npm start</code> 是启动后我们要在shell中输入的指令。</p>
<p>结果如下，我们发现我们并没有权限创建一个名为 <code>.cache</code>的文件。</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/22.png" style="zoom:100%;"></p>
<p>这是因为在Dockerfile中，我设置和切换用户写在最后两行，但是前面的指令都是root来执行的，因此我们没有权限在root创建的文件夹中进行操作。要解决这个问题，修改Dockerfile的顺序即可：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">14.16</span>.<span class="number">0</span>-alpine3.<span class="number">13</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> addgroup app &amp;&amp; adduser -S -G app app</span></span><br><span class="line"><span class="keyword">USER</span> app</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install</span></span><br><span class="line"><span class="keyword">ENV</span> API_URL=http://api.myapp.com/</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure>
<h4 id="在dockerfile中启动项目"><a href="#在dockerfile中启动项目" class="headerlink" title="在dockerfile中启动项目"></a>在dockerfile中启动项目</h4><p>在dockerfile通过命令启动项目有两种方式，一种是 CMD，另外一种是ENTRYPOINT。</p>
<p><strong>CMD</strong></p>
<p>支持三种格式:</p>
<ul>
<li><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code>使用 exec 执行，<strong>推荐方式</strong>；</li>
<li><code>CMD command param1 param2</code> 在 <code>/bin/sh</code> 中执行，提供给需要交互的应用；</li>
<li><code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code> 提供给 ENTRYPOINT 的默认参数；</li>
</ul>
<p>指定启动容器时执行的命令，每个 Dockerfile 只能有一条 CMD 命令。如果指定了多条命令，只有最后一条会被执行。如果用户启动容器时候<strong>指定了运行的命令，则会覆盖掉 CMD 指定的命令</strong>。</p>
<p><strong>ENTRYPOINT</strong></p>
<p>两种格式：</p>
<p><code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> ,<strong>推荐方式</strong></p>
<p> <code>ENTRYPOINT command param1 param2</code>（shell中执行）。</p>
<p>配置容器启动后执行的命令，并且<strong>不可被 docker run 提供的参数覆盖</strong>。</p>
<p>每个 Dockerfile 中只能有一个 ENTRYPOINT，当指定多个时，只有<strong>最后一个起效</strong>。</p>
<p>因此，当命令一定会被执行的时候，推荐使用ENTRYPOINT，因为其不会被覆盖。</p>
<h3 id="Speeding-Up-Builds"><a href="#Speeding-Up-Builds" class="headerlink" title="Speeding Up Builds"></a>Speeding Up Builds</h3><p>我们看到对于这个小项目，m1的mac mini每次编译运行都要大概三四十秒的时间，还是比较慢的。这和docker的镜像机制有关。当Docker在编译一个项目的时候，每次执行一条指令就会新建一个只读层，这个只读层包含了这条指令修改了的文件。</p>
<p>因此我们要优化它。首先我们用<code>docker history react-app</code>来看一下image的各层：</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/23.png" style="zoom:100%;"></p>
<p>我们看到下面没有COMMENT的半部分是 Base Image，也就是 我们创建的 <code>node:14.16.0-alpine3.13</code> ，这几层创建的时间都是十几天前，说明创建一次之后，若没有改变就不用再创建了</p>
<p>然后，执行<code>RUN addgroup app &amp;&amp; adduser -S -G app app</code> 命令后， image又加了一层，文件系统多了几个文件。但是新建过后，就不需要再改变了，我们看到这个修改时间是四个小时之前了。</p>
<p>接下来执行的是 <code>USER app</code> 和<code>WORKDIR /app</code>  ，它们没有添加也没有减少文件，因此这层layer的大小是0B</p>
<p>但是<code>COPY . .</code>  每次都会将本地文件夹中的内容放到镜像中，因此每执行一次build，这一层就会新建一次。并且，当里面的一层只读层重建的话，建立在其上面的只读层都必须重建。因此在<code>COPY</code> 之后的指令都会创建一个新的镜像。</p>
<p>现在技巧性的东西来了，我们希望 <code>npm install</code> 这一步不要经常改变，因为每次下载node_modules需要非常多的时间，而且依赖并不是经常会修改的。因此我们可以先将 <code>pakage.json</code>文件加入镜像并执行<code>npm install</code>,然后再把其他的文件加入镜像。这样以后执行起来就会跳过 <code>RUN  npm install</code> 这条指令。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">14.16</span>.<span class="number">0</span>-alpine3.<span class="number">13</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> addgroup app &amp;&amp; adduser -S -G app app</span></span><br><span class="line"><span class="keyword">USER</span> app</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> package*.json .	<span class="comment"># 先把依赖文件加进去</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install				<span class="comment"># 安装依赖，没有修改就跳过 </span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .							<span class="comment"># 再将其他的文件加入，从这里开始，每次都新建</span></span></span><br><span class="line"><span class="keyword">ENV</span> API_URL=http://api.myapp.com/</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"npm"</span>,<span class="string">"start"</span>]</span></span><br></pre></td></tr></table></figure>
<p>在第一次执行的时候，build需要执行38.2s,但是在修改了文件而不修改依赖的情况下再次build只需要4.9s，这是因为<code>npm install</code>的那一层并不需要重新再建一次，而是在缓存中了。</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/24.png" style="zoom:100%;"></p>
<h3 id="Removing-Images"><a href="#Removing-Images" class="headerlink" title="Removing Images"></a>Removing Images</h3><p>我们用<code>docker images</code>查看，会发现很多没有名字，也没有Tag的镜像文件：</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/25.png" style="zoom:100%;"></p>
<p>这些镜像文可能是临时镜像，没有最终build为一个最终的镜像，删掉即可。</p>
<p>我们可以使用：<code>docker container prune</code> 来删除已经停止多余的容器.</p>
<p>然后运行<code>docker image prune</code>来删除多余的镜像</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/26.png" style="zoom:100%;"></p>
<p>删除了之后，我们再打开镜像列表，发现只有两个我们在使用的镜像了。</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/27.png" style="zoom:100%;"></p>
<p>当我们想删除特定容器或者对象的时候，可以这样：</p>
<p>首先用<code>docker ps -a</code> 列出当前容器，然后：</p>
<p><code>docker rm -f &lt;?containerid&gt;</code> 来删除特定ID的容器或者镜像</p>
<p>或者用 <code>docker image rm &lt;name&gt;</code> 来制定删除特定名字的镜像或者容器</p>
<h3 id="Tagging-Images"><a href="#Tagging-Images" class="headerlink" title="Tagging Images"></a>Tagging Images</h3><p>为了项目维护方便，我们要养成给 Images打标签的习惯，否则每个项目的标签都是latest，比较难区分。比如说 testing, staging 之类的</p>
<p>举例： <code>docker build -t react-app:3.1.5</code>  也就是创建image的时候就给他打一个标签。其中，repository的名字是react-app, 该image的tag是冒号后面的 3.1.5</p>
<p>删除tag： <code>docker image remove react-app:1</code> </p>
<p>这和git中的tag有些类似，我们要时刻更新latest 这个tag</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/29.png" style="zoom:100%;"></p>
<p>比如现在我要将 lastest从上一个版本切换到现在tag为2的版本</p>
<p>可以用： <code>docker image tag 94e react-app:latest</code>  其中，945是Image ID的前三位</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/30.png" style="zoom:100%;"></p>
<h3 id="Sharing-Images"><a href="#Sharing-Images" class="headerlink" title="Sharing Images"></a>Sharing Images</h3><p>我们在dockerhub上</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/31.png" style="zoom:100%;"></p>
<p>然后我们把本地的image push上去, 首先为了管理方便我们再给第二版的项目打一个标签。</p>
<p><code>docker image tag 94e jasonxqh/react-app :2</code></p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/32.png" style="zoom:100%;"></p>
<p>然后利用<code>docker push jasonxqh/react-app:2</code>将第二版本的项目推送到docker hub上 ，推送之前记得先登录docker hub</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/34.png" style="zoom:100%;"></p>
<h3 id="Saving-and-Loading-Images"><a href="#Saving-and-Loading-Images" class="headerlink" title="Saving and Loading Images"></a>Saving and Loading Images</h3><p>如果我们不通过dockerhub，而是通过压缩文件的方法来保存images： <code>docker image save -o react-app.tar jasonxqh/react-app:3</code>  其中，前面的<code>react-app.tar</code>是压缩文件包的名字，后面的 <code>jasonxqh/react-app:3</code>是这个image的reference。</p>
<p>打开 <code>.tar</code>文件，里面保存的是一层一层的只读层</p>
<p>当我们在另一台电脑上要加载这个镜像的时候，可以：</p>
<p><code>docker image load -i react-app.tar</code></p>
<p>这样就把这个镜像加入进去了。</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/35.png" style="zoom:100%;"></p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/36.png" style="zoom:100%;"></p>
<h2 id="Working-with-Containers"><a href="#Working-with-Containers" class="headerlink" title="Working with Containers"></a>Working with Containers</h2><h3 id="Starting-Containers"><a href="#Starting-Containers" class="headerlink" title="Starting Containers"></a>Starting Containers</h3><p><code>docker run react-app</code> 可以让docker容器在前台运行：</p>
<p><code>docker run -d react-app</code> 可以让docker容器在后台运行。</p>
<p><code>docker run -d --name blue-sky react-app</code> 启动名为 <code>react-app</code>的docker镜像，并命名为 <code>blue-sky</code> </p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/37.png" style="zoom:100%;"></p>
<h3 id="Viewing-the-Logs"><a href="#Viewing-the-Logs" class="headerlink" title="Viewing the Logs"></a>Viewing the Logs</h3><p>现在我们在后台启动了这个容器，但是这对于我们来说相当于一个黑匣子，我并不清楚其中的运行信息。因此我们需要查看日志。</p>
<p>利用命令 <code>docker logs &lt;DockerID&gt;</code> 就可以查看该进程在后台打印的信息了：</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/38.png" style="zoom:100%;"></p>
<p>此外，通过查询 <code>docker logs --help</code> 可以查询更多操作：</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/39.png" style="zoom:100%;"></p>
<p>比如说：</p>
<p><code>dash logs -f ID</code> 可以<strong>实时监控</strong>后台的打印信息，可以通过 Ctrl+C 来退出该模式</p>
<p><code>dash logs -n 5 ID</code> 可以看到最后n条日志信息，这里是5条</p>
<p><code>dash logs -t ID</code> 可查看各条日志信息的时间戳</p>
<h3 id="Publishing-Ports"><a href="#Publishing-Ports" class="headerlink" title="Publishing Ports"></a>Publishing Ports</h3><p>之前我们说过，启动了container 之后，在本地访问<code>localhost:3000</code> 是没有效果的。因为在 Dockerfile 中，<code>Exposing 3000</code>只是在container所在的虚拟机中暴露3000端口。</p>
<p>为了做端口映射，我们可以用这条指令：</p>
<p><code>docker run -d -p 80:3000 --name c1  jasonxqh/react-app:3</code> </p>
<p>其中， -d 代表detach；-p 代表 port, 这里将container中的3000端口和本地的80端口做映射； —name是启动的container的名字； 最后一个参数是要启动的镜像</p>
<p>  <img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/40.png" style="zoom:100%;"></p>
<h3 id="Executing-Commands-in-Running-Containers"><a href="#Executing-Commands-in-Running-Containers" class="headerlink" title="Executing Commands in Running Containers"></a>Executing Commands in Running Containers</h3><p>之前我们学了在dockerfile中利用CMD执行命令。现在我们要来看怎么在一个正在运行的容器中执行命令</p>
<p>可以利用 <code>docker exec -it c1 sh</code>   来对一个正在运作的容器执行命令：</p>
<p>其中 <code>-it</code> 代表 interactive (交互)， c1是容器的名字， sh则是我们要打开的shell。</p>
<p>操作完之后，我们可以输入<code>exit</code> 退出shell，但是并不会使运行中的容器退出。</p>
<h3 id="Stopping-and-Starting-Containers"><a href="#Stopping-and-Starting-Containers" class="headerlink" title="Stopping and Starting Containers"></a>Stopping and Starting Containers</h3><p>使用<code>docker stop c1</code> 和<code>docker start c1</code>来结束或者开始一个容器。</p>
<p><code>docker run</code> 和 <code>docker start</code> 的区别就是前者是创建一个新的容器出来，后者是启动现有的容器</p>
<h3 id="Removing-Containers"><a href="#Removing-Containers" class="headerlink" title="Removing Containers"></a>Removing Containers</h3><p>我们用<code>docker rm c1</code> 是没有办法删除一个正在运行中的容器的，如果我们强制移除：<code>docker rm -f c1</code></p>
<h3 id="Containers-File-System"><a href="#Containers-File-System" class="headerlink" title="Containers File System"></a>Containers File System</h3><p>每一个容器都有独立的文件系统，在一个容器中创建的文件在另一个容器是访问不到的。</p>
<h3 id="Persisting-Data-using-Volumes"><a href="#Persisting-Data-using-Volumes" class="headerlink" title="Persisting Data using Volumes"></a>Persisting Data using Volumes</h3><p>Volume是 在container之外的一片存储空间。是绕过container的文件系统，直接将数据写到host机器上，只是volume是被docker管理的，docker下所有的volume都在host机器上的指定目录下/var/lib/docker/volumes。</p>
<p><code>docker volume create app-data</code> 是创建一个名叫app-data volume.</p>
<p><code>docker volume inspect app-data</code> 是查看这个volume的基本信息，我们看到这个volume是放在 <code>/var/lib/docker/volumes/app-data/_data</code>  文件夹下的</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/41.png" style="zoom:100%;"></p>
<p>接下来我们要把这个volume挂载到container中：</p>
<p><code>docker run -d -p 4000:3000 -v app-data:/app/data  jasonxqh/react-app:3</code></p>
<p>如果volume是空的而container中的目录有内容，那么docker会将container目录中的内容拷贝到volume中，但是如果volume中已经有内容，则会将container中的目录覆盖</p>
<p>也就是说现在我们往container中的<code>/app/data</code>目录写文件是会保存在本地电脑上的。</p>
<p>但是，现在我们直接 <code>echo something &gt; sth.data</code> ，是没有权限的，因为现在的用户是app,但是data的所有者是root。为此，我们要在dockerfile中事先以app用户的名义创建好data文件夹。</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/42.png" style="zoom:100%;"></p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/43.png" style="zoom:100%;"></p>
<p>现在，权限问题解决了。</p>
<h3 id="Copying-Files-between-the-Host-and-Containers"><a href="#Copying-Files-between-the-Host-and-Containers" class="headerlink" title="Copying Files between the Host and Containers"></a>Copying Files between the Host and Containers</h3><p>现在我们要把container中的文件拷贝到本地，或者把本地的文件拷贝到容器中去。</p>
<p><code>docker cp 776:/app/log.txt .</code> 其中<code>776:/app/log.txt</code> 是ID为776的container<code>/app</code>文件夹下的目标文件， <code>.</code> 是复制到的目的地。这里是把容器中的log.txt拷贝到本地当前文件夹。</p>
<p>同样的，<code>docker cp secret.txt 776:/app</code> 就是把本地的 <code>secret.txt</code>文件拷贝到container中去。</p>
<h3 id="Sharing-the-Source-Code-with-a-Container"><a href="#Sharing-the-Source-Code-with-a-Container" class="headerlink" title="Sharing the Source Code with a Container"></a>Sharing the Source Code with a Container</h3><p>当我们正式开始写项目的时候，我们不希望修改一点点东西就要新创建一个image，新开一个container，才能在网页上显示改变。这样太浪费时间了。</p>
<p>因此我们要做一个映射，就是在本地项目文件夹和docker的工作文件夹之间建立一个映射</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/44.png" style="zoom:100%;"></p>
<p>我们可以用这条命令来启动，首先我们做端口映射，然后 <code>-v</code> 代表挂载外接盘，这里我们把 <code>${PWD}</code> 和<code>/app</code> 做一个映射，也就是当我修改 当前目录文件夹的文件时，容器中的<code>/app</code>文件也会同步。 </p>
<p>注意 PWD 代表当前的目录，这里一定要<strong>使用大写 </strong>，否则是非法的。</p>
<p><code>docker run -d -p 5005:3000 -v ${PWD}:/app  react-app</code></p>
<h2 id="Running-Multi-container-Applications"><a href="#Running-Multi-container-Applications" class="headerlink" title="Running Multi-container Applications"></a>Running Multi-container Applications</h2><h3 id="Installing-Docker-Compose"><a href="#Installing-Docker-Compose" class="headerlink" title="Installing Docker Compose"></a>Installing Docker Compose</h3><p>前面我们使用 Docker 的时候，定义 Dockerfile 文件，然后使用 docker build、docker run 等命令操作容器。然而微服务架构的应用系统一般包含若干个微服务，每个微服务一般都会部署多个实例，如果每个微服务都要手动启停，那么效率之低，维护量之大可想而知</p>
<p><strong>使用 Docker Compose 可以轻松、高效的管理容器，它是一个用于定义和运行多容器 Docker 的应用程序工具</strong>mac和windows用户，当我们下载了Docker Desktop之后就自动安装了Docker Compose</p>
<h3 id="Cleaning-Up-our-Workspace"><a href="#Cleaning-Up-our-Workspace" class="headerlink" title="Cleaning Up our Workspace"></a>Cleaning Up our Workspace</h3><p><code>docker container rm -f $(docker container ls -aq)</code> 可以删除所有状态下的容器</p>
<p><code>docker image rm -f $(docker image ls -aq)</code> 可以删除所有状态下的 Image</p>
<p>其中<code>-aq</code> 中的a代表all， <code>-q</code> 则代表获取所有对象的ID。  </p>
<h3 id="The-Sample-Web-Application"><a href="#The-Sample-Web-Application" class="headerlink" title="The Sample Web Application"></a>The Sample Web Application</h3><p>这是一个有前端和后端的Web项目：</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/45.png" style="zoom:100%;"></p>
<p>按正常的方法，我们需要分别进入前后端文件夹并使用<code>npm run start</code> 但是如果我们使用了 docker compose，编写了yml文件，我们就可以直接输入<code>docker-compose up</code>让项目在docker容器中运行。</p>
<h4 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h4><p>这里我遇到了一个比较难发现的bug，那就是我一直无法启动 <code>./docker-entrypoint.sh</code> 这个文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">echo "Waiting for MongoDB to start..."</span><br><span class="line">./wait-for db:27017 </span><br><span class="line"></span><br><span class="line">echo "Migrating the databse..."</span><br><span class="line">npm run db:up </span><br><span class="line"></span><br><span class="line">echo "Starting the server..."</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>
<p>当后端启动，我们再调用这个文件，就能在container中运行shell命令。</p>
<p>但是，我这个文件是本地创建的，创建时并没有像app用户开放执行权限，导致我<code>docker-compose up</code> 的时候始终报：Permission denied。 因此，我们要在运行<code>docker-compose up</code> 前手动修改<code>docker-entrypoint.sh</code> 的权限：</p>
<p><code>chmod a+x docker-entrypoint.sh</code> 修改执行权限，再执行<code>docker-compose up</code> 之后，bug解决。</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/46.png" style="zoom:100%;"></p>
<h3 id="JSON-and-YAML-Formats"><a href="#JSON-and-YAML-Formats" class="headerlink" title="JSON and YAML Formats"></a>JSON and YAML Formats</h3><p> 现在我们就来介绍一下YAML格式以及它和JSON格式的区别。</p>
<p>首先我们看以下JSON格式的文件：JSON格式就是键值对</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"vidly-frontend"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.1.0"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"axios"</span>: <span class="string">"^0.21.1"</span>,</span><br><span class="line">    <span class="attr">"react"</span>: <span class="string">"^17.0.1"</span>,</span><br><span class="line">    <span class="attr">"react-dom"</span>: <span class="string">"^17.0.1"</span>,</span><br><span class="line">    <span class="attr">"react-scripts"</span>: <span class="string">"4.0.2"</span>,</span><br><span class="line">    <span class="attr">"web-vitals"</span>: <span class="string">"^1.0.1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"react-scripts start"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"react-scripts build"</span>,</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"react-scripts test --colors"</span>,</span><br><span class="line">    <span class="attr">"eject"</span>: <span class="string">"react-scripts eject"</span></span><br><span class="line">  &#125;,  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>YAML的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。那么YAML格式长啥样呢？下面是 <code>docker-compose.yml</code> 文件中的信息：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.8"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">frontend:</span></span><br><span class="line">    <span class="attr">depends_on:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./frontend</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3000</span><span class="string">:3000</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">backend:</span> </span><br><span class="line">    <span class="attr">depends_on:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./backend</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="number">3001</span><span class="string">:3001</span></span><br><span class="line">    <span class="attr">environment:</span> </span><br><span class="line">      <span class="attr">DB_URL:</span> <span class="string">mongodb://db/vidly</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">./docker-entrypoint.sh</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0-xenial</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27017</span><span class="string">:27017</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">vidly:/data/db</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">vidly:</span></span><br></pre></td></tr></table></figure>
<p>我们发现，YAML其实就是JSON格式去掉所有的大括号和引号，并用缩进来表示从属关系。</p>
<p>在一个冒号下的多个数值的列举，使用 <code>-</code> 使条理清晰</p>
<p>那么YAML可读性比JSON高的话，为什么我们步一直使用YAML呢？因为解析YAML格式的文件要比解析JSON格式的文件更慢一些，所以说各有利弊</p>
<p>接下来这章，我们就来复盘一下这样一份 <code>docker-compose.yml</code> 是怎么写出来的</p>
<h3 id="Creating-a-Compose-File"><a href="#Creating-a-Compose-File" class="headerlink" title="Creating a Compose File"></a>Creating a Compose File</h3><p>首先，我们新建一个 <code>docker-compose.yml</code> 文件。</p>
<h4 id="version字段"><a href="#version字段" class="headerlink" title="version字段"></a>version字段</h4><p>在文件的开始，我们要确定compose版本：</p>
<p>在： <a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener">https://docs.docker.com/compose/compose-file/</a> 中，我们可以查到compose file与Docker Engine对应的表格，按照上面写即可：</p>
<p>这里我们使用3.8版本：</p>
<p><code>Version: &quot;3.8&quot;</code> </p>
<h4 id="services字段"><a href="#services字段" class="headerlink" title="services字段"></a>services字段</h4><p>然后我们要确定<code>services</code>字段：这个字段告诉Docker，它要创建哪些container，比如frontend，backend，db，这些服务的名字我们可以乱取，Docker会依次为其创建容器。但是为了简洁起见，我们还是将其命名为frontend，backend，db三个服务，分别代表前端，后端，数据库</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.8"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">frontend:</span></span><br><span class="line">    </span><br><span class="line">  <span class="attr">backend:</span> </span><br><span class="line">  </span><br><span class="line">  <span class="attr">db:</span></span><br></pre></td></tr></table></figure>
<h5 id="frontend"><a href="#frontend" class="headerlink" title="frontend"></a>frontend</h5><p>在前端服务中，我们首先要运行frontend文件夹中的 <code>dockerfile</code> 文件。我们可以这么写：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">frontend:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./frontend</span></span><br></pre></td></tr></table></figure>
<p>接下来我们做端口映射，也就是将容器中的端口映射到本地。这里虽然我们只做一个端口映射，但是考虑到可能有多重端口映射，因此这里使用 <code>-</code> 来列举</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">frontend:</span></span><br><span class="line">  <span class="attr">build:</span> <span class="string">./frontend</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">3000</span><span class="string">:3000</span></span><br></pre></td></tr></table></figure>
<h5 id="backend"><a href="#backend" class="headerlink" title="backend"></a>backend</h5><p>和frontend一样，这里我们也要定义build属性，它将执行 backend文件夹下的dockerfile文件</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">backend:</span> </span><br><span class="line">	<span class="attr">build:</span> <span class="string">./backend</span></span><br></pre></td></tr></table></figure>
<p>和frontend一样，后端服务也需要端口映射：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">backend:</span> </span><br><span class="line">    <span class="attr">build:</span> <span class="string">./backend</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="number">3001</span><span class="string">:3001</span></span><br></pre></td></tr></table></figure>
<p>下面一个属性是<code>environment</code>,这是后端服务所需要</p>
<p>然后，我们要做一个volume映射，来告诉后端数据库在哪里.这个关键变量其实就是一个Mongodb的Connection URL ——  <code>mongodb://db/vidly</code> ，db是一个host(因为按照YAML创建的container中的host名与service的名字一样)，因此，这里是<code>db</code>;  <code>/vidly</code>代表这个db数据库下的一张数据表.</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">backend:</span> </span><br><span class="line">  <span class="attr">depends_on:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">  <span class="attr">build:</span> <span class="string">./backend</span></span><br><span class="line">  <span class="attr">ports:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="number">3001</span><span class="string">:3001</span></span><br><span class="line">  <span class="attr">environment:</span> </span><br><span class="line">    <span class="attr">DB_URL:</span> <span class="string">mongodb://db/vidly</span></span><br></pre></td></tr></table></figure>
<h5 id="db"><a href="#db" class="headerlink" title="db"></a>db</h5><p>这是一个数据库服务，因为我们本地没有相关的文件，所以就要用为其规定image属性，比如说这里的 <code>mongo:4.0-xenial</code> ，这是一个ubuntu 版本的mongodb，比windows下的mongodb要轻量化许多。然后同样做一个端口映射</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">db:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">mongo:4.0-xenial</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">27017</span><span class="string">:27017</span></span><br></pre></td></tr></table></figure>
<p>通常情况下，一个容器启动之后，所有容器中的数据都存在容器内部的临时文件中，如果容器停止，则数据也就清空了，为了能够在使用容器的过程中，还能把一些数据持久化下来，也即容器消失掉，这些数据依然还存在，因此dockercompose支持了数据卷（volume）功能，通过他可以指定Docker中一块持久化的区域，该区域在容器消失之后，还可以依然将区域中的数据保存下来。</p>
<p>相当于这部分区域不在属于某一个容器了，而是由dockercompose管理的一部分区域，只要通过compose启动容器，这部分区域就一直会存在</p>
<p>这里我们就要定义一个持久化的数据卷：左边的是主机目录，右边的是容器目录。也就是说，如果项目往容器数据库中写数据的话，那么这些数据会保存在主机上不会消失。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">db:</span> </span><br><span class="line">  <span class="attr">image:</span> <span class="string">mongo:4.0-xenial</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">27017</span><span class="string">:27017</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">vidly:/data/db</span></span><br></pre></td></tr></table></figure>
<h4 id="volumes"><a href="#volumes" class="headerlink" title="volumes:"></a>volumes:</h4><p>上面我们使用了一个数据卷 ，但我们还没有定义，因此接下来我们要定义它。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">vidly:</span></span><br></pre></td></tr></table></figure>
<h3 id="Building-Images-1"><a href="#Building-Images-1" class="headerlink" title="Building Images"></a>Building Images</h3><p>之前我们说了 Docker-Compose 是建立在 Docker-engine之上的，因此docker engine能完成的工作(build,run,listening等)，docker-compose都能够完成 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Commands:</span><br><span class="line">  build              Build or rebuild services</span><br><span class="line">  config             Validate and view the Compose file</span><br><span class="line">  create             Create services</span><br><span class="line">  down               Stop and remove resources</span><br><span class="line">  events             Receive real time events from containers</span><br><span class="line">  exec               Execute a command in a running container</span><br><span class="line">  help               Get help on a command</span><br><span class="line">  images             List images</span><br><span class="line">  kill               Kill containers</span><br><span class="line">  logs               View output from containers</span><br><span class="line">  pause              Pause services</span><br><span class="line">  port               Print the public port for a port binding</span><br><span class="line">  ps                 List containers</span><br><span class="line">  pull               Pull service images</span><br><span class="line">  push               Push service images</span><br><span class="line">  restart            Restart services</span><br><span class="line">  rm                 Remove stopped containers</span><br><span class="line">  run                Run a one-off command</span><br><span class="line">  scale              Set number of containers for a service</span><br><span class="line">  start              Start services</span><br><span class="line">  stop               Stop services</span><br><span class="line">  top                Display the running processes</span><br><span class="line">  unpause            Unpause services</span><br><span class="line">  up                 Create and start containers</span><br><span class="line">  version            Show version information and quit</span><br></pre></td></tr></table></figure>
<p>现在我们来学习如何用 build 指令, build就是用来构建刚才我们写的服务的。build完成后service会以 image的形式存在。</p>
<p>当我们想不借助cache，重新编译的时候，可以使用 <code>docker-compose build --no-cache</code> 但是显然这样会比较慢</p>
<h3 id="Starting-and-Stopping-the-Application"><a href="#Starting-and-Stopping-the-Application" class="headerlink" title="Starting and Stopping the Application"></a>Starting and Stopping the Application</h3><p>之前学的 <code>docker-compose up</code> 是将 build image，run container一步到位了。如果我们想重新build一遍，并运行起来，可以使用 <code>docker-compose up --build</code> ；如果我们想要其在后台运行，可以使用<code>docker-compose up -d</code> </p>
<p>使用docker-compose运行起来的容器可以使用 <code>docker-compose ps</code> 一览</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/47.png" style="zoom:100%;"></p>
<p>当我们想要关掉后台运行中的的容器时，可以 <code>docker-compose down</code> </p>
<h3 id="Docker-Networking"><a href="#Docker-Networking" class="headerlink" title="Docker Networking"></a>Docker Networking</h3><p>当我们用 docker-compose 启用一个项目的时候，Docker Compose会自动创建一个关系网络并将containers加到这个网络上，一遍这几个网络可以互相通讯。</p>
<p>我们可以使用<code>docker network ls</code> 来查看这几个container 的关系网：</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/48.png" style="zoom:100%;"></p>
<p>然后我用 root 用户登录backend(否则没有ping的权限)，然后ping 本地的frontend地址，就可以发现它们是可以互相通讯的。</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/49.png" style="zoom:100%;"></p>
<p>这也是为什么backend container能够通过 connection url与mongodb container 通讯了。</p>
<h3 id="Viewing-Logs"><a href="#Viewing-Logs" class="headerlink" title="Viewing Logs"></a>Viewing Logs</h3><p>使用<code>docker-compose logs</code> 可以查看后端程序日志信息，和<code>docker logs</code> 一样，也可以加上 <code>-f,-t</code> 用来跟踪日志或者打印时间戳。</p>
<h3 id="Publishing-Changes"><a href="#Publishing-Changes" class="headerlink" title="Publishing Changes"></a>Publishing Changes</h3><p>和单个container一样，我们不希望修改一点代码就要rebuild整个项目，那样太麻烦了。因此我们要降本的文件夹和container中的/app 文件夹做映射，而且要比之前的利用绝对路径<code>$(PWD)</code>做映射更简单。比如说，我要把 本地的backend文件夹和/app文件夹做映射。只要 <code>./backend:/app</code> 即可</p>
<p>但是这有一个bug，就是后端会报一个错误，也就是 <code>nodemon:not found</code> </p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/50.png" style="zoom:100%;"></p>
<p>我们知道nodemon是一个很有用的包，它会监测文件的修改并实时渲染。但是，我们只在container中装载了node_modules文件夹而本地的backend目录下并没有node_modules文件夹。因此无法实现监测。</p>
<p>为了解决这个问题，我们可以在本地也安装<code>node_modules</code> 文件夹。这样再次启动前后端，就能实现同步更新了。</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/51.png" style="zoom:100%;"></p>
<h3 id="Migrating-the-Database"><a href="#Migrating-the-Database" class="headerlink" title="Migrating the Database"></a>Migrating the Database</h3><p>如果要在一个新的电脑上运行这个项目，我们势必要把数据插入到新的mongodb当中去。因此这就需要用到数据迁移。在nodejs中有个很好用的工具，可以用来迁移mongodb数据库：<code>migrate-mongo</code></p>
<p>使用了这个工具，我们可以创建 <code>database-migration scripts</code> 如下：</p>
<p>这个文件存放在 <code>migrations</code>文件夹中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="keyword">async</span> up(db, client) &#123;</span><br><span class="line">    <span class="keyword">await</span> db</span><br><span class="line">      .collection(<span class="string">"movies"</span>)</span><br><span class="line">      .insertMany([</span><br><span class="line">        &#123; <span class="attr">title</span>: <span class="string">"Avatar"</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">title</span>: <span class="string">"Star Wars"</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">title</span>: <span class="string">"Terminator"</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">title</span>: <span class="string">"Titanic"</span> &#125;,</span><br><span class="line">      ]);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> down(db, client) &#123;</span><br><span class="line">    <span class="keyword">await</span> db.collection(<span class="string">"movies"</span>).deleteMany(&#123;</span><br><span class="line">      title: &#123;</span><br><span class="line">        $<span class="keyword">in</span>: [<span class="string">"Avatar"</span>, <span class="string">"Star Wars"</span>, <span class="string">"Terminator"</span>, <span class="string">"Titanic"</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里有两个模块：up函数是往database的movies数据表中中添加数据，down函数是在database删除数据。这两个函数式异步的</p>
<p>要启动这个脚本文件，可以 <code>migrate-mongo up</code>。因为在数据库中有变更日志，所以migrate-mongo 模块并不会重复执行一个脚本，插入重复的数据。</p>
<p>在package.json 中，我们看到可以用<code>npm run db:up</code>来简化<code>migrate-mongo up</code> </p>
<p>介绍完database migration之后，我们希望在启动项目的一开始先执行数据库迁移,在后端的Dockerfile中，我们只写了 <code>CMD [&quot;npm&quot;,&quot;start&quot;]</code> , 这是不够的，我们可在<code>docker-compose</code> 中定义 <code>command</code>字段来重写要执行的操作。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">backend:</span> </span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">	<span class="attr">command:</span> <span class="string">migrate-mongo</span> <span class="string">up</span> <span class="string">&amp;&amp;</span> <span class="string">npm</span> <span class="string">start</span></span><br></pre></td></tr></table></figure>
<p>但是这样写有个问题，因为当我执行<code>migrate-mongo up</code> 的时候， 我的db service可能还没有启动，这样就会报错了。为解决这个问题，需要在启动命令前增加<code>判断依赖服务状态的工具</code>，主要有三种：<strong>wait-for-it，dockerize，waitfor</strong>在这我使用<code>./wait-for</code> : </p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">backend:</span> </span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">	<span class="attr">command:</span> <span class="string">./wait-for</span> <span class="string">db:27017</span> <span class="string">&amp;&amp;</span> <span class="string">migrate-mongo</span> <span class="string">up</span> <span class="string">&amp;&amp;</span> <span class="string">npm</span> <span class="string">start</span></span><br></pre></td></tr></table></figure>
<p>其中<code>./wait-for</code>后面的第一个参数是service 的名字，第二个参数是其对应的端口.</p>
<p>虽然写是写好了，但是这样的command未免有点不美观，因此，我们可以新建一个<code>docker-entrypoint.sh</code>的可执行文件，然后用command来执行它。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">echo "Waiting for MongoDB to start..."</span><br><span class="line">./wait-for db:27017 # 首先等待db service 启动</span><br><span class="line"></span><br><span class="line">echo "Migrating the databse..."</span><br><span class="line">npm run db:up # 进行数据迁移操作</span><br><span class="line"></span><br><span class="line">echo "Starting the server..."</span><br><span class="line">npm start # 最后启动backend server</span><br></pre></td></tr></table></figure>
<p>把command字段改成执行docker-entrypoint.sh 即可</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">backend:</span> </span><br><span class="line"><span class="comment">#...</span></span><br><span class="line">  <span class="attr">command:</span> <span class="string">./docker-entrypoint.sh</span></span><br></pre></td></tr></table></figure>
<p>最后我们来设置一下服务器的顺序启动问题，比如说先启动db服务，再启动backend服务，最后启动frontend服务，但是注意这只能保证容器进入了running状态，而不保证进入 ready状态,所以说我们要将depends_on和wait-for搭配使用。可以设置 <code>depends_on</code>字段来解决</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.8"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">frontend:</span></span><br><span class="line">    <span class="attr">depends_on:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">   <span class="comment">#...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="attr">backend:</span> </span><br><span class="line">    <span class="attr">depends_on:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">   <span class="comment">#...</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">  <span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<h3 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h3><p>这一节我们主要讲了这几个命令以及它们的延伸。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker-compose build</span><br><span class="line">docker-compose build --no-cached</span><br><span class="line">ocker-compose up</span><br><span class="line">docker-compose up -d</span><br><span class="line">docker-compose up —build</span><br><span class="line">docker-compose down</span><br><span class="line">docker-compose ps</span><br><span class="line">docker-compose logs</span><br><span class="line">Docker Compose commands</span><br></pre></td></tr></table></figure>
<h2 id="Deploying-Applications"><a href="#Deploying-Applications" class="headerlink" title="Deploying Applications"></a>Deploying Applications</h2><p>这一章节我们来讲一下如何发布一个应用</p>
<h3 id="Deployment-Options"><a href="#Deployment-Options" class="headerlink" title="Deployment Options"></a>Deployment Options</h3><p>对于一个项目，有两种部署的方式，其一可以部署到一个服务器上(single-host deployment)，也可以部署到一个服务器集群上(Cluster deployment)</p>
<p>只部署到一个服务器上，虽然操作比较简单，但是一旦服务器宕机，我们的项目也就失效了。而且当应用的瞬时流量较大时，单个服务器可能承受不了这样的压力。</p>
<p>如果选择<code>cluster deployment</code> 这种方式，这需要编制软件(orchestration tools)帮忙，主流orchestration tools有： <code>docker swarm</code> 和 <code>kubernetes(俗称k8s)</code> ，但是部署的逻辑较为复杂，因此这章还是使用<code>single-host deployment</code> 这种方式。</p>
<h3 id="Getting-a-Virtual-Private-Server"><a href="#Getting-a-Virtual-Private-Server" class="headerlink" title="Getting a Virtual Private Server"></a>Getting a Virtual Private Server</h3><p>VPS提供商有很多,比如说：</p>
<ul>
<li>Digital Ocean</li>
<li>Google Cloud Platform(GCP)</li>
<li>Microsoft Azure</li>
<li>Amazon Web Services(AWS) </li>
</ul>
<p>一般来说租个VPS都是要花钱的，我这里使用Oracle Virtualbox 来演示</p>
<h3 id="Installing-Docker-Machine"><a href="#Installing-Docker-Machine" class="headerlink" title="Installing Docker Machine"></a>Installing Docker Machine</h3><p>首先我们需要在项目文件夹中安装 Docker Machine。Docker Machine 是一种可以让您在虚拟主机上安装 Docker 的工具，并可以使用 docker-machine 命令来管理主机。Docker Machine 也可以集中管理所有的 docker 主机，比如快速的给 100 台服务器安装上 docker。</p>
<p>可以在这里下载：<a href="https://github.com/docker/machine/releases" target="_blank" rel="noopener">https://github.com/docker/machine/releases</a></p>
<p>我们使用的是mac os，那就复制这段连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -L https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;machine&#x2F;releases&#x2F;download&#x2F;v0.16.2&#x2F;docker-machine-&#96;uname -s&#96;-&#96;uname -m&#96; &gt;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-machine &amp;&amp; \</span><br><span class="line">  chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-machine</span><br></pre></td></tr></table></figure>
<p>当然，我们下载了homebrew，可直接用 <code>brew install docker docker-machine</code></p>
<h3 id="Provisioning-a-Host"><a href="#Provisioning-a-Host" class="headerlink" title="Provisioning a Host"></a>Provisioning a Host</h3><p>现在我们要用docker machine 创建一个虚拟机。docker-machine支持的虚拟机提供服务如下:</p>
<p><a href="https://docs.docker.com/machine/drivers/" target="_blank" rel="noopener">https://docs.docker.com/machine/drivers/</a></p>
<h3 id="Connecting-to-the-Host"><a href="#Connecting-to-the-Host" class="headerlink" title="Connecting to the Host"></a>Connecting to the Host</h3><h3 id="Defining-the-Production-Configuration"><a href="#Defining-the-Production-Configuration" class="headerlink" title="Defining the Production Configuration"></a>Defining the Production Configuration</h3><h3 id="Reducing-the-Image-Size"><a href="#Reducing-the-Image-Size" class="headerlink" title="Reducing the Image Size"></a>Reducing the Image Size</h3><h3 id="Deploying-the-Application"><a href="#Deploying-the-Application" class="headerlink" title="Deploying the Application"></a>Deploying the Application</h3><h3 id="Troubleshooting-Deployment-Issues"><a href="#Troubleshooting-Deployment-Issues" class="headerlink" title="Troubleshooting Deployment Issues"></a>Troubleshooting Deployment Issues</h3><h3 id="Publishing-Changes-1"><a href="#Publishing-Changes-1" class="headerlink" title="Publishing Changes"></a>Publishing Changes</h3><h3 id="Course-Wrap-Up"><a href="#Course-Wrap-Up" class="headerlink" title="Course Wrap Up"></a>Course Wrap Up</h3>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/04/04/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F3-1-3-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/04/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F3-1-3-3/" itemprop="url">多维随机变量3.1-3.3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-04-04T22:09:27+08:00">
                2021-04-04
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2021-06-27T20:13:04+08:00">
                2021-06-27
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="多元随机变量及其联合分布"><a href="#多元随机变量及其联合分布" class="headerlink" title="多元随机变量及其联合分布"></a>多元随机变量及其联合分布</h1><h2 id="多维随机变量"><a href="#多维随机变量" class="headerlink" title="多维随机变量"></a>多维随机变量</h2><p><strong>定义：如果 $X_1(\omega),X_2(\omega)\cdots,X_n(\omega)$</strong>  是定义在同一个样本空间 $\Omega = {\omega}$ 上的 $n$ 个随机变量，则称 $X(\omega) = (X_1(\omega),X_2(\omega),\cdots,X_n(\omega))$ 为 n 维(n元) 随机变量或者随机向量。</p>
<h2 id="联合分布函数"><a href="#联合分布函数" class="headerlink" title="联合分布函数"></a>联合分布函数</h2><p><strong>定义：</strong> 对任意的n 个实数 $x_1,x_2,\cdots,x_n$ n个事件${X_1\leq x_1},\cdots,{X_n\leq x_n}$ 同时发生的概率为： $F(x_1,x_2\cdots,x_n)=P(X_1\leq x_1,X_2\leq x_2,\cdots,X_n\leq x_n)$  称为n维随机变量的联合分布函数</p>
<p>任意一个而为联合分布函数 $F(x,y)$ 必具有如下几条基本性质：</p>
<ul>
<li>单调性 </li>
<li>有界性</li>
<li>右连续性</li>
<li><strong>非负性</strong> ，这是新的性质： 对任意的$a&lt;b,c&lt;d$ 有$P(a&lt;X\leq b，c&lt;X\leq d) = F(b,d)-F(a,d)-F(b,c)+F(a,c)$ </li>
</ul>
<p>这几条性质的成立与该分布为某个二维随机变量的分布函数互为充要条件</p>
<h2 id="联合分布列"><a href="#联合分布列" class="headerlink" title="联合分布列"></a>联合分布列</h2><p>如果二维随机变量$(X,Y)$是<strong>离散的</strong>，则称 $(X,Y)$ 为二维离散随机变量，称$p_{ij}=P(X=x_i,Y=y_j),i,j=1,2\cdots$ 为$(X,Y)$的联合分布列。如图:</p>
<p><img src="/2021/04/04/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F3-1-3-3/1.png" style="zoom:80%;"></p>
<p>联合分布列的基本性质：</p>
<ol>
<li>非负性 $p_{ij}\geq 0$</li>
<li>正则性 $\sum<em>{i=1}^\infty \sum</em>{j=1}^\infty = 1$</li>
</ol>
<h2 id="联合密度函数"><a href="#联合密度函数" class="headerlink" title="联合密度函数"></a>联合密度函数</h2><p><strong>定义：</strong> 如果存在二元非负函数 $p(x,y)$ ，使得二维随机变量 $(X,Y)$ 的<strong>分布函数</strong> $F(x,y)$ 可表示为：</p>
<p>$F(x,y)=\int<em>{-\infty}^x\int</em>{-\infty}^y p(u,v) dvdu$ </p>
<p>则称 $F(x,y)$ 为二维连续随机变量，称$p(u,v)$ 为 $(X,Y)$ 的联合密度函数</p>
<h2 id="常用多维分布"><a href="#常用多维分布" class="headerlink" title="常用多维分布"></a>常用多维分布</h2><h3 id="多项分布"><a href="#多项分布" class="headerlink" title="多项分布"></a>多项分布</h3><p>多项分布是重要的多维离散分布，它是二项分布的推广</p>
<p><strong>进行 n 次</strong>独立重复试验，如果每次试验有 r 个互不相容的结果：$A_1,A_2,\cdots,A_r$ 之一发生，且每次试验中$A_i$ 发生的概率为$p_i=P(A_i) ,i=1,2,\cdots,r$ 且 $p_1+p_2+\cdots+p_r =1$。 记 $X_i$ 为 n次独立重复实验中 $A_i$ 出现的次数$i=1,2,\cdots,r$ </p>
<p>那么$(X_1,X_2,\cdots,X_r)$ 取值$(n_1,n_2,\cdots,n_r)$ 的概率 ，也就是说$A_1$ 出现$n_1$ 次，$A_2$ 出现 $n_2$次…的概率为：</p>
<script type="math/tex; mode=display">
P(X_1=n_1,X_2=n_2,\cdots,X_r=n_r) = \frac{n!}{n_1!n_2!\cdots n_r!} p_1^{n_1}p_2^{n_2}\cdots p_r^{n_r}</script><p>其中 $n=n_1+n_2+\cdots+n_r$ </p>
<p>这个联合分布列被称为 <strong>r项分布</strong>, 又称为<strong>多项分布</strong>，记为$M(n,p_1,p_2,\cdots,p_r)$ </p>
<p>这里我们要搞清楚一个概念，<strong>r项分布是r-1维随机变量的分布</strong></p>
<h3 id="多维均匀分布"><a href="#多维均匀分布" class="headerlink" title="多维均匀分布"></a>多维均匀分布</h3><p>设 D 为 $R^n$ 中的一个有界区域，其 measure(即平面的为面积，空间的为体积等) 为$S_D$ ,如果多维随机变量 $(X_1,X_2,\cdots,X_n) $ 的联合密度函数为：</p>
<script type="math/tex; mode=display">
p(x_1,x_2,\cdots)=\begin{cases}\dfrac{1}{SD}~~ (x_1,x_2,\cdots,x_n)\in D \\ \\ 0 ~~其他\end{cases}</script><p>则称$(X_1,X_2,\cdots,X_n)$ 服从D上的多维均匀分布，记为 $(X_1,X_2,\cdots,X_n)\sim U(D)$ </p>
<p>二维均匀分布所描述的随机现象就是向平面区域D中随机投点，如果该店坐标$(X,Y)$ 落在D的子区域 G 中的概率只和G的面积有关，而和G的位置无关。 现在用二维均匀分布来描述就是：</p>
<script type="math/tex; mode=display">
P((X,Y)\in G) = \iint_G p(x,y)dxdy = \iint_G\frac{1}{S_D}dxdy = \frac{G的面积}{D的面积}</script><p>推广到多维均匀分布，可以：</p>
<script type="math/tex; mode=display">
\frac{S_a}{S_D} = p((x_1x_2\cdots)\in G) = \int\cdots\int\limits_G P(x_1\cdots x_n)dx_1\cdots dx_n</script><h3 id="n维正态分布"><a href="#n维正态分布" class="headerlink" title="n维正态分布"></a>n维正态分布</h3><p>设 n 维随机变量 $X=(X_1,X_2,\cdots,X_n)’$  的协方差矩阵 $B= Cov(X)$是正定的，数学期望向量为 $a=(a_1,a_2\cdots,a_n)’$ 又记 $x=(x_1,x_2,\cdots,x_n)’$ 则由密度函数：</p>
<script type="math/tex; mode=display">
p(x_1,x_2,\cdots,x_n)=p(x)=\frac{1}{(2\pi)^{\frac{\pi}2}|B|^\frac{1}{2}}\exp{\{-\frac{1}{2}(x-a)^t B^{-1}(x-a)}\}</script><p>  定义的分布称为<strong>n元正态分布</strong>， 记为$X\sim N(a,B)$  . 其中$|B|$表示B的行列式，$B^{-1}$ 表示B的逆矩阵，$(x-a)^t$表示为向量$(x-a)$的转置</p>
<p>在n=2的场合，若取数学期望向量和协方差矩阵分别为</p>
<script type="math/tex; mode=display">
a=\begin{pmatrix} \mu_1 \\ \mu_2 \end{pmatrix} , B=\begin{pmatrix} \sigma_1^2 ~~~~ \sigma_1\sigma_2\rho \\ \sigma_1\sigma_2\rho ~~~~ \sigma_2^2\end{pmatrix}</script><p>带入上面的定义，可以得到二元正态密度函数。</p>
<h3 id="多维指数分布"><a href="#多维指数分布" class="headerlink" title="多维指数分布"></a>多维指数分布</h3><p>特别的，当随机变量个数取2时</p>
<p><img src="/2021/04/04/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F3-1-3-3/1.jpg" style="zoom:80%;"></p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>题目常常会给我们一个二元随机变量$(X,Y)$ 的联合密度函数。要我们求一些概率。</p>
<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p><strong>步骤1：先判断 X,Y 是否相互独立</strong></p>
<p>可以先求一下X，Y的边际分布，如果相互独立，那么会一定程度上减轻之后的计算量</p>
<p><strong>步骤2：利用给出的定义域和题目中的X,Y范围来作图求解/或者利用相互独立的性质求解</strong></p>
<p>比如：设二维随机变量$(X,Y)$ 的联合密度函数为：</p>
<script type="math/tex; mode=display">
p(x,y)=\begin{cases}4xy, ~~0<x<1,0<y<1\\ \\ 0 ,~~~~其他 \end{cases}</script><p>首先，我们可以判断一下X，Y是否相互独立：</p>
<script type="math/tex; mode=display">
p_X(x)=\int_0^1 4xy dy =2x , p_Y(y)=\int_0^1 4xy dx = 2y</script><script type="math/tex; mode=display">
p(x,y) = p_X(x)\cdot p_Y(y)</script><p>因此，X,Y 相互独立。</p>
<p>1) $P(0&lt;X&lt;0.5,0.25&lt;Y&lt;1)$</p>
<p>这一小题既可以使用画图法求解，也可以用边际分布的独立性求解。</p>
<script type="math/tex; mode=display">
P(0<X<0.5,0.25<Y<1)=P(0<X<0.5)P(0.25<Y<1)=\int_0^{0.5} 2x dx\int_{0.25}^1 2y dy = \frac{15}{64}</script><p>2) $P(X=Y)$</p>
<p>这是让我们求一条直线上的概率，显然$P(X=Y)=0$</p>
<p>3) $P(X&lt;Y)$ </p>
<p>这一小题只能使用画图法来求解， 区域就是 $\begin{cases}0&lt;x&lt;1,0&lt;y&lt;1\ \ x&lt;y \end{cases}$</p>
<script type="math/tex; mode=display">
\int_0^1\int_0^x 4xy dydx</script><p>4) $(X,Y)$ 的联合分布函数</p>
<p>求联合分布函数 </p>
<script type="math/tex; mode=display">
F(x,y) = P(X\leq x,Y\leq y) = \int_0^x\int_0^y 4xy~dy dx</script><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>这是另外一种题型，给出X，Y的边际分布列，要我们补全整个联合分布列。</p>
<p>设随机变量 $X_i,i=1,2$ 的分布列如下，且满足 $P(X_1X_2=0)=1$, 试求$P(X_1=X_2)$ </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$X_i$</th>
<th>-1</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>P</td>
<td>0.25</td>
<td>0.5</td>
<td>0.25</td>
</tr>
</tbody>
</table>
</div>
<p><strong>第一步：出$(X_1,X_2)$ 的联合分布列</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>下$X_1$/右$X_2$</th>
<th>-1</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>-1</td>
<td>$p_{11}$</td>
<td>$p_{12}$</td>
<td>$p_{13}$</td>
</tr>
<tr>
<td>0</td>
<td>$p_{21}$</td>
<td>$p_{22}$</td>
<td>$p_{23}$</td>
</tr>
<tr>
<td>1</td>
<td>$p_{31}$</td>
<td>$p_{32}$</td>
<td>$p_{33}$</td>
</tr>
</tbody>
</table>
</div>
<p><strong>第二步：根据第一个条件$P(X_1X_2=0)=1$ 排除所有概率为0的点</strong></p>
<p>已知 $P(X<em>1X_2=0)=1$ ,则 $p</em>{11}=p<em>{13}=p</em>{31}=p_{33}=0$</p>
<p><strong>第三步：根据边际分布列求解方程组</strong></p>
<p>又$P(X<em>1=-1)=0.25=p</em>{11}+p<em>{12}+p</em>{13}$ 所以 $p_{12}=0.25$</p>
<p>同理$P(X<em>1=1)=0.25 =p</em>{31}+p<em>{32}+p</em>{33}$, 所以$p_{32}=0.25$ </p>
<p>$P(X<em>2=-1)=0.25=P(X_2=1) $ 所以$p</em>{21}=p_{23}=0.25$ </p>
<p>现在只剩下$p<em>{22}$未知，根据正则性可以推断$p</em>{22}=0$ </p>
<p><strong>第四步：补全联合分布列并按要求求解</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>下$X_1$/右$X_2$</th>
<th>-1</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>-1</td>
<td>0</td>
<td>0.25</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0.25</td>
<td>0</td>
<td>0.25</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0.25</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>$P(X<em>1=X_2)=p</em>{11}+p<em>{22}+p</em>{33}=0$ </p>
<h1 id="边际分布与随机变量的独立性"><a href="#边际分布与随机变量的独立性" class="headerlink" title="边际分布与随机变量的独立性"></a>边际分布与随机变量的独立性</h1><p>如果在二维随机变量$(X,Y)$ 的联合分布函数 $F(x,y)$ 中令 $y\rightarrow \infty$ ,由于 ${Y&lt;\infty}$ 是必然事件，故：</p>
<p>$\lim\limits_{y\rightarrow\infty} F(x,y) = P(X\leq x,Y\leq y) = P(X\leq x)$ </p>
<p>这是由 $(X,Y)$ 的联合分布函数 $F(x,y)$ 求得的X的分布函数，被称为 X 的边际分布。记为 $F_X(x)=F(x,\infty)$ </p>
<p>类似的，在 $F(x,y)$ 中令 $x\rightarrow \infty$ ，可得$Y$ 的边际分布。$F_Y(y) = F(\infty,y)$</p>
<h3 id="边际分布列"><a href="#边际分布列" class="headerlink" title="边际分布列"></a>边际分布列</h3><p>在二元离散随机变量 $(X,Y)$ 的联合分布 ${P(X=x_1,Y = y_i)}$ 中，对 j 求和所得的分布列：</p>
<p>$\sum_{j=1}^\infty P(X=x_i,Y=y_i)=P(X=x_i),i=1,2\cdots$ 被称为 X 的边际分布列。 </p>
<p>类似的 $\sum_{j=1}^\infty P(X=x_i,Y=y_i)=P(Y=y_i),i=1,2\cdots$ 被称为 Y 的边际分布列</p>
<p>我们可以列一个表来求联合分布列和边际分布列</p>
<p><img src="/2021/04/04/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F3-1-3-3/2.jpg" style="zoom:80%;"></p>
<p>我们对联合分布列的每行每列求和就得到了关于 X和Y的边际分布列。</p>
<h3 id="边际密度函数"><a href="#边际密度函数" class="headerlink" title="边际密度函数"></a>边际密度函数</h3><p>如果二维连续随机变量 $(X,Y)$ 的联合密度函数为 $p(x,y)$ </p>
<p>$F<em>X(x)=F(x,\infty) = \int</em>{-\infty}^x(\int<em>{-\infty}^{\infty}p(u,v)dv)du =\int</em>{-\infty}^x p_X(u)du$    </p>
<p>$F<em>Y(y)=F(\infty,y) = \int</em>{-\infty}^y(\int<em>{-\infty}^{\infty}p(u,v)dv)du =\int</em>{-\infty}^y p_Y(v)dv$</p>
<p>将其分别求导得到：$p_X(x)$和$p_Y(y)$     分别为：</p>
<p>$p<em>X(x)=\int</em>{-\infty}^{\infty}p(x,y)dy$ </p>
<p>$p<em>Y(y)=\int</em>{-\infty}^{\infty} p(x,y)dx$ </p>
<p>$p_X(x)$ 为 X 的边际密度函数，$p_Y(y)$ 为y的边际密度函数</p>
<p>由联合密度函数求边际密度函数时，要注意<strong>积分区域的确定</strong>。<img src="/2021/04/04/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F3-1-3-3/3.jpg" style="zoom:80%;"></p>
<p><img src="/2021/04/04/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F3-1-3-3/4.jpg" style="zoom:80%;"></p>
<h3 id="常见多维分布的边际分布"><a href="#常见多维分布的边际分布" class="headerlink" title="常见多维分布的边际分布"></a>常见多维分布的边际分布</h3><h4 id="多维分布的边际分布"><a href="#多维分布的边际分布" class="headerlink" title="多维分布的边际分布"></a>多维分布的边际分布</h4><p>这时候，三项分布实际上是二维随机变量 $(X_1,X_2)$ 的分布。</p>
<p>我们可以列出密度函数： </p>
<p><img src="/2021/04/04/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F3-1-3-3/3.png" style="zoom:80%;"></p>
<p>那么，三项分布的边际分布等于什么？我们来算一下：</p>
<p><img src="/2021/04/04/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F3-1-3-3/8.png" style="zoom:80%;"></p>
<h4 id="二维指数分布的边际分布"><a href="#二维指数分布的边际分布" class="headerlink" title="二维指数分布的边际分布"></a>二维指数分布的边际分布</h4><p>设$(X_1,X_2)$服从二维指数分布，其 Joint CDF为： </p>
<script type="math/tex; mode=display">
F(X_1,X_2)=\begin{cases}1-e^{-x_1}-e^{-x_2}+e^{-x_1-x_2-\lambda x_1x_2} \\ \\ 0 ~~其他\end{cases}</script><p>求其边际分布的密度函数</p>
<script type="math/tex; mode=display">
F_{X_1}(x_1)=F(X_1,+\infty) = \lim\limits_{x\rightarrow\infty}(1-e^{x_1}-e^{x_2}+e^{-x_1-x_2-\lambda x_1x_2}) = 1-e^{-x_1}</script><h4 id="二维正态函数的边际分布"><a href="#二维正态函数的边际分布" class="headerlink" title="二维正态函数的边际分布"></a>二维正态函数的边际分布</h4><p>首先我们定义二元正态分布 $(X,Y)\sim N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)$ ，其中 $-\infty &lt;\mu_1,\mu_2&lt;\infty , \sigma_1,\sigma_2&gt;0,-1\leq \rho\leq 1$ </p>
<p>那么这个其 Joint PDF 为</p>
<script type="math/tex; mode=display">
p(x,y) = \frac{1}{2\pi\sigma_1\sigma_2\sqrt{1-\rho^2}} \exp\{-\frac{1}{2(1-\rho^2)}[\frac{(x-\mu_1)^2}{\sigma_1^2}-2\rho\frac{(x-\mu_1)(y-\mu_2)}{\sigma_1\sigma_2}+\frac{(y-\mu_2)^2}{\sigma_2^2}]\}</script><p>求其编辑分布，先来关注它的指数部分，可以改写成</p>
<script type="math/tex; mode=display">
-\frac{1}{2}(\rho\frac{x-\mu_1}{\sigma_1\sqrt{1-\rho^2}}-\frac{y-\mu_2}{\sigma_2\sqrt{1-\rho^2}})^2-\frac{(x-\mu_1)^2}{2\sigma_1^2}</script><p>然后对其求积分，根据边际分布的定义可知</p>
<script type="math/tex; mode=display">
F_X(x) = \int_{-\infty}^{\infty}p(x,y)dy</script><p>那么 </p>
<script type="math/tex; mode=display">
\int_{-\infty}^{\infty} \exp\{-\frac{1}{2}(\rho\frac{x-\mu_1}{\sigma_1\sqrt{1-\rho^2}}-\frac{y-\mu_2}{\sigma_2\sqrt{1-\rho^2}})^2-\frac{(x-\mu_1)^2}{2\sigma_1^2}\}dy</script><p>后面部分和y无关</p>
<p>令 </p>
<script type="math/tex; mode=display">
t =\rho\frac{x-\mu_1}{\sigma_1\sqrt{1-\rho^2}}-\frac{y-\mu_2}{\sigma_2\sqrt{1-\rho^2}}</script><p>则</p>
<script type="math/tex; mode=display">
{d(t)} = -(\sigma_2\sqrt{1-\rho^2})/\sigma_2^2({1-\rho^2})</script><script type="math/tex; mode=display">
p_X(x)=\frac{1}{2\pi\sigma_1\sigma_2\sqrt{1-\rho^2}}\exp\{-\frac{(x-\mu_1)^2}{2\sigma_1^2}\}\sigma_2\sqrt{1-\rho^2}\int_{-\infty}^{\infty} {-\frac{t^2}2}dt</script><p>已知 $\int_{-\infty}^{\infty}-\frac{t^2}{2} dt = \sqrt{2\pi}$ </p>
<p>所以原式可写为：</p>
<script type="math/tex; mode=display">
p_X(x)=\frac{1}{\sqrt{2\pi}\sigma_1}\exp\{-\frac{(x-\mu_1)^2}{2\sigma_1^2}\}</script><p>这就是一维正态分布$N(\mu_1,\sigma_1^2)$ 的密度函数。</p>
<p>从上面的证明可以看出：</p>
<ul>
<li>二维正态分布的边际分布中，是不含有参数$\rho$的</li>
<li>$N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2.0.1)$ 和 $N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2.0.2)$ 的边际分布是相同的</li>
<li>具有相同边际分布的多维联合分布可以使不同的。</li>
</ul>
<h3 id="随机变量间的独立性"><a href="#随机变量间的独立性" class="headerlink" title="随机变量间的独立性"></a>随机变量间的独立性</h3><p>设n维随机变量$(X<em>1,X_2,\cdots,X_n)$的联合分布函数为$F(x_1,x_2,\cdots,x_n)$ ,$F_i(x_i)$为$X_i$ 的边际分布函数。 如果对任意n个实数$x_1,x_2,\cdots,x_n$ 有 $F(x_1,x_2,\cdots,x_n)=\prod\limits</em>{i=1}^nF_i(x_i)$   则称$X_1,X_2,\cdots,X_n$相互独立</p>
<p>那么在离散和连续的场合我们就可以这么来写：</p>
<script type="math/tex; mode=display">
\begin{cases}P(X_1=x_1,X_2=x_2,\cdots,X_n=x_n)=\prod\limits_{i=1}^nP(X_i=x_i) ~~在离散场合\\ \\ P(x_1,x_2,\cdots,x_n)=\prod\limits_{i=1}^np_i(x_i) ~~在连续场合\end{cases}</script><p>则称$X_1,X_2,\cdots,X_n$相互独立。</p>
<p>之前，由联合分布可以求出边际分布，但是由边际分布不一定能求出联合分布。但是如果我们知道了随机变量间是相互独立的，则可以<strong>由边际分布的乘积求出联合分布</strong>。  同样的，现在我们也可以通过计算<strong>联合分布</strong>是否等于各个随机变量<strong>边际分布</strong> 的乘积来判断随机变量之间<strong>是否相互独立</strong>。</p>
<h1 id="多维随机变量函数的分布"><a href="#多维随机变量函数的分布" class="headerlink" title="多维随机变量函数的分布"></a>多维随机变量函数的分布</h1><h4 id="例题1：-当Z为离散可列的随机变量时"><a href="#例题1：-当Z为离散可列的随机变量时" class="headerlink" title="例题1： 当Z为离散可列的随机变量时"></a>例题1： 当Z为离散可列的随机变量时</h4><p>设X和Y是相互独立的随机变量，且 $X\sim Exp(\lambda),Y\sim Exp{(\mu)}$ 如果定义随机变量 </p>
<script type="math/tex; mode=display">
Z=\begin{cases}1 ,~~X\leq Y\\ \\ 0 ~~,X>Y\end{cases}</script><p>求 Z 的分布列。</p>
<p><strong>第一步：列出联合随机变量：</strong> </p>
<p>因为 $X$ 和 $Y$ 相互独立，所以 $p(x,y)=p_X(x)p_Y(y)=\begin{cases}\lambda\mu e^{-\lambda x-\mu y} ,~~X\leq Y\ \ 0 ~~,X&gt;Y\end{cases}$</p>
<p><strong>第二步：列出Z的取值</strong></p>
<p>在说到一元离散随机变量函数的分布时，当 $Y=g(X)$ 时，Y的分布列就按照Y的取值 一一列举,并根据取值范围计算。在多元情况下也是这样。这里 Z 有两个取值：</p>
<script type="math/tex; mode=display">
p(Z=1)=p(X\leq Y)=\int_0^\infty\int_x^\infty \lambda\mu e^{-\lambda x-\mu y}dydx\\
=\int_0^\infty\lambda\mu e^{-\lambda x}dx\int_x^\infty e^{-\mu y}dy\\
=\int_0^\infty\lambda\mu e^{-\lambda x}\frac{-1}{\mu}(0-e^{-\mu x})dx\\
=\lambda \int_0^\infty e^{-\lambda x-\mu x}dx\\
=\frac{\lambda}{\lambda+\mu}</script><p>关于$p(Z=0)$和 $p(Z=1)$的原理是一样的，但是这里可以直接利用 $1-P(X\leq Y)$ 计算，即 $\frac{\mu}{\lambda+\mu}$</p>
<p>设$(X_1,X_2,\cdots,X_n)$ 为 n 维随机变量，则 $(X_1,X_2,\cdots,X_n)$ 的函数$Y=g(X_1,X_2,\cdots,X_n)$  是一维随机变量。</p>
<p>现在问题就是已经知道了 $(X_1,X_2,\cdots,X_n)’$ 的联合分布/分布列/pdf,怎么求 $Y=g(X_1,X_2,\cdots,X_n)$ 的分布</p>
<h4 id="例题2：-当Z为连续随机变量时"><a href="#例题2：-当Z为连续随机变量时" class="headerlink" title="例题2： 当Z为连续随机变量时"></a>例题2： 当Z为连续随机变量时</h4><p>设X与Y的联合密度函数为 </p>
<script type="math/tex; mode=display">
p(x,y)=\begin{cases}e^{-x-y} ,~~x>0,y>0\\ \\ 0 ~~,else\end{cases}</script><p>求以下随机变量的<strong>密度函数：</strong> $Z=(X+Y)/2$ , $Z=Y-X$</p>
<p>对于 $Z=(X+Y)/2 $ 比较简单</p>
<p><strong>第一步：理清思路</strong></p>
<p>首先我们要画出关键词，这里要我们求的是密度函数而不是分布函数。 那么$P_Z(z)$怎么求？可以先求出 $F_Z(z)$ 再根据求导算出。</p>
<p><strong>第二步： 给出Z的取值范围</strong></p>
<p>已知 $x&gt;0,y&gt;0$ 又有 $Z=(X+Y)/2$ 因此 $z&gt;0$</p>
<p><strong>第三步：求出Z的分布函数</strong></p>
<p>$F_Z(z)=P_Z(Z\leq z)=P_Z(X+Y\leq 2Z)$  </p>
<p>已知x，y的联合分布，求$X+Y\leq 2Z$ 这种套路是我们常见的——使用画图后求积分即可。 因此</p>
<script type="math/tex; mode=display">
F_Z(z)=P_Z(X+Y\leq2Z)=\int_0^{2z}\int_0^{2z-x}e^{-x-y} dydx =1-e^{-2z}-2ze^{-2z} ，z>0</script><p><strong>第三步： 求密度函数</strong> $p_Z(z)$</p>
<p>$p_Z(z)=F_Z’(z)=2e^{-2z}+4ze^{-2z}-2e^{-2z}=4ze^{-2z},z&gt;0$ </p>
<p>对于$Z=Y-X$ ,需要做分类讨论</p>
<p><strong>第一步：确定Z的取值范围</strong></p>
<p>因为 $Z=Y-X$, 则 Z 可为实数轴上的任意数。</p>
<p><strong>第二步：分类讨论，情况1</strong></p>
<p>当 $Z\leq 0$时，说明 $Y\leq X$</p>
<p>$F_Z(z)=P_Z(Z\leq z)=P(Y-X\leq z)$ </p>
<p>通过画图可知,原式等于：</p>
<script type="math/tex; mode=display">
\int_{-z}^\infty\int_0^{z+x} e^{-y-x} dydx=\frac{1}{2}e^z</script><p>由此， $p_Z(z)=F_Z’(z)=\frac{1}{2}e^z$ </p>
<p><strong>第三步：分类讨论，情况2</strong></p>
<p>当 $Z&gt; 0$时，说明 $Y&gt; X$ </p>
<p>$F_Z(z)=P_Z(Z\leq z)=P(Y-X\leq z)$ </p>
<p>通过画图可知：</p>
<script type="math/tex; mode=display">
\int_{0}^\infty\int_x^{z+x} e^{-y-x} dydx=\frac{1}{2}(1-e^{-z}), z\in R</script><p>由此， $p_Z(z)=F’_Z(z)=\frac{1}{2}e^{-z}， z\in R$</p>
<p>综上可得： $p_Z(z)= e^{-|z|}/2, z\in R$</p>
<h2 id="卷积公式"><a href="#卷积公式" class="headerlink" title="卷积公式"></a>卷积公式</h2><h3 id="在离散场合下"><a href="#在离散场合下" class="headerlink" title="在离散场合下"></a>在离散场合下</h3><p>设X与Y是两个<strong>相互独立的离散随机变量</strong>。取值范围为0，1，2 。$Z=X+Y$ ,那么事件 ${Z=k}$ 是如下诸互不相容事件的并：</p>
<script type="math/tex; mode=display">
\{X=i,Y=k-i\}， ~~ i=0,1,\cdots,k</script><p>在考虑到独立性，则对任意非负整数 k， 有 </p>
<p>$P(Z=k)=\sum\limits_{i=0}^k P(X=i)P(Y=k-i)$ </p>
<p>这个概率等式被称为离散场合下的卷积公式</p>
<h3 id="在连续场合下"><a href="#在连续场合下" class="headerlink" title="在连续场合下"></a>在连续场合下</h3><p>设X与Y是<strong>两个相互独立的连续随机变量</strong>，其密度函数分数分别$p_X(x)$和$p_Y(y)$ ，则其和 $Z=X+Y$ 的密度函数为: </p>
<script type="math/tex; mode=display">
p_Z(z)=\int_{-\infty}^{\infty} p_X(z-y)p_Y(y)dy = \int_{-\infty}^{\infty} p_X(x)p_Y(z-x)dx</script><h2 id="卷积公式在离散场合下的应用"><a href="#卷积公式在离散场合下的应用" class="headerlink" title="卷积公式在离散场合下的应用"></a>卷积公式在离散场合下的应用</h2><ol>
<li>当$(X_1,X_2,\cdots,X_n)$ 的所有可能取值比较少的时候，可以将 $Y$ 值一一列出，然后再合并就可以得出结果。</li>
</ol>
<p><img src="/2021/04/04/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F3-1-3-3/5.jpg" style="zoom:80%;"></p>
<p><img src="/2021/04/04/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F3-1-3-3/6.jpg" style="zoom:80%;"></p>
<p><img src="/2021/04/04/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F3-1-3-3/7.jpg" style="zoom:80%;"></p>
<h3 id="泊松分布的可加性"><a href="#泊松分布的可加性" class="headerlink" title="泊松分布的可加性"></a>泊松分布的可加性</h3><p>设随机变量$X\sim P(\lambda_1)$, $Y\sim P(\lambda_2)$ ，且X与Y相互独立，证明： $Z=X+Y\sim P(\lambda_1+\lambda_2)$ </p>
<script type="math/tex; mode=display">
P(Z=k) =\sum\limits_{i=0}^k(\frac{\lambda_1^i}{i!}e^{-\lambda_1})(\frac{\lambda_2^{k-i}}{(k-i)!}e^{-\lambda_2}) \\</script><p>合并同类项，先把常数取出，然后将后面的求和部分配方成一个二项分布。</p>
<script type="math/tex; mode=display">
=\frac{e^{-(\lambda_1+\lambda_2)}{(\lambda_1+\lambda_2)^k}}{k!}\sum_{i=0}^k\frac{k!}{i!(k-i)!}(\frac{\lambda_1}{\lambda_1+\lambda_2})^i(\frac{\lambda_2}{\lambda_1+\lambda_2})^{k-i}</script><p>前面乘了 $(\lambda_1+\lambda_2)^k$,后面除了 $(\lambda_1+\lambda_2)^k$ ,前面除了 $k!$, 后面乘$k!$ ，目的就是把求和部分当成是一个二项分布的pdf，根据pdf性质可知求和部分的值为1.</p>
<p>所以最终得到 ： </p>
<script type="math/tex; mode=display">
=\frac{(\lambda_1+\lambda_2)^k}{k!}e^{-(\lambda_1+\lambda_2)}</script><p>也就是说，泊松分布的卷积仍然是泊松分布。这是一个新的泊松分布，记为  $P(\lambda_1)*P(\lambda_2)=P(\lambda_1+\lambda_2)$ ,</p>
<p>这个性质可以推广到有限个独立泊松变量之和的分布上去：</p>
<script type="math/tex; mode=display">
P(\lambda_1)*P(\lambda_2)*\cdots P(\lambda_n) =P(\lambda_1+\lambda_2+\cdots+\lambda_n)</script><p>特别的，当 $\lambda_1=\cdots=\lambda_n$ 时，有 $p(\lambda)<em>p(\lambda)\cdots</em>p(\lambda)=p(n\lambda)$ </p>
<h3 id="二项分布的可加性"><a href="#二项分布的可加性" class="headerlink" title="二项分布的可加性"></a>二项分布的可加性</h3><p>事实上，不仅仅是泊松分布有可加性，二项分布也具有可加性：设随机变量$X\sim b(n,p),Y\sim b(m,p)$ 且X与Y独立，那么 $Z=X+Y\sim b(n+m,p)$ </p>
<p>这个性质也可以推广到有限个场合：</p>
<script type="math/tex; mode=display">
b(n_1,p)*b(n_2,p)*\cdots *b(n_k,p)=b(n_1+\cdots+n_k,p)</script><p>特别的，当 $n_1=n_2=\cdots=n_k=1$ 时，$b(1,p)<em>b(1,p)\cdots</em>b(1,p)=b(k,p)$</p>
<p>这表明，如果 $X<em>1,X_2,\cdots X_n$ 独立同分布，都服从 $b(1,p)$ 分布，则其和 $\sum</em>{i=1}^n X_i\sim b(n,p)$ </p>
<p>或者说，服从二项分布 $b(n,p)$ 的随机变量都可以分解为 n 个相互独立的 $0-1$ 分布的随机变量之和。</p>
<h2 id="卷积公式在连续场合下的应用"><a href="#卷积公式在连续场合下的应用" class="headerlink" title="卷积公式在连续场合下的应用"></a>卷积公式在连续场合下的应用</h2><h3 id="正态分布的可加性"><a href="#正态分布的可加性" class="headerlink" title="正态分布的可加性"></a>正态分布的可加性</h3><p>设随机变量 $X\sim N(\mu_1,\sigma_1^2), Y\sim N(\mu_2.\sigma_2^2)$  ,且 X 与 Y 互相独立，那么$Z=X+Y\sim N(\mu_1+\mu_2, \sigma_1^2+\sigma_2^2)$ </p>
<p>也就是说，两个独立的正态分布之和仍然为正态变量，其分布中的两个参数分别对应相加，即：</p>
<script type="math/tex; mode=display">
N(\mu_1,\sigma_1^2)*N(\mu_2,\sigma_2^2)=N(\mu_1+\mu_2,\sigma_1^2+\sigma_2^2)</script><p>证明：首先可以知道 Z=X+Y的取值范围是 $(-\infty,\infty)$ ,那么利用卷积公式可以得到：</p>
<script type="math/tex; mode=display">
p_Z(z)=\int_{-\infty}^\infty p_Y(y)p_X(z-y)dy\\
=\frac{1}{2\pi\sigma_1\sigma_2}\int_{-\infty}^{\infty} \exp\{-\frac{1}{2}[\frac{(z-y-\mu_1)^2}{\sigma_1^2}-\frac{(y-\mu_2)^2}{\sigma_2^2}]\}\\</script><p>将积分式子中的指数部分按照y的幂展开，再合并同类项：</p>
<script type="math/tex; mode=display">
\frac{(z-y-\mu_1)^2}{\sigma_1^2}-\frac{(y-\mu_2)^2}{\sigma_2^2} =</script><p>显然，这个结论可以推广到有限个独立正态变量之和的场合</p>
<p>另外，我们还知道，若随机变量 $X\sim N(\mu,\sigma^2)$ ,则对任意非零实数a有 $aX\sim N(a\mu,a^2\mu^2)$ 。</p>
<p>因此，我们可以得到一个<strong>重要结论</strong>， 即</p>
<script type="math/tex; mode=display">
a_1X_1+a_2X_2+\cdots+a_nX_n \sim N(\mu_0,\sigma_0^2)</script><p>若$X_i\sim N(\mu_1,\sigma_1^2),i=1,2\cdots,n$则参数 $\mu_0$与 $\sigma_0^2$ 分别为：</p>
<script type="math/tex; mode=display">
\mu_0 = \sum_{i=1}^n a_i\mu_i\\ \sigma_0^2 = \sum_{i=1}^n a_i^2\sigma_i^2</script><p>譬如， 若 $X\sim N(-3,1),Y\sim N(2,1)$ 且 X与Y 独立，则：</p>
<p>$Z=X-2Y+7 \sim N(-3-2<em>2+7,1+2^2</em>2)=N(0,5)$</p>
<h3 id="伽马分布的可加性"><a href="#伽马分布的可加性" class="headerlink" title="伽马分布的可加性"></a>伽马分布的可加性</h3><p>设随机变量 $X\sim Ga(\alpha_1,\lambda)~,~ Y\sim Ga(\alpha_2,\lambda)$ , 且X与Y 独立，则 $Z=X+Y\sim Ga(\alpha_1+\alpha_2,\lambda)$ </p>
<p>这个结论表明，两个尺度参数相同的独立的伽马变量之和仍然是伽马变量，其尺度参数不变, 而形状参数相加。即</p>
<script type="math/tex; mode=display">
Ga(\alpha_1,\lambda)*Ga(\alpha_2,\lambda) = Ga(\alpha_1+\alpha_2,\lambda)</script><script type="math/tex; mode=display">
p_Z(z)=\int_{-\infty}^\infty p_Y(y)p_X(z-y)dy\\
=\frac{\lambda^{\alpha_1+\alpha_2}}{\Gamma(\alpha_1)\Gamma(\alpha_2)}\int_0^z (z-y)^{\alpha_1-1}e^{-\lambda(z-y)}y^{\alpha_2-1}e^{-\lambda y} dy \\
=\frac{\lambda^{\alpha_1+\alpha_2}}{\Gamma(\alpha_1)\Gamma(\alpha_2)} e^{-\lambda z} \int_0^z(z-y)^{\alpha_1-1}y^{\alpha_2-1}dy\\</script><p>令 $y=zt$ ，则$dy = zdt$ 带入原式可得 </p>
<script type="math/tex; mode=display">
=\frac{\lambda^{\alpha_1+\alpha_2}}{\Gamma(\alpha_1)\Gamma(\alpha_2)} e^{-\lambda z} z^{\alpha_1+\alpha_2-1}\int_0^1(1-t)^{\alpha_1-1}t^{\alpha_2-1}dt</script><p>我们看到这个积分的式子和 贝塔函数是一模一样的，贝塔函数 $B(\alpha_1,\alpha_2)=\frac{\Gamma(\alpha_1)\Gamma(\alpha_2)}{\Gamma(\alpha_1+\alpha_2)}$</p>
<p>最后，相乘我们得到：</p>
<script type="math/tex; mode=display">
\frac{\lambda^{\alpha_1+\alpha_2}}{\Gamma(\alpha_1+\alpha_2)} z^{\alpha_1+\alpha_2-1}e^{-\lambda z}</script><p>很明显，这个式子是一个 伽马分布 ，符合 $Ga(\alpha_1+\alpha_2,\lambda)$</p>
<p>这个结论可以推广到有限个尺度参数相同的独立伽马变量之和上</p>
<h4 id="特殊的：指数分布"><a href="#特殊的：指数分布" class="headerlink" title="特殊的：指数分布"></a>特殊的：指数分布</h4><p>指数分布是 $\alpha=1$ 的伽马分布，即 $Exp(\lambda)=Ga(1,\lambda)$ </p>
<p>那么m个独立同分布的指数变量之和是一个伽马变量 $Exp(\lambda)*Exp(\lambda)\cdots Exp(\lambda)=Ga(m,\lambda)$  。也就是说指数分布不满足可加性</p>
<h4 id="特殊的：-卡方分布"><a href="#特殊的：-卡方分布" class="headerlink" title="特殊的： 卡方分布"></a>特殊的： 卡方分布</h4><p>卡方分布： $\chi^2(n)= Ga(\frac{n}{2},\frac{1}{2})$</p>
<p>那么 m个独立的$\chi^2$变量之和为 $\chi^2$ 变量，即</p>
<script type="math/tex; mode=display">
\chi^2(n_1)*\chi^2(n_2)\cdots\chi^2(n_m)=\chi^2(n_1+n_2+\cdots+n_m)</script><h2 id="极值分布"><a href="#极值分布" class="headerlink" title="极值分布"></a>极值分布</h2><p>已知$x_1,x_2,\cdots,x_n$</p>
<p>现在令 $Y=\max{x_1,x_2,\cdots,x_n},Z=\min{x_1,x_2,\cdots,x_n}$</p>
<p>问Y与Z的分布,这就是极值分布</p>
<p>乍一看似乎极值没啥用。但是在现实生活中极值分布的使用场景非常广泛：</p>
<p>今年夏天最高温会不会是40摄氏度，水坝的高度必须覆盖水库的最高水位之类的问题。</p>
<p>极值分布与相互独立的随机变量$X_i$ 的分布有很大的关系。</p>
<h3 id="最大值分布"><a href="#最大值分布" class="headerlink" title="最大值分布"></a>最大值分布</h3><h4 id="当-X-i-sim-F-i-x-i-1-2-cdots-n-时"><a href="#当-X-i-sim-F-i-x-i-1-2-cdots-n-时" class="headerlink" title="当 $X_i\sim F_i(x)$, $i=1,2\cdots,n$ 时"></a>当 $X_i\sim F_i(x)$, $i=1,2\cdots,n$ 时</h4><p>因为 $X_1,X_2\cdots,X_n$的最大值小于等于 y，那么这就说明 $X_1,X_2\cdots,X_n $中的每一个都$\leq y$，又$X_i$是独立的，那么联合分布就可以表示为边际分布的乘积。</p>
<p>此时，$Y=\max{X_1,X_2,\cdots,X_n}$ 的分布函数为：</p>
<script type="math/tex; mode=display">
F_Y(y)= P(max\{X_1,X_2\cdots,X_n\}\leq y)=P(X_1\leq y,X_2\leq y,\cdots,X_n\leq y)\\
=P(X_1\leq y)P(X_2\leq y)\cdots P(X_n\leq y)=\prod_{i=1}^n F_i(y)</script><h4 id="当-X-i-sim-F-x-，即-所有-X-i-同分布时"><a href="#当-X-i-sim-F-x-，即-所有-X-i-同分布时" class="headerlink" title="当$X_i\sim F(x)$ ，即 所有$X_i$同分布时"></a>当$X_i\sim F(x)$ ，即 所有$X_i$同分布时</h4><p>此时，$Y=\max{X_1,X_2,\cdots,X_n}$ 的分布函数为：</p>
<p>这是第一种情况的特殊状况，即 $F_Y(y)=[F(y)]^n$</p>
<h4 id="当-X-i-为连续随机变量且同分布时，密度为-p-x"><a href="#当-X-i-为连续随机变量且同分布时，密度为-p-x" class="headerlink" title="当$X_i$为连续随机变量且同分布时，密度为 $p(x)$"></a>当$X_i$为连续随机变量且同分布时，密度为 $p(x)$</h4><p>此时，$Y=\max{X_1,X_2,\cdots,X_n}$ 的分布函数为：</p>
<p>这也是一种特殊情况， $F_Y(y)=[F(y)]^n$， 因为$X_i$是连续随机变量，那么我们也可以求 $Y$ 的 pdf为$p_Y(y)=n[F(y)]^{n-1}p(y)$ </p>
<h4 id="当-X-i-sim-Exp-lambda-i-1-2-cdots-n-时候"><a href="#当-X-i-sim-Exp-lambda-i-1-2-cdots-n-时候" class="headerlink" title="当 $X_i\sim Exp(\lambda),i=1,2\cdots,n$ 时候"></a>当 $X_i\sim Exp(\lambda),i=1,2\cdots,n$ 时候</h4><p>此时，$Y=\max{X_1,X_2,\cdots,X_n}$ 的分布函数为：</p>
<p>这符合$X_i$为连续随机变量且同分布的情况，因此已知 $p_X(x)=\lambda e^{-\lambda}$ 对其求积分得到 $F_X(x)=1-e^{-\lambda x}$</p>
<script type="math/tex; mode=display">
F_Y(y)=\begin{cases} 0 ,~~y<0\\ \\ (1-e^{-\lambda x})^n,~~y\geq 0 \end{cases}</script><p>然后对$F_Y(y)$求导，可以得到：</p>
<script type="math/tex; mode=display">
p_Y(y)=\begin{cases} 0 ,~~y<0\\ \\ n(1-e^{-\lambda x})^{n-1}\lambda e^{-\lambda x },~~y\geq 0 \end{cases}</script><h3 id="最小值分布"><a href="#最小值分布" class="headerlink" title="最小值分布"></a>最小值分布</h3><h4 id="当-X-i-sim-F-i-x-i-1-2-cdots-n-时-1"><a href="#当-X-i-sim-F-i-x-i-1-2-cdots-n-时-1" class="headerlink" title="当 $X_i\sim F_i(x)$, $i=1,2\cdots,n$ 时"></a>当 $X_i\sim F_i(x)$, $i=1,2\cdots,n$ 时</h4><p>求最小值分布的时候我们要做多次变换，但是只要牢记 $F_X(x)= P(X\leq x)=1-P(X&gt;x)$即可</p>
<p>此时，$Z=\min{X_1,X_2,\cdots,X_n}$ 的分布函数为：</p>
<script type="math/tex; mode=display">
F_Z(z)=P(\min\{X_i,X_2,\cdots,X_n\}\leq z)\\
=1-P(min\{X_1,X_2\cdots,X_n\}> z)\\
=1-P(X_1> z,X_2> z,\cdots,X_n> z)\\
=1-P(X_1>z)P(X_2>z)\cdots P(X_n>z)\\
=1-\prod_{i=1}^n[1-F_i(z)]</script><h4 id="当-X-i-sim-F-x-，即-所有-X-i-同分布时-1"><a href="#当-X-i-sim-F-x-，即-所有-X-i-同分布时-1" class="headerlink" title="当$X_i\sim F(x)$ ，即 所有$X_i$同分布时"></a>当$X_i\sim F(x)$ ，即 所有$X_i$同分布时</h4><p>此时，$Z=\min{X_1,X_2,\cdots,X_n}$ 的分布函数为：</p>
<p>将$X_i$的共通分布函数$F(x)$ 代入上式，可得：</p>
<p>$F_Z(z)=1-[1-F_i(z)]^n$</p>
<h4 id="当-X-i-为连续随机变量且同分布时，密度为-p-x-1"><a href="#当-X-i-为连续随机变量且同分布时，密度为-p-x-1" class="headerlink" title="当$X_i$为连续随机变量且同分布时，密度为 $p(x)$"></a>当$X_i$为连续随机变量且同分布时，密度为 $p(x)$</h4><p>此时，$Y=\min{X_1,X_2,\cdots,X_n}$ 的分布函数为：$F_Z(z)=1-[1-F_i(z)]^n$</p>
<p>另外，对$F_Z(z)$求导可以获得 $p_Z(z)$:</p>
<p>$p_Z(z)=F’_z(z)=n[1-F(z)]^{n-1}p(z)$</p>
<h4 id="当-X-i-sim-Exp-lambda-i-1-2-cdots-n-时候-1"><a href="#当-X-i-sim-Exp-lambda-i-1-2-cdots-n-时候-1" class="headerlink" title="当 $X_i\sim Exp(\lambda),i=1,2\cdots,n$ 时候"></a>当 $X_i\sim Exp(\lambda),i=1,2\cdots,n$ 时候</h4><p>此时，$Y=\min{X_1,X_2,\cdots,X_n}$ 的分布函数为：</p>
<p>带入上面的式子 ，可以得到：</p>
<p>这符合$X_i$为连续随机变量且同分布的情况，因此已知 $p_X(x)=\lambda e^{-\lambda}$ 对其求积分得到 $F_X(x)=1-e^{-\lambda x}$</p>
<script type="math/tex; mode=display">
F_Y(y)=\begin{cases} 0 ,~~y<0\\ \\ 1-\prod_{i=1}^n[1-1+e^{\lambda x}],~~y\geq 0 \end{cases}=\begin{cases} 0 ,~~y<0\\ \\ 1-e^{\lambda xn},~~y\geq 0 \end{cases}</script><p>然后对$F_Y(y)$求导，可以得到：</p>
<script type="math/tex; mode=display">
p_Y(y)=\begin{cases} 0 ,~~y<0\\ \\ n\lambda e^{-n\lambda x} ~~,y>0\end{cases}</script><p>我们发现，当$X_i$ 服从参数为 $\lambda $ 的指数分布，则 $\max{X_1,X_2\cdots,X_n}$ 是不服从指数分布的，但是$\min{X_1,X_2\cdots,X_n}\sim Exp{(n\lambda)}$  是符合指数分布的。</p>
<h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p>关于极值分布，一般的题型<strong>求离散随机变量的最大/小值分布列</strong></p>
<p>随机变量的分布列的公式这里这样表示：</p>
<script type="math/tex; mode=display">
p_X(k) = F_X(k)-F_X(k-1) = P(X\leq k)-P(X\leq k-1)</script><p>这样，我们就可以通过求 $F_X(x)$ 来计算X的分布列。</p>
<h4 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h4><p>设随机变量X，Y独立同分布，那么当X服从几何分布，即$P(X=k)=(1-p)^{k-1}p,~k=1,2\cdots$ ，求随机变量$Z=\max{X,Y}$ 的分布列</p>
<p>这题要我们求$\max{X,Y}$的分布列，那么我们就可以用上面这个公式</p>
<p><strong>第一步：求出 X,Y 的密度函数和分布函数</strong> </p>
<p>已知 X,Y  的密度函数和分布函数</p>
<script type="math/tex; mode=display">
p_X(x)=(1-p)^{x-1}p,F_X(x)=P_X(X\leq x)=\sum_{i=1}^x(1-p)^{i-1}p =1-(1-p)^x</script><p><strong>第二步：求出Z的分布函数</strong> </p>
<p>因为$Z=\max{X,Y}$ ，$X,Y$又是独立同分布的，因此</p>
<script type="math/tex; mode=display">
F_Z(z)=[F(z)]^n=(1-(1-p)^x)^2,z=1,2\cdots</script><p><strong>第三步：求出Z的分布列</strong></p>
<script type="math/tex; mode=display">
P(Z=i)=P(Z\leq i)-P(Z\leq i-1)\\
=(1-(1-p)^i)^2-(1-(1-p)^{i-1})^2
=(1-p)^{i-1}p[2-(1-p)^{i-1}-(1-p)^{i}],i=1,2\cdots</script><p><em>ps:</em>  千万别忘了写上取值范围！！！</p>
<h4 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h4><p>假设高尔夫成绩是一个随机变量，其得分的分布是${101,\cdots,110}$ 上的均匀分布。 为了改进成绩，你决定将 3 天的<strong>最小分数</strong>作为你的分数X，即$X$等于 $\min{X_1,X_2,X_3}$ ,其中$X_i,i=1,2,3$ 表示三天的分数：求<strong>计算X的分布列</strong></p>
<p><strong>第一步：求出$X_i$ 的密度函数和分布函数 </strong> </p>
<p>已知 $X_i\sim U(101,110)$</p>
<script type="math/tex; mode=display">
p_{i}(x_i)=\begin{cases} \frac{1}{10} ,~~101\leq x\leq110\\ \\ 0 ~~其他 \end{cases}, F_{i}(x_i)=\begin{cases} \frac{x-100}{10},~~ 101\leq x\leq 110\\ \\ 0, 其他\end{cases}</script><p><strong>第二步：求 X 的分布函数</strong></p>
<p>因为$X_i$ 是独立同分布，那么 $X\sim \min{X_1,X_2,X_3}$ 的分布函数为：</p>
<script type="math/tex; mode=display">
1-[1-F(x)]^n=1-[1-\frac{x-100}{10}]^3=1-(\frac{110-x}{10})^3</script><script type="math/tex; mode=display">
F_X(x)=\begin{cases} 1-(\frac{110-x}{10})^3 ~~101\leq x\leq 110\\ \\ 0, x<101\\ \\1,x>110\end{cases}</script><p><strong>第三步：求X的分布列</strong></p>
<script type="math/tex; mode=display">
p_X(k) = F_X(k)-F_X(k-1)=\begin{cases} \frac{(111-k)^3-(110-k)^3}{1000},101\leq k\leq 110\\ \\ 0,其他\end{cases}</script><h2 id="变量变换法"><a href="#变量变换法" class="headerlink" title="变量变换法"></a>变量变换法</h2><p>设二维随机变量 $(X,Y)$ 的联合密度函数为 $p(x,y)$,那么如果函数</p>
<script type="math/tex; mode=display">
\begin{cases} u = g_1(x,y)\\ \\ v=g_2(x,y)\end{cases}</script><p>有连续偏导数，且存在唯一的反函数：</p>
<script type="math/tex; mode=display">
\begin{cases} x = x(u,v)\\ \\ y=y(u,v)\end{cases}</script><p>然后我们可以列出雅克比行列式：</p>
<script type="math/tex; mode=display">
J= \begin{vmatrix} \frac{\partial x}{\partial u} & \frac{\partial x}{\partial v} \\ \frac{\partial y}{\partial u} & \frac{\partial y}{\partial x} \end{vmatrix}</script><p>那么，若 </p>
<script type="math/tex; mode=display">
\begin{cases} U = g_1(X,Y)\\ \\ V=g_2(X,Y)\end{cases}</script><p>则 $(U,V)$ 的联合密度函数为 </p>
<script type="math/tex; mode=display">
p(u,v)=p(x(u,v),y(u,v))|J|</script><h3 id="例题1："><a href="#例题1：" class="headerlink" title="例题1："></a>例题1：</h3><p>设随机变量是 $X$ 与 $Y$ 的<strong>独立同分布</strong>，都服从正态分布 $N(\mu,\sigma^2)$。记 $\begin{cases} U = X+Y\ \ V=X- Y\end{cases}$,试求$(U,V)$的联合密度函数，且问 $U$和$V$ 是否独立？</p>
<p><strong>第一步：列出u,v的反函数</strong>:</p>
<p>已知 $\begin{cases} u = x+y\ \v=x-y\end{cases}$ , 则它的反函数$\begin{cases}x=\frac{u+v}{2}\ \ y=\frac{u-v} {2}\end{cases}$</p>
<p><strong>第二步：列出雅克比行列式</strong></p>
<script type="math/tex; mode=display">
J=  \begin{vmatrix} \frac{\partial x}{\partial u} & \frac{\partial x}{\partial v} \\ \frac{\partial y}{\partial u} & \frac{\partial y}{\partial x} \end{vmatrix} =  J^{-1}=\begin{vmatrix} \frac{\partial u}{\partial x} &\frac{\partial u}{\partial y} \\ \frac{\partial v}{\partial x}   &  \frac{\partial v}{\partial y} \end{vmatrix}  

=-\frac{1}{2}</script><p><strong>第三步：列出联合密度函数p(u,v)</strong></p>
<script type="math/tex; mode=display">
p(u,v)=p(x(u,v),y(u,v))|J| = p_X(\frac{u+v}{2})p_Y(\frac{u-v}{2})|-\frac{1}{2}|</script><script type="math/tex; mode=display">
=\frac{1}{2} \frac{1}{\sqrt{2\pi}\sigma}\exp\{-\frac{(\frac{u+v}{2}-\mu)^2}{2\sigma^2}\}\frac{1}{\sqrt{2\pi}\sigma}\exp\{-\frac{(\frac{u-v}{2}-\mu)^2}{2\sigma^2}\}\\
=\frac{1}{4\pi\sigma^2}\exp\{-\frac{(u-2\mu)^2+v^2}{4\sigma^2}\}</script><p>这是二元正态分布$N(2\mu,0,2\sigma^2,2\sigma^2,0)$的密度函数，其边际分布为 $U\sim N(2\mu,2\sigma^2)$, $V\sim N(0,2\sigma^2)$ </p>
<p>符合 $p(u,v)=p(u)p(v)$ ，因此 $U,V$相互独立。</p>
<h3 id="例题2："><a href="#例题2：" class="headerlink" title="例题2："></a>例题2：</h3><p>设随机变量X与Y相互独立，且都服从标准正态分布 $N(0,1)$ ，试证 $U=X^2+Y^2$ 与 $V= Y/X$ 相互独立。已知</p>
<script type="math/tex; mode=display">
p_X(x)=\frac{1}{\sqrt{2\pi}}\exp\{-\frac{x^2}{2}\}\\~\\</script><p><strong>第一步：列出u,v的反函数：</strong></p>
<p>已知 $\begin{cases} u =x^2+y^2\ \v=y/x\end{cases}$ , 则它的反函数</p>
<script type="math/tex; mode=display">
\begin{cases}x = v\sqrt{\frac{u}{v^2+1}}\\ \\ y=\sqrt{\frac{v}{v^2+1}} \end{cases}</script><p><strong>第二步：曲线救国，列出雅克比行列式</strong></p>
<p>这道题目告诉我们当我们直接求 $|J|$比较麻烦的时候，我们可以先求 $J^{-1}$</p>
<script type="math/tex; mode=display">
J^{-1}=\begin{vmatrix} \frac{\partial u}{\partial x} &\frac{\partial u}{\partial y} \\ \frac{\partial v}{\partial x}   &  \frac{\partial v}{\partial y} \end{vmatrix} = \begin{vmatrix} 2x & 2y \\ 1/y   &  -x/y^2 \end{vmatrix} = -2(\frac{x^2}{y^2}+1)</script><p>然后我们就可以求出 $|J|$,注意这时候x，y要用u，v来表示：$|J|=\frac{1}{2(1+v^2)}$ </p>
<p><strong>第三步：列出联合密度函数p(u,v)</strong></p>
<script type="math/tex; mode=display">
p(u,v)=p(x(u,v),y(u,v))=p_X(x(u,v))p_Y(y(u,v))|J| = \frac{1}{2\pi} e^{-\frac{u}{2}} \frac{1}{2(v^2+1)} ,u>0,-\infty <v <+\infty</script>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/" itemprop="url">计算机网络报告5</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-04-02T12:27:30+08:00">
                2021-04-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-08-25T04:31:00+08:00">
                2022-08-25
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="计算机网络报告5"><a href="#计算机网络报告5" class="headerlink" title="计算机网络报告5"></a>计算机网络报告5</h1><h2 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1.实验目的"></a>1.实验目的</h2><ul>
<li>熟悉HTTP协议</li>
<li>了解HTTP协议在实际网络中的运行过程</li>
<li>熟悉SMTP和POP3协议</li>
<li>了解SMTP和POP3协议在实际网络中的运行过程</li>
</ul>
<h2 id="2-实验任务"><a href="#2-实验任务" class="headerlink" title="2.实验任务"></a>2.实验任务</h2><ul>
<li><p>通过wireshark分析HTTP协议</p>
</li>
<li><p>通过wireshark分析SMTP和POP3协议</p>
</li>
</ul>
<h2 id="3-协议简介"><a href="#3-协议简介" class="headerlink" title="3. 协议简介"></a>3. 协议简介</h2><h3 id="3-1-HTTP协议"><a href="#3-1-HTTP协议" class="headerlink" title="3.1 HTTP协议"></a>3.1 HTTP协议</h3><p>HTTP协议(超文本传输协议HyperText Transfer Protocol)，它是基于TCP协议的应用层传输协议，简单来说就是客户端和服务端进行数据传输的一种规则。</p>
<p>HTTP 是一种无状态 (stateless) 协议, HTTP协议本身不会对发送过的请求和相应的通信状态进行持久化处理。这样做的目的是为了保持HTTP协议的简单性，从而能够快速处理大量的事务, 提高效率。然而，在许多应用场景中，我们需要保持用户登录的状态或记录用户购物车中的商品。由于HTTP是无状态协议，所以必须引入一些技术来记录管理状态，例如Cookie。</p>
<h3 id="3-2-SMTP协议"><a href="#3-2-SMTP协议" class="headerlink" title="3.2 SMTP协议"></a>3.2 SMTP协议</h3><p>SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP协议属于TCP/IP协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。通过SMTP协议所指定的服务器,就可以把E-mail寄到收信人的服务器上了，整个过程只要几分钟。SMTP服务器则是遵循SMTP协议的发送邮件服务器，用来发送或中转发出的电子邮件。SMTP是一种TCP协议支持的提供可靠且有效电子邮件传输的应用层协议。</p>
<h3 id="3-3-POP3协议"><a href="#3-3-POP3协议" class="headerlink" title="3.3 POP3协议"></a>3.3 POP3协议</h3><p>POP3（Post Office Protocol version3）：邮局协议第三版本，协助用户代理（即客户端）从邮件服务器上获取邮件。POP3允许用户从服务器上把邮件存储到本地主机（即自己的计算机）上，同时删除保存在邮件服务器上的邮件，而POP3服务器则是遵循POP3协议的接收邮件服务器，用来接收电子邮件的。</p>
<h2 id="4-实验过程"><a href="#4-实验过程" class="headerlink" title="4.实验过程"></a>4.实验过程</h2><h3 id="4-1"><a href="#4-1" class="headerlink" title="4.1"></a>4.1</h3><p>抓取HTTP数据包，并分析HTTP协议具体细节（主要是分析HTTP数据包的组成）</p>
<p><strong>操作步骤：</strong></p>
<p>(1) 清空Web浏览器的缓存，保证数据是从网络中获取的</p>
<p>(2) 启动Wireshark，开始Wireshark抓包。</p>
<p>(3) 在浏览器地址栏中前往网址<a href="http://www.ecnu.edu.cn" target="_blank" rel="noopener">http://www.ecnu.edu.cn</a></p>
<p>(4) 单击测览器中的“刷新”按钮。</p>
<p>(5) 停止Wireshark分组俘获，过滤筛选处输入“http”显示捕获到的HTTP报文。</p>
<h3 id="Task1-amp-2："><a href="#Task1-amp-2：" class="headerlink" title="Task1&amp;2："></a>Task1&amp;2：</h3><p><strong>抓取HTTP网络包，分析HTTP请求网络包/响应网络包的组成</strong></p>
<p>我发现当我们用http来请求 www.ecnu.edu.cn 的时候，浏览器总是会自动切换到 https协议，导致我们的Wireshark抓取到的都是TLS协议的包。我用筛选条件<code>http and ip.addr == 202.120.92.50</code>抓取不到任何的报文。这可能是因为网站强制HTTPS来加密访问，只有确保网站的安全之后才会启用。</p>
<p>但是在我多刷新了几次过后，突然在Wireshark中出现了一个http请求报文和一个http相应报文(但是我并不知道它们是怎么出现的)我将其截图放在下面</p>
<p><strong>请求报文</strong></p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/5.png" style="zoom: 80%;"></p>
<p><strong>响应报文</strong></p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/6.png" style="zoom:130%;"></p>
<p>但这种http的报文出现是不可复制的，我在晚上又试了好几个不同的浏览器都无法抓到包。我还是认为这和https协议有关。所以我找到了平常在用的美剧天堂网站，它只需要http协议即可访问，这样抓取http协议的包就是可复制的了。我这里也给出美剧天堂的筛选条件：<code>http and ip.addr == 61.111.129.175</code> </p>
<p>需要注意的是，在抓包前需要关闭VPN或者代理服务器，否则我们发送的http请求都是先中转到代理服务商，收到的http响应也是从代理服务商发出的，无法达成直接和网站进行”握手“的操作。</p>
<p>截图如下</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/7.png" style="zoom:130%;"></p>
<p>现在，我们来用 <a href="http://www.ecnu.edu.cn" target="_blank" rel="noopener">http://www.ecnu.edu.cn</a> 来分析一下HTTP请求报文与响应报文。</p>
<h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p><strong>首先我们看请求行的三个部分</strong></p>
<ul>
<li><p>请求方法： GET</p>
</li>
<li><p>请求内容： / 这里显示的是网站的相对路由的url，因为我访问的是学校网站的主页，因此其相对路由就是 <code>/</code> </p>
</li>
<li><p>协议版本：HTTP/1.1</p>
</li>
</ul>
<p><strong>然后我们来看首部行</strong></p>
<ul>
<li><p><code>Connection: keep-alive</code> 这是让客户端与服务端保持连接。</p>
</li>
<li><p><code>User-Agent: Mozilla/5.0 .......</code> 这是发送请求的操作系统即浏览器信息，我是用Chrome访问的网站，但这里一开始现实的是Mozilla/5.0，这是因为Mozilla是较早支持框架的浏览器，后来的浏览器为了兼容，都把自己伪装成Mozilla。</p>
</li>
<li><p><code>Accept: text/html application/xhtml+xml</code>这边列举的是客户端可以识别的内容类型，用于指定客户端接受哪些类型的信息</p>
</li>
<li><p><code>Accept-Encoding ： gzip, deflate</code> ,客户端可识别的数据编码.  这边简单介绍一下这两个编码格式：利用Apache中的<code>Gzip</code>模块，我们可以使用<code>Gzip</code>压缩算法来对Apache服务器发布的网页内容进行压缩后再传输到客户端浏览器。这样经过压缩后实际上降低了网络传输的字节数，最明显的好处就是可以加快网页加载的速度； <code>DEFLATE</code>是同时使用了LZ77算法与哈夫曼编码（Huffman Coding）的一个无损数据压缩算法。 deflate与gzip解压的代码几乎相同，可以合成一块代码。</p>
</li>
<li><p><code>Accepet-Language: zh-CN ，zh; q= 0.9,en; q=0.8,en-GB...</code> 这是浏览器所支持的语言类型</p>
</li>
</ul>
<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><ul>
<li><code>HTTP/1.1 301 Moved Permanently</code>，这边校园网给我返回的状态码是301，也就是永久性转移，说明浏览器在拿到服务器返回的这个状态码之后会自动跳转到一个新的URL地址，这个地址在接下来的<code>Location</code>部分。在我们用户看来，就是地址 <code>http://www.ecnu.edu.cn</code> 瞬间变成了 <code>https://www.ecnu.edu.cn</code> 。这代表http 开头的旧地址的资源已经被永久移除了，搜索引擎在抓取新的内容的同时也将旧的网址交换为重定向之后的网址。所以很可能是我没有完全删除浏览器的缓存导致后面多次刷新也无法发起向 www.ecnu.edu.cn 的get请求。而是直接使用 https 加密协议。</li>
<li><code>Content-Type text/html</code>  告诉客户端，实际返回的内容的类型</li>
<li><code>Content-Length: 167\r\n</code> 消息主体的到校</li>
<li><code>Connection: keep-alive</code>表明连接状态： 保持连接</li>
<li><code>Location: https://www,ecnu.edu.cn:443</code> 这就是获得的新地址。浏览器实际上访问的是这个新地址。 443 代表网页浏览器端口，主要用于HTTPS服务。</li>
</ul>
<p>实际上这个响应并没有给我们很多信息，因为都转移到TLS协议去了。</p>
<h3 id="Task3："><a href="#Task3：" class="headerlink" title="Task3："></a>Task3：</h3><p><strong>学习了解GET和POST方法，分析对比GET和POST方法的请求和响应报文</strong></p>
<p>在我写的关于NodeJs 的博客中又一个章节 <a href="https://jasonxqh.github.io/2020/06/07/Nodejs基础1/#RESTful-Services">RESTful Services</a> 介绍了四种 Http 请求。分别是： Get 用于获取信息，Put用于更新数据，Delete用于删除操作，Post用于新建操作。</p>
<p>然后我又想到了去年Web课程编写的网页，里面可以发送各种类型的 http 请求，因此我们来试一下。 我的项目是本地运行的，因此我们在Wireshark中选择<strong>Adapter for loopback traffic capture</strong>。后台是挂在 8080端口上的，因此筛选条件是：<code>http and tcp.port == 8080</code></p>
<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>当我刷新首页的时候，现实的就是一系列的 Get类型的请求。</p>
<p>一开始是请求用户的信息，然后请求首页内容。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/8.png" style="zoom:67%;"></p>
<h4 id="post"><a href="#post" class="headerlink" title="post"></a>post</h4><p>对于post请求，我们可以在数据库中新建一条信息(如下图所示)，那么前端就会向后端发送一条post请求。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/9.png" style="zoom:67%;"></p>
<p>我们抓到的包如下：</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/11.png" style="zoom:67%;"></p>
<p>我们点击最后的 <code>JavaScript Object Notation</code>,会出现Post中包含的一些关于新建对象信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">JavaScript Object Notation: application&#x2F;json</span><br><span class="line">    Object</span><br><span class="line">        Member Key: title</span><br><span class="line">            String value: 黑镜第五季</span><br><span class="line">            Key: title</span><br><span class="line">        Member Key: actors</span><br><span class="line">            String value: 安德鲁·斯科特,麦莉·赛勒斯</span><br><span class="line">            Key: actors</span><br><span class="line">        Member Key: country</span><br><span class="line">            String value: 英国</span><br><span class="line">            Key: country</span><br><span class="line">        Member Key: type</span><br><span class="line">            String value: 魔幻&#x2F;科幻</span><br><span class="line">            Key: type</span><br><span class="line">        Member Key: single</span><br><span class="line">            String value: 90</span><br><span class="line">            Key: single</span><br><span class="line">        Member Key: first_date</span><br><span class="line">            String value: </span><br><span class="line">            Key: first_date</span><br><span class="line">        Member Key: station</span><br><span class="line">            String value: Channel 4</span><br><span class="line">            Key: station</span><br><span class="line">        Member Key: url</span><br><span class="line">            String value: http:&#x2F;&#x2F;www.meiju8.cc&#x2F;movie&#x2F;48600.html</span><br><span class="line">            Key: url</span><br></pre></td></tr></table></figure>
<h4 id="分析与总结"><a href="#分析与总结" class="headerlink" title="分析与总结"></a>分析与总结</h4><h5 id="Get-和-Post-请求报文区别"><a href="#Get-和-Post-请求报文区别" class="headerlink" title="Get 和 Post 请求报文区别"></a>Get 和 Post 请求报文区别</h5><p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/10.png" style="zoom:67%;"></p>
<p>这两份报文最大的区别就是在请求方法上的不同，一个是Get，另一个是Post</p>
<p>此外由于在操作界面上的不同，两者请求的Url也不一样。</p>
<p>相比 Post的请求报文，Get的请求报文在这里还多了一个 Authorization，其内容是一大串编码, 原因是我在设计系统的时候规定在请求信息的时候前端必须把用户的信息token放在Get报文中发送给后端，后端验明身份后才可以发送数据库中的信息给前端。因此这里的密码就是用户的token信息。</p>
<p>相比 Get的请求报文，Post的请求报文在底部还有一行 <code>File Data : 217 bytes</code> ,这是因为我新建了一条信息，夹带在请求报文中，发送给后端，后端解析后将其存入数据库当中。</p>
<p>和之前向 www.ecnu.edu.cn 发送的报文相比，这两份报文多了几个字段： </p>
<p><code>Sec-Fetch-Site： same-site</code> 这个请求头表示一个请求发起者的来源与目标资源来源之间的关系；same-site表示发起和目标站点源完全一致</p>
<p><code>Sec-Fetch-Mode: cors</code>该请求头表明了一个请求的模式；cors代表跨域请求。因为前端端口设在3000，后端端口设在8080，http请求需要跨域</p>
<p><code>Sec-Fetch-Dest: empty</code> 表示请求的目的地，即如何使用获取的数据；</p>
<p>Sec-Fetch-*请求头这是用来干嘛的呢，简单来说，就是网络请求的元数据描述，服务端根据这些补充数据进行细粒度的控制响应，换句话说，服务端可以精确判断请求的合法性，杜绝非法请求和攻击，提高web服务的安全性。</p>
<h5 id="Get和post响应报文区别"><a href="#Get和post响应报文区别" class="headerlink" title="Get和post响应报文区别"></a>Get和post响应报文区别</h5><p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/12.png" style="zoom:67%;"></p>
<p>现在我们来分析Get和Post的响应报文。</p>
<p>我们发现Get 与 Post 的响应报文大同小异，但是Post响应报文并没有报告模板中写着的那样有 Server字段，我并不知道是什么原因。</p>
<p>但是与之前 www.ecnu.edu.cn的响应报文相比，这次的相应报文多了很多 X-* 开始的响应头.我在 MDN Web Docs上找到了相关解释：</p>
<p><code>X-DNS-Prefetch-Control: off</code> 这个响应头控制着浏览器的DNS预读取功能。 DNS 预读取是一项使浏览器主动去执行域名解析的功能，其范围包括文档的所有链接，无论是图片的，CSS 的，还是 JavaScript 等其他用户能够点击的 URL。因为预读取会在后台执行，所以 DNS 很可能在链接对应的东西出现之前就已经解析完毕。这能够减少用户点击链接时的延迟。这里的off就是关闭DNS预解析。</p>
<p><code>X-Frame-Options: SAMEORIGIN</code>  这个响应头是用来给浏览器指示允许一个页面 可否在<code>&lt;frame&gt;</code>，<code>&lt;embed&gt;</code>或者<code>&lt;object&gt;</code>中展现的标记。sameorigin表示该页面可以在相同域名页面的 frame 中展示。</p>
<p><code>X-Download-Options: noopen</code> 这个响应头是用于放置直接打开用户下载文件。noopen用于指定 IE 8级以上的版本的用户不打开文件而直接保存文件，在下载对话框中不显示“打开”选项</p>
<p><code>X-SXX-Protection: 1; mode=bloack</code> 这个响应头是 Internet Explorer，Chrome 和 Safari 的一个特性，当检测到跨站脚本攻击 (<a href="https://developer.mozilla.org/en-US/docs/Glossary/Cross-site_scripting" target="_blank" rel="noopener">XSS</a>)时，浏览器将停止加载页面。这里，<code>1;mode=block</code> 代表启用XSS过滤。 如果检测到攻击，浏览器将不会清除页面，而是阻止页面加载。</p>
<h3 id="Task4"><a href="#Task4" class="headerlink" title="Task4"></a>Task4</h3><p><strong>抓取HTTP数据包，并分析HTTP协议交互流程（主要是客户端和服务器之间通过HTTP协议进行交互的流程）</strong></p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/4.png" style="zoom:67%;"></p>
<p>HTTP协议的流程可以概括为下图：</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/14.png" style="zoom:120%;"></p>
<p>我们看到按照上面这个图片，可以总结为下面四点：</p>
<ol>
<li>客户端通过TCP三次握手与服务器建立连接。</li>
<li>TCP建立连接成功后，向服务器发送HTTP请求。</li>
<li>服务器接收客户端的HTTP请求后，将返回应答，并向客户端发送数据</li>
<li>客户端通过TCP四次断开，与服务器断开TCP连接。</li>
</ol>
<p>为了直观，我们还是抓取了本地项目的报文来做分析</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/15.png" style="zoom:120%;"></p>
<p>首先是三次握手的过程。前端端口是3645，后端端口是8080</p>
<ul>
<li>第一份TCP报文是前端发送给后端使用SYN同步序列号，用来发起一个TCP连接，这时候 Seq=0。</li>
<li>第二份TCP报文是服务器发送的[SYN,ACK]确认报文，此时 Seq=0,Ack =1。这代表已经收到序列号为0的报文，现在请求要1的报文</li>
<li>第三份TCP报文是服务端发送的 Seq=1,Ack=1的[ACK]确认报文。</li>
</ul>
<p>我们发现和图片上的三次握手一一对应，现在客户端和服务端已经开始建立了联系，开始相互通讯了。下面的HTTP请求就是之前我们分析的报文。</p>
<p>四次挥手我们用 访问百度的例子：</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/17.png" style="zoom:120%;"></p>
<p>第一次挥手：首先客户端给服务器发送 [FIN,ACK] 包，用来关闭客户端到服务器的数据传送。Seq=1,Ack=1</p>
<p>第二次挥手：当服务器收到FIN之后，发挥一个 Ack=2 的TCP包。</p>
<p>第三次挥手：仍然是服务器给PC发送TCP包，用来关闭于客户端的连接。 <code>Seq=1 Ack=2</code></p>
<p>第四次挥手，客户端收到服务器发送的FIN之后，发送 <code>Seq=2,Ack=2</code> 的TCP包给客户端，结束链接，但是这里百度的客户端已经和我们断开了连接，因此出现了重新发送的情况。</p>
<h3 id="Task5-amp-6"><a href="#Task5-amp-6" class="headerlink" title="Task5&amp;6"></a>Task5&amp;6</h3><p><strong>抓取SMTP和POP3数据包，并分析SMTP和POP3协议具体细节（主要是分析SMTP和POP3数据包的组成) 和 协议交互流程（主要是SMTP和POP3协议在网络中运行的流程）</strong></p>
<p>为了方便起见，我将数据包的组成和交互流程放在一起分析：</p>
<h4 id="SMTP-协议"><a href="#SMTP-协议" class="headerlink" title="SMTP 协议"></a>SMTP 协议</h4><p>操作步骤：</p>
<p>（1） 打开Wireshark，开始捕获网络包。</p>
<p>（2） 在本地用foxmail（或其他）登录两个邮箱，用A邮箱发送邮件给B邮箱。</p>
<p>（3） 抓取smtp和pop3协议的数据包。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/18.png" style="zoom:120%;"></p>
<p>如果我们在使用 Foxmail发送邮件，需要先在设置中将取消使用SSL 加密邮件的功能，否则我们是抓取不到任何包裹的。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/19.png" style="zoom:120%;"></p>
<p>Wireshark 抓到的包如下：</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/20.png" style="zoom:120%;"></p>
<p>现在我们分析SMTP和POP3协议具体细节和流程。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/13.png" style="zoom:67%;"></p>
<p>第一条是邮件服务器发送给PC的报文，220 代表连接 SMTP 服务器成功。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Simple Mail Transfer Protocol</span><br><span class="line">    Response: 220 newxmesmtplogicsvrszc7.qq.com XMail Esmtp QQ Mail Server.\r\n</span><br><span class="line">        Response code: &lt;domain&gt; Service ready (220)</span><br><span class="line">        Response parameter: newxmesmtplogicsvrszc7.qq.com XMail Esmtp QQ Mail Server.</span><br></pre></td></tr></table></figure>
<p>第二条是PC发送给邮件服务器的报文，EHLO表明邮件带有身份验证，是没有办法伪造的，也就是可以规避垃圾邮件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Simple Mail Transfer Protocol</span><br><span class="line">    Command Line: EHLO JasonsT90\r\n</span><br></pre></td></tr></table></figure>
<p>第三条邮件服务器发送给PC的报文,状态字250代表与 服务器握手成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Simple Mail Transfer Protocol</span><br><span class="line">    Response: 250-newxmesmtplogicsvrszc7.qq.com\r\n</span><br><span class="line">        Response code: Requested mail action okay, completed (250)</span><br><span class="line">        Response parameter: newxmesmtplogicsvrszc7.qq.com</span><br><span class="line">        Response parameter: PIPELINING</span><br><span class="line">        Response parameter: SIZE 73400320</span><br><span class="line">        Response parameter: STARTTLS</span><br><span class="line">        Response parameter: AUTH LOGIN PLAIN XOAUTH XOAUTH2</span><br><span class="line">        Response parameter: AUTH&#x3D;LOGIN</span><br><span class="line">        Response parameter: MAILCOMPRESS</span><br><span class="line">        Response parameter: 8BITMIME</span><br></pre></td></tr></table></figure>
<p>第四条是PC发送给邮件服务器的报文，这边是用户登录命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Simple Mail Transfer Protocol</span><br><span class="line">    Command Line: AUTH LOGIN\r\n</span><br><span class="line">        Command: AUTH</span><br><span class="line">        Request parameter: LOGIN</span><br></pre></td></tr></table></figure>
<p>第五条是邮件服务器发送给PC的报文，状态码是334，代表接受用户登录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Simple Mail Transfer Protocol</span><br><span class="line">    Response: 334 VXNlcm5hbWU6\r\n</span><br><span class="line">        Response code: AUTH input (334)</span><br><span class="line">        Response parameter: VXNlcm5hbWU6</span><br></pre></td></tr></table></figure>
<p>第六条是PC发送给邮件服务器的报文，包含了登陆的用户名的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Simple Mail Transfer Protocol</span><br><span class="line">    Username: MjY5Nzc2NzE2MEBxcS5jb20&#x3D;</span><br></pre></td></tr></table></figure>
<p>第七条又是表示 邮件服务器接受用户登录</p>
<p>第八条是PC发送给邮件服务器的报文，包含了用户登录服务器的密码</p>
<p>第九条是邮件服务器发送给PC的报文，状态字235代表用户登录成功</p>
<p>第十条是PC发送给邮件服务器的报文，记录了邮件的发送者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Simple Mail Transfer Protocol</span><br><span class="line">    Command Line: MAIL FROM: &lt;2697767160@qq.com&gt; SIZE&#x3D;1354\r\n</span><br><span class="line">        Command: MAIL</span><br><span class="line">        Request parameter: FROM: &lt;2697767160@qq.com&gt; SIZE&#x3D;1354</span><br></pre></td></tr></table></figure>
<p>第十一条是邮件服务器发送给PC的报文，状态字250表示与服务器握手成功</p>
<p>第十二条是PC发送给邮件服务器的报文，记录了邮件的接收者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Simple Mail Transfer Protocol</span><br><span class="line">    Command Line: RCPT TO: &lt;10195501423@stu.ecnu.edu.cn&gt;\r\n</span><br><span class="line">        Command: RCPT</span><br><span class="line">        Request parameter: TO: &lt;10195501423@stu.ecnu.edu.cn&gt;</span><br></pre></td></tr></table></figure>
<p>第十三条是邮件服务器发送给PC的报文，也是250关键字</p>
<p>第十四条是PC发送给邮件服务器的报文，内容为DATA，表示邮件正文</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Simple Mail Transfer Protocol</span><br><span class="line">    Command Line: DATA\r\n</span><br><span class="line">        Command: DATA</span><br></pre></td></tr></table></figure>
<p>第十五条是邮件服务器发送给PC的报文</p>
<p>第十六条是PC发送给邮件服务器的报文，记载着邮件的详细信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Simple Mail Transfer Protocol</span><br><span class="line">    Line-based text data (13 lines)</span><br><span class="line">        Date: Sun, 4 Apr 2021 12:48:46 +0800\r\n</span><br><span class="line">        From: &quot;2697767160@qq.com&quot; &lt;2697767160@qq.com&gt;\r\n</span><br><span class="line">        To: &#x3D;?GB2312?B?0OyGorq9?&#x3D; &lt;10195501423@stu.ecnu.edu.cn&gt;\r\n</span><br><span class="line">        Subject: test\r\n</span><br><span class="line">        X-Priority: 3\r\n</span><br><span class="line">        X-GUID: C085913A-BCC1-425E-9D61-8E390342FC2A\r\n</span><br><span class="line">        X-Has-Attach: no\r\n</span><br><span class="line">        X-Mailer: Foxmail 7.2.20.273[cn]\r\n</span><br><span class="line">        Mime-Version: 1.0\r\n</span><br><span class="line">        Message-ID: &lt;202104041248465541575@qq.com&gt;\r\n</span><br><span class="line">        Content-Type: multipart&#x2F;alternative;\r\n</span><br><span class="line">        \tboundary&#x3D;&quot;----&#x3D;_001_NextPart310261260277_&#x3D;----&quot;\r\n</span><br><span class="line">        \r\n</span><br><span class="line">    [Reassembled DATA in frame: 974]</span><br></pre></td></tr></table></figure>
<p>第十七条是邮件服务器发送给PC的报文，状态字250表示握手成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Simple Mail Transfer Protocol</span><br><span class="line">    Response: 250 OK: queued as.\r\n</span><br><span class="line">        Response code: Requested mail action okay, completed (250)</span><br><span class="line">        Response parameter: OK: queued as.</span><br></pre></td></tr></table></figure>
<p>第十八条是PC发送给邮件服务器的报文，内容是QUIT，代表推出SMTP服务器</p>
<p>第十九条是邮件服务器发送给PC的报文，状态字221,代表与PC断开连接。服务关闭</p>
<h4 id="POP3协议"><a href="#POP3协议" class="headerlink" title="POP3协议"></a>POP3协议</h4><p>由于我使用的都是默认配置的邮箱，因此qq邮箱和企业邮箱都是使用IMAP类型的邮箱，无法收到POP协议的报文。因此我又重新配置了我的两个邮箱：</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/21.png" style="zoom:67%;"></p>
<ol>
<li>由于POP3协议默认的传输协议是TCP协议，因此，客户端连接服务器需要先进行三次握手建立端到端的连接。</li>
</ol>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/22.png" style="zoom:67%;"></p>
<ol>
<li>在客户端和服务器建立了连接之后，pop3服务器回向pop3客户端发送 带有OK的信息，通知客户端，服务器已经准备就绪，请开始认证阶段。</li>
</ol>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/23.png" style="zoom:67%;"></p>
<ol>
<li>还是参照上图，客户端会向服务器发送用户名、授权码，邮箱服务器也会返回OK作为回应</li>
<li>接下来客户端向服务器发送 LIST指令，服务器会返回邮件数量的大小。</li>
</ol>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/24.png" style="zoom:67%;"></p>
<p>我们看到POP服务器上一共有91份待收取的邮件。</p>
<p>接下来，客户端依次向POP服务器发送 RETR XX(代表第XX封邮件)，从RETR 91 一直到 RETR 1.服务器返回命令执行的状态(都是OK)以及第XX封邮件的全部内容。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/25.png" style="zoom:67%;"></p>
<p>每一份回传的OK的POP类型报文内容如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Post Office Protocol</span><br><span class="line">    +OK 17826\r\n</span><br><span class="line">    Received: from 66.203.125.14 (unknown [66.203.125.14])\r\n</span><br><span class="line">    \tby newmx31.qq.com (NewMx) with SMTP id \r\n</span><br><span class="line">    \tfor &lt;2697767160@qq.com&gt;; Wed, 10 Mar 2021 19:49:16 +0800\r\n</span><br><span class="line">    X-QQ-FEAT: cNGXrfP6b70WZB63pTXQMF109vshIAanTTfx8LrW82o&#x3D;\r\n</span><br><span class="line">    X-QQ-MAILINFO: MfiUJyQXz1c0MzpywYY9SZw82ms4O&#x2F;PNVMLpO9XG6T+YtCzTTfIxosGvW\r\n</span><br><span class="line">    \tGLtLTpNB6P6inseKmkcTT32W0twW00gkYhYWthuNeRGuMTLnB+eupX2zEdw+cI&#x3D;\r\n</span><br><span class="line">    X-QQ-mid: mxszc32t1615376953ta55hzshz\r\n</span><br><span class="line">    X-QQ-CSender: support+2697767160&#x3D;qq.com@mega.nz\r\n</span><br><span class="line">    X-QQ-ORGSender: support+2697767160&#x3D;qq.com@mega.nz\r\n</span><br><span class="line">    X-QQ-XMAILINFO: M2oFKfa0&#x2F;bfew2IwrID4iBasCNw8ww5ZmGVMCIlyGoUiPp1ZLokBv3JVRg4cLf\r\n</span><br><span class="line">    \t qdL1LytVljSPoYupd&#x2F;84PH64vr1LeLYuFDDvP&#x2F;LUNEiRf12ixQby9M2kKdRpXpSil5j1i69EWO68\r\n</span><br><span class="line">    \t 2RGSVu1ROA7mtPgjCRvHW&#x2F;PNtO3TLLMxAH8suiNHigFEw0GRN+drbQgVlpONXXJVb89q2pX&#x2F;pzFS\r\n</span><br><span class="line">    \t SdSvinFTax&#x2F;wB5jK6HPQqw1Xbnf2sUNSp036IOJRzC5KEgXPyebiCZpzxtS+PWS8kXL9iUacIlU2\r\n</span><br><span class="line">    \t EmZ3wQZen&#x2F;uFbHHEzSQfmFjDWpdy532VDeN5XqVsbHnlHh&#x2F;8kEl+Q9gPAVe5bJ1RJRabr7XyE0Av\r\n</span><br><span class="line">    \t loor6GeJUoDoBRDb1bb8mChh4h9k7UaO5wz8sv0mMh6HhKr3Ujx3b3Lse27w&#x2F;NOpvYghW2qA8RrS\r\n</span><br><span class="line">    \t wrw&#x2F;o0FqMWS4j0jFoBDa7P0foQdla168q2vbww1lMBSZWggXLxEaLHurlLFPvUpZ93+pwG5jRAWK\r\n</span><br><span class="line">    \t aebTM7ekTKZP8zDQIyUgQ+Vtg9GWiHyV1GSamnciZXrQisdO7g3nE+v8HfxACgv&#x2F;UkDF57WLe7rh\r\n</span><br><span class="line">    \t pXJIbvRnBuw4udVFzRRbwaZK67y&#x2F;2cFr3JZCtDqtiEG+C+6aDtU+&#x2F;0FxuehYwf0P3VbxbYhHcHn1\r\n</span><br><span class="line">    \t uXvvAL0sty3zSbweWINddy3GP2I9a2WX8MLkgMwoFhII+bbTxKdtN&#x2F;ayYW+N0&#x2F;331HfnxFvLtUNV\r\n</span><br><span class="line">    \t lIuxgBK+55V8&#x2F;p5BtjidmhkgkG1Tk9xi+zcpj+6J1q3u5vlNU2rZj6stX8F30M4bPXWc6Iqd+g7M\r\n</span><br><span class="line">    \t vkynns4nr537VzSL7YaM8HhBxhlsfXGLoOE3Ief2Wk3u58FOIf5cEK</span><br></pre></td></tr></table></figure>
<p><code>Received :  from  66.203.125.14</code> 表示从哪里收到的信息</p>
<p><code>by newmx31.qq.com (NewMx) with SMTP id</code> 表示发件服务器的信息</p>
<p><code>for &lt;2697767160@qq.com&gt;; Wed, 10 Mar 2021 19:49:16 +0800</code> 表示收件人信息和收件时间</p>
<p> <code>X-QQ-CSender: support+2697767160=qq.com@mega.nz</code> 弹回域名 </p>
<ol>
<li>最后客户端发送QUIT指令，退出处理状态。服务器也返回 OK Bye作为回应。并通过 TCP四次挥手断开连接。</li>
</ol>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/26.png" style="zoom:67%;"></p>
<p>那么 IMAP类型的邮箱和POP类型的邮箱有什么区别？</p>
<p>POP允许电子邮件客户端下载服务器上的邮件，但是我在电子邮件客户端的操作（如：移动邮件、标记已读等），这是不会反馈到服务器上的，比如：您通过电子邮件客户端收取了QQ邮箱中的3封邮件并移动到了其他文件夹，这些移动动作是不会反馈到服务器上的，也就是说，QQ邮箱服务器上的这些邮件是没有同时被移动的。</p>
<p>但是IMAP就不同了，电子邮件客户端的操作都会反馈到服务器上，我对邮件进行的操作（如：移动邮件、标记已读等），服务器上的邮件也会做相应的动作。也就是说，IMAP是“双向”的。</p>
<p>同时，IMAP可以只下载邮件的主题，只有当我真正需要的时候，才会下载邮件的所有内容。</p>
<h2 id="进阶（依据自身情况完成）"><a href="#进阶（依据自身情况完成）" class="headerlink" title="进阶（依据自身情况完成）"></a>进阶（依据自身情况完成）</h2><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p>利用Web邮件客户端进行邮件发送和接收，抓取相应的数据包，分析其流程。</p>
<h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p>在GitHub上寻找基于java实现的邮件收发客户端，找到之后运行它，实现正常的邮件收发，并抓取相应的网络包，分析判断其网络交互流程。</p>
<p><a href="https://github.com/RawSanj/java-mail-clients" target="_blank" rel="noopener">https://github.com/RawSanj/java-mail-clients</a></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/" itemprop="url">计算机网络实验报告2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-21T23:36:48+08:00">
                2021-03-21
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2022-08-23T22:25:06+08:00">
                2022-08-23
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="计算机网络实验报告2"><a href="#计算机网络实验报告2" class="headerlink" title="计算机网络实验报告2"></a>计算机网络实验报告2</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ul>
<li>理解多线程并熟悉Java多线程编程</li>
<li>熟悉并掌握线程创建、线程控制</li>
<li>熟悉并掌握线程同步、线程交互</li>
</ul>
<h2 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h2><ul>
<li><p>使用常用的两种方式创建线程</p>
</li>
<li><p>使用join()等方法进行线程控制</p>
</li>
<li><p>学习使用synchronized关键字进行线程同步</p>
</li>
<li><p>学习使用wait()和notify()方法进行线程交互</p>
</li>
</ul>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><h4 id="继承Thread类创建线程"><a href="#继承Thread类创建线程" class="headerlink" title="继承Thread类创建线程"></a>继承Thread类创建线程</h4><p> 通过继承Thread类来创建并启动多线程的一般步骤如下</p>
<p>1） 定义Thread类的子类，并重写该类的run()方法，该方法的方法体就是线程需要完成的任务，run()方法也称为线程执行体。</p>
<p>2） 创建Thread子类的实例，也就是创建了线程对象</p>
<p>3） 启动线程，即调用线程的start()方法</p>
<p>具体代码如下图所示：</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/1.png" style="zoom:80%;"></p>
<h5 id="任务1"><a href="#任务1" class="headerlink" title="任务1:"></a>任务1:</h5><p><strong>改写 <code>run()</code> 方法，将当前线程的信息打印出来</strong> </p>
<p><code>Mythread_a</code> 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mythread_a</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"当前线程: "</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Mythread_a mThread1 = <span class="keyword">new</span> Mythread_a();</span><br><span class="line">        Mythread_a mThread2 = <span class="keyword">new</span> Mythread_a();</span><br><span class="line">        Mythread_a mThread3 = <span class="keyword">new</span> Mythread_a();</span><br><span class="line">        mThread1.start();</span><br><span class="line">        mThread2.start();</span><br><span class="line">        mThread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Main</code>类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mythread_a.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/7.png" style="zoom:80%;"></p>
<h4 id="覆写Runnable-、run"><a href="#覆写Runnable-、run" class="headerlink" title="覆写Runnable()、run()"></a>覆写Runnable()、run()</h4><p>通过实现Runnable接口创建并启动线程一般步骤如下：</p>
<p>1） 定义Runnable接口的实现类，一样要重写run()方法，这个run（）方法和Thread中的run()方法一样是线程的执行体</p>
<p>2 ） 创建Runnable实现类的实例，并用这个实例作为Thread的target来创建Thread对象，这个Thread对象才是真正的线程对象</p>
<p>3） 第三部依然是通过调用线程对象的start()方法来启动线程</p>
<h5 id="任务2"><a href="#任务2" class="headerlink" title="任务2:"></a>任务2:</h5><p><strong>改写 <code>run()</code> 方法，实现循环打印1-100</strong></p>
<p><code>Mythread_b</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mythread_b</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">            System.out.print(i+<span class="number">1</span>+<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Main</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Mythread_b());</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果如下：</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/8.png" style="zoom:80%;"></p>
<h3 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h3><h4 id="join-线程"><a href="#join-线程" class="headerlink" title="join()线程"></a>join()线程</h4><p>join线程可以让一个线程等待另一个线程执行完毕以后再执行。</p>
<p>1）作用：主要作用是同步，它可以使得线程之间的并行执行变为串行执行。在A线程中调用了B线程的join()方法时，表示只有当B线程执行完毕时，A线程才能继续执行。</p>
<p>2）Join()和start()调用顺序问题：join()方法必须在线程start()方法调用之后调用才有意义。一个线程都还未开始运行，同步是不具有任何意义的。</p>
<p>3）原理：join方法的原理就是调用相应线程的wait方法进行等待操作的，例如A线程中调用了B线程的join方法，则相当于在A线程中调用了B线程的wait方法，当B线程执行完（或者到达等待时间），B线程会自动调用自身的notifyAll方法唤醒A线程，从而达到同步的目的。</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/3.png" style="zoom:80%;"></p>
<h5 id="任务3"><a href="#任务3" class="headerlink" title="任务3:"></a>任务3:</h5><p><strong>完善代码，用join()实现正常的逻辑</strong></p>
<p><code>ThreadJoin</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoin</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Main</code>类：</p>
<p>这里我设计了一个 Thread集合用来存放线程。每个线程声明的时候就将其添加到线程集合当中去。然后通过循环，依次启动四个线程 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ThreadJoin joinDemo = <span class="keyword">new</span> ThreadJoin();</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(joinDemo,<span class="string">"上课铃响"</span>);threads.add(thread1);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(joinDemo,<span class="string">"老师上课"</span>);threads.add(thread2);</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(joinDemo,<span class="string">"下课铃响"</span>);threads.add(thread3);</span><br><span class="line">        Thread thread4 = <span class="keyword">new</span> Thread(joinDemo,<span class="string">"老师下课"</span>);threads.add(thread4);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> thread:threads)&#123;</span><br><span class="line">            thread.start();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：每隔0.5秒按顺序出现一条讯息</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/9.png" style="zoom: 100%;"></p>
<h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>java中有一种线程只在后台运行，为其他线程提供服务，这种线程就是守护线程（Daemon Thread）。</p>
<p>只要当前JVM实例中尚存任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作，Daemon作用是为其他线程提供便利服务，守护线程最典型的应用就是GC(垃圾回收器)。</p>
<p>User和Daemon两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果 User Thread已经全部退出运行了，只剩下Daemon Thread存在了，虚拟机也就退出了。 因为没有了被守护者，Daemon也就没有工作可做了，也就没有继续运行程序的必要了。</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/5.png" style="zoom:80%;"></p>
<h5 id="任务4："><a href="#任务4：" class="headerlink" title="任务4："></a>任务4：</h5><p><strong>完善代码，将该线程设置为守护线程，当主线程结束时，结束该线程.</strong></p>
<p>学习资料：<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1306580788183074" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1252599548343744/1306580788183074</a></p>
<p>如何创建守护线程呢？方法和普通线程一样，只是在调用<code>start()</code>方法前，调用<code>setDaemon(true)</code>把该线程标记为守护线程：</p>
<p><code>ThreadDaemon</code> 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDaemon</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"助教在教室的第"</span>+i+<span class="string">"秒"</span>);</span><br><span class="line">                Thread.currentThread().sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Main</code> 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">         ThreadDaemon inClassroom = <span class="keyword">new</span> ThreadDaemon();</span><br><span class="line">         Thread thread = <span class="keyword">new</span> Thread(inClassroom,<span class="string">""</span>);</span><br><span class="line">         thread.setDaemon(<span class="keyword">true</span>);<span class="comment">//设thread为守护线程</span></span><br><span class="line">         thread.start();</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">             thread.sleep(<span class="number">1000</span>);</span><br><span class="line">             System.out.println(<span class="string">"同学们正在上课"</span>);</span><br><span class="line">             <span class="keyword">if</span>(i==<span class="number">9</span>)&#123;</span><br><span class="line">                 System.out.println(<span class="string">"同学们下课了"</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/10.png" style="zoom:80%;"></p>
<p>如果不将ThreadDaemon设为守护线程的话，在输出同学们下课了之后，还会继续输出 助教在教师的第 i 秒。而将其设为守护线程之后，当主线程main结束时，守护线程也结束了，不再打印。</p>
<h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a><strong>线程优先级</strong></h4><p>线程的优先级用1-10之间的整数表示，数值越大优先级越高，默认的优先级为5。线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，优先级低的并非没机会执行。</p>
<p>高优先级的线程比低优先级的线程有更高的几率得到执行，实际上这和操作系统及虚拟机版本相关，有可能即使设置了线程的优先级也不会产生任何作用</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/4.png" style="zoom:80%;"></p>
<h5 id="任务5："><a href="#任务5：" class="headerlink" title="任务5："></a>任务5：</h5><p><strong>完善代码，将两个线程设置为不同的优先级，并将不同的优先级的情况下的输出结果记录下来，总结优先级的特点。 </strong></p>
<p>当我们设置：t2为最高优先级，t1为最低优先级的时候：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t2.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">t1.setPriority(Thread.MIN_PRIORITY);</span><br></pre></td></tr></table></figure>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/11.png" style="zoom:80%;"></p>
<p>前面10次中线程2执行了5次，线程1执行了5次。</p>
<p>当我们设置t1为最高优先级，t2位最低优先级的时候：</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/12.png" style="zoom:80%;"></p>
<p>前面十次中线程1执行了5次，线程2也执行了5次</p>
<p>这说明，在我的电脑里，即使设置了线程的优先级也不会产生任何作用。</p>
<h4 id="线程让步"><a href="#线程让步" class="headerlink" title="线程让步"></a>线程让步</h4><p>线程让步用于正在执行的线程，在某些情况下让出CPU资源，让给其它线程执行。</p>
<p>yield()方法会让线程回到就绪状态，直接等到cpu重新分配资源，但只有优先级和该线程相等或大于该线程的其他线程才有机会被执行。</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/6.png" style="zoom:80%;"></p>
<h5 id="任务6："><a href="#任务6：" class="headerlink" title="任务6："></a>任务6：</h5><p><strong>完善代码，将两个线程设置为不同的优先级，并将第一个线程设置为让步状态，总结线程让步的特点。将关键代码和总结的内容写到实验报告中</strong></p>
<p>wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而yield()的作用是让步，它也会让当前线程离开“运行状态”。它们的区别是：</p>
<ul>
<li>wait()是让线程由“运行状态”进入到“等待(阻塞)状态”，而yield()是让线程由“运行状态”进入到“就绪状态”。</li>
<li>wait()是会线程释放它所持有对象的同步锁，而yield()方法<strong>不会释放锁 </strong></li>
</ul>
<p>Mythread3:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mythread3</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"线程1第"</span>+i+<span class="string">"次执行!"</span>);</span><br><span class="line">            Thread.yield();<span class="comment">//这里我们将线程让步</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们启动main函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Mythread3 t1 = <span class="keyword">new</span> Mythread3();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread4());</span><br><span class="line">        t2.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        t1.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果我们发现这并不能改变两个线程的运行顺序。这可能是因为yield()方法并不能立刻交出CPU，或者是让步后的线程还有可能被线程调度程序再次选中。</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/17.png" style="zoom:80%;"></p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>当我们有多个线程要同时访问一个变量或对象时，如果这些线程中既有读又有写操作时，就会导致变量值或对象的状态出现混乱，从而导致程序异常。举个例子，如果一个银行账户同时被两个线程操作，一个取100块，一个存钱100块。假设账户原本有0块，如果取钱线程和存钱线程同时发生，会出现什么结果呢？取钱不成功，账户余额是100.取钱成功了，账户余额是0.那到底是哪个呢？很难说清楚。因此多线程同步就是要解决这个问题。</p>
<p>在多线程中，可能有多个线程试图访问一个有限的资源，必须预防这种情况的发生。所以引入了同步机制：在线程使用一个资源时为其加锁，这样其他的线程便不能访问那个资源了，直到解锁后才可以访问。</p>
<p>synchronized同步方法：锁定的是当前对象。当多线程通过同一个对象引用多次调用当前同步方法时，需同步执行。也就是说当一个线程访问同步方法时，其他线程访问这个方法将会被阻塞(等待锁)。</p>
<p>synchronized同步代码块：用关键字synchronized声明方法在某些情况下是有弊端的，比如A线程调用同步方法执行一个较长时间的任务，那么B线程必须等待比较长的时间。这种情况下可以尝试使用synchronized同步代码块来解决问题。</p>
<p>同步代码块的同步粒度更加细致，是商业开发中推荐的编程方式。可以定位到具体的同步位置，而不是简单的将方法整体实现同步逻辑。在效率上，相对更高。</p>
<h5 id="任务7："><a href="#任务7：" class="headerlink" title="任务7："></a>任务7：</h5><p><strong>采用同步方法和同步代码段的方法来进行线程控制，总结对比两种方式的优缺点。将代码和总结的结果写到实验报告中。</strong></p>
<p>这里我们设计了一个模拟多任务下载的软件：一共有3个类</p>
<p><code>ThreadDemo</code>类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">var</span> status = <span class="keyword">new</span> DownloadStatus();</span><br><span class="line">       List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">var</span> thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DownloadFileTask(status));</span><br><span class="line">           thread.start();</span><br><span class="line">           threads.add(thread);</span><br><span class="line">       &#125;</span><br><span class="line">      <span class="comment">//将所有的线程都打开后，我们还需要等待所有的线程都停止。这里使用一个循环来解决。</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> thread : threads)&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               thread.join();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        System.out.println(status.getTotalBytes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DownloadFileTask</code>类</p>
<p>在这个Run函数当中，我们做一个10000次的循环，每一次循环都调用status对象的 <code>incrementTotalBytes()</code>函数。用来模拟下载一个 10000 bits的文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadFileTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DownloadStatus status;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DownloadFileTask</span><span class="params">(DownloadStatus status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;i&lt; <span class="number">10_000</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().isInterrupted()) <span class="keyword">return</span>;</span><br><span class="line">            status.incrementTotalBytes();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DownloadStatus</code>类</p>
<p>在这个类中，有一个下载总比特数的私有变量，当有线程中的对象调用<code>incrementTotalBytes()</code>的时候，totalBytes就会自增1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadStatus</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> totalBytes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotalBytes</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> totalBytes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incrementTotalBytes</span><span class="params">()</span></span>&#123;</span><br><span class="line">        totalBytes++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在预期的情况下，我们打开了10 个线程，每个线程都会下载10_000比特的数据，那么<code>totalBytes</code>的结果应该是100_000.但是我们多次运行之后，一直都是八九万，并没有到十万。这是因为发生了<code>Race condition</code>，线程在互相争抢修改同一个数据的时候，会发生数据丢失。这时候我们就可以使用 synchronized 关键词 </p>
<p>但是Java程序依靠<code>synchronized</code>对线程进行同步，使用<code>synchronized</code>的时候，锁住的是<strong>哪个对象</strong>非常重要。</p>
<p>让线程自己选择锁对象往往会使得代码逻辑混乱，也不利于封装。更好的方法是把<code>synchronized</code>逻辑封装起来。 </p>
<p>比如我们现在就要用synchronized来封装<code>totalBytes++</code> ,这是<strong>同步代码段的方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incrementTotalBytes</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        totalBytes++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，线程调用<code>incrementTotalBytes</code>方法时，它不必关心同步逻辑，因为<code>synchronized</code>代码块在<code>incrementTotalBytes</code>方法内部。并且，我们注意到，<code>synchronized</code>锁住的对象是<code>this</code>，即当前实例，这又使得创建多个<code>DownloadStatus</code>实例的时候，它们之间互不影响，可以并发执行。</p>
<p>当我们锁住的是 <code>this</code>实例的时候，实际上可以用 <code>synchronized</code>来修饰这个方法，因此这两种方法是等价的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">incrementTotalBytes</span><span class="params">()</span></span>&#123;</span><br><span class="line">       totalBytes++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，用<code>synchronized</code>修饰的方法就是<strong>同步方法</strong>，它表示整个方法都必须用<code>this</code>实例加锁。不能对其他实例加锁。</p>
<p>但是，对 <code>this</code> 实例加锁也是有缺点的。比如说：我又新建了一个<code>totalFiles</code>变量来记录已下载完成的文件总数。因为文件一多，很可能是两个文件同时下载完成的，因此我们也需要用 <code>synchronized</code>关键字来修饰</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/13.png" style="zoom:80%;"></p>
<p>那么问题来了：<code>incrementTotalByts</code>和<code>incrementTotalFiles</code>这两个方法都给 <code>this</code>对象上了锁。那么如果存在某一个时刻，要同时调用这两个方法的时候，必须等其中一个方法运行完之后把this对象解锁了之后才可以继续执行另一个方法。如果这只是一个小型应用，也许没事；但是如果这个应用非常庞大，需要上锁的参数非常多，那么同时调用的时刻会很多，会造成不必要的等待、降低程序的性能。</p>
<p>为了解决这个问题，我们可以给每一个需要上锁的变量新建一个专属对象。并用这个对象传入<code>synchronized</code>关键字。如下图所示：</p>
<p>我们创建了两个Object类型的对象，一个叫<code>totalBytesLock</code>用来锁住<code>totalBytes</code>; 以及<code>totalFilesLock</code>用来锁住<code>totalFiles</code> 变量。</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/14.png" style="zoom:80%;"></p>
<p>同步代码块能达成和同步方法一样的功能，但是效能比同步方法更高。</p>
<h3 id="线程交互"><a href="#线程交互" class="headerlink" title="线程交互"></a>线程交互</h3><p>线程交互是指两个线程之间通过通信联系对锁的获取与释放，从而达到较好的线程运行结果，避免引起混乱的结果。一般来说synchronized块的锁会让代码进入同步状态，即一个线程运行的同时让其它线程进行等待，那么如果需要进行实现更复杂的交互，则需要学习以下几个方法：</p>
<p>void notify(): 唤醒在此对象监视器上等待的单个线程。</p>
<p>void notifyAll(): 唤醒在此对象监视器上等待的所有线程。</p>
<p>void wait(): 让占用了这个同步对象的线程，临时释放当前的占用，并且等待。</p>
<p>wait()方法是使当前线程临时暂停，释放锁，并进入等待，其功能类似于sleep()方法，但是wait()需要释放锁，而sleep()不需要释放锁。</p>
<h5 id="任务："><a href="#任务：" class="headerlink" title="任务："></a>任务：</h5><p><strong>完善代码，利用wait()和notify()实现线程之间的交互。将关键代码写到实验报告中。</strong></p>
<p>还是用模拟多线程下载的例子。</p>
<p><code>DownloadStatus</code></p>
<p>首先我们在 <code>DownloadStatus</code> 中新建一个 <code>isDone</code>布尔变量并将其声明为volatile，来表明这个下载任务是否已经完成。并设定一个 <code>getter</code>返回<code>isDone</code> 和一个 <code>setter</code>将<code>isDown</code>设为True</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadStatus</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isDone;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> totalBytes;</span><br><span class="line">    <span class="keyword">private</span> Object totalBytesLock = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotalBytes</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> totalBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incrementTotalBytes</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (totalBytesLock)&#123;</span><br><span class="line">            totalBytes++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span>  <span class="title">isDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isDone;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isDone = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在<code>DownloadFileTask</code>类中，我们在下载结束后调用 <code>status.done()</code>将<code>isDone()</code> 设置为True并输出Download complete</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadFileTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DownloadStatus status;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DownloadFileTask</span><span class="params">(DownloadStatus status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;i&lt; <span class="number">10_000</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().isInterrupted()) <span class="keyword">return</span>;</span><br><span class="line">            status.incrementTotalBytes();</span><br><span class="line">        &#125;</span><br><span class="line">        status.done();</span><br><span class="line">        System.out.println(<span class="string">"Download complete:"</span>+Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在<code>ThreadDemo</code>类中，新建两个线程，第一个线程传入DownloadFileTask对象，第二个线程里面是个 Lambda表达式，它会一直询问status中的变量isDone是否为True，一直到下载完成 ，isDone==True,才会跳出循环并输出<code>totalBytes</code>的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">var</span> status = <span class="keyword">new</span> DownloadStatus();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DownloadFileTask(status));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> thread2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (!status.isDone())</span><br><span class="line">                System.out.println(status.getTotalBytes());</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(status.getTotalBytes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>刚才例子中，一直询问下载完成没。但是这样是很占用CPU的资源的。它可能会重复循环上亿次才能等到结果。</p>
<p>为了优化上面这种情况，我们可以用<code>wait()</code>和<code>notify()</code>方法</p>
<p>顾名思义，调用<code>wait()</code>方法后，线程进入等待状态，<code>wait()</code>方法不会返回，直到将来某个时刻，线程从等待状态被其他线程唤醒后，<code>wait()</code>方法才会返回，然后，继续执行下一条语句。<strong>注意，只能在锁对象上调用<code>wait()</code>方法</strong> 。<code>notify()</code>则是在<strong>相同的锁对象</strong>上作用，完成某件事后发出一个信号，让<code>wait()</code>去接收</p>
<p>比如下面这个例子，当我们要用while来询问<code>isDone()</code>是否为true的时候，我们对status上了一个锁。然后在里面调用<code>wait()</code>让线程2沉睡。再跑到<code>DownloadFileTask</code>类中，当下载完成时我们在 status上锁了的情况下调用 <code>notifyAll()</code>发出讯号。<code>wait()</code>收到后就会跳出循环，执行打印命令。</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/38.png" style="zoom:100%;"></p>
<p>通过这种机制我们可以降低CPU的负荷，优化程序性能。但同时，在不正确的地方使用<code>wait()</code>和<code>notify()</code>可能会造成很多难以解决的问题，因此我们不推荐这种方法。</p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p>编写一个程序，启动三个线程，三个线程的ID分别是A，B，C；每个线程将自己的ID值在屏幕上打印5遍，打印顺序是ABCABC…</p>
<p><code>MyThread</code> 类：</p>
<p>这里我们声明总线程数totalThreads，一个计数器 count ，一个进程号ID</p>
<p>判断当前线程是否需要打印的逻辑： 计数器%总线程数 == 当前线程的ID ，则打印进程名字</p>
<p>id由有参构造函数确定，这里 打印A的线程ID=0 ，打印B的线程ID=1，打印C的线程ID=2</p>
<p>注意，这里 count 要设置为 volatile 的，static的，因为这个变量是多个线程共享的，必须从主存中读取。此外，因为这个程序不是很大，所以我没有使用<code>wait()</code>和<code>notifyAll()</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> totalThreads;</span><br><span class="line">    <span class="comment">// 线程id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count % totalThreads != id)&#123;&#125;</span><br><span class="line">            System.out.print(Thread.currentThread().getName()+<span class="string">" "</span>);</span><br><span class="line">            MyThread.count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Main</code> 类：</p>
<p>在main方法中我们创建一个线程集合，然后利用有参构造创建三个线程对象，并规定他们的name分别是ABC</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Collection&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        MyThread.totalThreads = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MyThread.totalThreads; i++) &#123;</span><br><span class="line">            threads.add(<span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread(i),String.valueOf((<span class="keyword">char</span>)(i+<span class="string">'A'</span>))));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> thread:threads)</span><br><span class="line">            thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/15.png" style="zoom:80%;"></p>
<h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><p>编写两个线程，一个线程负责打印字母，另一个线程负责打印数字，两个线程同时进行打印，要求打印出来的结果的形式为</p>
<p>a1b23c456d7891 ……z……（数字为1-9的循环）</p>
<p>问题2和问题1的底层逻辑其实是共通的.</p>
<p>只不过这里没有办法只创建一个线程类了，因此我把公共的部分抽出来构成了一个新的类<code>PrintStatus</code>:</p>
<p>在这里我们设置了两个变量，一个是 volatile的计数器，我们用它来判断当前线程是否需要打印。第二个变量是totalThreads，用来记载当前线程数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintStatus</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> totalThreads;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotalThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> totalThreads;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTotalThreads</span><span class="params">(<span class="keyword">int</span> totalThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.totalThreads = totalThreads;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Main</code> 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        PrintStatus status = <span class="keyword">new</span> PrintStatus();</span><br><span class="line">        status.setTotalThreads(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> charPrinter = <span class="keyword">new</span> Thread(<span class="keyword">new</span> CharPrinter(status));</span><br><span class="line">        <span class="keyword">var</span> numberPrinter = <span class="keyword">new</span> Thread(<span class="keyword">new</span> NumberPrinter(status));</span><br><span class="line"></span><br><span class="line">        charPrinter.start();</span><br><span class="line">        numberPrinter.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CharPrinter</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharPrinter</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ID = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> PrintStatus status;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CharPrinter</span><span class="params">(PrintStatus status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (status.getCount() % status.getTotalThreads() != ID)&#123;&#125;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)(i+<span class="string">'a'</span>));</span><br><span class="line">            status.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NumberPrinter</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberPrinter</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ID = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> PrintStatus status;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> adder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumberPrinter</span><span class="params">(PrintStatus status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">27</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (status.getCount() % status.getTotalThreads() != ID)&#123;&#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = (adder+<span class="number">1</span>)%<span class="number">9</span> == <span class="number">0</span>?<span class="number">9</span>:(adder+<span class="number">1</span>)%<span class="number">9</span> ;</span><br><span class="line">                System.out.print(temp);</span><br><span class="line">                adder++;</span><br><span class="line">            &#125;</span><br><span class="line">            status.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里因为篇幅，我们只打印一个轮回就结束进程</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/16.png" style="zoom:80%;"></p>
<h3 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h3><p>编写程序，模拟三个窗口同时卖票，包括购票（可能存在购买多张的情况），退票（可能存在退多张的情况）和新进票，要求有余票时必须出售，无票时不能出售，购票时若无足量余票可选择继续等待或离开。</p>
<p> <code>Main</code>类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        <span class="keyword">int</span> windowNumber = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> buyNumber,refundNumber;</span><br><span class="line">        <span class="keyword">boolean</span> isLeave = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        TicketStatus ticketStatus = <span class="keyword">new</span> TicketStatus();</span><br><span class="line">        Scanner statusScanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        Scanner buyScanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        Scanner refundScanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        Scanner windowScanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        Scanner newTicketScanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> thread:threads)</span><br><span class="line">            thread.start();</span><br><span class="line">        <span class="keyword">while</span>(!isLeave)&#123;</span><br><span class="line">            System.out.println(<span class="string">"请输入要执行的操作。1代表购票；2代表退票；3代表查询余票；4代表离开; 5代表新进票"</span>);</span><br><span class="line">            status = statusScanner.nextInt();</span><br><span class="line">            <span class="keyword">switch</span> (status)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    System.out.println(<span class="string">"请问要到几号柜台进行办理购票操作？1/2/3"</span>);</span><br><span class="line">                    windowNumber = windowScanner.nextInt();</span><br><span class="line">                    System.out.println(<span class="string">"请问要购买几张票？"</span>);</span><br><span class="line">                    buyNumber = buyScanner.nextInt();</span><br><span class="line">                    ticketStatus.setSellNumber(buyNumber);</span><br><span class="line">                    ticketStatus.setOperation(status);</span><br><span class="line">                    <span class="keyword">new</span> Thread(<span class="keyword">new</span> TicketWindow(ticketStatus), String.valueOf(windowNumber)).start();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    System.out.println(<span class="string">"请问要到几号柜台进行办理退票操作？1/2/3"</span>);</span><br><span class="line">                    windowNumber = windowScanner.nextInt();</span><br><span class="line">                    System.out.println(<span class="string">"请问要退几张票？"</span>);</span><br><span class="line">                    refundNumber = refundScanner.nextInt();</span><br><span class="line">                    ticketStatus.setRefundNumber(refundNumber);</span><br><span class="line">                    ticketStatus.setOperation(status);</span><br><span class="line">                    <span class="keyword">new</span> Thread(<span class="keyword">new</span> TicketWindow(ticketStatus), String.valueOf(windowNumber)).start();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    System.out.println(<span class="string">"当前剩余票数: "</span>+ticketStatus.getTicketNumber());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    isLeave = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">var</span> thread:threads)</span><br><span class="line">                        thread.interrupt();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                    System.out.println(<span class="string">"请问要新进几张票？"</span>);</span><br><span class="line">                    <span class="keyword">int</span> newTicket = newTicketScanner.nextInt();</span><br><span class="line">                    ticketStatus.addNewTicket(newTicket);</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.println(<span class="string">"输入错误，请重试"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程：<code>TicketWindow</code>类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketWindow</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TicketStatus status;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TicketWindow</span><span class="params">(TicketStatus status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String name = Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">int</span> operation = status.getOperation();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        while (true) &#123;</span></span><br><span class="line">            <span class="keyword">switch</span> (operation) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    System.out.println(name + <span class="string">"号柜台为您办理"</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (status) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            status.sellTicket(status.getSellNumber());</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (NoTicketsException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    System.out.println(name + <span class="string">"号柜台为您办理"</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (status) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            status.refundTicket(status.getRefundNumber());</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (ExceedTicketsException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TicketStatus</code>类，用来存储余票,各种操作的状态，买卖票数等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketStatus</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger totalTickets = <span class="keyword">new</span> AtomicInteger(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> operation;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sellNumber;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> refundNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refundTicket</span><span class="params">(<span class="keyword">int</span> number)</span> <span class="keyword">throws</span> ExceedTicketsException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(totalTickets.get()+number&gt;<span class="number">1000</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExceedTicketsException();</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            totalTickets.addAndGet(number);</span><br><span class="line">            System.out.println(<span class="string">"退票成功！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">(<span class="keyword">int</span> number)</span> <span class="keyword">throws</span> NoTicketsException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number &gt; totalTickets.get())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoTicketsException();</span><br><span class="line">            totalTickets.addAndGet(-number);</span><br><span class="line">            System.out.println(<span class="string">"购票成功！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNewTicket</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        totalTickets.addAndGet(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTicketNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> totalTickets.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> operation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOperation</span><span class="params">(<span class="keyword">int</span> operation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.operation = operation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSellNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sellNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSellNumber</span><span class="params">(<span class="keyword">int</span> sellNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sellNumber = sellNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRefundNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> refundNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRefundNumber</span><span class="params">(<span class="keyword">int</span> refundNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.refundNumber = refundNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/18.png" style="zoom:80%;"></p>
<h3 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h3><p>编写10个线程，第一个线程从1加到10000，第二个线程从10001加20000…第十个线程从90001加到100000，最后再把10个线程结果相加，记录运行时间，并和串行相加时候的时间进行对比；编写50个线程，第一个线程从1加到10000，第二个线程从10001加20000……，最后再把50个线程结果相加，记录运行时间，并和串行相加时候的时间进行对比；编写100个线程，第一个线程从1加到10000，第二个线程从10001加20000……，最后再把100个线程结果相加，记录运行时间，并和串行相加时候的时间进行对比，给出对比结果。总结分析，单机情况下是不是线程越多越好，为什么。</p>
<p>串行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sequencial</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loop;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sequencial</span><span class="params">(<span class="keyword">int</span> loop)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loop = loop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span>  startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>;i&lt;loop*<span class="number">10_000</span>;i++)&#123;count++;&#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"串行程序运行时间："</span> + (endTime - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loop;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadDemo</span><span class="params">(<span class="keyword">int</span> loop)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loop = loop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">var</span> status = <span class="keyword">new</span> DownloadStatus();</span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">long</span>  startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="keyword">this</span>.loop;i++)&#123;</span><br><span class="line">            <span class="keyword">var</span> thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DownloadFileTask(status));</span><br><span class="line">            thread.start();</span><br><span class="line">            threads.add(thread);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> thread : threads)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(status.getTotalBytes());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();     </span><br><span class="line">        System.out.println(<span class="string">"并行程序运行时间："</span> + (endTime - startTime) + <span class="string">"ms"</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Main</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   		<span class="comment">// 传入的数据就是线程数</span></span><br><span class="line">        <span class="keyword">var</span> sequencialDemo = <span class="keyword">new</span> Sequencial(<span class="number">10000</span>);</span><br><span class="line">      <span class="comment">//循环次数=传入的数*10000</span></span><br><span class="line">        <span class="keyword">var</span> concurrencyDemo = <span class="keyword">new</span> ThreadDemo(<span class="number">10000</span>);</span><br><span class="line">        sequencialDemo.show();</span><br><span class="line">        concurrencyDemo.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个模型和线程同步模块所讲的例子一样，不过我们要计算一下运行时间</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>线程数</th>
<th>串行时间</th>
<th>并行时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>3</td>
<td>26</td>
</tr>
<tr>
<td>50</td>
<td>8</td>
<td>65</td>
</tr>
<tr>
<td>100</td>
<td>10</td>
<td>91</td>
</tr>
<tr>
<td>1000</td>
<td>11</td>
<td>498</td>
</tr>
<tr>
<td>10000</td>
<td>13</td>
<td>3018</td>
</tr>
</tbody>
</table>
</div>
<p>我们发现在一台电脑的情况下，串行时间比并行时间要快很多。因为并行操作会发生线程创建和上下文切换的开销。线程越多开销越大，因此并不是线程越多越好。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我在博客<a href="https://jasonxqh.github.io/2021/03/19/Java基础3/">Java基础3</a>中已经对多线程和并发做了详细的讨论了。但是这次的试验，又让我在复习的基础上对多线程编程有了更加深刻的认识。接下来的空闲时间需要学习Java的项目管理工具以及一些应用框架。</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/03/19/Java%E5%9F%BA%E7%A1%803/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/19/Java%E5%9F%BA%E7%A1%803/" itemprop="url">Java基础3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-19T00:27:30+08:00">
                2021-03-19
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2025-04-10T13:37:36+08:00">
                2025-04-10
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java基础3"><a href="#Java基础3" class="headerlink" title="Java基础3"></a>Java基础3</h1><h2 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h2><h3 id="What-are-Exceptions"><a href="#What-are-Exceptions" class="headerlink" title="What are Exceptions"></a>What are Exceptions</h3><p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/5.png" style="zoom:67%;"></p>
<p>当我们调用一个将字符串变成大写的函数、传入的却是一个空指针。运行后Java就会给我们一个报错： “name is null“ 。</p>
<p>Java给我们的报错信息非常有用，因为他能帮我们将发生错误的每一句代码都列出，并且一直到最深处。</p>
<h3 id="Types-of-Exceptions"><a href="#Types-of-Exceptions" class="headerlink" title="Types of Exceptions"></a>Types of Exceptions</h3><h4 id="Checked-exception"><a href="#Checked-exception" class="headerlink" title="Checked exception"></a>Checked exception</h4><p>比如说我想读取一个文件，但是这个文件刚刚被删掉了，这时候就会报错。Java 强迫我们在写这类代码的时候一定要做检查，是否存在该文件。否则在编译 的时候就会报错</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/6.png" style="zoom:67%;"></p>
<p>当我们新建了一个FileReader对象、要打开一个 file.txt文件时，Java会提醒我们要为其添加一个 exception，否则连编译都过不了。包括接下来我们要学的线程中的 <code>sleep()、join()</code>函数。</p>
<h4 id="Unchecked-exception-Runtime-exception"><a href="#Unchecked-exception-Runtime-exception" class="headerlink" title="Unchecked exception/Runtime exception"></a>Unchecked exception/Runtime exception</h4><p>如同我们刚才讲的例子： <code>NullPointerException</code> 还有其他几种 <code>Runtime Exceptions</code> ，它们不会在编译前就报错。因此我们要养成良好的编程习惯以及积累经验来规避这些问题</p>
<ul>
<li>ArithmeticException</li>
<li>IllegalArgumentException</li>
<li>IndexOutOfBoundsException</li>
<li>IllegalStateException</li>
</ul>
<p>Checked 和 Unchecked Excption 主要区别在：</p>
<ul>
<li>Runtime exceptions:<ul>
<li>在定义方法时<strong>不需要声明</strong>会抛出runtime exception;</li>
<li>在调用这个方法时<strong>不需要捕获</strong>这个runtime exception;</li>
</ul>
</li>
</ul>
<p>runtime exception是从java.lang.RuntimeException或java.lang.Error类衍生出来的。</p>
<ul>
<li>Checked exceptions:<ul>
<li>定义方法时<strong>必须声明</strong>所有可能会抛出的checked exception;</li>
<li>在调用这个方法时，<strong>必须捕获</strong>它的checked exception，不然就得把它的exception传递下去;</li>
</ul>
</li>
</ul>
<p>从逻辑的角度来说，checked exceptions和runtime exception是有不同的使用目的的。checked exception用来指示一种调用方<strong>能够直接处理</strong>的异常情况。而runtime exception则用来指示一种<strong>调用方本身无法处理</strong>或恢复的程序错误</p>
<h4 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h4><p>第三种是我们束手无策的错误，比如写了个无限循环，或者是内存溢出了。我们必须规避这种低级错误。</p>
<h3 id="Exceptions-Hierarchy"><a href="#Exceptions-Hierarchy" class="headerlink" title="Exceptions Hierarchy"></a>Exceptions Hierarchy</h3><p>现在我们来看一下 Exception 的组织结构。首先，最上层的是 <code>Throwable Class</code> ,这个class中包含了<code>Exception class</code>和<code>Error</code>两个类。  Exception 类中又包括 <code>RuntimeException class</code> 也就是unchecked Exception</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/7.png" style="zoom:67%;"></p>
<h3 id="Catching-Exceptions"><a href="#Catching-Exceptions" class="headerlink" title="Catching Exceptions"></a>Catching Exceptions</h3><p>对于 checked exception, 我们可以用 <code>try-catch</code> 代码块来捕捉错误：</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/9.png" style="zoom:67%;"></p>
<p>这样既可以打印 StackTrace来帮助我们找到错误，又可以让整个程序正常结束。最终，问题出在 Java.io库中的open0函数。</p>
<h3 id="Catching-Multiple-Types-of-Exceptions"><a href="#Catching-Multiple-Types-of-Exceptions" class="headerlink" title="Catching Multiple Types of Exceptions"></a>Catching Multiple Types of Exceptions</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader(<span class="string">"File.txt"</span>);</span><br><span class="line">            <span class="keyword">var</span> value = reader.read();</span><br><span class="line">            <span class="keyword">new</span> SimpleDateFormat().parse(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (FileNotFoundException | ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Could not read data"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们想要捕捉多个 Exception，我们可以使用多个 catch块。如果报错的信息是一样的，我们还可以用 或 运算符将它们放在一起。</p>
<p>注意，<code>IOException</code> 这个 catch block不能放到前面，否则会报错：因为IOException 包含了所有输入输出的错误，是一个“兜底“的类，如果将其放在第一个，就导致FileNotFoundException被IOException处在的代码块率先捕捉了。</p>
<h3 id="The-finally-Block"><a href="#The-finally-Block" class="headerlink" title="The finally Block"></a>The finally Block</h3><p>如果reader成功打开、我做好处理之后，想要把文件关掉，这时候应该怎么写？</p>
<p>我们应该把 <code>reader.close()</code>放在try代码块中吗？ 显然不行，因为如果try成功打开了文件，但在<code>var value = reader.read();</code>时抛出了一个错误，会直接跳到catch块，try后面的代码就不再被执行了。</p>
<p>我们应该直接把 <code>reader.close()</code>放在catch之后吗？ 貌似也不行。因为这样如果在未来我们在try-catch 和 close两者之间插入新的代码，并抛出新的错误的时候，reader还是不会被正常关闭。</p>
<p>因此，我们应该使用 finally block.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FileReader reader = <span class="keyword">null</span>;<span class="comment">//一定要预设为null不然finally block不好做判断</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reader = <span class="keyword">new</span> FileReader(<span class="string">"File.txt"</span>);</span><br><span class="line">            <span class="keyword">var</span> value = reader.read();</span><br><span class="line">            <span class="keyword">new</span> SimpleDateFormat().parse(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Could not read data"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(reader!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>finally在try代码块正常被进入执行，jvm正常执行处理的情况下，是一定会被执行的。</strong> 如果在 try block中存在return；那么finally的执行时间是：retrun表达式执行之后，在return返回操作之前。</p>
<h3 id="The-try-with-resources-Statement"><a href="#The-try-with-resources-Statement" class="headerlink" title="The try-with-resources Statement"></a>The try-with-resources Statement</h3><p>但是像刚才那样写finally block 会比较丑。我们有更好的方法来实现： 就是将申明对象、打开文件都放到 try后面的括号当中，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader(<span class="string">"File.txt"</span>)) &#123;</span><br><span class="line">            <span class="keyword">var</span> value = reader.read();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Could not read data"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法叫做 <code>try-with-resources Statement</code>,这样一来，我们就不用显式地写 close() 了，jvm会自动帮我们生成和上面的finally block一样的代码。</p>
<p><a href="https://docs.oracle.com/en/java/javase/16/docs/api/index.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/16/docs/api/index.html</a></p>
<p>在官方的文档中，我们可以找到AutoCloseable这个接口，这个接口下所有的子类都可以用这种<code>try-with-resources Statement</code>方法来自动关闭。比如说：FileReader、FileWriter这样的类。</p>
<h3 id="Throwing-Exceptions"><a href="#Throwing-Exceptions" class="headerlink" title="Throwing Exceptions"></a>Throwing Exceptions</h3><p>之前我们做的都是找到错误、抓住错误，但是现在我们要来主动抛出一个错误。</p>
<p>首先我们来讲 <code>defensive programming</code> ，也就是说遇到了错误，我们主动抛出并终结整个程序，如：</p>
<p> <img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/10.png" style="zoom:67%;"></p>
<p>我们新建了一个类，这里面会对value值进行一个判断，如果value小于0，就会抛出一个 <code>IllegalArgumentException()</code>错误，并结束整个程序。</p>
<p>如果我们的程序对value值得符号要求很高，如果输入不合法的值对整个程序的性能造成很大的影响(如库、框架等供多人使用的程序)，那么我们就应该适用这种 <code>defensive programming</code> 的方法，严格要求。</p>
<p>那么如果要throw一个 Checked Exception,该怎么写呢？比如说我在 Account 账户中抛出一个 IOException()这类异常，然后我必须在main函数中做一个 try-catch block 来接住这个exception</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/11.png" style="zoom:67%;"></p>
<p>注意了，在 Account 类中的 desposit 函数如果要抛出一个 <code>IOException</code>的话，必须在函数声明后面标明：<code>throws IOException</code>来告诉调用方我这个方法可能会抛出一个异常，而你调用者需要接收。</p>
<h3 id="Re-throwing-Exceptions"><a href="#Re-throwing-Exceptions" class="headerlink" title="Re-throwing Exceptions"></a>Re-throwing Exceptions</h3><p>现在我们在 ExceptionDemo 中接收 Account 抛出来的信息，然后再main函数中调用 <code>ExceptionDemo.show()</code>， 如果我现在希望ExceptionDemo收到异常信息后能将 StackTrace 记录到日志，并让main函数向用户打印一个有好的信息，应该怎么办？</p>
<p>这时候，我们应该 Re-throwing ,也就是说在收到Account  发出的异常信号的时候，ExceptionsDemo再向它的调用方(也就是main) 抛出一个错误，类似于一个接力的效果。然后在main中用<code>try-catch</code> 接收信号并打印一些信息：</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/12.png" style="zoom:67%;"></p>
<h3 id="Custom-Exceptions"><a href="#Custom-Exceptions" class="headerlink" title="Custom Exceptions"></a>Custom Exceptions</h3><p>Java已经为我们提供了很多基础异常类了，但是有些时候我们还是需要为我们的项目客制化一些异常。</p>
<p>比如说刚才那个例子，我在Account 中设立一个 withdraw(取钱的函数)，方法逻辑是：如果要取出的钱大于账户余额，那么就抛出一个异常。但这时用java提供的标准异常也不太贴切，因此我们可以自定义一个异常。</p>
<p>首先我们要创建一个自定义的异常类，异常类要以 <code>Exception</code>作为结尾，要有辨识度。然后我们要决定这个异常类是属于 <code>checked exception</code> (继承Exception类) 还是 <code>unchecked exception</code> (继承RuntimeException类)，然后</p>
<p>继承Exception 类之后，我们要自定义异常警告。因为 异常类是一个有参构造函数，因此我们还需要设置<code>super(&quot;异常信息&quot;)</code> 。这里我们也提供了两种构造函数，一种默认构造函数直接设置异常信息为 Insufficient funds in your account, 第二种则是让调用者自定义报错信息的有参构造函数。</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/13.png" style="zoom:67%;"></p>
<h3 id="Chaining-Exceptions"><a href="#Chaining-Exceptions" class="headerlink" title="Chaining Exceptions"></a>Chaining Exceptions</h3><p>Chaining Exception 就是将一个更广泛的异常包裹一个比较具体的异常。那刚才的例子来说，我们有一个比较具体的异常： <code>InsufficientFundsException()</code> 但是造成取钱失败的异常还可能有很多种，因此我们可以创建一个更加广泛地异常类 <code>AccountException()</code> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.exceptions;</span><br><span class="line"><span class="comment">//这里我super中传入的是一个异常的原因，比如 InsufficientFundsException 这个异常类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountException</span><span class="params">(Exception cause)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在 Account 类当中，当取款大于余额的时候，我们会向上抛出一个 AccountException类，并在这个类中传入原因：InsufficientFundsException，告诉调用者这是因为余额不够导致的账户异常。这就是 chain exception</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">float</span> value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(value&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">float</span> value)</span> <span class="keyword">throws</span> AccountException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(value &gt; balance)</span><br><span class="line">            <span class="keyword">throw</span>  <span class="keyword">new</span> AccountException(<span class="keyword">new</span> InsufficientFundsException());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ExceptionsDemo类中,我们捕捉一个 AccountException类，然后通过 <code>e.getCause()</code> 获取AccountException中的异常类型并通过<code>getMessage()</code>打印出改原因的异常信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> account = <span class="keyword">new</span> Account();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            account.withdraw(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AccountException e) &#123;</span><br><span class="line">            <span class="keyword">var</span> cause = e.getCause();</span><br><span class="line">            System.out.println(cause.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h2><p>泛型就是参数化类型</p>
<ul>
<li>适用于多种数据类型执行相同的代码</li>
<li>泛型中的类型在使用时指定</li>
<li>泛型归根到底就是C++中的“模版”</li>
</ul>
<h3 id="The-Need-for-Generics"><a href="#The-Need-for-Generics" class="headerlink" title="The Need for Generics"></a>The Need for Generics</h3><p>比如我创建了一个 <code>List()</code> 类，如下：</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/14.png"></p>
<p>那么如果我想创建一个 User 类的List，就要创建一个新的 UserList 类，久而久之，类就变得很繁杂。这时候我们就需要用到泛型了。</p>
<h3 id="A-Poor-Solution"><a href="#A-Poor-Solution" class="headerlink" title="A Poor Solution"></a>A Poor Solution</h3><p>遇到这种情况，使用 <code>Object Class</code> 是一种下策。因为虽然 所有的类都继承自Object类，但是有很多缺点</p>
<ol>
<li>比如我向Object List中存放了很多的元素(如Integer.valueOf(1)), 现在我想通过get 取出 List当中的第一个元素，但是这时候返回的类型是 Object,要得到int类型的返回结果我们必须进行强制类型转换，否则就会造成报错。</li>
<li>此外，List的管理会变得比较混乱，我们会搞不清楚 List中到底存储着什么类型的数据。</li>
</ol>
<h3 id="Generic-Classes"><a href="#Generic-Classes" class="headerlink" title="Generic Classes"></a>Generic Classes</h3><p>我们新创建一个 <code>GenericList</code> 类，需要在尖括号中一般使用 E或者T 来代表种类。</p>
<p>这里我们声明一个 类型为 T 的数组，因为我们没有办法直接 <code>new T[10]</code>，因为我们不知道传进来的是 int还是string，没办法实例化。这里我们必须创建一个 Object数组然后将其用强制类型转换变成 T 类型。</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/15.png"></p>
<p>然后 我们在main函数就可以声明各种类型的 list了,注意在声明的时候要传入数据类型，而且调用get()方法的时候也不用进行强制类型转换了。</p>
<h3 id="Generics-and-Primitive-Types"><a href="#Generics-and-Primitive-Types" class="headerlink" title="Generics and Primitive Types"></a>Generics and Primitive Types</h3><p>在声明泛型类实例的时候，我们不能穿入 Primitive Types，即 int, boolean，float 之类</p>
<p>如果我们要将这些类型的数据存入到泛型类实例当中，我们就必须要使用到 <strong>Wrapper class</strong></p>
<p>Java中每一个  <strong>Primitive Type</strong> 都有一个对应的 <strong>Wrapper class</strong>(包装类)</p>
<ul>
<li>int -&gt; Integer</li>
<li>float -&gt; Float</li>
<li>boolean -&gt; Boolean</li>
</ul>
<h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h3><p>如果我们只想让我们的泛型存储数值类型的数据，那么我们可以让 <code>&lt;T extends Number&gt;</code> </p>
<p>所有的包装类<strong>（Integer、Long、Byte、Double、Float、Short）</strong>都是抽象类 Number 的子类。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">包装类</th>
<th style="text-align:left">基本数据类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">boolean</td>
</tr>
<tr>
<td style="text-align:left">Byte</td>
<td style="text-align:left">byte</td>
</tr>
<tr>
<td style="text-align:left">Short</td>
<td style="text-align:left">short</td>
</tr>
<tr>
<td style="text-align:left">Integer</td>
<td style="text-align:left">int</td>
</tr>
<tr>
<td style="text-align:left">Long</td>
<td style="text-align:left">long</td>
</tr>
<tr>
<td style="text-align:left">Float</td>
<td style="text-align:left">float</td>
</tr>
<tr>
<td style="text-align:left">Double</td>
<td style="text-align:left">Double</td>
</tr>
</tbody>
</table>
</div>
<p>这时候，我再创建一个 String 类型的泛型实例就会报错了。</p>
<p>除了<code>extends Number</code> 之外，我们还可以 <code>extends Comparable</code> ,也就是只能使用可比较的数据类型： String, Integer等，但是如果我们直接传入 User，就会报错，因为我们自己申明的User类暂时是不能比较的。</p>
<p>要想 User能够比较，我们还需要在声明 User 类的时候让其 implements Comparable,如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">User</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(User o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意了，这里要在 Comparable后面用尖括号写上User,然后让Idea自动生成一个 <code>compareTo</code> 的重写函数，这样重写函数中的参数就是User，否则就是Object，而Object范围太广，不太安全。</p>
<p>还可以是 extends Cloneable,是另外一个很有用的接口。比如:<code>&lt;T extends Comparable &amp; Cloneable &gt;</code> </p>
<h3 id="Type-Erasure"><a href="#Type-Erasure" class="headerlink" title="Type Erasure"></a>Type Erasure</h3><p>现在我们在底层看看泛型是怎么实现的。</p>
<p> 我们首先看看没有限制条件的 Generics 的 Bytecode:</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/16.png"></p>
<p>我们发现在ByteCode里面，我们声明的T类型的数组都变成了 Object数组。 也就是说和我们一开始自己写的Object数组是一样的，那么泛型和Object数组的区别在哪里呢？</p>
<p>在于编译的时候Java会帮助我们检查数据类型是否正确，而自己写的Object数组则不会判断，我们可以传入数字也可以是实例化的对象。因此，泛型更便于我们对数据进行管理。 </p>
<p>当我们对泛型做出限定的时候，如 Comparable、Number， ByteCode中数据类型也会从Object变为Number、Comparable等。</p>
<h3 id="Comparable-Interface"><a href="#Comparable-Interface" class="headerlink" title="Comparable Interface"></a>Comparable Interface</h3><p><a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Comparable.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Comparable.html</a></p>
<p>我们上面说了，可以通过 User implements Comparable来把User类变成可比较的类,注意了，这里我们要传入比较的数据类型，否则Java会默认是两个Object在做比较。</p>
<p>如下面这段代码，我们在User里面创建一个points的变量，然后对其进行比较。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.generics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">User</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> points;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> points)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.points = points;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(User other)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// this &lt; o -&gt; -1</span></span><br><span class="line">        <span class="comment">// this == o -&gt; 0</span></span><br><span class="line">        <span class="comment">// this &gt; o -&gt; 1</span></span><br><span class="line">        <span class="keyword">return</span> points- other.points;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在main函数中，我们就可以对两个User实例进行比较</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> com.company.generics.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> user1 = <span class="keyword">new</span> User(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">var</span> user2 = <span class="keyword">new</span> User(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">if</span>(user1.compareTo(user2)&lt;<span class="number">0</span>)</span><br><span class="line">            System.out.println(<span class="string">"user1&lt;user2"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(user1.compareTo(user2)==<span class="number">0</span>)</span><br><span class="line">            System.out.println(<span class="string">"user1==user2"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"user1&gt;user2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Generic-Methods"><a href="#Generic-Methods" class="headerlink" title="Generic Methods"></a>Generic Methods</h3><p>除了泛型类，还有泛型方法。 在使用限定词的时候，类是 implements， 而方法则是 extends</p>
<p>比如我创建一个 Utils 类，里面有一个max方法，用来返回两个对象中较大的那一个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.generics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function">T <span class="title">max</span><span class="params">(T first ,T second)</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> (first.compareTo(second)&gt;<span class="number">0</span> )? first:second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数定义时，需要在尖括号中写 <code>&lt;T extends Comparable&lt;T&gt;&gt;</code> 返回数据类型也为T，然后利用<code>compareTo</code> 函数来比较二者的大小：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    User max_user = Utils.max(<span class="keyword">new</span> User(<span class="number">10</span>),<span class="keyword">new</span> User(<span class="number">20</span>));</span><br><span class="line">    System.out.println(max_user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果输出的却是这样的结果：<code>com.company.generics.User@3f99bd52</code></p>
<p>是因为返回的对象调用 toString()函数，因此输出了一个hashcode，要解决这个问题，我们需要在 编写 User类的时候重写 <code>toString()</code> 函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">User</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> points;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> points)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.points = points;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(User other)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// this &lt; o -&gt; -1</span></span><br><span class="line">        <span class="comment">// this == o -&gt; 0</span></span><br><span class="line">        <span class="comment">// this &gt; o -&gt; 1</span></span><br><span class="line">        <span class="keyword">return</span> points- other.points;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"points="</span> + points +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次运行得到： <code>User{points=20}</code> </p>
<h3 id="Multiple-Type-Parameters"><a href="#Multiple-Type-Parameters" class="headerlink" title="Multiple Type Parameters"></a>Multiple Type Parameters</h3><p>不管是泛型类还是泛型方法都可以传入多种不同类型的参数，我们各给出一个例子：</p>
<p><strong>泛型类</strong></p>
<p>这里我们创建了一个 键值对的类，K 代表key的数据类型，V代表value的数据类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.generics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.Key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyValuePair</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KeyValuePair</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，对于方法我们也可以使用多个类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T key,V value)</span></span>&#123;</span><br><span class="line">    System.out.println(key + <span class="string">"="</span>+ value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Generic-Classes-and-Inheritance"><a href="#Generic-Classes-and-Inheritance" class="headerlink" title="Generic Classes and Inheritance"></a>Generic Classes and Inheritance</h3><p>当我们用一个类来继承泛型类的时候，关系可如下图所示：</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/17.png"></p>
<p>也就是说Integer继承了Number，在一般的实例中，Number 是可以接收 Interger类型的参数的；但是在泛型类的实例中 如<code>Box&lt;Number&gt;</code>  只能接收数据类型为Number的数据，不接受 <code>Box&lt;Integer&gt;</code> 和 <code>Box&lt;Double&gt;</code>的参数。</p>
<p>所以说在泛型类中，虽然传入的类之间存在继承关系，但是他们的泛型类是不存在继承关系的。原因在于它们都继承自Object类型，但是二者相互独立。</p>
<p>我们用刚才的例子看一下：</p>
<p>首先我们创建一个 <code>Instructor</code> 类，并让其继承自<code>User</code> 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.generics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Instructor</span> <span class="keyword">extends</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Instructor</span><span class="params">(<span class="keyword">int</span> points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(points);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们在Utils中声明两个方法，一个是普通的 <code>printUser</code>方法，另一个则是接收 <code>GenericList&lt;User&gt;</code> 的<code>printUsers</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printUsers</span><span class="params">(GenericList&lt;User&gt; users)</span></span>&#123;</span><br><span class="line">    System.out.println(users.get(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果在 main 函数当中，可以用printUser来打印一个 Instructor实例，但是不能用 printUsers来打印一个 <code>GenericList&lt;Instructor&gt;</code> 实例：</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/18.png"></p>
<p>为了解决这个问题，我们可以用Wildcards(术语叫通配符，其实就类似于扑克中的万能牌)</p>
<h3 id="Wildcards"><a href="#Wildcards" class="headerlink" title="Wildcards"></a>Wildcards</h3><p>我们可以将 printUsers方法这样写：问号就是通配符，代表着一个unknown的数据类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printUsers</span><span class="params">(GenericList&lt;?&gt; users)</span></span>&#123;</span><br><span class="line">    System.out.println(users.get(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样虽然解决了问题，但是这样一来，我们可以向 <code>printUsers</code>传入任何数据类型，比如Integer，String等，把他们当做Users打印出来显然是不行的。因此在使用通配符之后还需要加上限定条件</p>
<h4 id="extends"><a href="#extends" class="headerlink" title="? + extends"></a>? + extends</h4><p>当我们使用了通配符 ？之后，相当于java创建了一个我们看不见的 类叫做 <code>CAP#1</code> 用来存放未知的数据类型。 因为可能有多个通配符，所以CAP后面的编号也不同。</p>
<p>如果我们用 <code>?+extends User</code> 的话，就相当于 Class CAP#1 继承了User，而 Instructor 也是继承User的，因此这时候可以向printUsers传入 User以及它的子类，而不能传入 Integer、String这种数据类型了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printUsers</span><span class="params">(GenericList&lt;? extends User&gt; users)</span></span>&#123;</span><br><span class="line">    User x = users.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如这里我们可以用 User来接收get函数的返回值，因为User是 Cap#1的父类，但是不能用Instructor来接收，因为Instructor和Cap#1是”兄弟“关系，是独立的两个类。</p>
<p>但是，我们不能在这里使用 <code>add()</code>函数。因为CAP#1是个抽象概念，我们没有办法实例化一个CAP#1对象并将其加到Users当中去。</p>
<p>因此如果选择 <code>?+extends</code> 对象是只读不可写的</p>
<h4 id="super"><a href="#super" class="headerlink" title="? + super"></a>? + super</h4><p>super和extends则是刚好相反。只可写不可读</p>
<p>在使用了super关键词后，？相当于 User类的父类，也就是 Object Class</p>
<p>因此<code>GenericList&lt;? super User&gt; users</code> 之后,Java会把users看做是：<code>GenericList&lt;Object&gt; temp</code> 这个对象</p>
<p>这时候我们调用 add方法，因为添加的对象都是Object的子类，因此不会报错。然而我们却无法使用get方法了，因为这时候get的返回类型为Object，但是Java并不知道你用什么类型来接收。很可能两种数据类型是不兼容的，因此不能使用：</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/19.png"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>总结：</th>
<th>可读</th>
<th>可写</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>?+extends</strong></td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td><strong>?+super</strong></td>
<td>×</td>
<td>√</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>提到集合就不得不提一下数组，好多集合底层都是依赖于数组的实现。数组一旦初始化后，长度就确定了，存储数据对象不能达到动态扩展，其次数组存储元素不便于对数组进行<code>添加</code>、<code>修改</code>、<code>删除操作</code>，而且数组可以存储重复元素。这个时候集合对作用显现出来了。集合分为<code>Collection</code>和<code>Map</code>两种体系。Collection的集合类的继承树如下图所示：</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/21.png"></p>
<p>化简可得：</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/22.png"></p>
<p>Collection 接口有 3 种子类型集合: <code>List</code>、<code>Set</code> 和 <code>Queue</code>，再下面是一些抽象类，最后是具体实现类。常用的有 <code>ArrayList</code>用来当数组用，<code>LinkedList</code>即链表；在<code>Queue</code>下常用的是<code>PriorityQueue</code>,即优先队列；在<code>Set</code>下常用 <code>Hashset</code> 用来做哈希映射。</p>
<p>简单的来说，Java中的collection类似于C++中的stl，有多种封装好的数据结构。</p>
<h3 id="The-Iterable-Interface"><a href="#The-Iterable-Interface" class="headerlink" title="The Iterable Interface"></a>The Iterable Interface</h3><p>下面是 Iterable的官方文档：</p>
<p><a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Iterable.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/lang/Iterable.html</a></p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/23.png"></p>
<p>在这个接口中一共有三个函数，我们要重写iterator()这个函数，因为这个函数会返回一个迭代器对象。迭代器的数据类型取决于泛型对象的数据类型</p>
<p>当一个类继承了 Iterable之后，他就可以被迭代了。这里，我们先用自建的代码来模拟 ArratList 。这里我虽然重写了Iterator但是没有写任何代码，只是为了做个演示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> T[] items = (T[])<span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在main函数中，我们用iterator来接收迭代器，这里返回的是一个String 类型的迭代器。</p>
<p>iterator中两个内置方法很重要，一个是 hasNext()， 也就是用来判断是否存在下一个元素；还有一个是next()即让迭代器指向下一个元素。使用while循环，可以遍历对象中的所有元素。(虽然hasNext()和next()我暂时还没有重写)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> list = <span class="keyword">new</span> GenericList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">var</span> iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        <span class="keyword">var</span> current = iterator.next();</span><br><span class="line">        System.out.println(current);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实，while循环可以这样来简化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> item : list)&#123;</span><br><span class="line">     	System.out.println(item);</span><br><span class="line">   	&#125;</span><br></pre></td></tr></table></figure>
<p>在底层的bytecode都是一样的。</p>
<p>使用了Iterable接口，我们就没有必要在GenericList类中将 <code>private T[] items</code>设置成 <code>public T[] items</code>，照样可以迭代。</p>
<h3 id="The-Iterator-Interface"><a href="#The-Iterator-Interface" class="headerlink" title="The Iterator Interface"></a>The Iterator Interface</h3><p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/24.png"></p>
<p>现在我们继续实现我们自建的 GenericList，刚才只是说了我们可以实现什么功能，但并没有将方法都写出来。</p>
<p>首先我们要在 <code>GenericList</code>中创建一个新的类，叫做<code>ListIterator</code>, 这个类讲接入 <code>Iterator</code>接口并重写 <code>hasNext()</code>、<code>next()</code> 两个函数。并让<code>GenericList</code>中的 <code>iterator</code>方法的返回一个 <code>ListIterator</code>对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] items = (T[]) <span class="keyword">new</span> Object[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">        items[count++] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//返回一个ListIterator实例，并将自身(GenericList)当做参数传入。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListIterator(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ListIterator 类是定义在Generic 里面的，因此能访问到私有变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ListIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">private</span> GenericList&lt;T&gt; list;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"><span class="comment">//定义 ListIterator的有参构造函数，传入参数类型为 GenericList&lt;T&gt;</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ListIterator</span><span class="params">(GenericList&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.list = list;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//重写 hasNext()函数</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (index &lt; list.count);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//重写next函数，返回list中的下一个元素</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> list.items[index++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，一个建议的ArrayList就做完了，我们可以测试一下让其遍历输出：</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/25.png"></p>
<h3 id="The-Collection-Interface"><a href="#The-Collection-Interface" class="headerlink" title="The Collection Interface"></a>The Collection Interface</h3><p>学会了ArrayList原理之后，我们正式来讲讲 Collection 接口, 这是官方文档</p>
<p><a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Collection.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Collection.html</a></p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/26.png"></p>
<p>在文档中，我们看到，Collection实现了 <code>Iterable&lt;E&gt;</code> 接口，这说明 collection中的子接口以及子类都是可以迭代的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsDemo</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">         Collection&lt;String&gt; collection = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         collection.add(<span class="string">"a"</span>);</span><br><span class="line">         collection.add(<span class="string">"b"</span>);</span><br><span class="line">         collection.add(<span class="string">"c"</span>);</span><br><span class="line">         Collections.addAll(collection,<span class="string">"d"</span>,<span class="string">"e"</span>,<span class="string">"f"</span>);</span><br><span class="line"></span><br><span class="line">         collection.remove(<span class="string">"a"</span>);</span><br><span class="line">         System.out.println(collection);</span><br><span class="line">         System.out.println(collection.size());</span><br><span class="line"></span><br><span class="line">         <span class="keyword">var</span> objectArray = collection.toArray();</span><br><span class="line">         <span class="keyword">var</span> stringArray = collection.toArray(<span class="keyword">new</span> String[<span class="number">5</span>]);</span><br><span class="line">         System.out.println(objectArray);</span><br><span class="line">         System.out.println(stringArray);</span><br><span class="line"></span><br><span class="line">         Collection&lt;String&gt; other = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         other.addAll(collection);</span><br><span class="line"></span><br><span class="line">         System.out.println(collection.contains(<span class="string">"a"</span>));</span><br><span class="line">         collection.clear();</span><br><span class="line">         System.out.println(collection.isEmpty());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是要注意了， collection是不支持通过索引访问的，即我们不能使用中括号或者 <code>add(index,element)</code>这种方法来添加元素的。</p>
<h3 id="The-List-Interface"><a href="#The-List-Interface" class="headerlink" title="The List Interface"></a>The List Interface</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//List 同样也有 add 操作，但是list可以通过index来决定插入的位置</span></span><br><span class="line">        list.add(<span class="string">"a"</span>);</span><br><span class="line">        list.add(<span class="string">"b"</span>);</span><br><span class="line">        list.add(<span class="string">"c"</span>);</span><br><span class="line">        list.add(<span class="number">0</span>,<span class="string">"!"</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"><span class="comment">// 打印得到： [!, a, b, c]， 同样也有 addAll 方法。</span></span><br><span class="line">        Collections.addAll(list,<span class="string">"d"</span>,<span class="string">"e"</span>,<span class="string">"f"</span>);</span><br><span class="line"><span class="comment">// set 是替换的方法，这里我们将 list中的第一个元素(!)替换成 "a+"</span></span><br><span class="line">        list.set(<span class="number">0</span>,<span class="string">"a+"</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"><span class="comment">//打印得到：[a+, a, b, c, d, e, f]</span></span><br><span class="line"><span class="comment">//删除第一个元素</span></span><br><span class="line">      	list.remove(<span class="number">0</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line"><span class="comment">//打印得到：[a, b, c, d, e, f]</span></span><br><span class="line">      	</span><br><span class="line">      <span class="comment">//打印出元素的"b"的位置，打印得： 1 </span></span><br><span class="line">        System.out.println(list.indexOf(<span class="string">"b"</span>));</span><br><span class="line">      <span class="comment">//打印出元素"ss"的位置，打印得： -1 因为ss并不在list中</span></span><br><span class="line">        System.out.println(list.indexOf(<span class="string">"ss"</span>));</span><br><span class="line">			<span class="comment">// 打印出list的子列表，即[a,b],因为不包括list[2]</span></span><br><span class="line">        System.out.println(list.subList(<span class="number">0</span>,<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="The-Comparable-Interface"><a href="#The-Comparable-Interface" class="headerlink" title="The Comparable Interface"></a>The Comparable Interface</h3><p>在泛型那章已经讲过 Comparable Interface了，一般来说我们自定义的类如果要实现Comparable接口的话，一般需要重写 compareTo 和 toString 两个方法，如下面这个比较字符串的 Customer类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Customer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Customer other)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// this &lt; other -&gt; -1</span></span><br><span class="line">        <span class="comment">// this == other -&gt; 0</span></span><br><span class="line">        <span class="comment">// this &gt; other -&gt; 1</span></span><br><span class="line">        <span class="keyword">return</span> name.compareTo(other.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="The-Comparator-Interface"><a href="#The-Comparator-Interface" class="headerlink" title="The Comparator Interface"></a>The Comparator Interface</h3><p>现在我们虽然实现了 Customer的排名，但实现起来却比较的麻烦，需要在类内实现。这时Comparator这个接口就可以在类外实现对象的比较。</p>
<p><strong>简单来说，Comparable就是定义一个单独的对象比较器，继承自Comparator接口，实现compare（）方法</strong></p>
<p>比如现在 Customer 中多了一个 Email 参数，然后我们就新建一个 <code>EmailComparator</code>类如下：</p>
<p>在这个类中我们重写 compare方法并按照email进行排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Customer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Customer o1, Customer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getEmail().compareTo(o2.getEmail());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在main函数中我们对Customer数组进行一个排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Customer&gt; customers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    customers.add(<span class="keyword">new</span> Customer(<span class="string">"b"</span>, <span class="string">"e3"</span>));</span><br><span class="line">    customers.add(<span class="keyword">new</span> Customer(<span class="string">"a"</span>, <span class="string">"e2"</span>));</span><br><span class="line">    customers.add(<span class="keyword">new</span> Customer(<span class="string">"c"</span>, <span class="string">"e1"</span>));</span><br><span class="line">  <span class="comment">//在调用sort的时候，将比较器放在第二个参数上</span></span><br><span class="line">    Collections.sort(customers,<span class="keyword">new</span> EmailComparator()); </span><br><span class="line">  	System.out.println(customers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印得到 [c, a, b]，说明确实是按照email进行排列的</p>
<h3 id="The-Queue-Interface"><a href="#The-Queue-Interface" class="headerlink" title="The Queue Interface"></a>The Queue Interface</h3><p>现在我们来讲 队列接口，这是<code>Queue&lt;E&gt;</code> 的文档：</p>
<p><a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Queue.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Queue.html</a></p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/27.png"></p>
<p>我们看到在 Queue接口下比较常用的就是 ArrayDeque(先进先出)、LinkedList(即继承自Queue又继承自List)、PriorityQueue等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Queue&lt;String&gt; queue  = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">  <span class="comment">//和list一样，queue也有add函数，但是加到队列的末尾</span></span><br><span class="line">  	queue.add(<span class="string">"c"</span>);</span><br><span class="line">    queue.add(<span class="string">"a"</span>);</span><br><span class="line">    queue.add(<span class="string">"b"</span>);</span><br><span class="line">  <span class="comment">// peek()就是获取队列的第一个元素</span></span><br><span class="line">    <span class="keyword">var</span> front = queue.peek();</span><br><span class="line">    System.out.println(front);<span class="comment">// c</span></span><br><span class="line">    System.out.println(queue);<span class="comment">// [c, a, b]</span></span><br><span class="line">    <span class="keyword">var</span> remove = queue.remove();<span class="comment">// 删除第一个元素</span></span><br><span class="line">    System.out.println(remove);<span class="comment">// c</span></span><br><span class="line">    System.out.println(queue);<span class="comment">// [a, b]</span></span><br><span class="line">		<span class="comment">//poll()和remove()都是删除队列第一个元素</span></span><br><span class="line">  	<span class="comment">//他们的唯一区别就是当队列为空时，poll返回null而remove会抛出异常</span></span><br><span class="line">  	System.out.println(queue.poll());<span class="comment">// a</span></span><br><span class="line">    queue.poll();</span><br><span class="line">    System.out.println(queue.poll());<span class="comment">// null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="The-Set-Interface"><a href="#The-Set-Interface" class="headerlink" title="The Set Interface"></a>The Set Interface</h3><p><a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Set.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/Set.html</a></p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/28.png"></p>
<p>和C++一样，Set 是不包含重复的元素的. 如果把一个ArrayList放到Set当中，也会将其变成一个不重复的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Collection&lt;String&gt; collection = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Collections.addAll(collection, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"c"</span>);</span><br><span class="line">    Set&lt;String&gt; set =  <span class="keyword">new</span> HashSet&lt;&gt;(collection);</span><br><span class="line">    System.out.println(set);<span class="comment">//[a, b, c]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在来介绍一些Set中的方法</p>
<p>set其实就是一个集合，数学上集合的操作在Java中都有对应的方法。</p>
<p>比如 <strong>并</strong>，就可以用 <code>addAll()</code> 方法求得</p>
<p><strong>交</strong>，可以用 <code>retainAll()</code>方法求得</p>
<p>A-B, 可以用 <code>removeAll()</code>方法求得</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set1 = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>));</span><br><span class="line">  Set&lt;String&gt; set2 = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="string">"d"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Union</span></span><br><span class="line">  set1.addAll(set2);</span><br><span class="line">  System.out.println(set1);<span class="comment">//[a, b, c, d]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//复原</span></span><br><span class="line">  set1 = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>));</span><br><span class="line">  <span class="comment">// Intersection</span></span><br><span class="line">  set1.retainAll(set2);</span><br><span class="line">  System.out.println(set1);<span class="comment">//[b, c]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//复原</span></span><br><span class="line">  set1 = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>));</span><br><span class="line">  <span class="comment">//Difference</span></span><br><span class="line">  set1.removeAll(set2);</span><br><span class="line">  System.out.println(set1);<span class="comment">//[a]</span></span><br></pre></td></tr></table></figure>
<h3 id="The-Map-Interface"><a href="#The-Map-Interface" class="headerlink" title="The Map Interface"></a>The Map Interface</h3><p> 在Java和C++中，哈希表可以用 Map接口来实现，在C#、python中，可以用Dictionary(词典)来实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c1 = <span class="keyword">new</span> Customer(<span class="string">"a"</span>,<span class="string">"e1"</span>);</span><br><span class="line"><span class="keyword">var</span> c2 = <span class="keyword">new</span> Customer(<span class="string">"b"</span>,<span class="string">"e2"</span>);</span><br><span class="line"><span class="keyword">var</span> unknown = <span class="keyword">new</span> Customer(<span class="string">"Unknown"</span>,<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">Map&lt;String,Customer&gt;map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(c1.getEmail(),c1);<span class="comment">// email作为key，而Customer对象作为value</span></span><br><span class="line">map.put(c2.getEmail(),c2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> customer = map.get(<span class="string">"e1"</span>);</span><br><span class="line">System.out.println(customer);<span class="comment">//a</span></span><br><span class="line"></span><br><span class="line">customer = map.get(<span class="string">"e10"</span>);<span class="comment">//如果按一个不存在的key去找，会返回10</span></span><br><span class="line">System.out.println(customer);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//找到就返回e10配对的对象，否则就返回unknown</span></span><br><span class="line">customer = map.getOrDefault(<span class="string">"e10"</span>,unknown);</span><br><span class="line">System.out.println(customer);<span class="comment">//Unknown</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> exists = map.containsKey(<span class="string">"e10"</span>);</span><br><span class="line">System.out.println(exists);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">map.replace(<span class="string">"e1"</span>,<span class="keyword">new</span> Customer(<span class="string">"a++"</span>,<span class="string">"e1"</span>));</span><br><span class="line">System.out.println(map);<span class="comment">//&#123;e1=a++, e2=b&#125;</span></span><br></pre></td></tr></table></figure>
<p>但是注意了，map是不能够被迭代的，因此我们没用办法用for each loop来直接遍历map，但是我们有其他的方法：</p>
<p>我们可以使用map内置的 entrySet方法来获得每一组键值对</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：e1=a++  e2=b</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出值 ：a++  b</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(entry.getKey());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出索引 key： e1  e2</span></span><br></pre></td></tr></table></figure>
<p>当然，也可以使用<code>map.values()</code>直接获得value</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (customer : map.values()) &#123;</span><br><span class="line">   	System.out.println(customer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Lambda-Expressions"><a href="#Lambda-Expressions" class="headerlink" title="Lambda Expressions"></a>Lambda Expressions</h2><h3 id="Functional-Interfaces"><a href="#Functional-Interfaces" class="headerlink" title="Functional Interfaces"></a>Functional Interfaces</h3><p>函数式接口，是指内部只有<strong>一个</strong>抽象方法的接口。注意，只能有一个，并且是抽象的方法</p>
<p>比如说我声明一个 <code>Printer</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Printer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后用一个<code>ConsolePrinter</code>类来实现这个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsolePrinter</span> <span class="keyword">implements</span> <span class="title">Printer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在LambdasDemo类中将实例传入到参数为接口的greet()方法中，完成打印。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdasDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        greet(<span class="keyword">new</span> ConsolePrinter());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">(Printer printer)</span></span>&#123;</span><br><span class="line">        printer.print(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这与我们之前<a href="https://jasonxqh.github.io/2020/07/05/Java基础2/">Java基础2</a>中关于接口的操作思路一样，但是有时候我们并不想创建这样一个功能如此特殊的类来实现接口，因为用一次以后可能再也不会使用了。因此接下来我们要来介绍匿名内部类。</p>
<h3 id="Anonymous-Inner-Classes"><a href="#Anonymous-Inner-Classes" class="headerlink" title="Anonymous Inner Classes"></a>Anonymous Inner Classes</h3><p>匿名内部类就是没有名字的、方法内部的类，通常用来简化代码的编写。</p>
<p>匿名内部类的使用场景： 我们只使用一次接口并用来实现某些特殊的功能的时候</p>
<p>匿名类是不能有名称的类，所以没办法引用它们。必须在创建时，作为new语句的一部分来声明它们。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.lambda;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdasDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        greet(<span class="keyword">new</span> Printer() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">                System.out.println(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">(Printer printer)</span></span>&#123;</span><br><span class="line">        printer.print(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>匿名内部类，虽然已经方便了许多。但是更好的方法是使用 <code>Lambda Expression</code></p>
<h3 id="Lambda-Expressions-1"><a href="#Lambda-Expressions-1" class="headerlink" title="Lambda Expressions"></a>Lambda Expressions</h3><p>Lambda 表达式的作用就像是一个匿名内部类，但是又不属于类。比如说我们重写刚才的匿名内部类代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    greet(message-&gt;&#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说使用 Lambda expression 可以代替一个类。在这里我们甚至不需要写 <code>message</code>的数据类型，因为当我们使用Lambda表达式的时候Java会根据调用它的方法(这里是<code>greet()</code>)找到对应的接口及其数据类型。</p>
<p>当我们只传入1个参数的时候，参数不需要用括号包裹。但是当我们传入0个或者多个参数的时候，需要使用小括号包裹。</p>
<p>如果这个Lambda Expression花括号中只含有一句代码，那么花括号也可以被省略，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">greet(message -&gt; System.out.println(message))</span><br></pre></td></tr></table></figure>
<h3 id="Variable-Capture"><a href="#Variable-Capture" class="headerlink" title="Variable Capture"></a>Variable Capture</h3><p>如果我们使用一个匿名内部类，我们可以在类内新建一些变量，但是在 <code>Lambda Expression</code> 中，是不能新建变量的。但是可以使用当前方法中定义的变量，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void show()&#123;</span><br><span class="line">    String prefix &#x3D; &quot;-&quot;;</span><br><span class="line"></span><br><span class="line">    greet((message)-&gt;&#123;</span><br><span class="line">        System.out.println(prefix+message);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可使用当前类中定义的静态变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdasDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String prefix = <span class="string">"-"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        greet((message)-&gt;&#123;</span><br><span class="line">            System.out.println(prefix+message);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">(Printer printer)</span></span>&#123;</span><br><span class="line">        printer.print(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 当然，如果要使用非静态变量的话，需要将 show()方法也定义成非静态的。</p>
<h3 id="Method-References"><a href="#Method-References" class="headerlink" title="Method References"></a>Method References</h3><p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/42.png"></p>
<p>方法引用一共有四种，目的是用来简化Lambda表达式的。一般引用格式是： 类名+静态方法名，要求是引用的静态方法跟 Lambda表达式是客观等价的(参数值、参数类型、返回值一致)</p>
<p>比如说刚才的例子中 ，<code>println</code>方法就和Lambda表达式是客观等价的，因此我们可以直接简化为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">       greet(System.out::println);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>当然，我们也可以在类中自定义一个静态函数然后实现函数引用：</p>
<p>在这里我们定义了静态函数 <code>LambdaDemo</code> 并在 greet中引用了它</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdasDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String message)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        greet(LambdasDemo::print);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">(Printer printer)</span></span>&#123;</span><br><span class="line">        printer.print(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上图，第四种方法就是引用一个构造函数。可以使用 <code>类+new</code> 的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdasDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LambdasDemo</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        greet(LambdasDemo::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">greet</span><span class="params">(Printer printer)</span></span>&#123;</span><br><span class="line">        printer.print(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Built-in-Functional-Interfaces"><a href="#Built-in-Functional-Interfaces" class="headerlink" title="Built-in Functional Interfaces"></a>Built-in Functional Interfaces</h3><p>文档：<a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/function/package-summary.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/function/package-summary.html</a></p>
<p>Java提供了四种内建的函数式接口：Consumer、Supplier、 Function、Predicate</p>
<p>Consumer接口的意思是它值接收一个参数，且不返回任何东西。就好像把一个值给消费掉了。</p>
<p>Supplier接口的意思是它并不接收任何参数，但返回一个值，就好像它在提供一个值。</p>
<p>Function接口的意思是它会把一个值映射到另一个值上， <code>obj map(obj)</code></p>
<p>Predicate接口的意思是判断一个对象是否符合某个条件，<code>bool test(condition)</code></p>
<p>现在我们来一一介绍四种接口</p>
<h3 id="The-Consumer-Interface"><a href="#The-Consumer-Interface" class="headerlink" title="The Consumer Interface"></a>The Consumer Interface</h3><p>文档：<a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/function/Consumer.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/function/Consumer.html</a></p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/43.png"></p>
<p>此外这个接口还有几个变形，比如 <code>BiConsumer</code>也就是接收两个参数但是不返回任何值</p>
<p>这里我们引用一个例子：</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/44.png"></p>
<p>List集合中的 <code>forEach()</code>方法就实现了一个 Consumer接口，因此我们要传入一个值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>这就是Declarative Programming, 也就是说这句命令做了些啥。</p>
<h3 id="Chaining-Consumer"><a href="#Chaining-Consumer" class="headerlink" title="Chaining Consumer"></a>Chaining Consumer</h3><p>现在我们来说说 链式的Consumer，在这里我们定义了两个lambda函数分别实现 Consumer接口：一个是打印原来的元素，另一个打印大写后的元素。</p>
<p>然后我们使用forEach方法的时候，先调用print，在print后调用内建的 addThen,又可以调用一个 Consumer对象.可以一直这样调用下去，比如：<code>list.forEach(print.andThen(printUpperCase).andThen(print));</code></p>
<p>调用顺序是：对于每一个元素，前调用print方法，然后调用printUpperCase方法，即先打印小写字母再打印大写祖母</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/45.png"></p>
<p>我们查看Consumer的源码就能看出原理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(after);</span><br><span class="line">    <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现这个函数的返回值也是一个 Consumer的对象，当一个Consumer调用<code>andThen</code>，它先执行前面的对象，再调用after执行后面的对象，这样就会使我们的传入的两个Consumer对象按照顺序执行。</p>
<h3 id="The-Supplier-Interface"><a href="#The-Supplier-Interface" class="headerlink" title="The Supplier Interface"></a>The Supplier Interface</h3><p>文档：<a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/function/Consumer.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/function/Consumer.html</a></p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/46.png"></p>
<p>这个接口只有一个方法，即<code>get</code> </p>
<p>这里我们创建了一个 <code>getRandom</code> 的 Lambda 表达式，用来随机生成一个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdasDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Supplier&lt;Double&gt; getRandom = () -&gt; Math.random();</span><br><span class="line">        <span class="keyword">var</span> random = getRandom.get();</span><br><span class="line">        System.out.println(random);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边要注意的是，如果我们不调用 <code>getRandom.get()</code>，这个Lambda 表达式是不会执行的。这叫做：Lazy evaluation. </p>
<p>和Consumer接口一样，Supplier接口也有多种变形： <code>DoubleSupplier</code>，<code>BooleanSupplier</code>,<code>IntSupplier</code>等，这些接口只能返回特定类型的数据。</p>
<h3 id="The-Function-Interface"><a href="#The-Function-Interface" class="headerlink" title="The Function Interface"></a>The Function Interface</h3><p>文档：<a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/function/Function.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/function/Function.html</a></p>
<p>基本模板：<code>Interface Function&lt;T,R&gt;</code></p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/47.png"></p>
<p>这个接口需要设置两个数据类型 T和R.文档中这么解释: </p>
<p><code>T</code> - the type of the input to the function </p>
<p><code>R</code> - the type of the result of the function</p>
<p>当然还有 Function 接口的变形如 <code>BiFunction&lt;T,U,R&gt;</code>，也就是设置三个数据类型，两个接收的和一个返回的：</p>
<p><code>T</code> - the type of the first argument to the function</p>
<p><code>U</code> - the type of the second argument to the function</p>
<p><code>R</code> - the type of the result of the function</p>
<p>还有像 <code>IntFunction&lt;R&gt;</code>这种接口，因为它已经规定了<strong>接收值得数据类型</strong>为int，因此只要确定返回值类型 R即可；和<code>IntFunction&lt;R&gt;</code>相对的是 <code>ToIntFunction&lt;T&gt;</code>接口，它规定了<strong>返回值的数据类型</strong>为int，因此我们要确定其接收值得数据类型T</p>
<p>这里我们创建了 一个 Lambda函数map，其作用就是接收一个String类型的字符串并返回Integer类型的该字符串的长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdasDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Function&lt;String,Integer&gt; map = str-&gt;str.length();</span><br><span class="line">        <span class="keyword">var</span> length = map.apply(<span class="string">"Sky"</span>);</span><br><span class="line">        System.out.println(length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Composing-Functions"><a href="#Composing-Functions" class="headerlink" title="Composing Functions"></a>Composing Functions</h3><p>因为 Function接口也有 <code>andThen()</code>方法,所以我们也可以链式使用 Function接口。</p>
<p>这里我们 同样定义了两个 lambda函数，第一个是将字符串中的’:’替换成’-‘。第二个是在字符串外面添加花括号。</p>
<p>我们有两种方式实现链式Function</p>
<p>我认为第一种更加直观：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdasDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Function&lt;String,String&gt; replaceColon = str -&gt; str.replace(<span class="string">":"</span>,<span class="string">"-"</span>);</span><br><span class="line">        Function&lt;String,String&gt; addBraces = str -&gt; <span class="string">"&#123;"</span>+str+<span class="string">"&#125;"</span> ;</span><br><span class="line">        <span class="keyword">var</span> result = replaceColon</span><br><span class="line">                .andThen(addBraces)</span><br><span class="line">                .apply(<span class="string">"key:value"</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = addBraces.compose(replaceColon).apply(<span class="string">"Key:Value"</span>);</span><br></pre></td></tr></table></figure>
<p>打印后得到： {key-value}</p>
<h3 id="The-Predicate-Interface"><a href="#The-Predicate-Interface" class="headerlink" title="The Predicate Interface"></a>The Predicate Interface</h3><p><a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/function/Predicate.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/function/Predicate.html</a></p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/48.png"></p>
<p>我们使用这个接口来筛选数据。最重要的就是这个 <code>test()</code>方法，它会判断t是否符合某些条件。</p>
<p>此外还有 <code>BiPredicate&lt;T,U&gt;</code>，用来检测传入的两个参数是否符合某些条件；<code>IntPredicate</code> 它只接受Integer类型的数据并返回一个布尔值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdasDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Predicate&lt;String&gt; isLongerThan5 = str -&gt; str.length() &gt;<span class="number">5</span>;</span><br><span class="line">        <span class="keyword">var</span> result = isLongerThan5.test(<span class="string">"sky"</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们设计了一个Lambda函数用来判断输入的String类型的字符串的长度是否大于5. </p>
<p>打印得到 false</p>
<h3 id="Combining-Predicates"><a href="#Combining-Predicates" class="headerlink" title="Combining Predicates"></a>Combining Predicates</h3><p>将 Predicates结合起来又有些不太一样，因为这些都是条件。因此我们可以将两个条件通过 <code>and()</code>,<code>or()</code> 变成一个新的 Predicate，比如说：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdasDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Predicate&lt;String&gt; hasLeftBrace = str-&gt;str.startsWith(<span class="string">"&#123;"</span>);</span><br><span class="line">        Predicate&lt;String&gt; hasRightBrace = str-&gt;str.endsWith(<span class="string">"&#125;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> hasBothBrace =hasLeftBrace.and(hasRightBrace);</span><br><span class="line">        <span class="keyword">var</span> eitherOneBrace = hasLeftBrace.or(hasRightBrace);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一个方法，叫做 <code>negate()</code>，也就是将条件取反变成新的条件，如 <code>hasLeftBrace.negate()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(hasBothBrace.test(<span class="string">"&#123;sss"</span>));		<span class="comment">// false</span></span><br><span class="line">System.out.println(eitherOneBrace.test(<span class="string">"&#123;sss"</span>));	<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="The-BinaryOperator-Interface"><a href="#The-BinaryOperator-Interface" class="headerlink" title="The BinaryOperator Interface"></a>The BinaryOperator Interface</h3><p>现在我们来介绍一种特殊的函数式接口： <code>BinaryOperator&lt;T&gt;</code></p>
<p><a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/function/BinaryOperator.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/function/BinaryOperator.html</a></p>
<p>这个接口是一个特殊的 BiFunction()接口，即接受两个参数，并返回一个值，这三个值得类型都必须相同。</p>
<p>比如说这里我们定义一个 BinaryOperator的函数为add，作用是将两个Integer类型的整数相加。我们还可以利用 <code>andThen()</code>将BinaryOperator和Function两个类型的函数复合起来，求两数之和的平方数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdasDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// a,b -&gt; a+b -&gt; square</span></span><br><span class="line">        BinaryOperator&lt;Integer&gt; add = (a,b)-&gt;a+b;</span><br><span class="line">        Function&lt;Integer,Integer&gt; square = a-&gt;a*a;</span><br><span class="line">        <span class="keyword">var</span> result = add.andThen(square).apply(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">      <span class="comment">//结果为9</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="The-UnaryOperator-Interface"><a href="#The-UnaryOperator-Interface" class="headerlink" title="The UnaryOperator Interface"></a>The UnaryOperator Interface</h3><p><a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/function/UnaryOperator.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/function/UnaryOperator.html</a></p>
<p><code>UnaryOperator&lt;T&gt;</code>接口是一种特殊的 Function()接口，即接受一个参数并返回一个值，但它们的类型必须相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdasDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        UnaryOperator&lt;Integer&gt; square = n-&gt;n*n;</span><br><span class="line">        UnaryOperator&lt;Integer&gt; increment = n-&gt;n+<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> result = increment.andThen(square).apply(<span class="number">1</span>);</span><br><span class="line">        System.out.println(result);<span class="comment">//打印的4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们新建了两个 <code>UnaryOperator</code> 对象，一个用来+1，一个用来求平方，使用<code>andThen()</code>将它们复合</p>
<h2 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h2><p>Java8 引入了 Stream，这可以让你以一种声明的方式处理数据。也就是说，Stream使用了一种类似用SQL 语句从数据库查询数据的直观方式来提供一种对Java集合(collection)运算的表达的高阶抽象。这可以让我们写出高效率的、干净、简洁的代码。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; transactionsIds = </span><br><span class="line">widgets.stream()</span><br><span class="line">             .filter(b -&gt; b.getColor() == RED)</span><br><span class="line">             .sorted((x,y) -&gt; x.getWeight() - y.getWeight())</span><br><span class="line">             .mapToInt(Widget::getWeight)</span><br><span class="line">             .sum();</span><br></pre></td></tr></table></figure>
<h3 id="Imperative-vs-Functional-Programming"><a href="#Imperative-vs-Functional-Programming" class="headerlink" title="Imperative vs Functional Programming"></a>Imperative vs Functional Programming</h3><p>首先我们来看命令式编程和函数式编程之间的区别。</p>
<p>下面给出 Imperative Code的例子：我们看到命令式编程完全就是一步一步执行下去的，仿佛就是我们在对计算机下命令。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Movie&gt; movies = List.of(</span><br><span class="line">            <span class="keyword">new</span> Movie(<span class="string">"a"</span>,<span class="number">10</span>),</span><br><span class="line">            <span class="keyword">new</span> Movie(<span class="string">"b"</span>,<span class="number">15</span>),</span><br><span class="line">            <span class="keyword">new</span> Movie(<span class="string">"c"</span>,<span class="number">20</span>)</span><br><span class="line">    ); </span><br><span class="line">    <span class="comment">// Imperative Programming</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> movie : movies)</span><br><span class="line">        <span class="keyword">if</span>(movie.getLikes()&gt;<span class="number">10</span>)</span><br><span class="line">            count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们用函数式编程来重写上面这段命令式编程的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count2 = movies.stream()</span><br><span class="line">        .filter(movie -&gt; movie.getLikes()&gt;<span class="number">10</span>)</span><br><span class="line">        .count();</span><br></pre></td></tr></table></figure>
<p>命令式编程更像是我们告诉电脑应该怎么做:循环，判断；而stream则是直接show出来它做了什么：filter+count</p>
<p>它就好比是对Collection中的元素流通过管道，并在管道中进行筛选、分流、聚合等操作，最终得到我们想要的结果。</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/29.png"></p>
<h3 id="Creating-a-Stream"><a href="#Creating-a-Stream" class="headerlink" title="Creating a Stream"></a>Creating a Stream</h3><p>我们可以从这几处来创建流：</p>
<ul>
<li>From collections</li>
<li>From arrays</li>
<li>From an arbitrary number of objects</li>
<li>Infinite/ finite streams</li>
</ul>
<p>Stream 提供了新的方法 ‘forEach’ 来迭代流中的每个数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//从数组中创建流</span></span><br><span class="line">    <span class="keyword">int</span> [] numbers = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    Arrays.stream(numbers)</span><br><span class="line">            .forEach(n -&gt; System.out.println(n));</span><br><span class="line">	<span class="comment">//从随机数中创建流</span></span><br><span class="line">    <span class="keyword">var</span> stream = Stream.generate(()-&gt;Math.random());</span><br><span class="line">    stream</span><br><span class="line">            .limit(<span class="number">3</span>)<span class="comment">//这里如果不做限制，会有无限多个随机数产生</span></span><br><span class="line">            .forEach(n -&gt; System.out.println(n));</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Mapping-Elements"><a href="#Mapping-Elements" class="headerlink" title="Mapping Elements"></a>Mapping Elements</h3><p>map 方法用于映射每个元素到对应的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Movie&gt; movies = List.of(</span><br><span class="line">            <span class="keyword">new</span> Movie(<span class="string">"a"</span>,<span class="number">10</span>),</span><br><span class="line">            <span class="keyword">new</span> Movie(<span class="string">"b"</span>,<span class="number">15</span>),</span><br><span class="line">            <span class="keyword">new</span> Movie(<span class="string">"c"</span>,<span class="number">20</span>)</span><br><span class="line">    );</span><br><span class="line">  <span class="comment">//最基础的就是map方法，他获取movies中的每个元素并取得他们的标题，然后输出</span></span><br><span class="line">   movies.stream()</span><br><span class="line">           .map(movie -&gt; movie.getTitle())</span><br><span class="line">           .forEach(name-&gt; System.out.println(name));</span><br><span class="line">  <span class="comment">//mapToInt则是将得到的数据全部转换为 int 类型的数据,同样还有mapToDouble</span></span><br><span class="line">   movies.stream()</span><br><span class="line">           .mapToInt(movie -&gt; movie.getLikes())</span><br><span class="line">           .forEach(likes -&gt; System.out.println(likes));</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外还有<code>flatmap()</code>方法，The <code>flatMap()</code> operation has the effect of applying a one-to-many transformation to the elements of the stream, and then flattening the resulting elements into a new stream.</p>
<p>首先我们用 <code>of()</code>创建一个含有两个 List 集合的流，然后让其打印元素。</p>
<p>然后我们让其调用<code>flatMap</code>,让 传入的List集合扁平化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stream = Stream.of(List.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),List.of(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>));</span><br><span class="line">stream.forEach(list -&gt; System.out.println(list));</span><br><span class="line"><span class="comment">/* 打印得</span></span><br><span class="line"><span class="comment">[1, 2, 3]</span></span><br><span class="line"><span class="comment">[4, 5, 6]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">stream</span><br><span class="line">       	  .flatMap(list -&gt; list.stream())</span><br><span class="line">    	    .forEach(n -&gt; System.out.println(n));</span><br><span class="line"><span class="comment">/* 打印得</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//注意，如果我们调用的是map(),那么打印出来的是这个流对象，而不是流中的元素：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.util.stream.ReferencePipeline$Head@3a71f4dd</span></span><br><span class="line"><span class="comment">java.util.stream.ReferencePipeline$Head@7adf9f5f</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="Filtering-Elements"><a href="#Filtering-Elements" class="headerlink" title="Filtering Elements"></a>Filtering Elements</h3><p>filter 方法用于通过设置的条件过滤出元素, 这里我们要分清 stream的两种类型的操作：Intermediate Operation 以及 Terminal Operation</p>
<p>Intermediate Operation 就是 <code>map()、filter()</code> 之类的操作，它们会继续返回一个stream供我们后续操作</p>
<p>Terminal Operation 的例子就是 <code>forEach()</code>，它会直接在终端输出结果</p>
<p>如果只使用 Intermidiate Operation那么终端中什么都不会输出。为了使filter更加利于理解，我们可以将筛选条件单独定义成一个变量，如下面这个例子：</p>
<p>注：<code>Predicate &lt;T&gt;</code> 接口是一个函数式接口，它接受一个输入参数，然后返回一个布尔值结果。该接口用于测试对象是 true 或 false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">var</span> movies = List.of(</span><br><span class="line">                <span class="keyword">new</span> Movie(<span class="string">"a"</span>,<span class="number">10</span>),</span><br><span class="line">                <span class="keyword">new</span> Movie(<span class="string">"b"</span>,<span class="number">15</span>),</span><br><span class="line">                <span class="keyword">new</span> Movie(<span class="string">"c"</span>,<span class="number">20</span>)</span><br><span class="line">        );</span><br><span class="line"> <span class="comment">// m 是一个参数传递到Predicate 接口的 test 方法</span></span><br><span class="line"> <span class="comment">// 如果 m.getLikes()&gt;10,那么就会返回 true</span></span><br><span class="line">        Predicate&lt;Movie&gt; isPopular = m -&gt; m.getLikes() &gt; <span class="number">10</span>;</span><br><span class="line">        movies.stream()</span><br><span class="line">                .filter(isPopular)</span><br><span class="line">                .forEach(movie -&gt; System.out.println(movie.getTitle()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Slicing-Streams"><a href="#Slicing-Streams" class="headerlink" title="Slicing Streams"></a>Slicing Streams</h3><p> slicing stream是一个大类别，包含了 <code>limit(n)</code>、<code>skip(n)</code>、<code>takeWhile(predicate)</code>、<code>dropWhile(predicate)</code> 这些方法</p>
<h4 id="limit-n"><a href="#limit-n" class="headerlink" title="limit(n)"></a>limit(n)</h4><p>顾名思义，就是只限制 n 条数据，如下：</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/49.png"></p>
<h4 id="skip-n"><a href="#skip-n" class="headerlink" title="skip(n)"></a>skip(n)</h4><p>顾名思义，就是跳过前n条数据。</p>
<p>假设现在有1000条电影数据，每10条一页，我想看第三页的数据，应该怎么编写代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movies.stream()</span><br><span class="line">			.skip(<span class="number">20</span>)</span><br><span class="line">			.limit(<span class="number">10</span>)</span><br><span class="line">			.forEach(m -&gt; System.out.println(m.getTitle()));</span><br></pre></td></tr></table></figure>
<h4 id="takeWhile-predicate"><a href="#takeWhile-predicate" class="headerlink" title="takeWhile(predicate)"></a>takeWhile(predicate)</h4><p>这个方法传入一个实现了 predicate接口的 lambda表达式，用来筛选满足条件的数据。但是注意了，这个和filter是不一样的。filter是筛选所有满足条件的数据，而takeWhile()方法则是一碰到不符合条件的数据就立即停止。</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/50.png"></p>
<p>上面的例子中，虽然第三条数据的 likes&lt;15,但是 takeWhile()在遇到第二条数据的时候就已经停止了筛选。</p>
<h4 id="dropWhile-predicate"><a href="#dropWhile-predicate" class="headerlink" title="dropWhile(predicate)"></a>dropWhile(predicate)</h4><p>dropWhile则和takeWhile恰好相反。就是去除掉那些符合条件的数据，直到遇到第一条不满足条件的数据为止。比如说刚才一模一样的代码，将takeWhile改成dropWhile，就会打印 b和c，因为会把a去除掉，而遇到b的时候就停止筛选了</p>
<h3 id="Sorting-Streams"><a href="#Sorting-Streams" class="headerlink" title="Sorting Streams"></a>Sorting Streams</h3><p>我们之前介绍了 <code>Comparable</code>和<code>Comparator</code>接口，是用来对对象进行排序的方法。</p>
<p>现在在stream中我们可以简化写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movies.stream()</span><br><span class="line">        .sorted((a,b)-&gt;a.getTitle().compareTo(b.getTitle()))<span class="comment">//原来我们这么写</span></span><br><span class="line">        .sorted(Comparator.comparing(Movie::getTitle))<span class="comment">//现在我们可以这么写</span></span><br><span class="line">        .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>如果我们要倒序排列，那么：<code>.sorted(Comparator.comparing(Movie::getTitle).reversed())</code>即可</p>
<h3 id="Getting-Unique-Elements"><a href="#Getting-Unique-Elements" class="headerlink" title="Getting Unique Elements"></a>Getting Unique Elements</h3><p>我们可以通过 stream中的 <code>distinct()</code>方法来获得集合中非重复的数据，比如说：</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/52.png"></p>
<h3 id="Peeking-Elements"><a href="#Peeking-Elements" class="headerlink" title="Peeking Elements"></a>Peeking Elements</h3><p>peek和map 有点相似，但是peek接收的是一个 Consumer，而map接受的是一个Function。</p>
<p>Consumer是没有返回值的，它只是对Stream中的元素进行某些操作，但是操作之后的数据并不返回到Stream中，所以Stream中的元素还是原来的元素。</p>
<p>而Function是有返回值的，这意味着对于Stream的元素的所有操作都会作为新的结果返回到Stream中。</p>
<p>我们常常用 <code>peek()</code>来debug我们的程序，因为它不会对Stream的元素作任何操作，又不是一个Terminal的操作会把Stream终止。</p>
<p>通过下面这个例子，我们能更深刻的理解 peek和map之间的差别了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">var</span> movies = List.of(</span><br><span class="line">                <span class="keyword">new</span> Movie(<span class="string">"a"</span>,<span class="number">10</span>),</span><br><span class="line">                <span class="keyword">new</span> Movie(<span class="string">"b"</span>,<span class="number">15</span>),</span><br><span class="line">                <span class="keyword">new</span> Movie(<span class="string">"c"</span>,<span class="number">20</span>)</span><br><span class="line">        );</span><br><span class="line">        movies.stream()</span><br><span class="line">                .filter(m-&gt;m.getLikes()&gt;<span class="number">10</span>)</span><br><span class="line">                .peek(m -&gt; System.out.println(<span class="string">"filtered: "</span>+m.getTitle()))</span><br><span class="line">                .map(m-&gt;m.getTitle())</span><br><span class="line">                .peek(t -&gt; System.out.println(<span class="string">"mapped: "</span>+t))</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一开始我们筛选出了集合中点赞数大于10的数据，这里是两个Movie对象b和c</p>
<p>然后我们通过peek对其进行了一个输出</p>
<p>之后我们通过map将对象映射成他们的名字了，因此现在stream中只有两个字符串 b和c</p>
<p>然后我们再通过peek对其进行输出，这时候我们直接打印t和上面那样调用 <code>getTitle()</code>的效果是一样的，因为map已经对流进行了映射。</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/53.png"></p>
<h3 id="Simple-Reducers"><a href="#Simple-Reducers" class="headerlink" title="Simple Reducers"></a>Simple Reducers</h3><p>刚才我们讲的一系列操作，目的是创建客制化的管道。接下来我们来讲Reducer，其目的就是将流中的元素直接变成一个对象。比如说<code>count()</code>，它直接返回集合中的元素数量；</p>
<p><code>anyMatch(predicate)</code>, 返回布尔值，只要含有符合条件的就返回true；</p>
<p><code>allMatch(predicate)</code>以及 <code>noneMatch(predicate)</code>，逻辑和 <code>anyMatch相同</code></p>
<p><code>findFirst()</code> 返回 <code>Optional</code> 类，本质上，这是一个包含有可选值的包装类，这意味着 Optional 类既可以含有对象也可以为空。我们可以通过<code>get()</code>获取Optional中的对象本体。findFirst也就是返回集合中的第一个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> movies = List.of(</span><br><span class="line">            <span class="keyword">new</span> Movie(<span class="string">"a"</span>,<span class="number">10</span>),</span><br><span class="line">            <span class="keyword">new</span> Movie(<span class="string">"b"</span>,<span class="number">15</span>),</span><br><span class="line">            <span class="keyword">new</span> Movie(<span class="string">"c"</span>,<span class="number">20</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result= movies.stream()</span><br><span class="line">                                .findFirst()</span><br><span class="line">                                .get();</span><br><span class="line">    System.out.println(result.getTitle());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>findAny()</code>和    <code>findFirst()</code>逻辑相同，只不过是返回任意一个集合中的对象。</p>
<p><code>max(comparator)</code> 这个方法需要接受一个 comparator 对象作为比较的依据. 用来返回拥有 最大参数的对象</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/54.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result= movies.stream()</span><br><span class="line">                  .max(Comparator.comparing(Movie::getLikes))</span><br><span class="line">                  .get();</span><br><span class="line">System.out.println(result.getTitle());</span><br></pre></td></tr></table></figure>
<p><code>min(comparator)</code>和max()的逻辑相同。</p>
<h3 id="Reducing-a-Stream"><a href="#Reducing-a-Stream" class="headerlink" title="Reducing a Stream"></a>Reducing a Stream</h3><h3 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h3><h3 id="Grouping-Elements"><a href="#Grouping-Elements" class="headerlink" title="Grouping Elements"></a>Grouping Elements</h3><h3 id="Partitioning-Elements"><a href="#Partitioning-Elements" class="headerlink" title="Partitioning Elements"></a>Partitioning Elements</h3><h3 id="Primitive-Type-Streams"><a href="#Primitive-Type-Streams" class="headerlink" title="Primitive Type Streams"></a>Primitive Type Streams</h3><h2 id="Concurrency-and-Multi-threading"><a href="#Concurrency-and-Multi-threading" class="headerlink" title="Concurrency and Multi-threading"></a>Concurrency and Multi-threading</h2><h3 id="Processes-and-Threads"><a href="#Processes-and-Threads" class="headerlink" title="Processes and Threads"></a>Processes and Threads</h3><p>我们在CSAPP中已经了解了进程和线程的关系。在一个进程中，一定有一个主线程，还可以有其他支线程。比如说我们在迅雷中一次下载了三个文件，那么这三个文件就可以占据三个线程。</p>
<p>现在我们来看一下关于这台电脑中关于线程的信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.activeCount());</span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一句是打印当前这个项目使用的进程数，下面一句打印当前电脑总的可用线程数。</p>
<p>因为 m1 是四大核四小盒，这里打印出来的是一共8个进程 。当我在 i7-9750(六核) 上运行时，打印得到12个线程。</p>
<h3 id="Starting-a-Thread"><a href="#Starting-a-Thread" class="headerlink" title="Starting a Thread"></a>Starting a Thread</h3><p>现在我们来讲怎么创建一个线程。要创建一个线程，我们首先要让一个类引入 Runnable 接口,并在其中重写 run函数。Runnable接口是Java.lang 中一个内置的接口。引入这个接口就代表着这个任务将被在一条线程中执行。这个接口中只有一个函数： <code>run()</code> , 当启动线程开始运作之后，会自动调用  <code>run()</code>函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadFileTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Downloading a file: "</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，在 <code>ThreadDemo</code> 类中，将一个 <code>DownloadFileTask()</code> 实例传入，并调用 <code>start()</code>函数启动线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DownloadFileTask());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/1.png" style="zoom:120%;"></p>
<p>打印结果如上图所示：首先打印的是当前所在的线程，也就是 main，然后我们进行了一个循环，调用了十个新的线程，并依次打印出他们的名字。</p>
<h3 id="Pausing-a-Thread"><a href="#Pausing-a-Thread" class="headerlink" title="Pausing a Thread"></a>Pausing a Thread</h3><p>现在我们尝试将一个线程“挂起”一段时间以模仿下载的过程。</p>
<p>要让线程挂起，我们可以使用 <code>sleep()</code> 方法，这里我选择让线程挂起5秒钟(注意，5000是以毫秒为单位，但并不是非常精确的5000毫秒，这和底层操作系统有关系) </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadFileTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Downloading a file: "</span>+Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Download complete: "</span>+ Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我直接写 <code>Tread.sleep(5000)</code>，那么 idea会报错，我们需要用 try/catch 将其包裹起来。打印结果如下： </p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/2.png" style="zoom:120%;"></p>
<p>如果我们只有一个线程来下载这10个文件，那么就需要用50秒的时间，但是现在我们有10个线程，所以只需要5秒就能完成任务。</p>
<p>如果我们现在要下载成百上千的文件，但是我们电脑没有那么多线程。这时候，就要用到 JVM 中的 <code>Thread Scheduler</code>,这是用来决定 java中每条线程执行的时间。所以当任务量大于线程数的时候，JVM 会执行分时操作。也就是每一个线程都能分到一点时间，让我们用户看起来像是在并行下载。</p>
<h3 id="Joining-a-Thread"><a href="#Joining-a-Thread" class="headerlink" title="Joining a Thread"></a>Joining a Thread</h3><p><code>join()</code>方法是<code>Thread</code>类中的一个方法，该方法的定义是等待该线程终止。其实就是<code>join()</code>方法将挂起<strong>调用线程</strong>的执行，直到<strong>被调用的对象</strong>完成它的执行。</p>
<p>比如说，一开始我不使用 <code>join()</code>，这样，主线程就运行主进程自己的代码，只是开辟了一条线程运行其他的代码。因此我们看到打印出来的先是主线程的运行结果</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/3.png" style="zoom:120%;"></p>
<p>但是使用了 <code>join()</code>方法之后，主线程就会等待子线程结束后再运行。比如说：</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/4.png" style="zoom:120%;"></p>
<h3 id="Interrupting-a-Thread"><a href="#Interrupting-a-Thread" class="headerlink" title="Interrupting a Thread"></a>Interrupting a Thread</h3><p>有时候我们必须要去终止一个运行中的线程，这时候就需要用到 <code>thread.interrupt()</code> 这个函数了。通常终止一个线程的逻辑是： 调用者发出一个interrupt信号，被调用的线程将对收到的信号做一个判断，如果是interrupt信号，就终止运行中的线程。否则就“充耳不闻”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadFileTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Downloading a file: "</span>+Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;i&lt; Integer.MAX_VALUE;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().isInterrupted()) <span class="keyword">return</span>;</span><br><span class="line">            System.out.println(<span class="string">"Downloading byte"</span>+ i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边我进行一个无限循环，然后判断主线程是否给我发送了一个 Interrupt信号，如果是就return掉，否则就继续打印。</p>
<p>注意了，如果线程正在挂起时向其发送 <code>interrupted</code> 信号，这样是会报错的。因此我们在用 <code>thread.sleep()</code> 的时候，需要用 <code>try-catch</code> 来包裹。</p>
<h3 id="Concurrency-Issues"><a href="#Concurrency-Issues" class="headerlink" title="Concurrency Issues"></a>Concurrency Issues</h3><p>在编写并行程序的时候会遇到一些问题：</p>
<ol>
<li>当很多不同的线程共用一个对象的时候，对对象的某些参数进行修改会导致“堵车”。这就好比三个人像同时吃掉一个汉堡。我们将这种情况叫做 “Race Condition”, </li>
<li>另一种情况就是，当一个线程对一个对象进行了修改，但是修改后的内容仅它自己可见，那么不同线程就会看到一个对象不同的状态。我们将这种情况叫做 ”Visibility Problem”</li>
</ol>
<p>我们必须要写出 <code>Thread-safe Code</code> 来规避这些问题。在很多Java的文档中，对一个类的描述是 <code>Thread Safe</code> 也就是这个类可以再很多并行的线程中使用。</p>
<h3 id="Race-Conditions"><a href="#Race-Conditions" class="headerlink" title="Race Conditions"></a>Race Conditions</h3><p>当很多线程都想修改一个对象的时候，就出现了竞争关系。</p>
<p>比如说我有以下代码：</p>
<p><code>ThreadDemo类</code></p>
<p>在这个调用的类当中，我们创建一个线程数组，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">var</span> status = <span class="keyword">new</span> DownloadStatus();</span><br><span class="line">       List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">var</span> thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DownloadFileTask(status));</span><br><span class="line">           thread.start();</span><br><span class="line">           threads.add(thread);</span><br><span class="line">       &#125;</span><br><span class="line">      <span class="comment">//将所有的线程都打开后，我们还需要等待所有的线程都停止。这里使用一个循环来解决。</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> thread : threads)&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               thread.join();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        System.out.println(status.getTotalBytes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DownloadFileTask</code>类</p>
<p>在这个Run函数当中，我们做一个10000次的循环，每一次循环都调用status对象的 <code>incrementTotalBytes()</code>函数。用来模拟下载一个 10000 bits的文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadFileTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DownloadStatus status;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DownloadFileTask</span><span class="params">(DownloadStatus status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;i&lt; <span class="number">10_000</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().isInterrupted()) <span class="keyword">return</span>;</span><br><span class="line">            status.incrementTotalBytes();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DownloadStatus</code>类</p>
<p>在这个类中，有一个下载总比特数的私有变量，当有线程中的对象调用<code>incrementTotalBytes()</code>的时候，totalBytes就会自增1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadStatus</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> totalBytes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotalBytes</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> totalBytes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incrementTotalBytes</span><span class="params">()</span></span>&#123;</span><br><span class="line">        totalBytes++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在预期的情况下，我们打开了10 个线程，每个线程都会下载10_000比特的数据，那么<code>totalBytes</code>的结果应该是100_000, 但是我们多次运行之后，一直都是八九万，并没有到十万。这是因为发生了<code>Race condition</code>，线程在互相争抢修改同一个数据的时候，会发生数据丢失。</p>
<p>当我们调用 <code>incrementTotalBytes()</code> 的时候，电脑会从内存中找到totalBytes的值，然后存储至cpu，然后cpu对值进行加1操作；操作结束后，这个值会被重新存储至内存中。</p>
<p>那么现在假设两个线程同时读取了 <code>totalBytes</code>然后对其进行加1操作，这时候，CPU也只是会将<code>totalBytes</code>加上1而已，并不会加上2。这就是导致了刚才的数据丢失。</p>
<h3 id="Strategies-for-Thread-Safety"><a href="#Strategies-for-Thread-Safety" class="headerlink" title="Strategies for Thread Safety"></a>Strategies for Thread Safety</h3><p>我们有一些写出 <code>Thread Safe Code</code> 的策略：</p>
<ul>
<li>Confinement</li>
</ul>
<p>这个概念很简单，就是原本是多个线程操作一个对象，现在变成了每个线程都操作属于它自己的对象，最后将对象中的值加起来就得到最后的总值。</p>
<ul>
<li>Immutability</li>
</ul>
<p>这个操作更加直白，就是我们将要操作的对象变成不可改变的。比如说 String 对象就是 Immutable 的，因为当我们对一个 String 对象进行修改的时候会创建一个新的String，之前的String并不会遭改变</p>
<ul>
<li>Synchronization</li>
</ul>
<p>同步操作，这使得同一个对象在不同的线程之间可以协调、同步。我们可以利用<strong>lock</strong>以及<strong>Synchronize</strong>关键词来实现这个操作.</p>
<p>我们使用锁将”有争议的部分”锁起来，一次只能让一个线程来访问，这样就能做到隔离的效果。然而，这样很容易造成死锁，因此不推荐使用</p>
<ul>
<li>Atomic Object </li>
</ul>
<p>原子对象。之前 若要对<code>totalBytes</code> 进行修改需要进行3个步骤，但是当我们使用原子对象的时候，只需要一个步骤即可，这就防止两个线程同时操作一个对象的情况出现了。</p>
<ul>
<li>Partitioning  </li>
</ul>
<p>中文叫分区</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/20.png" style="zoom:120%;"></p>
<h3 id="Confinement"><a href="#Confinement" class="headerlink" title="Confinement"></a>Confinement</h3><p>现在我们重构刚才那段代码。之前发生Race condition的时候，我们只创建了一个 <code>DownloadStatus</code> 对象，十个线程都对一个 <code>totalBytes</code> 变量进行操作，因此它们开始争夺。</p>
<p>我们现在要做的就是“隔离”，简单来说就是给每一个thread都新建一个DownloadStatus，线程的操作只对它自己的DownloadStatus中的TotalBytes进行操作，最后将这十个 TotalBytes变量累加得到最后答案。</p>
<p>因为我们要对每一个线程新建一个下载任务，因此我们还要一个 列表来保存这些Tasks。并且我们不再需要向<code>DownloadFileTask</code> 构造器传入status参数了，因为我们要对每一个Task新建一个DownloadStatus对象 ,但是我们要在 <code>DownloadFileTask</code>类中为status做一个getter，方便外界获取当前的下载状态。</p>
<p> <img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/30.png" style="zoom:100%;"></p>
<p>现在我们重构 ThreadDemo 类，因为我们要为每一个线程单独设一个DownloadFileTask，因此为了方便将其中的TotalBytes相加，我们要新建一个List对其进行管理。并在创建的时候将每一个Task加入到数组当中去。最后我们用 Stream 将tasks数组中的所有任务中的totalbytes相加，得到最终结果。</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/31.png" style="zoom:100%;"></p>
<p>打印得： Optional[100000]，即10个线程的下载总和，一个Byte都没丢掉</p>
<h3 id="Locks"><a href="#Locks" class="headerlink" title="Locks"></a>Locks</h3><p>上面我们说了隔离，这里我们再提供一种方案。就是设计一个锁，使得同一个对象在同一时间只能被访问修改一次。当一个线程想要正在修改对象的时候，就把这个对象锁起来，别的线程都无法访问。</p>
<p>根据上面的信息，我们现在要在 <code>DownloadStatus</code>上加一个锁。首先我们声明一个lock：</p>
<p><code>private Lock lock = new ReentrantLock()</code> 也就是一个可重入锁对象。<em>reentrant</em> 锁意味着什么呢？简单来说，它有一个与锁相关的获取计数器，如果拥有锁的某个线程再次得到锁，那么获取计数器就加1，然后锁需要被释放两次才能获得真正释放</p>
<p>然后我们在调用 <code>incrementTotalBytes</code> 的时候先上一个锁，等自增1结束后再解锁。这就好比一个人进了酒店房间办事，然后把门给锁了，办完事后再把门打开。</p>
<p>但是为了程序的正常运行，我们需要用 <code>try-finally block</code> ，因为如果在 <code>totalBytes++</code>的时候抛出了一个异常（我们当然知道自增1不会抛出异常，但是在未来我们自己的程序中这可能是一段很复杂的代码，因此必须要try），那么这个锁就永远无法打开了，会导致死锁。因此我们要保证 <code>lock.unlock()</code> 在任何情况下都能执行。 </p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/32.png" style="zoom:100%;"></p>
<p>打印结果：100000</p>
<h3 id="The-synchronized-Keyword"><a href="#The-synchronized-Keyword" class="headerlink" title="The synchronized Keyword"></a>The synchronized Keyword</h3><p>要让线程之间同步，我们还可以使用 synchronized 关键词。这样我们就不用很麻烦的先锁住、然后再解锁了。</p>
<p>但是Java程序依靠<code>synchronized</code>对线程进行同步，使用<code>synchronized</code>的时候，锁住的是哪个对象非常重要。</p>
<p>让线程自己选择锁对象往往会使得代码逻辑混乱，也不利于封装。更好的方法是把<code>synchronized</code>逻辑封装起来。 </p>
<p>比如我们现在就要用synchronized来封装<code>totalBytes++</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incrementTotalBytes</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        totalBytes++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，线程调用<code>incrementTotalBytes</code>方法时，它不必关心同步逻辑，因为<code>synchronized</code>代码块在<code>incrementTotalBytes</code>方法内部。并且，我们注意到，<code>synchronized</code>锁住的对象是<code>this</code>，即当前实例，这又使得创建多个<code>DownloadStatus</code>实例的时候，它们之间互不影响，可以并发执行。</p>
<p>当我们锁住的是 <code>this</code>实例的时候，实际上可以用 <code>synchronized</code>来修饰这个方法，因此这两种方法是等价的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">incrementTotalBytes</span><span class="params">()</span></span>&#123;</span><br><span class="line">       totalBytes++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，用<code>synchronized</code>修饰的方法就是同步方法，它表示整个方法都必须用<code>this</code>实例加锁。不能对其他实例加锁。</p>
<p>但是，对 <code>this</code> 实例加锁也是有缺点的。比如说：我又新建了一个totalFiles变量来记录已下载完成的文件总数。因为文件一多，很可能是两个文件同时下载完成的，因此我们也需要用 <code>synchronized</code>关键字来修饰</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/33.png" style="zoom:100%;"></p>
<p>那么问题来了：<code>incrementTotalByts</code>和<code>incrementTotalFiles</code>这两个方法都给 <code>this</code>对象上了锁。那么如果存在某一个时刻，要同时调用这两个方法的时候，必须等其中一个方法运行完之后把this对象解锁了之后才可以继续执行另一个方法。如果这只是一个小型应用，也许没事；但是如果这个应用非常庞大，需要上锁的参数非常多，那么同时调用的时刻会很多，会造成不必要的等待、降低程序的性能。</p>
<p>为了解决这个问题，我们可以给每一个需要上锁的变量新建一个专属对象。并用这个对象传入<code>synchronized</code>关键字。如下图所示：</p>
<p>我们创建了两个Object类型的对象，一个叫<code>totalBytesLock</code>用来锁住<code>totalBytes</code>; 以及<code>totalFilesLock</code>用来锁住<code>totalFiles</code> 变量。</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/34.png" style="zoom:100%;"></p>
<p>在今后的开发中我们最好选择变量的专属对象来上锁，而不要一直使用<code>this</code>对象</p>
<h3 id="The-volatile-Keyword"><a href="#The-volatile-Keyword" class="headerlink" title="The volatile Keyword"></a>The volatile Keyword</h3><p><a href="https://blog.csdn.net/u012723673/article/details/80682208" target="_blank" rel="noopener">https://blog.csdn.net/u012723673/article/details/80682208</a></p>
<p>Java 语言包含两种内在的同步机制：同步块（或方法）和 volatile 变量，相比于synchronized（synchronized通常称为重量级锁），volatile更轻量级，因为它不会引起线程上下文的切换和调度。但是volatile 变量的同步性较差（有时它更简单并且开销更低），而且其使用也更容易出错。</p>
<p>在多线程环境下，一个线程对共享变量的操作对其他线程是不可见的。Java提供了volatile来保证<strong>可见性</strong>，当一个变量被volatile修饰后，表示着<strong>线程本地缓存无效</strong>，当一个线程<strong>修改共享变量</strong>后他会<strong>立即被更新到主存</strong>中，其他线程读取共享变量时，会<strong>直接从主内存中读取</strong></p>
<p>我们先来看一个没有 <code>volatile</code> 版本的代码，分析一下里面有什么错误：</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/35.png" style="zoom:100%;"></p>
<p>首先我们在 <code>DownloadStatus</code> 中新建一个 <code>isDone</code>布尔变量，来表明这个下载任务是否已经完成。并设定一个 <code>getter</code>返回<code>isDone</code> 和一个 <code>setter</code>将<code>isDown</code>设为True</p>
<p>然后在<code>DownloadFileTask</code>类中，我们在下载结束后调用 <code>status.done()</code>将<code>isDone()</code> 设置为True并输出Download complete</p>
<p>最后在<code>ThreadDemo</code>类中，新建两个线程，第一个线程传入DownloadFileTask对象，第二个线程里面是个 Lambda表达式，它会一直询问status中的变量isDone是否为True，一直到下载完成 ，isDone==True,才会跳出循环并输出<code>totalBytes</code>的值。</p>
<p>我们运行这个demo，却发现程序迟迟不打印<code>totalBytes</code>的值，事实上如果我们不关闭这个程序，它就会一直运行下去。</p>
<p>为什么会发生这种事情？原因就在于 <code>thread1</code>和<code>thread2</code>两个线程之间并没有完全同步，我们注意到虽然<code>totalBytes</code>是通过 synchronized关键字修饰的，但是 <code>isDone</code> 并没有同步。因此在thread2看来，isDone始终是False。这种不可见性要从底层的JVM优化机制<strong>cache</strong>开始说起：</p>
<p>有一个变量，存储在主存中，值为1。现在CPU的两个核分别执行一条线程，将这个变量从主存中读入到CPU当中去，存储在不同的cache中，因为从cache中读取数据要比从主存中读取快得多。但是这两个CPU之间并不知道对方的cache中存的这个变量的值。因此，当CPU1将cache中的变量从1修改到2的时候，CPU2看到的该变量仍然是1，就算CPU将该变量回写到主存当中去，CPU2的cache中因为已经存储了该变量，因此仍然看不到改变后的结果。这就是多线程的<strong>不可见性</strong></p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/36.png" style="zoom:100%;"></p>
<p>一种可行但是不建议的方法就是将 <code>DownloadStatus</code>中的<code>isDone()</code>和<code>done()</code>方法都使用<code>synchronized</code>关键字修饰。但是我们有更好的方法——volatile</p>
<p>在一开始我们也说了volatile的原理，那就是告诉JVM,我这个变量是随时会变的，是不稳定的。你每次访问必须从主存当中去读取，不能从cache中去读取。</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/37.png" style="zoom:100%;"></p>
<h3 id="Thread-Signalling-with-wait-and-notify"><a href="#Thread-Signalling-with-wait-and-notify" class="headerlink" title="Thread Signalling with wait() and notify()"></a>Thread Signalling with wait() and notify()</h3><p>有时候我们会使用无限循环询问一个变量是否发生变化，比如刚才例子中，一直询问下载完成没。但是这样是很占用CPU的资源的。它可能会重复循环上亿次才能等到结果。</p>
<p>为了优化上面这种情况，我们可以用<code>wait()</code>和<code>notify()</code>方法</p>
<p>顾名思义，调用<code>wait()</code>方法后，线程进入等待状态，<code>wait()</code>方法不会返回，直到将来某个时刻，线程从等待状态被其他线程唤醒后，<code>wait()</code>方法才会返回，然后，继续执行下一条语句。<strong>注意，只能在锁对象上调用<code>wait()</code>方法</strong> 。<code>notify()</code>则是在相同的锁对象上作用，完成某件事后发出一个信号，让<code>wait()</code>去接收</p>
<p>比如下面这个例子，当我们要用while来询问<code>isDone()</code>是否为true的时候，我们对status上了一个锁。然后在里面调用<code>wait()</code>让线程2沉睡。再跑到<code>DownloadFileTask</code>类中，当下载完成时我们在 status上锁了的情况下调用 <code>notifyAll()</code>发出讯号。<code>wait()</code>收到后就会跳出循环，执行打印命令。</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/38.png" style="zoom:100%;"></p>
<p>通过这种机制我们可以降低CPU的负荷，优化程序性能。但同时，在不正确的地方使用<code>wait()</code>和<code>notify()</code>可能会造成很多难以解决的问题，因此我们不推荐这种方法。</p>
<h3 id="Atomic-Objects"><a href="#Atomic-Objects" class="headerlink" title="Atomic Objects"></a>Atomic Objects</h3><p><a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/concurrent/atomic/package-summary.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/concurrent/atomic/package-summary.html</a></p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/39.png" style="zoom:100%;"></p>
<p>Atomic object翻译过来就是原子对象，顾名思义，这个对象是不可分割的(不要用夸克抬杠) 。 我们之前做的所有努力，就是想避免多个线程<code>totalBytes++</code>产生竞争关系，因为<code>totalBytes++</code>需要进行三步操作，并不是原子化的。</p>
<p>ava的<code>java.util.concurrent</code>包除了提供底层锁、并发集合外，还提供了一组原子操作的封装类，它们位于<code>java.util.concurrent.atomic</code>包。</p>
<p>我们以<code>AtomicInteger</code>为例，它提供的主要操作有：</p>
<ul>
<li>增加值并返回新值：<code>int addAndGet(int delta)</code></li>
<li>加1后返回新值：<code>int incrementAndGet()</code></li>
<li>获取当前值：<code>int get()</code></li>
<li>用CAS方式设置：<code>int compareAndSet(int expect, int update)</code></li>
</ul>
<p>现在我们要做的就是将<code>totalBytes++</code>原子化，回到最初发生竞争状态的那段代码，我们要对<code>DownloadStatus</code>中的totalBytes进行修改，将其变成 <code>AtomicInteger</code>类型的数据。这时候就不能直接 <code>return totalBytes</code> 了，一定要调用 <code>get()</code>来获取当前的值；此外还要把++变成 <code>incrementAndGet()</code>，即自增1后返回。</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/40.png" style="zoom:100%;"></p>
<p>打印结果为： 100_000</p>
<p>原子类的实现原理就是<strong>compare and swap(CAS)</strong>, 比如说我调用 <code>incrementAndGet</code> 的时候原子类型的数据就会比较当前值和期望值，如果他们不相等，就进行交换操作。 </p>
<p>使用<code>java.util.concurrent.atomic</code>提供的原子操作可以简化多线程编程：</p>
<ul>
<li>原子操作实现了无锁的线程安全；</li>
<li>适用于计数器，累加器等。</li>
</ul>
<h3 id="Adders"><a href="#Adders" class="headerlink" title="Adders"></a>Adders</h3><p>虽然说原子类适用于计数器、累加器等，但是当有多个线程同时对一个对象进行累加操作的时候，我们更推荐使用Adder类，它同样可以实现原子化，但是在高并发的情况下，其速度会比 Atomic更快, 简单来说，Adder具有更高的吞吐量。</p>
<p>原理：<a href="https://blog.csdn.net/codingtu/article/details/89047291?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control" target="_blank" rel="noopener">参考这篇博客</a> </p>
<p>在LongAdder类中，我们使用 <code>intValue()</code>来获得当前<code>totalBytes</code>的值并返回为int 类型，同时在自增1的时候调用<code>increment()</code>方法。 总的来说和 Atomic 类是类似的。</p>
<p><img src="/2021/03/19/Java%E5%9F%BA%E7%A1%803/41.png" style="zoom:100%;"></p>
<h3 id="Synchronized-Collections"><a href="#Synchronized-Collections" class="headerlink" title="Synchronized Collections"></a>Synchronized Collections</h3><p>刚才我们讲的都是关于某一个变量的同步，现在我们来学对于一个集合的同步。</p>
<p>如果我们创建一个普通的 ArrayList集合，然后创建两个线程向集合中添加元素。有可能它们会发生 Race condition 导致数据丢失，为了规避这种情况的发生我们可以使用 Synchronized Collection:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//使用了 synchronizedCollection 能规避线程之间的进制，保持线程之间的同步</span></span><br><span class="line">        Collection&lt;Integer&gt; collection = </span><br><span class="line">          Collections.synchronizedCollection(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> thread1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">           collection.addAll(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">var</span> thread2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">           collection.addAll(Arrays.asList(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            thread1.join();</span><br><span class="line">            thread2.join();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(collection);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Concurrent-Collections"><a href="#Concurrent-Collections" class="headerlink" title="Concurrent Collections"></a>Concurrent Collections</h3><p>当并发高的时候，使用 Synchronized Collection 会导致CPU占用过高、性能下降。这时候我们可以用 <strong>Concurrent Collection</strong></p>
<p>在<a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/util/concurrent/package-summary.html" target="_blank" rel="noopener">Concurrent官方文档</a> 中，我们看到有 <code>ConcurrentHashMap</code>,<code>ConcurrentLinkedDeque</code>等并发集合</p>
<p>以Map为例，假如我们要对一个HashMap进行高并发的操作，我们就可以使用 <code>ConcurrentHashMap</code>类。事实上，<code>ConcurrentHashMap</code>和<code>HashMap</code>都是对 <code>Map</code>接口的实现类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">         Map&lt;Integer,String&gt;map = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">         map.put(<span class="number">1</span>,<span class="string">"a"</span>);</span><br><span class="line">         map.get(<span class="number">1</span>);</span><br><span class="line">         map.remove(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="The-Executive-Framework"><a href="#The-Executive-Framework" class="headerlink" title="The Executive Framework"></a>The Executive Framework</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><h3 id="Thread-Pools"><a href="#Thread-Pools" class="headerlink" title="Thread Pools"></a>Thread Pools</h3><h3 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h3><h3 id="Callables-and-Futures"><a href="#Callables-and-Futures" class="headerlink" title="Callables and Futures"></a>Callables and Futures</h3><h3 id="Asynchronous-Programming"><a href="#Asynchronous-Programming" class="headerlink" title="Asynchronous Programming"></a>Asynchronous Programming</h3><h3 id="Completable-Futures"><a href="#Completable-Futures" class="headerlink" title="Completable Futures"></a>Completable Futures</h3><h3 id="Creating-a-Completable-Future"><a href="#Creating-a-Completable-Future" class="headerlink" title="Creating a Completable Future"></a>Creating a Completable Future</h3><h3 id="Implementing-an-Asynchronous-API"><a href="#Implementing-an-Asynchronous-API" class="headerlink" title="Implementing an Asynchronous API"></a>Implementing an Asynchronous API</h3><h3 id="Running-Code-on-Completion"><a href="#Running-Code-on-Completion" class="headerlink" title="Running Code on Completion"></a>Running Code on Completion</h3><h3 id="Handling-Exceptions"><a href="#Handling-Exceptions" class="headerlink" title="Handling Exceptions"></a>Handling Exceptions</h3><h3 id="Transforming-a-Completable-Future"><a href="#Transforming-a-Completable-Future" class="headerlink" title="Transforming a Completable Future"></a>Transforming a Completable Future</h3><h3 id="Composing-Completable-Futures"><a href="#Composing-Completable-Futures" class="headerlink" title="Composing Completable Futures"></a>Composing Completable Futures</h3><h3 id="Combining-Completable-Futures"><a href="#Combining-Completable-Futures" class="headerlink" title="Combining Completable Futures"></a>Combining Completable Futures</h3><h3 id="Waiting-for-Many-Tasks-to-Complete"><a href="#Waiting-for-Many-Tasks-to-Complete" class="headerlink" title="Waiting for Many Tasks to Complete"></a>Waiting for Many Tasks to Complete</h3><h3 id="Waiting-for-the-First-Task"><a href="#Waiting-for-the-First-Task" class="headerlink" title="Waiting for the First Task"></a>Waiting for the First Task</h3><h3 id="Handling-timeouts"><a href="#Handling-timeouts" class="headerlink" title="Handling timeouts"></a>Handling timeouts</h3><h3 id="Project-Best-Price-Finder"><a href="#Project-Best-Price-Finder" class="headerlink" title="Project- Best Price Finder"></a>Project- Best Price Finder</h3><h3 id="Solution-Getting-a-Quote"><a href="#Solution-Getting-a-Quote" class="headerlink" title="Solution- Getting a Quote"></a>Solution- Getting a Quote</h3><h3 id="Solution-Getting-Many-Quotes"><a href="#Solution-Getting-Many-Quotes" class="headerlink" title="Solution- Getting Many Quotes"></a>Solution- Getting Many Quotes</h3><h3 id="Solution-Random-Delays"><a href="#Solution-Random-Delays" class="headerlink" title="Solution- Random Delays"></a>Solution- Random Delays</h3>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/" itemprop="url">离散分布和连续分布（2.4-2.6）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-16T13:15:07+08:00">
                2021-03-16
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2021-06-26T21:55:18+08:00">
                2021-06-26
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="常用离散分布"><a href="#常用离散分布" class="headerlink" title="常用离散分布"></a>常用离散分布</h1><h2 id="二项分布"><a href="#二项分布" class="headerlink" title="二项分布"></a>二项分布</h2><p>二项分布： X = “n次伯努利试验中成功的次数”</p>
<p>取值范围：0~n，为整数</p>
<p>分布列：$P(X=k)C_n^k p^k(1-p)^{n-k},k=0,1,\cdots,n$  </p>
<p>记为： $X \sim b(n,p)$ </p>
<h4 id="二点分布"><a href="#二点分布" class="headerlink" title="二点分布"></a>二点分布</h4><p>当 n=1 时的二项分布 $b(1,p)$ 称为 二点分布，或称 <strong>0-1分布</strong>，或称<strong>伯努利分布</strong>。</p>
<p>取值范围： 0，1</p>
<p>分布列： $P(X=x) = p^x(1-p)^{1-x}$ </p>
<p>二点分布主要用来描述一次伯努利试验中成功地次数(0或1) </p>
<h2 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h2><p>分布列： $P(X=k)=\frac{\lambda^k}{k!} e^{-\lambda},k=0,1,2,\cdots$  其中，参数 $\lambda&gt;0$ ，记为 $X\sim P(\lambda)$ </p>
<p>通过级数的知识，我们很容易验证泊松分布的正则性： $\sum<em>{k=0}^\infty \frac{\lambda^k}{k!}e^{-\lambda}=e^{-\lambda}\sum</em>{k=0}^{\infty} \frac{\lambda^k}{k!} =e^{-\lambda}e^{\lambda} = 1$</p>
<p>泊松分布常常用来刻画单位时间、单位面积上发生的次数。</p>
<p>泊松分布和二项分布的关系：在n重的伯努利试验中，设成功的概率为 $p<em>n$  当 $n\rightarrow \infty$  ，且 $n*p_n \rightarrow n$ 时，我们有 $\lim\limits</em>{n\rightarrow \infty}C_k^n p_n^k (1-p_n)^{n-k} = \frac{\lambda^k}{k!} e^{-\lambda}$ </p>
<p>泊松分布的概率质量函数(pmf) ：</p>
<p><img src="/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/8.png" style="zoom: 67%;"></p>
<p>对泊松分布的pmf做出的解释： 每个点的意义就是单位时间或者面积内随机事件发生k次的概率。</p>
<p>CDF:</p>
<p><img src="/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/9.png" style="zoom: 67%;"></p>
<p>对泊松分布的 CDF作解释 ：每个点的意义就是单位时间或者面积内随机事件发生的次数小于等于K次发生的概率</p>
<h4 id="期望与方差"><a href="#期望与方差" class="headerlink" title="期望与方差"></a>期望与方差</h4><p>求期望很简单，只要提出一个 $\lambda$ 剩下的求和为1；</p>
<p>方差的计算： 根据公式 $V(X)= E(X^2)-E(X)^2 = \lambda $ </p>
<h2 id="几何分布与负二项分布"><a href="#几何分布与负二项分布" class="headerlink" title="几何分布与负二项分布"></a>几何分布与负二项分布</h2><h3 id="几何分布"><a href="#几何分布" class="headerlink" title="几何分布"></a>几何分布</h3><p>几何分布：在伯努利试验序列中，记每次试验中事件A发生的概率为p，如果X为<strong>事件A首次出现</strong>时的<strong>试验次数</strong>，则X的可能取值为 $1,2\cdots$, 则称 X 服从几何分布，记为 $X\sim Ge(p)$ </p>
<p>分布列： $P(X=k)=(1-p)^{k-1}p , ~k=1,2\cdots$ </p>
<p>例如， 某产品的不合格率为0.05 , 则首次查到不合格品的检查次数 $X\sim Ge(0.05)$ </p>
<h4 id="性质：无记忆性"><a href="#性质：无记忆性" class="headerlink" title="性质：无记忆性"></a>性质：无记忆性</h4><p>设 $X\sim Ge(p)$ ,则对任意正整数m与n有： $P(X&gt;m+n|X&gt;m)=P(X&gt;n)$ </p>
<p>这个定理表明，在前m次试验中事件A没有出现的条件下，在接下去的n次试验中A仍然不出现的概率只与n有关，而与以前的m次试验无关，似乎忘记了前面m次的试验结果，这就是无记忆性。</p>
<h4 id="期望与方差-1"><a href="#期望与方差-1" class="headerlink" title="期望与方差"></a>期望与方差</h4><p><strong>期望:</strong></p>
<p>令 $1-p = q$ </p>
<p>$E(X)=p+2qp+3q^2p\cdots+kq^{k-1}p = p(1+2q+3q^2+\cdots+kq^{k-1})$ </p>
<p>令括号内部的式子为 $f(q)$, 则 $f(q)=(q+q^2+\cdots+q^k)’=[\frac{q(1-q^k)}{1-q}]’$</p>
<p>当$k\rightarrow \infty$的时候， $q^k\rightarrow 0$ ，因此 $[\frac{q}{1-q}]’ = \frac{1-q+q}{(1-q)^2}=\frac{1}{p^2}$ </p>
<p>所以 $E(X)=\frac{1}{p}$</p>
<p><strong>方差：</strong></p>
<p>根据公式 $V(X)=E(X^2)+E(X)^2$计算，方法和求期望一样。解得 $V(X)=\frac{1-p}{p^2}$</p>
<h3 id="负二项分布"><a href="#负二项分布" class="headerlink" title="负二项分布"></a>负二项分布</h3><p>作为几何分布的一种延伸，我们来讲负二项分布，也叫做帕斯卡分布</p>
<p>如果X 为事件 A 第 r 次出现时的试验次数，则 X的可能取值为 $r,r+1,\cdots,r+m,\cdots$ , 称 X 服从负二项分布。</p>
<p>分布列： $P(X=k)=C_{k-1}^{r-1}p^r(1-p)^{k-r} , k=r,r+1,\cdots$ </p>
<p>记为： $X\sim Nb(r,p)$   当 r=1 时，即为几何分布。</p>
<p>一个负二项分布可以写成 r 个<strong>独立同分布的几何分布的和</strong>的形式</p>
<h4 id="期望与方差-2"><a href="#期望与方差-2" class="headerlink" title="期望与方差"></a>期望与方差</h4><p>一个负二项分布可以写成r个独立同分布的几何分布的和的形式，因此其期望可以写作 $\frac{r}{p}$, 方差则可以写作$r(1-p)/p^2$</p>
<h1 id="常用连续分布"><a href="#常用连续分布" class="headerlink" title="常用连续分布"></a>常用连续分布</h1><h2 id="正态分布-高斯分布"><a href="#正态分布-高斯分布" class="headerlink" title="正态分布(高斯分布)"></a>正态分布(高斯分布)</h2><p>在统计学中常常用正态分布，在机器学习领域常常叫高斯分布。</p>
<p>若随机变量 X 的密度函数为 $p(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{\frac{(x-\mu)^2}{2\sigma^2}},-\infty&lt;x&lt;\infty$， 则称 X 服从正态分布，称X为正态变量</p>
<p>记作 $X\sim N(\mu,\sigma^2)$ 其中参数 $-\infty&lt;\mu&lt;\infty , \sigma&gt;0$ </p>
<p>密度函数(PDF) p(x):</p>
<p><img src="/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/1.png" style="zoom:180%;"></p>
<p>分布函数(CDF) $p(x)=\frac{1}{\sqrt{2\pi}\sigma}\int_{-\infty}^xe^{\frac{(t-\mu)^2}{2\sigma^2}}dt$</p>
<p><img src="/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/2.png" style="zoom: 50%;"></p>
<h3 id="标准正态分布"><a href="#标准正态分布" class="headerlink" title="标准正态分布"></a>标准正态分布</h3><p>当 $\mu =0,\sigma^2 =1 $ 时候。 通常记标准正态变量为U，记标准正态分布的密度函数为 $\varphi(u)$即：</p>
<p>$ \varphi(u)=\frac{1}{\sqrt{2\pi}}e^{-\frac{u^2}{2}}, -\infty&lt;u&lt;\infty$ </p>
<p> 分布函数为 $\Phi(u)$</p>
<p>$\Phi(u)=\frac{1}{\sqrt{2\pi}}\int_{-\infty}^u e^{-\frac{t^2}{2}}dt, -\infty&lt;u&lt;\infty$  </p>
<p> 由于标准正态分布的分布函数不含任何未知参数，故其值 $\Phi(u)=P(U\leq u)$ 完全可以算出。对于 $\Phi(u)$ 有</p>
<ul>
<li>$\Phi(-u)=1-\Phi(u)$ </li>
<li>$P(U&gt;u)= 1-\Phi(u)$ </li>
<li>$P(a&lt;U&lt;b)=\Phi(b)-\Phi(a)$ </li>
<li>$P(|U|&lt;c)=2\Phi(c)-1$ ，原理如下图所示，黄色阴影部分即为 $P(|U|&lt;c)$ </li>
</ul>
<p><img src="/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/3.jpg"></p>
<h3 id="正态分布族"><a href="#正态分布族" class="headerlink" title="正态分布族"></a>正态分布族</h3><p>正态分布有一个家族： $\mathcal P = {N(\mu,\sigma^2):-\infty &lt; \mu&lt;\infty ,\sigma &gt;0 } $,标准正态分布也是其中的一员. 一般的正态变量都可以通过一个线性变换(标准化) 化成标准正态变量。因此与正态变量有关的一切事件的概率都可以通过查标准正态分布函数表来获得。</p>
<p><strong>定理：</strong> 若随机变量 $X\sim N(\mu,\sigma^2)$ ,则 $U=(X-\mu)/\sigma\sim N(0,1)$ </p>
<p>由以上的定理，我们可以得到一些在实际中有用的计算公式: 若随机变量 $X\sim N(\mu,\sigma^2)$ ,则：</p>
<script type="math/tex; mode=display">
P(X\leq c) = \Phi(\frac{c-\mu}{\sigma})</script><p>例题：设随机变量 X服从正态分布 $N(108,3^2)$ , 试求：1. $P(102&lt;X&lt;117)$ 2. 常数a，使得 $P(X&lt;a)=0.95$ </p>
<p>我们可以利用公式 $P(a&lt;U&lt;b)=\Phi(b)-\Phi(a)$ 可得： $P(102&lt;X&lt;117)=P(117)-P(102)=\Phi(\frac{117-108}{3})-\Phi(\frac{102-108}{3})=\Phi(3)-\Phi(-2)=0.9759$ </p>
<p> 对于2，我们首先对定理做一个变形： 由 $P(X&lt;a)=\Phi(\frac{a-108}{3})= 0.95$  可知： $\Phi^{-1}(0.95)=\frac{a-108}3$ </p>
<p>所以现在我们就要查出满足$\Phi(x)=0.95$ 的值。通过查表得： $\Phi(1.64)=0.9495,\Phi(1.65)=0.9505$ ,再用线性内插法可得 $\Phi(1.645)= 0.95$ 即 $\Phi^{-1}(0.95)=1.645$ 故：$\frac{a-108}{3} = 1.645$ 解得 $a=112.935$</p>
<h4 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h4><p>设随机变量X 服从正态分布 $N(\mu,\sigma^2)$ 试问： 随着 $\sigma$ 的增大，概率 $P(|X-\mu|&lt;\sigma)$ 是如何变化的？</p>
<p>这个例题也可以作为一个正态分布的性质来记：</p>
<p>$P(|X-\mu|&lt;\sigma)=P(-\sigma &lt;X-\mu&lt;\sigma)=P(-1&lt;\frac{X-\mu}{\sigma}&lt;1)$</p>
<p>由 $\frac{(X-\mu)}{\sigma}\sim N(0,1)$可知，$P(-1&lt;\frac{X-\mu}{\sigma}&lt;1)=\Phi(1)-\Phi(-1)$</p>
<p>因此，不管 $\sigma$如何变化， $P(|X-\mu|&lt;\sigma)$的值都是个定值。</p>
<h3 id="3-sigma-原则"><a href="#3-sigma-原则" class="headerlink" title="$3\sigma$ 原则"></a>$3\sigma$ 原则</h3><p>设随机变量 $X\sim N(\mu,\sigma^2)$ , 则 $p(\mu-k\sigma&lt;X&lt;\mu+k\sigma)=P(|\frac{X-\mu}{\sigma}|&lt;k) = \Phi(k)-\Phi(-k)=2\Phi(k)-1$ </p>
<p>当 $k=1,2,3$ 时， 有</p>
<script type="math/tex; mode=display">
P(\mu-\sigma<X<\mu+\sigma) = 2\Phi(1)-1 = 0.6826\\
P(\mu-2\sigma<X<\mu+2\sigma) = 2\Phi(1)-1 = 0.9545\\
P(\mu-3\sigma<X<\mu+3\sigma) = 2\Phi(1)-1 = 0.9973</script><p>这是正态分布的重要性之，计入某随机变量的取值概率近似满足上面三个公式，则可认为这个随机变量近似服从正态分布。三式中有一个偏差较大，则可认为这个随机变量不服从正态分布。这就是 $3\sigma$ 原则。这个原则 在 X 的观察值较多的时候常常用于判断 X 的分布是否近似服从正态分布</p>
<h3 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h3><p>由期望的定义可以知道， $E(X)=\int_{-\infty}^{\infty}\frac{x}{\sigma\sqrt{2\pi}}exp{-\frac{(x-\mu)^2}{2\sigma^2}}dx$ </p>
<p>令 $y=x-u$ 可得： $E(X)=\int_{-\infty}^{\infty}y\frac{1}{\sigma\sqrt{2\pi}}exp{-\frac{y^2}{2\sigma^2}}dy+u\frac{1}{\sigma\sqrt{2\pi}}exp{-\frac{y^2}{2\sigma^2}}$ </p>
<p>第一部分用 $I<em>1$ 表示： 因为$\int</em>{-\infty}^{\infty} = x\frac{1}{\sigma\sqrt{2\pi}}exp{-\frac{x^2}{2\sigma^2}}$ 是一个奇函数，所以第一部分等于0</p>
<p>所以原式可以写成 $E(X)=\mu\int_{-\infty}^{\infty}\frac{1}{\sigma\sqrt{2\pi}}exp{-\frac{x^2}{2\sigma^2}}$ </p>
<p>后面的积分就是求 $\int_{-\infty}^\infty N(0,\sigma^2)dx = 1$ </p>
<p>因此$E(X)=\mu$ </p>
<h3 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h3><p> <img src="/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/14.png"></p>
<h2 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h2><p> 当分布函数(CDF)为：$F\left( x\right) =\begin{cases}0,<del>x &lt;a\ \dfrac{x-a}{b-a},</del>a\leq x\leq b\ 1,~~x &gt;b\end{cases}$， 密度函数(PDF)为$\begin{cases}\dfrac{1}{b-a},a &lt;x &lt;b\ 0, {其他}\end{cases}$时，这个分布就是区间 $(0,a)$上的均匀分布，记为 $U(a,b)$ </p>
<h3 id="期望和方差"><a href="#期望和方差" class="headerlink" title="期望和方差"></a>期望和方差</h3><p>$E(X) = \int_a^b x \frac{1}{b-a}dx = \frac{a+b}{2}$</p>
<p>$Var(X) = E(X^2)-E(X)^2 = (b-a)^2/12$ </p>
<h2 id="指数分布"><a href="#指数分布" class="headerlink" title="指数分布"></a>指数分布</h2><p>若随机变量X的密度函数(PDF)为$p(x) = \begin{cases}\lambda e^{-\lambda x} <del>,</del> x \geq 0 \ 0, x<0 \end{cases}$ 则称 x 服从指数分布。记作 $x\sim exp(\lambda)$ ,其中参数 $\lambda>0 $ .</0></p>
<p>正则性的验证：$\int_0^{+\infty} p(x) dx = -e^{-\lambda x}|_0^{\infty} = 1$ </p>
<p>指数分布的分布函数为： $F(x)=p(X\leq x) =\begin{cases}1- e^{-\lambda x} <del>,</del> x \geq 0 \ 0, x&lt;0 \end{cases}$ </p>
<p>指数分布是一种偏态分布，由于指数分布随机变量值可能取非负实数，所以指数分布常用作各种“寿命” 分布。比如说电子元器件的寿命、动物的寿命、通话时间都可以假定服从指数分布。</p>
<p>指数分布的 PDF: </p>
<p><img src="/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/6.png" style="zoom:67%;"></p>
<p>先来看 $\lambda = 1$ 这条曲线。曲线上横坐标为1的点，其意义是 1个单位时间该发生1次的概率。如果横坐标为2，其意义就是2个单位时间内发生1次的概率。抽象一点来说就是：第 k 次改时间发生后隔2个单位时间发生第 $k+1$ 次该事件的概率。</p>
<p>当 $\lambda = 1.5$ 的时候，变得更加抽象了，因为这时候横坐标为1的点其意义是1个单位的时间内发生1.5次的概率。换个说法就是第k次事件发生后1个单位时间内该事件发生1.5 次的概率。</p>
<p>指数分布的 CDF：</p>
<p><img src="/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/10.png" style="zoom:67%;"></p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><h4 id="无记忆性"><a href="#无记忆性" class="headerlink" title="无记忆性"></a>无记忆性</h4><p>和几何分布一样，指数分布有着无记忆性。 也就是说,对任意的$s,t &gt;0$, 若$X\sim Exp(\lambda)$ ,则 $P(x&gt;s+t|x&gt;s)=P(x&gt;t)$  .</p>
<p>放到一个具体的例子中，可以理解为： 记X 为某种产品的使用寿命(h) 。若X服从指数分布，那么已知此产品使用了 s(h)没有发生故障，则再能使用 t(h) 而不发生故障的概率与已使用的 $s(h)$无关，只想到与重新开始使用 t(h) 的概率。</p>
<h4 id="和泊松分布的关系"><a href="#和泊松分布的关系" class="headerlink" title="和泊松分布的关系"></a>和泊松分布的关系</h4><p>如果某设备在长为t的时间 $[0,t]$ 内发生故障的次数 $N(t)$ (与时间长度t有关)服从参数为 $\lambda t$ 的泊松分布。则相继两次故障之间的时间间隔T服从参数为$\lambda $ 的指数分布。</p>
<p><img src="/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/7.png" style="zoom:150%;"></p>
<h3 id="期望和方差-1"><a href="#期望和方差-1" class="headerlink" title="期望和方差"></a>期望和方差</h3><p>由指数分布和伽马分布的关系可以知道，指数分布的期望和方差即为当$\alpha = 1$ 的时候伽马分布的期望和方差。</p>
<p>所以 $E(X) = \frac{1}{\lambda},Var(X) = \frac{1}{\lambda^2}$ </p>
<p>泊松分布是针对随机事件发生次数的定义的<strong>离散随机变量</strong>，而指数分布是针对随机事件发生的间隔时间定义的<strong>连续随机变量</strong>，这是二者最大的区别。切莫因为参数λ把二者混淆了</p>
<h2 id="伽马分布"><a href="#伽马分布" class="headerlink" title="伽马分布"></a>伽马分布</h2><h3 id="伽马函数"><a href="#伽马函数" class="headerlink" title="伽马函数"></a>伽马函数</h3><p>首先我们来定义伽马函数</p>
<p>$\Gamma(\alpha) = \int_0^\infty x^{\alpha-1}e^{-x} dx$  是伽马函数。其中 $\alpha&gt;0 $ 。</p>
<h4 id="函数性质"><a href="#函数性质" class="headerlink" title="函数性质"></a>函数性质</h4><ul>
<li>$\Gamma(1)=1,\Gamma(\frac{1}{2}) = \sqrt{\pi}$</li>
</ul>
<p>当 $\alpha$ = 0.5 时， $\Gamma(\frac{1}{2} ) = \int_0^\infty\frac{e^{-x}}{\sqrt{x}}dx$ , 令 $t = \sqrt x$ 则 $x = t^2$ 原式等于 $2\int_0^\infty e^{-t^2}dt$ </p>
<p>根据正态分布的密度函数可以知道，当 $\mu = 0,\sigma^2= \frac{1}{2}$ 时， $1 = \int_{-\infty}^{\infty} \frac{1}{\sqrt{2\pi \frac{1}{2}}} <em>exp(\frac{-(t-0)^2}{2</em>\frac{1}{2}})dt$ </p>
<p>$\int_{-\infty}^{\infty}  \frac{1}{\sqrt\pi}*e^{-t^2}dt = 1 $ 又正态分布为偶函数，因此可得 $\Gamma(\frac{1}2)=\sqrt{\pi}$ </p>
<ul>
<li>$\Gamma(\alpha+1) = \alpha\Gamma(\alpha) $ (可用分布积分法证明得到)，当 $\alpha$为自然数 n的时候，有 $\Gamma(n+1) = n\Gamma (n)= n!$ </li>
</ul>
<h3 id="伽马分布-1"><a href="#伽马分布-1" class="headerlink" title="伽马分布"></a>伽马分布</h3><p>若随机变量X的密度函数为 $p(x) = \begin{cases}\frac{\lambda^\alpha}{\Gamma(\alpha)}x^{\alpha-1}e^{-\lambda x} <del>,</del> x \geq 0 \ 0, x<0 \end{cases}$ 则称 x 服从 伽马分布，记作 $x\sim ga(\alpha ,\lambda)$ 其中，$\alpha>0 $ 为形状参数，$\lambda&gt;0$ 是尺度参数。如下图所示</0></p>
<p><img src="/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/12.png"></p>
<h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><ul>
<li><p>当伽马函数的 $\alpha = 1$ 的时候 ，伽马分布的PDF = 指数分布的PDF。这说明指数分布是特殊的伽马分布 </p>
<h3 id="期望-1"><a href="#期望-1" class="headerlink" title="期望"></a>期望</h3></li>
</ul>
<p>首先我们要牢记这条性质：$\Gamma(\alpha+1) = \alpha\Gamma(\alpha) $ </p>
<p>$E(X) = \int_0^\infty xp(x)dx = \int_0^\infty x\cdot\frac{\lambda^\alpha}{\Gamma{(\alpha)}}x^{\alpha-1}e^{-\lambda x}dx = \frac{\lambda^\alpha}{\Gamma(\alpha)}\int_0^\infty x^{(\alpha+1)-1} e^{-\lambda x}dx $  </p>
<p>$=\frac{\lambda^\alpha}{\Gamma(\alpha)}<em>\frac{\Gamma(\alpha+1)}{\lambda^{\alpha+1}}</em>1 = \frac{\alpha}{\lambda}$ </p>
<p>我们可以利用凑数的方法，强行把后面的积分配成一个 $Ga(\alpha+1,\lambda)$ ,根据 $\int_0^\infty Ga(\alpha+1,\lambda) = 1$可以消除积分。</p>
<h3 id="方差-1"><a href="#方差-1" class="headerlink" title="方差"></a>方差</h3><p>利用配方法，我们还可以求出伽马分布的方差</p>
<p>我们根据公式 $Var(X) = E(X^2)-E(X)^2$ 可以得到</p>
<p> $E(X^2) = \int_0^\infty x^2 \frac{\lambda^\alpha}{\Gamma(\alpha)}x^{\alpha-1}e^{-\lambda x}dx =\frac{\lambda^\alpha}{\Gamma(\alpha)} \frac{\Gamma({\alpha+2})}{\lambda^{\alpha+2}}\int_0^\infty Ga(\alpha+2,\lambda)dx = \frac{\alpha(\alpha+1)}{\lambda^2}$ </p>
<p>$Var(X) = E(X^2)-E(X)^2 = \frac{\alpha(\alpha+1)}{\lambda^2} - \frac{\alpha^2}{\lambda^2} = \frac{\alpha}{\lambda^2}$</p>
<h2 id="贝塔分布"><a href="#贝塔分布" class="headerlink" title="贝塔分布"></a>贝塔分布</h2><h3 id="贝塔函数"><a href="#贝塔函数" class="headerlink" title="贝塔函数"></a>贝塔函数</h3><p>称函数 $B(a,b)=\int_0^1 x^{a -1}(1-x)^{b-1}dx$ 为贝塔函数，其中参数$a&gt;0,b&gt;0$ </p>
<h4 id="贝塔函数性质"><a href="#贝塔函数性质" class="headerlink" title="贝塔函数性质"></a>贝塔函数性质</h4><ul>
<li>$B(a,b) = B(b,a)$ 通过换元法可以直接证明</li>
<li>贝塔函数和伽马函数之间有关系： $B(a,b) = \frac{\Gamma(a)\Gamma(b)}{\Gamma(a+b)}$ </li>
</ul>
<h3 id="贝塔分布-1"><a href="#贝塔分布-1" class="headerlink" title="贝塔分布"></a>贝塔分布</h3><p>若随机变量X的密度函数为  $p(x) = \begin{cases}\frac{\Gamma (a+b)}{\Gamma(a){\Gamma(b)}}x^{a-1}(1-x)^{b-1 } <del>,</del> 0<x <1\\ 0, 其他 \end{cases}$ ，则称其为 贝塔分布，记作 $x\sim be(a,b)$ 其中 $a>0,b&gt;0$ 都是形状参数，下图给出几种典型的贝塔分布密度函数曲线。</x></p>
<p><img src="/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/13.png" style="zoom:150%;"></p>
<ul>
<li>当 a=b=1 时，$Be(1,1) = U(0,1)$ 即贝塔分布等于0-1上的均匀分布</li>
</ul>
<p>因为服从贝塔分布 $Be(a,b)$ 的随机变量是仅在区间$(0,1)$取值的所以可以描述一些不合格产品率、机器的维修率、市场的占有率、射击的命中率等各种比率。</p>
<h2 id="期望和方差-2"><a href="#期望和方差-2" class="headerlink" title="期望和方差"></a>期望和方差</h2><p>同样的，我们可以利用求 伽马分布的期望和方差的办法来求贝塔函数的期望和方差。</p>
<p>$P(X) =\frac{\Gamma(a+b)}{\Gamma(a)\Gamma(b)} x^{a-1}(1-x)^{b-1}$ </p>
<p>$E(X) = \frac{\Gamma(a+b)}{\Gamma(a)\Gamma(b)}\int_0^1  x^{(a+1)-1}(1-x)^{b-1} dx= \frac{\Gamma(a+b)}{\Gamma(a)\Gamma(b)}\frac{\Gamma(a+1)\Gamma(b)}{\Gamma(a+b+1)} = \frac{a}{a+b}$ </p>
<p>$Var(X) = E(X^2)-E(X)^2 = \frac{(a+1)a}{(a+b+1)(a+b)}- \frac{a^2}{(a+b)^2} = \frac{ab}{(a+b+1)(a+b)^2}$ </p>
<h1 id="常用概率分布表格"><a href="#常用概率分布表格" class="headerlink" title="常用概率分布表格"></a>常用概率分布表格</h1><p><img src="/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/4.png"></p>
<p><img src="/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/4.png"></p>
<h1 id="随机变量函数的分布"><a href="#随机变量函数的分布" class="headerlink" title="随机变量函数的分布"></a>随机变量函数的分布</h1><h2 id="离散随机变量函数的分布"><a href="#离散随机变量函数的分布" class="headerlink" title="离散随机变量函数的分布"></a>离散随机变量函数的分布</h2><p><img src="/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/16.png"></p>
<p>这种情况比较简单，如果题目给出的是X的分布列，那么我们直接列出$g(x)$的分布列即可。</p>
<h2 id="连续随机变量函数的分布"><a href="#连续随机变量函数的分布" class="headerlink" title="连续随机变量函数的分布"></a>连续随机变量函数的分布</h2><h3 id="当-Y-g-X-为离散随机变量"><a href="#当-Y-g-X-为离散随机变量" class="headerlink" title="当 $Y=g(X)$ 为离散随机变量"></a>当 $Y=g(X)$ 为离散随机变量</h3><p>这种情况比较简单，只要将 Y 的值一一列出，再讲 Y 取各种可能值得概率求出来即可。例如：设 $X\sim N(\mu,\sigma^2)$ </p>
<p>$Y = \begin{cases}0 , X&lt;\mu \ 1, X\geq \mu \end{cases}$   这样计算很容易： Y 服从 $p=0.5$的0-1分布</p>
<p>因此，我们要注意一些 pdf 为对称函数的分布，会简化很多计算。</p>
<p>比如说 $X$的pdf为 $p(x)=\frac{2}{\pi}\cdot \frac{1}{e^x+e^{-x}} ,-\infty&lt;x&lt;\infty$ ,试求 $Y=g(X)$ 的分布， $g(X) = \begin{cases}-1 , x&lt;0 \ 1, x\geq 0 \end{cases}$  </p>
<p>p(x)就是一个很标准的偶函数，关于x=0对称。因此 Y = 1和-1 的概率相等，都是0.5</p>
<h3 id="当-g-x-在定义域内为严格单调函数时"><a href="#当-g-x-在定义域内为严格单调函数时" class="headerlink" title="当 $g(x)$ 在定义域内为严格单调函数时"></a>当 $g(x)$ 在定义域内为严格单调函数时</h3><h4 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h4><p>设 $X$ 是连续随机变量，其密度函数为 $p_X(x)$ $Y=g(x)$ 是另一个连续随机变量。若 $y=g(x)$ 严格单调，其反函数 $h(y)$ 有连续导函数，则$Y=g(X)$ 的密度函数为：</p>
<p>$p_Y(y)= \begin{cases} P_X(h(y))|h’(y)| ,~a&lt;y&lt;b \ 0, 其他 \end{cases}$  其中  $a=min{g(-\infty).g(\infty)}$  , $b=max{g(-\infty),g(\infty)}$</p>
<h5 id="例题：-1"><a href="#例题：-1" class="headerlink" title="例题："></a>例题：</h5><p>设随机变量X服从区间$(1,2)$上的均匀分布，试求 $Y=e^{2X}$ 的密度函数</p>
<p><strong>步骤1：写出 X 的 pdf </strong></p>
<p>$p_X(y)= \begin{cases} 1 ,~~1&lt;y&lt;2 \ 0, 其他 \end{cases}$</p>
<p><strong>步骤2：写出Y与X之间的关系Y=g(x)</strong></p>
<p>这里我们已经知道了 $y=e^{2x}$ </p>
<p><strong>步骤3： 判断g(x)是否在定义域内为单调递增函数</strong></p>
<p>$y=e^{2x}$在 $x\in(1,2)$ 内是严格的单调递增函数</p>
<p><strong>步骤4：计算g(x)的反函数h(x)以及 |h’(y)|</strong></p>
<p>求得 $x=\frac{1}{2}\ln y$</p>
<p><strong>步骤5：根据公式，计算</strong> $p_Y(y)=p_X(h(y))|h’|$</p>
<p>$p_Y(y) =\begin{cases} 1\cdot \frac{1}{2y}, e^2&lt;y&lt;e^4 \ \0 ~~其他 \end{cases}$ </p>
<p>根据以上定理，我们可以来证明几个很有用的结论，并用定理形式表示。</p>
<h4 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h4><p>设随机变量 X 服从正态分布 $N(\mu,\sigma^2)$ ，则当 $a\neq 0$ 时候，有 $Y=aX+b\sim N(a\mu+b,a^2\sigma^2)$ </p>
<p>我们可以通过分类讨论来证明 $p_Y(y)=\frac{1}{\sqrt{2\pi}(a\sigma)}{exp{-\frac{(y-a\mu-b)^2}{2a^2\sigma^2}}}$ ,也就是 $N(a\mu+b,a^2\sigma^2)$ 的密度函数。</p>
<p>我们可以直接用 期望和方差来计算 $\mu$值和$\sigma^2$值</p>
<h4 id="定理3：对数正态分布"><a href="#定理3：对数正态分布" class="headerlink" title="定理3：对数正态分布"></a>定理3：对数正态分布</h4><p>设随机变量 $X\sim N(\mu,\sigma^2)$ </p>
<p>令 $Y=e^X$ ，那么当$y&gt;0$ 时，Y 的密度函数为：</p>
<script type="math/tex; mode=display">
p_Y(y) = \frac{1}{\sqrt{2\pi}\sigma}\exp\{-\frac{(\ln y-\mu)^2}{2\sigma^2}\}\frac{1}{y} = \frac{1}{\sqrt{2\pi}y \sigma} \exp\{-\frac{(\ln y-\mu)^2}
{2\sigma^2}\}</script><p>$p_Y(y)= \begin{cases}\frac{1}{\sqrt{2\pi}y\sigma}exp{-\frac{(\ln y-\mu)^2}{2\sigma^2}} , y&gt;0 \ 0, y\leq 0  \end{cases}$ </p>
<p>这个分布被称为正态分布，记为 $LN(\mu,\sigma^2)$ ,其中 $\mu$ 称为对数均值，$\sigma^2$ 称为对数方差。 对数正态分布 $LN(\mu,\sigma^2)$ 是一个偏态分布，也是一个常用分布，实际种有不少随机变量服从对数正态分布。 </p>
<p>对数函数的证明：</p>
<ul>
<li>绝缘材料的寿命服从对数正态分布</li>
<li>设备故障的维修时间服从对数正态分布</li>
</ul>
<h5 id="对数正态分布的期望"><a href="#对数正态分布的期望" class="headerlink" title="对数正态分布的期望"></a>对数正态分布的期望</h5><script type="math/tex; mode=display">
E(Y)=E(\exp\{X\})=\int_{-\infty}^\infty\exp\{x\}\frac{1}{\sqrt {2\pi}\sigma} \exp\{-\frac{1}{2\sigma^2}(x-\mu)^2\}dx\\~\\
=\int_{-\infty}^\infty \frac{1}{\sqrt{2\pi}\sigma}\exp\{-\frac{1}{2\sigma^2}(x^2-2\mu x-2\sigma^2x+\mu^2)\}dx\\
~\\
=\int_{-\infty}^\infty\frac{1}{\sqrt{2\pi}\sigma}\exp\{-\frac{1}{2\sigma^2}(x-\mu-\sigma^2)^2+\frac{(\mu+\sigma^2)^2}{2\sigma^2}-\frac{\mu^2}{2\sigma^2}\}dx\\
=\exp\{\mu+\sigma^2/2\}</script><p><strong>给定$N(0,1)$的p分位数为$\mu_p$ ,求Y的p分位数 $y_p$</strong></p>
<p>已知</p>
<script type="math/tex; mode=display">
p=P(Y\leq y_p)=P(\exp\{X\}\leq y_p)=P(X\leq \ln(y_p))=P(\frac{X-\mu}{\sigma}\leq\frac{\ln(y_p)-\mu}{\sigma})\\</script><p>因为 $X\sim N(\mu,\sigma^2)$, 所以 $\frac{X-\mu}{\sigma}\sim N(0,1)$ ，于是：</p>
<script type="math/tex; mode=display">
\frac{ln(Y_p)-\mu}{\sigma}=\mu_p</script><p>因此，$y_p=\exp{\sigma\mu_p+\mu}$</p>
<h4 id="定理4"><a href="#定理4" class="headerlink" title="定理4"></a>定理4</h4><p>设随机变量 X 服从伽马分布 $Ga(\alpha,\lambda)$ ，则当 $k&gt;0$的时候，有 $Y=kX\sim Ga(\alpha,\lambda/k)$ </p>
<p>根据定理1可得， $p_Y(y)=p_x(\frac{y}k)\frac{1}{k} = \frac{\lambda^\alpha}{k\Gamma{(\alpha)}} (\frac{y}{k})^{\alpha-1} exp{-\lambda \frac{y}{k}}$ </p>
<p>=$\frac{(\lambda/k)^\alpha}{\Gamma(\alpha)}y^{\alpha-1} exp{-\frac{\lambda}{k}y}$  这也就是 $Ga(\alpha,\lambda/k)$ 的密度函数。</p>
<h4 id="定理5"><a href="#定理5" class="headerlink" title="定理5"></a>定理5</h4><p>若随机变量 X的分布 $F_X(x)$ 为严格单调增的连续函数，其反函数 $F_X^{-1} (y)$ 存在，那么 $Y=F_X(X)$服从(0,1)上的均匀分布 $U(0,1)$ </p>
<p>这个定理比较神奇，我们来看一下它的证明：</p>
<p>由于分布函数 $F_X(x)$ 仅在 $[0,1]$区间上取值，因此当 $y&lt;0$ 时，因为 ${F_X(X)\leq y}$ 是不可能事件，所以 $F_Y(y) = P(Y\leq y)=P(F_X(X)\leq y)=0$ </p>
<p>当 $0\leq y&lt;1$ 有 $F_Y(y) = P(Y\leq y) = P(F_X(X)\leq y)=P(X\leq F_X^{-1}(y))=F_X(F_X^{-1}(y))=y$ </p>
<p>当 $y\geq 1$ 时， 因为 ${F_Y(y) \leq y)}$是必然事件 所以 $F_Y(y)=1$ </p>
<p><strong>这个定理表明</strong>: 均匀分布在连续分布类中占有特殊地位，任一个连续随机变量 X 都可通过其分布$F(x)$ 与均匀分布随机变量 $U$ 发生关系，譬如 X 服从指数分布, 其分布函数 $F(x)= 1-e^{-\lambda X}$ .<strong>当 x 换为 X</strong> 后，有 $U=1-e^{-\lambda X}$ 或者 $X=\frac{1}{\lambda}\ln\frac{1}{1-U} $ </p>
<p>后一式表明： 由均匀分布 $U(0,1)$ 的随机数 $u_i$ 可得指数分布$Exp(\lambda)$ 的随机数 $x_i=\frac{1}{\lambda}ln(\frac{1}{1-u_i}),i=1,2,\cdots,n,\cdots$ 而均匀分布随机数在任何一个统计软件中都可以产生，从而指数分布的随机数也可以获得。</p>
<p>各种分布随机数的获得，就是进行蒙特卡洛法的基础</p>
<h3 id="g-x-为其他形式时"><a href="#g-x-为其他形式时" class="headerlink" title="$g(x)$ 为其他形式时"></a>$g(x)$ 为其他形式时</h3><p>如果g(x)不是严格单调的函数，那么可直接由 分布函数 $F_Y(y)=P(g(X)\leq y)$出发，按函数$g(x)$ 的特点作个案处理，比如：</p>
<p>设随机变量X 服从<strong>标准正态分布</strong>  $N(0,1)$，试求 $Y=X^2$ 的分布函数函数</p>
<p><strong>步骤1：求 Y 的取值范围</strong></p>
<p>首先 $Y=X^2$,x的取值范围为$(-\infty,+\infty)$ ,则 y的取值范围为 $[0,\infty)$</p>
<p>那么我们就可以先确定当 $y\leq 0$ 的时候，有 $F_Y(y)=0$ ，从而$P_Y(y)=0$ </p>
<p><strong>步骤2：根据定义求解。</strong> $F_Y(y)=p_X(Y\leq y)=p_X(g(x)\leq y)$</p>
<p>当 $y&gt;0$ 的时候，有 $F_Y(y)=p_X(Y\leq y)=p_X(X^2\leq y)=p(-\sqrt y\leq X\leq \sqrt  y)=2\Phi(\sqrt y)-1$ </p>
<p>因此 $Y$ 的分布函数为 $F_Y = \begin{cases}2\Phi(\sqrt y)-1 , y&gt;0 \ 0, y\leq 0 \end{cases}$ </p>
<h1 id="分布的其他特征数"><a href="#分布的其他特征数" class="headerlink" title="分布的其他特征数"></a>分布的其他特征数</h1><h2 id="k阶矩"><a href="#k阶矩" class="headerlink" title="k阶矩"></a>k阶矩</h2><p><strong>定义：</strong> 设 X 为随机变量，k为正整数。 若数学期望$E(X)$ 存在，则称 $\mu_k = E(X^k)$ 为X的 k阶原点矩。称 $v_k = E(X-E(X))^k$ 为X的k阶中心矩。</p>
<p>显然,<strong>一阶原点矩</strong>就是数学<strong>期望</strong>，<strong>二阶中心矩</strong>就是<strong>方差</strong>。由1于 $|X|^{k-1} \leq |X|^k+1$, 故 k 阶矩存在时，低于k的各阶矩都存在。</p>
<p>中心矩和原点矩之间有一个简单的关系： </p>
<script type="math/tex; mode=display">
v_k = E(X-E(X))^k - E(X-\mu_1)^k = \sum_{i=0}^k C_k^i \mu_i(-\mu_1)^{k-i}</script><h2 id="变异系数"><a href="#变异系数" class="headerlink" title="变异系数"></a>变异系数</h2><p>当在比较两个随机变量的波动大小的时候，如果仅仅看方差(标准差) 的大小有时会产生不合理的现象。这有两个原因</p>
<ul>
<li>随机变量的取值有量纲，不同量纲的随机变量用其方差(或标准差)去比较它们的波动大小就显得不合理</li>
<li>在取值的量纲相同的情况下，取值的大小有一个相对性问题，取值较大的随机变量的方差(或标准差)也允许大一些。</li>
</ul>
<p>因此，要比较两个随机变量的波动大小的时候，在有些场合使用<strong>变异系数</strong> 来进行比较更有可比性：</p>
<p>若随即变量 X 的二阶矩存在，则称比值：$G_v(X) = \frac{\sqrt{Var(X)}}{E(X)} = \frac{\sigma(X)}{E(X)}$  为 X 的变异系数。</p>
<h2 id="分位数"><a href="#分位数" class="headerlink" title="分位数"></a>分位数</h2><p>设连续随机变量X的分布函数为 $F(x)$ ,密度函数为$p(x)$,对任意 $p\in(0,1)$ </p>
<ol>
<li><p>满足条件 $F(x<em>p) = \int</em>{-\infty}^{x_p}p(x)dx=p$ 的   $x_p$ 为此分布的 p分位数，又称<strong>下侧p分位数</strong>；</p>
</li>
<li><p>同理我们称满足条件 $1-F(x<em>p’) = \int</em>{x_p’}^{\infty}p(x)dx=p $  的 $x_p’$ 为此分布的<strong>上侧p分位数</strong></p>
</li>
<li><p>分位数 $x_p$ 是把密度函数下的面积分为两块，左侧面积恰好为p  </p>
</li>
<li>我们通过标准正态分布p分位数表可以知晓 $\Phi(x)$ 的不同分位数的值$u_p$。然后，对于一般正态分布$N(\mu,\sigma^2)$的p分位数$x_p$ 是方程 $\Phi(\frac{x_p-\mu}{\sigma})= p$ 的解。因此 $x_p = \mu+\sigma u_p$</li>
</ol>
<h2 id="中位数"><a href="#中位数" class="headerlink" title="中位数"></a>中位数</h2><p>设连续随机变量 X 的随机分布为 $F(x)$ ,密度函数为 $p(x)$. 称 $p=0.5$ 时的p分位数$x_{0.5}$ 为此分布的中位数。</p>
<p>$F(x<em>{0.5}) =\int</em>{-\infty}^{x_{0.5}}p(x)dx = 0.5 $ </p>
<h2 id="偏度系数"><a href="#偏度系数" class="headerlink" title="偏度系数"></a>偏度系数</h2><p>设随机变量 $X$ 的<strong>前三阶矩</strong>存在，则比值</p>
<p>$\beta_S = \frac{v_3}{v_2^{3/2}} = \frac{E(X-E(X))^3}{[Var(X)]^{3/2}}$  称为 X (或分布) 的偏度系数，简称偏度。 当 $\beta_S&gt;0$  时，称该分布为右偏(正偏)，当 $\beta_S&lt;0$ 时，称该分布为左偏(负偏)。</p>
<p>简单来判断，尾巴偏哪(异常值在哪)就是往哪偏：</p>
<p><img src="/2021/03/16/%E7%A6%BB%E6%95%A3%E5%88%86%E5%B8%83%E5%92%8C%E8%BF%9E%E7%BB%AD%E5%88%86%E5%B8%83%EF%BC%882-4-2-6%EF%BC%89/15.png"></p>
<h2 id="峰度系数"><a href="#峰度系数" class="headerlink" title="峰度系数"></a>峰度系数</h2><ol>
<li>设随机变量 X 的<strong>前四阶矩</strong>存在，则 $\beta_k = \frac{v_4}{v_2^2}-3=\frac{E(X-E(X))^4}{[Var(X)]^2}-3$  称为X(或分布) 的峰度系数，简称峰度。</li>
<li>峰度时描述分布尖峭程度和尾部粗细的一个特征数</li>
<li>任一正态分布的峰度 $\beta_k =0$ 当 $\beta_k<0$时， 分布比正态分布平坦； 当$\beta_k>0$时，分布比正态分布更尖峭</0$时，></li>
<li><p>偏度与峰度都是描述分布(密度)形状的参数。</p>
<p>z</p>
</li>
</ol>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/03/16/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%EF%BC%882-1-2-3%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/16/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%EF%BC%882-1-2-3%EF%BC%89/" itemprop="url">随机变量（2-1-2-3）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-16T13:14:02+08:00">
                2021-03-16
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2023-01-16T11:57:01+08:00">
                2023-01-16
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="随机变量及其分布"><a href="#随机变量及其分布" class="headerlink" title="随机变量及其分布"></a>随机变量及其分布</h1><p>定义在样本空间$\Omega$上的实值函数 $X=X(\omega)$ 称为随机变量，通常用大写的字母 X，Y，Z等表示随机变量，其取值用小写字母 x,y,z 等表示。</p>
<p>假如一个随机变量尽可能取有现个或可列个值，则称其为离散随机变量；假如一个随机变量的可能取之充满数轴上的一个区间 $(a,b)$ ,则称其为连续随机变量，其中a或b可以是 $\infty$ </p>
<h3 id="随机变量的分布函数-CDF"><a href="#随机变量的分布函数-CDF" class="headerlink" title="随机变量的分布函数(CDF)"></a>随机变量的分布函数(CDF)</h3><p>设 X 是一个随机变量，对任意实数x，称 $F(x) =P(X\leq x)$ 为随机变量X的分布函数。 且<strong>称 $X$ 服从 $F(x)$ , 记为$X\sim F(x)$</strong> 。 </p>
<h4 id="三条基本性质："><a href="#三条基本性质：" class="headerlink" title="三条基本性质："></a>三条基本性质：</h4><ul>
<li><strong>单调性</strong>  $F(x)$ 是定义在整个实数轴上的<strong>单调非减函数</strong> ，即对任意的 $x_1&lt;x_2$ ,有 $F(x_1)\leq F(x_2)$</li>
<li><strong>有界性</strong> 对任意的x，都有 $0\leq F(x)\leq 1$ 且 $F(-\infty) = \lim\limits<em>{x\rightarrow-\infty}F(x) = 0$; $F(\infty) = \lim\limits</em>{x\rightarrow\infty}F(x)=1$ </li>
<li><strong>右连续性</strong> $F(x)$ 是 x 的右连续函数，即对任意的 $x<em>0$ ,有 $\lim\limits</em>{x\rightarrow x_0^{+0}}F(x)=F(x_0)$ ,即 $F(x_0+0)=F(x_0)$ </li>
</ul>
<p>右连续性在计算分布函数中的未知参数有很大的作用。</p>
<p>这三条基本性质也成为了判别某个函数是否能成为分布函数的<strong>充要条件</strong> </p>
<p> 接下来还会说CDF是<strong>概率密度函数</strong>(PDF)的积分</p>
<p>有了随机变量 X的分布函数，那么有关 X 的各种事件的概率都能方便的用分布函数来表示了。例如对任意的实数 a、b，有：</p>
<ol>
<li>$P(a&lt;X\leq b) = F(b)-F(a)$</li>
<li>$P(a&lt;X&lt;b)=F(b-0)-F(a)$</li>
<li>$P(a\leq X\leq b)=F(b)-F(a-0)$</li>
<li>$P(a\leq X&lt;b)=F(b-0)-F(a-0)$</li>
<li>$P(X=a)=F(a)-F(a-0)$</li>
<li>$P(X\geq b)=1-F(b-0)$</li>
<li>$P(X&gt;b)= 1-F(b)$</li>
<li>$P(X&lt;b)=F(b-0)$</li>
</ol>
<p>特别当 F(x) 在 a与b 处连续时，有 $F(a-0)=F(a), F(b-0)=F(b)$ </p>
<p>上面这几个 公式非常重要，我们要牢牢基础。</p>
<h3 id="离散随机变量的概率分布列"><a href="#离散随机变量的概率分布列" class="headerlink" title="离散随机变量的概率分布列"></a>离散随机变量的概率分布列</h3><p>设 X 是一个离散随机变量，如果 X 的所有可能取值是 $x_1,x_2,\cdots,x_n,\cdots$ ,则称 X 取 $x_i$ 的概率。则称 X 取 $x_i$ 的概率 $p_i = p(x_i)=P(X=x_i),i=1,2,\cdots,n,\cdots$  为 X 的概率分布列或简称分布列，记为 $X\sim {p_i}$ </p>
<h4 id="分布列的基本性质"><a href="#分布列的基本性质" class="headerlink" title="分布列的基本性质"></a>分布列的基本性质</h4><ul>
<li>非负性  $p(x_i)\geq 0,i=1,2\cdots$</li>
<li>正则性 $\sum_{i=1}^\infty p(x_i)=1$ </li>
</ul>
<p>由离散随机变量 X 的分布列很容易写出 X的分布函数</p>
<h3 id="连续随机变量的概率密度函数-PDF"><a href="#连续随机变量的概率密度函数-PDF" class="headerlink" title="连续随机变量的概率密度函数(PDF)"></a>连续随机变量的概率密度函数(PDF)</h3><p>设随机变量X 的分布函数为 $F(x)$ ,如果存在实数轴上的一个非负可积函数$p(x)$,使得对任意函数x有 $F(x) = \int_{-\infty}^x p(t)dt$ ,则称 $p(x)$ 为 X 的<strong>概率密度函数</strong>，简称<strong>密度函数</strong> ，同时称 X 为连续随机变量，称 $F(x)$ 为<strong>连续分布函数</strong>  </p>
<p>简单的来说就是PDF是CDF的一阶导数。</p>
<h4 id="密度函数的基本性质"><a href="#密度函数的基本性质" class="headerlink" title="密度函数的基本性质"></a>密度函数的基本性质</h4><ul>
<li>非负性 $p(x)\geq 0$</li>
<li>正则性 $\int_{-\infty}^{\infty} p(x)dx = 1$</li>
</ul>
<p>譬如已知某个函数 $p(x)$ 为密度函数，若$p(x)$ 中有一个待定常数，那么我们就可以利用正则性 $\int_{-\infty}^{\infty} p(x)dx = 1$ 来确定该常数的值。</p>
<h4 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h4><p>当分布函数(CDF)为：$F\left( x\right) =\begin{cases}0,<del>x &lt;a\ \dfrac{x-a}{b-a},</del>a\leq x\leq b\ 1,~~x &gt;b\end{cases}$， 密度函数(PDF)为$\begin{cases}\dfrac{1}{b-a},a &lt;x &lt;b\ 0, {其他}\end{cases}$时，这个分布就是区间 $(0,a)$上的均匀分布，记为 $U(a,b)$ </p>
<h1 id="随机变量的数学期望"><a href="#随机变量的数学期望" class="headerlink" title="随机变量的数学期望"></a>随机变量的数学期望</h1><p>设<strong>离散随机变量 </strong>X 的分部列为 $p(x_i) = P(X=x_i),i = 1,2,…,n…$</p>
<p>如果 $\sum<em>{i=1}^\infty |x_i|p(x_i)&lt;\infty$ ，则称 $E(X) = \sum</em>{i=1}^\infty x_ip(x_i)$  为随机变量的<strong>期望</strong>或均值。注意，期望一定要收敛，否则期望便不复存在。</p>
<p>同样的，对于<strong>连续随机变量</strong> X 的密度函数为 $p(x)$ ,如果 $\int<em>{-\infty}^{\infty}|x|p(x)dx&lt;\infty$ ,则称 $E(X) = \int</em>{-\infty}^{\infty} xp(x)dx$ 为X的数学期望。</p>
<h3 id="期望的一些性质"><a href="#期望的一些性质" class="headerlink" title="期望的一些性质"></a>期望的一些性质</h3><p><strong>定理</strong>： 若随机变量 X 的分布用分布列 $p(x<em>i)$ 或用密度函数 $p(x)$ 表示，则 X 的某一函数$g(X)$ 的数学期望为 $E[g(X)]=\begin{cases}\sum</em>{i}g(x<em>i)p(x_i) ,在离散场合 \ \int</em>{-\infty}^{\infty}g(x)p(x)dx, {在连续场合}\end{cases} $</p>
<ul>
<li>性质1：设c是常数，则 $E(c) = c$</li>
<li>性质2：对任意常数 a 有 $E(aX)=aE(X)$ </li>
<li>性质3：对任意的两个函数 $g_1(x)$和 $g_2(x)$ 有： $E[g_1(x)\pm g_2(x)] = E[g_1(x)]\pm E[g_2(x)]$ </li>
</ul>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>设连续随机变量 X 的分布函数为 $F(x)$ ，且数学期望存在，证明：</p>
<p>$E(X) = \int<em>0^{+\infty} [1-F(x)]dx-\int</em>{-\infty}^0F(x)dx$ </p>
<p>解：</p>
<script type="math/tex; mode=display">
E(X) = \int_{-\infty}^{\infty} xp(x) dx =\int_{-\infty}^0 xp(x) dx+\int_{0}^\infty xp(x)dx\\~\\</script><p>将第一个积分改写为二次积分，然后改变积分次序，得到：</p>
<script type="math/tex; mode=display">
\int_{-\infty}^0 xp(x) dx =-\int_{-\infty}^0(\int_{x}^0 dy)p(x) dx\\~\\
=-\int_{-\infty}^0\int_{-\infty}^y p(x)dxdy\\~\\
=-\int_{-\infty}^0 F(y)dy</script><p>第二个积分也可以写成二次积分并改变积分次序：</p>
<script type="math/tex; mode=display">
\int_{0}^\infty xp(x)dx=\int_{0}^\infty (\int_{0}^x dy) p(x)dx =\int_{0}^\infty(\int_{y}^\infty p(x)dx)dy</script><p>因此当X 为非负的连续随机变量,且 $E(X^n)$ 存在，则可证明：</p>
<ul>
<li>$E(X) = \int<em>{0}^{+\infty} [1-F(x)]dx =\int</em>{0}^\infty P(X&gt;x)dx$  </li>
<li>$E(X^n) =\int_0^\infty n x^{n-1} P(X&gt;x)dx$  证明： $E(X^n)=\int_0^\infty P(X^n&gt;y)dy$ ， 那么当 $y=x^n$ 的时候，实际上我们可以得到 $E(X^n)=\int_0^\infty P(X^n&gt;x^n)nx^{n-1}dx$  ， 即$E(X^n)=\int_0^\infty P(X&gt;x)nx^{n-1}dx$</li>
</ul>
<h1 id="随机变量的方差与标准差"><a href="#随机变量的方差与标准差" class="headerlink" title="随机变量的方差与标准差"></a>随机变量的方差与标准差</h1><p>若随机变量 $X^2$ 的数学期望 $E(X^2)$ 存在，则称偏差平方 $(X-E(X))^2$ 的数学期望 $E(X-E(X))^2$ 为随机变量$X$ 为随机变量 $X$ 的方差，记为 $Var(X) = E(X-E(X))^2 = \begin{cases}\sum<em>i(x_i-E(X))^2p(x_i),在离散场合\ \int</em>{-\infty}^\infty (x-E(X))^2p(x)dx, {在连续场合}\end{cases}$  </p>
<p>并称方差的正平方根 $\sqrt{Var(X)}$为随机变量(或相应分布) 的标准差，记为 $\sigma(X)$或$\sigma_X$</p>
<p><strong>当随机变量X的数学期望存在时，方差不一定存在；而当X的方差存在时，则E(X)必定存在</strong></p>
<h3 id="方差的性质"><a href="#方差的性质" class="headerlink" title="方差的性质"></a>方差的性质</h3><h4 id="性质1："><a href="#性质1：" class="headerlink" title="性质1："></a>性质1：</h4><p>$Var(X) = E(X^2)-[E(X)]^2$ </p>
<p>在实际计算方差的时候，这个性质往往比定义 $Var(X) = E(X-E(X))^2$ 更加常用</p>
<p><strong>证明</strong>：$Var(X) = E(X^2)-2E(X)*E(X)+(E(X))^2 = E(X^2)-(E(X))^2$</p>
<h4 id="性质2："><a href="#性质2：" class="headerlink" title="性质2："></a>性质2：</h4><p>常数的方差为0，即 $Var(c) = 0$</p>
<p>若c是常数，则 $Var(c) = E(c-E(c))^2 = E(c-c)^2 = 0$ </p>
<h4 id="性质3："><a href="#性质3：" class="headerlink" title="性质3："></a>性质3：</h4><p>若a，b是常数，则 $Var(aX+b) = a^2Var(X)$</p>
<h3 id="切比雪夫不等式"><a href="#切比雪夫不等式" class="headerlink" title="切比雪夫不等式"></a>切比雪夫不等式</h3><p>设随机变量X 的数学<strong>期望和方差都存在</strong>则对任意常数$\epsilon&gt;0$  ,有 $P(|X-E(X)|\geq \epsilon)\leq \frac{Var(X)}{\epsilon^2}$ </p>
<p>通过二次放缩的方法可以证明：记 $E(X)=a$</p>
<p><img src="/2021/03/16/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%EF%BC%882-1-2-3%EF%BC%89/1.png" style="zoom:150%;"></p>
<p>因为  $|x-a|\geq \epsilon$, 所以 $\frac{|x-a|^2}{\epsilon^2}\geq 1$ </p>
<p>然后进行第二次缩放，将原来的积分范围修改成整个实数域</p>
<script type="math/tex; mode=display">
\int_{\{x:|x-a|\geq\epsilon\}}\frac{(x-a)^2}{\epsilon^2} p(x)dx\leq \frac{1}{\epsilon^2}\int_{-\infty}^{\infty}(x-a)^2p(x)dx</script><p>积分部分的值就是方差的定义，因此积分等于$Var(X)$ </p>
<p>在概率论中，时间 $||X-E(X)|\geq \epsilon|$称为大偏差，其概率 $P(|X-E(X)|)\geq \epsilon$称为大偏差发生概率。切比雪夫不等书给出大偏差发生概率的上界，这个上界与方差成正比,方差越大、上界也就越大。</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/03/05/%E5%BE%B7%E5%B7%9E%E6%89%91%E5%85%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/%5Bobject%20Object%5D">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/05/%E5%BE%B7%E5%B7%9E%E6%89%91%E5%85%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/" itemprop="url">德州扑克学习笔记1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-05T19:12:32+08:00">
                2021-03-05
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2021-03-07T12:42:28+08:00">
                2021-03-07
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="德州扑克学习笔记1"><a href="#德州扑克学习笔记1" class="headerlink" title="德州扑克学习笔记1"></a>德州扑克学习笔记1</h1><h2 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h2><h3 id="牌型大小"><a href="#牌型大小" class="headerlink" title="牌型大小"></a>牌型大小</h3><p>每个人手里先发两张牌。公共牌一共五张，先发三张，叫做翻牌(flop)，第四张叫做转牌(turn)，第五张叫做河牌(river)。</p>
<p>下面是牌型大小的梳理：</p>
<p>皇家同花顺，比如说 ♠10 ♠J ♠Q ♠K ♠A</p>
<p>同花顺，比如说 ♠3 ♠4 ♠5 ♠6 ♠7</p>
<p>四条，比如说 四个2，四个3</p>
<p>葫芦(满堂红)： 三带二</p>
<p>同花: 五张牌都是一种花色</p>
<p>顺子: 不一定同花</p>
<p>三条：有三张同一点数的牌</p>
<p>两对：两个对子</p>
<p>一对：两个对子</p>
<p>一共7张牌，选出5张最大的组合。</p>
<h3 id="翻牌前发牌"><a href="#翻牌前发牌" class="headerlink" title="翻牌前发牌"></a>翻牌前发牌</h3><p>在发牌前，小盲位和大盲位分别需要下小盲注和大盲注，大盲是小盲的两倍。</p>
<p>发牌从小盲开始，以六人桌为例，分别是： 小盲、大盲、枪口(UTG)、后置位的两个人、按钮位(庄家，button)</p>
<p>因为小盲和大盲已经下过盲注了，因此从枪口位置开始行动。每个人轮到的时候，都可以有三到四种可以选择的行动：弃牌、跟注、加注、过牌。当前面的选手加注以后，你就不能过牌了，必须选择跟注或弃牌。每一轮加注结束的标志是所有决定参与的玩家最终投入了一样多的筹码，如果不想再投入，就要弃牌。</p>
<h3 id="翻牌后发牌"><a href="#翻牌后发牌" class="headerlink" title="翻牌后发牌"></a>翻牌后发牌</h3><p>发公共的时候，要先切掉一张牌，然后再发三张；再切掉一张牌，发转牌；最后切掉一张牌，发河牌</p>
<p>庄家是每一轮最后发言的人，正常的顺序是从小盲这里开始按顺时针发牌。</p>
<h3 id="筹码选择"><a href="#筹码选择" class="headerlink" title="筹码选择"></a>筹码选择</h3><p>一般情况下，我们只需要筹码之间是五倍的关系：1，5，25，100.  玩家一般会从100个大盲开始买入。比如说我们规定盲注分别是1/2，那么每个人的初始筹码一般是200.也就是 10个1，8个5，6个25</p>
<h3 id="新手建议"><a href="#新手建议" class="headerlink" title="新手建议"></a>新手建议</h3><ol>
<li>加入一张桌子的时候，要收悉其他人的打法。</li>
<li>要分清楚哪些是应该尽量避免交手的高手，哪些是送财童子，那些比较激进，哪些比较保守，哪些喜欢 bluff，哪些人容易上头</li>
<li><strong>不要流露自己的情绪</strong>。</li>
</ol>
<h2 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h2><p>首先要明白一个基本概念： 越靠后的位置越好。因为翻拍后，行动顺序是从小盲开始，之后是大盲、枪口、枪口+1，枪口+2，这几个算是前置位。之后是中间的几个人，比如HIJACK 、CUTOFF，最后的位置是 Button位，也就是庄家。因此Button是最有优势的位置。</p>
<p><img src="/2021/03/05/%E5%BE%B7%E5%B7%9E%E6%89%91%E5%85%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/1.png" style="zoom:120%;"></p>
<p>Button位置的优势：</p>
<ol>
<li>可以看完前面所有人的决定后再做决定</li>
<li>前面牌力不强的时候，后置位更容易诈唬</li>
<li>后位强牌加注，看起来会更像诈唬</li>
<li>前位是强牌，后位是更强牌，能赢更多。</li>
</ol>
<p>由于位置优劣的影响，直接决定了该位置玩家该玩的手牌、范围、策略都是不一样的。</p>
<p>首先我们要科普一个概念： 3-bet。如果翻拍前有一个人起raise入池，后面的人在这个基础上再加注，就叫 3-bet。 我们可以理解成：大盲是第一个bet，起raise的人是第二个bet，那么再加注的人就叫3-bet。很多人不知道该玩什么牌，简单来说就是如果我们的位置好，就可以打地更激进一点，可以多玩一些牌。如果位置差，就保守一点，少玩一些牌 </p>
<p>下面是一个表格，里面讲两张手牌分为了六个等级。</p>
<p><img src="/2021/03/05/%E5%BE%B7%E5%B7%9E%E6%89%91%E5%85%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/2.png" style="zoom:120%;"></p>
<p>两张手牌后面带o的是不同花色，带s的是同一花色。</p>
<h3 id="一等牌力"><a href="#一等牌力" class="headerlink" title="一等牌力"></a>一等牌力</h3><p>左上角的 AA， AKs，AKo, KK, QQ都是最强的牌力。在任何位置上的都建议主动加注，也可以3-bet其他人</p>
<h3 id="二等牌力"><a href="#二等牌力" class="headerlink" title="二等牌力"></a>二等牌力</h3><p>AQs,AJs,KQs,AQo,KQo ，JJ，TT是二等牌力，则也是很好的牌，足以在任何位置起raise。面对3-bet，可以跟注，有时候也可以主动3-bet别人</p>
<h3 id="三等牌力"><a href="#三等牌力" class="headerlink" title="三等牌力"></a>三等牌力</h3><p>淡红色的三等牌力，已经落入了中等牌力的范围。主要是 AT以下的同花色牌以及 AJ，KQ等牌。三等牌力的牌依然可以在所有的位置上起raise，包括在后位偶尔3-bet形象不好的玩家。但是如果自己起raise入池，被后家 3-bet了，那就基本很难再领先对手了。</p>
<p>拿到了这些牌，现金局又不可能直接弃掉。所以还是建议自己起raise，如果被3-bet了，可以根据对手的风格，有时跟注有时弃牌，甚至偶尔可以4-bet回击。</p>
<h4 id="A小"><a href="#A小" class="headerlink" title="A小"></a>A小</h4><p>注意到A小同花是三等牌力，而A小不同花则放到了四五等牌力去了。他们的主要区别：</p>
<p>A小同花和A小不同花的策略是很不一样的。如果 我拿了A小同花，一旦翻牌三张后两张是我想要的花色，那么我们就是在听A同花，大部分情况下我都有30%以上的概率能够赢对方。所以拿两张同花色牌的时候，第一目标就是为了等同花。而听同花破产之后，即使中了对子，A小的价值也小了很多。</p>
<h3 id="四等牌力"><a href="#四等牌力" class="headerlink" title="四等牌力"></a>四等牌力</h3><p>四等牌力覆盖了很大的范围，基本属于在前位，可以玩也可以弃牌，在后位是可以玩的牌。</p>
<h4 id="A小不同花"><a href="#A小不同花" class="headerlink" title="A小不同花"></a>A小不同花</h4><p>注意到 ATs是三等牌力，ATo是四等牌力，因为ATs有听同花的可能，打牌很多时候是要看信心的，如果我们即有对子，又能听同花，表现出来的信心是远远大于只中了对子而不能听同花的牌的。</p>
<p>此外我们看ATo和A5o虽然差了不少，但仍然是属于四等牌力，建议在前位直接弃掉，在中后位看情况入池。这些牌的主要问题是，A5如果我中了A，很可能其他玩家也有A，但是踢脚(Kicker)比我的大，这时候我们已经被压制了但是我们中了AA不可能轻易弃牌。再比如说我是A8,翻牌 J87, 中了一个对子但也不知道自己的牌有多大。</p>
<p>很多新手看到手牌中的A就弃不动牌，中了A就丢不到，最终输了很多。</p>
<h4 id="KTo-到-JTo"><a href="#KTo-到-JTo" class="headerlink" title="KTo 到 JTo"></a>KTo 到 JTo</h4><p>这几副牌如果在前位，你又比较保守，建议直接弃牌。比如说我拿了 KTo,翻牌中了K但踢脚比10大。</p>
<h4 id="小口袋对"><a href="#小口袋对" class="headerlink" title="小口袋对"></a>小口袋对</h4><p>其他一些小的口袋对和同花连张也是四等牌力。比如对4，现金局一般是多人入池，拿了对4、发出5张牌之后，很难还是领先对手的。所以玩小对子目标就是中3条。中了3条基本就是坚果牌(必赢牌)，而且非常隐蔽。可以直接加注，也就可以在别人加注后再加注，或者根据牌面的潮湿度选择快打慢打。</p>
<h4 id="潮湿度"><a href="#潮湿度" class="headerlink" title="潮湿度"></a>潮湿度</h4><p>比如说翻出的3张牌是  ♠7 ♠6 ♠4，有三张黑桃，这个牌面是非常非常湿的。这时候如果我们中了3条，最好加注直接把别人赶走，因为如果再发出一张黑桃牌，或这者3，8，就为别人多了很多中听同花、买顺的组合。所以3张4在这种情况是非常不稳的，因此建议快打。</p>
<p>如果牌面是 ♦4，♥9，♠K，三张不同花，且分割很大，这个牌面就很干。因为不可有人会去听同花。如果要听顺子的人，也只能卡一张牌。比如说有人有 J T，对于公共牌他需要听 Q，只有四张牌的可能性。成功率就会小很多。所以这种时候可以慢打。</p>
<h4 id="同花连张"><a href="#同花连张" class="headerlink" title="同花连张"></a>同花连张</h4><p>同花连张既可以听同花也可以听顺子。当然小的同花连张是更倾向于听顺的。比如说我手牌是 56♣s，翻牌三张为 ♥K，♣4，♣8.这时候我们可以听9张梅花牌还有4张7，减去一张♣7，共有12张牌能让我们成牌。并且后面还需要发两张牌，因此我们有50%的几率获得坚果牌。为什么更倾向于听顺子呢? 因为如果真来了一张梅花，而其他人刚好也在听梅花，有很大概率她的手牌是比♣6更大的，因此我们更加期待来一张不同花色7. 这个顺子就非常隐蔽了。</p>
<p>而如果我手上是 ♣A 和♣2， 我们就不用怕任何听同花。</p>
<h3 id="五等牌力"><a href="#五等牌力" class="headerlink" title="五等牌力"></a>五等牌力</h3><p>五等牌力是黄色的，这边建议不要玩或者尽量少玩。比如说79s这种牌，如果一直玩的话是非常危险的。可以在后位偶尔玩一下，或者只需要很少的筹码就能入池看牌的时候。</p>
<p>这里我们要了解一个术语： Limp(跛入)： 即只跟注大盲而没有加注。比如我在小盲为，我可以只跟到大盲位的数量就可以入池。或者有一个人起raise而很多人跟进，那么我们也可以玩一下，因为这时候赔率很好。但这时候如果我们拿的是一等或者二等的牌力，我是希望用加注来赶人的，因为如果拿了大牌不赶人，很多其他的小牌就会进来，而如果自己拿的大牌中了 A对，而小牌的人中了两对或者顺子的时候，那么这时候自己很难弃牌，</p>
<h3 id="六等牌力"><a href="#六等牌力" class="headerlink" title="六等牌力"></a>六等牌力</h3><p>六等牌力建议再任何情况下都不要玩的牌</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>拿一等二等牌力，要主动出击，拿中等牌力主要看位置，拿低等牌力要看赔率非常好的时候才能入池。</p>
<p>A小同花等同花，同花连张等顺子。不要贪恋As小，牌力容易被压制；小对目标听三条，不中被打则弃牌。</p>
<p>现在我们以8人现金桌为例。翻牌前枪口的人先行动。他拿KT不同花先起raise，后面7个人有非常大的概率拿 AQ,AK以及10以上的口袋对，即使没有拿到很强牌力的牌，也可能选择 3-bet 回去。拿中等牌力的人遇到3-bet常常会遇到一个困境：自己牌力不够，不足4-bet回去，于是跟注了别人的3-bet。发出翻牌之后没有中牌，只能过牌。这时候位置靠后的人因为在翻牌前就显示了自己的牌力，因此翻牌后不管有牌没牌都会3-bet回去。很多时候，位置靠前的人，没有中牌就会弃牌。如果前置位的人经常遇到这种牌，这其实会输掉不少筹码。</p>
<p>在锦标赛中，如果是枪口或枪口+1位置的人起raise，每一个其他人几乎一定会认为这个人手牌很强，但是如果 button起raise，那么他的手牌范围就很广。</p>
<p>一般情况下，新手若在前位，只建议玩中强牌力以上的牌，比如 6以上的对子，AK， AQ这样的大牌。新手常常犯的一个错误就是自己不敢raise，只敢跟别人的raise，导致自己中牌之后，可能会输掉更多。所以新手在位置靠前的时候拿大牌，要入池就一定要加注入池，比如打一个3-4的大盲。</p>
<h4 id="间距理论"><a href="#间距理论" class="headerlink" title="间距理论"></a>间距理论</h4><p>相比于自己加注，你需要更强的牌来跟别人的加注。比如说我拿着 KJ同花，前面的人起raise，那么这时候我可以3-bet回去，这样是没问题的。但是如果前面第一个人起raise，后面的人已经3-bet他了，这时候拿着KJ同花是不该跟注别人的</p>
<h2 id="概率和赔率"><a href="#概率和赔率" class="headerlink" title="概率和赔率"></a>概率和赔率</h2><p>概率和赔率就是帮助我们做正确决定的工具。概率是自己击中公共牌之后能赢的概率。赔率是投入筹码和赢回筹码的比率</p>
<p>比如说： 翻拍后，有33%的概率能赢，67%的概率会输，比例是1：2</p>
<p>如果底池是100，只需要跟注20，赔率是1：5</p>
<p>$1:5&lt;1:2$ ，因此我们该跟注</p>
<h3 id="数outs"><a href="#数outs" class="headerlink" title="数outs"></a>数outs</h3><p>比如说现在是这个情况：</p>
<p><img src="/2021/03/05/%E5%BE%B7%E5%B7%9E%E6%89%91%E5%85%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/3.png" style="zoom:120%;"></p>
<p>首先我们要数能赢的牌：</p>
<p>首先转牌河牌翻出一张黑桃就能赢，因此一共有 13-4 = 9张牌。此外，所有的3都能让我们凑成顺子。不过黑桃3已经算到黑桃中了。因此这时候一共有12张牌能让我赢。</p>
<h3 id="算概率"><a href="#算概率" class="headerlink" title="算概率"></a>算概率</h3><p>我们可以用 <strong>四二定律</strong> 来计算概率</p>
<p>在发出翻牌之后，我们可以通过 能赢的牌(outs)*4 来计算概率。 比如说现在我有12张牌能赢，那么我获胜的概率大概就在48%。 </p>
<p>在转牌发出之后，我们可以通过能赢的牌*2 来简单计算能赢得概率</p>
<p>这个数字是怎么来的呢? 如果在转牌有12张outs，那么一副牌52张，4张公共牌已知，2张手牌已知，那么还有46张牌是未知的。46约等于50，一个数字除以50，换算成百分比，就是乘以2，比如 2/50 = 4%；</p>
<p>同理，翻牌上假设有12张outs，3张公共牌已知，2张手牌已知，3+2 = 5张已知，那么剩下47张牌是未知的。 我们赢得概率是12/47=26%。 那么 转牌上发出12张outs的机会是 26%，河牌发出的机会还是 26%，所以在翻牌上有12张outs能赢的概率是26+26=52%</p>
<p>我们依然按刚才的牌来算，假设我现在认为对手手里是一对10，那么如果转牌河牌发出一张A我也能赢，这时候我们的outs来到了 15张，根据四二定律，我们的胜率是60%</p>
<h3 id="算赔率"><a href="#算赔率" class="headerlink" title="算赔率"></a>算赔率</h3><p>比如说下图这个情况，底池是100，对手打了50，那么我只要跟注50，如果赢了，就能赢回来150，赔率是 25%</p>
<p><img src="/2021/03/05/%E5%BE%B7%E5%B7%9E%E6%89%91%E5%85%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/4.png" style="zoom:120%;"></p>
<h3 id="对比概率和赔率"><a href="#对比概率和赔率" class="headerlink" title="对比概率和赔率"></a>对比概率和赔率</h3><p>如果赢的概率 &gt; 赔率  : 我们应该选择 跟注</p>
<p>如果赢的概率 &lt; 赔率 : 我们应该选择 弃牌</p>
<h3 id="隐含赔率"><a href="#隐含赔率" class="headerlink" title="隐含赔率"></a>隐含赔率</h3><p>但是德州的信息并不是公开透明的，我永远不知道对手拿的是什么牌。所以隐含信息增加了游戏的不确定性。</p>
<p>有的时候，单算赔率其实是不够跟注的，因为赔率是基于在底池中的筹码而跟注的，而隐含赔率则要将对手的后手筹码考虑在内。</p>
<p>举个例子</p>
<p><img src="/2021/03/05/%E5%BE%B7%E5%B7%9E%E6%89%91%E5%85%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/5.png" style="zoom:120%;"></p>
<p>我的手里是88，对手是对A，底池是100，对手下注80，那么这时候总底池就是180。 如果我们跟注80 ，计算得到的赔率是  31%。而如果我们算概率，那么可以听三条和听顺子。一共有两张8和四张7能让我们成牌。这时候概率就是 6*4 = 24% 。 概率小于赔率，按照公式我们是不应该跟注的。</p>
<p>但是这时候大部分人都会跟注。如果选择跟注，总底池就是260，假设对手后手只有100个筹码了，如果我中牌了，那么对手在只有100个筹码的情况下是很难弃牌的 。因此我们可以认为如果中牌了，对手后手的筹码也能加入到底池当中来。那么这时候隐含赔率就是 80/(180+80+100) = 22%。 22%&lt;24%, 于是我们应该跟注。</p>
<p>另外一种情况。如果自己是88而对面是9,10 那么对手中了顶对。这时候就不应该用隐含赔率来计算。因为这时候如果我打All-in ,对手可能认为其手牌不够大，那么就会弃牌了。</p>
<h3 id="弃牌率"><a href="#弃牌率" class="headerlink" title="弃牌率"></a>弃牌率</h3><p>打弃牌率是对玩家读牌能力有一定的要求的。建议新手不要一直打弃牌率，隐含赔率倒是可以算一算</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/15/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/%5Bobject%20Object%5D"
                alt="Jason" />
            
              <p class="site-author-name" itemprop="name">Jason</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20fa%20fa-archive">
              
                  <span class="site-state-item-count">435</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">61</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="true"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
 <!--
  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>







-->
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>




















  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v="></script>

  <script type="text/javascript" src="/js/src/motion.js?v="></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v="></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
