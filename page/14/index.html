<!DOCTYPE html>
<html lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jasonxqh.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jason‘s Blog">
<meta property="og:url" content="https://jasonxqh.github.io/page/14/index.html">
<meta property="og:site_name" content="Jason‘s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jasonxqh.github.io/page/14/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jason‘s Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jason‘s Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8AExp8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8AExp8/" class="post-title-link" itemprop="url">计算机网络实验报告Exp8</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-22 23:32:39" itemprop="dateCreated datePublished" datetime="2021-04-22T23:32:39+08:00">2021-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-25 04:32:24" itemprop="dateModified" datetime="2022-08-25T04:32:24+08:00">2022-08-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Exp8-UDP报⽂分析"><a href="#Exp8-UDP报⽂分析" class="headerlink" title="Exp8: UDP报⽂分析"></a>Exp8: UDP报⽂分析</h1><h2 id="⼀、实验⽬的"><a href="#⼀、实验⽬的" class="headerlink" title="⼀、实验⽬的"></a>⼀、实验⽬的</h2><p>了解 UDP 协议的⼯作原理</p>
<h2 id="⼆、实验任务"><a href="#⼆、实验任务" class="headerlink" title="⼆、实验任务"></a>⼆、实验任务</h2><p>使⽤Wireshark快速了解UDP协议</p>
<h2 id="三、实验过程"><a href="#三、实验过程" class="headerlink" title="三、实验过程"></a>三、实验过程</h2><h3 id="3-1-UDP-协议"><a href="#3-1-UDP-协议" class="headerlink" title="3.1 UDP 协议"></a>3.1 UDP 协议</h3><p>⽤户数据报(UDP)协议是运输层提供的⼀种最低限度的复⽤/分解服务，可以在⽹络层和正确的⽤户即进程间传输数据。UDP 是⼀种不提供不必要服务的轻量级运输协议，除了复⽤/分⽤功能和简单的差错检测之外，⼏乎就是 IP 协议了，也可以说它仅提供最⼩服务。UDP 是⽆连接的，因此在两个进程通信前没有握⼿过程。UDP 协议提供⼀种不可靠数据传输服务，也就是说，当⼀个进程讲⼀个报⽂发送进 UDP套接字时，UDP 协议并不保证该报⽂将到达接收进程。也正是由于 UDP 不修复错误，因此到达接收进程的报⽂也可能是乱序到达的。UDP 是⾯向报⽂的，这是因为 UDP 并不会对应⽤层传递下来的报⽂进⾏任何处理，对于报⽂的边界信息都会保存，向下交付时交付的是完整报⽂。</p>
<p><img src="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8AExp8/0.png" style="zoom:67%;"></p>
<h3 id="3-2-UDP-报⽂结构"><a href="#3-2-UDP-报⽂结构" class="headerlink" title="3.2 UDP 报⽂结构"></a>3.2 UDP 报⽂结构</h3><p>UDP ⾸部只有 4 个字段：源端⼝号、⽬的端⼝号、⻓度、校验和，其中每个字段<strong>由 2 个字节</strong>组成。</p>
<p><img src="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8AExp8/1.png" style="zoom:67%;"></p>
<h3 id="3-3-实验操作"><a href="#3-3-实验操作" class="headerlink" title="3.3 实验操作"></a>3.3 实验操作</h3><ol>
<li><p>在 Wireshark 中捕获数据包，然后执⾏⼀些会导致主机发送和接收多个 UDP 数据包的操作。也可以什么也不做，仅执⾏ wireshark 捕获以便获取其他程序发给您的 UDP 数据包。有⼀种特殊情况：简单⽹络管理协议（SNMP）在 UDP 内部发送 SNMP 消息，因此可能会在跟踪中找到⼀些SNMP 消息（以及 UDP 数据包）。</p>
</li>
<li><p>停⽌数据包捕获后，设置数据包筛选器，以便 Wireshark 仅显示在主机上发送和接收的 UDP 数据包。 选择其中⼀个 UDP 数据包并在详细信息窗⼝中展开 UDP 字段。</p>
</li>
</ol>
<p><img src="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8AExp8/2.jpg" style="zoom:67%;"></p>
<h4 id="task1"><a href="#task1" class="headerlink" title="task1:"></a>task1:</h4><p>从跟踪中选择⼀个 UDP 数据包。从此数据包中，识别并确定 UDP ⾸部字段，请为这些字段命名并将实验结果附在实验报告中。</p>
<p>UDP首部有8个字节，由4个字段构成，每个字段都是两个字节，<br>1.<strong>源端口</strong>： 源端口号，需要对方回信时选用，不需要时全部置0.<br>2.<strong>目的端口</strong>：目的端口号，在终点交付报文的时候需要用到。<br>3.<strong>长度</strong>：UDP的数据报文的长度（包括首部和数据）其最小值为8（只有首部）<br>4.<strong>校验和</strong>：检测UDP数据报在传输中是否有错，有错则丢弃。</p>
<p>下面这段报文节选自Wireshark捕捉到的一个UDP数据包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">User Datagram Protocol, Src Port: 52355, Dst Port: 8000</span><br><span class="line">    Source Port: 52355  		# 源端口</span><br><span class="line">    Destination Port: 8000	# 目标端口</span><br><span class="line">    Length: 76							# 长度为76字节</span><br><span class="line">    Checksum: 0x1545 [unverified] # 检验和</span><br><span class="line">    [Checksum Status: Unverified]	</span><br><span class="line">    [Stream index: 4]</span><br><span class="line">    [Timestamps]</span><br><span class="line">    UDP payload (68 bytes) # 数据部分是总长度减去首部的长度</span><br></pre></td></tr></table></figure>
<h4 id="task2"><a href="#task2" class="headerlink" title="task2:"></a>task2:</h4><p>根据选择的UDP数据包，确定 UDP 报头字段的⻓度，请将实验结果附在实验报告中。</p>
<p><img src="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8AExp8/2.png" style="zoom:67%;"></p>
<p>我们发现这个UDP报头字段的长度是8个字节，因为每个字段长度为两个字节：</p>
<p>Source Port: cc 83 ， 转换成十进制就是52355，即端口号</p>
<p>Destination Port：1f 40,转换成十进制就是8000</p>
<p>Length: 00 4c,转换成十进制就是76 也就是报文长度</p>
<h4 id="task3"><a href="#task3" class="headerlink" title="task3:"></a>task3:</h4><p>UDP⾸部中的⻓度字段的值指的是什么？使⽤捕获的 UDP 数据包进⾏验证，请将实验结果附在实验报告中。</p>
<p>UDP的数据报文的长度（包括首部和数据）其最小值为8（只有首部）。</p>
<p>比如说这个UDP报文，首部的长度是8个字节，data部分如下：</p>
<p><img src="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8AExp8/3.png" style="zoom:67%;">‘</p>
<p>我们发现Data部分的长度是68个bytes，从十六进制数字中也可以看出一共有68个字节。</p>
<h4 id="task4"><a href="#task4" class="headerlink" title="task4:"></a>task4:</h4><p> UDP 有效负载中可包含的最⼤字节数是多少？请将实验结果附在实验报告中。</p>
<p>因为UDP首部中，长度的字段只有2个字节也就是16位。所以能表示的最大数为$2^{16}-1=65535$ 。又UDP首部占据了8字节，所以有效负载中可包含的最⼤字节数是 $65535-8 = 65527$ 字节。</p>
<p><strong>⾸先先认识下有效负载</strong>：</p>
<blockquote>
<p>有效负载是被传输数据中的⼀部分，⽽这部分才是数据传输的最基本的⽬的，和有效负载⼀同被传送的数据还有：数据头或称作元数据，有时候也被称为开销数据，这些数据⽤来辅助数据传输。</p>
</blockquote>
<h4 id="task5"><a href="#task5" class="headerlink" title="task5:"></a>task5:</h4><p>最⼤可能的源端⼝号是多少？请将实验结果附在实验报告中。</p>
<p>因为端口号也只有2个字节，因此最大能表达的数为65535，因此最大可能的源端口号是 65535</p>
<p>在之前我们编写的UDP Provider和UDP searcher文件当中，我们可以来验证这个结论：</p>
<p>当我们申请65535端口的时候，是可以正常利用UDP来发送数据处理数据的</p>
<p><img src="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8AExp8/4.png" style="zoom:67%;"></p>
<p>但是当我们申请65536端口的时候，Java会给我们一个报错，说 Port out of range,说明 65536接口是非法的。</p>
<p><img src="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8AExp8/5.png" style="zoom:67%;"></p>
<h4 id="task6"><a href="#task6" class="headerlink" title="task6:"></a>task6:</h4><p>根据选择的UDP数据包指出UDP的协议号是多少？请以⼗六进制和⼗进制表示法给出答案，并将实验结果附在实验报告中。</p>
<p>协议号指的是一个协议在IP包头中的一个字段,IP头中的协议号用来说明IP报文中承载的是哪种协议.目的主机收到IP包后，根据IP协议号确定送给哪个模块（TCP/UDP/ICMP…）处理，送给TCP/UDP模块的报文根据端口号确定送给哪个应用程序处理。</p>
<p><img src="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8AExp8/6.png" style="zoom:67%;"></p>
<p>我们在IPV4报文中找到了UDP的协议号，是17</p>
<p>用同样的方法可以找到</p>
<p>TCP的协议号是6</p>
<p>HTTP的协议号是80</p>
<p>DNS的协议号是53</p>
<h4 id="task7"><a href="#task7" class="headerlink" title="task7:"></a>task7:</h4><p>观察发送 UDP 数据包后接收响应的 UDP 数据包，这是对发送的 UDP 数据包的回复，请描述两个数据包中<strong>端⼝号</strong>之间的关系。(提示：对于响应 UDP ⽬的地应该为发送 UDP 包的地址。）请将实验结果附在实验报告中。</p>
<p>我们找到了这样一组发送UDP数据包和响应的UDP数据包。</p>
<p><img src="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8AExp8/7.png" style="zoom:67%;"></p>
<p>他们的编号是532493和532494。</p>
<p>532493 这个包的源地址是：192.168.31.15也就是我本地的电脑地址，目的地址是180.153.91.44 ，源端口是52355，目的端口是8000</p>
<p>532494 这个包的原地址是：180.153.91.44，而目的地之是192.168.31.15, 源端口是8000，目的端口是52355</p>
<p><img src="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8AExp8/8.png" style="zoom:67%;"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A7/" class="post-title-link" itemprop="url">计算机网络报告7</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-15 23:51:34" itemprop="dateCreated datePublished" datetime="2021-04-15T23:51:34+08:00">2021-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-25 04:32:12" itemprop="dateModified" datetime="2022-08-25T04:32:12+08:00">2022-08-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Exp7：基于TCP的Socket编程"><a href="#Exp7：基于TCP的Socket编程" class="headerlink" title="Exp7：基于TCP的Socket编程"></a>Exp7：基于TCP的Socket编程</h1><h2 id="⼀、实验⽬的"><a href="#⼀、实验⽬的" class="headerlink" title="⼀、实验⽬的"></a>⼀、实验⽬的</h2><p>学习使⽤Stream Socket（包括ServerSocket和Socket）</p>
<p>了解粘包概念</p>
<h2 id="⼆、实验任务"><a href="#⼆、实验任务" class="headerlink" title="⼆、实验任务"></a>⼆、实验任务</h2><p>使⽤Socket和ServerSocket编写代码</p>
<p>解决粘包问题</p>
<h2 id="三、实验过程"><a href="#三、实验过程" class="headerlink" title="三、实验过程"></a>三、实验过程</h2><h3 id="3-1-基础知识"><a href="#3-1-基础知识" class="headerlink" title="3.1 基础知识"></a>3.1 基础知识</h3><h4 id="3-1-1-Socket和ServerSocket交互过程"><a href="#3-1-1-Socket和ServerSocket交互过程" class="headerlink" title="3.1.1 Socket和ServerSocket交互过程"></a>3.1.1 Socket和ServerSocket交互过程</h4><p><img src="/2021/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A7/1.png" style="zoom:67%;"> </p>
<h4 id="3-1-2-建⽴服务器端"><a href="#3-1-2-建⽴服务器端" class="headerlink" title="3.1.2 建⽴服务器端"></a>3.1.2 建⽴服务器端</h4><ul>
<li>服务器建⽴通信ServerSocket</li>
<li>服务器建⽴Socket接收客户端连接</li>
<li>建⽴IO输⼊流读取客户端发送的数据</li>
<li>建⽴IO输出流向客户端发送数据消息</li>
</ul>
<h4 id="3-1-3-建⽴客户端"><a href="#3-1-3-建⽴客户端" class="headerlink" title="3.1.3 建⽴客户端"></a>3.1.3 建⽴客户端</h4><p>创建Socket通信，设置通信服务器的IP和Port</p>
<p>建⽴IO输出流向服务器发送数据消息</p>
<p>建⽴IO输⼊流读取服务器发送来的数据消息</p>
<h3 id="3-2-⼩试⽜⼑-TCP传输案例"><a href="#3-2-⼩试⽜⼑-TCP传输案例" class="headerlink" title="3.2 ⼩试⽜⼑: TCP传输案例"></a>3.2 ⼩试⽜⼑: TCP传输案例</h3><p>在src⽂件夹下新建⼀个Package，名为exp7</p>
<ul>
<li>编写TCPServer类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">9090</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServerSocket server = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 配置⼀些参数</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server.setReuseAddress(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server.setReceiveBufferSize(<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 绑定到本地端⼝上，backlog为50（请求在socket上的最⼤待处理连接数）</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            server.bind(<span class="keyword">new</span> InetSocketAddress(Inet4Address.getLocalHost(),</span><br><span class="line">                    PORT), <span class="number">50</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Server: 服务器已监听端⼝："</span>);</span><br><span class="line">        System.out.println(server.getInetAddress() + <span class="string">": "</span> +</span><br><span class="line">                server.getLocalPort());</span><br><span class="line"><span class="comment">// 等待客户端连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Server: 阻塞等待客户端连接中..."</span>);</span><br><span class="line">            Socket client = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                client = server.accept();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Server: 捕获成功"</span>);</span><br><span class="line"><span class="comment">// 在连接后，启动⼀个线程接管与客户端的交互操作</span></span><br><span class="line">            ClientHandler clientHandler = <span class="keyword">new</span> ClientHandler(client);</span><br><span class="line">            clientHandler.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理与客户端交互</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Socket socket;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ClientHandler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">            System.out.println(<span class="string">"Server: 新客户端连接："</span> + socket.getInetAddress() +</span><br><span class="line">                    <span class="string">": "</span> + socket.getPort());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 得到socket的输⼊输出流</span></span><br><span class="line">                InputStream inputStream = socket.getInputStream();</span><br><span class="line">                OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">// todo: task2 replace</span></span><br><span class="line">                <span class="keyword">int</span> len = inputStream.read(bytes);</span><br><span class="line">                StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                stringBuilder.append(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line">                <span class="comment">// todo: added for task1 to test multiple clients</span></span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                 Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                 &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">                 &#125;</span><br><span class="line">                System.out.println(<span class="string">"Server: 收到客户端消息："</span> + stringBuilder);</span><br><span class="line"><span class="comment">// 消息回写</span></span><br><span class="line">                outputStream.write(stringBuilder.toString().getBytes());</span><br><span class="line">                outputStream.close();</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Server: 连接异常断开"</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Server: 客户端已退出："</span> + socket.getInetAddress() +</span><br><span class="line">                    <span class="string">": "</span> + socket.getPort());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编写TCPClient类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Inet4Address;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">9090</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket();</span><br><span class="line"><span class="comment">// 连接本地9090端⼝，timeout为3000ms</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket.connect(<span class="keyword">new</span> InetSocketAddress(Inet4Address.getLocalHost(),</span><br><span class="line">                    PORT), <span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Client: 客户端为："</span> + socket.getLocalAddress() + <span class="string">": "</span> +</span><br><span class="line">                socket.getLocalPort());</span><br><span class="line">        System.out.println(<span class="string">"Client: 服务器为："</span> + socket.getInetAddress() + <span class="string">": "</span> +</span><br><span class="line">                socket.getPort());</span><br><span class="line">        InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream = socket.getInputStream();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        OutputStream outputStream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            outputStream = socket.getOutputStream();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        String s = <span class="string">"test client send"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            outputStream.write(s.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">// 接收服务器返回的消息</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            len = (inputStream.read(bytes));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        stringBuilder.append(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line">        System.out.println(<span class="string">"Client: 收到服务器端消息："</span> + stringBuilder);</span><br><span class="line"><span class="comment">// 资源释放</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            outputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Client: 客户端已退出～"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="task1"><a href="#task1" class="headerlink" title="task1:"></a>task1:</h4><p>分别运⾏Server端和2个Client端，请将运⾏结果附在实验报告中。 </p>
<p>当我们不使用while(true)时，tcpserver只接受一个客户端传来的信息，如下图所示：</p>
<p><img src="/2021/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A7/3.png" style="zoom:67%;"></p>
<p>那么，当sever一直开启时：我们在main函数中创建多个client线程，向服务器发送连接请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// write your code here</span></span><br><span class="line">        Thread server = <span class="keyword">new</span> Thread(<span class="keyword">new</span> TCPServer());</span><br><span class="line">        ArrayList&lt;Thread&gt; clients = <span class="keyword">new</span> ArrayList&lt;Thread&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">            Thread client = <span class="keyword">new</span> Thread(<span class="keyword">new</span> TCPClient());</span><br><span class="line">            clients.add(client);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        server.start();</span><br><span class="line">        <span class="keyword">for</span> (Thread client:clients)</span><br><span class="line">            client.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A7/4.png" style="zoom:67%;"></p>
<h4 id="task2"><a href="#task2" class="headerlink" title="task2:"></a>task2:</h4><p>⽤下段代码修改TCPServer中// todo task2：replace 后的三⾏，试运⾏Server端和Client端，观察运⾏结果，并将实验结果及产⽣的原因附在实验报告中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> len;</span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">while</span> ((len = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    stringBuilder.append(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A7/5.png" style="zoom:67%;"></p>
<p>我们发现TCPServer和TCPClient已经建立了连接，但是在处理客户端信息时出现了错误，导致一直卡在哪儿不能继续运行下去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> len = inputStream.read(bytes);</span><br><span class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    stringBuilder.append(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line">System.out.println(<span class="string">"Server: 收到客户端消息："</span> + stringBuilder);</span><br></pre></td></tr></table></figure>
<p>经过 测试，发现当 去掉While循环，便可以正常执行。</p>
<p>但这并不是一种好方法，因为当输入的 inputStream 信息很庞大，但是我只能读取前1024个字节。</p>
<p>其实，这里while循环不结束的原因是在client里面，当送出 outputStream之后，并没有关闭socket。因此server就会误以为后面还会有信息进来，因此一直在等待。虽然在client最后关闭了outputStream，但是那是在收到了server回传的信息之后了，这就形成了一个死锁。要解决这个问题，就要将这个socket关闭。 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">      outputStream.write(s.getBytes());</span><br><span class="line">      outputStream.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关闭后，恢复正常：</p>
<p><img src="/2021/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A7/6.png" style="zoom:67%;"></p>
<h4 id="task3"><a href="#task3" class="headerlink" title="task3:"></a>task3:</h4><p>使⽤Scanner修改TCPClient类，达成如下效果，请将实验结果附在实验报告中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client reads a line of characters from its keyboard and sends data to server</span><br><span class="line">server receives the data and converts characters to uppercase</span><br><span class="line">server sends modified data to client</span><br><span class="line">client receives modified data and displays line on its screen</span><br></pre></td></tr></table></figure>
<p>只需要修改client即可；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s = scanner.nextLine();</span><br><span class="line">outputStream.write(s.getBytes());</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A7/7.png" style="zoom:67%;"></p>
<h4 id="task4"><a href="#task4" class="headerlink" title="task4:"></a>task4:</h4><p>在task3的基础上继续TCPServer类和TCPClient类，Client端能够读取多⾏从控制台输⼊的数据分别发送，Server端收到后分别回写（请测试数据为中⽂时的情况），请将实验结果附在实验报告中。</p>
<ul>
<li>Server</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">9090</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      .</span><br><span class="line">        System.out.println(<span class="string">"服务器已监听端口："</span>);</span><br><span class="line">        System.out.println(server.getInetAddress() + <span class="string">": "</span> +</span><br><span class="line">                server.getLocalPort());</span><br><span class="line"><span class="comment">// 等待客户端连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"阻塞等待客户端连接中..."</span>);</span><br><span class="line">            Socket client = server.accept();</span><br><span class="line">            System.out.println(<span class="string">"连接成功"</span>);</span><br><span class="line"><span class="comment">// 在连接后，启动⼀个线程接管与客户端的交互操作</span></span><br><span class="line">            ClientHandler clientHandler = <span class="keyword">new</span> ClientHandler(client);</span><br><span class="line">            clientHandler.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理与客户端交互</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Socket socket;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ClientHandler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">            System.out.println(<span class="string">"新客户端连接："</span> + socket.getInetAddress() +</span><br><span class="line">                    <span class="string">": "</span> + socket.getPort());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                InputStream inputStream = socket.getInputStream();</span><br><span class="line">                OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> len = inputStream.read(bytes);</span><br><span class="line">                    StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                    stringBuilder.append(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line">                    System.out.println(<span class="string">"收到客户端消息："</span> + stringBuilder);</span><br><span class="line">                    outputStream.write(stringBuilder.toString().getBytes());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"连接异常断开"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Client</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Inet4Address;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">9090</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket();</span><br><span class="line"><span class="comment">// 连接本地9090端⼝，timeout为3000ms</span></span><br><span class="line">        socket.connect(<span class="keyword">new</span> InetSocketAddress(Inet4Address.getLocalHost(),</span><br><span class="line">                PORT), <span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">"客户端为："</span> + socket.getLocalAddress() + <span class="string">": "</span> +</span><br><span class="line">                socket.getLocalPort());</span><br><span class="line">        System.out.println(<span class="string">"服务器为："</span> + socket.getInetAddress() + <span class="string">": "</span> +</span><br><span class="line">                socket.getPort());</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            String s = scanner.nextLine();</span><br><span class="line">            outputStream.write(s.getBytes());</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">// 接收服务器返回的消息</span></span><br><span class="line">            <span class="keyword">int</span> len = (inputStream.read(bytes));</span><br><span class="line">            System.out.println(<span class="string">"收到服务器端消息："</span> + <span class="keyword">new</span> String(bytes, <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A7/8.png" style="zoom:67%;"></p>
<h3 id="3-3-什么是粘包"><a href="#3-3-什么是粘包" class="headerlink" title="3.3 什么是粘包"></a>3.3 什么是粘包</h3><ul>
<li>TCP本质上并不会发⽣数据层⾯的粘包</li>
<li>TCP的发送⽅和接收⽅⼀定会确保数据是以⼀种有序的⽅式到达的</li>
<li>所谓的粘包是数据处理逻辑层⾯上的粘包，即应⽤层上的</li>
</ul>
<p><img src="/2021/04/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A7/2.png" style="zoom:67%;"></p>
<h4 id="task5"><a href="#task5" class="headerlink" title="task5:"></a>task5:</h4><p>查阅资料，分析粘包可能产⽣的原因并搜索若⼲种解决⽅法（&gt;=3），并附在实验报告中。</p>
<p>在socket网络程序中，TCP和UDP分别是面向连接和非面向连接的。因此TCP的socket编程，收发两端（客户端和服务器端）都要有成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小、数据量小的数据，合并成一个大的数据块，然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。</p>
<p><strong>粘包出现原因</strong></p>
<ol>
<li>发送端需要等缓冲区满才发送出去，造成粘包</li>
</ol>
<p>发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一包数据。若连续几次发送的数据都很少，通常TCP会根据优化算法把这些数据合成一包后一次发送出去，这样接收方就收到了粘包数据。</p>
<ol>
<li>接收方不及时接收缓冲区的包，造成多个包接收</li>
</ol>
<p>接收方引起的粘包是由于接收方用户进程不及时接收数据，从而导致粘包现象。这是因为接收方先把收到的数据放在系统接收缓冲区，用户进程从该缓冲区取数据，若下一包数据到达时前一包数据尚未被用户进程取走，则下一包数据放到系统接收缓冲区时就接到前一包数据之后，而用户进程根据预先设定的缓冲区大小从系统接收缓冲区取数据，这样就一次取到了多包数据。 </p>
<p>为了避免粘包现象，可采取以下几种措施：</p>
<p>（1）对于发送方引起的粘包现象，用户可通过<strong>编程设置</strong>来避免，TCP提供了强制数据立即传送的操作指令push，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；<strong>但是</strong>但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。</p>
<p>（2）对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象；<strong>但是</strong>第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包</p>
<p>（3）由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。<strong>但是</strong>第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。比如说认为确定一个消息边界。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/04/12/os-Project2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/12/os-Project2/" class="post-title-link" itemprop="url">os-Project2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-12 12:40:22" itemprop="dateCreated datePublished" datetime="2021-04-12T12:40:22+08:00">2021-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-04-09 23:23:53" itemprop="dateModified" datetime="2025-04-09T23:23:53+08:00">2025-04-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Project2-进程调度"><a href="#Project2-进程调度" class="headerlink" title="Project2 进程调度"></a>Project2 进程调度</h1><h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p>在MINIX3中实现 Earlist-Deadline-First 近似实时调度功能：</p>
<ol>
<li>提供设置进程执行期限的系统调度 <code>chrt(long deadline)</code> ,用于将调用该系统调用的进程设为实时进程，其执行的期限为：从调用处开始deadline秒。例如：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//……</span></span><br><span class="line">chrt(<span class="number">10</span>);<span class="comment">/* 该程序将可以运行的最长时间为10秒，若没有运行结束，则强制结束*/</span></span><br><span class="line"><span class="comment">//……</span></span><br></pre></td></tr></table></figure>
<p><code>chrt</code>的定义：</p>
<p><code>int chrt(long deadline);</code>  deadline 是最后期限值(秒)，返回值1表示成功，返回值0表示该调用出错</p>
<ol>
<li>在内核进程表中需要增加一个条目，用于表示进程的实时属性；修改相关代码，新增一个系统调用chrt，用于设置其进程表中的实时属性。</li>
<li>修改proc.c和proc.h中相关的调度代码，实现最早deadline的用户进程相对于其它用户进程具有更高的优先级，从而被优先调度运行。</li>
<li>在用户程序中，可以在不同位置调用多次chrt系统调用，在未到deadline之前，调用chrt将会改变该程序的deadline。</li>
<li>未调用chrt的程序将以普通的用户进程(非实时进程)在系统中运行</li>
</ol>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="增加系统调用chrt"><a href="#增加系统调用chrt" class="headerlink" title="增加系统调用chrt"></a>增加系统调用<code>chrt</code></h3><p>MINIX3中的系统调用结构分成三个层次：应用层，服务层，内核层。在这三层中分别进行代码修改，实现系统调用chrt的信息传递。从应用层用<code>_syscall</code>将信息传递到服务层，在服务层用<code>_kernel_call</code>将信息传递到内核层，在内核层对进程结构体增加deadline成员。</p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>需要添加的系统调用chrt可以定义在unistd头文件中，并在libc中添加chrt函数体实现。</p>
<ul>
<li>在<code>/usr/src/include/unistd.h</code>中添加chrt函数定义</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chrt</span><span class="params">(<span class="keyword">long</span>)</span></span>;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>这里我犯了一个很愚蠢的错误，一开始我写的是 <code>int char(long deadline)</code>，虽然kernel编译成功但是在编译test.c 的时候却始终找不到chrt 函数，经过修改后排除错误</p>
<ul>
<li>在<code>/usr/src/minix/lib/libc/sys/chrt.c</code>中添加chrt函数实现。可用alarm函数实现超时强制终止。参照该文件夹下fork.c文件，在实现中通过<code>_syscall</code>(调用号)向系统服务传递。例如：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span>(_syscall(PM_PROC_NR, PM_FORK, &amp;m));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>chrt.c</code>如下图所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/cdefs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"namespace.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;lib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chrt</span><span class="params">(<span class="keyword">long</span> deadline)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timezone</span> <span class="title">tz</span>;</span></span><br><span class="line">    message m;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;m,<span class="number">0</span>,<span class="keyword">sizeof</span>(m));</span><br><span class="line">    <span class="comment">//设置alarm</span></span><br><span class="line">    alarm((<span class="keyword">unsigned</span> <span class="keyword">int</span>)deadline);</span><br><span class="line">    <span class="comment">//将当前时间记录下来 算deadline</span></span><br><span class="line">    <span class="keyword">if</span>(deadline&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    gettimeofday(&amp;tv,&amp;tz);</span><br><span class="line">    deadline = tv.tv_sec + deadline; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存deadline</span></span><br><span class="line">    m.m2_l1=deadline;</span><br><span class="line">  	<span class="comment">//把m传到服务层当中去</span></span><br><span class="line">    <span class="keyword">return</span>(_syscall(PM_PROC_NR,PM_CHRT,&amp;m));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>timeval</code> 使用来获得时间的</p>
<p><code>timezone</code> 是用来获得时区的</p>
<p> <code>gettimeofday</code> 用来获取当前的时间的函数，包含在头文件 <code>#include &lt;sys/time.h&gt;</code> 中</p>
<p><code>_syscall</code>函数可以用来查找系统调用。PM_PROC_NR 将会用来存放PM_CHRT的系统调用号，</p>
<ul>
<li>在<code>/usr/src/minix/lib/libc/sys</code>中 <code>Makefile.inc</code>文件添加chrt.c条目（添加C文件后，需在同目录下的Makefile/Makefile.inc中添加条目）</li>
</ul>
<p><img src="/2021/04/12/os-Project2/1.png" style="zoom:67%;"> </p>
<h4 id="服务层："><a href="#服务层：" class="headerlink" title="服务层："></a>服务层：</h4><p>需要向MINIX系统的进程管理服务中注册chrt，使得chrt服务可以向应用层提供。</p>
<ul>
<li>在<code>/usr/src/minix/servers/pm/proto.h</code>中添加<code>do_chrt</code>函数定义。</li>
</ul>
<p><img src="/2021/04/12/os-Project2/12.png"></p>
<p>因为 <code>do_chrt</code> 的功能是调用 <code>sys_chrt()</code>函数，并不需要传入参数，所以这里写<code>void</code></p>
<ul>
<li>在<code>/usr/src/minix/servers/pm/chrt.c</code>中添加<code>chrt</code>函数实现，调用<code>sys_chrt()</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"pm.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;minix/syslib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;minix/callnr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;minix/com.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;minix/vm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mproc.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;minix/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_chrt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// who_p 是用来获取进程信息的，类型是endpoint_t;m_in.m2_l1就是deadline</span></span><br><span class="line">    sys_chrt(who_p, m_in.m2_l1); </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在<code>/usr/src/minix/include/minix/callnr.h</code>中定义<code>PM_CHRT</code>编号。用来帮助应用层的系统调用能找到</li>
</ul>
<p><img src="/2021/04/12/os-Project2/2.png" style="zoom:67%;"></p>
<p>我一开始没有定义 PM_CHRT 的编号，导致 make build 的时候总是报告称<code>error: use of undeclared identifier &#39;PM_CHRT&#39;</code></p>
<ul>
<li>在<code>/usr/src/minix/servers/pm/Makefile</code>中添加<code>chrt.c</code>条目。</li>
</ul>
<p><img src="/2021/04/12/os-Project2/3.png" style="zoom:67%;"></p>
<ul>
<li>在<code>/usr/src/minix/servers/pm/table.c</code>中调用映射表。</li>
</ul>
<p><img src="/2021/04/12/os-Project2/4.png" style="zoom:67%;"></p>
<ul>
<li>在<code>/usr/src/minix/include/minix/syslib.h</code>中添加<code>sys_chrt()</code>定义。</li>
</ul>
<p><img src="/2021/04/12/os-Project2/5.png" style="zoom:67%;"></p>
<ul>
<li>在<code>/usr/src/minix/lib/libsys/sys_chrt.c</code>中添加<code>sys_chrt ()</code>实现。可参照该文件夹下的<code>sys_fork</code>文件，在实现中通过<code>_kernel_call</code> (调用号)向内核传递。例如：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_fork</span><span class="params">(parent, child, child_endpoint, flags, msgaddr)</span></span>&#123;</span><br><span class="line">	_kernel_call(SYS_FORK, &amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"syslib.h"</span></span></span><br><span class="line"><span class="comment">// 目的就是把进程和deadline提取出来，然后调用 kernel_call() 传入内核</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_chrt</span><span class="params">(proc_ep, deadline)</span></span></span><br><span class="line"><span class="function"><span class="keyword">endpoint_t</span> proc_ep</span>;</span><br><span class="line"><span class="keyword">long</span> deadline;</span><br><span class="line">&#123;</span><br><span class="line">    message m;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    m.m2_i1 = proc_ep; <span class="comment">//m2_i1 支持传送一个 int 类型的数据</span></span><br><span class="line">    m.m2_l1 = deadline; <span class="comment">// m2_l1 支持传送一个long 类型的数据</span></span><br><span class="line">  <span class="comment">//和syscall一样，这里通过SYS_CHRT和do_chrt的映射，把message传入内核层并调用do_chrt修改进程信息</span></span><br><span class="line">    r=_kernel_call(SYS_CHRT, &amp;m);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;、</span><br></pre></td></tr></table></figure>
<ul>
<li>在<code>/usr/src/minix/lib/libsys</code>中的<code>Makefile</code>中添加<code>sys_chrt.c</code>条目。</li>
</ul>
<p><img src="/2021/04/12/os-Project2/6.png"></p>
<h4 id="内核层"><a href="#内核层" class="headerlink" title="内核层"></a>内核层</h4><p>在MINIX内核中实现进程调度功能，此处可以直接修改内核信息，例如<strong>进程的截至时间</strong>。</p>
<ul>
<li>在<code>/usr/src/minix/kernel/system.h</code>中添加<code>do_chrt</code>函数定义。</li>
</ul>
<p><img src="/2021/04/12/os-Project2/8.png"></p>
<ul>
<li>在 <code>/usr/src/minix/kernel/config.h</code>中添加 <code>USE_CHRT</code></li>
</ul>
<p>踩坑：这一步虽然在实验说明中没有写，但是我们要加上去。否则在编译 测试文件的时候会报错</p>
<p><img src="/2021/04/12/os-Project2/14.png"></p>
<ul>
<li>在<code>/usr/src/minix/kernel/system/do_chrt.c</code>中添加<code>do_chrt</code>函数实现。参考该文件下的<code>do_fork</code>文件，修改调用者进程信息。例如：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span>(_syscall(PM_PROC_NR, PM_FORK, &amp;m));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="do-chrt-c"><a href="#do-chrt-c" class="headerlink" title="do_chrt.c"></a>do_chrt.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/system.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/vm.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;minix/endpoint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;minix/u64.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_CHRT</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_chrt</span><span class="params">(struct proc *caller, message *m_ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">rp</span>;</span></span><br><span class="line">    <span class="keyword">long</span> exp_time;</span><br><span class="line">    exp_time = m_ptr-&gt;m2_l1;</span><br><span class="line">    <span class="comment">//通过 proc_addr 定位内核中进程地址</span></span><br><span class="line">    rp = proc_addr(m_ptr-&gt;m2_i1);</span><br><span class="line">    <span class="comment">//将消息结构体中的deadline 赋值给该进程的 p_deadline</span></span><br><span class="line">    rp-&gt;deadline = exp_time;</span><br><span class="line">    <span class="keyword">return</span> (OK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* USE_CHRT */</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>在<code>/usr/src/minix/kernel/system/</code>中<code>Makefile.inc</code>文件添加<code>do_chrt.c</code>条目。</li>
</ul>
<p><img src="/2021/04/12/os-Project2/7.png"></p>
<ul>
<li>在<code>/usr/src/minix/include/minix/com.h</code>中定义<code>SYS_CHRT</code>编号。方便Kernel_Call找到SYS_CHRT函数。</li>
</ul>
<p><img src="/2021/04/12/os-Project2/9.png"></p>
<ul>
<li>在<code>/usr/src/minix/kernel/system.c</code>中添加<code>SYS_CHRT</code>编号到<code>do_chrt</code>的映射。</li>
</ul>
<p><img src="/2021/04/12/os-Project2/10.png"></p>
<ul>
<li>在<code>/usr/src/minix/commands/service/parse.c</code>的<code>system_tab</code>中添加名称编号对。</li>
</ul>
<p><img src="/2021/04/12/os-Project2/11.png"></p>
<p>踩坑：这个文件中有两个struct，一个都是 <code>VM_****</code>,一个都是 <code>SYS_****</code> ,不要放错，我因为这个调试了很久</p>
<h3 id="Minix3中的进程调度"><a href="#Minix3中的进程调度" class="headerlink" title="Minix3中的进程调度"></a>Minix3中的进程调度</h3><ul>
<li><p>MINIX3使用一种多级调度算法。进程优先级数字越小，优先级越高，根据优先级不同分成了16个可运行进程队列。每个队列内部采用时间片轮转调度，找到最高非空优先级队列，选取队列首部可运行的进程，当用完了时间片，则移到当前队列的队尾（详见教材P124）。</p>
</li>
<li><p><strong>将EDF添加到多级调度算法</strong>中，可控制入队实现<strong>实时调度</strong>（也可有其他新颖方式，得分更高）。入队是将当前剩余时间（终止时间-运行时间）大于0的进程添加到某个优先级队列，即设置进程优先级（需要选择合适的优先级否则执行效果不理想）。</p>
</li>
<li><p>在该队列内部将时间片轮转调度改成剩余时间最少优先调度，即将剩余时间最小的进程移到队列首部。</p>
</li>
<li><p>进程调度模块位于<code>/usr/src/minix/kernel/</code>下的<code>proc.h</code>和<code>proc.c</code>，修改影响进程调度顺序的部分。</p>
<h4 id="proc-h"><a href="#proc-h" class="headerlink" title="proc.h"></a>proc.h</h4></li>
<li><p>struct proc 维护每个进程的信息，用于调度决策。添加deadline成员。</p>
<p>利用xcode 可以很清楚得看见 proc 这个结构的内部成员：</p>
<p><img src="/2021/04/12/os-Project2/13.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc * <span class="title">pick_proc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="comment">//...	</span></span><br><span class="line">	<span class="keyword">long</span> deadline;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="proc-c"><a href="#proc-c" class="headerlink" title="proc.c"></a>proc.c</h4></li>
<li><p>switch_to_user() 选择进程进行切换。</p>
</li>
<li><p>enqueue_head() 按优先级将进程加入列队首。实验中需要将实时进程的优先级设<strong>置成合适的</strong>优先级。这里我设置成了5。也就是说，当我给进程设置了 deadline 之后，这个实时进程的优先级就会变成5。然后多级调度算法就会发现这个较高的优先级并执行入队操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(rp-&gt;deadline &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      rp-&gt;p_priority = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>enqueue() 按优先级将进程加入列队尾。同上。</p>
</li>
<li><p>pick_proc() 从队列中返回一个可调度的进程。遍历<strong>设置的</strong>优先级队列，<strong>返回剩余时间最小并可运行的进程</strong>。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc * <span class="title">pick_proc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* Decide who to run now.  A new process is selected an returned.</span></span><br><span class="line"><span class="comment"> * When a billable process is selected, record it in 'bill_ptr', so that the </span></span><br><span class="line"><span class="comment"> * clock task can tell who to bill for system time.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function always uses the run queues of the local cpu!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">rp</span>;</span>			<span class="comment">/* process to run */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> **<span class="title">rdy_head</span>;</span></span><br><span class="line">  <span class="keyword">int</span> q;				<span class="comment">/* iterate over queues */</span></span><br><span class="line">	<span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">next</span>;</span> <span class="comment">// 中间变量,用来指代下一个进程</span></span><br><span class="line">  <span class="comment">/* Check each of the scheduling queues for ready processes. The number of</span></span><br><span class="line"><span class="comment">   * queues is defined in proc.h, and priorities are set in the task table.</span></span><br><span class="line"><span class="comment">   * If there are no processes ready to run, return NULL.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  rdy_head = get_cpulocal_var(run_q_head);</span><br><span class="line">  <span class="keyword">for</span> (q=<span class="number">0</span>; q &lt; NR_SCHED_QUEUES; q++) &#123;	</span><br><span class="line">      <span class="keyword">if</span>(!(rp = rdy_head[q])) &#123;</span><br><span class="line">        TRACE(VF_PICKPROC, <span class="built_in">printf</span>(<span class="string">"cpu %d queue %d empty\n"</span>, cpuid, q););</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    	<span class="comment">//这里是新加入的部分</span></span><br><span class="line">    </span><br><span class="line"> 	<span class="keyword">if</span> (q == <span class="number">5</span>) &#123; <span class="comment">/* 如果优先级等于5，说明可能是设置deadline的进程，下面要找剩余时间最小的进程*/</span></span><br><span class="line">        rp = rdy_head[q];</span><br><span class="line">        next = rp-&gt;p_nextready;</span><br><span class="line">        <span class="comment">/* 拿到当前和下一个进程 */</span></span><br><span class="line">        <span class="keyword">while</span> (next != <span class="literal">NULL</span>) &#123;<span class="comment">//遍历进程</span></span><br><span class="line">            <span class="keyword">if</span> (next-&gt;deadline &gt; <span class="number">0</span>) &#123; <span class="comment">/* 再次判断，防止原本优先级就是7的进程，留下用了chrt的 */</span></span><br><span class="line">            <span class="comment">/* 如果当前的进程deadline为0了，或者说是当前进程的剩余时间比下一个进程的剩余时间更长 </span></span><br><span class="line"><span class="comment">            * 那么，就需要交换这两个进程，最终将会筛选得到剩余时间最短的进程。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">                <span class="keyword">if</span> (rp-&gt;deadline == <span class="number">0</span> || (rp-&gt;deadline &gt; next-&gt;deadline))&#123;</span><br><span class="line">                    <span class="keyword">if</span> (proc_is_runnable(next)) &#123; <span class="comment">//判断是否在运行</span></span><br><span class="line">                        rp = next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">/* 比下一个 */</span></span><br><span class="line">          next = next-&gt;p_nextready;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      assert(proc_is_runnable(rp));</span><br><span class="line">      <span class="keyword">if</span> (priv(rp)-&gt;s_flags &amp; BILLABLE)	 	</span><br><span class="line">        get_cpulocal_var(bill_ptr) = rp; <span class="comment">/* bill for system time */</span></span><br><span class="line">      <span class="keyword">return</span> rp;</span><br><span class="line">  &#125;   </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><p>测试用例来说明这个函数更直观：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;lib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//创建三个子进程，并赋予子进程id</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      proc(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> loop;</span><br><span class="line">  <span class="keyword">switch</span> (id)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//子进程1，设置deadline=20</span></span><br><span class="line">    chrt(<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"proc1 set success\n"</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//子进程2，设置deadline=15</span></span><br><span class="line">    chrt(<span class="number">15</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"proc2 set success\n"</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">//子进程3，普通进程</span></span><br><span class="line">    chrt(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"proc3 set success\n"</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (loop = <span class="number">1</span>; loop &lt; <span class="number">40</span>; loop++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//子进程1在5s后设置deadline=5</span></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">1</span> &amp;&amp; loop == <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      chrt(<span class="number">5</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Change proc1 deadline to 5s\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子进程3在10s后设置deadline=3</span></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">3</span> &amp;&amp; loop == <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      chrt(<span class="number">3</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"Change proc3 deadline to 3s\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">1</span>); <span class="comment">//睡眠，否则会打印很多信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"prc%d heart beat %d\n"</span>, id, loop);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>编译完成之后，我们把测试用的 <code>test.c</code>文件放到   文件夹下，然后 <code>clang test.c -o test</code> 编译文件 <code>./test</code> 运行可执行文件，结果如下图所示：</p>
<p><img src="/2021/04/12/os-Project2/15.png"></p>
<p>显然这个答案并不是正确的，但是起码在kernel中添加了chrt 函数。第二天我调试了四五个小时(主要时间花在编译上面)，将内核层多次删改后再次尝试，这次成功了：</p>
<p><img src="/2021/04/12/os-Project2/16.png"></p>
<p>在测试中，在<code>main</code>函数中<code>fork</code>三个子进程(P1, P2, P3)，并为每个子进程设置id。</p>
<p><code>P1</code>和<code>P2</code>为实时进程，<code>deadline</code>分别设为20s和15s。</p>
<p>三个子进程会打印出子进程id和循环次数。</p>
<p>第0s时：优先级<code>P2 &gt; P1 &gt; P3</code>;</p>
<p>第5s 时：P1设置deadline为5s，P1调用chrt(5);</p>
<p>第5s后：优先级<code>P1 &gt; P2 &gt; P3</code>;</p>
<p>第10s时：P3设置deadline为3s，P3调用chrt(3);</p>
<p>第10s后：优先级<code>P3 &gt; P2</code>;</p>
<p>n 打印输出信息，观察子进程执行顺序是否正确.</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>MINIX的不同服务模块和内核都是运行在不同进程中，只能使用基于消息的进程间系统调用/内核调用，不能使用直接调用普通C函数。</li>
<li>添加调用编号，需要修改取值范围限制。</li>
<li>以源码为准（博客等资料版本落后）。</li>
<li>善用source insight高级功能（调用关系，全局搜索）。</li>
<li>善用git diff 检查代码修改。修改涉及文件较多，git diff可直观看到修改内容，避免引入无意的错误。</li>
<li>善用FileZilla功能。连接虚拟机，拉取需修改的文件，修改后上传到虚拟机。</li>
</ul>
<h3 id="编译方法"><a href="#编译方法" class="headerlink" title="编译方法"></a>编译方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ &#96;cd &#x2F;usr&#x2F;src&#96;</span><br><span class="line">+ &#96;make build&#96; #首次编译，或者修改了头文件，Makefile时使用，时间较长。</span><br><span class="line">+ &#96; Make build MKUPDATE&#x3D;yes&#96; #增量式编译，适用于少量C源代码修改时使用。</span><br><span class="line">+ &#96;reboot&#96; #重启，默认情况下自动选择latest kernel（新生成的kernel），需要原始版本时手工选择。</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>这次实验要求我们修改的东西很多，我的解决步骤是：</p>
<p>应用层$\longrightarrow$服务层$\longrightarrow$内核层$\longrightarrow$修改进程调度算法</p>
<p>在每一part做完之后，都会编译一下kernal，如果没有报错，说明修改的代码没有问题</p>
</li>
<li><p>找到效率高的工作流很重要。我的工作软件如下：</p>
<p>Typora 负责步骤查看和报告撰写</p>
<p>Terminus 负责用ssh连接虚拟机与命令操作</p>
<p>Transmit3 负责用ftp连接虚拟机的文件系统，配合xcode 修改代码</p>
<p>Chrome、Acrobat 用于博客查看与资料查阅</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/04/11/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F3-4-3-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/11/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F3-4-3-5/" class="post-title-link" itemprop="url">多维随机变量3.4-3.5</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-11 23:26:07" itemprop="dateCreated datePublished" datetime="2021-04-11T23:26:07+08:00">2021-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-06-27 21:08:40" itemprop="dateModified" datetime="2021-06-27T21:08:40+08:00">2021-06-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="多维随机变量的特征数"><a href="#多维随机变量的特征数" class="headerlink" title="多维随机变量的特征数"></a>多维随机变量的特征数</h1><h2 id="多维随机变量函数的数学期望"><a href="#多维随机变量函数的数学期望" class="headerlink" title="多维随机变量函数的数学期望"></a>多维随机变量函数的数学期望</h2><p>当 $y=g(x_1)$ 的时候，我们由第二章的公式可以得出 </p>
<script type="math/tex; mode=display">
E(Y)=\begin{cases}\sum_{x_i}g(x_i)P(X=x_i) ~~在离散情况下 \\ \\ \int_{-\infty}^{\infty} g(x) p(x) dx ~~在连续情况下\end{cases}</script><p>那么推广到$Y=g(x)=p(x_1,x_2,\cdots,x_n)$  时</p>
<script type="math/tex; mode=display">
E(Y) =\begin{cases}\sum\limits_{x_1}\sum\limits_{x_2}\cdots\sum\limits_{x_n}g(x_1,x_2,\cdots,x_n)P(X_1=x_1,\cdots,X_n=x_n) ~~在离散情况下 \\ \\ \int_{-\infty}^{\infty}\cdots\int_{-\infty}^{\infty} g(x_1,x_2,\cdots,x_n) p(x_1,x_2,\cdots,x_n) dx_1dx_2\cdots dx_n  ~~在连续情况下\end{cases}</script><h2 id="数学期望与方差的运算性质"><a href="#数学期望与方差的运算性质" class="headerlink" title="数学期望与方差的运算性质"></a>数学期望与方差的运算性质</h2><h3 id="性质1"><a href="#性质1" class="headerlink" title="性质1"></a>性质1</h3><p>设 $(X,Y)$ 是二维随机变量，则有 $E(X+Y)=E(X)+E(Y)$ </p>
<p>证明还是比较重要的：</p>
<script type="math/tex; mode=display">
E(X+Y)= \int_{-\infty}^{\infty}\int_{-\infty}^{\infty} (x+y)p(x,y)dxdy\\
=\int_{-\infty}^{\infty}x[\int_{-\infty}^{\infty}p(x,y)dy]dx+\int_{-\infty}^{\infty}y[\int_{-\infty}^{\infty}p(x,y)dx]dy\\
=\int_{-\infty}^\infty xp_X(x)dx+\int_{-\infty}^\infty yp_Y(y)dy\\
=E(X)+E(Y)</script><p>这个性质可以描述为：<strong>和的期望等于期望的和</strong>。这个性质还可以推广到 n维随机变量场合，即</p>
<p>$E(X_1+X_2+\cdots+X_n)=E(X_1)+E(X_2)+\cdots+E(X_n)$ </p>
<h3 id="性质2"><a href="#性质2" class="headerlink" title="性质2"></a>性质2</h3><p>若随机变量<strong>X与Y相互独立</strong>，则有 $E(XY)=E(X)E(Y)$ </p>
<p>这个性质可以描述为： 在独立场合，<strong>随机变量乘积的数学期望</strong>等于<strong>数学期望的乘积</strong>。  </p>
<p>这个性质还可以推广到n维随机变量场合，即若$X_1,X_2\cdots,X_n$ <strong>相互独立</strong>，则有</p>
<p>$E(X_1X_2\cdots X_n)=E(X_1)E(X_2)\cdots E(X_n)$ </p>
<h3 id="性质3"><a href="#性质3" class="headerlink" title="性质3"></a>性质3</h3><p>若<strong>随机变量X与Y相互独立</strong>，则有 $Var(X\pm Y)=Var(X)+Var(Y)$ </p>
<p>这个性质表明： 独立变量代数和方差等于各方差之和。但要注意次性质对标准差不成立。即$\sigma(X\pm Y)\neq \sigma(X)+\sigma(Y)$ </p>
<p>标准差只能通“先方差，后标准差”求得，即$\sigma(X\pm Y)=\sqrt{Var(X)+Var(Y)}$ </p>
<p>这个性质可以推广到<strong>n维随机变量场合</strong> ，即若$X_1,X_2,\cdots,X_n$ 相互独立，则有</p>
<p>$Var(X_1\pm X_2\pm\cdots\pm X_n) = Var(X_1)+Var(X_2)+\cdots+Var(X_n)$ </p>
<p>这表明，对<strong>独立随机变量</strong>来说，它们之间无论是相加还是相减，其方差总是逐个累计起来，只会增加，不会减少。</p>
<p><strong>特别的</strong>，当n个相互独立同分布(方差为$\sigma^2$)的随机变量$X_1,X_2,\cdots,X_n )$ 的算术平均的方差为</p>
<script type="math/tex; mode=display">
Var(\frac{1}{n}\sum\limits_{i=1}^nX_i)=\frac{\sigma^2}{n}</script><h4 id="例题：离散情况"><a href="#例题：离散情况" class="headerlink" title="例题：离散情况"></a>例题：离散情况</h4><p>从数字$0,1,\cdots,n$ 中任取两个不同的数字，求这两个数字之差的绝对值和数学期望。</p>
<p><strong>第一步：列出x,y的联合分布列</strong></p>
<p>这里面是从$0\sim n$中取2个不同的数字，那么 </p>
<script type="math/tex; mode=display">
p(x=i,y=j)=\frac{1}{n(n-1)}, 0\leq i,j\leq n,i\neq j</script><p><strong>第二步：判断是否可以利用期望的性质，如果不能就按照定义求期望，否则可以用性质简化计算</strong></p>
<p>这里是<strong>二元随机变量</strong>，因此公式可以写为： $\sum_x\sum_yg(x)p(x,y)$ </p>
<p>这里还要注意，要我们求得是差的绝对值因此要拆成两部分求和</p>
<script type="math/tex; mode=display">
E(|X-Y|)=\frac{1}{n(n-1)}\sum_{x=0}^n\{\sum_{y=0}^x(x-y)+\sum_{y=x+1}^n(y-x)\}=\frac{1}{n(n-1)}\sum_{x=0}^n\{x^2-nx+n(n+1)/2\}</script><p>注意,$\sum_{x=0}^n x^2 = \frac{n(n+1)(2n+1)}{6}$ </p>
<p>因此，原式等于：</p>
<script type="math/tex; mode=display">
\frac{1}{n(n-1)}\sum_{x=0}^n\{x^2-nx+n(n+1)/2\} = \frac{1}{n(n-1)}(\frac{n(n+1)(2n+1)}6-\frac{n(n)(n+1)}2+\frac{n(n+1)^2}{2})=\frac{n+2}3</script><h4 id="例题：连续情况"><a href="#例题：连续情况" class="headerlink" title="例题：连续情况"></a>例题：连续情况</h4><p>在长为a的线段上任取两个点 $X$ 和 $Y$ ,求此两点间的平均长度</p>
<p><strong>第一步：列出x，y的联合分布</strong></p>
<p>因为X与Y都服从$(0,a)$上的均匀分布，且 X,Y 相互独立，所以$<X,Y>$ 的联合密度函数为：</X,Y></p>
<script type="math/tex; mode=display">
p(x,y) = \begin{cases}\frac{1}{a^2} ~~0<x<a,0<y<a \\ \\ 0 ~~ 其他\end{cases}</script><p><strong>第二步，判断是否可以利用期望的性质，如果不能就按照定义求期望，否则可以用性质简化计算</strong></p>
<p>这里是二元随机变量，所以公式可写为：$E(g(x))=\int<em>{-\infty}^\infty\int</em>{-\infty}^\infty g(x)p(x,y)dxdy$ </p>
<p>要求两点间的平均长度，就是要求$E(|X-Y|)$,</p>
<script type="math/tex; mode=display">
E(|X-Y|) = \int_0^a\int_0^a|x-y|\frac{1}{a^2}dxdy</script><p>直接求绝对值不太方便，我们拆成两部分，首先将常数 $\frac{1}{a^2}$ 提出</p>
<script type="math/tex; mode=display">
=\frac{1}{a^2}\{\int_{0}^a\int_0^x(x-y)dydx+\int_0^a\int_x^a(y-x)dy dx\}\\
=\frac{1}{a^2}\{\int_0^a(x^2-ax+\frac{a^2}{2})dx\}=\frac{a}{3}</script><h4 id="例题：当随机变量是极值分布时"><a href="#例题：当随机变量是极值分布时" class="headerlink" title="例题：当随机变量是极值分布时"></a>例题：当随机变量是极值分布时</h4><p>设在区间$(0,1)$上随机取n个点，求相聚最远的两点间的距离的数学期望</p>
<p><strong>第一步，定义极值分布，列出目标期望</strong></p>
<p>分别记 n个点为 $X_1,X_2\cdots,X_n$, 那么这n个点相互独立，且都服从 区间上$(0,1)$的均匀分布$U(0,1) $</p>
<p>所以 $p_X(x)=1,0&lt;x&lt;1; F_X(x)=x$</p>
<p>我们的目的是求 $E(\max{X_1,X_2\cdots,X_n}-\min{X_1,X_2\cdots,X_n})$ </p>
<p>因此，我们可以令 $Z=\max{X_1,X_2,\cdots,X_n}, T=\min{X_1,X_2\cdots,X_n}$ </p>
<p>根据极值分布的定义，可以分别写出Z和T的分布函数和密度函数：</p>
<script type="math/tex; mode=display">
F_Z(z)=[F_x(z)]^n = z^n\\p_Z(z) = nz^{n-1} ,0<z<1\\
F_T(t)=1-[1-F_X(t)]^n = 1-[1-t]^n \\p_T(t)=n(1-t)^{n-1},0<t<1,</script><p><strong>第二步，判断是否可以利用期望的性质求解</strong></p>
<p>因为求Z和T的联合分布列是比较困难的，因为他们不是独立分布的。所以我们可以利用其性质： $E(X+Y)=E(X)+E(Y)$</p>
<p>分别求$E(Z)$和$E(T)$再相减即可</p>
<script type="math/tex; mode=display">
E(Z)=\int_0^1 z\cdot nz^{n-1}dz = \frac{n}{n+1}\\
E(T)= \int_0^1 t\cdot n(1-t)^{n-1}dt</script><p>这个$E(T)$比较难算，我们可以将其配方成一个贝塔分布$Be(2,n)$的积分：</p>
<script type="math/tex; mode=display">
\int_0^1nt(1-t)^{n-1} = \frac{1}{n+1}\int_0^1n(n+1)t(1-t)^{n-1} dt
=\frac{1}{n+1}\int_0^1\frac{\Gamma(n+2)}{\Gamma(n)\Gamma(2)} t^{2-1}(1-t)^{n-1} = \frac{1}{n+1}</script><p>综上，$E(Z-T)=\frac{n}{n+1}-\frac{1}{n+1}=\frac{n-1}{n+1}$ </p>
<p>因此，当积分区域确定，积分形状又很类似我们常见的分布的时候，我们可以凑方、配方称常见的分布求积分，会省很多力气。</p>
<h2 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h2><p>设$(X,Y)$是一个二维随机变量，若 $E[(X-E(X))(Y-E(Y))]$存在，则称此数学期望为 $X$ 与 $Y$ 的协方差，或称为$X$ 与 $Y$ 的相关(中心)矩。并记为</p>
<script type="math/tex; mode=display">
Cov(X,Y) = E[(X-E(X))(Y-E(Y))]</script><p>特别有 $Cov(X,X)=Var(X)$ </p>
<ul>
<li>当$Cov(X,Y)&gt;0$的时候，称 X与Y <strong>正相关</strong>， 这时候两个偏差 $(X-E(X))$与 $(Y-E(Y))$ 有同时增加或者同时减少的倾向。由于 $E(X)$与$E(Y)$ 都是常数，故等价于$X$ 与 $Y$ 有同增同减的倾向。</li>
<li>当$Cov(X,Y)&lt;0$时，称X与Y<strong>负相关</strong> , 这时有X增加而Y减少的倾向，或者有 $Y$增加而$X$减少的倾向。</li>
<li>当$Cov(X,X)=0$时，称X与Y<strong>不相关</strong>，这时候X与Y可能取值毫无关联，也可能是X与Y之间存在某种非线性关系。</li>
</ul>
<h3 id="性质1-1"><a href="#性质1-1" class="headerlink" title="性质1"></a>性质1</h3><p>这是常用的协方差计算公式。</p>
<p>$Cov(X,Y)=E(XY)-E(X)E(Y)$ </p>
<h3 id="性质2-1"><a href="#性质2-1" class="headerlink" title="性质2"></a>性质2</h3><p><strong>若随机变量X与Y相互独立，则$Cov(X,Y)=0$ 反之不然。</strong></p>
<p>这是因为在独立场合有 $E(XY)=E(X)E(Y)$ 在，但是如果 $Cov(X,Y)=0$，X与Y可能是不独立的。</p>
<p>比如说，设随机变量 $X\sim N(0,\sigma^2)$，且令 $Y=X^2$ ,则X与Y不独立。 此时 X 与 Y的协方差为 $Cov(X,Y)=Cov(X,X^2)=E(X\cdot X^2)-E(X)E(X^2)=0$ </p>
<p>这说明：<strong>独立必然导致不相关，而不相关则不一定导致独立。</strong>  </p>
<p><img src="/2021/04/11/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F3-4-3-5/1.jpg" style="zoom:33%;"></p>
<h3 id="性质3-1"><a href="#性质3-1" class="headerlink" title="性质3"></a>性质3</h3><p>对于任意二维随机变量$(X,Y)$有：</p>
<script type="math/tex; mode=display">
Var(X\pm Y) = Var(X)+Var(Y)\pm 2Cov(X,Y)</script><p>因此，这也证明了刚才方差的运算性质。当X，Y互相独立的时候，$Var(X\pm Y)=Var(X)+Var(Y)$ </p>
<p>以上的性质还可以推广到更多个随机变量场合，即对任意n个随机变量 $X_1,X_2,\cdots,X_n$有</p>
<script type="math/tex; mode=display">
Var(\sum\limits_{i=1}^nX_i)=\sum\limits_{i=1}^n Var(X_i)+2\sum_{i=1}^n\sum_{j=1}^{i-1} Cov(X_i,X_j)</script><p>下面几条性质可以方便协方差的计算</p>
<h3 id="性质4"><a href="#性质4" class="headerlink" title="性质4"></a>性质4</h3><p>$Cov(X,Y)=Cov(Y,X)$</p>
<p>即协方差$Cov(X,Y)$的计算与X，Y的次序无关</p>
<h3 id="性质5"><a href="#性质5" class="headerlink" title="性质5"></a>性质5</h3><p>$Cov(X,a)=0$ </p>
<p>即任意随机变量X与常数a的协方差为0</p>
<h3 id="性质6"><a href="#性质6" class="headerlink" title="性质6"></a>性质6</h3><script type="math/tex; mode=display">
Cov(aX,bY) =abCov(X,Y)</script><h3 id="性质7"><a href="#性质7" class="headerlink" title="性质7"></a>性质7</h3><p>设$X,Y,Z$ 是任意三个随机变量，则</p>
<script type="math/tex; mode=display">
Cov(X+Y,Z)=Cov(X,Z)+Cov(Y,Z)</script><h3 id="性质8"><a href="#性质8" class="headerlink" title="性质8"></a>性质8</h3><script type="math/tex; mode=display">
Cov (X,Y)\leq \sqrt {Var(X)}\sqrt{Var(y)}</script><p>因为 协方差矩阵是非负定的，其绝对值是大于等于0的，当等于的时候，说明X，Y不相关；当大于0的时候，上述式子成立</p>
<h4 id="例题：常规方法求-Var-g-x-y"><a href="#例题：常规方法求-Var-g-x-y" class="headerlink" title="例题：常规方法求 Var(g(x,y))"></a>例题：常规方法求 Var(g(x,y))</h4><p>设二维随机变量$(X,Y)$的联合密度为</p>
<script type="math/tex; mode=display">
p(x,y)=\begin{cases}\frac{1}{3}(x+y) ~~0<x<1,0<y<2 \\ \\ 0 ~~ 其他\end{cases}</script><p>试求$Var(2X-3Y+8)$</p>
<p><strong>思路</strong></p>
<ol>
<li><strong>展开</strong>，化简为独立的X方差与Y方差、协方差形式</li>
</ol>
<script type="math/tex; mode=display">
Var(2X-3Y+8)=Var(2X)+Var(3Y)-2Cov(2X,3Y)\\
=4Var(X)+9Var(Y)-12Cov(X,Y)</script><ol>
<li>分别计算 $Var(X),Var(Y)$ ，用到 $Var(X)=E(X^2)-E(X)^2$ 这个公式</li>
<li>计算 $E(X),E(X^2),E(Y),E(Y^2)$ </li>
<li>计算$E(XY)$ 可以从联合密度函数导出</li>
<li>计算协方差 $Cov(X,Y)=E(XY)-E(X)E(Y)$ </li>
</ol>
<h4 id="例题：利用常见分布求期望和方差"><a href="#例题：利用常见分布求期望和方差" class="headerlink" title="例题：利用常见分布求期望和方差"></a>例题：利用常见分布求期望和方差</h4><p>随机变量$(X,Y)$服从以点$(0,1),(1,0),(1,1)$ 为顶点的三角形区域上的均匀分布，试求$E(X+Y)$和 $Var(X+Y)$</p>
<p>刚开始我用传统方法求解$E(X+Y)$，也就是先求出$p(x,y)$ 然后利用定义求解。但是这种方法对$Var(X+Y)$ 却起不到便利。因此我们可以用一下这种方法：</p>
<p><strong>第一步，求p(x,y)联合分布</strong></p>
<script type="math/tex; mode=display">
p(x,y)=\begin{cases}2 ,0<x<1,1-x<y<1\\ \\0 其他\end{cases}</script><p><strong>第二步，求x,y的边际分布</strong> </p>
<script type="math/tex; mode=display">
p_X(x)=\int_{1-x}^1 2dy =2x \\ 
p_Y(y)= \int_{1-y}^1 2dx = 2y</script><p><strong>第三步，用常见的分布求X、Y的期望与方差</strong></p>
<p>$p_X(x)=2x$ 可以看成 $p(x)=\frac{\Gamma(2+1)}{\Gamma(2)\Gamma(1)} x^{2-1}(1-x)^{1-1}$, 因此 $X\sim Be(2,1)$   ，同理 $Y\sim Be(2,1)$ </p>
<p>因此</p>
<script type="math/tex; mode=display">
E(X)=E(Y)=\frac{a}{a+b}=\frac{2}{3}\\
Var(X)=Var(Y)=\frac{ab}{(a+b)^2(a+b+1)}=\frac{1}{18}</script><p><strong>第四步：先计算E(X+Y)</strong></p>
<p>由性质可以得到</p>
<script type="math/tex; mode=display">
E(X+Y)=E(X)+E(Y)=\frac{2}{3}+\frac{2}{3}=\frac{4}{3}</script><p><strong>第五步：计算Var(X+Y)</strong></p>
<p>首先，列出$Var(X+Y)=Var(X)+Var(Y)+2Cov(X,Y)$ </p>
<p>因此我们还要求$Cov(X,Y)=E(XY)-E(X)E(Y)$ </p>
<p>因为X,Y并不是互相独立的，因此还要计算 $E(XY)$,$E(XY)$可以用传统方法求解：</p>
<script type="math/tex; mode=display">
E(XY)=\int_{0}^1\int_{1-x}^1 (xy) 2dydx=\frac{5}{12}\\
Cov(X,Y)=\frac{5}{12}-\frac{4}{9}=-\frac{1}{36}</script><p>因此</p>
<script type="math/tex; mode=display">
Var(X+Y)=\frac{1}{18}+\frac{1}{18}+2(-\frac{1}{36}) = \frac{1}{18}</script><p>这里我们要记住，贝塔分布 $Be(2,1)=2x$ 这一个很隐蔽但是很有用的性质。</p>
<h4 id="例题3-1：极值分布的期望和方差"><a href="#例题3-1：极值分布的期望和方差" class="headerlink" title="例题3-1：极值分布的期望和方差"></a>例题3-1：极值分布的期望和方差</h4><p>设 $X_1,X_2,X_3,X_4,X_5$ 是独立同分布的随机变量，其共同的密度函数</p>
<script type="math/tex; mode=display">
p(x)=\begin{cases}2x， ~~0<x<1\\ \\0, 其他\end{cases}</script><p>试求 $Y=\max{X_1,X_2,\cdots,X_5}$ 的密度函数、数学期望、方差</p>
<p><strong>第一步：求出X的分布函数</strong></p>
<script type="math/tex; mode=display">
F_X(x) = \int_0^x 2x dx =  x^2 , 0<x<1 \\</script><p><strong>第二步： 求出Y的分布函数</strong></p>
<script type="math/tex; mode=display">
F_Y(y) = [F_X(y)]^5 = y^{10}</script><p><strong>第三步：求出密度函数、数学期望和方差</strong></p>
<script type="math/tex; mode=display">
p_Y(y) = F_Y'(y) = 10y^9\\
E(y) = \int_0^1 y\cdot 10y^9 dy = \frac{10}{11}\\
Var(y) = E(y^2)-E^2(y)=\int_0^1y^210y^9 dy - \frac{100}{121}=\frac{5}{726}</script><h4 id="例题3-2-求-E-极值分布"><a href="#例题3-2-求-E-极值分布" class="headerlink" title="例题3-2: 求 E(极值分布)"></a>例题3-2: 求 E(极值分布)</h4><p>设X,Y 独立同分布，都服从标准正态分布$N(0,1)$, 求$E(\max{X,Y})$ </p>
<p><strong>第一步: 化简 max{X,Y}</strong></p>
<script type="math/tex; mode=display">
\max\{X,Y\}=\frac{X+Y+|X-Y|}{2}\\
E[\max\{X,Y\}]=E[\frac{X+Y+|X-Y|}{2}]=\frac{E(X)+E(Y)+E|X-Y|}{2} =\frac{E|X-Y|}{2}</script><p>现在我们把 $E[\max{X,Y}] $ 转换成了 $\frac{E|X-Y|}{2}$</p>
<p><strong>第二步：写出 X-Y 的密度函数</strong></p>
<p>因为X,Y 独立，都服从 $N(0,1)$根据性质 $X-Y\sim N(0,2)$ ，这里使用了正态分布的可加性——</p>
<p>若随机变量 $X\sim N(\mu,\sigma^2)$ ,则对任意非零实数a有 $aX\sim N(a\mu,a^2\mu^2)$ 。</p>
<p>因此，我们可以得到一个<strong>重要结论</strong>， 即</p>
<script type="math/tex; mode=display">
a_1X_1+a_2X_2+\cdots+a_nX_n \sim N(\mu_0,\sigma_0^2)</script><p>若$X_i\sim N(\mu_1,\sigma_1^2),i=1,2\cdots,n$则参数 $\mu_0$与 $\sigma_0^2$ 分别为：</p>
<script type="math/tex; mode=display">
\mu_0 = \sum_{i=1}^n a_i\mu_i\\ \sigma_0^2 = \sum_{i=1}^n a_i^2\sigma_i^2</script><p>$P(X-Y)=\frac{1}{\sqrt{2\pi}\sqrt{2}}\exp{-\frac{(x-y)^2}{4}}$  </p>
<p><strong>第三步：根据定义计算期望</strong></p>
<p>令 $X-Y=t$. 则 </p>
<script type="math/tex; mode=display">
E(|t|) = \int_{-\infty}^{\infty} |t| \frac{1}{\sqrt{2\pi}\sqrt{2}}\exp\{-\frac{(t)^2}{4}\}dt\\ \\
=\frac{1}{\sqrt{2\pi}\sqrt{2}}\cdot 2 \int_0^\infty t\exp\{-\frac{t^2}4\}dt\\
=\frac{-2}{\sqrt{\pi}} \exp\{-\frac{t^2}{4}\}|_0^\infty\\
=\frac{2}{\sqrt\pi}</script><p>因此 $E[\max{X,Y}]=\frac{E|X-Y|}{2}=\frac{1}{\sqrt\pi}$ </p>
<h2 id="相关系数"><a href="#相关系数" class="headerlink" title="相关系数"></a>相关系数</h2><p>协方差是有量纲的量，譬如X表示人的身高，单位是米(m) , Y表示人的体重，单位是千克(kg) .则Cov(X,Y) 带有量纲$(m\cdot kg)$ </p>
<p>为了消除量纲的影响，现对协方差除以相同量纲的量，得到相关系数的概念</p>
<p><strong>定义：</strong></p>
<script type="math/tex; mode=display">
Corr(X,Y)=\frac{Cov(X,Y)}{\sqrt{Var(X)}{\sqrt{Var(Y)}}} = \frac{Cov(X,Y)}{\sigma_X\sigma_Y}</script><p>上式为X与Y的(线性)相关系数</p>
<p>现在我们知道二维正态分布$N(\mu_1,\mu_2,\sigma_1,\sigma_2,\rho)$ 的相关系数是 $\rho$ </p>
<h3 id="性质1-2"><a href="#性质1-2" class="headerlink" title="性质1"></a>性质1</h3><script type="math/tex; mode=display">
1\leq Corr(X,Y)\leq 1</script><p>这个性质表明：相关系数介于 -1 和 1 之间。</p>
<h3 id="性质2-2"><a href="#性质2-2" class="headerlink" title="性质2"></a>性质2</h3><p>$Corr(X,Y)=\pm 1$ 的充要条件是 X与Y 之间几乎处处有线性关系，即存在 a与b，使得 $P(Y=aX+b)=1$ </p>
<p>其中当$Corr(X,Y)=1$时，有 $a&gt;0$，称X与Y <strong>完全正相关</strong>; $Corr(X,Y)=-1$ 时，有$a&lt;0$,称X与Y <strong>完全负相关</strong></p>
<h3 id="性质3-2"><a href="#性质3-2" class="headerlink" title="性质3"></a>性质3</h3><p>在二维正态分布 $N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)$ , 不相关与独立是等价的 </p>
<p>y因为二维正态分布$N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)$ 的两个边际分布为 $N(\mu_1,\sigma_1^2)$和$N(\mu_2,\sigma_2^2)$ ,所以记其联合非密度为$p(x,y)$.边际密度函数为$p_X(x)$ 与 $p_Y(y)$</p>
<p>那么当 $\rho =0$ 时，可从正态密度函数的表达式中看出： $p(x,y)=p_X(x)p_Y(y)$ 即 $X$ 与 $Y$ 相互独立</p>
<p>反之，若X与Y相互独立，则X与Y 不相关，从而有 $\rho =0$ </p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>已知随机向量$(X,Y)$的联合密度函数为：</p>
<p>$p(x,y)=\begin{cases}\frac{3}{8}  ~~0&lt;x-y&lt;0.5,0&lt;x,y&lt;1 \ \ 0 ~~ 其他\end{cases}$</p>
<p>求 X,Y 的相关系数$Corr(X,Y)$</p>
<p><strong>思路：</strong></p>
<ul>
<li>首先相关系数的公式 ： $Corr(X,Y)= \frac{Cov(X,Y)}{\sigma_X\sigma_Y}=\frac{E(XY)-E(X)E(Y)}{\sigma_X\sigma_Y}$ </li>
<li>先求边际密度函数，即 $p<em>X(x)=\int</em>{-\infty}^\infty p(x,y)dy$和$p<em>Y(y)=\int</em>{-\infty}^{\infty}p(x,y)dx$  </li>
<li>求 $E(X),E(Y),E(X^2),E(Y^2)$</li>
<li>求$Var(X),\sigma(X),Var(Y),\sigma(Y)$ </li>
<li>带入求得</li>
</ul>
<h4 id="例题：-当相关系数结合多元函数"><a href="#例题：-当相关系数结合多元函数" class="headerlink" title="例题： 当相关系数结合多元函数"></a>例题： 当相关系数结合多元函数</h4><p>设随机变量X和Y独立同服从参数为$\lambda$ 的泊松分布，令：$U=2X+Y,V=2X-Y$ ，求U和V的相关系数 $Corr(U,V)$ </p>
<p>如果按照常规方法，可以先求出 $p(u,v)$，然后求出  $p_U(u)、p_V(v)、E(U)、E(V)、Var(U)、Var(V)$ ,再求出$Corr(U,V)$ 但是这样太麻烦了。</p>
<p>我们可以通过方差的性质和协方差的性质来求解，因为我们已经知道了 $E(X),E(Y),Var(X),Var(Y)$ 根据泊松分布的可加性，我们可以进而求出 $E(U),E(V),Var(U),Var(V)$ </p>
<p>因此，$Corr(U,V)=Cov(U,V)/\sqrt{Var(U)Var(V)}$</p>
<p>又： </p>
<script type="math/tex; mode=display">
Var(U)=Var(2X+Y) = 4Var(X)+Var(Y)=5\lambda \\
Var(V)=Var(2X-Y)=4Var(X)+Var(Y)=5\lambda \\</script><script type="math/tex; mode=display">
Cov(U,V) = Cov(2X+Y,2X-Y)=Cov(2X，2X-Y)+Cov(Y,2X-Y)=Cov(2X,2X)-Cov(2X,Y)+Cov(Y,2X)-Cov(Y,Y)\\
=E(4X^2)-4E(X)E(X)-2E(XY)+2E(X)E(Y)+2E(XY)-2E(X)E(Y)-E(Y^2)+E(Y)E(Y)\\
=4(\lambda^2+\lambda)-(\lambda^2+\lambda) -3\lambda^2=3\lambda</script><p>因此 $Corr(U,V)=\frac{3\lambda}{5\lambda}=\frac{3}{5}$ </p>
<h2 id="随机向量的数学期望向量与协方差矩阵"><a href="#随机向量的数学期望向量与协方差矩阵" class="headerlink" title="随机向量的数学期望向量与协方差矩阵"></a>随机向量的数学期望向量与协方差矩阵</h2><p>记n维随机向量为 $X=(X_1,X_2,\cdots,X_n)’$ ，若其<strong>每个分量的数学期望都存在</strong>，则称：</p>
<script type="math/tex; mode=display">
E(X)=(E(X_1),E(X_2),\cdots,E(X_n))'</script><p>为n为随机向量X的<strong>数学期望向量</strong>，简称为X的数学期望。</p>
<p>称</p>
<p><img src="/2021/04/11/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F3-4-3-5/2.jpg" style="zoom:33%;"></p>
<p>为该向量的<strong>方差-协方差</strong> 矩阵，记为$Cov(X)$ </p>
<h3 id="性质1-3"><a href="#性质1-3" class="headerlink" title="性质1"></a>性质1</h3><p>n为随机向量的协方差矩阵 $Cov(X)=(Cov(X<em>i,X_j))</em>{n\times n}$ 是一个对称的<strong>非负定矩阵</strong>，也就是说其行列式值是大于等于0的。</p>
<h1 id="条件分布与条件期望"><a href="#条件分布与条件期望" class="headerlink" title="条件分布与条件期望"></a>条件分布与条件期望</h1><h2 id="条件分布"><a href="#条件分布" class="headerlink" title="条件分布"></a>条件分布</h2><h3 id="离散随机变量的条件分布"><a href="#离散随机变量的条件分布" class="headerlink" title="离散随机变量的条件分布"></a>离散随机变量的条件分布</h3><h4 id="条件分布列"><a href="#条件分布列" class="headerlink" title="条件分布列"></a>条件分布列</h4><p><strong>现在我们给出离散随机变量的条件分布列定义：</strong></p>
<p>对于一切使 $P(Y=y<em>i)=p</em>{\cdot j}=\sum<em>{i=1}^\infty p</em>{ij}&gt;0$ , 称</p>
<script type="math/tex; mode=display">
p_{i|j}=P(X=x_i|Y=y_i)=\frac{P(X=x_i,Y=y_i)}{P(Y=y_i)}=\frac{p_{ij}}{p_{\cdot j}},i=1,2\cdots</script><p>为给定$Y=y_j$ 条件下X的分布列</p>
<p>同理，一切使得 $P(X=x<em>i)=p</em>{i\cdot}=\sum<em>{j=1}^\infty p</em>{ij}&gt;0$ 的$x_i$ ，称 </p>
<script type="math/tex; mode=display">
p_{j|i} = P(Y=y_j|X=x_i)=\frac{P(X=x_i,Y=y_j)}{P(X=x_i)}=\frac{p_{ij}}{p_i}</script><p>为给定 $X=x_i$条件下 Y 的条件分布列</p>
<h4 id="条件分布函数"><a href="#条件分布函数" class="headerlink" title="条件分布函数"></a>条件分布函数</h4><p>有了条件分布列，我们就可以给出离散随机变量的<strong>条件分布函数</strong></p>
<p>给定$Y=y_j$ 条件下 X的条件<strong>分布函数</strong>为：</p>
<script type="math/tex; mode=display">
F(x|y_j)=\sum_{x_i\leq x}P(X=x_i|Y=y_j)=\sum_{x_i\leq x} p_{i|j}</script><p> 给定$X=x_i$ 条件下 Y 的条件<strong>分布函数</strong>为：</p>
<script type="math/tex; mode=display">
F(y|x_i)=\sum_{y_j\leq y} P(Y=y_j|X=x_i)=\sum_{y_j\leq y}p_{j|i}</script><h4 id="例题1：求条件分布"><a href="#例题1：求条件分布" class="headerlink" title="例题1：求条件分布"></a>例题1：求条件分布</h4><p>设随机变量 X 与 Y互相独立，且 $X\sim P(\lambda_1),Y\sim P(\lambda_2)$ 。在已知道 $X+Y=n$ 的条件下，求 X 的条件分布。</p>
<p><strong>第一步，求P(X+Y)的分布，（先求联合分布列）</strong> </p>
<p>一般来说如果X与Y独立同分布，那么我们就要利用多元随机变量函数的性质来求，表现在：<strong>二项分布、泊松分布、正态分布、伽马分布(卡方分布) 的可加性</strong>上。</p>
<p>首先我们要知道独立泊松变量的和仍然为泊松变量。即 $X+Y\sim P(\lambda_1+\lambda_2)$ ，</p>
<p><strong>第二步，带入条件分布</strong></p>
<script type="math/tex; mode=display">
P(X=k|X+Y=n)=\frac{P(X=k,X+Y=n)}{P(X+Y=n)}\\
=\frac{P(X=k)P(Y=n-k)}{P(X+Y=n)} 
=\frac{\frac{\lambda_1^k}{k!}e^{-\lambda_1}\frac{\lambda_2^{n-k}}{(n-k)!}e^{-\lambda_2}}{\frac{(\lambda_1+\lambda_2)^n}{n!}e^{-(\lambda_1+\lambda_2)}}</script><p>消除指数之后，同分可得到： </p>
<script type="math/tex; mode=display">
=C_n^k (\frac{\lambda_1}{\lambda_1+\lambda_2})^k(\frac{\lambda_2}{\lambda_1+\lambda_2})^{n-k}</script><p>这就是一个二项分布，说明，在 $X+Y=n$的条件下，X服从二项分布 $b(n,p)$,其中$p=\frac{\lambda_1}{\lambda_1+\lambda_2}$ </p>
<h4 id="例题2："><a href="#例题2：" class="headerlink" title="例题2："></a>例题2：</h4><p>设在一段时间内进入某一商店的顾客人数X服从泊松分布$P(\lambda)$  ，每个顾客购买某种物品的概率为p，并且各个顾客是否购买该种物品相互独立，求进入商店的顾客购买这种物品的人数Y的分布列，以及$E(Y),Var(Y)$ </p>
<p>首先我们列出X的分布列：$P(X=m)=\frac{\lambda^m}{m!}e^{-\lambda}, m=0,1,2\cdots$  . 那么m就是进入商店的人数。</p>
<p>同时，我们给出购买某种物品的人数Y的条件分布。很容易理解这是<strong>一个二项分布</strong>：</p>
<script type="math/tex; mode=display">
P(Y=k|X=m) =C_m^k p^k(1-p)^{m-k} ,k = 0,1,2,\cdots,m</script><p>由<strong>全概率公式</strong>，可以得到：</p>
<script type="math/tex; mode=display">
P(Y=k)=\sum_{m=k}^\infty P(X=m)P(Y=k|X=m)\\
=\sum_{m=k}^\infty \frac{\lambda^m}{m!}e^{-\lambda} \cdot\frac{m!}{k!(m-k)!}p^k(1-p)^{m-k}
\\={e^{-\lambda}} p^k\sum_{m=k}^\infty \frac{\lambda^m}{k!(m-k)!}(1-p)^{m-k}\\
=\frac{e^{-\lambda} \lambda^k p^k}{k!}e^{\lambda(1-p)}\sum_{m=k}^\infty \frac{[\lambda(1-p)]^{m-k}}{(m-k)!}e^{-\lambda(1-p)}\\
=P(\lambda p)</script><p>显然，求和部分就像是 一个泊松分布的求和，其值为1</p>
<p>剩余的部分期望和方差都为 $\lambda p$， 标准差为 $\sqrt{\lambda p}$</p>
<p>这个例子可以告诉我们，在直接寻求Y的分布有困难时，有时借助条件分布可以把困难解决</p>
<h4 id="例题3-求条件分布列"><a href="#例题3-求条件分布列" class="headerlink" title="例题3: 求条件分布列"></a>例题3: 求条件分布列</h4><script type="math/tex; mode=display">
P(X=n,Y=m)  =\frac{e^{-14}(7.14)^m(6.86)^{n-m}}{m!(n-m)!} ~~~ n=0,1,\cdots \\</script><p>试求条件分布列 $P(Y=m|X=n)$  </p>
<p><strong>第一步： 列出公式</strong></p>
<script type="math/tex; mode=display">
P(Y=m|X=n) =\frac{P(X=m,Y=n)}{P(X=n)}</script><p><strong>第二步：根据公式，求出未知数</strong></p>
<p>我们已经有了 $P(Y=m,X=n)$, 因此要求 $P_X(x)$ 这一个边际分布</p>
<script type="math/tex; mode=display">
P_X(x)= \sum_{m=0}^n \frac{e^{-14}(7.14)^m(6.86)^{n-m}}{m!(n-m)!}</script><p>我们看这里有 $m!(n-m)!$ 可以考虑将其配方成二项分布：</p>
<script type="math/tex; mode=display">
P_X(x)=\frac{14^ne^{-14}}{n!}\sum_{m=0}^n \frac{n!}{m!(n-m)!} (\frac{7.14}{14})^m(\frac{6.86}{14})^{n-m}</script><p>求和部分是一个二项分布列的求和，其值为1， 因此$P_X(x)=\frac{14^ne^{-14}}{n!}=P(14)$ 也就是说，X服从参数为14的泊松分布</p>
<p><strong>第三步：带入求解</strong></p>
<script type="math/tex; mode=display">
P(Y=m|X=n)=\frac{e^{-14}(7.14)^m(6.86)^{n-m}}{m!(n-m)!}\cdot\frac{n!}{14^ne^{-14}} = C_n^m (\frac{7.14}{14})^m(\frac{6.86}{14})^{n-m}</script><p>这是一个二项分布 $b(n,0.51)$ </p>
<h3 id="连续随机随机变量的条件分布"><a href="#连续随机随机变量的条件分布" class="headerlink" title="连续随机随机变量的条件分布"></a>连续随机随机变量的条件分布</h3><p>对一切使$P_Y(y)&gt;0$ 的y，给定 $Y=y$  条件下X的<strong>条件密度函数</strong>和<strong>条件分布函数</strong>分别为：</p>
<script type="math/tex; mode=display">
p(x|y) = \frac{p(x,y)}{p_Y(y)} , F(x|y)=\int_{-\infty}^x p(u|y) du = \int_\infty^x\frac{p(u,y)}{p_Y(y)}du</script><p>同理，对于一切使$p_X(x)&gt;0$ 的x，给定$X=x$ 条件下Y的<strong>条件密度函数</strong>和<strong>条件分布函数</strong>分别为：</p>
<script type="math/tex; mode=display">
p(y|x) = \frac{p(x,y)}{p_X(x)} , F(y|x)=\int_{-\infty}^y p(v|x) dv =\int_\infty^y\frac{p(x,v)}{p_X(x)}dv</script><h4 id="例题1-求条件密度函数"><a href="#例题1-求条件密度函数" class="headerlink" title="例题1: 求条件密度函数"></a>例题1: 求条件密度函数</h4><p>设二维<strong>连续随机变量</strong>(X,Y) 的联合密度函数为：</p>
<script type="math/tex; mode=display">
p(x,y)=\begin{cases}3x,  ~~0<x<1,0<y<x\\ \\0,~~ 其他 \end{cases}</script><p>试求条件密度函数$p(y|x)$</p>
<p><strong>第一步: 列出条件密度函数公式</strong></p>
<script type="math/tex; mode=display">
p(y|x) = \frac{p(y，x)}{p(x)}</script><p>我们已经知道$p(x,y)$的联合密度函数，现在需要求 $p_X(x)$  即x的边际密度函数</p>
<p><strong>第二步：求p(x)</strong> </p>
<script type="math/tex; mode=display">
p_X(x)=\int_0^x 3x dy = 3x^2 , 0<x<1</script><p><strong>第三步：带入公式</strong> </p>
<p>$p(y|x)=\frac{3x}{3x^2}=\frac{1}{x}, 1&lt;y&lt;x$  </p>
<h4 id="例题2：求条件概率"><a href="#例题2：求条件概率" class="headerlink" title="例题2：求条件概率"></a>例题2：求条件概率</h4><script type="math/tex; mode=display">
p(x,y)=\begin{cases}\frac{21}{4}x^2y,  ~~x^2<y<1\\ \\0,~~ 其他 \end{cases}</script><p>求条件概率 $P(Y\geq 0.75|X=0.5)$ </p>
<p><strong>第一步：列出条件密度函数公式：</strong></p>
<script type="math/tex; mode=display">
p(y|x) = \frac{p(y，x)}{p(x)}</script><p><strong>第二步，求p(x)</strong></p>
<script type="math/tex; mode=display">
p_X(x)=\int_{x^2}^1 \frac{21}{4}x^2ydy = \frac{21}{8}x^2(1-x^4)</script><p><strong>第三步，带入公式：</strong></p>
<script type="math/tex; mode=display">
p(y|x) = \frac{21}{4}x^2y\frac{8}{21x^2(1-x^4)}=\frac{2y}{1-x^4}, 0<y<1</script><p><strong>第四步，求条件边际分布</strong></p>
<p>题目要求$P{Y\geq 0.75|X=0.5}$ ,因此，我们需要求 $P{y|x=0.5}$</p>
<script type="math/tex; mode=display">
P\{y|x=0.5\}=\frac{32}{15}y</script><p><strong>第五步：求条件概率</strong></p>
<script type="math/tex; mode=display">
P\{Y\geq 0.75|X=0.5\}=\int_{0.75}^1\frac{32}{15}y dy =\frac{7}{15}</script><h3 id="连续场合的全概率公式和贝叶斯公式"><a href="#连续场合的全概率公式和贝叶斯公式" class="headerlink" title="连续场合的全概率公式和贝叶斯公式"></a>连续场合的全概率公式和贝叶斯公式</h3><p>1) 全概率公式的密度函数形式</p>
<script type="math/tex; mode=display">
p_Y(y) = \int_{-\infty}^{\infty} p_X(x)p(y|x) dx \\~\\~ \\ p_X(x)=\int_{-\infty}^{\infty}p_Y(y)p(x|y)dy</script><p>2) 贝叶斯公式的密度函数形式：</p>
<script type="math/tex; mode=display">
p(x|y) =\frac{p_X(x)p(y|x)}{\int_{-\infty}^{\infty}p_X(x)p(y|x)}\\~\\~\\
p(y|x) = \frac{p_Y(y)p(x|y)}{\int_{-\infty}^\infty p_Y(y)p(x|y)dy}</script><h2 id="条件数学期望"><a href="#条件数学期望" class="headerlink" title="条件数学期望"></a>条件数学期望</h2><h3 id="条件期望"><a href="#条件期望" class="headerlink" title="条件期望"></a>条件期望</h3><p> 条件分布的数学期望称为<strong>条件期望</strong>，其定义如下：</p>
<script type="math/tex; mode=display">
E(X|Y=y) = \begin{cases}\sum_i x_iP(X=x_i|Y=y)~~ (X,Y)为二维离散随机变量\\ \\\int_{-\infty}^{\infty}xp(x|y) dx~~ (X,Y) 为二维连续随机变量\end{cases}</script><p>同理，</p>
<script type="math/tex; mode=display">
E(Y|X=x) = \begin{cases}\sum_j y_jP(Y=y_i|X=x)~~ (X,Y)为二维离散随机变量\\ \\\int_{-\infty}^{\infty}yp(y|x) dy ~~ (X,Y) 为二维连续随机变量\end{cases}</script><h4 id="例题：求条件期望"><a href="#例题：求条件期望" class="headerlink" title="例题：求条件期望"></a>例题：求条件期望</h4><p>设二维连续随机变量 $(X,Y)$ 的联合密度函数为：</p>
<script type="math/tex; mode=display">
p(x,y) = \begin{cases}x+y , 0<x,y<1 \\ \\ 0, 其他\end{cases}</script><p>试求 $E(X|Y=0.5)$ </p>
<p><strong>第一步：列出E(X|Y=y)的公式</strong></p>
<script type="math/tex; mode=display">
E(X|Y=0.5) =\int_0^1xp(x|Y=0.5) dx</script><p>发现 $p(X|Y=0.5)$这一个条件分布列是未知的。因此我们要求条件密度函数</p>
<p><strong>第二步：求出条件密度函数</strong></p>
<script type="math/tex; mode=display">
p(X=x|Y=y)=\frac{p(X=x,Y=y)}{p(Y=y)}</script><p>因为已知 $p(x,y)=x+y$， 现在就要求 $p_Y(y)$即y的边际分布</p>
<script type="math/tex; mode=display">
p_Y(y) = \int_0^1(x+y)dx = y+\frac12</script><p>带入得到： $p(X=x|Y=y)=\frac{x+y}{y+\frac{1}{2}}$ </p>
<p>所以 $p(X|Y=0.5)=x+0.5$ </p>
<p><strong>第三步，代入第一步公式求解</strong></p>
<script type="math/tex; mode=display">
E(X|Y=0.5)=\int_0^1 x(x+\frac{1}{2}) dx=\frac{7}{12}</script><h3 id="重期望公式"><a href="#重期望公式" class="headerlink" title="重期望公式"></a>重期望公式</h3><p>设 $(X,Y)$ 是二维随机变量，且 $E(X)$ 存在，则 $E(X)=E(E(X|Y))$</p>
<p>重期望公式的具体使用如下：</p>
<p>(1) 如果Y是一个离散随机变量，则上式可以写成</p>
<script type="math/tex; mode=display">
E(X) = \sum_j E(X|Y=y_j)P(Y=y_i)</script><p>(2) 如果Y是一个连续随机变量，则上式可写成</p>
<script type="math/tex; mode=display">
E(X) = \int_{-\infty}^{\infty} E(X|Y=y_j)P_Y(y)dy</script><h4 id="例题：求二元函数的期望"><a href="#例题：求二元函数的期望" class="headerlink" title="例题：求二元函数的期望"></a>例题：求二元函数的期望</h4><p>设随机变量X与Y独立同步，都服从参数为 $\lambda$ 的指数分布，令</p>
<script type="math/tex; mode=display">
Z=\begin{cases}3X+1 ,X\geq Y\\ \\6Y,~~ X<Y \end{cases}</script><p>求$E(Z)$ </p>
<p><strong>第一步： 先分析思路</strong></p>
<p>要求$E(Z)$,其中Z是一个二元函数，因此这道题可以从两种思路来求解：</p>
<p>第一种就是用二元函数期望公式来就算；</p>
<p>第二种就是用条件期望(重期望公式)来计算</p>
<p><strong>第二步：用第一种方法——二元函数期望</strong></p>
<p>首先我们求X，Y的联合分布 $p(x,y)$ ： $X\sim \lambda e^{-\lambda x}, Y\sim \lambda e^{-\lambda y}$  </p>
<p>$p(x,y)=p(x)p(y)=\lambda^2 e^{-\lambda x-\lambda y}$</p>
<p>我的思路是拿到题目首先考虑二元函数期望公式：</p>
<script type="math/tex; mode=display">
E(Z)=\int_{-\infty}^{\infty} zp(z)dz =\int_{X\geq Y} (3x+1)p(x,y)dxdy+\int_{X<Y} 6yp(x,y)dxdy\\
=\int_0^\infty\int_y^\infty (3x+1)\lambda^2e^{-\lambda x-\lambda y }dxdy+\int_0^\infty\int_0^y 6y\lambda^2e^{-\lambda x-\lambda y} dxdy\\
=\cdots</script><p><strong>第三步：用第二种方法——条件期望</strong></p>
<ol>
<li><p>在 $X=x$ 给定时， $Z=\begin{cases}3X+1 ,X\geq Y\ \6Y,~~ X&lt;Y \end{cases}$ 是<strong>关于Y的函数</strong>。注意，这里不要用 $E(Z|X)=\int<em>{-\infty}^{\infty} zp(z|x)dz$ 来计算。而是说，把 $Z$ 看做是 $g(Y)$, 然后通过公式 $E(g(Y))=\int</em>{-\infty}^\infty g(y)p_Y(y)dy$ 来计算。 同理，可以将其看成是$Y=y$ 条件下X的函数</p>
<script type="math/tex; mode=display">
E(Z|X=x)=\int_0^x (3x+1)\lambda e^{-\lambda y}dy+\int_x^\infty 6y\lambda e^{-\lambda y} dy \\
=(3x+1)(1-e^{-\lambda x}) +6xe^{-\lambda x} +\frac{6}{\lambda} e^{-\lambda x}\\
=3x+1+e^{-\lambda x}(3x+\frac{6}{\lambda }-1) \\</script></li>
<li><p>根据重期望公式, $E(E(Z|X))=\int_{-\infty}^\infty E(Z|X)p_X(x)$求解：</p>
</li>
</ol>
<p>$E(Z)=E(E(Z|X))=E[3X+1+e^{-\lambda X}(3X+\frac{6}{\lambda}-1)]$ </p>
<script type="math/tex; mode=display">
=3E(X)+1+\int_0^\infty \lambda e^{-2\lambda x} (3x+\frac{6}{\lambda}-1)dx\\
=\frac{3}{\lambda} +1+\frac{1}{2}\int_0^\infty 2\lambda e^{-2\lambda x}(3x+\frac{6}{\lambda}-1)dx\\
=\frac{3}{\lambda}+1+\frac{1}{2}(\frac{3}{2\lambda}+\frac{6}{\lambda}-1)=\frac{1}{2}+\frac{27}{4\lambda}</script><p>很显然，使用重期望公式来做这道题非常的方便简洁</p>
<h3 id="二维正态分布"><a href="#二维正态分布" class="headerlink" title="二维正态分布"></a>二维正态分布</h3><p>$N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)$ 的两个条件分布仍是正态分布，即</p>
<script type="math/tex; mode=display">
X|Y = y\sim N(g_1(y),\sigma_1^2(1-\rho^2))\\
其中：g_1(y)=E(X|Y=y) = \mu_1+\rho\frac{\sigma_1}{\sigma_2}(y-\mu_2)
\\~\\
Y|X = x\sim N(g_2(x),\sigma_2^2(1-\rho^2))\\
其中：g_2(x)=E(Y|X=x) =\mu_2+\rho\frac{\sigma_2}{\sigma_1}(x-\mu_1)</script><p>可见，在二维正态分布之中，一个变量的条件期望是另一个变量取值的线性函数，常称为一元线性回归方程。</p>
<h3 id="随机个随机变量和的数学期望"><a href="#随机个随机变量和的数学期望" class="headerlink" title="随机个随机变量和的数学期望"></a>随机个随机变量和的数学期望</h3><p>设 $X_1,X_2\cdots$ 为一列独立同分布的随机变量，随机变量N只取正整数值，且$N$ 与 ${X_n}$ 独立，证明它们的和的期望</p>
<script type="math/tex; mode=display">
E(\sum_{i=1}^N X_i) = E(X_1)E(N)</script><p>这里我引入一个N， 让 $N\sim p_N(n)$ </p>
<p>利用重期望公式，可以把 $E(\sum_{i=1}^N X_i)$写成：</p>
<script type="math/tex; mode=display">
E(\sum_{i=1}^N X_i) = E(E(\sum_{n=1}^N X_i| N))</script><p>进而，在N=n 的情况下，上式可写为：</p>
<script type="math/tex; mode=display">
E(E(\sum_{n=1}^N X_i| N)) =\sum_{n=1}^\infty E(\sum_{n=1}^n X_i| N=n)p_N(n)</script><p>我们又知道，$X<em>i$和$N$是独立的，所以 $\sum</em>{n=1}^n X_i $ 与N独立，所以条件期望可以转换成无条件期望</p>
<script type="math/tex; mode=display">
\sum_{n=1}^\infty E(\sum_{i=1}^n X_i) p_N(n)\\</script><p>我们知道期望和有限个求和符号是可以交换的，我们把括号中的求和提出，变成n。原式可以写成以下形式：</p>
<script type="math/tex; mode=display">
=\sum_{n=1}^\infty nE(X_1)p_N(n)=E(X_1)E(N)</script><p>将$E(X<em>1)$提出，剩下的 $\sum</em>{n=1}^\infty E(X_1)p_N(n)$可以写成是 $E(N)$ </p>
<h4 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h4><p>上面证明了和的期望，现在来证明和的方差。</p>
<p>证明 </p>
<script type="math/tex; mode=display">
Var(\sum_{i=1}^N(X_i)) = Var(N)[E(X_1)]^2+E(N)Var(X_1)</script><p>首先我们要知道一个公式： $Var(X)=E_Y(Var_X(X|Y))+Var_Y(E_X(X|Y))$</p>
<p>因此，原式 $Var(\sum_{i=1}^N(X_i))$ 可写为：</p>
<script type="math/tex; mode=display">
Var(\sum_{i=1}^N(X_i)) = Var_N(E_{X_1\cdots X_n}(\sum_{i=1}^NX_i|N))+E(Var(\sum_{i=1}^N X_i|N))</script><p> 我们将其设为 $I_1+I_2$</p>
<p>先来化简 $I_1$ ,可以将其看成是N的函数，</p>
<script type="math/tex; mode=display">
I_1=\sum_{n=1}^\infty (E)</script>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">从题目出发复习数据科学数学基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-10 09:54:47" itemprop="dateCreated datePublished" datetime="2021-04-10T09:54:47+08:00">2021-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-06-30 13:23:26" itemprop="dateModified" datetime="2021-06-30T13:23:26+08:00">2021-06-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="从题目出发复习数据科学数学基础"><a href="#从题目出发复习数据科学数学基础" class="headerlink" title="从题目出发复习数据科学数学基础"></a>从题目出发复习数据科学数学基础</h1><h1 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h1><h2 id="求卷积"><a href="#求卷积" class="headerlink" title="求卷积"></a>求卷积</h2><h2 id="求TF-IDF"><a href="#求TF-IDF" class="headerlink" title="求TF-IDF"></a>求TF-IDF</h2><h2 id="考虑结构风险的损失函数"><a href="#考虑结构风险的损失函数" class="headerlink" title="考虑结构风险的损失函数"></a>考虑结构风险的损失函数</h2><h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><h2 id="求矩阵的逆"><a href="#求矩阵的逆" class="headerlink" title="求矩阵的逆"></a>求矩阵的逆</h2><h2 id="求解线性方程组"><a href="#求解线性方程组" class="headerlink" title="求解线性方程组"></a>求解线性方程组</h2><h2 id="求-线性组合"><a href="#求-线性组合" class="headerlink" title="求 线性组合"></a>求 线性组合</h2><h2 id="求特征值与特征向量"><a href="#求特征值与特征向量" class="headerlink" title="求特征值与特征向量"></a>求特征值与特征向量</h2><h2 id="求新基坐标"><a href="#求新基坐标" class="headerlink" title="求新基坐标"></a>求新基坐标</h2><h2 id="求二次型的标准型"><a href="#求二次型的标准型" class="headerlink" title="求二次型的标准型"></a>求二次型的标准型</h2><h2 id="判断正定矩阵"><a href="#判断正定矩阵" class="headerlink" title="判断正定矩阵"></a>判断正定矩阵</h2><p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/11.png" style="zoom:80%;"></p>
<h2 id="标准正交化"><a href="#标准正交化" class="headerlink" title="标准正交化"></a>标准正交化</h2><p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/1.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/2.png" style="zoom:80%;"></p>
<p><strong>[a,b]即a与b的内积之意</strong></p>
<h1 id="度量与投影"><a href="#度量与投影" class="headerlink" title="度量与投影"></a>度量与投影</h1><h2 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h2><h3 id="范数的定义"><a href="#范数的定义" class="headerlink" title="范数的定义"></a>范数的定义</h3><p>设 $\mathbb V$ 是数域上 $\mathbb K$  的 n 维线性空间，那么函数 $||\cdot||: \mathbb V\rightarrow \mathbb R<del>,</del>x\rightarrow ||x||$   就是将 $x$ 映射为它的长度 $||x||\in \mathbb R$ ，并且满足非负性、齐次性和三角不等式。 </p>
<p>我们称$||x||$ 是向量 x 的向量函数，称定义了范数的线性空间 $\mathbb V$ 为赋范线性空间。</p>
<h3 id="几种常用的向量范数"><a href="#几种常用的向量范数" class="headerlink" title="几种常用的向量范数"></a>几种常用的向量范数</h3><h4 id="l-p-范数"><a href="#l-p-范数" class="headerlink" title="$l_p$ 范数"></a>$l_p$ 范数</h4><p>对于任意 $x = (x<em>1,x_2,\cdots,x_n)\in \mathbb R^n$ ，由 $||x||_p = (\sum</em>{i=1}^n |x_i|^p)\frac{1}{p}, 1\leq p&lt; \infty$ </p>
<p>定义的 $||\cdot||_p$ 是 $\mathbb R^n$  上的向量范数，称为 $p$ <strong>范数</strong> 或者 $l_p$<strong>范数</strong></p>
<ol>
<li>当 p = 1时，得到 <strong>1范数</strong> 或者 $l<em>1$ <strong>范数</strong> ，也称 <strong>Manhattan 范数</strong>  ： $||x||_1 =\sum</em>{i = 1}^n |x_i|$ </li>
<li>当 p = 2时，得到 <strong>2范数</strong> 或者 $l<em>2$ <strong>范数</strong>， 也称为<strong>欧几里得范数</strong> : $||x||_2 = \sqrt{\sum</em>{i=1}^n x_i^2}$ </li>
</ol>
<h4 id="l-infty-范数"><a href="#l-infty-范数" class="headerlink" title="$l_\infty $ 范数"></a>$l_\infty $ 范数</h4><p>当p取无线大的时候，是否存在这种范数呢？</p>
<p>对 $\forall x=(x<em>1,x_2,\cdots,x_n)\in \mathbb R^2$ ， 由 $||x||</em>\infty = \lim \limits_{p\rightarrow\infty} ||x||_p$ </p>
<p>也就是$||x||<em>\infty = \max</em>{i=1,\cdots,n}|x_i|$ </p>
<p>定义 $||\cdot||<em>\infty$ 是 $\mathbb R^n$ 上的向量范数，称为 $\infty$ 范数 或者 $l</em>\infty$ 范数。</p>
<h4 id="非向量范数"><a href="#非向量范数" class="headerlink" title="非向量范数"></a>非向量范数</h4><p>当 $0&lt;p&lt;1$ 时， 由 $||x||<em>p = (\sum</em>{i=1}^n|x_i|^p)$ 定义的 $||\cdot||_P $ 不是 $\mathbb R$ 上的向量范数</p>
<p>举一个特例就能证明。</p>
<h4 id="基数函数-l-0-范数"><a href="#基数函数-l-0-范数" class="headerlink" title="基数函数 $l_0$ 范数"></a>基数函数 $l_0$ 范数</h4><p>向量 $x$ 的基数函数定义为 $x$ 即 $card(x) = \sum_{i=1}^m \mathcal I(x_i \neq 0)$ </p>
<p>其中， $\mathcal I(x_i\neq 0)= \begin{cases}{1},x_i\neq 0\ 0, {x_i = 0}\end{cases}$</p>
<p>基数函数也被称为$l_0$ 范数，但是它并不满足范数定义的条件</p>
<h3 id="几种常见的矩阵范数"><a href="#几种常见的矩阵范数" class="headerlink" title="几种常见的矩阵范数"></a>几种常见的矩阵范数</h3><h4 id="矩阵1范数-列模"><a href="#矩阵1范数-列模" class="headerlink" title="矩阵1范数(列模)"></a>矩阵1范数(列模)</h4><p>矩阵的每一列上的元素<strong>绝对值</strong>先求和，再从中取个最大的，(列和最大)</p>
<h4 id="矩阵2范数-谱模"><a href="#矩阵2范数-谱模" class="headerlink" title="矩阵2范数(谱模)"></a>矩阵2范数(谱模)</h4><p>$||A||<em>2 = \max\limits</em>{X\neq0} \frac{||AX||<em>2}{||X||_2}=\sqrt{\lambda</em>{max}(A^TA)} =\sqrt{\max\limits_{1\leq i\leq n}|\lambda_i|}$ ,其中 $\lambda_i$为 $A^TA$ 的特征值。</p>
<p>也就是说求矩阵 $A^TA$ 的最大特征值的开方</p>
<h4 id="矩阵的无穷范数-行模"><a href="#矩阵的无穷范数-行模" class="headerlink" title="矩阵的无穷范数(行模)"></a>矩阵的无穷范数(行模)</h4><p>矩阵的每一行上的元素绝对值先求和，再从中取个最大的，（行和最大）</p>
<h3 id="求范数、无穷范数"><a href="#求范数、无穷范数" class="headerlink" title="求范数、无穷范数"></a>求范数、无穷范数</h3><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>求向量 $x=(-1,2,4)^T$ 的 0，1，2 和 $\infty$ 范数</p>
<p>$||x||_0 = 3$ 非0元素的个数</p>
<p>$||x||_1= |-1|+2+4 = 7$</p>
<p>$||x||_2 = \sqrt{|-1|^2+2^2+4^2} = \sqrt{21}$ </p>
<p>$||x||_\infty = max {|-1|,2,4}$ </p>
<h3 id="证明某函数为向量范数"><a href="#证明某函数为向量范数" class="headerlink" title="证明某函数为向量范数"></a>证明某函数为向量范数</h3><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>满足三个性质，即<strong>非负性、齐次性以及三角不等式</strong></p>
<p>注意了，当且仅当$x_i$ 全是0的时候，范数才等于零；如果$x_i$ 不为零式子却是0，那么这就不满足非负性</p>
<h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><h5 id="1"><a href="#1" class="headerlink" title="1"></a>1</h5><p>对任意的 $x = (x_1,x_2,x_3)^T\in \mathbb C^3$ ，试问如下实值函数是否构成向量范数?</p>
<ol>
<li>$|x_1|+|2x_2+x_3|$</li>
<li>$|x_1|+|2x_2|-5|x_3| $ </li>
</ol>
<p>要让函数构成向量范数，必须满足三个性质，即非负性、齐次性以及三角不等式</p>
<p>对于1</p>
<ul>
<li>非负性，易证</li>
<li>齐次性， 令 $c\in \mathbb C, |cx_1|+|2cx_2+cx_3|=|c|(|x_1|+|2x_2+x_3|)$ </li>
<li>三角不等式：$x = (x_1,x_2,x_3)^T,y = (y_1,y_2,y_2)^T \in \mathbb C^3$ , 则 $|x_1+y_1|+|2(x_2+y_2)+(x_3+y_3)|\leq |x_1|+|2x_2+x_3|+|y_1| + |2y_2+y_3|$ 即 x 的范式加上 y 的范式</li>
</ul>
<p>对于2</p>
<p>取 $x=(0,0,1)$ 则 $|0|+|2\times 0|-5|1| = -5 &lt; 0 $ 不满足非负性，所以2不是范范数</p>
<h2 id="证明某函数是内积"><a href="#证明某函数是内积" class="headerlink" title="证明某函数是内积"></a>证明某函数是内积</h2><h3 id="标准内积的定义："><a href="#标准内积的定义：" class="headerlink" title="标准内积的定义："></a>标准内积的定义：</h3><p>n维实向量空间 $\mathbb R^n$ 的<strong>标准内积</strong>(点积)<strong>是两个向量的对应元素乘积之和</strong>。</p>
<p>即： $<x,y> = x^Ty = \sum_{i=1}^n x_iy_i$  通常我们指内积都是这种标准内积</x,y></p>
<p>现在我们引申出内积的定义。设$\mathbb V$是数域上$\mathbb K$ 的 n 维线性空间，函数$&lt;\cdot,\cdot&gt;:\mathbb V\times \mathbb V\rightarrow \mathbb R $它把向量$x,y\in \mathbb V $   映射为一实数 $<x,y>\in \mathbb R$ 并满足以下几个条件 ，其中， $\forall \lambda \in \mathbb R$和向量 $x,y,z\in \mathbb V$ ,满足</x,y></p>
<ol>
<li>非负性 ：$ <x,x> \geq 0$ 当且仅当x=0的时候，$<x,x> =0$ </x,x></x,x></li>
<li>对称性：$<x,y>=<y,x>$</y,x></x,y></li>
<li>齐次性：$&lt;\lambda x,y&gt; = \lambda<x,y>$ </x,y></li>
<li>线性性：$<x+y,z>=<x,z>+<y,z>$ </y,z></x,z></x+y,z></li>
</ol>
<p>称$<x,y>$是向量 $x,y$的内积，称定义了内积的线性空间$mathbb V$ 为<strong>内积空间</strong>。 若内积是点积时，称定义了标准内积的线性空间为<strong>欧式空间</strong>。 </x,y></p>
<h2 id="四个基本子空间的计算"><a href="#四个基本子空间的计算" class="headerlink" title="四个基本子空间的计算"></a>四个基本子空间的计算</h2><h3 id="列空间-Col-A"><a href="#列空间-Col-A" class="headerlink" title="列空间 $Col(A)$"></a>列空间 $Col(A)$</h3><p>行空间是其列向量 ${a_1,a_2\cdots,a_n}$ 的所有<strong>线性组合的集合</strong>，它是 $\mathbb R^m$ 的一个子空间，用符号 $Col(A)$ 表示。有：</p>
<p>$Col(A)={y\in \mathbb R^m|y=\sum_{j=1}^n\alpha_ja_j,\alpha_j\in\mathbb R }=span{\alpha_1,\alpha_2,\cdots,\alpha_n }$ </p>
<h4 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h4><p>现有矩阵：$\begin{pmatrix} 1 &amp; -1 &amp; 0 \ 2 &amp; 4 &amp; 1 \ 4 &amp; 2 &amp; 1 \end{pmatrix}$ 求其列空间</p>
<ol>
<li><p><strong>矩阵列变换</strong> ： $\begin{pmatrix} 1 &amp; -1 &amp; 0 \ 2 &amp; 4 &amp; 1 \ 4 &amp; 2 &amp; 1 \end{pmatrix}=\begin{pmatrix} 1 &amp; 0 &amp; 0 \ 2 &amp; 1 &amp; 0 \ 4 &amp; 1 &amp; 0 \end{pmatrix}$ </p>
</li>
<li><p><strong>列公式</strong> : $Col(A)=\alpha_1(1,2,4)^T+\alpha_2(0,1,1)^T+\alpha_3(0,0,0)^T$ </p>
</li>
<li><strong>写成span形式：</strong> $=span{(1,2,4)^T,(0,1,1)^T}$</li>
</ol>
<h3 id="行空间-Row-A-Col-A-T"><a href="#行空间-Row-A-Col-A-T" class="headerlink" title="行空间$ Row(A)=Col(A^T)$"></a>行空间$ Row(A)=Col(A^T)$</h3><ol>
<li><strong>矩阵行变换: </strong> $\begin{pmatrix} 1 &amp; -1 &amp; 0 \ 2 &amp; 4 &amp; 1 \ 4 &amp; 2 &amp; 1 \end{pmatrix}=\begin{pmatrix} 1 &amp; -1 &amp; 0 \ 0 &amp; 6 &amp; 1 \ 0 &amp; 0 &amp; 0 \end{pmatrix}$ </li>
<li><strong>列公式：</strong> $Col(A^T)=\alpha_1(1,-1,0)^T+\alpha_2(0,6,1)^T+\alpha_3(0,0,0)^T$ </li>
<li><strong>写成span形式：</strong> $span{(1,-1,0)^T,(0,6,1)^T}$ </li>
</ol>
<h3 id="零空间-Null-A"><a href="#零空间-Null-A" class="headerlink" title="零空间 $Null(A)$"></a>零空间 $Null(A)$</h3><p>零空间是所有满足齐次线性方程组$Ax = 0$ 的解向量集合，它是$\mathbb R^n$ 的一个子空间，用符号</p>
<p>$Null (A) $表示，即有 $Null(A)={x\in \mathbb R^n|Ax=0}$ </p>
<ol>
<li>求解线性方程组 $Ax=0$ ，$\begin{pmatrix} 1 &amp; -1 &amp; 0 \ 2 &amp; 4 &amp; 1 \ 4 &amp; 2 &amp; 1 \end{pmatrix}x=\begin{pmatrix} 1 &amp; -1 &amp; 0 \ 0 &amp; 6 &amp; 1 \ 0 &amp; 0 &amp; 0 \end{pmatrix}x =0$ </li>
<li>解得$(x_1,x_2,x_3)^T =k (1,1,-6)^T$ </li>
<li><strong>写成span形式：</strong> $=span{(1,1,-6)^T}$ </li>
</ol>
<h3 id="左零空间-Null-A-T"><a href="#左零空间-Null-A-T" class="headerlink" title="左零空间 $Null(A^T)$"></a>左零空间 $Null(A^T)$</h3><p>左零空间是所有满足齐次线性方程组$A^Ty = 0$ 的解向量集合，它是$\mathbb R^m$ 的一个子空间，用符号</p>
<p>$Null (A^T) $表示，即有 $Null(A^T)={y\in \mathbb R^n|A^Ty=0}$ </p>
<ol>
<li>求解线性方程组 $A^Ty =\begin{pmatrix} 1 &amp; 2 &amp; 4 \ -1 &amp; 4 &amp; 2 \ 0 &amp; 1 &amp; 1 \end{pmatrix}y=0$</li>
<li>解得$(x_1,x_2,x_3)^T = k(2,1,-1)^T$ </li>
<li><strong>写成span形式</strong> $span{(2,1,-1)^T}$</li>
</ol>
<h2 id="求正交投影"><a href="#求正交投影" class="headerlink" title="求正交投影"></a>求正交投影</h2><p>设 $\mathbb V$ 是一向量空间，$\mathbb W\subseteq \mathbb V$ 是$\mathbb V$ 的一个子空间。如果线性映射$\pi:\mathbb V\rightarrow \mathbb W$ 满足 $\pi^2 =\pi\circ \pi = \pi$  则称 $\pi$为投影。</p>
<p>设$\pi$对应的矩阵$P<em>{\pi}$ ，显然$P</em>{\pi}$ 满足 $P^2<em>{\pi}=P</em>{\pi}$ ，称$P_\pi$为投影矩阵。</p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/3.png" style="zoom:80%;"></p>
<h3 id="到一维子空间"><a href="#到一维子空间" class="headerlink" title="到一维子空间"></a>到一维子空间</h3><p>设基底矩阵$B = [b]$，也就是这组基中仅有一个向量。</p>
<p>设$\mathbb R^n$ 的子空间$\mathbb W = Col(B)$, 我们想寻找一个点$\pi_\mathbb W(x)\in\mathbb W $最接近x。 </p>
<p>因为$\pi_\mathbb W(x)\in \mathbb W$，又 $W = Col (B) = span{b}$ </p>
<p>所以$\pi_\mathbb W(x)=\lambda b,\lambda\in \mathbb R$ </p>
<p>接下来，我们将逐步确定$\lambda,\pi<em>\mathbb W(x)$和投影矩阵$P</em>\pi$ </p>
<ol>
<li>确定 $\lambda$</li>
</ol>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/4.png" style="zoom:80%;"></p>
<ol>
<li>确定 $\pi_\mathbb W(x)$</li>
</ol>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/5.png" style="zoom:80%;"></p>
<ol>
<li>确定 $P_\pi$ </li>
</ol>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/6.png" style="zoom:80%;"></p>
<ol>
<li>求得投影： </li>
</ol>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/7.png" style="zoom:80%;"></p>
<h3 id="到一般子空间"><a href="#到一般子空间" class="headerlink" title="到一般子空间"></a>到一般子空间</h3><p>设$B = (b<em>1,\cdots, b_n)$ 是子空间$\mathbb U$ 的一个有序基底。任何$\mathbb U$ 上的投影$\pi</em>\mathbb U(x)$ 必须是U 中的一</p>
<p>个元素。故有$\pi<em>\mathbb U(x) = \sum</em>{i=1}^n\lambda_ib_i$</p>
<ol>
<li><strong>确定 $\lambda_1,\cdots,\lambda_n$</strong> </li>
</ol>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/8.png" style="zoom:80%;"></p>
<ol>
<li><strong>确定 $\pi_\mathbb W(x)$</strong></li>
</ol>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/9.png" style="zoom:80%;"></p>
<ol>
<li><strong>投影矩阵</strong>$P_\pi$ </li>
</ol>
<p>$P_\pi = B(B^TB)^{-1}B^T$</p>
<h4 id="例题：-1"><a href="#例题：-1" class="headerlink" title="例题："></a>例题：</h4><p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/10.png" style="zoom:80%;"></p>
<h3 id="到仿射空间"><a href="#到仿射空间" class="headerlink" title="到仿射空间"></a>到仿射空间</h3><p>给定一个仿射空间 $\mathbb L = x<em>0+\mathbb U$ 其中，$b_1,b_2$是$\mathbb U$ 的基向量，为了确定 x在$\mathbb L$ 上的正交投影 $\pi</em>\mathbb L(x)$ </p>
<p>我们将问题转化为我们知道如何解决的问题：投影到向量子空间上。为此，我们从x和$\mathbb L$ 中减去支撑点 $x_0$ ，所以 $\mathbb L-x_0=\mathbb U$恰好是向量子空间 $\mathbb U$ </p>
<p>现在，我们前面讨论过的在子空间上的投影，获得投影$\pi_\mathbb U(x-x_0)$ 。 最后我们通过添加$x_0$将该投影转换回 $\mathbb L$ ，这样我们就可以得到仿射空间 $\mathbb L$上的正交投影：</p>
<p>$\pi<em>\mathbb L(x) = x_0+\pi</em>\mathbb U(x-x_0)$ </p>
<h4 id="例题：-2"><a href="#例题：-2" class="headerlink" title="例题："></a>例题：</h4><p>求向量 $(1,1,1)^T$ 投影到仿射空间，$span{(1,-1,1)^T,(1,1,0)^T}+(1,2,1)^T$ 的正交投影</p>
<p>首先我要求 $\pi<em>\mathbb U(x-x_0)=\pi</em>\mathbb U(0,-1,0)$ </p>
<p>令 $B=\begin{pmatrix} 1 &amp; 1 \ -1 &amp; 1  \ 1 &amp; 0 \end{pmatrix}$ , $B^TB=\begin{pmatrix} 3&amp;0\0&amp;2\end{pmatrix}$ </p>
<p>$B^T(x-x_0)=\begin{pmatrix} 1&amp;-1&amp;1\1&amp;1&amp;0\end{pmatrix}\begin{pmatrix} 0&amp;-1&amp;0\end{pmatrix}^T =(1~~-1)^T$ </p>
<p>解方程组 $B^TB\lambda=B^Tx \Rightarrow \begin{pmatrix} 3&amp;0\0&amp;2\end{pmatrix}\lambda = \begin{pmatrix} 1\-1\end{pmatrix}$  解得 $\lambda=\begin{pmatrix} \frac{1}{3}\-\frac{1}{2}\end{pmatrix}$ </p>
<p>最后我们求 $\pi_\mathbb W(x-x_0)=B\lambda = \begin{pmatrix} -\frac{1}{6}\-\frac{5}{6}\\frac{1}{3}\end{pmatrix}$ </p>
<p>$\pi<em>\mathbb L(x)=x_0+\pi</em>\mathbb W(x-x_0)=\begin{pmatrix} \frac{5}{6}\\frac{7}{6}\\frac{4}{3}\end{pmatrix}$ </p>
<h1 id="线代基础"><a href="#线代基础" class="headerlink" title="线代基础"></a>线代基础</h1><p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/44.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/45.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/46.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/47.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/48.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/49.png" style="zoom:80%;"></p>
<h1 id="矩阵分解"><a href="#矩阵分解" class="headerlink" title="矩阵分解"></a>矩阵分解</h1><h2 id="求张成的子空间"><a href="#求张成的子空间" class="headerlink" title="求张成的子空间"></a>求张成的子空间</h2><p>设 $a<em>1,a_2,\cdots,a_r$ 是$\mathbb V$ 的一组向量，则这组向量所有可能的线性组合 $\sum</em>{k=1}^r\lambda_ka_k$  所成的集合是$\mathbb V$ 的一个子空间，称为由 $a_1,a_2,\cdots,a_r$ 张成的子空间，记作 $L(a_1,a_2,\cdots,a_r)$ 或者 $span(a_1,a_2,\cdots,a_r)$ 。 $(a_1,a_2,\cdots,a_r)$ 叫做$\mathbb V$ 的生成集。</p>
<p>换句话说，<strong>张成子空间</strong>就是由$x_1,x_2,…,x_r(r&gt;0)$中<strong>极大线性无关组作为基向量所构成的空间</strong>。因为其余任何向量都可以被这个无关组所表示，满足空间中向量的无穷性。</p>
<p>比如求 向量$(1,2,0)^T,(0,1,2)^T$  张成的子空间</p>
<p>首先确定两者线性无关，因此二者张成的子空间为 $((1,2,0)^T,(0,1,2)^T)$ </p>
<h2 id="求正交补空间"><a href="#求正交补空间" class="headerlink" title="求正交补空间"></a>求正交补空间</h2><p>设 $\mathbb S$ 和 $\mathbb T$ 是 $\mathbb R^n$ 的两个子空间。如果对于 $\forall v\in \mathbb S,\forall w\in \mathbb T$ 均有 $v^Tw = 0$ 我们说 $\mathbb S$垂直于 $\mathbb T$ 或者说 子空间$\mathbb S$ 和子空间 $\mathbb T$ 是<strong>正交的</strong>。</p>
<p>相对于正交，正交补是两个子空间更强的一种关系</p>
<p><strong>定义正交补： </strong> 设 $\mathbb V \in \mathbb R^n$ 是一个子空间,$\mathbb V$ 在$\mathbb R^n$ 中的正交补定义为集合：${w\in \mathbb R^n|v^Tw=0,\forall v\in\mathbb V}$ </p>
<p>记作$\mathbb V^{\bot}$ </p>
<p>已经知道了一个子空间，怎么求它的正交补呢？我们可以利用这个性质：</p>
<p>$Col(A^T)^\bot = Null(A) , Col(A)^\bot = Null(A^T)$  </p>
<p>因此$A= ((1,2,0)^T,(0,1,2)^T)$  的正交补就可以写作$ Null(A^T) = span{(4,-2,1)^T} $  </p>
<h2 id="LU-分解"><a href="#LU-分解" class="headerlink" title="LU 分解"></a>LU 分解</h2><p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/12.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/13.png" style="zoom:80%;"></p>
<p>判断是否能进行 LU 分解： 若矩阵的一阶顺序主子式为0，那么就不能分解。</p>
<p><strong>LU 分解指将</strong>$n\times n$ <strong>的矩阵A分解成两个三角矩阵的乘积</strong></p>
<p>其中， L 为 $n\times n$ 单位下三角矩阵(对角元素为1)，U 是  $n\times n$ 上三角矩阵。</p>
<p>从秩1分解的角度分析 $A=LU$ , 可以将 A 写成若干个 秩1矩阵和的形式：</p>
<script type="math/tex; mode=display">
A = l_1u_1+\cdots+l_ru_r = \sum_{i=1}^r l_iu_i</script><p>其中r为矩阵A的秩，若A是满秩，则 $r=n$ 。 $l_i$ 是 $L$ 的第$i$列；$u_i$ 是 $U$ 的第$i$行。 $l_iu_i$ 都是秩为1的矩阵，并且这个矩阵的前 $i-1$行和前$i-1$列的元素都是0</p>
<p>求矩阵A</p>
<script type="math/tex; mode=display">
A=\begin{pmatrix} 1 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 10 \end{pmatrix}</script><p>的LU分解</p>
<p>我们要像<strong>剥洋葱</strong>一样一层一层地分解矩阵A，同时要记得 L 的对角线都是1</p>
<ul>
<li>第一步</li>
</ul>
<p>令 $u<em>1$ 是 A 的第1行，$l_1$ 是A的第1列 除以 $u</em>{11}$ ,则：</p>
<script type="math/tex; mode=display">
l_1u_1 =\begin{pmatrix} 1 \\ 4 \\ 7  \end{pmatrix}\begin{pmatrix} 1 & 2 & 3\end{pmatrix} = \begin{pmatrix} 1 & 2 & 3 \\ 4 & 8 & 12 \\ 7 & 14 & 21 \end{pmatrix}\\~~\\
A-l_1u_1 = \begin{pmatrix} 1 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 10 \end{pmatrix}-\begin{pmatrix} 1 & 2 & 3 \\ 4 & 8 & 12 \\ 7 & 14 & 21 \end{pmatrix} = \begin{pmatrix} 0 & 0 & 0 \\ 0 & -3 & -6 \\ 0 & -6 & -11 \end{pmatrix}</script><ul>
<li>第二步</li>
</ul>
<p>令 $u<em>2$ 是 $A-l_1 u_1$ 的第2行，$l_2$ 是 $A-l_1u_1$ 的第二列除以$u</em>{22}$ </p>
<script type="math/tex; mode=display">
l_2u_2 =\begin{pmatrix} 0 \\ 1 \\ 2  \end{pmatrix}\begin{pmatrix} 0 & -3 & -6\end{pmatrix} = \begin{pmatrix} 0 & 0 & 0 \\ 0 & -3 & -6 \\ 0 & -6 & -12 \end{pmatrix}\\~~\\
A-l_1u_1-l_2u_2 = \begin{pmatrix} 0 & 0 & 0 \\ 0 & -3 & -6 \\ 0 & -6 & -11 \end{pmatrix}-\begin{pmatrix} 0 & 0 & 0 \\ 0 & -3 & -6 \\ 0 & -6 & -12 \end{pmatrix} = \begin{pmatrix} 0 & 0 & 0 \\ 0 & 0 & 0 \\ 0 & 0 & 1 \end{pmatrix}</script><ul>
<li>第三步</li>
</ul>
<p>令$u<em>3$ 是$A-l_1u_1-l_2u_2$  的第3行，$l_3$ 是 $A-l_1u_1-l_2u_2$ 的第3列除以$u</em>{33}$ 即</p>
<script type="math/tex; mode=display">
l_3 =\begin{pmatrix} 0 \\ 0 \\ 1  \end{pmatrix}, u_3 = \begin{pmatrix} 0 & 0 & 1 \end{pmatrix}</script><ul>
<li>第四步，我们要把$l_1,l_2,l_3$ 相加得到$L$ ,$u_1,u_2,u_3$ 相加得到$U$ </li>
</ul>
<script type="math/tex; mode=display">
A = LU = \begin{pmatrix} 1 & 0 & 0 \\ 4 & 1 & 0 \\ 7 & 2 & 1 \end{pmatrix}\begin{pmatrix} 1 & 2 & 3 \\ 0 & -3 & -6 \\ 0 & 0 & 1 \end{pmatrix}</script><h2 id="Cholesky-分解"><a href="#Cholesky-分解" class="headerlink" title="Cholesky 分解"></a>Cholesky 分解</h2><p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/14.png" style="zoom:80%;"></p>
<h2 id="QR分解"><a href="#QR分解" class="headerlink" title="QR分解"></a>QR分解</h2><p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/15.png" style="zoom:80%;"></p>
<h2 id="奇异值分解"><a href="#奇异值分解" class="headerlink" title="奇异值分解"></a>奇异值分解</h2><p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/16.png" style="zoom:80%;"></p>
<h2 id="谱分解"><a href="#谱分解" class="headerlink" title="谱分解"></a>谱分解</h2><p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/17.png" style="zoom:80%;"></p>
<h1 id="方程求解问题，最小二乘"><a href="#方程求解问题，最小二乘" class="headerlink" title="方程求解问题，最小二乘"></a>方程求解问题，最小二乘</h1><p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/18.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/19.png" style="zoom:80%;"></p>
<p>求解 $AA^T x = A^Tb \Rightarrow$ 方程组求解</p>
<p>QR 解法：</p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/50.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/51.png" style="zoom:80%;"></p>
<p>要求QR，为了凑分，我们只能先求正则化情况下的x，得到答案后，计算 R矩阵，令 $Rx =b^<em>$ 然后装模做样的求出 $b^</em>$, 其实只是我们反推得到的。</p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/21.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/22.png" style="zoom:80%;"></p>
<h1 id="矩阵微分"><a href="#矩阵微分" class="headerlink" title="矩阵微分"></a>矩阵微分</h1><p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/23.png" style="zoom:80%;"></p>
<p>求梯度：</p>
<p>首先，这让我们化简一下向量2-范数。$l_2 = \sqrt{\sum |x_i|^2}$ 那么对于这个矩阵，可以用 $\sqrt{(Ax+b-y)^T(Ax+b-y)}$ 来算</p>
<p>所以：</p>
<script type="math/tex; mode=display">
f(A) = \frac{1}{2}(Ax+b-y)^T(Ax+b-y)</script><p>由 $df = dTr(f) = Tr(df)$ 可得：</p>
<script type="math/tex; mode=display">
df = dTr(\frac{1}{2}(Ax+b-y)^T(Ax+b-y))\\~\\
df = Tr(d(\frac12(Ax+b-y)^T(Ax+b-y)))</script><p>我们知道这样一个公式： $df = Tr(A^Tdx)\Rightarrow \frac{\partial f}{\partial x}=(A^T)^T=A$</p>
<p>因此，我们如果要求 $\frac{\partial f}{\partial A}$, 也可以用这种方法</p>
<script type="math/tex; mode=display">
df = Tr(\frac{1}{2}d(Ax)^T(Ax+b-y)+\frac12(Ax+b-y)^Td(Ax))\\~\\
As ~~~Tr(A+B)=Tr(A)+Tr(B)\\~\\
df = Tr(\frac{1}{2}d(Ax)^T(Ax+b-y))~~+~~Tr(\frac12(Ax+b-y)^Td(Ax))\\~\\</script><p>因为我们知道$d(cA) = cd(A)$</p>
<p>所以前面这部分可以写成是：</p>
<script type="math/tex; mode=display">
df = Tr(\frac{1}{2}x^Td(A)^T(Ax+b-y))~~+~~Tr(\frac12(Ax+b-y)^Txd(A))\\~\\</script><p>又知道：$\frac{\partial}{\partial x^T}f = (\frac{\partial }{\partial x}f)^T$ ,所以这里 $x^T(Ax+b-y)$ 为f,</p>
<script type="math/tex; mode=display">
df = Tr(\frac{1}{2}(x^T(Ax+b-y)d(A))^T)~~+~~Tr(\frac12(Ax+b-y)^Txd(A))\\~\\
df = Tr(\frac{1}{2}(Ax+b-y)^Txd(A))~~+~~Tr(\frac12(Ax+b-y)^Txd(A))\\~\\
df = Tr(x(Ax+b-y)^TdA)</script><p>最后，我们求得：$df = (x(Ax+b-y)^T)^T=(Ax+b-y)x^T$</p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/24.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/25.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/26.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/27.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/28.png" style="zoom:80%;"></p>
<p>这里我们要说一些书本上的结论。</p>
<ol>
<li><script type="math/tex; mode=display">
\frac{\partial|A|}{\partial A}=(A^*)^T</script></li>
</ol>
<p>如果矩阵可逆，说明非奇异矩阵，那么：$\frac{\partial |A|}{\partial A}=|A|(A^{-1})^T$ </p>
<ol>
<li><script type="math/tex; mode=display">
d|A| = Tr(A^*dA)\\~\\
d|A| = Tr(|A|A^{-1}dA)</script></li>
</ol>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/29.png" style="zoom:80%;"></p>
<h1 id="优化基础1"><a href="#优化基础1" class="headerlink" title="优化基础1"></a>优化基础1</h1><p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/30.png" style="zoom:80%;"></p>
<p>Keyouxing</p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/31.png" style="zoom:80%;"></p>
<p>这是对可微函数的优化。首先就是要求出 $x^<em>$ 的梯度$\nabla f_0(x)^T$，同 时要检验 $\nabla f_0(x)^T(y-x)\geq 0$  成立则说明 x</em> 即最优点。</p>
<p>对于上面这题，首先要求 $\frac{\partial f}{\partial x}$ 然后把 pqx*都带入得到 $\nabla f_0(x)^T$ </p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/32.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/33.png" style="zoom:80%;"></p>
<p>目标是求 $\max{xy-f(x)}$ 然后 $xy-f(x)$ 的导数，并反解出x=g(y),再将其带入 $xy-f(x)$ 即可。</p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/34.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/35.png" style="zoom:80%;"></p>
<h1 id="优化II-对偶"><a href="#优化II-对偶" class="headerlink" title="优化II(对偶)"></a>优化II(对偶)</h1><p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/36.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/37.png" style="zoom:80%;"></p>
<p>a. 要证明目标函数(minimize), 和 不等式约束函数都是凸函数。</p>
<p>b. <img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/52.png" style="zoom:80%;"></p>
<p>对偶函数就是要求拉格朗日图形的下界。</p>
<p>c.slater条件，这里 定义域内部的点要满足 $g(x)$ 也就是 $\frac{x^2}y &lt;0 $ 成立</p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/53.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/38.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/39.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/40.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/41.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/42.png" style="zoom:80%;"></p>
<p><img src="/2021/04/10/%E4%BB%8E%E9%A2%98%E7%9B%AE%E5%87%BA%E5%8F%91%E5%A4%8D%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/43.png" style="zoom:80%;"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A6/" class="post-title-link" itemprop="url">计算机网络报告6</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-08 23:06:01" itemprop="dateCreated datePublished" datetime="2021-04-08T23:06:01+08:00">2021-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-25 04:31:26" itemprop="dateModified" datetime="2022-08-25T04:31:26+08:00">2022-08-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Exp6-DNS报文分析和基于UDP的Socket编程"><a href="#Exp6-DNS报文分析和基于UDP的Socket编程" class="headerlink" title="Exp6: DNS报文分析和基于UDP的Socket编程"></a>Exp6: DNS报文分析和基于UDP的Socket编程</h1><p>[TOC]</p>
<p>题解请直接跳转task1,task2,task3 </p>
<h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><ul>
<li>学习DNS协议 </li>
<li>学习使用Datagram Socket</li>
</ul>
<h2 id="二、实验任务"><a href="#二、实验任务" class="headerlink" title="二、实验任务"></a>二、实验任务</h2><ul>
<li>使用Wireshark分析DNS协议 </li>
<li>使用DatagramSocket和DatagramPacket编写代码</li>
</ul>
<h2 id="三、实验过程"><a href="#三、实验过程" class="headerlink" title="三、实验过程"></a>三、实验过程</h2><h3 id="3-1-Wireshark补充"><a href="#3-1-Wireshark补充" class="headerlink" title="3.1 Wireshark补充"></a>3.1 Wireshark补充</h3><ul>
<li>着色规则</li>
</ul>
<p>数据包列表区中不同的协议使用了不同的颜色区分。协议颜色标识定位在菜单栏View —&gt; Coloring Rules。如下所示:</p>
<p><img src="/2021/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A6/1.png" style="zoom:67%;"></p>
<ul>
<li><p>Packet Details Pane(<strong>数据包详细信息</strong>)</p>
<p>在数据包列表中选择指定数据包，在数据包详细信息中会显示数据包的所有详细信息内容。数据包详细信息面板是最重要的，用来查看协议中的每一个字段。各行信息分别为:</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1）Frame: 物理层的数据帧概况</span><br><span class="line">2）Ethernet II: 数据链路层以太⽹帧头部信息</span><br><span class="line">3）Internet Protocol Version 4: 互联⽹层IP包头部信息</span><br><span class="line">4）Transmission Control Protocol: 传输层的数据段头部信息，此处是TCP</span><br><span class="line">5）Hypertext Transfer Protocol: 应⽤层的信息，此处是HTTP协议</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A6/2.png" style="zoom:67%;"></p>
<h4 id="3-1-1-Wireshake过滤器"><a href="#3-1-1-Wireshake过滤器" class="headerlink" title="3.1.1 Wireshake过滤器"></a>3.1.1 Wireshake过滤器</h4><ol>
<li>捕获过滤器<br>捕获过滤器 是指wireshark⼀开始在抓包时，就确定要抓取哪些类型的包；对于不需要的，不进⾏<br>抓取。</li>
</ol>
<p><img src="/2021/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A6/3.png" style="zoom:67%;"></p>
<ol>
<li>显示过滤器<br>显示过滤器 是指wireshark对所有的包都进⾏抓取，当⽤户分析数据包的信息，便于筛选出需要的<br>数据包</li>
</ol>
<p><img src="/2021/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A6/4.png" style="zoom:67%;"></p>
<p><strong>捕获过滤器</strong> 是在⽤户开始任务之前就要使⽤的规则；⽽显示过滤器 是任务开始之后（⽆论是否已<br>完成）要使⽤的规则。</p>
<h4 id="3-1-2-显示过滤器语法和实例"><a href="#3-1-2-显示过滤器语法和实例" class="headerlink" title="3.1.2 显示过滤器语法和实例"></a>3.1.2 显示过滤器语法和实例</h4><p>这⾥我们将主要介绍显示过滤器的常⽤语法和实例，捕获过滤器类似（可百度进⾏了解）。</p>
<ol>
<li>⽐较操作符</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;(eq)　　&#x2F;&#x2F;等于，equal</span><br><span class="line">!&#x3D;(ne)　　&#x2F;&#x2F;不等于，no equal</span><br><span class="line">&lt;(lt)　　 &#x2F;&#x2F;⼩于，less than</span><br><span class="line">&gt;(gt)　　 &#x2F;&#x2F;⼤于，great than</span><br><span class="line">&gt;&#x3D;(ge)　　&#x2F;&#x2F;⼤于等于，great equal</span><br><span class="line">&lt;&#x3D;(le)　　&#x2F;&#x2F;⼩于等于，less equal</span><br><span class="line">&amp;&amp;　　&#x2F;&#x2F;逻辑“与”运算</span><br><span class="line">||　　&#x2F;&#x2F;逻辑“或”运算</span><br><span class="line">!　　 &#x2F;&#x2F;逻辑“⾮”运算</span><br></pre></td></tr></table></figure>
<ol>
<li>协议过滤</li>
</ol>
<p>⽐较简单，直接在过滤框中直接输⼊协议名即可。 注意：协议名称需要输⼊⼩写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tcp、ip、dhcp、oicq、ftp、ssl等等</span><br><span class="line">icmp &#x2F;&#x2F;只查看HTTP协议的数据包列表</span><br><span class="line">udp || icmp || dns　&#x2F;&#x2F;只显示udp、icmp、dns相关协议的数据包</span><br><span class="line">not arp 等于 !arp　　&#x2F;&#x2F;不显示arp协议的数据包</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A6/5.png" style="zoom:67%;"></p>
<ol>
<li>过滤IP地址</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ip.addr&#x3D;&#x3D;192.168.1.104　　&#x2F;&#x2F;只显示源&#x2F;⽬的IP为192.168.1.3的数据包</span><br><span class="line">ip.src&#x3D;&#x3D;1.1.1.1 &#x2F;&#x2F;只显示源IP为1.1.1.1的数据包</span><br><span class="line">not ip.src&#x3D;&#x3D;1.1.1.1　　 &#x2F;&#x2F;不显示源IP为1.1.1.1的数据包</span><br><span class="line">ip.src&#x3D;&#x3D;1.1.1.1 or ip.dst&#x3D;&#x3D;1.1.1.2　　&#x2F;&#x2F;只显示源IP为1.1.1.1或⽬的IP为1.1.1.2的数据包</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A6/6.png" style="zoom:67%;"></p>
<ol>
<li>过滤端⼝</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tcp.port eq 80　　 &#x2F;&#x2F;只显示源&#x2F;⽬的端⼝为80的数据包</span><br><span class="line">tcp.dstport&#x3D;&#x3D;80　　&#x2F;&#x2F;只显示⽬的端⼝为80的数据包</span><br><span class="line">tcp.srcport&#x3D;&#x3D;80 &#x2F;&#x2F;只显示源端⼝为80的数据包</span><br><span class="line">tcp.port &gt;&#x3D;1 and tcp.port&lt;&#x3D;80　　&#x2F;&#x2F;只显示源&#x2F;⽬的端⼝⼤于等于1，⼩于等于80的数据包</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A6/7.png" style="zoom:67%;"></p>
<ol>
<li>过滤协议参数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcp.flags.syn &#x3D;&#x3D; 0x02　　&#x2F;&#x2F;显示包含syn标志位的数据包</span><br><span class="line">http.request.method&#x3D;&#x3D;&quot;get&quot;　　&#x2F;&#x2F;显示http请求中method值为get的包</span><br></pre></td></tr></table></figure>
<p>tips：如图所示，在显示过滤器中输⼊规则时，会出现提示信息，可据此了解更多的协议过滤规则</p>
<p><img src="/2021/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A6/8.png" style="zoom:67%;"></p>
<ol>
<li>逻辑运算符为 and/or/not</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">过滤多个条件组合时，使⽤and&#x2F;or。</span><br><span class="line">⽐如获取IP地址为192.168.1.104的ICMP数据包表达式为ip.addr &#x3D;&#x3D; 192.168.1.104 and icmp</span><br></pre></td></tr></table></figure>
<h3 id="3-2-DNS协议"><a href="#3-2-DNS协议" class="headerlink" title="3.2 DNS协议"></a>3.2 DNS协议</h3><h4 id="3-2-1-DNS协议简介"><a href="#3-2-1-DNS协议简介" class="headerlink" title="3.2.1 DNS协议简介"></a>3.2.1 DNS协议简介</h4><p>识别主机有两种⽅式：主机名、IP地址。前者便于记忆(如www.baidu.com)，但路由器很难处理(主机名⻓度不定)；后者定⻓、有层次结构，便于路由器处理，但难以记忆。折中的办法就是建⽴IP地址与主机名间的映射，这就是域名系统DNS做的⼯作。DNS通常由其他应⽤层协议使⽤(如HTTP、SMTP、FTP)，将主机名解析为IP地址。<br>在本实验中，我们将仔细查看 DNS 报⽂的细节。</p>
<h4 id="3-2-2-DNS报⽂"><a href="#3-2-2-DNS报⽂" class="headerlink" title="3.2.2 DNS报⽂"></a>3.2.2 DNS报⽂</h4><ul>
<li>报⽂格式<br>DNS只有两种报⽂：查询报⽂、响应报⽂，两者有着相同格式，如下：</li>
</ul>
<p><img src="/2021/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A6/9.png" style="zoom:67%;"></p>
<ul>
<li>捕获的DNS报⽂</li>
</ul>
<p>考虑访问百度⻚⾯的⼀个操作，在浏览器输⼊<a href="http://www.baidu.com/index.html并回⻋，⾸先需要将URL(存放对象的服务器主机名和对象的路径名)解析成IP地址，具体步骤为：" target="_blank" rel="noopener">http://www.baidu.com/index.html并回⻋，⾸先需要将URL(存放对象的服务器主机名和对象的路径名)解析成IP地址，具体步骤为：</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1）同⼀台⽤户主机上运⾏着DNS应⽤的客户机端(如浏览器)</span><br><span class="line">2）从上述URL抽取主机名[www.baidu.com](http:&#x2F;&#x2F;www.baidu.com&#x2F;)，传给DNS应⽤的客户机端(浏览器)</span><br><span class="line">3）该DNS客户机向DNS服务器发送⼀个包含主机名的请求(DNS查询报⽂)</span><br><span class="line">4）该DNS客户机收到⼀份回答报⽂(DNS响应报⽂)，该报⽂包含该主机名对应的IP地址 182.61.200.7</span><br><span class="line">5）浏览器由该IP地址定位的HTTP服务器发送⼀个TCP链接</span><br></pre></td></tr></table></figure>
<p>⽤Wireshark捕获的DNS报⽂如下图，第⼀⾏是DNS查询报⽂，第⼆⾏是DNS响应报⽂。</p>
<p><img src="/2021/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A6/10.png" style="zoom:67%;"></p>
<h4 id="域名解析过程："><a href="#域名解析过程：" class="headerlink" title="域名解析过程："></a>域名解析过程：</h4><p>表示授权应答 域名解析总体可分为两大步骤：</p>
<p>第一个步骤是本机向本地域名服务器发出一个DNS请求报文，报文里携带需要查询的域名；第二个步骤是本地域名服务器向本机回应一个DNS响应报文，里面包含域名对应的IP地址或者别名等。</p>
<p>注意：第一个步骤从主机到本地域名服务器是<strong>递归查询</strong>；第二大步骤中采用的是<strong>迭代查询</strong>，其实是包含了很多小步骤的</p>
<p><strong>递归查询：</strong>本机向本地域名服务器发出一次查询请求，<strong>就静待最终的结果</strong>。如果本地域名服务器无法解析，自己会以DNS客户机的身份向其它域名服务器查询，直到得到最终的IP地址告诉本机</p>
<p><strong>迭代查询：</strong>本地域名服务器向根域名服务器查询，根域名服务器告诉它下一步到哪里去查询，然后它再去查，<strong>每次它都是以客户机的身份去各个服务器查询 </strong></p>
<h4 id="task1"><a href="#task1" class="headerlink" title="task1:"></a>task1:</h4><p><strong>内容： 根据Wireshark抓取的报⽂信息（例，下图所示示例），分别分析DNS查询报⽂和响应报⽂的组成结构，参考上⾯的报⽂格式指出报⽂的每个部分（如，头部区域等），请将实验结果附在实验报告中。</strong></p>
<p><img src="/2021/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A6/11.png" style="zoom:67%;"></p>
<h5 id="DNS-查询报文格式："><a href="#DNS-查询报文格式：" class="headerlink" title="DNS 查询报文格式："></a>DNS 查询报文格式：</h5><div class="table-container">
<table>
<thead>
<tr>
<th>报文部分</th>
<th>字段名</th>
</tr>
</thead>
<tbody>
<tr>
<td>头部</td>
<td>Transaction ID (事务ID) <br>这是DNS报文的ID标识，对于<strong>请求报文和其对应的应答报文</strong>，该字段的值是<strong>相同的</strong>。通过这个ID课题区分DNS 应答报文是对哪个请求进行相应的。</td>
</tr>
<tr>
<td>头部</td>
<td>Flags (标志) <br>其中，Flags又有很多子字段，在下面详细介绍。</td>
</tr>
<tr>
<td>头部</td>
<td>Questions(问题计数)</td>
</tr>
<tr>
<td>头部</td>
<td>Answer RRs(回答资源记录数)</td>
</tr>
<tr>
<td>头部</td>
<td>Authority RRs(权威名称能服务器计数)</td>
</tr>
<tr>
<td>头部</td>
<td>Additional RRs(附加资源记录数)</td>
</tr>
<tr>
<td>问题部分</td>
<td>Queries (查询问题区域)</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Flags</strong> 这个字段是一串二进制编码，用来标志该请求报文的一些属性和窗台。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Flags: 0x0100 Standard query</span><br><span class="line">    0... .... .... .... &#x3D; Response: Message is a query</span><br><span class="line">    .000 0... .... .... &#x3D; Opcode: Standard query (0)</span><br><span class="line">    .... ..0. .... .... &#x3D; Truncated: Message is not truncated</span><br><span class="line">    .... ...1 .... .... &#x3D; Recursion desired: Do query recursively</span><br><span class="line">    .... .... .0.. .... &#x3D; Z: reserved (0)</span><br><span class="line">    .... .... ...0 .... &#x3D; Non-authenticated data: Unacceptable</span><br></pre></td></tr></table></figure>
<p>这个Flags字段里面一共有6个子字段：</p>
<ul>
<li><strong>Response:  </strong> 查询请求/响应的标志信息。 0代表查询请求，1代表响应请求，这里是0</li>
<li><strong>Opcode:</strong> 操作码。 0代表标准查询；1代表反响查询； 2代表服务器状态请求。</li>
<li><strong>Truncated: </strong> 表示是否被截断。 1代表响应已超过512字节并已经被截断，且只返回前面512个字节</li>
<li><strong>Recursion Desired: </strong> 期望递归。 该字段能在一个查询中设置，并在响应中返回。 该标志告诉名称服务器必须处理这个查询，这种方式被称为一个递归查询。如果该位为 0，且被请求的名称服务器没有一个授权回答，它将返回一个能解答该查询的其他名称服务器列表。这种方式被称为迭代查询。</li>
<li><strong>Z: </strong> 保留字段，在请求和响应报文中，值必须为0</li>
<li><strong>Non-authenticated data: Unacceptable：</strong>未经认证的数据；0 代表服务器已经进行了相关 DNSSEC 数字签名的验证 1 代表为服务器并未进行相关 DNSSEC 数字签名的验证</li>
</ul>
<p>事实上，Flags字段还有其他几个子字段：</p>
<ul>
<li><strong>Authoritative Answer</strong> 表示授权应答。 0代表 应答服务器不是该域名的权威解析服务器，1代表应答服务器是该域名的权威解析服务器。</li>
<li><strong>rcode</strong>返回码字段，表示响应的差错状态。不同的值代表了不同的错误。</li>
</ul>
<p><strong>Queries</strong> 查询问题区域：</p>
<p>该部分是用来显示 DNS 查询请求的问题，通常只有一个问题。该部分包含正在进行的查询信息，包含查询名（被查询主机名字）、查询类型、查询类。</p>
<p>比如说这是一个我查询 CSDN 时候捕捉到的DNS报文中的Queries部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Queries																		&#x2F;&#x2F;问题部分</span><br><span class="line">    www.csdn.net: type AAAA, class IN</span><br><span class="line">        Name: www.csdn.net								&#x2F;&#x2F;被查询的主机名字</span><br><span class="line">        [Name Length: 12]									&#x2F;&#x2F;名字长度</span><br><span class="line">        [Label Count: 3]					</span><br><span class="line">        Type: AAAA (IPv6 Address) (28)		&#x2F;&#x2F;查询类型，这里查询的是 IPv6 的地址</span><br><span class="line">        Class: IN (0x0001)								&#x2F;&#x2F;查询类字段，这里是互联网地址</span><br></pre></td></tr></table></figure>
<p>注意，DNS响应报文中的 Type类型要和查询报文中的Type类型保持一致。</p>
<h5 id="DNS-响应报文格式："><a href="#DNS-响应报文格式：" class="headerlink" title="DNS 响应报文格式："></a>DNS 响应报文格式：</h5><p>DNS响应报文的头部、查询问题区域结构基本和响应报文一致。并且一些查询主机的名字、查询类型等信息也需要保持一致。但是比起查询报文，响应报文多了一个资源记录部分：</p>
<p>资源记录部分是指 DNS 报文格式中的最后三个字段，包括<strong>Answers (回答问题区域)字段</strong>、<strong>Authoritative nameservers(权威名称服务器区域)字段</strong>、<strong>Additional records(附加信息区域)字段</strong>。这三个字段均采用一种称为资源记录的格式。 </p>
<p>这里我分析的是访问百度新闻的 DNS 响应报文。</p>
<p><strong>Answers 字段</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Answers</span><br><span class="line">    log.news.baidu.com: type CNAME, class IN, cname news.n.shifen.com # 资源记录部分</span><br><span class="line">        Name: log.news.baidu.com																			# 域名字段</span><br><span class="line">        Type: CNAME (Canonical NAME for an alias) (5)									# 类型字段，这里是CNAME</span><br><span class="line">        Class: IN (0x0001)				# 类字段</span><br><span class="line">        Time to live: 5483 (1 hour, 31 minutes, 23 seconds)# 生存时间</span><br><span class="line">        Data length: 16	#数据长度</span><br><span class="line">        CNAME: news.n.shifen.com# 资源数据，这里是 CNAME的信息</span><br></pre></td></tr></table></figure>
<p><strong>Authoritative字段</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Authoritative nameservers</span><br><span class="line">    n.shifen.com: type SOA, class IN, mname ns1.n.shifen.com	#资源记录部分</span><br><span class="line">        Name: n.shifen.com	</span><br><span class="line">        Type: SOA (Start Of a zone of Authority) (6)# 类型字段，这里是 SOA类型</span><br><span class="line">        Class: IN (0x0001)	#类字段</span><br><span class="line">        Time to live: 234 (3 minutes, 54 seconds)</span><br><span class="line">        Data length: 45</span><br><span class="line">        Primary name server: ns1.n.shifen.com 	# 该域名对应的权威名称服务器的名称</span><br><span class="line">        Responsible authority&#39;s mailbox: baidu_dns_master.baidu.com</span><br><span class="line">        Serial Number: 2104090020</span><br><span class="line">        Refresh Interval: 5 (5 seconds)</span><br><span class="line">        Retry Interval: 5 (5 seconds)</span><br><span class="line">        Expire limit: 2592000 (30 days)</span><br><span class="line">        Minimum TTL: 3600 (1 hour)</span><br></pre></td></tr></table></figure>
<p>在这里我们要了解一下 类型字段中 CNAME 类型和A类型的区别：</p>
<p>A类型即  Address，也是用来指定主机名（或域名）对应的IP地址记录。用户可以将该域名下的网站服务器指向到自己的web server上。</p>
<p>CNAME类型是 别名记录，也就是说，这种记录允许多个名字映射到另外一个域名。通常用于同时提供WWW和MAIL服务的计算机。例如，有一台计算机名为“host.mydomain.com”（A记录）。它同时提供WWW和MAIL服务，为了便于用户访问服务。可以为该计算机设置两个别名（CNAME）：WWW和MAIL。这两个别名的全称就<code>http://www.mydomain.com/</code>和<code>mail.mydomain.com</code>。实际上他们都指向 <code>host.mydomain.com</code></p>
<p>在 Authoritative 字段中的类型字段，这个报文中现实的是 SOA类型，这代表授权起始点 (SOA) 记录会提供有关域和相应托管区域的信息。此外，还有NS记录类型，会标识托管区域的名称服务器。NS 记录的值为名称服务器的域名。</p>
<h3 id="3-3-基于UDP的Socket编程"><a href="#3-3-基于UDP的Socket编程" class="headerlink" title="3.3 基于UDP的Socket编程"></a>3.3 基于UDP的Socket编程</h3><h4 id="3-3-1-什么是Socket"><a href="#3-3-1-什么是Socket" class="headerlink" title="3.3.1 什么是Socket"></a>3.3.1 什么是Socket</h4><ul>
<li>简单来说是⼀种地址和端⼝的结合描述协议。</li>
<li>TCP/IP协议的相关API的总称、是⽹络API的集合实现，涵盖了TCP和UDP。</li>
<li>UDP是⼀种⽤户报协议，⼜称为⽤户数据报⽂协议，是⼀个简单的⾯向数据报的传输层协议。</li>
<li>在本实验中，我们将重点学习基于UDP的Socket编程。</li>
</ul>
<h4 id="3-3-2-UDP核⼼API"><a href="#3-3-2-UDP核⼼API" class="headerlink" title="3.3.2 UDP核⼼API"></a>3.3.2 UDP核⼼API</h4><ul>
<li>DatagramSocket</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">⽤于接收与发送UDP的类。</span><br><span class="line">负责发送某⼀个UDP包，或者接收UDP包。</span><br><span class="line">DatagramSocket() &#x2F;&#x2F;创建简单实例，不指定端⼝与ip</span><br><span class="line">DatagramSocket(int port) &#x2F;&#x2F;创建监听固定端⼝的实例</span><br><span class="line">DatagramSocket(int port，InetAddress localAddr) &#x2F;&#x2F;创建固定端⼝指定ip的实例</span><br><span class="line">receive(DatagramPacket d) &#x2F;&#x2F;接收</span><br><span class="line">send(DatagramPack d) &#x2F;&#x2F;发送</span><br><span class="line">setSoTimeout(int timeout) &#x2F;&#x2F;设置超时、毫秒</span><br></pre></td></tr></table></figure>
<ul>
<li>DatagramPacket</li>
</ul>
<p>⽤于报⽂处理。<br>将byte数组、⽬标地址、⽬标端⼝等数据包装成报⽂或者将报⽂拆卸成byte数组。<br>是UDP的发送实体，也是接收实体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DatagramPacket(byte[] buf,int offset,int length、InetAddress address,int</span><br><span class="line">port)</span><br><span class="line">DatagramPacket(byte[] buf,int offset,int length、SocketAddress address)</span><br><span class="line">setData(byte[] buf ,int offset,int length)</span><br><span class="line">setData(byte[] buf)</span><br><span class="line">setLength(int length)</span><br><span class="line">getData()、getIffset()、getLength()</span><br><span class="line">setAddress(InetAddress iddrr)、setPort(int port)</span><br><span class="line">getAddress()、getPort()</span><br><span class="line">setSocketAddress(SocketAddress address)</span><br><span class="line">getSocketAddress()</span><br></pre></td></tr></table></figure>
<h4 id="3-3-3-小试牛刀-UDP传输案例"><a href="#3-3-3-小试牛刀-UDP传输案例" class="headerlink" title="3.3.3 小试牛刀: UDP传输案例"></a>3.3.3 小试牛刀: UDP传输案例</h4><p>UDP不分服务器端和客户端，这⾥为了更好地表示，采⽤了发送者和接收者的说法</p>
<h4 id="task2"><a href="#task2" class="headerlink" title="task2:"></a>task2:</h4><p><strong>内容：补充完整UDPSearcher类，并运⾏UDPProvider和UDPSearcher，请将实验结果附在实验报告中</strong></p>
<p>首先， TCP是面向连接的，且为两个端系统之间的数据流动提供可靠的字节流通道。而UDP是无连接的，从一个端系统向另一个端系统发送独立的数据分组，不对交付提供任何保证。</p>
<p>这个小程序的功能就是接收我们的学号并返回学号的长度。我将利用多线程来分别启动 UDPProvider和UDPSearcher。</p>
<ul>
<li>编写UDPProvider类 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPProvider</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Provider Started"</span>);</span><br><span class="line"><span class="comment">// 选择⼀个端⼝⽤于数据接收</span></span><br><span class="line">        DatagramSocket datagramSocket = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//首先在 9091端口开辟一个 Provider</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            datagramSocket = <span class="keyword">new</span> DatagramSocket(<span class="number">9091</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      <span class="comment">//接收送到这个端口来的数据包</span></span><br><span class="line">        DatagramPacket receivePack = <span class="keyword">new</span> DatagramPacket(buf, buf.length);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            datagramSocket.receive(receivePack);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//从数据包中读取发送者的端口号、地址、以及学号的长度</span></span><br><span class="line">        String ip = receivePack.getAddress().getHostAddress();</span><br><span class="line">        <span class="keyword">int</span> port = receivePack.getPort();</span><br><span class="line">        <span class="keyword">int</span> len = receivePack.getLength();</span><br><span class="line">			<span class="comment">// 将 学号从 Bytes[] 转换成 String 类型</span></span><br><span class="line">        String data = <span class="keyword">new</span> String(receivePack.getData(), <span class="number">0</span>, len);</span><br><span class="line">      <span class="comment">//打印</span></span><br><span class="line">        System.out.println(<span class="string">"receive from ip: "</span> + ip + <span class="string">"\tport: "</span> + port +</span><br><span class="line">                <span class="string">"\tdata: "</span> + data);</span><br><span class="line"><span class="comment">//回送数据</span></span><br><span class="line">      <span class="comment">// 编写返回数据的格式</span></span><br><span class="line">        String responseData = <span class="string">"receive data length = "</span> + len;</span><br><span class="line">        <span class="keyword">byte</span>[] responseDataBytes = responseData.getBytes();</span><br><span class="line">      <span class="comment">//编写返回包的信息</span></span><br><span class="line">        DatagramPacket responsePacket = <span class="keyword">new</span> DatagramPacket(</span><br><span class="line">                responseDataBytes,</span><br><span class="line">                responseDataBytes.length,</span><br><span class="line">                receivePack.getAddress(),</span><br><span class="line">                receivePack.getPort()</span><br><span class="line">        );</span><br><span class="line">      <span class="comment">// 会送数据包</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            datagramSocket.send(responsePacket);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Provider finished"</span>);</span><br><span class="line">        datagramSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编写UDPSearcher </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPSearcher</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Searcher Started"</span>);</span><br><span class="line"><span class="comment">// 搜索⽅不需要指定监听端⼝</span></span><br><span class="line">        DatagramSocket datagramSocket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            datagramSocket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line">        String sendData = <span class="string">"10195501423"</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] sendBytes = sendData.getBytes();</span><br><span class="line">        System.out.println(Arrays.toString(sendBytes));</span><br><span class="line"><span class="comment">// todo 请补充完sendPack,发送⾄localhost：9091</span></span><br><span class="line">        DatagramPacket sendPack = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//DatagramPacket包含四个字段，送出的信息(Bytes[]类型)、送出信息的长度，地址和端口</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sendPack = <span class="keyword">new</span> DatagramPacket(sendBytes,sendBytes.length, InetAddress.getLocalHost(),<span class="number">9091</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            datagramSocket.send(sendPack);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收回送数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        DatagramPacket receivePack = <span class="keyword">new</span> DatagramPacket(buf, buf.length);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            datagramSocket.receive(receivePack);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//从接受到的包中提取ip、端口和长度。</span></span><br><span class="line">        String ip = receivePack.getAddress().getHostAddress();</span><br><span class="line">        <span class="keyword">int</span> port = receivePack.getPort();</span><br><span class="line">        <span class="keyword">int</span> len = receivePack.getLength();</span><br><span class="line">        String data = <span class="keyword">new</span> String(receivePack.getData(), <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(<span class="string">"receive from ip: "</span> + ip + <span class="string">"\tport: "</span> + port +</span><br><span class="line">                <span class="string">"\tdata: "</span> + data);</span><br><span class="line">        System.out.println(<span class="string">"Searcher finished"</span>);</span><br><span class="line">        datagramSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">// 创建两个线程实例，分别调用。</span></span><br><span class="line">        Thread provider = <span class="keyword">new</span> Thread(<span class="keyword">new</span> UDPProvider());</span><br><span class="line">        Thread sercher = <span class="keyword">new</span> Thread(<span class="keyword">new</span> UDPSearcher());</span><br><span class="line"></span><br><span class="line">        provider.start();</span><br><span class="line">        sercher.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2021/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A6/12.png" style="zoom:67%;"></p>
<h4 id="task3"><a href="#task3" class="headerlink" title="task3:"></a>task3:</h4><p><strong>内容：改写UDPProvider和UDPSearcher以完成下述功能，请将实验结果附在实验报告中：</strong></p>
<ul>
<li>⼴播地址：255.255.255.255</li>
<li>现需完成如下场景的设计：<ul>
<li>UDPSearcher现将UDP包发送⾄⼴播地址的9091号端⼝（这表示该UDP包将会被⼴播⾄局域⽹下所有主机的对应端⼝）</li>
<li>如果有UDPProvider在监听，解析接受的UDP包，通过解析其中的data得到要回送的端⼝号，并将⾃⼰的⼀些信息写回，UDPSearcher接收到UDPProvider的消息后打印出来。</li>
</ul>
</li>
<li>现提供发送消息的格式：<ul>
<li>UDPSearcher请使⽤如下buildWithPort构建消息，port在实验中指定为30000</li>
<li>UDPProvider请使⽤如下parsePort解析收到的消息并得到要回写的端⼝号，然后⽤buildWithTag构建消息，tag可以是<code>String tag =UUID.randomUUID().toString();</code>，然后回送数据。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG_HEADER = <span class="string">"special tag:"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PORT_HEADER = <span class="string">"special port:"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">buildWithPort</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PORT_HEADER + port;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parsePort</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data.startsWith(PORT_HEADER)) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">                    Integer.parseInt(data.substring(PORT_HEADER.length()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">buildWithTag</span><span class="params">(String tag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> TAG_HEADER + tag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">parseTag</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data.startsWith(TAG_HEADER)) &#123;</span><br><span class="line">            <span class="keyword">return</span> data.substring(TAG_HEADER.length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改过的UDPProvider:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPProvider</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Provider Started"</span>);</span><br><span class="line"><span class="comment">// 选择⼀个端⼝⽤于数据接收</span></span><br><span class="line">        DatagramSocket datagramSocket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            datagramSocket = <span class="keyword">new</span> DatagramSocket(<span class="number">9091</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        DatagramPacket receivePack = <span class="keyword">new</span> DatagramPacket(buf, buf.length);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            datagramSocket.receive(receivePack);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取得 新的 port</span></span><br><span class="line">        <span class="keyword">int</span> len = receivePack.getLength();</span><br><span class="line">        String newPort = <span class="keyword">new</span> String(receivePack.getData(), <span class="number">0</span>, len);</span><br><span class="line">        <span class="keyword">int</span> port = MessageUtil.parsePort(newPort);</span><br><span class="line">        System.out.println(port);</span><br><span class="line">        String tag =UUID.randomUUID().toString();</span><br><span class="line">        String data = MessageUtil.buildWithTag(tag);</span><br><span class="line">        <span class="comment">//取得 新的ip</span></span><br><span class="line">        String newIP = receivePack.getAddress().getHostAddress();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"UDPProvider receive from ip: "</span> + newIP + <span class="string">"\tport: "</span> + port +</span><br><span class="line">                <span class="string">"\tdata: "</span> + <span class="keyword">new</span> String(receivePack.getData(), <span class="number">0</span>, len));</span><br><span class="line"><span class="comment">//回送数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] responseDataBytes = data.getBytes();</span><br><span class="line">        DatagramPacket responsePacket = <span class="keyword">new</span> DatagramPacket(</span><br><span class="line">                responseDataBytes,</span><br><span class="line">                responseDataBytes.length,</span><br><span class="line">                receivePack.getAddress(),</span><br><span class="line">                port</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            datagramSocket.send(responsePacket);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Provider finished"</span>);</span><br><span class="line">        datagramSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改过的UDPSearcher:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPSearcher</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Searcher Started"</span>);</span><br><span class="line"><span class="comment">// 搜索⽅不需要指定监听端⼝</span></span><br><span class="line">        DatagramSocket datagramSocket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            datagramSocket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line">        String sendData = MessageUtil.buildWithPort(<span class="number">30000</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] sendBytes = sendData.getBytes();</span><br><span class="line"></span><br><span class="line"><span class="comment">// todo 请补充完sendPack,发送⾄localhost：9091</span></span><br><span class="line">        DatagramPacket sendPack = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sendPack = <span class="keyword">new</span> DatagramPacket(sendBytes,sendBytes.length,InetAddress.getByName(<span class="string">"255.255.255.255"</span>),<span class="number">9091</span>);</span><br><span class="line">            datagramSocket.send(sendPack);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收回送数据</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            datagramSocket = <span class="keyword">new</span> DatagramSocket(<span class="number">30000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        DatagramPacket receivePack = <span class="keyword">new</span> DatagramPacket(buf, buf.length);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            datagramSocket.receive(receivePack);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        String ip = receivePack.getAddress().getHostAddress();</span><br><span class="line">        <span class="keyword">int</span> port = receivePack.getPort();</span><br><span class="line">        <span class="keyword">int</span> len = receivePack.getLength();</span><br><span class="line">        String data = <span class="keyword">new</span> String(receivePack.getData(), <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(<span class="string">"UDPSearcher receive from ip: "</span> + ip + <span class="string">"\tport: "</span> + port +</span><br><span class="line">                <span class="string">"\tdata: "</span> + data);</span><br><span class="line">        System.out.println(<span class="string">"Searcher finished"</span>);</span><br><span class="line">        datagramSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2021/04/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A6/13.png" style="zoom:67%;"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/04/07/docker%E5%9F%BA%E7%A1%801/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/07/docker%E5%9F%BA%E7%A1%801/" class="post-title-link" itemprop="url">docker基础1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-07 14:12:52" itemprop="dateCreated datePublished" datetime="2021-04-07T14:12:52+08:00">2021-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-08 15:46:36" itemprop="dateModified" datetime="2022-05-08T15:46:36+08:00">2022-05-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="docker基础1"><a href="#docker基础1" class="headerlink" title="docker基础1"></a>docker基础1</h1><h2 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h2><p>因为我在博客：<a href="https://jasonxqh.github.io/2020/06/30/Linux基础/">Linux基础</a> 中详细介绍了一些基本命令，因此这里只展示summary的内容。</p>
<p>在docker中运行 ubuntu:</p>
<p><code>docker run ubuntu</code> ，会自动监测是否存在 ubuntu 容器，没有的话会去 docker hub 拉去该容器。</p>
<p>然后我们还要运行 <code>docker run -it ubuntu</code> 才能启动。</p>
<h3 id="Managing-packages"><a href="#Managing-packages" class="headerlink" title="Managing packages"></a>Managing packages</h3><ul>
<li>apt update</li>
<li>apt list</li>
<li>apt install nano</li>
<li>apt remove nano<h3 id="Navigating-the-file-system"><a href="#Navigating-the-file-system" class="headerlink" title="Navigating the file system"></a>Navigating the file system</h3></li>
</ul>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/1.png" style="zoom:100%;"></p>
<h3 id="Manipulating-files-and-directories"><a href="#Manipulating-files-and-directories" class="headerlink" title="Manipulating files and directories"></a>Manipulating files and directories</h3><p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/2.png" style="zoom:100%;"></p>
<h3 id="Editing-and-viewing-files"><a href="#Editing-and-viewing-files" class="headerlink" title="Editing and viewing files"></a>Editing and viewing files</h3><p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/3.png" style="zoom:100%;"></p>
<h3 id="Searching-for-text"><a href="#Searching-for-text" class="headerlink" title="Searching for text"></a>Searching for text</h3><p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/4.png" style="zoom:100%;"></p>
<h3 id="Finding-files-and-directories"><a href="#Finding-files-and-directories" class="headerlink" title="Finding files and directories"></a>Finding files and directories</h3><p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/5.png" style="zoom:100%;"></p>
<h3 id="Managing-environment-variables"><a href="#Managing-environment-variables" class="headerlink" title="Managing environment variables"></a>Managing environment variables</h3><p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/6.png" style="zoom:100%;"></p>
<h3 id="Managing-processes"><a href="#Managing-processes" class="headerlink" title="Managing processes"></a>Managing processes</h3><p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/7.png" style="zoom:100%;"></p>
<h3 id="Managing-users-and-groups"><a href="#Managing-users-and-groups" class="headerlink" title="Managing users and groups"></a>Managing users and groups</h3><p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/8.png" style="zoom:100%;"></p>
<h3 id="File-permissions"><a href="#File-permissions" class="headerlink" title="File permissions"></a>File permissions</h3><p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/9.png" style="zoom:100%;"></p>
<h2 id="Building-Images"><a href="#Building-Images" class="headerlink" title="Building Images"></a>Building Images</h2><p>在这一章，我们要学习</p>
<ul>
<li>创建 Docker文件</li>
<li>对images 进行版本控制</li>
<li>共享 images</li>
<li>保存、加载images</li>
</ul>
<h3 id="Images-and-Containers"><a href="#Images-and-Containers" class="headerlink" title="Images and Containers"></a>Images and Containers</h3><p>学习博客：<a href="https://www.jianshu.com/p/2a0aaf76734a?utm_campaign=hugo" target="_blank" rel="noopener">https://www.jianshu.com/p/2a0aaf76734a?utm_campaign=hugo</a></p>
<p>首先我们要了解 Images 和 Containers的区别。</p>
<h4 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h4><p>镜像（Image）就是一堆<strong>只读层</strong>（read-only layer）的统一视角，下面的这张图能够帮助读者理解镜像的定义。</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/11.png" style="zoom:100%;"></p>
<p>它包含了：</p>
<ul>
<li>A cut-down OS</li>
<li>Third-party libraries</li>
<li>Application files</li>
<li>Environment variables</li>
</ul>
<p>从左边我们看到了多个只读层，它们重叠在一起。除了最下面一层，其它层都会有一个指针指向下一层。这些层是Docker内部的实现细节，并且能够 在主机（运行Docker的机器）的文件系统上访问到。统一文件系统（union file system）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。 我们可以在图片的右边看到这个视角的形式。</p>
<h4 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h4><p>容器（container）的定义和镜像（image）几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。</p>
<p>Container(容器)则像是我们开的虚拟机一样，它提供了：</p>
<ul>
<li>An isolated environment</li>
<li>Can be stopped &amp; restart</li>
<li>Container只是一个进程！但是它是一个特殊的进程，因为他有Image提供的自己的文件系统</li>
</ul>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/12.png" style="zoom:100%;"></p>
<p><strong>要点：容器 = 镜像 + 可读层。并且容器的定义并没有提及是否要运行容器</strong></p>
<p>综上我们可以这样来画出 Container和Images 的示意图：</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/10.png" style="zoom:100%;"></p>
<p>如果我们在两个终端分别运行 ubuntu，会发现他们的ID是不一样的，而且它们所属的文件系统(容器)也是不一样的。因此它们互相独立，不能访问对方的文件</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/13.png" style="zoom:100%;"></p>
<p>可以这样理解：容器是运行着的镜像</p>
<h3 id="Sample-Web-Application"><a href="#Sample-Web-Application" class="headerlink" title="Sample Web Application"></a>Sample Web Application</h3><p>我们拿到一个React项目，要在一台电脑上运行，需要三步</p>
<ul>
<li>Install Node 下载 Node.js</li>
<li>npm install 下载该项目的依赖</li>
<li>npm start 启动该项目</li>
</ul>
<h3 id="Dockerfile-Instructions"><a href="#Dockerfile-Instructions" class="headerlink" title="Dockerfile Instructions"></a>Dockerfile Instructions</h3><p>启动一个Docker项目，首先就是要创建一个 Dockerfile， Dockerfile 包含了创建一个镜像的所有指令。</p>
<p>一个 Dockerfile 主要包含下面几种指令：</p>
<ul>
<li>FROM        说明 base image，从基础镜像开始搭建</li>
<li>WORKDIR    项目工作的文件夹</li>
<li>COPY and ADD      # to copy files/directories</li>
<li>RUN                       # to run commands</li>
<li>ENV                        # to set environment variable</li>
<li>EXPOSE                # to document the port the container is listen</li>
<li>USER                   # to set the user running the app</li>
<li>CMD                   # to set the default command/pro</li>
<li>ENTRYPOINT        # to set the default command/prog</li>
</ul>
<h3 id="Choosing-the-Right-Base-Image"><a href="#Choosing-the-Right-Base-Image" class="headerlink" title="Choosing the Right Base Image"></a>Choosing the Right Base Image</h3><p>在mac在某个文件夹打开终端可以用 alfred 中的  open iterm 命令。然后输入 <code>code .</code>  就可以使用vscode 打开此文件夹，这种工作流是比较快的。</p>
<p>我们在根目录下创建 Dockerfile 文件。</p>
<p>首先我们要确定该项目的 base image，选择一个正确的docker image 十分重要。</p>
<p>关于什么技术栈使用什么base image，我们可以上  <a href="https://docs.docker.com/samples/" target="_blank" rel="noopener">https://docs.docker.com/samples/</a> 上找(我更喜欢dash 配合 alfred直接搜索) </p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/14.png" style="zoom:100%;"></p>
<p>比如说我想写一个关于 ASP.NET Core 的项目，我就可以点进第三个查看 ,里面有示例代码。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> mcr.microsoft.com/dotnet/core/sdk:<span class="number">3.1</span> AS build-<span class="keyword">env</span></span><br><span class="line"><span class="comment"># 注意，这里的代码网址可能一直在更新，因此我们要自己去找去问</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy csproj and restore as distinct layers</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> *.csproj ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> dotnet restore</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy everything else and build</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> dotnet publish -c Release -o out</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Build runtime image</span></span><br><span class="line"><span class="keyword">FROM</span> mcr.microsoft.com/dotnet/core/aspnet:<span class="number">3.1</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=build-env /app/out .</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"dotnet"</span>, <span class="string">"aspnetapp.dll"</span>]</span></span><br></pre></td></tr></table></figure>
<p>在这个ReactJS 项目中，我们自然使用node，但是使用哪个版本的node十分重要，我们<strong>不要这样写</strong>： <code>FROM node:latest</code>  因为这样会导致随时间推移版本号不一致，导致维护项目变得十分困难。</p>
<p>我们在dockerhub 上可以找到很多node image：</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/15.png" style="zoom:100%;"></p>
<p>在中间一列，分别是操作系统和CPU架构。我们要选择当前CPU架构的版本进行下载。但事实上当我要下载这个image的时候，docker会自动帮我选择适合我电脑CPU的镜像版本。</p>
<p>为了能让我们的项目编译的更快，我们这里使用 alpine版本的node，因为只要几十M。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">14.16</span>.<span class="number">0</span>-alpine3.<span class="number">13</span></span><br></pre></td></tr></table></figure>
<p>选择好 base image之后，我么可以编译项目了：</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/16.png" style="zoom:100%;"></p>
<p>接下来，我们使用 <code>docker run -it react-app</code> 运行该项目，发现我们进入了node当中，可以直接运行js代码的那种。但这并不是我们想要的，我们希望的是进入一个shell或者bash，同时又有该node环境。为了实现这个效果我们可以将命令这样写：</p>
<p><code>docker run -it react-app sh</code>代表进入shell，注意了这里不能将sh 替换成bash，因为alpine很小，没有bash。</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/17.png" style="zoom:100%;"></p>
<h3 id="Copying-Files-and-Directories"><a href="#Copying-Files-and-Directories" class="headerlink" title="Copying Files and Directories"></a>Copying Files and Directories</h3><p><code>COPY</code> 和 <code>ADD</code> 的作用基本相同，只不过 <code>ADD</code> 相较于<code>COPY</code>多了一些功能：</p>
<p>当我们执行<code>docker build -t react-app .</code>命令的时候，docker客户端就会把这些内容交给docker engine去构建。docker engine 会一一执行 Dockerfile中的命令。但是Docker Engine 是没有权限访问当前文件下的其他文件的。因此我们要使用 COPY和ADD 指令。</p>
<p>COPY 顾名思义，就是将当前文件夹中的文件复制到我们创建的镜像当中去；ADD 则是将文件添加到镜像当中。</p>
<p>我们可以一一加入文件夹中的文件： <code>COPY package.json /app/</code>  ,其中 <code>/app/</code> 是复制到的目的地,<strong>需要绝对路径</strong>。</p>
<p>注意，如果要添加多个文件，需要注意大小写，且 <code>/app/</code><strong>后面的斜杠一定要加</strong>的</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">14.16</span>.<span class="number">0</span>-alpine3.<span class="number">13</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> package.json README.md /app/</span></span><br></pre></td></tr></table></figure>
<p>当然也可以使用相对路径，这时候我们就要先用<code>WORKDIR</code> 来规定工作区域： 这里我规定 WORKDIR 是<code>/app</code> 那么接下来我使用命令 <code>COPY . .</code> 第一个 <code>.</code> 代表将文件夹下的所有内容都复制。第二个<code>.</code> 是目的地，即代表当前的文件夹<code>/app</code></p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">14.16</span>.<span class="number">0</span>-alpine3.<span class="number">13</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br></pre></td></tr></table></figure>
<p>此外，还可以用列表的形式来写 COPY 命令，但是不常用：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">14.16</span>.<span class="number">0</span>-alpine3.<span class="number">13</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> [<span class="string">"hello world.txt"</span>,<span class="string">"."</span>]</span></span><br></pre></td></tr></table></figure>
<h4 id="ADD-特有功能"><a href="#ADD-特有功能" class="headerlink" title="ADD 特有功能"></a>ADD 特有功能</h4><ol>
<li>ADD 可以加入URL</li>
</ol>
<p>比如说我有一个json文件是放在网络服务器上的，因此我就可以通过 <code>ADD  http://.../file.json .</code>  将这个文件添加到镜像当中。</p>
<ol>
<li>ADD 可以添加压缩文件</li>
</ol>
<p><code>ADD file.zip .</code> 使用这个命令后，docker会自动解压这个压缩文件，并将其中的内容加到镜像文件当中</p>
<h4 id="构建："><a href="#构建：" class="headerlink" title="构建："></a>构建：</h4><p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/18.png" style="zoom:100%;"></p>
<p>我们看到这个镜像一下子从二十多MB跳到一百多MB了，这是因为我们<code>npm install</code> 下载了大量node modules</p>
<h3 id="Excluding-Files-and-Directories"><a href="#Excluding-Files-and-Directories" class="headerlink" title="Excluding Files and Directories"></a>Excluding Files and Directories</h3><p>问题出现了，当我们的项目越做越大的时候，如果按照之前的方法，就要把几百兆的modules传给一个虚拟化的Linux机器，这样性能很低。 而且，这些依赖都已经记录在 <code>package.json</code> 中。因此我们没有必要将 node_moduls 拷贝到镜像当中，而是在linux中自己使用<code>npm install</code>安装</p>
<p>这样做的方法有两个好处：</p>
<ol>
<li>可以大大缩小 build context 的体积</li>
<li>镜像构建速度也能提升很多。 </li>
</ol>
<p>那么怎么才能将特定的文件排除在外呢？ 我们想到，在git中我们可以使用 <code>.gitignore</code>文件来屏蔽一些文件，那么在docker中，也有这样一个 <code>.dockerignore</code>的文件，用来屏蔽不需要添加到镜像中的文件。</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/19.png" style="zoom:100%;"></p>
<p>我们看到，屏蔽了node_modules之后，构建镜像的速度变得很快，在app文件夹中也没有 <code>node_modules</code>文件夹了。</p>
<h3 id="Running-Commands"><a href="#Running-Commands" class="headerlink" title="Running Commands"></a>Running Commands</h3><p>现在我们要在 dockerfile中添加RUN 命令，以便在构建的时候下载项目所需要的依赖。这样就不用构建完之后再手动<code>npm install</code> 了。</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/20.png" style="zoom:100%;"></p>
<h3 id="Setting-Environment-Variables"><a href="#Setting-Environment-Variables" class="headerlink" title="Setting Environment Variables"></a>Setting Environment Variables</h3><p>现在我们来设置 环境变量。比如说，当我们用前端和后端沟通的时候，使用环境变量可以为我们节省很多代码。</p>
<p>语法格式： <code>ENV API_URL=http://api.myapp.com/</code></p>
<p>在启动镜像之后，首先我们可以用<code>printenv</code>来打印所有的环境变量</p>
<p>然后我们可以通过两种方法查询特定的环境变量</p>
<p><code>printenv API_URL</code> 或者 <code>echo $API_URL</code> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;app # printenv API_URL</span><br><span class="line">http:&#x2F;&#x2F;api.myapp.com&#x2F;</span><br><span class="line">&#x2F;app # echo $API_URL</span><br><span class="line">http:&#x2F;&#x2F;api.myapp.com&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="Exposing-Ports"><a href="#Exposing-Ports" class="headerlink" title="Exposing Ports"></a>Exposing Ports</h3><p>我们需要为运行的程序设置一个端口，在Dockerfile中可以这么写：<code>EXPOSE 3000</code></p>
<p>但是注意了，这只是将程序挂载到 container 中的3000端口，并不是我本地电脑的3000端口，虽然都是localhost</p>
<h3 id="Setting-the-User"><a href="#Setting-the-User" class="headerlink" title="Setting the User"></a>Setting the User</h3><p>在默认情况下，Docker会以root用户来运行程序。虽然说root用户的权限最高，但是也会存在不少安全漏洞。因此，为了运行这个项目，我们需要创建一个普通用户，其权限比较低。</p>
<p>首先我们要创建一个组，<code>addgroup app</code> </p>
<p>然后我们创建一个 system user 并将其加入刚刚创建的组中 <code>adduser -S -G app app</code> ,这句命令的意思就是创建一个叫做app的user，并把它加入到名叫 app的组中。</p>
<p>我们还可以把这两个命令放在一个命令中： <code>addgroup app &amp;&amp; adduser -S -G app app</code></p>
<p>在<code>Dockerfile</code>中，我们可以这样写创建用户、切换用户：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> addgroup app &amp;&amp; adduser -S -G app app</span></span><br><span class="line"><span class="keyword">USER</span> app</span><br></pre></td></tr></table></figure>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/21.png" style="zoom:100%;"></p>
<p>我们重新编译之后，输入 <code>whoami</code> ,这时候用户已经切成了app. </p>
<p>用<code>ls -l</code> 可以列出根目录下的一些文件信息，我们发现它们的所有者都是root，app用户是没有权限修改这些文件的，这就消除一些人修改文件的想法，增加了项目的安全性。</p>
<h3 id="Defining-Entrypoints"><a href="#Defining-Entrypoints" class="headerlink" title="Defining Entrypoints"></a>Defining Entrypoints</h3><h4 id="在terminal中直接启动项目"><a href="#在terminal中直接启动项目" class="headerlink" title="在terminal中直接启动项目"></a>在terminal中直接启动项目</h4><p>现在我们要不进入interactive模式，直接启动react-app，可以使用<code>docker run react-app npm start</code> ，其中跟在后面的 <code>npm start</code> 是启动后我们要在shell中输入的指令。</p>
<p>结果如下，我们发现我们并没有权限创建一个名为 <code>.cache</code>的文件。</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/22.png" style="zoom:100%;"></p>
<p>这是因为在Dockerfile中，我设置和切换用户写在最后两行，但是前面的指令都是root来执行的，因此我们没有权限在root创建的文件夹中进行操作。要解决这个问题，修改Dockerfile的顺序即可：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">14.16</span>.<span class="number">0</span>-alpine3.<span class="number">13</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> addgroup app &amp;&amp; adduser -S -G app app</span></span><br><span class="line"><span class="keyword">USER</span> app</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install</span></span><br><span class="line"><span class="keyword">ENV</span> API_URL=http://api.myapp.com/</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure>
<h4 id="在dockerfile中启动项目"><a href="#在dockerfile中启动项目" class="headerlink" title="在dockerfile中启动项目"></a>在dockerfile中启动项目</h4><p>在dockerfile通过命令启动项目有两种方式，一种是 CMD，另外一种是ENTRYPOINT。</p>
<p><strong>CMD</strong></p>
<p>支持三种格式:</p>
<ul>
<li><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code>使用 exec 执行，<strong>推荐方式</strong>；</li>
<li><code>CMD command param1 param2</code> 在 <code>/bin/sh</code> 中执行，提供给需要交互的应用；</li>
<li><code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code> 提供给 ENTRYPOINT 的默认参数；</li>
</ul>
<p>指定启动容器时执行的命令，每个 Dockerfile 只能有一条 CMD 命令。如果指定了多条命令，只有最后一条会被执行。如果用户启动容器时候<strong>指定了运行的命令，则会覆盖掉 CMD 指定的命令</strong>。</p>
<p><strong>ENTRYPOINT</strong></p>
<p>两种格式：</p>
<p><code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code> ,<strong>推荐方式</strong></p>
<p> <code>ENTRYPOINT command param1 param2</code>（shell中执行）。</p>
<p>配置容器启动后执行的命令，并且<strong>不可被 docker run 提供的参数覆盖</strong>。</p>
<p>每个 Dockerfile 中只能有一个 ENTRYPOINT，当指定多个时，只有<strong>最后一个起效</strong>。</p>
<p>因此，当命令一定会被执行的时候，推荐使用ENTRYPOINT，因为其不会被覆盖。</p>
<h3 id="Speeding-Up-Builds"><a href="#Speeding-Up-Builds" class="headerlink" title="Speeding Up Builds"></a>Speeding Up Builds</h3><p>我们看到对于这个小项目，m1的mac mini每次编译运行都要大概三四十秒的时间，还是比较慢的。这和docker的镜像机制有关。当Docker在编译一个项目的时候，每次执行一条指令就会新建一个只读层，这个只读层包含了这条指令修改了的文件。</p>
<p>因此我们要优化它。首先我们用<code>docker history react-app</code>来看一下image的各层：</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/23.png" style="zoom:100%;"></p>
<p>我们看到下面没有COMMENT的半部分是 Base Image，也就是 我们创建的 <code>node:14.16.0-alpine3.13</code> ，这几层创建的时间都是十几天前，说明创建一次之后，若没有改变就不用再创建了</p>
<p>然后，执行<code>RUN addgroup app &amp;&amp; adduser -S -G app app</code> 命令后， image又加了一层，文件系统多了几个文件。但是新建过后，就不需要再改变了，我们看到这个修改时间是四个小时之前了。</p>
<p>接下来执行的是 <code>USER app</code> 和<code>WORKDIR /app</code>  ，它们没有添加也没有减少文件，因此这层layer的大小是0B</p>
<p>但是<code>COPY . .</code>  每次都会将本地文件夹中的内容放到镜像中，因此每执行一次build，这一层就会新建一次。并且，当里面的一层只读层重建的话，建立在其上面的只读层都必须重建。因此在<code>COPY</code> 之后的指令都会创建一个新的镜像。</p>
<p>现在技巧性的东西来了，我们希望 <code>npm install</code> 这一步不要经常改变，因为每次下载node_modules需要非常多的时间，而且依赖并不是经常会修改的。因此我们可以先将 <code>pakage.json</code>文件加入镜像并执行<code>npm install</code>,然后再把其他的文件加入镜像。这样以后执行起来就会跳过 <code>RUN  npm install</code> 这条指令。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">14.16</span>.<span class="number">0</span>-alpine3.<span class="number">13</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> addgroup app &amp;&amp; adduser -S -G app app</span></span><br><span class="line"><span class="keyword">USER</span> app</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> package*.json .	<span class="comment"># 先把依赖文件加进去</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install				<span class="comment"># 安装依赖，没有修改就跳过 </span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .							<span class="comment"># 再将其他的文件加入，从这里开始，每次都新建</span></span></span><br><span class="line"><span class="keyword">ENV</span> API_URL=http://api.myapp.com/</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">3000</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"npm"</span>,<span class="string">"start"</span>]</span></span><br></pre></td></tr></table></figure>
<p>在第一次执行的时候，build需要执行38.2s,但是在修改了文件而不修改依赖的情况下再次build只需要4.9s，这是因为<code>npm install</code>的那一层并不需要重新再建一次，而是在缓存中了。</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/24.png" style="zoom:100%;"></p>
<h3 id="Removing-Images"><a href="#Removing-Images" class="headerlink" title="Removing Images"></a>Removing Images</h3><p>我们用<code>docker images</code>查看，会发现很多没有名字，也没有Tag的镜像文件：</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/25.png" style="zoom:100%;"></p>
<p>这些镜像文可能是临时镜像，没有最终build为一个最终的镜像，删掉即可。</p>
<p>我们可以使用：<code>docker container prune</code> 来删除已经停止多余的容器.</p>
<p>然后运行<code>docker image prune</code>来删除多余的镜像</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/26.png" style="zoom:100%;"></p>
<p>删除了之后，我们再打开镜像列表，发现只有两个我们在使用的镜像了。</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/27.png" style="zoom:100%;"></p>
<p>当我们想删除特定容器或者对象的时候，可以这样：</p>
<p>首先用<code>docker ps -a</code> 列出当前容器，然后：</p>
<p><code>docker rm -f &lt;?containerid&gt;</code> 来删除特定ID的容器或者镜像</p>
<p>或者用 <code>docker image rm &lt;name&gt;</code> 来制定删除特定名字的镜像或者容器</p>
<h3 id="Tagging-Images"><a href="#Tagging-Images" class="headerlink" title="Tagging Images"></a>Tagging Images</h3><p>为了项目维护方便，我们要养成给 Images打标签的习惯，否则每个项目的标签都是latest，比较难区分。比如说 testing, staging 之类的</p>
<p>举例： <code>docker build -t react-app:3.1.5</code>  也就是创建image的时候就给他打一个标签。其中，repository的名字是react-app, 该image的tag是冒号后面的 3.1.5</p>
<p>删除tag： <code>docker image remove react-app:1</code> </p>
<p>这和git中的tag有些类似，我们要时刻更新latest 这个tag</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/29.png" style="zoom:100%;"></p>
<p>比如现在我要将 lastest从上一个版本切换到现在tag为2的版本</p>
<p>可以用： <code>docker image tag 94e react-app:latest</code>  其中，945是Image ID的前三位</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/30.png" style="zoom:100%;"></p>
<h3 id="Sharing-Images"><a href="#Sharing-Images" class="headerlink" title="Sharing Images"></a>Sharing Images</h3><p>我们在dockerhub上</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/31.png" style="zoom:100%;"></p>
<p>然后我们把本地的image push上去, 首先为了管理方便我们再给第二版的项目打一个标签。</p>
<p><code>docker image tag 94e jasonxqh/react-app :2</code></p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/32.png" style="zoom:100%;"></p>
<p>然后利用<code>docker push jasonxqh/react-app:2</code>将第二版本的项目推送到docker hub上 ，推送之前记得先登录docker hub</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/34.png" style="zoom:100%;"></p>
<h3 id="Saving-and-Loading-Images"><a href="#Saving-and-Loading-Images" class="headerlink" title="Saving and Loading Images"></a>Saving and Loading Images</h3><p>如果我们不通过dockerhub，而是通过压缩文件的方法来保存images： <code>docker image save -o react-app.tar jasonxqh/react-app:3</code>  其中，前面的<code>react-app.tar</code>是压缩文件包的名字，后面的 <code>jasonxqh/react-app:3</code>是这个image的reference。</p>
<p>打开 <code>.tar</code>文件，里面保存的是一层一层的只读层</p>
<p>当我们在另一台电脑上要加载这个镜像的时候，可以：</p>
<p><code>docker image load -i react-app.tar</code></p>
<p>这样就把这个镜像加入进去了。</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/35.png" style="zoom:100%;"></p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/36.png" style="zoom:100%;"></p>
<h2 id="Working-with-Containers"><a href="#Working-with-Containers" class="headerlink" title="Working with Containers"></a>Working with Containers</h2><h3 id="Starting-Containers"><a href="#Starting-Containers" class="headerlink" title="Starting Containers"></a>Starting Containers</h3><p><code>docker run react-app</code> 可以让docker容器在前台运行：</p>
<p><code>docker run -d react-app</code> 可以让docker容器在后台运行。</p>
<p><code>docker run -d --name blue-sky react-app</code> 启动名为 <code>react-app</code>的docker镜像，并命名为 <code>blue-sky</code> </p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/37.png" style="zoom:100%;"></p>
<h3 id="Viewing-the-Logs"><a href="#Viewing-the-Logs" class="headerlink" title="Viewing the Logs"></a>Viewing the Logs</h3><p>现在我们在后台启动了这个容器，但是这对于我们来说相当于一个黑匣子，我并不清楚其中的运行信息。因此我们需要查看日志。</p>
<p>利用命令 <code>docker logs &lt;DockerID&gt;</code> 就可以查看该进程在后台打印的信息了：</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/38.png" style="zoom:100%;"></p>
<p>此外，通过查询 <code>docker logs --help</code> 可以查询更多操作：</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/39.png" style="zoom:100%;"></p>
<p>比如说：</p>
<p><code>dash logs -f ID</code> 可以<strong>实时监控</strong>后台的打印信息，可以通过 Ctrl+C 来退出该模式</p>
<p><code>dash logs -n 5 ID</code> 可以看到最后n条日志信息，这里是5条</p>
<p><code>dash logs -t ID</code> 可查看各条日志信息的时间戳</p>
<h3 id="Publishing-Ports"><a href="#Publishing-Ports" class="headerlink" title="Publishing Ports"></a>Publishing Ports</h3><p>之前我们说过，启动了container 之后，在本地访问<code>localhost:3000</code> 是没有效果的。因为在 Dockerfile 中，<code>Exposing 3000</code>只是在container所在的虚拟机中暴露3000端口。</p>
<p>为了做端口映射，我们可以用这条指令：</p>
<p><code>docker run -d -p 80:3000 --name c1  jasonxqh/react-app:3</code> </p>
<p>其中， -d 代表detach；-p 代表 port, 这里将container中的3000端口和本地的80端口做映射； —name是启动的container的名字； 最后一个参数是要启动的镜像</p>
<p>  <img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/40.png" style="zoom:100%;"></p>
<h3 id="Executing-Commands-in-Running-Containers"><a href="#Executing-Commands-in-Running-Containers" class="headerlink" title="Executing Commands in Running Containers"></a>Executing Commands in Running Containers</h3><p>之前我们学了在dockerfile中利用CMD执行命令。现在我们要来看怎么在一个正在运行的容器中执行命令</p>
<p>可以利用 <code>docker exec -it c1 sh</code>   来对一个正在运作的容器执行命令：</p>
<p>其中 <code>-it</code> 代表 interactive (交互)， c1是容器的名字， sh则是我们要打开的shell。</p>
<p>操作完之后，我们可以输入<code>exit</code> 退出shell，但是并不会使运行中的容器退出。</p>
<h3 id="Stopping-and-Starting-Containers"><a href="#Stopping-and-Starting-Containers" class="headerlink" title="Stopping and Starting Containers"></a>Stopping and Starting Containers</h3><p>使用<code>docker stop c1</code> 和<code>docker start c1</code>来结束或者开始一个容器。</p>
<p><code>docker run</code> 和 <code>docker start</code> 的区别就是前者是创建一个新的容器出来，后者是启动现有的容器</p>
<h3 id="Removing-Containers"><a href="#Removing-Containers" class="headerlink" title="Removing Containers"></a>Removing Containers</h3><p>我们用<code>docker rm c1</code> 是没有办法删除一个正在运行中的容器的，如果我们强制移除：<code>docker rm -f c1</code></p>
<h3 id="Containers-File-System"><a href="#Containers-File-System" class="headerlink" title="Containers File System"></a>Containers File System</h3><p>每一个容器都有独立的文件系统，在一个容器中创建的文件在另一个容器是访问不到的。</p>
<h3 id="Persisting-Data-using-Volumes"><a href="#Persisting-Data-using-Volumes" class="headerlink" title="Persisting Data using Volumes"></a>Persisting Data using Volumes</h3><p>Volume是 在container之外的一片存储空间。是绕过container的文件系统，直接将数据写到host机器上，只是volume是被docker管理的，docker下所有的volume都在host机器上的指定目录下/var/lib/docker/volumes。</p>
<p><code>docker volume create app-data</code> 是创建一个名叫app-data volume.</p>
<p><code>docker volume inspect app-data</code> 是查看这个volume的基本信息，我们看到这个volume是放在 <code>/var/lib/docker/volumes/app-data/_data</code>  文件夹下的</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/41.png" style="zoom:100%;"></p>
<p>接下来我们要把这个volume挂载到container中：</p>
<p><code>docker run -d -p 4000:3000 -v app-data:/app/data  jasonxqh/react-app:3</code></p>
<p>如果volume是空的而container中的目录有内容，那么docker会将container目录中的内容拷贝到volume中，但是如果volume中已经有内容，则会将container中的目录覆盖</p>
<p>也就是说现在我们往container中的<code>/app/data</code>目录写文件是会保存在本地电脑上的。</p>
<p>但是，现在我们直接 <code>echo something &gt; sth.data</code> ，是没有权限的，因为现在的用户是app,但是data的所有者是root。为此，我们要在dockerfile中事先以app用户的名义创建好data文件夹。</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/42.png" style="zoom:100%;"></p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/43.png" style="zoom:100%;"></p>
<p>现在，权限问题解决了。</p>
<h3 id="Copying-Files-between-the-Host-and-Containers"><a href="#Copying-Files-between-the-Host-and-Containers" class="headerlink" title="Copying Files between the Host and Containers"></a>Copying Files between the Host and Containers</h3><p>现在我们要把container中的文件拷贝到本地，或者把本地的文件拷贝到容器中去。</p>
<p><code>docker cp 776:/app/log.txt .</code> 其中<code>776:/app/log.txt</code> 是ID为776的container<code>/app</code>文件夹下的目标文件， <code>.</code> 是复制到的目的地。这里是把容器中的log.txt拷贝到本地当前文件夹。</p>
<p>同样的，<code>docker cp secret.txt 776:/app</code> 就是把本地的 <code>secret.txt</code>文件拷贝到container中去。</p>
<h3 id="Sharing-the-Source-Code-with-a-Container"><a href="#Sharing-the-Source-Code-with-a-Container" class="headerlink" title="Sharing the Source Code with a Container"></a>Sharing the Source Code with a Container</h3><p>当我们正式开始写项目的时候，我们不希望修改一点点东西就要新创建一个image，新开一个container，才能在网页上显示改变。这样太浪费时间了。</p>
<p>因此我们要做一个映射，就是在本地项目文件夹和docker的工作文件夹之间建立一个映射</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/44.png" style="zoom:100%;"></p>
<p>我们可以用这条命令来启动，首先我们做端口映射，然后 <code>-v</code> 代表挂载外接盘，这里我们把 <code>${PWD}</code> 和<code>/app</code> 做一个映射，也就是当我修改 当前目录文件夹的文件时，容器中的<code>/app</code>文件也会同步。 </p>
<p>注意 PWD 代表当前的目录，这里一定要<strong>使用大写 </strong>，否则是非法的。</p>
<p><code>docker run -d -p 5005:3000 -v ${PWD}:/app  react-app</code></p>
<h2 id="Running-Multi-container-Applications"><a href="#Running-Multi-container-Applications" class="headerlink" title="Running Multi-container Applications"></a>Running Multi-container Applications</h2><h3 id="Installing-Docker-Compose"><a href="#Installing-Docker-Compose" class="headerlink" title="Installing Docker Compose"></a>Installing Docker Compose</h3><p>前面我们使用 Docker 的时候，定义 Dockerfile 文件，然后使用 docker build、docker run 等命令操作容器。然而微服务架构的应用系统一般包含若干个微服务，每个微服务一般都会部署多个实例，如果每个微服务都要手动启停，那么效率之低，维护量之大可想而知</p>
<p><strong>使用 Docker Compose 可以轻松、高效的管理容器，它是一个用于定义和运行多容器 Docker 的应用程序工具</strong>mac和windows用户，当我们下载了Docker Desktop之后就自动安装了Docker Compose</p>
<h3 id="Cleaning-Up-our-Workspace"><a href="#Cleaning-Up-our-Workspace" class="headerlink" title="Cleaning Up our Workspace"></a>Cleaning Up our Workspace</h3><p><code>docker container rm -f $(docker container ls -aq)</code> 可以删除所有状态下的容器</p>
<p><code>docker image rm -f $(docker image ls -aq)</code> 可以删除所有状态下的 Image</p>
<p>其中<code>-aq</code> 中的a代表all， <code>-q</code> 则代表获取所有对象的ID。  </p>
<h3 id="The-Sample-Web-Application"><a href="#The-Sample-Web-Application" class="headerlink" title="The Sample Web Application"></a>The Sample Web Application</h3><p>这是一个有前端和后端的Web项目：</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/45.png" style="zoom:100%;"></p>
<p>按正常的方法，我们需要分别进入前后端文件夹并使用<code>npm run start</code> 但是如果我们使用了 docker compose，编写了yml文件，我们就可以直接输入<code>docker-compose up</code>让项目在docker容器中运行。</p>
<h4 id="bug"><a href="#bug" class="headerlink" title="bug"></a>bug</h4><p>这里我遇到了一个比较难发现的bug，那就是我一直无法启动 <code>./docker-entrypoint.sh</code> 这个文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">echo "Waiting for MongoDB to start..."</span><br><span class="line">./wait-for db:27017 </span><br><span class="line"></span><br><span class="line">echo "Migrating the databse..."</span><br><span class="line">npm run db:up </span><br><span class="line"></span><br><span class="line">echo "Starting the server..."</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>
<p>当后端启动，我们再调用这个文件，就能在container中运行shell命令。</p>
<p>但是，我这个文件是本地创建的，创建时并没有像app用户开放执行权限，导致我<code>docker-compose up</code> 的时候始终报：Permission denied。 因此，我们要在运行<code>docker-compose up</code> 前手动修改<code>docker-entrypoint.sh</code> 的权限：</p>
<p><code>chmod a+x docker-entrypoint.sh</code> 修改执行权限，再执行<code>docker-compose up</code> 之后，bug解决。</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/46.png" style="zoom:100%;"></p>
<h3 id="JSON-and-YAML-Formats"><a href="#JSON-and-YAML-Formats" class="headerlink" title="JSON and YAML Formats"></a>JSON and YAML Formats</h3><p> 现在我们就来介绍一下YAML格式以及它和JSON格式的区别。</p>
<p>首先我们看以下JSON格式的文件：JSON格式就是键值对</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"vidly-frontend"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.1.0"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"axios"</span>: <span class="string">"^0.21.1"</span>,</span><br><span class="line">    <span class="attr">"react"</span>: <span class="string">"^17.0.1"</span>,</span><br><span class="line">    <span class="attr">"react-dom"</span>: <span class="string">"^17.0.1"</span>,</span><br><span class="line">    <span class="attr">"react-scripts"</span>: <span class="string">"4.0.2"</span>,</span><br><span class="line">    <span class="attr">"web-vitals"</span>: <span class="string">"^1.0.1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"react-scripts start"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"react-scripts build"</span>,</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"react-scripts test --colors"</span>,</span><br><span class="line">    <span class="attr">"eject"</span>: <span class="string">"react-scripts eject"</span></span><br><span class="line">  &#125;,  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>YAML的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。那么YAML格式长啥样呢？下面是 <code>docker-compose.yml</code> 文件中的信息：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.8"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">frontend:</span></span><br><span class="line">    <span class="attr">depends_on:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./frontend</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3000</span><span class="string">:3000</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">backend:</span> </span><br><span class="line">    <span class="attr">depends_on:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./backend</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="number">3001</span><span class="string">:3001</span></span><br><span class="line">    <span class="attr">environment:</span> </span><br><span class="line">      <span class="attr">DB_URL:</span> <span class="string">mongodb://db/vidly</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">./docker-entrypoint.sh</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mongo:4.0-xenial</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">27017</span><span class="string">:27017</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">vidly:/data/db</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">vidly:</span></span><br></pre></td></tr></table></figure>
<p>我们发现，YAML其实就是JSON格式去掉所有的大括号和引号，并用缩进来表示从属关系。</p>
<p>在一个冒号下的多个数值的列举，使用 <code>-</code> 使条理清晰</p>
<p>那么YAML可读性比JSON高的话，为什么我们步一直使用YAML呢？因为解析YAML格式的文件要比解析JSON格式的文件更慢一些，所以说各有利弊</p>
<p>接下来这章，我们就来复盘一下这样一份 <code>docker-compose.yml</code> 是怎么写出来的</p>
<h3 id="Creating-a-Compose-File"><a href="#Creating-a-Compose-File" class="headerlink" title="Creating a Compose File"></a>Creating a Compose File</h3><p>首先，我们新建一个 <code>docker-compose.yml</code> 文件。</p>
<h4 id="version字段"><a href="#version字段" class="headerlink" title="version字段"></a>version字段</h4><p>在文件的开始，我们要确定compose版本：</p>
<p>在： <a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener">https://docs.docker.com/compose/compose-file/</a> 中，我们可以查到compose file与Docker Engine对应的表格，按照上面写即可：</p>
<p>这里我们使用3.8版本：</p>
<p><code>Version: &quot;3.8&quot;</code> </p>
<h4 id="services字段"><a href="#services字段" class="headerlink" title="services字段"></a>services字段</h4><p>然后我们要确定<code>services</code>字段：这个字段告诉Docker，它要创建哪些container，比如frontend，backend，db，这些服务的名字我们可以乱取，Docker会依次为其创建容器。但是为了简洁起见，我们还是将其命名为frontend，backend，db三个服务，分别代表前端，后端，数据库</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.8"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">frontend:</span></span><br><span class="line">    </span><br><span class="line">  <span class="attr">backend:</span> </span><br><span class="line">  </span><br><span class="line">  <span class="attr">db:</span></span><br></pre></td></tr></table></figure>
<h5 id="frontend"><a href="#frontend" class="headerlink" title="frontend"></a>frontend</h5><p>在前端服务中，我们首先要运行frontend文件夹中的 <code>dockerfile</code> 文件。我们可以这么写：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">frontend:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./frontend</span></span><br></pre></td></tr></table></figure>
<p>接下来我们做端口映射，也就是将容器中的端口映射到本地。这里虽然我们只做一个端口映射，但是考虑到可能有多重端口映射，因此这里使用 <code>-</code> 来列举</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">frontend:</span></span><br><span class="line">  <span class="attr">build:</span> <span class="string">./frontend</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">3000</span><span class="string">:3000</span></span><br></pre></td></tr></table></figure>
<h5 id="backend"><a href="#backend" class="headerlink" title="backend"></a>backend</h5><p>和frontend一样，这里我们也要定义build属性，它将执行 backend文件夹下的dockerfile文件</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">backend:</span> </span><br><span class="line">	<span class="attr">build:</span> <span class="string">./backend</span></span><br></pre></td></tr></table></figure>
<p>和frontend一样，后端服务也需要端口映射：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">backend:</span> </span><br><span class="line">    <span class="attr">build:</span> <span class="string">./backend</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="number">3001</span><span class="string">:3001</span></span><br></pre></td></tr></table></figure>
<p>下面一个属性是<code>environment</code>,这是后端服务所需要</p>
<p>然后，我们要做一个volume映射，来告诉后端数据库在哪里.这个关键变量其实就是一个Mongodb的Connection URL ——  <code>mongodb://db/vidly</code> ，db是一个host(因为按照YAML创建的container中的host名与service的名字一样)，因此，这里是<code>db</code>;  <code>/vidly</code>代表这个db数据库下的一张数据表.</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">backend:</span> </span><br><span class="line">  <span class="attr">depends_on:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">  <span class="attr">build:</span> <span class="string">./backend</span></span><br><span class="line">  <span class="attr">ports:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="number">3001</span><span class="string">:3001</span></span><br><span class="line">  <span class="attr">environment:</span> </span><br><span class="line">    <span class="attr">DB_URL:</span> <span class="string">mongodb://db/vidly</span></span><br></pre></td></tr></table></figure>
<h5 id="db"><a href="#db" class="headerlink" title="db"></a>db</h5><p>这是一个数据库服务，因为我们本地没有相关的文件，所以就要用为其规定image属性，比如说这里的 <code>mongo:4.0-xenial</code> ，这是一个ubuntu 版本的mongodb，比windows下的mongodb要轻量化许多。然后同样做一个端口映射</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">db:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">mongo:4.0-xenial</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">27017</span><span class="string">:27017</span></span><br></pre></td></tr></table></figure>
<p>通常情况下，一个容器启动之后，所有容器中的数据都存在容器内部的临时文件中，如果容器停止，则数据也就清空了，为了能够在使用容器的过程中，还能把一些数据持久化下来，也即容器消失掉，这些数据依然还存在，因此dockercompose支持了数据卷（volume）功能，通过他可以指定Docker中一块持久化的区域，该区域在容器消失之后，还可以依然将区域中的数据保存下来。</p>
<p>相当于这部分区域不在属于某一个容器了，而是由dockercompose管理的一部分区域，只要通过compose启动容器，这部分区域就一直会存在</p>
<p>这里我们就要定义一个持久化的数据卷：左边的是主机目录，右边的是容器目录。也就是说，如果项目往容器数据库中写数据的话，那么这些数据会保存在主机上不会消失。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">db:</span> </span><br><span class="line">  <span class="attr">image:</span> <span class="string">mongo:4.0-xenial</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">27017</span><span class="string">:27017</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">vidly:/data/db</span></span><br></pre></td></tr></table></figure>
<h4 id="volumes"><a href="#volumes" class="headerlink" title="volumes:"></a>volumes:</h4><p>上面我们使用了一个数据卷 ，但我们还没有定义，因此接下来我们要定义它。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">vidly:</span></span><br></pre></td></tr></table></figure>
<h3 id="Building-Images-1"><a href="#Building-Images-1" class="headerlink" title="Building Images"></a>Building Images</h3><p>之前我们说了 Docker-Compose 是建立在 Docker-engine之上的，因此docker engine能完成的工作(build,run,listening等)，docker-compose都能够完成 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Commands:</span><br><span class="line">  build              Build or rebuild services</span><br><span class="line">  config             Validate and view the Compose file</span><br><span class="line">  create             Create services</span><br><span class="line">  down               Stop and remove resources</span><br><span class="line">  events             Receive real time events from containers</span><br><span class="line">  exec               Execute a command in a running container</span><br><span class="line">  help               Get help on a command</span><br><span class="line">  images             List images</span><br><span class="line">  kill               Kill containers</span><br><span class="line">  logs               View output from containers</span><br><span class="line">  pause              Pause services</span><br><span class="line">  port               Print the public port for a port binding</span><br><span class="line">  ps                 List containers</span><br><span class="line">  pull               Pull service images</span><br><span class="line">  push               Push service images</span><br><span class="line">  restart            Restart services</span><br><span class="line">  rm                 Remove stopped containers</span><br><span class="line">  run                Run a one-off command</span><br><span class="line">  scale              Set number of containers for a service</span><br><span class="line">  start              Start services</span><br><span class="line">  stop               Stop services</span><br><span class="line">  top                Display the running processes</span><br><span class="line">  unpause            Unpause services</span><br><span class="line">  up                 Create and start containers</span><br><span class="line">  version            Show version information and quit</span><br></pre></td></tr></table></figure>
<p>现在我们来学习如何用 build 指令, build就是用来构建刚才我们写的服务的。build完成后service会以 image的形式存在。</p>
<p>当我们想不借助cache，重新编译的时候，可以使用 <code>docker-compose build --no-cache</code> 但是显然这样会比较慢</p>
<h3 id="Starting-and-Stopping-the-Application"><a href="#Starting-and-Stopping-the-Application" class="headerlink" title="Starting and Stopping the Application"></a>Starting and Stopping the Application</h3><p>之前学的 <code>docker-compose up</code> 是将 build image，run container一步到位了。如果我们想重新build一遍，并运行起来，可以使用 <code>docker-compose up --build</code> ；如果我们想要其在后台运行，可以使用<code>docker-compose up -d</code> </p>
<p>使用docker-compose运行起来的容器可以使用 <code>docker-compose ps</code> 一览</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/47.png" style="zoom:100%;"></p>
<p>当我们想要关掉后台运行中的的容器时，可以 <code>docker-compose down</code> </p>
<h3 id="Docker-Networking"><a href="#Docker-Networking" class="headerlink" title="Docker Networking"></a>Docker Networking</h3><p>当我们用 docker-compose 启用一个项目的时候，Docker Compose会自动创建一个关系网络并将containers加到这个网络上，一遍这几个网络可以互相通讯。</p>
<p>我们可以使用<code>docker network ls</code> 来查看这几个container 的关系网：</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/48.png" style="zoom:100%;"></p>
<p>然后我用 root 用户登录backend(否则没有ping的权限)，然后ping 本地的frontend地址，就可以发现它们是可以互相通讯的。</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/49.png" style="zoom:100%;"></p>
<p>这也是为什么backend container能够通过 connection url与mongodb container 通讯了。</p>
<h3 id="Viewing-Logs"><a href="#Viewing-Logs" class="headerlink" title="Viewing Logs"></a>Viewing Logs</h3><p>使用<code>docker-compose logs</code> 可以查看后端程序日志信息，和<code>docker logs</code> 一样，也可以加上 <code>-f,-t</code> 用来跟踪日志或者打印时间戳。</p>
<h3 id="Publishing-Changes"><a href="#Publishing-Changes" class="headerlink" title="Publishing Changes"></a>Publishing Changes</h3><p>和单个container一样，我们不希望修改一点代码就要rebuild整个项目，那样太麻烦了。因此我们要降本的文件夹和container中的/app 文件夹做映射，而且要比之前的利用绝对路径<code>$(PWD)</code>做映射更简单。比如说，我要把 本地的backend文件夹和/app文件夹做映射。只要 <code>./backend:/app</code> 即可</p>
<p>但是这有一个bug，就是后端会报一个错误，也就是 <code>nodemon:not found</code> </p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/50.png" style="zoom:100%;"></p>
<p>我们知道nodemon是一个很有用的包，它会监测文件的修改并实时渲染。但是，我们只在container中装载了node_modules文件夹而本地的backend目录下并没有node_modules文件夹。因此无法实现监测。</p>
<p>为了解决这个问题，我们可以在本地也安装<code>node_modules</code> 文件夹。这样再次启动前后端，就能实现同步更新了。</p>
<p><img src="/2021/04/07/docker%E5%9F%BA%E7%A1%801/51.png" style="zoom:100%;"></p>
<h3 id="Migrating-the-Database"><a href="#Migrating-the-Database" class="headerlink" title="Migrating the Database"></a>Migrating the Database</h3><p>如果要在一个新的电脑上运行这个项目，我们势必要把数据插入到新的mongodb当中去。因此这就需要用到数据迁移。在nodejs中有个很好用的工具，可以用来迁移mongodb数据库：<code>migrate-mongo</code></p>
<p>使用了这个工具，我们可以创建 <code>database-migration scripts</code> 如下：</p>
<p>这个文件存放在 <code>migrations</code>文件夹中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="keyword">async</span> up(db, client) &#123;</span><br><span class="line">    <span class="keyword">await</span> db</span><br><span class="line">      .collection(<span class="string">"movies"</span>)</span><br><span class="line">      .insertMany([</span><br><span class="line">        &#123; <span class="attr">title</span>: <span class="string">"Avatar"</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">title</span>: <span class="string">"Star Wars"</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">title</span>: <span class="string">"Terminator"</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">title</span>: <span class="string">"Titanic"</span> &#125;,</span><br><span class="line">      ]);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> down(db, client) &#123;</span><br><span class="line">    <span class="keyword">await</span> db.collection(<span class="string">"movies"</span>).deleteMany(&#123;</span><br><span class="line">      title: &#123;</span><br><span class="line">        $<span class="keyword">in</span>: [<span class="string">"Avatar"</span>, <span class="string">"Star Wars"</span>, <span class="string">"Terminator"</span>, <span class="string">"Titanic"</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里有两个模块：up函数是往database的movies数据表中中添加数据，down函数是在database删除数据。这两个函数式异步的</p>
<p>要启动这个脚本文件，可以 <code>migrate-mongo up</code>。因为在数据库中有变更日志，所以migrate-mongo 模块并不会重复执行一个脚本，插入重复的数据。</p>
<p>在package.json 中，我们看到可以用<code>npm run db:up</code>来简化<code>migrate-mongo up</code> </p>
<p>介绍完database migration之后，我们希望在启动项目的一开始先执行数据库迁移,在后端的Dockerfile中，我们只写了 <code>CMD [&quot;npm&quot;,&quot;start&quot;]</code> , 这是不够的，我们可在<code>docker-compose</code> 中定义 <code>command</code>字段来重写要执行的操作。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">backend:</span> </span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">	<span class="attr">command:</span> <span class="string">migrate-mongo</span> <span class="string">up</span> <span class="string">&amp;&amp;</span> <span class="string">npm</span> <span class="string">start</span></span><br></pre></td></tr></table></figure>
<p>但是这样写有个问题，因为当我执行<code>migrate-mongo up</code> 的时候， 我的db service可能还没有启动，这样就会报错了。为解决这个问题，需要在启动命令前增加<code>判断依赖服务状态的工具</code>，主要有三种：<strong>wait-for-it，dockerize，waitfor</strong>在这我使用<code>./wait-for</code> : </p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">backend:</span> </span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">	<span class="attr">command:</span> <span class="string">./wait-for</span> <span class="string">db:27017</span> <span class="string">&amp;&amp;</span> <span class="string">migrate-mongo</span> <span class="string">up</span> <span class="string">&amp;&amp;</span> <span class="string">npm</span> <span class="string">start</span></span><br></pre></td></tr></table></figure>
<p>其中<code>./wait-for</code>后面的第一个参数是service 的名字，第二个参数是其对应的端口.</p>
<p>虽然写是写好了，但是这样的command未免有点不美观，因此，我们可以新建一个<code>docker-entrypoint.sh</code>的可执行文件，然后用command来执行它。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">echo "Waiting for MongoDB to start..."</span><br><span class="line">./wait-for db:27017 # 首先等待db service 启动</span><br><span class="line"></span><br><span class="line">echo "Migrating the databse..."</span><br><span class="line">npm run db:up # 进行数据迁移操作</span><br><span class="line"></span><br><span class="line">echo "Starting the server..."</span><br><span class="line">npm start # 最后启动backend server</span><br></pre></td></tr></table></figure>
<p>把command字段改成执行docker-entrypoint.sh 即可</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">backend:</span> </span><br><span class="line"><span class="comment">#...</span></span><br><span class="line">  <span class="attr">command:</span> <span class="string">./docker-entrypoint.sh</span></span><br></pre></td></tr></table></figure>
<p>最后我们来设置一下服务器的顺序启动问题，比如说先启动db服务，再启动backend服务，最后启动frontend服务，但是注意这只能保证容器进入了running状态，而不保证进入 ready状态,所以说我们要将depends_on和wait-for搭配使用。可以设置 <code>depends_on</code>字段来解决</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.8"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">frontend:</span></span><br><span class="line">    <span class="attr">depends_on:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">   <span class="comment">#...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="attr">backend:</span> </span><br><span class="line">    <span class="attr">depends_on:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">   <span class="comment">#...</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">  <span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<h3 id="Summary-1"><a href="#Summary-1" class="headerlink" title="Summary"></a>Summary</h3><p>这一节我们主要讲了这几个命令以及它们的延伸。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker-compose build</span><br><span class="line">docker-compose build --no-cached</span><br><span class="line">ocker-compose up</span><br><span class="line">docker-compose up -d</span><br><span class="line">docker-compose up —build</span><br><span class="line">docker-compose down</span><br><span class="line">docker-compose ps</span><br><span class="line">docker-compose logs</span><br><span class="line">Docker Compose commands</span><br></pre></td></tr></table></figure>
<h2 id="Deploying-Applications"><a href="#Deploying-Applications" class="headerlink" title="Deploying Applications"></a>Deploying Applications</h2><p>这一章节我们来讲一下如何发布一个应用</p>
<h3 id="Deployment-Options"><a href="#Deployment-Options" class="headerlink" title="Deployment Options"></a>Deployment Options</h3><p>对于一个项目，有两种部署的方式，其一可以部署到一个服务器上(single-host deployment)，也可以部署到一个服务器集群上(Cluster deployment)</p>
<p>只部署到一个服务器上，虽然操作比较简单，但是一旦服务器宕机，我们的项目也就失效了。而且当应用的瞬时流量较大时，单个服务器可能承受不了这样的压力。</p>
<p>如果选择<code>cluster deployment</code> 这种方式，这需要编制软件(orchestration tools)帮忙，主流orchestration tools有： <code>docker swarm</code> 和 <code>kubernetes(俗称k8s)</code> ，但是部署的逻辑较为复杂，因此这章还是使用<code>single-host deployment</code> 这种方式。</p>
<h3 id="Getting-a-Virtual-Private-Server"><a href="#Getting-a-Virtual-Private-Server" class="headerlink" title="Getting a Virtual Private Server"></a>Getting a Virtual Private Server</h3><p>VPS提供商有很多,比如说：</p>
<ul>
<li>Digital Ocean</li>
<li>Google Cloud Platform(GCP)</li>
<li>Microsoft Azure</li>
<li>Amazon Web Services(AWS) </li>
</ul>
<p>一般来说租个VPS都是要花钱的，我这里使用Oracle Virtualbox 来演示</p>
<h3 id="Installing-Docker-Machine"><a href="#Installing-Docker-Machine" class="headerlink" title="Installing Docker Machine"></a>Installing Docker Machine</h3><p>首先我们需要在项目文件夹中安装 Docker Machine。Docker Machine 是一种可以让您在虚拟主机上安装 Docker 的工具，并可以使用 docker-machine 命令来管理主机。Docker Machine 也可以集中管理所有的 docker 主机，比如快速的给 100 台服务器安装上 docker。</p>
<p>可以在这里下载：<a href="https://github.com/docker/machine/releases" target="_blank" rel="noopener">https://github.com/docker/machine/releases</a></p>
<p>我们使用的是mac os，那就复制这段连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -L https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;machine&#x2F;releases&#x2F;download&#x2F;v0.16.2&#x2F;docker-machine-&#96;uname -s&#96;-&#96;uname -m&#96; &gt;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-machine &amp;&amp; \</span><br><span class="line">  chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-machine</span><br></pre></td></tr></table></figure>
<p>当然，我们下载了homebrew，可直接用 <code>brew install docker docker-machine</code></p>
<h3 id="Provisioning-a-Host"><a href="#Provisioning-a-Host" class="headerlink" title="Provisioning a Host"></a>Provisioning a Host</h3><p>现在我们要用docker machine 创建一个虚拟机。docker-machine支持的虚拟机提供服务如下:</p>
<p><a href="https://docs.docker.com/machine/drivers/" target="_blank" rel="noopener">https://docs.docker.com/machine/drivers/</a></p>
<h3 id="Connecting-to-the-Host"><a href="#Connecting-to-the-Host" class="headerlink" title="Connecting to the Host"></a>Connecting to the Host</h3><h3 id="Defining-the-Production-Configuration"><a href="#Defining-the-Production-Configuration" class="headerlink" title="Defining the Production Configuration"></a>Defining the Production Configuration</h3><h3 id="Reducing-the-Image-Size"><a href="#Reducing-the-Image-Size" class="headerlink" title="Reducing the Image Size"></a>Reducing the Image Size</h3><h3 id="Deploying-the-Application"><a href="#Deploying-the-Application" class="headerlink" title="Deploying the Application"></a>Deploying the Application</h3><h3 id="Troubleshooting-Deployment-Issues"><a href="#Troubleshooting-Deployment-Issues" class="headerlink" title="Troubleshooting Deployment Issues"></a>Troubleshooting Deployment Issues</h3><h3 id="Publishing-Changes-1"><a href="#Publishing-Changes-1" class="headerlink" title="Publishing Changes"></a>Publishing Changes</h3><h3 id="Course-Wrap-Up"><a href="#Course-Wrap-Up" class="headerlink" title="Course Wrap Up"></a>Course Wrap Up</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/04/04/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F3-1-3-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/04/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F3-1-3-3/" class="post-title-link" itemprop="url">多维随机变量3.1-3.3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-04 22:09:27" itemprop="dateCreated datePublished" datetime="2021-04-04T22:09:27+08:00">2021-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-06-27 20:13:04" itemprop="dateModified" datetime="2021-06-27T20:13:04+08:00">2021-06-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="多元随机变量及其联合分布"><a href="#多元随机变量及其联合分布" class="headerlink" title="多元随机变量及其联合分布"></a>多元随机变量及其联合分布</h1><h2 id="多维随机变量"><a href="#多维随机变量" class="headerlink" title="多维随机变量"></a>多维随机变量</h2><p><strong>定义：如果 $X_1(\omega),X_2(\omega)\cdots,X_n(\omega)$</strong>  是定义在同一个样本空间 $\Omega = {\omega}$ 上的 $n$ 个随机变量，则称 $X(\omega) = (X_1(\omega),X_2(\omega),\cdots,X_n(\omega))$ 为 n 维(n元) 随机变量或者随机向量。</p>
<h2 id="联合分布函数"><a href="#联合分布函数" class="headerlink" title="联合分布函数"></a>联合分布函数</h2><p><strong>定义：</strong> 对任意的n 个实数 $x_1,x_2,\cdots,x_n$ n个事件${X_1\leq x_1},\cdots,{X_n\leq x_n}$ 同时发生的概率为： $F(x_1,x_2\cdots,x_n)=P(X_1\leq x_1,X_2\leq x_2,\cdots,X_n\leq x_n)$  称为n维随机变量的联合分布函数</p>
<p>任意一个而为联合分布函数 $F(x,y)$ 必具有如下几条基本性质：</p>
<ul>
<li>单调性 </li>
<li>有界性</li>
<li>右连续性</li>
<li><strong>非负性</strong> ，这是新的性质： 对任意的$a&lt;b,c&lt;d$ 有$P(a&lt;X\leq b，c&lt;X\leq d) = F(b,d)-F(a,d)-F(b,c)+F(a,c)$ </li>
</ul>
<p>这几条性质的成立与该分布为某个二维随机变量的分布函数互为充要条件</p>
<h2 id="联合分布列"><a href="#联合分布列" class="headerlink" title="联合分布列"></a>联合分布列</h2><p>如果二维随机变量$(X,Y)$是<strong>离散的</strong>，则称 $(X,Y)$ 为二维离散随机变量，称$p_{ij}=P(X=x_i,Y=y_j),i,j=1,2\cdots$ 为$(X,Y)$的联合分布列。如图:</p>
<p><img src="/2021/04/04/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F3-1-3-3/1.png" style="zoom:80%;"></p>
<p>联合分布列的基本性质：</p>
<ol>
<li>非负性 $p_{ij}\geq 0$</li>
<li>正则性 $\sum<em>{i=1}^\infty \sum</em>{j=1}^\infty = 1$</li>
</ol>
<h2 id="联合密度函数"><a href="#联合密度函数" class="headerlink" title="联合密度函数"></a>联合密度函数</h2><p><strong>定义：</strong> 如果存在二元非负函数 $p(x,y)$ ，使得二维随机变量 $(X,Y)$ 的<strong>分布函数</strong> $F(x,y)$ 可表示为：</p>
<p>$F(x,y)=\int<em>{-\infty}^x\int</em>{-\infty}^y p(u,v) dvdu$ </p>
<p>则称 $F(x,y)$ 为二维连续随机变量，称$p(u,v)$ 为 $(X,Y)$ 的联合密度函数</p>
<h2 id="常用多维分布"><a href="#常用多维分布" class="headerlink" title="常用多维分布"></a>常用多维分布</h2><h3 id="多项分布"><a href="#多项分布" class="headerlink" title="多项分布"></a>多项分布</h3><p>多项分布是重要的多维离散分布，它是二项分布的推广</p>
<p><strong>进行 n 次</strong>独立重复试验，如果每次试验有 r 个互不相容的结果：$A_1,A_2,\cdots,A_r$ 之一发生，且每次试验中$A_i$ 发生的概率为$p_i=P(A_i) ,i=1,2,\cdots,r$ 且 $p_1+p_2+\cdots+p_r =1$。 记 $X_i$ 为 n次独立重复实验中 $A_i$ 出现的次数$i=1,2,\cdots,r$ </p>
<p>那么$(X_1,X_2,\cdots,X_r)$ 取值$(n_1,n_2,\cdots,n_r)$ 的概率 ，也就是说$A_1$ 出现$n_1$ 次，$A_2$ 出现 $n_2$次…的概率为：</p>
<script type="math/tex; mode=display">
P(X_1=n_1,X_2=n_2,\cdots,X_r=n_r) = \frac{n!}{n_1!n_2!\cdots n_r!} p_1^{n_1}p_2^{n_2}\cdots p_r^{n_r}</script><p>其中 $n=n_1+n_2+\cdots+n_r$ </p>
<p>这个联合分布列被称为 <strong>r项分布</strong>, 又称为<strong>多项分布</strong>，记为$M(n,p_1,p_2,\cdots,p_r)$ </p>
<p>这里我们要搞清楚一个概念，<strong>r项分布是r-1维随机变量的分布</strong></p>
<h3 id="多维均匀分布"><a href="#多维均匀分布" class="headerlink" title="多维均匀分布"></a>多维均匀分布</h3><p>设 D 为 $R^n$ 中的一个有界区域，其 measure(即平面的为面积，空间的为体积等) 为$S_D$ ,如果多维随机变量 $(X_1,X_2,\cdots,X_n) $ 的联合密度函数为：</p>
<script type="math/tex; mode=display">
p(x_1,x_2,\cdots)=\begin{cases}\dfrac{1}{SD}~~ (x_1,x_2,\cdots,x_n)\in D \\ \\ 0 ~~其他\end{cases}</script><p>则称$(X_1,X_2,\cdots,X_n)$ 服从D上的多维均匀分布，记为 $(X_1,X_2,\cdots,X_n)\sim U(D)$ </p>
<p>二维均匀分布所描述的随机现象就是向平面区域D中随机投点，如果该店坐标$(X,Y)$ 落在D的子区域 G 中的概率只和G的面积有关，而和G的位置无关。 现在用二维均匀分布来描述就是：</p>
<script type="math/tex; mode=display">
P((X,Y)\in G) = \iint_G p(x,y)dxdy = \iint_G\frac{1}{S_D}dxdy = \frac{G的面积}{D的面积}</script><p>推广到多维均匀分布，可以：</p>
<script type="math/tex; mode=display">
\frac{S_a}{S_D} = p((x_1x_2\cdots)\in G) = \int\cdots\int\limits_G P(x_1\cdots x_n)dx_1\cdots dx_n</script><h3 id="n维正态分布"><a href="#n维正态分布" class="headerlink" title="n维正态分布"></a>n维正态分布</h3><p>设 n 维随机变量 $X=(X_1,X_2,\cdots,X_n)’$  的协方差矩阵 $B= Cov(X)$是正定的，数学期望向量为 $a=(a_1,a_2\cdots,a_n)’$ 又记 $x=(x_1,x_2,\cdots,x_n)’$ 则由密度函数：</p>
<script type="math/tex; mode=display">
p(x_1,x_2,\cdots,x_n)=p(x)=\frac{1}{(2\pi)^{\frac{\pi}2}|B|^\frac{1}{2}}\exp{\{-\frac{1}{2}(x-a)^t B^{-1}(x-a)}\}</script><p>  定义的分布称为<strong>n元正态分布</strong>， 记为$X\sim N(a,B)$  . 其中$|B|$表示B的行列式，$B^{-1}$ 表示B的逆矩阵，$(x-a)^t$表示为向量$(x-a)$的转置</p>
<p>在n=2的场合，若取数学期望向量和协方差矩阵分别为</p>
<script type="math/tex; mode=display">
a=\begin{pmatrix} \mu_1 \\ \mu_2 \end{pmatrix} , B=\begin{pmatrix} \sigma_1^2 ~~~~ \sigma_1\sigma_2\rho \\ \sigma_1\sigma_2\rho ~~~~ \sigma_2^2\end{pmatrix}</script><p>带入上面的定义，可以得到二元正态密度函数。</p>
<h3 id="多维指数分布"><a href="#多维指数分布" class="headerlink" title="多维指数分布"></a>多维指数分布</h3><p>特别的，当随机变量个数取2时</p>
<p><img src="/2021/04/04/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F3-1-3-3/1.jpg" style="zoom:80%;"></p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>题目常常会给我们一个二元随机变量$(X,Y)$ 的联合密度函数。要我们求一些概率。</p>
<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p><strong>步骤1：先判断 X,Y 是否相互独立</strong></p>
<p>可以先求一下X，Y的边际分布，如果相互独立，那么会一定程度上减轻之后的计算量</p>
<p><strong>步骤2：利用给出的定义域和题目中的X,Y范围来作图求解/或者利用相互独立的性质求解</strong></p>
<p>比如：设二维随机变量$(X,Y)$ 的联合密度函数为：</p>
<script type="math/tex; mode=display">
p(x,y)=\begin{cases}4xy, ~~0<x<1,0<y<1\\ \\ 0 ,~~~~其他 \end{cases}</script><p>首先，我们可以判断一下X，Y是否相互独立：</p>
<script type="math/tex; mode=display">
p_X(x)=\int_0^1 4xy dy =2x , p_Y(y)=\int_0^1 4xy dx = 2y</script><script type="math/tex; mode=display">
p(x,y) = p_X(x)\cdot p_Y(y)</script><p>因此，X,Y 相互独立。</p>
<p>1) $P(0&lt;X&lt;0.5,0.25&lt;Y&lt;1)$</p>
<p>这一小题既可以使用画图法求解，也可以用边际分布的独立性求解。</p>
<script type="math/tex; mode=display">
P(0<X<0.5,0.25<Y<1)=P(0<X<0.5)P(0.25<Y<1)=\int_0^{0.5} 2x dx\int_{0.25}^1 2y dy = \frac{15}{64}</script><p>2) $P(X=Y)$</p>
<p>这是让我们求一条直线上的概率，显然$P(X=Y)=0$</p>
<p>3) $P(X&lt;Y)$ </p>
<p>这一小题只能使用画图法来求解， 区域就是 $\begin{cases}0&lt;x&lt;1,0&lt;y&lt;1\ \ x&lt;y \end{cases}$</p>
<script type="math/tex; mode=display">
\int_0^1\int_0^x 4xy dydx</script><p>4) $(X,Y)$ 的联合分布函数</p>
<p>求联合分布函数 </p>
<script type="math/tex; mode=display">
F(x,y) = P(X\leq x,Y\leq y) = \int_0^x\int_0^y 4xy~dy dx</script><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>这是另外一种题型，给出X，Y的边际分布列，要我们补全整个联合分布列。</p>
<p>设随机变量 $X_i,i=1,2$ 的分布列如下，且满足 $P(X_1X_2=0)=1$, 试求$P(X_1=X_2)$ </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$X_i$</th>
<th>-1</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>P</td>
<td>0.25</td>
<td>0.5</td>
<td>0.25</td>
</tr>
</tbody>
</table>
</div>
<p><strong>第一步：出$(X_1,X_2)$ 的联合分布列</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>下$X_1$/右$X_2$</th>
<th>-1</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>-1</td>
<td>$p_{11}$</td>
<td>$p_{12}$</td>
<td>$p_{13}$</td>
</tr>
<tr>
<td>0</td>
<td>$p_{21}$</td>
<td>$p_{22}$</td>
<td>$p_{23}$</td>
</tr>
<tr>
<td>1</td>
<td>$p_{31}$</td>
<td>$p_{32}$</td>
<td>$p_{33}$</td>
</tr>
</tbody>
</table>
</div>
<p><strong>第二步：根据第一个条件$P(X_1X_2=0)=1$ 排除所有概率为0的点</strong></p>
<p>已知 $P(X<em>1X_2=0)=1$ ,则 $p</em>{11}=p<em>{13}=p</em>{31}=p_{33}=0$</p>
<p><strong>第三步：根据边际分布列求解方程组</strong></p>
<p>又$P(X<em>1=-1)=0.25=p</em>{11}+p<em>{12}+p</em>{13}$ 所以 $p_{12}=0.25$</p>
<p>同理$P(X<em>1=1)=0.25 =p</em>{31}+p<em>{32}+p</em>{33}$, 所以$p_{32}=0.25$ </p>
<p>$P(X<em>2=-1)=0.25=P(X_2=1) $ 所以$p</em>{21}=p_{23}=0.25$ </p>
<p>现在只剩下$p<em>{22}$未知，根据正则性可以推断$p</em>{22}=0$ </p>
<p><strong>第四步：补全联合分布列并按要求求解</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>下$X_1$/右$X_2$</th>
<th>-1</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>-1</td>
<td>0</td>
<td>0.25</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0.25</td>
<td>0</td>
<td>0.25</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0.25</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>$P(X<em>1=X_2)=p</em>{11}+p<em>{22}+p</em>{33}=0$ </p>
<h1 id="边际分布与随机变量的独立性"><a href="#边际分布与随机变量的独立性" class="headerlink" title="边际分布与随机变量的独立性"></a>边际分布与随机变量的独立性</h1><p>如果在二维随机变量$(X,Y)$ 的联合分布函数 $F(x,y)$ 中令 $y\rightarrow \infty$ ,由于 ${Y&lt;\infty}$ 是必然事件，故：</p>
<p>$\lim\limits_{y\rightarrow\infty} F(x,y) = P(X\leq x,Y\leq y) = P(X\leq x)$ </p>
<p>这是由 $(X,Y)$ 的联合分布函数 $F(x,y)$ 求得的X的分布函数，被称为 X 的边际分布。记为 $F_X(x)=F(x,\infty)$ </p>
<p>类似的，在 $F(x,y)$ 中令 $x\rightarrow \infty$ ，可得$Y$ 的边际分布。$F_Y(y) = F(\infty,y)$</p>
<h3 id="边际分布列"><a href="#边际分布列" class="headerlink" title="边际分布列"></a>边际分布列</h3><p>在二元离散随机变量 $(X,Y)$ 的联合分布 ${P(X=x_1,Y = y_i)}$ 中，对 j 求和所得的分布列：</p>
<p>$\sum_{j=1}^\infty P(X=x_i,Y=y_i)=P(X=x_i),i=1,2\cdots$ 被称为 X 的边际分布列。 </p>
<p>类似的 $\sum_{j=1}^\infty P(X=x_i,Y=y_i)=P(Y=y_i),i=1,2\cdots$ 被称为 Y 的边际分布列</p>
<p>我们可以列一个表来求联合分布列和边际分布列</p>
<p><img src="/2021/04/04/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F3-1-3-3/2.jpg" style="zoom:80%;"></p>
<p>我们对联合分布列的每行每列求和就得到了关于 X和Y的边际分布列。</p>
<h3 id="边际密度函数"><a href="#边际密度函数" class="headerlink" title="边际密度函数"></a>边际密度函数</h3><p>如果二维连续随机变量 $(X,Y)$ 的联合密度函数为 $p(x,y)$ </p>
<p>$F<em>X(x)=F(x,\infty) = \int</em>{-\infty}^x(\int<em>{-\infty}^{\infty}p(u,v)dv)du =\int</em>{-\infty}^x p_X(u)du$    </p>
<p>$F<em>Y(y)=F(\infty,y) = \int</em>{-\infty}^y(\int<em>{-\infty}^{\infty}p(u,v)dv)du =\int</em>{-\infty}^y p_Y(v)dv$</p>
<p>将其分别求导得到：$p_X(x)$和$p_Y(y)$     分别为：</p>
<p>$p<em>X(x)=\int</em>{-\infty}^{\infty}p(x,y)dy$ </p>
<p>$p<em>Y(y)=\int</em>{-\infty}^{\infty} p(x,y)dx$ </p>
<p>$p_X(x)$ 为 X 的边际密度函数，$p_Y(y)$ 为y的边际密度函数</p>
<p>由联合密度函数求边际密度函数时，要注意<strong>积分区域的确定</strong>。<img src="/2021/04/04/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F3-1-3-3/3.jpg" style="zoom:80%;"></p>
<p><img src="/2021/04/04/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F3-1-3-3/4.jpg" style="zoom:80%;"></p>
<h3 id="常见多维分布的边际分布"><a href="#常见多维分布的边际分布" class="headerlink" title="常见多维分布的边际分布"></a>常见多维分布的边际分布</h3><h4 id="多维分布的边际分布"><a href="#多维分布的边际分布" class="headerlink" title="多维分布的边际分布"></a>多维分布的边际分布</h4><p>这时候，三项分布实际上是二维随机变量 $(X_1,X_2)$ 的分布。</p>
<p>我们可以列出密度函数： </p>
<p><img src="/2021/04/04/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F3-1-3-3/3.png" style="zoom:80%;"></p>
<p>那么，三项分布的边际分布等于什么？我们来算一下：</p>
<p><img src="/2021/04/04/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F3-1-3-3/8.png" style="zoom:80%;"></p>
<h4 id="二维指数分布的边际分布"><a href="#二维指数分布的边际分布" class="headerlink" title="二维指数分布的边际分布"></a>二维指数分布的边际分布</h4><p>设$(X_1,X_2)$服从二维指数分布，其 Joint CDF为： </p>
<script type="math/tex; mode=display">
F(X_1,X_2)=\begin{cases}1-e^{-x_1}-e^{-x_2}+e^{-x_1-x_2-\lambda x_1x_2} \\ \\ 0 ~~其他\end{cases}</script><p>求其边际分布的密度函数</p>
<script type="math/tex; mode=display">
F_{X_1}(x_1)=F(X_1,+\infty) = \lim\limits_{x\rightarrow\infty}(1-e^{x_1}-e^{x_2}+e^{-x_1-x_2-\lambda x_1x_2}) = 1-e^{-x_1}</script><h4 id="二维正态函数的边际分布"><a href="#二维正态函数的边际分布" class="headerlink" title="二维正态函数的边际分布"></a>二维正态函数的边际分布</h4><p>首先我们定义二元正态分布 $(X,Y)\sim N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)$ ，其中 $-\infty &lt;\mu_1,\mu_2&lt;\infty , \sigma_1,\sigma_2&gt;0,-1\leq \rho\leq 1$ </p>
<p>那么这个其 Joint PDF 为</p>
<script type="math/tex; mode=display">
p(x,y) = \frac{1}{2\pi\sigma_1\sigma_2\sqrt{1-\rho^2}} \exp\{-\frac{1}{2(1-\rho^2)}[\frac{(x-\mu_1)^2}{\sigma_1^2}-2\rho\frac{(x-\mu_1)(y-\mu_2)}{\sigma_1\sigma_2}+\frac{(y-\mu_2)^2}{\sigma_2^2}]\}</script><p>求其编辑分布，先来关注它的指数部分，可以改写成</p>
<script type="math/tex; mode=display">
-\frac{1}{2}(\rho\frac{x-\mu_1}{\sigma_1\sqrt{1-\rho^2}}-\frac{y-\mu_2}{\sigma_2\sqrt{1-\rho^2}})^2-\frac{(x-\mu_1)^2}{2\sigma_1^2}</script><p>然后对其求积分，根据边际分布的定义可知</p>
<script type="math/tex; mode=display">
F_X(x) = \int_{-\infty}^{\infty}p(x,y)dy</script><p>那么 </p>
<script type="math/tex; mode=display">
\int_{-\infty}^{\infty} \exp\{-\frac{1}{2}(\rho\frac{x-\mu_1}{\sigma_1\sqrt{1-\rho^2}}-\frac{y-\mu_2}{\sigma_2\sqrt{1-\rho^2}})^2-\frac{(x-\mu_1)^2}{2\sigma_1^2}\}dy</script><p>后面部分和y无关</p>
<p>令 </p>
<script type="math/tex; mode=display">
t =\rho\frac{x-\mu_1}{\sigma_1\sqrt{1-\rho^2}}-\frac{y-\mu_2}{\sigma_2\sqrt{1-\rho^2}}</script><p>则</p>
<script type="math/tex; mode=display">
{d(t)} = -(\sigma_2\sqrt{1-\rho^2})/\sigma_2^2({1-\rho^2})</script><script type="math/tex; mode=display">
p_X(x)=\frac{1}{2\pi\sigma_1\sigma_2\sqrt{1-\rho^2}}\exp\{-\frac{(x-\mu_1)^2}{2\sigma_1^2}\}\sigma_2\sqrt{1-\rho^2}\int_{-\infty}^{\infty} {-\frac{t^2}2}dt</script><p>已知 $\int_{-\infty}^{\infty}-\frac{t^2}{2} dt = \sqrt{2\pi}$ </p>
<p>所以原式可写为：</p>
<script type="math/tex; mode=display">
p_X(x)=\frac{1}{\sqrt{2\pi}\sigma_1}\exp\{-\frac{(x-\mu_1)^2}{2\sigma_1^2}\}</script><p>这就是一维正态分布$N(\mu_1,\sigma_1^2)$ 的密度函数。</p>
<p>从上面的证明可以看出：</p>
<ul>
<li>二维正态分布的边际分布中，是不含有参数$\rho$的</li>
<li>$N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2.0.1)$ 和 $N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2.0.2)$ 的边际分布是相同的</li>
<li>具有相同边际分布的多维联合分布可以使不同的。</li>
</ul>
<h3 id="随机变量间的独立性"><a href="#随机变量间的独立性" class="headerlink" title="随机变量间的独立性"></a>随机变量间的独立性</h3><p>设n维随机变量$(X<em>1,X_2,\cdots,X_n)$的联合分布函数为$F(x_1,x_2,\cdots,x_n)$ ,$F_i(x_i)$为$X_i$ 的边际分布函数。 如果对任意n个实数$x_1,x_2,\cdots,x_n$ 有 $F(x_1,x_2,\cdots,x_n)=\prod\limits</em>{i=1}^nF_i(x_i)$   则称$X_1,X_2,\cdots,X_n$相互独立</p>
<p>那么在离散和连续的场合我们就可以这么来写：</p>
<script type="math/tex; mode=display">
\begin{cases}P(X_1=x_1,X_2=x_2,\cdots,X_n=x_n)=\prod\limits_{i=1}^nP(X_i=x_i) ~~在离散场合\\ \\ P(x_1,x_2,\cdots,x_n)=\prod\limits_{i=1}^np_i(x_i) ~~在连续场合\end{cases}</script><p>则称$X_1,X_2,\cdots,X_n$相互独立。</p>
<p>之前，由联合分布可以求出边际分布，但是由边际分布不一定能求出联合分布。但是如果我们知道了随机变量间是相互独立的，则可以<strong>由边际分布的乘积求出联合分布</strong>。  同样的，现在我们也可以通过计算<strong>联合分布</strong>是否等于各个随机变量<strong>边际分布</strong> 的乘积来判断随机变量之间<strong>是否相互独立</strong>。</p>
<h1 id="多维随机变量函数的分布"><a href="#多维随机变量函数的分布" class="headerlink" title="多维随机变量函数的分布"></a>多维随机变量函数的分布</h1><h4 id="例题1：-当Z为离散可列的随机变量时"><a href="#例题1：-当Z为离散可列的随机变量时" class="headerlink" title="例题1： 当Z为离散可列的随机变量时"></a>例题1： 当Z为离散可列的随机变量时</h4><p>设X和Y是相互独立的随机变量，且 $X\sim Exp(\lambda),Y\sim Exp{(\mu)}$ 如果定义随机变量 </p>
<script type="math/tex; mode=display">
Z=\begin{cases}1 ,~~X\leq Y\\ \\ 0 ~~,X>Y\end{cases}</script><p>求 Z 的分布列。</p>
<p><strong>第一步：列出联合随机变量：</strong> </p>
<p>因为 $X$ 和 $Y$ 相互独立，所以 $p(x,y)=p_X(x)p_Y(y)=\begin{cases}\lambda\mu e^{-\lambda x-\mu y} ,~~X\leq Y\ \ 0 ~~,X&gt;Y\end{cases}$</p>
<p><strong>第二步：列出Z的取值</strong></p>
<p>在说到一元离散随机变量函数的分布时，当 $Y=g(X)$ 时，Y的分布列就按照Y的取值 一一列举,并根据取值范围计算。在多元情况下也是这样。这里 Z 有两个取值：</p>
<script type="math/tex; mode=display">
p(Z=1)=p(X\leq Y)=\int_0^\infty\int_x^\infty \lambda\mu e^{-\lambda x-\mu y}dydx\\
=\int_0^\infty\lambda\mu e^{-\lambda x}dx\int_x^\infty e^{-\mu y}dy\\
=\int_0^\infty\lambda\mu e^{-\lambda x}\frac{-1}{\mu}(0-e^{-\mu x})dx\\
=\lambda \int_0^\infty e^{-\lambda x-\mu x}dx\\
=\frac{\lambda}{\lambda+\mu}</script><p>关于$p(Z=0)$和 $p(Z=1)$的原理是一样的，但是这里可以直接利用 $1-P(X\leq Y)$ 计算，即 $\frac{\mu}{\lambda+\mu}$</p>
<p>设$(X_1,X_2,\cdots,X_n)$ 为 n 维随机变量，则 $(X_1,X_2,\cdots,X_n)$ 的函数$Y=g(X_1,X_2,\cdots,X_n)$  是一维随机变量。</p>
<p>现在问题就是已经知道了 $(X_1,X_2,\cdots,X_n)’$ 的联合分布/分布列/pdf,怎么求 $Y=g(X_1,X_2,\cdots,X_n)$ 的分布</p>
<h4 id="例题2：-当Z为连续随机变量时"><a href="#例题2：-当Z为连续随机变量时" class="headerlink" title="例题2： 当Z为连续随机变量时"></a>例题2： 当Z为连续随机变量时</h4><p>设X与Y的联合密度函数为 </p>
<script type="math/tex; mode=display">
p(x,y)=\begin{cases}e^{-x-y} ,~~x>0,y>0\\ \\ 0 ~~,else\end{cases}</script><p>求以下随机变量的<strong>密度函数：</strong> $Z=(X+Y)/2$ , $Z=Y-X$</p>
<p>对于 $Z=(X+Y)/2 $ 比较简单</p>
<p><strong>第一步：理清思路</strong></p>
<p>首先我们要画出关键词，这里要我们求的是密度函数而不是分布函数。 那么$P_Z(z)$怎么求？可以先求出 $F_Z(z)$ 再根据求导算出。</p>
<p><strong>第二步： 给出Z的取值范围</strong></p>
<p>已知 $x&gt;0,y&gt;0$ 又有 $Z=(X+Y)/2$ 因此 $z&gt;0$</p>
<p><strong>第三步：求出Z的分布函数</strong></p>
<p>$F_Z(z)=P_Z(Z\leq z)=P_Z(X+Y\leq 2Z)$  </p>
<p>已知x，y的联合分布，求$X+Y\leq 2Z$ 这种套路是我们常见的——使用画图后求积分即可。 因此</p>
<script type="math/tex; mode=display">
F_Z(z)=P_Z(X+Y\leq2Z)=\int_0^{2z}\int_0^{2z-x}e^{-x-y} dydx =1-e^{-2z}-2ze^{-2z} ，z>0</script><p><strong>第三步： 求密度函数</strong> $p_Z(z)$</p>
<p>$p_Z(z)=F_Z’(z)=2e^{-2z}+4ze^{-2z}-2e^{-2z}=4ze^{-2z},z&gt;0$ </p>
<p>对于$Z=Y-X$ ,需要做分类讨论</p>
<p><strong>第一步：确定Z的取值范围</strong></p>
<p>因为 $Z=Y-X$, 则 Z 可为实数轴上的任意数。</p>
<p><strong>第二步：分类讨论，情况1</strong></p>
<p>当 $Z\leq 0$时，说明 $Y\leq X$</p>
<p>$F_Z(z)=P_Z(Z\leq z)=P(Y-X\leq z)$ </p>
<p>通过画图可知,原式等于：</p>
<script type="math/tex; mode=display">
\int_{-z}^\infty\int_0^{z+x} e^{-y-x} dydx=\frac{1}{2}e^z</script><p>由此， $p_Z(z)=F_Z’(z)=\frac{1}{2}e^z$ </p>
<p><strong>第三步：分类讨论，情况2</strong></p>
<p>当 $Z&gt; 0$时，说明 $Y&gt; X$ </p>
<p>$F_Z(z)=P_Z(Z\leq z)=P(Y-X\leq z)$ </p>
<p>通过画图可知：</p>
<script type="math/tex; mode=display">
\int_{0}^\infty\int_x^{z+x} e^{-y-x} dydx=\frac{1}{2}(1-e^{-z}), z\in R</script><p>由此， $p_Z(z)=F’_Z(z)=\frac{1}{2}e^{-z}， z\in R$</p>
<p>综上可得： $p_Z(z)= e^{-|z|}/2, z\in R$</p>
<h2 id="卷积公式"><a href="#卷积公式" class="headerlink" title="卷积公式"></a>卷积公式</h2><h3 id="在离散场合下"><a href="#在离散场合下" class="headerlink" title="在离散场合下"></a>在离散场合下</h3><p>设X与Y是两个<strong>相互独立的离散随机变量</strong>。取值范围为0，1，2 。$Z=X+Y$ ,那么事件 ${Z=k}$ 是如下诸互不相容事件的并：</p>
<script type="math/tex; mode=display">
\{X=i,Y=k-i\}， ~~ i=0,1,\cdots,k</script><p>在考虑到独立性，则对任意非负整数 k， 有 </p>
<p>$P(Z=k)=\sum\limits_{i=0}^k P(X=i)P(Y=k-i)$ </p>
<p>这个概率等式被称为离散场合下的卷积公式</p>
<h3 id="在连续场合下"><a href="#在连续场合下" class="headerlink" title="在连续场合下"></a>在连续场合下</h3><p>设X与Y是<strong>两个相互独立的连续随机变量</strong>，其密度函数分数分别$p_X(x)$和$p_Y(y)$ ，则其和 $Z=X+Y$ 的密度函数为: </p>
<script type="math/tex; mode=display">
p_Z(z)=\int_{-\infty}^{\infty} p_X(z-y)p_Y(y)dy = \int_{-\infty}^{\infty} p_X(x)p_Y(z-x)dx</script><h2 id="卷积公式在离散场合下的应用"><a href="#卷积公式在离散场合下的应用" class="headerlink" title="卷积公式在离散场合下的应用"></a>卷积公式在离散场合下的应用</h2><ol>
<li>当$(X_1,X_2,\cdots,X_n)$ 的所有可能取值比较少的时候，可以将 $Y$ 值一一列出，然后再合并就可以得出结果。</li>
</ol>
<p><img src="/2021/04/04/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F3-1-3-3/5.jpg" style="zoom:80%;"></p>
<p><img src="/2021/04/04/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F3-1-3-3/6.jpg" style="zoom:80%;"></p>
<p><img src="/2021/04/04/%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F3-1-3-3/7.jpg" style="zoom:80%;"></p>
<h3 id="泊松分布的可加性"><a href="#泊松分布的可加性" class="headerlink" title="泊松分布的可加性"></a>泊松分布的可加性</h3><p>设随机变量$X\sim P(\lambda_1)$, $Y\sim P(\lambda_2)$ ，且X与Y相互独立，证明： $Z=X+Y\sim P(\lambda_1+\lambda_2)$ </p>
<script type="math/tex; mode=display">
P(Z=k) =\sum\limits_{i=0}^k(\frac{\lambda_1^i}{i!}e^{-\lambda_1})(\frac{\lambda_2^{k-i}}{(k-i)!}e^{-\lambda_2}) \\</script><p>合并同类项，先把常数取出，然后将后面的求和部分配方成一个二项分布。</p>
<script type="math/tex; mode=display">
=\frac{e^{-(\lambda_1+\lambda_2)}{(\lambda_1+\lambda_2)^k}}{k!}\sum_{i=0}^k\frac{k!}{i!(k-i)!}(\frac{\lambda_1}{\lambda_1+\lambda_2})^i(\frac{\lambda_2}{\lambda_1+\lambda_2})^{k-i}</script><p>前面乘了 $(\lambda_1+\lambda_2)^k$,后面除了 $(\lambda_1+\lambda_2)^k$ ,前面除了 $k!$, 后面乘$k!$ ，目的就是把求和部分当成是一个二项分布的pdf，根据pdf性质可知求和部分的值为1.</p>
<p>所以最终得到 ： </p>
<script type="math/tex; mode=display">
=\frac{(\lambda_1+\lambda_2)^k}{k!}e^{-(\lambda_1+\lambda_2)}</script><p>也就是说，泊松分布的卷积仍然是泊松分布。这是一个新的泊松分布，记为  $P(\lambda_1)*P(\lambda_2)=P(\lambda_1+\lambda_2)$ ,</p>
<p>这个性质可以推广到有限个独立泊松变量之和的分布上去：</p>
<script type="math/tex; mode=display">
P(\lambda_1)*P(\lambda_2)*\cdots P(\lambda_n) =P(\lambda_1+\lambda_2+\cdots+\lambda_n)</script><p>特别的，当 $\lambda_1=\cdots=\lambda_n$ 时，有 $p(\lambda)<em>p(\lambda)\cdots</em>p(\lambda)=p(n\lambda)$ </p>
<h3 id="二项分布的可加性"><a href="#二项分布的可加性" class="headerlink" title="二项分布的可加性"></a>二项分布的可加性</h3><p>事实上，不仅仅是泊松分布有可加性，二项分布也具有可加性：设随机变量$X\sim b(n,p),Y\sim b(m,p)$ 且X与Y独立，那么 $Z=X+Y\sim b(n+m,p)$ </p>
<p>这个性质也可以推广到有限个场合：</p>
<script type="math/tex; mode=display">
b(n_1,p)*b(n_2,p)*\cdots *b(n_k,p)=b(n_1+\cdots+n_k,p)</script><p>特别的，当 $n_1=n_2=\cdots=n_k=1$ 时，$b(1,p)<em>b(1,p)\cdots</em>b(1,p)=b(k,p)$</p>
<p>这表明，如果 $X<em>1,X_2,\cdots X_n$ 独立同分布，都服从 $b(1,p)$ 分布，则其和 $\sum</em>{i=1}^n X_i\sim b(n,p)$ </p>
<p>或者说，服从二项分布 $b(n,p)$ 的随机变量都可以分解为 n 个相互独立的 $0-1$ 分布的随机变量之和。</p>
<h2 id="卷积公式在连续场合下的应用"><a href="#卷积公式在连续场合下的应用" class="headerlink" title="卷积公式在连续场合下的应用"></a>卷积公式在连续场合下的应用</h2><h3 id="正态分布的可加性"><a href="#正态分布的可加性" class="headerlink" title="正态分布的可加性"></a>正态分布的可加性</h3><p>设随机变量 $X\sim N(\mu_1,\sigma_1^2), Y\sim N(\mu_2.\sigma_2^2)$  ,且 X 与 Y 互相独立，那么$Z=X+Y\sim N(\mu_1+\mu_2, \sigma_1^2+\sigma_2^2)$ </p>
<p>也就是说，两个独立的正态分布之和仍然为正态变量，其分布中的两个参数分别对应相加，即：</p>
<script type="math/tex; mode=display">
N(\mu_1,\sigma_1^2)*N(\mu_2,\sigma_2^2)=N(\mu_1+\mu_2,\sigma_1^2+\sigma_2^2)</script><p>证明：首先可以知道 Z=X+Y的取值范围是 $(-\infty,\infty)$ ,那么利用卷积公式可以得到：</p>
<script type="math/tex; mode=display">
p_Z(z)=\int_{-\infty}^\infty p_Y(y)p_X(z-y)dy\\
=\frac{1}{2\pi\sigma_1\sigma_2}\int_{-\infty}^{\infty} \exp\{-\frac{1}{2}[\frac{(z-y-\mu_1)^2}{\sigma_1^2}-\frac{(y-\mu_2)^2}{\sigma_2^2}]\}\\</script><p>将积分式子中的指数部分按照y的幂展开，再合并同类项：</p>
<script type="math/tex; mode=display">
\frac{(z-y-\mu_1)^2}{\sigma_1^2}-\frac{(y-\mu_2)^2}{\sigma_2^2} =</script><p>显然，这个结论可以推广到有限个独立正态变量之和的场合</p>
<p>另外，我们还知道，若随机变量 $X\sim N(\mu,\sigma^2)$ ,则对任意非零实数a有 $aX\sim N(a\mu,a^2\mu^2)$ 。</p>
<p>因此，我们可以得到一个<strong>重要结论</strong>， 即</p>
<script type="math/tex; mode=display">
a_1X_1+a_2X_2+\cdots+a_nX_n \sim N(\mu_0,\sigma_0^2)</script><p>若$X_i\sim N(\mu_1,\sigma_1^2),i=1,2\cdots,n$则参数 $\mu_0$与 $\sigma_0^2$ 分别为：</p>
<script type="math/tex; mode=display">
\mu_0 = \sum_{i=1}^n a_i\mu_i\\ \sigma_0^2 = \sum_{i=1}^n a_i^2\sigma_i^2</script><p>譬如， 若 $X\sim N(-3,1),Y\sim N(2,1)$ 且 X与Y 独立，则：</p>
<p>$Z=X-2Y+7 \sim N(-3-2<em>2+7,1+2^2</em>2)=N(0,5)$</p>
<h3 id="伽马分布的可加性"><a href="#伽马分布的可加性" class="headerlink" title="伽马分布的可加性"></a>伽马分布的可加性</h3><p>设随机变量 $X\sim Ga(\alpha_1,\lambda)~,~ Y\sim Ga(\alpha_2,\lambda)$ , 且X与Y 独立，则 $Z=X+Y\sim Ga(\alpha_1+\alpha_2,\lambda)$ </p>
<p>这个结论表明，两个尺度参数相同的独立的伽马变量之和仍然是伽马变量，其尺度参数不变, 而形状参数相加。即</p>
<script type="math/tex; mode=display">
Ga(\alpha_1,\lambda)*Ga(\alpha_2,\lambda) = Ga(\alpha_1+\alpha_2,\lambda)</script><script type="math/tex; mode=display">
p_Z(z)=\int_{-\infty}^\infty p_Y(y)p_X(z-y)dy\\
=\frac{\lambda^{\alpha_1+\alpha_2}}{\Gamma(\alpha_1)\Gamma(\alpha_2)}\int_0^z (z-y)^{\alpha_1-1}e^{-\lambda(z-y)}y^{\alpha_2-1}e^{-\lambda y} dy \\
=\frac{\lambda^{\alpha_1+\alpha_2}}{\Gamma(\alpha_1)\Gamma(\alpha_2)} e^{-\lambda z} \int_0^z(z-y)^{\alpha_1-1}y^{\alpha_2-1}dy\\</script><p>令 $y=zt$ ，则$dy = zdt$ 带入原式可得 </p>
<script type="math/tex; mode=display">
=\frac{\lambda^{\alpha_1+\alpha_2}}{\Gamma(\alpha_1)\Gamma(\alpha_2)} e^{-\lambda z} z^{\alpha_1+\alpha_2-1}\int_0^1(1-t)^{\alpha_1-1}t^{\alpha_2-1}dt</script><p>我们看到这个积分的式子和 贝塔函数是一模一样的，贝塔函数 $B(\alpha_1,\alpha_2)=\frac{\Gamma(\alpha_1)\Gamma(\alpha_2)}{\Gamma(\alpha_1+\alpha_2)}$</p>
<p>最后，相乘我们得到：</p>
<script type="math/tex; mode=display">
\frac{\lambda^{\alpha_1+\alpha_2}}{\Gamma(\alpha_1+\alpha_2)} z^{\alpha_1+\alpha_2-1}e^{-\lambda z}</script><p>很明显，这个式子是一个 伽马分布 ，符合 $Ga(\alpha_1+\alpha_2,\lambda)$</p>
<p>这个结论可以推广到有限个尺度参数相同的独立伽马变量之和上</p>
<h4 id="特殊的：指数分布"><a href="#特殊的：指数分布" class="headerlink" title="特殊的：指数分布"></a>特殊的：指数分布</h4><p>指数分布是 $\alpha=1$ 的伽马分布，即 $Exp(\lambda)=Ga(1,\lambda)$ </p>
<p>那么m个独立同分布的指数变量之和是一个伽马变量 $Exp(\lambda)*Exp(\lambda)\cdots Exp(\lambda)=Ga(m,\lambda)$  。也就是说指数分布不满足可加性</p>
<h4 id="特殊的：-卡方分布"><a href="#特殊的：-卡方分布" class="headerlink" title="特殊的： 卡方分布"></a>特殊的： 卡方分布</h4><p>卡方分布： $\chi^2(n)= Ga(\frac{n}{2},\frac{1}{2})$</p>
<p>那么 m个独立的$\chi^2$变量之和为 $\chi^2$ 变量，即</p>
<script type="math/tex; mode=display">
\chi^2(n_1)*\chi^2(n_2)\cdots\chi^2(n_m)=\chi^2(n_1+n_2+\cdots+n_m)</script><h2 id="极值分布"><a href="#极值分布" class="headerlink" title="极值分布"></a>极值分布</h2><p>已知$x_1,x_2,\cdots,x_n$</p>
<p>现在令 $Y=\max{x_1,x_2,\cdots,x_n},Z=\min{x_1,x_2,\cdots,x_n}$</p>
<p>问Y与Z的分布,这就是极值分布</p>
<p>乍一看似乎极值没啥用。但是在现实生活中极值分布的使用场景非常广泛：</p>
<p>今年夏天最高温会不会是40摄氏度，水坝的高度必须覆盖水库的最高水位之类的问题。</p>
<p>极值分布与相互独立的随机变量$X_i$ 的分布有很大的关系。</p>
<h3 id="最大值分布"><a href="#最大值分布" class="headerlink" title="最大值分布"></a>最大值分布</h3><h4 id="当-X-i-sim-F-i-x-i-1-2-cdots-n-时"><a href="#当-X-i-sim-F-i-x-i-1-2-cdots-n-时" class="headerlink" title="当 $X_i\sim F_i(x)$, $i=1,2\cdots,n$ 时"></a>当 $X_i\sim F_i(x)$, $i=1,2\cdots,n$ 时</h4><p>因为 $X_1,X_2\cdots,X_n$的最大值小于等于 y，那么这就说明 $X_1,X_2\cdots,X_n $中的每一个都$\leq y$，又$X_i$是独立的，那么联合分布就可以表示为边际分布的乘积。</p>
<p>此时，$Y=\max{X_1,X_2,\cdots,X_n}$ 的分布函数为：</p>
<script type="math/tex; mode=display">
F_Y(y)= P(max\{X_1,X_2\cdots,X_n\}\leq y)=P(X_1\leq y,X_2\leq y,\cdots,X_n\leq y)\\
=P(X_1\leq y)P(X_2\leq y)\cdots P(X_n\leq y)=\prod_{i=1}^n F_i(y)</script><h4 id="当-X-i-sim-F-x-，即-所有-X-i-同分布时"><a href="#当-X-i-sim-F-x-，即-所有-X-i-同分布时" class="headerlink" title="当$X_i\sim F(x)$ ，即 所有$X_i$同分布时"></a>当$X_i\sim F(x)$ ，即 所有$X_i$同分布时</h4><p>此时，$Y=\max{X_1,X_2,\cdots,X_n}$ 的分布函数为：</p>
<p>这是第一种情况的特殊状况，即 $F_Y(y)=[F(y)]^n$</p>
<h4 id="当-X-i-为连续随机变量且同分布时，密度为-p-x"><a href="#当-X-i-为连续随机变量且同分布时，密度为-p-x" class="headerlink" title="当$X_i$为连续随机变量且同分布时，密度为 $p(x)$"></a>当$X_i$为连续随机变量且同分布时，密度为 $p(x)$</h4><p>此时，$Y=\max{X_1,X_2,\cdots,X_n}$ 的分布函数为：</p>
<p>这也是一种特殊情况， $F_Y(y)=[F(y)]^n$， 因为$X_i$是连续随机变量，那么我们也可以求 $Y$ 的 pdf为$p_Y(y)=n[F(y)]^{n-1}p(y)$ </p>
<h4 id="当-X-i-sim-Exp-lambda-i-1-2-cdots-n-时候"><a href="#当-X-i-sim-Exp-lambda-i-1-2-cdots-n-时候" class="headerlink" title="当 $X_i\sim Exp(\lambda),i=1,2\cdots,n$ 时候"></a>当 $X_i\sim Exp(\lambda),i=1,2\cdots,n$ 时候</h4><p>此时，$Y=\max{X_1,X_2,\cdots,X_n}$ 的分布函数为：</p>
<p>这符合$X_i$为连续随机变量且同分布的情况，因此已知 $p_X(x)=\lambda e^{-\lambda}$ 对其求积分得到 $F_X(x)=1-e^{-\lambda x}$</p>
<script type="math/tex; mode=display">
F_Y(y)=\begin{cases} 0 ,~~y<0\\ \\ (1-e^{-\lambda x})^n,~~y\geq 0 \end{cases}</script><p>然后对$F_Y(y)$求导，可以得到：</p>
<script type="math/tex; mode=display">
p_Y(y)=\begin{cases} 0 ,~~y<0\\ \\ n(1-e^{-\lambda x})^{n-1}\lambda e^{-\lambda x },~~y\geq 0 \end{cases}</script><h3 id="最小值分布"><a href="#最小值分布" class="headerlink" title="最小值分布"></a>最小值分布</h3><h4 id="当-X-i-sim-F-i-x-i-1-2-cdots-n-时-1"><a href="#当-X-i-sim-F-i-x-i-1-2-cdots-n-时-1" class="headerlink" title="当 $X_i\sim F_i(x)$, $i=1,2\cdots,n$ 时"></a>当 $X_i\sim F_i(x)$, $i=1,2\cdots,n$ 时</h4><p>求最小值分布的时候我们要做多次变换，但是只要牢记 $F_X(x)= P(X\leq x)=1-P(X&gt;x)$即可</p>
<p>此时，$Z=\min{X_1,X_2,\cdots,X_n}$ 的分布函数为：</p>
<script type="math/tex; mode=display">
F_Z(z)=P(\min\{X_i,X_2,\cdots,X_n\}\leq z)\\
=1-P(min\{X_1,X_2\cdots,X_n\}> z)\\
=1-P(X_1> z,X_2> z,\cdots,X_n> z)\\
=1-P(X_1>z)P(X_2>z)\cdots P(X_n>z)\\
=1-\prod_{i=1}^n[1-F_i(z)]</script><h4 id="当-X-i-sim-F-x-，即-所有-X-i-同分布时-1"><a href="#当-X-i-sim-F-x-，即-所有-X-i-同分布时-1" class="headerlink" title="当$X_i\sim F(x)$ ，即 所有$X_i$同分布时"></a>当$X_i\sim F(x)$ ，即 所有$X_i$同分布时</h4><p>此时，$Z=\min{X_1,X_2,\cdots,X_n}$ 的分布函数为：</p>
<p>将$X_i$的共通分布函数$F(x)$ 代入上式，可得：</p>
<p>$F_Z(z)=1-[1-F_i(z)]^n$</p>
<h4 id="当-X-i-为连续随机变量且同分布时，密度为-p-x-1"><a href="#当-X-i-为连续随机变量且同分布时，密度为-p-x-1" class="headerlink" title="当$X_i$为连续随机变量且同分布时，密度为 $p(x)$"></a>当$X_i$为连续随机变量且同分布时，密度为 $p(x)$</h4><p>此时，$Y=\min{X_1,X_2,\cdots,X_n}$ 的分布函数为：$F_Z(z)=1-[1-F_i(z)]^n$</p>
<p>另外，对$F_Z(z)$求导可以获得 $p_Z(z)$:</p>
<p>$p_Z(z)=F’_z(z)=n[1-F(z)]^{n-1}p(z)$</p>
<h4 id="当-X-i-sim-Exp-lambda-i-1-2-cdots-n-时候-1"><a href="#当-X-i-sim-Exp-lambda-i-1-2-cdots-n-时候-1" class="headerlink" title="当 $X_i\sim Exp(\lambda),i=1,2\cdots,n$ 时候"></a>当 $X_i\sim Exp(\lambda),i=1,2\cdots,n$ 时候</h4><p>此时，$Y=\min{X_1,X_2,\cdots,X_n}$ 的分布函数为：</p>
<p>带入上面的式子 ，可以得到：</p>
<p>这符合$X_i$为连续随机变量且同分布的情况，因此已知 $p_X(x)=\lambda e^{-\lambda}$ 对其求积分得到 $F_X(x)=1-e^{-\lambda x}$</p>
<script type="math/tex; mode=display">
F_Y(y)=\begin{cases} 0 ,~~y<0\\ \\ 1-\prod_{i=1}^n[1-1+e^{\lambda x}],~~y\geq 0 \end{cases}=\begin{cases} 0 ,~~y<0\\ \\ 1-e^{\lambda xn},~~y\geq 0 \end{cases}</script><p>然后对$F_Y(y)$求导，可以得到：</p>
<script type="math/tex; mode=display">
p_Y(y)=\begin{cases} 0 ,~~y<0\\ \\ n\lambda e^{-n\lambda x} ~~,y>0\end{cases}</script><p>我们发现，当$X_i$ 服从参数为 $\lambda $ 的指数分布，则 $\max{X_1,X_2\cdots,X_n}$ 是不服从指数分布的，但是$\min{X_1,X_2\cdots,X_n}\sim Exp{(n\lambda)}$  是符合指数分布的。</p>
<h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p>关于极值分布，一般的题型<strong>求离散随机变量的最大/小值分布列</strong></p>
<p>随机变量的分布列的公式这里这样表示：</p>
<script type="math/tex; mode=display">
p_X(k) = F_X(k)-F_X(k-1) = P(X\leq k)-P(X\leq k-1)</script><p>这样，我们就可以通过求 $F_X(x)$ 来计算X的分布列。</p>
<h4 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h4><p>设随机变量X，Y独立同分布，那么当X服从几何分布，即$P(X=k)=(1-p)^{k-1}p,~k=1,2\cdots$ ，求随机变量$Z=\max{X,Y}$ 的分布列</p>
<p>这题要我们求$\max{X,Y}$的分布列，那么我们就可以用上面这个公式</p>
<p><strong>第一步：求出 X,Y 的密度函数和分布函数</strong> </p>
<p>已知 X,Y  的密度函数和分布函数</p>
<script type="math/tex; mode=display">
p_X(x)=(1-p)^{x-1}p,F_X(x)=P_X(X\leq x)=\sum_{i=1}^x(1-p)^{i-1}p =1-(1-p)^x</script><p><strong>第二步：求出Z的分布函数</strong> </p>
<p>因为$Z=\max{X,Y}$ ，$X,Y$又是独立同分布的，因此</p>
<script type="math/tex; mode=display">
F_Z(z)=[F(z)]^n=(1-(1-p)^x)^2,z=1,2\cdots</script><p><strong>第三步：求出Z的分布列</strong></p>
<script type="math/tex; mode=display">
P(Z=i)=P(Z\leq i)-P(Z\leq i-1)\\
=(1-(1-p)^i)^2-(1-(1-p)^{i-1})^2
=(1-p)^{i-1}p[2-(1-p)^{i-1}-(1-p)^{i}],i=1,2\cdots</script><p><em>ps:</em>  千万别忘了写上取值范围！！！</p>
<h4 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h4><p>假设高尔夫成绩是一个随机变量，其得分的分布是${101,\cdots,110}$ 上的均匀分布。 为了改进成绩，你决定将 3 天的<strong>最小分数</strong>作为你的分数X，即$X$等于 $\min{X_1,X_2,X_3}$ ,其中$X_i,i=1,2,3$ 表示三天的分数：求<strong>计算X的分布列</strong></p>
<p><strong>第一步：求出$X_i$ 的密度函数和分布函数 </strong> </p>
<p>已知 $X_i\sim U(101,110)$</p>
<script type="math/tex; mode=display">
p_{i}(x_i)=\begin{cases} \frac{1}{10} ,~~101\leq x\leq110\\ \\ 0 ~~其他 \end{cases}, F_{i}(x_i)=\begin{cases} \frac{x-100}{10},~~ 101\leq x\leq 110\\ \\ 0, 其他\end{cases}</script><p><strong>第二步：求 X 的分布函数</strong></p>
<p>因为$X_i$ 是独立同分布，那么 $X\sim \min{X_1,X_2,X_3}$ 的分布函数为：</p>
<script type="math/tex; mode=display">
1-[1-F(x)]^n=1-[1-\frac{x-100}{10}]^3=1-(\frac{110-x}{10})^3</script><script type="math/tex; mode=display">
F_X(x)=\begin{cases} 1-(\frac{110-x}{10})^3 ~~101\leq x\leq 110\\ \\ 0, x<101\\ \\1,x>110\end{cases}</script><p><strong>第三步：求X的分布列</strong></p>
<script type="math/tex; mode=display">
p_X(k) = F_X(k)-F_X(k-1)=\begin{cases} \frac{(111-k)^3-(110-k)^3}{1000},101\leq k\leq 110\\ \\ 0,其他\end{cases}</script><h2 id="变量变换法"><a href="#变量变换法" class="headerlink" title="变量变换法"></a>变量变换法</h2><p>设二维随机变量 $(X,Y)$ 的联合密度函数为 $p(x,y)$,那么如果函数</p>
<script type="math/tex; mode=display">
\begin{cases} u = g_1(x,y)\\ \\ v=g_2(x,y)\end{cases}</script><p>有连续偏导数，且存在唯一的反函数：</p>
<script type="math/tex; mode=display">
\begin{cases} x = x(u,v)\\ \\ y=y(u,v)\end{cases}</script><p>然后我们可以列出雅克比行列式：</p>
<script type="math/tex; mode=display">
J= \begin{vmatrix} \frac{\partial x}{\partial u} & \frac{\partial x}{\partial v} \\ \frac{\partial y}{\partial u} & \frac{\partial y}{\partial x} \end{vmatrix}</script><p>那么，若 </p>
<script type="math/tex; mode=display">
\begin{cases} U = g_1(X,Y)\\ \\ V=g_2(X,Y)\end{cases}</script><p>则 $(U,V)$ 的联合密度函数为 </p>
<script type="math/tex; mode=display">
p(u,v)=p(x(u,v),y(u,v))|J|</script><h3 id="例题1："><a href="#例题1：" class="headerlink" title="例题1："></a>例题1：</h3><p>设随机变量是 $X$ 与 $Y$ 的<strong>独立同分布</strong>，都服从正态分布 $N(\mu,\sigma^2)$。记 $\begin{cases} U = X+Y\ \ V=X- Y\end{cases}$,试求$(U,V)$的联合密度函数，且问 $U$和$V$ 是否独立？</p>
<p><strong>第一步：列出u,v的反函数</strong>:</p>
<p>已知 $\begin{cases} u = x+y\ \v=x-y\end{cases}$ , 则它的反函数$\begin{cases}x=\frac{u+v}{2}\ \ y=\frac{u-v} {2}\end{cases}$</p>
<p><strong>第二步：列出雅克比行列式</strong></p>
<script type="math/tex; mode=display">
J=  \begin{vmatrix} \frac{\partial x}{\partial u} & \frac{\partial x}{\partial v} \\ \frac{\partial y}{\partial u} & \frac{\partial y}{\partial x} \end{vmatrix} =  J^{-1}=\begin{vmatrix} \frac{\partial u}{\partial x} &\frac{\partial u}{\partial y} \\ \frac{\partial v}{\partial x}   &  \frac{\partial v}{\partial y} \end{vmatrix}  

=-\frac{1}{2}</script><p><strong>第三步：列出联合密度函数p(u,v)</strong></p>
<script type="math/tex; mode=display">
p(u,v)=p(x(u,v),y(u,v))|J| = p_X(\frac{u+v}{2})p_Y(\frac{u-v}{2})|-\frac{1}{2}|</script><script type="math/tex; mode=display">
=\frac{1}{2} \frac{1}{\sqrt{2\pi}\sigma}\exp\{-\frac{(\frac{u+v}{2}-\mu)^2}{2\sigma^2}\}\frac{1}{\sqrt{2\pi}\sigma}\exp\{-\frac{(\frac{u-v}{2}-\mu)^2}{2\sigma^2}\}\\
=\frac{1}{4\pi\sigma^2}\exp\{-\frac{(u-2\mu)^2+v^2}{4\sigma^2}\}</script><p>这是二元正态分布$N(2\mu,0,2\sigma^2,2\sigma^2,0)$的密度函数，其边际分布为 $U\sim N(2\mu,2\sigma^2)$, $V\sim N(0,2\sigma^2)$ </p>
<p>符合 $p(u,v)=p(u)p(v)$ ，因此 $U,V$相互独立。</p>
<h3 id="例题2："><a href="#例题2：" class="headerlink" title="例题2："></a>例题2：</h3><p>设随机变量X与Y相互独立，且都服从标准正态分布 $N(0,1)$ ，试证 $U=X^2+Y^2$ 与 $V= Y/X$ 相互独立。已知</p>
<script type="math/tex; mode=display">
p_X(x)=\frac{1}{\sqrt{2\pi}}\exp\{-\frac{x^2}{2}\}\\~\\</script><p><strong>第一步：列出u,v的反函数：</strong></p>
<p>已知 $\begin{cases} u =x^2+y^2\ \v=y/x\end{cases}$ , 则它的反函数</p>
<script type="math/tex; mode=display">
\begin{cases}x = v\sqrt{\frac{u}{v^2+1}}\\ \\ y=\sqrt{\frac{v}{v^2+1}} \end{cases}</script><p><strong>第二步：曲线救国，列出雅克比行列式</strong></p>
<p>这道题目告诉我们当我们直接求 $|J|$比较麻烦的时候，我们可以先求 $J^{-1}$</p>
<script type="math/tex; mode=display">
J^{-1}=\begin{vmatrix} \frac{\partial u}{\partial x} &\frac{\partial u}{\partial y} \\ \frac{\partial v}{\partial x}   &  \frac{\partial v}{\partial y} \end{vmatrix} = \begin{vmatrix} 2x & 2y \\ 1/y   &  -x/y^2 \end{vmatrix} = -2(\frac{x^2}{y^2}+1)</script><p>然后我们就可以求出 $|J|$,注意这时候x，y要用u，v来表示：$|J|=\frac{1}{2(1+v^2)}$ </p>
<p><strong>第三步：列出联合密度函数p(u,v)</strong></p>
<script type="math/tex; mode=display">
p(u,v)=p(x(u,v),y(u,v))=p_X(x(u,v))p_Y(y(u,v))|J| = \frac{1}{2\pi} e^{-\frac{u}{2}} \frac{1}{2(v^2+1)} ,u>0,-\infty <v <+\infty</script>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/" class="post-title-link" itemprop="url">计算机网络报告5</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-02 12:27:30" itemprop="dateCreated datePublished" datetime="2021-04-02T12:27:30+08:00">2021-04-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-25 04:31:00" itemprop="dateModified" datetime="2022-08-25T04:31:00+08:00">2022-08-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机网络报告5"><a href="#计算机网络报告5" class="headerlink" title="计算机网络报告5"></a>计算机网络报告5</h1><h2 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1.实验目的"></a>1.实验目的</h2><ul>
<li>熟悉HTTP协议</li>
<li>了解HTTP协议在实际网络中的运行过程</li>
<li>熟悉SMTP和POP3协议</li>
<li>了解SMTP和POP3协议在实际网络中的运行过程</li>
</ul>
<h2 id="2-实验任务"><a href="#2-实验任务" class="headerlink" title="2.实验任务"></a>2.实验任务</h2><ul>
<li><p>通过wireshark分析HTTP协议</p>
</li>
<li><p>通过wireshark分析SMTP和POP3协议</p>
</li>
</ul>
<h2 id="3-协议简介"><a href="#3-协议简介" class="headerlink" title="3. 协议简介"></a>3. 协议简介</h2><h3 id="3-1-HTTP协议"><a href="#3-1-HTTP协议" class="headerlink" title="3.1 HTTP协议"></a>3.1 HTTP协议</h3><p>HTTP协议(超文本传输协议HyperText Transfer Protocol)，它是基于TCP协议的应用层传输协议，简单来说就是客户端和服务端进行数据传输的一种规则。</p>
<p>HTTP 是一种无状态 (stateless) 协议, HTTP协议本身不会对发送过的请求和相应的通信状态进行持久化处理。这样做的目的是为了保持HTTP协议的简单性，从而能够快速处理大量的事务, 提高效率。然而，在许多应用场景中，我们需要保持用户登录的状态或记录用户购物车中的商品。由于HTTP是无状态协议，所以必须引入一些技术来记录管理状态，例如Cookie。</p>
<h3 id="3-2-SMTP协议"><a href="#3-2-SMTP协议" class="headerlink" title="3.2 SMTP协议"></a>3.2 SMTP协议</h3><p>SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP协议属于TCP/IP协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。通过SMTP协议所指定的服务器,就可以把E-mail寄到收信人的服务器上了，整个过程只要几分钟。SMTP服务器则是遵循SMTP协议的发送邮件服务器，用来发送或中转发出的电子邮件。SMTP是一种TCP协议支持的提供可靠且有效电子邮件传输的应用层协议。</p>
<h3 id="3-3-POP3协议"><a href="#3-3-POP3协议" class="headerlink" title="3.3 POP3协议"></a>3.3 POP3协议</h3><p>POP3（Post Office Protocol version3）：邮局协议第三版本，协助用户代理（即客户端）从邮件服务器上获取邮件。POP3允许用户从服务器上把邮件存储到本地主机（即自己的计算机）上，同时删除保存在邮件服务器上的邮件，而POP3服务器则是遵循POP3协议的接收邮件服务器，用来接收电子邮件的。</p>
<h2 id="4-实验过程"><a href="#4-实验过程" class="headerlink" title="4.实验过程"></a>4.实验过程</h2><h3 id="4-1"><a href="#4-1" class="headerlink" title="4.1"></a>4.1</h3><p>抓取HTTP数据包，并分析HTTP协议具体细节（主要是分析HTTP数据包的组成）</p>
<p><strong>操作步骤：</strong></p>
<p>(1) 清空Web浏览器的缓存，保证数据是从网络中获取的</p>
<p>(2) 启动Wireshark，开始Wireshark抓包。</p>
<p>(3) 在浏览器地址栏中前往网址<a href="http://www.ecnu.edu.cn" target="_blank" rel="noopener">http://www.ecnu.edu.cn</a></p>
<p>(4) 单击测览器中的“刷新”按钮。</p>
<p>(5) 停止Wireshark分组俘获，过滤筛选处输入“http”显示捕获到的HTTP报文。</p>
<h3 id="Task1-amp-2："><a href="#Task1-amp-2：" class="headerlink" title="Task1&amp;2："></a>Task1&amp;2：</h3><p><strong>抓取HTTP网络包，分析HTTP请求网络包/响应网络包的组成</strong></p>
<p>我发现当我们用http来请求 www.ecnu.edu.cn 的时候，浏览器总是会自动切换到 https协议，导致我们的Wireshark抓取到的都是TLS协议的包。我用筛选条件<code>http and ip.addr == 202.120.92.50</code>抓取不到任何的报文。这可能是因为网站强制HTTPS来加密访问，只有确保网站的安全之后才会启用。</p>
<p>但是在我多刷新了几次过后，突然在Wireshark中出现了一个http请求报文和一个http相应报文(但是我并不知道它们是怎么出现的)我将其截图放在下面</p>
<p><strong>请求报文</strong></p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/5.png" style="zoom: 80%;"></p>
<p><strong>响应报文</strong></p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/6.png" style="zoom:130%;"></p>
<p>但这种http的报文出现是不可复制的，我在晚上又试了好几个不同的浏览器都无法抓到包。我还是认为这和https协议有关。所以我找到了平常在用的美剧天堂网站，它只需要http协议即可访问，这样抓取http协议的包就是可复制的了。我这里也给出美剧天堂的筛选条件：<code>http and ip.addr == 61.111.129.175</code> </p>
<p>需要注意的是，在抓包前需要关闭VPN或者代理服务器，否则我们发送的http请求都是先中转到代理服务商，收到的http响应也是从代理服务商发出的，无法达成直接和网站进行”握手“的操作。</p>
<p>截图如下</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/7.png" style="zoom:130%;"></p>
<p>现在，我们来用 <a href="http://www.ecnu.edu.cn" target="_blank" rel="noopener">http://www.ecnu.edu.cn</a> 来分析一下HTTP请求报文与响应报文。</p>
<h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p><strong>首先我们看请求行的三个部分</strong></p>
<ul>
<li><p>请求方法： GET</p>
</li>
<li><p>请求内容： / 这里显示的是网站的相对路由的url，因为我访问的是学校网站的主页，因此其相对路由就是 <code>/</code> </p>
</li>
<li><p>协议版本：HTTP/1.1</p>
</li>
</ul>
<p><strong>然后我们来看首部行</strong></p>
<ul>
<li><p><code>Connection: keep-alive</code> 这是让客户端与服务端保持连接。</p>
</li>
<li><p><code>User-Agent: Mozilla/5.0 .......</code> 这是发送请求的操作系统即浏览器信息，我是用Chrome访问的网站，但这里一开始现实的是Mozilla/5.0，这是因为Mozilla是较早支持框架的浏览器，后来的浏览器为了兼容，都把自己伪装成Mozilla。</p>
</li>
<li><p><code>Accept: text/html application/xhtml+xml</code>这边列举的是客户端可以识别的内容类型，用于指定客户端接受哪些类型的信息</p>
</li>
<li><p><code>Accept-Encoding ： gzip, deflate</code> ,客户端可识别的数据编码.  这边简单介绍一下这两个编码格式：利用Apache中的<code>Gzip</code>模块，我们可以使用<code>Gzip</code>压缩算法来对Apache服务器发布的网页内容进行压缩后再传输到客户端浏览器。这样经过压缩后实际上降低了网络传输的字节数，最明显的好处就是可以加快网页加载的速度； <code>DEFLATE</code>是同时使用了LZ77算法与哈夫曼编码（Huffman Coding）的一个无损数据压缩算法。 deflate与gzip解压的代码几乎相同，可以合成一块代码。</p>
</li>
<li><p><code>Accepet-Language: zh-CN ，zh; q= 0.9,en; q=0.8,en-GB...</code> 这是浏览器所支持的语言类型</p>
</li>
</ul>
<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><ul>
<li><code>HTTP/1.1 301 Moved Permanently</code>，这边校园网给我返回的状态码是301，也就是永久性转移，说明浏览器在拿到服务器返回的这个状态码之后会自动跳转到一个新的URL地址，这个地址在接下来的<code>Location</code>部分。在我们用户看来，就是地址 <code>http://www.ecnu.edu.cn</code> 瞬间变成了 <code>https://www.ecnu.edu.cn</code> 。这代表http 开头的旧地址的资源已经被永久移除了，搜索引擎在抓取新的内容的同时也将旧的网址交换为重定向之后的网址。所以很可能是我没有完全删除浏览器的缓存导致后面多次刷新也无法发起向 www.ecnu.edu.cn 的get请求。而是直接使用 https 加密协议。</li>
<li><code>Content-Type text/html</code>  告诉客户端，实际返回的内容的类型</li>
<li><code>Content-Length: 167\r\n</code> 消息主体的到校</li>
<li><code>Connection: keep-alive</code>表明连接状态： 保持连接</li>
<li><code>Location: https://www,ecnu.edu.cn:443</code> 这就是获得的新地址。浏览器实际上访问的是这个新地址。 443 代表网页浏览器端口，主要用于HTTPS服务。</li>
</ul>
<p>实际上这个响应并没有给我们很多信息，因为都转移到TLS协议去了。</p>
<h3 id="Task3："><a href="#Task3：" class="headerlink" title="Task3："></a>Task3：</h3><p><strong>学习了解GET和POST方法，分析对比GET和POST方法的请求和响应报文</strong></p>
<p>在我写的关于NodeJs 的博客中又一个章节 <a href="https://jasonxqh.github.io/2020/06/07/Nodejs基础1/#RESTful-Services">RESTful Services</a> 介绍了四种 Http 请求。分别是： Get 用于获取信息，Put用于更新数据，Delete用于删除操作，Post用于新建操作。</p>
<p>然后我又想到了去年Web课程编写的网页，里面可以发送各种类型的 http 请求，因此我们来试一下。 我的项目是本地运行的，因此我们在Wireshark中选择<strong>Adapter for loopback traffic capture</strong>。后台是挂在 8080端口上的，因此筛选条件是：<code>http and tcp.port == 8080</code></p>
<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>当我刷新首页的时候，现实的就是一系列的 Get类型的请求。</p>
<p>一开始是请求用户的信息，然后请求首页内容。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/8.png" style="zoom:67%;"></p>
<h4 id="post"><a href="#post" class="headerlink" title="post"></a>post</h4><p>对于post请求，我们可以在数据库中新建一条信息(如下图所示)，那么前端就会向后端发送一条post请求。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/9.png" style="zoom:67%;"></p>
<p>我们抓到的包如下：</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/11.png" style="zoom:67%;"></p>
<p>我们点击最后的 <code>JavaScript Object Notation</code>,会出现Post中包含的一些关于新建对象信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">JavaScript Object Notation: application&#x2F;json</span><br><span class="line">    Object</span><br><span class="line">        Member Key: title</span><br><span class="line">            String value: 黑镜第五季</span><br><span class="line">            Key: title</span><br><span class="line">        Member Key: actors</span><br><span class="line">            String value: 安德鲁·斯科特,麦莉·赛勒斯</span><br><span class="line">            Key: actors</span><br><span class="line">        Member Key: country</span><br><span class="line">            String value: 英国</span><br><span class="line">            Key: country</span><br><span class="line">        Member Key: type</span><br><span class="line">            String value: 魔幻&#x2F;科幻</span><br><span class="line">            Key: type</span><br><span class="line">        Member Key: single</span><br><span class="line">            String value: 90</span><br><span class="line">            Key: single</span><br><span class="line">        Member Key: first_date</span><br><span class="line">            String value: </span><br><span class="line">            Key: first_date</span><br><span class="line">        Member Key: station</span><br><span class="line">            String value: Channel 4</span><br><span class="line">            Key: station</span><br><span class="line">        Member Key: url</span><br><span class="line">            String value: http:&#x2F;&#x2F;www.meiju8.cc&#x2F;movie&#x2F;48600.html</span><br><span class="line">            Key: url</span><br></pre></td></tr></table></figure>
<h4 id="分析与总结"><a href="#分析与总结" class="headerlink" title="分析与总结"></a>分析与总结</h4><h5 id="Get-和-Post-请求报文区别"><a href="#Get-和-Post-请求报文区别" class="headerlink" title="Get 和 Post 请求报文区别"></a>Get 和 Post 请求报文区别</h5><p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/10.png" style="zoom:67%;"></p>
<p>这两份报文最大的区别就是在请求方法上的不同，一个是Get，另一个是Post</p>
<p>此外由于在操作界面上的不同，两者请求的Url也不一样。</p>
<p>相比 Post的请求报文，Get的请求报文在这里还多了一个 Authorization，其内容是一大串编码, 原因是我在设计系统的时候规定在请求信息的时候前端必须把用户的信息token放在Get报文中发送给后端，后端验明身份后才可以发送数据库中的信息给前端。因此这里的密码就是用户的token信息。</p>
<p>相比 Get的请求报文，Post的请求报文在底部还有一行 <code>File Data : 217 bytes</code> ,这是因为我新建了一条信息，夹带在请求报文中，发送给后端，后端解析后将其存入数据库当中。</p>
<p>和之前向 www.ecnu.edu.cn 发送的报文相比，这两份报文多了几个字段： </p>
<p><code>Sec-Fetch-Site： same-site</code> 这个请求头表示一个请求发起者的来源与目标资源来源之间的关系；same-site表示发起和目标站点源完全一致</p>
<p><code>Sec-Fetch-Mode: cors</code>该请求头表明了一个请求的模式；cors代表跨域请求。因为前端端口设在3000，后端端口设在8080，http请求需要跨域</p>
<p><code>Sec-Fetch-Dest: empty</code> 表示请求的目的地，即如何使用获取的数据；</p>
<p>Sec-Fetch-*请求头这是用来干嘛的呢，简单来说，就是网络请求的元数据描述，服务端根据这些补充数据进行细粒度的控制响应，换句话说，服务端可以精确判断请求的合法性，杜绝非法请求和攻击，提高web服务的安全性。</p>
<h5 id="Get和post响应报文区别"><a href="#Get和post响应报文区别" class="headerlink" title="Get和post响应报文区别"></a>Get和post响应报文区别</h5><p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/12.png" style="zoom:67%;"></p>
<p>现在我们来分析Get和Post的响应报文。</p>
<p>我们发现Get 与 Post 的响应报文大同小异，但是Post响应报文并没有报告模板中写着的那样有 Server字段，我并不知道是什么原因。</p>
<p>但是与之前 www.ecnu.edu.cn的响应报文相比，这次的相应报文多了很多 X-* 开始的响应头.我在 MDN Web Docs上找到了相关解释：</p>
<p><code>X-DNS-Prefetch-Control: off</code> 这个响应头控制着浏览器的DNS预读取功能。 DNS 预读取是一项使浏览器主动去执行域名解析的功能，其范围包括文档的所有链接，无论是图片的，CSS 的，还是 JavaScript 等其他用户能够点击的 URL。因为预读取会在后台执行，所以 DNS 很可能在链接对应的东西出现之前就已经解析完毕。这能够减少用户点击链接时的延迟。这里的off就是关闭DNS预解析。</p>
<p><code>X-Frame-Options: SAMEORIGIN</code>  这个响应头是用来给浏览器指示允许一个页面 可否在<code>&lt;frame&gt;</code>，<code>&lt;embed&gt;</code>或者<code>&lt;object&gt;</code>中展现的标记。sameorigin表示该页面可以在相同域名页面的 frame 中展示。</p>
<p><code>X-Download-Options: noopen</code> 这个响应头是用于放置直接打开用户下载文件。noopen用于指定 IE 8级以上的版本的用户不打开文件而直接保存文件，在下载对话框中不显示“打开”选项</p>
<p><code>X-SXX-Protection: 1; mode=bloack</code> 这个响应头是 Internet Explorer，Chrome 和 Safari 的一个特性，当检测到跨站脚本攻击 (<a href="https://developer.mozilla.org/en-US/docs/Glossary/Cross-site_scripting" target="_blank" rel="noopener">XSS</a>)时，浏览器将停止加载页面。这里，<code>1;mode=block</code> 代表启用XSS过滤。 如果检测到攻击，浏览器将不会清除页面，而是阻止页面加载。</p>
<h3 id="Task4"><a href="#Task4" class="headerlink" title="Task4"></a>Task4</h3><p><strong>抓取HTTP数据包，并分析HTTP协议交互流程（主要是客户端和服务器之间通过HTTP协议进行交互的流程）</strong></p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/4.png" style="zoom:67%;"></p>
<p>HTTP协议的流程可以概括为下图：</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/14.png" style="zoom:120%;"></p>
<p>我们看到按照上面这个图片，可以总结为下面四点：</p>
<ol>
<li>客户端通过TCP三次握手与服务器建立连接。</li>
<li>TCP建立连接成功后，向服务器发送HTTP请求。</li>
<li>服务器接收客户端的HTTP请求后，将返回应答，并向客户端发送数据</li>
<li>客户端通过TCP四次断开，与服务器断开TCP连接。</li>
</ol>
<p>为了直观，我们还是抓取了本地项目的报文来做分析</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/15.png" style="zoom:120%;"></p>
<p>首先是三次握手的过程。前端端口是3645，后端端口是8080</p>
<ul>
<li>第一份TCP报文是前端发送给后端使用SYN同步序列号，用来发起一个TCP连接，这时候 Seq=0。</li>
<li>第二份TCP报文是服务器发送的[SYN,ACK]确认报文，此时 Seq=0,Ack =1。这代表已经收到序列号为0的报文，现在请求要1的报文</li>
<li>第三份TCP报文是服务端发送的 Seq=1,Ack=1的[ACK]确认报文。</li>
</ul>
<p>我们发现和图片上的三次握手一一对应，现在客户端和服务端已经开始建立了联系，开始相互通讯了。下面的HTTP请求就是之前我们分析的报文。</p>
<p>四次挥手我们用 访问百度的例子：</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/17.png" style="zoom:120%;"></p>
<p>第一次挥手：首先客户端给服务器发送 [FIN,ACK] 包，用来关闭客户端到服务器的数据传送。Seq=1,Ack=1</p>
<p>第二次挥手：当服务器收到FIN之后，发挥一个 Ack=2 的TCP包。</p>
<p>第三次挥手：仍然是服务器给PC发送TCP包，用来关闭于客户端的连接。 <code>Seq=1 Ack=2</code></p>
<p>第四次挥手，客户端收到服务器发送的FIN之后，发送 <code>Seq=2,Ack=2</code> 的TCP包给客户端，结束链接，但是这里百度的客户端已经和我们断开了连接，因此出现了重新发送的情况。</p>
<h3 id="Task5-amp-6"><a href="#Task5-amp-6" class="headerlink" title="Task5&amp;6"></a>Task5&amp;6</h3><p><strong>抓取SMTP和POP3数据包，并分析SMTP和POP3协议具体细节（主要是分析SMTP和POP3数据包的组成) 和 协议交互流程（主要是SMTP和POP3协议在网络中运行的流程）</strong></p>
<p>为了方便起见，我将数据包的组成和交互流程放在一起分析：</p>
<h4 id="SMTP-协议"><a href="#SMTP-协议" class="headerlink" title="SMTP 协议"></a>SMTP 协议</h4><p>操作步骤：</p>
<p>（1） 打开Wireshark，开始捕获网络包。</p>
<p>（2） 在本地用foxmail（或其他）登录两个邮箱，用A邮箱发送邮件给B邮箱。</p>
<p>（3） 抓取smtp和pop3协议的数据包。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/18.png" style="zoom:120%;"></p>
<p>如果我们在使用 Foxmail发送邮件，需要先在设置中将取消使用SSL 加密邮件的功能，否则我们是抓取不到任何包裹的。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/19.png" style="zoom:120%;"></p>
<p>Wireshark 抓到的包如下：</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/20.png" style="zoom:120%;"></p>
<p>现在我们分析SMTP和POP3协议具体细节和流程。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/13.png" style="zoom:67%;"></p>
<p>第一条是邮件服务器发送给PC的报文，220 代表连接 SMTP 服务器成功。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Simple Mail Transfer Protocol</span><br><span class="line">    Response: 220 newxmesmtplogicsvrszc7.qq.com XMail Esmtp QQ Mail Server.\r\n</span><br><span class="line">        Response code: &lt;domain&gt; Service ready (220)</span><br><span class="line">        Response parameter: newxmesmtplogicsvrszc7.qq.com XMail Esmtp QQ Mail Server.</span><br></pre></td></tr></table></figure>
<p>第二条是PC发送给邮件服务器的报文，EHLO表明邮件带有身份验证，是没有办法伪造的，也就是可以规避垃圾邮件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Simple Mail Transfer Protocol</span><br><span class="line">    Command Line: EHLO JasonsT90\r\n</span><br></pre></td></tr></table></figure>
<p>第三条邮件服务器发送给PC的报文,状态字250代表与 服务器握手成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Simple Mail Transfer Protocol</span><br><span class="line">    Response: 250-newxmesmtplogicsvrszc7.qq.com\r\n</span><br><span class="line">        Response code: Requested mail action okay, completed (250)</span><br><span class="line">        Response parameter: newxmesmtplogicsvrszc7.qq.com</span><br><span class="line">        Response parameter: PIPELINING</span><br><span class="line">        Response parameter: SIZE 73400320</span><br><span class="line">        Response parameter: STARTTLS</span><br><span class="line">        Response parameter: AUTH LOGIN PLAIN XOAUTH XOAUTH2</span><br><span class="line">        Response parameter: AUTH&#x3D;LOGIN</span><br><span class="line">        Response parameter: MAILCOMPRESS</span><br><span class="line">        Response parameter: 8BITMIME</span><br></pre></td></tr></table></figure>
<p>第四条是PC发送给邮件服务器的报文，这边是用户登录命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Simple Mail Transfer Protocol</span><br><span class="line">    Command Line: AUTH LOGIN\r\n</span><br><span class="line">        Command: AUTH</span><br><span class="line">        Request parameter: LOGIN</span><br></pre></td></tr></table></figure>
<p>第五条是邮件服务器发送给PC的报文，状态码是334，代表接受用户登录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Simple Mail Transfer Protocol</span><br><span class="line">    Response: 334 VXNlcm5hbWU6\r\n</span><br><span class="line">        Response code: AUTH input (334)</span><br><span class="line">        Response parameter: VXNlcm5hbWU6</span><br></pre></td></tr></table></figure>
<p>第六条是PC发送给邮件服务器的报文，包含了登陆的用户名的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Simple Mail Transfer Protocol</span><br><span class="line">    Username: MjY5Nzc2NzE2MEBxcS5jb20&#x3D;</span><br></pre></td></tr></table></figure>
<p>第七条又是表示 邮件服务器接受用户登录</p>
<p>第八条是PC发送给邮件服务器的报文，包含了用户登录服务器的密码</p>
<p>第九条是邮件服务器发送给PC的报文，状态字235代表用户登录成功</p>
<p>第十条是PC发送给邮件服务器的报文，记录了邮件的发送者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Simple Mail Transfer Protocol</span><br><span class="line">    Command Line: MAIL FROM: &lt;2697767160@qq.com&gt; SIZE&#x3D;1354\r\n</span><br><span class="line">        Command: MAIL</span><br><span class="line">        Request parameter: FROM: &lt;2697767160@qq.com&gt; SIZE&#x3D;1354</span><br></pre></td></tr></table></figure>
<p>第十一条是邮件服务器发送给PC的报文，状态字250表示与服务器握手成功</p>
<p>第十二条是PC发送给邮件服务器的报文，记录了邮件的接收者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Simple Mail Transfer Protocol</span><br><span class="line">    Command Line: RCPT TO: &lt;10195501423@stu.ecnu.edu.cn&gt;\r\n</span><br><span class="line">        Command: RCPT</span><br><span class="line">        Request parameter: TO: &lt;10195501423@stu.ecnu.edu.cn&gt;</span><br></pre></td></tr></table></figure>
<p>第十三条是邮件服务器发送给PC的报文，也是250关键字</p>
<p>第十四条是PC发送给邮件服务器的报文，内容为DATA，表示邮件正文</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Simple Mail Transfer Protocol</span><br><span class="line">    Command Line: DATA\r\n</span><br><span class="line">        Command: DATA</span><br></pre></td></tr></table></figure>
<p>第十五条是邮件服务器发送给PC的报文</p>
<p>第十六条是PC发送给邮件服务器的报文，记载着邮件的详细信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Simple Mail Transfer Protocol</span><br><span class="line">    Line-based text data (13 lines)</span><br><span class="line">        Date: Sun, 4 Apr 2021 12:48:46 +0800\r\n</span><br><span class="line">        From: &quot;2697767160@qq.com&quot; &lt;2697767160@qq.com&gt;\r\n</span><br><span class="line">        To: &#x3D;?GB2312?B?0OyGorq9?&#x3D; &lt;10195501423@stu.ecnu.edu.cn&gt;\r\n</span><br><span class="line">        Subject: test\r\n</span><br><span class="line">        X-Priority: 3\r\n</span><br><span class="line">        X-GUID: C085913A-BCC1-425E-9D61-8E390342FC2A\r\n</span><br><span class="line">        X-Has-Attach: no\r\n</span><br><span class="line">        X-Mailer: Foxmail 7.2.20.273[cn]\r\n</span><br><span class="line">        Mime-Version: 1.0\r\n</span><br><span class="line">        Message-ID: &lt;202104041248465541575@qq.com&gt;\r\n</span><br><span class="line">        Content-Type: multipart&#x2F;alternative;\r\n</span><br><span class="line">        \tboundary&#x3D;&quot;----&#x3D;_001_NextPart310261260277_&#x3D;----&quot;\r\n</span><br><span class="line">        \r\n</span><br><span class="line">    [Reassembled DATA in frame: 974]</span><br></pre></td></tr></table></figure>
<p>第十七条是邮件服务器发送给PC的报文，状态字250表示握手成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Simple Mail Transfer Protocol</span><br><span class="line">    Response: 250 OK: queued as.\r\n</span><br><span class="line">        Response code: Requested mail action okay, completed (250)</span><br><span class="line">        Response parameter: OK: queued as.</span><br></pre></td></tr></table></figure>
<p>第十八条是PC发送给邮件服务器的报文，内容是QUIT，代表推出SMTP服务器</p>
<p>第十九条是邮件服务器发送给PC的报文，状态字221,代表与PC断开连接。服务关闭</p>
<h4 id="POP3协议"><a href="#POP3协议" class="headerlink" title="POP3协议"></a>POP3协议</h4><p>由于我使用的都是默认配置的邮箱，因此qq邮箱和企业邮箱都是使用IMAP类型的邮箱，无法收到POP协议的报文。因此我又重新配置了我的两个邮箱：</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/21.png" style="zoom:67%;"></p>
<ol>
<li>由于POP3协议默认的传输协议是TCP协议，因此，客户端连接服务器需要先进行三次握手建立端到端的连接。</li>
</ol>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/22.png" style="zoom:67%;"></p>
<ol>
<li>在客户端和服务器建立了连接之后，pop3服务器回向pop3客户端发送 带有OK的信息，通知客户端，服务器已经准备就绪，请开始认证阶段。</li>
</ol>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/23.png" style="zoom:67%;"></p>
<ol>
<li>还是参照上图，客户端会向服务器发送用户名、授权码，邮箱服务器也会返回OK作为回应</li>
<li>接下来客户端向服务器发送 LIST指令，服务器会返回邮件数量的大小。</li>
</ol>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/24.png" style="zoom:67%;"></p>
<p>我们看到POP服务器上一共有91份待收取的邮件。</p>
<p>接下来，客户端依次向POP服务器发送 RETR XX(代表第XX封邮件)，从RETR 91 一直到 RETR 1.服务器返回命令执行的状态(都是OK)以及第XX封邮件的全部内容。</p>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/25.png" style="zoom:67%;"></p>
<p>每一份回传的OK的POP类型报文内容如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Post Office Protocol</span><br><span class="line">    +OK 17826\r\n</span><br><span class="line">    Received: from 66.203.125.14 (unknown [66.203.125.14])\r\n</span><br><span class="line">    \tby newmx31.qq.com (NewMx) with SMTP id \r\n</span><br><span class="line">    \tfor &lt;2697767160@qq.com&gt;; Wed, 10 Mar 2021 19:49:16 +0800\r\n</span><br><span class="line">    X-QQ-FEAT: cNGXrfP6b70WZB63pTXQMF109vshIAanTTfx8LrW82o&#x3D;\r\n</span><br><span class="line">    X-QQ-MAILINFO: MfiUJyQXz1c0MzpywYY9SZw82ms4O&#x2F;PNVMLpO9XG6T+YtCzTTfIxosGvW\r\n</span><br><span class="line">    \tGLtLTpNB6P6inseKmkcTT32W0twW00gkYhYWthuNeRGuMTLnB+eupX2zEdw+cI&#x3D;\r\n</span><br><span class="line">    X-QQ-mid: mxszc32t1615376953ta55hzshz\r\n</span><br><span class="line">    X-QQ-CSender: support+2697767160&#x3D;qq.com@mega.nz\r\n</span><br><span class="line">    X-QQ-ORGSender: support+2697767160&#x3D;qq.com@mega.nz\r\n</span><br><span class="line">    X-QQ-XMAILINFO: M2oFKfa0&#x2F;bfew2IwrID4iBasCNw8ww5ZmGVMCIlyGoUiPp1ZLokBv3JVRg4cLf\r\n</span><br><span class="line">    \t qdL1LytVljSPoYupd&#x2F;84PH64vr1LeLYuFDDvP&#x2F;LUNEiRf12ixQby9M2kKdRpXpSil5j1i69EWO68\r\n</span><br><span class="line">    \t 2RGSVu1ROA7mtPgjCRvHW&#x2F;PNtO3TLLMxAH8suiNHigFEw0GRN+drbQgVlpONXXJVb89q2pX&#x2F;pzFS\r\n</span><br><span class="line">    \t SdSvinFTax&#x2F;wB5jK6HPQqw1Xbnf2sUNSp036IOJRzC5KEgXPyebiCZpzxtS+PWS8kXL9iUacIlU2\r\n</span><br><span class="line">    \t EmZ3wQZen&#x2F;uFbHHEzSQfmFjDWpdy532VDeN5XqVsbHnlHh&#x2F;8kEl+Q9gPAVe5bJ1RJRabr7XyE0Av\r\n</span><br><span class="line">    \t loor6GeJUoDoBRDb1bb8mChh4h9k7UaO5wz8sv0mMh6HhKr3Ujx3b3Lse27w&#x2F;NOpvYghW2qA8RrS\r\n</span><br><span class="line">    \t wrw&#x2F;o0FqMWS4j0jFoBDa7P0foQdla168q2vbww1lMBSZWggXLxEaLHurlLFPvUpZ93+pwG5jRAWK\r\n</span><br><span class="line">    \t aebTM7ekTKZP8zDQIyUgQ+Vtg9GWiHyV1GSamnciZXrQisdO7g3nE+v8HfxACgv&#x2F;UkDF57WLe7rh\r\n</span><br><span class="line">    \t pXJIbvRnBuw4udVFzRRbwaZK67y&#x2F;2cFr3JZCtDqtiEG+C+6aDtU+&#x2F;0FxuehYwf0P3VbxbYhHcHn1\r\n</span><br><span class="line">    \t uXvvAL0sty3zSbweWINddy3GP2I9a2WX8MLkgMwoFhII+bbTxKdtN&#x2F;ayYW+N0&#x2F;331HfnxFvLtUNV\r\n</span><br><span class="line">    \t lIuxgBK+55V8&#x2F;p5BtjidmhkgkG1Tk9xi+zcpj+6J1q3u5vlNU2rZj6stX8F30M4bPXWc6Iqd+g7M\r\n</span><br><span class="line">    \t vkynns4nr537VzSL7YaM8HhBxhlsfXGLoOE3Ief2Wk3u58FOIf5cEK</span><br></pre></td></tr></table></figure>
<p><code>Received :  from  66.203.125.14</code> 表示从哪里收到的信息</p>
<p><code>by newmx31.qq.com (NewMx) with SMTP id</code> 表示发件服务器的信息</p>
<p><code>for &lt;2697767160@qq.com&gt;; Wed, 10 Mar 2021 19:49:16 +0800</code> 表示收件人信息和收件时间</p>
<p> <code>X-QQ-CSender: support+2697767160=qq.com@mega.nz</code> 弹回域名 </p>
<ol>
<li>最后客户端发送QUIT指令，退出处理状态。服务器也返回 OK Bye作为回应。并通过 TCP四次挥手断开连接。</li>
</ol>
<p><img src="/2021/04/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A5/26.png" style="zoom:67%;"></p>
<p>那么 IMAP类型的邮箱和POP类型的邮箱有什么区别？</p>
<p>POP允许电子邮件客户端下载服务器上的邮件，但是我在电子邮件客户端的操作（如：移动邮件、标记已读等），这是不会反馈到服务器上的，比如：您通过电子邮件客户端收取了QQ邮箱中的3封邮件并移动到了其他文件夹，这些移动动作是不会反馈到服务器上的，也就是说，QQ邮箱服务器上的这些邮件是没有同时被移动的。</p>
<p>但是IMAP就不同了，电子邮件客户端的操作都会反馈到服务器上，我对邮件进行的操作（如：移动邮件、标记已读等），服务器上的邮件也会做相应的动作。也就是说，IMAP是“双向”的。</p>
<p>同时，IMAP可以只下载邮件的主题，只有当我真正需要的时候，才会下载邮件的所有内容。</p>
<h2 id="进阶（依据自身情况完成）"><a href="#进阶（依据自身情况完成）" class="headerlink" title="进阶（依据自身情况完成）"></a>进阶（依据自身情况完成）</h2><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p>利用Web邮件客户端进行邮件发送和接收，抓取相应的数据包，分析其流程。</p>
<h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p>在GitHub上寻找基于java实现的邮件收发客户端，找到之后运行它，实现正常的邮件收发，并抓取相应的网络包，分析判断其网络交互流程。</p>
<p><a href="https://github.com/RawSanj/java-mail-clients" target="_blank" rel="noopener">https://github.com/RawSanj/java-mail-clients</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/" class="post-title-link" itemprop="url">计算机网络实验报告2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-21 23:36:48" itemprop="dateCreated datePublished" datetime="2021-03-21T23:36:48+08:00">2021-03-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-08-23 22:25:06" itemprop="dateModified" datetime="2022-08-23T22:25:06+08:00">2022-08-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机网络实验报告2"><a href="#计算机网络实验报告2" class="headerlink" title="计算机网络实验报告2"></a>计算机网络实验报告2</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ul>
<li>理解多线程并熟悉Java多线程编程</li>
<li>熟悉并掌握线程创建、线程控制</li>
<li>熟悉并掌握线程同步、线程交互</li>
</ul>
<h2 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h2><ul>
<li><p>使用常用的两种方式创建线程</p>
</li>
<li><p>使用join()等方法进行线程控制</p>
</li>
<li><p>学习使用synchronized关键字进行线程同步</p>
</li>
<li><p>学习使用wait()和notify()方法进行线程交互</p>
</li>
</ul>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><h4 id="继承Thread类创建线程"><a href="#继承Thread类创建线程" class="headerlink" title="继承Thread类创建线程"></a>继承Thread类创建线程</h4><p> 通过继承Thread类来创建并启动多线程的一般步骤如下</p>
<p>1） 定义Thread类的子类，并重写该类的run()方法，该方法的方法体就是线程需要完成的任务，run()方法也称为线程执行体。</p>
<p>2） 创建Thread子类的实例，也就是创建了线程对象</p>
<p>3） 启动线程，即调用线程的start()方法</p>
<p>具体代码如下图所示：</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/1.png" style="zoom:80%;"></p>
<h5 id="任务1"><a href="#任务1" class="headerlink" title="任务1:"></a>任务1:</h5><p><strong>改写 <code>run()</code> 方法，将当前线程的信息打印出来</strong> </p>
<p><code>Mythread_a</code> 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mythread_a</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"当前线程: "</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Mythread_a mThread1 = <span class="keyword">new</span> Mythread_a();</span><br><span class="line">        Mythread_a mThread2 = <span class="keyword">new</span> Mythread_a();</span><br><span class="line">        Mythread_a mThread3 = <span class="keyword">new</span> Mythread_a();</span><br><span class="line">        mThread1.start();</span><br><span class="line">        mThread2.start();</span><br><span class="line">        mThread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Main</code>类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mythread_a.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/7.png" style="zoom:80%;"></p>
<h4 id="覆写Runnable-、run"><a href="#覆写Runnable-、run" class="headerlink" title="覆写Runnable()、run()"></a>覆写Runnable()、run()</h4><p>通过实现Runnable接口创建并启动线程一般步骤如下：</p>
<p>1） 定义Runnable接口的实现类，一样要重写run()方法，这个run（）方法和Thread中的run()方法一样是线程的执行体</p>
<p>2 ） 创建Runnable实现类的实例，并用这个实例作为Thread的target来创建Thread对象，这个Thread对象才是真正的线程对象</p>
<p>3） 第三部依然是通过调用线程对象的start()方法来启动线程</p>
<h5 id="任务2"><a href="#任务2" class="headerlink" title="任务2:"></a>任务2:</h5><p><strong>改写 <code>run()</code> 方法，实现循环打印1-100</strong></p>
<p><code>Mythread_b</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mythread_b</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">            System.out.print(i+<span class="number">1</span>+<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Main</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Mythread_b());</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果如下：</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/8.png" style="zoom:80%;"></p>
<h3 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h3><h4 id="join-线程"><a href="#join-线程" class="headerlink" title="join()线程"></a>join()线程</h4><p>join线程可以让一个线程等待另一个线程执行完毕以后再执行。</p>
<p>1）作用：主要作用是同步，它可以使得线程之间的并行执行变为串行执行。在A线程中调用了B线程的join()方法时，表示只有当B线程执行完毕时，A线程才能继续执行。</p>
<p>2）Join()和start()调用顺序问题：join()方法必须在线程start()方法调用之后调用才有意义。一个线程都还未开始运行，同步是不具有任何意义的。</p>
<p>3）原理：join方法的原理就是调用相应线程的wait方法进行等待操作的，例如A线程中调用了B线程的join方法，则相当于在A线程中调用了B线程的wait方法，当B线程执行完（或者到达等待时间），B线程会自动调用自身的notifyAll方法唤醒A线程，从而达到同步的目的。</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/3.png" style="zoom:80%;"></p>
<h5 id="任务3"><a href="#任务3" class="headerlink" title="任务3:"></a>任务3:</h5><p><strong>完善代码，用join()实现正常的逻辑</strong></p>
<p><code>ThreadJoin</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoin</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Main</code>类：</p>
<p>这里我设计了一个 Thread集合用来存放线程。每个线程声明的时候就将其添加到线程集合当中去。然后通过循环，依次启动四个线程 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ThreadJoin joinDemo = <span class="keyword">new</span> ThreadJoin();</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(joinDemo,<span class="string">"上课铃响"</span>);threads.add(thread1);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(joinDemo,<span class="string">"老师上课"</span>);threads.add(thread2);</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(joinDemo,<span class="string">"下课铃响"</span>);threads.add(thread3);</span><br><span class="line">        Thread thread4 = <span class="keyword">new</span> Thread(joinDemo,<span class="string">"老师下课"</span>);threads.add(thread4);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> thread:threads)&#123;</span><br><span class="line">            thread.start();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：每隔0.5秒按顺序出现一条讯息</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/9.png" style="zoom: 100%;"></p>
<h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><p>java中有一种线程只在后台运行，为其他线程提供服务，这种线程就是守护线程（Daemon Thread）。</p>
<p>只要当前JVM实例中尚存任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作，Daemon作用是为其他线程提供便利服务，守护线程最典型的应用就是GC(垃圾回收器)。</p>
<p>User和Daemon两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果 User Thread已经全部退出运行了，只剩下Daemon Thread存在了，虚拟机也就退出了。 因为没有了被守护者，Daemon也就没有工作可做了，也就没有继续运行程序的必要了。</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/5.png" style="zoom:80%;"></p>
<h5 id="任务4："><a href="#任务4：" class="headerlink" title="任务4："></a>任务4：</h5><p><strong>完善代码，将该线程设置为守护线程，当主线程结束时，结束该线程.</strong></p>
<p>学习资料：<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1306580788183074" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1252599548343744/1306580788183074</a></p>
<p>如何创建守护线程呢？方法和普通线程一样，只是在调用<code>start()</code>方法前，调用<code>setDaemon(true)</code>把该线程标记为守护线程：</p>
<p><code>ThreadDaemon</code> 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDaemon</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"助教在教室的第"</span>+i+<span class="string">"秒"</span>);</span><br><span class="line">                Thread.currentThread().sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Main</code> 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">         ThreadDaemon inClassroom = <span class="keyword">new</span> ThreadDaemon();</span><br><span class="line">         Thread thread = <span class="keyword">new</span> Thread(inClassroom,<span class="string">""</span>);</span><br><span class="line">         thread.setDaemon(<span class="keyword">true</span>);<span class="comment">//设thread为守护线程</span></span><br><span class="line">         thread.start();</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">             thread.sleep(<span class="number">1000</span>);</span><br><span class="line">             System.out.println(<span class="string">"同学们正在上课"</span>);</span><br><span class="line">             <span class="keyword">if</span>(i==<span class="number">9</span>)&#123;</span><br><span class="line">                 System.out.println(<span class="string">"同学们下课了"</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/10.png" style="zoom:80%;"></p>
<p>如果不将ThreadDaemon设为守护线程的话，在输出同学们下课了之后，还会继续输出 助教在教师的第 i 秒。而将其设为守护线程之后，当主线程main结束时，守护线程也结束了，不再打印。</p>
<h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a><strong>线程优先级</strong></h4><p>线程的优先级用1-10之间的整数表示，数值越大优先级越高，默认的优先级为5。线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，优先级低的并非没机会执行。</p>
<p>高优先级的线程比低优先级的线程有更高的几率得到执行，实际上这和操作系统及虚拟机版本相关，有可能即使设置了线程的优先级也不会产生任何作用</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/4.png" style="zoom:80%;"></p>
<h5 id="任务5："><a href="#任务5：" class="headerlink" title="任务5："></a>任务5：</h5><p><strong>完善代码，将两个线程设置为不同的优先级，并将不同的优先级的情况下的输出结果记录下来，总结优先级的特点。 </strong></p>
<p>当我们设置：t2为最高优先级，t1为最低优先级的时候：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t2.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">t1.setPriority(Thread.MIN_PRIORITY);</span><br></pre></td></tr></table></figure>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/11.png" style="zoom:80%;"></p>
<p>前面10次中线程2执行了5次，线程1执行了5次。</p>
<p>当我们设置t1为最高优先级，t2位最低优先级的时候：</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/12.png" style="zoom:80%;"></p>
<p>前面十次中线程1执行了5次，线程2也执行了5次</p>
<p>这说明，在我的电脑里，即使设置了线程的优先级也不会产生任何作用。</p>
<h4 id="线程让步"><a href="#线程让步" class="headerlink" title="线程让步"></a>线程让步</h4><p>线程让步用于正在执行的线程，在某些情况下让出CPU资源，让给其它线程执行。</p>
<p>yield()方法会让线程回到就绪状态，直接等到cpu重新分配资源，但只有优先级和该线程相等或大于该线程的其他线程才有机会被执行。</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/6.png" style="zoom:80%;"></p>
<h5 id="任务6："><a href="#任务6：" class="headerlink" title="任务6："></a>任务6：</h5><p><strong>完善代码，将两个线程设置为不同的优先级，并将第一个线程设置为让步状态，总结线程让步的特点。将关键代码和总结的内容写到实验报告中</strong></p>
<p>wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而yield()的作用是让步，它也会让当前线程离开“运行状态”。它们的区别是：</p>
<ul>
<li>wait()是让线程由“运行状态”进入到“等待(阻塞)状态”，而yield()是让线程由“运行状态”进入到“就绪状态”。</li>
<li>wait()是会线程释放它所持有对象的同步锁，而yield()方法<strong>不会释放锁 </strong></li>
</ul>
<p>Mythread3:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mythread3</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"线程1第"</span>+i+<span class="string">"次执行!"</span>);</span><br><span class="line">            Thread.yield();<span class="comment">//这里我们将线程让步</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们启动main函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Mythread3 t1 = <span class="keyword">new</span> Mythread3();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread4());</span><br><span class="line">        t2.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        t1.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果我们发现这并不能改变两个线程的运行顺序。这可能是因为yield()方法并不能立刻交出CPU，或者是让步后的线程还有可能被线程调度程序再次选中。</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/17.png" style="zoom:80%;"></p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>当我们有多个线程要同时访问一个变量或对象时，如果这些线程中既有读又有写操作时，就会导致变量值或对象的状态出现混乱，从而导致程序异常。举个例子，如果一个银行账户同时被两个线程操作，一个取100块，一个存钱100块。假设账户原本有0块，如果取钱线程和存钱线程同时发生，会出现什么结果呢？取钱不成功，账户余额是100.取钱成功了，账户余额是0.那到底是哪个呢？很难说清楚。因此多线程同步就是要解决这个问题。</p>
<p>在多线程中，可能有多个线程试图访问一个有限的资源，必须预防这种情况的发生。所以引入了同步机制：在线程使用一个资源时为其加锁，这样其他的线程便不能访问那个资源了，直到解锁后才可以访问。</p>
<p>synchronized同步方法：锁定的是当前对象。当多线程通过同一个对象引用多次调用当前同步方法时，需同步执行。也就是说当一个线程访问同步方法时，其他线程访问这个方法将会被阻塞(等待锁)。</p>
<p>synchronized同步代码块：用关键字synchronized声明方法在某些情况下是有弊端的，比如A线程调用同步方法执行一个较长时间的任务，那么B线程必须等待比较长的时间。这种情况下可以尝试使用synchronized同步代码块来解决问题。</p>
<p>同步代码块的同步粒度更加细致，是商业开发中推荐的编程方式。可以定位到具体的同步位置，而不是简单的将方法整体实现同步逻辑。在效率上，相对更高。</p>
<h5 id="任务7："><a href="#任务7：" class="headerlink" title="任务7："></a>任务7：</h5><p><strong>采用同步方法和同步代码段的方法来进行线程控制，总结对比两种方式的优缺点。将代码和总结的结果写到实验报告中。</strong></p>
<p>这里我们设计了一个模拟多任务下载的软件：一共有3个类</p>
<p><code>ThreadDemo</code>类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">var</span> status = <span class="keyword">new</span> DownloadStatus();</span><br><span class="line">       List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">var</span> thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DownloadFileTask(status));</span><br><span class="line">           thread.start();</span><br><span class="line">           threads.add(thread);</span><br><span class="line">       &#125;</span><br><span class="line">      <span class="comment">//将所有的线程都打开后，我们还需要等待所有的线程都停止。这里使用一个循环来解决。</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> thread : threads)&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               thread.join();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        System.out.println(status.getTotalBytes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DownloadFileTask</code>类</p>
<p>在这个Run函数当中，我们做一个10000次的循环，每一次循环都调用status对象的 <code>incrementTotalBytes()</code>函数。用来模拟下载一个 10000 bits的文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadFileTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DownloadStatus status;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DownloadFileTask</span><span class="params">(DownloadStatus status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;i&lt; <span class="number">10_000</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().isInterrupted()) <span class="keyword">return</span>;</span><br><span class="line">            status.incrementTotalBytes();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DownloadStatus</code>类</p>
<p>在这个类中，有一个下载总比特数的私有变量，当有线程中的对象调用<code>incrementTotalBytes()</code>的时候，totalBytes就会自增1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadStatus</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> totalBytes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotalBytes</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> totalBytes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incrementTotalBytes</span><span class="params">()</span></span>&#123;</span><br><span class="line">        totalBytes++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在预期的情况下，我们打开了10 个线程，每个线程都会下载10_000比特的数据，那么<code>totalBytes</code>的结果应该是100_000.但是我们多次运行之后，一直都是八九万，并没有到十万。这是因为发生了<code>Race condition</code>，线程在互相争抢修改同一个数据的时候，会发生数据丢失。这时候我们就可以使用 synchronized 关键词 </p>
<p>但是Java程序依靠<code>synchronized</code>对线程进行同步，使用<code>synchronized</code>的时候，锁住的是<strong>哪个对象</strong>非常重要。</p>
<p>让线程自己选择锁对象往往会使得代码逻辑混乱，也不利于封装。更好的方法是把<code>synchronized</code>逻辑封装起来。 </p>
<p>比如我们现在就要用synchronized来封装<code>totalBytes++</code> ,这是<strong>同步代码段的方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incrementTotalBytes</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        totalBytes++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，线程调用<code>incrementTotalBytes</code>方法时，它不必关心同步逻辑，因为<code>synchronized</code>代码块在<code>incrementTotalBytes</code>方法内部。并且，我们注意到，<code>synchronized</code>锁住的对象是<code>this</code>，即当前实例，这又使得创建多个<code>DownloadStatus</code>实例的时候，它们之间互不影响，可以并发执行。</p>
<p>当我们锁住的是 <code>this</code>实例的时候，实际上可以用 <code>synchronized</code>来修饰这个方法，因此这两种方法是等价的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">incrementTotalBytes</span><span class="params">()</span></span>&#123;</span><br><span class="line">       totalBytes++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，用<code>synchronized</code>修饰的方法就是<strong>同步方法</strong>，它表示整个方法都必须用<code>this</code>实例加锁。不能对其他实例加锁。</p>
<p>但是，对 <code>this</code> 实例加锁也是有缺点的。比如说：我又新建了一个<code>totalFiles</code>变量来记录已下载完成的文件总数。因为文件一多，很可能是两个文件同时下载完成的，因此我们也需要用 <code>synchronized</code>关键字来修饰</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/13.png" style="zoom:80%;"></p>
<p>那么问题来了：<code>incrementTotalByts</code>和<code>incrementTotalFiles</code>这两个方法都给 <code>this</code>对象上了锁。那么如果存在某一个时刻，要同时调用这两个方法的时候，必须等其中一个方法运行完之后把this对象解锁了之后才可以继续执行另一个方法。如果这只是一个小型应用，也许没事；但是如果这个应用非常庞大，需要上锁的参数非常多，那么同时调用的时刻会很多，会造成不必要的等待、降低程序的性能。</p>
<p>为了解决这个问题，我们可以给每一个需要上锁的变量新建一个专属对象。并用这个对象传入<code>synchronized</code>关键字。如下图所示：</p>
<p>我们创建了两个Object类型的对象，一个叫<code>totalBytesLock</code>用来锁住<code>totalBytes</code>; 以及<code>totalFilesLock</code>用来锁住<code>totalFiles</code> 变量。</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/14.png" style="zoom:80%;"></p>
<p>同步代码块能达成和同步方法一样的功能，但是效能比同步方法更高。</p>
<h3 id="线程交互"><a href="#线程交互" class="headerlink" title="线程交互"></a>线程交互</h3><p>线程交互是指两个线程之间通过通信联系对锁的获取与释放，从而达到较好的线程运行结果，避免引起混乱的结果。一般来说synchronized块的锁会让代码进入同步状态，即一个线程运行的同时让其它线程进行等待，那么如果需要进行实现更复杂的交互，则需要学习以下几个方法：</p>
<p>void notify(): 唤醒在此对象监视器上等待的单个线程。</p>
<p>void notifyAll(): 唤醒在此对象监视器上等待的所有线程。</p>
<p>void wait(): 让占用了这个同步对象的线程，临时释放当前的占用，并且等待。</p>
<p>wait()方法是使当前线程临时暂停，释放锁，并进入等待，其功能类似于sleep()方法，但是wait()需要释放锁，而sleep()不需要释放锁。</p>
<h5 id="任务："><a href="#任务：" class="headerlink" title="任务："></a>任务：</h5><p><strong>完善代码，利用wait()和notify()实现线程之间的交互。将关键代码写到实验报告中。</strong></p>
<p>还是用模拟多线程下载的例子。</p>
<p><code>DownloadStatus</code></p>
<p>首先我们在 <code>DownloadStatus</code> 中新建一个 <code>isDone</code>布尔变量并将其声明为volatile，来表明这个下载任务是否已经完成。并设定一个 <code>getter</code>返回<code>isDone</code> 和一个 <code>setter</code>将<code>isDown</code>设为True</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadStatus</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isDone;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> totalBytes;</span><br><span class="line">    <span class="keyword">private</span> Object totalBytesLock = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotalBytes</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> totalBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">incrementTotalBytes</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (totalBytesLock)&#123;</span><br><span class="line">            totalBytes++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span>  <span class="title">isDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isDone;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isDone = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在<code>DownloadFileTask</code>类中，我们在下载结束后调用 <code>status.done()</code>将<code>isDone()</code> 设置为True并输出Download complete</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadFileTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DownloadStatus status;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DownloadFileTask</span><span class="params">(DownloadStatus status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;i&lt; <span class="number">10_000</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().isInterrupted()) <span class="keyword">return</span>;</span><br><span class="line">            status.incrementTotalBytes();</span><br><span class="line">        &#125;</span><br><span class="line">        status.done();</span><br><span class="line">        System.out.println(<span class="string">"Download complete:"</span>+Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在<code>ThreadDemo</code>类中，新建两个线程，第一个线程传入DownloadFileTask对象，第二个线程里面是个 Lambda表达式，它会一直询问status中的变量isDone是否为True，一直到下载完成 ，isDone==True,才会跳出循环并输出<code>totalBytes</code>的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.concurrency;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">var</span> status = <span class="keyword">new</span> DownloadStatus();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DownloadFileTask(status));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> thread2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (!status.isDone())</span><br><span class="line">                System.out.println(status.getTotalBytes());</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(status.getTotalBytes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>刚才例子中，一直询问下载完成没。但是这样是很占用CPU的资源的。它可能会重复循环上亿次才能等到结果。</p>
<p>为了优化上面这种情况，我们可以用<code>wait()</code>和<code>notify()</code>方法</p>
<p>顾名思义，调用<code>wait()</code>方法后，线程进入等待状态，<code>wait()</code>方法不会返回，直到将来某个时刻，线程从等待状态被其他线程唤醒后，<code>wait()</code>方法才会返回，然后，继续执行下一条语句。<strong>注意，只能在锁对象上调用<code>wait()</code>方法</strong> 。<code>notify()</code>则是在<strong>相同的锁对象</strong>上作用，完成某件事后发出一个信号，让<code>wait()</code>去接收</p>
<p>比如下面这个例子，当我们要用while来询问<code>isDone()</code>是否为true的时候，我们对status上了一个锁。然后在里面调用<code>wait()</code>让线程2沉睡。再跑到<code>DownloadFileTask</code>类中，当下载完成时我们在 status上锁了的情况下调用 <code>notifyAll()</code>发出讯号。<code>wait()</code>收到后就会跳出循环，执行打印命令。</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/38.png" style="zoom:100%;"></p>
<p>通过这种机制我们可以降低CPU的负荷，优化程序性能。但同时，在不正确的地方使用<code>wait()</code>和<code>notify()</code>可能会造成很多难以解决的问题，因此我们不推荐这种方法。</p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p>编写一个程序，启动三个线程，三个线程的ID分别是A，B，C；每个线程将自己的ID值在屏幕上打印5遍，打印顺序是ABCABC…</p>
<p><code>MyThread</code> 类：</p>
<p>这里我们声明总线程数totalThreads，一个计数器 count ，一个进程号ID</p>
<p>判断当前线程是否需要打印的逻辑： 计数器%总线程数 == 当前线程的ID ，则打印进程名字</p>
<p>id由有参构造函数确定，这里 打印A的线程ID=0 ，打印B的线程ID=1，打印C的线程ID=2</p>
<p>注意，这里 count 要设置为 volatile 的，static的，因为这个变量是多个线程共享的，必须从主存中读取。此外，因为这个程序不是很大，所以我没有使用<code>wait()</code>和<code>notifyAll()</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> totalThreads;</span><br><span class="line">    <span class="comment">// 线程id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count % totalThreads != id)&#123;&#125;</span><br><span class="line">            System.out.print(Thread.currentThread().getName()+<span class="string">" "</span>);</span><br><span class="line">            MyThread.count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Main</code> 类：</p>
<p>在main方法中我们创建一个线程集合，然后利用有参构造创建三个线程对象，并规定他们的name分别是ABC</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Collection&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        MyThread.totalThreads = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MyThread.totalThreads; i++) &#123;</span><br><span class="line">            threads.add(<span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread(i),String.valueOf((<span class="keyword">char</span>)(i+<span class="string">'A'</span>))));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> thread:threads)</span><br><span class="line">            thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/15.png" style="zoom:80%;"></p>
<h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><p>编写两个线程，一个线程负责打印字母，另一个线程负责打印数字，两个线程同时进行打印，要求打印出来的结果的形式为</p>
<p>a1b23c456d7891 ……z……（数字为1-9的循环）</p>
<p>问题2和问题1的底层逻辑其实是共通的.</p>
<p>只不过这里没有办法只创建一个线程类了，因此我把公共的部分抽出来构成了一个新的类<code>PrintStatus</code>:</p>
<p>在这里我们设置了两个变量，一个是 volatile的计数器，我们用它来判断当前线程是否需要打印。第二个变量是totalThreads，用来记载当前线程数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintStatus</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> totalThreads;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotalThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> totalThreads;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTotalThreads</span><span class="params">(<span class="keyword">int</span> totalThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.totalThreads = totalThreads;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Main</code> 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        PrintStatus status = <span class="keyword">new</span> PrintStatus();</span><br><span class="line">        status.setTotalThreads(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> charPrinter = <span class="keyword">new</span> Thread(<span class="keyword">new</span> CharPrinter(status));</span><br><span class="line">        <span class="keyword">var</span> numberPrinter = <span class="keyword">new</span> Thread(<span class="keyword">new</span> NumberPrinter(status));</span><br><span class="line"></span><br><span class="line">        charPrinter.start();</span><br><span class="line">        numberPrinter.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CharPrinter</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharPrinter</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ID = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> PrintStatus status;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CharPrinter</span><span class="params">(PrintStatus status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (status.getCount() % status.getTotalThreads() != ID)&#123;&#125;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)(i+<span class="string">'a'</span>));</span><br><span class="line">            status.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NumberPrinter</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberPrinter</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ID = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> PrintStatus status;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> adder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumberPrinter</span><span class="params">(PrintStatus status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">27</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (status.getCount() % status.getTotalThreads() != ID)&#123;&#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = (adder+<span class="number">1</span>)%<span class="number">9</span> == <span class="number">0</span>?<span class="number">9</span>:(adder+<span class="number">1</span>)%<span class="number">9</span> ;</span><br><span class="line">                System.out.print(temp);</span><br><span class="line">                adder++;</span><br><span class="line">            &#125;</span><br><span class="line">            status.increment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里因为篇幅，我们只打印一个轮回就结束进程</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/16.png" style="zoom:80%;"></p>
<h3 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h3><p>编写程序，模拟三个窗口同时卖票，包括购票（可能存在购买多张的情况），退票（可能存在退多张的情况）和新进票，要求有余票时必须出售，无票时不能出售，购票时若无足量余票可选择继续等待或离开。</p>
<p> <code>Main</code>类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> status;</span><br><span class="line">        <span class="keyword">int</span> windowNumber = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> buyNumber,refundNumber;</span><br><span class="line">        <span class="keyword">boolean</span> isLeave = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        TicketStatus ticketStatus = <span class="keyword">new</span> TicketStatus();</span><br><span class="line">        Scanner statusScanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        Scanner buyScanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        Scanner refundScanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        Scanner windowScanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        Scanner newTicketScanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> thread:threads)</span><br><span class="line">            thread.start();</span><br><span class="line">        <span class="keyword">while</span>(!isLeave)&#123;</span><br><span class="line">            System.out.println(<span class="string">"请输入要执行的操作。1代表购票；2代表退票；3代表查询余票；4代表离开; 5代表新进票"</span>);</span><br><span class="line">            status = statusScanner.nextInt();</span><br><span class="line">            <span class="keyword">switch</span> (status)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    System.out.println(<span class="string">"请问要到几号柜台进行办理购票操作？1/2/3"</span>);</span><br><span class="line">                    windowNumber = windowScanner.nextInt();</span><br><span class="line">                    System.out.println(<span class="string">"请问要购买几张票？"</span>);</span><br><span class="line">                    buyNumber = buyScanner.nextInt();</span><br><span class="line">                    ticketStatus.setSellNumber(buyNumber);</span><br><span class="line">                    ticketStatus.setOperation(status);</span><br><span class="line">                    <span class="keyword">new</span> Thread(<span class="keyword">new</span> TicketWindow(ticketStatus), String.valueOf(windowNumber)).start();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    System.out.println(<span class="string">"请问要到几号柜台进行办理退票操作？1/2/3"</span>);</span><br><span class="line">                    windowNumber = windowScanner.nextInt();</span><br><span class="line">                    System.out.println(<span class="string">"请问要退几张票？"</span>);</span><br><span class="line">                    refundNumber = refundScanner.nextInt();</span><br><span class="line">                    ticketStatus.setRefundNumber(refundNumber);</span><br><span class="line">                    ticketStatus.setOperation(status);</span><br><span class="line">                    <span class="keyword">new</span> Thread(<span class="keyword">new</span> TicketWindow(ticketStatus), String.valueOf(windowNumber)).start();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    System.out.println(<span class="string">"当前剩余票数: "</span>+ticketStatus.getTicketNumber());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    isLeave = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">var</span> thread:threads)</span><br><span class="line">                        thread.interrupt();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                    System.out.println(<span class="string">"请问要新进几张票？"</span>);</span><br><span class="line">                    <span class="keyword">int</span> newTicket = newTicketScanner.nextInt();</span><br><span class="line">                    ticketStatus.addNewTicket(newTicket);</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    System.out.println(<span class="string">"输入错误，请重试"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程：<code>TicketWindow</code>类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketWindow</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TicketStatus status;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TicketWindow</span><span class="params">(TicketStatus status)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String name = Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">int</span> operation = status.getOperation();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        while (true) &#123;</span></span><br><span class="line">            <span class="keyword">switch</span> (operation) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    System.out.println(name + <span class="string">"号柜台为您办理"</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (status) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            status.sellTicket(status.getSellNumber());</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (NoTicketsException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    System.out.println(name + <span class="string">"号柜台为您办理"</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (status) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            status.refundTicket(status.getRefundNumber());</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (ExceedTicketsException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TicketStatus</code>类，用来存储余票,各种操作的状态，买卖票数等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketStatus</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger totalTickets = <span class="keyword">new</span> AtomicInteger(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> operation;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sellNumber;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> refundNumber;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refundTicket</span><span class="params">(<span class="keyword">int</span> number)</span> <span class="keyword">throws</span> ExceedTicketsException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(totalTickets.get()+number&gt;<span class="number">1000</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExceedTicketsException();</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            totalTickets.addAndGet(number);</span><br><span class="line">            System.out.println(<span class="string">"退票成功！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">(<span class="keyword">int</span> number)</span> <span class="keyword">throws</span> NoTicketsException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number &gt; totalTickets.get())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoTicketsException();</span><br><span class="line">            totalTickets.addAndGet(-number);</span><br><span class="line">            System.out.println(<span class="string">"购票成功！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNewTicket</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        totalTickets.addAndGet(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTicketNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> totalTickets.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> operation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOperation</span><span class="params">(<span class="keyword">int</span> operation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.operation = operation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSellNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sellNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSellNumber</span><span class="params">(<span class="keyword">int</span> sellNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sellNumber = sellNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRefundNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> refundNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRefundNumber</span><span class="params">(<span class="keyword">int</span> refundNumber)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.refundNumber = refundNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2021/03/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A2/18.png" style="zoom:80%;"></p>
<h3 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h3><p>编写10个线程，第一个线程从1加到10000，第二个线程从10001加20000…第十个线程从90001加到100000，最后再把10个线程结果相加，记录运行时间，并和串行相加时候的时间进行对比；编写50个线程，第一个线程从1加到10000，第二个线程从10001加20000……，最后再把50个线程结果相加，记录运行时间，并和串行相加时候的时间进行对比；编写100个线程，第一个线程从1加到10000，第二个线程从10001加20000……，最后再把100个线程结果相加，记录运行时间，并和串行相加时候的时间进行对比，给出对比结果。总结分析，单机情况下是不是线程越多越好，为什么。</p>
<p>串行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sequencial</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loop;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sequencial</span><span class="params">(<span class="keyword">int</span> loop)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loop = loop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span>  startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>;i&lt;loop*<span class="number">10_000</span>;i++)&#123;count++;&#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"串行程序运行时间："</span> + (endTime - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> loop;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadDemo</span><span class="params">(<span class="keyword">int</span> loop)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loop = loop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">var</span> status = <span class="keyword">new</span> DownloadStatus();</span><br><span class="line">        List&lt;Thread&gt; threads = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">long</span>  startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="keyword">this</span>.loop;i++)&#123;</span><br><span class="line">            <span class="keyword">var</span> thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> DownloadFileTask(status));</span><br><span class="line">            thread.start();</span><br><span class="line">            threads.add(thread);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> thread : threads)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                thread.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(status.getTotalBytes());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();     </span><br><span class="line">        System.out.println(<span class="string">"并行程序运行时间："</span> + (endTime - startTime) + <span class="string">"ms"</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Main</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   		<span class="comment">// 传入的数据就是线程数</span></span><br><span class="line">        <span class="keyword">var</span> sequencialDemo = <span class="keyword">new</span> Sequencial(<span class="number">10000</span>);</span><br><span class="line">      <span class="comment">//循环次数=传入的数*10000</span></span><br><span class="line">        <span class="keyword">var</span> concurrencyDemo = <span class="keyword">new</span> ThreadDemo(<span class="number">10000</span>);</span><br><span class="line">        sequencialDemo.show();</span><br><span class="line">        concurrencyDemo.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个模型和线程同步模块所讲的例子一样，不过我们要计算一下运行时间</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>线程数</th>
<th>串行时间</th>
<th>并行时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>3</td>
<td>26</td>
</tr>
<tr>
<td>50</td>
<td>8</td>
<td>65</td>
</tr>
<tr>
<td>100</td>
<td>10</td>
<td>91</td>
</tr>
<tr>
<td>1000</td>
<td>11</td>
<td>498</td>
</tr>
<tr>
<td>10000</td>
<td>13</td>
<td>3018</td>
</tr>
</tbody>
</table>
</div>
<p>我们发现在一台电脑的情况下，串行时间比并行时间要快很多。因为并行操作会发生线程创建和上下文切换的开销。线程越多开销越大，因此并不是线程越多越好。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我在博客<a href="https://jasonxqh.github.io/2021/03/19/Java基础3/">Java基础3</a>中已经对多线程和并发做了详细的讨论了。但是这次的试验，又让我在复习的基础上对多线程编程有了更加深刻的认识。接下来的空闲时间需要学习Java的项目管理工具以及一些应用框架。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/15/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jason</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">439</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    

  

</body>
</html>
