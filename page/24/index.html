<!DOCTYPE html>
<html lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jasonxqh.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Jason‘s Blog">
<meta property="og:url" content="https://jasonxqh.github.io/page/24/index.html">
<meta property="og:site_name" content="Jason‘s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Jason">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://jasonxqh.github.io/page/24/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Jason‘s Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Jason‘s Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/06/24/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/24/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">拓扑排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-24 13:59:20 / Modified: 17:11:46" itemprop="dateCreated datePublished" datetime="2020-06-24T13:59:20+08:00">2020-06-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE/" itemprop="url" rel="index"><span itemprop="name">图</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>​    —个无环的有向图称为<strong>有向无环图</strong> (DirectedAcycline Graph, DAG)。$11$</p>
<p>​    有向无环图是描述—个工程、 计划、 生产、 系统等流程的有效工具。 —个大工程可分为若干个子工程（活动）， 活动之间通常有—定的约束， 例如先做什么活动， 什么活动完成后才可以开始下—个活动。 </p>
<p>​    用顶点表示活动， 用弧表示活动之间的优先关系的有向图， 称为顶点表示活动的网 (Activity On Vertex Network), 简称 AOV 网。 </p>
<p>​    在 AOV 网中，若从顶点i 到顶点之间存在—条有向路径， 称顶点 i 是顶点 j 的前驱， 或者称顶点 j 是顶点 i 的后继。 若<i,j\>是图中的弧， 则称顶点i是顶点j 的互接前驱， 顶点 j 是顶点 i 的互接后驱。 </i,j\></p>
<p>​    AOV网中的弧表示了活动之间存在的制约关系。 例如， 计算机专业的学生必须完成一系列规定的基础课和专业课才能毕业．学生按照怎样的顺序来学习这些课程呢？这个问题可以被看成是一个大的工程， 其活动就是学习每一门课程。这些课程的名称和代号如下表所示</p>
<p><img src="/2020/06/24/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/1.png" style="zoom:80%;"></p>
<p>如果用顶点表示课程，弧表示先修关系，若课程i是课程j的先修课程，在用弧<i,j\> 表示，课程之间的关系如图</i,j\></p>
<p><img src="/2020/06/24/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/2.png" style="zoom:100%;"></p>
<p>要想找什么课程先修，那就看有没有入度。入度为0即可输出。比如这里C0,C5都是可以先输出的</p>
<p>C0一旦输出以后，C0的出度全部去掉。所以C1的入度从2变成了1……</p>
<p><code>AOV</code>网中是不允许有环的，否则会出现自己是自己的前驱，陷入死循环。<strong>怎么判断<code>AOV</code>网中， 是否有环呢</strong>？一个检测的办法是对有向图的顶点进行拓扑排序。如果<code>AOV</code>网中所有的顶点都在拓扑序列中， 则<code>AOV</code>网中必定无环。因为有环的话，这个环中的每个顶点都是存在入度的  </p>
<p><strong>拓扑排序</strong>是指将<code>AOV</code>网中的顶点排成一个<strong>线性序列</strong>，该序列必须满足： 若从顶点i到j有一条路径， 则该序列中顶点i一定在顶点j 之前</p>
<p>如果进行拓扑排序呢? </p>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>1)     选择—个无前驱的顶点并输出</p>
<p>2)    从图中删除该顶点和该顶点的所有发出边 </p>
<p>3)    重复 1) 和 2), 直到不存在无前驱的顶点。 </p>
<p>4)    如果输出的顶点数小于<code>AOV</code>网中的顶点数， 则说明网中有环，否则输出的序列即为拓扑序列。</p>
<p><img src="/2020/06/24/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/4.png" style="zoom:100%;"></p>
<p>上述的描述过程中，有删除顶点和边的操作，实际上， 完全没必要真的删除顶点和边 。 可以将没有前驱的顶点 （入度为0) 暂存到栈中，输出时出栈即表示删除 。边的删除只需要将其邻接点的入度减一即可。 例如图中， 删除C0的所有发出边， 相当于将 C3, C2, C1 顶点的入度减去1, 如图 7-185 所示。 </p>
<p><img src="/2020/06/24/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/5.png" style="zoom: 67%;"></p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>1)    求出各顶点的入度, 存入数组 indegree[]中，并将入度为0 的顶点入栈S。.,<br>2)    如果栈不空， 则重复执行以下操作</p>
<ul>
<li>栈顶元素i出栈，并保存到拓扑序列数组 topo[]中</li>
<li>顶点i 的所有邻接点入度减1, 如果减1后入度为 0 , 立即入栈S.</li>
</ul>
<p>3)    如果输出的顶点数小千 AOV网中的顶点数，则说明网中有环，否则输出拓扑序列。</p>
<p><img src="/2020/06/24/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/6.png"></p>
<p>因为经常要访问临界点，所以邻接表和链式前向星(静态邻接表)更好。 邻接表访问邻接点容易，计算入度难，因此为了计算顶点的入度，在创建邻接表的同时，再创建一个逆邻接表，根据逆邻接表计算各顶点的入度。</p>
<p><img src="/2020/06/24/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/7.png" style="zoom:67%;"></p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p><img src="/2020/06/24/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/8.png" style="zoom:110%;"></p>
<p><img src="/2020/06/24/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/9.png" style="zoom:120%;"></p>
<p><img src="/2020/06/24/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/10.png" style="zoom:120%;"></p>
<p><img src="/2020/06/24/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/11.png" style="zoom:120%;"></p>
<p><img src="/2020/06/24/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/12.png" style="zoom:120%;"></p>
<p><img src="/2020/06/24/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/13.png" style="zoom:120%;"></p>
<p><img src="/2020/06/24/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/14.png" style="zoom:120%;"></p>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p><strong>时间复杂度</strong>：求有向图中各顶点的入度需要遍历逆邻接表，算法的时间复杂度为O(e)。 度数为0的顶点入栈的时间复杂度为O(n), 若有向图无环，每个顶点出栈后其邻接点入度减1, 时间复杂度为O(e)。 总的时间复杂度为O(n+e)。 </p>
<p><strong>空间复杂度</strong>：算法所需要的辅助空间包含入度数组indegree[]、拓扑序列数组 topo[] 、栈s, 则算法的空间复杂度是O(n)</p>
<p>算法可视化 <a href="https://visualgo.net/zh/dfsbfs" target="_blank" rel="noopener">https://visualgo.net/zh/dfsbfs</a></p>
<p><a href="https://www.cs.usfca.edu/~galles/visualization/TopoSortIndegree.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/TopoSortIndegree.html</a></p>
<h3 id="代码一览"><a href="#代码一览" class="headerlink" title="代码一览"></a>代码一览</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxVnum=<span class="number">100</span>;<span class="comment">//顶点数最大值</span></span><br><span class="line"><span class="keyword">int</span> indegree[MaxVnum];<span class="comment">//入度数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">string</span> VexType;<span class="comment">//顶点的数据类型为字符串型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AdjNode</span>&#123;</span> <span class="comment">//定义邻接点类型</span></span><br><span class="line">	<span class="keyword">int</span> v; <span class="comment">//邻接点下标</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">AdjNode</span> *<span class="title">next</span>;</span> <span class="comment">//指向下一个邻接点</span></span><br><span class="line">&#125;AdjNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VexNode</span>&#123;</span> <span class="comment">//定义顶点类型</span></span><br><span class="line">	VexType data; <span class="comment">// VexType为顶点的数据类型，根据需要定义</span></span><br><span class="line">	AdjNode *first; <span class="comment">//指向第一个邻接点</span></span><br><span class="line">&#125;VexNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span><span class="comment">//包含邻接表和逆邻接表</span></span><br><span class="line">    VexNode Vex[MaxVnum]; <span class="comment">//定义邻接表</span></span><br><span class="line">    VexNode converse_Vex[MaxVnum]; <span class="comment">//定义逆邻接表</span></span><br><span class="line">    <span class="keyword">int</span> vexnum,edgenum; <span class="comment">//顶点数，边数</span></span><br><span class="line">&#125;ALGragh;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">locatevex</span><span class="params">(ALGragh G,VexType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//查找顶点信息的下标</span></span><br><span class="line">       <span class="keyword">if</span>(x==G.Vex[i].data)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//没找到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertedge</span><span class="params">(ALGragh &amp;G,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span><span class="comment">//插入一条边</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AdjNode *s1,*s2;</span><br><span class="line">    s1=<span class="keyword">new</span> AdjNode;<span class="comment">//创建邻接表结点</span></span><br><span class="line">    s1-&gt;v=j;</span><br><span class="line">    s1-&gt;next=G.Vex[i].first;</span><br><span class="line">    G.Vex[i].first=s1;</span><br><span class="line">    s2=<span class="keyword">new</span> AdjNode;<span class="comment">//创建逆邻接表结点</span></span><br><span class="line">    s2-&gt;v=i;</span><br><span class="line">    s2-&gt;next=G.converse_Vex[j].first;</span><br><span class="line">    G.converse_Vex[j].first=s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printg</span><span class="params">(ALGragh G)</span><span class="comment">//输出邻接表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"----------邻接表如下：----------"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       AdjNode *t=G.Vex[i].first;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;G.Vex[i].data&lt;&lt;<span class="string">"：  "</span>;</span><br><span class="line">       <span class="keyword">while</span>(t!=<span class="literal">NULL</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">cout</span>&lt;&lt;<span class="string">"["</span>&lt;&lt;t-&gt;v&lt;&lt;<span class="string">"]  "</span>;</span><br><span class="line">           t=t-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"----------逆邻接表如下：----------"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       AdjNode *t=G.converse_Vex[i].first;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;G.converse_Vex[i].data&lt;&lt;<span class="string">"：  "</span>;</span><br><span class="line">       <span class="keyword">while</span>(t!=<span class="literal">NULL</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">cout</span>&lt;&lt;<span class="string">"["</span>&lt;&lt;t-&gt;v&lt;&lt;<span class="string">"]  "</span>;</span><br><span class="line">           t=t-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateALGraph</span><span class="params">(ALGragh &amp;G)</span><span class="comment">//创建有向图的邻接表和逆邻接表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    VexType u,v;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入顶点数和边数:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;G.vexnum&gt;&gt;G.edgenum;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入顶点信息:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//输入顶点信息，存入顶点信息数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;G.Vex[i].data;</span><br><span class="line">        G.converse_Vex[i].data=G.Vex[i].data;</span><br><span class="line">        G.Vex[i].first=<span class="literal">NULL</span>;</span><br><span class="line">        G.converse_Vex[i].first=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请依次输入每条边的两个顶点u,v"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span>(G.edgenum--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        i=locatevex(G,u);<span class="comment">//查找顶点u的存储下标</span></span><br><span class="line">        j=locatevex(G,v);<span class="comment">//查找顶点v的存储下标</span></span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">-1</span>&amp;&amp;j!=<span class="number">-1</span>)</span><br><span class="line">            insertedge(G,i,j);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">           <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入顶点信息错！请重新输入！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">           G.edgenum++;<span class="comment">//本次输入不算</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindInDegree</span><span class="params">(ALGragh G)</span><span class="comment">//求出各顶点的入度存入数组indegree中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,count;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        count=<span class="number">0</span>;</span><br><span class="line">        AdjNode *p=G.converse_Vex[i].first;</span><br><span class="line">		<span class="keyword">if</span>(p)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span>(p)</span><br><span class="line">			&#123;</span><br><span class="line">				p=p-&gt;next;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		indegree[i]=count;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"入度数组为："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//输出入度数组</span></span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;indegree[i]&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TopologicalSort</span><span class="params">(ALGragh G, <span class="keyword">int</span> topo[])</span><span class="comment">//拓扑排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//有向图G采用邻接表存储结构</span></span><br><span class="line">    <span class="comment">//若G无回路，则生成G的一个拓扑序列topo[]并返回true，否则false</span></span><br><span class="line">	<span class="keyword">int</span> i,m;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;S;      <span class="comment">//初始化一个栈S，需要引入头文件#include&lt;stack&gt;</span></span><br><span class="line">    FindInDegree(G);  <span class="comment">//求出各顶点的入度存入数组indegree[]中</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">		<span class="keyword">if</span>(!indegree[i])<span class="comment">//入度为0者进栈</span></span><br><span class="line">            S.push(i);</span><br><span class="line">	m=<span class="number">0</span>;            <span class="comment">//对输出顶点计数，初始为0</span></span><br><span class="line">	<span class="keyword">while</span>(!S.empty())<span class="comment">//栈S非空</span></span><br><span class="line">    &#123;</span><br><span class="line">		i=S.top();    <span class="comment">//取栈顶顶点i</span></span><br><span class="line">        S.pop();      <span class="comment">//栈顶顶点i出栈</span></span><br><span class="line">		topo[m]=i;    <span class="comment">//将i保存在拓扑序列数组topo中</span></span><br><span class="line">		m++;          <span class="comment">//对输出顶点计数</span></span><br><span class="line">		AdjNode *p=G.Vex[i].first;  <span class="comment">//p指向i的第一个邻接点</span></span><br><span class="line">		<span class="keyword">while</span>(p) <span class="comment">//i的所有邻接点入度减1</span></span><br><span class="line">        &#123;</span><br><span class="line">			<span class="keyword">int</span> k=p-&gt;v;			 <span class="comment">//k为i的邻接点</span></span><br><span class="line">			--indegree[k];       <span class="comment">//i的每个邻接点的入度减1</span></span><br><span class="line">			<span class="keyword">if</span>(indegree[k]==<span class="number">0</span>)  <span class="comment">//若入度减为0，则入栈</span></span><br><span class="line">			  S.push(k);</span><br><span class="line">			p=p-&gt;next;      <span class="comment">//p指向顶点i下一个邻接结点</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(m&lt;G.vexnum)<span class="comment">//该有向图有回路</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ALGragh G;</span><br><span class="line">    <span class="keyword">int</span> *topo=<span class="keyword">new</span> <span class="keyword">int</span>[G.vexnum];</span><br><span class="line">    CreateALGraph(G);<span class="comment">//创建有向图的邻接表和逆邻接表</span></span><br><span class="line">    printg(G);<span class="comment">//输出邻接表和逆邻接表</span></span><br><span class="line">    <span class="keyword">if</span>(TopologicalSort(G,topo))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"拓扑序列为："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//输出拓扑序列</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;topo[i]&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"该图有环，无拓扑序列！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二种算法"><a href="#第二种算法" class="headerlink" title="第二种算法"></a>第二种算法</h3><p>假设这是有向无环图。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[maxn][maxn],indegree[maxn],topo[maxn];<span class="comment">//利用了邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line"><span class="comment">//不接受字符串，只能整数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TopoSort</span><span class="params">()</span> <span class="comment">//拓扑排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="comment">//入度为0的全部都入栈</span></span><br><span class="line">        <span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)</span><br><span class="line">        	s.push(i);</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">int</span> u=s.top(); <span class="comment">//取栈顶</span></span><br><span class="line">    	s.pop();	   <span class="comment">//出栈</span></span><br><span class="line">    	topo[++cnt]=u; <span class="comment">//然后把u存储到topo数组当中</span></span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)<span class="comment">//访问所有u的邻接点</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[u][j])</span><br><span class="line">            	<span class="keyword">if</span>(--indegree[j]==<span class="number">0</span>)<span class="comment">//然后把临界点的入度减一</span></span><br><span class="line">        			s.push(j);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;<span class="comment">//节点数和边数</span></span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">map</span>,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="built_in">map</span>));</span><br><span class="line">    <span class="built_in">memset</span>(indegree,<span class="number">0</span>,<span class="keyword">sizeof</span>(indegree));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">int</span> u,v;</span><br><span class="line">    	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v)<span class="comment">//输入边</span></span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="built_in">map</span>[u][v]=<span class="number">1</span>;<span class="comment">//表示有一条u-&gt;v的边</span></span><br><span class="line">    		indegree[v]++;<span class="comment">//立即入度++</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	TopoSort();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;topo[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;topo[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">图与贪心算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-21 12:55:53" itemprop="dateCreated datePublished" datetime="2020-06-21T12:55:53+08:00">2020-06-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-26 09:27:59" itemprop="dateModified" datetime="2023-03-26T09:27:59+08:00">2023-03-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE/" itemprop="url" rel="index"><span itemprop="name">图</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="图与贪心算法"><a href="#图与贪心算法" class="headerlink" title="图与贪心算法"></a>图与贪心算法</h1><h2 id="最短路径：Dijkstra算法"><a href="#最短路径：Dijkstra算法" class="headerlink" title="最短路径：Dijkstra算法"></a>最短路径：Dijkstra算法</h2><p>给定有向图带权图 G= (V, E), 其中每条边的权是<strong>非负实数</strong>。此外，给定V中的—个顶点，称为源点。现在要计算从源点到所有其他各顶点的最短路径长度， 这里<strong>路径长度指路上各边的权之和。</strong> </p>
<p>如何求其他各顶点的最短路径呢？</p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/1.png" style="zoom:80%;"></p>
<p>1-&gt;2 的最短路径为2</p>
<p>1-&gt;3的最短路径是2+2 = 4</p>
<p>……</p>
<p>​    迪科斯彻提出了著名的单源最短路径求解算法——Dijkstra算法。艾兹格• W• 迪科斯彻(Edsger Wybe Dijkstra), 荷兰人， 计算机科学家。 他早年钻研物理及数学， 后转而研究计算学今 他曾在1972年获得过素有 “计算机科学界的诺贝尔奖” 之称的图灵奖， 与Donald Ervin Knuth并称为我们这个时代最伟大的计算机科学家。 </p>
<p>​    Dijkstra算法是解决单源最短路径问题的贪心算法， 它先求出长度最短的—条路径， 再参照该最短路径求出长度次短的—条路径， 直到求出从源点到其他各个顶点的最短路径。 </p>
<p>​    Dijkstra算法的基本思想是首先假定源点为u, 顶点集合V被划分为两部分：集合S和V-S 。 初始时S中仅含有源点u, 其中S中的顶点到源点的最短路径已经确定。 集合V-S 中所包含的顶点到源点的最短路径的长度待定， 称从源点出发只经过S中的点到达V-S中的点的路径为特殊路径，并用数组dist[]记录当前每个顶点所对应的最短特殊路径<br>长度。 </p>
<p>Dijkstra算法采用的贪心策略是选择特殊路径长度最短 的路径，将其连接的 V-S 中的顶点加入到集合S中，同时更新数组dist[] —旦S包含了所有顶点，dist[] 就是从源到所有其他顶点之间的最短路径长度 。 </p>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>1)数据结构。设置地图的带权邻接矩阵为G.Edge [][], 即如果从源点u到顶点i有边，就令 G.Edge[u][i]等于\<u, i\>的权值，否则G.Edge(u](i]== (无穷大）；采用—维数组dist[i]来记录从源点到i顶点的最短路径长度；采用—维数组p[i]来记录最短路径上i顶点的前驱。 </u,></p>
<p>2) 初始化。令集合S={u}, 对千集合 V-S 中的所有顶点X, 初始化dist[i]=G.Edge[u][i],如果源点u到i有边相连，初始化p[i] = u，否则p[i] = -1；</p>
<p>3）找最小。在集合V-S中依照贪心策略来寻找使得dist[j]具有最小值的顶点t，即dist[t] = min(dist[j]|j属于V-S集合) ，则顶点t就是集合V-S中距离源点u最近的顶点</p>
<p>4）加入s战队。把顶点t加入集合s中。同时更新V-S</p>
<p>5）判结束。如果集合V-S为空。算法结束，否则进行6</p>
<p>6）借东风。在3）中已经找到了源点到t的最短路径，那么对集合V-S 中所有与顶点t相邻的顶点j，都可以借助t走捷径。如果dis[j]&gt;dist[t]+G.E[i][j] .则dist[j] = dist[t]+G.E[t][j] ，记录顶点j的前驱为t，有p[j] = t 转3）</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/2.png" style="zoom:120%;"></p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/3.png"></p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/4.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/5.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/6.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/7.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/8.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/9.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/10.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/11.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/12.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/13.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/14.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/15.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/1.gif" style="zoom:120%;"></p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/16.png" style="zoom:120%;"></p>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>1）时间复杂度：在Dijkstra 算法描述中，一共有4个for语句，第1个for语句的执行次数为n，第2个for语句里面嵌套了两个for语句3、4，它们的执行次数均为n，对算法的运行事件贡献最大，当外层循环标号为1时，3、4语句在内层循环的控制下均质性n次，外层循环2从1~n 。因此，该语句的执行次数为$n\times n=n^2$ 算法的时间复杂度为$O(|V|^2)$ </p>
<p>2) 空间复杂度，由以上算法可以得出，实现该算法需要的辅助空间包含数组flag、变量i,j,t 和temp所分配的空间，因此，空间复杂度为O(n).</p>
<h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/17.png"></p>
<h3 id="代码一览"><a href="#代码一览" class="headerlink" title="代码一览"></a>代码一览</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxVnum=<span class="number">100</span>; <span class="comment">// 城市的个数可修改</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1e7</span>; <span class="comment">// 无穷大10000000</span></span><br><span class="line"><span class="keyword">int</span> dist[MaxVnum],p[MaxVnum];<span class="comment">//最短距离和前驱数组</span></span><br><span class="line"><span class="keyword">bool</span> flag[MaxVnum]; <span class="comment">//如果s[i]等于true，说明顶点i已经加入到集合S;否则顶点i属于集合V-S</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">string</span> VexType;  <span class="comment">//顶点的数据类型，根据需要定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;  <span class="comment">//边上权值的数据类型，若不带权值的图，则为0或1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  VexType Vex[MaxVnum];</span><br><span class="line">  EdgeType Edge[MaxVnum][MaxVnum];</span><br><span class="line">  <span class="keyword">int</span> vexnum,edgenum; <span class="comment">//顶点数，边数</span></span><br><span class="line">&#125;AMGragh;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">locatevex</span><span class="params">(AMGragh G,VexType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//查找顶点信息的下标</span></span><br><span class="line">       <span class="keyword">if</span>(x==G.Vex[i])</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//没找到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateAMGraph</span><span class="params">(AMGragh &amp;G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,w;</span><br><span class="line">    VexType u,v;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入顶点数："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;G.vexnum;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入边数:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;G.edgenum;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入顶点信息:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//输入顶点信息，存入顶点信息数组</span></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;G.Vex[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//初始化邻接矩阵为无穷大</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;G.vexnum;j++)</span><br><span class="line">         G.Edge[i][j]=INF;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入每条边依附的两个顶点及权值："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span>(G.edgenum--)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">       i=locatevex(G,u);<span class="comment">//查找顶点u的存储下标</span></span><br><span class="line">       j=locatevex(G,v);<span class="comment">//查找顶点v的存储下标</span></span><br><span class="line">       <span class="keyword">if</span>(i!=<span class="number">-1</span>&amp;&amp;j!=<span class="number">-1</span>)</span><br><span class="line">         G.Edge[i][j]=w; <span class="comment">//有向图邻接矩阵</span></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">cout</span> &lt;&lt; <span class="string">"输入顶点信息错！请重新输入！"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">           G.edgenum++;<span class="comment">//本次输入不算</span></span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(AMGragh G,<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">     dist[i]=G.Edge[u][i]; <span class="comment">//初始化源点u到其他各个顶点的最短路径长度，时间为O(n)</span></span><br><span class="line">     flag[i]=<span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">if</span>(dist[i]==INF)</span><br><span class="line">       p[i]=<span class="number">-1</span>; <span class="comment">//源点u到该顶点的路径长度为无穷大，说明顶点i与源点u不相邻</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">       p[i]=u; <span class="comment">//说明顶点i与源点u相邻，设置顶点i的前驱p[i]=u</span></span><br><span class="line">     &#125;</span><br><span class="line">    dist[u]=<span class="number">0</span>;</span><br><span class="line">    flag[u]=<span class="literal">true</span>;   <span class="comment">//初始时，集合S中只有一个元素：源点u</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum; i++)<span class="comment">//运行n-1次，O(n)</span></span><br><span class="line">     &#123;</span><br><span class="line">        <span class="keyword">int</span> temp=INF,t=u; <span class="comment">//这个for语句是找最小值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;G.vexnum; j++) <span class="comment">//在集合V-S中寻找距离源点u最近的顶点t</span></span><br><span class="line">          <span class="keyword">if</span>(!flag[j]&amp;&amp;dist[j]&lt;temp)<span class="comment">//!flag[j]代表着这个元素属于V-S</span></span><br><span class="line">          &#123;</span><br><span class="line">            t=j;</span><br><span class="line">            temp=dist[j];</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">if</span>(t==u) <span class="keyword">return</span> ; <span class="comment">//找不到t，跳出循环</span></span><br><span class="line">        flag[t]= <span class="literal">true</span>;  <span class="comment">//否则，将t加入集合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;G.vexnum;j++)<span class="comment">//这个for语句是更新与t相邻接的顶点到源点u的距离</span></span><br><span class="line">          <span class="keyword">if</span>(!flag[j]&amp;&amp;G.Edge[t][j]&lt;INF)</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;(dist[t]+G.Edge[t][j]))</span><br><span class="line">             &#123;</span><br><span class="line">               dist[j]=dist[t]+G.Edge[t][j] ;</span><br><span class="line">               p[j]=t ;</span><br><span class="line">             &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findpath</span><span class="params">(AMGragh G,VexType u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;S;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"源点为："</span>&lt;&lt;u&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    x=p[i];</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">-1</span>&amp;&amp;u!=G.Vex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"源点到其它各顶点最短路径为："</span>&lt;&lt;u&lt;&lt;<span class="string">"--"</span>&lt;&lt;G.Vex[i]&lt;&lt;<span class="string">"    sorry,无路可达"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      S.push(x);</span><br><span class="line">      x=p[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"源点到其它各顶点最短路径为："</span>;</span><br><span class="line">    <span class="keyword">while</span>(!S.empty())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;G.Vex[S.top()]&lt;&lt;<span class="string">"--"</span>;</span><br><span class="line">      S.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;G.Vex[i]&lt;&lt;<span class="string">"    最短距离为："</span>&lt;&lt;dist[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        AMGragh G;</span><br><span class="line">        <span class="keyword">int</span> st;</span><br><span class="line">        VexType u;</span><br><span class="line">        CreateAMGraph(G);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">"请输入源点的信息:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;u;</span><br><span class="line">        st=locatevex(G,u);<span class="comment">//查找源点u的存储下标</span></span><br><span class="line">        Dijkstra(G,st);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">"小明所在的位置:"</span>&lt;&lt;u&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt;<span class="string">"小明:"</span>&lt;&lt;u&lt;&lt;<span class="string">" - "</span>&lt;&lt;<span class="string">"要去的位置:"</span>&lt;&lt;G.Vex[i];</span><br><span class="line">             <span class="keyword">if</span>(dist[i]==INF)</span><br><span class="line">               <span class="built_in">cout</span> &lt;&lt; <span class="string">" sorry,无路可达"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">               <span class="built_in">cout</span> &lt;&lt; <span class="string">" 最短距离为:"</span>&lt;&lt;dist[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         findpath(G,u);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最短路径：Floyd算法"><a href="#最短路径：Floyd算法" class="headerlink" title="最短路径：Floyd算法"></a>最短路径：Floyd算法</h2><p> 此算法由Robert W. Floyd（罗伯特·弗洛伊德）于1962年发表在“Communications of the ACM”上。同年Stephen Warshall（史蒂芬·沃舍尔）也独立发表了这个算法。Robert W．Floyd这个牛人是朵奇葩，他原本在芝加哥大学读的文学，但是因为当时美国经济不太景气，找工作比较困难，无奈之下到西屋电气公司当了一名计算机操作员，在IBM650机房值夜班，并由此开始了他的计算机生涯。此外他还和J.W.J. Williams（威廉姆斯）于1964年共同发明了著名的堆排序算法HEAPSORT。堆排序算法我们将在后面学习。Robert W．Floyd在1978年获得了图灵奖。</p>
<p>Dijkstra 算法是求源点到其它各个顶点的最短路径，如果求解任意两个顶点的最短路径， 则需要以每个顶点为源点， 重复调用 n 次 Dijkstra 算法。 完全没必要这么麻烦， 下面介绍的Floyd 算法可以求解任意两个顶点的最短路径今 Floyd 算法又称为插点法， 其算法核心是在顶点i到顶点j之间， 插入顶点k, 看是否能够缩短i和j之间距离（松弛操作） </p>
<h3 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>1)    数据结构。 设置地图的节权邻接矩阵为<code>G.Edge[][],</code>  即如果从顶点i到顶点j 有边，就让<code>G.Edge[i][j]=&lt;i, j&gt;</code>的权值，否则<code>G.Edge[i][j] =</code> $\infty$  (无穷大）；采用两个辅助数组：最短距离数组dist[i][j], 记录从 i到 j顶点的最短路径长度，前驱数组 $p[i][j]$  记录从洼肋顶点的最短路径上i顶点的前驱</p>
<p>2)     初始化。初始化<code>dist[i][j]=G.Edge[i][j]</code>,如果顶点i到顶点j有边相连，初始化$p[i][j]=i$,否则 $p[i][j]=-1$</p>
<p>3)    插点。其是就是在i,j之间插入顶点k, 者是否能够缩短i和j之间距离(松弛操作)。 如果<code>dist[i][j]&gt;dist[i][k]+dist[k][j]</code>, 则<code>dist[i][j]=dist[i][k]+dist[k][j]</code>, 记录顶点J的前驱 为:<code>p[i][j]=p[k][j]</code> </p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/16.png" style="zoom:120%;"></p>
<p>1) 数据结构</p>
<p>设置地图地带权邻接矩阵为 $G.E[][]$ 即如果从顶点i到顶点j有边，就让 $G.Edge[][] = <i,j>$的权值，当i=j的时候，$G.Edge[i][i] = 0 $ 否则$G.Edge[i][j] = \infty$</i,j></p>
<p>2) 初始化</p>
<p>初始化的最短距离数组 $dist[i][j]=G.Edge[i][j]$ 如果 顶点i到顶点j有边相连。初始化前驱数组$p[i][j] = i$ 否则   $p[i][j] = -1$ 初始化后的 $dist[][] 和p[][]$如图</p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/18.png" style="zoom: 67%;"></p>
<p>3) 插点</p>
<p>其实就是借点，大家一起借顶点0更新最短距离。如果$dist[i][j]$ &gt;$dist[i][0]+dist[0][j]$ ,则 $dist[i][j] = dist[i][0]+dist[0][j]$ </p>
<p>谁可以借顶点0？</p>
<p>看顶点0 的入边，2—0 ,也就是说2 可以借助0点，更新2到其他顶点的最短距离。（程序中未判断谁可以借0点，穷举所有顶点是否可以借0点）</p>
<p>$dist[2][1]:dist[2][1] = 5&gt;dist[2][0]+dist[0][1]= 4$ 则更新 $dist[2][1] = 4,p[2][1] = 0$</p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/19.png"></p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/20.png"></p>
<p>4）插点</p>
<p>大家一起借顶点1更新最短距离，谁可以借顶点1呢？</p>
<p>看顶点1 的入边，顶点0，2都可以借助1点，更新其到其他顶点的最短距离</p>
<p>更新的时候是根据现有的dist值来的，不是原始的两条边！</p>
<p>$dist[0][2]:dist[0][2]=\infty&gt;dist[0][1]+dist[1][2]= 10$则更新$dist[0][2]=10,p[0][2]=1$</p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/21.png"></p>
<p>同样的，$dist[0][3] : dist[0][3] = 4 &gt; dist[0][1]+dist[1][3] = 3$ 所以更新</p>
<p>$dist[2][3] = 7 &gt; dist[2][1]+[1][3] = 6$ ，所以更新</p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/22.png"></p>
<p>5）插点(k=2)</p>
<p>谁可以借顶点2更新最短距离呢？</p>
<ul>
<li><code>dist[1][0] = inf &gt; dist[1][2]+dist[2][0]=12</code> 所以更新</li>
<li><code>dist[3][0] = inf &gt; dist[3][2]+dist[2][0]= 9</code> 所以更新</li>
<li><code>dist[3][1] = inf &gt; dist[3][2]+dist[2][1](经过0点，是复杂路径)=10</code> 所以更新,注意这里的<code>p[i][j]</code> 要改成 <code>p[2][1]</code> </li>
</ul>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/23.png"></p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/24.png"></p>
<p>6）插点(k=3)<br><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/27.png"></p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/25.png"></p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/26.png"></p>
<h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><p>1）时间复杂度 三层for语句循环，时间复杂度为$O(n^3)$</p>
<p>2) 空间复杂度：采用两个辅助数组，最短距离数组和前驱数组,因此空间复杂度为$O(n^2)$</p>
<p>尽管Floyd算法的时间复杂度为$O(n^3)$ 但其代码简单，对中等输入规模来说，仍然相当有效。如果用Dijkstra算法求解各个顶点之间的最短路径，则需要以每个顶点为源点调用一次，一共调用n次，齐总时间复杂度也为$O(n^3) $。特别注意的是，Dijkstra算法无法处理带负权值边的图，Floyd算法可以处理带负权值边的图，但不允许图中包含带负权值边组成的回路。可以学习另一个解决负权值边的最短路径算法 Bellman-Ford 算法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVnum 100  <span class="comment">//顶点数最大值</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1e7</span>; <span class="comment">// 无穷大10000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">string</span> VexType;  <span class="comment">//顶点的数据类型，根据需要定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;  <span class="comment">//边上权值的数据类型，若不带权值的图，则为0或1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  VexType Vex[MaxVnum];</span><br><span class="line">  EdgeType Edge[MaxVnum][MaxVnum];</span><br><span class="line">  <span class="keyword">int</span> vexnum,edgenum; <span class="comment">//顶点数，边数</span></span><br><span class="line">&#125;AMGragh;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dist[MaxVnum][MaxVnum],p[MaxVnum][MaxVnum];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">locatevex</span><span class="params">(AMGragh G,VexType x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//查找顶点信息的下标</span></span><br><span class="line">       <span class="keyword">if</span>(x==G.Vex[i])</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//没找到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateAMGraph</span><span class="params">(AMGragh &amp;G)</span><span class="comment">//创建无向图的邻接矩阵</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,w;</span><br><span class="line">    VexType u,v;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入顶点数："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;G.vexnum;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入边数:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;G.edgenum;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入顶点信息:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//输入顶点信息，存入顶点信息数组</span></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;G.Vex[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//初始化邻接矩阵所有值为0，若是网，则初始化为无穷大</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;G.vexnum;j++)</span><br><span class="line">        <span class="keyword">if</span>(i!=j)</span><br><span class="line">            G.Edge[i][j]=INF;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            G.Edge[i][j]=<span class="number">0</span>; <span class="comment">//注意i==j时，设置为0</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入每条边依附的两个顶点及权值："</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span>(G.edgenum--)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">       i=locatevex(G,u);<span class="comment">//查找顶点u的存储下标</span></span><br><span class="line">       j=locatevex(G,v);<span class="comment">//查找顶点v的存储下标</span></span><br><span class="line">       <span class="keyword">if</span>(i!=<span class="number">-1</span>&amp;&amp;j!=<span class="number">-1</span>)</span><br><span class="line">         G.Edge[i][j]=w; <span class="comment">//有向图邻接矩阵存储权值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">(AMGragh G)</span> <span class="comment">//用Floyd算法求有向网G中各对顶点i和j之间的最短路径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   	<span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)   <span class="comment">//各对结点之间初始已知路径及距离</span></span><br><span class="line">      <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)</span><br><span class="line">      &#123;</span><br><span class="line">          dist[i][j]=G.Edge[i][j];</span><br><span class="line">          <span class="keyword">if</span>(dist[i][j]&lt;INF &amp;&amp; i!=j)</span><br><span class="line">             p[i][j]=i;  	<span class="comment">//如果i和j之间有弧，则将j的前驱置为i</span></span><br><span class="line">          <span class="keyword">else</span> p[i][j]=<span class="number">-1</span>;  <span class="comment">//如果i和j之间无弧，则将j的前驱置为-1</span></span><br><span class="line">      &#125;</span><br><span class="line">	<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G.vexnum; k++)<span class="comment">//插点k</span></span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum; i++)<span class="comment">//对矩阵中的每个元素，查看是否能更新</span></span><br><span class="line">			<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum; j++)</span><br><span class="line">				<span class="keyword">if</span>(dist[i][k]+dist[k][j]&lt;dist[i][j])<span class="comment">//从i经k到j的一条路径更短</span></span><br><span class="line">                &#123;</span><br><span class="line">					dist[i][j]=dist[i][k]+dist[k][j]; <span class="comment">//更新dist[i][j]</span></span><br><span class="line">					p[i][j]=p[k][j];       <span class="comment">//更改j的前驱为k</span></span><br><span class="line">				&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(AMGragh G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//输出最短距离数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;dist[i][j]&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;i++)<span class="comment">//输出前驱数组</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.vexnum;j++)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;p[i][j]&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DisplayPath</span><span class="params">(AMGragh G,<span class="keyword">int</span> s,<span class="keyword">int</span> t )</span><span class="comment">//显示最短路径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p[s][t]!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">		DisplayPath(G,s,p[s][t]);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;G.Vex[p[s][t]]&lt;&lt;<span class="string">"--&gt;"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VexType start,destination;</span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    system(<span class="string">"color 0d"</span>);</span><br><span class="line">    AMGragh G;</span><br><span class="line">    CreateAMGraph(G);</span><br><span class="line">    Floyd(G);</span><br><span class="line">    <span class="built_in">print</span>(G);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"请依次输入路径的起点与终点的名称:"</span>;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;start&gt;&gt;destination;</span><br><span class="line">	u=locatevex(G,start);</span><br><span class="line">	v=locatevex(G,destination);</span><br><span class="line">	DisplayPath(G,u,v);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;G.Vex[v]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"最短路径的长度为："</span>&lt;&lt;dist[u][v]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小生成树-Prim算法"><a href="#最小生成树-Prim算法" class="headerlink" title="最小生成树:Prim算法"></a>最小生成树:Prim算法</h2><p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/28.png" style="zoom:;"></p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/29.png" style="zoom:;"></p>
<p><strong>注意，n-1条边，保证没有回路！</strong> 所以要一边找，一边避免回路</p>
<h3 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h3><p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/30.png" style="zoom:;"></p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/31.png" style="zoom:;"></p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>设 G =（V，E）是无向连通带权图，如图2-65 所示。</p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/33.png" style="zoom:;"></p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/34.png" style="zoom:;"></p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/35.png" style="zoom:;"></p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/36.png" style="zoom:;"></p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/37.png" style="zoom:;"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 2-6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">bool</span> s[N];</span><br><span class="line"><span class="keyword">int</span> closest[N];</span><br><span class="line"><span class="keyword">int</span> lowcost[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prim</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> u0, <span class="keyword">int</span> c[N][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//顶点个数n、开始顶点u0、带权邻接矩阵C[n][n]</span></span><br><span class="line">    <span class="comment">//如果s[i]=true,说明顶点i已加入最小生成树</span></span><br><span class="line">    <span class="comment">//的顶点集合U；否则顶点i属于集合V-U</span></span><br><span class="line">    <span class="comment">//将最后的相关的最小权值传递到数组lowcost</span></span><br><span class="line">    s[u0]=<span class="literal">true</span>; <span class="comment">//初始时，集合中U只有一个元素，即顶点u0</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=u0)</span><br><span class="line">        &#123;</span><br><span class="line">            lowcost[i]=c[u0][i];</span><br><span class="line">            closest[i]=u0;</span><br><span class="line">            s[i]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lowcost[i]=<span class="number">0</span>;<span class="comment">//如果是无穷大的话，对求和会很麻烦!</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n;i++) <span class="comment">//在集合中V-u中寻找距离集合U最近的顶点t</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp=INF;</span><br><span class="line">        <span class="keyword">int</span> t=u0;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((!s[j])&amp;&amp;(lowcost[j]&lt;temp))<span class="comment">//!s[j] 是V-U集合</span></span><br><span class="line">            &#123;</span><br><span class="line">                t=j;</span><br><span class="line">                temp=lowcost[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t==u0)</span><br><span class="line">            <span class="keyword">break</span>;       <span class="comment">//找不到t，跳出循环</span></span><br><span class="line">        </span><br><span class="line">        s[t]=<span class="literal">true</span>;     <span class="comment">//否则，讲t加入集合U</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=n;j++) <span class="comment">//更新lowcost和closest，看看他能不能借助t进行更新</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((!s[j])&amp;&amp;(c[t][j]&lt;lowcost[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                lowcost[j]=c[t][j];</span><br><span class="line">                closest[j]=t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n, c[N][N], m, u, v, w;</span><br><span class="line">        <span class="keyword">int</span> u0;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"输入结点数n和边数m:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">int</span> sumcost=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">                c[i][j]=INF;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">"输入结点数u,v和边值w:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">            c[u][v]=c[v][u]=w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">"输入任一结点u0:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u0 ;</span><br><span class="line">        <span class="comment">//计算最后的lowcos的总和，即为最后要求的最小的费用之和</span></span><br><span class="line">        Prim(n, u0, c);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">"数组lowcost的内容为"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; lowcost[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">           sumcost += lowcost[i];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"最小的花费是："</span>&lt;&lt;sumcost&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><p>（1）时间复杂度：在<code>Prim（int n，int u0，int c[N][N]）</code>算法中，一共有4 个for 语句，第①个for 语句的执行次数为n，第②个for 语句里面嵌套了两个for 语句③、④，它们的执行次数均为n，对算法的运行时间贡献最大。当外层循环标号为1 时，③、④语句在内层循环的控制下均执行n 次，外层循环②从1～n。因此，该语句的执行次数为n*n=n²，算法的时间复杂度为$O(n^2 )$。这里的n指的是边的数量，即 $O(|V|^2)$ , 时间复杂度不依赖 $|E|$ </p>
<p>（2）空间复杂度：算法所需要的辅助空间包含i、j、lowcost 和closest，则算法的空间复杂度是$O(n)$</p>
<p>算法可视化在这里</p>
<p><a href="https://www.cs.usfca.edu/~galles/visualization/Prim.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/Prim.html</a></p>
<h3 id="算法优化-1"><a href="#算法优化-1" class="headerlink" title="算法优化"></a>算法优化</h3><p>Prim算法可以从两个方面优化：</p>
<p>（1）for 语句③找lowcost 最小值时使用优先队列，每次出队一个最小值，时间复杂度为logn，执行n 次，总时间复杂度为O( nlogn)。</p>
<p>（2）for 语句④更新lowcost 和closest 数据时，如果图采用邻接表存储，每次只检查t的邻接边，不用从1～n 检查，检查更新的次数为E（边数），每次更新数据入队，入队的时间复杂度为logn，这样更新的时间复杂度为O( Elogn)。</p>
<h2 id="最小生成树-Kruskal算法"><a href="#最小生成树-Kruskal算法" class="headerlink" title="最小生成树:Kruskal算法"></a>最小生成树:Kruskal算法</h2><h3 id="算法设计-1"><a href="#算法设计-1" class="headerlink" title="算法设计"></a>算法设计</h3><p> <img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/39.png" style="zoom:;"></p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/40.png" style="zoom:;"></p>
<h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p>每次选最短边，不要有回路</p>
<p>我们使用边集数组存储这张图，便于排序</p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/41.png" style="zoom:;"></p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/42.png" style="zoom:;"></p>
<p><img src="/2020/06/21/%E5%9B%BE%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/43.png" style="zoom:;"></p>
<h3 id="代码一览-1"><a href="#代码一览-1" class="headerlink" title="代码一览"></a>代码一览</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> nodeset[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="comment">//边集数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">&#125;e[N*N];</span><br><span class="line"><span class="comment">//对边进行排序，定义优先级，按边值进行升序排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(Edge x, Edge y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.w &lt; y.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        nodeset[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并集合</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = nodeset[a];<span class="comment">//先读取 a的集合号，赋值给p</span></span><br><span class="line">    <span class="keyword">int</span> q = nodeset[b];<span class="comment">//再读取 b的集合号，赋值给q</span></span><br><span class="line">    <span class="keyword">if</span>(p==q) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果等于，那么他们就是一个集合的，坚决不能合并，否则成为环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//检查所有结点，把集合号是q的改为p，需要O(n)的事件复杂度</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(nodeset[i]==q)</span><br><span class="line">        nodeset[i] = p;<span class="comment">//a的集合号赋值给b集合号</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;				<span class="comment">//ans 为权值之和，初始化为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="keyword">if</span>(Merge(e[i].u, e[i].v))</span><br><span class="line">         <span class="comment">//判断能不能合并成功，是则更新ans，并把边数量-1</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans += e[i].w;</span><br><span class="line">            n--;</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">"输入结点数n和边数m:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        Init(n);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">"输入结点数u,v和边值w:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; e[i].u&gt;&gt; e[i].v &gt;&gt;e[i].w;</span><br><span class="line">        sort(e, e+m, comp);</span><br><span class="line">        <span class="keyword">int</span> ans = Kruskal(n);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"最小的花费是："</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h3><p>（1）时间复杂度：算法中，需要对边进行排序，若使用快速排序，执行次数为$e\log e$，算法的时间复杂度为 $O(e\log e)$ ，如果使用对来存放边的集合，那么每次选择权值最小的边只需要$O(\log|E|)$ 的实践，而合并集合需要n−1 次合并，每次为$O(n)$，合并集合的时间复杂度为$O(n^2)$。</p>
<p>（2）空间复杂度：算法所需要的辅助空间包含集合号数组 <code>nodeset[n]</code>，则算法的空间复杂度是 $O(n)$ 。</p>
<h3 id="算法优化-2"><a href="#算法优化-2" class="headerlink" title="算法优化"></a>算法优化</h3><p>该算法合并集合的时间复杂度为 <code>O(n^2)</code>，我们可以用并查集的思想优化，使合并集合的时间复杂度降为$O(e\log e)$，优化后的程序如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 2-7-1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> father[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">&#125;e[N*N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(Edge x, Edge y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.w &lt; y.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        father[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//找祖宗</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x != father[x]) <span class="comment">//如果x不等于父亲，那么就去找父亲的父亲</span></span><br><span class="line">        father[x] = Find(father[x]);</span><br><span class="line">    <span class="keyword">return</span> father[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = Find(a);</span><br><span class="line">    <span class="keyword">int</span> q = Find(b);</span><br><span class="line">    <span class="keyword">if</span>(p==q) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(p &gt; q)</span><br><span class="line">        father[p] = q;<span class="comment">//小的赋值给大的集合号</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        father[q] = p;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="keyword">if</span>(Merge(e[i].u, e[i].v))</span><br><span class="line">        &#123;</span><br><span class="line">            ans += e[i].w;</span><br><span class="line">            n--;</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">"输入结点数n和边数m:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        Init(n);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt;<span class="string">"输入结点数u,v和边值w:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;e[i].u&gt;&gt;e[i].v&gt;&gt;e[i].w;</span><br><span class="line">        sort(e, e+m, comp);</span><br><span class="line">        <span class="keyword">int</span> ans = Kruskal(n);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"最小的花费是："</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="两种算法的比较"><a href="#两种算法的比较" class="headerlink" title="两种算法的比较"></a>两种算法的比较</h2><p>（1）从算法的思想可以看出，如果图G 中的边数较小时，可以采用Kruskal 算法，因为Kruskal 算法每次查找最短的边；边数较多可以用Prim 算法，因为它是每次加一个结点。可见，<strong>Kruskal 算法适用于稀疏图</strong>($e\log(e)$如果e及其大，会比 $n^2 $ 还大)，而<strong>Prim 算法适用于稠密图</strong>。</p>
<p>（2）<strong>从时间上讲</strong>，Prim 算法的时间复杂度为 $O(V^2)$，Kruskal 算法的时间复杂度为$O(e\log e)$ 。</p>
<p>（3）<strong>从空间上讲</strong>，显然在Prim 算法中，只需要<strong>很小的空间</strong>就可以完成算法，因为每一次都是从V−U 集合出发进行扫描的，只扫描与当前结点集到U 集合的最小边。但在Kruskal算法中，需要对所有的边进行排序，对于大型图而言，Kruskal 算法需要占用比Prim 算法大得多的空间。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/" class="post-title-link" itemprop="url">离散数学之图1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-19 12:02:35" itemprop="dateCreated datePublished" datetime="2020-06-19T12:02:35+08:00">2020-06-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-06 09:42:00" itemprop="dateModified" datetime="2020-09-06T09:42:00+08:00">2020-09-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE/" itemprop="url" rel="index"><span itemprop="name">图</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="离散数学之图1"><a href="#离散数学之图1" class="headerlink" title="离散数学之图1"></a>离散数学之图1</h1><p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/1.png" style="zoom:80%;"></p>
<h2 id="Graphs"><a href="#Graphs" class="headerlink" title="Graphs"></a>Graphs</h2><p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/2.png" style="zoom:80%;"></p>
<p>边集E就是顶点V和V的笛卡尔集中的子集。笛卡尔集是每连个点之间都有连线（包括自环）。</p>
<p>对一些图我们需要有基本的概念</p>
<ul>
<li>V和G可能是无限的，理论上存在，现实中可能是不会存在的</li>
<li>在一幅图中，每一条边连接的是不同的两个顶点，没有两条边连接的是同一对顶点。那么这个就是个<strong>简单图</strong><ul>
<li>排除自环 和 两个顶点有相同方向的两条边</li>
<li><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/3.png" style="zoom:40%;"></li>
</ul>
</li>
<li>否则，我们允许上面的情况，那么这就是个多图<ul>
<li><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/4.png" style="zoom:40%;"></li>
<li>比如说我们礼拜二和礼拜五都会去健身，这样可以画两条边，从家里到健身房。但是简单图之是去过健身房这个关系就建立了。</li>
</ul>
</li>
<li>如果有一条自己到自己的边，那么就叫做环</li>
</ul>
<h3 id="Directed-graphs"><a href="#Directed-graphs" class="headerlink" title="Directed graphs"></a>Directed graphs</h3><p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/5.png" style="zoom:80%;"></p>
<p>比如说我关注了一个大V但是它没有关注我，所以这就是单向的。如果大V关注了我，那么就有两条不同方向的边。</p>
<h3 id="graph-terminology"><a href="#graph-terminology" class="headerlink" title="graph terminology"></a>graph terminology</h3><p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/1.jpg" style="zoom:80%;"></p>
<ul>
<li>如果是无向图，$(u,v)\in E =&gt; (v,u)\in E$ 所以无向图可以看成双向图</li>
</ul>
<h2 id="Graph-Models"><a href="#Graph-Models" class="headerlink" title="Graph Models"></a>Graph Models</h2><h3 id="model1-Social-networks"><a href="#model1-Social-networks" class="headerlink" title="model1 Social networks"></a>model1 Social networks</h3><p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/6.png" style="zoom:80%;"></p>
<h3 id="model2-Communication-networks"><a href="#model2-Communication-networks" class="headerlink" title="model2 Communication networks"></a>model2 Communication networks</h3><p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/7.png" style="zoom:80%;"></p>
<p>交互的网络，比如说我和谁联系。或者我转发了某人的微博。是以传播信息为目的的</p>
<h3 id="model3-Information-networks"><a href="#model3-Information-networks" class="headerlink" title="model3 Information networks"></a>model3 Information networks</h3><p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/8.png" style="zoom:80%;"></p>
<p>信息网络。比如专利、论文之间的引用关系。专利、观点、论文之间也有引用的关系。</p>
<p>又比如超链接在网页中的嵌入。</p>
<h3 id="model4-Software-design-applications"><a href="#model4-Software-design-applications" class="headerlink" title="model4 Software design applications"></a>model4 Software design applications</h3><p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/9.png" style="zoom:80%;"></p>
<p>软件设计里的应用。我们可以描述不同模块之间的 关系是什么。比如我执行软件在后台的逻辑。这里面的逻辑调用了什么模块。基于这样的网络可以分析软件的内核是什么。</p>
<p>在执行的时候语句也构成了一个网络</p>
<h3 id="model5-Transportation-networks"><a href="#model5-Transportation-networks" class="headerlink" title="model5 Transportation networks"></a>model5 Transportation networks</h3><p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/10.png" style="zoom:80%;"></p>
<p>比如说交通网络。基于这样一个图我们可以分析世界航运中心在哪里。</p>
<p>或者我们可以根据这个路网制作导航。</p>
<h3 id="model6-Biological-networks"><a href="#model6-Biological-networks" class="headerlink" title="model6 Biological networks"></a>model6 Biological networks</h3><p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/11.png" style="zoom:80%;"></p>
<p>这是一个生物信息的网络。</p>
<h2 id="Graph-Terminology"><a href="#Graph-Terminology" class="headerlink" title="Graph Terminology"></a>Graph Terminology</h2><h3 id="Basic-concepts-for-undirected-graphs"><a href="#Basic-concepts-for-undirected-graphs" class="headerlink" title="Basic concepts for undirected graphs"></a>Basic concepts for undirected graphs</h3><h4 id="Neighbors"><a href="#Neighbors" class="headerlink" title="Neighbors"></a>Neighbors</h4><p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/14.png" style="zoom:90%;"></p>
<p>在无向图里，uv相连接，u是v的邻居，v是u的邻居</p>
<h4 id="Neighborhood"><a href="#Neighborhood" class="headerlink" title="Neighborhood"></a>Neighborhood</h4><p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/12.png" style="zoom:90%;"></p>
<p>我们可以把所有的邻居都找出来。这就是一个v的社区</p>
<h4 id="Degree"><a href="#Degree" class="headerlink" title="Degree"></a>Degree</h4><p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/13.png" style="zoom:90%;"></p>
<p>一个顶点的度就是连接到这个顶点的边的数量</p>
<p>对于简单图来说。$deg(v) = |N(v)|$</p>
<p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/15.png" style="zoom:90%;"></p>
<ul>
<li>这里有一个无向图。a这个顶点的neibor有 b、d、e 连接的边有4条。所以deg(a) = 4<ul>
<li>这不是一个简单图，否则deg(a) = N(v)</li>
</ul>
</li>
<li>对于 b，neighbor a,b,c,d,e 因为有自环，且在无向图里，所以度要加2；在有向图中加1即可</li>
</ul>
<h4 id="握手定理"><a href="#握手定理" class="headerlink" title="握手定理"></a>握手定理</h4><p>所有结点的度之和为什么是两倍的边的数量？</p>
<p>因为我同一条边会在一对结点中计算两次</p>
<p>据此可以推论 ：在无向图（包括简单图）中，degree是奇数的顶点的个数一定是偶数个。但这只是一个必要条件，度为奇数的顶点数量为偶数个并不能说明一定可以画处一个简单图，甚至连图都可能画不出。比如度为 5 5 4 3 2 1 的6个顶点，就画不出一个图</p>
<p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/16.png" style="zoom:90%;"></p>
<h3 id="Basic-concepts-for-directed-graphs"><a href="#Basic-concepts-for-directed-graphs" class="headerlink" title="Basic concepts for directed graphs"></a>Basic concepts for directed graphs</h3><p>有向图中具有方向 $(u,v)\in E$ 那么 有一条以u为起点，v为终点，u指向v的边</p>
<p>但是这里度要分为出度和入度</p>
<h4 id="Adjacent"><a href="#Adjacent" class="headerlink" title="Adjacent"></a>Adjacent</h4><p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/17.png" style="zoom:90%;"></p>
<h4 id="Degree-1"><a href="#Degree-1" class="headerlink" title="Degree"></a>Degree</h4><p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/18.png" style="zoom:90%;"></p>
<h4 id="Degrees-on-directed-graphs"><a href="#Degrees-on-directed-graphs" class="headerlink" title="Degrees on directed graphs"></a>Degrees on directed graphs</h4><p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/19.png" style="zoom:90%;"></p>
<p>在有向图中，出度等于入度等于边的数量</p>
<p>比如：</p>
<ul>
<li>如果有自环，那么在这个结点中的入度+1，出度+1</li>
<li>孤立点不指向任何点，也没有进来的边，出度入度都为0</li>
</ul>
<p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/20.png" style="zoom:90%;"></p>
<h2 id="Special-Types-of-Graphs"><a href="#Special-Types-of-Graphs" class="headerlink" title="Special Types of Graphs"></a>Special Types of Graphs</h2><h3 id="Complete-graphs"><a href="#Complete-graphs" class="headerlink" title="Complete graphs"></a>Complete graphs</h3><p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/21.png" style="zoom:90%;"></p>
<p>完全图就是每两个顶点之间都有一条边，但没有多边，没有自环。是一个简单图</p>
<p>只要少一条边，就不再是一个完全图了</p>
<h3 id="Cycles-and-wheels"><a href="#Cycles-and-wheels" class="headerlink" title="Cycles and wheels"></a>Cycles and wheels</h3><p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/22.png" style="zoom:90%;"></p>
<p>轮图，和轮子一样。外面每一个顶点都是3，里面的顶点的度取决于边数</p>
<h3 id="n-Cubes"><a href="#n-Cubes" class="headerlink" title="n-Cubes"></a>n-Cubes</h3><p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/23.png" style="zoom:90%;"></p>
<h3 id="Bipartite-graphs"><a href="#Bipartite-graphs" class="headerlink" title="Bipartite graphs"></a>Bipartite graphs</h3><p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/24.png" style="zoom:90%;"></p>
<p>二部图或者说是二分图。他是一个简单图。但是定点可以分成两部分v1,v2</p>
<p>边一定是包含在 $V_1*V_2$的笛卡尔集里面。所以不会出现 $V_1-V_1$这种的边</p>
<p>比如我们去看电影，一边是观众一边是电影</p>
<p>还可以有三步图，四步图……</p>
<p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/25.png" style="zoom:90%;"></p>
<p>A simple graph is bipartite if and only if it is possible to assign one of two different colors to each vertex of the graph so that no two adjacent vertices are assigned the same color.</p>
<p>也就是说，因为相连的两个顶点必然不可能在同一个集合当中，所以我们可以给他们涂上不同的颜色。再来看看整张图中是否存在两个颜色相同的点相连的状况。如果有的话那这就不是一个二分图。</p>
<p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/36.png" style="zoom: 80%;"></p>
<h3 id="Complete-bipartite-graphs"><a href="#Complete-bipartite-graphs" class="headerlink" title="Complete bipartite graphs"></a>Complete bipartite graphs</h3><p>A complete bipartite graph $K_{m,n}$ is a graph that has its vertex set partitioned into two subsets of m and n vertices, respectively with <strong>an edge between two vertices</strong> if and only if one vertex is in the first subset and the other vertex is in the second subset.</p>
<p>也就是说</p>
<p>完全二分图是一种特殊的二分图，可以把图中的顶点分成两个集合，使得第一个集合中的<strong>所有顶点</strong>都与第二个集合中的所有顶点相连。</p>
<p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/2.jpg" style="zoom: 60%;"></p>
<h3 id="不同图的节点数和边数"><a href="#不同图的节点数和边数" class="headerlink" title="不同图的节点数和边数"></a>不同图的节点数和边数</h3><div class="table-container">
<table>
<thead>
<tr>
<th>图的类型</th>
<th>节点数</th>
<th>边数</th>
</tr>
</thead>
<tbody>
<tr>
<td>$K_n$</td>
<td>$n$</td>
<td>$\frac{(n-1)n}{2}$</td>
</tr>
<tr>
<td>$C_n$</td>
<td>$n$</td>
<td>$n$</td>
</tr>
<tr>
<td>$W_n$</td>
<td>$n+1$</td>
<td>$2n$</td>
</tr>
<tr>
<td>$K_{m,n}$</td>
<td>$m+n$</td>
<td>$m\cdot n$</td>
</tr>
<tr>
<td>$Q_n$</td>
<td>$2^n$</td>
<td>$n\cdot2^{n-1}$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Matching-匹配"><a href="#Matching-匹配" class="headerlink" title="Matching 匹配"></a>Matching 匹配</h3><p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/26.png" style="zoom: 80%;"></p>
<p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/27.png" style="zoom: 80%;"></p>
<p>在图论中，一个「匹配」（matching）是一个边的集合，其中任意两条边都没有公共顶点。例如，图 3、图 4 中红色的边就是图 2 的匹配。</p>
<p>最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。图 4 是一个最大匹配，它包含 4 条匹配边。</p>
<p>完全匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完全匹配。图 4 是一个完全匹配。显然，完全匹配一定是最大匹配（完美匹配的任何一个点都已经匹配，添加一条新的匹配边一定会与已有的匹配边冲突）。但并非每个图都存在完全匹配。<br> (选自博客<a href="https://blog.csdn.net/qq_36345036/article/details/76977294）" target="_blank" rel="noopener">https://blog.csdn.net/qq_36345036/article/details/76977294）</a></p>
<h3 id="Hall’S-Marriage-theorem"><a href="#Hall’S-Marriage-theorem" class="headerlink" title="Hall’S Marriage theorem"></a>Hall’S Marriage theorem</h3><h4 id="Theorem"><a href="#Theorem" class="headerlink" title="Theorem"></a>Theorem</h4><p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/37.png" style="zoom: 80%;"></p>
<blockquote>
<p>对于一个二分图G={X+Y,E} ，它满足：<br>∀W⊆X,$|W|≤|N_G(W)|$ ⟺ X中的每个结点都有匹配.<br>其中$N_G(W)$为图G中所有与W相连的结点的集合。</p>
</blockquote>
<p>由这个定理，我们能得到一个推论：</p>
<blockquote>
<p>二分图G的最大匹配M等于$|X|−max(|W|−|N_G(W)|)$</p>
</blockquote>
<p>二分图有完全匹配当且仅当 $|N(A)|\geq|A|$ ，其中$A$代表了$V_1$当中的所有子集（包括空集）。 |N(A)| 代表了集合A中的所有元素的邻居的个数。|A| 代表了 子集中元素的个数，$N(\emptyset)$ = $\emptyset$, $|N(\emptyset)| = |\emptyset| = 0$</p>
<p>比如这张图来说，有没有一个完全匹配呢？</p>
<p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/38.png" style="zoom: 80%;"></p>
<p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/39.png" style="zoom: 80%;"></p>
<p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/40.png" style="zoom: 80%;"></p>
<p>由Hall’s 定律，这张图是有完全匹配的</p>
<h4 id="proof"><a href="#proof" class="headerlink" title="proof"></a>proof</h4><p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/28.png" style="zoom: 80%;"> </p>
<p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/29.png" style="zoom: 80%;"></p>
<p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/30.png" style="zoom: 80%;"></p>
<h2 id="New-Graphs-from-Old"><a href="#New-Graphs-from-Old" class="headerlink" title="New Graphs from Old"></a>New Graphs from Old</h2><h3 id="Subgraph-子图"><a href="#Subgraph-子图" class="headerlink" title="Subgraph 子图"></a>Subgraph 子图</h3><p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/31.png" style="zoom: 80%;"></p>
<h3 id="Remove-or-adding-edges-of-a-graph"><a href="#Remove-or-adding-edges-of-a-graph" class="headerlink" title="Remove or adding edges of a graph"></a>Remove or adding edges of a graph</h3><p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/32.png" style="zoom: 80%;"></p>
<h3 id="Edge-contractions-and-vertices-remove"><a href="#Edge-contractions-and-vertices-remove" class="headerlink" title="Edge contractions and vertices remove"></a>Edge contractions and vertices remove</h3><p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/33.png" style="zoom: 80%;"></p>
<h3 id="Graph-union"><a href="#Graph-union" class="headerlink" title="Graph union"></a>Graph union</h3><p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/34.png" style="zoom: 80%;"></p>
<h3 id="overline-G-和G-的区别"><a href="#overline-G-和G-的区别" class="headerlink" title="$\overline G$ 和G 的区别"></a>$\overline G$ 和G 的区别</h3><p>$\overline G$ of a simple graph G has the same vertices as G, Two vertices are adjacent in $\overline G$ if and only if they are not adjacent in G. </p>
<p>也就是说在$\overline G$ 当中，G中不连在一起的点连在一起，连在一起的点现在不连在一起。</p>
<p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/41.png" style="zoom: 80%;"></p>
<p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/42.png" style="zoom: 80%;"></p>
<p><img src="/2020/06/19/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E4%B9%8B%E5%9B%BE1/43.png" style="zoom: 80%;"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/" class="post-title-link" itemprop="url">高阶微分方程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-18 22:28:56" itemprop="dateCreated datePublished" datetime="2020-06-18T22:28:56+08:00">2020-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-30 08:07:26" itemprop="dateModified" datetime="2020-10-30T08:07:26+08:00">2020-10-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="高阶微分方程"><a href="#高阶微分方程" class="headerlink" title="高阶微分方程"></a>高阶微分方程</h1><h2 id="可降阶的微分方程"><a href="#可降阶的微分方程" class="headerlink" title="可降阶的微分方程"></a>可降阶的微分方程</h2><p>二阶以及二阶以上的微分方程称之为高阶微分方程</p>
<p>一般来说，微分方程的阶数越高，求解的难度也就越大。求高阶方程的一个常用方法就是降低阶数</p>
<p>对二阶方程 $y’’ = f(x,y,y’)$  </p>
<p>如果能用变量代换把它化成一阶方程，那么就可以用一阶微分方程的求解方法来解决了。</p>
<p>下面对二阶方程中的三种容易降阶的情形进行讨论。</p>
<h3 id="y-‘’-f-x-型-微分方程"><a href="#y-‘’-f-x-型-微分方程" class="headerlink" title="$y^{‘’} = f(x) $型 微分方程"></a>$y^{‘’} = f(x) $型 微分方程</h3><p>这类方程的特点就是左边为未知函数的二阶导数，右边只是自变量x的函数，只要对方程接连积分两次，就能得到原方程的含有两个任意常数的通解。</p>
<p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/2.png" style="zoom:80%;"></p>
<p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/3.png" style="zoom:80%;"></p>
<h3 id="y-‘’-f-x-y’-型微分方程"><a href="#y-‘’-f-x-y’-型微分方程" class="headerlink" title="$y^{‘’} =f(x,y’)$ 型微分方程"></a>$y^{‘’} =f(x,y’)$ 型微分方程</h3><p>特点是 不含未知函数，因此 设 $y’ = z(x)$ 则 $y’’ = \frac{dz}{dx}=z’$ 原方程化为一阶方程(可分离变量/齐次/一阶线性齐次/一阶线性非齐次/伯努利方程/全微分方程) ： $z’ = f(x,z)$ </p>
<p>设其通解为 $z = \phi(x,C_1)$  则得到一阶方程 $y’ = \phi(x,C_1)$ 再一次积分，得到原方程的通解。</p>
<p>$y=\int\phi(x,C_1)dx+C_2$ </p>
<p>例题： $xy’’ = y’-xy’^2$  这是比较复杂的一道微分方程</p>
<p>1.首先我们令 $z=y’$, 那么 $z’ = y’’$ 于是 $xz’ = z-xz^2$ 变型得到 $\frac{dz}{dx} -\frac{z}{x}= -z^2 $  (伯努利方程)</p>
<p>2.$P_1(x) = -\frac{1}{x},Q_1(x) = -1$   </p>
<p>3.然后用解伯努利的方程的方法。令 $w = z^{1-2} = z^{-1}$ 则 $\frac{dw}{dx} =-1\cdot z^{-2}\frac{dz}{dx}$ ,带入伯努利方程得到 $\frac{dw}{dx} + (1-n)P(x)w=(1-n)Q(x)$ 也就是 $\frac{dw}{dx}+(-1)(-\frac{1}{x})w = (1-2)\cdot -1$    化简得到 $\frac{dw}{dx} +\frac{w}{x} = 1$ （一阶线性非齐次方程),$P_2(x) = \frac{1}{x},Q_2(x)= 1$</p>
<p>4.然后利用解一阶线性非齐次方程的方法。其对应的一阶线性齐次方程为 $\frac{dw}{dx} + \frac{w}{x} = 0$ ,解得 $w=\frac{C}{x}$ .令一阶线性非齐次方程的通解为$w=\frac{u(x)}{x}$, $\frac{du}{dx} = w+x\frac{dw}{x}$ . 代入非齐次方程式得到$\frac{du}{dx}\cdot\frac{1}{x} = Q(x)  , \frac{du}{dx} = x, u = \frac{1}{2}x^2+C$   . 于是 通解 $w = \frac{u(x)}{x} = \frac{1}{2}x+\frac{C}{x}$</p>
<p>5.因此 $z=w^{-1}=\frac{2x}{x^2+2C}=y’, y=\int\frac{2x}{x^2+2C} dx = ln|x^2+C_1|+C_2$   </p>
<h3 id="y-‘’-f-y-y’-型微分方程"><a href="#y-‘’-f-y-y’-型微分方程" class="headerlink" title="$y^{‘’} =f(y,y’)$ 型微分方程"></a>$y^{‘’} =f(y,y’)$ 型微分方程</h3><p>这类方程的特点就是不含有自变量</p>
<p>令 $y’ = z(y)$, 则 $y’’ = \frac{dz}{dx}=\frac{dz}{dy}\cdot\frac{dy}{dx} = z\frac{dz}{dy}$ </p>
<p>故方程化为 $z\frac{dz}{dy} = f(y,z)$ </p>
<p>设其通解为 $z=\phi(y,C_1)$，即得 $y’ = \frac{dx}{dy}=\phi(y,C_1)$ 分离变量后积分，得到原方程的通解.</p>
<p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/8.png" style="zoom:80%;"></p>
<p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/0.png" style="zoom:100%;"></p>
<h2 id="线性微分方程的性质"><a href="#线性微分方程的性质" class="headerlink" title="线性微分方程的性质"></a>线性微分方程的性质</h2><p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/9.png" style="zoom:80%;">\</p>
<h3 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h3><p>设 $y_1(x),y_2(x)$ 是二阶线性齐次方程 $y’’+p_1(x)y’ +p_2(x)y=0$  的两个特解，则 $y = C_1y_1(x)+C_2y_2(x) $也应该是方程的解，其中$C_1,C_2$ 是任意常数。</p>
<p>注意：$y=C_1y_1(x)+C_2y_2(x)$ 虽有两个任意常数，他们可能不是独立的，所以不一定是所给二阶方程的通解。</p>
<p>例如，$y_1(x)$ 是某二阶齐次方程的解，则 $y_2(x)=2y_1(x)$ 也是齐次方程的解。</p>
<p>但是 $C_1y_1(x)+C_2y_2(x) = (C_1+2C_2)y_1(x)$并不是通解</p>
<h3 id="函数线性相关和线性无关"><a href="#函数线性相关和线性无关" class="headerlink" title="函数线性相关和线性无关"></a>函数线性相关和线性无关</h3><p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/12.png" style="zoom:80%;"></p>
<p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/13.png" style="zoom:80%;"></p>
<h3 id="定理2"><a href="#定理2" class="headerlink" title="定理2"></a>定理2</h3><p>设$y_1(x),y_2(x)$ 是二阶线性齐次方程的两个<strong>线性无关的特解</strong>，则 $y=C_1y_1(x)+C_2y_2(x)$  是方程的通解，其中$C_1,C_2$ 是任意常数</p>
<h3 id="定理3"><a href="#定理3" class="headerlink" title="定理3"></a>定理3</h3><p>设 $y^{\%}(x)$ 是二阶非齐次方程 $y’’+p_1(x)y’+p_2(x)y =q(x)$  的一个特解，$Y(x)$ 是相应的齐次方程的通解，则 $y = Y(x)+y^{\%}(x)$ 是非齐次方程(1) 的通解。</p>
<p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/16.png" style="zoom:80%;"></p>
<h3 id="定理4"><a href="#定理4" class="headerlink" title="定理4"></a>定理4</h3><p>设 $y_1(x),y_2(x)$ 分别是二阶线性非齐次方程 $y’’+p_1(x)y’+p_2(x) = q_1(x)$ 和 $y’’+p_1(x)y’+p_2(x) = q_2(x)$ 的解，则 $y(x) = ay_1(x) +by_2(x)$ 的解，则 $y(x)= ay_1(x)+by_2(x)$ 是非齐次方程  $y’’+p_1(x)y’+p_2(x)y = aq_1(x)+bq_2(x)$  的解。(非齐次方程解的叠加原理)</p>
<p>以上结论可以推广到n阶线性微分方程当中去</p>
<p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/18.png" style="zoom:80%;"></p>
<p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/19.png" style="zoom:80%;"></p>
<p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/20.png" style="zoom:80%;"></p>
<h2 id="二阶常系数线性齐次方程的解"><a href="#二阶常系数线性齐次方程的解" class="headerlink" title="二阶常系数线性齐次方程的解"></a>二阶常系数线性齐次方程的解</h2><p>二阶常系数齐次线性微分方程  $y’’ +py’+qy=0$ (p,q为常数) (1)</p>
<p>因为r为常数时，函数 $e^{rx}$ 和它的导数只差一个常数因子，所以令 (1) 的解为 $y=e^{rx}$ (r为待定常数)， 带入(1) 得 $(r^2+pr+q)e^{rx}=0\Rightarrow r^2+pr+q=0$ （2）。我们称(2) 为微分方程 (1) 的特征方程，其根称为特征根</p>
<p>1 当 $p^2-4q&gt;0$ 时，（2）有两个相异实根 $r_1,r_2$ ，则微分方程有两个线性无关的特解： $y_1=e^{r_1x},y_2=e^{r_2x}$ 因此<strong>方程的通解</strong>为 $y=C_1e^{r_1x}+C_2e^{r_2x}$ </p>
<p>2 当 $p^2-4q=0$ 时，特征方程有两个相等实根 $r_1=r_2=\frac{-p}{2}$  则微分方程有一个特解 $y_1=e^{r_1x}$ ，<strong>原方程的通解为 </strong>$y=(C_1+C_2x)e^{r_1x}$ </p>
<p>3 当 $p^2-4q&lt;0$ 时，特征方程有一对共轭复根 $r_1=\alpha+i\beta,r_2=\alpha-i\beta$ 这时原方程有两个复数解：<br>$y_1=e^{(\alpha+i\beta)x}=e^{\alpha x}(cos\beta x+isin\beta x)$</p>
<p>$y_2=e^{(\alpha-i\beta)x}=e^{\alpha x}(cos\beta x-isin\beta x)$</p>
<p><strong>原方程的通解</strong>为 $y=e^{\alpha x}(C_1cos\beta x+C_2sin\beta x)$ </p>
<p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/24.png" style="zoom:80%;"></p>
<p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/25.png" style="zoom:80%;"></p>
<p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/26.png" style="zoom:80%;"></p>
<p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/30.png" style="zoom:80%;"></p>
<p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/31.png" style="zoom:80%;"></p>
<p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/32.png" style="zoom:80%;"> </p>
<h2 id="二阶常系数线性非齐次方程的解"><a href="#二阶常系数线性非齐次方程的解" class="headerlink" title="二阶常系数线性非齐次方程的解"></a>二阶常系数线性非齐次方程的解</h2><p>二阶常系数线性非齐次微分方程 $y’’+py’+qy = f(x)$ </p>
<p>根据解的结构定理，其通解为 $y = Y(齐次方程通解)+y^*(非齐次方程特解)$ </p>
<p>求特解的方法： 待定系数法</p>
<p>根据 f(x)的特殊形式，给出特解 y* 的待定形式。代入原方程比较两端表达式以确定待定系数</p>
<h3 id="f-x-e-lambda-x-P-m-x-型"><a href="#f-x-e-lambda-x-P-m-x-型" class="headerlink" title="$f(x) = e^{\lambda x}P_m(x)$ 型"></a>$f(x) = e^{\lambda x}P_m(x)$ 型</h3><p>$\lambda$ 为实数，$P_m(x)$ 为 m 次多项式。</p>
<p>设特解为 $y^* = e^{\lambda x}Q(x)$,其中 $Q(x)$ 为待定多项式</p>
<p>$y^{*}{‘} = e^{\lambda x}[\lambda Q(x)+Q’(x)]$</p>
<p>$y^{*}{‘’} = e^{\lambda x}[\lambda^2 Q(x)+2\lambda Q’(x)+Q’’(x)]$ </p>
<p>带入原方程得到：</p>
<p>$Q’’(x) +(2\lambda+p)Q’(x)+(\lambda^2+2\lambda Q’(x)+Q’’(x))Q(x) = P_m(x)$ </p>
<p>1) 若 $\lambda$ 不是特征方程的根,即 $\lambda^2+p\lambda+q\neq 0$ ,则取$Q(x)$ 为m次待定系数多项式  $Q_m(x)$ 从而得到特解的形式 $y^*=e^{\lambda x}Q_m(x)$ </p>
<p>2) 若$\lambda$ 是特征方程的单根，即 $\lambda^2+p\lambda+q=0, 2\lambda+p\neq0$, 则 $Q’(x)$ 为<strong>m次</strong>多项式，故特解为 $y^* = xQ_m(x)e^{\lambda x} $ </p>
<p>3) 若$\lambda$ 是特征方程的重根，即 $\lambda^2+p\lambda+q=0 ,2\lambda +p =0$ 则 $Q’’(x)$ 是<strong>m次</strong>多项式，故特解的形式为 $y^*=x^2Q_m(x)e^{\lambda x}$  </p>
<p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/38.png" style="zoom:80%;"></p>
<p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/39.png" style="zoom:80%;"></p>
<p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/40.png" style="zoom:80%;"></p>
<h3 id="f-x-e-lambda-x-P-l-x-coswx-overline-P-n-x-sinwx-型"><a href="#f-x-e-lambda-x-P-l-x-coswx-overline-P-n-x-sinwx-型" class="headerlink" title="$f(x) = e^{\lambda x}[P_l(x)coswx+\overline P_n(x)sinwx]$ 型"></a>$f(x) = e^{\lambda x}[P_l(x)coswx+\overline P_n(x)sinwx]$ 型</h3><p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/45.png" style="zoom:80%;"></p>
<p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/46.png" style="zoom:80%;"></p>
<p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/47.png" style="zoom:80%;"></p>
<p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/48.png" style="zoom:80%;"></p>
<p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/49.png" style="zoom:80%;"></p>
<h2 id="欧拉方程"><a href="#欧拉方程" class="headerlink" title="欧拉方程"></a>欧拉方程</h2><p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/50.png" style="zoom:80%;"></p>
<p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/51.png" style="zoom:80%;"></p>
<p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/52.png" style="zoom:80%;"></p>
<p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/53.png" style="zoom:80%;"></p>
<p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/54.png" style="zoom:80%;"></p>
<p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/55.png" style="zoom:80%;"></p>
<p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/56.png" style="zoom:80%;"></p>
<p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/57.png" style="zoom:80%;"></p>
<p><img src="/2020/06/18/%E9%AB%98%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/58.png" style="zoom:80%;"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/" class="post-title-link" itemprop="url">一阶微分方程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-18 22:21:44" itemprop="dateCreated datePublished" datetime="2020-06-18T22:21:44+08:00">2020-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-09 22:35:30" itemprop="dateModified" datetime="2020-09-09T22:35:30+08:00">2020-09-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一阶微分方程"><a href="#一阶微分方程" class="headerlink" title="一阶微分方程"></a>一阶微分方程</h1><h2 id="可分离变量微分方程"><a href="#可分离变量微分方程" class="headerlink" title="可分离变量微分方程"></a>可分离变量微分方程</h2><p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/1.png" style="zoom:80%;"></p>
<p>右边可以分成一个关于x的函数和一个关于y的函数相乘，比如$ x^2 y$ ；$x^2+y^2 $这样的就不能算这类型的函数</p>
<p>对第一个式子进行变形我们得到了第二个式子，这也是可分离的</p>
<p>最后把y放在一起，x放在一起， 求解</p>
<h3 id="分离变量方程的解法"><a href="#分离变量方程的解法" class="headerlink" title="分离变量方程的解法"></a>分离变量方程的解法</h3><p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/2.png" style="zoom: 67%;"></p>
<h4 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h4><p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/3.png" style="zoom: 67%;"></p>
<h4 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h4><p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/4.png" style="zoom: 67%;"></p>
<h4 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h4><p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/5.png" style="zoom: 67%;"></p>
<h4 id="例四"><a href="#例四" class="headerlink" title="例四"></a>例四</h4><p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/6.png" style="zoom: 67%;"></p>
<h4 id="例五"><a href="#例五" class="headerlink" title="例五"></a>例五</h4><p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/9.png" style="zoom: 67%;"></p>
<p>C的范围一定要给出，C为任意常数</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>解可分离变量的微分方程的步骤：</p>
<ol>
<li>根据题目给出的方程化为 $\frac{dy}{dx} = f(x)g(y)$ 类型的式子</li>
<li>再变形，得到 $\frac{dy}{g(y)} = dxf(x)$ 类型的式子。x归一边，y 归一边</li>
<li>两边同时求积分，$\int \frac{dy}{g(y)} = \int f(x)dx +C$ </li>
<li>最后得到答案，记住，不要忘记加上C！</li>
</ol>
<p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/6.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/8.png" style="zoom: 67%;"></p>
<h2 id="齐次方程"><a href="#齐次方程" class="headerlink" title="齐次方程"></a>齐次方程</h2><p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/11.png" style="zoom: 75%;"></p>
<p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/12.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/13.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/14.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/15.png" style="zoom: 67%;"></p>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ol>
<li>分类讨论。如果题目中带有根号，在同除x或y的时候需要判断其是否大于0，并更改对应的符号</li>
</ol>
<p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/43.png" style="zoom:120%;"></p>
<ol>
<li>要注意常数和C的不同</li>
</ol>
<p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/44.png" style="zoom:120%;"></p>
<h2 id="可化为齐次方程的方程"><a href="#可化为齐次方程的方程" class="headerlink" title="可化为齐次方程的方程"></a>可化为齐次方程的方程</h2><p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/16.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/17.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/18.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/19.png" style="zoom: 67%;"></p>
<h2 id="一阶线性微分方程"><a href="#一阶线性微分方程" class="headerlink" title="一阶线性微分方程"></a>一阶线性微分方程</h2><p>一阶线性微分方程的标准形式：$\frac{dy}{dx} + P(x)y = Q(x)$</p>
<p>若 $Q(x)\equiv 0$ 称为齐次方程</p>
<p>若 $Q(x)\not \equiv 0$ 称为非齐次方程</p>
<h3 id="齐次方程："><a href="#齐次方程：" class="headerlink" title="齐次方程："></a>齐次方程：</h3><ol>
<li>解齐次方程 $\frac{dy}{dx} + P(x)y = 0$</li>
<li>分离变量 $\frac{dy}{y} = -P(x)dx$</li>
<li>两边积分 $ln|y| = -\int P(x)dx+ln|C|$</li>
<li>故通解为  $y = Ce^{-\int P(x)dx}$ </li>
</ol>
<h3 id="非齐次方程："><a href="#非齐次方程：" class="headerlink" title="非齐次方程："></a>非齐次方程：</h3><p>我们需要用到很有用的方法： 常数变易法。也就是先求出非齐次方程对应的齐次方程的通解。再令式中的C为$u(x)$,将其变为函数<br>也就是 作变换 $y(x) = u(x)e^{-\int P(x)dx}$ </p>
<p>然后再带入非齐次方程，作为它的一个解。 </p>
<p>所以原非齐次方程可以变成：</p>
<p>$u’e^{-\int P(x)dx}-P(x)ue^{-\int P(x)dx}+P(x)ue^{-\int P(x)dx} = Q(x)$ </p>
<p>即 $\frac{du}{dx} = Q(x)e^{\int P(x)dx}$ </p>
<p>两端积分可得： $u = \int Q(x)e^{\int P(x)dx}dx+C$ 注意，这个C不能忘记！</p>
<p>原齐次方程方程的通解：  $y =u(x)e^{-\int P(x)dx} = e^{-\int P(x)dx}[\int Q(x)e^{\int P(x)dx}dx+C]$</p>
<h4 id="例一-1"><a href="#例一-1" class="headerlink" title="例一"></a>例一</h4><p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/22.png" style="zoom: 67%;"></p>
<h4 id="例二-1"><a href="#例二-1" class="headerlink" title="例二"></a>例二</h4><p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/23.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/24.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/25.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/26.png" style="zoom: 67%;"></p>
<h2 id="伯努利方程"><a href="#伯努利方程" class="headerlink" title="伯努利方程"></a>伯努利方程</h2><p>伯努利方程的标准形式：</p>
<p>$\frac{dy}{dx} +P(x)y = Q(x)y^n(n\neq0,1)$</p>
<p>方法：</p>
<ol>
<li>首先标出 P(x),Q(x) 分别是多少！</li>
<li>令 $z=y^{1-n}$, 则 $\frac{dz}{dx} = (1-n)y^{-n} \frac{dy}{dx}$  </li>
<li>带入原伯努利方程得到： $\frac{dz}{dx} + (1-n)P(x)z = (1-n)Q(x)$ , 也就是我们熟悉的线性方程。然后求其次、设u(x) 等步骤</li>
</ol>
<p>求出这个z和x的线性方程之后，我们再把 $z=y^{1-n}$ 带入得到伯努利方程的通解。</p>
<h4 id="例题4"><a href="#例题4" class="headerlink" title="例题4"></a>例题4</h4><p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/28.png" style="zoom: 80%;"></p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ol>
<li>一阶线性方程 $\frac{dy}{dx}+P(x)y = Q(x)$</li>
</ol>
<p>方法： 先解齐次方程，再用常数变易法</p>
<p>要注意：可以转换为 $\frac{dx}{dy}$ 那么接下来就是x，y都反一下就可以了。</p>
<ol>
<li>伯努利方程 $\frac{dy}{dx} +P(x)y = Q(x)y^n,(n\neq 0,1)$  </li>
</ol>
<p>方法： 令 $u = y^{1-n}$ 转化为线性方程求解</p>
<p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/30.png" style="zoom: 75%;"></p>
<p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/31.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/32.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/33.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/34.png" style="zoom: 80%;"></p>
<h2 id="全微分方程"><a href="#全微分方程" class="headerlink" title="全微分方程"></a>全微分方程</h2><p>我们拿到微分方程，可以先判断一下他是不是全微分方程。全微分方程属于难度较低的一类。</p>
<p>一阶微分方程可以写成 $P(x,y)dx+Q(x,y)dy = 0$  的形式，若他的左边恰好是某个函数 $u(x,y)$ 的全微分， 即<br>$du(x,y) = P(x,y)dx+Q(x,y)$  则称 上式为全微分方程</p>
<p>方程 $P(x,y)dx+Q(x,y)dy = 0$ 等同于 $du(x,y) = 0$  由此可知，全微分方程(1) 的通解是方程 $u(x,y) = C$ 所确定的隐函数。</p>
<p>$P(x,y)dx+Q(x,y)dy = 0$ 是全微分的充要条件为： $\frac{\partial P}{\partial y} = \frac{\partial Q}{\partial x }$ </p>
<p>而且满足方程1 的原函数可以由曲线积分 $u(x,y) = \int<em>{x_0}^xP(x,y_0)dx+\int</em>{y_0}^yQ(x,y)dy$  求得，其中$(x_0,y_0)$为定义域D中任意选定的点。</p>
<p>这里要注意了，如果x，y再分数里，那么要判断 $x_0,y_0$ 是否可以取0 ，如果不能取0就取1</p>
<h4 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h4><p>求微分方程 $(2x+e^{y^2})dx+(2xye^{y^2}-2y)dy = 0$ 的通解</p>
<p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/37.png" style="zoom:80%;"></p>
<h4 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h4><p>求解 $(x+\frac{y}{x^2})dx-\frac{1}{x}dy=0$</p>
<p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/38.png" style="zoom:80%;"></p>
<p>那么我们可以想到，如果一个方程不是全微分，我们可以通过一个乘以一个积分因子，将其变为全微分的形式。</p>
<p>现在引入积分因子的概念</p>
<h3 id="积分因子"><a href="#积分因子" class="headerlink" title="积分因子"></a>积分因子</h3><p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/39.png" style="zoom:80%;"></p>
<p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/40.png" style="zoom:80%;"></p>
<h4 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h4><p><img src="/2020/06/18/%E4%B8%80%E9%98%B6%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/41.png" style="zoom:80%;"></p>
<p>分项组合是求积分因子的有效方法。常见的积分因子有: </p>
<p>$d(xy) = ydx+xdy$ </p>
<p>$d(\frac{y}{x})= \frac{xdy-ydx}{x^2}$</p>
<p>$d(arctan\frac{y}{x})=\frac{xdy-ydx}{x^2+y^2}$</p>
<p>$d(ln(x+y))= \frac{dx+dy}{x+y}$</p>
<p>$d(ln(x^2+y^2))= \frac{2xdx+2ydy}{x^2+y^2}$</p>
<p>$d(\frac{1}{y}) = \frac{1}{y^2}$</p>
<p>练习： 解方程 $2xy^3dx+(x^2y^2-1)dy = 0$</p>
<p>$y^2(2xydx+x^2)dy-dy = 0$</p>
<p>$x^2y+\frac{1}{y}=C$</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/06/17/BSTandAVL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/17/BSTandAVL/" class="post-title-link" itemprop="url">BSTandAVL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-17 16:26:03" itemprop="dateCreated datePublished" datetime="2020-06-17T16:26:03+08:00">2020-06-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-08 21:19:38" itemprop="dateModified" datetime="2022-12-08T21:19:38+08:00">2022-12-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">树</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h1><h2 id="知识点概述"><a href="#知识点概述" class="headerlink" title="知识点概述"></a>知识点概述</h2><p>二叉查找树(Binary Search Tree, BST), 又称为二叉搜索树，二叉排序树，是一种对查找和排序都有用的特殊二叉树。</p>
<p>二叉查找树或是空树， 或是满足如下性质的二叉树： </p>
<p>1)    若其左子树非空， 则左子树上所有结点的值均小于根结点的值</p>
<p>2)    若其右子树非空，则右子树上所有结点的值均大于等于根结点的值</p>
<p>3) 其左右子树本身又各是一棵二叉查找树。<br>二叉查找树的特性： 左子树＜根&lt;右子树即二叉查找树的中序遍历是一个递增序列</p>
<p>一般来说节点是不能相等的，如果硬要相等的话可以引入计数器</p>
<p><img src="/2020/06/17/BSTandAVL/1.png"></p>
<h2 id="二叉查找树的查找"><a href="#二叉查找树的查找" class="headerlink" title="二叉查找树的查找"></a>二叉查找树的查找</h2><p>因为二叉查找树的中序遍历有序性，所以查找和二分查找类似，每次缩小查找范围，查找的效率较高 。</p>
<h3 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a>算法步骤：</h3><p>1)    若二叉查找树为空，查找失败，返回空指针<br>2)     若二叉查找树非空， 将待查找关键字 x 与根结点的关键字 T-&gt;data 比较： </p>
<ul>
<li>若 x==T-&gt;data, 查找成功， 返回根结点指针</li>
<li>若 x\&lt;  T->data, 则递归查找左子树</li>
<li>若 x&gt;  T-&gt;data, 则递归查找右子树</li>
</ul>
<p><img src="/2020/06/17/BSTandAVL/2.png" style="zoom: 67%;"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BSTree <span class="title">SearchBST</span><span class="params">(BSTree T,ElemType key)</span><span class="comment">//二叉排序树的递归查找</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//若查找成功，则返回指向该数据元素结点的指针，否则返回空指针</span></span><br><span class="line">    <span class="keyword">if</span>((!T)|| key==T-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key&lt;T-&gt;data)</span><br><span class="line">            <span class="keyword">return</span> SearchBST(T-&gt;lchild,key);<span class="comment">//在左子树中继续查找</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> SearchBST(T-&gt;rchild,key); <span class="comment">//在右子树中继续查找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>二叉查找树的查找时间复杂度和树的形态有关，可分为最好情况、最坏情况和平均情况分析。</p>
<ul>
<li>最好情况下，二叉查找树的形态和二分查找的判定树相似，如图8-18所示。 每次查找可以缩小—半的搜索范围，查找路径最多从根到叶子，比较次数最多为树的高度$O(\log n)$ 最好情况的平均查找长度为$O(\log n)$</li>
</ul>
<p><img src="/2020/06/17/BSTandAVL/3.png"></p>
<ul>
<li>最坏情况下，二叉排序树的形态为单支树，即只有左子树或只有右子树。每次查找的搜索范围缩小为n-1，退化为顺序查找，最坏情况的平均查找的长度为$O(n)$ </li>
</ul>
<p><img src="/2020/06/17/BSTandAVL/4.png" style="zoom:67%;"></p>
<ul>
<li>n个结点的二叉查找树有n!颗（有的形态相同），可以证明，平均情况下，二叉查找树的平均查找长度也为$O(\log n)$</li>
</ul>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>空间复杂度为 O(1)</p>
<h2 id="二叉搜索树的插入"><a href="#二叉搜索树的插入" class="headerlink" title="二叉搜索树的插入"></a>二叉搜索树的插入</h2><p>因为二叉查找树的中序遍历有序性，首先要查找待插入关键字的插入位置，当查找不成功时， 将待插入关键字作为新的叶子结点插入到最后一个查找结点的左孩子或右孩子。 </p>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>1) 若二叉查找树为空， 创建一个新的结点 S, 将待插入关键字放入新结点的数据域，s结点作为根节点，左右子树均为空。如果查找成功，要么什么也不做，要么设置一个变量记录出现次数</p>
<p>2) 若二叉查找树非空，将待查找关键字x与根节点的关键字 T-&gt;data比较：</p>
<ul>
<li>若x\&lt; T->data,则将x插入到左子树</li>
<li>若x>T->data, 则将x插入到右子树</li>
</ul>
<p><img src="/2020/06/17/BSTandAVL/5.png" style="zoom:67%;"></p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertBST</span><span class="params">(BSTree &amp;T,ElemType e)</span><span class="comment">//二叉排序树的插入</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//当二叉排序树T中不存在关键字等于e的数据元素时，则插入该元素</span></span><br><span class="line">    <span class="keyword">if</span>(!T)<span class="comment">//如果T是空的，说明这个位置就是我们要插入的位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        BSTree S=<span class="keyword">new</span> BSTNode; <span class="comment">//生成新结点</span></span><br><span class="line">        S-&gt;data=e;             <span class="comment">//新结点S的数据域置为e</span></span><br><span class="line">        S-&gt;lchild=S-&gt;rchild=<span class="literal">NULL</span>;<span class="comment">//新结点S作为叶子结点</span></span><br><span class="line">        T=S;            		<span class="comment">//把新结点S链接到已找到的插入位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(e&lt;T-&gt;data)</span><br><span class="line">            InsertBST(T-&gt;lchild,e );<span class="comment">//插入左子树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(e&gt;T-&gt;data)</span><br><span class="line">            InsertBST(T-&gt;rchild,e);<span class="comment">//插入右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a>算法分析：</h3><p>二叉查找树的插入需要线查找插入位置，插入本身只需要常数时间，但查找插入位置的时间复杂度为$O(\log n)$</p>
<h2 id="二叉查找树的创建"><a href="#二叉查找树的创建" class="headerlink" title="二叉查找树的创建"></a>二叉查找树的创建</h2><p>二叉查找树的创建可以从空树开始，按照输入关键字的顺序依次进行插入操作，最终得到一棵二叉查找树</p>
<h3 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>1) 初始化二叉查找树为空树，T=NULL</p>
<p>2) 输入一个关键字x，将x插入到二叉查找树T当中</p>
<p>3) 重复步骤2），直到关键字输入完毕</p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBST</span><span class="params">(BSTree &amp;T )</span><span class="comment">//二叉排序树的创建</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//依次读入一个关键字为key的结点，将此结点插入二叉排序树T中</span></span><br><span class="line">    T=<span class="literal">NULL</span>;</span><br><span class="line">    ElemType e;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;e;</span><br><span class="line">    <span class="keyword">while</span>(e!=ENDFLAG)<span class="comment">//ENDFLAG为自定义常量，作为输入结束标志</span></span><br><span class="line">    &#123;</span><br><span class="line">        InsertBST(T,e);  <span class="comment">//插入二叉排序树T中</span></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><p>二叉查找树的创建，需要n次插入，每次需要$O(\log n) $时间 ,因此创建二叉搜索树的时间复杂度为$O(n\log n)$</p>
<p>相当于把一个无序序列转换为一个有序序列的排序过程。实际上，创建二叉查找树的过程和快速排序一样。根节点相当于快速排序中的基准元素，左右两部分划分的情况取决于基准元素，创建二叉查找树的时候，输入序列的次序不同，创建的二叉查找树是不同的</p>
<h2 id="二叉查找树的删除"><a href="#二叉查找树的删除" class="headerlink" title="二叉查找树的删除"></a>二叉查找树的删除</h2><p>首先要在二叉查找树中找到待删除的结点，然后执行删除操作。假设指针p指向待删除的结点，指针f指向p的双亲结点。根据待删除结点所在的位置不同，删除操作处理方法也不同可以分为3种情况</p>
<h3 id="被删除节点右子树为空"><a href="#被删除节点右子树为空" class="headerlink" title="被删除节点右子树为空"></a>被删除节点右子树为空</h3><p>如果被删除节点右子树为空，则令其左子树子承父业代替其位置即可。例如，在二叉查找树中删除p结点，如图所示</p>
<p><img src="/2020/06/17/BSTandAVL/7.png" style="zoom:67%;"></p>
<h3 id="被删除节点左右子树均不空"><a href="#被删除节点左右子树均不空" class="headerlink" title="被删除节点左右子树均不空"></a>被删除节点左右子树均不空</h3><p>如果被删除结点的左子树和右子树均不空，则没办法再使用子承父业的方法了。根据二叉查找树的 中序有序性，删除该结点时，可以用其直接前驱（或直接后继）代替其位置，然后删除其直接前驱（或直接后继）即可。那么中序遍历序列中，一个结点的直接前驱（或直接后继）是哪个结点呢? </p>
<p><strong>直接前驱</strong>：中序遍历中，结点p的直接前驱为其左子树的最右结点。即沿着p的左子树 一直访问其右子树，直到没有右子树，就找到了最右结点。如图下图a所示。 s 指向p的直接前驱，q指向s的双亲。 </p>
<p><img src="/2020/06/17/BSTandAVL/8.png"></p>
<p><strong>直接后继</strong>： 中序遍历中，结点p的直接后继为其右子树的最左结点。如图上图b所示s指向p的后继，q指向s的双亲</p>
<p><img src="/2020/06/17/BSTandAVL/9.png"></p>
<p>例如，在二叉查找树之中删除24，首先查找到24的位置p，然后找到p的直接前驱s(22)结点，令22赋值给p的数据域，删除s结点，删除过程如图</p>
<p><img src="/2020/06/17/BSTandAVL/10.png"></p>
<h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><p>特殊情况就是左右子树都非空，但是左子树并没有右子树。那么cl直接接到q的左子树上</p>
<p><img src="/2020/06/17/BSTandAVL/12.png" style="zoom:100%;"></p>
<p>比如这里我想删除20，</p>
<p><img src="/2020/06/17/BSTandAVL/13.png" style="zoom:100%;"></p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p><img src="/2020/06/17/BSTandAVL/15.png" style="zoom: 100%;"></p>
<p>用最大前驱来代替</p>
<p><img src="/2020/06/17/BSTandAVL/16.png" style="zoom: 50%;"></p>
<p>或者用最小后继来代替</p>
<p><img src="/2020/06/17/BSTandAVL/17.png" style="zoom: 50%;"></p>
<h3 id="算法步骤：-1"><a href="#算法步骤：-1" class="headerlink" title="算法步骤："></a>算法步骤：</h3><p>1)    在二叉查找树中查找待删除关键字的位置，p指向待删除结点， f指向p的双亲结点(f一开始为空)， 如果查找失败， 则返回。  </p>
<p>2)    如果查找成功， 则分三种情况进行删除操作： </p>
<ul>
<li>如果被删除结点<strong>左子树为空</strong>， 则令其右子树子承父业代替其位置即可。 </li>
<li>如果被删除结点<strong>右子树为空</strong>， 则令其左子树子承父业代替其位置即可。     </li>
<li>如果被删除结点右子树均不空， 则令其互接前驱（或互接后继）代替之，再删除其互接前驱（或互接后继） </li>
</ul>
<h2 id="代码一览"><a href="#代码一览" class="headerlink" title="代码一览"></a>代码一览</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENDFLAG -1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>&#123;</span></span><br><span class="line">	ElemType data;	<span class="comment">//结点数据域</span></span><br><span class="line">	BSTNode *lchild,*rchild;	<span class="comment">//左右孩子指针</span></span><br><span class="line">&#125;BSTNode,*BSTree;</span><br><span class="line"></span><br><span class="line"><span class="function">BSTree <span class="title">SearchBST</span><span class="params">(BSTree T,ElemType key)</span><span class="comment">//二叉排序树的递归查找</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//若查找成功，则返回指向该数据元素结点的指针，否则返回空指针</span></span><br><span class="line">    <span class="keyword">if</span>((!T)|| key==T-&gt;data)</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key&lt;T-&gt;data)</span><br><span class="line">            <span class="keyword">return</span> SearchBST(T-&gt;lchild,key);<span class="comment">//在左子树中继续查找</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> SearchBST(T-&gt;rchild,key); <span class="comment">//在右子树中继续查找</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertBST</span><span class="params">(BSTree &amp;T,ElemType e)</span><span class="comment">//二叉排序树的插入</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//当二叉排序树T中不存在关键字等于e的数据元素时，则插入该元素</span></span><br><span class="line">    <span class="keyword">if</span>(!T)</span><br><span class="line">    &#123;</span><br><span class="line">        BSTree S=<span class="keyword">new</span> BSTNode; <span class="comment">//生成新结点</span></span><br><span class="line">        S-&gt;data=e;             <span class="comment">//新结点S的数据域置为e</span></span><br><span class="line">        S-&gt;lchild=S-&gt;rchild=<span class="literal">NULL</span>;<span class="comment">//新结点S作为叶子结点</span></span><br><span class="line">        T=S;            		<span class="comment">//把新结点S链接到已找到的插入位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(e&lt;T-&gt;data)</span><br><span class="line">            InsertBST(T-&gt;lchild,e );<span class="comment">//插入左子树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(e&gt;T-&gt;data)</span><br><span class="line">            InsertBST(T-&gt;rchild,e);<span class="comment">//插入右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBST</span><span class="params">(BSTree &amp;T )</span><span class="comment">//二叉排序树的创建</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//依次读入一个关键字为key的结点，将此结点插入二叉排序树T中</span></span><br><span class="line">    T=<span class="literal">NULL</span>;</span><br><span class="line">    ElemType e;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;e;</span><br><span class="line">    <span class="keyword">while</span>(e!=ENDFLAG)<span class="comment">//ENDFLAG为自定义常量，作为输入结束标志</span></span><br><span class="line">    &#123;</span><br><span class="line">        InsertBST(T,e);  <span class="comment">//插入二叉排序树T中</span></span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteBST</span><span class="params">(BSTree &amp;T,<span class="keyword">char</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//从二叉排序树T中删除关键字等于key的结点</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    一开始p指向T，f指向p的父亲，也就是NULL</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    BSTree p=T;BSTree f=<span class="literal">NULL</span>;</span><br><span class="line">    BSTree q;</span><br><span class="line">    BSTree s;</span><br><span class="line">    <span class="keyword">if</span>(!T) <span class="keyword">return</span>; <span class="comment">//树为空则返回</span></span><br><span class="line">    <span class="keyword">while</span>(p)<span class="comment">//查找</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data==key) <span class="keyword">break</span>;  <span class="comment">//找到关键字等于key的结点p，结束循环</span></span><br><span class="line">        f=p;                <span class="comment">//f为p的双亲，因为接下来p会变成他的左右孩子</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data&gt;key)</span><br><span class="line">            p=p-&gt;lchild; <span class="comment">//在p的左子树中继续查找</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p=p-&gt;rchild; <span class="comment">//在p的右子树中继续查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span>; <span class="comment">//找不到被删结点则返回</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//三种情况：p左右子树均不空、无右子树、无左子树</span></span><br><span class="line">    <span class="keyword">if</span>((p-&gt;lchild)&amp;&amp;(p-&gt;rchild))<span class="comment">//被删结点p左右子树均不空</span></span><br><span class="line">    &#123;</span><br><span class="line">        q=p;<span class="comment">//让q指向p，s去找p的左子树的最右结点</span></span><br><span class="line">        s=p-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span>(s-&gt;rchild)<span class="comment">//在p的左子树中继续查找其前驱结点，即最右下结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            q=s;</span><br><span class="line">            s=s-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;data=s-&gt;data;  <span class="comment">//s的值赋值给被删结点p,然后删除s结点</span></span><br><span class="line">        <span class="keyword">if</span>(q!=p)		 <span class="comment">//q!=p说明 q向p的左子树的右子树方向移动了</span></span><br><span class="line">            q-&gt;rchild=s-&gt;lchild; <span class="comment">//把s的左子树赋值给q的右子树</span></span><br><span class="line">        <span class="keyword">else</span>			<span class="comment">//否则说明 q仍然是p的左子树，就是上面说的特殊情况</span></span><br><span class="line">            q-&gt;lchild=s-&gt;lchild; <span class="comment">//把s的左子树赋值给q的左子树</span></span><br><span class="line">        <span class="keyword">delete</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;rchild)<span class="comment">//被删结点p无右子树，只需重接其左子树</span></span><br><span class="line">        &#123;</span><br><span class="line">            q=p;</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!p-&gt;lchild)<span class="comment">//被删结点p无左子树，只需重接其右子树</span></span><br><span class="line">        &#123;</span><br><span class="line">             q=p;</span><br><span class="line">             p=p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*――――――――――将p所指的子树挂接到其双亲结点f相应的位置――重连――――――*/</span></span><br><span class="line">        <span class="keyword">if</span>(!f)</span><br><span class="line">            T=p;  <span class="comment">//被删结点为根结点，那么令p为根节点。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(q==f-&gt;lchild)</span><br><span class="line">                f-&gt;lchild=p; <span class="comment">//挂接到f的左子树位置</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                f-&gt;rchild=p;<span class="comment">//挂接到f的右子树位置</span></span><br><span class="line">        <span class="keyword">delete</span> q;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BSTree &amp;T)</span><span class="comment">//中序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">	&#123;</span><br><span class="line">        InOrderTraverse(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;T-&gt;data&lt;&lt;<span class="string">"\t"</span>;</span><br><span class="line">        InOrderTraverse(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BSTree T;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入一些整型数，-1结束"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	CreateBST(T);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"当前有序二叉树中序遍历结果为"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	InOrderTraverse(T);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	ElemType key;<span class="comment">//待查找或待删除内容</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入待查找关键字"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;key;</span><br><span class="line">	BSTree result=SearchBST(T,key);</span><br><span class="line">	<span class="keyword">if</span>(result)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"找到"</span>&lt;&lt;key&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"未找到"</span>&lt;&lt;key&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入待删除关键字"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;key;</span><br><span class="line">	DeleteBST(T,key);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"当前有序二叉树中序遍历结果为"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	InOrderTraverse(T);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="AVL平衡二叉树"><a href="#AVL平衡二叉树" class="headerlink" title="AVL平衡二叉树"></a>AVL平衡二叉树</h1><p>平衡二叉查找树 (Balanced Binary Search Tree, BBST), 简称平衡二叉树， 由前苏联数学家 Adelson-Velskii和 Landis 提出， 所以又称为 AVL 树。</p>
<p>平衡二叉树或者为空树， 或者为具有以下性质的平衡二叉树：</p>
<p>1)    左右子树高度差的绝对值不超过 1;</p>
<p>2)    左右子树也是平衡二叉树。</p>
<p>结点左右子树的高度只差称为平衡因子。二叉查找树中 ， 每个结点的平衡因子绝对值不超过1即为平衡二叉树。例如，一颗平衡二叉树及其平衡因子</p>
<p><img src="/2020/06/17/BSTandAVL/18.png" style="zoom: 100%;"></p>
<p>那么在这棵平衡二叉树中插入20, 结果会怎样？如图8-46所示。插入20之后，从该叶子到树根路径上的所有结点，平衡因子都有可能改变， 出现不平衡，有可能有多个结点平衡 因子绝对值超过1。从新插入结点向上 找离新插入结点<strong>最近的不平衡结点</strong>，以该结点为根的子树称为<strong>最小不平衡子树</strong>。只需要<strong>将最小不平衡子树调整为平衡二叉树</strong>即可，其它结点不变。</p>
<p><img src="/2020/06/17/BSTandAVL/19.png" style="zoom: 100%;"></p>
<p>平衡二叉树除了适度平衡性， 还具有局部性：</p>
<p>1)    单次插入、 删除后， 至多有 $O(1)$处出现不平衡</p>
<p>2)    总可以在 $O(logn)$时间内， 使这 $ O(1)$处不平衡重新调整为平衡。</p>
<p>平衡二叉树在动态修改后出现的不平衡， 只需要局部（最小不平衡子树）调平衡即可，不需要整棵树调整。</p>
<ol>
<li>在任意一颗非空平衡二叉树T1中，删除某节点v之后形成的平衡二叉树$T_2$ ，再将v插入$T_2$ 形成平衡二叉树 T3, 那么：<strong>取v为T1中的任意节点，T1和T3都可能相同可能不同</strong></li>
</ol>
<h2 id="平衡二叉树的调整"><a href="#平衡二叉树的调整" class="headerlink" title="平衡二叉树的调整"></a>平衡二叉树的调整</h2><p><strong>那么如何局部调平衡呢？</strong></p>
<p>调整平衡的方法<br>以插入操作为例， 调整平衡可以分为四种情况: <strong>LL型、 RR型、 LR型、 RL型。</strong></p>
<h3 id="LL型"><a href="#LL型" class="headerlink" title="LL型"></a>LL型</h3><p>插入新结点C后 ， 从该结点向上找到最近的不平衡结点A, 如果最近不平衡结点到新结点的路径前两个都是左子树 L, 即为 LL 型。 也就是说，C结点插入在A的左子树的左子树中 ， A的左子树因插入新结点高度增加， 造成A的平衡因子由1增 为2, 失去平衡。 需要进行 LL 旋转（顺时针）调整平衡。</p>
<p><img src="/2020/06/17/BSTandAVL/20.png" style="zoom: 100%;"></p>
<p>每一次旋转， 总有一个子树被抛弃， 一个指针空闲 ， 它们正好配对。旋转之后， 是否平衡呢</p>
<p>旋转之后， A、B两个结点的左右子树高度之差均为0, 满足平衡条件， C的左右子树未变 ， 仍然平衡。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>T指向最小不平衡子树的根。temp指向其左子树。</p>
<p>把temp的右子树（被抛弃的孩子）过继给T当左孩子</p>
<p>temp的右子树指向T，完成旋转</p>
<p>然后要更新T子树的高度和temp子树的高度</p>
<p>返回新树根</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVLTree <span class="title">LL_Rotation</span><span class="params">(AVLTree &amp;T)</span><span class="comment">//LL旋转</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVLTree temp=T-&gt;lchild;</span><br><span class="line">    T-&gt;lchild=temp-&gt;rchild;</span><br><span class="line">    temp-&gt;rchild=T;</span><br><span class="line">    updateHeight(T);<span class="comment">//更新高度</span></span><br><span class="line">    updateHeight(temp);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RR-型"><a href="#RR-型" class="headerlink" title="RR 型"></a>RR 型</h3><p>插入新结点x后，从该节点向上找到最近的不平衡节点A，如果最近不平衡节点到新节点的路径前两个都是右子树R，即为RR型。需要进行RR旋转(逆时针)调整平衡</p>
<p><img src="/2020/06/17/BSTandAVL/21.png" style="zoom: 100%;"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVLTree <span class="title">RR_Rotation</span><span class="params">(AVLTree &amp;T)</span><span class="comment">//RR旋转</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVLTree temp=T-&gt;rchild;</span><br><span class="line">    T-&gt;rchild=temp-&gt;lchild;</span><br><span class="line">    temp-&gt;lchild=T;</span><br><span class="line">    updateHeight(T);<span class="comment">//更新高度</span></span><br><span class="line">    updateHeight(temp);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LR-型"><a href="#LR-型" class="headerlink" title="LR 型"></a>LR 型</h3><p>插入新节点x后，从该结点向上找到最近的不平衡节点A，如果最近不平和给结点到新节点的路径前两个一次是左子树L和右子树R，即为LR型</p>
<p>旋转一次之后，变成了LL型，那么就进行LL旋转即可</p>
<p>或者让B转过来。</p>
<p><img src="/2020/06/17/BSTandAVL/23.png" style="zoom: 100%;"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVLTree <span class="title">LR_Rotation</span><span class="params">(AVLTree &amp;T)</span><span class="comment">//LR旋转</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     T-&gt;lchild=RR_Rotation(T-&gt;lchild);</span><br><span class="line">     <span class="keyword">return</span> LL_Rotation(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RL型"><a href="#RL型" class="headerlink" title="RL型"></a>RL型</h3><p>插入新结点x后，从该结点向上找到最近的不平衡结点A, 如果最近不平衡结点到新结点的路径前依次时右子树R、 左子树L, 即为RL型。</p>
<p><img src="/2020/06/17/BSTandAVL/24.png" style="zoom: 100%;"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVLTree <span class="title">RL_Rotation</span><span class="params">(AVLTree &amp;T)</span><span class="comment">//RL旋转</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T-&gt;rchild=LL_Rotation(T-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> RR_Rotation(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="平衡二叉树的插入"><a href="#平衡二叉树的插入" class="headerlink" title="平衡二叉树的插入"></a>平衡二叉树的插入</h2><p>在平衡二叉树上插入新的数据元素 X, 首先查找其插入位置， 查找过程中， 用p指针记录当前结点 ， J指针记录p的双亲， 其算法描述如下。</p>
<h3 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>1)    在平衡二叉树查找 X, 如果查找成功， 则什么也不做， 返回p; 如果查找失败， 则执行的插入操作；<br>2)    创建一个新结点p存储 X, 该结点的双亲为f, 高度为1。<br>3)    从新结点之父J出发 ， 向上寻找最近的不平衡结点 。逐层检查各代祖先结点， 如果平衡 ，则更新其高度， 继续向上寻找 ， 如果不平衡，则判断失衡类型（沿着高度大的子树判断， 刚插入新结点的子树必然高度大）， 并作相应的调整， 返回p。</p>
<p>例如，我们在这棵树中插入20，那么这样24的平衡因子是2，需要调整了</p>
<p><img src="/2020/06/17/BSTandAVL/25.png" style="zoom: 100%;"></p>
<p>因为是LR型，我们先把20逆时针移到19和24之间，然后把24顺时针旋转，作为20的右子树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVLTree <span class="title">Insert</span><span class="params">(AVLTree &amp;T,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="comment">//如果为空，创建新结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        T=<span class="keyword">new</span> AVLNode;</span><br><span class="line">        T-&gt;lchild=T-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">        T-&gt;data=x;</span><br><span class="line">        T-&gt;<span class="built_in">height</span>=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;data==x) <span class="keyword">return</span> T;<span class="comment">//查找成功，什么也不做，查找失败时才插入</span></span><br><span class="line">    <span class="keyword">if</span>(x&lt;T-&gt;data)<span class="comment">//插入到左子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;lchild=Insert(T-&gt;lchild,x);<span class="comment">//注意插入后饭后结果挂接到T-&gt;lchild</span></span><br><span class="line">        <span class="keyword">if</span>(Height(T-&gt;lchild)-Height(T-&gt;rchild)==<span class="number">2</span>)</span><br><span class="line"> <span class="comment">//插入后看是否平衡，如果不平衡显然是插入的那一边高度大。插入到左子树，左子树肯定比右子树高</span></span><br><span class="line">        &#123;                                         <span class="comment">//沿着高度大的那条路径判断</span></span><br><span class="line">            <span class="keyword">if</span>(x&lt;T-&gt;lchild-&gt;data)<span class="comment">//判断是LL还是LR,即插入的是lchild节点的lchild 还是rchild</span></span><br><span class="line">                T=LL_Rotation(T);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T=LR_Rotation(T);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//插入到右子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;rchild=Insert(T-&gt;rchild,x);</span><br><span class="line">        <span class="keyword">if</span>(Height(T-&gt;rchild)-Height(T-&gt;lchild)==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;T-&gt;rchild-&gt;data)</span><br><span class="line">                T=RR_Rotation(T);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T=RL_Rotation(T);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    updateHeight(T);</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="平衡二叉树的创建"><a href="#平衡二叉树的创建" class="headerlink" title="平衡二叉树的创建"></a>平衡二叉树的创建</h2><p>平衡二叉树的创建和二叉查找树的创建类似，只是插入操作多了调平衡而已。可以丛空树开始，按照输入关键字的顺序依次进行插入操作， 最终得到一颗平衡二叉树</p>
<h3 id="算法步骤：-2"><a href="#算法步骤：-2" class="headerlink" title="算法步骤："></a>算法步骤：</h3><ul>
<li>初始化平衡二叉树为空树，T=NULL;</li>
<li>输入一个关键字x，将x插入到平衡二叉树T中</li>
<li>重复步骤2，直到关键字输入完毕</li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVLTree <span class="title">CreateAVL</span><span class="params">(AVLTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,x;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        T=Insert(T,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="平衡二叉树的删除"><a href="#平衡二叉树的删除" class="headerlink" title="平衡二叉树的删除"></a>平衡二叉树的删除</h2><p><strong>插入只需要从插入结点之父向上检查，发现不平衡立即调整，一次调平横即可</strong>。</p>
<p><strong>删除操作则需要一直从删除节点之父向上检查，发现不平衡立即调整，然后继续向上检查，检查到树根为止</strong></p>
<h3 id="算法步骤：-3"><a href="#算法步骤：-3" class="headerlink" title="算法步骤："></a>算法步骤：</h3><ul>
<li><p>在平衡二叉树查找 X,如果查找失败，则返回，如果查找成功，则执行删除操作（回二叉查找树的删除）</p>
</li>
<li><p>从实际被删除结点之父g出发（当被删结点有左右子树时，令其直接前驱（或直接后继）代替其位置，删除其直接前驱，<strong>实际被删结点为其直接前驱（或直接后继）</strong>），向上寻找最近的不平衡结点。 逐层检查各代祖先结点，如果平衡， 则<strong>更新其高度</strong>， 继续向上寻找，如果不平衡，则<strong>判断失衡类型</strong>（沿着高度大的子树判断）， 并作相应的调整。</p>
</li>
<li>继续向上检查，一直到树根</li>
<li><img src="/2020/06/17/BSTandAVL/26.png" style="zoom: 80%;"></li>
</ul>
<p><img src="/2020/06/17/BSTandAVL/27.png" style="zoom: 100%;"></p>
<p><img src="/2020/06/17/BSTandAVL/28.png" style="zoom:100%;"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVLTree <span class="title">Delete</span><span class="params">(AVLTree &amp;T,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;data==x)<span class="comment">//如果找到删除节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;rchild==<span class="literal">NULL</span>)</span><br><span class="line">  <span class="comment">//如果该节点的右孩子为NULL,那么直接删除.如果左右都空，那么就返回NULL</span></span><br><span class="line">        &#123;</span><br><span class="line">            AVLTree temp=T;</span><br><span class="line">            T=T-&gt;lchild;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//否则，将其右子树的最左孩子作为这个节点（直接后继），并且递归删除这个节点的值</span></span><br><span class="line">        &#123;</span><br><span class="line">           AVLTree temp;</span><br><span class="line">           temp=T-&gt;rchild;</span><br><span class="line">           <span class="keyword">while</span>(temp-&gt;lchild)</span><br><span class="line">              temp=temp-&gt;lchild;</span><br><span class="line">           T-&gt;data=temp-&gt;data;</span><br><span class="line">           T-&gt;rchild=Delete(T-&gt;rchild,T-&gt;data);</span><br><span class="line">           updateHeight(T);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(T-&gt;data&gt;x)<span class="comment">//调节删除节点后可能涉及的节点</span></span><br><span class="line">        T-&gt;lchild=Delete(T-&gt;lchild,x);</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;data&lt;x)</span><br><span class="line">        T-&gt;rchild=Delete(T-&gt;rchild,x);</span><br><span class="line">    updateHeight(T);<span class="comment">//更新T的高度</span></span><br><span class="line">    <span class="keyword">if</span>(T-&gt;lchild)<span class="comment">//如果有左子树，那么调整左子树，是调平衡用的</span></span><br><span class="line">        T-&gt;lchild=adjust(T-&gt;lchild);</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;rchild)</span><br><span class="line">        T-&gt;rchild=adjust(T-&gt;rchild);</span><br><span class="line">    <span class="keyword">if</span>(T) T=adjust(T);</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">AVLTree <span class="title">adjust</span><span class="params">(AVLTree &amp;T)</span><span class="comment">//删除结点后，需要判断是否还是平衡，如果不平衡，就要调整</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(Height(T-&gt;lchild)-Height(T-&gt;rchild)==<span class="number">2</span>)<span class="comment">//沿着高度大的那条路径判断</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Height(T-&gt;lchild-&gt;lchild)&gt;=Height(T-&gt;lchild-&gt;rchild))</span><br><span class="line">            T=LL_Rotation(T);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T=LR_Rotation(T);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Height(T-&gt;rchild)-Height(T-&gt;lchild)==<span class="number">2</span>)<span class="comment">//沿着高度大的那条路径判断</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Height(T-&gt;rchild-&gt;rchild)&gt;=Height(T-&gt;rchild-&gt;lchild))</span><br><span class="line">            T=RR_Rotation(T);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T=RL_Rotation(T);</span><br><span class="line">    &#125;</span><br><span class="line">    updateHeight(T);</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span>&#123;</span></span><br><span class="line">   <span class="keyword">int</span> data;</span><br><span class="line">   <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> *<span class="title">lchild</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;*AVLTree;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLTree <span class="title">Empty</span><span class="params">(AVLTree &amp;T)</span><span class="comment">//删除树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    Empty(T-&gt;lchild);</span><br><span class="line">    Empty(T-&gt;rchild);</span><br><span class="line">    <span class="keyword">delete</span> T;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Height</span><span class="params">(AVLTree T)</span><span class="comment">//计算高度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> T-&gt;<span class="built_in">height</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateHeight</span><span class="params">(AVLTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     T-&gt;<span class="built_in">height</span>=<span class="built_in">max</span>(Height(T-&gt;lchild),Height(T-&gt;rchild))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLTree <span class="title">LL_Rotation</span><span class="params">(AVLTree &amp;T)</span><span class="comment">//LL旋转</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVLTree temp=T-&gt;lchild;</span><br><span class="line">    T-&gt;lchild=temp-&gt;rchild;</span><br><span class="line">    temp-&gt;rchild=T;</span><br><span class="line">    updateHeight(T);<span class="comment">//更新高度</span></span><br><span class="line">    updateHeight(temp);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLTree <span class="title">RR_Rotation</span><span class="params">(AVLTree &amp;T)</span><span class="comment">//RR旋转</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVLTree temp=T-&gt;rchild;</span><br><span class="line">    T-&gt;rchild=temp-&gt;lchild;</span><br><span class="line">    temp-&gt;lchild=T;</span><br><span class="line">    updateHeight(T);<span class="comment">//更新高度</span></span><br><span class="line">    updateHeight(temp);</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLTree <span class="title">LR_Rotation</span><span class="params">(AVLTree &amp;T)</span><span class="comment">//LR旋转</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     T-&gt;lchild=RR_Rotation(T-&gt;lchild);</span><br><span class="line">     <span class="keyword">return</span> LL_Rotation(T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLTree <span class="title">RL_Rotation</span><span class="params">(AVLTree &amp;T)</span><span class="comment">//RL旋转</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T-&gt;rchild=LL_Rotation(T-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> RR_Rotation(T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLTree <span class="title">Insert</span><span class="params">(AVLTree &amp;T,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="comment">//如果为空，创建新结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        T=<span class="keyword">new</span> AVLNode;</span><br><span class="line">        T-&gt;lchild=T-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">        T-&gt;data=x;</span><br><span class="line">        T-&gt;<span class="built_in">height</span>=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;data==x) <span class="keyword">return</span> T;<span class="comment">//查找成功，什么也不做，查找失败时才插入</span></span><br><span class="line">    <span class="keyword">if</span>(x&lt;T-&gt;data)<span class="comment">//插入到左子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;lchild=Insert(T-&gt;lchild,x);<span class="comment">//注意插入后饭后结果挂接到T-&gt;lchild</span></span><br><span class="line">        <span class="keyword">if</span>(Height(T-&gt;lchild)-Height(T-&gt;rchild)==<span class="number">2</span>)<span class="comment">//插入后看是否平衡，如果不平衡显然是插入的那一边高度大</span></span><br><span class="line">        &#123;                                         <span class="comment">//沿着高度大的那条路径判断</span></span><br><span class="line">            <span class="keyword">if</span>(x&lt;T-&gt;lchild-&gt;data)<span class="comment">//判断是LL还是LR,即插入的是lchild节点的lchild 还是rchild</span></span><br><span class="line">                T=LL_Rotation(T);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T=LR_Rotation(T);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//插入到右子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;rchild=Insert(T-&gt;rchild,x);</span><br><span class="line">        <span class="keyword">if</span>(Height(T-&gt;rchild)-Height(T-&gt;lchild)==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;T-&gt;rchild-&gt;data)</span><br><span class="line">                T=RR_Rotation(T);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T=RL_Rotation(T);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    updateHeight(T);</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLTree <span class="title">adjust</span><span class="params">(AVLTree &amp;T)</span><span class="comment">//删除结点后，需要判断是否还是平衡，如果不平衡，就要调整</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(Height(T-&gt;lchild)-Height(T-&gt;rchild)==<span class="number">2</span>)<span class="comment">//沿着高度大的那条路径判断</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Height(T-&gt;lchild-&gt;lchild)&gt;=Height(T-&gt;lchild-&gt;rchild))</span><br><span class="line">            T=LL_Rotation(T);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T=LR_Rotation(T);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Height(T-&gt;rchild)-Height(T-&gt;lchild)==<span class="number">2</span>)<span class="comment">//沿着高度大的那条路径判断</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Height(T-&gt;rchild-&gt;rchild)&gt;=Height(T-&gt;rchild-&gt;lchild))</span><br><span class="line">            T=RR_Rotation(T);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T=RL_Rotation(T);</span><br><span class="line">    &#125;</span><br><span class="line">    updateHeight(T);</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLTree <span class="title">Delete</span><span class="params">(AVLTree &amp;T,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;data==x)<span class="comment">//如果找到删除节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;rchild==<span class="literal">NULL</span>)<span class="comment">//如果该节点的右孩子为NULL,那么直接删除</span></span><br><span class="line">        &#123;</span><br><span class="line">            AVLTree temp=T;</span><br><span class="line">            T=T-&gt;lchild;</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//否则，将其右子树的最左孩子作为这个节点，并且递归删除这个节点的值</span></span><br><span class="line">        &#123;</span><br><span class="line">           AVLTree temp;</span><br><span class="line">           temp=T-&gt;rchild;</span><br><span class="line">           <span class="keyword">while</span>(temp-&gt;lchild)</span><br><span class="line">              temp=temp-&gt;lchild;</span><br><span class="line">           T-&gt;data=temp-&gt;data;</span><br><span class="line">           T-&gt;rchild=Delete(T-&gt;rchild,T-&gt;data);</span><br><span class="line">           updateHeight(T);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(T-&gt;data&gt;x)<span class="comment">//调节删除节点后可能涉及的节点</span></span><br><span class="line">        T-&gt;lchild=Delete(T-&gt;lchild,x);</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;data&lt;x)</span><br><span class="line">        T-&gt;rchild=Delete(T-&gt;rchild,x);</span><br><span class="line">    updateHeight(T);</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;lchild)</span><br><span class="line">        T-&gt;lchild=adjust(T-&gt;lchild);</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;rchild)</span><br><span class="line">        T-&gt;rchild=adjust(T-&gt;rchild);</span><br><span class="line">    <span class="keyword">if</span>(T) T=adjust(T);</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Preorder</span><span class="params">(AVLTree T)</span><span class="comment">//前序遍历方便看树的结果</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;T-&gt;data&lt;&lt;<span class="string">"\t"</span>&lt;&lt;T-&gt;<span class="built_in">height</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    Preorder(T-&gt;lchild);</span><br><span class="line">    Preorder(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">(AVLTree T)</span><span class="comment">//中序遍历方便看树的结果</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    Inorder(T-&gt;lchild);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;T-&gt;data&lt;&lt;<span class="string">"\t"</span>&lt;&lt;T-&gt;<span class="built_in">height</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    Inorder(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Posorder</span><span class="params">(AVLTree T)</span><span class="comment">//后序遍历方便看树的结果</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    Posorder(T-&gt;lchild);</span><br><span class="line">    Posorder(T-&gt;rchild);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;T-&gt;data&lt;&lt;<span class="string">"\t"</span>&lt;&lt;T-&gt;<span class="built_in">height</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(AVLTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Preorder(T);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    Inorder(T);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    Posorder(T);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLTree <span class="title">CreateAVL</span><span class="params">(AVLTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,x;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        T=Insert(T,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    AVLTree root=<span class="literal">NULL</span>;</span><br><span class="line">    root=Empty(root);</span><br><span class="line">    CreateAVL(root);</span><br><span class="line">    show(root);</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">    root=Delete(root,x);</span><br><span class="line">    show(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/06/17/B%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/17/B%E6%A0%91/" class="post-title-link" itemprop="url">B树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-17 16:00:16" itemprop="dateCreated datePublished" datetime="2020-06-17T16:00:16+08:00">2020-06-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-12-09 17:11:16" itemprop="dateModified" datetime="2022-12-09T17:11:16+08:00">2022-12-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">树</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>​        二叉搜索树的搜索效率和树高成正比关系，通过减少二叉搜索树的高度，可以提高搜索效率今 平衡二叉树可以减少树高，但是仍然不够彻底，因为每个结点只含有—个关键字，树 高仍然是$O(\log n)$， 能否继续压缩树高， 使其更加扁平化呢? </p>
<p>​        如果—个结点不限于存储—个关键字，可以包含多个关键字和多个子树，既保持二叉搜索树的特性，又具有平衡性，这样的搜索树称为<strong>多路平衡搜索树</strong> 如图所示平衡二叉搜索树比晋通的二叉搜索树高度<strong>低</strong>，而<strong>多路平衡搜索树的树高更低</strong>，更加扁平化， 搜索的效率更高。</p>
<p><img src="/2020/06/17/B%E6%A0%91/1.png" style="zoom: 67%;"></p>
<p>​        那么是不是越扁平就越好呢？再压缩下去， 就变成—个包含所有结点的树根了! 这样的效率反而会退化，因为这就相当于线性查找了，又退化成了 $O(n)$</p>
<p>​        事实上并非如此，多路平衡搜索树主要用于大规模数据的分级存储搜索，将内存的 “ 高速度 ” 和外存的 ”大容量” 结合起来，提高搜索效率。众所周知，内存的访问速度是很快的， 而外存的访问速度则慢5-6个数量级， 数据规模巨大时，无法全部放入内存，数据全集往 往放在外存中，如果频繁地访问外存，则搜索的效率降低。如何减少外存操作呢?    </p>
<p>​        外存访问时，访问一个数据和访问一段连续存储的数据，时间差别不大。因此可以用 “ 大结点 ” 代替多个单个结点， 一个 “ 大结点 ” 包含多个连续存储的数据，作为一个整体， 进行一次外存访问。将这个 “大结点 ” 调入内存后， 再进行多次内存操作， 例如顺序查找或折半 查找。 与外存访问相比， 内存操作的成本很小。</p>
<p>​        一个“大节点”到底到底包含多少个数据元素合适呢？主要取决千不同外存的批量访问特性。例如，可以根据磁盘扇区的容量和数据元素的大小计算出一个一个“大节点”包含数据元素的个数。若一个大结点包含255 个数据元素，那么1G个数据元素，每次查找需要4-5次外存访问。而如果使用平衡二叉搜索树(AVL树) ，则每次查找需要30次外存访问</p>
<p>​        多路平衡搜索树，又称为B-树，或者B树。一颗m阶B-树，或为空树，或满足以下特性</p>
<ol>
<li>每个结点最多有m棵子树</li>
<li>根结点至少有两棵子树；</li>
<li>内部结点（除根和叶子之外的结点）至少有$\lceil m/2\rceil$棵子树；</li>
<li>终端结点（叶子）在同—层上，并且不带信息（空指针）， 通常称为失败结点。</li>
<li>非终端结点的关键字个数比子树个数少 1</li>
</ol>
<p><img src="/2020/06/17/B%E6%A0%91/2.png" style="zoom: 67%;"></p>
<p>​        例如，3阶B-树，其内部节点的子树个数$2\leq k\leq3$ ，所以又称为2-3树。也就是说每个节点有1-2个关键词，2-3棵子树，所有的叶子都在最后一层，如图</p>
<p><img src="/2020/06/17/B%E6%A0%91/3.png" style="zoom: 67%;"></p>
<p>注意指针的方向</p>
<p><img src="/2020/06/17/B%E6%A0%91/4.png" style="zoom: 100%;"></p>
<p>如果我们要查询20，那么比65小，左子树；比56小，左子树；比25小，那么说明查找失败-失败节点就是这么命名的</p>
<p>B树具有平衡、有序、多路的特点，所有的叶子都在最后一层，因此左右子树的高差为0，体现了平衡的特性。B树具有<strong>中序有序</strong>性，即左子树&lt;根&lt;右子树。多路是指可以有多个分支，m阶B树的节点最多可以有m个分支。所以也可以成为m路平衡搜索树</p>
<p>查找插入删除操作和树高成正比关系，因此线分析树高，然后详解B树的查找插入、删除等基本操作</p>
<h2 id="树高与性能"><a href="#树高与性能" class="headerlink" title="树高与性能"></a>树高与性能</h2><p>一颗含有n个关键字的m阶B-树的最大高度是多少呢？</p>
<p>首先我们要看每层至少有多少个结点，因为结点越少，高度越大。根据定义，根节点至少有2棵子树，那么第二层至少有2个节点，除了根之外，每个非叶子节点至少有 $\lceil m/2\rceil$  棵子树，每个子树对应一个节点，因此第三层至少有 $2\lceil m/2\rceil $（取上限）个节点，以此类推， 第 h+1层，至少有 $2\lceil m/2\rceil^{h-1}$ 个叶子节点</p>
<p><img src="/2020/06/17/B%E6%A0%91/5.png" style="zoom: 80%;"></p>
<p>叶子结点为查找失败的空指针，n个关键字又n+1种查找失败的情况，即：</p>
<p><img src="/2020/06/17/B%E6%A0%91/6.png" style="zoom: 100%;"></p>
<p>$\lceil O(\log_mn)\rceil$就是树高，后面分析的B树的查找、插入、删除等基本操作的时间复杂度时可以利用该结果进行分析</p>
<p>比如说5阶B树，53个结点，最大的树高就是$O(\log_327)+1$ =4</p>
<p>还可以算最小的树高，那么每个节点都包含$m-1$个结点，最多会有$m$个分支，那么第$h+1$层就有$m^h$ 个结点。所以 $n+1&lt;=m^h $ , 即 $\log_m(n+1)\leq h$  放到刚才的例子当中  $\log_554$ 向上取整，也就是3层</p>
<p>因此，最短树高： $h = \lceil \log<em>m(n+1)\rceil$  , 最长树高： $h=\lfloor \log</em>{\lceil m/2\rceil} ((n+1)/2)+1\rfloor$ </p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>​        B树的查找和二叉搜索树的查找类似，不同的是需要从外存调入结点，然后在结点内查找(—个结点可能包含多个关键字 ）<br>​        首先将根结点作为当前结点， 在当前结点的关键字中查找目标， 若查找成功， 则返回 。否则通过判断进入下—层的结点， 若该结点不是叶子（空指针）， 则将其从外存调入内存作为当前结点， 重复查找过程。在任何时刻，通常只有当前结点在内存中，其他结点放在外存中， 需要时才会调入内存。</p>
<p><img src="/2020/06/17/B%E6%A0%91/7.png" style="zoom: 67%;"></p>
<p>首先和65比，比65大，那么和右子树比，和75，90比，在中间，那么在中间的指针种查找，所以找到了80</p>
<p>忽略掉内存查找的时间（内存的查找时间很短，可以忽略不计），我们执行了3次外存查找</p>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>B-树的查找时间包括将结点从外存调入内存和在内存中当前结点查找两个方面。结点间的跳转作为—次外存访问，结点内的查找作为多次内存操作，因为外存和内存操作时间相差巨大， 因此结点内的内存操作忽咯不计，只需要考察在查找的过程中，访问了多少个结点即可 查找最多从根边问到叶子， 即树的高度$O(\log_mn)$, 含有n个关键字的m阶B-树， 因此。m阶B-树查找的时间复杂度为$O(\log_mn)$</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入操作， 首先要在B-树中查找合适的插入位置。 因为关键字不允许重复， 如果查找成功，则不进行插入操作，返回。如果查找失败，则将关键字插入到失败结点的双亲结点中。<br>例如， 在 棵 3 阶 B-树中插入 59, 首先查找位置， 59 大于 58 小于 60, 而 58 和 60 之间的子树为空指针， 查找失败， 将 59 插入失败节点父亲的位置。 如图 10-35 所示。</p>
<p><img src="/2020/06/17/B%E6%A0%91/8.png" style="zoom: 67%;"></p>
<h3 id="上溢"><a href="#上溢" class="headerlink" title="上溢"></a>上溢</h3><p>​        但是m阶B-树主结点的关键字个数不能超过m-1, 插入关键字后， 如果仍然满足此条件， 那么插入操作完成。 如果插入后， 关键字个数为m （超过了m-1), 则发生了一次上溢。 帣要进行分裂操作解除上溢， 使该结点及整棵树重新满足m阶B-树的条件。（因为这是一个3阶B树，每个结点的关键字的个数为1，2。显然这个超过3个节点了，所以这就发生了上溢）<br>刚刚发生上溢的结点V, 插入之前满足条件（关键字个数小于等于m-1), 插入之后大于m-1, 因此V结点现在恰好有m个关键字。 将该关键字分裂操作：取V结点中间的关键字$K_s (s=m/2)$, 将$K_s$上升到其父结点P, 左右两部分作为$K_s$的左右孩子， 如图10-36所示。</p>
<p><img src="/2020/06/17/B%E6%A0%91/9.png" style="zoom: 67%;"></p>
<p>这里，把<strong>中间的关键字</strong>59往上提</p>
<p><img src="/2020/06/17/B%E6%A0%91/10.png" style="zoom: 67%;"></p>
<p>​        这里父亲没有发生上移，否则还要继续往上分裂，一直可以分裂到树根。最后让树高加一</p>
<p>​        分裂操作将上溢结点的中间关键字位上升到其父结点，如果其父结点这时也发生上溢，则继续分裂操作，一直向上传递， 录远到达树根。</p>
<p>位上升到其父结点P后， 可分为<strong>3种情况</strong>：</p>
<h4 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况"></a>第一种情况</h4><p>p结点未发生上溢， 修复完成</p>
<p><img src="/2020/06/17/B%E6%A0%91/11.png" style="zoom: 67%;"></p>
<h4 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h4><p>p结点发生上溢，执行分裂操作，一直向上传递，在到达树根前不再发生上溢， 或到达树根但树根未发生上溢， 修复完成。</p>
<p><img src="/2020/06/17/B%E6%A0%91/12.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/17/B%E6%A0%91/13.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/17/B%E6%A0%91/14.png" style="zoom: 67%;"></p>
<h4 id="第三种情况（特殊）"><a href="#第三种情况（特殊）" class="headerlink" title="第三种情况（特殊）"></a>第三种情况（特殊）</h4><p>上溢一直传递到树根，树根也发生上溢，那么将树根分裂，根节点中间关键字分裂成新的树根，修复完成，此时树的高度增加了1</p>
<p><img src="/2020/06/17/B%E6%A0%91/15.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/17/B%E6%A0%91/16.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/17/B%E6%A0%91/17.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/17/B%E6%A0%91/18.png" style="zoom: 67%;"></p>
<p>​        只有树根发生上溢的时候，B-树才会长高一层，其他情况，树高不变。树根分裂的时，新的树根只有一个关键字和两棵子树，这也是B-树定义中，特别是定义树根的原因</p>
<h3 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a>算法分析：</h3><p>含有n个关键字的m阶B-树，插入操作除了查找插入位置(需要$O(\log_mn)$时间) 之外，如果发生上溢，需要分裂操作，分裂操作不会超过树的高度$O(log_mn)$,因此，插入操作的时间复杂度为$O(\log_mn)$ </p>
<p>现在给我们一串数字，那么我们就可以先查找再看看有无上溢来新建一个m-阶B-树了</p>
<p><img src="/2020/06/17/B%E6%A0%91/27.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/17/B%E6%A0%91/28.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/17/B%E6%A0%91/29.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/17/B%E6%A0%91/30.png" style="zoom: 67%;"></p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>​        删除操作， 首先要在B-树中查找待删除关键字的位置。 如果查找失败，则不进行删除操作， 返回。如果查找成功，则执行以下删除操作。<strong>如果待删除关键字的子树非空</strong>，则需要像二叉搜索树一样， 令该关键字的直接前驱（或直接后继）代替待删除关键字， 然后删除其直接前驱（或直接后继）即可。直接前驱（或直接后继）的子树一定为空。因此只需要处理待删除关键字的子树为空的情况即可。</p>
<p>​        例如，在一棵3阶B-树中删除75，首先查找75位置，75所在结点的子树非空，则令75的直接前驱70代替之，然后删除70即可。</p>
<p><img src="/2020/06/17/B%E6%A0%91/19.png" style="zoom: 67%;"></p>
<p>那么如果拿直接前驱去代替它，是可以的，但是我们一定要保证删除后的结点仍然至少拥有1个关键词，如上图，删掉了70还有68；但是如果删掉了节点以后该节点小于$\lceil m/2\rceil-1$，那么我们就发生了下溢, 需要相关操作解除下溢，使该结点及整棵树重新满足 m阶B-树的条件</p>
<p><img src="/2020/06/17/B%E6%A0%91/19.png" style="zoom: 67%;"></p>
<h3 id="下溢"><a href="#下溢" class="headerlink" title="下溢"></a>下溢</h3><p>考察下溢结点V的左右兄弟，下溢处理分为3种情况：左借、右借、合并</p>
<h4 id="左借"><a href="#左借" class="headerlink" title="左借"></a>左借</h4><p><img src="/2020/06/17/B%E6%A0%91/21.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/17/B%E6%A0%91/22.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/17/B%E6%A0%91/32.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/17/B%E6%A0%91/33.png" style="zoom: 67%;"></p>
<h4 id="右借"><a href="#右借" class="headerlink" title="右借"></a>右借</h4><p><img src="/2020/06/17/B%E6%A0%91/23.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/17/B%E6%A0%91/24.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/17/B%E6%A0%91/34.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/17/B%E6%A0%91/35.png" style="zoom: 67%;"></p>
<h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><p><img src="/2020/06/17/B%E6%A0%91/25.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/17/B%E6%A0%91/26.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/17/B%E6%A0%91/36.png" style="zoom: 67%;"></p>
<p>发生下溢结点的左兄弟只有一个关键字，不可以借，也没有右兄弟。需要执行合并操作。父节点中的90下来，将左兄弟及下溢结点粘合成一个新的结点，父节点下移一个关键字后仍然满足条件，下溢解除。</p>
<p><img src="/2020/06/17/B%E6%A0%91/37.png" style="zoom: 67%;"></p>
<h4 id="特殊情况，树高减一"><a href="#特殊情况，树高减一" class="headerlink" title="特殊情况，树高减一"></a>特殊情况，树高减一</h4><p><img src="/2020/06/17/B%E6%A0%91/38.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/17/B%E6%A0%91/39.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/17/B%E6%A0%91/40.png" style="zoom: 67%;"></p>
<h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><p>含有n个关键字的m阶B-树，删除操作除了查找插入位置(需要$O(\log_mn)$时间) 之外，如果发生下溢，需要左借、右借或合并操作，合并操作不会超过树的高度$O(\log_mn)$,因此，删除操作的时间复杂度为$O(\log_mn)$ </p>
<p><img src="/2020/06/17/B%E6%A0%91/41.png" style="zoom: 67%;"></p>
<ul>
<li>删除25，节点中还有30，符合条件，直接删除即可</li>
</ul>
<p><img src="/2020/06/17/B%E6%A0%91/42.png" style="zoom: 67%;"></p>
<ul>
<li>删除80， 节点为空，此时左兄弟有两个节点，可以实行左借策略，把70放上去，把75放在原来80的位置</li>
</ul>
<p><img src="/2020/06/17/B%E6%A0%91/43.png" style="zoom: 67%;"></p>
<ul>
<li>删除65，先用最大前驱60代替65的位置，然后删除60，节点数据个数符合条件，不用进行借、合并操作</li>
</ul>
<p><img src="/2020/06/17/B%E6%A0%91/44.png" style="zoom: 67%;"></p>
<ul>
<li>删除56，节点为空，右兄弟有两个(70,90), 执行右借，70提上去，60移到56的位置</li>
</ul>
<p><img src="/2020/06/17/B%E6%A0%91/45.png" style="zoom: 67%;"></p>
<p>含有10亿个节点的3阶B-树的高度仅仅在19-30(根据上面提到的公式$\log_mn = \log_210^9 = 30$)之间，最多只需要访问30个结点就能够在10亿个键中进行任何查找、插入、和删除操作</p>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><ol>
<li><p>具有n个关键词的m阶B树，应有多少叶节点？ 即考察我们查找失败的可能性，即 n+1种，因此，由n+1个叶子节点</p>
</li>
<li><p>考察节点数：高度为5的3阶B树至少有多少节点，至多有多少结点？这里是3阶B树，节点内的关键字最少1个最多2个，因此节点数最少的时候，3阶B树的形状类似于一个满二叉树。此时高度为5的B树至少有 $2^5-1=31$ 个节点； 由于每个节点最多又m棵子树，所以当节点数最多的时候，3阶B树的形状类似于满三叉树，节点数为$(3^5-1)/2 = 121$</p>
</li>
<li><p>含有n个非叶节点的m阶B树，至少包含又多少个关键词？m阶B树每个节点包含的关键词最少是 $\lceil m/2\rceil -1$ ，根节点至少包含两颗子树、一个关键词，因此至少包含$(n-1)(\lceil m/2\rceil -1)+1$ 个关键词</p>
</li>
<li><p>利用B树做文件索引的时候，若假设磁盘页块的大小是 4000 B, 指示磁盘地址的指针需要5B，现有20000000个记录构成的文件，每个记录为200B，其中包括关键词5B</p>
<p>试问这个采用B树作索引的文件中，B树的阶数应为多少？ 假定文件数据部分 没有按照关键字有序排列，则索引部分需要占用多少磁盘页块？</p>
<p>根据B树的概念，一个索引节点应适应操作系统一次读写的物理记录大小，其大小应取不超过、但最接近一个磁盘页块的大小。假设B树为m阶，一个B树节点最多存放m-1个关键词(5B) 和对应的物理地址(5B)、m个子树指针(5B) 和一个指示磁盘地址种的实际关键字个数的整数 (2B) ,则有：</p>
<p>$(2(m-1)+m)\times 5 +2 \leq 400$  解得 $m\leq 267$ </p>
<p>一个267阶B树的索引节点最多可以存放m-1=266 个索引项，最少可以存放 $\lceil m/2\rceil -1=133$ 个索引项。因此，一共$n=2\times10^7$ 个记录，每个记录占用200B，每个页块可以存放20个记录，则全部记录将会分布在$p = 1\times 10^6$ 个页块种，最多需要占用$1\times 10^6/133=7519$ 个磁盘页块作为B树索引，最少需要 $1\times 10^6/266 = 3760$ 个磁盘块作为B树的索引</p>
</li>
</ol>
<h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><p>B+树是B-树的变种， 更适用于文件索引系统。 从严格定义上，B+树已经不属于树， 因为叶子之间有连接， 树是不允许同层结点有连接的。</p>
<p>一棵m阶B+树， 或为空树， 或为满足以下特性：</p>
<ul>
<li>每个结点最多有m棵子树。（这一点和B树是一样的）</li>
<li>根结点至少有两棵子树。（这一点和B树是一样的）</li>
<li>内部结点（除根和叶子之外的结点）至少有$\lceil m/2\rceil$（取上限）棵子树。（这一点和B树是一样的）</li>
<li>终端结点（叶子）在同—层上，并且不带信息（空指针）， 通常称为失败结点。 (<strong>很重要</strong>)</li>
<li><strong>非终端结点的关键字个数与子树个数相同</strong>。（和B树不一样，B树的关键字个数比子树少一个）</li>
<li><strong>倒数第二层结点(非空叶子)包含了全部的关键字</strong>， 结点内部有序且结点间按升序顺序链接。</li>
<li>所有的非终端结点只作为索引部分， <strong>结点中仅含子树中的最大（或最小）关键字</strong></li>
</ul>
<p>例如，一棵3阶B+树，其内部节点的子树个数$2\leq k\leq 3$,关键字的个数也是 $2\leq n\leq3$ 如下图，一般有两个指针，一个指向树根，一个指向倒数第二层关键字的最小节点(最后一层全是空的!)</p>
<p><img src="/2020/06/17/B%E6%A0%91/46.png" style="zoom: 67%;"></p>
<h2 id="B-树的查找"><a href="#B-树的查找" class="headerlink" title="B+树的查找"></a>B+树的查找</h2><p>​        B+树可通过<strong>两种方式的查找</strong>，可以利用 t 指针从树根向下索引查找，也可以利用r指针从最小关键字向后顺序查找。尽管如此，仍不建议顺序查找，因为其时间复杂度为$O(n)$, 索引查找效率要高得多。</p>
<p>​        若从树根向下查找，则首先在根结点中查找，然后在子树中查找，即使查找成功，也会继续向下，直到最后一层。也就是说，每次查找都要走一条从树根到叶子的路径，时间复杂度为树高$O(\log_mn)$</p>
<p><img src="/2020/06/17/B%E6%A0%91/47.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/17/B%E6%A0%91/48.png" style="zoom: 67%;"></p>
<p>B+树不仅支持单个关键字查找， 还支持范围查找。 例如， 查找范围在<code>[a, b]</code>之间的关键字， 首先查找a所在的位置， 从根到最后一层， 查找等于或大于a的关键字， 如果找到， 则继续在a所在的结点查找，如果未发现大于b的关键字，即可以沿该结点的最后一个指针查找下一个结点， 直到找到一个等于或大于b的关键字停止。</p>
<p>例如，在一棵3阶B+树中查找<code>[60-80]</code>之间的关键字</p>
<ul>
<li>首先查找60所在的位置，从根到最后一层，查找等于或者大于60的关键字，未找到60；</li>
<li>沿着60顺序查找，找到比它大的关键字65</li>
<li>继续在该节点中查找，在下下个节点中找到了等于80的关键字，查找成功。</li>
</ul>
<p><img src="/2020/06/17/B%E6%A0%91/49.png" style="zoom: 67%;"></p>
<h2 id="B-树的插入"><a href="#B-树的插入" class="headerlink" title="B+树的插入"></a>B+树的插入</h2><p>​        m阶B+树的插入， 仅在最后一层结点插入， 因为除了最后一层结点， 其他非终端结点都表示索引。 又因为m阶B+树的<strong>关键字个数要求不超过m</strong>, 如果插入后结点的关键字个数超过m, 则发生上溢, 要分裂操作。 只不过分裂时, 和B树的分裂不同, 上升到父结点的关键字, 子结点中仍然保留。<br>​        刚刚发生上溢的结点V,插入之前满足条件（关键字个数小于等于 m), 插入之后大于m, 因此 V结点现在恰好有 m+1 个关键字。 将该关键字分裂操作： 取V结点中间的关键字 $K_s(s=(m+l)/2)$ , 将$K_s$上升到其父结点 P, 左右两部分作为$K_s$的左右孩子，如图 10-61 所示。</p>
<p><img src="/2020/06/17/B%E6%A0%91/50.png" style="zoom: 67%;"></p>
<p>​        中间关键字上升到父结点后，需要检杳父结点是否发生上溢，如果发生上溢， 则继续分裂， 一直向上传递， 最远到达树根。 如果根结点发生上溢，则要以下特殊处理：</p>
<p>​        树根分裂操作而要分裂的两个于结点的<strong>最大关键字一起上升</strong>，生成 个新的结点作为新树根， 此时树高增1。 如下所示。</p>
<p><img src="/2020/06/17/B%E6%A0%91/51.png" style="zoom: 67%;"></p>
<h3 id="未发生上溢"><a href="#未发生上溢" class="headerlink" title="未发生上溢"></a>未发生上溢</h3><p><img src="/2020/06/17/B%E6%A0%91/52.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/17/B%E6%A0%91/53.png" style="zoom: 67%;"></p>
<h3 id="发生上溢"><a href="#发生上溢" class="headerlink" title="发生上溢"></a>发生上溢</h3><p><img src="/2020/06/17/B%E6%A0%91/54.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/17/B%E6%A0%91/55.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/17/B%E6%A0%91/56.png" style="zoom: 67%;"></p>
<h3 id="特殊情况（树根分裂）"><a href="#特殊情况（树根分裂）" class="headerlink" title="特殊情况（树根分裂）"></a>特殊情况（树根分裂）</h3><p><img src="/2020/06/17/B%E6%A0%91/57.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/17/B%E6%A0%91/58.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/17/B%E6%A0%91/59.png" style="zoom: 67%;"></p>
<h3 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h3><p><img src="/2020/06/17/B%E6%A0%91/60.png" style="zoom: 67%;"></p>
<ul>
<li><p>50 插入，不分裂</p>
</li>
<li><p>82插入，分裂，第二层变为70，80，85，98，再次发生分裂。树根变为 65 80 98</p>
</li>
</ul>
<p><img src="/2020/06/17/B%E6%A0%91/61.png" style="zoom: 67%;"></p>
<ul>
<li>95插入，不分裂</li>
</ul>
<p><strong>记住，如果插入的关键字比较大，一定要更新一个索引</strong></p>
<h2 id="B-树的删除"><a href="#B-树的删除" class="headerlink" title="B+树的删除"></a>B+树的删除</h2><p>m阶B+树的删除只在最后一层进行，首先通过查找确定待删除关键字的位置，删除之，然后判断该结点是否发生下溢，还要判断是否需要更新父结点的关键字。如果关键字个数小于 $\lceil m/2\rceil$ 时发生下溢。如果发生下溢则需要像B- 树那样左借、右借或合并操作解除下溢。解除下溢时要特别注意父结点中的最大关键字更新。</p>
<h3 id="未发生下溢"><a href="#未发生下溢" class="headerlink" title="未发生下溢"></a>未发生下溢</h3><p>在一棵3阶B+树中删除85，首先查找到85的位置，删除之。删除后未发生下溢，但是该孩子节点的最大关键字为80，需要更新其父结点中该位置关键字为80.</p>
<p><img src="/2020/06/17/B%E6%A0%91/63.png" style="zoom: 67%;"></p>
<h3 id="发生下溢（右借或左借）"><a href="#发生下溢（右借或左借）" class="headerlink" title="发生下溢（右借或左借）"></a>发生下溢（右借或左借）</h3><p>在一棵3阶B+树中删除68，首先查找到68的位置，删除之。删除后该节点关键字个数小于2，因此发生下溢，左兄弟只有2个关键字不可以借，右兄弟有3 个关键字，向右兄弟可以借一个，然后更新父节点</p>
<p><img src="/2020/06/17/B%E6%A0%91/64.png" style="zoom: 67%;"></p>
<p>可以向右兄弟借一个关键字78.借后更新父节点该位置最大的关键字为78.如图</p>
<p><img src="/2020/06/17/B%E6%A0%91/65.png" style="zoom: 67%;"></p>
<h3 id="发生下溢-合并"><a href="#发生下溢-合并" class="headerlink" title="发生下溢(合并)"></a>发生下溢(合并)</h3><p><img src="/2020/06/17/B%E6%A0%91/66.png" style="zoom: 67%;"></p>
<p><img src="/2020/06/17/B%E6%A0%91/67.png" style="zoom: 67%;"></p>
<p> <img src="/2020/06/17/B%E6%A0%91/68.png" style="zoom: 100%;"></p>
<h3 id="发生下溢-树根"><a href="#发生下溢-树根" class="headerlink" title="发生下溢(树根)"></a>发生下溢(树根)</h3><p><img src="/2020/06/17/B%E6%A0%91/69.png" style="zoom: 100%;"></p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p><img src="/2020/06/17/B%E6%A0%91/70.png" style="zoom: 100%;"></p>
<p><img src="/2020/06/17/B%E6%A0%91/71.png" style="zoom: 100%;"></p>
<p><img src="/2020/06/17/B%E6%A0%91/72.png" style="zoom: 100%;"></p>
<p><img src="/2020/06/17/B%E6%A0%91/73.png" style="zoom: 100%;"></p>
<h2 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h2><p>含有 n个关键字的m阶B+树，查找、插入和删除操作的时间复杂度均为树的高度$O(\log_mn)$ </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/06/16/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/16/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" class="post-title-link" itemprop="url">微分方程基本概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-16 20:29:53 / Modified: 21:09:02" itemprop="dateCreated datePublished" datetime="2020-06-16T20:29:53+08:00">2020-06-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="微分方程基本概念"><a href="#微分方程基本概念" class="headerlink" title="微分方程基本概念"></a>微分方程基本概念</h1><p><img src="/2020/06/16/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/1.png" style="zoom: 67%;"></p>
<h2 id="几何问题"><a href="#几何问题" class="headerlink" title="几何问题"></a>几何问题</h2><p><img src="/2020/06/16/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2.png" style="zoom: 67%;"></p>
<h2 id="物理问题"><a href="#物理问题" class="headerlink" title="物理问题"></a>物理问题</h2><p><img src="/2020/06/16/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/3.png" style="zoom: 60%;"></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><img src="/2020/06/16/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/4.png" style="zoom: 60%;"></p>
<p><img src="/2020/06/16/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/5.png" style="zoom: 60%;"></p>
<p><img src="/2020/06/16/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/6.png" style="zoom: 60%;"></p>
<p><img src="/2020/06/16/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/7.png" style="zoom: 60%;"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/06/16/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9C%A8%E4%BD%9C%E4%B8%9A%E5%BD%93%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/16/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9C%A8%E4%BD%9C%E4%B8%9A%E5%BD%93%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">数据可视化在作业当中的应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-16 17:19:56" itemprop="dateCreated datePublished" datetime="2020-06-16T17:19:56+08:00">2020-06-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-20 21:07:32" itemprop="dateModified" datetime="2020-06-20T21:07:32+08:00">2020-06-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据可视化在作业当中的应用"><a href="#数据可视化在作业当中的应用" class="headerlink" title="数据可视化在作业当中的应用"></a>数据可视化在作业当中的应用</h1><p>数据可视化我用了d3去实现</p>
<h2 id="home-js"><a href="#home-js" class="headerlink" title="home.js"></a>home.js</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">'../components/layout'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./style.scss'</span>;</span><br><span class="line"><span class="keyword">import</span> Api <span class="keyword">from</span> <span class="string">'../../js/Api'</span>;</span><br><span class="line"><span class="keyword">import</span> Util <span class="keyword">from</span> <span class="string">'../../js/Util'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> WordCloud <span class="keyword">from</span> <span class="string">'react-d3-cloud'</span>;</span><br><span class="line"><span class="comment">//这里运用了d3中的词云工具,下面是定义每条信息的大小的一个函数</span></span><br><span class="line"><span class="keyword">const</span> fontSizeMapper = <span class="function">(<span class="params">word</span>) =&gt;</span> <span class="built_in">Math</span>.log2(word.value) * <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      list: [],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.initTableData();</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">//我们要做的就是随机生成豆瓣中的简短介绍，然后加入到一个数组当中</span></span><br><span class="line">    <span class="comment">//再利用worldcould组件来生成词云</span></span><br><span class="line">  initTableData(current, params) &#123;</span><br><span class="line">    <span class="keyword">const</span> token = Util.getToken();</span><br><span class="line">    Api.get(<span class="string">`/douban/getAll`</span>, &#123;</span><br><span class="line">      headers: &#123; <span class="attr">Authorization</span>: <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span> &#125;,</span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (res.data) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; data &#125; = res.data || &#123;&#125;;</span><br><span class="line">        <span class="keyword">const</span> result = [];</span><br><span class="line">        data.forEach(<span class="function">(<span class="params">element</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//把每条信息插入，信息源时豆瓣表格中的quote，value是其大小</span></span><br><span class="line">          result.push(&#123; <span class="attr">text</span>: element.quote, <span class="attr">value</span>: <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">100</span>) &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          list: result,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//render中渲染出词云组件</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; list &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">const</span> &#123; userData &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="comment">// const &#123; name &#125; = userData;</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Layout&gt;</span><br><span class="line">          &lt;div className=<span class="string">"word-cloud"</span>&gt;</span><br><span class="line">            &lt;WordCloud width=&#123;<span class="number">1200</span>&#125; data=&#123;list&#125; fontSizeMapper=&#123;fontSizeMapper&#125; rotate=&#123;<span class="number">0</span>&#125; /&gt;,</span><br><span class="line">          &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Layout&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const mapStateToProps = (state) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  return &#123;</span></span><br><span class="line"><span class="regexp">    userData: state.userData.data,</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default connect(mapStateToProps, null)(Home);</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到每次的都是不一样的</p>
<p><img src="/2020/06/16/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9C%A8%E4%BD%9C%E4%B8%9A%E5%BD%93%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/1.png" style="zoom:80%;"></p>
<p><img src="/2020/06/16/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9C%A8%E4%BD%9C%E4%B8%9A%E5%BD%93%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/2.png" style="zoom:80%;"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://jasonxqh.github.io/2020/06/15/CssandSass/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Jason">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jason‘s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/15/CssandSass/" class="post-title-link" itemprop="url">CssandSass</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-15 23:58:45" itemprop="dateCreated datePublished" datetime="2020-06-15T23:58:45+08:00">2020-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-25 16:44:50" itemprop="dateModified" datetime="2021-01-25T16:44:50+08:00">2021-01-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CssandSass"><a href="#CssandSass" class="headerlink" title="CssandSass"></a>CssandSass</h1><p>学习视频：<a href="https://www.youtube.com/watch?v=_a5j7KoflTs&amp;list=WL&amp;index=6" target="_blank" rel="noopener">https://www.youtube.com/watch?v=_a5j7KoflTs&amp;list=WL&amp;index=6</a></p>
<p>Documentation：<a href="https://sass-lang.com/documentation" target="_blank" rel="noopener">https://sass-lang.com/documentation</a></p>
<p>引用的一些教程： w3cschool,菜鸟教程</p>
<h3 id="Install-Setup-Live-Sass-Compiler-VS-Code-Extension"><a href="#Install-Setup-Live-Sass-Compiler-VS-Code-Extension" class="headerlink" title="Install/Setup Live Sass Compiler VS Code Extension"></a>Install/Setup Live Sass Compiler VS Code Extension</h3><p><strong>Live Sass Compiler</strong></p>
<p><img src="/2020/06/15/CssandSass/1.png" style="zoom:80%;"></p>
<p>在setting.json中添加设置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"liveSassCompile.settings.formats"</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"format"</span>: <span class="string">"expanded"</span>,</span><br><span class="line">    <span class="string">"extensionName"</span>: <span class="string">".css"</span>,</span><br><span class="line">    <span class="string">"savePath"</span>: <span class="string">"/dist/css"</span></span><br><span class="line">  &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<p>新建dist文件夹，里面新建index.html文件，引入css/main.css</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"./css/main.css"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Sass Tutorial<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后新建scss文件夹，里面新建一个main.css文件</p>
<p>点击 下面的sass watching，那么就会在dist文件夹下自动生成编译好的css文件，这样在scss中做了改变，main.css中也会同步编译，转换成html读得懂的css文件</p>
<p><img src="/2020/06/15/CssandSass/3.png" style="zoom:80%;"></p>
<h3 id="Folder-Structure-Sass-Syntax"><a href="#Folder-Structure-Sass-Syntax" class="headerlink" title="Folder Structure / Sass Syntax"></a>Folder Structure / Sass Syntax</h3><p><img src="/2020/06/15/CssandSass/2.png" style="zoom:80%;"></p>
<p><img src="/2020/06/15/CssandSass/4.png" style="zoom:80%;"></p>
<h3 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h3><p><code>sass</code>让人们受益的一个重要特性就是它为<code>css</code>引入了变量。你可以把反复使用的<code>css</code>属性值定义成变量，然后通过变量名来引用它们，而无需重复书写这一属性值。或者，对于仅使用过一次的属性值，你可以赋予其一个易懂的变量名，让人一眼就知道这个属性值的用途。</p>
<p><code>sass</code>使用<script type="math/tex">`符号来标识变量(老版本的`sass`使用`!`来标识变量。改成`</script>是多半因为<code>!highlight-color</code>看起来太丑了。)，比如<script type="math/tex">highlight-color`和`$sidebar-width`。为什么选择`</script>符号呢？因为它好认、更具美感，且在CSS中并无他用，不会导致与现存或未来的<code>css</code>语法冲突。</p>
<p><code>sass</code>变量的声明和<code>css</code>属性的声明很像:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$highlight-color: #F90;</span><br></pre></td></tr></table></figure>
<p>这意味着变量<code>$highlight-color</code>现在的值是<code>#F90</code>。任何可以用作<code>css</code>属性值的赋值都可以用作<code>sass</code>的变量值，甚至是以空格分割的多个属性值，如<code>$basic-border: 1px solidblack;</code>，或以逗号分割的多个属性值，如<code>$plain-font: &quot;Myriad Pro&quot;、Myriad、&quot;HelveticaNeue&quot;、Helvetica、&quot;Liberation Sans&quot;、Arial和sans-serif; sans-serif;</code>。这时变量还没有生效，除非你引用这个变量——我们很快就会了解如何引用。</p>
<p>与<code>CSS</code>属性不同，变量可以在<code>css</code>规则块定义之外存在。当变量定义在<code>css</code>规则块内，那么该变量只能在此规则块内使用。如果它们出现在任何形式的<code>{...}</code>块中(如<code>@media</code>或者<code>@font-face</code>块)，情况也是如此:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$nav-color</span>: <span class="number">#F90</span>;</span><br><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="variable">$width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$nav-color</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译后</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#F90</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，<code>$nav-color</code>这个变量定义在了规则块外边，所以在这个样式表中都可以像<code>nav</code>规则块那样引用它。<code>$width</code>这个变量定义在了<code>nav</code>的<code>{ }</code>规则块内，所以它<strong>只能</strong>在<code>nav</code>规则块内使用。这意味着是你可以在样式表的其他地方定义和使用<code>$width</code>变量，不会对这里造成影响。</p>
<p>凡是<code>css</code>属性的标准值可存在的地方，变量就可以使用。<code>css</code>生成时，变量会被它们的值所替代。之后，如果你需要一个不同的值，只需要改变这个变量的值，则所有引用此变量的地方生成的值都会随之改变。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$highlight-color</span>: <span class="number">#F90</span>;</span><br><span class="line"><span class="selector-class">.selected</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="variable">$highlight-color</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译后</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.selected</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#F90</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看上边示例中的<code>$highlight-color</code>变量，它被直接赋值给<code>border</code>属性，当这段代码被编译输出<code>css</code>时，<code>$highlight-color</code>会被<code>#F90</code>这一颜色值所替代。产生的效果就是给<code>selected</code>这个类一条1像素宽、实心且颜色值为<code>#F90</code>的边框。</p>
<p>在声明变量时，变量值也可以引用其他变量。当你通过粒度区分，为不同的值取不同名字时，这相当有用。下例在独立的颜色值粒度上定义了一个变量，且在另一个更复杂的边框值粒度上也定义了一个变量:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$highlight-color</span>: <span class="number">#F90</span>;</span><br><span class="line"><span class="variable">$highlight-border</span>: <span class="number">1px</span> solid <span class="variable">$highlight-color</span>;</span><br><span class="line"><span class="selector-class">.selected</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="variable">$highlight-border</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译后</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.selected</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#F90</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，<code>$highlight-border</code>变量的声明中使用了<code>$highlight-color</code>这个变量。产生的效果就跟你直接为<code>border</code>属性设置了一个<code>1px</code> <code>$highlight-color solid</code>的值是一样的。</p>
<h3 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h3><p><strong>Sass Maps的函数 : <code>map-get($map,$key)</code></strong></p>
<p><code>map-get($map,$key)</code> 函数的作用是根据 <strong>$key</strong> 参数，返回 ​<strong>$key</strong> 在 ​<strong>$map</strong> 中对应的 value 值。如果 <strong>$key</strong> 不存在 <code>$map</code>中，将返回 null 值。此函数包括两个参数：</p>
<ul>
<li><code>$map：</code>定义好的 map。</li>
<li><code>$key：</code>需要遍历的 key。</li>
</ul>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我这里定义了四个变量，其中最后一个是一个map</span></span><br><span class="line"><span class="variable">$primary-color</span>: <span class="number">#272727</span>;</span><br><span class="line"><span class="variable">$accent-color</span>: <span class="number">#ff652f</span>;</span><br><span class="line"><span class="variable">$text-color</span>: <span class="number">#fff</span>;</span><br><span class="line"><span class="variable">$font-weights</span>: (</span><br><span class="line">  <span class="string">"regular"</span>: <span class="number">400</span>,</span><br><span class="line">  <span class="string">"medium"</span>: <span class="number">500</span>,</span><br><span class="line">  <span class="string">"bold"</span>: <span class="number">700</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//要获取font-weights中的东西，我们需要用map-get函数</span></span><br><span class="line"><span class="comment">//第一个参数是这个map，第二个参数是map中的key</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="variable">$primary-color</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$text-color</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: map-get(<span class="variable">$font-weights</span>, bold);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在main.css 中编译结果为：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#272727</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*# sourceMappingURL=main.css.map */</span></span><br></pre></td></tr></table></figure>
<h3 id="Nesting"><a href="#Nesting" class="headerlink" title="Nesting"></a>Nesting</h3><h4 id="父选择器的标识符-amp"><a href="#父选择器的标识符-amp" class="headerlink" title="父选择器的标识符&amp;"></a>父选择器的标识符&amp;</h4><p>一般情况下，<code>sass</code>在解开一个嵌套规则时就会把父选择器(<code>#content</code>)通过一个空格连接到子选择器的前边(<code>article</code>和<code>aside</code>)形成(<code>#content article</code>和<code>#content aside</code>)。这种在CSS里边被称为后代选择器，因为它选择ID为<code>content</code>的元素内所有命中选择器<code>article</code>和<code>aside</code>的元素。但在有些情况下你却不会希望<code>sass</code>使用这种后代选择器的方式生成这种连接。</p>
<p>最常见的一种情况是当你为链接之类的元素写<code>:hover</code>这种伪类时，你并不希望以后代选择器的方式连接。比如说，下面这种情况<code>sass</code>就无法正常工作:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">  <span class="selector-pseudo">:hover</span> &#123; <span class="attribute">color</span>: red &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这意味着<code>color: red</code>这条规则将会被应用到选择器<code>article a :hover</code>，<code>article</code>元素内链接的所有子元素在被<code>hover</code>时都会变成红色。这是不正确的！你想把这条规则应用到超链接自身，而后代选择器的方式无法帮你实现。</p>
<p>解决之道为使用一个特殊的<code>sass</code>选择器，即<strong>父选择器</strong>。在使用嵌套规则时，父选择器能对于嵌套规则如何解开提供更好的控制。它就是一个简单的<code>&amp;</code>符号，且可以放在任何一个选择器可出现的地方，比如<code>h1</code>放在哪，它就可以放在哪。</p>
<p>&amp; 就代表着父选择器， &amp; = article a</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span> &#123; <span class="attribute">color</span>: red &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当包含父选择器标识符的嵌套规则被打开时，它不会像后代选择器那样进行拼接，而是<code>&amp;</code>被父选择器直接替换:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">a</span> &#123; <span class="attribute">color</span>: blue &#125;</span><br><span class="line">article a:hover &#123; color: red &#125;</span><br></pre></td></tr></table></figure>
<p>在为父级选择器添加<code>:hover</code>等伪类时，这种方式非常有用。同时父选择器标识符还有另外一种用法，你可以在父选择器之前添加选择器。举例来说，当用户在使用IE浏览器时，你会通过<code>JavaScript</code>在``标签上添加一个ie的类名，为这种情况编写特殊的样式如下:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#content</span> <span class="selector-tag">aside</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="selector-tag">body</span><span class="selector-class">.ie</span> &amp; &#123; <span class="attribute">color</span>: green &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*编译后*/</span><br><span class="line"><span class="number">#c</span>ontent aside &#123;color: red&#125;;</span><br><span class="line"><span class="selector-tag">body</span><span class="selector-class">.ie</span> <span class="selector-id">#content</span> <span class="selector-tag">aside</span> &#123; <span class="attribute">color</span>: green &#125;</span><br></pre></td></tr></table></figure>
<p><code>sass</code>在选择器嵌套上是非常智能的，即使是带有父选择器的情况。当<code>sass</code>遇到群组选择器(由多个逗号分隔开的选择器形成)也能完美地处理这种嵌套。</p>
<h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p>main.scss</p>
<p> <code>&amp;_paragraph</code> 在编译完成后 是<code>.main_paragraph</code></p>
<p>但是从index.html中我们可以看到我们想选择的是 class = main包含着的 class= main_paragraph 的段落</p>
<p>所以我们可以这么修改</p>
<p><code>#{&amp;}_paragraph</code> 这叫 interpolation 现在 css文件中 变成了 <code>.main .main_paragraph</code> </p>
<p>此外我们还可以在嵌套中利用嵌套，那么就是在 <code>#{&amp;}_paragraph</code> 中再用 &amp;</p>
<p>因为这里只是设置一个伪类，那么不需要 #{&amp;}，直接相连结即可, <code>&amp;:hover</code>效果如下</p>
<p><code>.main .main_paragraph:hover</code></p>
<p>也就是现在当我鼠标移动到这段文字上的时候，文字会变成粉色</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">80%</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  #&#123;&amp;&#125;_paragraph &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: map-get(<span class="variable">$font-weights</span>, bold);</span><br><span class="line"></span><br><span class="line">    &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: pink;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>index.html</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"./css/main.css"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Sass Tutorial<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"main_paragraph"</span>&gt;</span>Lorem, ipsum dolor sit amet consectetur adipisicing elit. Possimus inventore sit earum, cum ipsa magni, perspiciatis eos aliquam id eius sed, totam esse? Optio in adipisci earum numquam magnam fugit?<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>main.css</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#272727</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">80%</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main</span> <span class="selector-class">.main_paragraph</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main</span> <span class="selector-class">.main_paragraph</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*# sourceMappingURL=main.css.map */</span></span><br></pre></td></tr></table></figure>
<h4 id="群组选择器的嵌套"><a href="#群组选择器的嵌套" class="headerlink" title="群组选择器的嵌套"></a>群组选择器的嵌套</h4><p>在<code>CSS</code>里边，选择器<code>h1</code> <code>h2</code>和<code>h3</code>会同时命中h1元素、h2元素和h3元素。与此类似，<code>.button</code> <code>button</code>会命中button元素和类名为.button的元素。这种选择器称为群组选择器。群组选择器的规则会对命中群组中<strong>任何一个</strong>选择器的元素生效。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.button</span>, <span class="selector-tag">button</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当看到上边这段代码时，你可能还没意识到会有重复性的工作。但会很快发现:如果你需要在一个特定的容器元素内对这样一个群组选择器进行修饰，情况就不同了。<code>css</code>的写法会让你在群组选择器中的每一个选择器前都重复一遍容器元素的选择器。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> <span class="selector-tag">h1</span>, <span class="selector-class">.container</span> <span class="selector-tag">h2</span>, <span class="selector-class">.container</span> <span class="selector-tag">h3</span> &#123; </span><br><span class="line"><span class="attribute">margin-bottom</span>: .<span class="number">8em</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非常幸运，<code>sass</code>的嵌套特性在这种场景下也非常有用。当<code>sass</code>解开一个群组选择器规则内嵌的规则时，它会把每一个内嵌选择器的规则都正确地解出来:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span> &#123;<span class="attribute">margin-bottom</span>: .<span class="number">8em</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先<code>sass</code>将<code>.container</code>和<code>h1</code>  <code>.container</code>和<code>h2</code>  <code>.container</code>和<code>h3</code>分别组合，然后将三者重新组合成一个群组选择器，生成你前边看到的普通<code>css</code>样式。</p>
<p>对于内嵌在群组选择器内的嵌套规则，处理方式也一样:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nav</span>, <span class="selector-tag">aside</span> &#123;</span><br><span class="line">  <span class="selector-tag">a</span> &#123;<span class="attribute">color</span>: blue&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先<code>sass</code>将<code>nav</code>和<code>a</code> <code>aside</code>和<code>a</code>分别组合，然后将二者重新组合成一个群组选择器:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">a</span>, <span class="selector-tag">aside</span> <span class="selector-tag">a</span> &#123;<span class="attribute">color</span>: blue&#125;</span><br></pre></td></tr></table></figure>
<p>处理这种群组选择器规则嵌套上的强大能力，正是<code>sass</code>在减少重复敲写方面的贡献之一。尤其在当嵌套级别达到两层甚至三层以上时，与普通的<code>css</code>编写方式相比，只写一遍群组选择器大大减少了工作量。</p>
<p>有利必有弊，你需要特别注意群组选择器的规则嵌套生成的<code>css</code>。虽然<code>sass</code>让你的样式表看上去很小，但实际生成的<code>css</code>却可能非常大，这会降低网站的速度。</p>
<p>关于选择器嵌套的最后一个方面，我们看看<code>sass</code>如何处理组合选择器，比如&gt;、+和~的使用。你将看到，这种场景下你甚至无需使用父选择器标识符。</p>
<h4 id="子组合选择器和同层组合选择器：-gt-、-和"><a href="#子组合选择器和同层组合选择器：-gt-、-和" class="headerlink" title="子组合选择器和同层组合选择器：&gt;、+和~"></a>子组合选择器和同层组合选择器：&gt;、+和~</h4><p>上边这三个组合选择器必须和其他选择器配合使用，以指定浏览器仅选择某种特定上下文中的元素。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">section</span> &#123; <span class="attribute">margin</span>: <span class="number">5px</span> &#125;</span><br><span class="line">article &gt; section &#123; border: <span class="number">1px</span> solid <span class="number">#ccc</span> &#125;</span><br></pre></td></tr></table></figure>
<p>你可以用<strong>子组合选择器</strong>&gt;选择一个元素的直接子元素。上例中，第一个选择器会选择article下的所有命中section选择器的元素。第二个选择器只会选择article下<strong>紧跟着的</strong>子元素中名为section选择器的元素。</p>
<p>在下例中，你可以用<strong>同层相邻组合选择器</strong><code>+</code>选择<code>header</code>元素后紧跟的<code>p</code>元素:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">header</span> + <span class="selector-tag">p</span> &#123; <span class="attribute">font-size</span>: <span class="number">1.1em</span> &#125;</span><br></pre></td></tr></table></figure>
<p>你也可以用<strong>同层全体组合选择器</strong><code>~</code>，选择所有跟在<code>article</code>后的同层<code>article</code>元素，不管它们之间隔了多少其他元素:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span> ~ <span class="selector-tag">article</span> &#123; <span class="attribute">border-top</span>: <span class="number">1px</span> dashed <span class="number">#ccc</span> &#125;</span><br></pre></td></tr></table></figure>
<p>这些组合选择器可以毫不费力地应用到<code>sass</code>的规则嵌套中。可以把它们放在外层选择器后边，或里层选择器前边:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">  ~ <span class="selector-tag">article</span> &#123; <span class="attribute">border-top</span>: <span class="number">1px</span> dashed <span class="number">#ccc</span> &#125;</span><br><span class="line">  &gt; section &#123; background: <span class="number">#eee</span> &#125;</span><br><span class="line">  dl &gt; &#123;</span><br><span class="line">    dt &#123; color: <span class="number">#333</span> &#125;</span><br><span class="line">    dd &#123; color: <span class="number">#555</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  nav + &amp; &#123; margin-top: <span class="number">0</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sass</code>会如你所愿地将这些嵌套规则一一解开组合在一起:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span> ~ <span class="selector-tag">article</span> &#123; <span class="attribute">border-top</span>: <span class="number">1px</span> dashed <span class="number">#ccc</span> &#125;</span><br><span class="line">article &gt; footer &#123; background: <span class="number">#eee</span> &#125;</span><br><span class="line">article dl &gt; dt &#123; color: <span class="number">#333</span> &#125;</span><br><span class="line">article dl &gt; dd &#123; color: <span class="number">#555</span> &#125;</span><br><span class="line">nav + article &#123; margin-top: <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure>
<p>在<code>sass</code>中，不仅仅<code>css</code>规则可以嵌套，对属性进行嵌套也可以减少很多重复性的工作。</p>
<h4 id="嵌套属性"><a href="#嵌套属性" class="headerlink" title="嵌套属性"></a>嵌套属性</h4><p>在<code>sass</code>中，除了CSS选择器，属性也可以进行嵌套。尽管编写属性涉及的重复不像编写选择器那么糟糕，但是要反复写<code>border-style</code> <code>border-width</code> <code>border-color</code>以及<code>border-*</code>等也是非常烦人的。在<code>sass</code>中，你只需敲写一遍<code>border</code>:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nav</span> &#123; </span><br><span class="line">  <span class="attribute">border</span>: &#123;</span><br><span class="line">  style: solid;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ccc</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嵌套属性的规则是这样的:把属性名从中划线-的地方断开，在根属性后边添加一个冒号:，紧跟一个<code>{ }</code>块，把子属性部分写在这个<code>{ }</code>块中。就像<code>css</code>选择器嵌套一样，<code>sass</code>会把你的子属性一一解开，把根属性和子属性部分通过中划线-连接起来，最后生成的效果与你手动一遍遍写的<code>css</code>样式一样:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于属性的缩写形式，你甚至可以像下边这样来嵌套，指明例外规则:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span> &#123;</span><br><span class="line">  left: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这比下边这种同等样式的写法要好:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>属性和选择器嵌套是非常伟大的特性，因为它们不仅大大减少了你的编写量，而且通过视觉上的缩进使你编写的样式结构更加清晰，更易于阅读和开发。</p>
<p>即便如此，随着你的样式表变得越来越大，这种写法也很难保持结构清晰。有时，处理这种大量样式的唯一方法就是把它们分拆到多个文件中。<code>sass</code>通过对<code>css</code>原有<code>@import</code>规则的改进直接支持了这一特性。</p>
<h3 id="Partials"><a href="#Partials" class="headerlink" title="Partials"></a>Partials</h3><p>当通过<code>@import</code>把<code>sass</code>样式分散到多个文件时，你通常只想生成少数几个<code>css</code>文件。那些专门为<code>@import</code>命令而编写的<code>sass</code>文件，并不需要生成对应的独立<code>css</code>文件，这样的<code>sass</code>文件称为局部文件。对此，<code>sass</code>有一个<strong>特殊的约定</strong>来命名这些文件。</p>
<p>此约定即，<code>sass</code>局部文件的文件名以下划线开头。这样，<code>sass</code>就不会在编译时单独编译这个文件输出<code>css</code>，而只把这个文件用作导入。当你<code>@import</code>一个局部文件时，还可以不写文件的全名，即省略文件名开头的下划线。举例来说，你想导入<code>themes/_night-sky.scss</code>这个局部文件里的变量，你只需在样式表中写<code>@import</code> <code>&quot;themes/night-sky&quot;;</code>。</p>
<p>比如，我们新建 <code>_reset.scss</code> 和<code>_variable.scss</code></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$primary-color</span>: <span class="number">#272727</span>;</span><br><span class="line"><span class="variable">$accent-color</span>: <span class="number">#ff652f</span>;</span><br><span class="line"><span class="variable">$text-color</span>: <span class="number">#fff</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$font-weights</span>: (</span><br><span class="line">  <span class="string">"regular"</span>: <span class="number">400</span>,</span><br><span class="line">  <span class="string">"medium"</span>: <span class="number">500</span>,</span><br><span class="line">  <span class="string">"bold"</span>: <span class="number">700</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>在main.scss中通过 @import 引入</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">"./reset"</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">"./variable"</span>;</span><br></pre></td></tr></table></figure>
<p>局部文件可以被多个不同的文件引用。当一些样式需要在多个页面甚至多个项目中使用时，这非常有用。在这种情况下，有时需要在你的样式表中对导入的样式稍作修改，<code>sass</code>有一个功能刚好可以解决这个问题，即默认变量值。</p>
<h4 id="默认变量值"><a href="#默认变量值" class="headerlink" title="默认变量值"></a>默认变量值</h4><p>一般情况下，你反复声明一个变量，只有<strong>最后一处</strong>声明有效且它会覆盖前边的值。举例说明:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$link-color</span>: blue;</span><br><span class="line"><span class="variable">$link-color</span>: red;</span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: <span class="variable">$link-color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上边的例子中，超链接的<code>color</code>会被设置为<code>red</code>。这可能并不是你想要的结果，假如你写了一个可被他人通过<code>@import</code>导入的<code>sass</code>库文件，你可能希望导入者可以定制修改<code>sass</code>库文件中的某些值。使用<code>sass</code>的<code>!default</code>标签可以实现这个目的。它很像<code>css</code>属性中<code>!important</code>标签的对立面，不同的是<code>!default</code>用于变量，含义是:如果这个变量被声明赋值了，那就用它声明的值，否则就用这个默认值。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$fancybox-width</span>: <span class="number">400px</span> !default;</span><br><span class="line"><span class="selector-class">.fancybox</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="variable">$fancybox-width</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上例中，如果用户在导入你的<code>sass</code>局部文件之前声明了一个<code>$fancybox-width</code>变量，那么你的局部文件中对<code>$fancybox-width</code>赋值<code>400px</code>的操作就无效。如果用户没有做这样的声明，则<code>$fancybox-width</code>将默认为<code>400px</code>。</p>
<p>接下来我们将学习嵌套导入，它允许只在某一个选择器的范围内导入<code>sass</code>局部文件。</p>
<h4 id="嵌套导入"><a href="#嵌套导入" class="headerlink" title="嵌套导入"></a>嵌套导入</h4><p>跟原生的<code>css</code>不同，<code>sass</code>允许<code>@import</code>命令写在<code>css</code>规则内。这种导入方式下，生成对应的<code>css</code>文件时，局部文件会被直接插入到<code>css</code>规则内导入它的地方。举例说明，有一个名为<code>_blue-theme.scss</code>的局部文件，内容如下:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">aside</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后把它导入到一个CSS规则内，如下所示:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.blue-theme</span> &#123;<span class="keyword">@import</span> <span class="string">"blue-theme"</span>&#125;</span><br><span class="line"></span><br><span class="line">//生成的结果跟你直接在.blue-theme选择器内写_blue-theme.scss文件的内容完全一样。</span><br><span class="line"></span><br><span class="line">.blue-theme &#123;</span><br><span class="line">  <span class="selector-tag">aside</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: blue;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被导入的局部文件中定义的所有变量和混合器，也会在这个规则范围内生效。这些变量和混合器不会全局有效，这样我们就可以通过嵌套导入只对站点中某一特定区域运用某种颜色主题或其他通过变量配置的样式。</p>
<p>有时，可用<code>css</code>原生的<code>@import</code>机制，在浏览器中下载必需的<code>css</code>文件。<code>sass</code>也提供了几种方法来达成这种需求。</p>
<h4 id="原生的CSS导入"><a href="#原生的CSS导入" class="headerlink" title="原生的CSS导入"></a>原生的CSS导入</h4><p>由于<code>sass</code>兼容原生的<code>css</code>，所以它也支持原生的<code>CSS@import</code>。尽管通常在<code>sass</code>中使用<code>@import</code>时，<code>sass</code>会尝试找到对应的<code>sass</code>文件并导入进来，但在下列三种情况下会生成原生的<code>CSS@import</code>，尽管这会造成浏览器解析<code>css</code>时的额外下载:</p>
<ul>
<li>被导入文件的名字以<code>.css</code>结尾；</li>
<li>被导入文件的名字是一个URL地址(比如<a href="http://www.sass.hk/css/css.css)，由此可用谷歌字体API提供的相应服务；" target="_blank" rel="noopener">http://www.sass.hk/css/css.css)，由此可用谷歌字体API提供的相应服务；</a></li>
<li>被导入文件的名字是<code>CSS</code>的url()值。</li>
</ul>
<p>这就是说，你不能用<code>sass</code>的<code>@import</code>直接导入一个原始的<code>css</code>文件，因为<code>sass</code>会认为你想用<code>css</code>原生的<code>@import</code>。但是，因为<code>sass</code>的语法完全兼容<code>css</code>，所以你可以把原始的<code>css</code>文件改名为<code>.scss</code>后缀，即可直接导入了。</p>
<p>文件导入是保证<code>sass</code>的代码可维护性和可读性的重要一环。次之但亦非常重要的就是注释了。注释可以帮助样式作者记录写<code>sass</code>的过程中的想法。在原生的<code>css</code>中，注释对于其他人是直接可见的，但<code>sass</code>提供了一种方式可在生成的<code>css</code>文件中按需抹掉相应的注释。</p>
<h3 id="静默注释"><a href="#静默注释" class="headerlink" title="静默注释"></a>静默注释</h3><p><code>css</code>中注释的作用包括帮助你组织样式、以后你看自己的代码时明白为什么这样写，以及简单的样式说明。但是，你并不希望每个浏览网站源码的人都能看到所有注释。</p>
<p><code>sass</code>另外提供了一种不同于<code>css</code>标准注释格式<code>/* ... */</code>的注释语法，即静默注释，其内容不会出现在生成的<code>css</code>文件中。静默注释的语法跟<code>JavaScript``Java</code>等类<code>C</code>的语言中单行注释的语法相同，它们以<code>//</code>开头，注释内容直到行末。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#333</span>; <span class="comment">// 这种注释内容不会出现在生成的css文件中</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>; <span class="comment">/* 这种注释内容会出现在生成的css文件中 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，<code>css</code>的标准注释格式<code>/* ... */</code>内的注释内容亦可在生成的<code>css</code>文件中抹去。当注释出现在原生<code>css</code>不允许的地方，如在<code>css</code>属性或选择器中，<code>sass</code>将不知如何将其生成到对应<code>css</code>文件中的相应位置，于是这些注释被抹掉。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">color</span> <span class="comment">/* 这块注释内容不会出现在生成的css中 */</span>: <span class="number">#333</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1</span>; <span class="comment">/* 这块注释内容也不会出现在生成的css中 */</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><p>font-weights 是上面导入中的map变量</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@function</span> weight(<span class="variable">$weight-name</span>) &#123;</span><br><span class="line">  <span class="keyword">@return</span> map-get(<span class="variable">$font-weights</span>, <span class="variable">$weight-name</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们调用这个function即可</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#&#123;&amp;&#125;_paragraph &#123;</span><br><span class="line">   <span class="attribute">font-weight</span>: weight(bold);</span><br><span class="line"></span><br><span class="line">   &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">     <span class="attribute">color</span>: pink;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h3><p>利用混合器，<strong>可以很容易地在样式表的不同地方共享样式</strong>。如果你发现自己在不停地重复一段样式，那就应该把这段样式构造成优良的混合器，尤其是这段样式本身就是一个逻辑单元，比如说是一组放在一起有意义的属性。</p>
<p>判断一组属性是否应该组合成一个混合器，一条经验法则就是<strong>你能否为这个混合器想出一个好的名字</strong>。如果你能找到一个<strong>很好的短名字来描述这些属性修饰的样式</strong>，比如<code>rounded-corners</code> <code>fancy-font</code>或者<code>no-bullets</code>，那么往往能够构造一个合适的混合器。如果你找不到，这时候构造一个混合器可能并不合适。</p>
<p>混合器在某些方面跟<code>css</code>类很像。都是让你给一大段样式命名，所以在选择使用哪个的时候可能会产生疑惑。最重要的区别就是<strong>类名是在<code>html</code>文件中应用的，而混合器是在样式表中应用的</strong>。这就意味着类名具有语义化含义，而不仅仅是一种展示性的描述:用来描述<code>html</code>元素的含义而不是<code>html</code>元素的外观。而另一方面，混合器是展示性的描述，用来描述一条<code>css</code>规则应用之后会产生怎样的效果。</p>
<p>在之前的例子中，<code>.notice</code>是一个有语义的类名。如果一个<code>html</code>元素有一个<code>notice</code>的类名，就表明了这个<code>html</code>元素的用途:向用户展示提醒信息。<code>rounded-corners</code>混合器是展示性的，它描述了包含它的<code>css</code>规则最终的视觉样式，尤其是边框角的视觉样式。混合器和类配合使用写出整洁的<code>html</code>和<code>css</code>，因为使用语义化的类名亦可以帮你避免重复使用混合器。为了保持你的<code>html</code>和<code>css</code>的易读性和可维护性，在写样式的过程中一定要铭记二者的区别。</p>
<p>有时候仅仅把属性放在混合器中还远远不够，可喜的是，<code>sass</code>同样允许你把<code>css</code>规则放在混合器中。</p>
<h4 id="混合器中的CSS规则"><a href="#混合器中的CSS规则" class="headerlink" title="混合器中的CSS规则"></a>混合器中的CSS规则</h4><p>混合器中不仅可以包含属性，也可以包含<code>css</code>规则，包含选择器和选择器中的属性，如下代码:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> no-bullets &#123;</span><br><span class="line">  <span class="attribute">list-style</span>: none;</span><br><span class="line">  <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">list-style-image</span>: none;</span><br><span class="line">    <span class="attribute">list-style-type</span>: none;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">0px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个包含<code>css</code>规则的混合器通过<code>@include</code>包含在一个父规则中时，在混合器中的规则最终会生成<strong>父规则中的嵌套规则</strong>。举个例子，看看下边的<code>sass</code>代码，这个例子中使用了<code>no-bullets</code>这个混合器:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.plain</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#444</span>;</span><br><span class="line">  <span class="keyword">@include</span> no-bullets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sass</code>的<code>@include</code>指令会<strong>将引入混合器的那行代码替换成混合器里边的内容</strong>。最终，上边的例子如下代码:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.plain</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#444</span>;</span><br><span class="line">  <span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.plain</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">list-style-image</span>: none;</span><br><span class="line">  <span class="attribute">list-style-type</span>: none;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>混合器中的规则甚至可以使用<code>sass</code>的父选择器标识符<code>&amp;</code>。使用起来跟不用混合器时一样，<code>sass</code>解开嵌套规则时，用父规则中的选择器替代<code>&amp;</code>。</p>
<p>如果一个混合器只包含<code>css</code>规则，不包含属性，那么这个混合器就可以在文档的顶部调用，写在所有的<code>css</code>规则之外。如果你只是为自己写一些混合器，这并没有什么大的用途，但是当你使用一个类似于<code>Compass</code>的库时，你会发现，这是提供样式的好方法，原因在于你可以选择是否使用这些样式。</p>
<p>接下来你将学习如何通过给混合器传参数来让混合器变得更加灵活和可重用。</p>
<h4 id="给混合器传参"><a href="#给混合器传参" class="headerlink" title="给混合器传参"></a>给混合器传参</h4><p> 混合器并不一定总得生成相同的样式。可以通过在<code>@include</code>混合器时给混合器传参，来定制混合器生成的精确样式。当<code>@include</code>混合器时，参数其实就是可以赋值给<code>css</code>属性值的变量。如果你写过<code>JavaScript</code>，这种方式跟<code>JavaScript</code>的<code>function</code>很像:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> link-colors(<span class="variable">$normal</span>, <span class="variable">$hover</span>, <span class="variable">$visited</span>) &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$normal</span>;</span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span> &#123; <span class="attribute">color</span>: <span class="variable">$hover</span>; &#125;</span><br><span class="line">  &amp;<span class="selector-pseudo">:visited</span> &#123; <span class="attribute">color</span>: <span class="variable">$visited</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当混合器被<code>@include</code>时，你可以把它当作一个<code>css</code>函数来传参。如果你像下边这样写:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> link-colors(blue, red, green);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Sass最终生成的是:</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span> &#123; <span class="attribute">color</span>: blue; &#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123; <span class="attribute">color</span>: red; &#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123; <span class="attribute">color</span>: green; &#125;</span><br></pre></td></tr></table></figure>
<p>当你@include混合器时，有时候可能会很难区分每个参数是什么意思，参数之间是一个什么样的顺序。为了解决这个问题，<code>sass</code>允许通过语法<code>$name: value</code>的形式指定每个参数的值。这种形式的传参，参数顺序就不必再在乎了，只需要保证没有漏掉参数即可:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="keyword">@include</span> link-colors(</span><br><span class="line">      <span class="variable">$normal</span>: blue,</span><br><span class="line">      <span class="variable">$visited</span>: green,</span><br><span class="line">      <span class="variable">$hover</span>: red</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管给混合器加参数来实现定制很好，但是有时有些参数我们没有定制的需要，这时候也需要赋值一个变量就变成很痛苦的事情了。所以<code>sass</code>允许混合器声明时<strong>给参数赋默认值</strong>。</p>
<h4 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h4><p>为了在<code>@include</code>混合器时不必传入所有的参数，我们可以给参数指定一个默认值。参数默认值使用<code>$name: default-value</code>的声明形式，默认值可以是任何有效的<code>css</code>属性值，甚至是其他参数的引用，如下代码:</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> link-colors(</span><br><span class="line">    //参数列表</span><br><span class="line">    <span class="variable">$normal</span>,</span><br><span class="line">    <span class="variable">$hover</span>: <span class="variable">$normal</span>,</span><br><span class="line">    <span class="variable">$visited</span>: <span class="variable">$normal</span></span><br><span class="line">  )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$normal</span>;</span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span> &#123; <span class="attribute">color</span>: <span class="variable">$hover</span>; &#125;</span><br><span class="line">  &amp;<span class="selector-pseudo">:visited</span> &#123; <span class="attribute">color</span>: <span class="variable">$visited</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果像下边这样调用:<code>@include link-colors(red)</code> <code>$hover</code>和<code>$visited</code>也会被自动赋值为<code>red</code>。</p>
<h3 id="Mixin-Example-1"><a href="#Mixin-Example-1" class="headerlink" title="Mixin Example 1"></a>Mixin Example 1</h3><h3 id="Mixin-Example-1-1"><a href="#Mixin-Example-1-1" class="headerlink" title="Mixin Example 1"></a>Mixin Example 1</h3><h4 id="display"><a href="#display" class="headerlink" title="display"></a>display</h4><p><a href="https://www.runoob.com/cssref/pr-class-display.html" target="_blank" rel="noopener">https://www.runoob.com/cssref/pr-class-display.html</a></p>
<h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><p><a href="https://www.runoob.com/cssref/css3-pr-justify-content.html" target="_blank" rel="noopener">https://www.runoob.com/cssref/css3-pr-justify-content.html</a></p>
<h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><p><a href="https://www.runoob.com/cssref/css3-pr-align-items.html" target="_blank" rel="noopener">https://www.runoob.com/cssref/css3-pr-align-items.html</a></p>
<h4 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h4><p><a href="https://www.runoob.com/cssref/pr-margin.html" target="_blank" rel="noopener">https://www.runoob.com/cssref/pr-margin.html</a></p>
<h4 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h4><p><a href="https://www.runoob.com/cssref/css3-pr-flex-direction.html" target="_blank" rel="noopener">https://www.runoob.com/cssref/css3-pr-flex-direction.html</a></p>
<p>没用mixin之前，我们可以这样设置</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">80%</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line"></span><br><span class="line">  #&#123;&amp;&#125;_paragraph &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: weight(bold);</span><br><span class="line"></span><br><span class="line">    &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: pink;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/06/15/CssandSass/5.png" style="zoom:80%;"></p>
<p>但是我们不想重复敲打 display，justify-content 之类的,所以我们使用mixin改造</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">@mixin</span> flexCenter(<span class="variable">$direction</span>) &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">flex-direction</span>: <span class="variable">$direction</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line"> <span class="keyword">@include</span> flexCenter(column);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/06/15/CssandSass/6.png" style="zoom:80%;"></p>
<p>现在他们在同一列中了</p>
<p>如果传入的参数是row，<img src="/2020/06/15/CssandSass/7.png" style="zoom:80%;"></p>
<h3 id="Mixin-Example-2"><a href="#Mixin-Example-2" class="headerlink" title="Mixin Example 2"></a>Mixin Example 2</h3><p>首先在html中把body改成 <code>&lt; body class=&quot;light&quot; &gt;</code></p>
<p>我们可以 像下面这样传入参数，也可以  <code>@include theme();</code></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认传参为true</span></span><br><span class="line"><span class="keyword">@mixin</span> theme(<span class="variable">$light-theme</span>: true) &#123;</span><br><span class="line">  <span class="keyword">@if</span> <span class="variable">$light-theme</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: lighten(<span class="variable">$primary-color</span>, <span class="number">100%</span>);</span><br><span class="line">    <span class="attribute">color</span>: darken(<span class="variable">$text-color</span>, <span class="number">100%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.light</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> theme(<span class="variable">$light-theme</span>: true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在变成了白底黑字了</p>
<p><img src="/2020/06/15/CssandSass/8.png" style="zoom:80%;"></p>
<h3 id="Mixin-Example-3"><a href="#Mixin-Example-3" class="headerlink" title="Mixin Example 3"></a>Mixin Example 3</h3><p>当我们的screen 小于800px的时候，文字就会从</p>
<p><img src="/2020/06/15/CssandSass/9.png" style="zoom: 67%;"></p>
<p>变成这样</p>
<p><img src="/2020/06/15/CssandSass/10.png" style="zoom: 80%;"></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$moblie</span>: <span class="number">800px</span>;</span><br><span class="line"><span class="keyword">@mixin</span> mobile &#123;</span><br><span class="line">  <span class="keyword">@media</span> screen <span class="keyword">and</span> (max-width: <span class="variable">$moblie</span>) &#123;</span><br><span class="line">    <span class="keyword">@content</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  <span class="keyword">@include</span> mobile() &#123;</span><br><span class="line">    <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Extend"><a href="#Extend" class="headerlink" title="Extend"></a>Extend</h3><p>混合器只是<code>sass</code>样式重用特性中的一个。我们已经了解到混合器主要用于样式展示层的重用，如果你想重用语义化的类呢？这就涉及<code>sass</code>的另一个重要的重用特性:选择器继承。</p>
<h4 id="何时使用继承"><a href="#何时使用继承" class="headerlink" title="何时使用继承"></a>何时使用继承</h4><p>之前介绍了<a href="http://www.sass.hk/sass-course.html" target="_blank" rel="noopener">混合器</a>主要用于展示性样式的重用，而类名用于语义化样式的重用。因为继承是基于类的(有时是基于其他类型的选择器)，所以继承应该是建立在语义化的关系上。当一个元素拥有的类(比如说<code>.seriousError</code>)表明它属于另一个类(比如说<code>.error</code>)，这时使用继承再合适不过了。</p>
<p>这有点抽象，所以我们从几个方面来阐释一下。想象一下你正在编写一个页面，给<code>html</code>元素添加类名，你发现你的某个类(比如说<code>.seriousError</code>)另一个类(比如说<code>.error</code>)的细化。你会怎么做？</p>
<ul>
<li>你可以为这两个类分别写相同的样式，但是如果有大量的重复怎么办？使用<code>sass</code>时，我们提倡的就是不要做重复的工作。</li>
<li>你可以使用一个选择器组(比如说<code>.error</code> <code>.seriousError</code>给这两个选择器写相同的样式。如果.error的所有样式都在同一个地方，这种做法很好，但是如果是分散在样式表的不同地方呢？再这样做就困难多了。</li>
<li>你可以使用一个混合器为这两个类提供相同的样式，但当<code>.error</code>的样式修饰遍布样式表中各处时，这种做法面临着跟使用选择器组一样的问题。这两个类也不是恰好有相同的样式。你应该更清晰地表达这种关系。</li>
<li><strong>综上所述你应该使用</strong><code>@extend</code>。让<code>.seriousError</code>从<code>.error</code>继承样式，使两者之间的关系非常清晰。更重要的是无论你在样式表的哪里使用<code>.error``.seriousError</code>都会继承其中的样式。</li>
</ul>
<p>现在你已经更好地掌握了何时使用继承，以及继承有哪些突出的优点，接下来我们看看一些高级用法。</p>
<h4 id="继承的高级用法"><a href="#继承的高级用法" class="headerlink" title="继承的高级用法"></a>继承的高级用法</h4><p>任何<code>css</code>规则都可以继承其他规则，几乎任何<code>css</code>规则也都可以被继承。大多数情况你可能只想对类使用继承，但是有些场合你可能想做得更多。最常用的一种高级用法是继承一个<code>html</code>元素的样式。尽管默认的浏览器样式不会被继承，因为它们不属于样式表中的样式，但是你对<code>html</code>元素添加的所有样式都会被继承。</p>
<p>接下来的这段代码定义了一个名为<code>disabled</code>的类，样式修饰使它看上去像一个灰掉的超链接。通过继承a这一超链接元素来实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.disabled &#123;</span><br><span class="line">  color: gray;</span><br><span class="line">  @extend a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假如一条样式规则继承了一个复杂的选择器，那么它只会继承这个复杂选择器命中的元素所应用的样式。举例来说， 如果<code>.seriousError@extend.important.error</code> ， 那么<code>.important.error</code> 和<code>h1.important.error</code> 的样式都会被<code>.seriousError</code>继承， 但是<code>.important</code>或者<code>.error</code>下的样式则不会被继承。这种情况下你很可能希望<code>.seriousError</code>能够分别继承<code>.important</code>或者<code>.error</code>下的样式。</p>
<p>如果一个选择器序列(<code>#main .seriousError</code>)<code>@extend</code>另一个选择器(<code>.error</code>)，那么只有完全命中<code>#main .seriousError</code>这个选择器的元素才会继承<code>.error</code>的样式，就像单个类名继承那样。拥有<code>class=&quot;seriousError&quot;</code>的<code>.main</code>元素之外的元素不会受到影响。</p>
<p>像<code>#main .error</code>这种选择器序列是不能被继承的。这是因为从<code>#main .error</code>中继承的样式一般情况下会跟直接从<code>.error</code>中继承的样式基本一致，细微的区别往往使人迷惑。</p>
<p>现在你已经了解了通过继承能够做些什么事情，接下来我们将学习继承的工作细节，在生成对应<code>css</code>的时候，<code>sass</code>具体干了些什么事情。</p>
<h4 id="继承的工作细节"><a href="#继承的工作细节" class="headerlink" title="继承的工作细节"></a>继承的工作细节</h4><p>跟变量和混合器不同，继承不是仅仅用<code>css</code>样式替换@extend处的代码那么简单。为了不让你对生成的<code>css</code>感觉奇怪，对这背后的工作原理有一定了解是非常重要的。</p>
<p><code>@extend</code>背后最基本的想法是，如果<code>.seriousError @extend .error</code>， 那么样式表中的任何一处<code>.error</code>都用<code>.error</code> <code>.seriousError</code>这一选择器组进行替换。这就意味着相关样式会如预期那样应用到<code>.error</code>和<code>.seriousError</code>。当<code>.error</code>出现在复杂的选择器中，比如说<code>h1.error``.error a</code>或者<code>#main .sidebar input.error[type=&quot;text&quot;]</code>，那情况就变得复杂多了，但是不用担心，<code>sass</code>已经为你考虑到了这些。</p>
<p>关于<code>@extend</code>有两个要点你应该知道。</p>
<ul>
<li>跟混合器相比，继承生成的<code>css</code>代码相对更少。因为继承仅仅是重复选择器，而不会重复属性，所以使用继承往往比混合器生成的<code>css</code>体积更小。如果你非常关心你站点的速度，请牢记这一点。</li>
<li>继承遵从<code>css</code>层叠的规则。当两个不同的<code>css</code>规则应用到同一个<code>html</code>元素上时，并且这两个不同的<code>css</code>规则对同一属性的修饰存在不同的值，<code>css</code>层叠规则会决定应用哪个样式。相当直观:通常权重更高的选择器胜出，如果权重相同，定义在后边的规则胜出。</li>
</ul>
<p>混合器本身不会引起<code>css</code>层叠的问题，因为混合器把样式直接放到了<code>css</code>规则中，而继承存在样式层叠的问题。被继承的样式会保持原有定义位置和选择器权重不变。通常来说这并不会引起什么问题，但是知道这点总没有坏处。</p>
<h4 id="使用继承的最佳实践"><a href="#使用继承的最佳实践" class="headerlink" title="使用继承的最佳实践"></a>使用继承的最佳实践</h4><p>通常使用继承会让你的<code>css</code>美观、整洁。因为继承只会在生成<code>css</code>时复制选择器，而不会复制大段的<code>css</code>属性。但是如果你不小心，可能会让生成的<code>css</code>中包含大量的选择器复制。</p>
<p>避免这种情况出现的最好方法就是不要在<code>css</code>规则中使用后代选择器(比如<code>.foo .bar</code>)去继承<code>css</code>规则。如果你这么做，同时被继承的<code>css</code>规则有通过后代选择器修饰的样式，生成<code>css</code>中的选择器的数量很快就会失控:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.foo .bar &#123; @extend .baz; &#125;</span><br><span class="line">.bip .baz &#123; a: b; &#125;</span><br></pre></td></tr></table></figure>
<p>在上边的例子中，<code>sass</code>必须保证应用到.baz的样式同时也要应用到<code>.foo .bar</code>(位于class=”foo”的元素内的class=”bar”的元素)。例子中有一条应用到<code>.bip .baz</code>(位于class=”bip”的元素内的class=”baz”的元素)的<code>css</code>规则。当这条规则应用到<code>.foo .bar</code>时，可能存在三种情况，如下代码:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 继承可能迅速变复杂 --&gt;</span><br><span class="line">&lt;!-- Case 1 --&gt;</span><br><span class="line">&lt;div class="foo"&gt;</span><br><span class="line">  &lt;div class="bip"&gt;</span><br><span class="line">    &lt;div class="bar"&gt;...&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!-- Case 2 --&gt;</span><br><span class="line">&lt;div class="bip"&gt;</span><br><span class="line">  &lt;div class="foo"&gt;</span><br><span class="line">    &lt;div class="bar"&gt;...&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!-- Case 3 --&gt;</span><br><span class="line">&lt;div class="foo bip"&gt;</span><br><span class="line">  &lt;div class="bar"&gt;...&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>为了应付这些情况，<code>sass</code>必须生成三种选择器组合(仅仅是.bip .foo .bar不能覆盖所有情况)。如果任何一条规则里边的后代选择器再长一点，<code>sass</code>需要考虑的情况就会更多。实际上<code>sass</code>并不总是会生成所有可能的选择器组合，即使是这样，选择器的个数依然可能会变得相当大，所以如果允许，尽可能避免这种用法。</p>
<p>值得一提的是，只要你想，你<strong>完全可以放心地继承有后代选择器修饰规则的选择器</strong>，不管后代选择器多长，但有一个前提就是，<strong>不要用后代选择器去继承</strong>。</p>
<h4 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h4><p>index.html</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--//...--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"main_paragraph1"</span>&gt;</span></span><br><span class="line">        Lorem, ipsum dolor sit amet consectetur adipisicing elit. Possimus</span><br><span class="line">        inventore sit earum, cum ipsa magni, perspiciatis eos aliquam id eius</span><br><span class="line">        sed, totam esse? Optio in adipisci earum numquam magnam fugit?</span><br><span class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"main_paragraph2"</span>&gt;</span></span><br><span class="line">        Lorem, ipsum dolor sit amet consectetur adipisicing elit. Possimus</span><br><span class="line">        inventore sit earum, cum ipsa magni, perspiciatis eos aliquam id eius</span><br><span class="line">        sed, totam esse? Optio in adipisci earum numquam magnam fugit?</span><br><span class="line">      <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--//...--&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  #&#123;&amp;&#125;_paragraph1 &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: weight(bold);</span><br><span class="line"></span><br><span class="line">    &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: pink;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//我们还可以把继承下来的数据进行重新赋值</span></span><br><span class="line">  #&#123;&amp;&#125;_paragraph2 &#123;</span><br><span class="line">    <span class="keyword">@extend</span> .main_paragraph1;</span><br><span class="line">    &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: <span class="variable">$accent-color</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Math-Operations"><a href="#Math-Operations" class="headerlink" title="Math Operations"></a>Math Operations</h3><p>在原生css中，我们要计算必须这样  <code>cal(80%-40%)</code> 但在scss中可以直接这么写。但要保持单位相同！</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> flexCenter(row);</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">80%</span>-<span class="number">40%</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/23/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><span class="page-number current">24</span><a class="page-number" href="/page/25/">25</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/25/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Jason</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">439</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    

  

</body>
</html>
